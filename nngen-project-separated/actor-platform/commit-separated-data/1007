BLEU SCORE: 0.23462350320528

TEST MSG: fix ( core ) : Fixing decryption mismatched decryption source array
GENERATED MSG: feat ( core ) : Enable Java 8 .

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - api / actor . json b / actor - sdk / sdk - api / actor . json < nl > index c1ef127 . . ed15f18 100644 < nl > - - - a / actor - sdk / sdk - api / actor . json < nl > + + + b / actor - sdk / sdk - api / actor . json < nl > @ @ - 12415 , 13 + 12415 , 13 @ @ < nl > { < nl > " type " : " reference " , < nl > " argument " : " keys " , < nl > - " category " : " compact " , < nl > + " category " : " full " , < nl > " description " : " keys of Key Group " < nl > } , < nl > { < nl > " type " : " reference " , < nl > " argument " : " signatures " , < nl > - " category " : " compact " , < nl > + " category " : " full " , < nl > " description " : " Signatures of keys " < nl > } < nl > ] , < nl > diff - - git a / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps b / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps < nl > index 5cfa7fa . . 04b7d33 100644 < nl > - - - a / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps < nl > + + + b / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps < nl > @ @ - 10750 , 11 + 10750 , 11 @ @ < nl > < / node > < nl > < node concept = " NX1gA " id = " 5 _ CDdZ2qgM2 " role = " NXodf " > < nl > < property role = " NX6R2 " value = " keys of Key Group " / > < nl > - < property role = " 1GSvIU " value = " compact " / > < nl > + < property role = " 1GSvIU " value = " full " / > < nl > < ref role = " NX6Kv " node = " 5 _ CDdZ2jJbB " resolve = " keys " / > < nl > < / node > < nl > < node concept = " NX1gA " id = " 5 _ CDdZ2qzHm " role = " NXodf " > < nl > - < property role = " 1GSvIU " value = " compact " / > < nl > + < property role = " 1GSvIU " value = " full " / > < nl > < property role = " NX6R2 " value = " Signatures of keys " / > < nl > < ref role = " NX6Kv " node = " 5 _ CDdZ2qzGT " resolve = " signatures " / > < nl > < / node > < nl > diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist < nl > index f1c2a0e . . 775a777 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > @ @ - 34 , 7 + 34 , 7 @ @ < nl > 	 	 < / dict > < nl > 	 < / array > < nl > 	 < key > CFBundleVersion < / key > < nl > - 	 < string > 715 < / string > < nl > + 	 < string > 734 < / string > < nl > 	 < key > Fabric < / key > < nl > 	 < dict > < nl > 	 	 < key > APIKey < / key > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java < nl > index 68e5367 . . 472a16c 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java < nl > @ @ - 103 , 8 + 103 , 8 @ @ public class ApiEncryptionKeyGroup extends BserObject { < nl > res + = " keyGroupId = " + this . keyGroupId ; < nl > res + = " , supportedEncryption = " + this . supportedEncryption ; < nl > res + = " , identityKey = " + this . identityKey ; < nl > - res + = " , keys = " + this . keys . size ( ) ; < nl > - res + = " , signatures = " + this . signatures . size ( ) ; < nl > + res + = " , keys = " + this . keys ; < nl > + res + = " , signatures = " + this . signatures ; < nl > res + = " } " ; < nl > return res ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > index f99143d . . f4cd037 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > @ @ - 46 , 6 + 46 , 7 @ @ public class EncryptedMsgActor extends ModuleActor { < nl > @ Override < nl > public void onError ( Exception e ) { < nl > Log . d ( TAG , " doEncrypt : onError " ) ; < nl > + e . printStackTrace ( ) ; < nl > future . error ( e ) ; < nl > } < nl > } ) ; < nl > @ @ - 74 , 6 + 75 , 7 @ @ public class EncryptedMsgActor extends ModuleActor { < nl > @ Override < nl > public void onError ( Exception e ) { < nl > Log . d ( TAG , " onDecrypt : onError " ) ; < nl > + e . printStackTrace ( ) ; < nl > } < nl > } ) ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 6ed6e0d . . 90ad254 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 181 , 9 + 181 , 9 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > } ) < nl > . first ( ) < nl > - . mapPromise ( new Function < EncryptedBoxKey , Promise < SessionActor > > ( ) { < nl > + . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { < nl > @ Override < nl > - public Promise < SessionActor > apply ( EncryptedBoxKey boxKey ) { < nl > + public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { < nl > final long senderEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; < nl > final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; < nl > < nl > @ @ - 191 , 25 + 191 , 25 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { < nl > if ( s . getOwnKeyId ( ) = = receiverEphermalKey0Id & & < nl > s . getTheirKeyId ( ) = = senderEphermalKey0Id ) { < nl > - return success ( s ) ; < nl > + return success ( new Tuple2 < > ( s , boxKey ) ) ; < nl > } < nl > } < nl > } < nl > return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) < nl > . pickSession ( uid , senderKeyGroup , receiverEphermalKey0Id , senderEphermalKey0Id ) < nl > - . map ( new Function < PeerSession , SessionActor > ( ) { < nl > + . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { < nl > @ Override < nl > - public SessionActor apply ( PeerSession src ) { < nl > - return spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , < nl > - src . getOwnPreKeyId ( ) ) ; < nl > + public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { < nl > + return new Tuple2 < > ( spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , < nl > + src . getOwnPreKeyId ( ) ) , boxKey ) ; < nl > } < nl > } ) ; < nl > } < nl > } ) < nl > - . mapPromise ( new Function < SessionActor , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { < nl > + . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { < nl > @ Override < nl > - public Promise < EncryptedSessionActor . DecryptedPackage > apply ( SessionActor src ) { < nl > - return ask ( src . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( data . getEncryptedPackage ( ) ) ) ; < nl > + public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { < nl > + return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; < nl > } < nl > } ) < nl > . map ( new Function < EncryptedSessionActor . DecryptedPackage , byte [ ] > ( ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 1077d2a . . 952c3cc 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 210 , 12 + 210 , 15 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > / / Stage 4 : Saving their ephemeral key < nl > / / < nl > < nl > + Log . d ( TAG , " Decrypt " + Crypto . hex ( data ) ) ; < nl > + < nl > / / final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > / / final long ownEphemeralKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > / / final long theirEphemeralKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > - Log . d ( TAG , " Receiver Ephemeral " + Crypto . keyHash ( receiverEphemeralKey ) ) ; < nl > + Log . d ( TAG , " Sender Ephemeral " + Crypto . hex ( senderEphemeralKey ) ) ; < nl > + Log . d ( TAG , " Receiver Ephemeral " + Crypto . hex ( receiverEphemeralKey ) ) ; < nl > < nl > pickDecryptChain ( senderEphemeralKey , receiverEphemeralKey ) < nl > . map ( new Function < EncryptedSessionChain , DecryptedPackage > ( ) { < nl > @ @ - 251 , 6 + 254 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > private EncryptedPackageRes encrypt ( EncryptedSessionChain chain , byte [ ] data ) { < nl > + < nl > byte [ ] encrypted ; < nl > try { < nl > encrypted = chain . encrypt ( data ) ; < nl > @ @ - 258 , 6 + 262 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > e . printStackTrace ( ) ; < nl > throw new RuntimeException ( e ) ; < nl > } < nl > + Log . d ( TAG , " Encrypt " + Crypto . hex ( encrypted ) ) ; < nl > return new EncryptedPackageRes ( encrypted , theirKeyGroup ) ; < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index e0f99e8 . . 17eb2c3 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 219 , 7 + 219 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void onAllKeysReady ( ) { < nl > - Log . d ( TAG , " Key Manager started " ) ; < nl > + Log . d ( TAG , " Key Manager started with key group # " + ownKeys . getKeyGroupId ( ) ) ; < nl > / / Now we can start receiving or sending encrypted messages < nl > isReady = true ; < nl > unstashAll ( ) ; < nl > @ @ - 243 , 9 + 243 , 9 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > } < nl > < nl > - Log . d ( TAG , " No key found : " + Crypto . keyHash ( publicKey ) ) ; < nl > + Log . d ( TAG , " No key found : " + Crypto . hex ( publicKey ) ) ; < nl > for ( PrivateKey k : ownKeys . getPreKeys ( ) ) { < nl > - Log . d ( TAG , " Have : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( k . getKey ( ) ) ) ) ; < nl > + Log . d ( TAG , " Have : " + Crypto . hex ( Curve25519 . keyGenPublic ( k . getKey ( ) ) ) ) ; < nl > } < nl > < nl > future . error ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; < nl > @ @ - 312 , 7 + 312 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > final UserKeys keys = getCachedUserKeys ( uid ) ; < nl > UserKeysGroup keysGroup = null ; < nl > for ( UserKeysGroup g : keys . getUserKeysGroups ( ) ) { < nl > - Log . d ( TAG , " KeyGroup ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; < nl > + / / Log . d ( TAG , " KeyGroup ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; < nl > if ( g . getKeyGroupId ( ) = = keyGroupId ) { < nl > keysGroup = g ; < nl > } < nl > @ @ - 356 , 7 + 356 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) < nl > . addUserKeyGroup ( userKeysGroup ) ) ; < nl > < nl > - Log . d ( TAG , " ( uid : " + uid + " ) Fetched PreKey " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; < nl > + / / Log . d ( TAG , " ( uid : " + uid + " ) Fetched PreKey " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; < nl > future . result ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; < nl > } < nl > < nl > @ @ - 385 , 7 + 385 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > PublicKey pkey = new PublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; < nl > / / Do not store all ephemeral key as it is not required < nl > < nl > - Log . d ( TAG , " ( uid : " + uid + " ) Fetched ephemeral " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; < nl > + / / Log . d ( TAG , " ( uid : " + uid + " ) Fetched ephemeral " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; < nl > future . result ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; < nl > } < nl > < nl > @ @ - 484 , 10 + 484 , 6 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( cached ! = null ) { < nl > try { < nl > userKeys = new UserKeys ( cached ) ; < nl > - Log . d ( TAG , " Loaded ( uid : " + uid + " ) : " + Crypto . hex ( cached ) ) ; < nl > - for ( UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { < nl > - Log . d ( TAG , " Loaded ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; < nl > - } < nl > } catch ( IOException e ) { < nl > e . printStackTrace ( ) ; < nl > } < nl > @ @ - 497 , 18 + 493 , 6 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void cacheUserKeys ( UserKeys userKeys ) { < nl > - for ( UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { < nl > - Log . d ( TAG , " Cache ( uid : " + userKeys . getUid ( ) + " ) : " + g . getKeyGroupId ( ) ) ; < nl > - } < nl > - try { < nl > - UserKeys upd = new UserKeys ( userKeys . toByteArray ( ) ) ; < nl > - Log . d ( TAG , " Cache2 ( uid : " + userKeys . getUid ( ) + " ) : " + Crypto . hex ( userKeys . toByteArray ( ) ) ) ; < nl > - for ( UserKeysGroup g : upd . getUserKeysGroups ( ) ) { < nl > - Log . d ( TAG , " Cache2 ( uid : " + userKeys . getUid ( ) + " ) : " + g . getKeyGroupId ( ) ) ; < nl > - } < nl > - } catch ( IOException e ) { < nl > - e . printStackTrace ( ) ; < nl > - } < nl > encryptionKeysStorage . addOrUpdateItem ( userKeys . getUid ( ) , userKeys . toByteArray ( ) ) ; < nl > cachedUserKeys . put ( userKeys . getUid ( ) , userKeys ) ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > index 098a2ac . . 6f38004 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java < nl > @ @ - 108 , 8 + 108 , 8 @ @ public class EncryptedSessionChain { < nl > theirPublicKey , < nl > ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / < nl > < nl > - Log . d ( " EncryptedSessionChain " , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; < nl > - Log . d ( " EncryptedSessionChain " , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; < nl > + Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; < nl > + Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; < nl > < nl > return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; < nl > }
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > index a6a37f9 . . 11474a8 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile < nl > @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } < nl > J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive < nl > J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc < nl > J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc < nl > - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods < nl > + J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 < nl > J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include < nl > < nl > LIBRARY _ NAME = libactor . so < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / build . gradle b / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > index e7791f8 . . c994383 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > + + + b / actor - sdk / sdk - core / core / core - shared / build . gradle < nl > @ @ - 1 , 7 + 1 , 7 @ @ < nl > apply plugin : ' java ' < nl > < nl > compileJava { < nl > - sourceCompatibility = 1 . 6 < nl > + sourceCompatibility = 1 . 8 < nl > targetCompatibility = 1 . 6 < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 6ab8482 . . ca8c14b 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 71 , 109 + 71 , 80 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > sequence ( < nl > ask ( keyManager , new FetchOwnKeyGroup ( ) ) . cast ( ) , < nl > ask ( keyManager , new FetchUserKeyGroups ( uid ) ) . cast ( ) < nl > - ) . then ( new Supplier < Object [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( Object [ ] objects ) { < nl > - ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; < nl > - theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; < nl > - isReady = true ; < nl > - unstashAll ( ) ; < nl > - } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . w ( TAG , " Unable to fetch initial parameters " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + ) . then ( objects - > { < nl > + ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; < nl > + theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; < nl > + isReady = true ; < nl > + unstashAll ( ) ; < nl > + } ) . failure ( e - > { < nl > + Log . w ( TAG , " Unable to fetch initial parameters " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - sequence ( map ( theirKeys . getUserKeysGroups ( ) , new Map < UserKeysGroup , Promise < ActorRef > > ( ) { < nl > - @ Override < nl > - public Promise < ActorRef > map ( final UserKeysGroup src ) { < nl > - Log . d ( TAG , " doEncrypt : map " ) ; < nl > - for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > - return success ( activeSessions . get ( sessionId ) ) ; < nl > - } < nl > + sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { < nl > + Log . d ( TAG , " doEncrypt : map " ) ; < nl > + for ( SessionId sessionId : activeSessions . keySet ( ) ) { < nl > + if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { < nl > + return success ( activeSessions . get ( sessionId ) ) ; < nl > } < nl > - < nl > - Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > - < nl > - return zip ( sequence ( < nl > - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > - ) , new ArrayFunction < Object , ActorRef > ( ) { < nl > - @ Override < nl > - public ActorRef apply ( Object [ ] t ) { < nl > - < nl > - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > - < nl > - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > - < nl > - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { < nl > - @ Override < nl > - public EncryptedSessionActor create ( ) { < nl > - return new EncryptedSessionActor ( context ( ) , uid , < nl > - ownEphemeral , theirEphemeral . getKeyId ( ) , src . getKeyGroupId ( ) ) ; < nl > - } < nl > - } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > - activeSessions . put ( sessionId , res ) ; < nl > - return res ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) ; < nl > } < nl > - } ) ) . then ( new Supplier < ActorRef [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( ActorRef [ ] actorRefs ) { < nl > < nl > - Log . d ( TAG , " doEncrypt : enc " ) ; < nl > + Log . d ( TAG , " doEncrypt : not _ found " ) ; < nl > + final UserKeysGroup srcFinal = src ; < nl > + return zip ( sequence ( < nl > + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , < nl > + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) < nl > + ) , t - > { < nl > + < nl > + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; < nl > + < nl > + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; < nl > + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; < nl > + < nl > + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , < nl > + src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; < nl > + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , < nl > + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; < nl > + activeSessions . put ( sessionId , res ) ; < nl > + return res ; < nl > + } ) ; < nl > + } ) ) . then ( actorRefs - > { < nl > + < nl > + Log . d ( TAG , " doEncrypt : enc " ) ; < nl > + < nl > + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + < nl > + sequence ( Promises . map ( actorRefs , src - > { < nl > + return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > + } ) ) . then ( encryptedPackageRes - > { < nl > + ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; < nl > + for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > + encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > + } < nl > < nl > - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; < nl > + byte [ ] encData ; < nl > + try { < nl > + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > + } catch ( IntegrityException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . error ( e ) ; < nl > + return ; < nl > + } < nl > < nl > - sequence ( Promises . map ( actorRefs , new Map < ActorRef , Promise < EncryptedPackageRes > > ( ) { < nl > - @ Override < nl > - public Promise < EncryptedPackageRes > map ( ActorRef src ) { < nl > - return ask ( src , new EncryptPackage ( encKey ) ) ; < nl > - } < nl > - } ) ) . then ( new Supplier < EncryptedPackageRes [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( EncryptedPackageRes [ ] encryptedPackageRes ) { < nl > - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; < nl > - for ( EncryptedPackageRes r : encryptedPackageRes ) { < nl > - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; < nl > - } < nl > - < nl > - byte [ ] encData ; < nl > - try { < nl > - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; < nl > - } catch ( IntegrityException e ) { < nl > - e . printStackTrace ( ) ; < nl > - future . error ( e ) ; < nl > - return ; < nl > - } < nl > - < nl > - EncryptedBox encryptedBox = new EncryptedBox ( < nl > - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > - < nl > - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > - } < nl > - } ) . failure ( new Supplier < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - future . error ( e ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > - } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + EncryptedBox encryptedBox = new EncryptedBox ( < nl > + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , < nl > + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; < nl > + < nl > + future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; < nl > + } ) . failure ( e - > { < nl > + Log . d ( TAG , " Unable to encrypt all receivers " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + future . error ( e ) ; < nl > + } ) . done ( self ( ) ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 6cea4f7 . . f5481e2 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 92 , 7 + 92 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; < nl > } < nl > - } ) . dispatch ( self ( ) ) . then ( new Supplier < EncryptedSession > ( ) { < nl > + } ) . then ( new Supplier < EncryptedSession > ( ) { < nl > @ Override < nl > public void apply ( EncryptedSession encryptedSession ) { < nl > EncryptedSessionActor . this . session = encryptedSession ; < nl > @ @ - 104 , 7 + 104 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . w ( TAG , " Session load error " ) ; < nl > Log . e ( TAG , e ) ; < nl > } < nl > - } ) . dispatch ( self ( ) ) . done ( ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > < nl > private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > index ee0cc28 . . 723ae25 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java < nl > @ @ - 198 , 7 + 198 , 7 @ @ public class ModuleActor extends AskcableActor implements BusSubscriber { < nl > } < nl > } ) ; < nl > } < nl > - } . dispatch ( self ( ) ) ; < nl > + } . done ( self ( ) ) ; < nl > } < nl > < nl > public void cancelRequest ( long rid ) { < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > index 6ad3121 . . 063d466 100755 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java < nl > @ @ - 221 , 7 + 221 , 7 @ @ public class Actor { < nl > protected void exec ( @ NotNull PromiseResolver < T > executor ) { < nl > dest . send ( new AskIntRequest ( msg , executor ) ) ; < nl > } < nl > - } . dispatch ( self ( ) ) ; < nl > + } ; < nl > } < nl > < nl > public void ask ( ActorRef dest , Object message ) { < nl > @ @ - 295 , 6 + 295 , 6 @ @ public class Actor { < nl > public void apply ( Exception e ) { < nl > self ( ) . send ( new AskIntError ( id , e ) ) ; < nl > } < nl > - } ) . done ( ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > index 2f5e64c . . f16e918 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java < nl > @ @ - 2 , 4 + 2 , 8 @ @ package im . actor . runtime . function ; < nl > < nl > public interface Function < T , R > { < nl > R apply ( T t ) ; < nl > + < nl > + default R apply2 ( T t ) { < nl > + return apply ( t ) ; < nl > + } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > index 89e8a6f . . 7a376aa 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > @ @ - 5 , 6 + 5 , 7 @ @ import org . jetbrains . annotations . Nullable ; < nl > < nl > import java . util . ArrayList ; < nl > < nl > + import im . actor . runtime . actors . Actor ; < nl > import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . function . Supplier ; < nl > < nl > @ @ - 18 , 7 + 19 , 7 @ @ public abstract class Promise < T > { < nl > < nl > private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; < nl > < nl > - private PromiseDispatcher dispatcher = PromiseDispatcher . DEFAULT ; < nl > + private ActorRef dispatchActor ; < nl > private volatile T result ; < nl > private volatile Exception exception ; < nl > private volatile boolean isFinished ; < nl > @ @ - 40 , 7 + 41 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > then ( final Supplier < T > then ) { < nl > if ( isFinished ) { < nl > if ( exception = = null ) { < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > then . apply ( result ) ; < nl > @ @ - 72 , 7 + 73 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { < nl > if ( isFinished ) { < nl > if ( exception ! = null ) { < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > failure . apply ( exception ) ; < nl > @ @ - 104 , 7 + 105 , 7 @ @ public abstract class Promise < T > { < nl > public synchronized Promise < T > complete ( final PromiseCallback < T > callback ) { < nl > if ( isFinished ) { < nl > < nl > - dispatcher . dispatch ( new Runnable ( ) { < nl > + dispatchActor . send ( new Runnable ( ) { < nl > @ Override < nl > public void run ( ) { < nl > if ( exception ! = null ) { < nl > @ @ - 120 , 25 + 121 , 26 @ @ public abstract class Promise < T > { < nl > return this ; < nl > } < nl > < nl > - / * * < nl > - * Binding result dispatching to actor < nl > - * < nl > - * @ param ref dest actor < nl > - * @ return this < nl > - * / < nl > - public Promise < T > dispatch ( ActorRef ref ) { < nl > - dispatcher = PromiseDispatcher . forActor ( ref ) ; < nl > - return this ; < nl > - } < nl > + / / / * * < nl > + / / * Binding result dispatching to actor < nl > + / / * < nl > + / / * @ param ref dest actor < nl > + / / * @ return this < nl > + / / * / < nl > + / / public Promise < T > dispatch ( ActorRef ref ) { < nl > + / / dispatcher = PromiseDispatcher . forActor ( ref ) ; < nl > + / / return this ; < nl > + / / } < nl > < nl > / * * < nl > * Call this method to start promise execution < nl > * / < nl > - public Promise < T > done ( ) { < nl > + public Promise < T > done ( ActorRef ref ) { < nl > if ( isStarted ) { < nl > throw new RuntimeException ( " Promise already started " ) ; < nl > } < nl > isStarted = true ; < nl > + dispatchActor = ref ; < nl > exec ( new PromiseResolver < T > ( this ) ) ; < nl > return this ; < nl > } < nl > @ @ - 147 , 18 + 149 , 22 @ @ public abstract class Promise < T > { < nl > return ( Promise < R > ) this ; < nl > } < nl > < nl > - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { < nl > + public ActorRef getDispatchActor ( ) { < nl > + return dispatchActor ; < nl > + } < nl > + < nl > + / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { < nl > / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; < nl > / / } < nl > < nl > - / * * < nl > - * Getting current dispatcher for promise < nl > - * < nl > - * @ return current dispatcher < nl > - * / < nl > - public PromiseDispatcher getDispatcher ( ) { < nl > - return dispatcher ; < nl > - } < nl > + / / / * * < nl > + / / * Getting current dispatcher for promise < nl > + / / * < nl > + / / * @ return current dispatcher < nl > + / / * / < nl > + / / public PromiseDispatcher getDispatcher ( ) { < nl > + / / return dispatcher ; < nl > + / / } < nl > < nl > public boolean isFinished ( ) { < nl > return isFinished ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > index 4614511 . . b071798 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > @ @ - 52 , 7 + 52 , 7 @ @ public class Promises { < nl > executor . error ( e ) ; < nl > } < nl > } ) ; < nl > - promises . done ( ) ; < nl > + promises . done ( promises . getDispatchActor ( ) ) ; < nl > } < nl > } ; < nl > } < nl > @ @ - 106 , 7 + 106 , 7 @ @ public class Promises { < nl > } ) ; < nl > } < nl > for ( Promise < T > p : promises ) { < nl > - p . done ( ) ; < nl > + p . done ( self . getDispatchActor ( ) ) ; < nl > } < nl > } < nl > } ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - api / actor . json b / actor - sdk / sdk - api / actor . json 
 index c1ef127 . . ed15f18 100644 
 - - - a / actor - sdk / sdk - api / actor . json 
 + + + b / actor - sdk / sdk - api / actor . json 
 @ @ - 12415 , 13 + 12415 , 13 @ @ 
 { 
 " type " : " reference " , 
 " argument " : " keys " , 
 - " category " : " compact " , 
 + " category " : " full " , 
 " description " : " keys of Key Group " 
 } , 
 { 
 " type " : " reference " , 
 " argument " : " signatures " , 
 - " category " : " compact " , 
 + " category " : " full " , 
 " description " : " Signatures of keys " 
 } 
 ] , 
 diff - - git a / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps b / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps 
 index 5cfa7fa . . 04b7d33 100644 
 - - - a / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps 
 + + + b / actor - sdk / sdk - api / api - language / solutions / im . actor . api / models / im / actor / api / scheme . mps 
 @ @ - 10750 , 11 + 10750 , 11 @ @ 
 < / node > 
 < node concept = " NX1gA " id = " 5 _ CDdZ2qgM2 " role = " NXodf " > 
 < property role = " NX6R2 " value = " keys of Key Group " / > 
 - < property role = " 1GSvIU " value = " compact " / > 
 + < property role = " 1GSvIU " value = " full " / > 
 < ref role = " NX6Kv " node = " 5 _ CDdZ2jJbB " resolve = " keys " / > 
 < / node > 
 < node concept = " NX1gA " id = " 5 _ CDdZ2qzHm " role = " NXodf " > 
 - < property role = " 1GSvIU " value = " compact " / > 
 + < property role = " 1GSvIU " value = " full " / > 
 < property role = " NX6R2 " value = " Signatures of keys " / > 
 < ref role = " NX6Kv " node = " 5 _ CDdZ2qzGT " resolve = " signatures " / > 
 < / node > 
 diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 
 index f1c2a0e . . 775a777 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 @ @ - 34 , 7 + 34 , 7 @ @ 
 	 	 < / dict > 
 	 < / array > 
 	 < key > CFBundleVersion < / key > 
 - 	 < string > 715 < / string > 
 + 	 < string > 734 < / string > 
 	 < key > Fabric < / key > 
 	 < dict > 
 	 	 < key > APIKey < / key > 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java 
 index 68e5367 . . 472a16c 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / api / ApiEncryptionKeyGroup . java 
 @ @ - 103 , 8 + 103 , 8 @ @ public class ApiEncryptionKeyGroup extends BserObject { 
 res + = " keyGroupId = " + this . keyGroupId ; 
 res + = " , supportedEncryption = " + this . supportedEncryption ; 
 res + = " , identityKey = " + this . identityKey ; 
 - res + = " , keys = " + this . keys . size ( ) ; 
 - res + = " , signatures = " + this . signatures . size ( ) ; 
 + res + = " , keys = " + this . keys ; 
 + res + = " , signatures = " + this . signatures ; 
 res + = " } " ; 
 return res ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 index f99143d . . f4cd037 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 @ @ - 46 , 6 + 46 , 7 @ @ public class EncryptedMsgActor extends ModuleActor { 
 @ Override 
 public void onError ( Exception e ) { 
 Log . d ( TAG , " doEncrypt : onError " ) ; 
 + e . printStackTrace ( ) ; 
 future . error ( e ) ; 
 } 
 } ) ; 
 @ @ - 74 , 6 + 75 , 7 @ @ public class EncryptedMsgActor extends ModuleActor { 
 @ Override 
 public void onError ( Exception e ) { 
 Log . d ( TAG , " onDecrypt : onError " ) ; 
 + e . printStackTrace ( ) ; 
 } 
 } ) ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 6ed6e0d . . 90ad254 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 181 , 9 + 181 , 9 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 } ) 
 . first ( ) 
 - . mapPromise ( new Function < EncryptedBoxKey , Promise < SessionActor > > ( ) { 
 + . mapPromise ( new Function < EncryptedBoxKey , Promise < Tuple2 < SessionActor , EncryptedBoxKey > > > ( ) { 
 @ Override 
 - public Promise < SessionActor > apply ( EncryptedBoxKey boxKey ) { 
 + public Promise < Tuple2 < SessionActor , EncryptedBoxKey > > apply ( final EncryptedBoxKey boxKey ) { 
 final long senderEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 4 ) ; 
 final long receiverEphermalKey0Id = ByteStrings . bytesToLong ( boxKey . getEncryptedKey ( ) , 12 ) ; 
 
 @ @ - 191 , 25 + 191 , 25 @ @ public class EncryptedPeerActor extends ModuleActor { 
 for ( SessionActor s : activeSessions . get ( senderKeyGroup ) . getSessions ( ) ) { 
 if ( s . getOwnKeyId ( ) = = receiverEphermalKey0Id & & 
 s . getTheirKeyId ( ) = = senderEphermalKey0Id ) { 
 - return success ( s ) ; 
 + return success ( new Tuple2 < > ( s , boxKey ) ) ; 
 } 
 } 
 } 
 return context ( ) . getEncryption ( ) . getSessionManagerInt ( ) 
 . pickSession ( uid , senderKeyGroup , receiverEphermalKey0Id , senderEphermalKey0Id ) 
 - . map ( new Function < PeerSession , SessionActor > ( ) { 
 + . map ( new Function < PeerSession , Tuple2 < SessionActor , EncryptedBoxKey > > ( ) { 
 @ Override 
 - public SessionActor apply ( PeerSession src ) { 
 - return spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , 
 - src . getOwnPreKeyId ( ) ) ; 
 + public Tuple2 < SessionActor , EncryptedBoxKey > apply ( PeerSession src ) { 
 + return new Tuple2 < > ( spawnSession ( src . getTheirKeyGroupId ( ) , src . getTheirPreKeyId ( ) , 
 + src . getOwnPreKeyId ( ) ) , boxKey ) ; 
 } 
 } ) ; 
 } 
 } ) 
 - . mapPromise ( new Function < SessionActor , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { 
 + . mapPromise ( new Function < Tuple2 < SessionActor , EncryptedBoxKey > , Promise < EncryptedSessionActor . DecryptedPackage > > ( ) { 
 @ Override 
 - public Promise < EncryptedSessionActor . DecryptedPackage > apply ( SessionActor src ) { 
 - return ask ( src . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( data . getEncryptedPackage ( ) ) ) ; 
 + public Promise < EncryptedSessionActor . DecryptedPackage > apply ( Tuple2 < SessionActor , EncryptedBoxKey > src ) { 
 + return ask ( src . getT1 ( ) . getActorRef ( ) , new EncryptedSessionActor . DecryptPackage ( src . getT2 ( ) . getEncryptedKey ( ) ) ) ; 
 } 
 } ) 
 . map ( new Function < EncryptedSessionActor . DecryptedPackage , byte [ ] > ( ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 1077d2a . . 952c3cc 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 210 , 12 + 210 , 15 @ @ public class EncryptedSessionActor extends ModuleActor { 
 / / Stage 4 : Saving their ephemeral key 
 / / 
 
 + Log . d ( TAG , " Decrypt " + Crypto . hex ( data ) ) ; 
 + 
 / / final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 / / final long ownEphemeralKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 / / final long theirEphemeralKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 final byte [ ] senderEphemeralKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 final byte [ ] receiverEphemeralKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 - Log . d ( TAG , " Receiver Ephemeral " + Crypto . keyHash ( receiverEphemeralKey ) ) ; 
 + Log . d ( TAG , " Sender Ephemeral " + Crypto . hex ( senderEphemeralKey ) ) ; 
 + Log . d ( TAG , " Receiver Ephemeral " + Crypto . hex ( receiverEphemeralKey ) ) ; 
 
 pickDecryptChain ( senderEphemeralKey , receiverEphemeralKey ) 
 . map ( new Function < EncryptedSessionChain , DecryptedPackage > ( ) { 
 @ @ - 251 , 6 + 254 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 private EncryptedPackageRes encrypt ( EncryptedSessionChain chain , byte [ ] data ) { 
 + 
 byte [ ] encrypted ; 
 try { 
 encrypted = chain . encrypt ( data ) ; 
 @ @ - 258 , 6 + 262 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 e . printStackTrace ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 + Log . d ( TAG , " Encrypt " + Crypto . hex ( encrypted ) ) ; 
 return new EncryptedPackageRes ( encrypted , theirKeyGroup ) ; 
 } 
 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index e0f99e8 . . 17eb2c3 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 219 , 7 + 219 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void onAllKeysReady ( ) { 
 - Log . d ( TAG , " Key Manager started " ) ; 
 + Log . d ( TAG , " Key Manager started with key group # " + ownKeys . getKeyGroupId ( ) ) ; 
 / / Now we can start receiving or sending encrypted messages 
 isReady = true ; 
 unstashAll ( ) ; 
 @ @ - 243 , 9 + 243 , 9 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 } 
 
 - Log . d ( TAG , " No key found : " + Crypto . keyHash ( publicKey ) ) ; 
 + Log . d ( TAG , " No key found : " + Crypto . hex ( publicKey ) ) ; 
 for ( PrivateKey k : ownKeys . getPreKeys ( ) ) { 
 - Log . d ( TAG , " Have : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( k . getKey ( ) ) ) ) ; 
 + Log . d ( TAG , " Have : " + Crypto . hex ( Curve25519 . keyGenPublic ( k . getKey ( ) ) ) ) ; 
 } 
 
 future . error ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; 
 @ @ - 312 , 7 + 312 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 final UserKeys keys = getCachedUserKeys ( uid ) ; 
 UserKeysGroup keysGroup = null ; 
 for ( UserKeysGroup g : keys . getUserKeysGroups ( ) ) { 
 - Log . d ( TAG , " KeyGroup ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; 
 + / / Log . d ( TAG , " KeyGroup ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; 
 if ( g . getKeyGroupId ( ) = = keyGroupId ) { 
 keysGroup = g ; 
 } 
 @ @ - 356 , 7 + 356 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 cacheUserKeys ( keys . removeUserKeyGroup ( userKeysGroup . getKeyGroupId ( ) ) 
 . addUserKeyGroup ( userKeysGroup ) ) ; 
 
 - Log . d ( TAG , " ( uid : " + uid + " ) Fetched PreKey " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; 
 + / / Log . d ( TAG , " ( uid : " + uid + " ) Fetched PreKey " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; 
 future . result ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; 
 } 
 
 @ @ - 385 , 7 + 385 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 PublicKey pkey = new PublicKey ( key . getKeyId ( ) , key . getKeyAlg ( ) , key . getKeyMaterial ( ) ) ; 
 / / Do not store all ephemeral key as it is not required 
 
 - Log . d ( TAG , " ( uid : " + uid + " ) Fetched ephemeral " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; 
 + / / Log . d ( TAG , " ( uid : " + uid + " ) Fetched ephemeral " + Crypto . keyHash ( key . getKeyMaterial ( ) ) ) ; 
 future . result ( new FetchUserEphemeralKeyResponse ( pkey ) ) ; 
 } 
 
 @ @ - 484 , 10 + 484 , 6 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( cached ! = null ) { 
 try { 
 userKeys = new UserKeys ( cached ) ; 
 - Log . d ( TAG , " Loaded ( uid : " + uid + " ) : " + Crypto . hex ( cached ) ) ; 
 - for ( UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { 
 - Log . d ( TAG , " Loaded ( uid : " + uid + " ) : " + g . getKeyGroupId ( ) ) ; 
 - } 
 } catch ( IOException e ) { 
 e . printStackTrace ( ) ; 
 } 
 @ @ - 497 , 18 + 493 , 6 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void cacheUserKeys ( UserKeys userKeys ) { 
 - for ( UserKeysGroup g : userKeys . getUserKeysGroups ( ) ) { 
 - Log . d ( TAG , " Cache ( uid : " + userKeys . getUid ( ) + " ) : " + g . getKeyGroupId ( ) ) ; 
 - } 
 - try { 
 - UserKeys upd = new UserKeys ( userKeys . toByteArray ( ) ) ; 
 - Log . d ( TAG , " Cache2 ( uid : " + userKeys . getUid ( ) + " ) : " + Crypto . hex ( userKeys . toByteArray ( ) ) ) ; 
 - for ( UserKeysGroup g : upd . getUserKeysGroups ( ) ) { 
 - Log . d ( TAG , " Cache2 ( uid : " + userKeys . getUid ( ) + " ) : " + g . getKeyGroupId ( ) ) ; 
 - } 
 - } catch ( IOException e ) { 
 - e . printStackTrace ( ) ; 
 - } 
 encryptionKeysStorage . addOrUpdateItem ( userKeys . getUid ( ) , userKeys . toByteArray ( ) ) ; 
 cachedUserKeys . put ( userKeys . getUid ( ) , userKeys ) ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 index 098a2ac . . 6f38004 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / session / EncryptedSessionChain . java 
 @ @ - 108 , 8 + 108 , 8 @ @ public class EncryptedSessionChain { 
 theirPublicKey , 
 ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / 
 
 - Log . d ( " EncryptedSessionChain " , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; 
 - Log . d ( " EncryptedSessionChain " , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; 
 + Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Own ephemeral Key : " + Crypto . keyHash ( Curve25519 . keyGenPublic ( ownPrivateKey ) ) ) ; 
 + Log . d ( " EncryptedSessionChain # " + session . getPeerKeyGroupId ( ) , " Their ephemeral Key : " + Crypto . keyHash ( theirPublicKey ) ) ; 
 
 return ByteStrings . merge ( header , ActorBox . closeBox ( header , data , Crypto . randomBytes ( 32 ) , ratchetMessageKey ) ) ; 
 }

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 index a6a37f9 . . 11474a8 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 + + + b / actor - sdk / sdk - core - ios / ActorSDK / Sources / ActorCore / Makefile 
 @ @ - 28 , 7 + 28 , 7 @ @ space : = $ { null } $ { null } 
 J2OBJC _ DISTRIBUTION = $ ( PODS _ ROOT ) / J2ObjC - Framework / Distributive 
 J2OBJC = $ ( J2OBJC _ DISTRIBUTION ) / j2objc 
 J2OBJCC = $ ( J2OBJC _ DISTRIBUTION ) / j2objcc 
 - J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods 
 + J2OBJC _ ARGS = - use - arc - - generate - deprecated - - doc - comments - g - - static - accessor - methods - source 8 - Xforce - incomplete - java8 
 J2OBJCC _ ARGS = - ObjC - fobjc - arc - fembed - bitcode - marker - Wobjc - designated - initializers - g $ ( ARCHFLAGS ) $ ( SDKFLAGS ) - I $ ( J2OBJC _ DISTRIBUTION ) / include 
 
 LIBRARY _ NAME = libactor . so 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / build . gradle b / actor - sdk / sdk - core / core / core - shared / build . gradle 
 index e7791f8 . . c994383 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / build . gradle 
 + + + b / actor - sdk / sdk - core / core / core - shared / build . gradle 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 apply plugin : ' java ' 
 
 compileJava { 
 - sourceCompatibility = 1 . 6 
 + sourceCompatibility = 1 . 8 
 targetCompatibility = 1 . 6 
 } 
 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 6ab8482 . . ca8c14b 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 71 , 109 + 71 , 80 @ @ public class EncryptedPeerActor extends ModuleActor { 
 sequence ( 
 ask ( keyManager , new FetchOwnKeyGroup ( ) ) . cast ( ) , 
 ask ( keyManager , new FetchUserKeyGroups ( uid ) ) . cast ( ) 
 - ) . then ( new Supplier < Object [ ] > ( ) { 
 - @ Override 
 - public void apply ( Object [ ] objects ) { 
 - ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; 
 - theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; 
 - isReady = true ; 
 - unstashAll ( ) ; 
 - } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . w ( TAG , " Unable to fetch initial parameters " ) ; 
 - Log . e ( TAG , e ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + ) . then ( objects - > { 
 + ownKeyGroupId = ( ( FetchOwnKeyGroupResult ) objects [ 0 ] ) . getKeyGroupId ( ) ; 
 + theirKeys = ( ( FetchUserKeyGroupsResponse ) objects [ 1 ] ) . getUserKeys ( ) ; 
 + isReady = true ; 
 + unstashAll ( ) ; 
 + } ) . failure ( e - > { 
 + Log . w ( TAG , " Unable to fetch initial parameters " ) ; 
 + Log . e ( TAG , e ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void doEncrypt ( final byte [ ] data , final PromiseResolver < EncryptBoxResponse > future ) { 
 Log . d ( TAG , " doEncrypt " ) ; 
 - sequence ( map ( theirKeys . getUserKeysGroups ( ) , new Map < UserKeysGroup , Promise < ActorRef > > ( ) { 
 - @ Override 
 - public Promise < ActorRef > map ( final UserKeysGroup src ) { 
 - Log . d ( TAG , " doEncrypt : map " ) ; 
 - for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 - if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 - return success ( activeSessions . get ( sessionId ) ) ; 
 - } 
 + sequence ( map ( theirKeys . getUserKeysGroups ( ) , src - > { 
 + Log . d ( TAG , " doEncrypt : map " ) ; 
 + for ( SessionId sessionId : activeSessions . keySet ( ) ) { 
 + if ( sessionId . getTheirKeyGroupId ( ) = = src . getKeyGroupId ( ) ) { 
 + return success ( activeSessions . get ( sessionId ) ) ; 
 } 
 - 
 - Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 - 
 - return zip ( sequence ( 
 - ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 - ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 - ) , new ArrayFunction < Object , ActorRef > ( ) { 
 - @ Override 
 - public ActorRef apply ( Object [ ] t ) { 
 - 
 - Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 - 
 - final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 - final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 - 
 - SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 - src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 - ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , new ActorCreator < EncryptedSessionActor > ( ) { 
 - @ Override 
 - public EncryptedSessionActor create ( ) { 
 - return new EncryptedSessionActor ( context ( ) , uid , 
 - ownEphemeral , theirEphemeral . getKeyId ( ) , src . getKeyGroupId ( ) ) ; 
 - } 
 - } ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 - activeSessions . put ( sessionId , res ) ; 
 - return res ; 
 - } 
 - } ) . dispatch ( self ( ) ) ; 
 } 
 - } ) ) . then ( new Supplier < ActorRef [ ] > ( ) { 
 - @ Override 
 - public void apply ( ActorRef [ ] actorRefs ) { 
 
 - Log . d ( TAG , " doEncrypt : enc " ) ; 
 + Log . d ( TAG , " doEncrypt : not _ found " ) ; 
 + final UserKeysGroup srcFinal = src ; 
 + return zip ( sequence ( 
 + ask ( keyManager , new FetchUserEphemeralKeyRandom ( uid , src . getKeyGroupId ( ) ) ) . cast ( ) , 
 + ask ( keyManager , new FetchOwnEphemeralKey ( ) ) . cast ( ) 
 + ) , t - > { 
 + 
 + Log . d ( TAG , " doEncrypt : not _ found : apply " ) ; 
 + 
 + final UserPublicKey theirEphemeral = ( ( FetchUserEphemeralKeyResponse ) t [ 0 ] ) . getEphemeralKey ( ) ; 
 + final long ownEphemeral = ( ( FetchOwnEphemeralKeyResult ) t [ 1 ] ) . getId ( ) ; 
 + 
 + SessionId sessionId = new SessionId ( ownKeyGroupId , ownEphemeral , 
 + src . getKeyGroupId ( ) , theirEphemeral . getKeyId ( ) ) ; 
 + ActorRef res = system ( ) . actorOf ( Props . create ( EncryptedSessionActor . class , ( ) - > new EncryptedSessionActor ( context ( ) , uid , 
 + ownEphemeral , theirEphemeral . getKeyId ( ) , srcFinal . getKeyGroupId ( ) ) ) , getPath ( ) + " / k _ " + RandomUtils . nextRid ( ) ) ; 
 + activeSessions . put ( sessionId , res ) ; 
 + return res ; 
 + } ) ; 
 + } ) ) . then ( actorRefs - > { 
 + 
 + Log . d ( TAG , " doEncrypt : enc " ) ; 
 + 
 + final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + 
 + sequence ( Promises . map ( actorRefs , src - > { 
 + return ask ( src , new EncryptPackage ( encKey ) ) ; 
 + } ) ) . then ( encryptedPackageRes - > { 
 + ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < > ( ) ; 
 + for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 + encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 + } 
 
 - final byte [ ] encKey = Crypto . randomBytes ( 128 ) ; 
 + byte [ ] encData ; 
 + try { 
 + encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 + } catch ( IntegrityException e ) { 
 + e . printStackTrace ( ) ; 
 + future . error ( e ) ; 
 + return ; 
 + } 
 
 - sequence ( Promises . map ( actorRefs , new Map < ActorRef , Promise < EncryptedPackageRes > > ( ) { 
 - @ Override 
 - public Promise < EncryptedPackageRes > map ( ActorRef src ) { 
 - return ask ( src , new EncryptPackage ( encKey ) ) ; 
 - } 
 - } ) ) . then ( new Supplier < EncryptedPackageRes [ ] > ( ) { 
 - @ Override 
 - public void apply ( EncryptedPackageRes [ ] encryptedPackageRes ) { 
 - ArrayList < EncryptedBoxKey > encryptedKeys = new ArrayList < EncryptedBoxKey > ( ) ; 
 - for ( EncryptedPackageRes r : encryptedPackageRes ) { 
 - encryptedKeys . add ( new EncryptedBoxKey ( uid , r . getKeyGroupId ( ) , r . getData ( ) ) ) ; 
 - } 
 - 
 - byte [ ] encData ; 
 - try { 
 - encData = ActorBox . closeBox ( ByteStrings . intToBytes ( ownKeyGroupId ) , data , Crypto . randomBytes ( 32 ) , new ActorBoxKey ( encKey ) ) ; 
 - } catch ( IntegrityException e ) { 
 - e . printStackTrace ( ) ; 
 - future . error ( e ) ; 
 - return ; 
 - } 
 - 
 - EncryptedBox encryptedBox = new EncryptedBox ( 
 - encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 - ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 - 
 - future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 - } 
 - } ) . failure ( new Supplier < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 - Log . e ( TAG , e ) ; 
 - future . error ( e ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 - } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + EncryptedBox encryptedBox = new EncryptedBox ( 
 + encryptedKeys . toArray ( new EncryptedBoxKey [ encryptedKeys . size ( ) ] ) , 
 + ByteStrings . merge ( ByteStrings . intToBytes ( ownKeyGroupId ) , encData ) ) ; 
 + 
 + future . result ( new EncryptBoxResponse ( encryptedBox ) ) ; 
 + } ) . failure ( e - > { 
 + Log . d ( TAG , " Unable to encrypt all receivers " ) ; 
 + Log . e ( TAG , e ) ; 
 + future . error ( e ) ; 
 + } ) . done ( self ( ) ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void doDecrypt ( final EncryptedBox data , final PromiseResolver < DecryptBoxResponse > future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 6cea4f7 . . f5481e2 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 92 , 7 + 92 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 return new EncryptedSession ( ownIdentityKey , ownPreKey , theirIdentityKey , theirPreKey , theirKeyGroup ) ; 
 } 
 - } ) . dispatch ( self ( ) ) . then ( new Supplier < EncryptedSession > ( ) { 
 + } ) . then ( new Supplier < EncryptedSession > ( ) { 
 @ Override 
 public void apply ( EncryptedSession encryptedSession ) { 
 EncryptedSessionActor . this . session = encryptedSession ; 
 @ @ - 104 , 7 + 104 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . w ( TAG , " Session load error " ) ; 
 Log . e ( TAG , e ) ; 
 } 
 - } ) . dispatch ( self ( ) ) . done ( ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 
 private void onEncrypt ( final byte [ ] data , final PromiseResolver < EncryptedPackageRes > future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 index ee0cc28 . . 723ae25 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / util / ModuleActor . java 
 @ @ - 198 , 7 + 198 , 7 @ @ public class ModuleActor extends AskcableActor implements BusSubscriber { 
 } 
 } ) ; 
 } 
 - } . dispatch ( self ( ) ) ; 
 + } . done ( self ( ) ) ; 
 } 
 
 public void cancelRequest ( long rid ) { 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 index 6ad3121 . . 063d466 100755 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / actors / Actor . java 
 @ @ - 221 , 7 + 221 , 7 @ @ public class Actor { 
 protected void exec ( @ NotNull PromiseResolver < T > executor ) { 
 dest . send ( new AskIntRequest ( msg , executor ) ) ; 
 } 
 - } . dispatch ( self ( ) ) ; 
 + } ; 
 } 
 
 public void ask ( ActorRef dest , Object message ) { 
 @ @ - 295 , 6 + 295 , 6 @ @ public class Actor { 
 public void apply ( Exception e ) { 
 self ( ) . send ( new AskIntError ( id , e ) ) ; 
 } 
 - } ) . done ( ) ; 
 + } ) . done ( self ( ) ) ; 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 index 2f5e64c . . f16e918 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / function / Function . java 
 @ @ - 2 , 4 + 2 , 8 @ @ package im . actor . runtime . function ; 
 
 public interface Function < T , R > { 
 R apply ( T t ) ; 
 + 
 + default R apply2 ( T t ) { 
 + return apply ( t ) ; 
 + } 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 index 89e8a6f . . 7a376aa 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 @ @ - 5 , 6 + 5 , 7 @ @ import org . jetbrains . annotations . Nullable ; 
 
 import java . util . ArrayList ; 
 
 + import im . actor . runtime . actors . Actor ; 
 import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . function . Supplier ; 
 
 @ @ - 18 , 7 + 19 , 7 @ @ public abstract class Promise < T > { 
 
 private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; 
 
 - private PromiseDispatcher dispatcher = PromiseDispatcher . DEFAULT ; 
 + private ActorRef dispatchActor ; 
 private volatile T result ; 
 private volatile Exception exception ; 
 private volatile boolean isFinished ; 
 @ @ - 40 , 7 + 41 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > then ( final Supplier < T > then ) { 
 if ( isFinished ) { 
 if ( exception = = null ) { 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 then . apply ( result ) ; 
 @ @ - 72 , 7 + 73 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > failure ( final Supplier < Exception > failure ) { 
 if ( isFinished ) { 
 if ( exception ! = null ) { 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 failure . apply ( exception ) ; 
 @ @ - 104 , 7 + 105 , 7 @ @ public abstract class Promise < T > { 
 public synchronized Promise < T > complete ( final PromiseCallback < T > callback ) { 
 if ( isFinished ) { 
 
 - dispatcher . dispatch ( new Runnable ( ) { 
 + dispatchActor . send ( new Runnable ( ) { 
 @ Override 
 public void run ( ) { 
 if ( exception ! = null ) { 
 @ @ - 120 , 25 + 121 , 26 @ @ public abstract class Promise < T > { 
 return this ; 
 } 
 
 - / * * 
 - * Binding result dispatching to actor 
 - * 
 - * @ param ref dest actor 
 - * @ return this 
 - * / 
 - public Promise < T > dispatch ( ActorRef ref ) { 
 - dispatcher = PromiseDispatcher . forActor ( ref ) ; 
 - return this ; 
 - } 
 + / / / * * 
 + / / * Binding result dispatching to actor 
 + / / * 
 + / / * @ param ref dest actor 
 + / / * @ return this 
 + / / * / 
 + / / public Promise < T > dispatch ( ActorRef ref ) { 
 + / / dispatcher = PromiseDispatcher . forActor ( ref ) ; 
 + / / return this ; 
 + / / } 
 
 / * * 
 * Call this method to start promise execution 
 * / 
 - public Promise < T > done ( ) { 
 + public Promise < T > done ( ActorRef ref ) { 
 if ( isStarted ) { 
 throw new RuntimeException ( " Promise already started " ) ; 
 } 
 isStarted = true ; 
 + dispatchActor = ref ; 
 exec ( new PromiseResolver < T > ( this ) ) ; 
 return this ; 
 } 
 @ @ - 147 , 18 + 149 , 22 @ @ public abstract class Promise < T > { 
 return ( Promise < R > ) this ; 
 } 
 
 - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { 
 + public ActorRef getDispatchActor ( ) { 
 + return dispatchActor ; 
 + } 
 + 
 + / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { 
 / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; 
 / / } 
 
 - / * * 
 - * Getting current dispatcher for promise 
 - * 
 - * @ return current dispatcher 
 - * / 
 - public PromiseDispatcher getDispatcher ( ) { 
 - return dispatcher ; 
 - } 
 + / / / * * 
 + / / * Getting current dispatcher for promise 
 + / / * 
 + / / * @ return current dispatcher 
 + / / * / 
 + / / public PromiseDispatcher getDispatcher ( ) { 
 + / / return dispatcher ; 
 + / / } 
 
 public boolean isFinished ( ) { 
 return isFinished ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 index 4614511 . . b071798 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 @ @ - 52 , 7 + 52 , 7 @ @ public class Promises { 
 executor . error ( e ) ; 
 } 
 } ) ; 
 - promises . done ( ) ; 
 + promises . done ( promises . getDispatchActor ( ) ) ; 
 } 
 } ; 
 } 
 @ @ - 106 , 7 + 106 , 7 @ @ public class Promises { 
 } ) ; 
 } 
 for ( Promise < T > p : promises ) { 
 - p . done ( ) ; 
 + p . done ( self . getDispatchActor ( ) ) ; 
 } 
 } 
 } ;
