BLEU SCORE: 0.1203921753741131

TEST MSG: fix ( server : rpc , test ) : use slick based key - value for webactions
GENERATED MSG: feat ( server : core , rpc ) : webactions service implementation

TEST DIFF (one line): diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > index ab788fe . . 6ac43c8 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > @ @ - 9 , 8 + 9 , 9 @ @ import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWeba < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . webactions . Webaction < nl > + import im . actor . storage . SimpleStorage < nl > + import im . actor . storage . api . PutAction < nl > import shardakka . ShardakkaExtension < nl > - import slick . dbio . DBIO < nl > < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > @ @ - 23 , 8 + 24 , 8 @ @ object WebactionsErrors { < nl > def actionFailed ( message : String ) = RpcError ( 500 , " WEBACTION _ FAILED " , message , false , None ) < nl > } < nl > < nl > - private [ rpc ] object WebactionsKeyValues { < nl > - def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) < nl > + private [ rpc ] object WebactionStorage extends SimpleStorage ( " webactions " ) { < nl > + def putWebaction ( hash : String , name : String ) : PutAction = put ( hash , name . getBytes ) < nl > } < nl > < nl > final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { < nl > @ @ - 33 , 8 + 34 , 10 @ @ final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends Web < nl > < nl > override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > private implicit val timeout : Timeout = Timeout ( 5 . seconds ) < nl > - private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) < nl > - private val db = DbExtension ( actorSystem ) . db < nl > + private val ( db , conn ) = { < nl > + val dbExt = DbExtension ( actorSystem ) < nl > + ( dbExt . db , dbExt . connector ) < nl > + } < nl > < nl > override def doHandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > @ @ - 42 , 19 + 45 , 19 @ @ final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends Web < nl > fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > webAction ← fromXor ( createWebaction ( fqn ) ) < nl > actionHash = generateActionHash ( ) < nl > - _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) < nl > + _ ← fromFuture ( conn . run ( WebactionStorage . putWebaction ( actionHash , actionName ) ) ) < nl > } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . value < nl > } < nl > < nl > override def doHandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > ( for { < nl > - actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) < nl > + actionName ← fromFutureOption ( WrongActionHash ) ( conn . run ( WebactionStorage . get ( actionHash ) ) ) map ( new String ( _ ) ) < nl > fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > webAction ← fromXor ( createWebaction ( fqn ) ) < nl > response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) < nl > _ ← fromBoolean ( actionFailed ( response . content . toString ) ) ( response . isSuccess ) < nl > - _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) < nl > + _ ← fromFuture ( conn . run ( WebactionStorage . delete ( actionHash ) ) ) < nl > } yield ResponseCompleteWebaction ( response . content ) ) . value < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > index 82da12a . . 97de05e 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > @ @ - 3 , 10 + 3 , 10 @ @ package im . actor . server . api . rpc . service < nl > import im . actor . api . rpc . collections . { ApiInt32Value , ApiMapValue , ApiMapValueItem , ApiStringValue } < nl > import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } < nl > import im . actor . api . rpc . { AuthData , ClientData , Error , Ok } < nl > - import im . actor . server . api . rpc . service . webactions . { WebactionsErrors , WebactionsKeyValues , WebactionsServiceImpl } < nl > + import im . actor . server . api . rpc . service . webactions . { WebactionStorage , WebactionsErrors , WebactionsServiceImpl } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . webactions . CorrectWebaction < nl > import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > - import org . scalatest . Inside . _ < nl > < nl > class WebactionServiceSpec < nl > extends BaseAppSuite < nl > @ @ - 31 , 7 + 31 , 7 @ @ class WebactionServiceSpec < nl > val ( user , userAuthId , userAuthSid , _ ) = createUser ( ) < nl > val sessionId = createSessionId ( ) < nl > implicit val clientData = ClientData ( userAuthId , sessionId , Some ( AuthData ( user . id , userAuthSid , 42 ) ) ) < nl > - private val kv = WebactionsKeyValues . actionHashUserKV ( ) < nl > + val conn = DbExtension ( system ) . connector < nl > < nl > def e1 ( ) : Unit = { < nl > whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ < nl > @ @ - 56 , 10 + 56 , 9 @ @ class WebactionServiceSpec < nl > case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ < nl > uri shouldEqual CorrectWebaction . uri < nl > reg shouldEqual CorrectWebaction . regex < nl > - whenReady ( kv . get ( hash ) ) { optAction ⇒ < nl > + whenReady ( conn . run ( WebactionStorage . get ( hash ) ) ) { optAction ⇒ < nl > optAction shouldBe defined < nl > - val action = optAction . get < nl > - actionName shouldEqual action < nl > + actionName shouldEqual new String ( optAction . get ) < nl > } < nl > } < nl > } < nl > @ @ - 92 , 7 + 91 , 7 @ @ class WebactionServiceSpec < nl > ) < nl > } < nl > } < nl > - whenReady ( kv . get ( actionHash ) ) { optAction ⇒ < nl > + whenReady ( conn . run ( WebactionStorage . get ( actionHash ) ) ) { optAction ⇒ < nl > optAction should not be defined < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 4d9609f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala < nl > @ @ - 0 , 0 + 1 , 46 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiMapValueItem , ApiMapValue } < nl > + import im . actor . config . ActorConfig < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . collection . JavaConversions . _ < nl > + import scala . util . Try < nl > + < nl > + object Webaction { < nl > + < nl > + / * * < nl > + * Retrieves list of all available webactions < nl > + * @ param path path ofconfig , containing list of registered webactions < nl > + * @ return mapping from webaction name to its FQN < nl > + * / < nl > + def list ( path : String ) : Map [ String , String ] = < nl > + ActorConfig . load ( ) . getConfig ( path ) . root . unwrapped . toMap map { case ( k , v ) ⇒ k → v . toString } < nl > + < nl > + def list : Map [ String , String ] = list ( " enabled - modules . webactions " ) < nl > + < nl > + / * * < nl > + * Instantiates webaction by fully qualified class name < nl > + * @ param actionFQN fully qualified class name < nl > + * @ param system actor system , required to execute actions inside webaction < nl > + * @ return ` Success ( webaction ) ` when webaction instantiation succeeds , < nl > + * and ` Failure ( exception ) ` when instantiation failed by various reasons ( no such class / wrong constuctor ) < nl > + * / < nl > + def webactionOf ( actionFQN : String , system : ActorSystem ) : Try [ Webaction ] = Try { < nl > + val constructor = Class . forName ( actionFQN ) . getConstructors ( ) ( 0 ) < nl > + constructor . newInstance ( system ) . asInstanceOf [ Webaction ] < nl > + } < nl > + < nl > + def failure ( cause : String ) : ApiMapValue = < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " error " , ApiStringValue ( cause ) ) ) ) < nl > + < nl > + def success ( message : String ) : ApiMapValue = < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " success " , ApiStringValue ( message ) ) ) ) < nl > + } < nl > + < nl > + abstract class Webaction ( system : ActorSystem ) { < nl > + def uri ( params : ApiMapValue ) : String < nl > + def regex : String < nl > + def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . 6168f4a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 75 @ @ < nl > + package im . actor . server . api . rpc . service . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . FutureResultRpc . _ < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . collections . ApiMapValue < nl > + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction , WebactionsService } < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . webactions . Webaction < nl > + import shardakka . ShardakkaExtension < nl > + import slick . dbio . DBIO < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . util . { Failure , Success } < nl > + import scalaz . { \ / , \ / - } < nl > + < nl > + object WebactionsErrors { < nl > + val WebactionNotFound = RpcError ( 404 , " WEBACTION _ NOT _ FOUND " , " Web action not found " , false , None ) < nl > + val FailedToCreateWebaction = RpcError ( 500 , " FAILED _ TO _ CREATE _ WEBACTION " , " Failed to create webaction " , true , None ) < nl > + val WrongActionHash = RpcError ( 400 , " WRONG _ WEBACTION _ HASH " , " Web action not found " , false , None ) < nl > + < nl > + } < nl > + < nl > + private [ rpc ] object WebactionsKeyValues { < nl > + def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) < nl > + } < nl > + < nl > + final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { < nl > + import WebactionsErrors . _ < nl > + < nl > + override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > + private implicit val timeout : Timeout = Timeout ( 5 . seconds ) < nl > + private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) < nl > + private val db = DbExtension ( actorSystem ) . db < nl > + < nl > + override def jhandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = { < nl > + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > + ( for { < nl > + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > + webAction ← fromEither ( createWebaction ( fqn ) ) < nl > + actionHash = generateActionHash ( ) < nl > + _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) < nl > + } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . run < nl > + } < nl > + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) < nl > + } < nl > + < nl > + override def jhandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = { < nl > + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > + ( for { < nl > + actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) < nl > + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > + webAction ← fromEither ( createWebaction ( fqn ) ) < nl > + response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) < nl > + _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) < nl > + } yield ResponseCompleteWebaction ( response ) ) . run < nl > + } < nl > + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) < nl > + } < nl > + < nl > + private def createWebaction ( fqn : String ) : RpcError \ / Webaction = { < nl > + Webaction . webactionOf ( fqn , actorSystem ) match { < nl > + case Success ( s ) ⇒ \ / - ( s ) < nl > + case Failure ( f ) ⇒ < nl > + actorSystem . log . error ( f , " Failed to create webaction " ) < nl > + Error ( FailedToCreateWebaction ) < nl > + } < nl > + } < nl > + < nl > + private def generateActionHash ( ) : String = ACLUtils . authTransactionHash ( ACLUtils . nextAccessSalt ( ) ) < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index 5ce2887 . . 9d1eabc 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 25 , 6 + 25 , 7 @ @ import im . actor . server . api . rpc . service . push . PushServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > import im . actor . server . api . rpc . service . users . UsersServiceImpl < nl > import im . actor . server . api . rpc . service . weak . WeakServiceImpl < nl > + import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl < nl > import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . { DialogExtension , DialogProcessor } < nl > @ @ - 138 , 7 + 139 , 8 @ @ object Main extends App { < nl > new ConfigsServiceImpl , < nl > new PushServiceImpl , < nl > new ProfileServiceImpl , < nl > - new IntegrationsServiceImpl ( webappConfig ) < nl > + new IntegrationsServiceImpl ( webappConfig ) , < nl > + new WebactionsServiceImpl < nl > ) < nl > < nl > system . actorOf ( RpcApiService . props ( services ) , " rpcApiService " ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > index 241f07d . . 0eec015 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > @ @ - 10 , 14 + 10 , 12 @ @ trait InternalExtension < nl > < nl > object InternalExtensions { < nl > < nl > - private val config = ActorConfig . load ( ) < nl > - < nl > def getId ( path : String , name : String ) = { < nl > - config . getInt ( s " $ path . $ name . id " ) < nl > + ActorConfig . load ( ) . getInt ( s " $ path . $ name . id " ) < nl > } < nl > < nl > def extensions ( path : String ) : Map [ Int , String ] = { < nl > - val extConfig = config . getConfig ( path ) < nl > + val extConfig = ActorConfig . load ( ) . getConfig ( path ) < nl > val extensionsKeys = extConfig . root . keys < nl > ( extensionsKeys map { extName ⇒ < nl > extConfig . getInt ( s " $ extName . id " ) → extConfig . getString ( s " $ extName . class " ) < nl > diff - - git a / actor - server / actor - testkit / src / main / resources / reference . conf b / actor - server / actor - testkit / src / main / resources / reference . conf < nl > index 6f166cc . . e122ccb 100644 < nl > - - - a / actor - server / actor - testkit / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - testkit / src / main / resources / reference . conf < nl > @ @ - 18 , 6 + 18 , 10 @ @ enabled - modules { < nl > sequence { < nl > max - update - size : 20 KiB < nl > } < nl > + webactions { < nl > + wrong : " im . actor . server . webactions . WrongWebaction " < nl > + correct : " im . actor . server . webactions . CorrectWebaction " < nl > + } < nl > } < nl > services { < nl > aws { < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 29288ff < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala < nl > @ @ - 0 , 0 + 1 , 22 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object CorrectWebaction { < nl > + val uri = " https : / / google . com / " < nl > + val regex = " https : / / mail . google . com " < nl > + val completeUri = " https : / / mail . google . com / mail / u / 0 / # inbox " < nl > + } < nl > + < nl > + class CorrectWebaction ( system : ActorSystem ) extends Webaction ( system ) { < nl > + import system . dispatcher < nl > + < nl > + override def uri ( params : ApiMapValue ) : String = CorrectWebaction . uri < nl > + override def regex : String = CorrectWebaction . regex < nl > + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future { < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " userId " , ApiInt32Value ( userId ) ) , ApiMapValueItem ( " url " , ApiStringValue ( url . reverse ) ) ) ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 8c21fa2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala < nl > @ @ - 0 , 0 + 1 , 15 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . ApiMapValue < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + / / MUST fail < nl > + class WrongWebaction ( system : ActorSystem ) extends Webaction ( system ) { < nl > + val importantVal = 2 / 0 < nl > + < nl > + override def uri ( params : ApiMapValue ) : String = " " < nl > + override def regex : String = " " < nl > + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future . successful ( ApiMapValue ( Vector ( ) ) ) < nl > + } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . f8b8fea < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > @ @ - 0 , 0 + 1 , 107 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } < nl > + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } < nl > + import im . actor . api . rpc . { Ok , ClientData , Error } < nl > + import im . actor . server . api . rpc . service . webactions . { WebactionsKeyValues , WebactionsErrors , WebactionsServiceImpl } < nl > + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > + import im . actor . server . webactions . CorrectWebaction < nl > + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegionProxy } < nl > + import org . scalatest . Inside . _ < nl > + < nl > + class WebactionServiceSpec < nl > + extends BaseAppSuite < nl > + with ImplicitSessionRegionProxy < nl > + with ImplicitAuthService { < nl > + < nl > + behavior of " WebactionService " < nl > + < nl > + " Init webaction " should " response with WEBACTION _ NOT _ FOUND when there is no webaction with such name " in t . e1 < nl > + < nl > + it should " response with FAILED _ TO _ CREATE _ WEBACTION when web action cannot be instantiated " in t . e2 < nl > + < nl > + it should " response with correct uri and regex when web action exists " in t . e3 < nl > + < nl > + " Complete webaction " should " response with WRONG _ WEBACTION _ HASH to wrong action hash " in t . e4 < nl > + < nl > + it should " response with ApiMapValue to correct action hash and remove action hash from key value " in t . e5 < nl > + < nl > + implicit val presenceManagerRegion = PresenceManager . startRegion ( ) < nl > + implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) < nl > + < nl > + val service = new WebactionsServiceImpl ( ) < nl > + < nl > + object t { < nl > + val ( user , userAuthId , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = ClientData ( userAuthId , sessionId , Some ( user . id ) ) < nl > + private val kv = WebactionsKeyValues . actionHashUserKV ( ) < nl > + < nl > + def e1 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . WebactionNotFound ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e2 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " wrong " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . FailedToCreateWebaction ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e3 ( ) : Unit = { < nl > + val actionName = " correct " < nl > + whenReady ( service . handleInitWebaction ( actionName , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ < nl > + uri shouldEqual CorrectWebaction . uri < nl > + reg shouldEqual CorrectWebaction . regex < nl > + whenReady ( kv . get ( hash ) ) { optAction ⇒ < nl > + optAction shouldBe defined < nl > + val action = optAction . get < nl > + actionName shouldEqual action < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e4 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ < nl > + } < nl > + } < nl > + whenReady ( service . handleCompleteWebaction ( " wrong _ hash " , CorrectWebaction . completeUri ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . WrongActionHash ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e5 ( ) : Unit = { < nl > + val actionHash = whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ < nl > + resp . toOption . get . actionHash < nl > + } < nl > + whenReady ( service . handleCompleteWebaction ( actionHash , CorrectWebaction . completeUri ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseCompleteWebaction ( map ) ) ⇒ < nl > + map . items should have length 2 < nl > + map . items should contain theSameElementsAs Vector ( < nl > + ApiMapValueItem ( " userId " , ApiInt32Value ( user . id ) ) , < nl > + ApiMapValueItem ( " url " , ApiStringValue ( CorrectWebaction . completeUri . reverse ) ) < nl > + ) < nl > + } < nl > + } < nl > + whenReady ( kv . get ( actionHash ) ) { optAction ⇒ < nl > + optAction should not be defined < nl > + } < nl > + } < nl > + < nl > + private val emptyParams = ApiMapValue ( Vector ( ) ) < nl > + } < nl > + < nl > + }

TEST DIFF:
diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 index ab788fe . . 6ac43c8 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 @ @ - 9 , 8 + 9 , 9 @ @ import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWeba 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . db . DbExtension 
 import im . actor . server . webactions . Webaction 
 + import im . actor . storage . SimpleStorage 
 + import im . actor . storage . api . PutAction 
 import shardakka . ShardakkaExtension 
 - import slick . dbio . DBIO 
 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 @ @ - 23 , 8 + 24 , 8 @ @ object WebactionsErrors { 
 def actionFailed ( message : String ) = RpcError ( 500 , " WEBACTION _ FAILED " , message , false , None ) 
 } 
 
 - private [ rpc ] object WebactionsKeyValues { 
 - def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) 
 + private [ rpc ] object WebactionStorage extends SimpleStorage ( " webactions " ) { 
 + def putWebaction ( hash : String , name : String ) : PutAction = put ( hash , name . getBytes ) 
 } 
 
 final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { 
 @ @ - 33 , 8 + 34 , 10 @ @ final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends Web 
 
 override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 private implicit val timeout : Timeout = Timeout ( 5 . seconds ) 
 - private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) 
 - private val db = DbExtension ( actorSystem ) . db 
 + private val ( db , conn ) = { 
 + val dbExt = DbExtension ( actorSystem ) 
 + ( dbExt . db , dbExt . connector ) 
 + } 
 
 override def doHandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 @ @ - 42 , 19 + 45 , 19 @ @ final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends Web 
 fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 webAction ← fromXor ( createWebaction ( fqn ) ) 
 actionHash = generateActionHash ( ) 
 - _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) 
 + _ ← fromFuture ( conn . run ( WebactionStorage . putWebaction ( actionHash , actionName ) ) ) 
 } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . value 
 } 
 
 override def doHandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 ( for { 
 - actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) 
 + actionName ← fromFutureOption ( WrongActionHash ) ( conn . run ( WebactionStorage . get ( actionHash ) ) ) map ( new String ( _ ) ) 
 fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 webAction ← fromXor ( createWebaction ( fqn ) ) 
 response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) 
 _ ← fromBoolean ( actionFailed ( response . content . toString ) ) ( response . isSuccess ) 
 - _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) 
 + _ ← fromFuture ( conn . run ( WebactionStorage . delete ( actionHash ) ) ) 
 } yield ResponseCompleteWebaction ( response . content ) ) . value 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 index 82da12a . . 97de05e 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 @ @ - 3 , 10 + 3 , 10 @ @ package im . actor . server . api . rpc . service 
 import im . actor . api . rpc . collections . { ApiInt32Value , ApiMapValue , ApiMapValueItem , ApiStringValue } 
 import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } 
 import im . actor . api . rpc . { AuthData , ClientData , Error , Ok } 
 - import im . actor . server . api . rpc . service . webactions . { WebactionsErrors , WebactionsKeyValues , WebactionsServiceImpl } 
 + import im . actor . server . api . rpc . service . webactions . { WebactionStorage , WebactionsErrors , WebactionsServiceImpl } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . webactions . CorrectWebaction 
 import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 - import org . scalatest . Inside . _ 
 
 class WebactionServiceSpec 
 extends BaseAppSuite 
 @ @ - 31 , 7 + 31 , 7 @ @ class WebactionServiceSpec 
 val ( user , userAuthId , userAuthSid , _ ) = createUser ( ) 
 val sessionId = createSessionId ( ) 
 implicit val clientData = ClientData ( userAuthId , sessionId , Some ( AuthData ( user . id , userAuthSid , 42 ) ) ) 
 - private val kv = WebactionsKeyValues . actionHashUserKV ( ) 
 + val conn = DbExtension ( system ) . connector 
 
 def e1 ( ) : Unit = { 
 whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ 
 @ @ - 56 , 10 + 56 , 9 @ @ class WebactionServiceSpec 
 case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ 
 uri shouldEqual CorrectWebaction . uri 
 reg shouldEqual CorrectWebaction . regex 
 - whenReady ( kv . get ( hash ) ) { optAction ⇒ 
 + whenReady ( conn . run ( WebactionStorage . get ( hash ) ) ) { optAction ⇒ 
 optAction shouldBe defined 
 - val action = optAction . get 
 - actionName shouldEqual action 
 + actionName shouldEqual new String ( optAction . get ) 
 } 
 } 
 } 
 @ @ - 92 , 7 + 91 , 7 @ @ class WebactionServiceSpec 
 ) 
 } 
 } 
 - whenReady ( kv . get ( actionHash ) ) { optAction ⇒ 
 + whenReady ( conn . run ( WebactionStorage . get ( actionHash ) ) ) { optAction ⇒ 
 optAction should not be defined 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala 
 new file mode 100644 
 index 0000000 . . 4d9609f 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiMapValueItem , ApiMapValue } 
 + import im . actor . config . ActorConfig 
 + 
 + import scala . concurrent . Future 
 + import scala . collection . JavaConversions . _ 
 + import scala . util . Try 
 + 
 + object Webaction { 
 + 
 + / * * 
 + * Retrieves list of all available webactions 
 + * @ param path path ofconfig , containing list of registered webactions 
 + * @ return mapping from webaction name to its FQN 
 + * / 
 + def list ( path : String ) : Map [ String , String ] = 
 + ActorConfig . load ( ) . getConfig ( path ) . root . unwrapped . toMap map { case ( k , v ) ⇒ k → v . toString } 
 + 
 + def list : Map [ String , String ] = list ( " enabled - modules . webactions " ) 
 + 
 + / * * 
 + * Instantiates webaction by fully qualified class name 
 + * @ param actionFQN fully qualified class name 
 + * @ param system actor system , required to execute actions inside webaction 
 + * @ return ` Success ( webaction ) ` when webaction instantiation succeeds , 
 + * and ` Failure ( exception ) ` when instantiation failed by various reasons ( no such class / wrong constuctor ) 
 + * / 
 + def webactionOf ( actionFQN : String , system : ActorSystem ) : Try [ Webaction ] = Try { 
 + val constructor = Class . forName ( actionFQN ) . getConstructors ( ) ( 0 ) 
 + constructor . newInstance ( system ) . asInstanceOf [ Webaction ] 
 + } 
 + 
 + def failure ( cause : String ) : ApiMapValue = 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " error " , ApiStringValue ( cause ) ) ) ) 
 + 
 + def success ( message : String ) : ApiMapValue = 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " success " , ApiStringValue ( message ) ) ) ) 
 + } 
 + 
 + abstract class Webaction ( system : ActorSystem ) { 
 + def uri ( params : ApiMapValue ) : String 
 + def regex : String 
 + def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . 6168f4a 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + package im . actor . server . api . rpc . service . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . FutureResultRpc . _ 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . collections . ApiMapValue 
 + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction , WebactionsService } 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . webactions . Webaction 
 + import shardakka . ShardakkaExtension 
 + import slick . dbio . DBIO 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . concurrent . { ExecutionContext , Future } 
 + import scala . util . { Failure , Success } 
 + import scalaz . { \ / , \ / - } 
 + 
 + object WebactionsErrors { 
 + val WebactionNotFound = RpcError ( 404 , " WEBACTION _ NOT _ FOUND " , " Web action not found " , false , None ) 
 + val FailedToCreateWebaction = RpcError ( 500 , " FAILED _ TO _ CREATE _ WEBACTION " , " Failed to create webaction " , true , None ) 
 + val WrongActionHash = RpcError ( 400 , " WRONG _ WEBACTION _ HASH " , " Web action not found " , false , None ) 
 + 
 + } 
 + 
 + private [ rpc ] object WebactionsKeyValues { 
 + def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) 
 + } 
 + 
 + final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { 
 + import WebactionsErrors . _ 
 + 
 + override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 + private implicit val timeout : Timeout = Timeout ( 5 . seconds ) 
 + private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) 
 + private val db = DbExtension ( actorSystem ) . db 
 + 
 + override def jhandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = { 
 + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 + ( for { 
 + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 + webAction ← fromEither ( createWebaction ( fqn ) ) 
 + actionHash = generateActionHash ( ) 
 + _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) 
 + } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . run 
 + } 
 + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) 
 + } 
 + 
 + override def jhandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = { 
 + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 + ( for { 
 + actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) 
 + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 + webAction ← fromEither ( createWebaction ( fqn ) ) 
 + response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) 
 + _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) 
 + } yield ResponseCompleteWebaction ( response ) ) . run 
 + } 
 + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) 
 + } 
 + 
 + private def createWebaction ( fqn : String ) : RpcError \ / Webaction = { 
 + Webaction . webactionOf ( fqn , actorSystem ) match { 
 + case Success ( s ) ⇒ \ / - ( s ) 
 + case Failure ( f ) ⇒ 
 + actorSystem . log . error ( f , " Failed to create webaction " ) 
 + Error ( FailedToCreateWebaction ) 
 + } 
 + } 
 + 
 + private def generateActionHash ( ) : String = ACLUtils . authTransactionHash ( ACLUtils . nextAccessSalt ( ) ) 
 + 
 + } 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index 5ce2887 . . 9d1eabc 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 25 , 6 + 25 , 7 @ @ import im . actor . server . api . rpc . service . push . PushServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 import im . actor . server . api . rpc . service . users . UsersServiceImpl 
 import im . actor . server . api . rpc . service . weak . WeakServiceImpl 
 + import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl 
 import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . { DialogExtension , DialogProcessor } 
 @ @ - 138 , 7 + 139 , 8 @ @ object Main extends App { 
 new ConfigsServiceImpl , 
 new PushServiceImpl , 
 new ProfileServiceImpl , 
 - new IntegrationsServiceImpl ( webappConfig ) 
 + new IntegrationsServiceImpl ( webappConfig ) , 
 + new WebactionsServiceImpl 
 ) 
 
 system . actorOf ( RpcApiService . props ( services ) , " rpcApiService " ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 index 241f07d . . 0eec015 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 @ @ - 10 , 14 + 10 , 12 @ @ trait InternalExtension 
 
 object InternalExtensions { 
 
 - private val config = ActorConfig . load ( ) 
 - 
 def getId ( path : String , name : String ) = { 
 - config . getInt ( s " $ path . $ name . id " ) 
 + ActorConfig . load ( ) . getInt ( s " $ path . $ name . id " ) 
 } 
 
 def extensions ( path : String ) : Map [ Int , String ] = { 
 - val extConfig = config . getConfig ( path ) 
 + val extConfig = ActorConfig . load ( ) . getConfig ( path ) 
 val extensionsKeys = extConfig . root . keys 
 ( extensionsKeys map { extName ⇒ 
 extConfig . getInt ( s " $ extName . id " ) → extConfig . getString ( s " $ extName . class " ) 
 diff - - git a / actor - server / actor - testkit / src / main / resources / reference . conf b / actor - server / actor - testkit / src / main / resources / reference . conf 
 index 6f166cc . . e122ccb 100644 
 - - - a / actor - server / actor - testkit / src / main / resources / reference . conf 
 + + + b / actor - server / actor - testkit / src / main / resources / reference . conf 
 @ @ - 18 , 6 + 18 , 10 @ @ enabled - modules { 
 sequence { 
 max - update - size : 20 KiB 
 } 
 + webactions { 
 + wrong : " im . actor . server . webactions . WrongWebaction " 
 + correct : " im . actor . server . webactions . CorrectWebaction " 
 + } 
 } 
 services { 
 aws { 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala 
 new file mode 100644 
 index 0000000 . . 29288ff 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala 
 @ @ - 0 , 0 + 1 , 22 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } 
 + 
 + import scala . concurrent . Future 
 + 
 + object CorrectWebaction { 
 + val uri = " https : / / google . com / " 
 + val regex = " https : / / mail . google . com " 
 + val completeUri = " https : / / mail . google . com / mail / u / 0 / # inbox " 
 + } 
 + 
 + class CorrectWebaction ( system : ActorSystem ) extends Webaction ( system ) { 
 + import system . dispatcher 
 + 
 + override def uri ( params : ApiMapValue ) : String = CorrectWebaction . uri 
 + override def regex : String = CorrectWebaction . regex 
 + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future { 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " userId " , ApiInt32Value ( userId ) ) , ApiMapValueItem ( " url " , ApiStringValue ( url . reverse ) ) ) ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala 
 new file mode 100644 
 index 0000000 . . 8c21fa2 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . ApiMapValue 
 + 
 + import scala . concurrent . Future 
 + 
 + / / MUST fail 
 + class WrongWebaction ( system : ActorSystem ) extends Webaction ( system ) { 
 + val importantVal = 2 / 0 
 + 
 + override def uri ( params : ApiMapValue ) : String = " " 
 + override def regex : String = " " 
 + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future . successful ( ApiMapValue ( Vector ( ) ) ) 
 + } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 new file mode 100644 
 index 0000000 . . f8b8fea 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 @ @ - 0 , 0 + 1 , 107 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } 
 + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } 
 + import im . actor . api . rpc . { Ok , ClientData , Error } 
 + import im . actor . server . api . rpc . service . webactions . { WebactionsKeyValues , WebactionsErrors , WebactionsServiceImpl } 
 + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 + import im . actor . server . webactions . CorrectWebaction 
 + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegionProxy } 
 + import org . scalatest . Inside . _ 
 + 
 + class WebactionServiceSpec 
 + extends BaseAppSuite 
 + with ImplicitSessionRegionProxy 
 + with ImplicitAuthService { 
 + 
 + behavior of " WebactionService " 
 + 
 + " Init webaction " should " response with WEBACTION _ NOT _ FOUND when there is no webaction with such name " in t . e1 
 + 
 + it should " response with FAILED _ TO _ CREATE _ WEBACTION when web action cannot be instantiated " in t . e2 
 + 
 + it should " response with correct uri and regex when web action exists " in t . e3 
 + 
 + " Complete webaction " should " response with WRONG _ WEBACTION _ HASH to wrong action hash " in t . e4 
 + 
 + it should " response with ApiMapValue to correct action hash and remove action hash from key value " in t . e5 
 + 
 + implicit val presenceManagerRegion = PresenceManager . startRegion ( ) 
 + implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) 
 + 
 + val service = new WebactionsServiceImpl ( ) 
 + 
 + object t { 
 + val ( user , userAuthId , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = ClientData ( userAuthId , sessionId , Some ( user . id ) ) 
 + private val kv = WebactionsKeyValues . actionHashUserKV ( ) 
 + 
 + def e1 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . WebactionNotFound ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e2 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " wrong " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . FailedToCreateWebaction ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e3 ( ) : Unit = { 
 + val actionName = " correct " 
 + whenReady ( service . handleInitWebaction ( actionName , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ 
 + uri shouldEqual CorrectWebaction . uri 
 + reg shouldEqual CorrectWebaction . regex 
 + whenReady ( kv . get ( hash ) ) { optAction ⇒ 
 + optAction shouldBe defined 
 + val action = optAction . get 
 + actionName shouldEqual action 
 + } 
 + } 
 + } 
 + } 
 + 
 + def e4 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ 
 + } 
 + } 
 + whenReady ( service . handleCompleteWebaction ( " wrong _ hash " , CorrectWebaction . completeUri ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . WrongActionHash ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e5 ( ) : Unit = { 
 + val actionHash = whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ 
 + resp . toOption . get . actionHash 
 + } 
 + whenReady ( service . handleCompleteWebaction ( actionHash , CorrectWebaction . completeUri ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseCompleteWebaction ( map ) ) ⇒ 
 + map . items should have length 2 
 + map . items should contain theSameElementsAs Vector ( 
 + ApiMapValueItem ( " userId " , ApiInt32Value ( user . id ) ) , 
 + ApiMapValueItem ( " url " , ApiStringValue ( CorrectWebaction . completeUri . reverse ) ) 
 + ) 
 + } 
 + } 
 + whenReady ( kv . get ( actionHash ) ) { optAction ⇒ 
 + optAction should not be defined 
 + } 
 + } 
 + 
 + private val emptyParams = ApiMapValue ( Vector ( ) ) 
 + } 
 + 
 + }
