BLEU SCORE: 0.17064197787316962

TEST MSG: fix ( server : core ) : dont allow to change name to empty
GENERATED MSG: fix ( server : rpc ) : Preserve local names after contacts import . fixed # 96

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 6742c3c . . ed68723 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 43 , 6 + 43 , 8 @ @ object UserErrors { < nl > < nl > case object InvalidNickname extends UserError ( " Invalid nickname " ) < nl > < nl > + case object InvalidName extends UserError ( " Invalid name " ) < nl > + < nl > final case class InvalidTimeZone ( tz : String ) extends UserError ( s " Invalid time zone : $ tz " ) < nl > < nl > final case class InvalidLocale ( locale : String ) extends UserError ( s " Invalid locale : $ locale " ) < nl > @ @ - 136 , 16 + 138 , 23 @ @ private [ user ] trait UserCommandHandlers { < nl > db . run ( p . UserRepo . setCountryCode ( userId , countryCode ) map ( _ ⇒ ChangeCountryCodeAck ( ) ) ) < nl > } < nl > < nl > - protected def changeName ( user : User , name : String ) : Unit = < nl > - persistReply ( TSEvent ( now ( ) , UserEvents . NameChanged ( name ) ) , user ) { _ ⇒ < nl > - val update = UpdateUserNameChanged ( userId , name ) < nl > - for { < nl > - relatedUserIds ← getRelations ( userId ) < nl > - _ ← seqUpdatesExt . broadcastSingleUpdate ( relatedUserIds , update ) < nl > - seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , update ) < nl > - _ ← db . run ( UserRepo . setName ( userId , name ) ) < nl > - } yield seqstate < nl > + protected def changeName ( user : User , name : String ) : Unit = { < nl > + val replyTo = sender ( ) < nl > + < nl > + if ( StringUtils . validName ( name ) . fold ( l ⇒ false , r ⇒ true ) ) { < nl > + persistReply ( TSEvent ( now ( ) , UserEvents . NameChanged ( name ) ) , user ) { _ ⇒ < nl > + val update = UpdateUserNameChanged ( userId , name ) < nl > + for { < nl > + relatedUserIds ← getRelations ( userId ) < nl > + _ ← seqUpdatesExt . broadcastSingleUpdate ( relatedUserIds , update ) < nl > + seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , update ) < nl > + _ ← db . run ( UserRepo . setName ( userId , name ) ) < nl > + } yield seqstate < nl > + } < nl > + } else { < nl > + replyTo ! Status . Failure ( UserErrors . InvalidName ) < nl > } < nl > + } < nl > < nl > protected def delete ( user : User ) : Unit = < nl > persistStashingReply ( TSEvent ( now ( ) , UserEvents . Deleted ( ) ) , user ) { _ ⇒ < nl > @ @ - 198 , 8 + 207 , 9 @ @ private [ user ] trait UserCommandHandlers { < nl > ( seqstate , _ ) ← seqUpdatesExt . broadcastOwnSingleUpdate ( userId , relatedUserIds , update ) < nl > } yield seqstate < nl > } < nl > - } else < nl > + } else { < nl > replyTo ! Status . Failure ( UserErrors . InvalidNickname ) < nl > + } < nl > } else { < nl > replyTo ! Status . Failure ( UserErrors . NicknameTaken ) < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > index 4373f5f . . 2098ee6 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > @ @ - 276 , 12 + 276 , 12 @ @ trait AuthHelpers extends Helpers { < nl > } yield \ / - ( user ) < nl > } < nl > < nl > - protected def newUser ( ) : Result [ User ] = { < nl > + protected def newUser ( name : String ) : Result [ User ] = { < nl > val rng = ThreadLocalRandom . current ( ) < nl > val user = model . User ( < nl > id = nextIntId ( rng ) , < nl > accessSalt = ACLUtils . nextAccessSalt ( rng ) , < nl > - name = " " , < nl > + name = name , < nl > countryCode = " " , < nl > sex = model . NoSex , < nl > state = model . UserState . Registered , < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index 9f8cdcc . . 7abbba4 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 267 , 7 + 267 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > DeviceInfo ( timeZone . getOrElse ( " " ) , preferredLanguages ) . toByteArray , < nl > isChecked = false / / we don ' t need to check password if user signs up < nl > ) < nl > - user ← newUser ( ) < nl > + user ← newUser ( normUsername ) < nl > _ ← handleUserCreate ( user , transaction , clientData ) < nl > userStruct ← authorizeT ( user . id , " " , transaction , clientData ) < nl > } yield ResponseAuth ( userStruct , ApiConfig ( maxGroupSize ) ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > index 4e2de7f . . f37ff88 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > @ @ - 23 , 27 + 23 , 25 @ @ import scala . concurrent . { ExecutionContext , Future } < nl > object ProfileErrors { < nl > val NicknameInvalid = RpcError ( 400 , " NICKNAME _ INVALID " , < nl > " Invalid nickname . Valid nickname should contain from 5 to 32 characters , and may consist of latin characters , numbers and underscores " , false , None ) < nl > + val NameInvalid = RpcError ( 400 , " NAME _ INVALID " , " Invalid name . Valid name should not be empty or contain bad symbols " , false , None ) < nl > val NicknameBusy = RpcError ( 400 , " NICKNAME _ BUSY " , " This nickname already belongs some other user , we are sorry ! " , false , None ) < nl > val AboutTooLong = RpcError ( 400 , " ABOUT _ TOO _ LONG " , < nl > " About is too long . It should be no longer then 255 characters " , false , None ) < nl > } < nl > < nl > - final class ProfileServiceImpl ( ) ( < nl > - implicit < nl > - actorSystem : ActorSystem < nl > - ) extends ProfileService { < nl > + final class ProfileServiceImpl ( ) ( implicit system : ActorSystem ) extends ProfileService { < nl > < nl > import FileHelpers . _ < nl > import ImageUtils . _ < nl > < nl > - override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > + override implicit val ec : ExecutionContext = system . dispatcher < nl > < nl > private implicit val timeout = Timeout ( 5 . seconds ) < nl > / / TODO : configurable < nl > - private val db : Database = DbExtension ( actorSystem ) . db < nl > - private val userExt = UserExtension ( actorSystem ) < nl > - private implicit val socialRegion : SocialManagerRegion = SocialExtension ( actorSystem ) . region < nl > - private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( actorSystem ) . fsAdapter < nl > + private val db : Database = DbExtension ( system ) . db < nl > + private val userExt = UserExtension ( system ) < nl > + private implicit val socialRegion : SocialManagerRegion = SocialExtension ( system ) . region < nl > + private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( system ) . fsAdapter < nl > < nl > override def jhandleEditAvatar ( fileLocation : ApiFileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseEditAvatar ] ] = { < nl > / / TODO : flatten < nl > @ @ - 80 , 14 + 78 , 14 @ @ final class ProfileServiceImpl ( ) ( < nl > db . run ( toDBIOAction ( authorizedAction ) ) < nl > } < nl > < nl > - override def jhandleEditName ( name : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > - val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > - DBIO . from ( userExt . changeName ( client . userId , name ) map { < nl > - case SeqState ( seq , state ) ⇒ Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > - } ) < nl > + override def jhandleEditName ( name : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + for { < nl > + SeqState ( seq , state ) ← userExt . changeName ( client . userId , name ) < nl > + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) < nl > + } recover { < nl > + case UserErrors . InvalidName ⇒ Error ( ProfileErrors . NameInvalid ) < nl > } < nl > - db . run ( toDBIOAction ( authorizedAction ) ) < nl > - } < nl > < nl > def jhandleEditNickName ( nickname : Option [ String ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > authorized ( clientData ) { implicit client ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > index 79e6807 . . d745804 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > @ @ - 39 , 6 + 39 , 8 @ @ final class ProfileServiceSpec < nl > it should " respond with error on invalid locale " in profile . invalidPreferredLanguages < nl > it should " respond with error on same preferred languages " in profile . samePreferredLanguages < nl > < nl > + " Edit name " should " not allow to use empty name " in profile . editNameEmpty < nl > + < nl > implicit lazy val service = new ProfileServiceImpl < nl > implicit lazy val filesService = new FilesServiceImpl < nl > < nl > @ @ - 299 , 5 + 301 , 19 @ @ final class ProfileServiceSpec < nl > } < nl > } < nl > } < nl > + < nl > + def editNameEmpty ( ) = { < nl > + val ( user , authId , authSid , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + val clientData1 = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) < nl > + < nl > + whenReady ( service . jhandleEditName ( " " , clientData ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( e ) ⇒ e shouldEqual ProfileErrors . NameInvalid < nl > + } < nl > + } < nl > + < nl > + } < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > index c11aff2 . . d50d6e6 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > @ @ - 25 , 5 + 25 , 5 @ @ trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ < nl > } < nl > } < nl > < nl > - private def formatAuthored ( authorName : String , message : String ) : String = s " $ { authorName } : $ { message } " < nl > + private def formatAuthored ( authorName : String , message : String ) : String = s " $ authorName : $ message " < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index a8d7c13 . . 56cc358 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 116 , 14 + 116 , 14 @ @ private [ user ] trait UserCommandHandlers extends UpdateCounters { < nl > ) < nl > < nl > val result = if ( user . authIds . nonEmpty ) { < nl > - ( for { < nl > + for { < nl > senderUser ← UserOffice . getApiStruct ( senderUserId , userId , getAuthIdUnsafe ( user ) ) < nl > senderName = senderUser . localName . getOrElse ( senderUser . name ) < nl > pushText = getPushText ( message , senderName , userId ) < nl > counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) < nl > _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None , isFat = false ) < nl > _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , Some ( pushText ) , isFat ) < nl > - } yield DeliverMessageAck ( ) ) < nl > + } yield DeliverMessageAck ( ) < nl > } else { < nl > Future . successful ( DeliverMessageAck ( ) ) < nl > } < nl > @ @ - 194 , 9 + 194 , 10 @ @ private [ user ] trait UserCommandHandlers extends UpdateCounters { < nl > val serviceMessage = ServiceMessages . contactRegistered ( user . id ) < nl > / / FIXME : # perf broadcast updates using broadcastUpdateAll to serialize update once < nl > val actions = contacts map { contact ⇒ < nl > + val localName = contact . name . getOrElse ( user . name ) < nl > for { < nl > - _ ← p . contact . UserPhoneContact . createOrRestore ( contact . ownerUserId , user . id , phoneNumber , Some ( user . name ) , user . accessSalt ) < nl > - _ ← DBIO . from ( UserOffice . broadcastUserUpdate ( contact . ownerUserId , update , Some ( s " $ { contact . name . getOrElse ( user . name ) } registered " ) , isFat = true ) ) < nl > + _ ← p . contact . UserPhoneContact . createOrRestore ( contact . ownerUserId , user . id , phoneNumber , Some ( localName ) , user . accessSalt ) < nl > + _ ← DBIO . from ( UserOffice . broadcastUserUpdate ( contact . ownerUserId , update , Some ( s " $ localName registered " ) , isFat = true ) ) < nl > _ ← HistoryUtils . writeHistoryMessage ( < nl > models . Peer . privat ( user . id ) , < nl > models . Peer . privat ( contact . ownerUserId ) , < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala < nl > index 2b6f064 . . 85d592a 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala < nl > @ @ - 14 , 7 + 14 , 7 @ @ object UserPhoneContact { < nl > val pcontacts = TableQuery [ UserPhoneContactTable ] < nl > < nl > def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { < nl > - val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) < nl > + val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted = false ) < nl > pcontacts . insertOrUpdate ( contact ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > index 34e3c82 . . 7b93854 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > @ @ - 3 , 6 + 3 , 8 @ @ package im . actor . server . api . rpc . service < nl > import java . net . URLEncoder < nl > import java . time . { LocalDateTime , ZoneOffset } < nl > < nl > + import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl < nl > + < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . Random < nl > import scalaz . \ / < nl > @ @ - 13 , 7 + 15 , 7 @ @ import org . scalatest . Inside . _ < nl > < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . auth . _ < nl > - import im . actor . api . rpc . contacts . UpdateContactRegistered < nl > + import im . actor . api . rpc . contacts . { ResponseGetContacts , PhoneToImport , UpdateContactRegistered } < nl > import im . actor . api . rpc . misc . ResponseVoid < nl > import im . actor . api . rpc . users . { ContactRecord , ContactType , Sex } < nl > import im . actor . server . activation . internal . { ActivationConfig , InternalCodeActivation } < nl > @ @ - 66 , 6 + 68 , 8 @ @ final class AuthServiceSpec < nl > < nl > it should " register unregistered contacts and send updates " in s . e90 < nl > < nl > + it should " register unregistered contacts with local name " in s . e91 < nl > + < nl > " AuthTransaction and AuthSmsCode " should " be invalidated after sign in process successfully completed " in s . e10 < nl > < nl > it should " be invalidated after sign up process successfully completed " in s . e11 < nl > @ @ - 119 , 6 + 123 , 7 @ @ final class AuthServiceSpec < nl > val activationContext = InternalCodeActivation . newContext ( activationConfig , new DummySmsEngine , null ) < nl > implicit val service = new auth . AuthServiceImpl ( activationContext , mediator ) < nl > implicit val rpcApiService = system . actorOf ( RpcApiService . props ( Seq ( service ) ) ) < nl > + implicit val contactService = new ContactsServiceImpl < nl > < nl > val correctUri = " https : / / actor . im / registration " < nl > val correctAuthCode = " 0000 " < nl > @ @ - 439 , 6 + 444 , 58 @ @ final class AuthServiceSpec < nl > } < nl > } < nl > < nl > + def e91 ( ) = { < nl > + val phoneNumber = buildPhone ( ) < nl > + val userName = " Rock Jam " < nl > + val userSex = Some ( Sex . Male ) < nl > + val authId = createAuthId ( ) < nl > + val sessionId = createSessionId ( ) < nl > + val unregClientData = ClientData ( authId , sessionId , None ) < nl > + < nl > + val ( regUser , regAuthId , _ ) = createUser ( ) < nl > + val localName = Some ( " Bloody wild goat " ) < nl > + val regClientData = ClientData ( regAuthId , sessionId , Some ( regUser . id ) ) < nl > + < nl > + { < nl > + implicit val clientData = regClientData < nl > + val unregPhones = Vector ( PhoneToImport ( phoneNumber , localName ) ) < nl > + whenReady ( contactService . handleImportContacts ( unregPhones , Vector . empty ) ) ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > + sendSessionHello ( authId , sessionId ) < nl > + < nl > + { < nl > + implicit val clientData = unregClientData < nl > + val transactionHash = < nl > + whenReady ( startPhoneAuth ( phoneNumber ) ) { resp ⇒ < nl > + resp should matchPattern { case Ok ( ResponseStartPhoneAuth ( _ , false ) ) ⇒ } < nl > + resp . toOption . get . transactionHash < nl > + } < nl > + whenReady ( service . handleValidateCode ( transactionHash , correctAuthCode ) ) ( _ ⇒ ( ) ) < nl > + whenReady ( service . handleSignUp ( transactionHash , userName , userSex ) ) ( _ . toOption . get . user ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = regClientData < nl > + expectUpdate [ UpdateContactRegistered ] ( 0 , Array . empty , UpdateContactRegistered . header ) ( identity ) < nl > + < nl > + whenReady ( db . run ( persist . contact . UnregisteredPhoneContact . find ( phoneNumber ) ) ) { < nl > + _ shouldBe empty < nl > + } < nl > + < nl > + whenReady ( contactService . handleGetContacts ( " wrongHash " ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseGetContacts ( users , false ) ) ⇒ < nl > + users should have length 1 < nl > + val newUser = users . head < nl > + newUser . name shouldEqual userName < nl > + newUser . localName shouldEqual localName < nl > + } < nl > + } < nl > + } < nl > + < nl > + } < nl > + < nl > def e10 ( ) = { < nl > val ( user , authId , phoneNumber ) = createUser ( ) < nl > val sessionId = createSessionId ( )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 6742c3c . . ed68723 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 43 , 6 + 43 , 8 @ @ object UserErrors { 
 
 case object InvalidNickname extends UserError ( " Invalid nickname " ) 
 
 + case object InvalidName extends UserError ( " Invalid name " ) 
 + 
 final case class InvalidTimeZone ( tz : String ) extends UserError ( s " Invalid time zone : $ tz " ) 
 
 final case class InvalidLocale ( locale : String ) extends UserError ( s " Invalid locale : $ locale " ) 
 @ @ - 136 , 16 + 138 , 23 @ @ private [ user ] trait UserCommandHandlers { 
 db . run ( p . UserRepo . setCountryCode ( userId , countryCode ) map ( _ ⇒ ChangeCountryCodeAck ( ) ) ) 
 } 
 
 - protected def changeName ( user : User , name : String ) : Unit = 
 - persistReply ( TSEvent ( now ( ) , UserEvents . NameChanged ( name ) ) , user ) { _ ⇒ 
 - val update = UpdateUserNameChanged ( userId , name ) 
 - for { 
 - relatedUserIds ← getRelations ( userId ) 
 - _ ← seqUpdatesExt . broadcastSingleUpdate ( relatedUserIds , update ) 
 - seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , update ) 
 - _ ← db . run ( UserRepo . setName ( userId , name ) ) 
 - } yield seqstate 
 + protected def changeName ( user : User , name : String ) : Unit = { 
 + val replyTo = sender ( ) 
 + 
 + if ( StringUtils . validName ( name ) . fold ( l ⇒ false , r ⇒ true ) ) { 
 + persistReply ( TSEvent ( now ( ) , UserEvents . NameChanged ( name ) ) , user ) { _ ⇒ 
 + val update = UpdateUserNameChanged ( userId , name ) 
 + for { 
 + relatedUserIds ← getRelations ( userId ) 
 + _ ← seqUpdatesExt . broadcastSingleUpdate ( relatedUserIds , update ) 
 + seqstate ← seqUpdatesExt . deliverSingleUpdate ( user . id , update ) 
 + _ ← db . run ( UserRepo . setName ( userId , name ) ) 
 + } yield seqstate 
 + } 
 + } else { 
 + replyTo ! Status . Failure ( UserErrors . InvalidName ) 
 } 
 + } 
 
 protected def delete ( user : User ) : Unit = 
 persistStashingReply ( TSEvent ( now ( ) , UserEvents . Deleted ( ) ) , user ) { _ ⇒ 
 @ @ - 198 , 8 + 207 , 9 @ @ private [ user ] trait UserCommandHandlers { 
 ( seqstate , _ ) ← seqUpdatesExt . broadcastOwnSingleUpdate ( userId , relatedUserIds , update ) 
 } yield seqstate 
 } 
 - } else 
 + } else { 
 replyTo ! Status . Failure ( UserErrors . InvalidNickname ) 
 + } 
 } else { 
 replyTo ! Status . Failure ( UserErrors . NicknameTaken ) 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 index 4373f5f . . 2098ee6 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 @ @ - 276 , 12 + 276 , 12 @ @ trait AuthHelpers extends Helpers { 
 } yield \ / - ( user ) 
 } 
 
 - protected def newUser ( ) : Result [ User ] = { 
 + protected def newUser ( name : String ) : Result [ User ] = { 
 val rng = ThreadLocalRandom . current ( ) 
 val user = model . User ( 
 id = nextIntId ( rng ) , 
 accessSalt = ACLUtils . nextAccessSalt ( rng ) , 
 - name = " " , 
 + name = name , 
 countryCode = " " , 
 sex = model . NoSex , 
 state = model . UserState . Registered , 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index 9f8cdcc . . 7abbba4 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 267 , 7 + 267 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 DeviceInfo ( timeZone . getOrElse ( " " ) , preferredLanguages ) . toByteArray , 
 isChecked = false / / we don ' t need to check password if user signs up 
 ) 
 - user ← newUser ( ) 
 + user ← newUser ( normUsername ) 
 _ ← handleUserCreate ( user , transaction , clientData ) 
 userStruct ← authorizeT ( user . id , " " , transaction , clientData ) 
 } yield ResponseAuth ( userStruct , ApiConfig ( maxGroupSize ) ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 index 4e2de7f . . f37ff88 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 @ @ - 23 , 27 + 23 , 25 @ @ import scala . concurrent . { ExecutionContext , Future } 
 object ProfileErrors { 
 val NicknameInvalid = RpcError ( 400 , " NICKNAME _ INVALID " , 
 " Invalid nickname . Valid nickname should contain from 5 to 32 characters , and may consist of latin characters , numbers and underscores " , false , None ) 
 + val NameInvalid = RpcError ( 400 , " NAME _ INVALID " , " Invalid name . Valid name should not be empty or contain bad symbols " , false , None ) 
 val NicknameBusy = RpcError ( 400 , " NICKNAME _ BUSY " , " This nickname already belongs some other user , we are sorry ! " , false , None ) 
 val AboutTooLong = RpcError ( 400 , " ABOUT _ TOO _ LONG " , 
 " About is too long . It should be no longer then 255 characters " , false , None ) 
 } 
 
 - final class ProfileServiceImpl ( ) ( 
 - implicit 
 - actorSystem : ActorSystem 
 - ) extends ProfileService { 
 + final class ProfileServiceImpl ( ) ( implicit system : ActorSystem ) extends ProfileService { 
 
 import FileHelpers . _ 
 import ImageUtils . _ 
 
 - override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 + override implicit val ec : ExecutionContext = system . dispatcher 
 
 private implicit val timeout = Timeout ( 5 . seconds ) 
 / / TODO : configurable 
 - private val db : Database = DbExtension ( actorSystem ) . db 
 - private val userExt = UserExtension ( actorSystem ) 
 - private implicit val socialRegion : SocialManagerRegion = SocialExtension ( actorSystem ) . region 
 - private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( actorSystem ) . fsAdapter 
 + private val db : Database = DbExtension ( system ) . db 
 + private val userExt = UserExtension ( system ) 
 + private implicit val socialRegion : SocialManagerRegion = SocialExtension ( system ) . region 
 + private implicit val fsAdapter : FileStorageAdapter = FileStorageExtension ( system ) . fsAdapter 
 
 override def jhandleEditAvatar ( fileLocation : ApiFileLocation , clientData : ClientData ) : Future [ HandlerResult [ ResponseEditAvatar ] ] = { 
 / / TODO : flatten 
 @ @ - 80 , 14 + 78 , 14 @ @ final class ProfileServiceImpl ( ) ( 
 db . run ( toDBIOAction ( authorizedAction ) ) 
 } 
 
 - override def jhandleEditName ( name : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 - val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 - DBIO . from ( userExt . changeName ( client . userId , name ) map { 
 - case SeqState ( seq , state ) ⇒ Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 - } ) 
 + override def jhandleEditName ( name : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = 
 + authorized ( clientData ) { implicit client ⇒ 
 + for { 
 + SeqState ( seq , state ) ← userExt . changeName ( client . userId , name ) 
 + } yield Ok ( ResponseSeq ( seq , state . toByteArray ) ) 
 + } recover { 
 + case UserErrors . InvalidName ⇒ Error ( ProfileErrors . NameInvalid ) 
 } 
 - db . run ( toDBIOAction ( authorizedAction ) ) 
 - } 
 
 def jhandleEditNickName ( nickname : Option [ String ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 authorized ( clientData ) { implicit client ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 index 79e6807 . . d745804 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 @ @ - 39 , 6 + 39 , 8 @ @ final class ProfileServiceSpec 
 it should " respond with error on invalid locale " in profile . invalidPreferredLanguages 
 it should " respond with error on same preferred languages " in profile . samePreferredLanguages 
 
 + " Edit name " should " not allow to use empty name " in profile . editNameEmpty 
 + 
 implicit lazy val service = new ProfileServiceImpl 
 implicit lazy val filesService = new FilesServiceImpl 
 
 @ @ - 299 , 5 + 301 , 19 @ @ final class ProfileServiceSpec 
 } 
 } 
 } 
 + 
 + def editNameEmpty ( ) = { 
 + val ( user , authId , authSid , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + 
 + val clientData1 = ClientData ( authId , sessionId , Some ( AuthData ( user . id , authSid ) ) ) 
 + 
 + whenReady ( service . jhandleEditName ( " " , clientData ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( e ) ⇒ e shouldEqual ProfileErrors . NameInvalid 
 + } 
 + } 
 + 
 + } 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 index c11aff2 . . d50d6e6 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 @ @ - 25 , 5 + 25 , 5 @ @ trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ 
 } 
 } 
 
 - private def formatAuthored ( authorName : String , message : String ) : String = s " $ { authorName } : $ { message } " 
 + private def formatAuthored ( authorName : String , message : String ) : String = s " $ authorName : $ message " 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index a8d7c13 . . 56cc358 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 116 , 14 + 116 , 14 @ @ private [ user ] trait UserCommandHandlers extends UpdateCounters { 
 ) 
 
 val result = if ( user . authIds . nonEmpty ) { 
 - ( for { 
 + for { 
 senderUser ← UserOffice . getApiStruct ( senderUserId , userId , getAuthIdUnsafe ( user ) ) 
 senderName = senderUser . localName . getOrElse ( senderUser . name ) 
 pushText = getPushText ( message , senderName , userId ) 
 counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) 
 _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None , isFat = false ) 
 _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , Some ( pushText ) , isFat ) 
 - } yield DeliverMessageAck ( ) ) 
 + } yield DeliverMessageAck ( ) 
 } else { 
 Future . successful ( DeliverMessageAck ( ) ) 
 } 
 @ @ - 194 , 9 + 194 , 10 @ @ private [ user ] trait UserCommandHandlers extends UpdateCounters { 
 val serviceMessage = ServiceMessages . contactRegistered ( user . id ) 
 / / FIXME : # perf broadcast updates using broadcastUpdateAll to serialize update once 
 val actions = contacts map { contact ⇒ 
 + val localName = contact . name . getOrElse ( user . name ) 
 for { 
 - _ ← p . contact . UserPhoneContact . createOrRestore ( contact . ownerUserId , user . id , phoneNumber , Some ( user . name ) , user . accessSalt ) 
 - _ ← DBIO . from ( UserOffice . broadcastUserUpdate ( contact . ownerUserId , update , Some ( s " $ { contact . name . getOrElse ( user . name ) } registered " ) , isFat = true ) ) 
 + _ ← p . contact . UserPhoneContact . createOrRestore ( contact . ownerUserId , user . id , phoneNumber , Some ( localName ) , user . accessSalt ) 
 + _ ← DBIO . from ( UserOffice . broadcastUserUpdate ( contact . ownerUserId , update , Some ( s " $ localName registered " ) , isFat = true ) ) 
 _ ← HistoryUtils . writeHistoryMessage ( 
 models . Peer . privat ( user . id ) , 
 models . Peer . privat ( contact . ownerUserId ) , 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala 
 index 2b6f064 . . 85d592a 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserPhoneContact . scala 
 @ @ - 14 , 7 + 14 , 7 @ @ object UserPhoneContact { 
 val pcontacts = TableQuery [ UserPhoneContactTable ] 
 
 def createOrRestore ( ownerUserId : Int , contactUserId : Int , phoneNumber : Long , name : Option [ String ] , accessSalt : String ) = { 
 - val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , false ) 
 + val contact = models . contact . UserPhoneContact ( phoneNumber , ownerUserId , contactUserId , name , accessSalt , isDeleted = false ) 
 pcontacts . insertOrUpdate ( contact ) 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 index 34e3c82 . . 7b93854 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 @ @ - 3 , 6 + 3 , 8 @ @ package im . actor . server . api . rpc . service 
 import java . net . URLEncoder 
 import java . time . { LocalDateTime , ZoneOffset } 
 
 + import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl 
 + 
 import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . Random 
 import scalaz . \ / 
 @ @ - 13 , 7 + 15 , 7 @ @ import org . scalatest . Inside . _ 
 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . auth . _ 
 - import im . actor . api . rpc . contacts . UpdateContactRegistered 
 + import im . actor . api . rpc . contacts . { ResponseGetContacts , PhoneToImport , UpdateContactRegistered } 
 import im . actor . api . rpc . misc . ResponseVoid 
 import im . actor . api . rpc . users . { ContactRecord , ContactType , Sex } 
 import im . actor . server . activation . internal . { ActivationConfig , InternalCodeActivation } 
 @ @ - 66 , 6 + 68 , 8 @ @ final class AuthServiceSpec 
 
 it should " register unregistered contacts and send updates " in s . e90 
 
 + it should " register unregistered contacts with local name " in s . e91 
 + 
 " AuthTransaction and AuthSmsCode " should " be invalidated after sign in process successfully completed " in s . e10 
 
 it should " be invalidated after sign up process successfully completed " in s . e11 
 @ @ - 119 , 6 + 123 , 7 @ @ final class AuthServiceSpec 
 val activationContext = InternalCodeActivation . newContext ( activationConfig , new DummySmsEngine , null ) 
 implicit val service = new auth . AuthServiceImpl ( activationContext , mediator ) 
 implicit val rpcApiService = system . actorOf ( RpcApiService . props ( Seq ( service ) ) ) 
 + implicit val contactService = new ContactsServiceImpl 
 
 val correctUri = " https : / / actor . im / registration " 
 val correctAuthCode = " 0000 " 
 @ @ - 439 , 6 + 444 , 58 @ @ final class AuthServiceSpec 
 } 
 } 
 
 + def e91 ( ) = { 
 + val phoneNumber = buildPhone ( ) 
 + val userName = " Rock Jam " 
 + val userSex = Some ( Sex . Male ) 
 + val authId = createAuthId ( ) 
 + val sessionId = createSessionId ( ) 
 + val unregClientData = ClientData ( authId , sessionId , None ) 
 + 
 + val ( regUser , regAuthId , _ ) = createUser ( ) 
 + val localName = Some ( " Bloody wild goat " ) 
 + val regClientData = ClientData ( regAuthId , sessionId , Some ( regUser . id ) ) 
 + 
 + { 
 + implicit val clientData = regClientData 
 + val unregPhones = Vector ( PhoneToImport ( phoneNumber , localName ) ) 
 + whenReady ( contactService . handleImportContacts ( unregPhones , Vector . empty ) ) ( _ ⇒ ( ) ) 
 + } 
 + 
 + sendSessionHello ( authId , sessionId ) 
 + 
 + { 
 + implicit val clientData = unregClientData 
 + val transactionHash = 
 + whenReady ( startPhoneAuth ( phoneNumber ) ) { resp ⇒ 
 + resp should matchPattern { case Ok ( ResponseStartPhoneAuth ( _ , false ) ) ⇒ } 
 + resp . toOption . get . transactionHash 
 + } 
 + whenReady ( service . handleValidateCode ( transactionHash , correctAuthCode ) ) ( _ ⇒ ( ) ) 
 + whenReady ( service . handleSignUp ( transactionHash , userName , userSex ) ) ( _ . toOption . get . user ) 
 + } 
 + 
 + { 
 + implicit val clientData = regClientData 
 + expectUpdate [ UpdateContactRegistered ] ( 0 , Array . empty , UpdateContactRegistered . header ) ( identity ) 
 + 
 + whenReady ( db . run ( persist . contact . UnregisteredPhoneContact . find ( phoneNumber ) ) ) { 
 + _ shouldBe empty 
 + } 
 + 
 + whenReady ( contactService . handleGetContacts ( " wrongHash " ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseGetContacts ( users , false ) ) ⇒ 
 + users should have length 1 
 + val newUser = users . head 
 + newUser . name shouldEqual userName 
 + newUser . localName shouldEqual localName 
 + } 
 + } 
 + } 
 + 
 + } 
 + 
 def e10 ( ) = { 
 val ( user , authId , phoneNumber ) = createUser ( ) 
 val sessionId = createSessionId ( )
