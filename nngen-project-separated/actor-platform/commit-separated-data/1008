BLEU SCORE: 0.2824099048856541

TEST MSG: fix ( core ) : Fixing key manager initialization
GENERATED MSG: feat ( core ) : More lightweight Encrypted Session initialization

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist < nl > index 0350d1f . . cf167e6 100644 < nl > - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 < nl > @ @ - 34 , 7 + 34 , 7 @ @ < nl > 	 	 < / dict > < nl > 	 < / array > < nl > 	 < key > CFBundleVersion < / key > < nl > - 	 < string > 677 < / string > < nl > + 	 < string > 680 < / string > < nl > 	 < key > Fabric < / key > < nl > 	 < dict > < nl > 	 	 < key > APIKey < / key > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index f37cee2 . . 2bf61c3 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 58 , 6 + 58 , 8 @ @ public class KeyManagerActor extends ModuleActor { < nl > @ Override < nl > public void preStart ( ) { < nl > < nl > + Log . d ( TAG , " Starting KeyManager . . . " ) ; < nl > + < nl > encryptionKeysStorage = Storage . createKeyValue ( " encryption _ keys " ) ; < nl > < nl > ownKeys = null ; < nl > @ @ - 120 , 6 + 122 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > signature ) ) ; < nl > } < nl > < nl > + Log . d ( TAG , " Creation of new key group " ) ; < nl > api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Consumer < ResponseCreateNewKeyGroup > ( ) { < nl > @ Override < nl > public void apply ( ResponseCreateNewKeyGroup response ) { < nl > @ @ - 135 , 7 + 138 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > < nl > / / Just ignore < nl > } < nl > - } ) ; < nl > + } ) . done ( self ( ) ) ; < nl > } else { < nl > onMainKeysReady ( ) ; < nl > } < nl > @ @ - 192 , 29 + 195 , 31 @ @ public class KeyManagerActor extends ModuleActor { < nl > signature ) ) ; < nl > } < nl > < nl > - request ( new RequestUploadEphermalKey ( ownKeys . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) , new RpcCallback < ResponseVoid > ( ) { < nl > - @ Override < nl > - public void onResult ( ResponseVoid response ) { < nl > - ownKeys = ownKeys . markAsUploaded ( pendingEphermalKeys . toArray ( new PrivateKey [ pendingEphermalKeys . size ( ) ] ) ) ; < nl > - encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; < nl > - onAllKeysReady ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onError ( RpcException e ) { < nl > - Log . w ( TAG , " Ephemeral keys upload error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > - < nl > - / / Ignore < nl > - } < nl > - } ) ; < nl > + api ( new RequestUploadEphermalKey ( ownKeys . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) ) < nl > + . then ( new Consumer < ResponseVoid > ( ) { < nl > + @ Override < nl > + public void apply ( ResponseVoid responseVoid ) { < nl > + ownKeys = ownKeys . markAsUploaded ( pendingEphermalKeys . toArray ( new PrivateKey [ pendingEphermalKeys . size ( ) ] ) ) ; < nl > + encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; < nl > + onAllKeysReady ( ) ; < nl > + } < nl > + } ) < nl > + . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + Log . w ( TAG , " Ephemeral keys upload error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + < nl > + / / Ignore . This will freeze all encryption operations . < nl > + } < nl > + } ) . done ( self ( ) ) ; < nl > } else { < nl > onAllKeysReady ( ) ; < nl > } < nl > } < nl > < nl > private void onAllKeysReady ( ) { < nl > - Log . d ( TAG , " All Keys are ready " ) ; < nl > + Log . d ( TAG , " Key Manager started " ) ; < nl > / / Now we can start receiving or sending encrypted messages < nl > isReady = true ; < nl > unstashAll ( ) ;
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 2d55d49 . . bac687f 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 153 , 14 + 153 , 19 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > < nl > if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > - Log . d ( TAG , " Decryption with key group " ) ; < nl > + Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; < nl > byte [ ] encKey = null ; < nl > for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; < nl > if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > encKey = k . getEncryptedKey ( ) ; < nl > break ; < nl > } < nl > } < nl > + if ( encKey = = null ) { < nl > + Log . d ( TAG , " Unable to find encryption key in key group " ) ; < nl > + return ; < nl > + } < nl > < nl > Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 50a0cc1 . . 0ff4699 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 20 , 7 + 20 , 6 @ @ import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > - import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > @ @ - 48 , 13 + 47 , 9 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > private OwnPrivateKey currentOwnKey ; < nl > private UserPublicKey currentTheirKey ; < nl > < nl > - private byte [ ] rootChainKey ; < nl > - < nl > private int outIndex = 0 ; < nl > private int inIndex = 0 ; < nl > < nl > - private boolean isReady = false ; < nl > - < nl > public EncryptedSessionActor ( ModuleContext context , int uid , UserKeysGroup encryptionKeyGroup ) { < nl > super ( context ) ; < nl > this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; < nl > @ @ - 65 , 36 + 60 , 104 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > @ Override < nl > public void preStart ( ) { < nl > - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > - Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > - @ Override < nl > - public void onResult ( Object obj ) { < nl > - Log . d ( TAG , " Own keys loaded " ) ; < nl > - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > - ownIdentityKey = res . getIdentityKey ( ) ; < nl > - ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > - currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; < nl > - onOwnReady ( ) ; < nl > - } < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > + ownIdentityKey = res . getIdentityKey ( ) ; < nl > + ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > + currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; < nl > + } < nl > < nl > - @ Override < nl > - public void onError ( Exception e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Own keys error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . w ( TAG , " Own keys error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > < nl > - } < nl > - } ) ; < nl > - } else { < nl > - onOwnReady ( ) ; < nl > - } < nl > + / / Crashing Actor < nl > + throw new RuntimeException ( e ) ; < nl > + } < nl > + } ) ; < nl > } < nl > < nl > - private void onOwnReady ( ) { < nl > - Log . w ( TAG , " Own keys ready " ) ; < nl > - < nl > + / / private void onOwnReady ( ) { < nl > + / / Log . w ( TAG , " Own keys ready " ) ; < nl > + / / < nl > + / / if ( theirEphermalKey0 = = null ) { < nl > + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + / / @ Override < nl > + / / public void onResult ( ResponsePublicKeys response ) { < nl > + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + / / Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / < nl > + / / @ Override < nl > + / / public void onError ( RpcException e ) { < nl > + / / / / Nothing to do < nl > + / / Log . w ( TAG , " Their ephemeral error " ) ; < nl > + / / Log . e ( TAG , e ) ; < nl > + / / } < nl > + / / } ) ; < nl > + / / } else { < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / private void onTheirReady0 ( ) { < nl > + / / Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > + / / < nl > + / / if ( currentTheirKey = = null ) { < nl > + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + / / @ Override < nl > + / / public void onResult ( ResponsePublicKeys response ) { < nl > + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + / / Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + / / currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > + / / allSet ( ) ; < nl > + / / } < nl > + / / < nl > + / / @ Override < nl > + / / public void onError ( RpcException e ) { < nl > + / / / / Nothing to do < nl > + / / Log . w ( TAG , " Their ephemeral error " ) ; < nl > + / / Log . e ( TAG , e ) ; < nl > + / / } < nl > + / / } ) ; < nl > + / / } else { < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / private void allSet ( ) { < nl > + / / Log . d ( TAG , " All keys are ready " ) ; < nl > + / / isReady = true ; < nl > + / / < nl > + / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > + / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > + / / rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > + / / master _ secret ) ; < nl > + / / < nl > + / / unstashAll ( ) ; < nl > + / / } < nl > + < nl > + private boolean assumeEnabled ( final Runnable onOk ) { < nl > if ( theirEphermalKey0 = = null ) { < nl > + Log . w ( TAG , " Loading their ephemeral key0 " ) ; < nl > request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > @ @ - 105 , 7 + 168 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > - onTheirReady0 ( ) ; < nl > + onOk . run ( ) ; < nl > } < nl > < nl > @ Override < nl > @ @ - 115 , 15 + 178 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . e ( TAG , e ) ; < nl > } < nl > } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > + return false ; < nl > } < nl > - } < nl > - < nl > - private void onTheirReady0 ( ) { < nl > - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > - < nl > if ( currentTheirKey = = null ) { < nl > + Log . w ( TAG , " Loading their ephemeral key " ) ; < nl > request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > @ @ - 134 , 7 + 192 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > - allSet ( ) ; < nl > + onOk . run ( ) ; < nl > } < nl > < nl > @ Override < nl > @ @ - 144 , 38 + 202 , 58 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . e ( TAG , e ) ; < nl > } < nl > } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > + return false ; < nl > + } < nl > + return true ; < nl > + } < nl > + < nl > + private void onEncrypt ( final byte [ ] data , final Future future ) { < nl > + < nl > + if ( ! assumeEnabled ( new Runnable ( ) { < nl > + @ Override < nl > + public void run ( ) { < nl > + onEncrypt ( data , future ) ; < nl > + } < nl > + } ) ) { < nl > + return ; < nl > } < nl > + < nl > + onEncrypt ( data , < nl > + ownEphermalKey0 , < nl > + currentOwnKey , < nl > + theirEphermalKey0 , < nl > + currentTheirKey , < nl > + future ) ; < nl > } < nl > < nl > - private void allSet ( ) { < nl > - Log . d ( TAG , " All keys are ready " ) ; < nl > - isReady = true ; < nl > + private void onEncrypt ( byte [ ] data , < nl > + OwnPrivateKey ownEphermalKey0 , < nl > + OwnPrivateKey ownEphermalKey , < nl > + UserPublicKey theirEphermalKey0 , < nl > + UserPublicKey theirEphermalKey , < nl > + Future future ) { < nl > + < nl > + Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > < nl > byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > - rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > master _ secret ) ; < nl > < nl > - unstashAll ( ) ; < nl > - } < nl > - < nl > - private void onEncrypt ( byte [ ] data , Future future ) { < nl > - < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > - Curve25519 . keyGenPublic ( currentOwnKey . getKey ( ) ) , < nl > - currentTheirKey . getPublicKey ( ) , < nl > + Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , < nl > + theirEphermalKey . getPublicKey ( ) , < nl > ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / < nl > < nl > byte [ ] encrypted ; < nl > @ @ - 187 , 41 + 265 , 22 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > - < nl > - < nl > - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > - < nl > - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > - < nl > - < nl > - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > - < nl > - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > + future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; < nl > } < nl > < nl > private void onDecrypt ( final byte [ ] data , final Future future ) { < nl > - final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + Log . d ( TAG , " onDecrypt " ) ; < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + < nl > + final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > < nl > - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; < nl > Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > @ @ - 247 , 8 + 306 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ArrayList < Long > keys = new ArrayList < Long > ( ) ; < nl > keys . add ( ownEphermalKey0Id ) ; < nl > - < nl > - request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; < nl > @ @ - 295 , 6 + 353 , 8 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > int index , < nl > Future future ) { < nl > < nl > + Log . d ( TAG , " onDecrypt2 " ) ; < nl > + < nl > byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( < nl > new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , < nl > @ @ - 313 , 16 + 373 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > @ Override < nl > - public void onReceive ( Object message ) { < nl > - Log . d ( TAG , " msg : " + message ) ; < nl > - if ( ! isReady & & message instanceof AskRequest ) { < nl > - stash ( ) ; < nl > - return ; < nl > - } < nl > - super . onReceive ( message ) ; < nl > - } < nl > - < nl > - @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > if ( message instanceof EncryptPackage ) { < nl > onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > index a24abaa . . 72ceb4c 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . core . modules . encryption . entity ; < nl > < nl > import java . io . IOException ; < nl > + import java . util . ArrayList ; < nl > import java . util . List ; < nl > < nl > import im . actor . core . modules . encryption . Configuration ; < nl > @ @ - 77 , 7 + 78 , 13 @ @ public class OwnKeys extends BserObject { < nl > } < nl > < nl > public OwnPrivateKeyUploadable pickRandomEphemeralKey ( ) { < nl > - return ephemeralKeys [ RandomUtils . randomId ( ephemeralKeys . length ) ] ; < nl > + ArrayList < OwnPrivateKeyUploadable > uploadedKeys = new ArrayList < OwnPrivateKeyUploadable > ( ) ; < nl > + for ( OwnPrivateKeyUploadable u : ephemeralKeys ) { < nl > + if ( u . isUploaded ( ) ) { < nl > + uploadedKeys . add ( u ) ; < nl > + } < nl > + } < nl > + return uploadedKeys . get ( RandomUtils . randomId ( uploadedKeys . size ( ) ) ) ; < nl > } < nl > < nl > @ Override

TEST DIFF:
diff - - git a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 
 index 0350d1f . . cf167e6 100644 
 - - - a / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 + + + b / actor - sdk / sdk - core - ios / ActorApp / Supporting Files / Info . plist 	 
 @ @ - 34 , 7 + 34 , 7 @ @ 
 	 	 < / dict > 
 	 < / array > 
 	 < key > CFBundleVersion < / key > 
 - 	 < string > 677 < / string > 
 + 	 < string > 680 < / string > 
 	 < key > Fabric < / key > 
 	 < dict > 
 	 	 < key > APIKey < / key > 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index f37cee2 . . 2bf61c3 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 58 , 6 + 58 , 8 @ @ public class KeyManagerActor extends ModuleActor { 
 @ Override 
 public void preStart ( ) { 
 
 + Log . d ( TAG , " Starting KeyManager . . . " ) ; 
 + 
 encryptionKeysStorage = Storage . createKeyValue ( " encryption _ keys " ) ; 
 
 ownKeys = null ; 
 @ @ - 120 , 6 + 122 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 signature ) ) ; 
 } 
 
 + Log . d ( TAG , " Creation of new key group " ) ; 
 api ( new RequestCreateNewKeyGroup ( apiEncryptionKey , encryption , keys , keySignatures ) ) . then ( new Consumer < ResponseCreateNewKeyGroup > ( ) { 
 @ Override 
 public void apply ( ResponseCreateNewKeyGroup response ) { 
 @ @ - 135 , 7 + 138 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 
 / / Just ignore 
 } 
 - } ) ; 
 + } ) . done ( self ( ) ) ; 
 } else { 
 onMainKeysReady ( ) ; 
 } 
 @ @ - 192 , 29 + 195 , 31 @ @ public class KeyManagerActor extends ModuleActor { 
 signature ) ) ; 
 } 
 
 - request ( new RequestUploadEphermalKey ( ownKeys . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) , new RpcCallback < ResponseVoid > ( ) { 
 - @ Override 
 - public void onResult ( ResponseVoid response ) { 
 - ownKeys = ownKeys . markAsUploaded ( pendingEphermalKeys . toArray ( new PrivateKey [ pendingEphermalKeys . size ( ) ] ) ) ; 
 - encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; 
 - onAllKeysReady ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onError ( RpcException e ) { 
 - Log . w ( TAG , " Ephemeral keys upload error " ) ; 
 - Log . e ( TAG , e ) ; 
 - 
 - / / Ignore 
 - } 
 - } ) ; 
 + api ( new RequestUploadEphermalKey ( ownKeys . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) ) 
 + . then ( new Consumer < ResponseVoid > ( ) { 
 + @ Override 
 + public void apply ( ResponseVoid responseVoid ) { 
 + ownKeys = ownKeys . markAsUploaded ( pendingEphermalKeys . toArray ( new PrivateKey [ pendingEphermalKeys . size ( ) ] ) ) ; 
 + encryptionKeysStorage . addOrUpdateItem ( 0 , ownKeys . toByteArray ( ) ) ; 
 + onAllKeysReady ( ) ; 
 + } 
 + } ) 
 + . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + Log . w ( TAG , " Ephemeral keys upload error " ) ; 
 + Log . e ( TAG , e ) ; 
 + 
 + / / Ignore . This will freeze all encryption operations . 
 + } 
 + } ) . done ( self ( ) ) ; 
 } else { 
 onAllKeysReady ( ) ; 
 } 
 } 
 
 private void onAllKeysReady ( ) { 
 - Log . d ( TAG , " All Keys are ready " ) ; 
 + Log . d ( TAG , " Key Manager started " ) ; 
 / / Now we can start receiving or sending encrypted messages 
 isReady = true ; 
 unstashAll ( ) ;

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 2d55d49 . . bac687f 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 153 , 14 + 153 , 19 @ @ public class EncryptedPeerActor extends ModuleActor { 
 byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 
 if ( sessions . containsKey ( senderKeyGroup ) ) { 
 - Log . d ( TAG , " Decryption with key group " ) ; 
 + Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; 
 byte [ ] encKey = null ; 
 for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; 
 if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 encKey = k . getEncryptedKey ( ) ; 
 break ; 
 } 
 } 
 + if ( encKey = = null ) { 
 + Log . d ( TAG , " Unable to find encryption key in key group " ) ; 
 + return ; 
 + } 
 
 Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 50a0cc1 . . 0ff4699 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 20 , 7 + 20 , 6 @ @ import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 - import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 @ @ - 48 , 13 + 47 , 9 @ @ public class EncryptedSessionActor extends ModuleActor { 
 private OwnPrivateKey currentOwnKey ; 
 private UserPublicKey currentTheirKey ; 
 
 - private byte [ ] rootChainKey ; 
 - 
 private int outIndex = 0 ; 
 private int inIndex = 0 ; 
 
 - private boolean isReady = false ; 
 - 
 public EncryptedSessionActor ( ModuleContext context , int uid , UserKeysGroup encryptionKeyGroup ) { 
 super ( context ) ; 
 this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; 
 @ @ - 65 , 36 + 60 , 104 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 @ Override 
 public void preStart ( ) { 
 - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 - Log . d ( TAG , " Loading own keys for conversation " ) ; 
 - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 - @ Override 
 - public void onResult ( Object obj ) { 
 - Log . d ( TAG , " Own keys loaded " ) ; 
 - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 - ownIdentityKey = res . getIdentityKey ( ) ; 
 - ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 - currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; 
 - onOwnReady ( ) ; 
 - } 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 + ownIdentityKey = res . getIdentityKey ( ) ; 
 + ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 + currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; 
 + } 
 
 - @ Override 
 - public void onError ( Exception e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Own keys error " ) ; 
 - Log . e ( TAG , e ) ; 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . w ( TAG , " Own keys error " ) ; 
 + Log . e ( TAG , e ) ; 
 
 - } 
 - } ) ; 
 - } else { 
 - onOwnReady ( ) ; 
 - } 
 + / / Crashing Actor 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } ) ; 
 } 
 
 - private void onOwnReady ( ) { 
 - Log . w ( TAG , " Own keys ready " ) ; 
 - 
 + / / private void onOwnReady ( ) { 
 + / / Log . w ( TAG , " Own keys ready " ) ; 
 + / / 
 + / / if ( theirEphermalKey0 = = null ) { 
 + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + / / @ Override 
 + / / public void onResult ( ResponsePublicKeys response ) { 
 + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + / / Log . w ( TAG , " No ephemeral keys found " ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / 
 + / / @ Override 
 + / / public void onError ( RpcException e ) { 
 + / / / / Nothing to do 
 + / / Log . w ( TAG , " Their ephemeral error " ) ; 
 + / / Log . e ( TAG , e ) ; 
 + / / } 
 + / / } ) ; 
 + / / } else { 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / } 
 + / / 
 + / / private void onTheirReady0 ( ) { 
 + / / Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 + / / 
 + / / if ( currentTheirKey = = null ) { 
 + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + / / @ Override 
 + / / public void onResult ( ResponsePublicKeys response ) { 
 + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + / / Log . w ( TAG , " No ephemeral keys found " ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + / / currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 + / / allSet ( ) ; 
 + / / } 
 + / / 
 + / / @ Override 
 + / / public void onError ( RpcException e ) { 
 + / / / / Nothing to do 
 + / / Log . w ( TAG , " Their ephemeral error " ) ; 
 + / / Log . e ( TAG , e ) ; 
 + / / } 
 + / / } ) ; 
 + / / } else { 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / } 
 + / / 
 + / / private void allSet ( ) { 
 + / / Log . d ( TAG , " All keys are ready " ) ; 
 + / / isReady = true ; 
 + / / 
 + / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 + / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 + / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 + / / rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 + / / master _ secret ) ; 
 + / / 
 + / / unstashAll ( ) ; 
 + / / } 
 + 
 + private boolean assumeEnabled ( final Runnable onOk ) { 
 if ( theirEphermalKey0 = = null ) { 
 + Log . w ( TAG , " Loading their ephemeral key0 " ) ; 
 request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 @ @ - 105 , 7 + 168 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 - onTheirReady0 ( ) ; 
 + onOk . run ( ) ; 
 } 
 
 @ Override 
 @ @ - 115 , 15 + 178 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . e ( TAG , e ) ; 
 } 
 } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 + return false ; 
 } 
 - } 
 - 
 - private void onTheirReady0 ( ) { 
 - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 - 
 if ( currentTheirKey = = null ) { 
 + Log . w ( TAG , " Loading their ephemeral key " ) ; 
 request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 @ @ - 134 , 7 + 192 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 - allSet ( ) ; 
 + onOk . run ( ) ; 
 } 
 
 @ Override 
 @ @ - 144 , 38 + 202 , 58 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . e ( TAG , e ) ; 
 } 
 } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + private void onEncrypt ( final byte [ ] data , final Future future ) { 
 + 
 + if ( ! assumeEnabled ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + onEncrypt ( data , future ) ; 
 + } 
 + } ) ) { 
 + return ; 
 } 
 + 
 + onEncrypt ( data , 
 + ownEphermalKey0 , 
 + currentOwnKey , 
 + theirEphermalKey0 , 
 + currentTheirKey , 
 + future ) ; 
 } 
 
 - private void allSet ( ) { 
 - Log . d ( TAG , " All keys are ready " ) ; 
 - isReady = true ; 
 + private void onEncrypt ( byte [ ] data , 
 + OwnPrivateKey ownEphermalKey0 , 
 + OwnPrivateKey ownEphermalKey , 
 + UserPublicKey theirEphermalKey0 , 
 + UserPublicKey theirEphermalKey , 
 + Future future ) { 
 + 
 + Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 
 byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 - rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 master _ secret ) ; 
 
 - unstashAll ( ) ; 
 - } 
 - 
 - private void onEncrypt ( byte [ ] data , Future future ) { 
 - 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 - Curve25519 . keyGenPublic ( currentOwnKey . getKey ( ) ) , 
 - currentTheirKey . getPublicKey ( ) , 
 + Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , 
 + theirEphermalKey . getPublicKey ( ) , 
 ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / 
 
 byte [ ] encrypted ; 
 @ @ - 187 , 41 + 265 , 22 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 - 
 - 
 - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 - 
 - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 - 
 - 
 - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 - 
 - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 + future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; 
 } 
 
 private void onDecrypt ( final byte [ ] data , final Future future ) { 
 - final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + Log . d ( TAG , " onDecrypt " ) ; 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + 
 + final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 
 - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; 
 Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 @ @ - 247 , 8 + 306 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ArrayList < Long > keys = new ArrayList < Long > ( ) ; 
 keys . add ( ownEphermalKey0Id ) ; 
 - 
 - request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; 
 @ @ - 295 , 6 + 353 , 8 @ @ public class EncryptedSessionActor extends ModuleActor { 
 int index , 
 Future future ) { 
 
 + Log . d ( TAG , " onDecrypt2 " ) ; 
 + 
 byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( 
 new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , 
 @ @ - 313 , 16 + 373 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 @ Override 
 - public void onReceive ( Object message ) { 
 - Log . d ( TAG , " msg : " + message ) ; 
 - if ( ! isReady & & message instanceof AskRequest ) { 
 - stash ( ) ; 
 - return ; 
 - } 
 - super . onReceive ( message ) ; 
 - } 
 - 
 - @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 if ( message instanceof EncryptPackage ) { 
 onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 index a24abaa . . 72ceb4c 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . core . modules . encryption . entity ; 
 
 import java . io . IOException ; 
 + import java . util . ArrayList ; 
 import java . util . List ; 
 
 import im . actor . core . modules . encryption . Configuration ; 
 @ @ - 77 , 7 + 78 , 13 @ @ public class OwnKeys extends BserObject { 
 } 
 
 public OwnPrivateKeyUploadable pickRandomEphemeralKey ( ) { 
 - return ephemeralKeys [ RandomUtils . randomId ( ephemeralKeys . length ) ] ; 
 + ArrayList < OwnPrivateKeyUploadable > uploadedKeys = new ArrayList < OwnPrivateKeyUploadable > ( ) ; 
 + for ( OwnPrivateKeyUploadable u : ephemeralKeys ) { 
 + if ( u . isUploaded ( ) ) { 
 + uploadedKeys . add ( u ) ; 
 + } 
 + } 
 + return uploadedKeys . get ( RandomUtils . randomId ( uploadedKeys . size ( ) ) ) ; 
 } 
 
 @ Override
