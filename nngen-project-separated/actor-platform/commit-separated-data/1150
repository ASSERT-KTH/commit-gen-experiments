BLEU SCORE: 0.3203558799120807

TEST MSG: feat ( server : rpc ) : raw service + spec
GENERATED MSG: feat ( server : core , rpc ) : webactions service implementation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala < nl > new file mode 100644 < nl > index 0000000 . . e0d918b < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala < nl > @ @ - 0 , 0 + 1 , 21 @ @ < nl > + package im . actor . rpc . raw < nl > + < nl > + import akka . actor . ActorSystem < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . collections . ApiRawValue < nl > + import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + / * * < nl > + * Base class for raw service handlers . < nl > + * / < nl > + abstract class RawApiService ( system : ActorSystem ) { < nl > + < nl > + type Response = Future [ RpcError Xor ApiRawValue ] < nl > + < nl > + type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Response ] < nl > + < nl > + def handleRequests : Handler < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala < nl > deleted file mode 100644 < nl > index e3bf3e0 . . 0000000 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala < nl > + + + / dev / null < nl > @ @ - 1 , 21 + 0 , 0 @ @ < nl > - package im . actor . rpc . raw < nl > - < nl > - import akka . actor . ActorSystem < nl > - import cats . data . Xor < nl > - import im . actor . api . rpc . collections . ApiRawValue < nl > - import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > - < nl > - import scala . concurrent . Future < nl > - < nl > - / * * < nl > - * Base class for raw service handlers . < nl > - * / < nl > - abstract class RawServiceHandler ( system : ActorSystem ) { < nl > - < nl > - type RawFunction = AuthorizedClientData ⇒ RawAuthorizedFunction < nl > - < nl > - type RawAuthorizedFunction = Option [ ApiRawValue ] ⇒ Future [ RpcError Xor ApiRawValue ] < nl > - < nl > - def handle : PartialFunction [ String , RawFunction ] < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > index 8237db1 . . 0ef4c32 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > @ @ - 2 , 34 + 2 , 37 @ @ package im . actor . server . api . rpc < nl > < nl > import akka . actor . _ < nl > import cats . data . Xor < nl > + import im . actor . api . rpc . collections . ApiRawValue < nl > + import im . actor . api . rpc . FutureResultRpcCats < nl > import im . actor . api . rpc . { AuthorizedClientData , CommonErrors , RpcError } < nl > - import im . actor . rpc . raw . RawServiceHandler < nl > + import im . actor . rpc . raw . RawApiService < nl > < nl > import scala . collection . concurrent . TrieMap < nl > + import scala . concurrent . Future < nl > < nl > sealed trait RawApiExtension extends Extension < nl > < nl > private [ rpc ] final class RawApiExtensionImpl ( system : ExtendedActorSystem ) extends RawApiExtension { < nl > + import FutureResultRpcCats . _ < nl > + import system . dispatcher < nl > < nl > - private val services = TrieMap . empty [ String , RawServiceHandler ] < nl > + private val services = TrieMap . empty [ String , RawApiService ] < nl > < nl > - def register ( name : String , clazz : Class [ _ < : RawServiceHandler ] ) : Unit = { < nl > - val service = system . dynamicAccess . createInstanceFor [ RawServiceHandler ] ( clazz , List ( classOf [ ActorSystem ] → system ) ) . get < nl > + def register ( name : String , clazz : Class [ _ < : RawApiService ] ) : Unit = { < nl > + val service = system . dynamicAccess . createInstanceFor [ RawApiService ] ( clazz , List ( classOf [ ActorSystem ] → system ) ) . get < nl > register ( name , service ) < nl > } < nl > < nl > - def register ( name : String , service : RawServiceHandler ) : Unit = services . putIfAbsent ( name , service ) < nl > + def register ( name : String , service : RawApiService ) : Unit = services . putIfAbsent ( name , service ) < nl > < nl > - def register ( serviceSeq : Seq [ ( String , RawServiceHandler ) ] ) : Unit = services + + = serviceSeq < nl > + def register ( serviceSeq : Seq [ ( String , RawApiService ) ] ) : Unit = services + + = serviceSeq < nl > < nl > - def getHandlingFunction ( service : String , method : String ) ( implicit client : AuthorizedClientData ) : RpcError Xor RawServiceHandler # RawAuthorizedFunction = { < nl > - val optFunction : Option [ RawServiceHandler # RawAuthorizedFunction ] = < nl > - for { < nl > - handler ← services . get ( service ) < nl > - rawFunc ← handler . handle . lift ( method ) < nl > - } yield rawFunc ( client ) < nl > - Xor . fromOption ( optFunction , CommonErrors . UnsupportedRequest ) < nl > - } < nl > + def handle ( service : String , method : String , params : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ RpcError Xor ApiRawValue ] = < nl > + ( for { < nl > + serviceHandler ← fromOption ( CommonErrors . UnsupportedRequest ) ( services . get ( service ) ) < nl > + response ← fromOption ( CommonErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( client ) ( params ) . lift ( method ) ) < nl > + result ← fromFutureEither ( response ) < nl > + } yield result ) . value < nl > } < nl > < nl > object RawApiExtension extends ExtensionId [ RawApiExtensionImpl ] with ExtensionIdProvider { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > index d55ae43 . . 7e02f36 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > @ @ - 18 , 9 + 18 , 7 @ @ final class RawServiceImpl ( implicit system : ActorSystem ) extends RawService { < nl > < nl > override def jhandleRawRequest ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseRawRequest ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > - ( for { < nl > - func ← fromEither ( rawApiExt . getHandlingFunction ( service , method ) ) < nl > - result ← fromFutureEither ( func ( params ) ) < nl > - } yield ResponseRawRequest ( result ) ) . value map ( _ . toScalaz ) < nl > + ( for ( result ← fromFutureEither ( rawApiExt . handle ( service , method , params ) ) ) < nl > + yield ResponseRawRequest ( result ) ) . value map ( _ . toScalaz ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . da24c5f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala < nl > @ @ - 0 , 0 + 1 , 172 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . collections . _ < nl > + import im . actor . rpc . raw . RawApiService < nl > + import im . actor . server . api . rpc . RawApiExtension < nl > + import im . actor . server . api . rpc . service . raw . RawServiceImpl < nl > + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > + < nl > + import scala . collection . concurrent . TrieMap < nl > + import scala . concurrent . Future < nl > + import scala . concurrent . duration . _ < nl > + import scalaz . \ / - < nl > + < nl > + class RawServiceSpec < nl > + extends BaseAppSuite < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegion { < nl > + < nl > + behavior of " raw api service " < nl > + < nl > + it should " respond with Unsupported Request , when there is no such service " in e1 < nl > + < nl > + it should " respond with error to invalid request " in e2 < nl > + < nl > + it should " respond with result to valid request " in e3 < nl > + < nl > + it should " detect dynamically registered services " in e4 < nl > + < nl > + val service = new RawServiceImpl ( ) < nl > + < nl > + RawApiExtension ( system ) . register ( " dictionary " , new DictionaryService ( system ) ) < nl > + < nl > + val ( user , authId , authSid , _ ) = createUser ( ) < nl > + implicit val clientData : ClientData = ClientData ( authId , createSessionId ( ) , Some ( AuthData ( user . id , authSid ) ) ) < nl > + < nl > + def e1 ( ) = { < nl > + whenReady ( service . handleRawRequest ( " maps " , " getGeo " , None ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( err ) ⇒ err shouldEqual CommonErrors . UnsupportedRequest < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e2 ( ) = { < nl > + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiInt32Value ( 22 ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( err ) ⇒ err shouldEqual ServiceErrors . InvalidParams < nl > + } < nl > + } < nl > + < nl > + / / not right cause we should pass params as map , not as string < nl > + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiStringValue ( " culture " ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( err ) ⇒ err shouldEqual ServiceErrors . InvalidParams < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e3 ( ) = { < nl > + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( DictionaryMeanings . Culture ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " UNKNOWN " ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items shouldBe empty < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e4 ( ) = { < nl > + whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( err ) ⇒ err shouldEqual CommonErrors . UnsupportedRequest < nl > + } < nl > + } < nl > + < nl > + RawApiExtension ( system ) . register ( " echo " , new EchoService ( system ) ) < nl > + < nl > + whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiMapValueItem ( " echo " , ApiStringValue ( " Hello you back ! " ) ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service < nl > + < nl > + private object DictionaryMeanings { < nl > + val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " < nl > + val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " < nl > + val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " < nl > + } < nl > + < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . < nl > + * / < nl > + private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import ServiceErrors . _ < nl > + import im . actor . api . rpc . FutureResultRpcCats . _ < nl > + < nl > + implicit val timeout = Timeout ( 20 . seconds ) < nl > + private val kv = TrieMap . empty [ String , String ] < nl > + < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > + < nl > + override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > + case " getWord " ⇒ getWord ( params ) < nl > + / / case " putWord " = > putWord ( ) < nl > + } < nl > + < nl > + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Response = { < nl > + val ps = optParams flatMap { < nl > + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } < nl > + case _ ⇒ None < nl > + } < nl > + ( for { < nl > + key ← fromOption ( InvalidParams ) ( ps ) < nl > + optValue ← point ( kv . get ( key ) ) < nl > + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > + } yield ApiMapValue ( result ) ) . value < nl > + } < nl > + } < nl > + < nl > + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service < nl > + < nl > + private final class EchoService ( system : ActorSystem ) extends RawApiService ( system ) { < nl > + import ServiceErrors . _ < nl > + < nl > + override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > + case " makeEcho " ⇒ echo ( params ) < nl > + } < nl > + < nl > + def echo ( params : Option [ ApiRawValue ] ) : Response = { < nl > + val resp = extractStringFromMap ( params , " query " ) map { q ⇒ < nl > + Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) < nl > + } getOrElse Xor . left ( InvalidParams ) < nl > + Future . successful ( resp ) < nl > + } < nl > + } < nl > + < nl > + private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = < nl > + optParams flatMap { < nl > + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( ` key ` , ApiStringValue ( str ) ) ⇒ str } < nl > + case _ ⇒ None < nl > + } < nl > + < nl > + private object ServiceErrors { < nl > + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) < nl > + } < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 4d9609f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala < nl > @ @ - 0 , 0 + 1 , 46 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiMapValueItem , ApiMapValue } < nl > + import im . actor . config . ActorConfig < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . collection . JavaConversions . _ < nl > + import scala . util . Try < nl > + < nl > + object Webaction { < nl > + < nl > + / * * < nl > + * Retrieves list of all available webactions < nl > + * @ param path path ofconfig , containing list of registered webactions < nl > + * @ return mapping from webaction name to its FQN < nl > + * / < nl > + def list ( path : String ) : Map [ String , String ] = < nl > + ActorConfig . load ( ) . getConfig ( path ) . root . unwrapped . toMap map { case ( k , v ) ⇒ k → v . toString } < nl > + < nl > + def list : Map [ String , String ] = list ( " enabled - modules . webactions " ) < nl > + < nl > + / * * < nl > + * Instantiates webaction by fully qualified class name < nl > + * @ param actionFQN fully qualified class name < nl > + * @ param system actor system , required to execute actions inside webaction < nl > + * @ return ` Success ( webaction ) ` when webaction instantiation succeeds , < nl > + * and ` Failure ( exception ) ` when instantiation failed by various reasons ( no such class / wrong constuctor ) < nl > + * / < nl > + def webactionOf ( actionFQN : String , system : ActorSystem ) : Try [ Webaction ] = Try { < nl > + val constructor = Class . forName ( actionFQN ) . getConstructors ( ) ( 0 ) < nl > + constructor . newInstance ( system ) . asInstanceOf [ Webaction ] < nl > + } < nl > + < nl > + def failure ( cause : String ) : ApiMapValue = < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " error " , ApiStringValue ( cause ) ) ) ) < nl > + < nl > + def success ( message : String ) : ApiMapValue = < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " success " , ApiStringValue ( message ) ) ) ) < nl > + } < nl > + < nl > + abstract class Webaction ( system : ActorSystem ) { < nl > + def uri ( params : ApiMapValue ) : String < nl > + def regex : String < nl > + def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . 6168f4a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 75 @ @ < nl > + package im . actor . server . api . rpc . service . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . FutureResultRpc . _ < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . collections . ApiMapValue < nl > + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction , WebactionsService } < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . webactions . Webaction < nl > + import shardakka . ShardakkaExtension < nl > + import slick . dbio . DBIO < nl > + < nl > + import scala . concurrent . duration . _ < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . util . { Failure , Success } < nl > + import scalaz . { \ / , \ / - } < nl > + < nl > + object WebactionsErrors { < nl > + val WebactionNotFound = RpcError ( 404 , " WEBACTION _ NOT _ FOUND " , " Web action not found " , false , None ) < nl > + val FailedToCreateWebaction = RpcError ( 500 , " FAILED _ TO _ CREATE _ WEBACTION " , " Failed to create webaction " , true , None ) < nl > + val WrongActionHash = RpcError ( 400 , " WRONG _ WEBACTION _ HASH " , " Web action not found " , false , None ) < nl > + < nl > + } < nl > + < nl > + private [ rpc ] object WebactionsKeyValues { < nl > + def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) < nl > + } < nl > + < nl > + final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { < nl > + import WebactionsErrors . _ < nl > + < nl > + override implicit val ec : ExecutionContext = actorSystem . dispatcher < nl > + private implicit val timeout : Timeout = Timeout ( 5 . seconds ) < nl > + private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) < nl > + private val db = DbExtension ( actorSystem ) . db < nl > + < nl > + override def jhandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = { < nl > + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > + ( for { < nl > + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > + webAction ← fromEither ( createWebaction ( fqn ) ) < nl > + actionHash = generateActionHash ( ) < nl > + _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) < nl > + } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . run < nl > + } < nl > + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) < nl > + } < nl > + < nl > + override def jhandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = { < nl > + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ < nl > + ( for { < nl > + actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) < nl > + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) < nl > + webAction ← fromEither ( createWebaction ( fqn ) ) < nl > + response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) < nl > + _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) < nl > + } yield ResponseCompleteWebaction ( response ) ) . run < nl > + } < nl > + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) < nl > + } < nl > + < nl > + private def createWebaction ( fqn : String ) : RpcError \ / Webaction = { < nl > + Webaction . webactionOf ( fqn , actorSystem ) match { < nl > + case Success ( s ) ⇒ \ / - ( s ) < nl > + case Failure ( f ) ⇒ < nl > + actorSystem . log . error ( f , " Failed to create webaction " ) < nl > + Error ( FailedToCreateWebaction ) < nl > + } < nl > + } < nl > + < nl > + private def generateActionHash ( ) : String = ACLUtils . authTransactionHash ( ACLUtils . nextAccessSalt ( ) ) < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index 5ce2887 . . 9d1eabc 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 25 , 6 + 25 , 7 @ @ import im . actor . server . api . rpc . service . push . PushServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > import im . actor . server . api . rpc . service . users . UsersServiceImpl < nl > import im . actor . server . api . rpc . service . weak . WeakServiceImpl < nl > + import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl < nl > import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . { DialogExtension , DialogProcessor } < nl > @ @ - 138 , 7 + 139 , 8 @ @ object Main extends App { < nl > new ConfigsServiceImpl , < nl > new PushServiceImpl , < nl > new ProfileServiceImpl , < nl > - new IntegrationsServiceImpl ( webappConfig ) < nl > + new IntegrationsServiceImpl ( webappConfig ) , < nl > + new WebactionsServiceImpl < nl > ) < nl > < nl > system . actorOf ( RpcApiService . props ( services ) , " rpcApiService " ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > index 241f07d . . 0eec015 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala < nl > @ @ - 10 , 14 + 10 , 12 @ @ trait InternalExtension < nl > < nl > object InternalExtensions { < nl > < nl > - private val config = ActorConfig . load ( ) < nl > - < nl > def getId ( path : String , name : String ) = { < nl > - config . getInt ( s " $ path . $ name . id " ) < nl > + ActorConfig . load ( ) . getInt ( s " $ path . $ name . id " ) < nl > } < nl > < nl > def extensions ( path : String ) : Map [ Int , String ] = { < nl > - val extConfig = config . getConfig ( path ) < nl > + val extConfig = ActorConfig . load ( ) . getConfig ( path ) < nl > val extensionsKeys = extConfig . root . keys < nl > ( extensionsKeys map { extName ⇒ < nl > extConfig . getInt ( s " $ extName . id " ) → extConfig . getString ( s " $ extName . class " ) < nl > diff - - git a / actor - server / actor - testkit / src / main / resources / reference . conf b / actor - server / actor - testkit / src / main / resources / reference . conf < nl > index 6f166cc . . e122ccb 100644 < nl > - - - a / actor - server / actor - testkit / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - testkit / src / main / resources / reference . conf < nl > @ @ - 18 , 6 + 18 , 10 @ @ enabled - modules { < nl > sequence { < nl > max - update - size : 20 KiB < nl > } < nl > + webactions { < nl > + wrong : " im . actor . server . webactions . WrongWebaction " < nl > + correct : " im . actor . server . webactions . CorrectWebaction " < nl > + } < nl > } < nl > services { < nl > aws { < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 29288ff < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala < nl > @ @ - 0 , 0 + 1 , 22 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object CorrectWebaction { < nl > + val uri = " https : / / google . com / " < nl > + val regex = " https : / / mail . google . com " < nl > + val completeUri = " https : / / mail . google . com / mail / u / 0 / # inbox " < nl > + } < nl > + < nl > + class CorrectWebaction ( system : ActorSystem ) extends Webaction ( system ) { < nl > + import system . dispatcher < nl > + < nl > + override def uri ( params : ApiMapValue ) : String = CorrectWebaction . uri < nl > + override def regex : String = CorrectWebaction . regex < nl > + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future { < nl > + ApiMapValue ( Vector ( ApiMapValueItem ( " userId " , ApiInt32Value ( userId ) ) , ApiMapValueItem ( " url " , ApiStringValue ( url . reverse ) ) ) ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala < nl > new file mode 100644 < nl > index 0000000 . . 8c21fa2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala < nl > @ @ - 0 , 0 + 1 , 15 @ @ < nl > + package im . actor . server . webactions < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . collections . ApiMapValue < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + / / MUST fail < nl > + class WrongWebaction ( system : ActorSystem ) extends Webaction ( system ) { < nl > + val importantVal = 2 / 0 < nl > + < nl > + override def uri ( params : ApiMapValue ) : String = " " < nl > + override def regex : String = " " < nl > + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future . successful ( ApiMapValue ( Vector ( ) ) ) < nl > + } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . f8b8fea < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala < nl > @ @ - 0 , 0 + 1 , 107 @ @ < nl > + package im . actor . server . api . rpc . service < nl > + < nl > + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } < nl > + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } < nl > + import im . actor . api . rpc . { Ok , ClientData , Error } < nl > + import im . actor . server . api . rpc . service . webactions . { WebactionsKeyValues , WebactionsErrors , WebactionsServiceImpl } < nl > + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > + import im . actor . server . webactions . CorrectWebaction < nl > + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegionProxy } < nl > + import org . scalatest . Inside . _ < nl > + < nl > + class WebactionServiceSpec < nl > + extends BaseAppSuite < nl > + with ImplicitSessionRegionProxy < nl > + with ImplicitAuthService { < nl > + < nl > + behavior of " WebactionService " < nl > + < nl > + " Init webaction " should " response with WEBACTION _ NOT _ FOUND when there is no webaction with such name " in t . e1 < nl > + < nl > + it should " response with FAILED _ TO _ CREATE _ WEBACTION when web action cannot be instantiated " in t . e2 < nl > + < nl > + it should " response with correct uri and regex when web action exists " in t . e3 < nl > + < nl > + " Complete webaction " should " response with WRONG _ WEBACTION _ HASH to wrong action hash " in t . e4 < nl > + < nl > + it should " response with ApiMapValue to correct action hash and remove action hash from key value " in t . e5 < nl > + < nl > + implicit val presenceManagerRegion = PresenceManager . startRegion ( ) < nl > + implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) < nl > + < nl > + val service = new WebactionsServiceImpl ( ) < nl > + < nl > + object t { < nl > + val ( user , userAuthId , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = ClientData ( userAuthId , sessionId , Some ( user . id ) ) < nl > + private val kv = WebactionsKeyValues . actionHashUserKV ( ) < nl > + < nl > + def e1 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . WebactionNotFound ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e2 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " wrong " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . FailedToCreateWebaction ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e3 ( ) : Unit = { < nl > + val actionName = " correct " < nl > + whenReady ( service . handleInitWebaction ( actionName , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ < nl > + uri shouldEqual CorrectWebaction . uri < nl > + reg shouldEqual CorrectWebaction . regex < nl > + whenReady ( kv . get ( hash ) ) { optAction ⇒ < nl > + optAction shouldBe defined < nl > + val action = optAction . get < nl > + actionName shouldEqual action < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e4 ( ) : Unit = { < nl > + whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ < nl > + } < nl > + } < nl > + whenReady ( service . handleCompleteWebaction ( " wrong _ hash " , CorrectWebaction . completeUri ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Error ( WebactionsErrors . WrongActionHash ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + def e5 ( ) : Unit = { < nl > + val actionHash = whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ < nl > + resp . toOption . get . actionHash < nl > + } < nl > + whenReady ( service . handleCompleteWebaction ( actionHash , CorrectWebaction . completeUri ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseCompleteWebaction ( map ) ) ⇒ < nl > + map . items should have length 2 < nl > + map . items should contain theSameElementsAs Vector ( < nl > + ApiMapValueItem ( " userId " , ApiInt32Value ( user . id ) ) , < nl > + ApiMapValueItem ( " url " , ApiStringValue ( CorrectWebaction . completeUri . reverse ) ) < nl > + ) < nl > + } < nl > + } < nl > + whenReady ( kv . get ( actionHash ) ) { optAction ⇒ < nl > + optAction should not be defined < nl > + } < nl > + } < nl > + < nl > + private val emptyParams = ApiMapValue ( Vector ( ) ) < nl > + } < nl > + < nl > + }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala 
 new file mode 100644 
 index 0000000 . . e0d918b 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + package im . actor . rpc . raw 
 + 
 + import akka . actor . ActorSystem 
 + import cats . data . Xor 
 + import im . actor . api . rpc . collections . ApiRawValue 
 + import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 + 
 + import scala . concurrent . Future 
 + 
 + / * * 
 + * Base class for raw service handlers . 
 + * / 
 + abstract class RawApiService ( system : ActorSystem ) { 
 + 
 + type Response = Future [ RpcError Xor ApiRawValue ] 
 + 
 + type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Response ] 
 + 
 + def handleRequests : Handler 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala 
 deleted file mode 100644 
 index e3bf3e0 . . 0000000 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawServiceHandler . scala 
 + + + / dev / null 
 @ @ - 1 , 21 + 0 , 0 @ @ 
 - package im . actor . rpc . raw 
 - 
 - import akka . actor . ActorSystem 
 - import cats . data . Xor 
 - import im . actor . api . rpc . collections . ApiRawValue 
 - import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 - 
 - import scala . concurrent . Future 
 - 
 - / * * 
 - * Base class for raw service handlers . 
 - * / 
 - abstract class RawServiceHandler ( system : ActorSystem ) { 
 - 
 - type RawFunction = AuthorizedClientData ⇒ RawAuthorizedFunction 
 - 
 - type RawAuthorizedFunction = Option [ ApiRawValue ] ⇒ Future [ RpcError Xor ApiRawValue ] 
 - 
 - def handle : PartialFunction [ String , RawFunction ] 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 index 8237db1 . . 0ef4c32 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 @ @ - 2 , 34 + 2 , 37 @ @ package im . actor . server . api . rpc 
 
 import akka . actor . _ 
 import cats . data . Xor 
 + import im . actor . api . rpc . collections . ApiRawValue 
 + import im . actor . api . rpc . FutureResultRpcCats 
 import im . actor . api . rpc . { AuthorizedClientData , CommonErrors , RpcError } 
 - import im . actor . rpc . raw . RawServiceHandler 
 + import im . actor . rpc . raw . RawApiService 
 
 import scala . collection . concurrent . TrieMap 
 + import scala . concurrent . Future 
 
 sealed trait RawApiExtension extends Extension 
 
 private [ rpc ] final class RawApiExtensionImpl ( system : ExtendedActorSystem ) extends RawApiExtension { 
 + import FutureResultRpcCats . _ 
 + import system . dispatcher 
 
 - private val services = TrieMap . empty [ String , RawServiceHandler ] 
 + private val services = TrieMap . empty [ String , RawApiService ] 
 
 - def register ( name : String , clazz : Class [ _ < : RawServiceHandler ] ) : Unit = { 
 - val service = system . dynamicAccess . createInstanceFor [ RawServiceHandler ] ( clazz , List ( classOf [ ActorSystem ] → system ) ) . get 
 + def register ( name : String , clazz : Class [ _ < : RawApiService ] ) : Unit = { 
 + val service = system . dynamicAccess . createInstanceFor [ RawApiService ] ( clazz , List ( classOf [ ActorSystem ] → system ) ) . get 
 register ( name , service ) 
 } 
 
 - def register ( name : String , service : RawServiceHandler ) : Unit = services . putIfAbsent ( name , service ) 
 + def register ( name : String , service : RawApiService ) : Unit = services . putIfAbsent ( name , service ) 
 
 - def register ( serviceSeq : Seq [ ( String , RawServiceHandler ) ] ) : Unit = services + + = serviceSeq 
 + def register ( serviceSeq : Seq [ ( String , RawApiService ) ] ) : Unit = services + + = serviceSeq 
 
 - def getHandlingFunction ( service : String , method : String ) ( implicit client : AuthorizedClientData ) : RpcError Xor RawServiceHandler # RawAuthorizedFunction = { 
 - val optFunction : Option [ RawServiceHandler # RawAuthorizedFunction ] = 
 - for { 
 - handler ← services . get ( service ) 
 - rawFunc ← handler . handle . lift ( method ) 
 - } yield rawFunc ( client ) 
 - Xor . fromOption ( optFunction , CommonErrors . UnsupportedRequest ) 
 - } 
 + def handle ( service : String , method : String , params : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ RpcError Xor ApiRawValue ] = 
 + ( for { 
 + serviceHandler ← fromOption ( CommonErrors . UnsupportedRequest ) ( services . get ( service ) ) 
 + response ← fromOption ( CommonErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( client ) ( params ) . lift ( method ) ) 
 + result ← fromFutureEither ( response ) 
 + } yield result ) . value 
 } 
 
 object RawApiExtension extends ExtensionId [ RawApiExtensionImpl ] with ExtensionIdProvider { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 index d55ae43 . . 7e02f36 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 @ @ - 18 , 9 + 18 , 7 @ @ final class RawServiceImpl ( implicit system : ActorSystem ) extends RawService { 
 
 override def jhandleRawRequest ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseRawRequest ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 - ( for { 
 - func ← fromEither ( rawApiExt . getHandlingFunction ( service , method ) ) 
 - result ← fromFutureEither ( func ( params ) ) 
 - } yield ResponseRawRequest ( result ) ) . value map ( _ . toScalaz ) 
 + ( for ( result ← fromFutureEither ( rawApiExt . handle ( service , method , params ) ) ) 
 + yield ResponseRawRequest ( result ) ) . value map ( _ . toScalaz ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala 
 new file mode 100644 
 index 0000000 . . da24c5f 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala 
 @ @ - 0 , 0 + 1 , 172 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 + import cats . data . Xor 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . collections . _ 
 + import im . actor . rpc . raw . RawApiService 
 + import im . actor . server . api . rpc . RawApiExtension 
 + import im . actor . server . api . rpc . service . raw . RawServiceImpl 
 + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 + 
 + import scala . collection . concurrent . TrieMap 
 + import scala . concurrent . Future 
 + import scala . concurrent . duration . _ 
 + import scalaz . \ / - 
 + 
 + class RawServiceSpec 
 + extends BaseAppSuite 
 + with ImplicitAuthService 
 + with ImplicitSessionRegion { 
 + 
 + behavior of " raw api service " 
 + 
 + it should " respond with Unsupported Request , when there is no such service " in e1 
 + 
 + it should " respond with error to invalid request " in e2 
 + 
 + it should " respond with result to valid request " in e3 
 + 
 + it should " detect dynamically registered services " in e4 
 + 
 + val service = new RawServiceImpl ( ) 
 + 
 + RawApiExtension ( system ) . register ( " dictionary " , new DictionaryService ( system ) ) 
 + 
 + val ( user , authId , authSid , _ ) = createUser ( ) 
 + implicit val clientData : ClientData = ClientData ( authId , createSessionId ( ) , Some ( AuthData ( user . id , authSid ) ) ) 
 + 
 + def e1 ( ) = { 
 + whenReady ( service . handleRawRequest ( " maps " , " getGeo " , None ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( err ) ⇒ err shouldEqual CommonErrors . UnsupportedRequest 
 + } 
 + } 
 + } 
 + 
 + def e2 ( ) = { 
 + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiInt32Value ( 22 ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( err ) ⇒ err shouldEqual ServiceErrors . InvalidParams 
 + } 
 + } 
 + 
 + / / not right cause we should pass params as map , not as string 
 + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiStringValue ( " culture " ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( err ) ⇒ err shouldEqual ServiceErrors . InvalidParams 
 + } 
 + } 
 + } 
 + 
 + def e3 ( ) = { 
 + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( DictionaryMeanings . Culture ) ) 
 + } 
 + } 
 + } 
 + 
 + whenReady ( service . handleRawRequest ( " dictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " UNKNOWN " ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items shouldBe empty 
 + } 
 + } 
 + } 
 + } 
 + 
 + def e4 ( ) = { 
 + whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( err ) ⇒ err shouldEqual CommonErrors . UnsupportedRequest 
 + } 
 + } 
 + 
 + RawApiExtension ( system ) . register ( " echo " , new EchoService ( system ) ) 
 + 
 + whenReady ( service . handleRawRequest ( " echo " , " makeEcho " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " query " , ApiStringValue ( " Hello " ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiMapValueItem ( " echo " , ApiStringValue ( " Hello you back ! " ) ) 
 + } 
 + } 
 + } 
 + } 
 + 
 + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service 
 + 
 + private object DictionaryMeanings { 
 + val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " 
 + val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " 
 + val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " 
 + } 
 + 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . 
 + * / 
 + private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import ServiceErrors . _ 
 + import im . actor . api . rpc . FutureResultRpcCats . _ 
 + 
 + implicit val timeout = Timeout ( 20 . seconds ) 
 + private val kv = TrieMap . empty [ String , String ] 
 + 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 + 
 + override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 + case " getWord " ⇒ getWord ( params ) 
 + / / case " putWord " = > putWord ( ) 
 + } 
 + 
 + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Response = { 
 + val ps = optParams flatMap { 
 + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } 
 + case _ ⇒ None 
 + } 
 + ( for { 
 + key ← fromOption ( InvalidParams ) ( ps ) 
 + optValue ← point ( kv . get ( key ) ) 
 + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 + } yield ApiMapValue ( result ) ) . value 
 + } 
 + } 
 + 
 + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service 
 + 
 + private final class EchoService ( system : ActorSystem ) extends RawApiService ( system ) { 
 + import ServiceErrors . _ 
 + 
 + override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 + case " makeEcho " ⇒ echo ( params ) 
 + } 
 + 
 + def echo ( params : Option [ ApiRawValue ] ) : Response = { 
 + val resp = extractStringFromMap ( params , " query " ) map { q ⇒ 
 + Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) 
 + } getOrElse Xor . left ( InvalidParams ) 
 + Future . successful ( resp ) 
 + } 
 + } 
 + 
 + private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = 
 + optParams flatMap { 
 + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( ` key ` , ApiStringValue ( str ) ) ⇒ str } 
 + case _ ⇒ None 
 + } 
 + 
 + private object ServiceErrors { 
 + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala 
 new file mode 100644 
 index 0000000 . . 4d9609f 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webactions / Webaction . scala 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiMapValueItem , ApiMapValue } 
 + import im . actor . config . ActorConfig 
 + 
 + import scala . concurrent . Future 
 + import scala . collection . JavaConversions . _ 
 + import scala . util . Try 
 + 
 + object Webaction { 
 + 
 + / * * 
 + * Retrieves list of all available webactions 
 + * @ param path path ofconfig , containing list of registered webactions 
 + * @ return mapping from webaction name to its FQN 
 + * / 
 + def list ( path : String ) : Map [ String , String ] = 
 + ActorConfig . load ( ) . getConfig ( path ) . root . unwrapped . toMap map { case ( k , v ) ⇒ k → v . toString } 
 + 
 + def list : Map [ String , String ] = list ( " enabled - modules . webactions " ) 
 + 
 + / * * 
 + * Instantiates webaction by fully qualified class name 
 + * @ param actionFQN fully qualified class name 
 + * @ param system actor system , required to execute actions inside webaction 
 + * @ return ` Success ( webaction ) ` when webaction instantiation succeeds , 
 + * and ` Failure ( exception ) ` when instantiation failed by various reasons ( no such class / wrong constuctor ) 
 + * / 
 + def webactionOf ( actionFQN : String , system : ActorSystem ) : Try [ Webaction ] = Try { 
 + val constructor = Class . forName ( actionFQN ) . getConstructors ( ) ( 0 ) 
 + constructor . newInstance ( system ) . asInstanceOf [ Webaction ] 
 + } 
 + 
 + def failure ( cause : String ) : ApiMapValue = 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " error " , ApiStringValue ( cause ) ) ) ) 
 + 
 + def success ( message : String ) : ApiMapValue = 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " success " , ApiStringValue ( message ) ) ) ) 
 + } 
 + 
 + abstract class Webaction ( system : ActorSystem ) { 
 + def uri ( params : ApiMapValue ) : String 
 + def regex : String 
 + def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . 6168f4a 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webactions / WebactionsServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + package im . actor . server . api . rpc . service . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . FutureResultRpc . _ 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . collections . ApiMapValue 
 + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction , WebactionsService } 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . webactions . Webaction 
 + import shardakka . ShardakkaExtension 
 + import slick . dbio . DBIO 
 + 
 + import scala . concurrent . duration . _ 
 + import scala . concurrent . { ExecutionContext , Future } 
 + import scala . util . { Failure , Success } 
 + import scalaz . { \ / , \ / - } 
 + 
 + object WebactionsErrors { 
 + val WebactionNotFound = RpcError ( 404 , " WEBACTION _ NOT _ FOUND " , " Web action not found " , false , None ) 
 + val FailedToCreateWebaction = RpcError ( 500 , " FAILED _ TO _ CREATE _ WEBACTION " , " Failed to create webaction " , true , None ) 
 + val WrongActionHash = RpcError ( 400 , " WRONG _ WEBACTION _ HASH " , " Web action not found " , false , None ) 
 + 
 + } 
 + 
 + private [ rpc ] object WebactionsKeyValues { 
 + def actionHashUserKV ( ) ( implicit system : ActorSystem ) = ShardakkaExtension ( system ) . simpleKeyValue ( " WebactionHashUserId " ) 
 + } 
 + 
 + final class WebactionsServiceImpl ( implicit actorSystem : ActorSystem ) extends WebactionsService { 
 + import WebactionsErrors . _ 
 + 
 + override implicit val ec : ExecutionContext = actorSystem . dispatcher 
 + private implicit val timeout : Timeout = Timeout ( 5 . seconds ) 
 + private val actionHashUserKV = WebactionsKeyValues . actionHashUserKV ( ) 
 + private val db = DbExtension ( actorSystem ) . db 
 + 
 + override def jhandleInitWebaction ( actionName : String , params : ApiMapValue , clientData : ClientData ) : Future [ HandlerResult [ ResponseInitWebaction ] ] = { 
 + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 + ( for { 
 + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 + webAction ← fromEither ( createWebaction ( fqn ) ) 
 + actionHash = generateActionHash ( ) 
 + _ ← fromFuture ( actionHashUserKV . upsert ( actionHash , actionName ) ) 
 + } yield ResponseInitWebaction ( webAction . uri ( params ) , webAction . regex , actionHash ) ) . run 
 + } 
 + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) 
 + } 
 + 
 + override def jhandleCompleteWebaction ( actionHash : String , completeUri : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseCompleteWebaction ] ] = { 
 + val authorizedAction = requireAuth ( clientData ) map { implicit client ⇒ 
 + ( for { 
 + actionName ← fromFutureOption ( WrongActionHash ) ( actionHashUserKV . get ( actionHash ) ) 
 + fqn ← fromOption ( WebactionNotFound ) ( Webaction . list . get ( actionName ) ) 
 + webAction ← fromEither ( createWebaction ( fqn ) ) 
 + response ← fromFuture ( webAction . complete ( client . userId , completeUri ) ) 
 + _ ← fromFuture ( actionHashUserKV . delete ( actionHash ) ) 
 + } yield ResponseCompleteWebaction ( response ) ) . run 
 + } 
 + db . run ( toDBIOAction ( authorizedAction map DBIO . from ) ) 
 + } 
 + 
 + private def createWebaction ( fqn : String ) : RpcError \ / Webaction = { 
 + Webaction . webactionOf ( fqn , actorSystem ) match { 
 + case Success ( s ) ⇒ \ / - ( s ) 
 + case Failure ( f ) ⇒ 
 + actorSystem . log . error ( f , " Failed to create webaction " ) 
 + Error ( FailedToCreateWebaction ) 
 + } 
 + } 
 + 
 + private def generateActionHash ( ) : String = ACLUtils . authTransactionHash ( ACLUtils . nextAccessSalt ( ) ) 
 + 
 + } 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index 5ce2887 . . 9d1eabc 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 25 , 6 + 25 , 7 @ @ import im . actor . server . api . rpc . service . push . PushServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 import im . actor . server . api . rpc . service . users . UsersServiceImpl 
 import im . actor . server . api . rpc . service . weak . WeakServiceImpl 
 + import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl 
 import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . { DialogExtension , DialogProcessor } 
 @ @ - 138 , 7 + 139 , 8 @ @ object Main extends App { 
 new ConfigsServiceImpl , 
 new PushServiceImpl , 
 new ProfileServiceImpl , 
 - new IntegrationsServiceImpl ( webappConfig ) 
 + new IntegrationsServiceImpl ( webappConfig ) , 
 + new WebactionsServiceImpl 
 ) 
 
 system . actorOf ( RpcApiService . props ( services ) , " rpcApiService " ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 index 241f07d . . 0eec015 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / extension / InternalExtensions . scala 
 @ @ - 10 , 14 + 10 , 12 @ @ trait InternalExtension 
 
 object InternalExtensions { 
 
 - private val config = ActorConfig . load ( ) 
 - 
 def getId ( path : String , name : String ) = { 
 - config . getInt ( s " $ path . $ name . id " ) 
 + ActorConfig . load ( ) . getInt ( s " $ path . $ name . id " ) 
 } 
 
 def extensions ( path : String ) : Map [ Int , String ] = { 
 - val extConfig = config . getConfig ( path ) 
 + val extConfig = ActorConfig . load ( ) . getConfig ( path ) 
 val extensionsKeys = extConfig . root . keys 
 ( extensionsKeys map { extName ⇒ 
 extConfig . getInt ( s " $ extName . id " ) → extConfig . getString ( s " $ extName . class " ) 
 diff - - git a / actor - server / actor - testkit / src / main / resources / reference . conf b / actor - server / actor - testkit / src / main / resources / reference . conf 
 index 6f166cc . . e122ccb 100644 
 - - - a / actor - server / actor - testkit / src / main / resources / reference . conf 
 + + + b / actor - server / actor - testkit / src / main / resources / reference . conf 
 @ @ - 18 , 6 + 18 , 10 @ @ enabled - modules { 
 sequence { 
 max - update - size : 20 KiB 
 } 
 + webactions { 
 + wrong : " im . actor . server . webactions . WrongWebaction " 
 + correct : " im . actor . server . webactions . CorrectWebaction " 
 + } 
 } 
 services { 
 aws { 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala 
 new file mode 100644 
 index 0000000 . . 29288ff 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / CorrectWebaction . scala 
 @ @ - 0 , 0 + 1 , 22 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } 
 + 
 + import scala . concurrent . Future 
 + 
 + object CorrectWebaction { 
 + val uri = " https : / / google . com / " 
 + val regex = " https : / / mail . google . com " 
 + val completeUri = " https : / / mail . google . com / mail / u / 0 / # inbox " 
 + } 
 + 
 + class CorrectWebaction ( system : ActorSystem ) extends Webaction ( system ) { 
 + import system . dispatcher 
 + 
 + override def uri ( params : ApiMapValue ) : String = CorrectWebaction . uri 
 + override def regex : String = CorrectWebaction . regex 
 + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future { 
 + ApiMapValue ( Vector ( ApiMapValueItem ( " userId " , ApiInt32Value ( userId ) ) , ApiMapValueItem ( " url " , ApiStringValue ( url . reverse ) ) ) ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala 
 new file mode 100644 
 index 0000000 . . 8c21fa2 
 - - - / dev / null 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / webactions / WrongWebaction . scala 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package im . actor . server . webactions 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . collections . ApiMapValue 
 + 
 + import scala . concurrent . Future 
 + 
 + / / MUST fail 
 + class WrongWebaction ( system : ActorSystem ) extends Webaction ( system ) { 
 + val importantVal = 2 / 0 
 + 
 + override def uri ( params : ApiMapValue ) : String = " " 
 + override def regex : String = " " 
 + override def complete ( userId : Int , url : String ) : Future [ ApiMapValue ] = Future . successful ( ApiMapValue ( Vector ( ) ) ) 
 + } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 new file mode 100644 
 index 0000000 . . f8b8fea 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / WebactionServiceSpec . scala 
 @ @ - 0 , 0 + 1 , 107 @ @ 
 + package im . actor . server . api . rpc . service 
 + 
 + import im . actor . api . rpc . collections . { ApiStringValue , ApiInt32Value , ApiMapValueItem , ApiMapValue } 
 + import im . actor . api . rpc . webactions . { ResponseCompleteWebaction , ResponseInitWebaction } 
 + import im . actor . api . rpc . { Ok , ClientData , Error } 
 + import im . actor . server . api . rpc . service . webactions . { WebactionsKeyValues , WebactionsErrors , WebactionsServiceImpl } 
 + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 + import im . actor . server . webactions . CorrectWebaction 
 + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegionProxy } 
 + import org . scalatest . Inside . _ 
 + 
 + class WebactionServiceSpec 
 + extends BaseAppSuite 
 + with ImplicitSessionRegionProxy 
 + with ImplicitAuthService { 
 + 
 + behavior of " WebactionService " 
 + 
 + " Init webaction " should " response with WEBACTION _ NOT _ FOUND when there is no webaction with such name " in t . e1 
 + 
 + it should " response with FAILED _ TO _ CREATE _ WEBACTION when web action cannot be instantiated " in t . e2 
 + 
 + it should " response with correct uri and regex when web action exists " in t . e3 
 + 
 + " Complete webaction " should " response with WRONG _ WEBACTION _ HASH to wrong action hash " in t . e4 
 + 
 + it should " response with ApiMapValue to correct action hash and remove action hash from key value " in t . e5 
 + 
 + implicit val presenceManagerRegion = PresenceManager . startRegion ( ) 
 + implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) 
 + 
 + val service = new WebactionsServiceImpl ( ) 
 + 
 + object t { 
 + val ( user , userAuthId , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = ClientData ( userAuthId , sessionId , Some ( user . id ) ) 
 + private val kv = WebactionsKeyValues . actionHashUserKV ( ) 
 + 
 + def e1 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " foo " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . WebactionNotFound ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e2 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " wrong " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . FailedToCreateWebaction ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e3 ( ) : Unit = { 
 + val actionName = " correct " 
 + whenReady ( service . handleInitWebaction ( actionName , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ 
 + uri shouldEqual CorrectWebaction . uri 
 + reg shouldEqual CorrectWebaction . regex 
 + whenReady ( kv . get ( hash ) ) { optAction ⇒ 
 + optAction shouldBe defined 
 + val action = optAction . get 
 + actionName shouldEqual action 
 + } 
 + } 
 + } 
 + } 
 + 
 + def e4 ( ) : Unit = { 
 + whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseInitWebaction ( uri , reg , hash ) ) ⇒ 
 + } 
 + } 
 + whenReady ( service . handleCompleteWebaction ( " wrong _ hash " , CorrectWebaction . completeUri ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Error ( WebactionsErrors . WrongActionHash ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + def e5 ( ) : Unit = { 
 + val actionHash = whenReady ( service . handleInitWebaction ( " correct " , emptyParams ) ) { resp ⇒ 
 + resp . toOption . get . actionHash 
 + } 
 + whenReady ( service . handleCompleteWebaction ( actionHash , CorrectWebaction . completeUri ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseCompleteWebaction ( map ) ) ⇒ 
 + map . items should have length 2 
 + map . items should contain theSameElementsAs Vector ( 
 + ApiMapValueItem ( " userId " , ApiInt32Value ( user . id ) ) , 
 + ApiMapValueItem ( " url " , ApiStringValue ( CorrectWebaction . completeUri . reverse ) ) 
 + ) 
 + } 
 + } 
 + whenReady ( kv . get ( actionHash ) ) { optAction ⇒ 
 + optAction should not be defined 
 + } 
 + } 
 + 
 + private val emptyParams = ApiMapValue ( Vector ( ) ) 
 + } 
 + 
 + }
