BLEU SCORE: 0.02383853510228548

TEST MSG: Merge commit ' 9b0ac16527c799d0d89536f32dca1c015e11a1a4 ' into calls / v2
GENERATED MSG: feat ( server : bots ) : bots api

TEST DIFF (one line): diff - - git a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > index 161c9c8 . . cfddd9f 100644 < nl > - - - a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > + + + b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > @ @ - 292 , 7 + 292 , 7 @ @ object BotMessages { < nl > override def readResponse ( obj : Js . Obj ) = readJs [ MessageSent ] ( obj ) < nl > } < nl > < nl > - @ key ( " SendMessage " ) < nl > + @ key ( " UpdateMessageContent " ) < nl > final case class UpdateMessageContent ( < nl > @ beanGetter peer : OutPeer , < nl > @ beanGetter randomId : Long , < nl > diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > index 6a28636 . . 2488aae 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala < nl > @ @ - 1 , 19 + 1 , 39 @ @ < nl > package im . actor . server . bot . services < nl > < nl > import akka . actor . ActorSystem < nl > - import im . actor . server . bot . { BotToApiConversions , BotServiceBase } < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } < nl > + import im . actor . bots . BotMessages . BotError < nl > + import im . actor . concurrent . FutureResultCats < nl > + import im . actor . server . bot . { BotServiceBase , BotToApiConversions } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . group . GroupExtension < nl > + import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . sequence . SeqStateDate < nl > < nl > - private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) with BotToApiConversions { < nl > + import scala . concurrent . Future < nl > < nl > + private [ bot ] object MessagingBotErrors { < nl > + val Forbidden = BotError ( 403 , " FORBIDDEN " ) < nl > + } < nl > + < nl > + private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) < nl > + with FutureResultCats [ BotError ] < nl > + with BotToApiConversions < nl > + with PeersImplicits { < nl > + < nl > + import MessagingBotErrors . _ < nl > import im . actor . bots . BotMessages . _ < nl > import system . dispatcher < nl > < nl > private lazy val dialogExt = DialogExtension ( system ) < nl > + private lazy val db = DbExtension ( system ) . db < nl > < nl > override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { < nl > - case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak < nl > + case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak < nl > + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak < nl > } < nl > < nl > private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( < nl > @ @ - 32 , 4 + 52 , 66 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer < nl > } yield Right ( MessageSent ( date ) ) < nl > } < nl > ) < nl > + < nl > + / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages < nl > + private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( < nl > + ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { < nl > + val peerModel = toPeer ( peer ) . asModel < nl > + val botPeer = ModelPeer . privat ( botUserId ) < nl > + ( for { < nl > + _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) < nl > + _ ← fromFuture ( peer match { < nl > + case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) < nl > + case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) < nl > + } ) < nl > + } yield MessageContentUpdated ) . value < nl > + } < nl > + ) < nl > + < nl > + private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > + val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + _ ← userExt . broadcastUserUpdate ( < nl > + userId = userId , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + reduceKey = None , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = Set ( userId , botPeer . id ) , < nl > + randomId = randomId , < nl > + peerType = PeerType . Private , < nl > + peerIds = Set ( userId , botPeer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield ( ) < nl > + } < nl > + < nl > + private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { < nl > + / / no need to send update to bot itself < nl > + val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) < nl > + for { < nl > + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) < nl > + membersSet = memberIds . toSet < nl > + _ ← userExt . broadcastUsersUpdate ( < nl > + userIds = membersSet , < nl > + update = upd , < nl > + pushText = None , < nl > + isFat = false , < nl > + deliveryId = Some ( s " msgcontent _ $ randomId " ) < nl > + ) < nl > + _ ← db . run ( HistoryMessageRepo . updateContentAll ( < nl > + userIds = membersSet + botUserId , < nl > + randomId = randomId , < nl > + peerType = PeerType . Group , < nl > + peerIds = Set ( groupPeer . id ) , < nl > + messageContentHeader = updatedMessage . header , < nl > + messageContentData = updatedMessage . toByteArray < nl > + ) ) < nl > + } yield ( ) < nl > + } < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 0eceef8 . . 2907ae8 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import sbt . _ < nl > object Dependencies { < nl > object V { < nl > val actorCommons = " 0 . 0 . 13 " < nl > - val actorBotkit = " 1 . 0 . 72 " < nl > + val actorBotkit = " 1 . 0 . 75 " < nl > val akka = " 2 . 4 . 2 - RC2 " < nl > val akkaHttpJson = " 1 . 5 . 0 " < nl > val cats = " 0 . 3 . 0 "
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > new file mode 100644 < nl > index 0000000 . . 9b8e44a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala < nl > @ @ - 0 , 0 + 1 , 33 @ @ < nl > + package im . actor . bot < nl > + < nl > + import derive . key < nl > + < nl > + sealed trait BotMessage < nl > + < nl > + final object BotMessages { < nl > + final object OutPeer { < nl > + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) < nl > + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) < nl > + } < nl > + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) < nl > + final case class Peer ( ` type ` : Int , id : Int ) < nl > + < nl > + sealed trait RequestBody < nl > + < nl > + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessage < nl > + < nl > + @ key ( " SendMessage " ) < nl > + final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody < nl > + < nl > + sealed trait ResponseBody < nl > + < nl > + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessage < nl > + < nl > + @ key ( " MessageSent " ) < nl > + final case class MessageSent ( date : Long ) extends ResponseBody < nl > + < nl > + sealed trait BotUpdate extends BotMessage < nl > + < nl > + @ key ( " TextMessage " ) < nl > + final case class TextMessage ( peer : Peer , senderUserId : Int , date : Long , randomId : Long , message : String ) extends BotUpdate < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > new file mode 100644 < nl > index 0000000 . . f2d446e < nl > - - - / dev / null < nl > + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala < nl > @ @ - 0 , 0 + 1 , 98 @ @ < nl > + package im . actor . server . bot < nl > + < nl > + import akka . actor . { ExtendedActorSystem , ExtensionId , ActorSystem , Extension } < nl > + import akka . util . Timeout < nl > + import im . actor . api . rpc . users . ApiSex < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . user . UserExtension < nl > + import im . actor . server . persist < nl > + import im . actor . util . misc . IdUtils < nl > + import shardakka . ShardakkaExtension < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object BotExtension extends ExtensionId [ BotExtension ] { < nl > + private [ bot ] val tokensKV = " BotsTokens " < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) : BotExtension = new BotExtensionImpl ( system ) < nl > + } < nl > + < nl > + trait BotExtension extends Extension { < nl > + type Token = String < nl > + type UserId = Int < nl > + type AuthId = Long < nl > + < nl > + / * * < nl > + * Creates a bot user < nl > + * < nl > + * @ return token future < nl > + * / < nl > + def create ( name : String ) : Future [ Token ] < nl > + < nl > + / * * < nl > + * Gets userId associated with token < nl > + * < nl > + * @ param token < nl > + * @ return user id < nl > + * / < nl > + def getUserId ( token : String ) : Future [ Option [ UserId ] ] < nl > + < nl > + / * * < nl > + * Gets or creates bot auth id < nl > + * @ param token < nl > + * @ return auth id < nl > + * / < nl > + def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] < nl > + } < nl > + < nl > + private [ bot ] final class BotExtensionImpl ( _ system : ActorSystem ) extends BotExtension { < nl > + import _ system . _ < nl > + < nl > + private implicit val system = _ system < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private lazy val userExt = UserExtension ( system ) < nl > + private lazy val tokensKV = ShardakkaExtension ( system ) . simpleKeyValue ( BotExtension . tokensKV ) < nl > + private lazy val db = DbExtension ( system ) . db < nl > + < nl > + override def create ( name : String ) : Future [ Token ] = { < nl > + val userId = IdUtils . nextIntId ( ) < nl > + val token = ACLUtils . randomHash ( ) < nl > + < nl > + for { < nl > + user ← userExt . create ( < nl > + userId = userId , < nl > + accessSalt = ACLUtils . nextAccessSalt ( ) , < nl > + name = name , < nl > + countryCode = " US " , < nl > + sex = ApiSex . Unknown , < nl > + isBot = true < nl > + ) < nl > + _ ← tokensKV . upsert ( token , s " $ userId " ) < nl > + } yield token < nl > + } < nl > + < nl > + override def getUserId ( token : String ) : Future [ Option [ UserId ] ] = { < nl > + for { < nl > + tokOpt ← tokensKV . get ( token ) < nl > + } yield tokOpt map ( _ . toInt ) < nl > + } < nl > + < nl > + override def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] = { < nl > + getUserId ( token ) flatMap { < nl > + case Some ( userId ) ⇒ getOrCreateAuthId ( userId ) map ( Some ( _ ) ) < nl > + case None ⇒ Future . successful ( None ) < nl > + } < nl > + } < nl > + < nl > + private def getOrCreateAuthId ( userId : Int ) : Future [ AuthId ] = { < nl > + db . run ( persist . AuthId . findFirstIdByUserId ( userId ) ) flatMap { < nl > + case Some ( authId ) ⇒ Future . successful ( authId ) < nl > + case None ⇒ < nl > + val authId = ACLUtils . randomLong ( ) < nl > + db . run ( persist . AuthId . create ( authId , Some ( userId ) , None ) ) map ( _ ⇒ authId ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > index ba37e90 . . 734f1f9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > @ @ - 46 , 7 + 46 , 18 @ @ object ACLUtils { < nl > def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = < nl > DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) < nl > < nl > - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString < nl > + def randomHash ( ) ( implicit s : ActorSystem ) : String = < nl > + DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) < nl > + < nl > + def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) < nl > + < nl > + def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) < nl > + < nl > + def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) < nl > + < nl > + def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString < nl > + < nl > + def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) < nl > < nl > def nextAccessSalt ( ) : String = { < nl > nextAccessSalt ( ThreadLocalRandom . current ( ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index bd3b59c . . 79e425b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 5 , 6 + 5 , 7 @ @ import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . messaging . ApiMessage < nl > import im . actor . api . rpc . misc . ApiExtension < nl > + import im . actor . api . rpc . peers . ApiPeer < nl > import im . actor . api . rpc . peers . ApiPeerType . _ < nl > import im . actor . api . rpc . peers . ApiPeerType . ApiPeerType < nl > import im . actor . extension . InternalExtensions < nl > @ @ - 28 , 7 + 29 , 17 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { < nl > < nl > implicit val s : ActorSystem = system < nl > implicit val ec : ExecutionContext = system . dispatcher < nl > - implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable < nl > + implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable < nl > + < nl > + def sendMessage ( < nl > + peer : ApiPeer , < nl > + senderUserId : Int , < nl > + senderAuthId : Long , < nl > + randomId : Long , < nl > + message : ApiMessage , < nl > + isFat : Boolean < nl > + ) : Future [ SeqStateDate ] = < nl > + sendMessage ( peer . ` type ` , peer . id , senderUserId , senderAuthId , randomId , message , isFat ) < nl > < nl > def sendMessage ( peerType : ApiPeerType , peerId : Int , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { < nl > ( peerType match { < nl > @ @ - 83 , 4 + 94 , 4 @ @ object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionId < nl > override def lookup = DialogExtension < nl > < nl > override def createExtension ( system : ExtendedActorSystem ) = new DialogExtensionImpl ( system ) < nl > - } < nl > \ No newline at end of file < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index 9552f85 . . 56fd62a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { Future , Promise } < nl > - import scala . util . { Failure , Success , Try } < nl > + import scala . util . Try < nl > < nl > sealed trait SeqUpdatesExtension extends Extension { < nl > val region : SeqUpdatesManagerRegion < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > index cd328be . . 2a6c005 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > @ @ - 10 , 11 + 10 , 11 @ @ import im . actor . api . rpc . users . ApiUser < nl > import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } < nl > import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . group . { GroupExtension , GroupOffice , GroupViewRegion } < nl > + import im . actor . server . group . GroupExtension < nl > import im . actor . server . mtproto . protocol . UpdateBox < nl > import im . actor . server . persist < nl > import im . actor . server . presences . _ < nl > - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } < nl > + import im . actor . server . user . UserExtension < nl > import org . joda . time . DateTime < nl > < nl > import scala . concurrent . _ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > index b06a574 . . 533795b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala < nl > @ @ - 33 , 9 + 33 , 17 @ @ private [ user ] sealed trait Commands extends AuthCommands { < nl > < nl > implicit val timeout : Timeout < nl > < nl > - def create ( userId : Int , accessSalt : String , name : String , countryCode : String , sex : ApiSex . ApiSex , isBot : Boolean , extensions : Seq [ ApiExtension ] , external : Option [ String ] ) : Future [ CreateAck ] = { < nl > + def create ( < nl > + userId : Int , < nl > + accessSalt : String , < nl > + name : String , < nl > + countryCode : String , < nl > + sex : ApiSex . ApiSex , < nl > + isBot : Boolean , < nl > + extensions : Seq [ ApiExtension ] = Seq . empty , < nl > + external : Option [ String ] = None < nl > + ) : Future [ CreateAck ] = < nl > ( processorRegion . ref ? Create ( userId , accessSalt , name , countryCode , sex , isBot , extensions , external ) ) . mapTo [ CreateAck ] < nl > - } < nl > < nl > def addPhone ( userId : Int , phone : Long ) : Future [ Unit ] = { < nl > ( processorRegion . ref ? AddPhone ( userId , phone ) ) . mapTo [ AddPhoneAck ] map ( _ ⇒ ( ) ) < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala < nl > new file mode 100644 < nl > index 0000000 . . 940b6dd < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala < nl > @ @ - 0 , 0 + 1 , 68 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . stream . scaladsl . { Flow , Merge , Source } < nl > + import im . actor . api . rpc . messaging . ApiTextMessage < nl > + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . bot . BotMessages < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . sequence . SeqStateDate < nl > + import upickle . default . _ < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { < nl > + < nl > + import BotMessages . _ < nl > + import akka . stream . scaladsl . FlowGraph . Implicits . _ < nl > + import system . _ < nl > + < nl > + private lazy val dialogExt = DialogExtension ( system ) < nl > + < nl > + val flow : Flow [ String , String , Unit ] = { < nl > + val updSource = < nl > + Source . actorPublisher [ BotUpdate ] ( UpdatesSource . props ( botAuthId ) ) < nl > + . map ( write [ BotUpdate ] ) < nl > + < nl > + val rqrspFlow = Flow [ String ] < nl > + . map ( parseMessage ) < nl > + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) < nl > + . map ( write [ BotResponse ] ) < nl > + < nl > + Flow ( ) { implicit b ⇒ < nl > + val upd = b . add ( updSource ) < nl > + val rqrsp = b . add ( rqrspFlow ) < nl > + val merge = b . add ( Merge [ String ] ( 2 ) ) < nl > + < nl > + upd ~ > merge < nl > + rqrsp ~ > merge < nl > + < nl > + ( rqrsp . inlet , merge . out ) < nl > + } < nl > + } < nl > + < nl > + private def parseMessage ( source : String ) : BotRequest = read [ BotRequest ] ( source ) < nl > + < nl > + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = < nl > + for { < nl > + response ← handleRequestBody ( body ) < nl > + } yield BotResponse ( id , response ) < nl > + < nl > + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { < nl > + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) < nl > + } < nl > + < nl > + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { < nl > + / / FIXME : check access hash < nl > + for { < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , < nl > + senderUserId = botUserId , < nl > + senderAuthId = 0L , < nl > + randomId = randomId , < nl > + message = ApiTextMessage ( message , Vector . empty , None ) , < nl > + isFat = false < nl > + ) < nl > + } yield MessageSent ( date ) < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > new file mode 100644 < nl > index 0000000 . . efa0994 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 0 , 0 + 1 , 46 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . server . Directives . _ < nl > + import akka . http . scaladsl . server . Route < nl > + import akka . stream . scaladsl . Flow < nl > + import cats . data . OptionT < nl > + import cats . std . future . _ < nl > + import im . actor . server . api . http . RoutesHandler < nl > + import im . actor . server . bot . BotExtension < nl > + < nl > + import scala . util . control . NoStackTrace < nl > + < nl > + private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { < nl > + < nl > + import system . _ < nl > + < nl > + private val botExt = BotExtension ( system ) < nl > + < nl > + override def routes : Route = path ( " bots " / Segment ) { token ⇒ < nl > + val flowFuture = ( for { < nl > + userId ← OptionT ( botExt . getUserId ( token ) ) < nl > + authId ← OptionT ( botExt . getAuthId ( token ) ) < nl > + } yield flow ( userId , authId ) ) . value map { < nl > + case Some ( r ) ⇒ r < nl > + case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace < nl > + } < nl > + < nl > + onSuccess ( flowFuture ) { < nl > + case flow ⇒ handleWebsocketMessages ( flow ) < nl > + } < nl > + } < nl > + < nl > + private def flow ( botUserId : Int , botAuthId : Long ) = { < nl > + val bp = new BotBlueprint ( botUserId , botAuthId , system ) < nl > + < nl > + Flow [ Message ] < nl > + . collect { < nl > + case TextMessage . Strict ( text ) ⇒ text < nl > + case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace < nl > + } < nl > + . via ( bp . flow ) < nl > + . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala < nl > new file mode 100644 < nl > index 0000000 . . 40f3804 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala < nl > @ @ - 0 , 0 + 1 , 95 @ @ < nl > + package im . actor . server . api . http . bots < nl > + < nl > + import akka . actor . { ActorLogging , Props } < nl > + import akka . stream . actor . ActorPublisher < nl > + import im . actor . api . rpc . codecs . _ < nl > + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } < nl > + import im . actor . api . rpc . sequence . SeqUpdate < nl > + import im . actor . bot . BotMessages < nl > + import im . actor . server . mtproto . protocol . UpdateBox < nl > + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > + import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } < nl > + < nl > + import scala . annotation . tailrec < nl > + < nl > + private [ bots ] object UpdatesSource { < nl > + def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) < nl > + } < nl > + < nl > + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging { < nl > + < nl > + import BotMessages . { Peer , TextMessage } < nl > + import akka . stream . actor . ActorPublisherMessage . _ < nl > + import context . _ < nl > + import im . actor . server . sequence . NewUpdate < nl > + < nl > + private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) < nl > + private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) < nl > + private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) < nl > + < nl > + context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) < nl > + < nl > + private var buf = Vector . empty [ BotMessages . BotUpdate ] < nl > + < nl > + def receive = { < nl > + case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ < nl > + UpdateBoxCodec . decode ( bodyBytes ) . require . value match { < nl > + case SeqUpdate ( _ , _ , header , body ) ⇒ < nl > + < nl > + header match { < nl > + case UpdateMessage . header ⇒ < nl > + UpdateMessage . parseFrom ( body ) match { < nl > + case Right ( upd ) ⇒ < nl > + upd . message match { < nl > + case ApiTextMessage ( message , _ , _ ) ⇒ < nl > + log . debug ( " Received ApiTextMessage " ) < nl > + enqueue ( TextMessage ( < nl > + peer = Peer ( upd . peer . ` type ` . id , upd . peer . id ) , < nl > + senderUserId = upd . senderUserId , < nl > + date = upd . date , < nl > + randomId = upd . randomId , < nl > + message = message < nl > + ) ) < nl > + case _ ⇒ < nl > + log . debug ( " Received non - text message , ignoring " ) < nl > + } < nl > + < nl > + case Left ( e ) ⇒ < nl > + log . error ( e , " Failed to parse UpdateMessage " ) < nl > + } < nl > + case _ ⇒ < nl > + log . debug ( " Received SeqUpdate with header : { } , ignoring " , header ) < nl > + } < nl > + case _ ⇒ < nl > + } < nl > + case Request ( _ ) ⇒ < nl > + deliverBuf ( ) < nl > + case Cancel ⇒ < nl > + context . stop ( self ) < nl > + } < nl > + < nl > + private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { < nl > + log . debug ( " Enqueuing { } " , upd ) < nl > + < nl > + if ( buf . isEmpty & & totalDemand > 0 ) { < nl > + onNext ( upd ) < nl > + } else { < nl > + buf : + = upd < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + @ tailrec final def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) < nl > + buf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) < nl > + buf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > index 8e12f6e . . aa01de9 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala < nl > @ @ - 43 , 6 + 43 , 7 @ @ object AuthId { < nl > < nl > val activeByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) ) < nl > val activeIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) ) < nl > + val firstActiveIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) take ( 1 ) ) < nl > < nl > def activeIdByUserIds ( userIds : Set [ Int ] ) = activeAuthIds . filter ( _ . userId inSetBind userIds ) . map ( _ . id ) < nl > < nl > @ @ - 61 , 6 + 62 , 9 @ @ object AuthId { < nl > def findIdByUserId ( userId : Int ) = < nl > activeIdByUserIdCompiled ( userId ) . result < nl > < nl > + def findFirstIdByUserId ( userId : Int ) = < nl > + firstActiveIdByUserIdCompiled ( userId ) . result . headOption < nl > + < nl > def findIdByUserIds ( userIds : Set [ Int ] ) = < nl > activeIdByUserIds ( userIds ) . result < nl > < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index c55ec26 . . 5ce2887 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 113 , 7 + 113 , 7 @ @ object Main extends App { < nl > new EmailSender ( emailConfig ) < nl > ) < nl > case " actor - activation " ⇒ new GateCodeActivation ( gateConfig ) < nl > - case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) < nl > + case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) < nl > } < nl > < nl > implicit val sessionRegion = Session . startRegion ( < nl > @ @ - 146 , 10 + 146 , 10 @ @ object Main extends App { < nl > Frontend . start ( serverConfig ) < nl > HttpApiFrontend . start ( serverConfig ) < nl > } catch { < nl > - case e : ConfigException = > < nl > + case e : ConfigException ⇒ < nl > system . log . error ( e , " Failed to load server configuration " ) < nl > throw e < nl > - case e : Throwable = > < nl > + case e : Throwable ⇒ < nl > system . log . error ( e , " Server failed to start up " ) < nl > throw e < nl > } < nl > diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > index 281b729 . . 1402287 100644 < nl > - - - a / actor - server / actor - runtime / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > @ @ - 19 , 6 + 19 , 10 @ @ tls { < nl > } < nl > } < nl > < nl > + common { < nl > + default - timeout : 20 seconds < nl > + } < nl > + < nl > akka { < nl > extensions = $ { akka . extensions } [ < nl > " akka . contrib . pattern . DistributedPubSubExtension " , < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index badb833 . . 0cef7d5 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 1 , 5 + 1 , 8 @ @ < nl > package im . actor . config < nl > < nl > + import scala . concurrent . duration . _ < nl > + import java . util . concurrent . TimeUnit < nl > + < nl > import com . typesafe . config . { Config , ConfigFactory } < nl > < nl > object ActorConfig { < nl > @ @ - 31 , 4 + 34 , 6 @ @ object ActorConfig { < nl > ) ) < nl > . resolve ( ) < nl > } < nl > + < nl > + val defaultTimeout : FiniteDuration = ActorConfig . load ( ) . getDuration ( " common . default - timeout " , TimeUnit . MILLISECONDS ) . millis < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > index 2d4d434 . . 980b06d 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala < nl > @ @ - 24 , 8 + 24 , 6 @ @ object SessionStreamMessage { < nl > < nl > @ SerialVersionUID ( 1L ) < nl > case class SendProtoMessage ( message : ProtoMessage with OutgoingProtoMessage ) extends SessionStreamMessage < nl > - < nl > - case class EnqueuedProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) extends SessionStreamMessage < nl > } < nl > < nl > private [ session ] object SessionStream { < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > index 5656c80 . . fa15f5e 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala < nl > @ @ - 2 , 10 + 2 , 9 @ @ package im . actor . server . session < nl > < nl > import akka . actor . { ActorLogging , Props } < nl > import akka . stream . actor . _ < nl > - import im . actor . server . mtproto . protocol . ProtoMessage < nl > + import im . actor . server . mtproto . protocol . UpdateBox < nl > import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } < nl > import im . actor . server . sequence . _ < nl > - import im . actor . server . session . SessionStreamMessage . EnqueuedProtoMessage < nl > < nl > import scala . annotation . tailrec < nl > import scala . collection . immutable < nl > @ @ - 26 , 7 + 25 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > weakUpdManagerRegion : WeakUpdatesManagerRegion , < nl > presenceManagerRegion : PresenceManagerRegion , < nl > groupPresenceManagerRegion : GroupPresenceManagerRegion < nl > - ) extends ActorSubscriber with ActorPublisher [ ( ProtoMessage , Option [ String ] ) ] with ActorLogging { < nl > + ) extends ActorSubscriber with ActorPublisher [ ( UpdateBox , Option [ String ] ) ] with ActorLogging { < nl > < nl > import ActorPublisherMessage . _ < nl > import ActorSubscriberMessage . _ < nl > @ @ - 62 , 7 + 61 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > override val requestStrategy = WatermarkRequestStrategy ( 10 ) / / TODO : configurable < nl > < nl > / / Publisher - related < nl > - private [ this ] var messageQueue = immutable . Queue . empty [ ( ProtoMessage , Option [ String ] ) ] < nl > + private [ this ] var messageQueue = immutable . Queue . empty [ ( UpdateBox , Option [ String ] ) ] < nl > < nl > def publisher : Receive = { < nl > case NewUpdate ( ub , reduceKey ) ⇒ enqueueProtoMessage ( ub , reduceKey ) < nl > @ @ - 70 , 7 + 69 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( < nl > case Cancel ⇒ context . stop ( self ) < nl > } < nl > < nl > - private def enqueueProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) : Unit = { < nl > + private def enqueueProtoMessage ( message : UpdateBox , reduceKey : Option [ String ] ) : Unit = { < nl > if ( messageQueue . isEmpty & & totalDemand > 0 ) { < nl > onNext ( message → reduceKey ) < nl > } else { < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 5fb9a44 . . b96b492 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 114 , 6 + 114 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > settings = defaultSettings < nl > ) . dependsOn ( < nl > actorActivation , < nl > + actorBot , < nl > actorEnrich , < nl > actorEmail , < nl > actorFrontend , < nl > @ @ - 133 , 6 + 134 , 24 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > ) < nl > ) . dependsOn ( actorEmail , actorSms , actorPersist ) < nl > < nl > + lazy val actorBot = Project ( < nl > + id = " actor - bot " , < nl > + base = file ( " actor - bot " ) , < nl > + settings = defaultSettings + + < nl > + Seq ( < nl > + libraryDependencies + + = Dependencies . bot < nl > + ) < nl > + ) . dependsOn ( actorBotMessages , shardakka , actorCore ) < nl > + < nl > + lazy val actorBotMessages = Project ( < nl > + id = " actor - bot - messages " , < nl > + base = file ( " actor - bot - messages " ) , < nl > + settings = defaultSettings + + < nl > + Seq ( < nl > + libraryDependencies + + = Dependencies . botMessages < nl > + ) < nl > + ) < nl > + < nl > lazy val actorCore = Project ( < nl > id = " actor - core " , < nl > base = file ( " actor - core " ) , < nl > @ @ - 164 , 7 + 183 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > settings = defaultSettings + + Seq ( < nl > libraryDependencies + + = Dependencies . httpApi < nl > ) < nl > - ) . dependsOn ( actorCore , actorPersist , actorRuntime ) < nl > + ) . dependsOn ( actorBot , actorCore , actorPersist , actorRuntime ) < nl > < nl > lazy val actorOAuth = Project ( < nl > id = " actor - oauth " , < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index ce84317 . . 428af06 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 9 , 7 + 9 , 7 @ @ object Dependencies { < nl > val scalaz = " 7 . 1 . 1 " < nl > val slick = " 3 . 0 . 3 " < nl > val scalatest = " 2 . 2 . 4 " < nl > - val catsVersion = " 0 . 1 . 2 " < nl > + val catsVersion = " 0 . 2 . 0 " < nl > < nl > } < nl > < nl > @ @ - 30 , 8 + 30 , 7 @ @ object Dependencies { < nl > val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " < nl > val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " < nl > < nl > - val cats = " org . spire - math " % % " cats - core " % V . catsVersion < nl > - val catsStd = " org . spire - math " % % " cats - std " % V . catsVersion < nl > + val cats = " org . spire - math " % % " cats " % V . catsVersion < nl > < nl > val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " < nl > < nl > @ @ - 39 , 6 + 38 , 7 @ @ object Dependencies { < nl > val javaCompat = " org . scala - lang . modules " % % " scala - java8 - compat " % " 0 . 5 . 0 " < nl > < nl > val playJson = " com . typesafe . play " % % " play - json " % " 2 . 4 . 2 " < nl > + val upickle = " com . lihaoyi " % % " upickle " % " 0 . 3 . 6 " < nl > < nl > val postgresJdbc = " org . postgresql " % " postgresql " % " 9 . 4 - 1201 - jdbc41 " exclude ( " org . slf4j " , " slf4j - simple " ) < nl > val slick = " com . typesafe . slick " % % " slick " % V . slick < nl > @ @ - 102 , 6 + 102 , 10 @ @ object Dependencies { < nl > < nl > val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) < nl > < nl > + val bot = shared + + Seq ( upickle ) < nl > + < nl > + val botMessages = Seq ( upickle ) < nl > + < nl > val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) < nl > < nl > val enrich = shared + + Seq ( akkaActor , akkaHttp ) < nl > @ @ - 146 , 7 + 150 , 7 @ @ object Dependencies { < nl > < nl > val notifications = shared + + Seq ( akkaContrib , slick ) < nl > < nl > - val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , catsStd , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) < nl > + val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) < nl > < nl > val voximplant = shared + + Seq ( akkaActor , dispatch , playJson )

TEST DIFF:
diff - - git a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 index 161c9c8 . . cfddd9f 100644 
 - - - a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 + + + b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 @ @ - 292 , 7 + 292 , 7 @ @ object BotMessages { 
 override def readResponse ( obj : Js . Obj ) = readJs [ MessageSent ] ( obj ) 
 } 
 
 - @ key ( " SendMessage " ) 
 + @ key ( " UpdateMessageContent " ) 
 final case class UpdateMessageContent ( 
 @ beanGetter peer : OutPeer , 
 @ beanGetter randomId : Long , 
 diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 index 6a28636 . . 2488aae 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / services / MessagingBotService . scala 
 @ @ - 1 , 19 + 1 , 39 @ @ 
 package im . actor . server . bot . services 
 
 import akka . actor . ActorSystem 
 - import im . actor . server . bot . { BotToApiConversions , BotServiceBase } 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessageContentChanged } 
 + import im . actor . bots . BotMessages . BotError 
 + import im . actor . concurrent . FutureResultCats 
 + import im . actor . server . bot . { BotServiceBase , BotToApiConversions } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . group . GroupExtension 
 + import im . actor . server . model . { Peer ⇒ ModelPeer , PeerType } 
 + import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . sequence . SeqStateDate 
 
 - private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) with BotToApiConversions { 
 + import scala . concurrent . Future 
 
 + private [ bot ] object MessagingBotErrors { 
 + val Forbidden = BotError ( 403 , " FORBIDDEN " ) 
 + } 
 + 
 + private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotServiceBase ( system ) 
 + with FutureResultCats [ BotError ] 
 + with BotToApiConversions 
 + with PeersImplicits { 
 + 
 + import MessagingBotErrors . _ 
 import im . actor . bots . BotMessages . _ 
 import system . dispatcher 
 
 private lazy val dialogExt = DialogExtension ( system ) 
 + private lazy val db = DbExtension ( system ) . db 
 
 override val handlers : PartialFunction [ RequestBody , WeakRequestHandler ] = { 
 - case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak 
 + case SendMessage ( peer , randomId , message ) ⇒ sendMessage ( peer , randomId , message ) . toWeak 
 + case UpdateMessageContent ( peer , randomId , message ) ⇒ updateMessageContent ( peer , randomId , message ) . toWeak 
 } 
 
 private def sendMessage ( peer : OutPeer , randomId : Long , message : MessageBody ) = RequestHandler [ SendMessage , SendMessage # Response ] ( 
 @ @ - 32 , 4 + 52 , 66 @ @ private [ bot ] final class MessagingBotService ( system : ActorSystem ) extends BotSer 
 } yield Right ( MessageSent ( date ) ) 
 } 
 ) 
 + 
 + / / allow bot to update only it ' s messages . Bot won ' t not be able to modify user ' s messages 
 + private def updateMessageContent ( peer : OutPeer , randomId : Long , updatedMessage : MessageBody ) = RequestHandler [ UpdateMessageContent , UpdateMessageContent # Response ] ( 
 + ( botUserId : BotUserId , botAuthId : BotAuthId , botAuthSid : BotAuthSid ) ⇒ { 
 + val peerModel = toPeer ( peer ) . asModel 
 + val botPeer = ModelPeer . privat ( botUserId ) 
 + ( for { 
 + _ ← fromFutureBoolean ( Forbidden ) ( db . run ( HistoryMessageRepo . findBySender ( botUserId , peerModel , randomId ) . headOption map ( _ . nonEmpty ) ) ) 
 + _ ← fromFuture ( peer match { 
 + case UserOutPeer ( userId , _ ) ⇒ updateContentPrivate ( peerModel . id , botPeer , randomId , updatedMessage ) 
 + case GroupOutPeer ( groupId , _ ) ⇒ updateContentGroup ( botUserId , peerModel , randomId , updatedMessage ) 
 + } ) 
 + } yield MessageContentUpdated ) . value 
 + } 
 + ) 
 + 
 + private def updateContentPrivate ( userId : Int , botPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 + val upd = UpdateMessageContentChanged ( botPeer . asStruct , randomId , updatedMessage ) 
 + for { 
 + _ ← userExt . broadcastUserUpdate ( 
 + userId = userId , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + reduceKey = None , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = Set ( userId , botPeer . id ) , 
 + randomId = randomId , 
 + peerType = PeerType . Private , 
 + peerIds = Set ( userId , botPeer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield ( ) 
 + } 
 + 
 + private def updateContentGroup ( botUserId : Int , groupPeer : ModelPeer , randomId : Long , updatedMessage : ApiMessage ) : Future [ Unit ] = { 
 + / / no need to send update to bot itself 
 + val upd = UpdateMessageContentChanged ( groupPeer . asStruct , randomId , updatedMessage ) 
 + for { 
 + ( memberIds , _ , _ ) ← GroupExtension ( system ) . getMemberIds ( groupPeer . id ) 
 + membersSet = memberIds . toSet 
 + _ ← userExt . broadcastUsersUpdate ( 
 + userIds = membersSet , 
 + update = upd , 
 + pushText = None , 
 + isFat = false , 
 + deliveryId = Some ( s " msgcontent _ $ randomId " ) 
 + ) 
 + _ ← db . run ( HistoryMessageRepo . updateContentAll ( 
 + userIds = membersSet + botUserId , 
 + randomId = randomId , 
 + peerType = PeerType . Group , 
 + peerIds = Set ( groupPeer . id ) , 
 + messageContentHeader = updatedMessage . header , 
 + messageContentData = updatedMessage . toByteArray 
 + ) ) 
 + } yield ( ) 
 + } 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 0eceef8 . . 2907ae8 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import sbt . _ 
 object Dependencies { 
 object V { 
 val actorCommons = " 0 . 0 . 13 " 
 - val actorBotkit = " 1 . 0 . 72 " 
 + val actorBotkit = " 1 . 0 . 75 " 
 val akka = " 2 . 4 . 2 - RC2 " 
 val akkaHttpJson = " 1 . 5 . 0 " 
 val cats = " 0 . 3 . 0 "

NEAREST DIFF:
diff - - git a / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 new file mode 100644 
 index 0000000 . . 9b8e44a 
 - - - / dev / null 
 + + + b / actor - server / actor - bot - messages / src / main / scala / im / actor / bot / BotMessages . scala 
 @ @ - 0 , 0 + 1 , 33 @ @ 
 + package im . actor . bot 
 + 
 + import derive . key 
 + 
 + sealed trait BotMessage 
 + 
 + final object BotMessages { 
 + final object OutPeer { 
 + def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) 
 + def group ( id : Int , accessHash : Long ) = OutPeer ( 2 , id , accessHash ) 
 + } 
 + final case class OutPeer ( ` type ` : Int , id : Int , accessHash : Long ) 
 + final case class Peer ( ` type ` : Int , id : Int ) 
 + 
 + sealed trait RequestBody 
 + 
 + final case class BotRequest ( id : Long , body : RequestBody ) extends BotMessage 
 + 
 + @ key ( " SendMessage " ) 
 + final case class SendTextMessage ( peer : OutPeer , randomId : Long , message : String ) extends RequestBody 
 + 
 + sealed trait ResponseBody 
 + 
 + final case class BotResponse ( id : Long , body : ResponseBody ) extends BotMessage 
 + 
 + @ key ( " MessageSent " ) 
 + final case class MessageSent ( date : Long ) extends ResponseBody 
 + 
 + sealed trait BotUpdate extends BotMessage 
 + 
 + @ key ( " TextMessage " ) 
 + final case class TextMessage ( peer : Peer , senderUserId : Int , date : Long , randomId : Long , message : String ) extends BotUpdate 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala 
 new file mode 100644 
 index 0000000 . . f2d446e 
 - - - / dev / null 
 + + + b / actor - server / actor - bot / src / main / scala / im / actor / server / bot / BotExtension . scala 
 @ @ - 0 , 0 + 1 , 98 @ @ 
 + package im . actor . server . bot 
 + 
 + import akka . actor . { ExtendedActorSystem , ExtensionId , ActorSystem , Extension } 
 + import akka . util . Timeout 
 + import im . actor . api . rpc . users . ApiSex 
 + import im . actor . config . ActorConfig 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . user . UserExtension 
 + import im . actor . server . persist 
 + import im . actor . util . misc . IdUtils 
 + import shardakka . ShardakkaExtension 
 + 
 + import scala . concurrent . Future 
 + 
 + object BotExtension extends ExtensionId [ BotExtension ] { 
 + private [ bot ] val tokensKV = " BotsTokens " 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) : BotExtension = new BotExtensionImpl ( system ) 
 + } 
 + 
 + trait BotExtension extends Extension { 
 + type Token = String 
 + type UserId = Int 
 + type AuthId = Long 
 + 
 + / * * 
 + * Creates a bot user 
 + * 
 + * @ return token future 
 + * / 
 + def create ( name : String ) : Future [ Token ] 
 + 
 + / * * 
 + * Gets userId associated with token 
 + * 
 + * @ param token 
 + * @ return user id 
 + * / 
 + def getUserId ( token : String ) : Future [ Option [ UserId ] ] 
 + 
 + / * * 
 + * Gets or creates bot auth id 
 + * @ param token 
 + * @ return auth id 
 + * / 
 + def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] 
 + } 
 + 
 + private [ bot ] final class BotExtensionImpl ( _ system : ActorSystem ) extends BotExtension { 
 + import _ system . _ 
 + 
 + private implicit val system = _ system 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private lazy val userExt = UserExtension ( system ) 
 + private lazy val tokensKV = ShardakkaExtension ( system ) . simpleKeyValue ( BotExtension . tokensKV ) 
 + private lazy val db = DbExtension ( system ) . db 
 + 
 + override def create ( name : String ) : Future [ Token ] = { 
 + val userId = IdUtils . nextIntId ( ) 
 + val token = ACLUtils . randomHash ( ) 
 + 
 + for { 
 + user ← userExt . create ( 
 + userId = userId , 
 + accessSalt = ACLUtils . nextAccessSalt ( ) , 
 + name = name , 
 + countryCode = " US " , 
 + sex = ApiSex . Unknown , 
 + isBot = true 
 + ) 
 + _ ← tokensKV . upsert ( token , s " $ userId " ) 
 + } yield token 
 + } 
 + 
 + override def getUserId ( token : String ) : Future [ Option [ UserId ] ] = { 
 + for { 
 + tokOpt ← tokensKV . get ( token ) 
 + } yield tokOpt map ( _ . toInt ) 
 + } 
 + 
 + override def getAuthId ( token : String ) : Future [ Option [ AuthId ] ] = { 
 + getUserId ( token ) flatMap { 
 + case Some ( userId ) ⇒ getOrCreateAuthId ( userId ) map ( Some ( _ ) ) 
 + case None ⇒ Future . successful ( None ) 
 + } 
 + } 
 + 
 + private def getOrCreateAuthId ( userId : Int ) : Future [ AuthId ] = { 
 + db . run ( persist . AuthId . findFirstIdByUserId ( userId ) ) flatMap { 
 + case Some ( authId ) ⇒ Future . successful ( authId ) 
 + case None ⇒ 
 + val authId = ACLUtils . randomLong ( ) 
 + db . run ( persist . AuthId . create ( authId , Some ( userId ) , None ) ) map ( _ ⇒ authId ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 index ba37e90 . . 734f1f9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 @ @ - 46 , 7 + 46 , 18 @ @ object ACLUtils { 
 def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = 
 DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) 
 
 - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString 
 + def randomHash ( ) ( implicit s : ActorSystem ) : String = 
 + DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) 
 + 
 + def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) 
 + 
 + def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) 
 + 
 + def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) 
 + 
 + def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString 
 + 
 + def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) 
 
 def nextAccessSalt ( ) : String = { 
 nextAccessSalt ( ThreadLocalRandom . current ( ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index bd3b59c . . 79e425b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 5 , 6 + 5 , 7 @ @ import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . api . rpc . messaging . ApiMessage 
 import im . actor . api . rpc . misc . ApiExtension 
 + import im . actor . api . rpc . peers . ApiPeer 
 import im . actor . api . rpc . peers . ApiPeerType . _ 
 import im . actor . api . rpc . peers . ApiPeerType . ApiPeerType 
 import im . actor . extension . InternalExtensions 
 @ @ - 28 , 7 + 29 , 17 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension { 
 
 implicit val s : ActorSystem = system 
 implicit val ec : ExecutionContext = system . dispatcher 
 - implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable 
 + implicit val timeout : Timeout = Timeout ( 20 . seconds ) / / TODO : configurable 
 + 
 + def sendMessage ( 
 + peer : ApiPeer , 
 + senderUserId : Int , 
 + senderAuthId : Long , 
 + randomId : Long , 
 + message : ApiMessage , 
 + isFat : Boolean 
 + ) : Future [ SeqStateDate ] = 
 + sendMessage ( peer . ` type ` , peer . id , senderUserId , senderAuthId , randomId , message , isFat ) 
 
 def sendMessage ( peerType : ApiPeerType , peerId : Int , senderUserId : Int , senderAuthId : Long , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = { 
 ( peerType match { 
 @ @ - 83 , 4 + 94 , 4 @ @ object DialogExtension extends ExtensionId [ DialogExtensionImpl ] with ExtensionId 
 override def lookup = DialogExtension 
 
 override def createExtension ( system : ExtendedActorSystem ) = new DialogExtensionImpl ( system ) 
 - } 
 \ No newline at end of file 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index 9552f85 . . 56fd62a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { Future , Promise } 
 - import scala . util . { Failure , Success , Try } 
 + import scala . util . Try 
 
 sealed trait SeqUpdatesExtension extends Extension { 
 val region : SeqUpdatesManagerRegion 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 index cd328be . . 2a6c005 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 @ @ - 10 , 11 + 10 , 11 @ @ import im . actor . api . rpc . users . ApiUser 
 import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } 
 import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . group . { GroupExtension , GroupOffice , GroupViewRegion } 
 + import im . actor . server . group . GroupExtension 
 import im . actor . server . mtproto . protocol . UpdateBox 
 import im . actor . server . persist 
 import im . actor . server . presences . _ 
 - import im . actor . server . user . { UserExtension , UserOffice , UserViewRegion } 
 + import im . actor . server . user . UserExtension 
 import org . joda . time . DateTime 
 
 import scala . concurrent . _ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 index b06a574 . . 533795b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserOperations . scala 
 @ @ - 33 , 9 + 33 , 17 @ @ private [ user ] sealed trait Commands extends AuthCommands { 
 
 implicit val timeout : Timeout 
 
 - def create ( userId : Int , accessSalt : String , name : String , countryCode : String , sex : ApiSex . ApiSex , isBot : Boolean , extensions : Seq [ ApiExtension ] , external : Option [ String ] ) : Future [ CreateAck ] = { 
 + def create ( 
 + userId : Int , 
 + accessSalt : String , 
 + name : String , 
 + countryCode : String , 
 + sex : ApiSex . ApiSex , 
 + isBot : Boolean , 
 + extensions : Seq [ ApiExtension ] = Seq . empty , 
 + external : Option [ String ] = None 
 + ) : Future [ CreateAck ] = 
 ( processorRegion . ref ? Create ( userId , accessSalt , name , countryCode , sex , isBot , extensions , external ) ) . mapTo [ CreateAck ] 
 - } 
 
 def addPhone ( userId : Int , phone : Long ) : Future [ Unit ] = { 
 ( processorRegion . ref ? AddPhone ( userId , phone ) ) . mapTo [ AddPhoneAck ] map ( _ ⇒ ( ) ) 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala 
 new file mode 100644 
 index 0000000 . . 940b6dd 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotBlueprint . scala 
 @ @ - 0 , 0 + 1 , 68 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . ActorSystem 
 + import akka . stream . scaladsl . { Flow , Merge , Source } 
 + import im . actor . api . rpc . messaging . ApiTextMessage 
 + import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . bot . BotMessages 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . sequence . SeqStateDate 
 + import upickle . default . _ 
 + 
 + import scala . concurrent . Future 
 + 
 + final class BotBlueprint ( botUserId : Int , botAuthId : Long , system : ActorSystem ) { 
 + 
 + import BotMessages . _ 
 + import akka . stream . scaladsl . FlowGraph . Implicits . _ 
 + import system . _ 
 + 
 + private lazy val dialogExt = DialogExtension ( system ) 
 + 
 + val flow : Flow [ String , String , Unit ] = { 
 + val updSource = 
 + Source . actorPublisher [ BotUpdate ] ( UpdatesSource . props ( botAuthId ) ) 
 + . map ( write [ BotUpdate ] ) 
 + 
 + val rqrspFlow = Flow [ String ] 
 + . map ( parseMessage ) 
 + . mapAsync ( 1 ) ( r ⇒ handleRequest ( r . id , r . body ) ) 
 + . map ( write [ BotResponse ] ) 
 + 
 + Flow ( ) { implicit b ⇒ 
 + val upd = b . add ( updSource ) 
 + val rqrsp = b . add ( rqrspFlow ) 
 + val merge = b . add ( Merge [ String ] ( 2 ) ) 
 + 
 + upd ~ > merge 
 + rqrsp ~ > merge 
 + 
 + ( rqrsp . inlet , merge . out ) 
 + } 
 + } 
 + 
 + private def parseMessage ( source : String ) : BotRequest = read [ BotRequest ] ( source ) 
 + 
 + private def handleRequest ( id : Long , body : RequestBody ) : Future [ BotResponse ] = 
 + for { 
 + response ← handleRequestBody ( body ) 
 + } yield BotResponse ( id , response ) 
 + 
 + private def handleRequestBody ( body : RequestBody ) : Future [ ResponseBody ] = body match { 
 + case SendTextMessage ( peer , randomId , message ) ⇒ sendTextMessage ( peer , randomId , message ) 
 + } 
 + 
 + private def sendTextMessage ( peer : OutPeer , randomId : Long , message : String ) : Future [ ResponseBody ] = { 
 + / / FIXME : check access hash 
 + for { 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType ( peer . ` type ` ) , peer . id ) , 
 + senderUserId = botUserId , 
 + senderAuthId = 0L , 
 + randomId = randomId , 
 + message = ApiTextMessage ( message , Vector . empty , None ) , 
 + isFat = false 
 + ) 
 + } yield MessageSent ( date ) 
 + } 
 + } 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 new file mode 100644 
 index 0000000 . . efa0994 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . ActorSystem 
 + import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . server . Directives . _ 
 + import akka . http . scaladsl . server . Route 
 + import akka . stream . scaladsl . Flow 
 + import cats . data . OptionT 
 + import cats . std . future . _ 
 + import im . actor . server . api . http . RoutesHandler 
 + import im . actor . server . bot . BotExtension 
 + 
 + import scala . util . control . NoStackTrace 
 + 
 + private [ http ] final class BotsHandler ( system : ActorSystem ) extends RoutesHandler { 
 + 
 + import system . _ 
 + 
 + private val botExt = BotExtension ( system ) 
 + 
 + override def routes : Route = path ( " bots " / Segment ) { token ⇒ 
 + val flowFuture = ( for { 
 + userId ← OptionT ( botExt . getUserId ( token ) ) 
 + authId ← OptionT ( botExt . getAuthId ( token ) ) 
 + } yield flow ( userId , authId ) ) . value map { 
 + case Some ( r ) ⇒ r 
 + case None ⇒ throw new RuntimeException ( " Wrong token " ) with NoStackTrace 
 + } 
 + 
 + onSuccess ( flowFuture ) { 
 + case flow ⇒ handleWebsocketMessages ( flow ) 
 + } 
 + } 
 + 
 + private def flow ( botUserId : Int , botAuthId : Long ) = { 
 + val bp = new BotBlueprint ( botUserId , botAuthId , system ) 
 + 
 + Flow [ Message ] 
 + . collect { 
 + case TextMessage . Strict ( text ) ⇒ text 
 + case tm : TextMessage ⇒ throw new RuntimeException ( " Streamed text message is not supported " ) with NoStackTrace 
 + } 
 + . via ( bp . flow ) 
 + . map ( TextMessage . Strict ( _ ) . asInstanceOf [ Message ] ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala 
 new file mode 100644 
 index 0000000 . . 40f3804 
 - - - / dev / null 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / UpdatesSource . scala 
 @ @ - 0 , 0 + 1 , 95 @ @ 
 + package im . actor . server . api . http . bots 
 + 
 + import akka . actor . { ActorLogging , Props } 
 + import akka . stream . actor . ActorPublisher 
 + import im . actor . api . rpc . codecs . _ 
 + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessage } 
 + import im . actor . api . rpc . sequence . SeqUpdate 
 + import im . actor . bot . BotMessages 
 + import im . actor . server . mtproto . protocol . UpdateBox 
 + import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 + import im . actor . server . sequence . { UpdatesConsumer , WeakUpdatesManager } 
 + 
 + import scala . annotation . tailrec 
 + 
 + private [ bots ] object UpdatesSource { 
 + def props ( authId : Long ) = Props ( classOf [ UpdatesSource ] , authId ) 
 + } 
 + 
 + private class UpdatesSource ( authId : Long ) extends ActorPublisher [ BotMessages . BotUpdate ] with ActorLogging { 
 + 
 + import BotMessages . { Peer , TextMessage } 
 + import akka . stream . actor . ActorPublisherMessage . _ 
 + import context . _ 
 + import im . actor . server . sequence . NewUpdate 
 + 
 + private implicit val weakUpdatesManagerRegion = WeakUpdatesManager . startRegionProxy ( ) 
 + private implicit val presenceManagerRegion = PresenceManager . startRegionProxy ( ) 
 + private implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegionProxy ( ) 
 + 
 + context . actorOf ( UpdatesConsumer . props ( authId , self ) , " updatesConsumer " ) 
 + 
 + private var buf = Vector . empty [ BotMessages . BotUpdate ] 
 + 
 + def receive = { 
 + case NewUpdate ( UpdateBox ( bodyBytes ) , _ ) ⇒ 
 + UpdateBoxCodec . decode ( bodyBytes ) . require . value match { 
 + case SeqUpdate ( _ , _ , header , body ) ⇒ 
 + 
 + header match { 
 + case UpdateMessage . header ⇒ 
 + UpdateMessage . parseFrom ( body ) match { 
 + case Right ( upd ) ⇒ 
 + upd . message match { 
 + case ApiTextMessage ( message , _ , _ ) ⇒ 
 + log . debug ( " Received ApiTextMessage " ) 
 + enqueue ( TextMessage ( 
 + peer = Peer ( upd . peer . ` type ` . id , upd . peer . id ) , 
 + senderUserId = upd . senderUserId , 
 + date = upd . date , 
 + randomId = upd . randomId , 
 + message = message 
 + ) ) 
 + case _ ⇒ 
 + log . debug ( " Received non - text message , ignoring " ) 
 + } 
 + 
 + case Left ( e ) ⇒ 
 + log . error ( e , " Failed to parse UpdateMessage " ) 
 + } 
 + case _ ⇒ 
 + log . debug ( " Received SeqUpdate with header : { } , ignoring " , header ) 
 + } 
 + case _ ⇒ 
 + } 
 + case Request ( _ ) ⇒ 
 + deliverBuf ( ) 
 + case Cancel ⇒ 
 + context . stop ( self ) 
 + } 
 + 
 + private def enqueue ( upd : BotMessages . BotUpdate ) : Unit = { 
 + log . debug ( " Enqueuing { } " , upd ) 
 + 
 + if ( buf . isEmpty & & totalDemand > 0 ) { 
 + onNext ( upd ) 
 + } else { 
 + buf : + = upd 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + @ tailrec final def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) 
 + buf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) 
 + buf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 index 8e12f6e . . aa01de9 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / AuthId . scala 
 @ @ - 43 , 6 + 43 , 7 @ @ object AuthId { 
 
 val activeByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) ) 
 val activeIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) ) 
 + val firstActiveIdByUserIdCompiled = Compiled ( ( userId : Rep [ Int ] ) ⇒ activeByUserId ( userId ) map ( _ . id ) take ( 1 ) ) 
 
 def activeIdByUserIds ( userIds : Set [ Int ] ) = activeAuthIds . filter ( _ . userId inSetBind userIds ) . map ( _ . id ) 
 
 @ @ - 61 , 6 + 62 , 9 @ @ object AuthId { 
 def findIdByUserId ( userId : Int ) = 
 activeIdByUserIdCompiled ( userId ) . result 
 
 + def findFirstIdByUserId ( userId : Int ) = 
 + firstActiveIdByUserIdCompiled ( userId ) . result . headOption 
 + 
 def findIdByUserIds ( userIds : Set [ Int ] ) = 
 activeIdByUserIds ( userIds ) . result 
 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index c55ec26 . . 5ce2887 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 113 , 7 + 113 , 7 @ @ object Main extends App { 
 new EmailSender ( emailConfig ) 
 ) 
 case " actor - activation " ⇒ new GateCodeActivation ( gateConfig ) 
 - case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) 
 + case _ ⇒ throw new Exception ( " " " Invalid activation . default - service value provided : valid options : " internal " , actor - activation " " " ) 
 } 
 
 implicit val sessionRegion = Session . startRegion ( 
 @ @ - 146 , 10 + 146 , 10 @ @ object Main extends App { 
 Frontend . start ( serverConfig ) 
 HttpApiFrontend . start ( serverConfig ) 
 } catch { 
 - case e : ConfigException = > 
 + case e : ConfigException ⇒ 
 system . log . error ( e , " Failed to load server configuration " ) 
 throw e 
 - case e : Throwable = > 
 + case e : Throwable ⇒ 
 system . log . error ( e , " Server failed to start up " ) 
 throw e 
 } 
 diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf 
 index 281b729 . . 1402287 100644 
 - - - a / actor - server / actor - runtime / src / main / resources / reference . conf 
 + + + b / actor - server / actor - runtime / src / main / resources / reference . conf 
 @ @ - 19 , 6 + 19 , 10 @ @ tls { 
 } 
 } 
 
 + common { 
 + default - timeout : 20 seconds 
 + } 
 + 
 akka { 
 extensions = $ { akka . extensions } [ 
 " akka . contrib . pattern . DistributedPubSubExtension " , 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index badb833 . . 0cef7d5 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 1 , 5 + 1 , 8 @ @ 
 package im . actor . config 
 
 + import scala . concurrent . duration . _ 
 + import java . util . concurrent . TimeUnit 
 + 
 import com . typesafe . config . { Config , ConfigFactory } 
 
 object ActorConfig { 
 @ @ - 31 , 4 + 34 , 6 @ @ object ActorConfig { 
 ) ) 
 . resolve ( ) 
 } 
 + 
 + val defaultTimeout : FiniteDuration = ActorConfig . load ( ) . getDuration ( " common . default - timeout " , TimeUnit . MILLISECONDS ) . millis 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 index 2d4d434 . . 980b06d 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / SessionStream . scala 
 @ @ - 24 , 8 + 24 , 6 @ @ object SessionStreamMessage { 
 
 @ SerialVersionUID ( 1L ) 
 case class SendProtoMessage ( message : ProtoMessage with OutgoingProtoMessage ) extends SessionStreamMessage 
 - 
 - case class EnqueuedProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) extends SessionStreamMessage 
 } 
 
 private [ session ] object SessionStream { 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 index 5656c80 . . fa15f5e 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / UpdatesHandler . scala 
 @ @ - 2 , 10 + 2 , 9 @ @ package im . actor . server . session 
 
 import akka . actor . { ActorLogging , Props } 
 import akka . stream . actor . _ 
 - import im . actor . server . mtproto . protocol . ProtoMessage 
 + import im . actor . server . mtproto . protocol . UpdateBox 
 import im . actor . server . presences . { GroupPresenceManagerRegion , PresenceManagerRegion } 
 import im . actor . server . sequence . _ 
 - import im . actor . server . session . SessionStreamMessage . EnqueuedProtoMessage 
 
 import scala . annotation . tailrec 
 import scala . collection . immutable 
 @ @ - 26 , 7 + 25 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 weakUpdManagerRegion : WeakUpdatesManagerRegion , 
 presenceManagerRegion : PresenceManagerRegion , 
 groupPresenceManagerRegion : GroupPresenceManagerRegion 
 - ) extends ActorSubscriber with ActorPublisher [ ( ProtoMessage , Option [ String ] ) ] with ActorLogging { 
 + ) extends ActorSubscriber with ActorPublisher [ ( UpdateBox , Option [ String ] ) ] with ActorLogging { 
 
 import ActorPublisherMessage . _ 
 import ActorSubscriberMessage . _ 
 @ @ - 62 , 7 + 61 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 override val requestStrategy = WatermarkRequestStrategy ( 10 ) / / TODO : configurable 
 
 / / Publisher - related 
 - private [ this ] var messageQueue = immutable . Queue . empty [ ( ProtoMessage , Option [ String ] ) ] 
 + private [ this ] var messageQueue = immutable . Queue . empty [ ( UpdateBox , Option [ String ] ) ] 
 
 def publisher : Receive = { 
 case NewUpdate ( ub , reduceKey ) ⇒ enqueueProtoMessage ( ub , reduceKey ) 
 @ @ - 70 , 7 + 69 , 7 @ @ private [ session ] class UpdatesHandler ( authId : Long ) ( 
 case Cancel ⇒ context . stop ( self ) 
 } 
 
 - private def enqueueProtoMessage ( message : ProtoMessage , reduceKey : Option [ String ] ) : Unit = { 
 + private def enqueueProtoMessage ( message : UpdateBox , reduceKey : Option [ String ] ) : Unit = { 
 if ( messageQueue . isEmpty & & totalDemand > 0 ) { 
 onNext ( message → reduceKey ) 
 } else { 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 5fb9a44 . . b96b492 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 114 , 6 + 114 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 settings = defaultSettings 
 ) . dependsOn ( 
 actorActivation , 
 + actorBot , 
 actorEnrich , 
 actorEmail , 
 actorFrontend , 
 @ @ - 133 , 6 + 134 , 24 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 ) 
 ) . dependsOn ( actorEmail , actorSms , actorPersist ) 
 
 + lazy val actorBot = Project ( 
 + id = " actor - bot " , 
 + base = file ( " actor - bot " ) , 
 + settings = defaultSettings + + 
 + Seq ( 
 + libraryDependencies + + = Dependencies . bot 
 + ) 
 + ) . dependsOn ( actorBotMessages , shardakka , actorCore ) 
 + 
 + lazy val actorBotMessages = Project ( 
 + id = " actor - bot - messages " , 
 + base = file ( " actor - bot - messages " ) , 
 + settings = defaultSettings + + 
 + Seq ( 
 + libraryDependencies + + = Dependencies . botMessages 
 + ) 
 + ) 
 + 
 lazy val actorCore = Project ( 
 id = " actor - core " , 
 base = file ( " actor - core " ) , 
 @ @ - 164 , 7 + 183 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 settings = defaultSettings + + Seq ( 
 libraryDependencies + + = Dependencies . httpApi 
 ) 
 - ) . dependsOn ( actorCore , actorPersist , actorRuntime ) 
 + ) . dependsOn ( actorBot , actorCore , actorPersist , actorRuntime ) 
 
 lazy val actorOAuth = Project ( 
 id = " actor - oauth " , 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index ce84317 . . 428af06 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 9 , 7 + 9 , 7 @ @ object Dependencies { 
 val scalaz = " 7 . 1 . 1 " 
 val slick = " 3 . 0 . 3 " 
 val scalatest = " 2 . 2 . 4 " 
 - val catsVersion = " 0 . 1 . 2 " 
 + val catsVersion = " 0 . 2 . 0 " 
 
 } 
 
 @ @ - 30 , 8 + 30 , 7 @ @ object Dependencies { 
 val caffeine = " com . github . ben - manes . caffeine " % " caffeine " % " 1 . 2 . 0 " 
 val eaioUuid = " com . eaio . uuid " % " uuid " % " 3 . 4 " 
 
 - val cats = " org . spire - math " % % " cats - core " % V . catsVersion 
 - val catsStd = " org . spire - math " % % " cats - std " % V . catsVersion 
 + val cats = " org . spire - math " % % " cats " % V . catsVersion 
 
 val configs = " com . github . kxbmap " % % " configs " % " 0 . 2 . 4 " 
 
 @ @ - 39 , 6 + 38 , 7 @ @ object Dependencies { 
 val javaCompat = " org . scala - lang . modules " % % " scala - java8 - compat " % " 0 . 5 . 0 " 
 
 val playJson = " com . typesafe . play " % % " play - json " % " 2 . 4 . 2 " 
 + val upickle = " com . lihaoyi " % % " upickle " % " 0 . 3 . 6 " 
 
 val postgresJdbc = " org . postgresql " % " postgresql " % " 9 . 4 - 1201 - jdbc41 " exclude ( " org . slf4j " , " slf4j - simple " ) 
 val slick = " com . typesafe . slick " % % " slick " % V . slick 
 @ @ - 102 , 6 + 102 , 10 @ @ object Dependencies { 
 
 val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) 
 
 + val bot = shared + + Seq ( upickle ) 
 + 
 + val botMessages = Seq ( upickle ) 
 + 
 val core = shared + + Seq ( akkaActor , akkaContrib , amazonaws , awsWrap , caffeine , gcmServer , pushy , jodaTime , postgresJdbc , slick , scrImageCore ) 
 
 val enrich = shared + + Seq ( akkaActor , akkaHttp ) 
 @ @ - 146 , 7 + 150 , 7 @ @ object Dependencies { 
 
 val notifications = shared + + Seq ( akkaContrib , slick ) 
 
 - val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , catsStd , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) 
 + val runtime = shared + + Seq ( akkaActor , akkaHttp , akkaStream , akkaPersistenceJdbc , caffeine , cats , concmap , jodaConvert , jodaTime , libPhoneNumber , scalazCore , akkaTestkit % " test " , scalatest % " test " ) 
 
 val voximplant = shared + + Seq ( akkaActor , dispatch , playJson )
