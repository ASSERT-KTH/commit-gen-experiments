BLEU SCORE: 0.2490328638846773

TEST MSG: feat ( core ) : Finished implementation of key manager - storing ephemeral and identity keys
GENERATED MSG: feat ( core ) : Uploading ephemeral keys

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > index 58c2383 . . b6936ab 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java < nl > @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . core . modules . encryption ; < nl > < nl > import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > + import java . util . HashMap ; < nl > import java . util . List ; < nl > < nl > import im . actor . core . api . ApiEncryptionKey ; < nl > @ @ - 24 , 6 + 25 , 7 @ @ import im . actor . runtime . Storage ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > + import im . actor . runtime . crypto . primitives . util . ByteStrings ; < nl > import im . actor . runtime . storage . KeyValueRecord ; < nl > import im . actor . runtime . storage . KeyValueStorage ; < nl > < nl > @ @ - 33 , 6 + 35 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > < nl > private static final String TAG = " KeyManagerActor " ; < nl > < nl > + private HashMap < Long , EphemeralEncryptionKey > ephemeralKeys = new HashMap < Long , EphemeralEncryptionKey > ( ) ; < nl > private PrivateKeyStorage privateKeyStorage ; < nl > private KeyValueStorage ephemeralStorage ; < nl > private boolean isReady = false ; < nl > @ @ - 131 , 9 + 134 , 18 @ @ public class KeyManagerActor extends ModuleActor { < nl > private void onMainKeysReady ( ) { < nl > Log . d ( TAG , " Main Keys are ready " ) ; < nl > < nl > - / / Generating ephemeral keys < nl > - List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; < nl > - for ( int i = 0 ; i < 100 - records . size ( ) ; i + + ) { < nl > + / / Loading all keys < nl > + for ( KeyValueRecord r : ephemeralStorage . loadAllItems ( ) ) { < nl > + try { < nl > + EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( r . getData ( ) ) ; < nl > + ephemeralKeys . put ( encryptionKey . getEncryptionKey ( ) . getKeyId ( ) , encryptionKey ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + < nl > + / / Generating missing ephemeral keys < nl > + for ( int i = 0 ; i < 100 - ephemeralKeys . size ( ) ; i + + ) { < nl > long randomId = RandomUtils . nextRid ( ) ; < nl > EncryptionKey encryptionKey = new EncryptionKey ( < nl > randomId , < nl > @ @ - 141 , 20 + 153 , 16 @ @ public class KeyManagerActor extends ModuleActor { < nl > EphemeralEncryptionKey ephemeralEncryptionKey = < nl > new EphemeralEncryptionKey ( encryptionKey , false ) ; < nl > ephemeralStorage . addOrUpdateItem ( randomId , ephemeralEncryptionKey . toByteArray ( ) ) ; < nl > + ephemeralKeys . put ( randomId , ephemeralEncryptionKey ) ; < nl > } < nl > < nl > / / Uploading ephemeral keys < nl > - records = ephemeralStorage . loadAllItems ( ) ; < nl > + / / records = ephemeralStorage . loadAllItems ( ) ; < nl > < nl > final ArrayList < EphemeralEncryptionKey > pendingEphermalKeys = new ArrayList < EphemeralEncryptionKey > ( ) ; < nl > - for ( KeyValueRecord record : records ) { < nl > - try { < nl > - EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( record . getData ( ) ) ; < nl > - if ( ! encryptionKey . isUploaded ( ) ) { < nl > - pendingEphermalKeys . add ( encryptionKey ) ; < nl > - } < nl > - } catch ( IOException e ) { < nl > - e . printStackTrace ( ) ; < nl > + for ( EphemeralEncryptionKey record : ephemeralKeys . values ( ) ) { < nl > + if ( ! record . isUploaded ( ) ) { < nl > + pendingEphermalKeys . add ( record ) ; < nl > } < nl > } < nl > < nl > @ @ - 185 , 12 + 193 , 12 @ @ public class KeyManagerActor extends ModuleActor { < nl > public void onResult ( ResponseVoid response ) { < nl > List < KeyValueRecord > updated = new ArrayList < KeyValueRecord > ( ) ; < nl > for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { < nl > - updated . add ( new KeyValueRecord ( k . getEncryptionKey ( ) . getKeyId ( ) , < nl > - k . markUploaded ( ) . toByteArray ( ) ) ) ; < nl > + EphemeralEncryptionKey uploaded = k . markUploaded ( ) ; < nl > + updated . add ( new KeyValueRecord ( uploaded . getEncryptionKey ( ) . getKeyId ( ) , uploaded . toByteArray ( ) ) ) ; < nl > + ephemeralKeys . put ( uploaded . getEncryptionKey ( ) . getKeyId ( ) , uploaded ) ; < nl > } < nl > ephemeralStorage . addOrUpdateItems ( updated ) ; < nl > < nl > - < nl > onAllKeysReady ( ) ; < nl > } < nl > < nl > @ @ - 217 , 16 + 225 , 8 @ @ public class KeyManagerActor extends ModuleActor { < nl > } < nl > < nl > private void fetchOwnKey ( Future future ) { < nl > - List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; < nl > - EphemeralEncryptionKey ephemeralEncryptionKey ; < nl > - try { < nl > - ephemeralEncryptionKey = new EphemeralEncryptionKey ( records . get ( RandomUtils . randomId ( records . size ( ) ) ) . getData ( ) ) ; < nl > - } catch ( IOException e ) { < nl > - e . printStackTrace ( ) ; < nl > - future . onError ( e ) ; < nl > - return ; < nl > - } < nl > - < nl > + Long [ ] keys = ephemeralKeys . keySet ( ) . toArray ( new Long [ ephemeralKeys . size ( ) ] ) ; < nl > + EphemeralEncryptionKey ephemeralEncryptionKey = ephemeralKeys . get ( keys [ RandomUtils . randomId ( keys . length ) ] ) ; < nl > future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; < nl > } < nl > < nl > @ @ - 234 , 6 + 234 , 26 @ @ public class KeyManagerActor extends ModuleActor { < nl > future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; < nl > } < nl > < nl > + private void fetchEphemeralKey ( byte [ ] publicKey , Future future ) { < nl > + for ( EphemeralEncryptionKey encryptionKey : ephemeralKeys . values ( ) ) { < nl > + if ( ByteStrings . isEquals ( encryptionKey . getEncryptionKey ( ) . getPublicKey ( ) , publicKey ) ) { < nl > + future . onResult ( new FetchEphemeralPrivateKeyRes ( encryptionKey . getEncryptionKey ( ) . getPrivateKey ( ) ) ) ; < nl > + return ; < nl > + } < nl > + } < nl > + future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; < nl > + } < nl > + < nl > + private void fetchEphemeralKey ( long keyId , Future future ) { < nl > + for ( EphemeralEncryptionKey encryptionKey : ephemeralKeys . values ( ) ) { < nl > + if ( encryptionKey . getEncryptionKey ( ) . getKeyId ( ) = = keyId ) { < nl > + future . onResult ( new FetchEphemeralPrivateKeyRes ( encryptionKey . getEncryptionKey ( ) . getPrivateKey ( ) ) ) ; < nl > + return ; < nl > + } < nl > + } < nl > + future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; < nl > + } < nl > + < nl > @ Override < nl > public void onReceive ( Object message ) { < nl > if ( message instanceof AskRequest & & ! isReady ) { < nl > @ @ - 251 , 6 + 271 , 12 @ @ public class KeyManagerActor extends ModuleActor { < nl > } else if ( message instanceof FetchOwnKeyGroup ) { < nl > fetchKeyGroup ( future ) ; < nl > return false ; < nl > + } else if ( message instanceof FetchEphemeralPrivateKey ) { < nl > + fetchEphemeralKey ( ( ( FetchEphemeralPrivateKey ) message ) . getPublicKey ( ) , future ) ; < nl > + return false ; < nl > + } else if ( message instanceof FetchEphemeralPrivateKeyById ) { < nl > + fetchEphemeralKey ( ( ( FetchEphemeralPrivateKeyById ) message ) . getKeyId ( ) , future ) ; < nl > + return false ; < nl > } < nl > return super . onAsk ( message , future ) ; < nl > } < nl > @ @ - 293 , 4 + 319 , 42 @ @ public class KeyManagerActor extends ModuleActor { < nl > return keyGroupId ; < nl > } < nl > } < nl > + < nl > + public static class FetchEphemeralPrivateKey { < nl > + < nl > + private byte [ ] publicKey ; < nl > + < nl > + public FetchEphemeralPrivateKey ( byte [ ] publicKey ) { < nl > + this . publicKey = publicKey ; < nl > + } < nl > + < nl > + public byte [ ] getPublicKey ( ) { < nl > + return publicKey ; < nl > + } < nl > + } < nl > + < nl > + public static class FetchEphemeralPrivateKeyById { < nl > + < nl > + private long keyId ; < nl > + < nl > + public FetchEphemeralPrivateKeyById ( long keyId ) { < nl > + this . keyId = keyId ; < nl > + } < nl > + < nl > + public long getKeyId ( ) { < nl > + return keyId ; < nl > + } < nl > + } < nl > + < nl > + public static class FetchEphemeralPrivateKeyRes { < nl > + private byte [ ] privateKey ; < nl > + < nl > + public FetchEphemeralPrivateKeyRes ( byte [ ] privateKey ) { < nl > + this . privateKey = privateKey ; < nl > + } < nl > + < nl > + public byte [ ] getPrivateKey ( ) { < nl > + return privateKey ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > index e4aff27 . . 0022766 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java < nl > @ @ - 96 , 4 + 96 , 16 @ @ public class ByteStrings { < nl > dest [ destOffset + i ] = src [ srcOffset + i ] ; < nl > } < nl > } < nl > + < nl > + public static boolean isEquals ( byte [ ] a , byte [ ] b ) { < nl > + if ( a . length ! = b . length ) { < nl > + return false ; < nl > + } < nl > + / / To avoid timing attacks < nl > + int result = 0 ; < nl > + for ( int i = 0 ; i < a . length ; i + + ) { < nl > + result | = a [ i ] ^ b [ i ] ; < nl > + } < nl > + return result = = 0 ; < nl > + } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java < nl > index c214949 . . c58469c 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java < nl > @ @ - 7 , 12 + 7 , 15 @ @ import java . util . List ; < nl > import im . actor . core . api . ApiEncryptionKey ; < nl > import im . actor . core . api . ApiEncryptionKeySignature ; < nl > import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; < nl > + import im . actor . core . api . rpc . RequestUploadEphermalKey ; < nl > import im . actor . core . api . rpc . ResponseCreateNewKeyGroup ; < nl > + import im . actor . core . api . rpc . ResponseVoid ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; < nl > - import im . actor . core . modules . internal . encryption . entity . EphermalEncryptionKey ; < nl > + import im . actor . core . modules . internal . encryption . entity . EphemeralEncryptionKey ; < nl > import im . actor . core . modules . internal . encryption . entity . PrivateKeyStorage ; < nl > import im . actor . core . modules . utils . ModuleActor ; < nl > + import im . actor . core . modules . utils . RandomUtils ; < nl > import im . actor . core . network . RpcCallback ; < nl > import im . actor . core . network . RpcException ; < nl > import im . actor . runtime . Crypto ; < nl > @ @ - 21 , 7 + 24 , 6 @ @ import im . actor . runtime . Storage ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . storage . KeyValueRecord ; < nl > import im . actor . runtime . storage . KeyValueStorage ; < nl > - import im . actor . sdk . util . Randoms ; < nl > < nl > public class KeyManagerActor extends ModuleActor { < nl > < nl > @ @ - 30 , 7 + 32 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > private static final String TAG = " KeyManagerActor " ; < nl > < nl > private PrivateKeyStorage privateKeyStorage ; < nl > - private KeyValueStorage ephermalStorage ; < nl > + private KeyValueStorage ephemeralStorage ; < nl > < nl > public KeyManagerActor ( ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 38 , 7 + 40 , 7 @ @ public class KeyManagerActor extends ModuleActor { < nl > < nl > @ Override < nl > public void preStart ( ) { < nl > - ephermalStorage = Storage . createKeyValue ( " ephermal _ keys " ) ; < nl > + ephemeralStorage = Storage . createKeyValue ( " ephemeral _ keys " ) ; < nl > < nl > byte [ ] data = preferences ( ) . getBytes ( PRIVATE _ KEYS ) ; < nl > if ( data ! = null ) { < nl > @ @ - 52 , 10 + 54 , 10 @ @ public class KeyManagerActor extends ModuleActor { < nl > if ( privateKeyStorage = = null ) { < nl > Log . d ( TAG , " Generating new encryption keys . . . " ) ; < nl > < nl > - EncryptionKey identityKey = new EncryptionKey ( Randoms . randomId ( ) , < nl > + EncryptionKey identityKey = new EncryptionKey ( RandomUtils . nextRid ( ) , < nl > Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > ArrayList < EncryptionKey > keyPairs = new ArrayList < EncryptionKey > ( ) ; < nl > - keyPairs . add ( new EncryptionKey ( Randoms . randomId ( ) , < nl > + keyPairs . add ( new EncryptionKey ( RandomUtils . nextRid ( ) , < nl > Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ) ; < nl > < nl > privateKeyStorage = new PrivateKeyStorage ( identityKey , keyPairs , 0 ) ; < nl > @ @ - 127 , 20 + 129 , 84 @ @ public class KeyManagerActor extends ModuleActor { < nl > Log . d ( TAG , " Main Keys are ready " ) ; < nl > < nl > / / Generating ephemeral keys < nl > - List < KeyValueRecord > records = ephermalStorage . loadAllItems ( ) ; < nl > + List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; < nl > for ( int i = 0 ; i < records . size ( ) - 100 ; i + + ) { < nl > - long randomId = Randoms . randomId ( ) ; < nl > + long randomId = RandomUtils . nextRid ( ) ; < nl > EncryptionKey encryptionKey = new EncryptionKey ( < nl > randomId , < nl > Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > - EphermalEncryptionKey ephermalEncryptionKey = < nl > - new EphermalEncryptionKey ( encryptionKey , false ) ; < nl > - ephermalStorage . addOrUpdateItem ( randomId , ephermalEncryptionKey . toByteArray ( ) ) ; < nl > + EphemeralEncryptionKey ephemeralEncryptionKey = < nl > + new EphemeralEncryptionKey ( encryptionKey , false ) ; < nl > + ephemeralStorage . addOrUpdateItem ( randomId , ephemeralEncryptionKey . toByteArray ( ) ) ; < nl > } < nl > < nl > / / Uploading ephemeral keys < nl > - records = ephermalStorage . loadAllItems ( ) ; < nl > + records = ephemeralStorage . loadAllItems ( ) ; < nl > < nl > - / / TODO : Implement uploading < nl > + final ArrayList < EphemeralEncryptionKey > pendingEphermalKeys = new ArrayList < EphemeralEncryptionKey > ( ) ; < nl > + for ( KeyValueRecord record : records ) { < nl > + try { < nl > + EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( record . getData ( ) ) ; < nl > + if ( ! encryptionKey . isUploaded ( ) ) { < nl > + pendingEphermalKeys . add ( encryptionKey ) ; < nl > + } < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + < nl > + if ( pendingEphermalKeys . size ( ) > 0 ) { < nl > + ArrayList < ApiEncryptionKey > uploadingKeys = new ArrayList < ApiEncryptionKey > ( ) ; < nl > + ArrayList < ApiEncryptionKeySignature > uploadingSignatures = new ArrayList < ApiEncryptionKeySignature > ( ) ; < nl > + for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { < nl > + ApiEncryptionKey apiKey = < nl > + new ApiEncryptionKey ( < nl > + k . getEncryptionKey ( ) . getKeyId ( ) , < nl > + k . getEncryptionKey ( ) . getKeyAlg ( ) , < nl > + k . getEncryptionKey ( ) . getPublicKey ( ) , < nl > + null ) ; < nl > + uploadingKeys . add ( apiKey ) ; < nl > + < nl > + < nl > + byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , < nl > + privateKeyStorage . getIdentityKey ( ) . getPrivateKey ( ) , apiKey . toByteArray ( ) ) ; < nl > + uploadingSignatures . add ( < nl > + new ApiEncryptionKeySignature ( < nl > + k . getEncryptionKey ( ) . getKeyId ( ) , < nl > + " Ed25519 " , < nl > + signature ) ) ; < nl > + } < nl > + < nl > + request ( new RequestUploadEphermalKey ( privateKeyStorage . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) , new RpcCallback < ResponseVoid > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponseVoid response ) { < nl > + List < KeyValueRecord > updated = new ArrayList < KeyValueRecord > ( ) ; < nl > + for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { < nl > + updated . add ( new KeyValueRecord ( k . getEncryptionKey ( ) . getKeyId ( ) , < nl > + k . toByteArray ( ) ) ) ; < nl > + } < nl > + ephemeralStorage . addOrUpdateItems ( updated ) ; < nl > + < nl > + < nl > + onAllKeysReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + Log . w ( TAG , " Ephemeral keys upload error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + < nl > + / / Ignore < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onAllKeysReady ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onAllKeysReady ( ) { < nl > + Log . d ( TAG , " Ephemeral Keys are ready " ) ; < nl > + < nl > + / / Now we can start receiving encrypted messages < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java < nl > new file mode 100644 < nl > index 0000000 . . 4b492ae < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java < nl > @ @ - 0 , 0 + 1 , 46 @ @ < nl > + package im . actor . core . modules . internal . encryption . entity ; < nl > + < nl > + import java . io . IOException ; < nl > + < nl > + import im . actor . runtime . bser . BserObject ; < nl > + import im . actor . runtime . bser . BserValues ; < nl > + import im . actor . runtime . bser . BserWriter ; < nl > + < nl > + public class EphemeralEncryptionKey extends BserObject { < nl > + < nl > + private EncryptionKey encryptionKey ; < nl > + private boolean isUploaded ; < nl > + < nl > + public EphemeralEncryptionKey ( EncryptionKey encryptionKey , boolean isUploaded ) { < nl > + this . encryptionKey = encryptionKey ; < nl > + this . isUploaded = isUploaded ; < nl > + } < nl > + < nl > + public EphemeralEncryptionKey ( byte [ ] data ) throws IOException { < nl > + load ( data ) ; < nl > + } < nl > + < nl > + public EncryptionKey getEncryptionKey ( ) { < nl > + return encryptionKey ; < nl > + } < nl > + < nl > + public boolean isUploaded ( ) { < nl > + return isUploaded ; < nl > + } < nl > + < nl > + public EphemeralEncryptionKey markUploaded ( ) { < nl > + return new EphemeralEncryptionKey ( encryptionKey , true ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void parse ( BserValues values ) throws IOException { < nl > + encryptionKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; < nl > + isUploaded = values . getBool ( 2 ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void serialize ( BserWriter writer ) throws IOException { < nl > + writer . writeBytes ( 1 , encryptionKey . toByteArray ( ) ) ; < nl > + writer . writeBool ( 2 , isUploaded ) ; < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java < nl > deleted file mode 100644 < nl > index 7942fd2 . . 0000000 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java < nl > + + + / dev / null < nl > @ @ - 1 , 46 + 0 , 0 @ @ < nl > - package im . actor . core . modules . internal . encryption . entity ; < nl > - < nl > - import java . io . IOException ; < nl > - < nl > - import im . actor . runtime . bser . BserObject ; < nl > - import im . actor . runtime . bser . BserValues ; < nl > - import im . actor . runtime . bser . BserWriter ; < nl > - < nl > - public class EphermalEncryptionKey extends BserObject { < nl > - < nl > - private EncryptionKey encryptionKey ; < nl > - private boolean isUploaded ; < nl > - < nl > - public EphermalEncryptionKey ( EncryptionKey encryptionKey , boolean isUploaded ) { < nl > - this . encryptionKey = encryptionKey ; < nl > - this . isUploaded = isUploaded ; < nl > - } < nl > - < nl > - public EphermalEncryptionKey ( byte [ ] data ) throws IOException { < nl > - load ( data ) ; < nl > - } < nl > - < nl > - public EncryptionKey getEncryptionKey ( ) { < nl > - return encryptionKey ; < nl > - } < nl > - < nl > - public boolean isUploaded ( ) { < nl > - return isUploaded ; < nl > - } < nl > - < nl > - public EphermalEncryptionKey markUploaded ( ) { < nl > - return new EphermalEncryptionKey ( encryptionKey , true ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void parse ( BserValues values ) throws IOException { < nl > - encryptionKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; < nl > - isUploaded = values . getBool ( 2 ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void serialize ( BserWriter writer ) throws IOException { < nl > - writer . writeBytes ( 1 , encryptionKey . toByteArray ( ) ) ; < nl > - writer . writeBool ( 2 , isUploaded ) ; < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java < nl > index e1eaa64 . . 7f5c254 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java < nl > @ @ - 9 , 11 + 9 , 11 @ @ import im . actor . runtime . bser . BserWriter ; < nl > < nl > public class PrivateKeyStorage extends BserObject { < nl > < nl > - private long keyGroupId ; < nl > + private int keyGroupId ; < nl > private EncryptionKey identityKey = null ; < nl > private ArrayList < EncryptionKey > keys = new ArrayList < EncryptionKey > ( ) ; < nl > < nl > - public PrivateKeyStorage ( EncryptionKey identityKey , ArrayList < EncryptionKey > keys , long keyGroupId ) { < nl > + public PrivateKeyStorage ( EncryptionKey identityKey , ArrayList < EncryptionKey > keys , int keyGroupId ) { < nl > this . identityKey = identityKey ; < nl > this . keys = keys ; < nl > this . keyGroupId = keyGroupId ; < nl > @ @ - 31 , 18 + 31 , 18 @ @ public class PrivateKeyStorage extends BserObject { < nl > return keys ; < nl > } < nl > < nl > - public long getKeyGroupId ( ) { < nl > + public int getKeyGroupId ( ) { < nl > return keyGroupId ; < nl > } < nl > < nl > - public PrivateKeyStorage markUploaded ( long keyGroupId ) { < nl > + public PrivateKeyStorage markUploaded ( int keyGroupId ) { < nl > return new PrivateKeyStorage ( identityKey , keys , keyGroupId ) ; < nl > } < nl > < nl > @ Override < nl > public void parse ( BserValues values ) throws IOException { < nl > identityKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; < nl > - keyGroupId = values . optLong ( 2 ) ; < nl > + keyGroupId = values . optInt ( 2 ) ; < nl > for ( byte [ ] b : values . getRepeatedBytes ( 3 ) ) { < nl > keys . add ( new EncryptionKey ( b ) ) ; < nl > } < nl > @ @ - 51 , 7 + 51 , 7 @ @ public class PrivateKeyStorage extends BserObject { < nl > @ Override < nl > public void serialize ( BserWriter writer ) throws IOException { < nl > writer . writeObject ( 1 , identityKey ) ; < nl > - writer . writeLong ( 2 , keyGroupId ) ; < nl > + writer . writeInt ( 2 , keyGroupId ) ; < nl > writer . writeRepeatedObj ( 3 , keys ) ; < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 index 58c2383 . . b6936ab 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerActor . java 
 @ @ - 2 , 6 + 2 , 7 @ @ package im . actor . core . modules . encryption ; 
 
 import java . io . IOException ; 
 import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 import java . util . List ; 
 
 import im . actor . core . api . ApiEncryptionKey ; 
 @ @ - 24 , 6 + 25 , 7 @ @ import im . actor . runtime . Storage ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 + import im . actor . runtime . crypto . primitives . util . ByteStrings ; 
 import im . actor . runtime . storage . KeyValueRecord ; 
 import im . actor . runtime . storage . KeyValueStorage ; 
 
 @ @ - 33 , 6 + 35 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 
 private static final String TAG = " KeyManagerActor " ; 
 
 + private HashMap < Long , EphemeralEncryptionKey > ephemeralKeys = new HashMap < Long , EphemeralEncryptionKey > ( ) ; 
 private PrivateKeyStorage privateKeyStorage ; 
 private KeyValueStorage ephemeralStorage ; 
 private boolean isReady = false ; 
 @ @ - 131 , 9 + 134 , 18 @ @ public class KeyManagerActor extends ModuleActor { 
 private void onMainKeysReady ( ) { 
 Log . d ( TAG , " Main Keys are ready " ) ; 
 
 - / / Generating ephemeral keys 
 - List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; 
 - for ( int i = 0 ; i < 100 - records . size ( ) ; i + + ) { 
 + / / Loading all keys 
 + for ( KeyValueRecord r : ephemeralStorage . loadAllItems ( ) ) { 
 + try { 
 + EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( r . getData ( ) ) ; 
 + ephemeralKeys . put ( encryptionKey . getEncryptionKey ( ) . getKeyId ( ) , encryptionKey ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + / / Generating missing ephemeral keys 
 + for ( int i = 0 ; i < 100 - ephemeralKeys . size ( ) ; i + + ) { 
 long randomId = RandomUtils . nextRid ( ) ; 
 EncryptionKey encryptionKey = new EncryptionKey ( 
 randomId , 
 @ @ - 141 , 20 + 153 , 16 @ @ public class KeyManagerActor extends ModuleActor { 
 EphemeralEncryptionKey ephemeralEncryptionKey = 
 new EphemeralEncryptionKey ( encryptionKey , false ) ; 
 ephemeralStorage . addOrUpdateItem ( randomId , ephemeralEncryptionKey . toByteArray ( ) ) ; 
 + ephemeralKeys . put ( randomId , ephemeralEncryptionKey ) ; 
 } 
 
 / / Uploading ephemeral keys 
 - records = ephemeralStorage . loadAllItems ( ) ; 
 + / / records = ephemeralStorage . loadAllItems ( ) ; 
 
 final ArrayList < EphemeralEncryptionKey > pendingEphermalKeys = new ArrayList < EphemeralEncryptionKey > ( ) ; 
 - for ( KeyValueRecord record : records ) { 
 - try { 
 - EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( record . getData ( ) ) ; 
 - if ( ! encryptionKey . isUploaded ( ) ) { 
 - pendingEphermalKeys . add ( encryptionKey ) ; 
 - } 
 - } catch ( IOException e ) { 
 - e . printStackTrace ( ) ; 
 + for ( EphemeralEncryptionKey record : ephemeralKeys . values ( ) ) { 
 + if ( ! record . isUploaded ( ) ) { 
 + pendingEphermalKeys . add ( record ) ; 
 } 
 } 
 
 @ @ - 185 , 12 + 193 , 12 @ @ public class KeyManagerActor extends ModuleActor { 
 public void onResult ( ResponseVoid response ) { 
 List < KeyValueRecord > updated = new ArrayList < KeyValueRecord > ( ) ; 
 for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { 
 - updated . add ( new KeyValueRecord ( k . getEncryptionKey ( ) . getKeyId ( ) , 
 - k . markUploaded ( ) . toByteArray ( ) ) ) ; 
 + EphemeralEncryptionKey uploaded = k . markUploaded ( ) ; 
 + updated . add ( new KeyValueRecord ( uploaded . getEncryptionKey ( ) . getKeyId ( ) , uploaded . toByteArray ( ) ) ) ; 
 + ephemeralKeys . put ( uploaded . getEncryptionKey ( ) . getKeyId ( ) , uploaded ) ; 
 } 
 ephemeralStorage . addOrUpdateItems ( updated ) ; 
 
 - 
 onAllKeysReady ( ) ; 
 } 
 
 @ @ - 217 , 16 + 225 , 8 @ @ public class KeyManagerActor extends ModuleActor { 
 } 
 
 private void fetchOwnKey ( Future future ) { 
 - List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; 
 - EphemeralEncryptionKey ephemeralEncryptionKey ; 
 - try { 
 - ephemeralEncryptionKey = new EphemeralEncryptionKey ( records . get ( RandomUtils . randomId ( records . size ( ) ) ) . getData ( ) ) ; 
 - } catch ( IOException e ) { 
 - e . printStackTrace ( ) ; 
 - future . onError ( e ) ; 
 - return ; 
 - } 
 - 
 + Long [ ] keys = ephemeralKeys . keySet ( ) . toArray ( new Long [ ephemeralKeys . size ( ) ] ) ; 
 + EphemeralEncryptionKey ephemeralEncryptionKey = ephemeralKeys . get ( keys [ RandomUtils . randomId ( keys . length ) ] ) ; 
 future . onResult ( new FetchOwnKeyResult ( privateKeyStorage . getIdentityKey ( ) , ephemeralEncryptionKey . getEncryptionKey ( ) ) ) ; 
 } 
 
 @ @ - 234 , 6 + 234 , 26 @ @ public class KeyManagerActor extends ModuleActor { 
 future . onResult ( new FetchOwnKeyGroupResult ( privateKeyStorage . getKeyGroupId ( ) ) ) ; 
 } 
 
 + private void fetchEphemeralKey ( byte [ ] publicKey , Future future ) { 
 + for ( EphemeralEncryptionKey encryptionKey : ephemeralKeys . values ( ) ) { 
 + if ( ByteStrings . isEquals ( encryptionKey . getEncryptionKey ( ) . getPublicKey ( ) , publicKey ) ) { 
 + future . onResult ( new FetchEphemeralPrivateKeyRes ( encryptionKey . getEncryptionKey ( ) . getPrivateKey ( ) ) ) ; 
 + return ; 
 + } 
 + } 
 + future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; 
 + } 
 + 
 + private void fetchEphemeralKey ( long keyId , Future future ) { 
 + for ( EphemeralEncryptionKey encryptionKey : ephemeralKeys . values ( ) ) { 
 + if ( encryptionKey . getEncryptionKey ( ) . getKeyId ( ) = = keyId ) { 
 + future . onResult ( new FetchEphemeralPrivateKeyRes ( encryptionKey . getEncryptionKey ( ) . getPrivateKey ( ) ) ) ; 
 + return ; 
 + } 
 + } 
 + future . onError ( new RuntimeException ( " Unable to find ephemeral key " ) ) ; 
 + } 
 + 
 @ Override 
 public void onReceive ( Object message ) { 
 if ( message instanceof AskRequest & & ! isReady ) { 
 @ @ - 251 , 6 + 271 , 12 @ @ public class KeyManagerActor extends ModuleActor { 
 } else if ( message instanceof FetchOwnKeyGroup ) { 
 fetchKeyGroup ( future ) ; 
 return false ; 
 + } else if ( message instanceof FetchEphemeralPrivateKey ) { 
 + fetchEphemeralKey ( ( ( FetchEphemeralPrivateKey ) message ) . getPublicKey ( ) , future ) ; 
 + return false ; 
 + } else if ( message instanceof FetchEphemeralPrivateKeyById ) { 
 + fetchEphemeralKey ( ( ( FetchEphemeralPrivateKeyById ) message ) . getKeyId ( ) , future ) ; 
 + return false ; 
 } 
 return super . onAsk ( message , future ) ; 
 } 
 @ @ - 293 , 4 + 319 , 42 @ @ public class KeyManagerActor extends ModuleActor { 
 return keyGroupId ; 
 } 
 } 
 + 
 + public static class FetchEphemeralPrivateKey { 
 + 
 + private byte [ ] publicKey ; 
 + 
 + public FetchEphemeralPrivateKey ( byte [ ] publicKey ) { 
 + this . publicKey = publicKey ; 
 + } 
 + 
 + public byte [ ] getPublicKey ( ) { 
 + return publicKey ; 
 + } 
 + } 
 + 
 + public static class FetchEphemeralPrivateKeyById { 
 + 
 + private long keyId ; 
 + 
 + public FetchEphemeralPrivateKeyById ( long keyId ) { 
 + this . keyId = keyId ; 
 + } 
 + 
 + public long getKeyId ( ) { 
 + return keyId ; 
 + } 
 + } 
 + 
 + public static class FetchEphemeralPrivateKeyRes { 
 + private byte [ ] privateKey ; 
 + 
 + public FetchEphemeralPrivateKeyRes ( byte [ ] privateKey ) { 
 + this . privateKey = privateKey ; 
 + } 
 + 
 + public byte [ ] getPrivateKey ( ) { 
 + return privateKey ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 index e4aff27 . . 0022766 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / util / ByteStrings . java 
 @ @ - 96 , 4 + 96 , 16 @ @ public class ByteStrings { 
 dest [ destOffset + i ] = src [ srcOffset + i ] ; 
 } 
 } 
 + 
 + public static boolean isEquals ( byte [ ] a , byte [ ] b ) { 
 + if ( a . length ! = b . length ) { 
 + return false ; 
 + } 
 + / / To avoid timing attacks 
 + int result = 0 ; 
 + for ( int i = 0 ; i < a . length ; i + + ) { 
 + result | = a [ i ] ^ b [ i ] ; 
 + } 
 + return result = = 0 ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java 
 index c214949 . . c58469c 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / KeyManagerActor . java 
 @ @ - 7 , 12 + 7 , 15 @ @ import java . util . List ; 
 import im . actor . core . api . ApiEncryptionKey ; 
 import im . actor . core . api . ApiEncryptionKeySignature ; 
 import im . actor . core . api . rpc . RequestCreateNewKeyGroup ; 
 + import im . actor . core . api . rpc . RequestUploadEphermalKey ; 
 import im . actor . core . api . rpc . ResponseCreateNewKeyGroup ; 
 + import im . actor . core . api . rpc . ResponseVoid ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; 
 - import im . actor . core . modules . internal . encryption . entity . EphermalEncryptionKey ; 
 + import im . actor . core . modules . internal . encryption . entity . EphemeralEncryptionKey ; 
 import im . actor . core . modules . internal . encryption . entity . PrivateKeyStorage ; 
 import im . actor . core . modules . utils . ModuleActor ; 
 + import im . actor . core . modules . utils . RandomUtils ; 
 import im . actor . core . network . RpcCallback ; 
 import im . actor . core . network . RpcException ; 
 import im . actor . runtime . Crypto ; 
 @ @ - 21 , 7 + 24 , 6 @ @ import im . actor . runtime . Storage ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . storage . KeyValueRecord ; 
 import im . actor . runtime . storage . KeyValueStorage ; 
 - import im . actor . sdk . util . Randoms ; 
 
 public class KeyManagerActor extends ModuleActor { 
 
 @ @ - 30 , 7 + 32 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 private static final String TAG = " KeyManagerActor " ; 
 
 private PrivateKeyStorage privateKeyStorage ; 
 - private KeyValueStorage ephermalStorage ; 
 + private KeyValueStorage ephemeralStorage ; 
 
 public KeyManagerActor ( ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 38 , 7 + 40 , 7 @ @ public class KeyManagerActor extends ModuleActor { 
 
 @ Override 
 public void preStart ( ) { 
 - ephermalStorage = Storage . createKeyValue ( " ephermal _ keys " ) ; 
 + ephemeralStorage = Storage . createKeyValue ( " ephemeral _ keys " ) ; 
 
 byte [ ] data = preferences ( ) . getBytes ( PRIVATE _ KEYS ) ; 
 if ( data ! = null ) { 
 @ @ - 52 , 10 + 54 , 10 @ @ public class KeyManagerActor extends ModuleActor { 
 if ( privateKeyStorage = = null ) { 
 Log . d ( TAG , " Generating new encryption keys . . . " ) ; 
 
 - EncryptionKey identityKey = new EncryptionKey ( Randoms . randomId ( ) , 
 + EncryptionKey identityKey = new EncryptionKey ( RandomUtils . nextRid ( ) , 
 Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 ArrayList < EncryptionKey > keyPairs = new ArrayList < EncryptionKey > ( ) ; 
 - keyPairs . add ( new EncryptionKey ( Randoms . randomId ( ) , 
 + keyPairs . add ( new EncryptionKey ( RandomUtils . nextRid ( ) , 
 Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ) ; 
 
 privateKeyStorage = new PrivateKeyStorage ( identityKey , keyPairs , 0 ) ; 
 @ @ - 127 , 20 + 129 , 84 @ @ public class KeyManagerActor extends ModuleActor { 
 Log . d ( TAG , " Main Keys are ready " ) ; 
 
 / / Generating ephemeral keys 
 - List < KeyValueRecord > records = ephermalStorage . loadAllItems ( ) ; 
 + List < KeyValueRecord > records = ephemeralStorage . loadAllItems ( ) ; 
 for ( int i = 0 ; i < records . size ( ) - 100 ; i + + ) { 
 - long randomId = Randoms . randomId ( ) ; 
 + long randomId = RandomUtils . nextRid ( ) ; 
 EncryptionKey encryptionKey = new EncryptionKey ( 
 randomId , 
 Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 - EphermalEncryptionKey ephermalEncryptionKey = 
 - new EphermalEncryptionKey ( encryptionKey , false ) ; 
 - ephermalStorage . addOrUpdateItem ( randomId , ephermalEncryptionKey . toByteArray ( ) ) ; 
 + EphemeralEncryptionKey ephemeralEncryptionKey = 
 + new EphemeralEncryptionKey ( encryptionKey , false ) ; 
 + ephemeralStorage . addOrUpdateItem ( randomId , ephemeralEncryptionKey . toByteArray ( ) ) ; 
 } 
 
 / / Uploading ephemeral keys 
 - records = ephermalStorage . loadAllItems ( ) ; 
 + records = ephemeralStorage . loadAllItems ( ) ; 
 
 - / / TODO : Implement uploading 
 + final ArrayList < EphemeralEncryptionKey > pendingEphermalKeys = new ArrayList < EphemeralEncryptionKey > ( ) ; 
 + for ( KeyValueRecord record : records ) { 
 + try { 
 + EphemeralEncryptionKey encryptionKey = new EphemeralEncryptionKey ( record . getData ( ) ) ; 
 + if ( ! encryptionKey . isUploaded ( ) ) { 
 + pendingEphermalKeys . add ( encryptionKey ) ; 
 + } 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + 
 + if ( pendingEphermalKeys . size ( ) > 0 ) { 
 + ArrayList < ApiEncryptionKey > uploadingKeys = new ArrayList < ApiEncryptionKey > ( ) ; 
 + ArrayList < ApiEncryptionKeySignature > uploadingSignatures = new ArrayList < ApiEncryptionKeySignature > ( ) ; 
 + for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { 
 + ApiEncryptionKey apiKey = 
 + new ApiEncryptionKey ( 
 + k . getEncryptionKey ( ) . getKeyId ( ) , 
 + k . getEncryptionKey ( ) . getKeyAlg ( ) , 
 + k . getEncryptionKey ( ) . getPublicKey ( ) , 
 + null ) ; 
 + uploadingKeys . add ( apiKey ) ; 
 + 
 + 
 + byte [ ] signature = Curve25519 . calculateSignature ( Crypto . randomBytes ( 64 ) , 
 + privateKeyStorage . getIdentityKey ( ) . getPrivateKey ( ) , apiKey . toByteArray ( ) ) ; 
 + uploadingSignatures . add ( 
 + new ApiEncryptionKeySignature ( 
 + k . getEncryptionKey ( ) . getKeyId ( ) , 
 + " Ed25519 " , 
 + signature ) ) ; 
 + } 
 + 
 + request ( new RequestUploadEphermalKey ( privateKeyStorage . getKeyGroupId ( ) , uploadingKeys , uploadingSignatures ) , new RpcCallback < ResponseVoid > ( ) { 
 + @ Override 
 + public void onResult ( ResponseVoid response ) { 
 + List < KeyValueRecord > updated = new ArrayList < KeyValueRecord > ( ) ; 
 + for ( EphemeralEncryptionKey k : pendingEphermalKeys ) { 
 + updated . add ( new KeyValueRecord ( k . getEncryptionKey ( ) . getKeyId ( ) , 
 + k . toByteArray ( ) ) ) ; 
 + } 
 + ephemeralStorage . addOrUpdateItems ( updated ) ; 
 + 
 + 
 + onAllKeysReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + Log . w ( TAG , " Ephemeral keys upload error " ) ; 
 + Log . e ( TAG , e ) ; 
 + 
 + / / Ignore 
 + } 
 + } ) ; 
 + } else { 
 + onAllKeysReady ( ) ; 
 + } 
 + } 
 + 
 + private void onAllKeysReady ( ) { 
 + Log . d ( TAG , " Ephemeral Keys are ready " ) ; 
 + 
 + / / Now we can start receiving encrypted messages 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java 
 new file mode 100644 
 index 0000000 . . 4b492ae 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphemeralEncryptionKey . java 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + package im . actor . core . modules . internal . encryption . entity ; 
 + 
 + import java . io . IOException ; 
 + 
 + import im . actor . runtime . bser . BserObject ; 
 + import im . actor . runtime . bser . BserValues ; 
 + import im . actor . runtime . bser . BserWriter ; 
 + 
 + public class EphemeralEncryptionKey extends BserObject { 
 + 
 + private EncryptionKey encryptionKey ; 
 + private boolean isUploaded ; 
 + 
 + public EphemeralEncryptionKey ( EncryptionKey encryptionKey , boolean isUploaded ) { 
 + this . encryptionKey = encryptionKey ; 
 + this . isUploaded = isUploaded ; 
 + } 
 + 
 + public EphemeralEncryptionKey ( byte [ ] data ) throws IOException { 
 + load ( data ) ; 
 + } 
 + 
 + public EncryptionKey getEncryptionKey ( ) { 
 + return encryptionKey ; 
 + } 
 + 
 + public boolean isUploaded ( ) { 
 + return isUploaded ; 
 + } 
 + 
 + public EphemeralEncryptionKey markUploaded ( ) { 
 + return new EphemeralEncryptionKey ( encryptionKey , true ) ; 
 + } 
 + 
 + @ Override 
 + public void parse ( BserValues values ) throws IOException { 
 + encryptionKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; 
 + isUploaded = values . getBool ( 2 ) ; 
 + } 
 + 
 + @ Override 
 + public void serialize ( BserWriter writer ) throws IOException { 
 + writer . writeBytes ( 1 , encryptionKey . toByteArray ( ) ) ; 
 + writer . writeBool ( 2 , isUploaded ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java 
 deleted file mode 100644 
 index 7942fd2 . . 0000000 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / EphermalEncryptionKey . java 
 + + + / dev / null 
 @ @ - 1 , 46 + 0 , 0 @ @ 
 - package im . actor . core . modules . internal . encryption . entity ; 
 - 
 - import java . io . IOException ; 
 - 
 - import im . actor . runtime . bser . BserObject ; 
 - import im . actor . runtime . bser . BserValues ; 
 - import im . actor . runtime . bser . BserWriter ; 
 - 
 - public class EphermalEncryptionKey extends BserObject { 
 - 
 - private EncryptionKey encryptionKey ; 
 - private boolean isUploaded ; 
 - 
 - public EphermalEncryptionKey ( EncryptionKey encryptionKey , boolean isUploaded ) { 
 - this . encryptionKey = encryptionKey ; 
 - this . isUploaded = isUploaded ; 
 - } 
 - 
 - public EphermalEncryptionKey ( byte [ ] data ) throws IOException { 
 - load ( data ) ; 
 - } 
 - 
 - public EncryptionKey getEncryptionKey ( ) { 
 - return encryptionKey ; 
 - } 
 - 
 - public boolean isUploaded ( ) { 
 - return isUploaded ; 
 - } 
 - 
 - public EphermalEncryptionKey markUploaded ( ) { 
 - return new EphermalEncryptionKey ( encryptionKey , true ) ; 
 - } 
 - 
 - @ Override 
 - public void parse ( BserValues values ) throws IOException { 
 - encryptionKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; 
 - isUploaded = values . getBool ( 2 ) ; 
 - } 
 - 
 - @ Override 
 - public void serialize ( BserWriter writer ) throws IOException { 
 - writer . writeBytes ( 1 , encryptionKey . toByteArray ( ) ) ; 
 - writer . writeBool ( 2 , isUploaded ) ; 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java 
 index e1eaa64 . . 7f5c254 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / entity / PrivateKeyStorage . java 
 @ @ - 9 , 11 + 9 , 11 @ @ import im . actor . runtime . bser . BserWriter ; 
 
 public class PrivateKeyStorage extends BserObject { 
 
 - private long keyGroupId ; 
 + private int keyGroupId ; 
 private EncryptionKey identityKey = null ; 
 private ArrayList < EncryptionKey > keys = new ArrayList < EncryptionKey > ( ) ; 
 
 - public PrivateKeyStorage ( EncryptionKey identityKey , ArrayList < EncryptionKey > keys , long keyGroupId ) { 
 + public PrivateKeyStorage ( EncryptionKey identityKey , ArrayList < EncryptionKey > keys , int keyGroupId ) { 
 this . identityKey = identityKey ; 
 this . keys = keys ; 
 this . keyGroupId = keyGroupId ; 
 @ @ - 31 , 18 + 31 , 18 @ @ public class PrivateKeyStorage extends BserObject { 
 return keys ; 
 } 
 
 - public long getKeyGroupId ( ) { 
 + public int getKeyGroupId ( ) { 
 return keyGroupId ; 
 } 
 
 - public PrivateKeyStorage markUploaded ( long keyGroupId ) { 
 + public PrivateKeyStorage markUploaded ( int keyGroupId ) { 
 return new PrivateKeyStorage ( identityKey , keys , keyGroupId ) ; 
 } 
 
 @ Override 
 public void parse ( BserValues values ) throws IOException { 
 identityKey = new EncryptionKey ( values . getBytes ( 1 ) ) ; 
 - keyGroupId = values . optLong ( 2 ) ; 
 + keyGroupId = values . optInt ( 2 ) ; 
 for ( byte [ ] b : values . getRepeatedBytes ( 3 ) ) { 
 keys . add ( new EncryptionKey ( b ) ) ; 
 } 
 @ @ - 51 , 7 + 51 , 7 @ @ public class PrivateKeyStorage extends BserObject { 
 @ Override 
 public void serialize ( BserWriter writer ) throws IOException { 
 writer . writeObject ( 1 , identityKey ) ; 
 - writer . writeLong ( 2 , keyGroupId ) ; 
 + writer . writeInt ( 2 , keyGroupId ) ; 
 writer . writeRepeatedObj ( 3 , keys ) ; 
 } 
 }
