BLEU SCORE: 0.06074588070876682

TEST MSG: fix ( server : groups ) : allow to block users in groups via personal blacklist of owner
GENERATED MSG: wip ( server ) : channel updates

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala < nl > index a41b746 . . 1127e2f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala < nl > @ @ - 11 , 6 + 11 , 7 @ @ trait UserAcl { < nl > < nl > protected val system : ActorSystem < nl > < nl > + / / TODO : clarify names of params . < nl > protected def withNonBlockedPeer [ A ] ( < nl > contactUserId : Int , < nl > peer : Peer < nl > @ @ - 23 , 16 + 24 , 17 @ @ trait UserAcl { < nl > } < nl > < nl > protected def withNonBlockedUser [ A ] ( < nl > - contactUserId : Int , < nl > - contactOwnerUserId : Int < nl > + userId : Int , < nl > + ownerUserId : Int < nl > ) ( default : ⇒ Future [ A ] , failed : ⇒ Future [ A ] ) : Future [ A ] = { < nl > import system . dispatcher < nl > for { < nl > - isBlocked ← checkIsBlocked ( contactUserId , contactOwnerUserId ) < nl > + isBlocked ← checkIsBlocked ( userId , ownerUserId ) < nl > result ← if ( isBlocked ) failed else default < nl > } yield result < nl > } < nl > < nl > - protected def checkIsBlocked ( contactUserId : Int , contactOwnerUserId : Int ) : Future [ Boolean ] = < nl > - DbExtension ( system ) . db . run ( RelationRepo . isBlocked ( contactOwnerUserId , contactUserId ) ) < nl > - } < nl > \ No newline at end of file < nl > + / / check that ` userId ` is blocked by ` ownerUserId ` < nl > + protected def checkIsBlocked ( userId : Int , ownerUserId : Int ) : Future [ Boolean ] = < nl > + DbExtension ( system ) . db . run ( RelationRepo . isBlocked ( ownerUserId , userId ) ) < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala < nl > index 5080d09 . . 578a11e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala < nl > @ @ - 39 , 6 + 39 , 8 @ @ object GroupErrors { < nl > < nl > case object BlockedByUser extends Exception with NoStackTrace < nl > < nl > + case object UserIsBanned extends Exception with NoStackTrace < nl > + < nl > case object NoPermission extends Exception with NoStackTrace < nl > < nl > case object CantLeaveGroup extends Exception with NoStackTrace < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > index 22eef90 . . 94f0680 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > @ @ - 32 , 173 + 32 , 181 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > } else if ( state . isMember ( cmd . inviteeUserId ) ) { < nl > sender ( ) ! Status . Failure ( GroupErrors . UserAlreadyJoined ) < nl > } else { < nl > - val inviteeIsExUser = state . isExUser ( cmd . inviteeUserId ) < nl > + val isBlockedFu = checkIsBlocked ( cmd . inviteeUserId , state . ownerUserId ) < nl > < nl > - persist ( UserInvited ( Instant . now , cmd . inviteeUserId , cmd . inviterUserId ) ) { evt ⇒ < nl > - val newState = commit ( evt ) < nl > + onSuccess ( isBlockedFu ) { isBlocked ⇒ < nl > + if ( isBlocked ) { < nl > + sender ( ) ! Status . Failure ( GroupErrors . UserIsBanned ) < nl > + } else { < nl > + val inviteeIsExUser = state . isExUser ( cmd . inviteeUserId ) < nl > < nl > - val dateMillis = evt . ts . toEpochMilli < nl > - val memberIds = newState . memberIds < nl > + persist ( UserInvited ( Instant . now , cmd . inviteeUserId , cmd . inviterUserId ) ) { evt ⇒ < nl > + val newState = commit ( evt ) < nl > < nl > - / / TODO : unify isHistoryShared usage < nl > - val inviteeUpdatesNew : Vector [ Update ] = { < nl > - val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > - optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > - } < nl > - < nl > - / / For groups with not async members we should push Diff for members , and all Members for invitee < nl > - / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members < nl > - val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > - if ( newState . isAsyncMembers ) { < nl > - val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - ( u , u ) < nl > - } else { < nl > - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > - val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) < nl > - < nl > - ( < nl > - UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > - UpdateGroupMemberDiff ( < nl > - groupId , < nl > - addedMembers = inviteeMember . toVector , < nl > - membersCount = newState . membersCount , < nl > - removedUsers = Vector . empty < nl > - ) < nl > - ) < nl > - } < nl > - < nl > - val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( < nl > - groupId , < nl > - inviteUserId = cmd . inviterUserId , < nl > - date = dateMillis , < nl > - randomId = cmd . randomId < nl > - ) < nl > - < nl > - val membersUpdateObsolete = UpdateGroupUserInvitedObsolete ( < nl > - groupId , < nl > - userId = cmd . inviteeUserId , < nl > - inviterUserId = cmd . inviterUserId , < nl > - date = dateMillis , < nl > - randomId = cmd . randomId < nl > - ) < nl > - val serviceMessage = GroupServiceMessages . userInvited ( cmd . inviteeUserId ) < nl > - < nl > - / / TODO : remove deprecated < nl > - db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) : @ silent ) < nl > - < nl > - def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > - for { < nl > - / / push updated members list / count to inviteeUserId , < nl > - / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . inviteeUserId , < nl > - update = inviteeUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + val dateMillis = evt . ts . toEpochMilli < nl > + val memberIds = newState . memberIds < nl > < nl > - / / push all " refresh group " updates to inviteeUserId < nl > - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + / / TODO : unify isHistoryShared usage < nl > + val inviteeUpdatesNew : Vector [ Update ] = { < nl > + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > + optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > } < nl > < nl > - / / push updated members difference to all group members except inviteeUserId < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . inviterUserId , < nl > - authId = cmd . inviterAuthId , < nl > - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > - update = membersUpdateNew , < nl > - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + / / For groups with not async members we should push Diff for members , and all Members for invitee < nl > + / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members < nl > + val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > + if ( newState . isAsyncMembers ) { < nl > + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + ( u , u ) < nl > + } else { < nl > + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > + val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) < nl > + < nl > + ( < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > + UpdateGroupMemberDiff ( < nl > + groupId , < nl > + addedMembers = inviteeMember . toVector , < nl > + membersCount = newState . membersCount , < nl > + removedUsers = Vector . empty < nl > + ) < nl > + ) < nl > + } < nl > < nl > - / / explicitly send service message < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - cmd . inviterUserId , < nl > - cmd . inviterAuthId , < nl > - cmd . randomId , < nl > - serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > + val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( < nl > + groupId , < nl > + inviteUserId = cmd . inviterUserId , < nl > + date = dateMillis , < nl > + randomId = cmd . randomId < nl > ) < nl > - } yield SeqStateDate ( seq , state , date ) < nl > < nl > - def inviteCHANNELUpdates : Future [ SeqStateDate ] = < nl > - for { < nl > - / / push updated members count to inviteeUserId < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > + val membersUpdateObsolete = UpdateGroupUserInvitedObsolete ( < nl > + groupId , < nl > userId = cmd . inviteeUserId , < nl > - update = inviteeUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + inviterUserId = cmd . inviterUserId , < nl > + date = dateMillis , < nl > + randomId = cmd . randomId < nl > ) < nl > + val serviceMessage = GroupServiceMessages . userInvited ( cmd . inviteeUserId ) < nl > < nl > - / / push all " refresh group " updates to inviteeUserId < nl > - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > - } < nl > + / / TODO : remove deprecated < nl > + db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) : @ silent ) < nl > < nl > - / / push updated members count to all group members < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . inviterUserId , < nl > - authId = cmd . inviterAuthId , < nl > - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > - update = membersUpdateNew , < nl > - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list / count to inviteeUserId , < nl > + / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + update = inviteeUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - / / push service message to invitee < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . inviteeUserId , < nl > - update = serviceMessageUpdate ( < nl > - cmd . inviterUserId , < nl > - dateMillis , < nl > - cmd . randomId , < nl > - serviceMessage < nl > - ) , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - _ ← dialogExt . bump ( cmd . inviteeUserId , apiGroupPeer . asModel ) < nl > - } yield SeqStateDate ( seq , state , dateMillis ) < nl > + / / push all " refresh group " updates to inviteeUserId < nl > + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + } < nl > + < nl > + / / push updated members difference to all group members except inviteeUserId < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > + update = membersUpdateNew , < nl > + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - val result : Future [ SeqStateDate ] = for { < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / Groups V1 API updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / explicitly send service message < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + cmd . inviterUserId , < nl > + cmd . inviterAuthId , < nl > + cmd . randomId , < nl > + serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } yield SeqStateDate ( seq , state , date ) < nl > < nl > - / / push " Invited " to invitee < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . inviteeUserId , < nl > - inviteeUpdateObsolete , < nl > - pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > - deliveryId = s " invite _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + def inviteCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members count to inviteeUserId < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + update = inviteeUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - / / push " User added " to all group members except for ` inviterUserId ` < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - ( memberIds - cmd . inviteeUserId ) - cmd . inviterUserId , / / is it right ? < nl > - membersUpdateObsolete , < nl > - pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . Added ) ) , < nl > - deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + / / push all " refresh group " updates to inviteeUserId < nl > + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + } < nl > + < nl > + / / push updated members count to all group members < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > + update = membersUpdateNew , < nl > + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - / / push " User added " to ` inviterUserId ` < nl > - _ ← seqUpdExt . deliverClientUpdate ( < nl > - cmd . inviterUserId , < nl > - cmd . inviterAuthId , < nl > - membersUpdateObsolete , < nl > - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > - deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > + / / push service message to invitee < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + update = serviceMessageUpdate ( < nl > + cmd . inviterUserId , < nl > + dateMillis , < nl > + cmd . randomId , < nl > + serviceMessage < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + _ ← dialogExt . bump ( cmd . inviteeUserId , apiGroupPeer . asModel ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > + val result : Future [ SeqStateDate ] = for { < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / Groups V1 API updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + < nl > + / / push " Invited " to invitee < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + inviteeUpdateObsolete , < nl > + pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . invited ( newState . groupType ) ) ) , < nl > + deliveryId = s " invite _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / Groups V2 API updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / push " User added " to all group members except for ` inviterUserId ` < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + ( memberIds - cmd . inviteeUserId ) - cmd . inviterUserId , / / is it right ? < nl > + membersUpdateObsolete , < nl > + pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . Added ) ) , < nl > + deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > + < nl > + / / push " User added " to ` inviterUserId ` < nl > + _ ← seqUpdExt . deliverClientUpdate ( < nl > + cmd . inviterUserId , < nl > + cmd . inviterAuthId , < nl > + membersUpdateObsolete , < nl > + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > + deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > < nl > - seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / Groups V2 API updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - } yield seqStateDate < nl > + seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > < nl > - result pipeTo sender ( ) < nl > + } yield seqStateDate < nl > + < nl > + result pipeTo sender ( ) < nl > + } < nl > + } < nl > } < nl > } < nl > } < nl > @ @ - 213 , 135 + 221 , 178 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > if ( state . isMember ( cmd . joiningUserId ) & & ! state . isInvited ( cmd . joiningUserId ) ) { < nl > sender ( ) ! Status . Failure ( GroupErrors . UserAlreadyJoined ) < nl > } else { < nl > - / / user was invited in group by other group user < nl > - val wasInvited = state . isInvited ( cmd . joiningUserId ) < nl > - < nl > - / / trying to figure out who invited joining user . < nl > - / / Descending priority : < nl > - / / • inviter defined in ` Join ` command ( when invited via token ) < nl > - / / • inviter from members list ( when invited by other user ) < nl > - / / • group creator ( safe fallback ) < nl > - val optMember = state . members . get ( cmd . joiningUserId ) < nl > - val inviterUserId = cmd . invitingUserId < nl > - . orElse ( optMember . map ( _ . inviterUserId ) ) < nl > - . getOrElse ( state . ownerUserId ) < nl > - < nl > - persist ( UserJoined ( Instant . now , cmd . joiningUserId , inviterUserId ) ) { evt ⇒ < nl > - val newState = commit ( evt ) < nl > - < nl > - val date = evt . ts < nl > - val dateMillis = date . toEpochMilli < nl > - val showJoinMessage = newState . adminSettings . showJoinLeaveMessages < nl > - val memberIds = newState . memberIds < nl > - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > - val randomId = ACLUtils . randomLong ( ) < nl > - < nl > - / / If user was never invited to group - he don ' t have group on devices , < nl > - / / that means we need to push all group - info related updates < nl > - / / < nl > - / / If user was invited to group by other member - we don ' t need to push group updates , < nl > - / / cause they were pushed already on invite step < nl > - / / TODO : unify isHistoryShared usage < nl > - val joiningUserUpdatesNew : Vector [ Update ] = { < nl > - if ( wasInvited ) { < nl > - Vector . empty [ Update ] < nl > - } else { < nl > - val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > - optDrop + + : refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > - } < nl > - } < nl > - < nl > - / / For groups with not async members we should push : < nl > - / / • Diff for members ; < nl > - / / • Diff for joining user if he was previously invited ; < nl > - / / • Members for joining user if he wasn ' t previously invited . < nl > - / / < nl > - / / For groups with async members we should push : < nl > - / / • UpdateGroupMembersCountChanged for both joining user and members < nl > - val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > - if ( newState . isAsyncMembers ) { < nl > - val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > - ( u , u ) < nl > - } else { < nl > - val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) < nl > - val diff = UpdateGroupMemberDiff ( < nl > - groupId , < nl > - addedMembers = joiningMember . toVector , < nl > - membersCount = newState . membersCount , < nl > - removedUsers = Vector . empty < nl > - ) < nl > - < nl > - if ( wasInvited ) { < nl > - ( diff , diff ) < nl > - } else { < nl > - ( < nl > - UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > - diff < nl > - ) < nl > + val isBlockedFu = checkIsBlocked ( cmd . joiningUserId , state . ownerUserId ) < nl > + < nl > + onSuccess ( isBlockedFu ) { isBlocked ⇒ < nl > + if ( isBlocked ) { < nl > + sender ( ) ! Status . Failure ( GroupErrors . UserIsBanned ) < nl > + } else { < nl > + / / user was invited in group by other group user < nl > + val wasInvited = state . isInvited ( cmd . joiningUserId ) < nl > + < nl > + / / trying to figure out who invited joining user . < nl > + / / Descending priority : < nl > + / / • inviter defined in ` Join ` command ( when invited via token ) < nl > + / / • inviter from members list ( when invited by other user ) < nl > + / / • group creator ( safe fallback ) < nl > + val optMember = state . members . get ( cmd . joiningUserId ) < nl > + val inviterUserId = cmd . invitingUserId < nl > + . orElse ( optMember . map ( _ . inviterUserId ) ) < nl > + . getOrElse ( state . ownerUserId ) < nl > + < nl > + persist ( UserJoined ( Instant . now , cmd . joiningUserId , inviterUserId ) ) { evt ⇒ < nl > + val newState = commit ( evt ) < nl > + < nl > + val date = evt . ts < nl > + val dateMillis = date . toEpochMilli < nl > + val showJoinMessage = newState . adminSettings . showJoinLeaveMessages < nl > + val memberIds = newState . memberIds < nl > + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > + val randomId = ACLUtils . randomLong ( ) < nl > + < nl > + / / If user was never invited to group - he don ' t have group on devices , < nl > + / / that means we need to push all group - info related updates < nl > + / / < nl > + / / If user was invited to group by other member - we don ' t need to push group updates , < nl > + / / cause they were pushed already on invite step < nl > + / / TODO : unify isHistoryShared usage < nl > + val joiningUserUpdatesNew : Vector [ Update ] = { < nl > + if ( wasInvited ) { < nl > + Vector . empty [ Update ] < nl > + } else { < nl > + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > + optDrop + + : refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > + } < nl > } < nl > - } < nl > < nl > - / / TODO : not sure how it should be in old API < nl > - val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) < nl > + / / For groups with not async members we should push : < nl > + / / • Diff for members ; < nl > + / / • Diff for joining user if he was previously invited ; < nl > + / / • Members for joining user if he wasn ' t previously invited . < nl > + / / < nl > + / / For groups with async members we should push : < nl > + / / • UpdateGroupMembersCountChanged for both joining user and members < nl > + val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = < nl > + if ( newState . isAsyncMembers ) { < nl > + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) < nl > + ( u , u ) < nl > + } else { < nl > + val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) < nl > + val diff = UpdateGroupMemberDiff ( < nl > + groupId , < nl > + addedMembers = joiningMember . toVector , < nl > + membersCount = newState . membersCount , < nl > + removedUsers = Vector . empty < nl > + ) < nl > < nl > - val serviceMessage = GroupServiceMessages . userJoined < nl > + if ( wasInvited ) { < nl > + ( diff , diff ) < nl > + } else { < nl > + ( < nl > + UpdateGroupMembersUpdated ( groupId , apiMembers ) , < nl > + diff < nl > + ) < nl > + } < nl > + } < nl > < nl > - / / TODO : remove deprecated < nl > - db . run ( GroupUserRepo . create ( < nl > - groupId , < nl > - userId = cmd . joiningUserId , < nl > - inviterUserId = inviterUserId , < nl > - invitedAt = optMember . map ( _ . invitedAt ) . getOrElse ( date ) , < nl > - joinedAt = Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , < nl > - isAdmin = false < nl > - ) : @ silent ) < nl > + / / TODO : not sure how it should be in old API < nl > + val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) < nl > < nl > - def joinGROUPUpdates : Future [ SeqStateDate ] = < nl > - for { < nl > - / / push all group updates to joiningUserId < nl > - _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > - } < nl > + val serviceMessage = GroupServiceMessages . userJoined < nl > < nl > - / / push updated members list / count / difference to joining user , < nl > - / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > - / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + / / TODO : remove deprecated < nl > + db . run ( GroupUserRepo . create ( < nl > + groupId , < nl > userId = cmd . joiningUserId , < nl > - authId = cmd . joiningUserAuthId , < nl > - update = joiningUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here < nl > - deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > + inviterUserId = inviterUserId , < nl > + invitedAt = optMember . map ( _ . invitedAt ) . getOrElse ( date ) , < nl > + joinedAt = Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , < nl > + isAdmin = false < nl > + ) : @ silent ) < nl > < nl > - ) < nl > + def joinGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push all group updates to joiningUserId < nl > + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > + } < nl > + < nl > + / / push updated members list / count / difference to joining user , < nl > + / / make it ` FatSeqUpdate ` if this user invited to group for first time . < nl > + / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . joiningUserId , < nl > + authId = cmd . joiningUserAuthId , < nl > + update = joiningUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here < nl > + deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > < nl > - / / push updated members list / count to all group members except joiningUserId < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - memberIds - cmd . joiningUserId , < nl > - membersUpdateNew , < nl > - deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > + ) < nl > < nl > - date ← if ( showJoinMessage ) { < nl > - dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . joiningUserId , < nl > - senderAuthId = cmd . joiningUserAuthId , < nl > - randomId = randomId , < nl > - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > - ) map ( _ . date ) < nl > - } else { < nl > - / / write service message only for joining user < nl > - / / and push join message < nl > + / / push updated members list / count to all group members except joiningUserId < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + memberIds - cmd . joiningUserId , < nl > + membersUpdateNew , < nl > + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > + < nl > + date ← if ( showJoinMessage ) { < nl > + dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . joiningUserId , < nl > + senderAuthId = cmd . joiningUserAuthId , < nl > + randomId = randomId , < nl > + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > + ) map ( _ . date ) < nl > + } else { < nl > + / / write service message only for joining user < nl > + / / and push join message < nl > + for { < nl > + _ ← dialogExt . writeMessageSelf ( < nl > + userId = cmd . joiningUserId , < nl > + peer = apiGroupPeer , < nl > + senderUserId = cmd . joiningUserId , < nl > + dateMillis = dateMillis , < nl > + randomId = randomId , < nl > + serviceMessage < nl > + ) < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . joiningUserId , < nl > + update = serviceMessageUpdate ( < nl > + cmd . joiningUserId , < nl > + dateMillis , < nl > + randomId , < nl > + serviceMessage < nl > + ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } yield dateMillis < nl > + } < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + def joinCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > - _ ← dialogExt . writeMessageSelf ( < nl > + / / push all group updates to joiningUserId < nl > + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > + } < nl > + < nl > + / / push updated members count to joining user < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > - peer = apiGroupPeer , < nl > - senderUserId = cmd . joiningUserId , < nl > - dateMillis = dateMillis , < nl > - randomId = randomId , < nl > - serviceMessage < nl > + authId = cmd . joiningUserAuthId , < nl > + update = joiningUpdateNew , < nl > + deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > + < nl > + / / push updated members count to all group members except joining user < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + memberIds - cmd . joiningUserId , < nl > + membersUpdateNew , < nl > + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > + < nl > + / / push join message only to joining user < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = cmd . joiningUserId , < nl > update = serviceMessageUpdate ( < nl > @ @ - 352 , 69 + 403 , 34 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > ) , < nl > deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > - } yield dateMillis < nl > - } < nl > - } yield SeqStateDate ( seq , state , date ) < nl > - < nl > - def joinCHANNELUpdates : Future [ SeqStateDate ] = < nl > - for { < nl > - / / push all group updates to joiningUserId < nl > - _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > - } < nl > - < nl > - / / push updated members count to joining user < nl > - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > - userId = cmd . joiningUserId , < nl > - authId = cmd . joiningUserAuthId , < nl > - update = joiningUpdateNew , < nl > - deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > - < nl > - / / push updated members count to all group members except joining user < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - memberIds - cmd . joiningUserId , < nl > - membersUpdateNew , < nl > - deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > + _ ← dialogExt . bump ( cmd . joiningUserId , apiGroupPeer . asModel ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > - / / push join message only to joining user < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . joiningUserId , < nl > - update = serviceMessageUpdate ( < nl > - cmd . joiningUserId , < nl > - dateMillis , < nl > - randomId , < nl > - serviceMessage < nl > - ) , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - _ ← dialogExt . bump ( cmd . joiningUserId , apiGroupPeer . asModel ) < nl > - } yield SeqStateDate ( seq , state , dateMillis ) < nl > - < nl > - val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > - for { < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / Groups V1 API updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - < nl > - / / push update about members to all users , except joining user < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - memberIds - cmd . joiningUserId , < nl > - membersUpdateObsolete , < nl > - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > - deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > + val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > + for { < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / Groups V1 API updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + < nl > + / / push update about members to all users , except joining user < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + memberIds - cmd . joiningUserId , < nl > + membersUpdateObsolete , < nl > + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > + deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / Groups V2 API updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / Groups V2 API updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > + seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > < nl > - } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) < nl > + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) < nl > < nl > - result pipeTo sender ( ) < nl > + result pipeTo sender ( ) < nl > + } < nl > + } < nl > } < nl > } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala < nl > index 74d3940 . . e3332b1 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala < nl > @ @ - 20 , 10 + 20 , 12 @ @ object GroupRpcErrors { < nl > val GroupNotPublic = RpcError ( 400 , " GROUP _ IS _ NOT _ PUBLIC " , " The group is not public . " , false , None ) < nl > val CantLeaveGroup = RpcError ( 403 , " CANT _ LEAVE _ GROUP " , " You can ' t leave this group ! " , false , None ) < nl > val CantJoinGroup = RpcError ( 403 , " CANT _ JOIN _ GROUP " , " You can ' t join this group ! " , false , None ) < nl > + val CantGrantToBot = RpcError ( 400 , " CANT _ GRANT _ TO _ BOT " , " Can ' t grant this permissions to bot " , false , None ) < nl > + val UserIsBanned = RpcError ( 403 , " USER _ IS _ BANNED " , " You can ' t join this group . " , false , None ) < nl > + < nl > val InvalidShortName = RpcError ( 400 , " GROUP _ SHORT _ NAME _ INVALID " , < nl > " Invalid group short name . Valid short name should contain from 5 to 32 characters , and may consist of latin characters , numbers and underscores " , false , None ) < nl > val ShortNameTaken = RpcError ( 400 , " GROUP _ SHORT _ NAME _ TAKEN " , " This short name already belongs to other user or group , we are sorry ! " , false , None ) < nl > val NoPermission = CommonRpcErrors . forbidden ( " You have no permission to execute this action " ) < nl > - val CantGrantToBot = RpcError ( 400 , " CANT _ GRANT _ TO _ BOT " , " Can ' t grant this permissions to bot " , false , None ) < nl > } < nl > / / format : ON < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index d0c9916 . . 8a568a5 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 645 , 6 + 645 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > case GroupErrors . ShortNameTaken ⇒ GroupRpcErrors . ShortNameTaken < nl > case GroupErrors . NoPermission ⇒ GroupRpcErrors . NoPermission < nl > case GroupErrors . CantLeaveGroup ⇒ GroupRpcErrors . CantLeaveGroup < nl > + case GroupErrors . UserIsBanned ⇒ GroupRpcErrors . UserIsBanned < nl > } < nl > < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index e82dbae . . 5433dd0 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 1 , 11 + 1 , 9 @ @ < nl > package im . actor . server . dialog < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . util . FastFuture < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } < nl > import im . actor . api . rpc . messaging . _ < nl > - import im . actor . server . db . DbExtension < nl > import im . actor . server . messaging . PushText < nl > import im . actor . server . model . Peer < nl > import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqUpdatesExtension } < nl > @ @ - 54 , 7 + 52 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > . withCensoredText ( censoredPushText ) < nl > . withPeer ( peer ) < nl > ) , < nl > - deliveryId = deliveryId ( peer , randomId ) , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , < nl > deliveryTag = deliveryTag < nl > ) < nl > } yield ( ) < nl > @ @ - 100 , 7 + 98 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > default = Some ( senderUpdate ) , < nl > custom = senderAuthId map ( authId ⇒ Map ( authId → senderClientUpdate ) ) getOrElse Map . empty , < nl > pushRules = PushRules ( isFat = isFat , excludeAuthIds = senderAuthId . toSeq ) , < nl > - deliveryId = deliveryId ( peer , randomId ) , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , < nl > deliveryTag = deliveryTag < nl > ) < nl > } < nl > @ @ - 134 , 9 + 132 , 6 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > } yield ( ) < nl > < nl > - private def deliveryId ( peer : Peer , randomId : Long ) = < nl > - s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " < nl > - < nl > private def reduceKey ( prefix : String , peer : Peer ) : String = < nl > s " $ { prefix } _ $ { peer . ` type ` . value } _ $ { peer . id } " < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 85a5734 . . 6d19375 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import akka . pattern . pipe < nl > import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . files . ApiAvatar < nl > import im . actor . api . rpc . groups . _ < nl > + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } < nl > import im . actor . api . rpc . users . ApiSex < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . CommonErrors < nl > @ @ - 205 , 7 + 206 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / TODO : remove deprecated < nl > db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) < nl > < nl > - def inviteGROUPUpdates : Future [ SeqState ] = < nl > + def inviteGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push updated members list to inviteeUserId , < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > @ @ - 221 , 17 + 222 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > < nl > / / push updated members list to all group members except inviteeUserId < nl > - seqState ← seqUpdExt . broadcastClientUpdate ( < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > userId = cmd . inviterUserId , < nl > authId = cmd . inviterAuthId , < nl > bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > update = membersUpdateNew , < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - } yield seqState < nl > < nl > - def inviteCHANNELUpdates : Future [ SeqState ] = < nl > + / / explicitly send service message < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + cmd . inviterUserId , < nl > + cmd . inviterAuthId , < nl > + cmd . randomId , < nl > + serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + def inviteCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . < nl > / / invitee could be admin , if he created this group , and turning back < nl > @ @ - 258 , 9 + 268 , 24 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > < nl > - / / get current SeqState for inviter user < nl > - seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) < nl > - } yield seqState < nl > + / / push service message to invitee < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . inviteeUserId , < nl > + authId = 0L , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push service message to inviter and return seqState < nl > + SeqState ( seq , state ) ← pushUpdateMessage ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > @ @ - 296 , 18 + 321 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > + seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > < nl > - / / explicitly send service message < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - cmd . inviterUserId , < nl > - cmd . inviterAuthId , < nl > - cmd . randomId , < nl > - serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 336 , 6 + 352 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val newState = commit ( evt ) < nl > < nl > val date = evt . ts < nl > + val dateMillis = date . toEpochMilli < nl > val memberIds = newState . memberIds < nl > val members = newState . members . values . map ( _ . asStruct ) . toVector < nl > val randomId = ACLUtils . randomLong ( ) < nl > @ @ - 367 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > isAdmin = false < nl > ) ) < nl > < nl > - def joinGROUPUpdates : Future [ SeqState ] = < nl > + def joinGROUPUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push all group updates to joiningUserId < nl > _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > @ @ - 376 , 7 + 393 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / push updated members list to joining user , < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - seqState ← seqUpdExt . deliverClientUpdate ( < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > update = membersUpdateNew , < nl > @ @ - 391 , 9 + 408 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > - } yield seqState < nl > < nl > - def joinCHANNELUpdates : Future [ SeqState ] = < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . joiningUserId , < nl > + senderAuthId = cmd . joiningUserAuthId , < nl > + randomId = randomId , < nl > + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > + ) < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + def joinCHANNELUpdates : Future [ SeqStateDate ] = < nl > for { < nl > / / push all group updates to joiningUserId < nl > _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > @ @ - 403 , 7 + 428 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . < nl > / / joining user can be admin , if he created this group , and turning back < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > + SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > @ @ - 421 , 7 + 446 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > - } yield seqState < nl > + < nl > + / / push service message to joining user and return seqState < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . joiningUserId , < nl > + authId = cmd . joiningUserAuthId , < nl > + ts = dateMillis , < nl > + randomId = randomId , < nl > + serviceMessage < nl > + ) < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > < nl > val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > for { < nl > @ @ - 441 , 16 + 475 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > + seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . joiningUserId , < nl > - senderAuthId = cmd . joiningUserAuthId , < nl > - randomId = randomId , < nl > - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 < nl > - ) < nl > - } yield ( SeqStateDate ( seq , state , date ) , memberIds . toVector : + inviterUserId , randomId ) < nl > + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 474 , 11 + 501 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) < nl > < nl > - val leftUserUpdatesNew = List ( < nl > - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > - ) < nl > + val leftUserUpdatesNew = < nl > + if ( state . typ . isChannel ) List ( < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > + ) < nl > + else List ( < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > + ) < nl > < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > < nl > @ @ - 492 , 6 + 523 , 67 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + val leaveGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all group members < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + state . memberIds - cmd . userId , < nl > + membersUpdateNew < nl > + ) < nl > + < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . userId , < nl > + senderAuthId = cmd . authId , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + < nl > + / / push left user that he is no longer a member < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + < nl > + / / push left user updates < nl > + / / • with empty group members < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + val leaveCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all ADMINS , except userId ( if he was there ) < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + state . adminIds - cmd . userId , < nl > + membersUpdateNew < nl > + ) < nl > + < nl > + / / push service message to left user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage < nl > + ) < nl > + < nl > + / / push left user that he is no longer a member < nl > + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . userId , < nl > + authId = cmd . authId , < nl > + update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > / / read this dialog by user that leaves group . don ' t wait for ack < nl > dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > @ @ - 512 , 36 + 604 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / push updated members list to all group members < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - state . memberIds - cmd . userId , < nl > - membersUpdateNew < nl > - ) < nl > + seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates < nl > < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . userId , < nl > - senderAuthId = cmd . authId , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > - < nl > - / / push left user that he is no longer a member < nl > - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > - userId = cmd . userId , < nl > - authId = cmd . authId , < nl > - update = UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > - ) < nl > - < nl > - / / push left user updates < nl > - / / • with empty group members < nl > - / / • that he can ' t view and invite members < nl > - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > - } < nl > - < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) < nl > } < nl > @ @ - 549 , 7 + 614 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > < nl > protected def kick ( cmd : Kick ) : Unit = { < nl > - if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { < nl > + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . kickedUserId ) ) { < nl > + sender ( ) ! notAdmin < nl > + } else if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { < nl > sender ( ) ! notMember < nl > } else { < nl > persist ( UserKicked ( Instant . now , cmd . kickedUserId , cmd . kickerUserId ) ) { evt ⇒ < nl > @ @ - 560 , 12 + 627 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) < nl > < nl > - val kickedUserUpdatesNew : List [ Update ] = List ( < nl > - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > - UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > - ) < nl > + val kickedUserUpdatesNew : List [ Update ] = < nl > + if ( state . typ . isChannel ) List ( < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > + UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > + else List ( < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , < nl > + UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + ) < nl > < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > < nl > @ @ - 579 , 6 + 651 , 68 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } yield ( ) < nl > ) < nl > < nl > + val kickGROUPUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all group members . Don ' t push to kicked user ! < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , < nl > + bcastUserIds = newState . memberIds - cmd . kickerUserId , < nl > + update = membersUpdateNew < nl > + ) < nl > + < nl > + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > + apiGroupPeer , < nl > + senderUserId = cmd . kickerUserId , < nl > + senderAuthId = cmd . kickerAuthId , < nl > + randomId = cmd . randomId , < nl > + message = serviceMessage , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + < nl > + / / push kicked user updates < nl > + / / • with empty group members < nl > + / / • that he is no longer a member of group < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , date ) < nl > + < nl > + val kickCHANNELUpdates : Future [ SeqStateDate ] = < nl > + for { < nl > + / / push updated members list to all ADMINS . Don ' t push to kicked user ! < nl > + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , < nl > + bcastUserIds = newState . adminIds - cmd . kickerUserId , < nl > + update = membersUpdateNew < nl > + ) < nl > + < nl > + / / push service message to kicker user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . kickerUserId , < nl > + authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push service message to kicked user < nl > + _ ← pushUpdateMessage ( < nl > + userId = cmd . kickedUserId , < nl > + authId = 0L , < nl > + ts = dateMillis , < nl > + randomId = cmd . randomId , < nl > + serviceMessage < nl > + ) < nl > + < nl > + / / push kicked user updates < nl > + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > + } < nl > + } yield SeqStateDate ( seq , state , dateMillis ) < nl > + < nl > / / read this dialog by kicked user . don ' t wait for ack < nl > dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) < nl > val result : Future [ SeqStateDate ] = for { < nl > @ @ - 598 , 32 + 732 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / push updated members list to all group members . Don ' t push to kicked user ! < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . kickerUserId , < nl > - authId = cmd . kickerAuthId , < nl > - bcastUserIds = newState . memberIds - cmd . kickerUserId , < nl > - update = membersUpdateNew < nl > - ) < nl > - < nl > - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > - apiGroupPeer , < nl > - senderUserId = cmd . kickerUserId , < nl > - senderAuthId = cmd . kickerAuthId , < nl > - randomId = cmd . randomId , < nl > - message = serviceMessage , < nl > - deliveryTag = Some ( Optimization . GroupV2 ) < nl > - ) < nl > + seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates < nl > < nl > - / / push kicked user updates < nl > - / / • with empty group members < nl > - / / • that he is no longer a member of group < nl > - / / • that he can ' t view and invite members < nl > - _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > - } < nl > - < nl > - } yield SeqStateDate ( seq , state , date ) < nl > + } yield seqStateDate < nl > < nl > result pipeTo sender ( ) < nl > } < nl > @ @ - 987 , 6 + 1098 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > + / / и л и в с е т а к и б у д е т broadcast ? < nl > + private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { < nl > + val messUpdate = UpdateMessage ( < nl > + peer = apiGroupPeer , < nl > + senderUserId = userId , < nl > + date = ts , < nl > + randomId = randomId , < nl > + message = message , < nl > + attributes = None , < nl > + quotedMessage = None < nl > + ) < nl > + seqUpdExt . deliverClientUpdate ( < nl > + userId = userId , < nl > + authId = authId , < nl > + update = messUpdate , < nl > + deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , < nl > + deliveryTag = Some ( Optimization . GroupV2 ) < nl > + ) < nl > + } < nl > + < nl > private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = < nl > s map ( _ . trim ) filter ( _ . nonEmpty ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index 9f0b5ed . . ee7837b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 63 , 6 + 63 , 9 @ @ final class SeqUpdatesExtension ( _ system : ActorSystem ) < nl > optTs . getOrElse ( throw new RuntimeException ( s " No Migration timestamp found for $ { MigrationNameList . MultiSequence } " ) ) < nl > } < nl > < nl > + def msgDeliveryId ( peer : Peer , randomId : Long ) = < nl > + s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " < nl > + < nl > def getSeqState ( userId : Int , authId : Long ) : Future [ SeqState ] = < nl > ( region . ref ? Envelope ( userId ) . withGetSeqState ( GetSeqState ( authId ) ) ) . mapTo [ SeqState ] < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > index 62a149c . . 80a199b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala < nl > @ @ - 21 , 12 + 21 , 13 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > * Send update to all devices of user and return ` SeqState ` associated with ` authId ` < nl > * / < nl > def deliverClientUpdate ( < nl > - userId : Int , < nl > - authId : Long , < nl > - update : Update , < nl > - pushRules : PushRules = PushRules ( ) , < nl > - reduceKey : Option [ String ] = None , < nl > - deliveryId : String = " " < nl > + userId : Int , < nl > + authId : Long , < nl > + update : Update , < nl > + pushRules : PushRules = PushRules ( ) , < nl > + reduceKey : Option [ String ] = None , < nl > + deliveryId : String = " " , < nl > + deliveryTag : Option [ String ] = None < nl > ) : Future [ SeqState ] = < nl > deliverUpdate ( < nl > userId , < nl > @ @ - 34 , 7 + 35 , 8 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ < nl > UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) , < nl > pushRules , < nl > reduceKey , < nl > - deliveryId < nl > + deliveryId , < nl > + deliveryTag < nl > ) < nl > < nl > / * * < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 59786e3 . . f35f67f 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm < nl > import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging < nl > import com . typesafe . sbt . packager . debian . JDebPackaging < nl > < nl > - object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { < nl > + object Build extends sbt . Build with Versioning with Releasing with Packaging { < nl > val ScalaVersion = " 2 . 11 . 8 " < nl > val BotKitVersion = getVersion < nl > < nl > @ @ - 89 , 7 + 89 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging wit < nl > " actor " , < nl > file ( " . " ) , < nl > settings = < nl > - startUpSettings + + < nl > packagingSettings + + < nl > defaultSettingsServer + + < nl > Revolver . settings + + < nl > diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala < nl > deleted file mode 100644 < nl > index 62ca90f . . 0000000 < nl > - - - a / actor - server / project / StartHook . scala < nl > + + + / dev / null < nl > @ @ - 1 , 15 + 0 , 0 @ @ < nl > - package im . actor < nl > - < nl > - import sbt . Keys . _ < nl > - import sbt . _ < nl > - < nl > - private [ actor ] trait StartHook { < nl > - lazy val startUpSettings = Seq ( < nl > - onLoad in Global : = { state = > < nl > - < nl > - println ( " = = = = = = = = = = = = = = hello world " ) < nl > - state < nl > - } < nl > - ) < nl > - < nl > - }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala 
 index a41b746 . . 1127e2f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / UserAcl . scala 
 @ @ - 11 , 6 + 11 , 7 @ @ trait UserAcl { 
 
 protected val system : ActorSystem 
 
 + / / TODO : clarify names of params . 
 protected def withNonBlockedPeer [ A ] ( 
 contactUserId : Int , 
 peer : Peer 
 @ @ - 23 , 16 + 24 , 17 @ @ trait UserAcl { 
 } 
 
 protected def withNonBlockedUser [ A ] ( 
 - contactUserId : Int , 
 - contactOwnerUserId : Int 
 + userId : Int , 
 + ownerUserId : Int 
 ) ( default : ⇒ Future [ A ] , failed : ⇒ Future [ A ] ) : Future [ A ] = { 
 import system . dispatcher 
 for { 
 - isBlocked ← checkIsBlocked ( contactUserId , contactOwnerUserId ) 
 + isBlocked ← checkIsBlocked ( userId , ownerUserId ) 
 result ← if ( isBlocked ) failed else default 
 } yield result 
 } 
 
 - protected def checkIsBlocked ( contactUserId : Int , contactOwnerUserId : Int ) : Future [ Boolean ] = 
 - DbExtension ( system ) . db . run ( RelationRepo . isBlocked ( contactOwnerUserId , contactUserId ) ) 
 - } 
 \ No newline at end of file 
 + / / check that ` userId ` is blocked by ` ownerUserId ` 
 + protected def checkIsBlocked ( userId : Int , ownerUserId : Int ) : Future [ Boolean ] = 
 + DbExtension ( system ) . db . run ( RelationRepo . isBlocked ( ownerUserId , userId ) ) 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala 
 index 5080d09 . . 578a11e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupErrors . scala 
 @ @ - 39 , 6 + 39 , 8 @ @ object GroupErrors { 
 
 case object BlockedByUser extends Exception with NoStackTrace 
 
 + case object UserIsBanned extends Exception with NoStackTrace 
 + 
 case object NoPermission extends Exception with NoStackTrace 
 
 case object CantLeaveGroup extends Exception with NoStackTrace 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 index 22eef90 . . 94f0680 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 @ @ - 32 , 173 + 32 , 181 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 } else if ( state . isMember ( cmd . inviteeUserId ) ) { 
 sender ( ) ! Status . Failure ( GroupErrors . UserAlreadyJoined ) 
 } else { 
 - val inviteeIsExUser = state . isExUser ( cmd . inviteeUserId ) 
 + val isBlockedFu = checkIsBlocked ( cmd . inviteeUserId , state . ownerUserId ) 
 
 - persist ( UserInvited ( Instant . now , cmd . inviteeUserId , cmd . inviterUserId ) ) { evt ⇒ 
 - val newState = commit ( evt ) 
 + onSuccess ( isBlockedFu ) { isBlocked ⇒ 
 + if ( isBlocked ) { 
 + sender ( ) ! Status . Failure ( GroupErrors . UserIsBanned ) 
 + } else { 
 + val inviteeIsExUser = state . isExUser ( cmd . inviteeUserId ) 
 
 - val dateMillis = evt . ts . toEpochMilli 
 - val memberIds = newState . memberIds 
 + persist ( UserInvited ( Instant . now , cmd . inviteeUserId , cmd . inviterUserId ) ) { evt ⇒ 
 + val newState = commit ( evt ) 
 
 - / / TODO : unify isHistoryShared usage 
 - val inviteeUpdatesNew : Vector [ Update ] = { 
 - val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 - optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 - } 
 - 
 - / / For groups with not async members we should push Diff for members , and all Members for invitee 
 - / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members 
 - val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 - if ( newState . isAsyncMembers ) { 
 - val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - ( u , u ) 
 - } else { 
 - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 - val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) 
 - 
 - ( 
 - UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 - UpdateGroupMemberDiff ( 
 - groupId , 
 - addedMembers = inviteeMember . toVector , 
 - membersCount = newState . membersCount , 
 - removedUsers = Vector . empty 
 - ) 
 - ) 
 - } 
 - 
 - val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( 
 - groupId , 
 - inviteUserId = cmd . inviterUserId , 
 - date = dateMillis , 
 - randomId = cmd . randomId 
 - ) 
 - 
 - val membersUpdateObsolete = UpdateGroupUserInvitedObsolete ( 
 - groupId , 
 - userId = cmd . inviteeUserId , 
 - inviterUserId = cmd . inviterUserId , 
 - date = dateMillis , 
 - randomId = cmd . randomId 
 - ) 
 - val serviceMessage = GroupServiceMessages . userInvited ( cmd . inviteeUserId ) 
 - 
 - / / TODO : remove deprecated 
 - db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) : @ silent ) 
 - 
 - def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 - for { 
 - / / push updated members list / count to inviteeUserId , 
 - / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . inviteeUserId , 
 - update = inviteeUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + val dateMillis = evt . ts . toEpochMilli 
 + val memberIds = newState . memberIds 
 
 - / / push all " refresh group " updates to inviteeUserId 
 - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + / / TODO : unify isHistoryShared usage 
 + val inviteeUpdatesNew : Vector [ Update ] = { 
 + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 + optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 } 
 
 - / / push updated members difference to all group members except inviteeUserId 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . inviterUserId , 
 - authId = cmd . inviterAuthId , 
 - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 - update = membersUpdateNew , 
 - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + / / For groups with not async members we should push Diff for members , and all Members for invitee 
 + / / For groups with async members we should push UpdateGroupMembersCountChanged for both invitee and members 
 + val ( inviteeUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 + if ( newState . isAsyncMembers ) { 
 + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + ( u , u ) 
 + } else { 
 + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 + val inviteeMember = apiMembers . find ( _ . userId = = cmd . inviteeUserId ) 
 + 
 + ( 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 + UpdateGroupMemberDiff ( 
 + groupId , 
 + addedMembers = inviteeMember . toVector , 
 + membersCount = newState . membersCount , 
 + removedUsers = Vector . empty 
 + ) 
 + ) 
 + } 
 
 - / / explicitly send service message 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - cmd . inviterUserId , 
 - cmd . inviterAuthId , 
 - cmd . randomId , 
 - serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 + val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( 
 + groupId , 
 + inviteUserId = cmd . inviterUserId , 
 + date = dateMillis , 
 + randomId = cmd . randomId 
 ) 
 - } yield SeqStateDate ( seq , state , date ) 
 
 - def inviteCHANNELUpdates : Future [ SeqStateDate ] = 
 - for { 
 - / / push updated members count to inviteeUserId 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 + val membersUpdateObsolete = UpdateGroupUserInvitedObsolete ( 
 + groupId , 
 userId = cmd . inviteeUserId , 
 - update = inviteeUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + inviterUserId = cmd . inviterUserId , 
 + date = dateMillis , 
 + randomId = cmd . randomId 
 ) 
 + val serviceMessage = GroupServiceMessages . userInvited ( cmd . inviteeUserId ) 
 
 - / / push all " refresh group " updates to inviteeUserId 
 - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 - } 
 + / / TODO : remove deprecated 
 + db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) : @ silent ) 
 
 - / / push updated members count to all group members 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . inviterUserId , 
 - authId = cmd . inviterAuthId , 
 - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 - update = membersUpdateNew , 
 - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list / count to inviteeUserId , 
 + / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + update = inviteeUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - / / push service message to invitee 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . inviteeUserId , 
 - update = serviceMessageUpdate ( 
 - cmd . inviterUserId , 
 - dateMillis , 
 - cmd . randomId , 
 - serviceMessage 
 - ) , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - _ ← dialogExt . bump ( cmd . inviteeUserId , apiGroupPeer . asModel ) 
 - } yield SeqStateDate ( seq , state , dateMillis ) 
 + / / push all " refresh group " updates to inviteeUserId 
 + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + } 
 + 
 + / / push updated members difference to all group members except inviteeUserId 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 + update = membersUpdateNew , 
 + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - val result : Future [ SeqStateDate ] = for { 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / Groups V1 API updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / explicitly send service message 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + cmd . inviterUserId , 
 + cmd . inviterAuthId , 
 + cmd . randomId , 
 + serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } yield SeqStateDate ( seq , state , date ) 
 
 - / / push " Invited " to invitee 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . inviteeUserId , 
 - inviteeUpdateObsolete , 
 - pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 - deliveryId = s " invite _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + def inviteCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members count to inviteeUserId 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + update = inviteeUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = false , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - / / push " User added " to all group members except for ` inviterUserId ` 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - ( memberIds - cmd . inviteeUserId ) - cmd . inviterUserId , / / is it right ? 
 - membersUpdateObsolete , 
 - pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . Added ) ) , 
 - deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + / / push all " refresh group " updates to inviteeUserId 
 + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + } 
 + 
 + / / push updated members count to all group members 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 + update = membersUpdateNew , 
 + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - / / push " User added " to ` inviterUserId ` 
 - _ ← seqUpdExt . deliverClientUpdate ( 
 - cmd . inviterUserId , 
 - cmd . inviterAuthId , 
 - membersUpdateObsolete , 
 - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 - deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 + / / push service message to invitee 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + update = serviceMessageUpdate ( 
 + cmd . inviterUserId , 
 + dateMillis , 
 + cmd . randomId , 
 + serviceMessage 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + _ ← dialogExt . bump ( cmd . inviteeUserId , apiGroupPeer . asModel ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 + val result : Future [ SeqStateDate ] = for { 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Groups V1 API updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + / / push " Invited " to invitee 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + inviteeUpdateObsolete , 
 + pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . invited ( newState . groupType ) ) ) , 
 + deliveryId = s " invite _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / Groups V2 API updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / push " User added " to all group members except for ` inviterUserId ` 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + ( memberIds - cmd . inviteeUserId ) - cmd . inviterUserId , / / is it right ? 
 + membersUpdateObsolete , 
 + pushRules = seqUpdExt . pushRules ( isFat = true , Some ( PushTexts . Added ) ) , 
 + deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 + 
 + / / push " User added " to ` inviterUserId ` 
 + _ ← seqUpdExt . deliverClientUpdate ( 
 + cmd . inviterUserId , 
 + cmd . inviterAuthId , 
 + membersUpdateObsolete , 
 + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 + deliveryId = s " useradded _ obsolete _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 
 - seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Groups V2 API updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - } yield seqStateDate 
 + seqStateDate ← if ( newState . groupType . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 
 - result pipeTo sender ( ) 
 + } yield seqStateDate 
 + 
 + result pipeTo sender ( ) 
 + } 
 + } 
 } 
 } 
 } 
 @ @ - 213 , 135 + 221 , 178 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 if ( state . isMember ( cmd . joiningUserId ) & & ! state . isInvited ( cmd . joiningUserId ) ) { 
 sender ( ) ! Status . Failure ( GroupErrors . UserAlreadyJoined ) 
 } else { 
 - / / user was invited in group by other group user 
 - val wasInvited = state . isInvited ( cmd . joiningUserId ) 
 - 
 - / / trying to figure out who invited joining user . 
 - / / Descending priority : 
 - / / • inviter defined in ` Join ` command ( when invited via token ) 
 - / / • inviter from members list ( when invited by other user ) 
 - / / • group creator ( safe fallback ) 
 - val optMember = state . members . get ( cmd . joiningUserId ) 
 - val inviterUserId = cmd . invitingUserId 
 - . orElse ( optMember . map ( _ . inviterUserId ) ) 
 - . getOrElse ( state . ownerUserId ) 
 - 
 - persist ( UserJoined ( Instant . now , cmd . joiningUserId , inviterUserId ) ) { evt ⇒ 
 - val newState = commit ( evt ) 
 - 
 - val date = evt . ts 
 - val dateMillis = date . toEpochMilli 
 - val showJoinMessage = newState . adminSettings . showJoinLeaveMessages 
 - val memberIds = newState . memberIds 
 - val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 - val randomId = ACLUtils . randomLong ( ) 
 - 
 - / / If user was never invited to group - he don ' t have group on devices , 
 - / / that means we need to push all group - info related updates 
 - / / 
 - / / If user was invited to group by other member - we don ' t need to push group updates , 
 - / / cause they were pushed already on invite step 
 - / / TODO : unify isHistoryShared usage 
 - val joiningUserUpdatesNew : Vector [ Update ] = { 
 - if ( wasInvited ) { 
 - Vector . empty [ Update ] 
 - } else { 
 - val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 - optDrop + + : refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 - } 
 - } 
 - 
 - / / For groups with not async members we should push : 
 - / / • Diff for members ; 
 - / / • Diff for joining user if he was previously invited ; 
 - / / • Members for joining user if he wasn ' t previously invited . 
 - / / 
 - / / For groups with async members we should push : 
 - / / • UpdateGroupMembersCountChanged for both joining user and members 
 - val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 - if ( newState . isAsyncMembers ) { 
 - val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 - ( u , u ) 
 - } else { 
 - val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) 
 - val diff = UpdateGroupMemberDiff ( 
 - groupId , 
 - addedMembers = joiningMember . toVector , 
 - membersCount = newState . membersCount , 
 - removedUsers = Vector . empty 
 - ) 
 - 
 - if ( wasInvited ) { 
 - ( diff , diff ) 
 - } else { 
 - ( 
 - UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 - diff 
 - ) 
 + val isBlockedFu = checkIsBlocked ( cmd . joiningUserId , state . ownerUserId ) 
 + 
 + onSuccess ( isBlockedFu ) { isBlocked ⇒ 
 + if ( isBlocked ) { 
 + sender ( ) ! Status . Failure ( GroupErrors . UserIsBanned ) 
 + } else { 
 + / / user was invited in group by other group user 
 + val wasInvited = state . isInvited ( cmd . joiningUserId ) 
 + 
 + / / trying to figure out who invited joining user . 
 + / / Descending priority : 
 + / / • inviter defined in ` Join ` command ( when invited via token ) 
 + / / • inviter from members list ( when invited by other user ) 
 + / / • group creator ( safe fallback ) 
 + val optMember = state . members . get ( cmd . joiningUserId ) 
 + val inviterUserId = cmd . invitingUserId 
 + . orElse ( optMember . map ( _ . inviterUserId ) ) 
 + . getOrElse ( state . ownerUserId ) 
 + 
 + persist ( UserJoined ( Instant . now , cmd . joiningUserId , inviterUserId ) ) { evt ⇒ 
 + val newState = commit ( evt ) 
 + 
 + val date = evt . ts 
 + val dateMillis = date . toEpochMilli 
 + val showJoinMessage = newState . adminSettings . showJoinLeaveMessages 
 + val memberIds = newState . memberIds 
 + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 + val randomId = ACLUtils . randomLong ( ) 
 + 
 + / / If user was never invited to group - he don ' t have group on devices , 
 + / / that means we need to push all group - info related updates 
 + / / 
 + / / If user was invited to group by other member - we don ' t need to push group updates , 
 + / / cause they were pushed already on invite step 
 + / / TODO : unify isHistoryShared usage 
 + val joiningUserUpdatesNew : Vector [ Update ] = { 
 + if ( wasInvited ) { 
 + Vector . empty [ Update ] 
 + } else { 
 + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 + optDrop + + : refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 + } 
 } 
 - } 
 
 - / / TODO : not sure how it should be in old API 
 - val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) 
 + / / For groups with not async members we should push : 
 + / / • Diff for members ; 
 + / / • Diff for joining user if he was previously invited ; 
 + / / • Members for joining user if he wasn ' t previously invited . 
 + / / 
 + / / For groups with async members we should push : 
 + / / • UpdateGroupMembersCountChanged for both joining user and members 
 + val ( joiningUpdateNew , membersUpdateNew ) : ( Update , Update ) = 
 + if ( newState . isAsyncMembers ) { 
 + val u = UpdateGroupMembersCountChanged ( groupId , newState . membersCount ) 
 + ( u , u ) 
 + } else { 
 + val joiningMember = apiMembers . find ( _ . userId = = cmd . joiningUserId ) 
 + val diff = UpdateGroupMemberDiff ( 
 + groupId , 
 + addedMembers = joiningMember . toVector , 
 + membersCount = newState . membersCount , 
 + removedUsers = Vector . empty 
 + ) 
 
 - val serviceMessage = GroupServiceMessages . userJoined 
 + if ( wasInvited ) { 
 + ( diff , diff ) 
 + } else { 
 + ( 
 + UpdateGroupMembersUpdated ( groupId , apiMembers ) , 
 + diff 
 + ) 
 + } 
 + } 
 
 - / / TODO : remove deprecated 
 - db . run ( GroupUserRepo . create ( 
 - groupId , 
 - userId = cmd . joiningUserId , 
 - inviterUserId = inviterUserId , 
 - invitedAt = optMember . map ( _ . invitedAt ) . getOrElse ( date ) , 
 - joinedAt = Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , 
 - isAdmin = false 
 - ) : @ silent ) 
 + / / TODO : not sure how it should be in old API 
 + val membersUpdateObsolete = UpdateGroupMembersUpdateObsolete ( groupId , apiMembers ) 
 
 - def joinGROUPUpdates : Future [ SeqStateDate ] = 
 - for { 
 - / / push all group updates to joiningUserId 
 - _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 - } 
 + val serviceMessage = GroupServiceMessages . userJoined 
 
 - / / push updated members list / count / difference to joining user , 
 - / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 - / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + / / TODO : remove deprecated 
 + db . run ( GroupUserRepo . create ( 
 + groupId , 
 userId = cmd . joiningUserId , 
 - authId = cmd . joiningUserAuthId , 
 - update = joiningUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here 
 - deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 + inviterUserId = inviterUserId , 
 + invitedAt = optMember . map ( _ . invitedAt ) . getOrElse ( date ) , 
 + joinedAt = Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , 
 + isAdmin = false 
 + ) : @ silent ) 
 
 - ) 
 + def joinGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push all group updates to joiningUserId 
 + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 + } 
 + 
 + / / push updated members list / count / difference to joining user , 
 + / / make it ` FatSeqUpdate ` if this user invited to group for first time . 
 + / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . joiningUserId , 
 + authId = cmd . joiningUserAuthId , 
 + update = joiningUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here 
 + deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 
 - / / push updated members list / count to all group members except joiningUserId 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - memberIds - cmd . joiningUserId , 
 - membersUpdateNew , 
 - deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 - ) 
 + ) 
 
 - date ← if ( showJoinMessage ) { 
 - dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . joiningUserId , 
 - senderAuthId = cmd . joiningUserAuthId , 
 - randomId = randomId , 
 - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 - ) map ( _ . date ) 
 - } else { 
 - / / write service message only for joining user 
 - / / and push join message 
 + / / push updated members list / count to all group members except joiningUserId 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + memberIds - cmd . joiningUserId , 
 + membersUpdateNew , 
 + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 + ) 
 + 
 + date ← if ( showJoinMessage ) { 
 + dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . joiningUserId , 
 + senderAuthId = cmd . joiningUserAuthId , 
 + randomId = randomId , 
 + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 + ) map ( _ . date ) 
 + } else { 
 + / / write service message only for joining user 
 + / / and push join message 
 + for { 
 + _ ← dialogExt . writeMessageSelf ( 
 + userId = cmd . joiningUserId , 
 + peer = apiGroupPeer , 
 + senderUserId = cmd . joiningUserId , 
 + dateMillis = dateMillis , 
 + randomId = randomId , 
 + serviceMessage 
 + ) 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . joiningUserId , 
 + update = serviceMessageUpdate ( 
 + cmd . joiningUserId , 
 + dateMillis , 
 + randomId , 
 + serviceMessage 
 + ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } yield dateMillis 
 + } 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + def joinCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 - _ ← dialogExt . writeMessageSelf ( 
 + / / push all group updates to joiningUserId 
 + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 + } 
 + 
 + / / push updated members count to joining user 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 - peer = apiGroupPeer , 
 - senderUserId = cmd . joiningUserId , 
 - dateMillis = dateMillis , 
 - randomId = randomId , 
 - serviceMessage 
 + authId = cmd . joiningUserAuthId , 
 + update = joiningUpdateNew , 
 + deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 + ) 
 + 
 + / / push updated members count to all group members except joining user 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + memberIds - cmd . joiningUserId , 
 + membersUpdateNew , 
 + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 + 
 + / / push join message only to joining user 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = cmd . joiningUserId , 
 update = serviceMessageUpdate ( 
 @ @ - 352 , 69 + 403 , 34 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 ) , 
 deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 - } yield dateMillis 
 - } 
 - } yield SeqStateDate ( seq , state , date ) 
 - 
 - def joinCHANNELUpdates : Future [ SeqStateDate ] = 
 - for { 
 - / / push all group updates to joiningUserId 
 - _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 - } 
 - 
 - / / push updated members count to joining user 
 - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 - userId = cmd . joiningUserId , 
 - authId = cmd . joiningUserAuthId , 
 - update = joiningUpdateNew , 
 - deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 - ) 
 - 
 - / / push updated members count to all group members except joining user 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - memberIds - cmd . joiningUserId , 
 - membersUpdateNew , 
 - deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 - ) 
 + _ ← dialogExt . bump ( cmd . joiningUserId , apiGroupPeer . asModel ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 
 - / / push join message only to joining user 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . joiningUserId , 
 - update = serviceMessageUpdate ( 
 - cmd . joiningUserId , 
 - dateMillis , 
 - randomId , 
 - serviceMessage 
 - ) , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - _ ← dialogExt . bump ( cmd . joiningUserId , apiGroupPeer . asModel ) 
 - } yield SeqStateDate ( seq , state , dateMillis ) 
 - 
 - val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 - for { 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / Groups V1 API updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - 
 - / / push update about members to all users , except joining user 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - memberIds - cmd . joiningUserId , 
 - membersUpdateObsolete , 
 - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 - deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " 
 - ) 
 + val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 + for { 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Groups V1 API updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + / / push update about members to all users , except joining user 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + memberIds - cmd . joiningUserId , 
 + membersUpdateObsolete , 
 + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 + deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " 
 + ) 
 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / Groups V2 API updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Groups V2 API updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 + seqStateDate ← if ( newState . groupType . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 
 - } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) 
 + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) 
 
 - result pipeTo sender ( ) 
 + result pipeTo sender ( ) 
 + } 
 + } 
 } 
 } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala 
 index 74d3940 . . e3332b1 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupRpcErrors . scala 
 @ @ - 20 , 10 + 20 , 12 @ @ object GroupRpcErrors { 
 val GroupNotPublic = RpcError ( 400 , " GROUP _ IS _ NOT _ PUBLIC " , " The group is not public . " , false , None ) 
 val CantLeaveGroup = RpcError ( 403 , " CANT _ LEAVE _ GROUP " , " You can ' t leave this group ! " , false , None ) 
 val CantJoinGroup = RpcError ( 403 , " CANT _ JOIN _ GROUP " , " You can ' t join this group ! " , false , None ) 
 + val CantGrantToBot = RpcError ( 400 , " CANT _ GRANT _ TO _ BOT " , " Can ' t grant this permissions to bot " , false , None ) 
 + val UserIsBanned = RpcError ( 403 , " USER _ IS _ BANNED " , " You can ' t join this group . " , false , None ) 
 + 
 val InvalidShortName = RpcError ( 400 , " GROUP _ SHORT _ NAME _ INVALID " , 
 " Invalid group short name . Valid short name should contain from 5 to 32 characters , and may consist of latin characters , numbers and underscores " , false , None ) 
 val ShortNameTaken = RpcError ( 400 , " GROUP _ SHORT _ NAME _ TAKEN " , " This short name already belongs to other user or group , we are sorry ! " , false , None ) 
 val NoPermission = CommonRpcErrors . forbidden ( " You have no permission to execute this action " ) 
 - val CantGrantToBot = RpcError ( 400 , " CANT _ GRANT _ TO _ BOT " , " Can ' t grant this permissions to bot " , false , None ) 
 } 
 / / format : ON 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index d0c9916 . . 8a568a5 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 645 , 6 + 645 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 case GroupErrors . ShortNameTaken ⇒ GroupRpcErrors . ShortNameTaken 
 case GroupErrors . NoPermission ⇒ GroupRpcErrors . NoPermission 
 case GroupErrors . CantLeaveGroup ⇒ GroupRpcErrors . CantLeaveGroup 
 + case GroupErrors . UserIsBanned ⇒ GroupRpcErrors . UserIsBanned 
 } 
 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index e82dbae . . 5433dd0 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 1 , 11 + 1 , 9 @ @ 
 package im . actor . server . dialog 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . util . FastFuture 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } 
 import im . actor . api . rpc . messaging . _ 
 - import im . actor . server . db . DbExtension 
 import im . actor . server . messaging . PushText 
 import im . actor . server . model . Peer 
 import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqUpdatesExtension } 
 @ @ - 54 , 7 + 52 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 . withCensoredText ( censoredPushText ) 
 . withPeer ( peer ) 
 ) , 
 - deliveryId = deliveryId ( peer , randomId ) , 
 + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , 
 deliveryTag = deliveryTag 
 ) 
 } yield ( ) 
 @ @ - 100 , 7 + 98 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 default = Some ( senderUpdate ) , 
 custom = senderAuthId map ( authId ⇒ Map ( authId → senderClientUpdate ) ) getOrElse Map . empty , 
 pushRules = PushRules ( isFat = isFat , excludeAuthIds = senderAuthId . toSeq ) , 
 - deliveryId = deliveryId ( peer , randomId ) , 
 + deliveryId = seqUpdExt . msgDeliveryId ( peer , randomId ) , 
 deliveryTag = deliveryTag 
 ) 
 } 
 @ @ - 134 , 9 + 132 , 6 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 } yield ( ) 
 
 - private def deliveryId ( peer : Peer , randomId : Long ) = 
 - s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " 
 - 
 private def reduceKey ( prefix : String , peer : Peer ) : String = 
 s " $ { prefix } _ $ { peer . ` type ` . value } _ $ { peer . id } " 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 85a5734 . . 6d19375 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import akka . pattern . pipe 
 import im . actor . api . rpc . Update 
 import im . actor . api . rpc . files . ApiAvatar 
 import im . actor . api . rpc . groups . _ 
 + import im . actor . api . rpc . messaging . { ApiMessage , UpdateMessage } 
 import im . actor . api . rpc . users . ApiSex 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . CommonErrors 
 @ @ - 205 , 7 + 206 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / TODO : remove deprecated 
 db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) 
 
 - def inviteGROUPUpdates : Future [ SeqState ] = 
 + def inviteGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push updated members list to inviteeUserId , 
 _ ← seqUpdExt . deliverUserUpdate ( 
 @ @ - 221 , 17 + 222 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 
 / / push updated members list to all group members except inviteeUserId 
 - seqState ← seqUpdExt . broadcastClientUpdate ( 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 userId = cmd . inviterUserId , 
 authId = cmd . inviterAuthId , 
 bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 update = membersUpdateNew , 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - } yield seqState 
 
 - def inviteCHANNELUpdates : Future [ SeqState ] = 
 + / / explicitly send service message 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + cmd . inviterUserId , 
 + cmd . inviterAuthId , 
 + cmd . randomId , 
 + serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + def inviteCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . 
 / / invitee could be admin , if he created this group , and turning back 
 @ @ - 258 , 9 + 268 , 24 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 
 - / / get current SeqState for inviter user 
 - seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) 
 - } yield seqState 
 + / / push service message to invitee 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . inviteeUserId , 
 + authId = 0L , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push service message to inviter and return seqState 
 + SeqState ( seq , state ) ← pushUpdateMessage ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 @ @ - 296 , 18 + 321 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 + seqStateDate ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 
 - / / explicitly send service message 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - cmd . inviterUserId , 
 - cmd . inviterAuthId , 
 - cmd . randomId , 
 - serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 336 , 6 + 352 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val newState = commit ( evt ) 
 
 val date = evt . ts 
 + val dateMillis = date . toEpochMilli 
 val memberIds = newState . memberIds 
 val members = newState . members . values . map ( _ . asStruct ) . toVector 
 val randomId = ACLUtils . randomLong ( ) 
 @ @ - 367 , 7 + 384 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 isAdmin = false 
 ) ) 
 
 - def joinGROUPUpdates : Future [ SeqState ] = 
 + def joinGROUPUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push all group updates to joiningUserId 
 _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 @ @ - 376 , 7 + 393 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / push updated members list to joining user , 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - seqState ← seqUpdExt . deliverClientUpdate ( 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 update = membersUpdateNew , 
 @ @ - 391 , 9 + 408 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 - } yield seqState 
 
 - def joinCHANNELUpdates : Future [ SeqState ] = 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . joiningUserId , 
 + senderAuthId = cmd . joiningUserAuthId , 
 + randomId = randomId , 
 + serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 + ) 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + def joinCHANNELUpdates : Future [ SeqStateDate ] = 
 for { 
 / / push all group updates to joiningUserId 
 _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 @ @ - 403 , 7 + 428 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . 
 / / joining user can be admin , if he created this group , and turning back 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 + SeqState ( seq , state ) ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 @ @ - 421 , 7 + 446 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 - } yield seqState 
 + 
 + / / push service message to joining user and return seqState 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . joiningUserId , 
 + authId = cmd . joiningUserAuthId , 
 + ts = dateMillis , 
 + randomId = randomId , 
 + serviceMessage 
 + ) 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 
 val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 for { 
 @ @ - 441 , 16 + 475 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 + seqStateDate ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . joiningUserId , 
 - senderAuthId = cmd . joiningUserAuthId , 
 - randomId = randomId , 
 - serviceMessage / / no delivery tag . This updated handled this way in Groups V1 
 - ) 
 - } yield ( SeqStateDate ( seq , state , date ) , memberIds . toVector : + inviterUserId , randomId ) 
 + } yield ( seqStateDate , memberIds . toVector : + inviterUserId , randomId ) 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 474 , 11 + 501 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) 
 
 - val leftUserUpdatesNew = List ( 
 - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 - ) 
 + val leftUserUpdatesNew = 
 + if ( state . typ . isChannel ) List ( 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 + ) 
 + else List ( 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 + ) 
 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 
 @ @ - 492 , 6 + 523 , 67 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + val leaveGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all group members 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + state . memberIds - cmd . userId , 
 + membersUpdateNew 
 + ) 
 + 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . userId , 
 + senderAuthId = cmd . authId , 
 + randomId = cmd . randomId , 
 + message = serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + 
 + / / push left user that he is no longer a member 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + 
 + / / push left user updates 
 + / / • with empty group members 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + val leaveCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all ADMINS , except userId ( if he was there ) 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + state . adminIds - cmd . userId , 
 + membersUpdateNew 
 + ) 
 + 
 + / / push service message to left user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + message = serviceMessage 
 + ) 
 + 
 + / / push left user that he is no longer a member 
 + SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . userId , 
 + authId = cmd . authId , 
 + update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 / / read this dialog by user that leaves group . don ' t wait for ack 
 dialogExt . messageRead ( apiGroupPeer , cmd . userId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 @ @ - 512 , 36 + 604 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / push updated members list to all group members 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - state . memberIds - cmd . userId , 
 - membersUpdateNew 
 - ) 
 + seqStateDate ← if ( state . typ . isChannel ) leaveCHANNELUpdates else leaveGROUPUpdates 
 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . userId , 
 - senderAuthId = cmd . authId , 
 - randomId = cmd . randomId , 
 - message = serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 - 
 - / / push left user that he is no longer a member 
 - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 - userId = cmd . userId , 
 - authId = cmd . authId , 
 - update = UpdateGroupMemberChanged ( groupId , isMember = false ) 
 - ) 
 - 
 - / / push left user updates 
 - / / • with empty group members 
 - / / • that he can ' t view and invite members 
 - _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 - } 
 - 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result andThen { case _ ⇒ commit ( evt ) } pipeTo sender ( ) 
 } 
 @ @ - 549 , 7 + 614 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 
 protected def kick ( cmd : Kick ) : Unit = { 
 - if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { 
 + if ( state . typ . isChannel & & ! state . isAdmin ( cmd . kickedUserId ) ) { 
 + sender ( ) ! notAdmin 
 + } else if ( state . nonMember ( cmd . kickerUserId ) | | state . nonMember ( cmd . kickedUserId ) ) { 
 sender ( ) ! notMember 
 } else { 
 persist ( UserKicked ( Instant . now , cmd . kickedUserId , cmd . kickerUserId ) ) { evt ⇒ 
 @ @ - 560 , 12 + 627 , 17 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val updateObsolete = UpdateGroupUserKickObsolete ( groupId , cmd . kickedUserId , cmd . kickerUserId , dateMillis , cmd . randomId ) 
 
 - val kickedUserUpdatesNew : List [ Update ] = List ( 
 - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 - UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 - UpdateGroupMemberChanged ( groupId , isMember = false ) 
 - ) 
 + val kickedUserUpdatesNew : List [ Update ] = 
 + if ( state . typ . isChannel ) List ( 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 + UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 + else List ( 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) , 
 + UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + ) 
 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 
 @ @ - 579 , 6 + 651 , 68 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } yield ( ) 
 ) 
 
 + val kickGROUPUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all group members . Don ' t push to kicked user ! 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , 
 + bcastUserIds = newState . memberIds - cmd . kickerUserId , 
 + update = membersUpdateNew 
 + ) 
 + 
 + SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 + apiGroupPeer , 
 + senderUserId = cmd . kickerUserId , 
 + senderAuthId = cmd . kickerAuthId , 
 + randomId = cmd . randomId , 
 + message = serviceMessage , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + 
 + / / push kicked user updates 
 + / / • with empty group members 
 + / / • that he is no longer a member of group 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , date ) 
 + 
 + val kickCHANNELUpdates : Future [ SeqStateDate ] = 
 + for { 
 + / / push updated members list to all ADMINS . Don ' t push to kicked user ! 
 + SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , 
 + bcastUserIds = newState . adminIds - cmd . kickerUserId , 
 + update = membersUpdateNew 
 + ) 
 + 
 + / / push service message to kicker user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . kickerUserId , 
 + authId = cmd . kickerAuthId , / / ? ? ? what ' s a point ? 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push service message to kicked user 
 + _ ← pushUpdateMessage ( 
 + userId = cmd . kickedUserId , 
 + authId = 0L , 
 + ts = dateMillis , 
 + randomId = cmd . randomId , 
 + serviceMessage 
 + ) 
 + 
 + / / push kicked user updates 
 + _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 + } 
 + } yield SeqStateDate ( seq , state , dateMillis ) 
 + 
 / / read this dialog by kicked user . don ' t wait for ack 
 dialogExt . messageRead ( apiGroupPeer , cmd . kickedUserId , 0L , dateMillis ) 
 val result : Future [ SeqStateDate ] = for { 
 @ @ - 598 , 32 + 732 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / push updated members list to all group members . Don ' t push to kicked user ! 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . kickerUserId , 
 - authId = cmd . kickerAuthId , 
 - bcastUserIds = newState . memberIds - cmd . kickerUserId , 
 - update = membersUpdateNew 
 - ) 
 - 
 - SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 - apiGroupPeer , 
 - senderUserId = cmd . kickerUserId , 
 - senderAuthId = cmd . kickerAuthId , 
 - randomId = cmd . randomId , 
 - message = serviceMessage , 
 - deliveryTag = Some ( Optimization . GroupV2 ) 
 - ) 
 + seqStateDate ← if ( state . typ . isChannel ) kickCHANNELUpdates else kickGROUPUpdates 
 
 - / / push kicked user updates 
 - / / • with empty group members 
 - / / • that he is no longer a member of group 
 - / / • that he can ' t view and invite members 
 - _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 - } 
 - 
 - } yield SeqStateDate ( seq , state , date ) 
 + } yield seqStateDate 
 
 result pipeTo sender ( ) 
 } 
 @ @ - 987 , 6 + 1098 , 26 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 + / / и л и в с е т а к и б у д е т broadcast ? 
 + private def pushUpdateMessage ( userId : Int , authId : Long , ts : Long , randomId : Long , message : ApiMessage ) : Future [ SeqState ] = { 
 + val messUpdate = UpdateMessage ( 
 + peer = apiGroupPeer , 
 + senderUserId = userId , 
 + date = ts , 
 + randomId = randomId , 
 + message = message , 
 + attributes = None , 
 + quotedMessage = None 
 + ) 
 + seqUpdExt . deliverClientUpdate ( 
 + userId = userId , 
 + authId = authId , 
 + update = messUpdate , 
 + deliveryId = seqUpdExt . msgDeliveryId ( apiGroupPeer . asModel , randomId ) , 
 + deliveryTag = Some ( Optimization . GroupV2 ) 
 + ) 
 + } 
 + 
 private def trimToEmpty ( s : Option [ String ] ) : Option [ String ] = 
 s map ( _ . trim ) filter ( _ . nonEmpty ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index 9f0b5ed . . ee7837b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 63 , 6 + 63 , 9 @ @ final class SeqUpdatesExtension ( _ system : ActorSystem ) 
 optTs . getOrElse ( throw new RuntimeException ( s " No Migration timestamp found for $ { MigrationNameList . MultiSequence } " ) ) 
 } 
 
 + def msgDeliveryId ( peer : Peer , randomId : Long ) = 
 + s " msg _ $ { peer . ` type ` . value } _ $ { peer . id } _ $ { randomId } " 
 + 
 def getSeqState ( userId : Int , authId : Long ) : Future [ SeqState ] = 
 ( region . ref ? Envelope ( userId ) . withGetSeqState ( GetSeqState ( authId ) ) ) . mapTo [ SeqState ] 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 index 62a149c . . 80a199b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / operations / DeliveryOperations . scala 
 @ @ - 21 , 12 + 21 , 13 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 * Send update to all devices of user and return ` SeqState ` associated with ` authId ` 
 * / 
 def deliverClientUpdate ( 
 - userId : Int , 
 - authId : Long , 
 - update : Update , 
 - pushRules : PushRules = PushRules ( ) , 
 - reduceKey : Option [ String ] = None , 
 - deliveryId : String = " " 
 + userId : Int , 
 + authId : Long , 
 + update : Update , 
 + pushRules : PushRules = PushRules ( ) , 
 + reduceKey : Option [ String ] = None , 
 + deliveryId : String = " " , 
 + deliveryTag : Option [ String ] = None 
 ) : Future [ SeqState ] = 
 deliverUpdate ( 
 userId , 
 @ @ - 34 , 7 + 35 , 8 @ @ trait DeliveryOperations { this : SeqUpdatesExtension ⇒ 
 UpdateMapping ( default = Some ( serializedUpdate ( update ) ) ) , 
 pushRules , 
 reduceKey , 
 - deliveryId 
 + deliveryId , 
 + deliveryTag 
 ) 
 
 / * * 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 59786e3 . . f35f67f 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm 
 import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging 
 import com . typesafe . sbt . packager . debian . JDebPackaging 
 
 - object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { 
 + object Build extends sbt . Build with Versioning with Releasing with Packaging { 
 val ScalaVersion = " 2 . 11 . 8 " 
 val BotKitVersion = getVersion 
 
 @ @ - 89 , 7 + 89 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging wit 
 " actor " , 
 file ( " . " ) , 
 settings = 
 - startUpSettings + + 
 packagingSettings + + 
 defaultSettingsServer + + 
 Revolver . settings + + 
 diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala 
 deleted file mode 100644 
 index 62ca90f . . 0000000 
 - - - a / actor - server / project / StartHook . scala 
 + + + / dev / null 
 @ @ - 1 , 15 + 0 , 0 @ @ 
 - package im . actor 
 - 
 - import sbt . Keys . _ 
 - import sbt . _ 
 - 
 - private [ actor ] trait StartHook { 
 - lazy val startUpSettings = Seq ( 
 - onLoad in Global : = { state = > 
 - 
 - println ( " = = = = = = = = = = = = = = hello world " ) 
 - state 
 - } 
 - ) 
 - 
 - }
