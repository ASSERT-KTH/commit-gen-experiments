BLEU SCORE: 0.0711586419732111

TEST MSG: doc ( core ) : Documented promises
GENERATED MSG: wip ( * ) : Big project refactoring : Android run successful

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index ef5a670 . . 809775a 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 224 , 7 + 224 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return Promises . success ( pickedChain ) < nl > . mapPromise ( src - > { < nl > if ( src ! = null ) { < nl > - return Promises . successNotNull ( src ) ; < nl > + return Promises . success ( src ) ; < nl > } < nl > < nl > return ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new FetchEphemeralPrivateKey ( ephemeralKey ) ) < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java < nl > index 7984bcc . . 20545d9 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java < nl > @ @ - 36 , 17 + 36 , 11 @ @ public class KeyManagerInt extends ActorInterface { < nl > @ Override < nl > public Promise < byte [ ] > map ( byte [ ] src ) { < nl > if ( src ! = null ) { < nl > - Log . d ( " getEphemeralKey " , " stored " ) ; < nl > - return Promises . successNotNull ( src ) ; < nl > + return Promises . success ( src ) ; < nl > } < nl > < nl > return getUserRandomPreKey ( uid , keyGroupId ) < nl > - . map ( src1 - > src1 . getEphemeralKey ( ) . getPublicKey ( ) ) . then ( new Consumer < byte [ ] > ( ) { < nl > - @ Override < nl > - public void apply ( byte [ ] bytes ) { < nl > - Log . d ( " getEphemeralKey " , " loaded : " + bytes ) ; < nl > - } < nl > - } ) ; < nl > + . map ( src1 - > src1 . getEphemeralKey ( ) . getPublicKey ( ) ) ; < nl > } < nl > } ) ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > index 90c0fea . . a9ba04a 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java < nl > @ @ - 18 , 10 + 18 , 18 @ @ import im . actor . runtime . function . Map ; < nl > * / < nl > public class Promise < T > { < nl > < nl > + / / < nl > + / / Dispatching parameters < nl > + / / < nl > + < nl > private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; < nl > private final PromiseFunc < T > executor ; < nl > - < nl > private ActorRef dispatchActor ; < nl > + < nl > + / / < nl > + / / State of Promise < nl > + / / < nl > + < nl > private volatile T result ; < nl > private volatile Exception exception ; < nl > private volatile boolean isFinished ; < nl > @ @ - 34 , 6 + 42 , 9 @ @ public class Promise < T > { < nl > this . executor = executor ; < nl > } < nl > < nl > + / * * < nl > + * Internal constructor to work - around lambda support issueses < nl > + * / < nl > Promise ( ) { < nl > this . executor = null ; < nl > } < nl > @ @ - 152 , 64 + 163 , 83 @ @ public class Promise < T > { < nl > < nl > / * * < nl > * Call this method to start promise execution < nl > + * < nl > + * @ param ref Scheduling actor < nl > * / < nl > public Promise < T > done ( ActorRef ref ) { < nl > - Log . d ( " PromisesArray " , " done " + this + " ( " + ref . getPath ( ) + " ) " ) ; < nl > if ( isStarted ) { < nl > - throw new RuntimeException ( " Promise already started " ) ; < nl > + throw new RuntimeException ( " Promise already started ! " ) ; < nl > } < nl > isStarted = true ; < nl > dispatchActor = ref ; < nl > dispatchActor . send ( new PromiseDispatch ( this ) { < nl > @ Override < nl > public void run ( ) { < nl > - exec ( new PromiseResolver < T > ( Promise . this ) ) ; < nl > + exec ( new PromiseResolver < T > ( Promise . this , dispatchActor ) ) ; < nl > } < nl > } ) ; < nl > return this ; < nl > } < nl > < nl > + / * * < nl > + * Main execution method < nl > + * < nl > + * @ param resolver resolver < nl > + * / < nl > void exec ( PromiseResolver < T > resolver ) { < nl > executor . exec ( resolver ) ; < nl > } < nl > < nl > - public boolean isStarted ( ) { < nl > - return isStarted ; < nl > - } < nl > - < nl > + / * * < nl > + * Cast promise to different type < nl > + * < nl > + * @ param < R > destination type < nl > + * @ return casted promise < nl > + * / < nl > public < R > Promise < R > cast ( ) { < nl > return ( Promise < R > ) this ; < nl > } < nl > < nl > - public ActorRef getDispatchActor ( ) { < nl > - return dispatchActor ; < nl > + / * * < nl > + * Getting result if finished < nl > + * < nl > + * @ return result < nl > + * / < nl > + public T getResult ( ) { < nl > + if ( ! isFinished ) { < nl > + throw new RuntimeException ( " Promise is not finished ! " ) ; < nl > + } < nl > + return result ; < nl > } < nl > < nl > - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { < nl > - / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; < nl > - / / } < nl > - < nl > - / / / * * < nl > - / / * Getting current dispatcher for promise < nl > - / / * < nl > - / / * @ return current dispatcher < nl > - / / * / < nl > - / / public PromiseDispatcher getDispatcher ( ) { < nl > - / / return dispatcher ; < nl > - / / } < nl > - < nl > + / * * < nl > + * Is promise finished < nl > + * < nl > + * @ return result < nl > + * / < nl > public boolean isFinished ( ) { < nl > return isFinished ; < nl > } < nl > < nl > + / * * < nl > + * Exception if promise finished with error < nl > + * < nl > + * @ return exception < nl > + * / < nl > public Exception getException ( ) { < nl > + if ( ! isFinished ) { < nl > + throw new RuntimeException ( " Promise is not finished ! " ) ; < nl > + } < nl > return exception ; < nl > } < nl > < nl > - public T getResult ( ) { < nl > - return result ; < nl > - } < nl > - < nl > + / * * < nl > + * Mapping result value of promise to another value < nl > + * < nl > + * @ param res mapping function < nl > + * @ param < R > destination type < nl > + * @ return promise < nl > + * / < nl > public < R > Promise < R > map ( Map < T , R > res ) { < nl > final Promise < T > self = this ; < nl > return new Promise < R > ( ) { < nl > @ @ - 238 , 22 + 268 , 15 @ @ public class Promise < T > { < nl > self . done ( resolver . getDispatcher ( ) ) ; < nl > } < nl > } ; < nl > - / / return new Promise < > ( executor1 - > { < nl > - / / self . then ( t - > { < nl > - / / R r ; < nl > - / / try { < nl > - / / r = res . map ( t ) ; < nl > - / / } catch ( Exception e ) { < nl > - / / executor1 . tryError ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / executor1 . tryResult ( r ) ; < nl > - / / } ) ; < nl > - / / self . failure ( e - > executor1 . error ( e ) ) ; < nl > - / / self . done ( executor1 . getDispatcher ( ) ) ; < nl > - / / } ) ; < nl > } < nl > < nl > + / * * < nl > + * Map result of promise to promise of value < nl > + * < nl > + * @ param res mapping function < nl > + * @ param < R > destination type < nl > + * @ return promise < nl > + * / < nl > public < R > Promise < R > mapPromise ( Map < T , Promise < R > > res ) { < nl > final Promise < T > self = this ; < nl > return new Promise < R > ( ) { < nl > @ @ - 301 , 33 + 324 , 24 @ @ public class Promise < T > { < nl > * Delivering result < nl > * / < nl > private void deliverResult ( ) { < nl > - Log . d ( " Promise " , " result : 4 " ) ; < nl > if ( callbacks . size ( ) > 0 ) { < nl > - Log . d ( " Promise " , " result : 5 " ) ; < nl > dispatchActor . send ( new PromiseDispatch ( this ) { < nl > @ Override < nl > public void run ( ) { < nl > - Log . d ( " Promise " , " result : 6 " ) ; < nl > if ( exception ! = null ) { < nl > - Log . d ( " Promise " , " result : 7 " ) ; < nl > for ( PromiseCallback < T > callback : callbacks ) { < nl > try { < nl > - Log . d ( " Promise " , " result : callback : " + callback ) ; < nl > callback . onError ( exception ) ; < nl > } catch ( Exception e ) { < nl > e . printStackTrace ( ) ; < nl > - Log . d ( " Promise " , " result : callback _ error " ) ; < nl > } < nl > } < nl > } else { < nl > - Log . d ( " Promise " , " result : 8 " ) ; < nl > for ( PromiseCallback < T > callback : callbacks ) { < nl > try { < nl > - Log . d ( " Promise " , " result : callback : " + callback ) ; < nl > callback . onResult ( result ) ; < nl > } catch ( Exception e ) { < nl > e . printStackTrace ( ) ; < nl > - Log . d ( " Promise " , " result : callback _ error2 " ) ; < nl > } < nl > } < nl > } < nl > @ @ - 377 , 9 + 391 , 7 @ @ public class Promise < T > { < nl > } < nl > isFinished = true ; < nl > result = res ; < nl > - Log . d ( " Promise " , " result : 1 " ) ; < nl > deliverResult ( ) ; < nl > - Log . d ( " Promise " , " result : 2 " ) ; < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java < nl > index 0ccc1e7 . . 95683ef 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java < nl > @ @ - 1 , 5 + 1 , 8 @ @ < nl > package im . actor . runtime . promise ; < nl > < nl > + / * * < nl > + * Actor message that is used in Actor scheduling < nl > + * / < nl > public abstract class PromiseDispatch implements Runnable { < nl > < nl > private Promise promise ; < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java < nl > deleted file mode 100644 < nl > index 97c7174 . . 0000000 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java < nl > + + + / dev / null < nl > @ @ - 1 , 24 + 0 , 0 @ @ < nl > - package im . actor . runtime . promise ; < nl > - < nl > - import im . actor . runtime . actors . ActorRef ; < nl > - < nl > - public abstract class PromiseDispatcher { < nl > - < nl > - public abstract void dispatch ( Runnable runnable ) ; < nl > - < nl > - public static PromiseDispatcher DEFAULT = new PromiseDispatcher ( ) { < nl > - @ Override < nl > - public void dispatch ( Runnable runnable ) { < nl > - im . actor . runtime . Runtime . dispatch ( runnable ) ; < nl > - } < nl > - } ; < nl > - < nl > - public static PromiseDispatcher forActor ( final ActorRef ref ) { < nl > - return new PromiseDispatcher ( ) { < nl > - @ Override < nl > - public void dispatch ( Runnable runnable ) { < nl > - ref . send ( runnable ) ; < nl > - } < nl > - } ; < nl > - } < nl > - } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java < nl > index d7965fc . . 6c717db 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java < nl > @ @ - 1 , 5 + 1 , 11 @ @ < nl > package im . actor . runtime . promise ; < nl > < nl > + / * * < nl > + * Method that evaluate result of a promise < nl > + * < nl > + * @ param < T > result type < nl > + * / < nl > public interface PromiseFunc < T > { < nl > + < nl > void exec ( PromiseResolver < T > executor ) ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java < nl > index e910811 . . f672f8d 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java < nl > @ @ - 9 , 14 + 9 , 16 @ @ import im . actor . runtime . actors . ActorRef ; < nl > / * * < nl > * Object for completing promises < nl > * < nl > - * @ param < T > < nl > + * @ param < T > type of resolver < nl > * / < nl > public class PromiseResolver < T > { < nl > < nl > private Promise < T > promise ; < nl > + private ActorRef dispatcher ; < nl > < nl > - PromiseResolver ( Promise < T > promise ) { < nl > + PromiseResolver ( Promise < T > promise , ActorRef dispatcher ) { < nl > this . promise = promise ; < nl > + this . dispatcher = dispatcher ; < nl > } < nl > < nl > / * * < nl > @ @ - 28 , 8 + 30 , 13 @ @ public class PromiseResolver < T > { < nl > return promise ; < nl > } < nl > < nl > + / * * < nl > + * Get Resolver ' s dispatcher < nl > + * < nl > + * @ return dispatcher actor < nl > + * / < nl > public ActorRef getDispatcher ( ) { < nl > - return promise . getDispatchActor ( ) ; < nl > + return dispatcher ; < nl > } < nl > < nl > / * * < nl > @ @ - 38 , 7 + 45 , 6 @ @ public class PromiseResolver < T > { < nl > * @ param res result of promise < nl > * / < nl > public void result ( @ Nullable T res ) { < nl > - Log . d ( " Promise " , " Result : " + promise ) ; < nl > promise . result ( res ) ; < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > index da44841 . . d9bac86 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java < nl > @ @ - 1 , 270 + 1 , 112 @ @ < nl > package im . actor . runtime . promise ; < nl > < nl > - import org . jetbrains . annotations . NotNull ; < nl > - < nl > - import java . util . ArrayList ; < nl > - import java . util . Collection ; < nl > - < nl > - import im . actor . runtime . Log ; < nl > - import im . actor . runtime . function . ArrayFunction ; < nl > import im . actor . runtime . function . Map ; < nl > - import im . actor . runtime . function . Consumer ; < nl > < nl > + / * * < nl > + * Various methods for creating promises . < nl > + * / < nl > public class Promises { < nl > < nl > + / * * < nl > + * Always success promise < nl > + * < nl > + * @ param val success value < nl > + * @ param < T > type of value < nl > + * @ return promise < nl > + * / < nl > public static < T > Promise < T > success ( final T val ) { < nl > return new Promise < T > ( ) { < nl > @ Override < nl > void exec ( PromiseResolver resolver ) { < nl > - Log . d ( " Promises " , " success : " + val ) ; < nl > resolver . result ( val ) ; < nl > } < nl > } ; < nl > } < nl > < nl > - public static < T > Promise < T > successNotNull ( final T val ) { < nl > - if ( val = = null ) { < nl > - throw new RuntimeException ( " Val can ' t be null " ) ; < nl > - } < nl > - return success ( val ) ; < nl > + / * * < nl > + * Always failed promise < nl > + * < nl > + * @ param e fail reason < nl > + * @ param < T > type of promise < nl > + * @ return promise < nl > + * / < nl > + public static < T > Promise < T > failure ( final Exception e ) { < nl > + return new Promise < T > ( ) { < nl > + @ Override < nl > + void exec ( PromiseResolver < T > resolver ) { < nl > + resolver . error ( e ) ; < nl > + } < nl > + } ; < nl > } < nl > < nl > + / * * < nl > + * Combines two promises to one with different data types < nl > + * < nl > + * @ param t1 first argument < nl > + * @ param t2 second argument < nl > + * @ param < T1 > first argument type < nl > + * @ param < T2 > second argument type < nl > + * @ return promise < nl > + * / < nl > public static < T1 , T2 > Promise < Tuple2 < T1 , T2 > > tuple ( Promise < T1 > t1 , Promise < T2 > t2 ) { < nl > - return new Promise < Tuple2 < T1 , T2 > > ( ) { < nl > - @ Override < nl > - void exec ( PromiseResolver resolver ) { < nl > - final Object [ ] res = new Object [ 2 ] ; < nl > - final boolean [ ] ended = new boolean [ 2 ] ; < nl > - < nl > - t1 . then ( t11 - > { < nl > - ended [ 0 ] = true ; < nl > - res [ 0 ] = t11 ; < nl > < nl > - if ( ended [ 0 ] & & ended [ 1 ] ) { < nl > - resolver . result ( new Tuple2 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] ) ) ; < nl > + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) ) < nl > + . zip ( ) < nl > + . map ( new Map < Object [ ] , Tuple2 < T1 , T2 > > ( ) { < nl > + @ Override < nl > + public Tuple2 < T1 , T2 > map ( Object [ ] src ) { < nl > + return new Tuple2 < T1 , T2 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] ) ; < nl > } < nl > } ) ; < nl > - t1 . failure ( e - > resolver . error ( e ) ) ; < nl > - < nl > - t2 . then ( t11 - > { < nl > - ended [ 1 ] = true ; < nl > - res [ 1 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] ) { < nl > - resolver . result ( new Tuple2 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t2 . failure ( e - > resolver . error ( e ) ) ; < nl > - t1 . done ( resolver . getDispatcher ( ) ) ; < nl > - t2 . done ( resolver . getDispatcher ( ) ) ; < nl > - } < nl > - } ; < nl > } < nl > < nl > + / * * < nl > + * Combines tree promises to one with different data types < nl > + * < nl > + * @ param t1 first argument < nl > + * @ param t2 second argument < nl > + * @ param t3 third argument < nl > + * @ param < T1 > first argument type < nl > + * @ param < T2 > second argument type < nl > + * @ param < T3 > third argument type < nl > + * @ return promise < nl > + * / < nl > public static < T1 , T2 , T3 > Promise < Tuple3 < T1 , T2 , T3 > > tuple ( Promise < T1 > t1 , Promise < T2 > t2 , Promise < T3 > t3 ) { < nl > - return new Promise < > ( executor - > { < nl > - final Object [ ] res = new Object [ 3 ] ; < nl > - final boolean [ ] ended = new boolean [ 3 ] ; < nl > - < nl > - t1 . then ( t11 - > { < nl > - ended [ 0 ] = true ; < nl > - res [ 0 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { < nl > - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t1 . failure ( e - > executor . error ( e ) ) ; < nl > - t1 . done ( executor . getDispatcher ( ) ) ; < nl > - < nl > - t2 . then ( t11 - > { < nl > - ended [ 1 ] = true ; < nl > - res [ 1 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { < nl > - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t2 . failure ( e - > executor . error ( e ) ) ; < nl > - t2 . done ( executor . getDispatcher ( ) ) ; < nl > - < nl > - t3 . then ( t11 - > { < nl > - ended [ 2 ] = true ; < nl > - res [ 2 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { < nl > - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t3 . failure ( e - > executor . error ( e ) ) ; < nl > - t3 . done ( executor . getDispatcher ( ) ) ; < nl > - } ) ; < nl > + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) , t3 . cast ( ) ) < nl > + . zip ( ) < nl > + . map ( new Map < Object [ ] , Tuple3 < T1 , T2 , T3 > > ( ) { < nl > + @ Override < nl > + public Tuple3 < T1 , T2 , T3 > map ( Object [ ] src ) { < nl > + return new Tuple3 < T1 , T2 , T3 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] , ( T3 ) src [ 2 ] ) ; < nl > + } < nl > + } ) ; < nl > } < nl > < nl > + / * * < nl > + * Combines four promises to one with different data types < nl > + * < nl > + * @ param t1 first argument < nl > + * @ param t2 second argument < nl > + * @ param t3 third argument < nl > + * @ param t4 fourth argument < nl > + * @ param < T1 > first argument type < nl > + * @ param < T2 > second argument type < nl > + * @ param < T3 > third argument type < nl > + * @ param < T4 > fourth argument type < nl > + * @ return promise < nl > + * / < nl > public static < T1 , T2 , T3 , T4 > Promise < Tuple4 < T1 , T2 , T3 , T4 > > tuple ( Promise < T1 > t1 , < nl > Promise < T2 > t2 , < nl > Promise < T3 > t3 , < nl > Promise < T4 > t4 ) { < nl > - return new Promise < > ( executor - > { < nl > - final Object [ ] res = new Object [ 4 ] ; < nl > - final boolean [ ] ended = new boolean [ 4 ] ; < nl > - < nl > - t1 . then ( t11 - > { < nl > - ended [ 0 ] = true ; < nl > - res [ 0 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { < nl > - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , < nl > - ( T4 ) res [ 3 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t1 . failure ( e - > executor . error ( e ) ) ; < nl > - t1 . done ( executor . getDispatcher ( ) ) ; < nl > - < nl > - t2 . then ( t11 - > { < nl > - ended [ 1 ] = true ; < nl > - res [ 1 ] = t11 ; < nl > < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { < nl > - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , < nl > - ( T4 ) res [ 3 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t2 . failure ( e - > executor . error ( e ) ) ; < nl > - t2 . done ( executor . getDispatcher ( ) ) ; < nl > - < nl > - t3 . then ( t11 - > { < nl > - ended [ 2 ] = true ; < nl > - res [ 2 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { < nl > - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , < nl > - ( T4 ) res [ 3 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t3 . failure ( e - > executor . error ( e ) ) ; < nl > - t3 . done ( executor . getDispatcher ( ) ) ; < nl > - < nl > - < nl > - t4 . then ( t11 - > { < nl > - ended [ 3 ] = true ; < nl > - res [ 3 ] = t11 ; < nl > - < nl > - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { < nl > - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , < nl > - ( T4 ) res [ 3 ] ) ) ; < nl > - } < nl > - } ) ; < nl > - t4 . failure ( e - > executor . error ( e ) ) ; < nl > - t4 . done ( executor . getDispatcher ( ) ) ; < nl > - } ) ; < nl > + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) , t3 . cast ( ) , t4 . cast ( ) ) < nl > + . zip ( ) < nl > + . map ( new Map < Object [ ] , Tuple4 < T1 , T2 , T3 , T4 > > ( ) { < nl > + @ Override < nl > + public Tuple4 < T1 , T2 , T3 , T4 > map ( Object [ ] src ) { < nl > + return new Tuple4 < T1 , T2 , T3 , T4 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] , ( T3 ) src [ 2 ] , ( T4 ) src [ 3 ] ) ; < nl > + } < nl > + } ) ; < nl > } < nl > - < nl > - / / / * * < nl > - / / * Zip promise of array to single object < nl > - / / * < nl > - / / * @ param zip zip method < nl > - / / * @ param promises promises to zip < nl > - / / * @ param < T > array element types < nl > - / / * @ param < R > result element types < nl > - / / * @ return updated promise < nl > - / / * / < nl > - / / public static < T , R > Promise < R > zip ( final Promise < T [ ] > promises , final ArrayFunction < T , R > zip ) { < nl > - / / return new Promise < R > ( ) { < nl > - / / @ Override < nl > - / / protected void exec ( @ NotNull final PromiseResolver < R > executor ) { < nl > - / / promises . complete ( new PromiseCallback < T [ ] > ( ) { < nl > - / / @ Override < nl > - / / public void onResult ( T [ ] ts ) { < nl > - / / R res ; < nl > - / / try { < nl > - / / res = zip . apply ( ts ) ; < nl > - / / } catch ( Exception e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - / / executor . error ( e ) ; < nl > - / / return ; < nl > - / / } < nl > - / / executor . result ( res ) ; < nl > - / / } < nl > - / / < nl > - / / @ Override < nl > - / / public void onError ( Exception e ) { < nl > - / / executor . error ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / promises . done ( promises . getDispatchActor ( ) ) ; < nl > - / / } < nl > - / / } ; < nl > - / / } < nl > - / / < nl > - / / / * * < nl > - / / * Combining sequence of promises to one single promise < nl > - / / * < nl > - / / * @ param promises source promises < nl > - / / * @ param < T > type of arguments < nl > - / / * @ return result promise < nl > - / / * / < nl > - / / @ SafeVarargs < nl > - / / public static < T > Promise < T [ ] > sequence ( final Promise < T > . . . promises ) { < nl > - / / if ( promises . length = = 0 ) { < nl > - / / throw new RuntimeException ( " Promises array must not be empty " ) ; < nl > - / / } < nl > - / / return new Promise < T [ ] > ( ) { < nl > - / / @ Override < nl > - / / protected void exec ( @ NotNull final PromiseResolver < T [ ] > executor ) { < nl > - / / final T [ ] res = ( T [ ] ) new Object [ promises . length ] ; < nl > - / / final boolean [ ] isSet = new boolean [ promises . length ] ; < nl > - / / final Promise self = this ; < nl > - / / for ( int i = 0 ; i < res . length ; i + + ) { < nl > - / / final int finalI = i ; < nl > - / / promises [ i ] . then ( new Consumer < T > ( ) { < nl > - / / @ Override < nl > - / / public void apply ( T t ) { < nl > - / / if ( self . isFinished ( ) ) { < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / res [ finalI ] = t ; < nl > - / / isSet [ finalI ] = true ; < nl > - / / for ( int i = 0 ; i < promises . length ; i + + ) { < nl > - / / if ( ! isSet [ i ] ) { < nl > - / / return ; < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / executor . result ( res ) ; < nl > - / / } < nl > - / / } ) . failure ( new Consumer < Exception > ( ) { < nl > - / / @ Override < nl > - / / public void apply ( Exception e ) { < nl > - / / if ( self . isFinished ( ) ) { < nl > - / / return ; < nl > - / / } < nl > - / / < nl > - / / executor . error ( e ) ; < nl > - / / } < nl > - / / } ) ; < nl > - / / } < nl > - / / for ( Promise < T > p : promises ) { < nl > - / / p . done ( self . getDispatchActor ( ) ) ; < nl > - / / } < nl > - / / } < nl > - / / } ; < nl > - / / } < nl > - / / < nl > - / / public static < T , C > Promise < T > [ ] map ( Collection < C > items , Map < C , Promise < T > > map ) { < nl > - / / ArrayList < Promise < T > > res = new ArrayList < Promise < T > > ( ) ; < nl > - / / for ( C c : items ) { < nl > - / / res . add ( map . map ( c ) ) ; < nl > - / / } < nl > - / / return res . toArray ( new Promise [ 0 ] ) ; < nl > - / / } < nl > - / / < nl > - / / public static < T , C > Promise < T > [ ] map ( C [ ] items , Map < C , Promise < T > > map ) { < nl > - / / ArrayList < Promise < T > > res = new ArrayList < Promise < T > > ( ) ; < nl > - / / for ( C c : items ) { < nl > - / / res . add ( map . map ( c ) ) ; < nl > - / / } < nl > - / / return res . toArray ( new Promise [ 0 ] ) ; < nl > - / / } < nl > } < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java < nl > index 904e866 . . a1253d4 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java < nl > @ @ - 1 , 16 + 1 , 74 @ @ < nl > package im . actor . runtime . promise ; < nl > < nl > import java . util . ArrayList ; < nl > + import java . util . Collection ; < nl > import java . util . Collections ; < nl > - import java . util . List ; < nl > < nl > - import im . actor . runtime . Log ; < nl > import im . actor . runtime . function . ArrayFunction ; < nl > import im . actor . runtime . function . Consumer ; < nl > import im . actor . runtime . function . Function ; < nl > < nl > + / * * < nl > + * Array of Promises . Allows you to invoke map , mapPromise and other useful methods < nl > + * for manipulating data . < nl > + * < nl > + * @ param < T > type of array < nl > + * / < nl > public class PromisesArray < T > { < nl > < nl > + / * * < nl > + * Create PromisesArray from collection < nl > + * < nl > + * @ param collection Source collection < nl > + * @ param < T > type of array < nl > + * @ return array < nl > + * / < nl > + public static < T > PromisesArray < T > of ( Collection < T > collection ) { < nl > + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > + for ( T t : collection ) { < nl > + res . add ( Promises . success ( t ) ) ; < nl > + } < nl > + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > + } < nl > + < nl > + / * * < nl > + * Create PromisesArray from values < nl > + * < nl > + * @ param items elements < nl > + * @ param < T > type of array < nl > + * @ return array < nl > + * / < nl > + @ SafeVarargs < nl > + public static < T > PromisesArray < T > of ( T . . . items ) { < nl > + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > + for ( T t : items ) { < nl > + res . add ( Promises . success ( t ) ) ; < nl > + } < nl > + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > + } < nl > + < nl > + / * * < nl > + * Create PromisesArray from multiple Promise < nl > + * < nl > + * @ param items promises < nl > + * @ param < T > type of array < nl > + * @ return array < nl > + * / < nl > + @ SafeVarargs < nl > + public static < T > PromisesArray < T > ofPromises ( Promise < T > . . . items ) { < nl > + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > + Collections . addAll ( res , items ) ; < nl > + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > + } < nl > + < nl > + < nl > + / / < nl > + / / Constructors and methods < nl > + / / < nl > + < nl > private Promise < Promise < T > [ ] > promises ; < nl > < nl > private PromisesArray ( Promise < Promise < T > [ ] > promises ) { < nl > @ @ - 21 , 58 + 79 , 119 @ @ public class PromisesArray < T > { < nl > this ( new Promise < > ( executor ) ) ; < nl > } < nl > < nl > + / * * < nl > + * Map promises results to new promises < nl > + * < nl > + * @ param fun mapping function < nl > + * @ param < R > type of result promises < nl > + * @ return PromisesArray < nl > + * / < nl > public < R > PromisesArray < R > map ( Function < T , Promise < R > > fun ) { < nl > return new PromisesArray < > ( executor - > { < nl > + < nl > + / / < nl > + / / Handling source results < nl > + / / < nl > + < nl > promises . then ( sourcePromises - > { < nl > - Log . d ( " PromisesArray " , " 1 " ) ; < nl > - / / Starting source promises < nl > - for ( int i = 0 ; i < sourcePromises . length ; i + + ) { < nl > - sourcePromises [ i ] . done ( executor . getDispatcher ( ) ) ; < nl > - } < nl > + < nl > + / / < nl > / / Building mapped promises < nl > + / / < nl > + < nl > final Promise < R > [ ] mappedPromises = new Promise [ sourcePromises . length ] ; < nl > + < nl > for ( int i = 0 ; i < mappedPromises . length ; i + + ) { < nl > final int finalI = i ; < nl > final Function < T , Promise < R > > fun2 = fun ; < nl > + < nl > mappedPromises [ finalI ] = new Promise < R > ( ) { < nl > @ Override < nl > void exec ( PromiseResolver < R > resolver ) { < nl > + < nl > + / / < nl > + / / Handling results from source PromisesArray < nl > + / / < nl > + < nl > sourcePromises [ finalI ] . then ( new Consumer < T > ( ) { < nl > @ Override < nl > public void apply ( T t ) { < nl > - fun2 . apply ( t ) < nl > - . then ( new Consumer < R > ( ) { < nl > - @ Override < nl > - public void apply ( R r ) { < nl > - resolver . result ( r ) ; < nl > - } < nl > - } ) < nl > - . failure ( new Consumer < Exception > ( ) { < nl > - @ Override < nl > - public void apply ( Exception e ) { < nl > - resolver . error ( e ) ; < nl > - } < nl > - } ) . done ( resolver . getDispatcher ( ) ) ; < nl > - ; < nl > + < nl > + / / < nl > + / / Mapping value to promise < nl > + / / < nl > + Promise < R > mapped = fun2 . apply ( t ) ; < nl > + < nl > + / / < nl > + / / Handling results < nl > + / / < nl > + mapped . then ( new Consumer < R > ( ) { < nl > + @ Override < nl > + public void apply ( R r ) { < nl > + resolver . result ( r ) ; < nl > + } < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + resolver . error ( e ) ; < nl > + } < nl > + } ) . done ( resolver . getDispatcher ( ) ) ; < nl > } < nl > } ) ; < nl > - sourcePromises [ finalI ] . failure ( e - > { < nl > - resolver . error ( e ) ; < nl > + < nl > + / / < nl > + / / Handling failures < nl > + / / < nl > + < nl > + sourcePromises [ finalI ] . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + resolver . error ( e ) ; < nl > + } < nl > } ) ; < nl > + < nl > + / / < nl > + / / Starting source promise < nl > + / / < nl > + < nl > + sourcePromises [ finalI ] . done ( resolver . getDispatcher ( ) ) ; < nl > } < nl > } ; < nl > } < nl > + < nl > + / / < nl > + / / Returning mapped promises < nl > + / / < nl > + < nl > executor . result ( mappedPromises ) ; < nl > - Log . d ( " PromisesArray " , " 5 " ) ; < nl > } ) ; < nl > - Log . d ( " PromisesArray " , " map : executor : 1 " ) ; < nl > - promises . failure ( e - > executor . error ( e ) ) ; < nl > - Log . d ( " PromisesArray " , " map : executor : 2 " ) ; < nl > + < nl > + / / < nl > + / / Handling failure < nl > + / / < nl > + < nl > + promises . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + executor . error ( e ) ; < nl > + } < nl > + } ) ; < nl > + < nl > + / / < nl > + / / Starting source promises < nl > + / / < nl > + < nl > promises . done ( executor . getDispatcher ( ) ) ; < nl > - Log . d ( " PromisesArray " , " map : executor : 3 " ) ; < nl > } ) ; < nl > } < nl > < nl > + / * * < nl > + * Zip array to single promise < nl > + * < nl > + * @ param fuc zipping function < nl > + * @ param < R > type of result < nl > + * @ return promise < nl > + * / < nl > public < R > Promise < R > zipPromise ( ArrayFunction < T , Promise < R > > fuc ) { < nl > return new Promise < R > ( ) { < nl > @ Override < nl > @ @ - 113 , 24 + 232 , 6 @ @ public class PromisesArray < T > { < nl > promise . done ( resolver . getDispatcher ( ) ) ; < nl > } < nl > } ) ; < nl > - / / promises1 [ i ] . then ( t - > { < nl > - / / < nl > - / / res [ finalI ] = t ; < nl > - / / ended [ finalI ] = true ; < nl > - / / < nl > - / / for ( int i1 = 0 ; i1 < promises1 . length ; i1 + + ) { < nl > - / / if ( ended [ i1 ] = = null | | ! ended [ i1 ] ) { < nl > - / / return ; < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / / / Promise < R > promise = fuc . apply ( ( T [ ] ) res ) ; < nl > - / / / / promise . then ( r - > resolver . result ( r ) ) ; < nl > - / / / / promise . failure ( e - > resolver . error ( e ) ) ; < nl > - / / / / promise . done ( resolver . getDispatcher ( ) ) ; < nl > - / / } ) ; < nl > - / / promises1 [ i ] . failure ( e - > resolver . error ( e ) ) ; < nl > - / / promises1 [ i ] . done ( resolver . getDispatcher ( ) ) ; < nl > promises1 [ i ] . failure ( new Consumer < Exception > ( ) { < nl > @ Override < nl > public void apply ( Exception e ) { < nl > @ @ - 149 , 12 + 250 , 15 @ @ public class PromisesArray < T > { < nl > } ) ; < nl > < nl > promises . done ( resolver . getDispatcher ( ) ) ; < nl > - / / promises . failure ( e - > resolver . error ( e ) ) ; < nl > - / / promises . done ( resolver . getDispatcher ( ) ) ; < nl > } < nl > } ; < nl > } < nl > < nl > + / * * < nl > + * Zipping array of promises to single promise of array < nl > + * < nl > + * @ return promise < nl > + * / < nl > public Promise < T [ ] > zip ( ) { < nl > return zipPromise ( new ArrayFunction < T , Promise < T [ ] > > ( ) { < nl > @ Override < nl > @ @ - 163 , 31 + 267 , 4 @ @ public class PromisesArray < T > { < nl > } < nl > } ) ; < nl > } < nl > - < nl > - public static < T > PromisesArray < T > of ( List < T > list ) { < nl > - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > - for ( T t : list ) { < nl > - res . add ( Promises . success ( t ) ) ; < nl > - } < nl > - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > - } < nl > - < nl > - @ SafeVarargs < nl > - public static < T > PromisesArray < T > of ( T . . . items ) { < nl > - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > - for ( T t : items ) { < nl > - res . add ( Promises . success ( t ) ) ; < nl > - } < nl > - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > - } < nl > - < nl > - @ SafeVarargs < nl > - public static < T > PromisesArray < T > ofPromises ( Promise < T > . . . items ) { < nl > - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; < nl > - Collections . addAll ( res , items ) ; < nl > - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; < nl > - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; < nl > - } < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java b / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java < nl > index 169d0f0 . . 21d6484 100644 < nl > - - - a / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java < nl > + + + b / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java < nl > @ @ - 125 , 19 + 125 , 21 @ @ public class MainPhoneController extends MainBaseController { < nl > < nl > Intent intent = getIntent ( ) ; < nl > if ( intent ! = null ) { < nl > - if ( intent . getAction ( ) . equals ( Intent . ACTION _ VIEW ) & & intent . getData ( ) ! = null ) { < nl > - joinGroupUrl = getIntent ( ) . getData ( ) . toString ( ) ; < nl > - } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND ) ) { < nl > - if ( " text / plain " . equals ( getIntent ( ) . getType ( ) ) ) { < nl > - sendText = intent . getStringExtra ( Intent . EXTRA _ TEXT ) ; < nl > - } else { < nl > - sendUriString = intent . getParcelableExtra ( Intent . EXTRA _ STREAM ) . toString ( ) ; < nl > - } < nl > - } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND _ MULTIPLE ) ) { < nl > - ArrayList < Uri > imageUris = intent . getParcelableArrayListExtra ( Intent . EXTRA _ STREAM ) ; < nl > - if ( imageUris ! = null ) { < nl > - for ( Uri u : imageUris ) { < nl > - sendUriMultiple . add ( u . toString ( ) ) ; < nl > + if ( intent . getAction ( ) ! = null ) { < nl > + if ( intent . getAction ( ) . equals ( Intent . ACTION _ VIEW ) & & intent . getData ( ) ! = null ) { < nl > + joinGroupUrl = getIntent ( ) . getData ( ) . toString ( ) ; < nl > + } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND ) ) { < nl > + if ( " text / plain " . equals ( getIntent ( ) . getType ( ) ) ) { < nl > + sendText = intent . getStringExtra ( Intent . EXTRA _ TEXT ) ; < nl > + } else { < nl > + sendUriString = intent . getParcelableExtra ( Intent . EXTRA _ STREAM ) . toString ( ) ; < nl > + } < nl > + } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND _ MULTIPLE ) ) { < nl > + ArrayList < Uri > imageUris = intent . getParcelableArrayListExtra ( Intent . EXTRA _ STREAM ) ; < nl > + if ( imageUris ! = null ) { < nl > + for ( Uri u : imageUris ) { < nl > + sendUriMultiple . add ( u . toString ( ) ) ; < nl > + } < nl > } < nl > } < nl > } < nl > diff - - git a / actor - apps / core - android / build . gradle b / actor - apps / core - android / build . gradle < nl > index 2a34465 . . 8acee4e 100644 < nl > - - - a / actor - apps / core - android / build . gradle < nl > + + + b / actor - apps / core - android / build . gradle < nl > @ @ - 30 , 6 + 30 , 9 @ @ android { < nl > ' . . / runtime / src / generic / java ' , < nl > ' . . / runtime - android / src / main / java ' ] < nl > } < nl > + resources { < nl > + srcDirs = [ ' . . / core / src / main / resources ' ] < nl > + } < nl > } < nl > } < nl > < nl > diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java b / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java < nl > index 703c112 . . 5e1f174 100644 < nl > - - - a / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java < nl > + + + b / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java < nl > @ @ - 27 , 6 + 27 , 8 @ @ import im . actor . core . entity . Peer ; < nl > import im . actor . core . entity . SearchEntity ; < nl > import im . actor . core . entity . content . FastThumb ; < nl > import im . actor . core . network . NetworkState ; < nl > + import im . actor . core . utils . AppStateActor ; < nl > + import im . actor . core . utils . ImageHelper ; < nl > import im . actor . runtime . actors . ActorCreator ; < nl > import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . actors . Props ; < nl > diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java b / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java < nl > deleted file mode 100644 < nl > index 04ca1ca . . 0000000 < nl > - - - a / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java < nl > + + + / dev / null < nl > @ @ - 1 , 107 + 0 , 0 @ @ < nl > - package im . actor . core ; < nl > - < nl > - import im . actor . runtime . actors . Actor ; < nl > - < nl > - / * * < nl > - * Created by ex3ndr on 31 . 07 . 15 . < nl > - * / < nl > - public class AppStateActor extends Actor { < nl > - < nl > - private static final int CLOSE _ TIMEOUT = 1000 ; < nl > - < nl > - private final AndroidMessenger messenger ; < nl > - < nl > - private boolean isAppOpen = false ; < nl > - private boolean isScreenVisible = true ; < nl > - private int activityCount = 0 ; < nl > - < nl > - public AppStateActor ( AndroidMessenger messenger ) { < nl > - this . messenger = messenger ; < nl > - } < nl > - < nl > - private void onActivityOpened ( ) { < nl > - activityCount + + ; < nl > - if ( isScreenVisible ) { < nl > - onAppProbablyOpened ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void onActivityClosed ( ) { < nl > - activityCount - - ; < nl > - < nl > - if ( activityCount = = 0 ) { < nl > - onAppProbablyClosed ( ) ; < nl > - } < nl > - } < nl > - < nl > - private void onAppProbablyClosed ( ) { < nl > - if ( isAppOpen ) { < nl > - self ( ) . sendOnce ( new MarkAppAsClosed ( ) , CLOSE _ TIMEOUT ) ; < nl > - } < nl > - } < nl > - < nl > - private void onAppProbablyOpened ( ) { < nl > - if ( ! isAppOpen ) { < nl > - isAppOpen = true ; < nl > - onAppOpened ( ) ; < nl > - } < nl > - self ( ) . sendOnce ( new MarkAppAsClosed ( ) , 24 * 60 * 60 * 1000 ) ; / / Far away < nl > - } < nl > - < nl > - private void onAppOpened ( ) { < nl > - messenger . onAppVisible ( ) ; < nl > - } < nl > - < nl > - private void onAppClosed ( ) { < nl > - messenger . onAppHidden ( ) ; < nl > - } < nl > - < nl > - private void onScreenOn ( ) { < nl > - isScreenVisible = true ; < nl > - if ( activityCount > 0 ) { < nl > - onAppProbablyOpened ( ) ; < nl > - } < nl > - } < nl > - < nl > - public void onScreenOff ( ) { < nl > - isScreenVisible = false ; < nl > - onAppProbablyClosed ( ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void onReceive ( Object message ) { < nl > - if ( message instanceof OnActivityOpened ) { < nl > - onActivityOpened ( ) ; < nl > - } else if ( message instanceof OnActivityClosed ) { < nl > - onActivityClosed ( ) ; < nl > - } else if ( message instanceof MarkAppAsClosed ) { < nl > - onAppClosed ( ) ; < nl > - } else if ( message instanceof OnScreenOn ) { < nl > - onScreenOn ( ) ; < nl > - } else if ( message instanceof OnScreenOff ) { < nl > - onScreenOff ( ) ; < nl > - } else { < nl > - super . onReceive ( message ) ; < nl > - } < nl > - } < nl > - < nl > - private static class MarkAppAsClosed { < nl > - < nl > - } < nl > - < nl > - public static class OnActivityOpened { < nl > - < nl > - } < nl > - < nl > - public static class OnActivityClosed { < nl > - < nl > - } < nl > - < nl > - public static class OnScreenOn { < nl > - < nl > - } < nl > - < nl > - public static class OnScreenOff { < nl > - < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java b / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java < nl > deleted file mode 100644 < nl > index e5ffc8a . . 0000000 < nl > - - - a / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java < nl > + + + / dev / null < nl > @ @ - 1 , 248 + 0 , 0 @ @ < nl > - / * < nl > - * Copyright ( C ) 2015 Actor LLC . < https : / / actor . im > < nl > - * / < nl > - < nl > - package im . actor . core ; < nl > - < nl > - import android . graphics . Bitmap ; < nl > - import android . graphics . BitmapFactory ; < nl > - import android . graphics . Canvas ; < nl > - import android . graphics . Color ; < nl > - import android . graphics . Matrix ; < nl > - import android . graphics . Paint ; < nl > - import android . graphics . Rect ; < nl > - import android . media . ExifInterface ; < nl > - import android . os . Build ; < nl > - < nl > - import java . io . ByteArrayOutputStream ; < nl > - import java . io . File ; < nl > - import java . io . FileOutputStream ; < nl > - import java . io . IOException ; < nl > - < nl > - public class ImageHelper { < nl > - private static final int MAX _ PIXELS = 1200 * 1200 ; < nl > - private static final int MAX _ PIXELS _ HQ = 1500 * 1500 ; < nl > - < nl > - private static final int JPEG _ QUALITY = 80 ; < nl > - private static final int JPEG _ QUALITY _ HQ = 90 ; < nl > - private static final int JPEG _ QUALITY _ LOW = 55 ; < nl > - < nl > - public static void save ( Bitmap bitmap , String fileName ) throws IOException { < nl > - save ( bitmap , fileName , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ HQ ) ; < nl > - } < nl > - < nl > - public static byte [ ] save ( Bitmap bitmap ) { < nl > - return save ( bitmap , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ LOW ) ; < nl > - } < nl > - < nl > - public static Bitmap loadOptimizedHQ ( String fileName ) { < nl > - int scale = getScaleFactor ( getImageSize ( fileName ) , MAX _ PIXELS _ HQ ) ; < nl > - < nl > - BitmapFactory . Options o = new BitmapFactory . Options ( ) ; < nl > - < nl > - o . inScaled = false ; < nl > - o . inSampleSize = scale ; < nl > - o . inPreferredConfig = Bitmap . Config . ARGB _ 8888 ; < nl > - < nl > - if ( Build . VERSION . SDK _ INT > = 10 ) { < nl > - o . inPreferQualityOverSpeed = true ; < nl > - } < nl > - < nl > - if ( Build . VERSION . SDK _ INT > = 11 ) { < nl > - o . inMutable = true ; < nl > - } < nl > - < nl > - if ( ! new File ( fileName ) . exists ( ) ) { < nl > - return null ; < nl > - } < nl > - < nl > - Bitmap res = BitmapFactory . decodeFile ( fileName , o ) ; < nl > - if ( res = = null ) { < nl > - return null ; < nl > - } < nl > - < nl > - try { < nl > - ExifInterface exif = new ExifInterface ( fileName ) ; < nl > - String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; < nl > - int orientation = 0 ; < nl > - if ( exifOrientation ! = null ) { < nl > - orientation = Integer . parseInt ( exifOrientation ) ; < nl > - } < nl > - res = fixExif ( res , orientation ) ; < nl > - } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - } < nl > - < nl > - return res ; < nl > - } < nl > - < nl > - private static Bitmap fixExif ( Bitmap src , int exifOrientation ) { < nl > - try { < nl > - final Matrix bitmapMatrix = new Matrix ( ) ; < nl > - switch ( exifOrientation ) { < nl > - case 1 : < nl > - break ; / / top left < nl > - case 2 : < nl > - bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > - break ; / / top right < nl > - case 3 : < nl > - bitmapMatrix . postRotate ( 180 ) ; < nl > - break ; / / bottom right < nl > - case 4 : < nl > - bitmapMatrix . postRotate ( 180 ) ; < nl > - bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > - break ; / / bottom left < nl > - case 5 : < nl > - bitmapMatrix . postRotate ( 90 ) ; < nl > - bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > - break ; / / left top < nl > - case 6 : < nl > - bitmapMatrix . postRotate ( 90 ) ; < nl > - break ; / / right top < nl > - case 7 : < nl > - bitmapMatrix . postRotate ( 270 ) ; < nl > - bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > - break ; / / right bottom < nl > - case 8 : < nl > - bitmapMatrix . postRotate ( 270 ) ; < nl > - break ; / / left bottom < nl > - default : < nl > - break ; / / Unknown < nl > - } < nl > - < nl > - / / Create new bitmap . < nl > - return Bitmap . createBitmap ( src , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , bitmapMatrix , false ) ; < nl > - } catch ( Exception e ) { < nl > - / / TODO : handle exception < nl > - } < nl > - return null ; < nl > - } < nl > - < nl > - private static int getScaleFactor ( BitmapSize size , int maxPixels ) { < nl > - int scale = 1 ; < nl > - int scaledW = size . getWidth ( ) ; < nl > - int scaledH = size . getHeight ( ) ; < nl > - while ( scaledW * scaledH > maxPixels ) { < nl > - scale * = 2 ; < nl > - scaledH / = 2 ; < nl > - scaledW / = 2 ; < nl > - } < nl > - return scale ; < nl > - } < nl > - < nl > - private static BitmapSize getImageSize ( String fileName ) { < nl > - BitmapFactory . Options o = new BitmapFactory . Options ( ) ; < nl > - o . inJustDecodeBounds = true ; < nl > - BitmapFactory . decodeFile ( fileName , o ) ; < nl > - if ( o . outWidth = = 0 | | o . outHeight = = 0 ) { < nl > - return null ; < nl > - } < nl > - < nl > - int w = o . outWidth ; < nl > - int h = o . outHeight ; < nl > - < nl > - try { < nl > - ExifInterface exif = new ExifInterface ( fileName ) ; < nl > - String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; < nl > - if ( exifOrientation ! = null ) { < nl > - if ( exifOrientation . equals ( " 5 " ) | | < nl > - exifOrientation . equals ( " 6 " ) | | < nl > - exifOrientation . equals ( " 7 " ) | | < nl > - exifOrientation . equals ( " 8 " ) ) { < nl > - w = o . outHeight ; < nl > - h = o . outWidth ; < nl > - < nl > - } < nl > - } < nl > - } catch ( IOException e ) { < nl > - / / e . printStackTrace ( ) ; < nl > - } < nl > - < nl > - return new BitmapSize ( w , h ) ; < nl > - } < nl > - < nl > - private static byte [ ] save ( Bitmap src , Bitmap . CompressFormat format , int quality ) { < nl > - ByteArrayOutputStream outputStream = null ; < nl > - try { < nl > - outputStream = new ByteArrayOutputStream ( ) ; < nl > - src . compress ( format , quality , outputStream ) ; < nl > - return outputStream . toByteArray ( ) ; < nl > - } finally { < nl > - if ( outputStream ! = null ) { < nl > - try { < nl > - outputStream . close ( ) ; < nl > - } catch ( IOException e1 ) { < nl > - e1 . printStackTrace ( ) ; < nl > - } < nl > - } < nl > - } < nl > - } < nl > - < nl > - private static void save ( Bitmap src , String fileName , Bitmap . CompressFormat format , int quality ) throws IOException { < nl > - FileOutputStream outputStream = null ; < nl > - try { < nl > - outputStream = new FileOutputStream ( fileName ) ; < nl > - src . compress ( format , quality , outputStream ) ; < nl > - outputStream . close ( ) ; < nl > - } finally { < nl > - if ( outputStream ! = null ) { < nl > - try { < nl > - outputStream . close ( ) ; < nl > - } catch ( IOException e1 ) { < nl > - e1 . printStackTrace ( ) ; < nl > - } < nl > - } < nl > - } < nl > - } < nl > - < nl > - public static Bitmap scaleFit ( Bitmap src , int maxW , int maxH ) { < nl > - float ratio = Math . min ( maxW / ( float ) src . getWidth ( ) , maxH / ( float ) src . getHeight ( ) ) ; < nl > - int newW = ( int ) ( src . getWidth ( ) * ratio ) ; < nl > - int newH = ( int ) ( src . getHeight ( ) * ratio ) ; < nl > - return scale ( src , newW , newH ) ; < nl > - } < nl > - < nl > - private static Bitmap scale ( Bitmap src , int dw , int dh ) { < nl > - Bitmap res = Bitmap . createBitmap ( dw , dh , Bitmap . Config . ARGB _ 8888 ) ; < nl > - scale ( src , res ) ; < nl > - return res ; < nl > - } < nl > - < nl > - private static void scale ( Bitmap src , Bitmap dest ) { < nl > - scale ( src , dest , Color . TRANSPARENT ) ; < nl > - } < nl > - < nl > - private static void scale ( Bitmap src , Bitmap dest , int clearColor ) { < nl > - scale ( src , dest , clearColor , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , 0 , 0 , dest . getWidth ( ) , dest . getHeight ( ) ) ; < nl > - } < nl > - < nl > - private static void scale ( Bitmap src , Bitmap dest , int clearColor , < nl > - int x , int y , int sw , int sh , < nl > - int dx , int dy , < nl > - int dw , int dh ) { < nl > - dest . eraseColor ( clearColor ) ; < nl > - Canvas canvas = new Canvas ( dest ) ; < nl > - Paint paint = new Paint ( ) ; < nl > - paint . setFilterBitmap ( true ) ; < nl > - canvas . drawBitmap ( src , new Rect ( x + 1 , y + 1 , sw - 1 , sh - 1 ) , new Rect ( dx , dy , dw , dh ) , paint ) ; < nl > - canvas . setBitmap ( null ) ; < nl > - } < nl > - < nl > - private static class BitmapSize { < nl > - private int width ; < nl > - private int height ; < nl > - < nl > - private BitmapSize ( int width , int height ) { < nl > - this . width = width ; < nl > - this . height = height ; < nl > - } < nl > - < nl > - public int getWidth ( ) { < nl > - return width ; < nl > - } < nl > - < nl > - public int getHeight ( ) { < nl > - return height ; < nl > - } < nl > - } < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java b / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java < nl > new file mode 100644 < nl > index 0000000 . . 94c0b08 < nl > - - - / dev / null < nl > + + + b / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java < nl > @ @ - 0 , 0 + 1 , 108 @ @ < nl > + package im . actor . core . utils ; < nl > + < nl > + import im . actor . core . AndroidMessenger ; < nl > + import im . actor . runtime . actors . Actor ; < nl > + < nl > + / * * < nl > + * Created by ex3ndr on 31 . 07 . 15 . < nl > + * / < nl > + public class AppStateActor extends Actor { < nl > + < nl > + private static final int CLOSE _ TIMEOUT = 1000 ; < nl > + < nl > + private final AndroidMessenger messenger ; < nl > + < nl > + private boolean isAppOpen = false ; < nl > + private boolean isScreenVisible = true ; < nl > + private int activityCount = 0 ; < nl > + < nl > + public AppStateActor ( AndroidMessenger messenger ) { < nl > + this . messenger = messenger ; < nl > + } < nl > + < nl > + private void onActivityOpened ( ) { < nl > + activityCount + + ; < nl > + if ( isScreenVisible ) { < nl > + onAppProbablyOpened ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onActivityClosed ( ) { < nl > + activityCount - - ; < nl > + < nl > + if ( activityCount = = 0 ) { < nl > + onAppProbablyClosed ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onAppProbablyClosed ( ) { < nl > + if ( isAppOpen ) { < nl > + self ( ) . sendOnce ( new MarkAppAsClosed ( ) , CLOSE _ TIMEOUT ) ; < nl > + } < nl > + } < nl > + < nl > + private void onAppProbablyOpened ( ) { < nl > + if ( ! isAppOpen ) { < nl > + isAppOpen = true ; < nl > + onAppOpened ( ) ; < nl > + } < nl > + self ( ) . sendOnce ( new MarkAppAsClosed ( ) , 24 * 60 * 60 * 1000 ) ; / / Far away < nl > + } < nl > + < nl > + private void onAppOpened ( ) { < nl > + messenger . onAppVisible ( ) ; < nl > + } < nl > + < nl > + private void onAppClosed ( ) { < nl > + messenger . onAppHidden ( ) ; < nl > + } < nl > + < nl > + private void onScreenOn ( ) { < nl > + isScreenVisible = true ; < nl > + if ( activityCount > 0 ) { < nl > + onAppProbablyOpened ( ) ; < nl > + } < nl > + } < nl > + < nl > + public void onScreenOff ( ) { < nl > + isScreenVisible = false ; < nl > + onAppProbablyClosed ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + if ( message instanceof OnActivityOpened ) { < nl > + onActivityOpened ( ) ; < nl > + } else if ( message instanceof OnActivityClosed ) { < nl > + onActivityClosed ( ) ; < nl > + } else if ( message instanceof MarkAppAsClosed ) { < nl > + onAppClosed ( ) ; < nl > + } else if ( message instanceof OnScreenOn ) { < nl > + onScreenOn ( ) ; < nl > + } else if ( message instanceof OnScreenOff ) { < nl > + onScreenOff ( ) ; < nl > + } else { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + } < nl > + < nl > + private static class MarkAppAsClosed { < nl > + < nl > + } < nl > + < nl > + public static class OnActivityOpened { < nl > + < nl > + } < nl > + < nl > + public static class OnActivityClosed { < nl > + < nl > + } < nl > + < nl > + public static class OnScreenOn { < nl > + < nl > + } < nl > + < nl > + public static class OnScreenOff { < nl > + < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java b / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java < nl > new file mode 100644 < nl > index 0000000 . . 40b42bd < nl > - - - / dev / null < nl > + + + b / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java < nl > @ @ - 0 , 0 + 1 , 248 @ @ < nl > + / * < nl > + * Copyright ( C ) 2015 Actor LLC . < https : / / actor . im > < nl > + * / < nl > + < nl > + package im . actor . core . utils ; < nl > + < nl > + import android . graphics . Bitmap ; < nl > + import android . graphics . BitmapFactory ; < nl > + import android . graphics . Canvas ; < nl > + import android . graphics . Color ; < nl > + import android . graphics . Matrix ; < nl > + import android . graphics . Paint ; < nl > + import android . graphics . Rect ; < nl > + import android . media . ExifInterface ; < nl > + import android . os . Build ; < nl > + < nl > + import java . io . ByteArrayOutputStream ; < nl > + import java . io . File ; < nl > + import java . io . FileOutputStream ; < nl > + import java . io . IOException ; < nl > + < nl > + public class ImageHelper { < nl > + private static final int MAX _ PIXELS = 1200 * 1200 ; < nl > + private static final int MAX _ PIXELS _ HQ = 1500 * 1500 ; < nl > + < nl > + private static final int JPEG _ QUALITY = 80 ; < nl > + private static final int JPEG _ QUALITY _ HQ = 90 ; < nl > + private static final int JPEG _ QUALITY _ LOW = 55 ; < nl > + < nl > + public static void save ( Bitmap bitmap , String fileName ) throws IOException { < nl > + save ( bitmap , fileName , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ HQ ) ; < nl > + } < nl > + < nl > + public static byte [ ] save ( Bitmap bitmap ) { < nl > + return save ( bitmap , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ LOW ) ; < nl > + } < nl > + < nl > + public static Bitmap loadOptimizedHQ ( String fileName ) { < nl > + int scale = getScaleFactor ( getImageSize ( fileName ) , MAX _ PIXELS _ HQ ) ; < nl > + < nl > + BitmapFactory . Options o = new BitmapFactory . Options ( ) ; < nl > + < nl > + o . inScaled = false ; < nl > + o . inSampleSize = scale ; < nl > + o . inPreferredConfig = Bitmap . Config . ARGB _ 8888 ; < nl > + < nl > + if ( Build . VERSION . SDK _ INT > = 10 ) { < nl > + o . inPreferQualityOverSpeed = true ; < nl > + } < nl > + < nl > + if ( Build . VERSION . SDK _ INT > = 11 ) { < nl > + o . inMutable = true ; < nl > + } < nl > + < nl > + if ( ! new File ( fileName ) . exists ( ) ) { < nl > + return null ; < nl > + } < nl > + < nl > + Bitmap res = BitmapFactory . decodeFile ( fileName , o ) ; < nl > + if ( res = = null ) { < nl > + return null ; < nl > + } < nl > + < nl > + try { < nl > + ExifInterface exif = new ExifInterface ( fileName ) ; < nl > + String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; < nl > + int orientation = 0 ; < nl > + if ( exifOrientation ! = null ) { < nl > + orientation = Integer . parseInt ( exifOrientation ) ; < nl > + } < nl > + res = fixExif ( res , orientation ) ; < nl > + } catch ( IOException e ) { < nl > + / / e . printStackTrace ( ) ; < nl > + } < nl > + < nl > + return res ; < nl > + } < nl > + < nl > + private static Bitmap fixExif ( Bitmap src , int exifOrientation ) { < nl > + try { < nl > + final Matrix bitmapMatrix = new Matrix ( ) ; < nl > + switch ( exifOrientation ) { < nl > + case 1 : < nl > + break ; / / top left < nl > + case 2 : < nl > + bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > + break ; / / top right < nl > + case 3 : < nl > + bitmapMatrix . postRotate ( 180 ) ; < nl > + break ; / / bottom right < nl > + case 4 : < nl > + bitmapMatrix . postRotate ( 180 ) ; < nl > + bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > + break ; / / bottom left < nl > + case 5 : < nl > + bitmapMatrix . postRotate ( 90 ) ; < nl > + bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > + break ; / / left top < nl > + case 6 : < nl > + bitmapMatrix . postRotate ( 90 ) ; < nl > + break ; / / right top < nl > + case 7 : < nl > + bitmapMatrix . postRotate ( 270 ) ; < nl > + bitmapMatrix . postScale ( - 1 , 1 ) ; < nl > + break ; / / right bottom < nl > + case 8 : < nl > + bitmapMatrix . postRotate ( 270 ) ; < nl > + break ; / / left bottom < nl > + default : < nl > + break ; / / Unknown < nl > + } < nl > + < nl > + / / Create new bitmap . < nl > + return Bitmap . createBitmap ( src , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , bitmapMatrix , false ) ; < nl > + } catch ( Exception e ) { < nl > + / / TODO : handle exception < nl > + } < nl > + return null ; < nl > + } < nl > + < nl > + private static int getScaleFactor ( BitmapSize size , int maxPixels ) { < nl > + int scale = 1 ; < nl > + int scaledW = size . getWidth ( ) ; < nl > + int scaledH = size . getHeight ( ) ; < nl > + while ( scaledW * scaledH > maxPixels ) { < nl > + scale * = 2 ; < nl > + scaledH / = 2 ; < nl > + scaledW / = 2 ; < nl > + } < nl > + return scale ; < nl > + } < nl > + < nl > + private static BitmapSize getImageSize ( String fileName ) { < nl > + BitmapFactory . Options o = new BitmapFactory . Options ( ) ; < nl > + o . inJustDecodeBounds = true ; < nl > + BitmapFactory . decodeFile ( fileName , o ) ; < nl > + if ( o . outWidth = = 0 | | o . outHeight = = 0 ) { < nl > + return null ; < nl > + } < nl > + < nl > + int w = o . outWidth ; < nl > + int h = o . outHeight ; < nl > + < nl > + try { < nl > + ExifInterface exif = new ExifInterface ( fileName ) ; < nl > + String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; < nl > + if ( exifOrientation ! = null ) { < nl > + if ( exifOrientation . equals ( " 5 " ) | | < nl > + exifOrientation . equals ( " 6 " ) | | < nl > + exifOrientation . equals ( " 7 " ) | | < nl > + exifOrientation . equals ( " 8 " ) ) { < nl > + w = o . outHeight ; < nl > + h = o . outWidth ; < nl > + < nl > + } < nl > + } < nl > + } catch ( IOException e ) { < nl > + / / e . printStackTrace ( ) ; < nl > + } < nl > + < nl > + return new BitmapSize ( w , h ) ; < nl > + } < nl > + < nl > + private static byte [ ] save ( Bitmap src , Bitmap . CompressFormat format , int quality ) { < nl > + ByteArrayOutputStream outputStream = null ; < nl > + try { < nl > + outputStream = new ByteArrayOutputStream ( ) ; < nl > + src . compress ( format , quality , outputStream ) ; < nl > + return outputStream . toByteArray ( ) ; < nl > + } finally { < nl > + if ( outputStream ! = null ) { < nl > + try { < nl > + outputStream . close ( ) ; < nl > + } catch ( IOException e1 ) { < nl > + e1 . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + private static void save ( Bitmap src , String fileName , Bitmap . CompressFormat format , int quality ) throws IOException { < nl > + FileOutputStream outputStream = null ; < nl > + try { < nl > + outputStream = new FileOutputStream ( fileName ) ; < nl > + src . compress ( format , quality , outputStream ) ; < nl > + outputStream . close ( ) ; < nl > + } finally { < nl > + if ( outputStream ! = null ) { < nl > + try { < nl > + outputStream . close ( ) ; < nl > + } catch ( IOException e1 ) { < nl > + e1 . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + public static Bitmap scaleFit ( Bitmap src , int maxW , int maxH ) { < nl > + float ratio = Math . min ( maxW / ( float ) src . getWidth ( ) , maxH / ( float ) src . getHeight ( ) ) ; < nl > + int newW = ( int ) ( src . getWidth ( ) * ratio ) ; < nl > + int newH = ( int ) ( src . getHeight ( ) * ratio ) ; < nl > + return scale ( src , newW , newH ) ; < nl > + } < nl > + < nl > + private static Bitmap scale ( Bitmap src , int dw , int dh ) { < nl > + Bitmap res = Bitmap . createBitmap ( dw , dh , Bitmap . Config . ARGB _ 8888 ) ; < nl > + scale ( src , res ) ; < nl > + return res ; < nl > + } < nl > + < nl > + private static void scale ( Bitmap src , Bitmap dest ) { < nl > + scale ( src , dest , Color . TRANSPARENT ) ; < nl > + } < nl > + < nl > + private static void scale ( Bitmap src , Bitmap dest , int clearColor ) { < nl > + scale ( src , dest , clearColor , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , 0 , 0 , dest . getWidth ( ) , dest . getHeight ( ) ) ; < nl > + } < nl > + < nl > + private static void scale ( Bitmap src , Bitmap dest , int clearColor , < nl > + int x , int y , int sw , int sh , < nl > + int dx , int dy , < nl > + int dw , int dh ) { < nl > + dest . eraseColor ( clearColor ) ; < nl > + Canvas canvas = new Canvas ( dest ) ; < nl > + Paint paint = new Paint ( ) ; < nl > + paint . setFilterBitmap ( true ) ; < nl > + canvas . drawBitmap ( src , new Rect ( x + 1 , y + 1 , sw - 1 , sh - 1 ) , new Rect ( dx , dy , dw , dh ) , paint ) ; < nl > + canvas . setBitmap ( null ) ; < nl > + } < nl > + < nl > + private static class BitmapSize { < nl > + private int width ; < nl > + private int height ; < nl > + < nl > + private BitmapSize ( int width , int height ) { < nl > + this . width = width ; < nl > + this . height = height ; < nl > + } < nl > + < nl > + public int getWidth ( ) { < nl > + return width ; < nl > + } < nl > + < nl > + public int getHeight ( ) { < nl > + return height ; < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java b / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java < nl > index 237178a . . f419e3a 100644 < nl > - - - a / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java < nl > + + + b / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java < nl > @ @ - 15 , 7 + 15 , 9 @ @ public class LocaleLoader { < nl > continue ; < nl > } < nl > String [ ] lineVal = line . split ( " = " , 2 ) ; < nl > - res . put ( lineVal [ 0 ] , lineVal [ 1 ] ) ; < nl > + if ( lineVal . length = = 2 ) { < nl > + res . put ( lineVal [ 0 ] , lineVal [ 1 ] ) ; < nl > + } < nl > } < nl > return res ; < nl > } < nl > diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java < nl > index 6249b44 . . 59036ec 100644 < nl > - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java < nl > + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java < nl > @ @ - 1 , 23 + 1 , 7 @ @ < nl > package im . actor . runtime ; < nl > < nl > - public class LocaleRuntimeProvider implements LocaleRuntime { < nl > - @ Override < nl > - public String getCurrentLocale ( ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > + import im . actor . runtime . android . AndroidLocaleProvider ; < nl > < nl > - @ Override < nl > - public boolean is24Hours ( ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > + public class LocaleRuntimeProvider extends AndroidLocaleProvider { < nl > < nl > - @ Override < nl > - public String formatDate ( long date ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public String formatTime ( long date ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > } < nl > diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java < nl > index f777d54 . . c7e8924 100644 < nl > - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java < nl > + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java < nl > @ @ - 4 , 23 + 4 , 4 @ @ import im . actor . runtime . android . AndroidLogProvider ; < nl > < nl > public class LogRuntimeProvider extends AndroidLogProvider { < nl > < nl > - @ Override < nl > - public void w ( String tag , String message ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void e ( String tag , Throwable throwable ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void d ( String tag , String message ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > - < nl > - @ Override < nl > - public void v ( String tag , String message ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > } < nl > diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java < nl > index 1ee7313 . . 106489b 100644 < nl > - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java < nl > + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java < nl > @ @ - 1 , 12 + 1 , 7 @ @ < nl > package im . actor . runtime ; < nl > < nl > - import im . actor . runtime . mtproto . ConnectionCallback ; < nl > - import im . actor . runtime . mtproto . ConnectionEndpoint ; < nl > - import im . actor . runtime . mtproto . CreateConnectionCallback ; < nl > + import im . actor . core . runtime . generic . GenericNetworkProvider ; < nl > + < nl > + public class NetworkRuntimeProvider extends GenericNetworkProvider { < nl > < nl > - public class NetworkRuntimeProvider implements NetworkRuntime { < nl > - @ Override < nl > - public void createConnection ( int connectionId , int mtprotoVersion , int apiMajorVersion , int apiMinorVersion , ConnectionEndpoint endpoint , ConnectionCallback callback , CreateConnectionCallback createCallback ) { < nl > - throw new RuntimeException ( " Dumb " ) ; < nl > - } < nl > } < nl > diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java < nl > new file mode 100644 < nl > index 0000000 . . 11eb081 < nl > - - - / dev / null < nl > + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java < nl > @ @ - 0 , 0 + 1 , 29 @ @ < nl > + package im . actor . runtime . android ; < nl > + < nl > + import java . text . DateFormat ; < nl > + import java . util . Date ; < nl > + < nl > + import im . actor . runtime . LocaleRuntime ; < nl > + < nl > + / * * < nl > + * Created by ex3ndr on 10 . 08 . 15 . < nl > + * / < nl > + public class AndroidLocaleProvider implements LocaleRuntime { < nl > + < nl > + @ Override < nl > + public String getCurrentLocale ( ) { < nl > + return null ; < nl > + } < nl > + < nl > + @ Override < nl > + public String formatDate ( long date ) { < nl > + DateFormat dateFormat = android . text . format . DateFormat . getDateFormat ( AndroidContext . getContext ( ) ) ; < nl > + return dateFormat . format ( new Date ( date ) ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public String formatTime ( long date ) { < nl > + DateFormat dateFormat = android . text . format . DateFormat . getTimeFormat ( AndroidContext . getContext ( ) ) ; < nl > + return dateFormat . format ( new Date ( date ) ) ; < nl > + } < nl > + } < nl > diff - - git a / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java b / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java < nl > index daa69db . . 92bde84 100644 < nl > - - - a / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java < nl > + + + b / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . core . runtime . generic ; < nl > < nl > + import java . io . ByteArrayOutputStream ; < nl > + import java . io . IOException ; < nl > import java . io . InputStream ; < nl > < nl > import im . actor . runtime . AssetsRuntime ; < nl > @ @ - 17 , 7 + 19 , 33 @ @ public class GenericAssetsProvider implements AssetsRuntime { < nl > @ Override < nl > public String loadAsset ( String name ) { < nl > InputStream stream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( name ) ; < nl > - / / TODO : Read all < nl > + try { < nl > + return readFully ( stream , " UTF - 8 " ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } finally { < nl > + if ( stream ! = null ) { < nl > + try { < nl > + stream . close ( ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > + } < nl > + } < nl > return null ; < nl > } < nl > + < nl > + public String readFully ( InputStream inputStream , String encoding ) throws IOException { < nl > + return new String ( readFully ( inputStream ) , encoding ) ; < nl > + } < nl > + < nl > + private byte [ ] readFully ( InputStream inputStream ) throws IOException { < nl > + ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; < nl > + byte [ ] buffer = new byte [ 1024 ] ; < nl > + int length = 0 ; < nl > + while ( ( length = inputStream . read ( buffer ) ) ! = - 1 ) { < nl > + baos . write ( buffer , 0 , length ) ; < nl > + } < nl > + return baos . toByteArray ( ) ; < nl > + } < nl > } < nl > diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java b / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java < nl > index 704579d . . 6eb8675 100644 < nl > - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java < nl > + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java < nl > @ @ - 13 , 15 + 13 , 6 @ @ public interface LocaleRuntime { < nl > String getCurrentLocale ( ) ; < nl > < nl > / * * < nl > - * Is local settings use 24 hours format < nl > - * < nl > - * @ return is 24 hour format < nl > - * / < nl > - @ ObjectiveCName ( " is24Hours " ) < nl > - boolean is24Hours ( ) ; < nl > - < nl > - < nl > - / * * < nl > * Format date < nl > * < nl > * @ param date date value < nl > diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java b / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java < nl > index 9a4ad01 . . 9512332 100644 < nl > - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java < nl > + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java < nl > @ @ - 2 , 21 + 2 , 21 @ @ package im . actor . runtime ; < nl > < nl > public final class Log { < nl > < nl > - private static final LogRuntime log = Runtime . getLogRuntime ( ) ; < nl > + private static final LogRuntime logRuntime = new LogRuntimeProvider ( ) ; < nl > < nl > public static void w ( String tag , String message ) { < nl > - log . w ( tag , message ) ; < nl > + logRuntime . w ( tag , message ) ; < nl > } < nl > < nl > public static void e ( String tag , Throwable throwable ) { < nl > - log . e ( tag , throwable ) ; < nl > + logRuntime . e ( tag , throwable ) ; < nl > } < nl > < nl > public static void d ( String tag , String message ) { < nl > - log . d ( tag , message ) ; < nl > + logRuntime . d ( tag , message ) ; < nl > } < nl > < nl > public static void v ( String tag , String message ) { < nl > - log . v ( tag , message ) ; < nl > + logRuntime . v ( tag , message ) ; < nl > } < nl > } < nl > diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java b / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java < nl > index 7bef7b4 . . 63c27b3 100644 < nl > - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java < nl > + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java < nl > @ @ - 15 , 15 + 15 , 11 @ @ public class Runtime { < nl > private static final MainThreadRuntimeProvider mainThreadRuntime = new MainThreadRuntimeProvider ( ) ; < nl > private static final LifecycleRuntime lifecycleRuntime = new LifecycleRuntimeProvider ( ) ; < nl > private static final LocaleRuntime localeRuntime = new LocaleRuntimeProvider ( ) ; < nl > - private static final LogRuntime logRuntime = new LogRuntimeProvider ( ) ; < nl > < nl > public static LocaleRuntime getLocaleRuntime ( ) { < nl > return localeRuntime ; < nl > } < nl > < nl > - public static LogRuntime getLogRuntime ( ) { < nl > - return logRuntime ; < nl > - } < nl > < nl > public static ActorDispatcher createDefaultDispatcher ( String name , ThreadPriority priority , ActorSystem actorSystem ) { < nl > return threadingRuntime . createDefaultDispatcher ( name , priority , actorSystem ) ; < nl > diff - - git a / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java b / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java < nl > index 9a351dc . . 2db9dad 100644 < nl > - - - a / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java < nl > + + + b / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java < nl > @ @ - 4 , 6 + 4 , 7 @ @ package im . actor . runtime ; < nl > * Created by ex3ndr on 07 . 08 . 15 . < nl > * / < nl > public class LogRuntimeProvider implements LogRuntime { < nl > + < nl > @ Override < nl > public void w ( String tag , String message ) { < nl > throw new RuntimeException ( " Dumb " ) ;

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index ef5a670 . . 809775a 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 224 , 7 + 224 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return Promises . success ( pickedChain ) 
 . mapPromise ( src - > { 
 if ( src ! = null ) { 
 - return Promises . successNotNull ( src ) ; 
 + return Promises . success ( src ) ; 
 } 
 
 return ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new FetchEphemeralPrivateKey ( ephemeralKey ) ) 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java 
 index 7984bcc . . 20545d9 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / KeyManagerInt . java 
 @ @ - 36 , 17 + 36 , 11 @ @ public class KeyManagerInt extends ActorInterface { 
 @ Override 
 public Promise < byte [ ] > map ( byte [ ] src ) { 
 if ( src ! = null ) { 
 - Log . d ( " getEphemeralKey " , " stored " ) ; 
 - return Promises . successNotNull ( src ) ; 
 + return Promises . success ( src ) ; 
 } 
 
 return getUserRandomPreKey ( uid , keyGroupId ) 
 - . map ( src1 - > src1 . getEphemeralKey ( ) . getPublicKey ( ) ) . then ( new Consumer < byte [ ] > ( ) { 
 - @ Override 
 - public void apply ( byte [ ] bytes ) { 
 - Log . d ( " getEphemeralKey " , " loaded : " + bytes ) ; 
 - } 
 - } ) ; 
 + . map ( src1 - > src1 . getEphemeralKey ( ) . getPublicKey ( ) ) ; 
 } 
 } ) ; 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 index 90c0fea . . a9ba04a 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promise . java 
 @ @ - 18 , 10 + 18 , 18 @ @ import im . actor . runtime . function . Map ; 
 * / 
 public class Promise < T > { 
 
 + / / 
 + / / Dispatching parameters 
 + / / 
 + 
 private final ArrayList < PromiseCallback < T > > callbacks = new ArrayList < PromiseCallback < T > > ( ) ; 
 private final PromiseFunc < T > executor ; 
 - 
 private ActorRef dispatchActor ; 
 + 
 + / / 
 + / / State of Promise 
 + / / 
 + 
 private volatile T result ; 
 private volatile Exception exception ; 
 private volatile boolean isFinished ; 
 @ @ - 34 , 6 + 42 , 9 @ @ public class Promise < T > { 
 this . executor = executor ; 
 } 
 
 + / * * 
 + * Internal constructor to work - around lambda support issueses 
 + * / 
 Promise ( ) { 
 this . executor = null ; 
 } 
 @ @ - 152 , 64 + 163 , 83 @ @ public class Promise < T > { 
 
 / * * 
 * Call this method to start promise execution 
 + * 
 + * @ param ref Scheduling actor 
 * / 
 public Promise < T > done ( ActorRef ref ) { 
 - Log . d ( " PromisesArray " , " done " + this + " ( " + ref . getPath ( ) + " ) " ) ; 
 if ( isStarted ) { 
 - throw new RuntimeException ( " Promise already started " ) ; 
 + throw new RuntimeException ( " Promise already started ! " ) ; 
 } 
 isStarted = true ; 
 dispatchActor = ref ; 
 dispatchActor . send ( new PromiseDispatch ( this ) { 
 @ Override 
 public void run ( ) { 
 - exec ( new PromiseResolver < T > ( Promise . this ) ) ; 
 + exec ( new PromiseResolver < T > ( Promise . this , dispatchActor ) ) ; 
 } 
 } ) ; 
 return this ; 
 } 
 
 + / * * 
 + * Main execution method 
 + * 
 + * @ param resolver resolver 
 + * / 
 void exec ( PromiseResolver < T > resolver ) { 
 executor . exec ( resolver ) ; 
 } 
 
 - public boolean isStarted ( ) { 
 - return isStarted ; 
 - } 
 - 
 + / * * 
 + * Cast promise to different type 
 + * 
 + * @ param < R > destination type 
 + * @ return casted promise 
 + * / 
 public < R > Promise < R > cast ( ) { 
 return ( Promise < R > ) this ; 
 } 
 
 - public ActorRef getDispatchActor ( ) { 
 - return dispatchActor ; 
 + / * * 
 + * Getting result if finished 
 + * 
 + * @ return result 
 + * / 
 + public T getResult ( ) { 
 + if ( ! isFinished ) { 
 + throw new RuntimeException ( " Promise is not finished ! " ) ; 
 + } 
 + return result ; 
 } 
 
 - / / public < R > Promise < R > zip ( ArrayFunction < T , R > zip ) { 
 - / / return Promises . zip ( ( Promise < T [ ] > ) this , zip ) ; 
 - / / } 
 - 
 - / / / * * 
 - / / * Getting current dispatcher for promise 
 - / / * 
 - / / * @ return current dispatcher 
 - / / * / 
 - / / public PromiseDispatcher getDispatcher ( ) { 
 - / / return dispatcher ; 
 - / / } 
 - 
 + / * * 
 + * Is promise finished 
 + * 
 + * @ return result 
 + * / 
 public boolean isFinished ( ) { 
 return isFinished ; 
 } 
 
 + / * * 
 + * Exception if promise finished with error 
 + * 
 + * @ return exception 
 + * / 
 public Exception getException ( ) { 
 + if ( ! isFinished ) { 
 + throw new RuntimeException ( " Promise is not finished ! " ) ; 
 + } 
 return exception ; 
 } 
 
 - public T getResult ( ) { 
 - return result ; 
 - } 
 - 
 + / * * 
 + * Mapping result value of promise to another value 
 + * 
 + * @ param res mapping function 
 + * @ param < R > destination type 
 + * @ return promise 
 + * / 
 public < R > Promise < R > map ( Map < T , R > res ) { 
 final Promise < T > self = this ; 
 return new Promise < R > ( ) { 
 @ @ - 238 , 22 + 268 , 15 @ @ public class Promise < T > { 
 self . done ( resolver . getDispatcher ( ) ) ; 
 } 
 } ; 
 - / / return new Promise < > ( executor1 - > { 
 - / / self . then ( t - > { 
 - / / R r ; 
 - / / try { 
 - / / r = res . map ( t ) ; 
 - / / } catch ( Exception e ) { 
 - / / executor1 . tryError ( e ) ; 
 - / / return ; 
 - / / } 
 - / / executor1 . tryResult ( r ) ; 
 - / / } ) ; 
 - / / self . failure ( e - > executor1 . error ( e ) ) ; 
 - / / self . done ( executor1 . getDispatcher ( ) ) ; 
 - / / } ) ; 
 } 
 
 + / * * 
 + * Map result of promise to promise of value 
 + * 
 + * @ param res mapping function 
 + * @ param < R > destination type 
 + * @ return promise 
 + * / 
 public < R > Promise < R > mapPromise ( Map < T , Promise < R > > res ) { 
 final Promise < T > self = this ; 
 return new Promise < R > ( ) { 
 @ @ - 301 , 33 + 324 , 24 @ @ public class Promise < T > { 
 * Delivering result 
 * / 
 private void deliverResult ( ) { 
 - Log . d ( " Promise " , " result : 4 " ) ; 
 if ( callbacks . size ( ) > 0 ) { 
 - Log . d ( " Promise " , " result : 5 " ) ; 
 dispatchActor . send ( new PromiseDispatch ( this ) { 
 @ Override 
 public void run ( ) { 
 - Log . d ( " Promise " , " result : 6 " ) ; 
 if ( exception ! = null ) { 
 - Log . d ( " Promise " , " result : 7 " ) ; 
 for ( PromiseCallback < T > callback : callbacks ) { 
 try { 
 - Log . d ( " Promise " , " result : callback : " + callback ) ; 
 callback . onError ( exception ) ; 
 } catch ( Exception e ) { 
 e . printStackTrace ( ) ; 
 - Log . d ( " Promise " , " result : callback _ error " ) ; 
 } 
 } 
 } else { 
 - Log . d ( " Promise " , " result : 8 " ) ; 
 for ( PromiseCallback < T > callback : callbacks ) { 
 try { 
 - Log . d ( " Promise " , " result : callback : " + callback ) ; 
 callback . onResult ( result ) ; 
 } catch ( Exception e ) { 
 e . printStackTrace ( ) ; 
 - Log . d ( " Promise " , " result : callback _ error2 " ) ; 
 } 
 } 
 } 
 @ @ - 377 , 9 + 391 , 7 @ @ public class Promise < T > { 
 } 
 isFinished = true ; 
 result = res ; 
 - Log . d ( " Promise " , " result : 1 " ) ; 
 deliverResult ( ) ; 
 - Log . d ( " Promise " , " result : 2 " ) ; 
 } 
 
 / * * 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java 
 index 0ccc1e7 . . 95683ef 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatch . java 
 @ @ - 1 , 5 + 1 , 8 @ @ 
 package im . actor . runtime . promise ; 
 
 + / * * 
 + * Actor message that is used in Actor scheduling 
 + * / 
 public abstract class PromiseDispatch implements Runnable { 
 
 private Promise promise ; 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java 
 deleted file mode 100644 
 index 97c7174 . . 0000000 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseDispatcher . java 
 + + + / dev / null 
 @ @ - 1 , 24 + 0 , 0 @ @ 
 - package im . actor . runtime . promise ; 
 - 
 - import im . actor . runtime . actors . ActorRef ; 
 - 
 - public abstract class PromiseDispatcher { 
 - 
 - public abstract void dispatch ( Runnable runnable ) ; 
 - 
 - public static PromiseDispatcher DEFAULT = new PromiseDispatcher ( ) { 
 - @ Override 
 - public void dispatch ( Runnable runnable ) { 
 - im . actor . runtime . Runtime . dispatch ( runnable ) ; 
 - } 
 - } ; 
 - 
 - public static PromiseDispatcher forActor ( final ActorRef ref ) { 
 - return new PromiseDispatcher ( ) { 
 - @ Override 
 - public void dispatch ( Runnable runnable ) { 
 - ref . send ( runnable ) ; 
 - } 
 - } ; 
 - } 
 - } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java 
 index d7965fc . . 6c717db 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseFunc . java 
 @ @ - 1 , 5 + 1 , 11 @ @ 
 package im . actor . runtime . promise ; 
 
 + / * * 
 + * Method that evaluate result of a promise 
 + * 
 + * @ param < T > result type 
 + * / 
 public interface PromiseFunc < T > { 
 + 
 void exec ( PromiseResolver < T > executor ) ; 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java 
 index e910811 . . f672f8d 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromiseResolver . java 
 @ @ - 9 , 14 + 9 , 16 @ @ import im . actor . runtime . actors . ActorRef ; 
 / * * 
 * Object for completing promises 
 * 
 - * @ param < T > 
 + * @ param < T > type of resolver 
 * / 
 public class PromiseResolver < T > { 
 
 private Promise < T > promise ; 
 + private ActorRef dispatcher ; 
 
 - PromiseResolver ( Promise < T > promise ) { 
 + PromiseResolver ( Promise < T > promise , ActorRef dispatcher ) { 
 this . promise = promise ; 
 + this . dispatcher = dispatcher ; 
 } 
 
 / * * 
 @ @ - 28 , 8 + 30 , 13 @ @ public class PromiseResolver < T > { 
 return promise ; 
 } 
 
 + / * * 
 + * Get Resolver ' s dispatcher 
 + * 
 + * @ return dispatcher actor 
 + * / 
 public ActorRef getDispatcher ( ) { 
 - return promise . getDispatchActor ( ) ; 
 + return dispatcher ; 
 } 
 
 / * * 
 @ @ - 38 , 7 + 45 , 6 @ @ public class PromiseResolver < T > { 
 * @ param res result of promise 
 * / 
 public void result ( @ Nullable T res ) { 
 - Log . d ( " Promise " , " Result : " + promise ) ; 
 promise . result ( res ) ; 
 } 
 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 index da44841 . . d9bac86 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / Promises . java 
 @ @ - 1 , 270 + 1 , 112 @ @ 
 package im . actor . runtime . promise ; 
 
 - import org . jetbrains . annotations . NotNull ; 
 - 
 - import java . util . ArrayList ; 
 - import java . util . Collection ; 
 - 
 - import im . actor . runtime . Log ; 
 - import im . actor . runtime . function . ArrayFunction ; 
 import im . actor . runtime . function . Map ; 
 - import im . actor . runtime . function . Consumer ; 
 
 + / * * 
 + * Various methods for creating promises . 
 + * / 
 public class Promises { 
 
 + / * * 
 + * Always success promise 
 + * 
 + * @ param val success value 
 + * @ param < T > type of value 
 + * @ return promise 
 + * / 
 public static < T > Promise < T > success ( final T val ) { 
 return new Promise < T > ( ) { 
 @ Override 
 void exec ( PromiseResolver resolver ) { 
 - Log . d ( " Promises " , " success : " + val ) ; 
 resolver . result ( val ) ; 
 } 
 } ; 
 } 
 
 - public static < T > Promise < T > successNotNull ( final T val ) { 
 - if ( val = = null ) { 
 - throw new RuntimeException ( " Val can ' t be null " ) ; 
 - } 
 - return success ( val ) ; 
 + / * * 
 + * Always failed promise 
 + * 
 + * @ param e fail reason 
 + * @ param < T > type of promise 
 + * @ return promise 
 + * / 
 + public static < T > Promise < T > failure ( final Exception e ) { 
 + return new Promise < T > ( ) { 
 + @ Override 
 + void exec ( PromiseResolver < T > resolver ) { 
 + resolver . error ( e ) ; 
 + } 
 + } ; 
 } 
 
 + / * * 
 + * Combines two promises to one with different data types 
 + * 
 + * @ param t1 first argument 
 + * @ param t2 second argument 
 + * @ param < T1 > first argument type 
 + * @ param < T2 > second argument type 
 + * @ return promise 
 + * / 
 public static < T1 , T2 > Promise < Tuple2 < T1 , T2 > > tuple ( Promise < T1 > t1 , Promise < T2 > t2 ) { 
 - return new Promise < Tuple2 < T1 , T2 > > ( ) { 
 - @ Override 
 - void exec ( PromiseResolver resolver ) { 
 - final Object [ ] res = new Object [ 2 ] ; 
 - final boolean [ ] ended = new boolean [ 2 ] ; 
 - 
 - t1 . then ( t11 - > { 
 - ended [ 0 ] = true ; 
 - res [ 0 ] = t11 ; 
 
 - if ( ended [ 0 ] & & ended [ 1 ] ) { 
 - resolver . result ( new Tuple2 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] ) ) ; 
 + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) ) 
 + . zip ( ) 
 + . map ( new Map < Object [ ] , Tuple2 < T1 , T2 > > ( ) { 
 + @ Override 
 + public Tuple2 < T1 , T2 > map ( Object [ ] src ) { 
 + return new Tuple2 < T1 , T2 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] ) ; 
 } 
 } ) ; 
 - t1 . failure ( e - > resolver . error ( e ) ) ; 
 - 
 - t2 . then ( t11 - > { 
 - ended [ 1 ] = true ; 
 - res [ 1 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] ) { 
 - resolver . result ( new Tuple2 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] ) ) ; 
 - } 
 - } ) ; 
 - t2 . failure ( e - > resolver . error ( e ) ) ; 
 - t1 . done ( resolver . getDispatcher ( ) ) ; 
 - t2 . done ( resolver . getDispatcher ( ) ) ; 
 - } 
 - } ; 
 } 
 
 + / * * 
 + * Combines tree promises to one with different data types 
 + * 
 + * @ param t1 first argument 
 + * @ param t2 second argument 
 + * @ param t3 third argument 
 + * @ param < T1 > first argument type 
 + * @ param < T2 > second argument type 
 + * @ param < T3 > third argument type 
 + * @ return promise 
 + * / 
 public static < T1 , T2 , T3 > Promise < Tuple3 < T1 , T2 , T3 > > tuple ( Promise < T1 > t1 , Promise < T2 > t2 , Promise < T3 > t3 ) { 
 - return new Promise < > ( executor - > { 
 - final Object [ ] res = new Object [ 3 ] ; 
 - final boolean [ ] ended = new boolean [ 3 ] ; 
 - 
 - t1 . then ( t11 - > { 
 - ended [ 0 ] = true ; 
 - res [ 0 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { 
 - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; 
 - } 
 - } ) ; 
 - t1 . failure ( e - > executor . error ( e ) ) ; 
 - t1 . done ( executor . getDispatcher ( ) ) ; 
 - 
 - t2 . then ( t11 - > { 
 - ended [ 1 ] = true ; 
 - res [ 1 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { 
 - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; 
 - } 
 - } ) ; 
 - t2 . failure ( e - > executor . error ( e ) ) ; 
 - t2 . done ( executor . getDispatcher ( ) ) ; 
 - 
 - t3 . then ( t11 - > { 
 - ended [ 2 ] = true ; 
 - res [ 2 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] ) { 
 - executor . result ( new Tuple3 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] ) ) ; 
 - } 
 - } ) ; 
 - t3 . failure ( e - > executor . error ( e ) ) ; 
 - t3 . done ( executor . getDispatcher ( ) ) ; 
 - } ) ; 
 + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) , t3 . cast ( ) ) 
 + . zip ( ) 
 + . map ( new Map < Object [ ] , Tuple3 < T1 , T2 , T3 > > ( ) { 
 + @ Override 
 + public Tuple3 < T1 , T2 , T3 > map ( Object [ ] src ) { 
 + return new Tuple3 < T1 , T2 , T3 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] , ( T3 ) src [ 2 ] ) ; 
 + } 
 + } ) ; 
 } 
 
 + / * * 
 + * Combines four promises to one with different data types 
 + * 
 + * @ param t1 first argument 
 + * @ param t2 second argument 
 + * @ param t3 third argument 
 + * @ param t4 fourth argument 
 + * @ param < T1 > first argument type 
 + * @ param < T2 > second argument type 
 + * @ param < T3 > third argument type 
 + * @ param < T4 > fourth argument type 
 + * @ return promise 
 + * / 
 public static < T1 , T2 , T3 , T4 > Promise < Tuple4 < T1 , T2 , T3 , T4 > > tuple ( Promise < T1 > t1 , 
 Promise < T2 > t2 , 
 Promise < T3 > t3 , 
 Promise < T4 > t4 ) { 
 - return new Promise < > ( executor - > { 
 - final Object [ ] res = new Object [ 4 ] ; 
 - final boolean [ ] ended = new boolean [ 4 ] ; 
 - 
 - t1 . then ( t11 - > { 
 - ended [ 0 ] = true ; 
 - res [ 0 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { 
 - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , 
 - ( T4 ) res [ 3 ] ) ) ; 
 - } 
 - } ) ; 
 - t1 . failure ( e - > executor . error ( e ) ) ; 
 - t1 . done ( executor . getDispatcher ( ) ) ; 
 - 
 - t2 . then ( t11 - > { 
 - ended [ 1 ] = true ; 
 - res [ 1 ] = t11 ; 
 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { 
 - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , 
 - ( T4 ) res [ 3 ] ) ) ; 
 - } 
 - } ) ; 
 - t2 . failure ( e - > executor . error ( e ) ) ; 
 - t2 . done ( executor . getDispatcher ( ) ) ; 
 - 
 - t3 . then ( t11 - > { 
 - ended [ 2 ] = true ; 
 - res [ 2 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { 
 - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , 
 - ( T4 ) res [ 3 ] ) ) ; 
 - } 
 - } ) ; 
 - t3 . failure ( e - > executor . error ( e ) ) ; 
 - t3 . done ( executor . getDispatcher ( ) ) ; 
 - 
 - 
 - t4 . then ( t11 - > { 
 - ended [ 3 ] = true ; 
 - res [ 3 ] = t11 ; 
 - 
 - if ( ended [ 0 ] & & ended [ 1 ] & & ended [ 2 ] & & ended [ 3 ] ) { 
 - executor . result ( new Tuple4 < > ( ( T1 ) res [ 0 ] , ( T2 ) res [ 1 ] , ( T3 ) res [ 2 ] , 
 - ( T4 ) res [ 3 ] ) ) ; 
 - } 
 - } ) ; 
 - t4 . failure ( e - > executor . error ( e ) ) ; 
 - t4 . done ( executor . getDispatcher ( ) ) ; 
 - } ) ; 
 + return PromisesArray . ofPromises ( t1 . cast ( ) , t2 . cast ( ) , t3 . cast ( ) , t4 . cast ( ) ) 
 + . zip ( ) 
 + . map ( new Map < Object [ ] , Tuple4 < T1 , T2 , T3 , T4 > > ( ) { 
 + @ Override 
 + public Tuple4 < T1 , T2 , T3 , T4 > map ( Object [ ] src ) { 
 + return new Tuple4 < T1 , T2 , T3 , T4 > ( ( T1 ) src [ 0 ] , ( T2 ) src [ 1 ] , ( T3 ) src [ 2 ] , ( T4 ) src [ 3 ] ) ; 
 + } 
 + } ) ; 
 } 
 - 
 - / / / * * 
 - / / * Zip promise of array to single object 
 - / / * 
 - / / * @ param zip zip method 
 - / / * @ param promises promises to zip 
 - / / * @ param < T > array element types 
 - / / * @ param < R > result element types 
 - / / * @ return updated promise 
 - / / * / 
 - / / public static < T , R > Promise < R > zip ( final Promise < T [ ] > promises , final ArrayFunction < T , R > zip ) { 
 - / / return new Promise < R > ( ) { 
 - / / @ Override 
 - / / protected void exec ( @ NotNull final PromiseResolver < R > executor ) { 
 - / / promises . complete ( new PromiseCallback < T [ ] > ( ) { 
 - / / @ Override 
 - / / public void onResult ( T [ ] ts ) { 
 - / / R res ; 
 - / / try { 
 - / / res = zip . apply ( ts ) ; 
 - / / } catch ( Exception e ) { 
 - / / e . printStackTrace ( ) ; 
 - / / executor . error ( e ) ; 
 - / / return ; 
 - / / } 
 - / / executor . result ( res ) ; 
 - / / } 
 - / / 
 - / / @ Override 
 - / / public void onError ( Exception e ) { 
 - / / executor . error ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / promises . done ( promises . getDispatchActor ( ) ) ; 
 - / / } 
 - / / } ; 
 - / / } 
 - / / 
 - / / / * * 
 - / / * Combining sequence of promises to one single promise 
 - / / * 
 - / / * @ param promises source promises 
 - / / * @ param < T > type of arguments 
 - / / * @ return result promise 
 - / / * / 
 - / / @ SafeVarargs 
 - / / public static < T > Promise < T [ ] > sequence ( final Promise < T > . . . promises ) { 
 - / / if ( promises . length = = 0 ) { 
 - / / throw new RuntimeException ( " Promises array must not be empty " ) ; 
 - / / } 
 - / / return new Promise < T [ ] > ( ) { 
 - / / @ Override 
 - / / protected void exec ( @ NotNull final PromiseResolver < T [ ] > executor ) { 
 - / / final T [ ] res = ( T [ ] ) new Object [ promises . length ] ; 
 - / / final boolean [ ] isSet = new boolean [ promises . length ] ; 
 - / / final Promise self = this ; 
 - / / for ( int i = 0 ; i < res . length ; i + + ) { 
 - / / final int finalI = i ; 
 - / / promises [ i ] . then ( new Consumer < T > ( ) { 
 - / / @ Override 
 - / / public void apply ( T t ) { 
 - / / if ( self . isFinished ( ) ) { 
 - / / return ; 
 - / / } 
 - / / 
 - / / res [ finalI ] = t ; 
 - / / isSet [ finalI ] = true ; 
 - / / for ( int i = 0 ; i < promises . length ; i + + ) { 
 - / / if ( ! isSet [ i ] ) { 
 - / / return ; 
 - / / } 
 - / / } 
 - / / 
 - / / executor . result ( res ) ; 
 - / / } 
 - / / } ) . failure ( new Consumer < Exception > ( ) { 
 - / / @ Override 
 - / / public void apply ( Exception e ) { 
 - / / if ( self . isFinished ( ) ) { 
 - / / return ; 
 - / / } 
 - / / 
 - / / executor . error ( e ) ; 
 - / / } 
 - / / } ) ; 
 - / / } 
 - / / for ( Promise < T > p : promises ) { 
 - / / p . done ( self . getDispatchActor ( ) ) ; 
 - / / } 
 - / / } 
 - / / } ; 
 - / / } 
 - / / 
 - / / public static < T , C > Promise < T > [ ] map ( Collection < C > items , Map < C , Promise < T > > map ) { 
 - / / ArrayList < Promise < T > > res = new ArrayList < Promise < T > > ( ) ; 
 - / / for ( C c : items ) { 
 - / / res . add ( map . map ( c ) ) ; 
 - / / } 
 - / / return res . toArray ( new Promise [ 0 ] ) ; 
 - / / } 
 - / / 
 - / / public static < T , C > Promise < T > [ ] map ( C [ ] items , Map < C , Promise < T > > map ) { 
 - / / ArrayList < Promise < T > > res = new ArrayList < Promise < T > > ( ) ; 
 - / / for ( C c : items ) { 
 - / / res . add ( map . map ( c ) ) ; 
 - / / } 
 - / / return res . toArray ( new Promise [ 0 ] ) ; 
 - / / } 
 } 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java 
 index 904e866 . . a1253d4 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / promise / PromisesArray . java 
 @ @ - 1 , 16 + 1 , 74 @ @ 
 package im . actor . runtime . promise ; 
 
 import java . util . ArrayList ; 
 + import java . util . Collection ; 
 import java . util . Collections ; 
 - import java . util . List ; 
 
 - import im . actor . runtime . Log ; 
 import im . actor . runtime . function . ArrayFunction ; 
 import im . actor . runtime . function . Consumer ; 
 import im . actor . runtime . function . Function ; 
 
 + / * * 
 + * Array of Promises . Allows you to invoke map , mapPromise and other useful methods 
 + * for manipulating data . 
 + * 
 + * @ param < T > type of array 
 + * / 
 public class PromisesArray < T > { 
 
 + / * * 
 + * Create PromisesArray from collection 
 + * 
 + * @ param collection Source collection 
 + * @ param < T > type of array 
 + * @ return array 
 + * / 
 + public static < T > PromisesArray < T > of ( Collection < T > collection ) { 
 + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 + for ( T t : collection ) { 
 + res . add ( Promises . success ( t ) ) ; 
 + } 
 + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 + } 
 + 
 + / * * 
 + * Create PromisesArray from values 
 + * 
 + * @ param items elements 
 + * @ param < T > type of array 
 + * @ return array 
 + * / 
 + @ SafeVarargs 
 + public static < T > PromisesArray < T > of ( T . . . items ) { 
 + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 + for ( T t : items ) { 
 + res . add ( Promises . success ( t ) ) ; 
 + } 
 + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 + } 
 + 
 + / * * 
 + * Create PromisesArray from multiple Promise 
 + * 
 + * @ param items promises 
 + * @ param < T > type of array 
 + * @ return array 
 + * / 
 + @ SafeVarargs 
 + public static < T > PromisesArray < T > ofPromises ( Promise < T > . . . items ) { 
 + ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 + Collections . addAll ( res , items ) ; 
 + Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 + return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 + } 
 + 
 + 
 + / / 
 + / / Constructors and methods 
 + / / 
 + 
 private Promise < Promise < T > [ ] > promises ; 
 
 private PromisesArray ( Promise < Promise < T > [ ] > promises ) { 
 @ @ - 21 , 58 + 79 , 119 @ @ public class PromisesArray < T > { 
 this ( new Promise < > ( executor ) ) ; 
 } 
 
 + / * * 
 + * Map promises results to new promises 
 + * 
 + * @ param fun mapping function 
 + * @ param < R > type of result promises 
 + * @ return PromisesArray 
 + * / 
 public < R > PromisesArray < R > map ( Function < T , Promise < R > > fun ) { 
 return new PromisesArray < > ( executor - > { 
 + 
 + / / 
 + / / Handling source results 
 + / / 
 + 
 promises . then ( sourcePromises - > { 
 - Log . d ( " PromisesArray " , " 1 " ) ; 
 - / / Starting source promises 
 - for ( int i = 0 ; i < sourcePromises . length ; i + + ) { 
 - sourcePromises [ i ] . done ( executor . getDispatcher ( ) ) ; 
 - } 
 + 
 + / / 
 / / Building mapped promises 
 + / / 
 + 
 final Promise < R > [ ] mappedPromises = new Promise [ sourcePromises . length ] ; 
 + 
 for ( int i = 0 ; i < mappedPromises . length ; i + + ) { 
 final int finalI = i ; 
 final Function < T , Promise < R > > fun2 = fun ; 
 + 
 mappedPromises [ finalI ] = new Promise < R > ( ) { 
 @ Override 
 void exec ( PromiseResolver < R > resolver ) { 
 + 
 + / / 
 + / / Handling results from source PromisesArray 
 + / / 
 + 
 sourcePromises [ finalI ] . then ( new Consumer < T > ( ) { 
 @ Override 
 public void apply ( T t ) { 
 - fun2 . apply ( t ) 
 - . then ( new Consumer < R > ( ) { 
 - @ Override 
 - public void apply ( R r ) { 
 - resolver . result ( r ) ; 
 - } 
 - } ) 
 - . failure ( new Consumer < Exception > ( ) { 
 - @ Override 
 - public void apply ( Exception e ) { 
 - resolver . error ( e ) ; 
 - } 
 - } ) . done ( resolver . getDispatcher ( ) ) ; 
 - ; 
 + 
 + / / 
 + / / Mapping value to promise 
 + / / 
 + Promise < R > mapped = fun2 . apply ( t ) ; 
 + 
 + / / 
 + / / Handling results 
 + / / 
 + mapped . then ( new Consumer < R > ( ) { 
 + @ Override 
 + public void apply ( R r ) { 
 + resolver . result ( r ) ; 
 + } 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + resolver . error ( e ) ; 
 + } 
 + } ) . done ( resolver . getDispatcher ( ) ) ; 
 } 
 } ) ; 
 - sourcePromises [ finalI ] . failure ( e - > { 
 - resolver . error ( e ) ; 
 + 
 + / / 
 + / / Handling failures 
 + / / 
 + 
 + sourcePromises [ finalI ] . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + resolver . error ( e ) ; 
 + } 
 } ) ; 
 + 
 + / / 
 + / / Starting source promise 
 + / / 
 + 
 + sourcePromises [ finalI ] . done ( resolver . getDispatcher ( ) ) ; 
 } 
 } ; 
 } 
 + 
 + / / 
 + / / Returning mapped promises 
 + / / 
 + 
 executor . result ( mappedPromises ) ; 
 - Log . d ( " PromisesArray " , " 5 " ) ; 
 } ) ; 
 - Log . d ( " PromisesArray " , " map : executor : 1 " ) ; 
 - promises . failure ( e - > executor . error ( e ) ) ; 
 - Log . d ( " PromisesArray " , " map : executor : 2 " ) ; 
 + 
 + / / 
 + / / Handling failure 
 + / / 
 + 
 + promises . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + executor . error ( e ) ; 
 + } 
 + } ) ; 
 + 
 + / / 
 + / / Starting source promises 
 + / / 
 + 
 promises . done ( executor . getDispatcher ( ) ) ; 
 - Log . d ( " PromisesArray " , " map : executor : 3 " ) ; 
 } ) ; 
 } 
 
 + / * * 
 + * Zip array to single promise 
 + * 
 + * @ param fuc zipping function 
 + * @ param < R > type of result 
 + * @ return promise 
 + * / 
 public < R > Promise < R > zipPromise ( ArrayFunction < T , Promise < R > > fuc ) { 
 return new Promise < R > ( ) { 
 @ Override 
 @ @ - 113 , 24 + 232 , 6 @ @ public class PromisesArray < T > { 
 promise . done ( resolver . getDispatcher ( ) ) ; 
 } 
 } ) ; 
 - / / promises1 [ i ] . then ( t - > { 
 - / / 
 - / / res [ finalI ] = t ; 
 - / / ended [ finalI ] = true ; 
 - / / 
 - / / for ( int i1 = 0 ; i1 < promises1 . length ; i1 + + ) { 
 - / / if ( ended [ i1 ] = = null | | ! ended [ i1 ] ) { 
 - / / return ; 
 - / / } 
 - / / } 
 - / / 
 - / / / / Promise < R > promise = fuc . apply ( ( T [ ] ) res ) ; 
 - / / / / promise . then ( r - > resolver . result ( r ) ) ; 
 - / / / / promise . failure ( e - > resolver . error ( e ) ) ; 
 - / / / / promise . done ( resolver . getDispatcher ( ) ) ; 
 - / / } ) ; 
 - / / promises1 [ i ] . failure ( e - > resolver . error ( e ) ) ; 
 - / / promises1 [ i ] . done ( resolver . getDispatcher ( ) ) ; 
 promises1 [ i ] . failure ( new Consumer < Exception > ( ) { 
 @ Override 
 public void apply ( Exception e ) { 
 @ @ - 149 , 12 + 250 , 15 @ @ public class PromisesArray < T > { 
 } ) ; 
 
 promises . done ( resolver . getDispatcher ( ) ) ; 
 - / / promises . failure ( e - > resolver . error ( e ) ) ; 
 - / / promises . done ( resolver . getDispatcher ( ) ) ; 
 } 
 } ; 
 } 
 
 + / * * 
 + * Zipping array of promises to single promise of array 
 + * 
 + * @ return promise 
 + * / 
 public Promise < T [ ] > zip ( ) { 
 return zipPromise ( new ArrayFunction < T , Promise < T [ ] > > ( ) { 
 @ Override 
 @ @ - 163 , 31 + 267 , 4 @ @ public class PromisesArray < T > { 
 } 
 } ) ; 
 } 
 - 
 - public static < T > PromisesArray < T > of ( List < T > list ) { 
 - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 - for ( T t : list ) { 
 - res . add ( Promises . success ( t ) ) ; 
 - } 
 - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 - } 
 - 
 - @ SafeVarargs 
 - public static < T > PromisesArray < T > of ( T . . . items ) { 
 - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 - for ( T t : items ) { 
 - res . add ( Promises . success ( t ) ) ; 
 - } 
 - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 - } 
 - 
 - @ SafeVarargs 
 - public static < T > PromisesArray < T > ofPromises ( Promise < T > . . . items ) { 
 - ArrayList < Promise < T > > res = new ArrayList < > ( ) ; 
 - Collections . addAll ( res , items ) ; 
 - Promise [ ] promises = ( Promise [ ] ) res . toArray ( ) ; 
 - return new PromisesArray < > ( executor - > executor . result ( promises ) ) ; 
 - } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java b / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java 
 index 169d0f0 . . 21d6484 100644 
 - - - a / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java 
 + + + b / actor - apps / app - android / src / main / java / im / actor / messenger / app / activity / controllers / MainPhoneController . java 
 @ @ - 125 , 19 + 125 , 21 @ @ public class MainPhoneController extends MainBaseController { 
 
 Intent intent = getIntent ( ) ; 
 if ( intent ! = null ) { 
 - if ( intent . getAction ( ) . equals ( Intent . ACTION _ VIEW ) & & intent . getData ( ) ! = null ) { 
 - joinGroupUrl = getIntent ( ) . getData ( ) . toString ( ) ; 
 - } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND ) ) { 
 - if ( " text / plain " . equals ( getIntent ( ) . getType ( ) ) ) { 
 - sendText = intent . getStringExtra ( Intent . EXTRA _ TEXT ) ; 
 - } else { 
 - sendUriString = intent . getParcelableExtra ( Intent . EXTRA _ STREAM ) . toString ( ) ; 
 - } 
 - } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND _ MULTIPLE ) ) { 
 - ArrayList < Uri > imageUris = intent . getParcelableArrayListExtra ( Intent . EXTRA _ STREAM ) ; 
 - if ( imageUris ! = null ) { 
 - for ( Uri u : imageUris ) { 
 - sendUriMultiple . add ( u . toString ( ) ) ; 
 + if ( intent . getAction ( ) ! = null ) { 
 + if ( intent . getAction ( ) . equals ( Intent . ACTION _ VIEW ) & & intent . getData ( ) ! = null ) { 
 + joinGroupUrl = getIntent ( ) . getData ( ) . toString ( ) ; 
 + } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND ) ) { 
 + if ( " text / plain " . equals ( getIntent ( ) . getType ( ) ) ) { 
 + sendText = intent . getStringExtra ( Intent . EXTRA _ TEXT ) ; 
 + } else { 
 + sendUriString = intent . getParcelableExtra ( Intent . EXTRA _ STREAM ) . toString ( ) ; 
 + } 
 + } else if ( intent . getAction ( ) . equals ( Intent . ACTION _ SEND _ MULTIPLE ) ) { 
 + ArrayList < Uri > imageUris = intent . getParcelableArrayListExtra ( Intent . EXTRA _ STREAM ) ; 
 + if ( imageUris ! = null ) { 
 + for ( Uri u : imageUris ) { 
 + sendUriMultiple . add ( u . toString ( ) ) ; 
 + } 
 } 
 } 
 } 
 diff - - git a / actor - apps / core - android / build . gradle b / actor - apps / core - android / build . gradle 
 index 2a34465 . . 8acee4e 100644 
 - - - a / actor - apps / core - android / build . gradle 
 + + + b / actor - apps / core - android / build . gradle 
 @ @ - 30 , 6 + 30 , 9 @ @ android { 
 ' . . / runtime / src / generic / java ' , 
 ' . . / runtime - android / src / main / java ' ] 
 } 
 + resources { 
 + srcDirs = [ ' . . / core / src / main / resources ' ] 
 + } 
 } 
 } 
 
 diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java b / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java 
 index 703c112 . . 5e1f174 100644 
 - - - a / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java 
 + + + b / actor - apps / core - android / src / main / java / im / actor / core / AndroidMessenger . java 
 @ @ - 27 , 6 + 27 , 8 @ @ import im . actor . core . entity . Peer ; 
 import im . actor . core . entity . SearchEntity ; 
 import im . actor . core . entity . content . FastThumb ; 
 import im . actor . core . network . NetworkState ; 
 + import im . actor . core . utils . AppStateActor ; 
 + import im . actor . core . utils . ImageHelper ; 
 import im . actor . runtime . actors . ActorCreator ; 
 import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . actors . Props ; 
 diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java b / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java 
 deleted file mode 100644 
 index 04ca1ca . . 0000000 
 - - - a / actor - apps / core - android / src / main / java / im / actor / core / AppStateActor . java 
 + + + / dev / null 
 @ @ - 1 , 107 + 0 , 0 @ @ 
 - package im . actor . core ; 
 - 
 - import im . actor . runtime . actors . Actor ; 
 - 
 - / * * 
 - * Created by ex3ndr on 31 . 07 . 15 . 
 - * / 
 - public class AppStateActor extends Actor { 
 - 
 - private static final int CLOSE _ TIMEOUT = 1000 ; 
 - 
 - private final AndroidMessenger messenger ; 
 - 
 - private boolean isAppOpen = false ; 
 - private boolean isScreenVisible = true ; 
 - private int activityCount = 0 ; 
 - 
 - public AppStateActor ( AndroidMessenger messenger ) { 
 - this . messenger = messenger ; 
 - } 
 - 
 - private void onActivityOpened ( ) { 
 - activityCount + + ; 
 - if ( isScreenVisible ) { 
 - onAppProbablyOpened ( ) ; 
 - } 
 - } 
 - 
 - private void onActivityClosed ( ) { 
 - activityCount - - ; 
 - 
 - if ( activityCount = = 0 ) { 
 - onAppProbablyClosed ( ) ; 
 - } 
 - } 
 - 
 - private void onAppProbablyClosed ( ) { 
 - if ( isAppOpen ) { 
 - self ( ) . sendOnce ( new MarkAppAsClosed ( ) , CLOSE _ TIMEOUT ) ; 
 - } 
 - } 
 - 
 - private void onAppProbablyOpened ( ) { 
 - if ( ! isAppOpen ) { 
 - isAppOpen = true ; 
 - onAppOpened ( ) ; 
 - } 
 - self ( ) . sendOnce ( new MarkAppAsClosed ( ) , 24 * 60 * 60 * 1000 ) ; / / Far away 
 - } 
 - 
 - private void onAppOpened ( ) { 
 - messenger . onAppVisible ( ) ; 
 - } 
 - 
 - private void onAppClosed ( ) { 
 - messenger . onAppHidden ( ) ; 
 - } 
 - 
 - private void onScreenOn ( ) { 
 - isScreenVisible = true ; 
 - if ( activityCount > 0 ) { 
 - onAppProbablyOpened ( ) ; 
 - } 
 - } 
 - 
 - public void onScreenOff ( ) { 
 - isScreenVisible = false ; 
 - onAppProbablyClosed ( ) ; 
 - } 
 - 
 - @ Override 
 - public void onReceive ( Object message ) { 
 - if ( message instanceof OnActivityOpened ) { 
 - onActivityOpened ( ) ; 
 - } else if ( message instanceof OnActivityClosed ) { 
 - onActivityClosed ( ) ; 
 - } else if ( message instanceof MarkAppAsClosed ) { 
 - onAppClosed ( ) ; 
 - } else if ( message instanceof OnScreenOn ) { 
 - onScreenOn ( ) ; 
 - } else if ( message instanceof OnScreenOff ) { 
 - onScreenOff ( ) ; 
 - } else { 
 - super . onReceive ( message ) ; 
 - } 
 - } 
 - 
 - private static class MarkAppAsClosed { 
 - 
 - } 
 - 
 - public static class OnActivityOpened { 
 - 
 - } 
 - 
 - public static class OnActivityClosed { 
 - 
 - } 
 - 
 - public static class OnScreenOn { 
 - 
 - } 
 - 
 - public static class OnScreenOff { 
 - 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java b / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java 
 deleted file mode 100644 
 index e5ffc8a . . 0000000 
 - - - a / actor - apps / core - android / src / main / java / im / actor / core / ImageHelper . java 
 + + + / dev / null 
 @ @ - 1 , 248 + 0 , 0 @ @ 
 - / * 
 - * Copyright ( C ) 2015 Actor LLC . < https : / / actor . im > 
 - * / 
 - 
 - package im . actor . core ; 
 - 
 - import android . graphics . Bitmap ; 
 - import android . graphics . BitmapFactory ; 
 - import android . graphics . Canvas ; 
 - import android . graphics . Color ; 
 - import android . graphics . Matrix ; 
 - import android . graphics . Paint ; 
 - import android . graphics . Rect ; 
 - import android . media . ExifInterface ; 
 - import android . os . Build ; 
 - 
 - import java . io . ByteArrayOutputStream ; 
 - import java . io . File ; 
 - import java . io . FileOutputStream ; 
 - import java . io . IOException ; 
 - 
 - public class ImageHelper { 
 - private static final int MAX _ PIXELS = 1200 * 1200 ; 
 - private static final int MAX _ PIXELS _ HQ = 1500 * 1500 ; 
 - 
 - private static final int JPEG _ QUALITY = 80 ; 
 - private static final int JPEG _ QUALITY _ HQ = 90 ; 
 - private static final int JPEG _ QUALITY _ LOW = 55 ; 
 - 
 - public static void save ( Bitmap bitmap , String fileName ) throws IOException { 
 - save ( bitmap , fileName , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ HQ ) ; 
 - } 
 - 
 - public static byte [ ] save ( Bitmap bitmap ) { 
 - return save ( bitmap , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ LOW ) ; 
 - } 
 - 
 - public static Bitmap loadOptimizedHQ ( String fileName ) { 
 - int scale = getScaleFactor ( getImageSize ( fileName ) , MAX _ PIXELS _ HQ ) ; 
 - 
 - BitmapFactory . Options o = new BitmapFactory . Options ( ) ; 
 - 
 - o . inScaled = false ; 
 - o . inSampleSize = scale ; 
 - o . inPreferredConfig = Bitmap . Config . ARGB _ 8888 ; 
 - 
 - if ( Build . VERSION . SDK _ INT > = 10 ) { 
 - o . inPreferQualityOverSpeed = true ; 
 - } 
 - 
 - if ( Build . VERSION . SDK _ INT > = 11 ) { 
 - o . inMutable = true ; 
 - } 
 - 
 - if ( ! new File ( fileName ) . exists ( ) ) { 
 - return null ; 
 - } 
 - 
 - Bitmap res = BitmapFactory . decodeFile ( fileName , o ) ; 
 - if ( res = = null ) { 
 - return null ; 
 - } 
 - 
 - try { 
 - ExifInterface exif = new ExifInterface ( fileName ) ; 
 - String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; 
 - int orientation = 0 ; 
 - if ( exifOrientation ! = null ) { 
 - orientation = Integer . parseInt ( exifOrientation ) ; 
 - } 
 - res = fixExif ( res , orientation ) ; 
 - } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - } 
 - 
 - return res ; 
 - } 
 - 
 - private static Bitmap fixExif ( Bitmap src , int exifOrientation ) { 
 - try { 
 - final Matrix bitmapMatrix = new Matrix ( ) ; 
 - switch ( exifOrientation ) { 
 - case 1 : 
 - break ; / / top left 
 - case 2 : 
 - bitmapMatrix . postScale ( - 1 , 1 ) ; 
 - break ; / / top right 
 - case 3 : 
 - bitmapMatrix . postRotate ( 180 ) ; 
 - break ; / / bottom right 
 - case 4 : 
 - bitmapMatrix . postRotate ( 180 ) ; 
 - bitmapMatrix . postScale ( - 1 , 1 ) ; 
 - break ; / / bottom left 
 - case 5 : 
 - bitmapMatrix . postRotate ( 90 ) ; 
 - bitmapMatrix . postScale ( - 1 , 1 ) ; 
 - break ; / / left top 
 - case 6 : 
 - bitmapMatrix . postRotate ( 90 ) ; 
 - break ; / / right top 
 - case 7 : 
 - bitmapMatrix . postRotate ( 270 ) ; 
 - bitmapMatrix . postScale ( - 1 , 1 ) ; 
 - break ; / / right bottom 
 - case 8 : 
 - bitmapMatrix . postRotate ( 270 ) ; 
 - break ; / / left bottom 
 - default : 
 - break ; / / Unknown 
 - } 
 - 
 - / / Create new bitmap . 
 - return Bitmap . createBitmap ( src , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , bitmapMatrix , false ) ; 
 - } catch ( Exception e ) { 
 - / / TODO : handle exception 
 - } 
 - return null ; 
 - } 
 - 
 - private static int getScaleFactor ( BitmapSize size , int maxPixels ) { 
 - int scale = 1 ; 
 - int scaledW = size . getWidth ( ) ; 
 - int scaledH = size . getHeight ( ) ; 
 - while ( scaledW * scaledH > maxPixels ) { 
 - scale * = 2 ; 
 - scaledH / = 2 ; 
 - scaledW / = 2 ; 
 - } 
 - return scale ; 
 - } 
 - 
 - private static BitmapSize getImageSize ( String fileName ) { 
 - BitmapFactory . Options o = new BitmapFactory . Options ( ) ; 
 - o . inJustDecodeBounds = true ; 
 - BitmapFactory . decodeFile ( fileName , o ) ; 
 - if ( o . outWidth = = 0 | | o . outHeight = = 0 ) { 
 - return null ; 
 - } 
 - 
 - int w = o . outWidth ; 
 - int h = o . outHeight ; 
 - 
 - try { 
 - ExifInterface exif = new ExifInterface ( fileName ) ; 
 - String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; 
 - if ( exifOrientation ! = null ) { 
 - if ( exifOrientation . equals ( " 5 " ) | | 
 - exifOrientation . equals ( " 6 " ) | | 
 - exifOrientation . equals ( " 7 " ) | | 
 - exifOrientation . equals ( " 8 " ) ) { 
 - w = o . outHeight ; 
 - h = o . outWidth ; 
 - 
 - } 
 - } 
 - } catch ( IOException e ) { 
 - / / e . printStackTrace ( ) ; 
 - } 
 - 
 - return new BitmapSize ( w , h ) ; 
 - } 
 - 
 - private static byte [ ] save ( Bitmap src , Bitmap . CompressFormat format , int quality ) { 
 - ByteArrayOutputStream outputStream = null ; 
 - try { 
 - outputStream = new ByteArrayOutputStream ( ) ; 
 - src . compress ( format , quality , outputStream ) ; 
 - return outputStream . toByteArray ( ) ; 
 - } finally { 
 - if ( outputStream ! = null ) { 
 - try { 
 - outputStream . close ( ) ; 
 - } catch ( IOException e1 ) { 
 - e1 . printStackTrace ( ) ; 
 - } 
 - } 
 - } 
 - } 
 - 
 - private static void save ( Bitmap src , String fileName , Bitmap . CompressFormat format , int quality ) throws IOException { 
 - FileOutputStream outputStream = null ; 
 - try { 
 - outputStream = new FileOutputStream ( fileName ) ; 
 - src . compress ( format , quality , outputStream ) ; 
 - outputStream . close ( ) ; 
 - } finally { 
 - if ( outputStream ! = null ) { 
 - try { 
 - outputStream . close ( ) ; 
 - } catch ( IOException e1 ) { 
 - e1 . printStackTrace ( ) ; 
 - } 
 - } 
 - } 
 - } 
 - 
 - public static Bitmap scaleFit ( Bitmap src , int maxW , int maxH ) { 
 - float ratio = Math . min ( maxW / ( float ) src . getWidth ( ) , maxH / ( float ) src . getHeight ( ) ) ; 
 - int newW = ( int ) ( src . getWidth ( ) * ratio ) ; 
 - int newH = ( int ) ( src . getHeight ( ) * ratio ) ; 
 - return scale ( src , newW , newH ) ; 
 - } 
 - 
 - private static Bitmap scale ( Bitmap src , int dw , int dh ) { 
 - Bitmap res = Bitmap . createBitmap ( dw , dh , Bitmap . Config . ARGB _ 8888 ) ; 
 - scale ( src , res ) ; 
 - return res ; 
 - } 
 - 
 - private static void scale ( Bitmap src , Bitmap dest ) { 
 - scale ( src , dest , Color . TRANSPARENT ) ; 
 - } 
 - 
 - private static void scale ( Bitmap src , Bitmap dest , int clearColor ) { 
 - scale ( src , dest , clearColor , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , 0 , 0 , dest . getWidth ( ) , dest . getHeight ( ) ) ; 
 - } 
 - 
 - private static void scale ( Bitmap src , Bitmap dest , int clearColor , 
 - int x , int y , int sw , int sh , 
 - int dx , int dy , 
 - int dw , int dh ) { 
 - dest . eraseColor ( clearColor ) ; 
 - Canvas canvas = new Canvas ( dest ) ; 
 - Paint paint = new Paint ( ) ; 
 - paint . setFilterBitmap ( true ) ; 
 - canvas . drawBitmap ( src , new Rect ( x + 1 , y + 1 , sw - 1 , sh - 1 ) , new Rect ( dx , dy , dw , dh ) , paint ) ; 
 - canvas . setBitmap ( null ) ; 
 - } 
 - 
 - private static class BitmapSize { 
 - private int width ; 
 - private int height ; 
 - 
 - private BitmapSize ( int width , int height ) { 
 - this . width = width ; 
 - this . height = height ; 
 - } 
 - 
 - public int getWidth ( ) { 
 - return width ; 
 - } 
 - 
 - public int getHeight ( ) { 
 - return height ; 
 - } 
 - } 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java b / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java 
 new file mode 100644 
 index 0000000 . . 94c0b08 
 - - - / dev / null 
 + + + b / actor - apps / core - android / src / main / java / im / actor / core / utils / AppStateActor . java 
 @ @ - 0 , 0 + 1 , 108 @ @ 
 + package im . actor . core . utils ; 
 + 
 + import im . actor . core . AndroidMessenger ; 
 + import im . actor . runtime . actors . Actor ; 
 + 
 + / * * 
 + * Created by ex3ndr on 31 . 07 . 15 . 
 + * / 
 + public class AppStateActor extends Actor { 
 + 
 + private static final int CLOSE _ TIMEOUT = 1000 ; 
 + 
 + private final AndroidMessenger messenger ; 
 + 
 + private boolean isAppOpen = false ; 
 + private boolean isScreenVisible = true ; 
 + private int activityCount = 0 ; 
 + 
 + public AppStateActor ( AndroidMessenger messenger ) { 
 + this . messenger = messenger ; 
 + } 
 + 
 + private void onActivityOpened ( ) { 
 + activityCount + + ; 
 + if ( isScreenVisible ) { 
 + onAppProbablyOpened ( ) ; 
 + } 
 + } 
 + 
 + private void onActivityClosed ( ) { 
 + activityCount - - ; 
 + 
 + if ( activityCount = = 0 ) { 
 + onAppProbablyClosed ( ) ; 
 + } 
 + } 
 + 
 + private void onAppProbablyClosed ( ) { 
 + if ( isAppOpen ) { 
 + self ( ) . sendOnce ( new MarkAppAsClosed ( ) , CLOSE _ TIMEOUT ) ; 
 + } 
 + } 
 + 
 + private void onAppProbablyOpened ( ) { 
 + if ( ! isAppOpen ) { 
 + isAppOpen = true ; 
 + onAppOpened ( ) ; 
 + } 
 + self ( ) . sendOnce ( new MarkAppAsClosed ( ) , 24 * 60 * 60 * 1000 ) ; / / Far away 
 + } 
 + 
 + private void onAppOpened ( ) { 
 + messenger . onAppVisible ( ) ; 
 + } 
 + 
 + private void onAppClosed ( ) { 
 + messenger . onAppHidden ( ) ; 
 + } 
 + 
 + private void onScreenOn ( ) { 
 + isScreenVisible = true ; 
 + if ( activityCount > 0 ) { 
 + onAppProbablyOpened ( ) ; 
 + } 
 + } 
 + 
 + public void onScreenOff ( ) { 
 + isScreenVisible = false ; 
 + onAppProbablyClosed ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + if ( message instanceof OnActivityOpened ) { 
 + onActivityOpened ( ) ; 
 + } else if ( message instanceof OnActivityClosed ) { 
 + onActivityClosed ( ) ; 
 + } else if ( message instanceof MarkAppAsClosed ) { 
 + onAppClosed ( ) ; 
 + } else if ( message instanceof OnScreenOn ) { 
 + onScreenOn ( ) ; 
 + } else if ( message instanceof OnScreenOff ) { 
 + onScreenOff ( ) ; 
 + } else { 
 + super . onReceive ( message ) ; 
 + } 
 + } 
 + 
 + private static class MarkAppAsClosed { 
 + 
 + } 
 + 
 + public static class OnActivityOpened { 
 + 
 + } 
 + 
 + public static class OnActivityClosed { 
 + 
 + } 
 + 
 + public static class OnScreenOn { 
 + 
 + } 
 + 
 + public static class OnScreenOff { 
 + 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java b / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java 
 new file mode 100644 
 index 0000000 . . 40b42bd 
 - - - / dev / null 
 + + + b / actor - apps / core - android / src / main / java / im / actor / core / utils / ImageHelper . java 
 @ @ - 0 , 0 + 1 , 248 @ @ 
 + / * 
 + * Copyright ( C ) 2015 Actor LLC . < https : / / actor . im > 
 + * / 
 + 
 + package im . actor . core . utils ; 
 + 
 + import android . graphics . Bitmap ; 
 + import android . graphics . BitmapFactory ; 
 + import android . graphics . Canvas ; 
 + import android . graphics . Color ; 
 + import android . graphics . Matrix ; 
 + import android . graphics . Paint ; 
 + import android . graphics . Rect ; 
 + import android . media . ExifInterface ; 
 + import android . os . Build ; 
 + 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . File ; 
 + import java . io . FileOutputStream ; 
 + import java . io . IOException ; 
 + 
 + public class ImageHelper { 
 + private static final int MAX _ PIXELS = 1200 * 1200 ; 
 + private static final int MAX _ PIXELS _ HQ = 1500 * 1500 ; 
 + 
 + private static final int JPEG _ QUALITY = 80 ; 
 + private static final int JPEG _ QUALITY _ HQ = 90 ; 
 + private static final int JPEG _ QUALITY _ LOW = 55 ; 
 + 
 + public static void save ( Bitmap bitmap , String fileName ) throws IOException { 
 + save ( bitmap , fileName , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ HQ ) ; 
 + } 
 + 
 + public static byte [ ] save ( Bitmap bitmap ) { 
 + return save ( bitmap , Bitmap . CompressFormat . JPEG , JPEG _ QUALITY _ LOW ) ; 
 + } 
 + 
 + public static Bitmap loadOptimizedHQ ( String fileName ) { 
 + int scale = getScaleFactor ( getImageSize ( fileName ) , MAX _ PIXELS _ HQ ) ; 
 + 
 + BitmapFactory . Options o = new BitmapFactory . Options ( ) ; 
 + 
 + o . inScaled = false ; 
 + o . inSampleSize = scale ; 
 + o . inPreferredConfig = Bitmap . Config . ARGB _ 8888 ; 
 + 
 + if ( Build . VERSION . SDK _ INT > = 10 ) { 
 + o . inPreferQualityOverSpeed = true ; 
 + } 
 + 
 + if ( Build . VERSION . SDK _ INT > = 11 ) { 
 + o . inMutable = true ; 
 + } 
 + 
 + if ( ! new File ( fileName ) . exists ( ) ) { 
 + return null ; 
 + } 
 + 
 + Bitmap res = BitmapFactory . decodeFile ( fileName , o ) ; 
 + if ( res = = null ) { 
 + return null ; 
 + } 
 + 
 + try { 
 + ExifInterface exif = new ExifInterface ( fileName ) ; 
 + String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; 
 + int orientation = 0 ; 
 + if ( exifOrientation ! = null ) { 
 + orientation = Integer . parseInt ( exifOrientation ) ; 
 + } 
 + res = fixExif ( res , orientation ) ; 
 + } catch ( IOException e ) { 
 + / / e . printStackTrace ( ) ; 
 + } 
 + 
 + return res ; 
 + } 
 + 
 + private static Bitmap fixExif ( Bitmap src , int exifOrientation ) { 
 + try { 
 + final Matrix bitmapMatrix = new Matrix ( ) ; 
 + switch ( exifOrientation ) { 
 + case 1 : 
 + break ; / / top left 
 + case 2 : 
 + bitmapMatrix . postScale ( - 1 , 1 ) ; 
 + break ; / / top right 
 + case 3 : 
 + bitmapMatrix . postRotate ( 180 ) ; 
 + break ; / / bottom right 
 + case 4 : 
 + bitmapMatrix . postRotate ( 180 ) ; 
 + bitmapMatrix . postScale ( - 1 , 1 ) ; 
 + break ; / / bottom left 
 + case 5 : 
 + bitmapMatrix . postRotate ( 90 ) ; 
 + bitmapMatrix . postScale ( - 1 , 1 ) ; 
 + break ; / / left top 
 + case 6 : 
 + bitmapMatrix . postRotate ( 90 ) ; 
 + break ; / / right top 
 + case 7 : 
 + bitmapMatrix . postRotate ( 270 ) ; 
 + bitmapMatrix . postScale ( - 1 , 1 ) ; 
 + break ; / / right bottom 
 + case 8 : 
 + bitmapMatrix . postRotate ( 270 ) ; 
 + break ; / / left bottom 
 + default : 
 + break ; / / Unknown 
 + } 
 + 
 + / / Create new bitmap . 
 + return Bitmap . createBitmap ( src , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , bitmapMatrix , false ) ; 
 + } catch ( Exception e ) { 
 + / / TODO : handle exception 
 + } 
 + return null ; 
 + } 
 + 
 + private static int getScaleFactor ( BitmapSize size , int maxPixels ) { 
 + int scale = 1 ; 
 + int scaledW = size . getWidth ( ) ; 
 + int scaledH = size . getHeight ( ) ; 
 + while ( scaledW * scaledH > maxPixels ) { 
 + scale * = 2 ; 
 + scaledH / = 2 ; 
 + scaledW / = 2 ; 
 + } 
 + return scale ; 
 + } 
 + 
 + private static BitmapSize getImageSize ( String fileName ) { 
 + BitmapFactory . Options o = new BitmapFactory . Options ( ) ; 
 + o . inJustDecodeBounds = true ; 
 + BitmapFactory . decodeFile ( fileName , o ) ; 
 + if ( o . outWidth = = 0 | | o . outHeight = = 0 ) { 
 + return null ; 
 + } 
 + 
 + int w = o . outWidth ; 
 + int h = o . outHeight ; 
 + 
 + try { 
 + ExifInterface exif = new ExifInterface ( fileName ) ; 
 + String exifOrientation = exif . getAttribute ( ExifInterface . TAG _ ORIENTATION ) ; 
 + if ( exifOrientation ! = null ) { 
 + if ( exifOrientation . equals ( " 5 " ) | | 
 + exifOrientation . equals ( " 6 " ) | | 
 + exifOrientation . equals ( " 7 " ) | | 
 + exifOrientation . equals ( " 8 " ) ) { 
 + w = o . outHeight ; 
 + h = o . outWidth ; 
 + 
 + } 
 + } 
 + } catch ( IOException e ) { 
 + / / e . printStackTrace ( ) ; 
 + } 
 + 
 + return new BitmapSize ( w , h ) ; 
 + } 
 + 
 + private static byte [ ] save ( Bitmap src , Bitmap . CompressFormat format , int quality ) { 
 + ByteArrayOutputStream outputStream = null ; 
 + try { 
 + outputStream = new ByteArrayOutputStream ( ) ; 
 + src . compress ( format , quality , outputStream ) ; 
 + return outputStream . toByteArray ( ) ; 
 + } finally { 
 + if ( outputStream ! = null ) { 
 + try { 
 + outputStream . close ( ) ; 
 + } catch ( IOException e1 ) { 
 + e1 . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + private static void save ( Bitmap src , String fileName , Bitmap . CompressFormat format , int quality ) throws IOException { 
 + FileOutputStream outputStream = null ; 
 + try { 
 + outputStream = new FileOutputStream ( fileName ) ; 
 + src . compress ( format , quality , outputStream ) ; 
 + outputStream . close ( ) ; 
 + } finally { 
 + if ( outputStream ! = null ) { 
 + try { 
 + outputStream . close ( ) ; 
 + } catch ( IOException e1 ) { 
 + e1 . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 + } 
 + 
 + public static Bitmap scaleFit ( Bitmap src , int maxW , int maxH ) { 
 + float ratio = Math . min ( maxW / ( float ) src . getWidth ( ) , maxH / ( float ) src . getHeight ( ) ) ; 
 + int newW = ( int ) ( src . getWidth ( ) * ratio ) ; 
 + int newH = ( int ) ( src . getHeight ( ) * ratio ) ; 
 + return scale ( src , newW , newH ) ; 
 + } 
 + 
 + private static Bitmap scale ( Bitmap src , int dw , int dh ) { 
 + Bitmap res = Bitmap . createBitmap ( dw , dh , Bitmap . Config . ARGB _ 8888 ) ; 
 + scale ( src , res ) ; 
 + return res ; 
 + } 
 + 
 + private static void scale ( Bitmap src , Bitmap dest ) { 
 + scale ( src , dest , Color . TRANSPARENT ) ; 
 + } 
 + 
 + private static void scale ( Bitmap src , Bitmap dest , int clearColor ) { 
 + scale ( src , dest , clearColor , 0 , 0 , src . getWidth ( ) , src . getHeight ( ) , 0 , 0 , dest . getWidth ( ) , dest . getHeight ( ) ) ; 
 + } 
 + 
 + private static void scale ( Bitmap src , Bitmap dest , int clearColor , 
 + int x , int y , int sw , int sh , 
 + int dx , int dy , 
 + int dw , int dh ) { 
 + dest . eraseColor ( clearColor ) ; 
 + Canvas canvas = new Canvas ( dest ) ; 
 + Paint paint = new Paint ( ) ; 
 + paint . setFilterBitmap ( true ) ; 
 + canvas . drawBitmap ( src , new Rect ( x + 1 , y + 1 , sw - 1 , sh - 1 ) , new Rect ( dx , dy , dw , dh ) , paint ) ; 
 + canvas . setBitmap ( null ) ; 
 + } 
 + 
 + private static class BitmapSize { 
 + private int width ; 
 + private int height ; 
 + 
 + private BitmapSize ( int width , int height ) { 
 + this . width = width ; 
 + this . height = height ; 
 + } 
 + 
 + public int getWidth ( ) { 
 + return width ; 
 + } 
 + 
 + public int getHeight ( ) { 
 + return height ; 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java b / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java 
 index 237178a . . f419e3a 100644 
 - - - a / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java 
 + + + b / actor - apps / core / src / main / java / im / actor / core / i18n / LocaleLoader . java 
 @ @ - 15 , 7 + 15 , 9 @ @ public class LocaleLoader { 
 continue ; 
 } 
 String [ ] lineVal = line . split ( " = " , 2 ) ; 
 - res . put ( lineVal [ 0 ] , lineVal [ 1 ] ) ; 
 + if ( lineVal . length = = 2 ) { 
 + res . put ( lineVal [ 0 ] , lineVal [ 1 ] ) ; 
 + } 
 } 
 return res ; 
 } 
 diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java 
 index 6249b44 . . 59036ec 100644 
 - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java 
 + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LocaleRuntimeProvider . java 
 @ @ - 1 , 23 + 1 , 7 @ @ 
 package im . actor . runtime ; 
 
 - public class LocaleRuntimeProvider implements LocaleRuntime { 
 - @ Override 
 - public String getCurrentLocale ( ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 + import im . actor . runtime . android . AndroidLocaleProvider ; 
 
 - @ Override 
 - public boolean is24Hours ( ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 + public class LocaleRuntimeProvider extends AndroidLocaleProvider { 
 
 - @ Override 
 - public String formatDate ( long date ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 - 
 - @ Override 
 - public String formatTime ( long date ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 } 
 diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java 
 index f777d54 . . c7e8924 100644 
 - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java 
 + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / LogRuntimeProvider . java 
 @ @ - 4 , 23 + 4 , 4 @ @ import im . actor . runtime . android . AndroidLogProvider ; 
 
 public class LogRuntimeProvider extends AndroidLogProvider { 
 
 - @ Override 
 - public void w ( String tag , String message ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 - 
 - @ Override 
 - public void e ( String tag , Throwable throwable ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 - 
 - @ Override 
 - public void d ( String tag , String message ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 - 
 - @ Override 
 - public void v ( String tag , String message ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 } 
 diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java 
 index 1ee7313 . . 106489b 100644 
 - - - a / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java 
 + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / NetworkRuntimeProvider . java 
 @ @ - 1 , 12 + 1 , 7 @ @ 
 package im . actor . runtime ; 
 
 - import im . actor . runtime . mtproto . ConnectionCallback ; 
 - import im . actor . runtime . mtproto . ConnectionEndpoint ; 
 - import im . actor . runtime . mtproto . CreateConnectionCallback ; 
 + import im . actor . core . runtime . generic . GenericNetworkProvider ; 
 + 
 + public class NetworkRuntimeProvider extends GenericNetworkProvider { 
 
 - public class NetworkRuntimeProvider implements NetworkRuntime { 
 - @ Override 
 - public void createConnection ( int connectionId , int mtprotoVersion , int apiMajorVersion , int apiMinorVersion , ConnectionEndpoint endpoint , ConnectionCallback callback , CreateConnectionCallback createCallback ) { 
 - throw new RuntimeException ( " Dumb " ) ; 
 - } 
 } 
 diff - - git a / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java b / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java 
 new file mode 100644 
 index 0000000 . . 11eb081 
 - - - / dev / null 
 + + + b / actor - apps / runtime - android / src / main / java / im / actor / runtime / android / AndroidLocaleProvider . java 
 @ @ - 0 , 0 + 1 , 29 @ @ 
 + package im . actor . runtime . android ; 
 + 
 + import java . text . DateFormat ; 
 + import java . util . Date ; 
 + 
 + import im . actor . runtime . LocaleRuntime ; 
 + 
 + / * * 
 + * Created by ex3ndr on 10 . 08 . 15 . 
 + * / 
 + public class AndroidLocaleProvider implements LocaleRuntime { 
 + 
 + @ Override 
 + public String getCurrentLocale ( ) { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public String formatDate ( long date ) { 
 + DateFormat dateFormat = android . text . format . DateFormat . getDateFormat ( AndroidContext . getContext ( ) ) ; 
 + return dateFormat . format ( new Date ( date ) ) ; 
 + } 
 + 
 + @ Override 
 + public String formatTime ( long date ) { 
 + DateFormat dateFormat = android . text . format . DateFormat . getTimeFormat ( AndroidContext . getContext ( ) ) ; 
 + return dateFormat . format ( new Date ( date ) ) ; 
 + } 
 + } 
 diff - - git a / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java b / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java 
 index daa69db . . 92bde84 100644 
 - - - a / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java 
 + + + b / actor - apps / runtime / src / generic / java / im / actor / core / runtime / generic / GenericAssetsProvider . java 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . core . runtime . generic ; 
 
 + import java . io . ByteArrayOutputStream ; 
 + import java . io . IOException ; 
 import java . io . InputStream ; 
 
 import im . actor . runtime . AssetsRuntime ; 
 @ @ - 17 , 7 + 19 , 33 @ @ public class GenericAssetsProvider implements AssetsRuntime { 
 @ Override 
 public String loadAsset ( String name ) { 
 InputStream stream = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( name ) ; 
 - / / TODO : Read all 
 + try { 
 + return readFully ( stream , " UTF - 8 " ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } finally { 
 + if ( stream ! = null ) { 
 + try { 
 + stream . close ( ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 + } 
 + } 
 return null ; 
 } 
 + 
 + public String readFully ( InputStream inputStream , String encoding ) throws IOException { 
 + return new String ( readFully ( inputStream ) , encoding ) ; 
 + } 
 + 
 + private byte [ ] readFully ( InputStream inputStream ) throws IOException { 
 + ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
 + byte [ ] buffer = new byte [ 1024 ] ; 
 + int length = 0 ; 
 + while ( ( length = inputStream . read ( buffer ) ) ! = - 1 ) { 
 + baos . write ( buffer , 0 , length ) ; 
 + } 
 + return baos . toByteArray ( ) ; 
 + } 
 } 
 diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java b / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java 
 index 704579d . . 6eb8675 100644 
 - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java 
 + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / LocaleRuntime . java 
 @ @ - 13 , 15 + 13 , 6 @ @ public interface LocaleRuntime { 
 String getCurrentLocale ( ) ; 
 
 / * * 
 - * Is local settings use 24 hours format 
 - * 
 - * @ return is 24 hour format 
 - * / 
 - @ ObjectiveCName ( " is24Hours " ) 
 - boolean is24Hours ( ) ; 
 - 
 - 
 - / * * 
 * Format date 
 * 
 * @ param date date value 
 diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java b / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java 
 index 9a4ad01 . . 9512332 100644 
 - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java 
 + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / Log . java 
 @ @ - 2 , 21 + 2 , 21 @ @ package im . actor . runtime ; 
 
 public final class Log { 
 
 - private static final LogRuntime log = Runtime . getLogRuntime ( ) ; 
 + private static final LogRuntime logRuntime = new LogRuntimeProvider ( ) ; 
 
 public static void w ( String tag , String message ) { 
 - log . w ( tag , message ) ; 
 + logRuntime . w ( tag , message ) ; 
 } 
 
 public static void e ( String tag , Throwable throwable ) { 
 - log . e ( tag , throwable ) ; 
 + logRuntime . e ( tag , throwable ) ; 
 } 
 
 public static void d ( String tag , String message ) { 
 - log . d ( tag , message ) ; 
 + logRuntime . d ( tag , message ) ; 
 } 
 
 public static void v ( String tag , String message ) { 
 - log . v ( tag , message ) ; 
 + logRuntime . v ( tag , message ) ; 
 } 
 } 
 diff - - git a / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java b / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java 
 index 7bef7b4 . . 63c27b3 100644 
 - - - a / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java 
 + + + b / actor - apps / runtime / src / main / java / im / actor / runtime / Runtime . java 
 @ @ - 15 , 15 + 15 , 11 @ @ public class Runtime { 
 private static final MainThreadRuntimeProvider mainThreadRuntime = new MainThreadRuntimeProvider ( ) ; 
 private static final LifecycleRuntime lifecycleRuntime = new LifecycleRuntimeProvider ( ) ; 
 private static final LocaleRuntime localeRuntime = new LocaleRuntimeProvider ( ) ; 
 - private static final LogRuntime logRuntime = new LogRuntimeProvider ( ) ; 
 
 public static LocaleRuntime getLocaleRuntime ( ) { 
 return localeRuntime ; 
 } 
 
 - public static LogRuntime getLogRuntime ( ) { 
 - return logRuntime ; 
 - } 
 
 public static ActorDispatcher createDefaultDispatcher ( String name , ThreadPriority priority , ActorSystem actorSystem ) { 
 return threadingRuntime . createDefaultDispatcher ( name , priority , actorSystem ) ; 
 diff - - git a / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java b / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java 
 index 9a351dc . . 2db9dad 100644 
 - - - a / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java 
 + + + b / actor - apps / runtime / src / template / java / im / actor / runtime / LogRuntimeProvider . java 
 @ @ - 4 , 6 + 4 , 7 @ @ package im . actor . runtime ; 
 * Created by ex3ndr on 07 . 08 . 15 . 
 * / 
 public class LogRuntimeProvider implements LogRuntime { 
 + 
 @ Override 
 public void w ( String tag , String message ) { 
 throw new RuntimeException ( " Dumb " ) ;
