BLEU SCORE: 0.016932492841722675

TEST MSG: chore : migrate journal to the new akka - persistence - jdbc
GENERATED MSG: Merge commit ' 9492e7b167aa4743660fc1a3a7f7facd6df5825c '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala < nl > new file mode 100644 < nl > index 0000000 . . 3cba2dc < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala < nl > @ @ - 0 , 0 + 1 , 22 @ @ < nl > + package im . actor . server . cqrs < nl > + < nl > + import akka . actor . ExtendedActorSystem < nl > + import akka . persistence . journal . { Tagged , EventSeq , EventAdapter } < nl > + < nl > + final class ActorEventAdapter ( system : ExtendedActorSystem ) extends EventAdapter { < nl > + override def manifest ( event : Any ) : String = " V1 " < nl > + < nl > + override def toJournal ( event : Any ) : Any = { < nl > + event match { < nl > + case e : TaggedEvent ⇒ Tagged ( e , e . tags ) < nl > + case _ ⇒ event < nl > + } < nl > + } < nl > + < nl > + override def fromJournal ( event : Any , manifest : String ) : EventSeq = < nl > + event match { < nl > + case e : AnyRef ⇒ EventSeq ( e ) < nl > + case _ ⇒ throw new IllegalArgumentException ( s " Supported AnyRef but got : $ { event . getClass } " ) < nl > + } < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala < nl > new file mode 100644 < nl > index 0000000 . . 7dd7366 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala < nl > @ @ - 0 , 0 + 1 , 7 @ @ < nl > + package im . actor . server . cqrs < nl > + < nl > + trait Event < nl > + < nl > + trait TaggedEvent extends Event { < nl > + def tags : Set [ String ] < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index 6d7bbe0 . . b70d905 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 10 , 6 + 10 , 7 @ @ import akka . util . Timeout < nl > import im . actor . api . rpc . collections . ApiMapValue < nl > import im . actor . serialization . ActorSerializer < nl > import im . actor . server . KeyValueMappings < nl > + import im . actor . server . cqrs . TaggedEvent < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } < nl > import im . actor . server . file . { FileStorageExtension , FileStorageAdapter , Avatar } < nl > @ @ - 57 , 8 + 58 , 10 @ @ trait GroupCommand { < nl > val groupId : Int < nl > } < nl > < nl > - trait GroupEvent { < nl > + trait GroupEvent extends TaggedEvent { < nl > val ts : Instant < nl > + < nl > + override def tags : Set [ String ] = Set ( " group " ) < nl > } < nl > < nl > trait GroupQuery { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index 23a10f4 . . bdad712 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 9 , 6 + 9 , 7 @ @ import akka . util . Timeout < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . serialization . ActorSerializer < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . cqrs . TaggedEvent < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . { DialogCommand , DialogExtension } < nl > import im . actor . server . office . { PeerProcessor , StopOffice } < nl > @ @ - 20 , 8 + 21 , 10 @ @ import slick . driver . PostgresDriver . api . _ < nl > import scala . concurrent . ExecutionContext < nl > import scala . concurrent . duration . _ < nl > < nl > - trait UserEvent { < nl > + trait UserEvent extends TaggedEvent { < nl > val ts : Instant < nl > + < nl > + def tags : Set [ String ] = Set ( " user " ) < nl > } < nl > < nl > trait UserCommand { < nl > diff - - git a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > index 0e60a14 . . 6e8a850 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > + + + b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala < nl > @ @ - 1 , 17 + 1 , 26 @ @ < nl > package sql . migration < nl > < nl > import java . sql . Connection < nl > + import java . time . Instant < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . persistence . PersistentRepr < nl > - import akka . serialization . SerializationExtension < nl > + import akka . persistence . jdbc . serialization . SerializationFacade < nl > + import akka . persistence . journal . Tagged < nl > + import akka . persistence . { AtomicWrite , PersistentRepr } < nl > + import akka . serialization . { Serialization , SerializationExtension } < nl > + import akka . stream . ActorMaterializer < nl > + import akka . stream . scaladsl . Source < nl > + import im . actor . serialization . ActorSerializer < nl > import im . actor . server . CommonSerialization < nl > - import im . actor . server . group . GroupProcessor < nl > - import im . actor . server . user . UserProcessor < nl > + import im . actor . server . event . TSEvent < nl > + import im . actor . server . group . { GroupEvent , GroupProcessor } < nl > + import im . actor . server . user . { UserEvent , UserProcessor } < nl > import org . flywaydb . core . api . migration . jdbc . JdbcMigration < nl > + import org . joda . time . DateTime < nl > + import shardakka . keyvalue . { ValueEvents , ValueQueries , ValueCommands , RootEvents } < nl > < nl > - import scala . concurrent . Await < nl > + import scala . concurrent . _ < nl > import scala . concurrent . duration . Duration < nl > < nl > final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { < nl > @ @ - 19 , 28 + 28 , 203 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { < nl > CommonSerialization . register ( ) < nl > GroupProcessor . register ( ) < nl > UserProcessor . register ( ) < nl > + ActorSerializer . register ( 5201 , classOf [ RootEvents . KeyCreated ] ) < nl > + ActorSerializer . register ( 5202 , classOf [ RootEvents . KeyDeleted ] ) < nl > + < nl > + ActorSerializer . register ( 5301 , classOf [ ValueCommands . Upsert ] ) < nl > + ActorSerializer . register ( 5302 , classOf [ ValueCommands . Delete ] ) < nl > + ActorSerializer . register ( 5303 , classOf [ ValueCommands . Ack ] ) < nl > + < nl > + ActorSerializer . register ( 5401 , classOf [ ValueQueries . Get ] ) < nl > + ActorSerializer . register ( 5402 , classOf [ ValueQueries . GetResponse ] ) < nl > + < nl > + ActorSerializer . register ( 5501 , classOf [ ValueEvents . ValueUpdated ] ) < nl > + ActorSerializer . register ( 5502 , classOf [ ValueEvents . ValueDeleted ] ) < nl > < nl > override def migrate ( connection : Connection ) : Unit = { < nl > - val system = ActorSystem ( " migration " ) < nl > - val serialization = SerializationExtension ( system ) < nl > - < nl > - val stmt = connection . prepareStatement ( " SELECT persistence _ id , sequence _ number , marker , message , created FROM journal LIMIT 10 " ) < nl > - val rs = stmt . executeQuery ( ) < nl > - < nl > - while ( rs . next ( ) ) { < nl > - val persistenceId = rs . getString ( " persistence _ id " ) < nl > - println ( s " = = = $ { persistenceId } " ) < nl > - val sequenceNumber = rs . getLong ( " sequence _ number " ) < nl > - val marker = rs . getString ( " marker " ) < nl > - val message = Base64 . getDecoder . decode ( rs . getString ( " message " ) ) < nl > - val created = rs . getTimestamp ( " created " ) < nl > - val repr = serialization . deserialize ( message , classOf [ PersistentRepr ] ) < nl > - println ( repr . get ) < nl > - } < nl > + implicit val system = ActorSystem ( " migration " ) < nl > + implicit val serialization = SerializationExtension ( system ) < nl > + < nl > + val seqs = getSeqs ( connection ) < nl > + < nl > + val events = < nl > + seqs . flatMap { < nl > + case ( persistenceId , seq ) ⇒ < nl > + getObsoleteEvents ( connection , persistenceId , seq ) < nl > + } . map { < nl > + case ( obsEvent , evTs ) ⇒ < nl > + val payload = < nl > + obsEvent . payload match { < nl > + case TSEvent ( ts , ue : UserEvent ) ⇒ < nl > + val e = convert ( ts , ue ) < nl > + Tagged ( e , e . tags ) < nl > + case TSEvent ( ts , ge : GroupEvent ) ⇒ < nl > + val e = convert ( ts , ge ) < nl > + Tagged ( e , e . tags ) < nl > + case other ⇒ other < nl > + } < nl > + ( obsEvent . withPayload ( payload ) . withManifest ( " V1 " ) , evTs ) < nl > + } < nl > + < nl > + batchWrite ( connection , events ) < nl > < nl > system . terminate ( ) < nl > Await . result ( system . whenTerminated , Duration . Inf ) < nl > - / / throw new RuntimeException ( " xaxaxa " ) < nl > + } < nl > + < nl > + private def batchWrite ( < nl > + connection : Connection , < nl > + events : List [ ( PersistentRepr , Long ) ] < nl > + ) ( implicit system : ActorSystem ) : Unit = { < nl > + implicit val mat = ActorMaterializer ( ) < nl > + val sql = < nl > + " " " < nl > + | INSERT INTO persistence _ journal ( persistence _ id , sequence _ number , created , tags , message ) < nl > + | VALUES ( ? , ? , ? , ? , ? ) < nl > + " " " . stripMargin < nl > < nl > + val flowResult = < nl > + Source ( events ) < nl > + . map ( p ⇒ AtomicWrite ( p . _ 1 ) ) < nl > + . via ( SerializationFacade ( system , " , " ) . serialize ) < nl > + . map ( _ . get ) < nl > + . map { iter ⇒ < nl > + val ps = connection . prepareStatement ( sql ) < nl > + try { < nl > + for { < nl > + ser ← iter < nl > + } yield { < nl > + ps . setString ( 1 , ser . persistenceId ) < nl > + ps . setLong ( 2 , ser . sequenceNr ) < nl > + ps . setLong ( 3 , ser . created ) < nl > + ps . setString ( 4 , ser . tags . orNull ) < nl > + ps . setBytes ( 5 , ser . serialized . array ( ) ) < nl > + ps . addBatch ( ) < nl > + } < nl > + ps . execute ( ) < nl > + } finally { < nl > + ps . close ( ) < nl > + } < nl > + } . runForeach ( _ ⇒ ( ) ) < nl > + < nl > + Await . result ( flowResult , Duration . Inf ) < nl > + } < nl > + < nl > + private def convert ( ts : DateTime , event : GroupEvent ) : GroupEvent = { < nl > + import im . actor . server . group . GroupEvents . _ < nl > + val instant = Instant . ofEpochMilli ( ts . getMillis ) < nl > + < nl > + event match { < nl > + case e : Created ⇒ e . withTs ( instant ) < nl > + case e : UserInvited ⇒ e . withTs ( instant ) < nl > + case e : UserJoined ⇒ e . withTs ( instant ) < nl > + case e : UserKicked ⇒ e . withTs ( instant ) < nl > + case e : UserLeft ⇒ e . withTs ( instant ) < nl > + case e : BotAdded ⇒ e . withTs ( instant ) < nl > + case e : AvatarUpdated ⇒ e . withTs ( instant ) < nl > + case e : TitleUpdated ⇒ e . withTs ( instant ) < nl > + case e : BecamePublic ⇒ e . withTs ( instant ) < nl > + case e : AboutUpdated ⇒ e . withTs ( instant ) < nl > + case e : TopicUpdated ⇒ e . withTs ( instant ) < nl > + case e : UserBecameAdmin ⇒ e . withTs ( instant ) < nl > + case e : IntegrationTokenRevoked ⇒ e . withTs ( instant ) < nl > + } < nl > + } < nl > + < nl > + private def convert ( ts : DateTime , event : UserEvent ) : UserEvent = { < nl > + import im . actor . server . user . UserEvents . _ < nl > + val instant = Instant . ofEpochMilli ( ts . getMillis ) < nl > + < nl > + event match { < nl > + case e : AuthAdded ⇒ e . withTs ( instant ) < nl > + case e : AuthRemoved ⇒ e . withTs ( instant ) < nl > + case e : Created ⇒ e . withTs ( instant ) < nl > + case e : IsAdminUpdated ⇒ e . withTs ( instant ) < nl > + case e : PhoneAdded ⇒ e . withTs ( instant ) < nl > + case e : EmailAdded ⇒ e . withTs ( instant ) < nl > + case e : SocialContactAdded ⇒ e . withTs ( instant ) < nl > + case e : CountryCodeChanged ⇒ e . withTs ( instant ) < nl > + case e : NameChanged ⇒ e . withTs ( instant ) < nl > + case e : Deleted ⇒ e . withTs ( instant ) < nl > + case e : NicknameChanged ⇒ e . withTs ( instant ) < nl > + case e : AboutChanged ⇒ e . withTs ( instant ) < nl > + case e : AvatarUpdated ⇒ e . withTs ( instant ) < nl > + case e : PreferredLanguagesChanged ⇒ e . withTs ( instant ) < nl > + case e : TimeZoneChanged ⇒ e . withTs ( instant ) < nl > + case e : LocalNameChanged ⇒ e . withTs ( instant ) < nl > + } < nl > + } < nl > + < nl > + private def getObsoleteEvents ( < nl > + connection : Connection , < nl > + persistenceId : String , < nl > + seq : Long < nl > + ) ( implicit serialization : Serialization ) : List [ ( PersistentRepr , Long ) ] = { < nl > + val stmt = connection . prepareStatement ( < nl > + " " " < nl > + | SELECT persistence _ id , sequence _ number , marker , message , created FROM journal < nl > + | WHERE persistence _ id = ? AND sequence _ number > ? < nl > + " " " . stripMargin < nl > + ) < nl > + < nl > + try { < nl > + stmt . setString ( 1 , persistenceId ) < nl > + stmt . setLong ( 2 , seq ) < nl > + val rs = stmt . executeQuery ( ) < nl > + < nl > + var events = List . empty [ ( PersistentRepr , Long ) ] < nl > + < nl > + while ( rs . next ( ) ) { < nl > + val message = Base64 . getDecoder . decode ( rs . getString ( " message " ) ) < nl > + val created = rs . getTimestamp ( " created " ) < nl > + events = ( serialization . deserialize ( message , classOf [ PersistentRepr ] ) . get , created . toInstant . toEpochMilli ) : : events < nl > + } < nl > + < nl > + events < nl > + < nl > + } finally { < nl > + stmt . close ( ) < nl > + } < nl > + } < nl > + < nl > + private def getPersistenceIds ( connection : Connection ) : List [ String ] = { < nl > + val stmt = connection . prepareStatement ( " SELECT DISTINCT persistence _ id FROM journal " ) < nl > + try { < nl > + val rs = stmt . executeQuery ( ) < nl > + var ids = List . empty [ String ] < nl > + < nl > + while ( rs . next ( ) ) { < nl > + ids = rs . getString ( 1 ) : : ids < nl > + } < nl > + < nl > + ids < nl > + } finally { < nl > + stmt . close ( ) < nl > + } < nl > + } < nl > + < nl > + private def getSeqs ( connection : Connection ) : List [ ( String , Long ) ] = { < nl > + val persistenceIds = getPersistenceIds ( connection ) < nl > + < nl > + val stmt = connection . prepareStatement ( < nl > + " " " < nl > + | SELECT sequence _ number FROM persistence _ journal WHERE persistence _ id = ? < nl > + | ORDER BY sequence _ number DESC LIMIT 1 < nl > + " " " . stripMargin < nl > + ) < nl > + try { < nl > + persistenceIds map { id ⇒ < nl > + stmt . setString ( 1 , id ) < nl > + val rs = stmt . executeQuery ( ) < nl > + val seq = < nl > + if ( rs . next ( ) ) < nl > + rs . getLong ( 1 ) < nl > + else < nl > + 0L < nl > + ( id , seq ) < nl > + } < nl > + } finally { < nl > + stmt . close ( ) < nl > + } < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala < nl > deleted file mode 100644 < nl > index f29367c . . 0000000 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala < nl > + + + / dev / null < nl > @ @ - 1 , 20 + 0 , 0 @ @ < nl > - package im . actor . server . persist < nl > - < nl > - import akka . actor . ExtendedActorSystem < nl > - import akka . persistence . journal . { EventSeq , EventAdapter } < nl > - < nl > - final class ActorEventAdapter ( system : ExtendedActorSystem ) extends EventAdapter { < nl > - override def manifest ( event : Any ) : String = " " < nl > - < nl > - override def toJournal ( event : Any ) : Any = { < nl > - println ( " = = = toJournal " ) < nl > - event < nl > - } < nl > - < nl > - override def fromJournal ( event : Any , manifest : String ) : EventSeq = < nl > - event match { < nl > - case e : AnyRef ⇒ EventSeq ( e ) < nl > - case _ ⇒ throw new IllegalArgumentException ( s " Supported AnyRef but got : $ { event . getClass } " ) < nl > - } < nl > - < nl > - } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > index ebaa25c . . 6d4e28c 100644 < nl > - - - a / actor - server / actor - runtime / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - runtime / src / main / resources / reference . conf < nl > @ @ - 13 , 10 + 13 , 12 @ @ akka { < nl > < nl > jdbc - journal { < nl > event - adapters { < nl > - actor = " im . actor . server . persist . ActorEventAdapter " < nl > + actor = " im . actor . server . cqrs . ActorEventAdapter " < nl > } < nl > + < nl > event - adapter - bindings { < nl > " im . actor . server . event . TSEvent " = actor < nl > + " im . actor . server . cqrs . Event " = actor < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 9490dea . . aa14ed0 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 15 , 8 + 15 , 8 @ @ object Dependencies { < nl > val slick = " 3 . 1 . 1 " < nl > val slickPg = " 0 . 10 . 2 " < nl > val scalatest = " 2 . 2 . 4 " < nl > - val shardakka = " 0 . 1 . 20 " < nl > - val scalapbSer = " 0 . 1 . 13 " < nl > + val shardakka = " 0 . 1 . 21 " < nl > + val scalapbSer = " 0 . 1 . 14 " < nl > } < nl > < nl > object Compile {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / keyvalue . proto b / actor - server / actor - core / src / main / protobuf / keyvalue . proto < nl > new file mode 100644 < nl > index 0000000 . . 57acd6a < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / protobuf / keyvalue . proto < nl > @ @ - 0 , 0 + 1 , 78 @ @ < nl > + syntax = ' proto2 ' ; < nl > + < nl > + package shardakka ; < nl > + < nl > + option ( scalapb . options ) = { < nl > + import : " shardakka . TypeMappers . _ " < nl > + } ; < nl > + < nl > + import " scalapb / scalapb . proto " ; < nl > + < nl > + message RootCommands { < nl > + message Upsert { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootCommand " ; < nl > + required string key = 1 ; < nl > + required bytes value = 2 ; < nl > + } < nl > + < nl > + message Delete { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootCommand " ; < nl > + required string key = 1 ; < nl > + } < nl > + < nl > + message Ack { } < nl > + } < nl > + < nl > + message ValueCommands { < nl > + message Upsert { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueCommand " ; < nl > + < nl > + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; < nl > + required string key = 2 ; < nl > + required bytes value = 3 ; < nl > + } < nl > + < nl > + message Delete { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueCommand " ; < nl > + < nl > + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; < nl > + required string key = 2 ; < nl > + } < nl > + < nl > + message Ack { < nl > + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; < nl > + } < nl > + } < nl > + < nl > + message ValueQueries { < nl > + message Get { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueQuery " ; < nl > + required string key = 1 ; < nl > + } < nl > + < nl > + message GetResponse { < nl > + optional bytes value = 1 ; < nl > + } < nl > + } < nl > + < nl > + message ValueEvents { < nl > + message ValueUpdated { < nl > + required bytes value = 1 ; < nl > + } < nl > + < nl > + message ValueDeleted { } < nl > + } < nl > + < nl > + message RootEvents { < nl > + message KeyCreated { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootEvent " ; < nl > + < nl > + required string key = 1 ; < nl > + } < nl > + < nl > + message KeyDeleted { < nl > + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootEvent " ; < nl > + < nl > + required string key = 1 ; < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala < nl > index 630162d . . f58914d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala < nl > @ @ - 56 , 8 + 56 , 8 @ @ final class SeqUpdatesExtensionImpl ( < nl > implicit lazy val groupViewRegion : GroupViewRegion = GroupExtension ( system ) . viewRegion < nl > < nl > getUserId ( authId ) flatMap { userId ⇒ < nl > - val usersFuture = Future . sequence ( fatMetaData . userIds map ( UserOffice . getApiStruct ( _ , userId , authId ) ) ) < nl > val groupsFuture = Future . sequence ( fatMetaData . groupIds map ( GroupOffice . getApiStruct ( _ , userId ) ) ) < nl > + val usersFuture = Future . sequence ( fatMetaData . userIds map ( UserOffice . getApiStruct ( _ , userId , authId ) ) ) < nl > < nl > DBIO . from ( for { < nl > users ← usersFuture < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / Codec . scala b / actor - server / actor - core / src / main / scala / shardakka / Codec . scala < nl > new file mode 100644 < nl > index 0000000 . . 3632bca < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / Codec . scala < nl > @ @ - 0 , 0 + 1 , 23 @ @ < nl > + package shardakka < nl > + < nl > + import com . google . protobuf . ByteString < nl > + < nl > + abstract class Codec [ A ] extends Encoder [ A ] with Decoder [ A ] < nl > + < nl > + trait Encoder [ A ] { < nl > + def toString ( bytes : ByteString ) : String < nl > + < nl > + def toBytes ( value : A ) : ByteString < nl > + } < nl > + < nl > + trait Decoder [ A ] { < nl > + def fromBytes ( bytes : ByteString ) : A < nl > + } < nl > + < nl > + final object StringCodec extends Codec [ String ] { < nl > + override def toString ( bytes : ByteString ) : String = bytes . toStringUtf8 < nl > + < nl > + override def toBytes ( value : String ) : ByteString = ByteString . copyFromUtf8 ( value ) < nl > + < nl > + override def fromBytes ( bytes : ByteString ) : String = bytes . toStringUtf8 < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala b / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala < nl > new file mode 100644 < nl > index 0000000 . . 51007a2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala < nl > @ @ - 0 , 0 + 1 , 21 @ @ < nl > + package shardakka < nl > + < nl > + import akka . actor . _ < nl > + import shardakka . keyvalue . SimpleKeyValueExtension < nl > + import scala . concurrent . duration . _ < nl > + < nl > + trait ShardakkaExtension extends Extension with SimpleKeyValueExtension < nl > + < nl > + final class ShardakkaExtensionImpl ( _ system : ExtendedActorSystem ) extends ShardakkaExtension { < nl > + private implicit val system : ActorSystem = _ system < nl > + < nl > + } < nl > + < nl > + object ShardakkaExtension extends ExtensionId [ ShardakkaExtension ] with ExtensionIdProvider { < nl > + val CacheTTL = 5 . minutes < nl > + val KVPersistencePrefix = " kv " < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) : ShardakkaExtension = new ShardakkaExtensionImpl ( system ) < nl > + < nl > + override def lookup ( ) : ExtensionId [ _ < : Extension ] = ShardakkaExtension < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala b / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala < nl > new file mode 100644 < nl > index 0000000 . . 22e08c5 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala < nl > @ @ - 0 , 0 + 1 , 40 @ @ < nl > + package shardakka < nl > + < nl > + import java . io . _ < nl > + < nl > + import com . eaio . uuid . UUID < nl > + import com . google . protobuf . ByteString < nl > + import com . trueaccord . scalapb . TypeMapper < nl > + < nl > + object TypeMappers extends UUIDMapper < nl > + < nl > + private [ shardakka ] trait UUIDMapper { < nl > + private def applyUUID ( bytes : ByteString ) : UUID = { < nl > + val bis = bytes . newInput ( ) < nl > + val ois = new ObjectInputStream ( bis ) < nl > + < nl > + try { < nl > + val uuid = UUID . nilUUID ( ) < nl > + uuid . readExternal ( ois ) < nl > + uuid < nl > + } finally { < nl > + ois . close ( ) < nl > + bis . close ( ) < nl > + } < nl > + } < nl > + < nl > + private def unapplyUUID ( uuid : UUID ) : ByteString = { < nl > + val bos = new ByteArrayOutputStream ( 2 ) < nl > + val oos = new ObjectOutputStream ( bos ) < nl > + < nl > + try { < nl > + uuid . writeExternal ( oos ) < nl > + ByteString . copyFrom ( bos . toByteArray ) < nl > + } finally { < nl > + oos . close ( ) < nl > + bos . close ( ) < nl > + } < nl > + } < nl > + < nl > + implicit val uuidMapper : TypeMapper [ ByteString , UUID ] = TypeMapper [ ByteString , UUID ] ( applyUUID ) ( unapplyUUID ) < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala < nl > new file mode 100644 < nl > index 0000000 . . 607027b < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala < nl > @ @ - 0 , 0 + 1 , 77 @ @ < nl > + package shardakka . keyvalue < nl > + < nl > + import akka . actor . _ < nl > + import akka . contrib . pattern . { ClusterSingletonProxy , ClusterSingletonManager } < nl > + import akka . pattern . ask < nl > + import akka . util . Timeout < nl > + import im . actor . server . commons . serialization . ActorSerializer < nl > + import shardakka . { StringCodec , Codec , ShardakkaExtension } < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + private case object End < nl > + < nl > + case class SimpleKeyValue [ A ] ( < nl > + name : String , < nl > + private val root : ActorRef , < nl > + private val proxy : ActorRef , < nl > + private val codec : Codec [ A ] < nl > + ) { < nl > + def upsert ( key : String , value : A ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Unit ] = < nl > + ( proxy ? RootCommands . Upsert ( key , codec . toBytes ( value ) ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def delete ( key : String ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Unit ] = < nl > + ( proxy ? RootCommands . Delete ( key ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def get ( key : String ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Option [ A ] ] = < nl > + ( proxy ? ValueQueries . Get ( key ) ) . mapTo [ ValueQueries . GetResponse ] map ( _ . value . map ( codec . fromBytes ) ) < nl > + < nl > + def shutdown ( ) : Unit = { < nl > + proxy ! End < nl > + root ! PoisonPill < nl > + proxy ! PoisonPill < nl > + } < nl > + } < nl > + < nl > + trait SimpleKeyValueExtension { < nl > + this : ShardakkaExtension ⇒ < nl > + < nl > + ActorSerializer . register ( 10001 , classOf [ RootCommands . Upsert ] ) < nl > + ActorSerializer . register ( 10002 , classOf [ RootCommands . Delete ] ) < nl > + ActorSerializer . register ( 10003 , classOf [ RootCommands . Ack ] ) < nl > + < nl > + ActorSerializer . register ( 12001 , classOf [ RootEvents . KeyCreated ] ) < nl > + ActorSerializer . register ( 12002 , classOf [ RootEvents . KeyDeleted ] ) < nl > + < nl > + ActorSerializer . register ( 13001 , classOf [ ValueCommands . Upsert ] ) < nl > + ActorSerializer . register ( 13002 , classOf [ ValueCommands . Delete ] ) < nl > + ActorSerializer . register ( 13003 , classOf [ ValueCommands . Ack ] ) < nl > + < nl > + ActorSerializer . register ( 14001 , classOf [ ValueQueries . Get ] ) < nl > + ActorSerializer . register ( 14002 , classOf [ ValueQueries . GetResponse ] ) < nl > + < nl > + ActorSerializer . register ( 15001 , classOf [ ValueEvents . ValueUpdated ] ) < nl > + ActorSerializer . register ( 15002 , classOf [ ValueEvents . ValueDeleted ] ) < nl > + < nl > + def startKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { < nl > + val manager = system . actorOf ( < nl > + ClusterSingletonManager . props ( < nl > + singletonProps = SimpleKeyValueRoot . props ( name ) , < nl > + singletonName = name , < nl > + terminationMessage = End , < nl > + role = None < nl > + ) , name = s " SimpleKeyValueRoot - $ name " < nl > + ) < nl > + < nl > + val proxy = system . actorOf ( < nl > + ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , < nl > + name = s " SimpleKeyValueRoot - $ name - Proxy " < nl > + ) < nl > + < nl > + SimpleKeyValue ( name , manager , proxy , codec ) < nl > + } < nl > + < nl > + def startKeyValueString ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = < nl > + startKeyValue ( name , StringCodec ) < nl > + } < nl > + < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala < nl > new file mode 100644 < nl > index 0000000 . . 8c3bd07 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala < nl > @ @ - 0 , 0 + 1 , 95 @ @ < nl > + package shardakka . keyvalue < nl > + < nl > + import akka . actor . { ActorRef , ActorLogging , Props } < nl > + import akka . persistence . PersistentActor < nl > + import com . eaio . uuid . UUID < nl > + import shardakka . ShardakkaExtension < nl > + < nl > + trait RootCommand { < nl > + val key : String < nl > + } < nl > + < nl > + trait RootEvent < nl > + < nl > + object SimpleKeyValueRoot { < nl > + def props ( name : String ) : Props = < nl > + Props ( classOf [ SimpleKeyValueRoot ] , name ) < nl > + } < nl > + < nl > + final class SimpleKeyValueRoot ( name : String ) extends PersistentActor with ActorLogging { < nl > + < nl > + import RootCommands . _ < nl > + import RootEvents . _ < nl > + < nl > + type PendingCommand = ( RootCommand , ActorRef ) < nl > + < nl > + private [ this ] var keys = Set . empty [ String ] < nl > + private [ this ] var pendingCommands = Map . empty [ UUID , PendingCommand ] < nl > + < nl > + override def persistenceId = ShardakkaExtension . KVPersistencePrefix + " _ " + name + " _ root " < nl > + < nl > + override def receiveCommand : Receive = { < nl > + case cmd : RootCommand ⇒ handleRootCommand ( cmd , sender ( ) ) < nl > + case ValueCommands . Ack ( uuid ) ⇒ ack ( uuid ) < nl > + case query : ValueQuery ⇒ handleQuery ( query ) < nl > + case End ⇒ context stop self < nl > + } < nl > + < nl > + override def receiveRecover : Receive = { < nl > + case e : RootEvent ⇒ updateState ( e ) < nl > + } < nl > + < nl > + private def handleRootCommand ( cmd : RootCommand , sender : ActorRef ) : Unit = { < nl > + val uuid = new UUID ( ) < nl > + / / FIXME : handle UUID collisions < nl > + pendingCommands + = ( uuid → ( cmd → sender ) ) < nl > + < nl > + val valueCmd = cmd match { < nl > + case cmd @ Upsert ( key , value ) ⇒ ValueCommands . Upsert ( uuid , key , value ) < nl > + case cmd @ Delete ( key ) ⇒ ValueCommands . Delete ( uuid , key ) < nl > + } < nl > + < nl > + valueActorOf ( cmd . key ) ! valueCmd < nl > + } < nl > + < nl > + private def ack ( uuid : UUID ) : Unit = { < nl > + pendingCommands get ( uuid ) match { < nl > + case Some ( ( cmd , sender ) ) ⇒ < nl > + cmd match { < nl > + case Upsert ( key , _ ) ⇒ < nl > + if ( keyExists ( key ) ) { < nl > + sender ! Ack ( ) < nl > + } else { < nl > + persist ( KeyCreated ( key ) ) { e ⇒ < nl > + updateState ( e ) < nl > + sender ! Ack ( ) < nl > + } < nl > + } < nl > + case Delete ( key ) ⇒ < nl > + if ( ! keyExists ( key ) ) { < nl > + sender ! Ack ( ) < nl > + } else { < nl > + persist ( KeyDeleted ( key ) ) { e ⇒ < nl > + updateState ( e ) < nl > + sender ! Ack ( ) < nl > + } < nl > + } < nl > + } < nl > + case None ⇒ log . error ( " Got ack to a non - existent command " ) < nl > + } < nl > + } < nl > + < nl > + private def handleQuery ( query : ValueQuery ) = valueActorOf ( query . key ) forward query < nl > + < nl > + private def updateState ( e : RootEvent ) : Unit = e match { < nl > + case KeyCreated ( key ) ⇒ keys + = key < nl > + case KeyDeleted ( key ) ⇒ keys - = key < nl > + } < nl > + < nl > + private def keyExists ( key : String ) : Boolean = keys . contains ( key ) < nl > + < nl > + private def valueActorOf ( key : String ) : ActorRef = { < nl > + context . child ( key ) . getOrElse ( context . actorOf ( ValueActor . props ( name ) , key ) ) < nl > + } < nl > + } < nl > + < nl > diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala < nl > new file mode 100644 < nl > index 0000000 . . f91e5ac < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala < nl > @ @ - 0 , 0 + 1 , 55 @ @ < nl > + package shardakka . keyvalue < nl > + < nl > + import akka . actor . { Props , ReceiveTimeout } < nl > + import akka . persistence . PersistentActor < nl > + import com . eaio . uuid . UUID < nl > + import com . google . protobuf . ByteString < nl > + import shardakka . ShardakkaExtension < nl > + < nl > + trait ValueCommand { < nl > + val uuid : UUID < nl > + val key : String < nl > + } < nl > + < nl > + trait ValueQuery { < nl > + val key : String < nl > + } < nl > + < nl > + object ValueActor { < nl > + def props ( name : String ) = Props ( classOf [ ValueActor ] , name ) < nl > + } < nl > + < nl > + final class ValueActor ( name : String ) extends PersistentActor { < nl > + < nl > + import ValueCommands . _ < nl > + import ValueEvents . _ < nl > + import ValueQueries . _ < nl > + < nl > + context . setReceiveTimeout ( ShardakkaExtension . CacheTTL ) < nl > + < nl > + override def persistenceId = ShardakkaExtension . KVPersistencePrefix + " _ " + name + " _ " + self . path . name < nl > + < nl > + private var value : Option [ ByteString ] = None < nl > + < nl > + override def receiveCommand : Receive = { < nl > + case Upsert ( uuid , _ , newValue ) ⇒ < nl > + persist ( ValueUpdated ( newValue ) ) { e ⇒ < nl > + value = Some ( newValue ) < nl > + sender ( ) ! Ack ( uuid ) < nl > + } < nl > + case Delete ( uuid , _ ) ⇒ < nl > + persist ( ValueDeleted ( ) ) { e ⇒ < nl > + value = None < nl > + sender ( ) ! Ack ( uuid ) < nl > + } < nl > + case Get ( _ ) ⇒ < nl > + sender ( ) ! GetResponse ( value ) < nl > + case ReceiveTimeout ⇒ < nl > + context stop self < nl > + } < nl > + < nl > + override def receiveRecover : Receive = { < nl > + case ValueUpdated ( newValue ) ⇒ value = Some ( newValue ) < nl > + case ValueDeleted ( ) ⇒ value = None < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala < nl > index a5480dd . . 87d641c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala < nl > @ @ - 2 , 15 + 2 , 12 @ @ package im . actor . server < nl > < nl > import im . actor . server . api . CommonSerialization < nl > import im . actor . server . commons . serialization . ActorSerializer < nl > - import org . scalatest . { Suite , BeforeAndAfterAll } < nl > + import org . scalatest . Suite < nl > < nl > - trait ActorSerializerPrepare extends BeforeAndAfterAll { < nl > + trait ActorSerializerPrepare { < nl > this : Suite ⇒ < nl > < nl > - override protected def beforeAll ( ) : Unit = { < nl > - super . beforeAll ( ) < nl > - ActorSerializer . clean ( ) < nl > - CommonSerialization . register ( ) < nl > - } < nl > + ActorSerializer . clean ( ) < nl > + CommonSerialization . register ( ) < nl > < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > index d62bb00 . . b510432 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > @ @ - 28 , 8 + 28 , 6 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { < nl > protected implicit val materializer : ActorMaterializer = ActorMaterializer ( ) < nl > protected implicit lazy val ec : ExecutionContext = _ system . dispatcher < nl > < nl > - protected lazy val mediator = DistributedPubSubExtension ( system ) . mediator < nl > - < nl > protected implicit lazy val db : PostgresDriver . api . Database = DbExtension ( _ system ) . db < nl > < nl > DbExtension ( _ system ) . clean ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala < nl > index 5f54350 . . ca6734f 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala < nl > @ @ - 9 , 11 + 9 , 8 @ @ import org . scalatest . Suite < nl > trait ImplicitGroupRegions extends ImplicitUserRegions with ImplicitFileStorageAdapter with ActorSerializerPrepare { < nl > this : Suite ⇒ < nl > < nl > - override protected def beforeAll ( ) : Unit = { < nl > - super . beforeAll ( ) < nl > - GroupDialog . register ( ) < nl > - GroupProcessor . register ( ) < nl > - } < nl > + GroupDialog . register ( ) < nl > + GroupProcessor . register ( ) < nl > < nl > protected implicit val system : ActorSystem < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala < nl > index 9fc7c5d . . 8cfe94e 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala < nl > @ @ - 9 , 11 + 9 , 8 @ @ import org . scalatest . Suite < nl > trait ImplicitUserRegions extends ImplicitSocialManagerRegion with ImplicitSeqUpdatesManagerRegion with ActorSerializerPrepare { < nl > this : Suite ⇒ < nl > < nl > - override protected def beforeAll ( ) : Unit = { < nl > - super . beforeAll ( ) < nl > - PrivateDialog . register ( ) < nl > - UserProcessor . register ( ) < nl > - } < nl > + PrivateDialog . register ( ) < nl > + UserProcessor . register ( ) < nl > < nl > protected implicit val system : ActorSystem < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > index 7b93854 . . 95504b7 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > @ @ - 112 , 7 + 112 , 6 @ @ final class AuthServiceSpec < nl > implicit val presenceManagerRegion = PresenceManager . startRegion ( ) < nl > implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) < nl > < nl > - val mediator = DistributedPubSubExtension ( system ) . mediator < nl > implicit val sessionConfig = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) < nl > Session . startRegion ( Some ( Session . props ( mediator ) ) ) < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > index ad3842c . . 5f45a8f 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > import akka . actor . { ActorRef , ActorSystem } < nl > + import akka . contrib . pattern . DistributedPubSubExtension < nl > import akka . stream . Materializer < nl > import akka . util . Timeout < nl > import eu . codearte . jfairy . Fairy < nl > @ @ - 34 , 7 + 35 , 8 @ @ trait UserStructExtensions { < nl > trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > this : Suite ⇒ < nl > < nl > - protected val mediator : ActorRef < nl > + protected val system : ActorSystem < nl > + protected lazy val mediator : ActorRef = DistributedPubSubExtension ( system ) . mediator < nl > < nl > protected val fairy = Fairy . create ( ) < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 6b17bea < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala < nl > @ @ - 0 , 0 + 1 , 63 @ @ < nl > + package shardakka < nl > + < nl > + import im . actor . server . api . rpc . service . ServiceSpecHelpers < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . { ActorSerializerPrepare , ActorSpecification , ActorSuite , ServiceSpecMatchers } < nl > + import org . scalatest . concurrent . ScalaFutures < nl > + import org . scalatest . time . { Seconds , Span } < nl > + import org . scalatest . { FlatSpecLike , Matchers } < nl > + < nl > + import scala . concurrent . ExecutionContext < nl > + < nl > + final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) < nl > + with FlatSpecLike < nl > + with ScalaFutures < nl > + with Matchers < nl > + with ServiceSpecMatchers < nl > + with ServiceSpecHelpers < nl > + with ActorSerializerPrepare { < nl > + < nl > + it should " set and get values " in setAndGet < nl > + it should " restore state " in restoreState < nl > + < nl > + override implicit def patienceConfig : PatienceConfig = < nl > + new PatienceConfig ( timeout = Span ( 5 , Seconds ) ) < nl > + < nl > + DbExtension ( system ) . clean ( ) < nl > + DbExtension ( system ) . migrate ( ) < nl > + < nl > + private implicit val ec : ExecutionContext = system . dispatcher < nl > + < nl > + val ext = ShardakkaExtension ( system ) < nl > + < nl > + def setAndGet ( ) = { < nl > + val keyValue = ext . startKeyValueString ( " setAndGet " ) < nl > + < nl > + whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ < nl > + resp shouldBe empty < nl > + } < nl > + < nl > + whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) < nl > + < nl > + whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ < nl > + resp shouldBe Some ( " value " ) < nl > + } < nl > + } < nl > + < nl > + def restoreState ( ) = { < nl > + val kvName = " restoreState " < nl > + < nl > + val keyValue = ext . startKeyValueString ( kvName ) < nl > + < nl > + whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) < nl > + < nl > + keyValue . shutdown ( ) < nl > + Thread . sleep ( 200 ) < nl > + < nl > + val keyValueNew = ext . startKeyValueString ( kvName ) < nl > + < nl > + whenReady ( keyValueNew . get ( " key1 " ) ) { resp ⇒ < nl > + resp shouldBe Some ( " value " ) < nl > + } < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala 
 new file mode 100644 
 index 0000000 . . 3cba2dc 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ActorEventAdapter . scala 
 @ @ - 0 , 0 + 1 , 22 @ @ 
 + package im . actor . server . cqrs 
 + 
 + import akka . actor . ExtendedActorSystem 
 + import akka . persistence . journal . { Tagged , EventSeq , EventAdapter } 
 + 
 + final class ActorEventAdapter ( system : ExtendedActorSystem ) extends EventAdapter { 
 + override def manifest ( event : Any ) : String = " V1 " 
 + 
 + override def toJournal ( event : Any ) : Any = { 
 + event match { 
 + case e : TaggedEvent ⇒ Tagged ( e , e . tags ) 
 + case _ ⇒ event 
 + } 
 + } 
 + 
 + override def fromJournal ( event : Any , manifest : String ) : EventSeq = 
 + event match { 
 + case e : AnyRef ⇒ EventSeq ( e ) 
 + case _ ⇒ throw new IllegalArgumentException ( s " Supported AnyRef but got : $ { event . getClass } " ) 
 + } 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala 
 new file mode 100644 
 index 0000000 . . 7dd7366 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / TaggedEvent . scala 
 @ @ - 0 , 0 + 1 , 7 @ @ 
 + package im . actor . server . cqrs 
 + 
 + trait Event 
 + 
 + trait TaggedEvent extends Event { 
 + def tags : Set [ String ] 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index 6d7bbe0 . . b70d905 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 10 , 6 + 10 , 7 @ @ import akka . util . Timeout 
 import im . actor . api . rpc . collections . ApiMapValue 
 import im . actor . serialization . ActorSerializer 
 import im . actor . server . KeyValueMappings 
 + import im . actor . server . cqrs . TaggedEvent 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . { DirectDialogCommand , DialogExtension } 
 import im . actor . server . file . { FileStorageExtension , FileStorageAdapter , Avatar } 
 @ @ - 57 , 8 + 58 , 10 @ @ trait GroupCommand { 
 val groupId : Int 
 } 
 
 - trait GroupEvent { 
 + trait GroupEvent extends TaggedEvent { 
 val ts : Instant 
 + 
 + override def tags : Set [ String ] = Set ( " group " ) 
 } 
 
 trait GroupQuery { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index 23a10f4 . . bdad712 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 9 , 6 + 9 , 7 @ @ import akka . util . Timeout 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . serialization . ActorSerializer 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . cqrs . TaggedEvent 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . { DialogCommand , DialogExtension } 
 import im . actor . server . office . { PeerProcessor , StopOffice } 
 @ @ - 20 , 8 + 21 , 10 @ @ import slick . driver . PostgresDriver . api . _ 
 import scala . concurrent . ExecutionContext 
 import scala . concurrent . duration . _ 
 
 - trait UserEvent { 
 + trait UserEvent extends TaggedEvent { 
 val ts : Instant 
 + 
 + def tags : Set [ String ] = Set ( " user " ) 
 } 
 
 trait UserCommand { 
 diff - - git a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 index 0e60a14 . . 6e8a850 100644 
 - - - a / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 + + + b / actor - server / actor - core / src / main / scala / sql / migration / V20160128142000 _ _ AkkaPersistence . scala 
 @ @ - 1 , 17 + 1 , 26 @ @ 
 package sql . migration 
 
 import java . sql . Connection 
 + import java . time . Instant 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . persistence . PersistentRepr 
 - import akka . serialization . SerializationExtension 
 + import akka . persistence . jdbc . serialization . SerializationFacade 
 + import akka . persistence . journal . Tagged 
 + import akka . persistence . { AtomicWrite , PersistentRepr } 
 + import akka . serialization . { Serialization , SerializationExtension } 
 + import akka . stream . ActorMaterializer 
 + import akka . stream . scaladsl . Source 
 + import im . actor . serialization . ActorSerializer 
 import im . actor . server . CommonSerialization 
 - import im . actor . server . group . GroupProcessor 
 - import im . actor . server . user . UserProcessor 
 + import im . actor . server . event . TSEvent 
 + import im . actor . server . group . { GroupEvent , GroupProcessor } 
 + import im . actor . server . user . { UserEvent , UserProcessor } 
 import org . flywaydb . core . api . migration . jdbc . JdbcMigration 
 + import org . joda . time . DateTime 
 + import shardakka . keyvalue . { ValueEvents , ValueQueries , ValueCommands , RootEvents } 
 
 - import scala . concurrent . Await 
 + import scala . concurrent . _ 
 import scala . concurrent . duration . Duration 
 
 final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { 
 @ @ - 19 , 28 + 28 , 203 @ @ final class V20160128142000 _ _ AkkaPersistence extends JdbcMigration { 
 CommonSerialization . register ( ) 
 GroupProcessor . register ( ) 
 UserProcessor . register ( ) 
 + ActorSerializer . register ( 5201 , classOf [ RootEvents . KeyCreated ] ) 
 + ActorSerializer . register ( 5202 , classOf [ RootEvents . KeyDeleted ] ) 
 + 
 + ActorSerializer . register ( 5301 , classOf [ ValueCommands . Upsert ] ) 
 + ActorSerializer . register ( 5302 , classOf [ ValueCommands . Delete ] ) 
 + ActorSerializer . register ( 5303 , classOf [ ValueCommands . Ack ] ) 
 + 
 + ActorSerializer . register ( 5401 , classOf [ ValueQueries . Get ] ) 
 + ActorSerializer . register ( 5402 , classOf [ ValueQueries . GetResponse ] ) 
 + 
 + ActorSerializer . register ( 5501 , classOf [ ValueEvents . ValueUpdated ] ) 
 + ActorSerializer . register ( 5502 , classOf [ ValueEvents . ValueDeleted ] ) 
 
 override def migrate ( connection : Connection ) : Unit = { 
 - val system = ActorSystem ( " migration " ) 
 - val serialization = SerializationExtension ( system ) 
 - 
 - val stmt = connection . prepareStatement ( " SELECT persistence _ id , sequence _ number , marker , message , created FROM journal LIMIT 10 " ) 
 - val rs = stmt . executeQuery ( ) 
 - 
 - while ( rs . next ( ) ) { 
 - val persistenceId = rs . getString ( " persistence _ id " ) 
 - println ( s " = = = $ { persistenceId } " ) 
 - val sequenceNumber = rs . getLong ( " sequence _ number " ) 
 - val marker = rs . getString ( " marker " ) 
 - val message = Base64 . getDecoder . decode ( rs . getString ( " message " ) ) 
 - val created = rs . getTimestamp ( " created " ) 
 - val repr = serialization . deserialize ( message , classOf [ PersistentRepr ] ) 
 - println ( repr . get ) 
 - } 
 + implicit val system = ActorSystem ( " migration " ) 
 + implicit val serialization = SerializationExtension ( system ) 
 + 
 + val seqs = getSeqs ( connection ) 
 + 
 + val events = 
 + seqs . flatMap { 
 + case ( persistenceId , seq ) ⇒ 
 + getObsoleteEvents ( connection , persistenceId , seq ) 
 + } . map { 
 + case ( obsEvent , evTs ) ⇒ 
 + val payload = 
 + obsEvent . payload match { 
 + case TSEvent ( ts , ue : UserEvent ) ⇒ 
 + val e = convert ( ts , ue ) 
 + Tagged ( e , e . tags ) 
 + case TSEvent ( ts , ge : GroupEvent ) ⇒ 
 + val e = convert ( ts , ge ) 
 + Tagged ( e , e . tags ) 
 + case other ⇒ other 
 + } 
 + ( obsEvent . withPayload ( payload ) . withManifest ( " V1 " ) , evTs ) 
 + } 
 + 
 + batchWrite ( connection , events ) 
 
 system . terminate ( ) 
 Await . result ( system . whenTerminated , Duration . Inf ) 
 - / / throw new RuntimeException ( " xaxaxa " ) 
 + } 
 + 
 + private def batchWrite ( 
 + connection : Connection , 
 + events : List [ ( PersistentRepr , Long ) ] 
 + ) ( implicit system : ActorSystem ) : Unit = { 
 + implicit val mat = ActorMaterializer ( ) 
 + val sql = 
 + " " " 
 + | INSERT INTO persistence _ journal ( persistence _ id , sequence _ number , created , tags , message ) 
 + | VALUES ( ? , ? , ? , ? , ? ) 
 + " " " . stripMargin 
 
 + val flowResult = 
 + Source ( events ) 
 + . map ( p ⇒ AtomicWrite ( p . _ 1 ) ) 
 + . via ( SerializationFacade ( system , " , " ) . serialize ) 
 + . map ( _ . get ) 
 + . map { iter ⇒ 
 + val ps = connection . prepareStatement ( sql ) 
 + try { 
 + for { 
 + ser ← iter 
 + } yield { 
 + ps . setString ( 1 , ser . persistenceId ) 
 + ps . setLong ( 2 , ser . sequenceNr ) 
 + ps . setLong ( 3 , ser . created ) 
 + ps . setString ( 4 , ser . tags . orNull ) 
 + ps . setBytes ( 5 , ser . serialized . array ( ) ) 
 + ps . addBatch ( ) 
 + } 
 + ps . execute ( ) 
 + } finally { 
 + ps . close ( ) 
 + } 
 + } . runForeach ( _ ⇒ ( ) ) 
 + 
 + Await . result ( flowResult , Duration . Inf ) 
 + } 
 + 
 + private def convert ( ts : DateTime , event : GroupEvent ) : GroupEvent = { 
 + import im . actor . server . group . GroupEvents . _ 
 + val instant = Instant . ofEpochMilli ( ts . getMillis ) 
 + 
 + event match { 
 + case e : Created ⇒ e . withTs ( instant ) 
 + case e : UserInvited ⇒ e . withTs ( instant ) 
 + case e : UserJoined ⇒ e . withTs ( instant ) 
 + case e : UserKicked ⇒ e . withTs ( instant ) 
 + case e : UserLeft ⇒ e . withTs ( instant ) 
 + case e : BotAdded ⇒ e . withTs ( instant ) 
 + case e : AvatarUpdated ⇒ e . withTs ( instant ) 
 + case e : TitleUpdated ⇒ e . withTs ( instant ) 
 + case e : BecamePublic ⇒ e . withTs ( instant ) 
 + case e : AboutUpdated ⇒ e . withTs ( instant ) 
 + case e : TopicUpdated ⇒ e . withTs ( instant ) 
 + case e : UserBecameAdmin ⇒ e . withTs ( instant ) 
 + case e : IntegrationTokenRevoked ⇒ e . withTs ( instant ) 
 + } 
 + } 
 + 
 + private def convert ( ts : DateTime , event : UserEvent ) : UserEvent = { 
 + import im . actor . server . user . UserEvents . _ 
 + val instant = Instant . ofEpochMilli ( ts . getMillis ) 
 + 
 + event match { 
 + case e : AuthAdded ⇒ e . withTs ( instant ) 
 + case e : AuthRemoved ⇒ e . withTs ( instant ) 
 + case e : Created ⇒ e . withTs ( instant ) 
 + case e : IsAdminUpdated ⇒ e . withTs ( instant ) 
 + case e : PhoneAdded ⇒ e . withTs ( instant ) 
 + case e : EmailAdded ⇒ e . withTs ( instant ) 
 + case e : SocialContactAdded ⇒ e . withTs ( instant ) 
 + case e : CountryCodeChanged ⇒ e . withTs ( instant ) 
 + case e : NameChanged ⇒ e . withTs ( instant ) 
 + case e : Deleted ⇒ e . withTs ( instant ) 
 + case e : NicknameChanged ⇒ e . withTs ( instant ) 
 + case e : AboutChanged ⇒ e . withTs ( instant ) 
 + case e : AvatarUpdated ⇒ e . withTs ( instant ) 
 + case e : PreferredLanguagesChanged ⇒ e . withTs ( instant ) 
 + case e : TimeZoneChanged ⇒ e . withTs ( instant ) 
 + case e : LocalNameChanged ⇒ e . withTs ( instant ) 
 + } 
 + } 
 + 
 + private def getObsoleteEvents ( 
 + connection : Connection , 
 + persistenceId : String , 
 + seq : Long 
 + ) ( implicit serialization : Serialization ) : List [ ( PersistentRepr , Long ) ] = { 
 + val stmt = connection . prepareStatement ( 
 + " " " 
 + | SELECT persistence _ id , sequence _ number , marker , message , created FROM journal 
 + | WHERE persistence _ id = ? AND sequence _ number > ? 
 + " " " . stripMargin 
 + ) 
 + 
 + try { 
 + stmt . setString ( 1 , persistenceId ) 
 + stmt . setLong ( 2 , seq ) 
 + val rs = stmt . executeQuery ( ) 
 + 
 + var events = List . empty [ ( PersistentRepr , Long ) ] 
 + 
 + while ( rs . next ( ) ) { 
 + val message = Base64 . getDecoder . decode ( rs . getString ( " message " ) ) 
 + val created = rs . getTimestamp ( " created " ) 
 + events = ( serialization . deserialize ( message , classOf [ PersistentRepr ] ) . get , created . toInstant . toEpochMilli ) : : events 
 + } 
 + 
 + events 
 + 
 + } finally { 
 + stmt . close ( ) 
 + } 
 + } 
 + 
 + private def getPersistenceIds ( connection : Connection ) : List [ String ] = { 
 + val stmt = connection . prepareStatement ( " SELECT DISTINCT persistence _ id FROM journal " ) 
 + try { 
 + val rs = stmt . executeQuery ( ) 
 + var ids = List . empty [ String ] 
 + 
 + while ( rs . next ( ) ) { 
 + ids = rs . getString ( 1 ) : : ids 
 + } 
 + 
 + ids 
 + } finally { 
 + stmt . close ( ) 
 + } 
 + } 
 + 
 + private def getSeqs ( connection : Connection ) : List [ ( String , Long ) ] = { 
 + val persistenceIds = getPersistenceIds ( connection ) 
 + 
 + val stmt = connection . prepareStatement ( 
 + " " " 
 + | SELECT sequence _ number FROM persistence _ journal WHERE persistence _ id = ? 
 + | ORDER BY sequence _ number DESC LIMIT 1 
 + " " " . stripMargin 
 + ) 
 + try { 
 + persistenceIds map { id ⇒ 
 + stmt . setString ( 1 , id ) 
 + val rs = stmt . executeQuery ( ) 
 + val seq = 
 + if ( rs . next ( ) ) 
 + rs . getLong ( 1 ) 
 + else 
 + 0L 
 + ( id , seq ) 
 + } 
 + } finally { 
 + stmt . close ( ) 
 + } 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala 
 deleted file mode 100644 
 index f29367c . . 0000000 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / ActorEventAdapter . scala 
 + + + / dev / null 
 @ @ - 1 , 20 + 0 , 0 @ @ 
 - package im . actor . server . persist 
 - 
 - import akka . actor . ExtendedActorSystem 
 - import akka . persistence . journal . { EventSeq , EventAdapter } 
 - 
 - final class ActorEventAdapter ( system : ExtendedActorSystem ) extends EventAdapter { 
 - override def manifest ( event : Any ) : String = " " 
 - 
 - override def toJournal ( event : Any ) : Any = { 
 - println ( " = = = toJournal " ) 
 - event 
 - } 
 - 
 - override def fromJournal ( event : Any , manifest : String ) : EventSeq = 
 - event match { 
 - case e : AnyRef ⇒ EventSeq ( e ) 
 - case _ ⇒ throw new IllegalArgumentException ( s " Supported AnyRef but got : $ { event . getClass } " ) 
 - } 
 - 
 - } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - runtime / src / main / resources / reference . conf b / actor - server / actor - runtime / src / main / resources / reference . conf 
 index ebaa25c . . 6d4e28c 100644 
 - - - a / actor - server / actor - runtime / src / main / resources / reference . conf 
 + + + b / actor - server / actor - runtime / src / main / resources / reference . conf 
 @ @ - 13 , 10 + 13 , 12 @ @ akka { 
 
 jdbc - journal { 
 event - adapters { 
 - actor = " im . actor . server . persist . ActorEventAdapter " 
 + actor = " im . actor . server . cqrs . ActorEventAdapter " 
 } 
 + 
 event - adapter - bindings { 
 " im . actor . server . event . TSEvent " = actor 
 + " im . actor . server . cqrs . Event " = actor 
 } 
 } 
 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 9490dea . . aa14ed0 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 15 , 8 + 15 , 8 @ @ object Dependencies { 
 val slick = " 3 . 1 . 1 " 
 val slickPg = " 0 . 10 . 2 " 
 val scalatest = " 2 . 2 . 4 " 
 - val shardakka = " 0 . 1 . 20 " 
 - val scalapbSer = " 0 . 1 . 13 " 
 + val shardakka = " 0 . 1 . 21 " 
 + val scalapbSer = " 0 . 1 . 14 " 
 } 
 
 object Compile {

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / keyvalue . proto b / actor - server / actor - core / src / main / protobuf / keyvalue . proto 
 new file mode 100644 
 index 0000000 . . 57acd6a 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / protobuf / keyvalue . proto 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + syntax = ' proto2 ' ; 
 + 
 + package shardakka ; 
 + 
 + option ( scalapb . options ) = { 
 + import : " shardakka . TypeMappers . _ " 
 + } ; 
 + 
 + import " scalapb / scalapb . proto " ; 
 + 
 + message RootCommands { 
 + message Upsert { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootCommand " ; 
 + required string key = 1 ; 
 + required bytes value = 2 ; 
 + } 
 + 
 + message Delete { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootCommand " ; 
 + required string key = 1 ; 
 + } 
 + 
 + message Ack { } 
 + } 
 + 
 + message ValueCommands { 
 + message Upsert { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueCommand " ; 
 + 
 + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; 
 + required string key = 2 ; 
 + required bytes value = 3 ; 
 + } 
 + 
 + message Delete { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueCommand " ; 
 + 
 + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; 
 + required string key = 2 ; 
 + } 
 + 
 + message Ack { 
 + required bytes uuid = 1 [ ( scalapb . field ) . type = " com . eaio . uuid . UUID " ] ; 
 + } 
 + } 
 + 
 + message ValueQueries { 
 + message Get { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . ValueQuery " ; 
 + required string key = 1 ; 
 + } 
 + 
 + message GetResponse { 
 + optional bytes value = 1 ; 
 + } 
 + } 
 + 
 + message ValueEvents { 
 + message ValueUpdated { 
 + required bytes value = 1 ; 
 + } 
 + 
 + message ValueDeleted { } 
 + } 
 + 
 + message RootEvents { 
 + message KeyCreated { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootEvent " ; 
 + 
 + required string key = 1 ; 
 + } 
 + 
 + message KeyDeleted { 
 + option ( scalapb . message ) . extends = " shardakka . keyvalue . RootEvent " ; 
 + 
 + required string key = 1 ; 
 + } 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala 
 index 630162d . . f58914d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / push / SeqUpdatesExtension . scala 
 @ @ - 56 , 8 + 56 , 8 @ @ final class SeqUpdatesExtensionImpl ( 
 implicit lazy val groupViewRegion : GroupViewRegion = GroupExtension ( system ) . viewRegion 
 
 getUserId ( authId ) flatMap { userId ⇒ 
 - val usersFuture = Future . sequence ( fatMetaData . userIds map ( UserOffice . getApiStruct ( _ , userId , authId ) ) ) 
 val groupsFuture = Future . sequence ( fatMetaData . groupIds map ( GroupOffice . getApiStruct ( _ , userId ) ) ) 
 + val usersFuture = Future . sequence ( fatMetaData . userIds map ( UserOffice . getApiStruct ( _ , userId , authId ) ) ) 
 
 DBIO . from ( for { 
 users ← usersFuture 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / Codec . scala b / actor - server / actor - core / src / main / scala / shardakka / Codec . scala 
 new file mode 100644 
 index 0000000 . . 3632bca 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / Codec . scala 
 @ @ - 0 , 0 + 1 , 23 @ @ 
 + package shardakka 
 + 
 + import com . google . protobuf . ByteString 
 + 
 + abstract class Codec [ A ] extends Encoder [ A ] with Decoder [ A ] 
 + 
 + trait Encoder [ A ] { 
 + def toString ( bytes : ByteString ) : String 
 + 
 + def toBytes ( value : A ) : ByteString 
 + } 
 + 
 + trait Decoder [ A ] { 
 + def fromBytes ( bytes : ByteString ) : A 
 + } 
 + 
 + final object StringCodec extends Codec [ String ] { 
 + override def toString ( bytes : ByteString ) : String = bytes . toStringUtf8 
 + 
 + override def toBytes ( value : String ) : ByteString = ByteString . copyFromUtf8 ( value ) 
 + 
 + override def fromBytes ( bytes : ByteString ) : String = bytes . toStringUtf8 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala b / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala 
 new file mode 100644 
 index 0000000 . . 51007a2 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / ShardakkaExtension . scala 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + package shardakka 
 + 
 + import akka . actor . _ 
 + import shardakka . keyvalue . SimpleKeyValueExtension 
 + import scala . concurrent . duration . _ 
 + 
 + trait ShardakkaExtension extends Extension with SimpleKeyValueExtension 
 + 
 + final class ShardakkaExtensionImpl ( _ system : ExtendedActorSystem ) extends ShardakkaExtension { 
 + private implicit val system : ActorSystem = _ system 
 + 
 + } 
 + 
 + object ShardakkaExtension extends ExtensionId [ ShardakkaExtension ] with ExtensionIdProvider { 
 + val CacheTTL = 5 . minutes 
 + val KVPersistencePrefix = " kv " 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) : ShardakkaExtension = new ShardakkaExtensionImpl ( system ) 
 + 
 + override def lookup ( ) : ExtensionId [ _ < : Extension ] = ShardakkaExtension 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala b / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala 
 new file mode 100644 
 index 0000000 . . 22e08c5 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / TypeMappers . scala 
 @ @ - 0 , 0 + 1 , 40 @ @ 
 + package shardakka 
 + 
 + import java . io . _ 
 + 
 + import com . eaio . uuid . UUID 
 + import com . google . protobuf . ByteString 
 + import com . trueaccord . scalapb . TypeMapper 
 + 
 + object TypeMappers extends UUIDMapper 
 + 
 + private [ shardakka ] trait UUIDMapper { 
 + private def applyUUID ( bytes : ByteString ) : UUID = { 
 + val bis = bytes . newInput ( ) 
 + val ois = new ObjectInputStream ( bis ) 
 + 
 + try { 
 + val uuid = UUID . nilUUID ( ) 
 + uuid . readExternal ( ois ) 
 + uuid 
 + } finally { 
 + ois . close ( ) 
 + bis . close ( ) 
 + } 
 + } 
 + 
 + private def unapplyUUID ( uuid : UUID ) : ByteString = { 
 + val bos = new ByteArrayOutputStream ( 2 ) 
 + val oos = new ObjectOutputStream ( bos ) 
 + 
 + try { 
 + uuid . writeExternal ( oos ) 
 + ByteString . copyFrom ( bos . toByteArray ) 
 + } finally { 
 + oos . close ( ) 
 + bos . close ( ) 
 + } 
 + } 
 + 
 + implicit val uuidMapper : TypeMapper [ ByteString , UUID ] = TypeMapper [ ByteString , UUID ] ( applyUUID ) ( unapplyUUID ) 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala 
 new file mode 100644 
 index 0000000 . . 607027b 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValue . scala 
 @ @ - 0 , 0 + 1 , 77 @ @ 
 + package shardakka . keyvalue 
 + 
 + import akka . actor . _ 
 + import akka . contrib . pattern . { ClusterSingletonProxy , ClusterSingletonManager } 
 + import akka . pattern . ask 
 + import akka . util . Timeout 
 + import im . actor . server . commons . serialization . ActorSerializer 
 + import shardakka . { StringCodec , Codec , ShardakkaExtension } 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + private case object End 
 + 
 + case class SimpleKeyValue [ A ] ( 
 + name : String , 
 + private val root : ActorRef , 
 + private val proxy : ActorRef , 
 + private val codec : Codec [ A ] 
 + ) { 
 + def upsert ( key : String , value : A ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Unit ] = 
 + ( proxy ? RootCommands . Upsert ( key , codec . toBytes ( value ) ) ) map ( _ ⇒ ( ) ) 
 + 
 + def delete ( key : String ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Unit ] = 
 + ( proxy ? RootCommands . Delete ( key ) ) map ( _ ⇒ ( ) ) 
 + 
 + def get ( key : String ) ( implicit ec : ExecutionContext , timeout : Timeout ) : Future [ Option [ A ] ] = 
 + ( proxy ? ValueQueries . Get ( key ) ) . mapTo [ ValueQueries . GetResponse ] map ( _ . value . map ( codec . fromBytes ) ) 
 + 
 + def shutdown ( ) : Unit = { 
 + proxy ! End 
 + root ! PoisonPill 
 + proxy ! PoisonPill 
 + } 
 + } 
 + 
 + trait SimpleKeyValueExtension { 
 + this : ShardakkaExtension ⇒ 
 + 
 + ActorSerializer . register ( 10001 , classOf [ RootCommands . Upsert ] ) 
 + ActorSerializer . register ( 10002 , classOf [ RootCommands . Delete ] ) 
 + ActorSerializer . register ( 10003 , classOf [ RootCommands . Ack ] ) 
 + 
 + ActorSerializer . register ( 12001 , classOf [ RootEvents . KeyCreated ] ) 
 + ActorSerializer . register ( 12002 , classOf [ RootEvents . KeyDeleted ] ) 
 + 
 + ActorSerializer . register ( 13001 , classOf [ ValueCommands . Upsert ] ) 
 + ActorSerializer . register ( 13002 , classOf [ ValueCommands . Delete ] ) 
 + ActorSerializer . register ( 13003 , classOf [ ValueCommands . Ack ] ) 
 + 
 + ActorSerializer . register ( 14001 , classOf [ ValueQueries . Get ] ) 
 + ActorSerializer . register ( 14002 , classOf [ ValueQueries . GetResponse ] ) 
 + 
 + ActorSerializer . register ( 15001 , classOf [ ValueEvents . ValueUpdated ] ) 
 + ActorSerializer . register ( 15002 , classOf [ ValueEvents . ValueDeleted ] ) 
 + 
 + def startKeyValue [ A ] ( name : String , codec : Codec [ A ] ) ( implicit system : ActorSystem ) : SimpleKeyValue [ A ] = { 
 + val manager = system . actorOf ( 
 + ClusterSingletonManager . props ( 
 + singletonProps = SimpleKeyValueRoot . props ( name ) , 
 + singletonName = name , 
 + terminationMessage = End , 
 + role = None 
 + ) , name = s " SimpleKeyValueRoot - $ name " 
 + ) 
 + 
 + val proxy = system . actorOf ( 
 + ClusterSingletonProxy . props ( singletonPath = s " / user / SimpleKeyValueRoot - $ name / $ name " , role = None ) , 
 + name = s " SimpleKeyValueRoot - $ name - Proxy " 
 + ) 
 + 
 + SimpleKeyValue ( name , manager , proxy , codec ) 
 + } 
 + 
 + def startKeyValueString ( name : String ) ( implicit system : ActorSystem ) : SimpleKeyValue [ String ] = 
 + startKeyValue ( name , StringCodec ) 
 + } 
 + 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala 
 new file mode 100644 
 index 0000000 . . 8c3bd07 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / SimpleKeyValueRoot . scala 
 @ @ - 0 , 0 + 1 , 95 @ @ 
 + package shardakka . keyvalue 
 + 
 + import akka . actor . { ActorRef , ActorLogging , Props } 
 + import akka . persistence . PersistentActor 
 + import com . eaio . uuid . UUID 
 + import shardakka . ShardakkaExtension 
 + 
 + trait RootCommand { 
 + val key : String 
 + } 
 + 
 + trait RootEvent 
 + 
 + object SimpleKeyValueRoot { 
 + def props ( name : String ) : Props = 
 + Props ( classOf [ SimpleKeyValueRoot ] , name ) 
 + } 
 + 
 + final class SimpleKeyValueRoot ( name : String ) extends PersistentActor with ActorLogging { 
 + 
 + import RootCommands . _ 
 + import RootEvents . _ 
 + 
 + type PendingCommand = ( RootCommand , ActorRef ) 
 + 
 + private [ this ] var keys = Set . empty [ String ] 
 + private [ this ] var pendingCommands = Map . empty [ UUID , PendingCommand ] 
 + 
 + override def persistenceId = ShardakkaExtension . KVPersistencePrefix + " _ " + name + " _ root " 
 + 
 + override def receiveCommand : Receive = { 
 + case cmd : RootCommand ⇒ handleRootCommand ( cmd , sender ( ) ) 
 + case ValueCommands . Ack ( uuid ) ⇒ ack ( uuid ) 
 + case query : ValueQuery ⇒ handleQuery ( query ) 
 + case End ⇒ context stop self 
 + } 
 + 
 + override def receiveRecover : Receive = { 
 + case e : RootEvent ⇒ updateState ( e ) 
 + } 
 + 
 + private def handleRootCommand ( cmd : RootCommand , sender : ActorRef ) : Unit = { 
 + val uuid = new UUID ( ) 
 + / / FIXME : handle UUID collisions 
 + pendingCommands + = ( uuid → ( cmd → sender ) ) 
 + 
 + val valueCmd = cmd match { 
 + case cmd @ Upsert ( key , value ) ⇒ ValueCommands . Upsert ( uuid , key , value ) 
 + case cmd @ Delete ( key ) ⇒ ValueCommands . Delete ( uuid , key ) 
 + } 
 + 
 + valueActorOf ( cmd . key ) ! valueCmd 
 + } 
 + 
 + private def ack ( uuid : UUID ) : Unit = { 
 + pendingCommands get ( uuid ) match { 
 + case Some ( ( cmd , sender ) ) ⇒ 
 + cmd match { 
 + case Upsert ( key , _ ) ⇒ 
 + if ( keyExists ( key ) ) { 
 + sender ! Ack ( ) 
 + } else { 
 + persist ( KeyCreated ( key ) ) { e ⇒ 
 + updateState ( e ) 
 + sender ! Ack ( ) 
 + } 
 + } 
 + case Delete ( key ) ⇒ 
 + if ( ! keyExists ( key ) ) { 
 + sender ! Ack ( ) 
 + } else { 
 + persist ( KeyDeleted ( key ) ) { e ⇒ 
 + updateState ( e ) 
 + sender ! Ack ( ) 
 + } 
 + } 
 + } 
 + case None ⇒ log . error ( " Got ack to a non - existent command " ) 
 + } 
 + } 
 + 
 + private def handleQuery ( query : ValueQuery ) = valueActorOf ( query . key ) forward query 
 + 
 + private def updateState ( e : RootEvent ) : Unit = e match { 
 + case KeyCreated ( key ) ⇒ keys + = key 
 + case KeyDeleted ( key ) ⇒ keys - = key 
 + } 
 + 
 + private def keyExists ( key : String ) : Boolean = keys . contains ( key ) 
 + 
 + private def valueActorOf ( key : String ) : ActorRef = { 
 + context . child ( key ) . getOrElse ( context . actorOf ( ValueActor . props ( name ) , key ) ) 
 + } 
 + } 
 + 
 diff - - git a / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala 
 new file mode 100644 
 index 0000000 . . f91e5ac 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / shardakka / keyvalue / ValueActor . scala 
 @ @ - 0 , 0 + 1 , 55 @ @ 
 + package shardakka . keyvalue 
 + 
 + import akka . actor . { Props , ReceiveTimeout } 
 + import akka . persistence . PersistentActor 
 + import com . eaio . uuid . UUID 
 + import com . google . protobuf . ByteString 
 + import shardakka . ShardakkaExtension 
 + 
 + trait ValueCommand { 
 + val uuid : UUID 
 + val key : String 
 + } 
 + 
 + trait ValueQuery { 
 + val key : String 
 + } 
 + 
 + object ValueActor { 
 + def props ( name : String ) = Props ( classOf [ ValueActor ] , name ) 
 + } 
 + 
 + final class ValueActor ( name : String ) extends PersistentActor { 
 + 
 + import ValueCommands . _ 
 + import ValueEvents . _ 
 + import ValueQueries . _ 
 + 
 + context . setReceiveTimeout ( ShardakkaExtension . CacheTTL ) 
 + 
 + override def persistenceId = ShardakkaExtension . KVPersistencePrefix + " _ " + name + " _ " + self . path . name 
 + 
 + private var value : Option [ ByteString ] = None 
 + 
 + override def receiveCommand : Receive = { 
 + case Upsert ( uuid , _ , newValue ) ⇒ 
 + persist ( ValueUpdated ( newValue ) ) { e ⇒ 
 + value = Some ( newValue ) 
 + sender ( ) ! Ack ( uuid ) 
 + } 
 + case Delete ( uuid , _ ) ⇒ 
 + persist ( ValueDeleted ( ) ) { e ⇒ 
 + value = None 
 + sender ( ) ! Ack ( uuid ) 
 + } 
 + case Get ( _ ) ⇒ 
 + sender ( ) ! GetResponse ( value ) 
 + case ReceiveTimeout ⇒ 
 + context stop self 
 + } 
 + 
 + override def receiveRecover : Receive = { 
 + case ValueUpdated ( newValue ) ⇒ value = Some ( newValue ) 
 + case ValueDeleted ( ) ⇒ value = None 
 + } 
 + } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala 
 index a5480dd . . 87d641c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ActorSerializerPrepare . scala 
 @ @ - 2 , 15 + 2 , 12 @ @ package im . actor . server 
 
 import im . actor . server . api . CommonSerialization 
 import im . actor . server . commons . serialization . ActorSerializer 
 - import org . scalatest . { Suite , BeforeAndAfterAll } 
 + import org . scalatest . Suite 
 
 - trait ActorSerializerPrepare extends BeforeAndAfterAll { 
 + trait ActorSerializerPrepare { 
 this : Suite ⇒ 
 
 - override protected def beforeAll ( ) : Unit = { 
 - super . beforeAll ( ) 
 - ActorSerializer . clean ( ) 
 - CommonSerialization . register ( ) 
 - } 
 + ActorSerializer . clean ( ) 
 + CommonSerialization . register ( ) 
 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 index d62bb00 . . b510432 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 @ @ - 28 , 8 + 28 , 6 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { 
 protected implicit val materializer : ActorMaterializer = ActorMaterializer ( ) 
 protected implicit lazy val ec : ExecutionContext = _ system . dispatcher 
 
 - protected lazy val mediator = DistributedPubSubExtension ( system ) . mediator 
 - 
 protected implicit lazy val db : PostgresDriver . api . Database = DbExtension ( _ system ) . db 
 
 DbExtension ( _ system ) . clean ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala 
 index 5f54350 . . ca6734f 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitGroupRegions . scala 
 @ @ - 9 , 11 + 9 , 8 @ @ import org . scalatest . Suite 
 trait ImplicitGroupRegions extends ImplicitUserRegions with ImplicitFileStorageAdapter with ActorSerializerPrepare { 
 this : Suite ⇒ 
 
 - override protected def beforeAll ( ) : Unit = { 
 - super . beforeAll ( ) 
 - GroupDialog . register ( ) 
 - GroupProcessor . register ( ) 
 - } 
 + GroupDialog . register ( ) 
 + GroupProcessor . register ( ) 
 
 protected implicit val system : ActorSystem 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala 
 index 9fc7c5d . . 8cfe94e 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / ImplicitUserRegions . scala 
 @ @ - 9 , 11 + 9 , 8 @ @ import org . scalatest . Suite 
 trait ImplicitUserRegions extends ImplicitSocialManagerRegion with ImplicitSeqUpdatesManagerRegion with ActorSerializerPrepare { 
 this : Suite ⇒ 
 
 - override protected def beforeAll ( ) : Unit = { 
 - super . beforeAll ( ) 
 - PrivateDialog . register ( ) 
 - UserProcessor . register ( ) 
 - } 
 + PrivateDialog . register ( ) 
 + UserProcessor . register ( ) 
 
 protected implicit val system : ActorSystem 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 index 7b93854 . . 95504b7 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 @ @ - 112 , 7 + 112 , 6 @ @ final class AuthServiceSpec 
 implicit val presenceManagerRegion = PresenceManager . startRegion ( ) 
 implicit val groupPresenceManagerRegion = GroupPresenceManager . startRegion ( ) 
 
 - val mediator = DistributedPubSubExtension ( system ) . mediator 
 implicit val sessionConfig = SessionConfig . load ( system . settings . config . getConfig ( " session " ) ) 
 Session . startRegion ( Some ( Session . props ( mediator ) ) ) 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 index ad3842c . . 5f45a8f 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 import akka . actor . { ActorRef , ActorSystem } 
 + import akka . contrib . pattern . DistributedPubSubExtension 
 import akka . stream . Materializer 
 import akka . util . Timeout 
 import eu . codearte . jfairy . Fairy 
 @ @ - 34 , 7 + 35 , 8 @ @ trait UserStructExtensions { 
 trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 this : Suite ⇒ 
 
 - protected val mediator : ActorRef 
 + protected val system : ActorSystem 
 + protected lazy val mediator : ActorRef = DistributedPubSubExtension ( system ) . mediator 
 
 protected val fairy = Fairy . create ( ) 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala 
 new file mode 100644 
 index 0000000 . . 6b17bea 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / shardakka / KeyValueSpec . scala 
 @ @ - 0 , 0 + 1 , 63 @ @ 
 + package shardakka 
 + 
 + import im . actor . server . api . rpc . service . ServiceSpecHelpers 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . { ActorSerializerPrepare , ActorSpecification , ActorSuite , ServiceSpecMatchers } 
 + import org . scalatest . concurrent . ScalaFutures 
 + import org . scalatest . time . { Seconds , Span } 
 + import org . scalatest . { FlatSpecLike , Matchers } 
 + 
 + import scala . concurrent . ExecutionContext 
 + 
 + final class KeyValueSpec extends ActorSuite ( ActorSpecification . createSystem ( ) ) 
 + with FlatSpecLike 
 + with ScalaFutures 
 + with Matchers 
 + with ServiceSpecMatchers 
 + with ServiceSpecHelpers 
 + with ActorSerializerPrepare { 
 + 
 + it should " set and get values " in setAndGet 
 + it should " restore state " in restoreState 
 + 
 + override implicit def patienceConfig : PatienceConfig = 
 + new PatienceConfig ( timeout = Span ( 5 , Seconds ) ) 
 + 
 + DbExtension ( system ) . clean ( ) 
 + DbExtension ( system ) . migrate ( ) 
 + 
 + private implicit val ec : ExecutionContext = system . dispatcher 
 + 
 + val ext = ShardakkaExtension ( system ) 
 + 
 + def setAndGet ( ) = { 
 + val keyValue = ext . startKeyValueString ( " setAndGet " ) 
 + 
 + whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ 
 + resp shouldBe empty 
 + } 
 + 
 + whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) 
 + 
 + whenReady ( keyValue . get ( " key1 " ) ) { resp ⇒ 
 + resp shouldBe Some ( " value " ) 
 + } 
 + } 
 + 
 + def restoreState ( ) = { 
 + val kvName = " restoreState " 
 + 
 + val keyValue = ext . startKeyValueString ( kvName ) 
 + 
 + whenReady ( keyValue . upsert ( " key1 " , " value " ) ) ( identity ) 
 + 
 + keyValue . shutdown ( ) 
 + Thread . sleep ( 200 ) 
 + 
 + val keyValueNew = ext . startKeyValueString ( kvName ) 
 + 
 + whenReady ( keyValueNew . get ( " key1 " ) ) { resp ⇒ 
 + resp shouldBe Some ( " value " ) 
 + } 
 + } 
 + }
