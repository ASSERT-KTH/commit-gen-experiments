BLEU SCORE: 0.20969025558524573

TEST MSG: fix ( server ) : secure random generation
GENERATED MSG: feat ( server ) : moved group avatar management to the GroupOffice

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > index 7bcad1e . . 08271ac 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > @ @ - 13 , 11 + 13 , 11 @ @ import im . actor . server . model < nl > import im . actor . server . model . UserPassword < nl > import im . actor . server . persist . UserPasswordRepo < nl > import im . actor . server . user . UserExtension < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import org . apache . commons . codec . digest . DigestUtils < nl > import scodec . bits . BitVector < nl > import slick . dbio . DBIO < nl > < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object ACLUtils extends ACLBase with ACLFiles { < nl > @ @ - 57 , 9 + 57 , 9 @ @ object ACLUtils extends ACLBase with ACLFiles { < nl > def randomHash ( ) ( implicit s : ActorSystem ) : String = < nl > DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) < nl > < nl > - def accessToken ( ) : String = accessToken ( ThreadLocalRandom . current ( ) ) < nl > + def accessToken ( ) : String = accessToken ( ThreadLocalSecureRandom . current ( ) ) < nl > < nl > - def accessToken ( rng : ThreadLocalRandom ) : String = DigestUtils . sha256Hex ( rng . nextLong ( ) . toString ) < nl > + def accessToken ( rng : ThreadLocalSecureRandom ) : String = DigestUtils . sha256Hex ( rng . nextLong ( ) . toString ) < nl > < nl > def checkOutPeer ( outPeer : ApiOutPeer , clientAuthId : Long ) ( implicit s : ActorSystem ) : Future [ Boolean ] = { < nl > outPeer . ` type ` match { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > index c9ac745 . . a5d60f4 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala < nl > @ @ - 8 , 9 + 8 , 9 @ @ import com . sksamuel . scrimage . { Image , ParImage , Position } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . { model , persist } < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import slick . dbio . DBIO < nl > < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . { Try , Failure , Success } < nl > < nl > @ @ - 62 , 7 + 62 , 7 @ @ object ImageUtils { < nl > DbExtension ( system ) . db . run ( < nl > scaleAvatar ( < nl > fullFileId , < nl > - ThreadLocalRandom . current ( ) , < nl > + ThreadLocalSecureRandom . current ( ) , < nl > ThumbDescriptor ( " small - sticker . png " , 128 , PngWriter ( ) ) , < nl > ThumbDescriptor ( " medium - sticker . png " , 256 , PngWriter ( ) ) < nl > ) < nl > @ @ - 82 , 11 + 82 , 11 @ @ object ImageUtils { < nl > ec : ExecutionContext , < nl > system : ActorSystem < nl > ) : DBIO [ Either [ Throwable , Avatar ] ] = < nl > - scaleAvatar ( fullFileId , ThreadLocalRandom . current ( ) ) < nl > + scaleAvatar ( fullFileId , ThreadLocalSecureRandom . current ( ) ) < nl > < nl > def scaleAvatar ( < nl > fullFileId : Long , < nl > - rng : ThreadLocalRandom < nl > + rng : ThreadLocalSecureRandom < nl > ) ( implicit system : ActorSystem ) : DBIO [ Either [ Throwable , Avatar ] ] = < nl > scaleAvatar ( < nl > fullFileId , < nl > @ @ - 97 , 7 + 97 , 7 @ @ object ImageUtils { < nl > < nl > def scaleAvatar ( < nl > fullFileId : Long , < nl > - rng : ThreadLocalRandom , < nl > + rng : ThreadLocalSecureRandom , < nl > smallDesc : ThumbDescriptor , < nl > largeDesc : ThumbDescriptor < nl > ) ( implicit system : ActorSystem ) : DBIO [ Either [ Throwable , Avatar ] ] = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 25f96d8 . . b9e3841 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 22 , 6 + 22 , 7 @ @ import im . actor . server . file . { ImageUtils , Avatar } < nl > import im . actor . server . group . GroupErrors . _ < nl > import im . actor . server . office . PushTexts < nl > import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqStateDate } < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import ACLUtils . _ < nl > import im . actor . util . misc . IdUtils . _ < nl > import ImageUtils . _ < nl > @ @ - 29 , 7 + 30 , 6 @ @ import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupCommandHelpers { < nl > this : GroupProcessor ⇒ < nl > @ @ - 47 , 7 + 47 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > persist ( TSEvent ( date , created ) ) { _ ⇒ < nl > context become working ( state ) < nl > < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > < nl > / / FIXME : invite other members < nl > < nl > @ @ - 67 , 7 + 67 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > protected def create ( groupId : Int , typ : GroupType , creatorUserId : Int , title : String , randomId : Long , userIds : Set [ Int ] ) : Unit = { < nl > val accessHash = genAccessHash ( ) < nl > < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > userIds . filterNot ( _ = = creatorUserId ) foreach { userId ⇒ < nl > val randomId = rng . nextLong ( ) < nl > context . parent ! Invite ( groupId , userId , creatorUserId , randomId ) < nl > @ @ - 120 , 7 + 120 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > context become working ( updatedState ( tsEvt , state ) ) < nl > < nl > ( for { < nl > - _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) < nl > + _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) < nl > _ ← db . run ( p . GroupBotRepo . create ( groupId , botUserId , botToken ) ) < nl > _ ← integrationTokensKv . upsert ( botToken , groupId ) < nl > } yield ( ) ) onFailure { < nl > @ @ - 171 , 7 + 171 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > for { < nl > updates ← { < nl > val date = new DateTime < nl > - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > for { < nl > exists ← p . GroupUserRepo . exists ( groupId , joiningUserId ) < nl > _ ← if ( exists ) DBIO . successful ( ( ) ) else p . GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) < nl > @ @ - 379 , 7 + 379 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > protected def revokeIntegrationToken ( group : Group , userId : Int ) : Unit = { < nl > withGroupAdmin ( group , userId ) { < nl > val oldToken = group . bot . map ( _ . token ) < nl > - val newToken = accessToken ( ThreadLocalRandom . current ( ) ) < nl > + val newToken = accessToken ( ThreadLocalSecureRandom . current ( ) ) < nl > persistStashingReply ( TSEvent ( now ( ) , IntegrationTokenRevoked ( newToken ) ) , group ) { _ ⇒ < nl > for { < nl > _ ← db . run ( p . GroupBotRepo . updateToken ( groupId , newToken ) ) < nl > @ @ - 418 , 7 + 418 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > } < nl > < nl > private def genAccessHash ( ) : Long = < nl > - ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > < nl > private def createInDb ( state : Group , randomId : Long ) = < nl > p . GroupRepo . create ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > index a4685c9 . . 8b205f8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala < nl > @ @ - 13 , 10 + 13 , 10 @ @ import im . actor . server . sequence . SeqUpdatesExtension < nl > import im . actor . server . sticker . Sticker < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . misc . IdUtils < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import slick . dbio . DBIO < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . control . NoStackTrace < nl > < nl > abstract class StickerError ( message : String ) extends RuntimeException ( message ) with NoStackTrace < nl > @ @ - 53 , 7 + 53 , 7 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) < nl > private val seqExt = SeqUpdatesExtension ( system ) < nl > < nl > def createPack ( creatorUserId : Int , isDefault : Boolean ) : Future [ Int ] = { < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > val packId = IdUtils . nextIntId ( rng ) < nl > val accessSalt = ACLUtils . nextAccessSalt ( rng ) < nl > db . run ( for { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 55ffca2 . . 1f82de2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 25 , 11 + 25 , 11 @ @ import im . actor . server . social . SocialManager . _ < nl > import im . actor . server . user . UserCommands . _ < nl > import im . actor . server . { model , persist ⇒ p } < nl > import im . actor . util . misc . StringUtils < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . Failure < nl > import scala . util . control . NoStackTrace < nl > < nl > @ @ - 163 , 7 + 163 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > < nl > protected def addPhone ( user : User , phone : Long ) : Unit = < nl > persistReply ( TSEvent ( now ( ) , UserEvents . PhoneAdded ( phone ) ) , user ) { _ ⇒ < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > db . run ( for { < nl > _ ← p . UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) < nl > _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) < nl > @ @ - 176 , 7 + 176 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > < nl > protected def addEmail ( user : User , email : String ) : Unit = < nl > persistReply ( TSEvent ( now ( ) , UserEvents . EmailAdded ( email ) ) , user ) { event ⇒ < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > db . run ( for { < nl > _ ← p . UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) < nl > _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) < nl > @ @ - 347 , 7 + 347 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > contacts ← db . run ( p . contact . UnregisteredPhoneContactRepo . find ( phoneNumber ) ) < nl > _ = log . debug ( s " Unregistered $ phoneNumber is in contacts of users : $ contacts " ) < nl > _ ← Future . sequence ( contacts map { contact ⇒ < nl > - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > val updateContactRegistered = UpdateContactRegistered ( user . id , isSilent , date . getMillis , randomId ) < nl > val updateContactsAdded = UpdateContactsAdded ( Vector ( user . id ) ) < nl > val localName = contact . name < nl > @ @ - 379 , 7 + 379 , 7 @ @ private [ user ] trait UserCommandHandlers { < nl > contacts ← db . run ( p . contact . UnregisteredEmailContactRepo . find ( email ) ) < nl > _ = log . debug ( s " Unregistered $ email is in contacts of users : $ contacts " ) < nl > _ ← Future . sequence ( contacts . map { contact ⇒ < nl > - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > val updateContactRegistered = UpdateContactRegistered ( user . id , isSilent , date . getMillis , randomId ) < nl > val updateContactsAdded = UpdateContactsAdded ( Vector ( user . id ) ) < nl > val localName = contact . name < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala < nl > index b2bbf6c . . 1f64f9c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala < nl > @ @ - 14 , 7 + 14 , 6 @ @ import shardakka . ShardakkaExtension < nl > import shardakka . keyvalue . SimpleKeyValue < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . Try < nl > < nl > object FutureResultHttp extends FutureResultCats [ ( StatusCode , String ) ] < nl > @ @ - 81 , 7 + 80 , 7 @ @ trait OutgoingHooks extends ReverseHookUnmarshaler with PlayJsonSupport { < nl > registeredUrs ← fromFuture ( getHooks ( token ) ) < nl > _ ← fromBoolean ( Conflict → OutgoingHooksErrors . AlreadyRegistered ) ( ! registeredUrs . map ( _ . _ 2 ) . contains ( strUri ) ) < nl > < nl > - id = IdUtils . nextIntId ( ThreadLocalRandom . current ( ) ) < nl > + id = IdUtils . nextIntId ( ) < nl > _ ← fromFuture ( getTokenKv ( token ) . upsert ( id . toString , strUri ) ) < nl > } yield id ) . value < nl > } < nl > diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala < nl > index b8cca02 . . 28220ea 100644 < nl > - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala < nl > + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala < nl > @ @ - 17 , 12 + 17 , 12 @ @ import im . actor . server . mtproto . transport . _ < nl > import im . actor . server . persist < nl > import im . actor . server . persist . { AuthIdRepo , MasterKeyRepo } < nl > import im . actor . util . misc . IdUtils < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import scodec . bits . BitVector < nl > < nl > import scala . annotation . tailrec < nl > import scala . collection . JavaConversions . _ < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . { Failure , Success , Try } < nl > < nl > object ServerKey { < nl > @ @ - 129 , 7 + 129 , 7 @ @ final class AuthorizationManager ( serverKeys : Seq [ ServerKey ] , sessionClient : Acto < nl > def handleRequestAuthId ( ) : Unit = { < nl > val f = < nl > if ( authId = = 0L ) { < nl > - authId = IdUtils . nextAuthId ( ThreadLocalRandom . current ( ) ) < nl > + authId = IdUtils . nextAuthId ( ThreadLocalSecureRandom . current ( ) ) < nl > db . run ( persist . AuthIdRepo . create ( authId , None , None ) ) < nl > } else Future . successful ( ( ) ) < nl > < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > index d2d2d41 . . 0dcaec1 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala < nl > @ @ - 15 , 8 + 15 , 8 @ @ import im . actor . server . db . DbExtension < nl > import im . actor . server . file . _ < nl > import im . actor . server . file . local . http . FilesHttpHandler < nl > import im . actor . server . { model , persist } < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . { Failure , Success , Try } < nl > < nl > @ @ - 77 , 7 + 77 , 7 @ @ final class LocalFileStorageAdapter ( _ system : ActorSystem ) < nl > val baseUri = Uri ( httpConfig . baseUri ) < nl > < nl > override def uploadFile ( name : UnsafeFileName , data : Array [ Byte ] ) : DBIO [ FileLocation ] = { < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > val id = ACLFiles . randomLong ( rng ) < nl > val accessSalt = ACLFiles . nextAccessSalt ( rng ) < nl > < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > index b1aec30 . . 3905f91 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala < nl > @ @ - 18 , 9 + 18 , 9 @ @ import im . actor . server . file . FileUtils . _ < nl > import im . actor . server . file . _ < nl > import im . actor . server . { model , persist } < nl > import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > < nl > import scala . concurrent . duration . _ < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > final class S3StorageAdapter ( _ system : ActorSystem ) extends FileStorageAdapter { < nl > @ @ - 83 , 9 + 83 , 9 @ @ final class S3StorageAdapter ( _ system : ActorSystem ) extends FileStorageAdapter { < nl > } < nl > < nl > private def uploadFile ( bucketName : String , name : UnsafeFileName , data : Array [ Byte ] ) : DBIO [ FileLocation ] = { < nl > - val rnd = ThreadLocalRandom . current ( ) < nl > - val id = rnd . nextLong ( ) < nl > - val accessSalt = ACLFiles . nextAccessSalt ( rnd ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > + val id = rng . nextLong ( ) < nl > + val accessSalt = ACLFiles . nextAccessSalt ( rng ) < nl > val size = data . length < nl > < nl > for { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > index 65e3a5d . . e38d226 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > @ @ - 22 , 11 + 22 , 11 @ @ import im . actor . util . misc . EmailUtils . isTestEmail < nl > import im . actor . util . misc . IdUtils . _ < nl > import im . actor . util . misc . PhoneNumberUtils . _ < nl > import im . actor . util . misc . StringUtils . validName < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import org . joda . time . DateTime < nl > import slick . dbio . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . Try < nl > import scalaz . { - \ / , \ / , \ / - } < nl > < nl > @ @ - 215 , 7 + 215 , 7 @ @ trait AuthHelpers extends Helpers { < nl > / / refresh session data < nl > authSession = model . AuthSession ( < nl > userId = userId , < nl > - id = nextIntId ( ThreadLocalRandom . current ( ) ) , < nl > + id = nextIntId ( ) , < nl > authId = clientData . authId , < nl > appId = transaction . appId , < nl > appTitle = model . AuthSession . appTitleOf ( transaction . appId ) , < nl > @ @ - 247 , 7 + 247 , 7 @ @ trait AuthHelpers extends Helpers { < nl > emailSender . send ( Some ( transactionHash ) , EmailCode ( email , code ) ) < nl > } < nl > < nl > - protected def genSmsHash ( ) = ThreadLocalRandom . current . nextLong ( ) . toString < nl > + protected def genSmsHash ( ) = ThreadLocalSecureRandom . current . nextLong ( ) . toString < nl > < nl > protected def genEmailCode ( email : String ) : String = < nl > if ( isTestEmail ( email ) ) genTestCode ( email ) else genCode ( ) < nl > @ @ - 258 , 7 + 258 , 7 @ @ trait AuthHelpers extends Helpers { < nl > } < nl > < nl > protected def newUser ( name : String , countryCode : String , optSex : Option [ ApiSex ] , username : Option [ String ] ) : Result [ \ / - [ User ] ] = { < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > val sex = optSex . map ( s ⇒ model . Sex . fromInt ( s . id ) ) . getOrElse ( model . NoSex ) < nl > for { < nl > validName ← fromEither ( validName ( name ) . leftMap ( validationFailed ( " NAME _ INVALID " , _ ) ) ) < nl > @ @ - 277 , 7 + 277 , 7 @ @ trait AuthHelpers extends Helpers { < nl > } < nl > < nl > protected def newUser ( name : String ) : Result [ User ] = { < nl > - val rng = ThreadLocalRandom . current ( ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > val user = model . User ( < nl > id = nextIntId ( rng ) , < nl > accessSalt = ACLUtils . nextAccessSalt ( rng ) , < nl > @ @ - 302 , 6 + 302 , 6 @ @ trait AuthHelpers extends Helpers { < nl > private def genTestCode ( email : String ) : String = < nl > ( email replaceAll ( " " " . * acme " " " , " " ) ) replaceAll ( " . com " , " " ) < nl > < nl > - private def genCode ( ) = ThreadLocalRandom . current . nextLong ( ) . toString . dropWhile ( c ⇒ c = = ' 0 ' | | c = = ' - ' ) . take ( 5 ) < nl > + private def genCode ( ) = ThreadLocalSecureRandom . current . nextLong ( ) . toString . dropWhile ( c ⇒ c = = ' 0 ' | | c = = ' - ' ) . take ( 5 ) < nl > < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index 5c35406 . . 1cce886 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 31 , 6 + 31 , 7 @ @ import im . actor . server . { model , persist } < nl > import im . actor . util . log . AnyRefLogSource < nl > import im . actor . util . misc . PhoneNumberUtils . _ < nl > import im . actor . util . misc . _ < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import org . joda . time . DateTime < nl > import shapeless . _ < nl > import slick . dbio . DBIO < nl > @ @ - 38 , 7 + 39 , 6 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . language . postfixOps < nl > import scalaz . _ < nl > < nl > @ @ - 134 , 7 + 134 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > / / refresh session data < nl > authSession = model . AuthSession ( < nl > userId = user . id , < nl > - id = nextIntId ( ThreadLocalRandom . current ( ) ) , < nl > + id = nextIntId ( ) , < nl > authId = clientData . authId , < nl > appId = transaction . appId , < nl > appTitle = model . AuthSession . appTitleOf ( transaction . appId ) , < nl > @ @ - 488 , 7 + 488 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > val smsCode = genSmsCode ( normPhoneNumber ) < nl > for ( < nl > _ ← persist . AuthSmsCodeObsoleteRepo . create ( < nl > - id = ThreadLocalRandom . current ( ) . nextLong ( ) , < nl > + id = ThreadLocalSecureRandom . current ( ) . nextLong ( ) , < nl > phoneNumber = normPhoneNumber , < nl > smsHash = smsHash , < nl > smsCode = smsCode < nl > @ @ - 576 , 12 + 576 , 12 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > optPhone match { < nl > / / Phone does not exist , register the user < nl > case None ⇒ withValidName ( rawName ) { name ⇒ < nl > - val rnd = ThreadLocalRandom . current ( ) < nl > - val userId = nextIntId ( rnd ) < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > + val userId = nextIntId ( rng ) < nl > / / todo : move this to UserOffice < nl > val user = model . User ( < nl > id = userId , < nl > - accessSalt = ACLUtils . nextAccessSalt ( rnd ) , < nl > + accessSalt = ACLUtils . nextAccessSalt ( rng ) , < nl > name = name , < nl > countryCode = countryCode , < nl > sex = model . NoSex , < nl > @ @ - 614 , 10 + 614 , 9 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > } < nl > } . flatMap { < nl > case \ / - ( user : : HNil ) ⇒ < nl > - val rnd = ThreadLocalRandom . current ( ) < nl > val authSession = model . AuthSession ( < nl > userId = user . id , < nl > - id = nextIntId ( rnd ) , < nl > + id = nextIntId ( ) , < nl > authId = clientData . authId , < nl > appId = appId , < nl > appTitle = model . AuthSession . appTitleOf ( appId ) , < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index dec628c . . 92e00f3 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 18 , 6 + 18 , 7 @ @ import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . user . { UserUtils , UserExtension } < nl > import im . actor . server . { model , persist } < nl > import im . actor . util . misc . IdUtils < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import slick . dbio . DBIO < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > @ @ - 43 , 7 + 44 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ < nl > withFileLocation ( fileLocation , AvatarSizeLimit ) { < nl > - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { < nl > + scaleAvatar ( fileLocation . fileId , ThreadLocalSecureRandom . current ( ) ) flatMap { < nl > case Right ( avatar ) ⇒ < nl > for { < nl > UpdateAvatarAck ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( groupExt . updateAvatar ( fullGroup . id , client . userId , Some ( avatar ) , randomId ) ) < nl > @ @ - 146 , 7 + 147 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withUserOutPeers ( users ) { < nl > withValidGroupTitle ( title ) { validTitle ⇒ < nl > - val groupId = nextIntId ( ThreadLocalRandom . current ( ) ) < nl > + val groupId = nextIntId ( ThreadLocalSecureRandom . current ( ) ) < nl > val userIds = users . map ( _ . userId ) . toSet < nl > val groupUserIds = userIds + client . userId < nl > < nl > @ @ - 206 , 7 + 207 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > token ← persist . GroupInviteTokenRepo . find ( fullGroup . id , client . userId ) . headOption . flatMap { < nl > case Some ( invToken ) ⇒ DBIO . successful ( invToken . token ) < nl > case None ⇒ < nl > - val token = accessToken ( ThreadLocalRandom . current ( ) ) < nl > + val token = accessToken ( ThreadLocalSecureRandom . current ( ) ) < nl > val inviteToken = model . GroupInviteToken ( fullGroup . id , client . userId , token ) < nl > for ( _ ← persist . GroupInviteTokenRepo . create ( inviteToken ) ) yield token < nl > } < nl > @ @ - 263 , 7 + 264 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > override def jhandleRevokeInviteUrl ( groupPeer : ApiGroupOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseInviteUrl ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withOwnGroupMember ( groupPeer , client . userId ) { fullGroup ⇒ < nl > - val token = accessToken ( ThreadLocalRandom . current ( ) ) < nl > + val token = accessToken ( ThreadLocalSecureRandom . current ( ) ) < nl > val inviteToken = model . GroupInviteToken ( fullGroup . id , client . userId , token ) < nl > < nl > for { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > index f37ff88 . . 6def758 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala < nl > @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . persist < nl > import im . actor . server . sequence . { SequenceErrors , SeqState } < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > import im . actor . server . user . _ < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > import im . actor . util . misc . StringUtils < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > @ @ - 48 , 7 + 49 , 7 @ @ final class ProfileServiceImpl ( ) ( implicit system : ActorSystem ) extends ProfileSe < nl > < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withFileLocation ( fileLocation , AvatarSizeLimit ) { < nl > - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { < nl > + scaleAvatar ( fileLocation . fileId , ThreadLocalSecureRandom . current ( ) ) flatMap { < nl > case Right ( avatar ) ⇒ < nl > for { < nl > UserCommands . UpdateAvatarAck ( avatar , SeqState ( seq , state ) ) ← DBIO . from ( userExt . updateAvatar ( client . userId , Some ( avatar ) ) ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > index d23b981 . . 5f0eb26 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala < nl > @ @ - 4 , 8 + 4 , 7 @ @ import java . nio . ByteBuffer < nl > import java . security . MessageDigest < nl > < nl > import akka . actor . ActorSystem < nl > - < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > < nl > trait ACLBase { < nl > < nl > @ @ - 17 , 18 + 16 , 18 @ @ trait ACLBase { < nl > def hash ( s : String , md : MessageDigest = getMDInstance ( ) ) : Long = < nl > ByteBuffer . wrap ( md . digest ( s . getBytes ) ) . getLong < nl > < nl > - def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) < nl > + def randomLong ( ) : Long = randomLong ( ThreadLocalSecureRandom . current ( ) ) < nl > < nl > - def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) < nl > + def randomLong ( rng : ThreadLocalSecureRandom ) : Long = rng . nextLong ( ) < nl > < nl > - def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) < nl > + def randomString ( ) : String = randomString ( ThreadLocalSecureRandom . current ( ) ) < nl > < nl > - def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString < nl > + def randomString ( rng : ThreadLocalSecureRandom ) : String = rng . nextLong ( ) . toString < nl > < nl > - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) < nl > + def nextAccessSalt ( rng : ThreadLocalSecureRandom ) : String = randomString ( rng ) < nl > < nl > def nextAccessSalt ( ) : String = { < nl > - nextAccessSalt ( ThreadLocalRandom . current ( ) ) < nl > + nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) < nl > } < nl > < nl > } < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala b / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala < nl > index faeda75 . . 0347069 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala < nl > @ @ - 1 , 17 + 1 , 20 @ @ < nl > package im . actor . util . misc < nl > < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > < nl > object IdUtils { < nl > - def nextIntId ( ) : Int = nextIntId ( ThreadLocalRandom . current ( ) ) < nl > + def nextIntId ( ) : Int = nextIntId ( ThreadLocalSecureRandom . current ( ) ) < nl > < nl > - def nextIntId ( rnd : ThreadLocalRandom ) : Int = rnd . nextInt ( 1000 , Int . MaxValue ) + 1 < nl > + def nextIntId ( rnd : ThreadLocalSecureRandom ) : Int = { < nl > + val min = 1000 < nl > + min + rnd . nextInt ( Int . MaxValue - min + 1 ) < nl > + } < nl > < nl > - def nextLongId ( ) : Long = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + def nextLongId ( ) : Long = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > < nl > - def nextAuthId ( ) : Long = nextAuthId ( ThreadLocalRandom . current ( ) ) < nl > + def nextAuthId ( ) : Long = nextAuthId ( ThreadLocalSecureRandom . current ( ) ) < nl > < nl > - def nextAuthId ( rng : ThreadLocalRandom ) : Long = { < nl > + def nextAuthId ( rng : ThreadLocalSecureRandom ) : Long = { < nl > val candidate = rng . nextLong ( ) < nl > if ( candidate = = 0L ) nextAuthId ( rng ) else candidate < nl > } < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 9dd0ae7 . . f30b52e 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ < nl > < nl > object Dependencies { < nl > object V { < nl > - val actorCommons = " 0 . 0 . 11 " < nl > + val actorCommons = " 0 . 0 . 12 " < nl > val actorBotkit = " 1 . 0 . 66 " < nl > val akka = " 2 . 4 . 0 " < nl > val akkaExperimental = " 2 . 0 . 2 "
NEAREST DIFF (one line): diff - - git a / actor - server / actor - commons - api / src / main / protobuf / file . proto b / actor - server / actor - commons - api / src / main / protobuf / file . proto < nl > new file mode 100644 < nl > index 0000000 . . 511bca7 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - commons - api / src / main / protobuf / file . proto < nl > @ @ - 0 , 0 + 1 , 21 @ @ < nl > + syntax = " proto2 " ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + message FileLocation { < nl > + required int64 file _ id = 1 ; < nl > + required int64 access _ hash = 2 ; < nl > + } < nl > + < nl > + message AvatarImage { < nl > + required FileLocation file _ location = 1 ; < nl > + required int32 width = 2 ; < nl > + required int32 height = 3 ; < nl > + required int64 file _ size = 4 ; < nl > + } < nl > + < nl > + message Avatar { < nl > + optional AvatarImage small = 1 ; < nl > + optional AvatarImage large = 2 ; < nl > + optional AvatarImage full = 3 ; < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala < nl > new file mode 100644 < nl > index 0000000 . . 5ac78fc < nl > - - - / dev / null < nl > + + + b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala < nl > @ @ - 0 , 0 + 1 , 39 @ @ < nl > + package im . actor . server . api < nl > + < nl > + import scala . language . implicitConversions < nl > + < nl > + import im . actor . api . rpc . files . { Avatar ⇒ ApiAvatar , AvatarImage ⇒ ApiAvatarImage , FileLocation ⇒ ApiFileLocation } < nl > + import im . actor . server . file . { FileLocation , AvatarImage , Avatar } < nl > + < nl > + object ApiConversions { < nl > + < nl > + implicit def apiToFileLocation ( fl : ApiFileLocation ) : FileLocation = < nl > + FileLocation ( fl . fileId , fl . accessHash ) < nl > + < nl > + implicit def apiToAvatarImage ( image : ApiAvatarImage ) : AvatarImage = < nl > + AvatarImage ( image . fileLocation , image . width , image . height , image . fileSize . toLong ) < nl > + < nl > + implicit def apiToAvatarImage ( imageOpt : Option [ ApiAvatarImage ] ) : Option [ AvatarImage ] = < nl > + imageOpt map apiToAvatarImage < nl > + < nl > + implicit def apiToAvatar ( avatar : ApiAvatar ) : Avatar = < nl > + Avatar ( avatar . smallImage , avatar . largeImage , avatar . fullImage ) < nl > + < nl > + implicit def apiOptToAvatar ( avatarOpt : Option [ ApiAvatar ] ) : Option [ Avatar ] = < nl > + avatarOpt map apiToAvatar < nl > + < nl > + implicit def fileLocationToApi ( fl : FileLocation ) : ApiFileLocation = < nl > + ApiFileLocation ( fl . fileId , fl . accessHash ) < nl > + < nl > + implicit def avatarImageToApi ( image : AvatarImage ) : ApiAvatarImage = < nl > + ApiAvatarImage ( image . fileLocation , image . width , image . height , image . fileSize . toInt ) < nl > + < nl > + implicit def avatarImageOptToApi ( imageOpt : Option [ AvatarImage ] ) : Option [ ApiAvatarImage ] = < nl > + imageOpt map avatarImageToApi < nl > + < nl > + implicit def avatarToApi ( avatar : Avatar ) : ApiAvatar = < nl > + ApiAvatar ( avatar . small , avatar . large , avatar . full ) < nl > + < nl > + implicit def avatarOptToApi ( avatarOpt : Option [ Avatar ] ) : Option [ ApiAvatar ] = < nl > + avatarOpt map avatarToApi < nl > + } < nl > diff - - git a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > index 3b7b97c . . 2352f9e 100644 < nl > - - - a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > + + + b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import com . google . protobuf . { ByteString , CodedInputStream } < nl > import com . trueaccord . scalapb . TypeMapper < nl > import org . joda . time . DateTime < nl > < nl > + import im . actor . api . rpc . files . Avatar < nl > import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } < nl > import im . actor . api . rpc . peers . Peer < nl > < nl > @ @ - 33 , 9 + 34 , 17 @ @ trait MessageMapper { < nl > < nl > private def unapplyDateTime ( dt : DateTime ) : Long = dt . getMillis < nl > < nl > + private def applyAvatar ( buf : ByteString ) : Avatar = < nl > + Avatar . parseFrom ( CodedInputStream . newInstance ( buf . asReadOnlyByteBuffer ( ) ) ) . right . get < nl > + < nl > + private def unapplyAvatar ( avatar : Avatar ) : ByteString = < nl > + ByteString . copyFrom ( avatar . toByteArray ) < nl > + < nl > implicit val messageMapper : TypeMapper [ ByteString , ApiMessage ] = TypeMapper ( applyMessage ) ( unapplyMessage ) < nl > < nl > implicit val peerMapper : TypeMapper [ ByteString , Peer ] = TypeMapper ( applyPeer ) ( unapplyPeer ) < nl > < nl > implicit val dateTimeMapper : TypeMapper [ Long , DateTime ] = TypeMapper ( applyDateTime ) ( unapplyDateTime ) < nl > + < nl > + implicit val avatarMapper : TypeMapper [ ByteString , Avatar ] = TypeMapper ( applyAvatar ) ( unapplyAvatar ) < nl > } < nl > diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / file . proto b / actor - server / actor - peer - managers / src / main / protobuf / file . proto < nl > new file mode 100644 < nl > index 0000000 . . 511bca7 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - peer - managers / src / main / protobuf / file . proto < nl > @ @ - 0 , 0 + 1 , 21 @ @ < nl > + syntax = " proto2 " ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + message FileLocation { < nl > + required int64 file _ id = 1 ; < nl > + required int64 access _ hash = 2 ; < nl > + } < nl > + < nl > + message AvatarImage { < nl > + required FileLocation file _ location = 1 ; < nl > + required int32 width = 2 ; < nl > + required int32 height = 3 ; < nl > + required int64 file _ size = 4 ; < nl > + } < nl > + < nl > + message Avatar { < nl > + optional AvatarImage small = 1 ; < nl > + optional AvatarImage large = 2 ; < nl > + optional AvatarImage full = 3 ; < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / group . proto b / actor - server / actor - peer - managers / src / main / protobuf / group . proto < nl > index 4cc138b . . e6781b4 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / protobuf / group . proto < nl > + + + b / actor - server / actor - peer - managers / src / main / protobuf / group . proto < nl > @ @ - 8 , 6 + 8 , 8 @ @ option ( scalapb . options ) = { < nl > } ; < nl > < nl > import " scalapb / scalapb . proto " ; < nl > + import " file . proto " ; < nl > + import " sequence . proto " ; < nl > < nl > message GroupEnvelope { < nl > required int32 user _ id = 1 ; < nl > @ @ - 21 , 6 + 23 , 7 @ @ message GroupEnvelope { < nl > Invite invite = 7 ; < nl > Leave leave = 8 ; < nl > Create create = 9 ; < nl > + UpdateAvatar update _ Avatar = 10 ; < nl > } < nl > < nl > message Create { < nl > @ @ - 86 , 6 + 89 , 18 @ @ message GroupEnvelope { < nl > required int64 auth _ id = 2 ; < nl > required int64 random _ id = 3 ; < nl > } < nl > + < nl > + message UpdateAvatar { < nl > + required int32 client _ user _ id = 1 ; < nl > + required int64 client _ auth _ id = 2 ; < nl > + optional FileLocation file _ location = 3 ; < nl > + required int64 random _ id = 4 ; < nl > + } < nl > + < nl > + message UpdateAvatarResponse { < nl > + optional bytes avatar = 1 [ ( scalapb . field ) . type = " im . actor . api . rpc . files . Avatar " ] ; < nl > + required SeqStateDate seqstatedate = 2 ; < nl > + } < nl > } < nl > < nl > message GroupEvents { < nl > @ @ - 147 , 5 + 162 , 11 @ @ message GroupEvents { < nl > < nl > required int32 user _ id = 1 ; < nl > } < nl > + < nl > + message AvatarUpdated { < nl > + option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; < nl > + < nl > + optional Avatar avatar = 1 ; < nl > + } < nl > } < nl > < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala < nl > new file mode 100644 < nl > index 0000000 . . 0ecf687 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala < nl > @ @ - 0 , 0 + 1 , 7 @ @ < nl > + package im . actor . server . file < nl > + < nl > + import scala . util . control . NoStackTrace < nl > + < nl > + object FileErrors { < nl > + object LocationInvalid extends IllegalArgumentException with NoStackTrace < nl > + } < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala < nl > new file mode 100644 < nl > index 0000000 . . 2cfad8d < nl > - - - / dev / null < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala < nl > @ @ - 0 , 0 + 1 , 78 @ @ < nl > + package im . actor . server . group < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + < nl > + import akka . actor . ActorRef < nl > + import akka . pattern . pipe < nl > + import org . joda . time . DateTime < nl > + import slick . dbio . DBIO < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import im . actor . api . rpc . groups . UpdateGroupAvatarChanged < nl > + import im . actor . server . api . ApiConversions . _ < nl > + import im . actor . server . file . { FileErrors , FileLocation } < nl > + import im . actor . server . group . GroupEnvelope . UpdateAvatarResponse < nl > + import im . actor . server . group . GroupEvents . AvatarUpdated < nl > + import im . actor . server . push . SeqUpdatesManager . _ < nl > + import im . actor . server . push . SeqUpdatesManagerRegion < nl > + import im . actor . server . sequence . SeqStateDate < nl > + import im . actor . server . util . ImageUtils . _ < nl > + import im . actor . server . util . { FileStorageAdapter , GroupServiceMessages , HistoryUtils } < nl > + import im . actor . server . { models , persist ⇒ p } < nl > + < nl > + private [ group ] trait GroupCommands { < nl > + self : GroupOfficeActor ⇒ < nl > + < nl > + private implicit val system = context . system < nl > + private implicit val ec = context . dispatcher < nl > + < nl > + protected def updateAvatar ( group : Group , sendr : ActorRef , clientUserId : Int , clientAuthId : Long , fileLocationOpt : Option [ FileLocation ] , randomId : Long ) ( < nl > + implicit < nl > + fsAdapter : FileStorageAdapter , < nl > + db : Database , < nl > + seqUpdManagerRegion : SeqUpdatesManagerRegion < nl > + ) : Unit = { < nl > + val avatarFuture = fileLocationOpt match { < nl > + case Some ( fileLocation ) ⇒ < nl > + db . run ( scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) map { < nl > + case Right ( avatar ) ⇒ < nl > + Some ( avatar ) < nl > + case Left ( e ) ⇒ < nl > + log . error ( e , " Failed to scale group avatar " ) < nl > + throw FileErrors . LocationInvalid < nl > + } < nl > + case None ⇒ < nl > + Future . successful ( None ) < nl > + } < nl > + < nl > + avatarFuture foreach { avatarOpt ⇒ < nl > + val date = new DateTime < nl > + val avatarDataOpt = avatarOpt map ( getAvatarData ( models . AvatarData . OfGroup , groupId , _ ) ) < nl > + < nl > + persist ( AvatarUpdated ( avatarOpt ) ) { evt ⇒ < nl > + context become working ( updateState ( evt , group ) ) < nl > + < nl > + val update = UpdateGroupAvatarChanged ( groupId , clientUserId , avatarOpt , date . getMillis , randomId ) < nl > + val serviceMessage = GroupServiceMessages . changedAvatar ( avatarOpt ) < nl > + < nl > + db . run ( for { < nl > + _ ← avatarDataOpt map ( p . AvatarData . createOrUpdate ( _ ) ) getOrElse ( DBIO . successful ( ( ) ) ) < nl > + groupUserIds ← p . GroupUser . findUserIds ( groupId ) < nl > + ( seqstate , _ ) ← broadcastClientAndUsersUpdate ( clientUserId , clientAuthId , groupUserIds . toSet , update , None , isFat = false ) < nl > + } yield { < nl > + db . run ( HistoryUtils . writeHistoryMessage ( < nl > + models . Peer . privat ( clientUserId ) , < nl > + models . Peer . group ( groupId ) , < nl > + date , < nl > + randomId , < nl > + serviceMessage . header , < nl > + serviceMessage . toByteArray < nl > + ) ) < nl > + < nl > + UpdateAvatarResponse ( avatarOpt , SeqStateDate ( seqstate . seq , seqstate . state , date . getMillis ) ) < nl > + } ) pipeTo sendr < nl > + } < nl > + } < nl > + } < nl > + } < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > index bdecb99 . . a250234 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > @ @ - 20 , 6 + 20 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > import im . actor . api . rpc . groups . { UpdateGroupInvite , UpdateGroupUserInvited , UpdateGroupUserKick , UpdateGroupUserLeave } < nl > import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage , _ } < nl > import im . actor . server . commons . serialization . ActorSerializer < nl > + import im . actor . server . file . Avatar < nl > import im . actor . server . models . UserState . Registered < nl > import im . actor . server . office . PeerOffice . MessageSentComplete < nl > import im . actor . server . office . { PeerOffice , PushTexts } < nl > @ @ - 28 , 7 + 29 , 7 @ @ import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . user . { UserOffice , UserOfficeRegion } < nl > import im . actor . server . util . ACLUtils . _ < nl > import im . actor . server . util . IdUtils . _ < nl > - import im . actor . server . util . { GroupServiceMessages , HistoryUtils , UserUtils } < nl > + import im . actor . server . util . { FileStorageAdapter , GroupServiceMessages , HistoryUtils , UserUtils } < nl > import im . actor . server . { models , persist ⇒ p } < nl > import im . actor . utils . cache . CacheHelpers . _ < nl > < nl > @ @ - 50 , 7 + 51 , 8 @ @ case class Group ( < nl > lastSenderId : Option [ Int ] , < nl > lastReceivedDate : Option [ DateTime ] , < nl > lastReadDate : Option [ DateTime ] , < nl > - botUserId : Int < nl > + botUserId : Int , < nl > + avatarOpt : Option [ Avatar ] < nl > ) < nl > < nl > trait GroupEvent < nl > @ @ - 69 , 6 + 71 , 7 @ @ private [ group ] object GroupOfficeActor { < nl > ActorSerializer . register ( 5007 , classOf [ GroupEnvelope . SendMessage ] ) < nl > ActorSerializer . register ( 5008 , classOf [ GroupEnvelope . MessageReceived ] ) < nl > ActorSerializer . register ( 5009 , classOf [ GroupEnvelope . MessageRead ] ) < nl > + ActorSerializer . register ( 5010 , classOf [ GroupEnvelope . UpdateAvatar ] ) < nl > < nl > ActorSerializer . register ( 6001 , classOf [ GroupEvents . MessageRead ] ) < nl > ActorSerializer . register ( 6002 , classOf [ GroupEvents . MessageReceived ] ) < nl > @ @ - 78 , 22 + 81 , 24 @ @ private [ group ] object GroupOfficeActor { < nl > ActorSerializer . register ( 6006 , classOf [ GroupEvents . BotAdded ] ) < nl > ActorSerializer . register ( 6007 , classOf [ GroupEvents . UserKicked ] ) < nl > ActorSerializer . register ( 6008 , classOf [ GroupEvents . UserLeft ] ) < nl > + ActorSerializer . register ( 6007 , classOf [ GroupEvents . AvatarUpdated ] ) < nl > < nl > def props ( < nl > implicit < nl > db : Database , < nl > seqUpdManagerRegion : SeqUpdatesManagerRegion , < nl > - userOfficeRegion : UserOfficeRegion < nl > - ) : Props = < nl > - Props ( classOf [ GroupOfficeActor ] , db , seqUpdManagerRegion , userOfficeRegion ) < nl > + userOfficeRegion : UserOfficeRegion , < nl > + fsAdapter : FileStorageAdapter < nl > + ) : Props = Props ( classOf [ GroupOfficeActor ] , db , seqUpdManagerRegion , userOfficeRegion , fsAdapter ) < nl > } < nl > < nl > - private [ group ] class GroupOfficeActor ( < nl > + private [ group ] final class GroupOfficeActor ( < nl > implicit < nl > db : Database , < nl > seqUpdManagerRegion : SeqUpdatesManagerRegion , < nl > - userOfficeRegion : UserOfficeRegion < nl > - ) extends PeerOffice with ActorLogging with Stash with GroupsImplicits { < nl > + userOfficeRegion : UserOfficeRegion , < nl > + fsAdapter : FileStorageAdapter < nl > + ) extends PeerOffice with GroupCommands with ActorLogging with Stash with GroupsImplicits { < nl > < nl > import GroupEnvelope . _ < nl > import GroupErrors . _ < nl > @ @ - 107 , 7 + 112 , 7 @ @ private [ group ] class GroupOfficeActor ( < nl > < nl > implicit private val timeout : Timeout = Timeout ( 10 . seconds ) < nl > < nl > - private val groupId = self . path . name . toInt < nl > + protected val groupId = self . path . name . toInt < nl > < nl > override def persistenceId = s " group _ $ { groupId } " < nl > < nl > @ @ - 391 , 6 + 396 , 8 @ @ private [ group ] class GroupOfficeActor ( < nl > case e ⇒ replyTo ! Status . Failure ( e ) < nl > } < nl > } < nl > + case Payload . UpdateAvatar ( UpdateAvatar ( clientUserId , clientAuthId , fileLocationOpt , randomId ) ) ⇒ < nl > + updateAvatar ( group , sender ( ) , clientUserId , clientAuthId , fileLocationOpt , randomId ) < nl > case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) < nl > } < nl > < nl > @ @ - 425 , 11 + 432 , 12 @ @ private [ group ] class GroupOfficeActor ( < nl > lastReceivedDate = None , < nl > lastReadDate = None , < nl > botUserId = 0 , < nl > - invitedUserIds = Set . empty < nl > + invitedUserIds = Set . empty , < nl > + avatarOpt = None < nl > ) < nl > } < nl > < nl > - private def updateState ( evt : GroupEvent , state : Group ) : Group = { < nl > + protected def updateState ( evt : GroupEvent , state : Group ) : Group = { < nl > evt match { < nl > case GroupEvents . BotAdded ( userId ) ⇒ < nl > state . copy ( botUserId = userId ) < nl > @ @ - 453 , 6 + 461 , 8 @ @ private [ group ] class GroupOfficeActor ( < nl > state . copy ( members = state . members - userId ) < nl > case GroupEvents . UserLeft ( userId , _ ) ⇒ < nl > state . copy ( members = state . members - userId ) < nl > + case GroupEvents . AvatarUpdated ( avatarOpt ) ⇒ < nl > + state . copy ( avatarOpt = avatarOpt ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala < nl > index 69193db . . a6cb194 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala < nl > @ @ - 6 , 6 + 6 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . server . push . SeqUpdatesManagerRegion < nl > import im . actor . server . user . UserOfficeRegion < nl > + import im . actor . server . util . FileStorageAdapter < nl > < nl > object GroupOfficeRegion { < nl > private val idExtractor : ShardRegion . IdExtractor = { < nl > @ @ - 29 , 9 + 30 , 9 @ @ object GroupOfficeRegion { < nl > system : ActorSystem , < nl > db : Database , < nl > seqUpdManagerRegion : SeqUpdatesManagerRegion , < nl > - userOfficeRegion : UserOfficeRegion < nl > - ) : GroupOfficeRegion = < nl > - start ( Some ( GroupOfficeActor . props ) ) < nl > + userOfficeRegion : UserOfficeRegion , < nl > + fsAdapter : FileStorageAdapter < nl > + ) : GroupOfficeRegion = start ( Some ( GroupOfficeActor . props ) ) < nl > < nl > def startProxy ( ) ( implicit system : ActorSystem ) : GroupOfficeRegion = < nl > start ( None ) < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index e773422 . . 81fa9c5 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 6 , 7 + 6 , 9 @ @ import akka . pattern . ask < nl > import akka . util . Timeout < nl > < nl > import im . actor . api . rpc . AuthorizedClientData < nl > + import im . actor . api . rpc . files . { FileLocation ⇒ ApiFileLocation } < nl > import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } < nl > + import im . actor . server . file . FileLocation < nl > import im . actor . server . sequence . SeqStateDate < nl > < nl > trait GroupOperations { < nl > @ @ - 75 , 4 + 77 , 14 @ @ trait GroupOperations { < nl > peerManagerRegion . ref ! GroupEnvelope ( groupId ) . withMessageRead ( MessageRead ( readerUserId , readerAuthId , date , readDate ) ) < nl > } < nl > < nl > + def updateAvatar ( groupId : Int , clientUserId : Int , clientAuthId : Long , fileLocationOpt : Option [ ApiFileLocation ] , randomId : Long ) ( < nl > + implicit < nl > + region : GroupOfficeRegion , < nl > + timeout : Timeout , < nl > + ec : ExecutionContext < nl > + ) : Future [ UpdateAvatarResponse ] = { < nl > + val fl = fileLocationOpt map ( f ⇒ FileLocation ( f . fileId , f . accessHash ) ) < nl > + < nl > + ( region . ref ? GroupEnvelope ( groupId ) . withUpdateAvatar ( UpdateAvatar ( clientUserId , clientAuthId , fl , randomId ) ) ) . mapTo [ UpdateAvatarResponse ] < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index 7e9a283 . . 9e7698d 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 16 , 6 + 16 , 8 @ @ import im . actor . api . rpc . files . FileLocation < nl > import im . actor . api . rpc . groups . _ < nl > import im . actor . api . rpc . misc . ResponseSeqDate < nl > import im . actor . api . rpc . peers . { GroupOutPeer , UserOutPeer } < nl > + import im . actor . server . file . FileErrors < nl > + import im . actor . server . group . GroupEnvelope . UpdateAvatarResponse < nl > import im . actor . server . group . { GroupErrors , GroupOffice , GroupOfficeRegion } < nl > import im . actor . server . presences . { GroupPresenceManager , GroupPresenceManagerRegion } < nl > import im . actor . server . push . SeqUpdatesManager . _ < nl > @ @ - 47 , 66 + 49 , 37 @ @ class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ < nl > withFileLocation ( fileLocation , AvatarSizeLimit ) { < nl > - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { < nl > - case Right ( avatar ) ⇒ < nl > - val date = new DateTime < nl > - val avatarData = getAvatarData ( models . AvatarData . OfGroup , fullGroup . id , avatar ) < nl > - < nl > - val update = UpdateGroupAvatarChanged ( fullGroup . id , client . userId , Some ( avatar ) , date . getMillis , randomId ) < nl > - val serviceMessage = GroupServiceMessages . changedAvatar ( Some ( avatar ) ) < nl > - < nl > - for { < nl > - _ ← persist . AvatarData . createOrUpdate ( avatarData ) < nl > - groupUserIds ← persist . GroupUser . findUserIds ( fullGroup . id ) < nl > - _ ← broadcastClientAndUsersUpdate ( groupUserIds . toSet , update , None ) < nl > - seqstate ← broadcastClientUpdate ( update , None ) < nl > - _ ← HistoryUtils . writeHistoryMessage ( < nl > - models . Peer . privat ( client . userId ) , < nl > - models . Peer . group ( fullGroup . id ) , < nl > - date , < nl > - randomId , < nl > - serviceMessage . header , < nl > - serviceMessage . toByteArray < nl > - ) < nl > - } yield { < nl > - Ok ( ResponseEditGroupAvatar ( avatar , seqstate . seq , seqstate . state . toByteArray , date . getMillis ) ) < nl > - } < nl > - case Left ( e ) ⇒ < nl > - actorSystem . log . error ( e , " Failed to scale group avatar " ) < nl > - DBIO . successful ( Error ( Errors . LocationInvalid ) ) < nl > - } < nl > + for { < nl > + UpdateAvatarResponse ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( GroupOffice . updateAvatar ( fullGroup . id , client . userId , client . authId , Some ( fileLocation ) , randomId ) ) < nl > + } yield Ok ( ResponseEditGroupAvatar ( < nl > + avatar . get , < nl > + seq , < nl > + state . toByteArray , < nl > + date < nl > + ) ) < nl > } < nl > } < nl > } < nl > < nl > - db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) < nl > + db . run ( toDBIOAction ( authorizedAction ) ) recover { < nl > + case FileErrors . LocationInvalid ⇒ Error ( Errors . LocationInvalid ) < nl > + } < nl > } < nl > < nl > override def jhandleRemoveGroupAvatar ( groupOutPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ < nl > - val date = new DateTime < nl > - val update = UpdateGroupAvatarChanged ( fullGroup . id , client . userId , None , date . getMillis , randomId ) < nl > - val serviceMessage = GroupServiceMessages . changedAvatar ( None ) < nl > - < nl > for { < nl > - _ ← persist . AvatarData . createOrUpdate ( models . AvatarData . empty ( models . AvatarData . OfGroup , fullGroup . id . toLong ) ) < nl > - groupUserIds ← persist . GroupUser . findUserIds ( fullGroup . id ) < nl > - _ ← broadcastClientAndUsersUpdate ( groupUserIds . toSet , update , None ) < nl > - seqstate ← broadcastClientUpdate ( update , None ) < nl > - _ ← HistoryUtils . writeHistoryMessage ( < nl > - models . Peer . privat ( client . userId ) , < nl > - models . Peer . group ( fullGroup . id ) , < nl > - date , < nl > - randomId , < nl > - serviceMessage . header , < nl > - serviceMessage . toByteArray < nl > - ) < nl > - } yield Ok ( ResponseSeqDate ( seqstate . seq , seqstate . state . toByteArray , date . getMillis ) ) < nl > + UpdateAvatarResponse ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( GroupOffice . updateAvatar ( fullGroup . id , client . userId , client . authId , None , randomId ) ) < nl > + } yield Ok ( ResponseSeqDate ( < nl > + seq , < nl > + state . toByteArray , < nl > + date < nl > + ) ) < nl > } < nl > } < nl > < nl > - db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) < nl > + db . run ( toDBIOAction ( authorizedAction ) ) < nl > } < nl > < nl > override def jhandleKickUser ( groupOutPeer : GroupOutPeer , randomId : Long , userOutPeer : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { < nl > diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > index 1218b74 . . 3339e47 100644 < nl > - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala < nl > @ @ - 35 , 7 + 35 , 7 @ @ import im . actor . server . session . { Session , SessionConfig } < nl > import im . actor . server . sms . TelesignSmsEngine < nl > import im . actor . server . social . SocialManager < nl > import im . actor . server . user . UserOfficeRegion < nl > - import im . actor . server . util . { S3StorageAdapter , S3StorageAdapterConfig } < nl > + import im . actor . server . util . { FileStorageAdapter , S3StorageAdapter , S3StorageAdapterConfig } < nl > < nl > class Main extends Bootable with DbInit with FlywayInit { < nl > val serverConfig = ActorConfig . load ( ) < nl > @ @ - 69 , 9 + 69 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { < nl > flyway . migrate ( ) < nl > < nl > implicit val googlePushManager = new GooglePushManager ( googlePushConfig ) < nl > - < nl > implicit val apnsManager = new ApplePushManager ( applePushConfig , system ) < nl > < nl > + / / FIXME : FilesServiceImpl depends on S3StorageAdapter type < nl > + implicit val fsAdapterS3 : S3StorageAdapter = new S3StorageAdapter ( s3StorageAdapterConfig ) < nl > + implicit val fsAdapter : FileStorageAdapter = fsAdapterS3 < nl > + < nl > implicit val seqUpdManagerRegion = SeqUpdatesManagerRegion . start ( ) < nl > implicit val weakUpdManagerRegion = WeakUpdatesManager . startRegion ( ) < nl > implicit val presenceManagerRegion = PresenceManager . startRegion ( ) < nl > @ @ - 80 , 8 + 83 , 6 @ @ class Main extends Bootable with DbInit with FlywayInit { < nl > implicit val privatePeerManagerRegion = UserOfficeRegion . start ( ) < nl > implicit val groupPeerManagerRegion = GroupOfficeRegion . start ( ) < nl > < nl > - implicit val fsAdapter = new S3StorageAdapter ( s3StorageAdapterConfig ) < nl > - < nl > val mediator = DistributedPubSubExtension ( system ) . mediator < nl > < nl > val activationContext = serverConfig . getString ( " services . activation . default - service " ) match { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala < nl > index 5b5ae93 . . a2f0471 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala < nl > @ @ - 44 , 7 + 44 , 8 @ @ trait ImplicitFileStorageAdapter { < nl > implicit val db : Database < nl > implicit val awsCredentials : AWSCredentialsProvider < nl > < nl > - implicit lazy val fsAdapter : S3StorageAdapter = new S3StorageAdapter ( S3StorageAdapterConfig . load . get ) < nl > + implicit lazy val fsAdapterS3 : S3StorageAdapter = new S3StorageAdapter ( S3StorageAdapterConfig . load . get ) < nl > + implicit lazy val fsAdapter : FileStorageAdapter = fsAdapterS3 < nl > } < nl > < nl > trait ImplicitServiceDependencies extends ImplicitFileStorageAdapter < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > index 1301548 . . 1b0dda3 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala < nl > @ @ - 2 , 9 + 2 , 6 @ @ package im . actor . server < nl > < nl > import java . net . InetSocketAddress < nl > < nl > - import im . actor . server . group . { GroupOfficeRegion , GroupOffice } < nl > - import im . actor . server . user . { UserOfficeRegion , UserOffice } < nl > - < nl > import scala . concurrent . ExecutionContext < nl > import scala . util . Random < nl > < nl > @ @ - 26 , 6 + 23 , 7 @ @ import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > import im . actor . server . api . rpc . { RpcApiService , RpcResultCodec } < nl > import im . actor . server . db . DbInit < nl > + import im . actor . server . group . GroupOfficeRegion < nl > import im . actor . server . mtproto . codecs . protocol . _ < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . { MTPackage , TransportPackage } < nl > @ @ - 34 , 16 + 32 , 17 @ @ import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > import im . actor . server . push . _ < nl > import im . actor . server . session . { Session , SessionConfig } < nl > import im . actor . server . social . SocialManager < nl > + import im . actor . server . user . UserOfficeRegion < nl > < nl > class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > ActorSpecification . createSystem ( ConfigFactory . parseString ( < nl > " " " < nl > - | session { < nl > - | idle - timeout = 5 seconds < nl > - | } < nl > - " " " . stripMargin < nl > + | session { < nl > + | idle - timeout = 5 seconds < nl > + | } < nl > + " " " . stripMargin < nl > ) ) < nl > - ) with DbInit with SqlSpecHelpers { < nl > + ) with DbInit with SqlSpecHelpers with ImplicitFileStorageAdapter { < nl > behavior of " Server " < nl > < nl > it should " connect and Handshake " in Server . e1 < nl > @ @ - 58 , 6 + 57 , 8 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > < nl > implicit lazy val ( ds , db ) = migrateAndInitDb ( ) < nl > < nl > + val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) < nl > + < nl > object Server { < nl > val serverConfig = system . settings . config < nl > < nl > @ @ - 86 , 8 + 87 , 6 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( < nl > Session . startRegion ( Some ( Session . props ( mediator ) ) ) < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > < nl > - val bucketName = " actor - uploads - test " < nl > - val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) < nl > implicit val transferManager = new TransferManager ( awsCredentials ) < nl > implicit val ec : ExecutionContext = system . dispatcher < nl > implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > index d0cb1bc . . ab01717 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . api . rpc . groups . UpdateGroupUserLeave < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > import im . actor . api . rpc . sequence . { DifferenceUpdate , ResponseGetDifference } < nl > import im . actor . api . rpc . users . UpdateUserNameChanged < nl > - import im . actor . server . { ActorSpecification , BaseAppSuite } < nl > + import im . actor . server . { ImplicitFileStorageAdapter , ActorSpecification , BaseAppSuite } < nl > import im . actor . server . api . rpc . service . sequence . SequenceServiceConfig < nl > import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } < nl > import im . actor . server . presences . PresenceManager < nl > @ @ - 33 , 7 + 33 , 7 @ @ class SequenceServiceSpec extends BaseAppSuite ( { < nl > " " " < nl > ) < nl > ) < nl > - } ) { < nl > + } ) with ImplicitFileStorageAdapter { < nl > < nl > behavior of " Sequence service " < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > index db46150 . . 4e6a63e 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > @ @ - 73 , 7 + 73 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers with Im < nl > implicit val authService = buildAuthService ( ) < nl > implicit val groupsService = new GroupsServiceImpl ( groupInviteConfig ) < nl > < nl > - val s3BucketName = fsAdapter . bucketName < nl > + val s3BucketName = fsAdapterS3 . bucketName < nl > < nl > object t { < nl > val ( user1 , authId1 , _ ) = createUser ( ) < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index a9e58f8 . . d078ae7 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 47 , 7 + 47 , 10 @ @ object Build extends sbt . Build { < nl > PB . protobufSettings + + Seq ( < nl > / / PB . javaConversions in PB . protobufConfig : = true , < nl > libraryDependencies + = " com . trueaccord . scalapb " % % " scalapb - runtime " % " 0 . 5 . 9 " % PB . protobufConfig , < nl > - PB . includePaths in PB . protobufConfig + = file ( " actor - push / src / main / protobuf " ) < nl > + PB . includePaths in PB . protobufConfig + + = Seq ( < nl > + file ( " actor - commons - api / src / main / protobuf " ) , < nl > + file ( " actor - push / src / main / protobuf " ) < nl > + ) < nl > ) + + < nl > Seq ( < nl > initialize ~ = { _ = >

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 index 7bcad1e . . 08271ac 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 @ @ - 13 , 11 + 13 , 11 @ @ import im . actor . server . model 
 import im . actor . server . model . UserPassword 
 import im . actor . server . persist . UserPasswordRepo 
 import im . actor . server . user . UserExtension 
 + import im . actor . util . ThreadLocalSecureRandom 
 import org . apache . commons . codec . digest . DigestUtils 
 import scodec . bits . BitVector 
 import slick . dbio . DBIO 
 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . concurrent . { ExecutionContext , Future } 
 
 object ACLUtils extends ACLBase with ACLFiles { 
 @ @ - 57 , 9 + 57 , 9 @ @ object ACLUtils extends ACLBase with ACLFiles { 
 def randomHash ( ) ( implicit s : ActorSystem ) : String = 
 DigestUtils . sha1Hex ( s " $ { randomString ( ) } : $ { secretKey ( ) } " ) 
 
 - def accessToken ( ) : String = accessToken ( ThreadLocalRandom . current ( ) ) 
 + def accessToken ( ) : String = accessToken ( ThreadLocalSecureRandom . current ( ) ) 
 
 - def accessToken ( rng : ThreadLocalRandom ) : String = DigestUtils . sha256Hex ( rng . nextLong ( ) . toString ) 
 + def accessToken ( rng : ThreadLocalSecureRandom ) : String = DigestUtils . sha256Hex ( rng . nextLong ( ) . toString ) 
 
 def checkOutPeer ( outPeer : ApiOutPeer , clientAuthId : Long ) ( implicit s : ActorSystem ) : Future [ Boolean ] = { 
 outPeer . ` type ` match { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 index c9ac745 . . a5d60f4 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / file / ImageUtils . scala 
 @ @ - 8 , 9 + 8 , 9 @ @ import com . sksamuel . scrimage . { Image , ParImage , Position } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . db . DbExtension 
 import im . actor . server . { model , persist } 
 + import im . actor . util . ThreadLocalSecureRandom 
 import slick . dbio . DBIO 
 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . { Try , Failure , Success } 
 
 @ @ - 62 , 7 + 62 , 7 @ @ object ImageUtils { 
 DbExtension ( system ) . db . run ( 
 scaleAvatar ( 
 fullFileId , 
 - ThreadLocalRandom . current ( ) , 
 + ThreadLocalSecureRandom . current ( ) , 
 ThumbDescriptor ( " small - sticker . png " , 128 , PngWriter ( ) ) , 
 ThumbDescriptor ( " medium - sticker . png " , 256 , PngWriter ( ) ) 
 ) 
 @ @ - 82 , 11 + 82 , 11 @ @ object ImageUtils { 
 ec : ExecutionContext , 
 system : ActorSystem 
 ) : DBIO [ Either [ Throwable , Avatar ] ] = 
 - scaleAvatar ( fullFileId , ThreadLocalRandom . current ( ) ) 
 + scaleAvatar ( fullFileId , ThreadLocalSecureRandom . current ( ) ) 
 
 def scaleAvatar ( 
 fullFileId : Long , 
 - rng : ThreadLocalRandom 
 + rng : ThreadLocalSecureRandom 
 ) ( implicit system : ActorSystem ) : DBIO [ Either [ Throwable , Avatar ] ] = 
 scaleAvatar ( 
 fullFileId , 
 @ @ - 97 , 7 + 97 , 7 @ @ object ImageUtils { 
 
 def scaleAvatar ( 
 fullFileId : Long , 
 - rng : ThreadLocalRandom , 
 + rng : ThreadLocalSecureRandom , 
 smallDesc : ThumbDescriptor , 
 largeDesc : ThumbDescriptor 
 ) ( implicit system : ActorSystem ) : DBIO [ Either [ Throwable , Avatar ] ] = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 25f96d8 . . b9e3841 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 22 , 6 + 22 , 7 @ @ import im . actor . server . file . { ImageUtils , Avatar } 
 import im . actor . server . group . GroupErrors . _ 
 import im . actor . server . office . PushTexts 
 import im . actor . server . sequence . { PushData , PushRules , SeqState , SeqStateDate } 
 + import im . actor . util . ThreadLocalSecureRandom 
 import ACLUtils . _ 
 import im . actor . util . misc . IdUtils . _ 
 import ImageUtils . _ 
 @ @ - 29 , 7 + 30 , 6 @ @ import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupCommandHelpers { 
 this : GroupProcessor ⇒ 
 @ @ - 47 , 7 + 47 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 persist ( TSEvent ( date , created ) ) { _ ⇒ 
 context become working ( state ) 
 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 
 / / FIXME : invite other members 
 
 @ @ - 67 , 7 + 67 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 protected def create ( groupId : Int , typ : GroupType , creatorUserId : Int , title : String , randomId : Long , userIds : Set [ Int ] ) : Unit = { 
 val accessHash = genAccessHash ( ) 
 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 userIds . filterNot ( _ = = creatorUserId ) foreach { userId ⇒ 
 val randomId = rng . nextLong ( ) 
 context . parent ! Invite ( groupId , userId , creatorUserId , randomId ) 
 @ @ - 120 , 7 + 120 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 context become working ( updatedState ( tsEvt , state ) ) 
 
 ( for { 
 - _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) 
 + _ ← userExt . create ( botUserId , nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) , None , " Bot " , " US " , ApiSex . Unknown , isBot = true ) 
 _ ← db . run ( p . GroupBotRepo . create ( groupId , botUserId , botToken ) ) 
 _ ← integrationTokensKv . upsert ( botToken , groupId ) 
 } yield ( ) ) onFailure { 
 @ @ - 171 , 7 + 171 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 for { 
 updates ← { 
 val date = new DateTime 
 - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 for { 
 exists ← p . GroupUserRepo . exists ( groupId , joiningUserId ) 
 _ ← if ( exists ) DBIO . successful ( ( ) ) else p . GroupUserRepo . create ( groupId , joiningUserId , invitingUserId , date , Some ( LocalDateTime . now ( ZoneOffset . UTC ) ) , isAdmin = false ) 
 @ @ - 379 , 7 + 379 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 protected def revokeIntegrationToken ( group : Group , userId : Int ) : Unit = { 
 withGroupAdmin ( group , userId ) { 
 val oldToken = group . bot . map ( _ . token ) 
 - val newToken = accessToken ( ThreadLocalRandom . current ( ) ) 
 + val newToken = accessToken ( ThreadLocalSecureRandom . current ( ) ) 
 persistStashingReply ( TSEvent ( now ( ) , IntegrationTokenRevoked ( newToken ) ) , group ) { _ ⇒ 
 for { 
 _ ← db . run ( p . GroupBotRepo . updateToken ( groupId , newToken ) ) 
 @ @ - 418 , 7 + 418 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 } 
 
 private def genAccessHash ( ) : Long = 
 - ThreadLocalRandom . current ( ) . nextLong ( ) 
 + ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 
 private def createInDb ( state : Group , randomId : Long ) = 
 p . GroupRepo . create ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 index a4685c9 . . 8b205f8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / stickers / StickersExtension . scala 
 @ @ - 13 , 10 + 13 , 10 @ @ import im . actor . server . sequence . SeqUpdatesExtension 
 import im . actor . server . sticker . Sticker 
 import im . actor . server . user . UserExtension 
 import im . actor . util . misc . IdUtils 
 + import im . actor . util . ThreadLocalSecureRandom 
 import slick . dbio . DBIO 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . control . NoStackTrace 
 
 abstract class StickerError ( message : String ) extends RuntimeException ( message ) with NoStackTrace 
 @ @ - 53 , 7 + 53 , 7 @ @ final class StickersExtensionImpl ( _ system : ActorSystem ) 
 private val seqExt = SeqUpdatesExtension ( system ) 
 
 def createPack ( creatorUserId : Int , isDefault : Boolean ) : Future [ Int ] = { 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 val packId = IdUtils . nextIntId ( rng ) 
 val accessSalt = ACLUtils . nextAccessSalt ( rng ) 
 db . run ( for { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 55ffca2 . . 1f82de2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 25 , 11 + 25 , 11 @ @ import im . actor . server . social . SocialManager . _ 
 import im . actor . server . user . UserCommands . _ 
 import im . actor . server . { model , persist ⇒ p } 
 import im . actor . util . misc . StringUtils 
 + import im . actor . util . ThreadLocalSecureRandom 
 import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . Failure 
 import scala . util . control . NoStackTrace 
 
 @ @ - 163 , 7 + 163 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 
 protected def addPhone ( user : User , phone : Long ) : Unit = 
 persistReply ( TSEvent ( now ( ) , UserEvents . PhoneAdded ( phone ) ) , user ) { _ ⇒ 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 db . run ( for { 
 _ ← p . UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) 
 _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) 
 @ @ - 176 , 7 + 176 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 
 protected def addEmail ( user : User , email : String ) : Unit = 
 persistReply ( TSEvent ( now ( ) , UserEvents . EmailAdded ( email ) ) , user ) { event ⇒ 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 db . run ( for { 
 _ ← p . UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) 
 _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) 
 @ @ - 347 , 7 + 347 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 contacts ← db . run ( p . contact . UnregisteredPhoneContactRepo . find ( phoneNumber ) ) 
 _ = log . debug ( s " Unregistered $ phoneNumber is in contacts of users : $ contacts " ) 
 _ ← Future . sequence ( contacts map { contact ⇒ 
 - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 val updateContactRegistered = UpdateContactRegistered ( user . id , isSilent , date . getMillis , randomId ) 
 val updateContactsAdded = UpdateContactsAdded ( Vector ( user . id ) ) 
 val localName = contact . name 
 @ @ - 379 , 7 + 379 , 7 @ @ private [ user ] trait UserCommandHandlers { 
 contacts ← db . run ( p . contact . UnregisteredEmailContactRepo . find ( email ) ) 
 _ = log . debug ( s " Unregistered $ email is in contacts of users : $ contacts " ) 
 _ ← Future . sequence ( contacts . map { contact ⇒ 
 - val randomId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + val randomId = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 val updateContactRegistered = UpdateContactRegistered ( user . id , isSilent , date . getMillis , randomId ) 
 val updateContactsAdded = UpdateContactsAdded ( Vector ( user . id ) ) 
 val localName = contact . name 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala 
 index b2bbf6c . . 1f64f9c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webhooks / http / routes / OutgoingHooks . scala 
 @ @ - 14 , 7 + 14 , 6 @ @ import shardakka . ShardakkaExtension 
 import shardakka . keyvalue . SimpleKeyValue 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . Try 
 
 object FutureResultHttp extends FutureResultCats [ ( StatusCode , String ) ] 
 @ @ - 81 , 7 + 80 , 7 @ @ trait OutgoingHooks extends ReverseHookUnmarshaler with PlayJsonSupport { 
 registeredUrs ← fromFuture ( getHooks ( token ) ) 
 _ ← fromBoolean ( Conflict → OutgoingHooksErrors . AlreadyRegistered ) ( ! registeredUrs . map ( _ . _ 2 ) . contains ( strUri ) ) 
 
 - id = IdUtils . nextIntId ( ThreadLocalRandom . current ( ) ) 
 + id = IdUtils . nextIntId ( ) 
 _ ← fromFuture ( getTokenKv ( token ) . upsert ( id . toString , strUri ) ) 
 } yield id ) . value 
 } 
 diff - - git a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala 
 index b8cca02 . . 28220ea 100644 
 - - - a / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala 
 + + + b / actor - server / actor - frontend / src / main / scala / im / actor / server / frontend / AuthorizationManager . scala 
 @ @ - 17 , 12 + 17 , 12 @ @ import im . actor . server . mtproto . transport . _ 
 import im . actor . server . persist 
 import im . actor . server . persist . { AuthIdRepo , MasterKeyRepo } 
 import im . actor . util . misc . IdUtils 
 + import im . actor . util . ThreadLocalSecureRandom 
 import scodec . bits . BitVector 
 
 import scala . annotation . tailrec 
 import scala . collection . JavaConversions . _ 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . { Failure , Success , Try } 
 
 object ServerKey { 
 @ @ - 129 , 7 + 129 , 7 @ @ final class AuthorizationManager ( serverKeys : Seq [ ServerKey ] , sessionClient : Acto 
 def handleRequestAuthId ( ) : Unit = { 
 val f = 
 if ( authId = = 0L ) { 
 - authId = IdUtils . nextAuthId ( ThreadLocalRandom . current ( ) ) 
 + authId = IdUtils . nextAuthId ( ThreadLocalSecureRandom . current ( ) ) 
 db . run ( persist . AuthIdRepo . create ( authId , None , None ) ) 
 } else Future . successful ( ( ) ) 
 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 index d2d2d41 . . 0dcaec1 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / LocalFileStorageAdapter . scala 
 @ @ - 15 , 8 + 15 , 8 @ @ import im . actor . server . db . DbExtension 
 import im . actor . server . file . _ 
 import im . actor . server . file . local . http . FilesHttpHandler 
 import im . actor . server . { model , persist } 
 + import im . actor . util . ThreadLocalSecureRandom 
 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . { Failure , Success , Try } 
 
 @ @ - 77 , 7 + 77 , 7 @ @ final class LocalFileStorageAdapter ( _ system : ActorSystem ) 
 val baseUri = Uri ( httpConfig . baseUri ) 
 
 override def uploadFile ( name : UnsafeFileName , data : Array [ Byte ] ) : DBIO [ FileLocation ] = { 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 val id = ACLFiles . randomLong ( rng ) 
 val accessSalt = ACLFiles . nextAccessSalt ( rng ) 
 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 index b1aec30 . . 3905f91 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / s3 / S3StorageAdapter . scala 
 @ @ - 18 , 9 + 18 , 9 @ @ import im . actor . server . file . FileUtils . _ 
 import im . actor . server . file . _ 
 import im . actor . server . { model , persist } 
 import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . util . ThreadLocalSecureRandom 
 
 import scala . concurrent . duration . _ 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . concurrent . { ExecutionContext , Future } 
 
 final class S3StorageAdapter ( _ system : ActorSystem ) extends FileStorageAdapter { 
 @ @ - 83 , 9 + 83 , 9 @ @ final class S3StorageAdapter ( _ system : ActorSystem ) extends FileStorageAdapter { 
 } 
 
 private def uploadFile ( bucketName : String , name : UnsafeFileName , data : Array [ Byte ] ) : DBIO [ FileLocation ] = { 
 - val rnd = ThreadLocalRandom . current ( ) 
 - val id = rnd . nextLong ( ) 
 - val accessSalt = ACLFiles . nextAccessSalt ( rnd ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 + val id = rng . nextLong ( ) 
 + val accessSalt = ACLFiles . nextAccessSalt ( rng ) 
 val size = data . length 
 
 for { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 index 65e3a5d . . e38d226 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 @ @ - 22 , 11 + 22 , 11 @ @ import im . actor . util . misc . EmailUtils . isTestEmail 
 import im . actor . util . misc . IdUtils . _ 
 import im . actor . util . misc . PhoneNumberUtils . _ 
 import im . actor . util . misc . StringUtils . validName 
 + import im . actor . util . ThreadLocalSecureRandom 
 import org . joda . time . DateTime 
 import slick . dbio . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . Try 
 import scalaz . { - \ / , \ / , \ / - } 
 
 @ @ - 215 , 7 + 215 , 7 @ @ trait AuthHelpers extends Helpers { 
 / / refresh session data 
 authSession = model . AuthSession ( 
 userId = userId , 
 - id = nextIntId ( ThreadLocalRandom . current ( ) ) , 
 + id = nextIntId ( ) , 
 authId = clientData . authId , 
 appId = transaction . appId , 
 appTitle = model . AuthSession . appTitleOf ( transaction . appId ) , 
 @ @ - 247 , 7 + 247 , 7 @ @ trait AuthHelpers extends Helpers { 
 emailSender . send ( Some ( transactionHash ) , EmailCode ( email , code ) ) 
 } 
 
 - protected def genSmsHash ( ) = ThreadLocalRandom . current . nextLong ( ) . toString 
 + protected def genSmsHash ( ) = ThreadLocalSecureRandom . current . nextLong ( ) . toString 
 
 protected def genEmailCode ( email : String ) : String = 
 if ( isTestEmail ( email ) ) genTestCode ( email ) else genCode ( ) 
 @ @ - 258 , 7 + 258 , 7 @ @ trait AuthHelpers extends Helpers { 
 } 
 
 protected def newUser ( name : String , countryCode : String , optSex : Option [ ApiSex ] , username : Option [ String ] ) : Result [ \ / - [ User ] ] = { 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 val sex = optSex . map ( s ⇒ model . Sex . fromInt ( s . id ) ) . getOrElse ( model . NoSex ) 
 for { 
 validName ← fromEither ( validName ( name ) . leftMap ( validationFailed ( " NAME _ INVALID " , _ ) ) ) 
 @ @ - 277 , 7 + 277 , 7 @ @ trait AuthHelpers extends Helpers { 
 } 
 
 protected def newUser ( name : String ) : Result [ User ] = { 
 - val rng = ThreadLocalRandom . current ( ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 val user = model . User ( 
 id = nextIntId ( rng ) , 
 accessSalt = ACLUtils . nextAccessSalt ( rng ) , 
 @ @ - 302 , 6 + 302 , 6 @ @ trait AuthHelpers extends Helpers { 
 private def genTestCode ( email : String ) : String = 
 ( email replaceAll ( " " " . * acme " " " , " " ) ) replaceAll ( " . com " , " " ) 
 
 - private def genCode ( ) = ThreadLocalRandom . current . nextLong ( ) . toString . dropWhile ( c ⇒ c = = ' 0 ' | | c = = ' - ' ) . take ( 5 ) 
 + private def genCode ( ) = ThreadLocalSecureRandom . current . nextLong ( ) . toString . dropWhile ( c ⇒ c = = ' 0 ' | | c = = ' - ' ) . take ( 5 ) 
 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index 5c35406 . . 1cce886 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 31 , 6 + 31 , 7 @ @ import im . actor . server . { model , persist } 
 import im . actor . util . log . AnyRefLogSource 
 import im . actor . util . misc . PhoneNumberUtils . _ 
 import im . actor . util . misc . _ 
 + import im . actor . util . ThreadLocalSecureRandom 
 import org . joda . time . DateTime 
 import shapeless . _ 
 import slick . dbio . DBIO 
 @ @ - 38 , 7 + 39 , 6 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . language . postfixOps 
 import scalaz . _ 
 
 @ @ - 134 , 7 + 134 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 / / refresh session data 
 authSession = model . AuthSession ( 
 userId = user . id , 
 - id = nextIntId ( ThreadLocalRandom . current ( ) ) , 
 + id = nextIntId ( ) , 
 authId = clientData . authId , 
 appId = transaction . appId , 
 appTitle = model . AuthSession . appTitleOf ( transaction . appId ) , 
 @ @ - 488 , 7 + 488 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 val smsCode = genSmsCode ( normPhoneNumber ) 
 for ( 
 _ ← persist . AuthSmsCodeObsoleteRepo . create ( 
 - id = ThreadLocalRandom . current ( ) . nextLong ( ) , 
 + id = ThreadLocalSecureRandom . current ( ) . nextLong ( ) , 
 phoneNumber = normPhoneNumber , 
 smsHash = smsHash , 
 smsCode = smsCode 
 @ @ - 576 , 12 + 576 , 12 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 optPhone match { 
 / / Phone does not exist , register the user 
 case None ⇒ withValidName ( rawName ) { name ⇒ 
 - val rnd = ThreadLocalRandom . current ( ) 
 - val userId = nextIntId ( rnd ) 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 + val userId = nextIntId ( rng ) 
 / / todo : move this to UserOffice 
 val user = model . User ( 
 id = userId , 
 - accessSalt = ACLUtils . nextAccessSalt ( rnd ) , 
 + accessSalt = ACLUtils . nextAccessSalt ( rng ) , 
 name = name , 
 countryCode = countryCode , 
 sex = model . NoSex , 
 @ @ - 614 , 10 + 614 , 9 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 } 
 } . flatMap { 
 case \ / - ( user : : HNil ) ⇒ 
 - val rnd = ThreadLocalRandom . current ( ) 
 val authSession = model . AuthSession ( 
 userId = user . id , 
 - id = nextIntId ( rnd ) , 
 + id = nextIntId ( ) , 
 authId = clientData . authId , 
 appId = appId , 
 appTitle = model . AuthSession . appTitleOf ( appId ) , 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index dec628c . . 92e00f3 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 18 , 6 + 18 , 7 @ @ import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . user . { UserUtils , UserExtension } 
 import im . actor . server . { model , persist } 
 import im . actor . util . misc . IdUtils 
 + import im . actor . util . ThreadLocalSecureRandom 
 import slick . dbio . DBIO 
 import slick . driver . PostgresDriver . api . _ 
 
 @ @ - 43 , 7 + 44 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ 
 withFileLocation ( fileLocation , AvatarSizeLimit ) { 
 - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { 
 + scaleAvatar ( fileLocation . fileId , ThreadLocalSecureRandom . current ( ) ) flatMap { 
 case Right ( avatar ) ⇒ 
 for { 
 UpdateAvatarAck ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( groupExt . updateAvatar ( fullGroup . id , client . userId , Some ( avatar ) , randomId ) ) 
 @ @ - 146 , 7 + 147 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withUserOutPeers ( users ) { 
 withValidGroupTitle ( title ) { validTitle ⇒ 
 - val groupId = nextIntId ( ThreadLocalRandom . current ( ) ) 
 + val groupId = nextIntId ( ThreadLocalSecureRandom . current ( ) ) 
 val userIds = users . map ( _ . userId ) . toSet 
 val groupUserIds = userIds + client . userId 
 
 @ @ - 206 , 7 + 207 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 token ← persist . GroupInviteTokenRepo . find ( fullGroup . id , client . userId ) . headOption . flatMap { 
 case Some ( invToken ) ⇒ DBIO . successful ( invToken . token ) 
 case None ⇒ 
 - val token = accessToken ( ThreadLocalRandom . current ( ) ) 
 + val token = accessToken ( ThreadLocalSecureRandom . current ( ) ) 
 val inviteToken = model . GroupInviteToken ( fullGroup . id , client . userId , token ) 
 for ( _ ← persist . GroupInviteTokenRepo . create ( inviteToken ) ) yield token 
 } 
 @ @ - 263 , 7 + 264 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 override def jhandleRevokeInviteUrl ( groupPeer : ApiGroupOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseInviteUrl ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withOwnGroupMember ( groupPeer , client . userId ) { fullGroup ⇒ 
 - val token = accessToken ( ThreadLocalRandom . current ( ) ) 
 + val token = accessToken ( ThreadLocalSecureRandom . current ( ) ) 
 val inviteToken = model . GroupInviteToken ( fullGroup . id , client . userId , token ) 
 
 for { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 index f37ff88 . . 6def758 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / profile / ProfileServiceImpl . scala 
 @ @ - 13 , 6 + 13 , 7 @ @ import im . actor . server . persist 
 import im . actor . server . sequence . { SequenceErrors , SeqState } 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 import im . actor . server . user . _ 
 + import im . actor . util . ThreadLocalSecureRandom 
 import im . actor . util . misc . StringUtils 
 import slick . driver . PostgresDriver . api . _ 
 
 @ @ - 48 , 7 + 49 , 7 @ @ final class ProfileServiceImpl ( ) ( implicit system : ActorSystem ) extends ProfileSe 
 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withFileLocation ( fileLocation , AvatarSizeLimit ) { 
 - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { 
 + scaleAvatar ( fileLocation . fileId , ThreadLocalSecureRandom . current ( ) ) flatMap { 
 case Right ( avatar ) ⇒ 
 for { 
 UserCommands . UpdateAvatarAck ( avatar , SeqState ( seq , state ) ) ← DBIO . from ( userExt . updateAvatar ( client . userId , Some ( avatar ) ) ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 index d23b981 . . 5f0eb26 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / acl / ACLBase . scala 
 @ @ - 4 , 8 + 4 , 7 @ @ import java . nio . ByteBuffer 
 import java . security . MessageDigest 
 
 import akka . actor . ActorSystem 
 - 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import im . actor . util . ThreadLocalSecureRandom 
 
 trait ACLBase { 
 
 @ @ - 17 , 18 + 16 , 18 @ @ trait ACLBase { 
 def hash ( s : String , md : MessageDigest = getMDInstance ( ) ) : Long = 
 ByteBuffer . wrap ( md . digest ( s . getBytes ) ) . getLong 
 
 - def randomLong ( ) : Long = randomLong ( ThreadLocalRandom . current ( ) ) 
 + def randomLong ( ) : Long = randomLong ( ThreadLocalSecureRandom . current ( ) ) 
 
 - def randomLong ( rng : ThreadLocalRandom ) : Long = rng . nextLong ( ) 
 + def randomLong ( rng : ThreadLocalSecureRandom ) : Long = rng . nextLong ( ) 
 
 - def randomString ( ) : String = randomString ( ThreadLocalRandom . current ( ) ) 
 + def randomString ( ) : String = randomString ( ThreadLocalSecureRandom . current ( ) ) 
 
 - def randomString ( rng : ThreadLocalRandom ) : String = rng . nextLong ( ) . toString 
 + def randomString ( rng : ThreadLocalSecureRandom ) : String = rng . nextLong ( ) . toString 
 
 - def nextAccessSalt ( rng : ThreadLocalRandom ) : String = randomString ( rng ) 
 + def nextAccessSalt ( rng : ThreadLocalSecureRandom ) : String = randomString ( rng ) 
 
 def nextAccessSalt ( ) : String = { 
 - nextAccessSalt ( ThreadLocalRandom . current ( ) ) 
 + nextAccessSalt ( ThreadLocalSecureRandom . current ( ) ) 
 } 
 
 } 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala b / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala 
 index faeda75 . . 0347069 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / util / misc / IdUtils . scala 
 @ @ - 1 , 17 + 1 , 20 @ @ 
 package im . actor . util . misc 
 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import im . actor . util . ThreadLocalSecureRandom 
 
 object IdUtils { 
 - def nextIntId ( ) : Int = nextIntId ( ThreadLocalRandom . current ( ) ) 
 + def nextIntId ( ) : Int = nextIntId ( ThreadLocalSecureRandom . current ( ) ) 
 
 - def nextIntId ( rnd : ThreadLocalRandom ) : Int = rnd . nextInt ( 1000 , Int . MaxValue ) + 1 
 + def nextIntId ( rnd : ThreadLocalSecureRandom ) : Int = { 
 + val min = 1000 
 + min + rnd . nextInt ( Int . MaxValue - min + 1 ) 
 + } 
 
 - def nextLongId ( ) : Long = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + def nextLongId ( ) : Long = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 
 - def nextAuthId ( ) : Long = nextAuthId ( ThreadLocalRandom . current ( ) ) 
 + def nextAuthId ( ) : Long = nextAuthId ( ThreadLocalSecureRandom . current ( ) ) 
 
 - def nextAuthId ( rng : ThreadLocalRandom ) : Long = { 
 + def nextAuthId ( rng : ThreadLocalSecureRandom ) : Long = { 
 val candidate = rng . nextLong ( ) 
 if ( candidate = = 0L ) nextAuthId ( rng ) else candidate 
 } 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 9dd0ae7 . . f30b52e 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ 
 
 object Dependencies { 
 object V { 
 - val actorCommons = " 0 . 0 . 11 " 
 + val actorCommons = " 0 . 0 . 12 " 
 val actorBotkit = " 1 . 0 . 66 " 
 val akka = " 2 . 4 . 0 " 
 val akkaExperimental = " 2 . 0 . 2 "

NEAREST DIFF:
diff - - git a / actor - server / actor - commons - api / src / main / protobuf / file . proto b / actor - server / actor - commons - api / src / main / protobuf / file . proto 
 new file mode 100644 
 index 0000000 . . 511bca7 
 - - - / dev / null 
 + + + b / actor - server / actor - commons - api / src / main / protobuf / file . proto 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + syntax = " proto2 " ; 
 + 
 + package im . actor . server ; 
 + 
 + message FileLocation { 
 + required int64 file _ id = 1 ; 
 + required int64 access _ hash = 2 ; 
 + } 
 + 
 + message AvatarImage { 
 + required FileLocation file _ location = 1 ; 
 + required int32 width = 2 ; 
 + required int32 height = 3 ; 
 + required int64 file _ size = 4 ; 
 + } 
 + 
 + message Avatar { 
 + optional AvatarImage small = 1 ; 
 + optional AvatarImage large = 2 ; 
 + optional AvatarImage full = 3 ; 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala 
 new file mode 100644 
 index 0000000 . . 5ac78fc 
 - - - / dev / null 
 + + + b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / ApiConversions . scala 
 @ @ - 0 , 0 + 1 , 39 @ @ 
 + package im . actor . server . api 
 + 
 + import scala . language . implicitConversions 
 + 
 + import im . actor . api . rpc . files . { Avatar ⇒ ApiAvatar , AvatarImage ⇒ ApiAvatarImage , FileLocation ⇒ ApiFileLocation } 
 + import im . actor . server . file . { FileLocation , AvatarImage , Avatar } 
 + 
 + object ApiConversions { 
 + 
 + implicit def apiToFileLocation ( fl : ApiFileLocation ) : FileLocation = 
 + FileLocation ( fl . fileId , fl . accessHash ) 
 + 
 + implicit def apiToAvatarImage ( image : ApiAvatarImage ) : AvatarImage = 
 + AvatarImage ( image . fileLocation , image . width , image . height , image . fileSize . toLong ) 
 + 
 + implicit def apiToAvatarImage ( imageOpt : Option [ ApiAvatarImage ] ) : Option [ AvatarImage ] = 
 + imageOpt map apiToAvatarImage 
 + 
 + implicit def apiToAvatar ( avatar : ApiAvatar ) : Avatar = 
 + Avatar ( avatar . smallImage , avatar . largeImage , avatar . fullImage ) 
 + 
 + implicit def apiOptToAvatar ( avatarOpt : Option [ ApiAvatar ] ) : Option [ Avatar ] = 
 + avatarOpt map apiToAvatar 
 + 
 + implicit def fileLocationToApi ( fl : FileLocation ) : ApiFileLocation = 
 + ApiFileLocation ( fl . fileId , fl . accessHash ) 
 + 
 + implicit def avatarImageToApi ( image : AvatarImage ) : ApiAvatarImage = 
 + ApiAvatarImage ( image . fileLocation , image . width , image . height , image . fileSize . toInt ) 
 + 
 + implicit def avatarImageOptToApi ( imageOpt : Option [ AvatarImage ] ) : Option [ ApiAvatarImage ] = 
 + imageOpt map avatarImageToApi 
 + 
 + implicit def avatarToApi ( avatar : Avatar ) : ApiAvatar = 
 + ApiAvatar ( avatar . small , avatar . large , avatar . full ) 
 + 
 + implicit def avatarOptToApi ( avatarOpt : Option [ Avatar ] ) : Option [ ApiAvatar ] = 
 + avatarOpt map avatarToApi 
 + } 
 diff - - git a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala 
 index 3b7b97c . . 2352f9e 100644 
 - - - a / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala 
 + + + b / actor - server / actor - commons - api / src / main / scala / im / actor / server / api / TypeMappers . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import com . google . protobuf . { ByteString , CodedInputStream } 
 import com . trueaccord . scalapb . TypeMapper 
 import org . joda . time . DateTime 
 
 + import im . actor . api . rpc . files . Avatar 
 import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } 
 import im . actor . api . rpc . peers . Peer 
 
 @ @ - 33 , 9 + 34 , 17 @ @ trait MessageMapper { 
 
 private def unapplyDateTime ( dt : DateTime ) : Long = dt . getMillis 
 
 + private def applyAvatar ( buf : ByteString ) : Avatar = 
 + Avatar . parseFrom ( CodedInputStream . newInstance ( buf . asReadOnlyByteBuffer ( ) ) ) . right . get 
 + 
 + private def unapplyAvatar ( avatar : Avatar ) : ByteString = 
 + ByteString . copyFrom ( avatar . toByteArray ) 
 + 
 implicit val messageMapper : TypeMapper [ ByteString , ApiMessage ] = TypeMapper ( applyMessage ) ( unapplyMessage ) 
 
 implicit val peerMapper : TypeMapper [ ByteString , Peer ] = TypeMapper ( applyPeer ) ( unapplyPeer ) 
 
 implicit val dateTimeMapper : TypeMapper [ Long , DateTime ] = TypeMapper ( applyDateTime ) ( unapplyDateTime ) 
 + 
 + implicit val avatarMapper : TypeMapper [ ByteString , Avatar ] = TypeMapper ( applyAvatar ) ( unapplyAvatar ) 
 } 
 diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / file . proto b / actor - server / actor - peer - managers / src / main / protobuf / file . proto 
 new file mode 100644 
 index 0000000 . . 511bca7 
 - - - / dev / null 
 + + + b / actor - server / actor - peer - managers / src / main / protobuf / file . proto 
 @ @ - 0 , 0 + 1 , 21 @ @ 
 + syntax = " proto2 " ; 
 + 
 + package im . actor . server ; 
 + 
 + message FileLocation { 
 + required int64 file _ id = 1 ; 
 + required int64 access _ hash = 2 ; 
 + } 
 + 
 + message AvatarImage { 
 + required FileLocation file _ location = 1 ; 
 + required int32 width = 2 ; 
 + required int32 height = 3 ; 
 + required int64 file _ size = 4 ; 
 + } 
 + 
 + message Avatar { 
 + optional AvatarImage small = 1 ; 
 + optional AvatarImage large = 2 ; 
 + optional AvatarImage full = 3 ; 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / group . proto b / actor - server / actor - peer - managers / src / main / protobuf / group . proto 
 index 4cc138b . . e6781b4 100644 
 - - - a / actor - server / actor - peer - managers / src / main / protobuf / group . proto 
 + + + b / actor - server / actor - peer - managers / src / main / protobuf / group . proto 
 @ @ - 8 , 6 + 8 , 8 @ @ option ( scalapb . options ) = { 
 } ; 
 
 import " scalapb / scalapb . proto " ; 
 + import " file . proto " ; 
 + import " sequence . proto " ; 
 
 message GroupEnvelope { 
 required int32 user _ id = 1 ; 
 @ @ - 21 , 6 + 23 , 7 @ @ message GroupEnvelope { 
 Invite invite = 7 ; 
 Leave leave = 8 ; 
 Create create = 9 ; 
 + UpdateAvatar update _ Avatar = 10 ; 
 } 
 
 message Create { 
 @ @ - 86 , 6 + 89 , 18 @ @ message GroupEnvelope { 
 required int64 auth _ id = 2 ; 
 required int64 random _ id = 3 ; 
 } 
 + 
 + message UpdateAvatar { 
 + required int32 client _ user _ id = 1 ; 
 + required int64 client _ auth _ id = 2 ; 
 + optional FileLocation file _ location = 3 ; 
 + required int64 random _ id = 4 ; 
 + } 
 + 
 + message UpdateAvatarResponse { 
 + optional bytes avatar = 1 [ ( scalapb . field ) . type = " im . actor . api . rpc . files . Avatar " ] ; 
 + required SeqStateDate seqstatedate = 2 ; 
 + } 
 } 
 
 message GroupEvents { 
 @ @ - 147 , 5 + 162 , 11 @ @ message GroupEvents { 
 
 required int32 user _ id = 1 ; 
 } 
 + 
 + message AvatarUpdated { 
 + option ( scalapb . message ) . extends = " im . actor . server . group . GroupEvent " ; 
 + 
 + optional Avatar avatar = 1 ; 
 + } 
 } 
 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala 
 new file mode 100644 
 index 0000000 . . 0ecf687 
 - - - / dev / null 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / file / FileErrors . scala 
 @ @ - 0 , 0 + 1 , 7 @ @ 
 + package im . actor . server . file 
 + 
 + import scala . util . control . NoStackTrace 
 + 
 + object FileErrors { 
 + object LocationInvalid extends IllegalArgumentException with NoStackTrace 
 + } 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala 
 new file mode 100644 
 index 0000000 . . 2cfad8d 
 - - - / dev / null 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupCommands . scala 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + package im . actor . server . group 
 + 
 + import scala . concurrent . Future 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + 
 + import akka . actor . ActorRef 
 + import akka . pattern . pipe 
 + import org . joda . time . DateTime 
 + import slick . dbio . DBIO 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import im . actor . api . rpc . groups . UpdateGroupAvatarChanged 
 + import im . actor . server . api . ApiConversions . _ 
 + import im . actor . server . file . { FileErrors , FileLocation } 
 + import im . actor . server . group . GroupEnvelope . UpdateAvatarResponse 
 + import im . actor . server . group . GroupEvents . AvatarUpdated 
 + import im . actor . server . push . SeqUpdatesManager . _ 
 + import im . actor . server . push . SeqUpdatesManagerRegion 
 + import im . actor . server . sequence . SeqStateDate 
 + import im . actor . server . util . ImageUtils . _ 
 + import im . actor . server . util . { FileStorageAdapter , GroupServiceMessages , HistoryUtils } 
 + import im . actor . server . { models , persist ⇒ p } 
 + 
 + private [ group ] trait GroupCommands { 
 + self : GroupOfficeActor ⇒ 
 + 
 + private implicit val system = context . system 
 + private implicit val ec = context . dispatcher 
 + 
 + protected def updateAvatar ( group : Group , sendr : ActorRef , clientUserId : Int , clientAuthId : Long , fileLocationOpt : Option [ FileLocation ] , randomId : Long ) ( 
 + implicit 
 + fsAdapter : FileStorageAdapter , 
 + db : Database , 
 + seqUpdManagerRegion : SeqUpdatesManagerRegion 
 + ) : Unit = { 
 + val avatarFuture = fileLocationOpt match { 
 + case Some ( fileLocation ) ⇒ 
 + db . run ( scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) map { 
 + case Right ( avatar ) ⇒ 
 + Some ( avatar ) 
 + case Left ( e ) ⇒ 
 + log . error ( e , " Failed to scale group avatar " ) 
 + throw FileErrors . LocationInvalid 
 + } 
 + case None ⇒ 
 + Future . successful ( None ) 
 + } 
 + 
 + avatarFuture foreach { avatarOpt ⇒ 
 + val date = new DateTime 
 + val avatarDataOpt = avatarOpt map ( getAvatarData ( models . AvatarData . OfGroup , groupId , _ ) ) 
 + 
 + persist ( AvatarUpdated ( avatarOpt ) ) { evt ⇒ 
 + context become working ( updateState ( evt , group ) ) 
 + 
 + val update = UpdateGroupAvatarChanged ( groupId , clientUserId , avatarOpt , date . getMillis , randomId ) 
 + val serviceMessage = GroupServiceMessages . changedAvatar ( avatarOpt ) 
 + 
 + db . run ( for { 
 + _ ← avatarDataOpt map ( p . AvatarData . createOrUpdate ( _ ) ) getOrElse ( DBIO . successful ( ( ) ) ) 
 + groupUserIds ← p . GroupUser . findUserIds ( groupId ) 
 + ( seqstate , _ ) ← broadcastClientAndUsersUpdate ( clientUserId , clientAuthId , groupUserIds . toSet , update , None , isFat = false ) 
 + } yield { 
 + db . run ( HistoryUtils . writeHistoryMessage ( 
 + models . Peer . privat ( clientUserId ) , 
 + models . Peer . group ( groupId ) , 
 + date , 
 + randomId , 
 + serviceMessage . header , 
 + serviceMessage . toByteArray 
 + ) ) 
 + 
 + UpdateAvatarResponse ( avatarOpt , SeqStateDate ( seqstate . seq , seqstate . state , date . getMillis ) ) 
 + } ) pipeTo sendr 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 index bdecb99 . . a250234 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 @ @ - 20 , 6 + 20 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 import im . actor . api . rpc . groups . { UpdateGroupInvite , UpdateGroupUserInvited , UpdateGroupUserKick , UpdateGroupUserLeave } 
 import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage , _ } 
 import im . actor . server . commons . serialization . ActorSerializer 
 + import im . actor . server . file . Avatar 
 import im . actor . server . models . UserState . Registered 
 import im . actor . server . office . PeerOffice . MessageSentComplete 
 import im . actor . server . office . { PeerOffice , PushTexts } 
 @ @ - 28 , 7 + 29 , 7 @ @ import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . user . { UserOffice , UserOfficeRegion } 
 import im . actor . server . util . ACLUtils . _ 
 import im . actor . server . util . IdUtils . _ 
 - import im . actor . server . util . { GroupServiceMessages , HistoryUtils , UserUtils } 
 + import im . actor . server . util . { FileStorageAdapter , GroupServiceMessages , HistoryUtils , UserUtils } 
 import im . actor . server . { models , persist ⇒ p } 
 import im . actor . utils . cache . CacheHelpers . _ 
 
 @ @ - 50 , 7 + 51 , 8 @ @ case class Group ( 
 lastSenderId : Option [ Int ] , 
 lastReceivedDate : Option [ DateTime ] , 
 lastReadDate : Option [ DateTime ] , 
 - botUserId : Int 
 + botUserId : Int , 
 + avatarOpt : Option [ Avatar ] 
 ) 
 
 trait GroupEvent 
 @ @ - 69 , 6 + 71 , 7 @ @ private [ group ] object GroupOfficeActor { 
 ActorSerializer . register ( 5007 , classOf [ GroupEnvelope . SendMessage ] ) 
 ActorSerializer . register ( 5008 , classOf [ GroupEnvelope . MessageReceived ] ) 
 ActorSerializer . register ( 5009 , classOf [ GroupEnvelope . MessageRead ] ) 
 + ActorSerializer . register ( 5010 , classOf [ GroupEnvelope . UpdateAvatar ] ) 
 
 ActorSerializer . register ( 6001 , classOf [ GroupEvents . MessageRead ] ) 
 ActorSerializer . register ( 6002 , classOf [ GroupEvents . MessageReceived ] ) 
 @ @ - 78 , 22 + 81 , 24 @ @ private [ group ] object GroupOfficeActor { 
 ActorSerializer . register ( 6006 , classOf [ GroupEvents . BotAdded ] ) 
 ActorSerializer . register ( 6007 , classOf [ GroupEvents . UserKicked ] ) 
 ActorSerializer . register ( 6008 , classOf [ GroupEvents . UserLeft ] ) 
 + ActorSerializer . register ( 6007 , classOf [ GroupEvents . AvatarUpdated ] ) 
 
 def props ( 
 implicit 
 db : Database , 
 seqUpdManagerRegion : SeqUpdatesManagerRegion , 
 - userOfficeRegion : UserOfficeRegion 
 - ) : Props = 
 - Props ( classOf [ GroupOfficeActor ] , db , seqUpdManagerRegion , userOfficeRegion ) 
 + userOfficeRegion : UserOfficeRegion , 
 + fsAdapter : FileStorageAdapter 
 + ) : Props = Props ( classOf [ GroupOfficeActor ] , db , seqUpdManagerRegion , userOfficeRegion , fsAdapter ) 
 } 
 
 - private [ group ] class GroupOfficeActor ( 
 + private [ group ] final class GroupOfficeActor ( 
 implicit 
 db : Database , 
 seqUpdManagerRegion : SeqUpdatesManagerRegion , 
 - userOfficeRegion : UserOfficeRegion 
 - ) extends PeerOffice with ActorLogging with Stash with GroupsImplicits { 
 + userOfficeRegion : UserOfficeRegion , 
 + fsAdapter : FileStorageAdapter 
 + ) extends PeerOffice with GroupCommands with ActorLogging with Stash with GroupsImplicits { 
 
 import GroupEnvelope . _ 
 import GroupErrors . _ 
 @ @ - 107 , 7 + 112 , 7 @ @ private [ group ] class GroupOfficeActor ( 
 
 implicit private val timeout : Timeout = Timeout ( 10 . seconds ) 
 
 - private val groupId = self . path . name . toInt 
 + protected val groupId = self . path . name . toInt 
 
 override def persistenceId = s " group _ $ { groupId } " 
 
 @ @ - 391 , 6 + 396 , 8 @ @ private [ group ] class GroupOfficeActor ( 
 case e ⇒ replyTo ! Status . Failure ( e ) 
 } 
 } 
 + case Payload . UpdateAvatar ( UpdateAvatar ( clientUserId , clientAuthId , fileLocationOpt , randomId ) ) ⇒ 
 + updateAvatar ( group , sender ( ) , clientUserId , clientAuthId , fileLocationOpt , randomId ) 
 case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = PoisonPill ) 
 } 
 
 @ @ - 425 , 11 + 432 , 12 @ @ private [ group ] class GroupOfficeActor ( 
 lastReceivedDate = None , 
 lastReadDate = None , 
 botUserId = 0 , 
 - invitedUserIds = Set . empty 
 + invitedUserIds = Set . empty , 
 + avatarOpt = None 
 ) 
 } 
 
 - private def updateState ( evt : GroupEvent , state : Group ) : Group = { 
 + protected def updateState ( evt : GroupEvent , state : Group ) : Group = { 
 evt match { 
 case GroupEvents . BotAdded ( userId ) ⇒ 
 state . copy ( botUserId = userId ) 
 @ @ - 453 , 6 + 461 , 8 @ @ private [ group ] class GroupOfficeActor ( 
 state . copy ( members = state . members - userId ) 
 case GroupEvents . UserLeft ( userId , _ ) ⇒ 
 state . copy ( members = state . members - userId ) 
 + case GroupEvents . AvatarUpdated ( avatarOpt ) ⇒ 
 + state . copy ( avatarOpt = avatarOpt ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala 
 index 69193db . . a6cb194 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeRegion . scala 
 @ @ - 6 , 6 + 6 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . server . push . SeqUpdatesManagerRegion 
 import im . actor . server . user . UserOfficeRegion 
 + import im . actor . server . util . FileStorageAdapter 
 
 object GroupOfficeRegion { 
 private val idExtractor : ShardRegion . IdExtractor = { 
 @ @ - 29 , 9 + 30 , 9 @ @ object GroupOfficeRegion { 
 system : ActorSystem , 
 db : Database , 
 seqUpdManagerRegion : SeqUpdatesManagerRegion , 
 - userOfficeRegion : UserOfficeRegion 
 - ) : GroupOfficeRegion = 
 - start ( Some ( GroupOfficeActor . props ) ) 
 + userOfficeRegion : UserOfficeRegion , 
 + fsAdapter : FileStorageAdapter 
 + ) : GroupOfficeRegion = start ( Some ( GroupOfficeActor . props ) ) 
 
 def startProxy ( ) ( implicit system : ActorSystem ) : GroupOfficeRegion = 
 start ( None ) 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index e773422 . . 81fa9c5 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 6 , 7 + 6 , 9 @ @ import akka . pattern . ask 
 import akka . util . Timeout 
 
 import im . actor . api . rpc . AuthorizedClientData 
 + import im . actor . api . rpc . files . { FileLocation ⇒ ApiFileLocation } 
 import im . actor . api . rpc . messaging . { Message ⇒ ApiMessage } 
 + import im . actor . server . file . FileLocation 
 import im . actor . server . sequence . SeqStateDate 
 
 trait GroupOperations { 
 @ @ - 75 , 4 + 77 , 14 @ @ trait GroupOperations { 
 peerManagerRegion . ref ! GroupEnvelope ( groupId ) . withMessageRead ( MessageRead ( readerUserId , readerAuthId , date , readDate ) ) 
 } 
 
 + def updateAvatar ( groupId : Int , clientUserId : Int , clientAuthId : Long , fileLocationOpt : Option [ ApiFileLocation ] , randomId : Long ) ( 
 + implicit 
 + region : GroupOfficeRegion , 
 + timeout : Timeout , 
 + ec : ExecutionContext 
 + ) : Future [ UpdateAvatarResponse ] = { 
 + val fl = fileLocationOpt map ( f ⇒ FileLocation ( f . fileId , f . accessHash ) ) 
 + 
 + ( region . ref ? GroupEnvelope ( groupId ) . withUpdateAvatar ( UpdateAvatar ( clientUserId , clientAuthId , fl , randomId ) ) ) . mapTo [ UpdateAvatarResponse ] 
 + } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index 7e9a283 . . 9e7698d 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 16 , 6 + 16 , 8 @ @ import im . actor . api . rpc . files . FileLocation 
 import im . actor . api . rpc . groups . _ 
 import im . actor . api . rpc . misc . ResponseSeqDate 
 import im . actor . api . rpc . peers . { GroupOutPeer , UserOutPeer } 
 + import im . actor . server . file . FileErrors 
 + import im . actor . server . group . GroupEnvelope . UpdateAvatarResponse 
 import im . actor . server . group . { GroupErrors , GroupOffice , GroupOfficeRegion } 
 import im . actor . server . presences . { GroupPresenceManager , GroupPresenceManagerRegion } 
 import im . actor . server . push . SeqUpdatesManager . _ 
 @ @ - 47 , 66 + 49 , 37 @ @ class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ 
 withFileLocation ( fileLocation , AvatarSizeLimit ) { 
 - scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) flatMap { 
 - case Right ( avatar ) ⇒ 
 - val date = new DateTime 
 - val avatarData = getAvatarData ( models . AvatarData . OfGroup , fullGroup . id , avatar ) 
 - 
 - val update = UpdateGroupAvatarChanged ( fullGroup . id , client . userId , Some ( avatar ) , date . getMillis , randomId ) 
 - val serviceMessage = GroupServiceMessages . changedAvatar ( Some ( avatar ) ) 
 - 
 - for { 
 - _ ← persist . AvatarData . createOrUpdate ( avatarData ) 
 - groupUserIds ← persist . GroupUser . findUserIds ( fullGroup . id ) 
 - _ ← broadcastClientAndUsersUpdate ( groupUserIds . toSet , update , None ) 
 - seqstate ← broadcastClientUpdate ( update , None ) 
 - _ ← HistoryUtils . writeHistoryMessage ( 
 - models . Peer . privat ( client . userId ) , 
 - models . Peer . group ( fullGroup . id ) , 
 - date , 
 - randomId , 
 - serviceMessage . header , 
 - serviceMessage . toByteArray 
 - ) 
 - } yield { 
 - Ok ( ResponseEditGroupAvatar ( avatar , seqstate . seq , seqstate . state . toByteArray , date . getMillis ) ) 
 - } 
 - case Left ( e ) ⇒ 
 - actorSystem . log . error ( e , " Failed to scale group avatar " ) 
 - DBIO . successful ( Error ( Errors . LocationInvalid ) ) 
 - } 
 + for { 
 + UpdateAvatarResponse ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( GroupOffice . updateAvatar ( fullGroup . id , client . userId , client . authId , Some ( fileLocation ) , randomId ) ) 
 + } yield Ok ( ResponseEditGroupAvatar ( 
 + avatar . get , 
 + seq , 
 + state . toByteArray , 
 + date 
 + ) ) 
 } 
 } 
 } 
 
 - db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) 
 + db . run ( toDBIOAction ( authorizedAction ) ) recover { 
 + case FileErrors . LocationInvalid ⇒ Error ( Errors . LocationInvalid ) 
 + } 
 } 
 
 override def jhandleRemoveGroupAvatar ( groupOutPeer : GroupOutPeer , randomId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 withOwnGroupMember ( groupOutPeer , client . userId ) { fullGroup ⇒ 
 - val date = new DateTime 
 - val update = UpdateGroupAvatarChanged ( fullGroup . id , client . userId , None , date . getMillis , randomId ) 
 - val serviceMessage = GroupServiceMessages . changedAvatar ( None ) 
 - 
 for { 
 - _ ← persist . AvatarData . createOrUpdate ( models . AvatarData . empty ( models . AvatarData . OfGroup , fullGroup . id . toLong ) ) 
 - groupUserIds ← persist . GroupUser . findUserIds ( fullGroup . id ) 
 - _ ← broadcastClientAndUsersUpdate ( groupUserIds . toSet , update , None ) 
 - seqstate ← broadcastClientUpdate ( update , None ) 
 - _ ← HistoryUtils . writeHistoryMessage ( 
 - models . Peer . privat ( client . userId ) , 
 - models . Peer . group ( fullGroup . id ) , 
 - date , 
 - randomId , 
 - serviceMessage . header , 
 - serviceMessage . toByteArray 
 - ) 
 - } yield Ok ( ResponseSeqDate ( seqstate . seq , seqstate . state . toByteArray , date . getMillis ) ) 
 + UpdateAvatarResponse ( avatar , SeqStateDate ( seq , state , date ) ) ← DBIO . from ( GroupOffice . updateAvatar ( fullGroup . id , client . userId , client . authId , None , randomId ) ) 
 + } yield Ok ( ResponseSeqDate ( 
 + seq , 
 + state . toByteArray , 
 + date 
 + ) ) 
 } 
 } 
 
 - db . run ( toDBIOAction ( authorizedAction map ( _ . transactionally ) ) ) 
 + db . run ( toDBIOAction ( authorizedAction ) ) 
 } 
 
 override def jhandleKickUser ( groupOutPeer : GroupOutPeer , randomId : Long , userOutPeer : UserOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeqDate ] ] = { 
 diff - - git a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 index 1218b74 . . 3339e47 100644 
 - - - a / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 + + + b / actor - server / actor - runner / src / main / scala / im / actor / server / Main . scala 
 @ @ - 35 , 7 + 35 , 7 @ @ import im . actor . server . session . { Session , SessionConfig } 
 import im . actor . server . sms . TelesignSmsEngine 
 import im . actor . server . social . SocialManager 
 import im . actor . server . user . UserOfficeRegion 
 - import im . actor . server . util . { S3StorageAdapter , S3StorageAdapterConfig } 
 + import im . actor . server . util . { FileStorageAdapter , S3StorageAdapter , S3StorageAdapterConfig } 
 
 class Main extends Bootable with DbInit with FlywayInit { 
 val serverConfig = ActorConfig . load ( ) 
 @ @ - 69 , 9 + 69 , 12 @ @ class Main extends Bootable with DbInit with FlywayInit { 
 flyway . migrate ( ) 
 
 implicit val googlePushManager = new GooglePushManager ( googlePushConfig ) 
 - 
 implicit val apnsManager = new ApplePushManager ( applePushConfig , system ) 
 
 + / / FIXME : FilesServiceImpl depends on S3StorageAdapter type 
 + implicit val fsAdapterS3 : S3StorageAdapter = new S3StorageAdapter ( s3StorageAdapterConfig ) 
 + implicit val fsAdapter : FileStorageAdapter = fsAdapterS3 
 + 
 implicit val seqUpdManagerRegion = SeqUpdatesManagerRegion . start ( ) 
 implicit val weakUpdManagerRegion = WeakUpdatesManager . startRegion ( ) 
 implicit val presenceManagerRegion = PresenceManager . startRegion ( ) 
 @ @ - 80 , 8 + 83 , 6 @ @ class Main extends Bootable with DbInit with FlywayInit { 
 implicit val privatePeerManagerRegion = UserOfficeRegion . start ( ) 
 implicit val groupPeerManagerRegion = GroupOfficeRegion . start ( ) 
 
 - implicit val fsAdapter = new S3StorageAdapter ( s3StorageAdapterConfig ) 
 - 
 val mediator = DistributedPubSubExtension ( system ) . mediator 
 
 val activationContext = serverConfig . getString ( " services . activation . default - service " ) match { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala 
 index 5b5ae93 . . a2f0471 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / Implicits . scala 
 @ @ - 44 , 7 + 44 , 8 @ @ trait ImplicitFileStorageAdapter { 
 implicit val db : Database 
 implicit val awsCredentials : AWSCredentialsProvider 
 
 - implicit lazy val fsAdapter : S3StorageAdapter = new S3StorageAdapter ( S3StorageAdapterConfig . load . get ) 
 + implicit lazy val fsAdapterS3 : S3StorageAdapter = new S3StorageAdapter ( S3StorageAdapterConfig . load . get ) 
 + implicit lazy val fsAdapter : FileStorageAdapter = fsAdapterS3 
 } 
 
 trait ImplicitServiceDependencies extends ImplicitFileStorageAdapter 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 index 1301548 . . 1b0dda3 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / SimpleServerE2eSpec . scala 
 @ @ - 2 , 9 + 2 , 6 @ @ package im . actor . server 
 
 import java . net . InetSocketAddress 
 
 - import im . actor . server . group . { GroupOfficeRegion , GroupOffice } 
 - import im . actor . server . user . { UserOfficeRegion , UserOffice } 
 - 
 import scala . concurrent . ExecutionContext 
 import scala . util . Random 
 
 @ @ - 26 , 6 + 23 , 7 @ @ import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 import im . actor . server . api . rpc . { RpcApiService , RpcResultCodec } 
 import im . actor . server . db . DbInit 
 + import im . actor . server . group . GroupOfficeRegion 
 import im . actor . server . mtproto . codecs . protocol . _ 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . { MTPackage , TransportPackage } 
 @ @ - 34 , 16 + 32 , 17 @ @ import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 import im . actor . server . push . _ 
 import im . actor . server . session . { Session , SessionConfig } 
 import im . actor . server . social . SocialManager 
 + import im . actor . server . user . UserOfficeRegion 
 
 class SimpleServerE2eSpec extends ActorFlatSuite ( 
 ActorSpecification . createSystem ( ConfigFactory . parseString ( 
 " " " 
 - | session { 
 - | idle - timeout = 5 seconds 
 - | } 
 - " " " . stripMargin 
 + | session { 
 + | idle - timeout = 5 seconds 
 + | } 
 + " " " . stripMargin 
 ) ) 
 - ) with DbInit with SqlSpecHelpers { 
 + ) with DbInit with SqlSpecHelpers with ImplicitFileStorageAdapter { 
 behavior of " Server " 
 
 it should " connect and Handshake " in Server . e1 
 @ @ - 58 , 6 + 57 , 8 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 
 implicit lazy val ( ds , db ) = migrateAndInitDb ( ) 
 
 + val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) 
 + 
 object Server { 
 val serverConfig = system . settings . config 
 
 @ @ - 86 , 8 + 87 , 6 @ @ class SimpleServerE2eSpec extends ActorFlatSuite ( 
 Session . startRegion ( Some ( Session . props ( mediator ) ) ) 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 
 - val bucketName = " actor - uploads - test " 
 - val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) 
 implicit val transferManager = new TransferManager ( awsCredentials ) 
 implicit val ec : ExecutionContext = system . dispatcher 
 implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 index d0cb1bc . . ab01717 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . api . rpc . groups . UpdateGroupUserLeave 
 import im . actor . api . rpc . misc . ResponseSeq 
 import im . actor . api . rpc . sequence . { DifferenceUpdate , ResponseGetDifference } 
 import im . actor . api . rpc . users . UpdateUserNameChanged 
 - import im . actor . server . { ActorSpecification , BaseAppSuite } 
 + import im . actor . server . { ImplicitFileStorageAdapter , ActorSpecification , BaseAppSuite } 
 import im . actor . server . api . rpc . service . sequence . SequenceServiceConfig 
 import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } 
 import im . actor . server . presences . PresenceManager 
 @ @ - 33 , 7 + 33 , 7 @ @ class SequenceServiceSpec extends BaseAppSuite ( { 
 " " " 
 ) 
 ) 
 - } ) { 
 + } ) with ImplicitFileStorageAdapter { 
 
 behavior of " Sequence service " 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 index db46150 . . 4e6a63e 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 @ @ - 73 , 7 + 73 , 7 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers with Im 
 implicit val authService = buildAuthService ( ) 
 implicit val groupsService = new GroupsServiceImpl ( groupInviteConfig ) 
 
 - val s3BucketName = fsAdapter . bucketName 
 + val s3BucketName = fsAdapterS3 . bucketName 
 
 object t { 
 val ( user1 , authId1 , _ ) = createUser ( ) 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index a9e58f8 . . d078ae7 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 47 , 7 + 47 , 10 @ @ object Build extends sbt . Build { 
 PB . protobufSettings + + Seq ( 
 / / PB . javaConversions in PB . protobufConfig : = true , 
 libraryDependencies + = " com . trueaccord . scalapb " % % " scalapb - runtime " % " 0 . 5 . 9 " % PB . protobufConfig , 
 - PB . includePaths in PB . protobufConfig + = file ( " actor - push / src / main / protobuf " ) 
 + PB . includePaths in PB . protobufConfig + + = Seq ( 
 + file ( " actor - commons - api / src / main / protobuf " ) , 
 + file ( " actor - push / src / main / protobuf " ) 
 + ) 
 ) + + 
 Seq ( 
 initialize ~ = { _ = >
