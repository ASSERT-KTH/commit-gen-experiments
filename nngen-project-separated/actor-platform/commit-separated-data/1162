BLEU SCORE: 0.10600313379512592

TEST MSG: fix ( server : calls ) : properly handle call state
GENERATED MSG: refactor ( server ) : upgraded sbt - scalariform

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > index 3ba8407 . . ea6955d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 20 , 6 + 20 , 8 @ @ sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( < nl > < nl > object WebrtcCallErrors { < nl > object NotAParticipant extends WebrtcCallError ( " Not participant " ) < nl > + object CallNotStarted extends WebrtcCallError ( " Call not started " ) < nl > + object CallAlreadyStarted extends WebrtcCallError ( " Call already started " ) < nl > } < nl > < nl > sealed trait WebrtcCallMessage < nl > @ @ - 72 , 15 + 74 , 16 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > becomeStashing ( replyTo ⇒ { < nl > case ( ) ⇒ < nl > replyTo ! CallStarted < nl > - context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) ) < nl > + context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) , scheduleEnd ( DefaultCallTimeout ) ) < nl > unstashAll ( ) < nl > case failure : Status . Failure ⇒ < nl > replyTo forward failure < nl > throw failure . cause < nl > } , discardOld = true ) < nl > + case _ ⇒ sender ( ) ! Status . Failure ( WebrtcCallErrors . CallNotStarted ) < nl > } < nl > < nl > - def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEnd : Cancellable ) : Receive = { < nl > + def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEndCaller : Cancellable , scheduledEndReceiver : Cancellable ) : Receive = { < nl > def end ( ) : Future [ Unit ] = { < nl > val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt < nl > val update = UpdateCallEnded ( id ) < nl > @ @ - 109 , 25 + 112 , 32 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > < nl > { < nl > case CallInProgress ( userId , timeout ) ⇒ < nl > - withOrigin ( userId ) { _ ⇒ < nl > - scheduledEnd . cancel ( ) < nl > - scheduleEnd ( timeout . seconds ) < nl > + withOrigin ( userId ) { targetUserId ⇒ < nl > + val newReceive = < nl > + if ( userId = = receiverUserId ) { < nl > + scheduledEndReceiver . cancel ( ) < nl > + callInProgress ( startTime , callerUserId , receiverUserId , scheduledEndCaller , scheduleEnd ( timeout . seconds ) ) < nl > + } else { < nl > + scheduledEndCaller . cancel ( ) < nl > + callInProgress ( startTime , callerUserId , receiverUserId , scheduleEnd ( timeout . seconds ) , scheduledEndReceiver ) < nl > + } < nl > + < nl > val update = UpdateCallInProgress ( id , timeout ) < nl > < nl > ( for { < nl > - _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > - _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( targetUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > } yield ( ) ) pipeTo self < nl > < nl > becomeStashing ( replyTo ⇒ { < nl > case ( ) ⇒ < nl > - context . unbecome ( ) < nl > + context become newReceive < nl > unstashAll ( ) < nl > replyTo ! CallInProgressAck < nl > - case Status . Failure ( cause ) ⇒ < nl > - end ( ) < nl > + case failure @ Status . Failure ( cause ) ⇒ < nl > + replyTo ! failure < nl > log . error ( cause , " Failed to process CallInProgress " ) < nl > - throw cause < nl > + unstashAll ( ) < nl > + context . unbecome ( ) < nl > } , discardOld = false ) < nl > } < nl > case CallSignal ( userId , pkg ) ⇒ < nl > @ @ - 139 , 7 + 149 , 8 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > } < nl > case EndCall ( userId ) ⇒ < nl > withOrigin ( userId ) { _ ⇒ < nl > - scheduledEnd . cancel ( ) < nl > + scheduledEndReceiver . cancel ( ) < nl > + scheduledEndCaller . cancel ( ) < nl > val replyTo = sender ( ) < nl > < nl > end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onComplete { < nl > @ @ - 149 , 8 + 160 , 14 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > log . error ( e , " Failed to end call " ) < nl > } < nl > } < nl > + case _ : StartCall ⇒ sender ( ) ! WebrtcCallErrors . CallAlreadyStarted < nl > } < nl > } < nl > < nl > def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) < nl > + < nl > + override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { < nl > + super . preRestart ( reason , message ) < nl > + log . error ( reason , " Failure on message : { } " , message ) < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > index a58ada7 . . 75ed780 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > @ @ - 7 , 10 + 7 , 16 @ @ import im . actor . api . rpc . misc . ResponseVoid < nl > import im . actor . api . rpc . peers . ApiOutPeer < nl > import im . actor . api . rpc . webrtc . { ResponseDoCall , WebrtcService } < nl > import im . actor . server . session . _ < nl > - import im . actor . server . webrtc . { WebrtcExtension , Webrtc } < nl > + import im . actor . server . webrtc . { WebrtcCallErrors , WebrtcExtension , Webrtc } < nl > < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + object WebrtcErrors { < nl > + val CallNotStarted = RpcError ( 400 , " CALL _ NOT _ STARTED " , " Call not started . " , canTryAgain = false , None ) < nl > + val CallAlreadyStareted = RpcError ( 400 , " CALL _ ALREADY _ STARTED " , " Call already started " , canTryAgain = false , None ) < nl > + val NotAParticipant = RpcError ( 403 , " NOT _ A _ PARTICIPANT " , " Not a participant " , canTryAgain = false , None ) < nl > + } < nl > + < nl > final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : SessionRegion ) extends WebrtcService { < nl > import PeerHelpers . _ < nl > < nl > @ @ - 21 , 17 + 27 , 21 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi < nl > override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > withOutPeerF ( peer ) { < nl > - for { < nl > + ( for { < nl > callId ← webrtcExt . doCall ( client . userId , peer . id ) < nl > - } yield Ok ( ResponseDoCall ( callId ) ) < nl > + } yield Ok ( ResponseDoCall ( callId ) ) ) recover { < nl > + case WebrtcCallErrors . CallAlreadyStarted ⇒ Error ( WebrtcErrors . CallAlreadyStareted ) < nl > + } < nl > } < nl > } < nl > < nl > override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > authorized ( clientData ) { client ⇒ < nl > - for { < nl > + ( for { < nl > _ ← webrtcExt . endCall ( client . userId , callId ) < nl > - } yield Ok ( ResponseVoid ) < nl > + } yield Ok ( ResponseVoid ) ) recover { < nl > + case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) < nl > + } < nl > } < nl > < nl > override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] =
NEAREST DIFF (one line): diff - - git a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala < nl > index 45bdd96 . . 76ed9b4 100644 < nl > - - - a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala < nl > + + + b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . botkit < nl > < nl > - import akka . actor . { Status , ActorRef , ActorLogging , Actor } < nl > + import akka . actor . { Status , ActorRef , ActorLogging , Actor } < nl > import akka . pattern . ask < nl > import akka . util . Timeout < nl > import im . actor . bots . BotMessages < nl > @ @ - 17 , 7 + 17 , 6 @ @ abstract class BotBase extends BotBaseBase { < nl > import BotMessages . _ < nl > import context . dispatcher < nl > < nl > - < nl > protected implicit val timeout : Timeout < nl > < nl > private var requestCounter = 0L < nl > @ @ - 32 , 37 + 31 , 37 @ @ abstract class BotBase extends BotBaseBase { < nl > protected def onStreamFailure ( cause : Throwable ) : Unit < nl > < nl > protected final def workingBehavior ( rqSource : ActorRef ) : Receive = { < nl > - case Status . Failure ( cause ) = > < nl > + case Status . Failure ( cause ) ⇒ < nl > onStreamFailure ( cause ) < nl > - case rq : RequestBody = > < nl > + case rq : RequestBody ⇒ < nl > requestCounter + = 1 < nl > val request = BotRequest ( requestCounter , rq . service , rq ) < nl > - requests + = ( requestCounter - > ( sender ( ) - > rq ) ) < nl > + requests + = ( requestCounter → ( sender ( ) → rq ) ) < nl > rqSource ! request < nl > case upd : BotUpdate ⇒ < nl > log . debug ( " Update { } " , upd ) < nl > < nl > upd match { < nl > - case BotFatSeqUpdate ( _ , _ , users , groups ) = > < nl > + case BotFatSeqUpdate ( _ , _ , users , groups ) ⇒ < nl > users foreach { < nl > - case ( id , user ) = > this . users . putIfAbsent ( id , user ) < nl > + case ( id , user ) ⇒ this . users . putIfAbsent ( id , user ) < nl > } < nl > < nl > groups foreach { < nl > - case ( id , group ) = > this . groups . putIfAbsent ( id , group ) < nl > + case ( id , group ) ⇒ this . groups . putIfAbsent ( id , group ) < nl > } < nl > - case _ = > < nl > + case _ ⇒ < nl > } < nl > < nl > onUpdate ( upd . body ) < nl > case rsp : BotResponse ⇒ < nl > log . info ( " Response # { } : { } " , rsp . id , rsp . body ) < nl > requests . get ( rsp . id ) foreach { < nl > - case ( replyTo , rq ) = > < nl > + case ( replyTo , rq ) ⇒ < nl > < nl > val reply = rsp . body match { < nl > - case err : BotError = > Status . Failure ( err ) < nl > - case BotSuccess ( obj ) = > rq . readResponse ( obj ) < nl > + case err : BotError ⇒ Status . Failure ( err ) < nl > + case BotSuccess ( obj ) ⇒ rq . readResponse ( obj ) < nl > } < nl > replyTo ! reply < nl > } < nl > diff - - git a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > index ab801b0 . . 83e7eec 100644 < nl > - - - a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > + + + b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala < nl > @ @ - 18 , 33 + 18 , 33 @ @ object BotMessages { < nl > } < nl > < nl > final case class FileLocation ( < nl > - fileId : Long , < nl > - accessHash : Long < nl > - ) < nl > + fileId : Long , < nl > + accessHash : Long < nl > + ) < nl > < nl > final case class AvatarImage ( < nl > - fileLocation : FileLocation , < nl > - width : Int , < nl > - height : Int , < nl > - fileSize : Int < nl > - ) < nl > + fileLocation : FileLocation , < nl > + width : Int , < nl > + height : Int , < nl > + fileSize : Int < nl > + ) < nl > < nl > final case class Avatar ( < nl > - smallImage : Option [ AvatarImage ] , < nl > - largeImage : Option [ AvatarImage ] , < nl > - fullImage : Option [ AvatarImage ] < nl > - ) < nl > + smallImage : Option [ AvatarImage ] , < nl > + largeImage : Option [ AvatarImage ] , < nl > + fullImage : Option [ AvatarImage ] < nl > + ) < nl > < nl > final case class User ( < nl > - id : Int , < nl > - accessHash : Long , < nl > - name : String , < nl > - sex : Option [ Int ] , < nl > - about : Option [ String ] , < nl > - avatar : Option [ Avatar ] , < nl > - username : Option [ String ] , < nl > - isBot : Option [ Boolean ] < nl > - ) { < nl > + id : Int , < nl > + accessHash : Long , < nl > + name : String , < nl > + sex : Option [ Int ] , < nl > + about : Option [ String ] , < nl > + avatar : Option [ Avatar ] , < nl > + username : Option [ String ] , < nl > + isBot : Option [ Boolean ] < nl > + ) { < nl > def isMale = sex . contains ( 1 ) < nl > < nl > def isFemale = sex . contains ( 2 ) < nl > @ @ - 53 , 22 + 53 , 22 @ @ object BotMessages { < nl > } < nl > < nl > final case class GroupMember ( < nl > - userId : Int , < nl > - inviterUserId : Int , < nl > - memberSince : Long , < nl > - isAdmin : Option [ Boolean ] < nl > - ) < nl > + userId : Int , < nl > + inviterUserId : Int , < nl > + memberSince : Long , < nl > + isAdmin : Option [ Boolean ] < nl > + ) < nl > < nl > final case class Group ( < nl > - id : Int , < nl > - accessHash : Long , < nl > - title : String , < nl > - about : Option [ String ] , < nl > - avatar : Option [ Avatar ] , < nl > - isMember : Boolean , < nl > - creatorUserId : Int , < nl > - members : Seq [ GroupMember ] < nl > - ) < nl > + id : Int , < nl > + accessHash : Long , < nl > + title : String , < nl > + about : Option [ String ] , < nl > + avatar : Option [ Avatar ] , < nl > + isMember : Boolean , < nl > + creatorUserId : Int , < nl > + members : Seq [ GroupMember ] < nl > + ) < nl > < nl > final object OutPeer { < nl > def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) < nl > @ @ - 79 , 10 + 79 , 10 @ @ object BotMessages { < nl > } < nl > < nl > final case class OutPeer ( < nl > - ` type ` : Int , < nl > - id : Int , < nl > - accessHash : Long < nl > - ) { < nl > + ` type ` : Int , < nl > + id : Int , < nl > + accessHash : Long < nl > + ) { < nl > final def isPrivate = ` type ` = = 1 < nl > < nl > final def isUser = isPrivate < nl > @ @ - 91 , 16 + 91 , 16 @ @ object BotMessages { < nl > } < nl > < nl > final case class UserOutPeer ( < nl > - id : Int , < nl > - accessHash : Long < nl > - ) { < nl > + id : Int , < nl > + accessHash : Long < nl > + ) { < nl > val asOutPeer = OutPeer ( 1 , id , accessHash ) < nl > } < nl > < nl > final case class Peer ( < nl > - ` type ` : Int , < nl > - id : Int < nl > - ) < nl > + ` type ` : Int , < nl > + id : Int < nl > + ) < nl > < nl > sealed trait RequestBody { < nl > type Response < : ResponseBody < nl > @ @ - 113 , 16 + 113 , 16 @ @ object BotMessages { < nl > < nl > @ key ( " Request " ) < nl > final case class BotRequest ( < nl > - id : Long , < nl > - service : String , < nl > - body : RequestBody < nl > - ) extends BotMessageIn < nl > + id : Long , < nl > + service : String , < nl > + body : RequestBody < nl > + ) extends BotMessageIn < nl > < nl > @ key ( " Response " ) < nl > final case class BotResponse ( < nl > - id : Long , < nl > - body : BotResponseBody < nl > - ) extends BotMessageOut < nl > + id : Long , < nl > + body : BotResponseBody < nl > + ) extends BotMessageOut < nl > < nl > sealed trait BotResponseBody < nl > < nl > @ @ - 135 , 17 + 135 , 17 @ @ object BotMessages { < nl > < nl > @ key ( " SeqUpdate " ) < nl > final case class BotSeqUpdate ( < nl > - seq : Int , < nl > - body : UpdateBody < nl > - ) extends BotUpdate < nl > + seq : Int , < nl > + body : UpdateBody < nl > + ) extends BotUpdate < nl > < nl > @ key ( " FatSeqUpdate " ) < nl > final case class BotFatSeqUpdate ( < nl > - seq : Int , < nl > - body : UpdateBody , < nl > - users : Map [ Int , User ] , < nl > - groups : Map [ Int , Group ] < nl > - ) extends BotUpdate < nl > + seq : Int , < nl > + body : UpdateBody , < nl > + users : Map [ Int , User ] , < nl > + groups : Map [ Int , Group ] < nl > + ) extends BotUpdate < nl > < nl > @ key ( " Error " ) < nl > case class BotError ( code : Int , tag : String , data : Js . Obj , retryIn : Option [ Int ] ) extends RuntimeException with BotResponseBody < nl > @ @ - 154 , 28 + 154 , 28 @ @ object BotMessages { < nl > case class BotSuccess ( obj : Js . Obj ) extends BotResponseBody < nl > < nl > implicit val objWriter = Writer [ Js . Obj ] { < nl > - case obj = > obj < nl > + case obj ⇒ obj < nl > } < nl > < nl > implicit val objReader = Reader [ Js . Obj ] { < nl > - case obj : Js . Obj = > obj < nl > + case obj : Js . Obj ⇒ obj < nl > } < nl > < nl > implicit val botSuccessWriter = upickle . default . Writer [ BotSuccess ] { < nl > - case BotSuccess ( obj ) = > obj < nl > + case BotSuccess ( obj ) ⇒ obj < nl > } < nl > < nl > implicit val botSuccessReader = upickle . default . Reader [ BotSuccess ] { < nl > - case obj : Js . Obj = > BotSuccess ( obj ) < nl > + case obj : Js . Obj ⇒ BotSuccess ( obj ) < nl > } < nl > < nl > implicit val botErrorWriter = upickle . default . Writer [ BotError ] { < nl > - case BotError ( code , tag , data , retryInOpt ) = > < nl > + case BotError ( code , tag , data , retryInOpt ) ⇒ < nl > Js . Obj ( < nl > - " code " - > Js . Num ( code . toDouble ) , < nl > - " tag " - > Js . Str ( tag ) , < nl > - " data " - > data , < nl > - " retryIn " - > retryInOpt . map ( n = > Js . Num ( n . toDouble ) ) . getOrElse ( Js . Null ) < nl > + " code " → Js . Num ( code . toDouble ) , < nl > + " tag " → Js . Str ( tag ) , < nl > + " data " → data , < nl > + " retryIn " → retryInOpt . map ( n ⇒ Js . Num ( n . toDouble ) ) . getOrElse ( Js . Null ) < nl > ) < nl > } < nl > < nl > @ @ - 186 , 19 + 186 , 19 @ @ object BotMessages { < nl > final case object Void extends Void < nl > < nl > implicit val voidReader = upickle . default . Reader [ Void ] { < nl > - case Js . Obj ( ) = > Void < nl > + case Js . Obj ( ) ⇒ Void < nl > } < nl > < nl > implicit val voidWriter = upickle . default . Writer [ Void ] { < nl > - case _ = > Js . Obj ( ) < nl > + case _ ⇒ Js . Obj ( ) < nl > } < nl > < nl > @ key ( " SendMessage " ) < nl > final case class SendTextMessage ( < nl > - peer : OutPeer , < nl > - randomId : Long , < nl > - text : String < nl > - ) extends RequestBody { < nl > + peer : OutPeer , < nl > + randomId : Long , < nl > + text : String < nl > + ) extends RequestBody { < nl > override type Response = MessageSent < nl > override val service = Services . Messaging < nl > < nl > @ @ - 207 , 10 + 207 , 10 @ @ object BotMessages { < nl > < nl > @ key ( " SetValue " ) < nl > final case class SetValue ( < nl > - keyspace : String , < nl > - key : String , < nl > - value : String < nl > - ) extends RequestBody { < nl > + keyspace : String , < nl > + key : String , < nl > + value : String < nl > + ) extends RequestBody { < nl > override type Response = Void < nl > override val service = Services . KeyValue < nl > < nl > @ @ - 219 , 9 + 219 , 9 @ @ object BotMessages { < nl > < nl > @ key ( " GetValue " ) < nl > final case class GetValue ( < nl > - keyspace : String , < nl > - key : String < nl > - ) extends RequestBody { < nl > + keyspace : String , < nl > + key : String < nl > + ) extends RequestBody { < nl > override type Response = Container [ Option [ String ] ] < nl > override val service = Services . KeyValue < nl > < nl > @ @ - 230 , 9 + 230 , 9 @ @ object BotMessages { < nl > < nl > @ key ( " DeleteValue " ) < nl > final case class DeleteValue ( < nl > - keyspace : String , < nl > - key : String < nl > - ) extends RequestBody { < nl > + keyspace : String , < nl > + key : String < nl > + ) extends RequestBody { < nl > override type Response = Void < nl > override val service = Services . KeyValue < nl > < nl > @ @ - 251 , 11 + 251 , 11 @ @ object BotMessages { < nl > < nl > @ key ( " TextMessage " ) < nl > final case class TextMessage ( < nl > - peer : OutPeer , < nl > - sender : UserOutPeer , < nl > - date : Long , < nl > - randomId : Long , < nl > - text : String < nl > - ) extends UpdateBody < nl > + peer : OutPeer , < nl > + sender : UserOutPeer , < nl > + date : Long , < nl > + randomId : Long , < nl > + text : String < nl > + ) extends UpdateBody < nl > < nl > } < nl > diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala < nl > index 8cfb5e4 . . c81cd72 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import im . actor . bots . BotMessages < nl > import upickle . Js < nl > import upickle . default . _ < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object BotService { < nl > import BotMessages . _ < nl > @ @ - 14 , 24 + 14 , 24 @ @ object BotService { < nl > < nl > type RequestResult [ + RSP < : ResponseBody ] = Either [ BotError , RSP ] < nl > < nl > - private type Handler [ + RSP < : ResponseBody ] = ( BotUserId , BotAuthId ) = > Future [ RequestResult [ RSP ] ] < nl > + private type Handler [ + RSP < : ResponseBody ] = ( BotUserId , BotAuthId ) ⇒ Future [ RequestResult [ RSP ] ] < nl > < nl > - case class RequestHandler [ + RQ < : RequestBody , RSP < : ResponseBody : Writer ] ( handle : Handler [ RQ # Response ] ) { < nl > + case class RequestHandler [ + RQ < : RequestBody , RSP < : ResponseBody : Writer ] ( handle : Handler [ RQ # Response ] ) { < nl > def result ( botUserId : Int , botAuthId : Long ) ( implicit ec : ExecutionContext ) : Future [ BotResponseBody ] = < nl > for { < nl > - res < - handle ( botUserId , botAuthId ) < nl > - } yield res match { < nl > - case Right ( rsp ) = > BotSuccess ( writeJs ( rsp . asInstanceOf [ RSP ] ) . asInstanceOf [ Js . Obj ] ) < nl > - case Left ( error ) = > error < nl > + res ← handle ( botUserId , botAuthId ) < nl > + } yield res match { < nl > + case Right ( rsp ) ⇒ BotSuccess ( writeJs ( rsp . asInstanceOf [ RSP ] ) . asInstanceOf [ Js . Obj ] ) < nl > + case Left ( error ) ⇒ error < nl > } < nl > < nl > def toWeak ( implicit ec : ExecutionContext ) = WeakRequestHandler ( < nl > - ( botUserId : Int , botAuthId : Long ) = > < nl > + ( botUserId : Int , botAuthId : Long ) ⇒ < nl > result ( botUserId , botAuthId ) < nl > ) < nl > } < nl > < nl > - case class WeakRequestHandler ( handle : ( BotUserId , BotAuthId ) = > Future [ BotResponseBody ] ) < nl > + case class WeakRequestHandler ( handle : ( BotUserId , BotAuthId ) ⇒ Future [ BotResponseBody ] ) < nl > } < nl > < nl > trait BotService { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala < nl > index 733b3dc . . 987077d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala < nl > @ @ - 1 , 9 + 1 , 9 @ @ < nl > package im . actor . api < nl > < nl > - import slick . dbio . { DBIO , DBIOAction } < nl > + import slick . dbio . { DBIO , DBIOAction } < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > import scala . reflect . _ < nl > import scalaz . Scalaz . _ < nl > import scalaz . _ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index bff0ec8 . . fc54206 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 1 , 16 + 1 , 16 @ @ < nl > package im . actor . server . dialog < nl > < nl > import im . actor . serialization . ActorSerializer < nl > - import im . actor . server . office . { Processor , ProcessorState } < nl > + import im . actor . server . office . { Processor , ProcessorState } < nl > < nl > object DialogProcessor { < nl > def register ( ) : Unit = { < nl > ActorSerializer . register ( < nl > - 40000 - > classOf [ DialogCommands . SendMessage ] , < nl > - 40001 - > classOf [ DialogCommands . MessageReceived ] , < nl > - 40002 - > classOf [ DialogCommands . MessageReceivedAck ] , < nl > - 40003 - > classOf [ DialogCommands . MessageRead ] , < nl > - 40004 - > classOf [ DialogCommands . MessageReadAck ] < nl > + 40000 → classOf [ DialogCommands . SendMessage ] , < nl > + 40001 → classOf [ DialogCommands . MessageReceived ] , < nl > + 40002 → classOf [ DialogCommands . MessageReceivedAck ] , < nl > + 40003 → classOf [ DialogCommands . MessageRead ] , < nl > + 40004 → classOf [ DialogCommands . MessageReadAck ] < nl > ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > index 49176df . . 67c8d445 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala < nl > @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . office < nl > < nl > import java . util . concurrent . TimeUnit < nl > < nl > - import akka . actor . { ActorRef , Status } < nl > + import akka . actor . { ActorRef , Status } < nl > import akka . contrib . pattern . ShardRegion . Passivate < nl > import akka . pattern . pipe < nl > import akka . persistence . PersistentActor < nl > @ @ - 65 , 21 + 65 , 21 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > final def receiveCommand = initializing < nl > < nl > protected final def initializing : Receive = handleInitCommand orElse { < nl > - case msg = > < nl > + case msg ⇒ < nl > log . debug ( " Entity not found while processing { } " , msg ) < nl > sender ( ) ! Status . Failure ( EntityNotFound ) < nl > } < nl > < nl > protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { < nl > - case Work ( newState ) = > context become working ( newState ) < nl > - case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) < nl > + case Work ( newState ) ⇒ context become working ( newState ) < nl > + case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) < nl > } < nl > < nl > protected final def stashingBehavior : Receive = { < nl > - case UnstashAndWork ( evt , s ) = > < nl > + case UnstashAndWork ( evt , s ) ⇒ < nl > context become working ( updatedState ( evt , s ) ) < nl > unstashAll ( ) < nl > - case UnstashAndWorkBatch ( es , s ) = > < nl > + case UnstashAndWorkBatch ( es , s ) ⇒ < nl > val newState = es . foldLeft ( s ) { < nl > case ( acc , e ) ⇒ < nl > log . debug ( " Updating state : { } with event : { } " , acc , e ) < nl > @ @ - 94 , 7 + 94 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture < nl > < nl > protected final def stashing ( state : State ) : Receive = handleQuery ( state ) orElse stashingBehavior < nl > < nl > - final def persistReply [ R ] ( e : Event , state : State ) ( f : Event = > Future [ R ] ) : Unit = < nl > + final def persistReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = < nl > persistReply ( e , state , sender ( ) ) ( f ) < nl > < nl > final def persistReply [ R ] ( e : Event , state : State , replyTo : ActorRef ) ( f : Event ⇒ Future [ R ] ) : Unit = { < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala b / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala < nl > index aba292a . . 531dc63 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala < nl > @ @ - 1 , 8 + 1 , 8 @ @ < nl > package im . actor . util . cache < nl > < nl > - import com . github . benmanes . caffeine . cache . { Caffeine , Cache } < nl > + import com . github . benmanes . caffeine . cache . { Caffeine , Cache } < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object CacheHelpers { < nl > < nl > @ @ - 21 , 7 + 21 , 7 @ @ object CacheHelpers { < nl > cache . put ( key , result ) < nl > < nl > result recover { < nl > - case e = > < nl > + case e ⇒ < nl > cache . invalidate ( key ) < nl > throw e < nl > } < nl > diff - - git a / actor - server / project / Formatting . scala b / actor - server / project / Formatting . scala < nl > index 69b0c9d . . cd6bf6e 100644 < nl > - - - a / actor - server / project / Formatting . scala < nl > + + + b / actor - server / project / Formatting . scala < nl > @ @ - 24 , 6 + 24 , 7 @ @ object Formatting { < nl > . setPreference ( RewriteArrowSymbols , true ) < nl > . setPreference ( AlignParameters , true ) < nl > . setPreference ( AlignSingleLineCaseStatements , true ) < nl > + . setPreference ( SpacesAroundMultiImports , true ) < nl > } < nl > < nl > def docFormattingPreferences = { < nl > diff - - git a / actor - server / project / plugins . sbt b / actor - server / project / plugins . sbt < nl > index e31b3f4 . . b75ac6e 100644 < nl > - - - a / actor - server / project / plugins . sbt < nl > + + + b / actor - server / project / plugins . sbt < nl > @ @ - 19 , 7 + 19 , 7 @ @ addSbtPlugin ( " im . actor " % % " sbt - actor - api " % " 0 . 6 . 15 " ) < nl > < nl > / / addSbtPlugin ( " com . typesafe . play " % " sbt - plugin " % " 2 . 3 . 9 " ) < nl > < nl > - addSbtPlugin ( " org . scalariform " % " sbt - scalariform " % " 1 . 4 . 0 " ) < nl > + addSbtPlugin ( " org . scalariform " % " sbt - scalariform " % " 1 . 5 . 1 " ) < nl > < nl > addSbtPlugin ( " com . typesafe . sbt " % " sbt - native - packager " % " 1 . 0 . 4 " )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 index 3ba8407 . . ea6955d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 20 , 6 + 20 , 8 @ @ sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( 
 
 object WebrtcCallErrors { 
 object NotAParticipant extends WebrtcCallError ( " Not participant " ) 
 + object CallNotStarted extends WebrtcCallError ( " Call not started " ) 
 + object CallAlreadyStarted extends WebrtcCallError ( " Call already started " ) 
 } 
 
 sealed trait WebrtcCallMessage 
 @ @ - 72 , 15 + 74 , 16 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 becomeStashing ( replyTo ⇒ { 
 case ( ) ⇒ 
 replyTo ! CallStarted 
 - context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) ) 
 + context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) , scheduleEnd ( DefaultCallTimeout ) ) 
 unstashAll ( ) 
 case failure : Status . Failure ⇒ 
 replyTo forward failure 
 throw failure . cause 
 } , discardOld = true ) 
 + case _ ⇒ sender ( ) ! Status . Failure ( WebrtcCallErrors . CallNotStarted ) 
 } 
 
 - def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEnd : Cancellable ) : Receive = { 
 + def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEndCaller : Cancellable , scheduledEndReceiver : Cancellable ) : Receive = { 
 def end ( ) : Future [ Unit ] = { 
 val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt 
 val update = UpdateCallEnded ( id ) 
 @ @ - 109 , 25 + 112 , 32 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 
 { 
 case CallInProgress ( userId , timeout ) ⇒ 
 - withOrigin ( userId ) { _ ⇒ 
 - scheduledEnd . cancel ( ) 
 - scheduleEnd ( timeout . seconds ) 
 + withOrigin ( userId ) { targetUserId ⇒ 
 + val newReceive = 
 + if ( userId = = receiverUserId ) { 
 + scheduledEndReceiver . cancel ( ) 
 + callInProgress ( startTime , callerUserId , receiverUserId , scheduledEndCaller , scheduleEnd ( timeout . seconds ) ) 
 + } else { 
 + scheduledEndCaller . cancel ( ) 
 + callInProgress ( startTime , callerUserId , receiverUserId , scheduleEnd ( timeout . seconds ) , scheduledEndReceiver ) 
 + } 
 + 
 val update = UpdateCallInProgress ( id , timeout ) 
 
 ( for { 
 - _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 - _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( targetUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 } yield ( ) ) pipeTo self 
 
 becomeStashing ( replyTo ⇒ { 
 case ( ) ⇒ 
 - context . unbecome ( ) 
 + context become newReceive 
 unstashAll ( ) 
 replyTo ! CallInProgressAck 
 - case Status . Failure ( cause ) ⇒ 
 - end ( ) 
 + case failure @ Status . Failure ( cause ) ⇒ 
 + replyTo ! failure 
 log . error ( cause , " Failed to process CallInProgress " ) 
 - throw cause 
 + unstashAll ( ) 
 + context . unbecome ( ) 
 } , discardOld = false ) 
 } 
 case CallSignal ( userId , pkg ) ⇒ 
 @ @ - 139 , 7 + 149 , 8 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 } 
 case EndCall ( userId ) ⇒ 
 withOrigin ( userId ) { _ ⇒ 
 - scheduledEnd . cancel ( ) 
 + scheduledEndReceiver . cancel ( ) 
 + scheduledEndCaller . cancel ( ) 
 val replyTo = sender ( ) 
 
 end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onComplete { 
 @ @ - 149 , 8 + 160 , 14 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 log . error ( e , " Failed to end call " ) 
 } 
 } 
 + case _ : StartCall ⇒ sender ( ) ! WebrtcCallErrors . CallAlreadyStarted 
 } 
 } 
 
 def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) 
 + 
 + override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { 
 + super . preRestart ( reason , message ) 
 + log . error ( reason , " Failure on message : { } " , message ) 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 index a58ada7 . . 75ed780 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 @ @ - 7 , 10 + 7 , 16 @ @ import im . actor . api . rpc . misc . ResponseVoid 
 import im . actor . api . rpc . peers . ApiOutPeer 
 import im . actor . api . rpc . webrtc . { ResponseDoCall , WebrtcService } 
 import im . actor . server . session . _ 
 - import im . actor . server . webrtc . { WebrtcExtension , Webrtc } 
 + import im . actor . server . webrtc . { WebrtcCallErrors , WebrtcExtension , Webrtc } 
 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + object WebrtcErrors { 
 + val CallNotStarted = RpcError ( 400 , " CALL _ NOT _ STARTED " , " Call not started . " , canTryAgain = false , None ) 
 + val CallAlreadyStareted = RpcError ( 400 , " CALL _ ALREADY _ STARTED " , " Call already started " , canTryAgain = false , None ) 
 + val NotAParticipant = RpcError ( 403 , " NOT _ A _ PARTICIPANT " , " Not a participant " , canTryAgain = false , None ) 
 + } 
 + 
 final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : SessionRegion ) extends WebrtcService { 
 import PeerHelpers . _ 
 
 @ @ - 21 , 17 + 27 , 21 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi 
 override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 withOutPeerF ( peer ) { 
 - for { 
 + ( for { 
 callId ← webrtcExt . doCall ( client . userId , peer . id ) 
 - } yield Ok ( ResponseDoCall ( callId ) ) 
 + } yield Ok ( ResponseDoCall ( callId ) ) ) recover { 
 + case WebrtcCallErrors . CallAlreadyStarted ⇒ Error ( WebrtcErrors . CallAlreadyStareted ) 
 + } 
 } 
 } 
 
 override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 authorized ( clientData ) { client ⇒ 
 - for { 
 + ( for { 
 _ ← webrtcExt . endCall ( client . userId , callId ) 
 - } yield Ok ( ResponseVoid ) 
 + } yield Ok ( ResponseVoid ) ) recover { 
 + case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) 
 + } 
 } 
 
 override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] =

NEAREST DIFF:
diff - - git a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala 
 index 45bdd96 . . 76ed9b4 100644 
 - - - a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala 
 + + + b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / BotBase . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . botkit 
 
 - import akka . actor . { Status , ActorRef , ActorLogging , Actor } 
 + import akka . actor . { Status , ActorRef , ActorLogging , Actor } 
 import akka . pattern . ask 
 import akka . util . Timeout 
 import im . actor . bots . BotMessages 
 @ @ - 17 , 7 + 17 , 6 @ @ abstract class BotBase extends BotBaseBase { 
 import BotMessages . _ 
 import context . dispatcher 
 
 - 
 protected implicit val timeout : Timeout 
 
 private var requestCounter = 0L 
 @ @ - 32 , 37 + 31 , 37 @ @ abstract class BotBase extends BotBaseBase { 
 protected def onStreamFailure ( cause : Throwable ) : Unit 
 
 protected final def workingBehavior ( rqSource : ActorRef ) : Receive = { 
 - case Status . Failure ( cause ) = > 
 + case Status . Failure ( cause ) ⇒ 
 onStreamFailure ( cause ) 
 - case rq : RequestBody = > 
 + case rq : RequestBody ⇒ 
 requestCounter + = 1 
 val request = BotRequest ( requestCounter , rq . service , rq ) 
 - requests + = ( requestCounter - > ( sender ( ) - > rq ) ) 
 + requests + = ( requestCounter → ( sender ( ) → rq ) ) 
 rqSource ! request 
 case upd : BotUpdate ⇒ 
 log . debug ( " Update { } " , upd ) 
 
 upd match { 
 - case BotFatSeqUpdate ( _ , _ , users , groups ) = > 
 + case BotFatSeqUpdate ( _ , _ , users , groups ) ⇒ 
 users foreach { 
 - case ( id , user ) = > this . users . putIfAbsent ( id , user ) 
 + case ( id , user ) ⇒ this . users . putIfAbsent ( id , user ) 
 } 
 
 groups foreach { 
 - case ( id , group ) = > this . groups . putIfAbsent ( id , group ) 
 + case ( id , group ) ⇒ this . groups . putIfAbsent ( id , group ) 
 } 
 - case _ = > 
 + case _ ⇒ 
 } 
 
 onUpdate ( upd . body ) 
 case rsp : BotResponse ⇒ 
 log . info ( " Response # { } : { } " , rsp . id , rsp . body ) 
 requests . get ( rsp . id ) foreach { 
 - case ( replyTo , rq ) = > 
 + case ( replyTo , rq ) ⇒ 
 
 val reply = rsp . body match { 
 - case err : BotError = > Status . Failure ( err ) 
 - case BotSuccess ( obj ) = > rq . readResponse ( obj ) 
 + case err : BotError ⇒ Status . Failure ( err ) 
 + case BotSuccess ( obj ) ⇒ rq . readResponse ( obj ) 
 } 
 replyTo ! reply 
 } 
 diff - - git a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 index ab801b0 . . 83e7eec 100644 
 - - - a / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 + + + b / actor - server / actor - bots - shared / src / main / scala / im / actor / bots / BotMessages . scala 
 @ @ - 18 , 33 + 18 , 33 @ @ object BotMessages { 
 } 
 
 final case class FileLocation ( 
 - fileId : Long , 
 - accessHash : Long 
 - ) 
 + fileId : Long , 
 + accessHash : Long 
 + ) 
 
 final case class AvatarImage ( 
 - fileLocation : FileLocation , 
 - width : Int , 
 - height : Int , 
 - fileSize : Int 
 - ) 
 + fileLocation : FileLocation , 
 + width : Int , 
 + height : Int , 
 + fileSize : Int 
 + ) 
 
 final case class Avatar ( 
 - smallImage : Option [ AvatarImage ] , 
 - largeImage : Option [ AvatarImage ] , 
 - fullImage : Option [ AvatarImage ] 
 - ) 
 + smallImage : Option [ AvatarImage ] , 
 + largeImage : Option [ AvatarImage ] , 
 + fullImage : Option [ AvatarImage ] 
 + ) 
 
 final case class User ( 
 - id : Int , 
 - accessHash : Long , 
 - name : String , 
 - sex : Option [ Int ] , 
 - about : Option [ String ] , 
 - avatar : Option [ Avatar ] , 
 - username : Option [ String ] , 
 - isBot : Option [ Boolean ] 
 - ) { 
 + id : Int , 
 + accessHash : Long , 
 + name : String , 
 + sex : Option [ Int ] , 
 + about : Option [ String ] , 
 + avatar : Option [ Avatar ] , 
 + username : Option [ String ] , 
 + isBot : Option [ Boolean ] 
 + ) { 
 def isMale = sex . contains ( 1 ) 
 
 def isFemale = sex . contains ( 2 ) 
 @ @ - 53 , 22 + 53 , 22 @ @ object BotMessages { 
 } 
 
 final case class GroupMember ( 
 - userId : Int , 
 - inviterUserId : Int , 
 - memberSince : Long , 
 - isAdmin : Option [ Boolean ] 
 - ) 
 + userId : Int , 
 + inviterUserId : Int , 
 + memberSince : Long , 
 + isAdmin : Option [ Boolean ] 
 + ) 
 
 final case class Group ( 
 - id : Int , 
 - accessHash : Long , 
 - title : String , 
 - about : Option [ String ] , 
 - avatar : Option [ Avatar ] , 
 - isMember : Boolean , 
 - creatorUserId : Int , 
 - members : Seq [ GroupMember ] 
 - ) 
 + id : Int , 
 + accessHash : Long , 
 + title : String , 
 + about : Option [ String ] , 
 + avatar : Option [ Avatar ] , 
 + isMember : Boolean , 
 + creatorUserId : Int , 
 + members : Seq [ GroupMember ] 
 + ) 
 
 final object OutPeer { 
 def privat ( id : Int , accessHash : Long ) = OutPeer ( 1 , id , accessHash ) 
 @ @ - 79 , 10 + 79 , 10 @ @ object BotMessages { 
 } 
 
 final case class OutPeer ( 
 - ` type ` : Int , 
 - id : Int , 
 - accessHash : Long 
 - ) { 
 + ` type ` : Int , 
 + id : Int , 
 + accessHash : Long 
 + ) { 
 final def isPrivate = ` type ` = = 1 
 
 final def isUser = isPrivate 
 @ @ - 91 , 16 + 91 , 16 @ @ object BotMessages { 
 } 
 
 final case class UserOutPeer ( 
 - id : Int , 
 - accessHash : Long 
 - ) { 
 + id : Int , 
 + accessHash : Long 
 + ) { 
 val asOutPeer = OutPeer ( 1 , id , accessHash ) 
 } 
 
 final case class Peer ( 
 - ` type ` : Int , 
 - id : Int 
 - ) 
 + ` type ` : Int , 
 + id : Int 
 + ) 
 
 sealed trait RequestBody { 
 type Response < : ResponseBody 
 @ @ - 113 , 16 + 113 , 16 @ @ object BotMessages { 
 
 @ key ( " Request " ) 
 final case class BotRequest ( 
 - id : Long , 
 - service : String , 
 - body : RequestBody 
 - ) extends BotMessageIn 
 + id : Long , 
 + service : String , 
 + body : RequestBody 
 + ) extends BotMessageIn 
 
 @ key ( " Response " ) 
 final case class BotResponse ( 
 - id : Long , 
 - body : BotResponseBody 
 - ) extends BotMessageOut 
 + id : Long , 
 + body : BotResponseBody 
 + ) extends BotMessageOut 
 
 sealed trait BotResponseBody 
 
 @ @ - 135 , 17 + 135 , 17 @ @ object BotMessages { 
 
 @ key ( " SeqUpdate " ) 
 final case class BotSeqUpdate ( 
 - seq : Int , 
 - body : UpdateBody 
 - ) extends BotUpdate 
 + seq : Int , 
 + body : UpdateBody 
 + ) extends BotUpdate 
 
 @ key ( " FatSeqUpdate " ) 
 final case class BotFatSeqUpdate ( 
 - seq : Int , 
 - body : UpdateBody , 
 - users : Map [ Int , User ] , 
 - groups : Map [ Int , Group ] 
 - ) extends BotUpdate 
 + seq : Int , 
 + body : UpdateBody , 
 + users : Map [ Int , User ] , 
 + groups : Map [ Int , Group ] 
 + ) extends BotUpdate 
 
 @ key ( " Error " ) 
 case class BotError ( code : Int , tag : String , data : Js . Obj , retryIn : Option [ Int ] ) extends RuntimeException with BotResponseBody 
 @ @ - 154 , 28 + 154 , 28 @ @ object BotMessages { 
 case class BotSuccess ( obj : Js . Obj ) extends BotResponseBody 
 
 implicit val objWriter = Writer [ Js . Obj ] { 
 - case obj = > obj 
 + case obj ⇒ obj 
 } 
 
 implicit val objReader = Reader [ Js . Obj ] { 
 - case obj : Js . Obj = > obj 
 + case obj : Js . Obj ⇒ obj 
 } 
 
 implicit val botSuccessWriter = upickle . default . Writer [ BotSuccess ] { 
 - case BotSuccess ( obj ) = > obj 
 + case BotSuccess ( obj ) ⇒ obj 
 } 
 
 implicit val botSuccessReader = upickle . default . Reader [ BotSuccess ] { 
 - case obj : Js . Obj = > BotSuccess ( obj ) 
 + case obj : Js . Obj ⇒ BotSuccess ( obj ) 
 } 
 
 implicit val botErrorWriter = upickle . default . Writer [ BotError ] { 
 - case BotError ( code , tag , data , retryInOpt ) = > 
 + case BotError ( code , tag , data , retryInOpt ) ⇒ 
 Js . Obj ( 
 - " code " - > Js . Num ( code . toDouble ) , 
 - " tag " - > Js . Str ( tag ) , 
 - " data " - > data , 
 - " retryIn " - > retryInOpt . map ( n = > Js . Num ( n . toDouble ) ) . getOrElse ( Js . Null ) 
 + " code " → Js . Num ( code . toDouble ) , 
 + " tag " → Js . Str ( tag ) , 
 + " data " → data , 
 + " retryIn " → retryInOpt . map ( n ⇒ Js . Num ( n . toDouble ) ) . getOrElse ( Js . Null ) 
 ) 
 } 
 
 @ @ - 186 , 19 + 186 , 19 @ @ object BotMessages { 
 final case object Void extends Void 
 
 implicit val voidReader = upickle . default . Reader [ Void ] { 
 - case Js . Obj ( ) = > Void 
 + case Js . Obj ( ) ⇒ Void 
 } 
 
 implicit val voidWriter = upickle . default . Writer [ Void ] { 
 - case _ = > Js . Obj ( ) 
 + case _ ⇒ Js . Obj ( ) 
 } 
 
 @ key ( " SendMessage " ) 
 final case class SendTextMessage ( 
 - peer : OutPeer , 
 - randomId : Long , 
 - text : String 
 - ) extends RequestBody { 
 + peer : OutPeer , 
 + randomId : Long , 
 + text : String 
 + ) extends RequestBody { 
 override type Response = MessageSent 
 override val service = Services . Messaging 
 
 @ @ - 207 , 10 + 207 , 10 @ @ object BotMessages { 
 
 @ key ( " SetValue " ) 
 final case class SetValue ( 
 - keyspace : String , 
 - key : String , 
 - value : String 
 - ) extends RequestBody { 
 + keyspace : String , 
 + key : String , 
 + value : String 
 + ) extends RequestBody { 
 override type Response = Void 
 override val service = Services . KeyValue 
 
 @ @ - 219 , 9 + 219 , 9 @ @ object BotMessages { 
 
 @ key ( " GetValue " ) 
 final case class GetValue ( 
 - keyspace : String , 
 - key : String 
 - ) extends RequestBody { 
 + keyspace : String , 
 + key : String 
 + ) extends RequestBody { 
 override type Response = Container [ Option [ String ] ] 
 override val service = Services . KeyValue 
 
 @ @ - 230 , 9 + 230 , 9 @ @ object BotMessages { 
 
 @ key ( " DeleteValue " ) 
 final case class DeleteValue ( 
 - keyspace : String , 
 - key : String 
 - ) extends RequestBody { 
 + keyspace : String , 
 + key : String 
 + ) extends RequestBody { 
 override type Response = Void 
 override val service = Services . KeyValue 
 
 @ @ - 251 , 11 + 251 , 11 @ @ object BotMessages { 
 
 @ key ( " TextMessage " ) 
 final case class TextMessage ( 
 - peer : OutPeer , 
 - sender : UserOutPeer , 
 - date : Long , 
 - randomId : Long , 
 - text : String 
 - ) extends UpdateBody 
 + peer : OutPeer , 
 + sender : UserOutPeer , 
 + date : Long , 
 + randomId : Long , 
 + text : String 
 + ) extends UpdateBody 
 
 } 
 diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala 
 index 8cfb5e4 . . c81cd72 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / BotService . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import im . actor . bots . BotMessages 
 import upickle . Js 
 import upickle . default . _ 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . { ExecutionContext , Future } 
 
 object BotService { 
 import BotMessages . _ 
 @ @ - 14 , 24 + 14 , 24 @ @ object BotService { 
 
 type RequestResult [ + RSP < : ResponseBody ] = Either [ BotError , RSP ] 
 
 - private type Handler [ + RSP < : ResponseBody ] = ( BotUserId , BotAuthId ) = > Future [ RequestResult [ RSP ] ] 
 + private type Handler [ + RSP < : ResponseBody ] = ( BotUserId , BotAuthId ) ⇒ Future [ RequestResult [ RSP ] ] 
 
 - case class RequestHandler [ + RQ < : RequestBody , RSP < : ResponseBody : Writer ] ( handle : Handler [ RQ # Response ] ) { 
 + case class RequestHandler [ + RQ < : RequestBody , RSP < : ResponseBody : Writer ] ( handle : Handler [ RQ # Response ] ) { 
 def result ( botUserId : Int , botAuthId : Long ) ( implicit ec : ExecutionContext ) : Future [ BotResponseBody ] = 
 for { 
 - res < - handle ( botUserId , botAuthId ) 
 - } yield res match { 
 - case Right ( rsp ) = > BotSuccess ( writeJs ( rsp . asInstanceOf [ RSP ] ) . asInstanceOf [ Js . Obj ] ) 
 - case Left ( error ) = > error 
 + res ← handle ( botUserId , botAuthId ) 
 + } yield res match { 
 + case Right ( rsp ) ⇒ BotSuccess ( writeJs ( rsp . asInstanceOf [ RSP ] ) . asInstanceOf [ Js . Obj ] ) 
 + case Left ( error ) ⇒ error 
 } 
 
 def toWeak ( implicit ec : ExecutionContext ) = WeakRequestHandler ( 
 - ( botUserId : Int , botAuthId : Long ) = > 
 + ( botUserId : Int , botAuthId : Long ) ⇒ 
 result ( botUserId , botAuthId ) 
 ) 
 } 
 
 - case class WeakRequestHandler ( handle : ( BotUserId , BotAuthId ) = > Future [ BotResponseBody ] ) 
 + case class WeakRequestHandler ( handle : ( BotUserId , BotAuthId ) ⇒ Future [ BotResponseBody ] ) 
 } 
 
 trait BotService { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala 
 index 733b3dc . . 987077d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / package . scala 
 @ @ - 1 , 9 + 1 , 9 @ @ 
 package im . actor . api 
 
 - import slick . dbio . { DBIO , DBIOAction } 
 + import slick . dbio . { DBIO , DBIOAction } 
 import slick . driver . PostgresDriver . api . _ 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . { ExecutionContext , Future } 
 import scala . reflect . _ 
 import scalaz . Scalaz . _ 
 import scalaz . _ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index bff0ec8 . . fc54206 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 1 , 16 + 1 , 16 @ @ 
 package im . actor . server . dialog 
 
 import im . actor . serialization . ActorSerializer 
 - import im . actor . server . office . { Processor , ProcessorState } 
 + import im . actor . server . office . { Processor , ProcessorState } 
 
 object DialogProcessor { 
 def register ( ) : Unit = { 
 ActorSerializer . register ( 
 - 40000 - > classOf [ DialogCommands . SendMessage ] , 
 - 40001 - > classOf [ DialogCommands . MessageReceived ] , 
 - 40002 - > classOf [ DialogCommands . MessageReceivedAck ] , 
 - 40003 - > classOf [ DialogCommands . MessageRead ] , 
 - 40004 - > classOf [ DialogCommands . MessageReadAck ] 
 + 40000 → classOf [ DialogCommands . SendMessage ] , 
 + 40001 → classOf [ DialogCommands . MessageReceived ] , 
 + 40002 → classOf [ DialogCommands . MessageReceivedAck ] , 
 + 40003 → classOf [ DialogCommands . MessageRead ] , 
 + 40004 → classOf [ DialogCommands . MessageReadAck ] 
 ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 index 49176df . . 67c8d445 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / Processor . scala 
 @ @ - 2 , 7 + 2 , 7 @ @ package im . actor . server . office 
 
 import java . util . concurrent . TimeUnit 
 
 - import akka . actor . { ActorRef , Status } 
 + import akka . actor . { ActorRef , Status } 
 import akka . contrib . pattern . ShardRegion . Passivate 
 import akka . pattern . pipe 
 import akka . persistence . PersistentActor 
 @ @ - 65 , 21 + 65 , 21 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 final def receiveCommand = initializing 
 
 protected final def initializing : Receive = handleInitCommand orElse { 
 - case msg = > 
 + case msg ⇒ 
 log . debug ( " Entity not found while processing { } " , msg ) 
 sender ( ) ! Status . Failure ( EntityNotFound ) 
 } 
 
 protected final def working ( state : State ) : Receive = handleCommand ( state ) orElse handleQuery ( state ) orElse { 
 - case Work ( newState ) = > context become working ( newState ) 
 - case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) 
 + case Work ( newState ) ⇒ context become working ( newState ) 
 + case unmatched ⇒ log . warning ( " Unmatched message : { } , sender : { } " , unmatched , sender ( ) ) 
 } 
 
 protected final def stashingBehavior : Receive = { 
 - case UnstashAndWork ( evt , s ) = > 
 + case UnstashAndWork ( evt , s ) ⇒ 
 context become working ( updatedState ( evt , s ) ) 
 unstashAll ( ) 
 - case UnstashAndWorkBatch ( es , s ) = > 
 + case UnstashAndWorkBatch ( es , s ) ⇒ 
 val newState = es . foldLeft ( s ) { 
 case ( acc , e ) ⇒ 
 log . debug ( " Updating state : { } with event : { } " , acc , e ) 
 @ @ - 94 , 7 + 94 , 7 @ @ trait Processor [ State , Event < : AnyRef ] extends PersistentActor with ActorFuture 
 
 protected final def stashing ( state : State ) : Receive = handleQuery ( state ) orElse stashingBehavior 
 
 - final def persistReply [ R ] ( e : Event , state : State ) ( f : Event = > Future [ R ] ) : Unit = 
 + final def persistReply [ R ] ( e : Event , state : State ) ( f : Event ⇒ Future [ R ] ) : Unit = 
 persistReply ( e , state , sender ( ) ) ( f ) 
 
 final def persistReply [ R ] ( e : Event , state : State , replyTo : ActorRef ) ( f : Event ⇒ Future [ R ] ) : Unit = { 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala b / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala 
 index aba292a . . 531dc63 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / util / cache / CacheHelpers . scala 
 @ @ - 1 , 8 + 1 , 8 @ @ 
 package im . actor . util . cache 
 
 - import com . github . benmanes . caffeine . cache . { Caffeine , Cache } 
 + import com . github . benmanes . caffeine . cache . { Caffeine , Cache } 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . { ExecutionContext , Future } 
 
 object CacheHelpers { 
 
 @ @ - 21 , 7 + 21 , 7 @ @ object CacheHelpers { 
 cache . put ( key , result ) 
 
 result recover { 
 - case e = > 
 + case e ⇒ 
 cache . invalidate ( key ) 
 throw e 
 } 
 diff - - git a / actor - server / project / Formatting . scala b / actor - server / project / Formatting . scala 
 index 69b0c9d . . cd6bf6e 100644 
 - - - a / actor - server / project / Formatting . scala 
 + + + b / actor - server / project / Formatting . scala 
 @ @ - 24 , 6 + 24 , 7 @ @ object Formatting { 
 . setPreference ( RewriteArrowSymbols , true ) 
 . setPreference ( AlignParameters , true ) 
 . setPreference ( AlignSingleLineCaseStatements , true ) 
 + . setPreference ( SpacesAroundMultiImports , true ) 
 } 
 
 def docFormattingPreferences = { 
 diff - - git a / actor - server / project / plugins . sbt b / actor - server / project / plugins . sbt 
 index e31b3f4 . . b75ac6e 100644 
 - - - a / actor - server / project / plugins . sbt 
 + + + b / actor - server / project / plugins . sbt 
 @ @ - 19 , 7 + 19 , 7 @ @ addSbtPlugin ( " im . actor " % % " sbt - actor - api " % " 0 . 6 . 15 " ) 
 
 / / addSbtPlugin ( " com . typesafe . play " % " sbt - plugin " % " 2 . 3 . 9 " ) 
 
 - addSbtPlugin ( " org . scalariform " % " sbt - scalariform " % " 1 . 4 . 0 " ) 
 + addSbtPlugin ( " org . scalariform " % " sbt - scalariform " % " 1 . 5 . 1 " ) 
 
 addSbtPlugin ( " com . typesafe . sbt " % " sbt - native - packager " % " 1 . 0 . 4 " )
