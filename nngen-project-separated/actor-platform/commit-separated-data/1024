BLEU SCORE: 0.2620251007173263

TEST MSG: fix ( server : core ) : stash messages on dialog send
GENERATED MSG: fix ( server : dialog ) : fix group dialog issues

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 6cb7497 . . 024adab 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 15 , 7 + 15 , 6 @ @ import im . actor . server . social . SocialManager < nl > import im . actor . util . cache . CacheHelpers . _ < nl > import im . actor . server . ApiConversions . _ < nl > import org . joda . time . DateTime < nl > - import slick . dbio . DBIO < nl > < nl > import scala . concurrent . Future < nl > import scala . util . Failure < nl > @ @ - 27 , 6 + 26 , 19 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > import DialogEvents . _ < nl > < nl > protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > + context become receiveStashing ( replyTo ⇒ ( { < nl > + case seq : SeqStateDate ⇒ < nl > + replyTo ! seq < nl > + if ( state . isHidden ) { < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > + updateMessageDate ( state , sm . date , checkOpen = true ) < nl > + unstashAll ( ) < nl > + case fail : Status . Failure ⇒ < nl > + replyTo forward fail < nl > + unstashAll ( ) < nl > + } : Receive ) orElse reactions ( state ) ) < nl > + < nl > ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > for { < nl > _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > @ @ - 39 , 12 + 51 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > case e ⇒ < nl > log . error ( e , " Failed to send message " ) < nl > throw e < nl > - } ) pipeTo sender ( ) onSuccess { < nl > - case _ ⇒ < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > - } < nl > - updateMessageDate ( state , sm . date , checkOpen = true ) < nl > + } ) pipeTo self < nl > } < nl > < nl > protected def updateCountersChanged ( ) : Unit = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index e806656 . . 69c4afd 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 152 , 25 + 152 , 33 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > self ! Kill < nl > } ) < nl > < nl > - def initialized ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > - case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) < nl > - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > - case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) < nl > - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) < nl > + < nl > + / / when receiving this messages , dialog reacts on other dialog ' s < nl > + / / action ( except for WriteMessage and WriteMessageSelf - they don ' t really belong here ) < nl > + def reactions ( state : DialogState ) : Receive = { < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > + case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) < nl > + case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) < nl > + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > - case Show ( _ ) ⇒ show ( state ) < nl > - case Hide ( _ ) ⇒ hide ( state ) < nl > - case Favourite ( _ ) ⇒ favourite ( state ) < nl > - case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > - case Delete ( _ ) ⇒ delete ( state ) < nl > - case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > + case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > + } < nl > + < nl > + / / when receiving this messages , dialog required to take action < nl > + def actions ( state : DialogState ) : Receive = { < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > + case Show ( _ ) ⇒ show ( state ) < nl > + case Hide ( _ ) ⇒ hide ( state ) < nl > + case Favourite ( _ ) ⇒ favourite ( state ) < nl > + case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > + case Delete ( _ ) ⇒ delete ( state ) < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 4e705ac < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > @ @ - 0 , 0 + 1 , 62 @ @ < nl > + package im . actor . server . dialog < nl > + < nl > + import akka . testkit . TestProbe < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogCommands . { SendMessageAck , SendMessage } < nl > + import im . actor . server . model . Peer < nl > + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > + < nl > + import scala . concurrent . duration . _ < nl > + < nl > + final class DialogProcessorSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with PeersImplicits { < nl > + < nl > + behavior of " Dialog Processor " < nl > + < nl > + it should " not allow deadlocks with high frequent messages " in e1 ( ) < nl > + < nl > + def e1 ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val alicePeer = Peer . privat ( alice . id ) < nl > + val bobPeer = Peer . privat ( bob . id ) < nl > + < nl > + val aliceDialog = system . actorOf ( DialogProcessor . props ( alice . id , bobPeer , Seq . empty ) , s " Private _ dialog _ with _ bob " ) < nl > + val bobDialog = system . actorOf ( DialogProcessor . props ( bob . id , alicePeer , Seq . empty ) , s " Private _ dialog _ with _ alice " ) < nl > + < nl > + val probe = TestProbe ( ) < nl > + < nl > + def sendMessageToAlice ( text : String ) = < nl > + aliceDialog . tell ( SendMessage ( bobPeer , alicePeer , bobAuthSid , System . currentTimeMillis , ACLUtils . randomLong ( ) , textMessage ( text ) ) , probe . ref ) < nl > + < nl > + def sendMessageToBob ( text : String ) = < nl > + bobDialog . tell ( SendMessage ( alicePeer , bobPeer , aliceAuthSid , System . currentTimeMillis , ACLUtils . randomLong ( ) , textMessage ( text ) ) , probe . ref ) < nl > + < nl > + / / 3 messages to alice < nl > + for ( i ← 1 to 3 ) { sendMessageToAlice ( s " Hello $ i " ) } < nl > + / / 1 message to bob < nl > + sendMessageToBob ( " Hello you back " ) < nl > + < nl > + / / 4 messages to alice < nl > + for ( i ← 1 to 4 ) { sendMessageToAlice ( s " How are you $ i " ) } < nl > + / / 2 messages to bob < nl > + sendMessageToBob ( " Well , I am fine 1 " ) < nl > + sendMessageToBob ( " Well , I am fine 2 " ) < nl > + < nl > + / / 4 messages to alice < nl > + for ( i ← 1 to 4 ) { sendMessageToAlice ( s " Mee too $ i " ) } < nl > + < nl > + / / 1 message to bob < nl > + sendMessageToBob ( " Cool " ) < nl > + < nl > + / / 2 messages to alice < nl > + for ( i ← 1 to 2 ) { sendMessageToAlice ( s " Well bye $ i " ) } < nl > + < nl > + / / 3 + 1 + 4 + 2 + 4 + 1 + 2 = 17 messages < nl > + val expectThese = Array . fill ( 17 ) ( classOf [ SendMessageAck ] ) < nl > + < nl > + probe . expectMsgAllConformingOf ( 20 . seconds , expectThese : _ * ) < nl > + } < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index b7a71be . . b3c2204 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 132 , 19 + 132 , 29 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > self ! Kill < nl > } ) < nl > < nl > - def initialized ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > + def initialized ( state : DialogState ) : Receive = invokesRcv ( state ) orElse acceptsRcv ( state ) orElse { < nl > case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > case md : LastOwnMessageDate ⇒ updateOwnMessageDate ( state , md ) < nl > case Show ( _ ) ⇒ show ( state ) < nl > case Hide ( _ ) ⇒ hide ( state ) < nl > } < nl > < nl > + def invokesRcv ( state : DialogState ) : Receive = { < nl > + case dc : DirectDialogCommand if invokes ( dc ) ⇒ dc match { < nl > + case sm : SendMessage ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case mrv : MessageReceived ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrd : MessageRead ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + } < nl > + } < nl > + < nl > + def acceptsRcv ( state : DialogState ) : Receive = { < nl > + case dc : DirectDialogCommand if accepts ( dc ) ⇒ dc match { < nl > + case sm : SendMessage ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > + } < nl > + } < nl > + < nl > / * * < nl > * dialog owner invokes ` dc ` < nl > * destination should be ` peer ` and origin should be ` selfPeer ` < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 218c286 . . 9c4b38c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 105 , 23 + 105 , 26 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } else { < nl > Future . successful ( MessageReceivedAck ( ) ) < nl > } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to process MessageReceived " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to process MessageReceived " ) < nl > } < nl > < nl > if ( mustReceive ) { < nl > - onSuccess ( receiveFuture ) { _ ⇒ < nl > - updateOwnReceiveDate ( state , mr . date ) < nl > - } < nl > + receiveFuture pipeTo self < nl > + becomeStashing ( replyTo ⇒ acceptsRcv ( state ) orElse { < nl > + case MessageReceivedAck ( ) ⇒ < nl > + updateOwnReceiveDate ( state , mr . date ) < nl > + context . unbecome ( ) < nl > + unstashAll ( ) < nl > + } ) < nl > } < nl > } < nl > < nl > protected def ackMessageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > val notifyFuture = < nl > ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { < nl > - case Failure ( e ) = > log . error ( e , " Failed to ack MessageReceived " ) < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) < nl > } < nl > < nl > - < nl > onSuccess ( notifyFuture ) { _ ⇒ < nl > updatePeerReceiveDate ( state , mr . date ) < nl > } < nl > @ @ - 143 , 9 + 146 , 13 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > } < nl > < nl > if ( mustRead ) { < nl > - onSuccess ( readFuture ) { _ ⇒ < nl > - updateOwnReadDate ( state , mr . date ) < nl > - } < nl > + readFuture pipeTo self < nl > + becomeStashing ( replyTo ⇒ acceptsRcv ( state ) orElse { < nl > + case MessageReadAck ( ) ⇒ < nl > + updateOwnReadDate ( state , mr . date ) < nl > + context . unbecome ( ) < nl > + unstashAll ( ) < nl > + } ) < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 6cb7497 . . 024adab 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 15 , 7 + 15 , 6 @ @ import im . actor . server . social . SocialManager 
 import im . actor . util . cache . CacheHelpers . _ 
 import im . actor . server . ApiConversions . _ 
 import org . joda . time . DateTime 
 - import slick . dbio . DBIO 
 
 import scala . concurrent . Future 
 import scala . util . Failure 
 @ @ - 27 , 6 + 26 , 19 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 import DialogEvents . _ 
 
 protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 + context become receiveStashing ( replyTo ⇒ ( { 
 + case seq : SeqStateDate ⇒ 
 + replyTo ! seq 
 + if ( state . isHidden ) { 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 + updateMessageDate ( state , sm . date , checkOpen = true ) 
 + unstashAll ( ) 
 + case fail : Status . Failure ⇒ 
 + replyTo forward fail 
 + unstashAll ( ) 
 + } : Receive ) orElse reactions ( state ) ) 
 + 
 ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 for { 
 _ ← dialogExt . ackSendMessage ( peer , sm ) 
 @ @ - 39 , 12 + 51 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 case e ⇒ 
 log . error ( e , " Failed to send message " ) 
 throw e 
 - } ) pipeTo sender ( ) onSuccess { 
 - case _ ⇒ 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 - } 
 - updateMessageDate ( state , sm . date , checkOpen = true ) 
 + } ) pipeTo self 
 } 
 
 protected def updateCountersChanged ( ) : Unit = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index e806656 . . 69c4afd 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 152 , 25 + 152 , 33 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 self ! Kill 
 } ) 
 
 - def initialized ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 - case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) 
 - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 - case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) 
 - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) 
 + 
 + / / when receiving this messages , dialog reacts on other dialog ' s 
 + / / action ( except for WriteMessage and WriteMessageSelf - they don ' t really belong here ) 
 + def reactions ( state : DialogState ) : Receive = { 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 + case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) 
 + case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) 
 + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 - case Show ( _ ) ⇒ show ( state ) 
 - case Hide ( _ ) ⇒ hide ( state ) 
 - case Favourite ( _ ) ⇒ favourite ( state ) 
 - case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 - case Delete ( _ ) ⇒ delete ( state ) 
 - case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 + case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 + } 
 + 
 + / / when receiving this messages , dialog required to take action 
 + def actions ( state : DialogState ) : Receive = { 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 + case Show ( _ ) ⇒ show ( state ) 
 + case Hide ( _ ) ⇒ hide ( state ) 
 + case Favourite ( _ ) ⇒ favourite ( state ) 
 + case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 + case Delete ( _ ) ⇒ delete ( state ) 
 } 
 
 / * * 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 new file mode 100644 
 index 0000000 . . 4e705ac 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 @ @ - 0 , 0 + 1 , 62 @ @ 
 + package im . actor . server . dialog 
 + 
 + import akka . testkit . TestProbe 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogCommands . { SendMessageAck , SendMessage } 
 + import im . actor . server . model . Peer 
 + import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 + 
 + import scala . concurrent . duration . _ 
 + 
 + final class DialogProcessorSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with PeersImplicits { 
 + 
 + behavior of " Dialog Processor " 
 + 
 + it should " not allow deadlocks with high frequent messages " in e1 ( ) 
 + 
 + def e1 ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val alicePeer = Peer . privat ( alice . id ) 
 + val bobPeer = Peer . privat ( bob . id ) 
 + 
 + val aliceDialog = system . actorOf ( DialogProcessor . props ( alice . id , bobPeer , Seq . empty ) , s " Private _ dialog _ with _ bob " ) 
 + val bobDialog = system . actorOf ( DialogProcessor . props ( bob . id , alicePeer , Seq . empty ) , s " Private _ dialog _ with _ alice " ) 
 + 
 + val probe = TestProbe ( ) 
 + 
 + def sendMessageToAlice ( text : String ) = 
 + aliceDialog . tell ( SendMessage ( bobPeer , alicePeer , bobAuthSid , System . currentTimeMillis , ACLUtils . randomLong ( ) , textMessage ( text ) ) , probe . ref ) 
 + 
 + def sendMessageToBob ( text : String ) = 
 + bobDialog . tell ( SendMessage ( alicePeer , bobPeer , aliceAuthSid , System . currentTimeMillis , ACLUtils . randomLong ( ) , textMessage ( text ) ) , probe . ref ) 
 + 
 + / / 3 messages to alice 
 + for ( i ← 1 to 3 ) { sendMessageToAlice ( s " Hello $ i " ) } 
 + / / 1 message to bob 
 + sendMessageToBob ( " Hello you back " ) 
 + 
 + / / 4 messages to alice 
 + for ( i ← 1 to 4 ) { sendMessageToAlice ( s " How are you $ i " ) } 
 + / / 2 messages to bob 
 + sendMessageToBob ( " Well , I am fine 1 " ) 
 + sendMessageToBob ( " Well , I am fine 2 " ) 
 + 
 + / / 4 messages to alice 
 + for ( i ← 1 to 4 ) { sendMessageToAlice ( s " Mee too $ i " ) } 
 + 
 + / / 1 message to bob 
 + sendMessageToBob ( " Cool " ) 
 + 
 + / / 2 messages to alice 
 + for ( i ← 1 to 2 ) { sendMessageToAlice ( s " Well bye $ i " ) } 
 + 
 + / / 3 + 1 + 4 + 2 + 4 + 1 + 2 = 17 messages 
 + val expectThese = Array . fill ( 17 ) ( classOf [ SendMessageAck ] ) 
 + 
 + probe . expectMsgAllConformingOf ( 20 . seconds , expectThese : _ * ) 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index b7a71be . . b3c2204 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 132 , 19 + 132 , 29 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 self ! Kill 
 } ) 
 
 - def initialized ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 + def initialized ( state : DialogState ) : Receive = invokesRcv ( state ) orElse acceptsRcv ( state ) orElse { 
 case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 case md : LastOwnMessageDate ⇒ updateOwnMessageDate ( state , md ) 
 case Show ( _ ) ⇒ show ( state ) 
 case Hide ( _ ) ⇒ hide ( state ) 
 } 
 
 + def invokesRcv ( state : DialogState ) : Receive = { 
 + case dc : DirectDialogCommand if invokes ( dc ) ⇒ dc match { 
 + case sm : SendMessage ⇒ sendMessage ( state , sm ) / / User sends message 
 + case mrv : MessageReceived ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrd : MessageRead ⇒ messageRead ( state , mrd ) / / User reads messages 
 + } 
 + } 
 + 
 + def acceptsRcv ( state : DialogState ) : Receive = { 
 + case dc : DirectDialogCommand if accepts ( dc ) ⇒ dc match { 
 + case sm : SendMessage ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 + case mrd : MessageRead ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 + } 
 + } 
 + 
 / * * 
 * dialog owner invokes ` dc ` 
 * destination should be ` peer ` and origin should be ` selfPeer ` 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 218c286 . . 9c4b38c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 105 , 23 + 105 , 26 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } else { 
 Future . successful ( MessageReceivedAck ( ) ) 
 } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to process MessageReceived " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to process MessageReceived " ) 
 } 
 
 if ( mustReceive ) { 
 - onSuccess ( receiveFuture ) { _ ⇒ 
 - updateOwnReceiveDate ( state , mr . date ) 
 - } 
 + receiveFuture pipeTo self 
 + becomeStashing ( replyTo ⇒ acceptsRcv ( state ) orElse { 
 + case MessageReceivedAck ( ) ⇒ 
 + updateOwnReceiveDate ( state , mr . date ) 
 + context . unbecome ( ) 
 + unstashAll ( ) 
 + } ) 
 } 
 } 
 
 protected def ackMessageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 val notifyFuture = 
 ( deliveryExt . notifyReceive ( userId , peer , mr . date , mr . now ) map { _ ⇒ MessageReceivedAck ( ) } ) pipeTo sender ( ) andThen { 
 - case Failure ( e ) = > log . error ( e , " Failed to ack MessageReceived " ) 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to ack MessageReceived " ) 
 } 
 
 - 
 onSuccess ( notifyFuture ) { _ ⇒ 
 updatePeerReceiveDate ( state , mr . date ) 
 } 
 @ @ - 143 , 9 + 146 , 13 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 } 
 
 if ( mustRead ) { 
 - onSuccess ( readFuture ) { _ ⇒ 
 - updateOwnReadDate ( state , mr . date ) 
 - } 
 + readFuture pipeTo self 
 + becomeStashing ( replyTo ⇒ acceptsRcv ( state ) orElse { 
 + case MessageReadAck ( ) ⇒ 
 + updateOwnReadDate ( state , mr . date ) 
 + context . unbecome ( ) 
 + unstashAll ( ) 
 + } ) 
 } 
 }
