BLEU SCORE: 0.020980574531482755

TEST MSG: feat ( server : webrtc ) : new webrtc api
GENERATED MSG: Merge remote - tracking branch ' origin / master '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json < nl > index 81b3c84 . . dd57b91 100644 < nl > - - - a / actor - server / actor - core / src / main / actor - api / actor . json < nl > + + + b / actor - server / actor - core / src / main / actor - api / actor . json < nl > @ @ - 12293 , 10 + 12293 , 10 @ @ < nl > { < nl > " type " : " update " , < nl > " content " : { < nl > - " name " : " CallEnded " , < nl > + " name " : " CallHandled " , < nl > " header " : 53 , < nl > " doc " : [ < nl > - " Update about call end " , < nl > + " Update about incoming call handled " , < nl > { < nl > " type " : " reference " , < nl > " argument " : " callId " , < nl > @ @ - 12314 , 43 + 12314 , 6 @ @ < nl > } < nl > } , < nl > { < nl > - " type " : " update " , < nl > - " content " : { < nl > - " name " : " CallRejected " , < nl > - " header " : 56 , < nl > - " doc " : [ < nl > - " Update about call reject " , < nl > - { < nl > - " type " : " reference " , < nl > - " argument " : " callId " , < nl > - " category " : " full " , < nl > - " description " : " Call Id " < nl > - } , < nl > - { < nl > - " type " : " reference " , < nl > - " argument " : " userId " , < nl > - " category " : " full " , < nl > - " description " : " User Id " < nl > - } < nl > - ] , < nl > - " attributes " : [ < nl > - { < nl > - " type " : " int64 " , < nl > - " id " : 1 , < nl > - " name " : " callId " < nl > - } , < nl > - { < nl > - " type " : { < nl > - " type " : " alias " , < nl > - " childType " : " userId " < nl > - } , < nl > - " id " : 2 , < nl > - " name " : " userId " < nl > - } < nl > - ] < nl > - } < nl > - } , < nl > - { < nl > " type " : " rpc " , < nl > " content " : { < nl > " name " : " GetCallInfo " , < nl > @ @ - 12497 , 83 + 12460 , 356 @ @ < nl > } < nl > } , < nl > { < nl > - " type " : " rpc " , < nl > + " type " : " trait " , < nl > " content " : { < nl > - " name " : " JoinCall " , < nl > - " header " : 2599 , < nl > - " response " : { < nl > - " type " : " reference " , < nl > - " name " : " Void " < nl > + " isContainer " : " true " , < nl > + " name " : " WebRTCSignaling " , < nl > + " attributes " : [ ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " AnswerCall " , < nl > + " doc " : [ < nl > + " Answer Call signal " < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 1 < nl > } , < nl > + " attributes " : [ ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " EndCall " , < nl > " doc " : [ < nl > - " Answer Call " , < nl > + " Ending Call signal " < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 2 < nl > + } , < nl > + " attributes " : [ ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " Candidate " , < nl > + " doc " : [ < nl > + " Candidate signal " , < nl > { < nl > " type " : " reference " , < nl > - " argument " : " peer " , < nl > + " argument " : " sessionId " , < nl > + " category " : " full " , < nl > + " description " : " Session Id of candidate " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 3 < nl > + } , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " sessionId " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " Offer " , < nl > + " doc " : [ < nl > + " Offer signal " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " sessionId " , < nl > " category " : " full " , < nl > - " description " : " Call Peer " < nl > + " description " : " Session Id of offer " < nl > } , < nl > { < nl > " type " : " reference " , < nl > - " argument " : " callId " , < nl > + " argument " : " sdp " , < nl > " category " : " full " , < nl > - " description " : " Call Id " < nl > + " description " : " Offer SDP " < nl > } < nl > ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 4 < nl > + } , < nl > " attributes " : [ < nl > { < nl > " type " : { < nl > - " type " : " struct " , < nl > - " childType " : " OutPeer " < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > } , < nl > " id " : 1 , < nl > - " name " : " peer " < nl > + " name " : " sessionId " < nl > } , < nl > { < nl > - " type " : " int64 " , < nl > + " type " : " string " , < nl > " id " : 2 , < nl > - " name " : " callId " < nl > + " name " : " sdp " < nl > } < nl > ] < nl > } < nl > } , < nl > { < nl > - " type " : " rpc " , < nl > + " type " : " struct " , < nl > " content " : { < nl > - " name " : " RejectCall " , < nl > - " header " : 2607 , < nl > - " response " : { < nl > - " type " : " reference " , < nl > - " name " : " Void " < nl > + " name " : " Answer " , < nl > + " doc " : [ < nl > + " Answer signal " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " sessionId " , < nl > + " category " : " full " , < nl > + " description " : " Session Id of answer " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " sdp " , < nl > + " category " : " full " , < nl > + " description " : " Answer SDP " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 5 < nl > } , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " sessionId " < nl > + } , < nl > + { < nl > + " type " : " string " , < nl > + " id " : 2 , < nl > + " name " : " sdp " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " NeedRenegotiate " , < nl > " doc " : [ < nl > - " End Call " , < nl > + " Need renegotiate session . For example when streams are changed . " , < nl > { < nl > " type " : " reference " , < nl > - " argument " : " peer " , < nl > + " argument " : " sessionId " , < nl > " category " : " full " , < nl > - " description " : " Call Peer " < nl > + " description " : " Session Id for renegotiation " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 6 < nl > + } , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " sessionId " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " ConnectedDevice " , < nl > + " doc " : [ < nl > + " Connected Device " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " device " , < nl > + " category " : " full " , < nl > + " description " : " Device Id " < nl > } , < nl > { < nl > " type " : " reference " , < nl > - " argument " : " callId " , < nl > + " argument " : " isConnecting " , < nl > " category " : " full " , < nl > - " description " : " Call Id " < nl > + " description " : " Is Connecting to device . Default is false . " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " isConnected " , < nl > + " category " : " full " , < nl > + " description " : " Is Connected to device . Default is false . " < nl > } < nl > ] , < nl > " attributes " : [ < nl > { < nl > " type " : { < nl > - " type " : " struct " , < nl > - " childType " : " OutPeer " < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > } , < nl > " id " : 1 , < nl > - " name " : " peer " < nl > + " name " : " device " < nl > } , < nl > { < nl > - " type " : " int64 " , < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bool " < nl > + } , < nl > " id " : 2 , < nl > - " name " : " callId " < nl > + " name " : " isConnecting " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bool " < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " isConnected " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " ConnectedUser " , < nl > + " doc " : [ < nl > + " Connected User " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " Device uid " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " isConnecting " , < nl > + " category " : " full " , < nl > + " description " : " Is Connecting to user . Default is false . " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " isConnected " , < nl > + " category " : " full " , < nl > + " description " : " Is connected to user . Default is false . " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bool " < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " isConnecting " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bool " < nl > + } , < nl > + " id " : 5 , < nl > + " name " : " isConnected " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " ActiveDevices " , < nl > + " doc " : [ < nl > + " List of current memb " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " users " , < nl > + " category " : " full " , < nl > + " description " : " Currently active users " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 7 < nl > + } , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " ConnectedUser " < nl > + } < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " users " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " NeedOffer " , < nl > + " doc " : [ < nl > + " Notification from owner that offer is required " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User ' s Id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " device " , < nl > + " category " : " full " , < nl > + " description " : " Destination Device Id " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " WebRTCSignaling " , < nl > + " key " : 8 < nl > + } , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " randomId " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " device " < nl > } < nl > ] < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index c9231b4 . . b1fad34 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 378 , 10 + 378 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > context become initialized ( state . updated ( Unfavourited ) ) < nl > < nl > / * * < nl > - * check access hash < nl > - * If ` optAccessHash ` is ` None ` - we simply don ' t check access hash < nl > - * If ` optSenderAuthId ` is None , and we are validating access hash for private peer - it is invalid < nl > - * / < nl > + * check access hash < nl > + * If ` optAccessHash ` is ` None ` - we simply don ' t check access hash < nl > + * If ` optSenderAuthId ` is None , and we are validating access hash for private peer - it is invalid < nl > + * / < nl > private def validateAccessHash ( peer : Peer , optSenderAuthId : Option [ Long ] , optAccessHash : Option [ Long ] ) : Future [ Boolean ] = < nl > optAccessHash map { hash ⇒ < nl > peer . ` type ` match { < nl > @ @ - 389 , 7 + 389 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > optSenderAuthId map { authId ⇒ userExt . checkAccessHash ( peer . id , authId , hash ) } getOrElse Future . successful ( false ) < nl > case PeerType . Group ⇒ < nl > groupExt . checkAccessHash ( peer . id , hash ) < nl > - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) < nl > + case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) < nl > } < nl > } getOrElse Future . successful ( true ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala < nl > index 18c108a . . 4a906d3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala < nl > @ @ - 15 , 6 + 15 , 9 @ @ import scala . concurrent . Future < nl > object EventBus { < nl > type EventBusId = String < nl > type DeviceId = Long < nl > + < nl > + final case class Message ( id : String , userId : Int , message : Array [ Byte ] ) < nl > + final case class Disposed ( id : String ) < nl > } < nl > < nl > final class EventBusExtension ( system : ActorSystem ) extends Extension { < nl > @ @ - 33 , 6 + 36 , 9 @ @ final class EventBusExtension ( system : ActorSystem ) extends Extension { < nl > EventBusMediator . extractShardId < nl > ) < nl > < nl > + def subscribe ( id : String , consumer : ActorRef ) : Future [ Unit ] = < nl > + ( region ? EventBusEnvelope ( id , Subscribe ( consumer ) ) ) map ( _ ⇒ ( ) ) < nl > + < nl > def create ( < nl > clientUserId : UserId , < nl > clientAuthId : AuthId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > index 8509e9d . . fa4ae6e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala < nl > @ @ - 35 , 6 + 35 , 9 @ @ private [ eventbus ] object EventBusMessages { < nl > < nl > final case class Join ( clientUserId : UserId , clientAuthId : AuthId , timeout : Option [ Long ] ) extends EventBusMessage < nl > final case class JoinAck ( deviceId : DeviceId ) < nl > + < nl > + final case class Subscribe ( ref : ActorRef ) extends EventBusMessage < nl > + final case class SubscribeAck ( subscribe : Subscribe ) < nl > } < nl > < nl > object EventBusMediator { < nl > @ @ - 64 , 6 + 67 , 7 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > val id = self . path . name < nl > < nl > var owner : Option [ Int ] = None < nl > + val internalConsumers = mutable . Set . empty [ ActorRef ] < nl > < nl > object consumers { < nl > private val a2d = mutable . Map . empty [ AuthId , ( UserId , DeviceId ) ] < nl > @ @ - 104 , 6 + 108 , 11 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > } < nl > } < nl > < nl > + override def postStop ( ) : Unit = { < nl > + super . postStop ( ) < nl > + internalConsumers foreach ( _ ! EventBus . Disposed ( id ) ) < nl > + } < nl > + < nl > def receive = { < nl > case Create ( clientUserId , clientAuthId , timeoutOpt , isOwned ) ⇒ < nl > if ( isOwned . contains ( true ) ) this . owner = Some ( clientUserId ) < nl > @ @ - 133 , 6 + 142 , 9 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > } < nl > } < nl > < nl > + val msg = EventBus . Message ( id , clientUserId , message ) < nl > + this . internalConsumers foreach ( _ ! msg ) < nl > + < nl > sender ( ) ! PostAck < nl > case KeepAlive ( clientAuthId , timeoutOpt ) ⇒ < nl > timeoutOpt match { < nl > @ @ - 162 , 8 + 174 , 18 @ @ final class EventBusMediator extends Actor with ActorLogging { < nl > broadcast ( UpdateEventBusDisposed ( id ) ) < nl > context stop self < nl > } else sender ( ) ! Status . Failure ( new RuntimeException ( " Attempt to dispose by not an owner " ) ) < nl > + case Subscribe ( ref ) ⇒ < nl > + this . internalConsumers . add ( ref ) < nl > + context watch ref < nl > + case Terminated ( ref ) ⇒ < nl > + this . internalConsumers . remove ( ref ) < nl > } < nl > < nl > private def broadcast ( update : Update ) : Unit = < nl > consumers . authIds foreach ( weakExt . pushUpdate ( _ , update , None , None ) ) < nl > + < nl > + override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { < nl > + super . preRestart ( reason , message ) < nl > + log . error ( reason , " Failure while processing message : { } " , message ) < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > index 5426045 . . 834f30d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 2 , 20 + 2 , 18 @ @ package im . actor . server . webrtc < nl > < nl > import akka . actor . _ < nl > import akka . pattern . pipe < nl > - import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . messaging . { ApiServiceMessage , ApiServiceExPhoneCall } < nl > import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } < nl > import im . actor . api . rpc . webrtc . _ < nl > import im . actor . concurrent . ActorStashing < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . eventbus . { EventBus , EventBusExtension } < nl > import im . actor . server . persist . webrtc . WebrtcCallRepo < nl > - import im . actor . server . sequence . { WeakUpdatesExtension , SeqUpdatesExtension } < nl > + import im . actor . server . sequence . WeakUpdatesExtension < nl > + import im . actor . types . _ < nl > < nl > - import scala . concurrent . Future < nl > - import scala . concurrent . duration . _ < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > - import scala . util . { Failure , Success } < nl > < nl > sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( message ) < nl > < nl > @ @ - 28 , 54 + 26 , 50 @ @ object WebrtcCallErrors { < nl > sealed trait WebrtcCallMessage < nl > < nl > object WebrtcCallMessages { < nl > - final case class StartCall ( callerUserId : Int , receiverUserId : Int ) extends WebrtcCallMessage < nl > - case object CallStarted < nl > + final case class StartCall ( callerUserId : Int , receiverUserId : Int , eventBusId : String ) extends WebrtcCallMessage < nl > + case object StartCallAck < nl > < nl > - final case class CallInProgress ( userId : Int , timeout : Int ) extends WebrtcCallMessage < nl > - object CallInProgressAck < nl > - < nl > - final case class CallSignal ( userId : Int , pkg : Array [ Byte ] ) extends WebrtcCallMessage < nl > - object CallSignalAck < nl > - < nl > - final case class EndCall ( userId : Int ) extends WebrtcCallMessage < nl > - object EndCallAck < nl > + case object GetInfo extends WebrtcCallMessage < nl > + final case class GetInfoAck ( eventBusId : String , callerUserId : UserId , participantUserIds : Seq [ UserId ] ) { < nl > + val tupled = ( eventBusId , callerUserId , participantUserIds ) < nl > + } < nl > } < nl > < nl > final case class WebrtcCallEnvelope ( id : Long , message : WebrtcCallMessage ) < nl > < nl > object WebrtcCallActor { < nl > val RegionTypeName = " WebrtcCall " < nl > - val DefaultCallTimeout = 30 . seconds < nl > < nl > def props = Props ( classOf [ WebrtcCallActor ] ) < nl > } < nl > < nl > private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > import WebrtcCallMessages . _ < nl > - import WebrtcCallActor . _ < nl > import context . dispatcher < nl > < nl > private val id = self . path . name . toLong < nl > < nl > private lazy val weakUpdExt = WeakUpdatesExtension ( context . system ) < nl > private lazy val dialogExt = DialogExtension ( context . system ) < nl > + private lazy val eventBusExt = EventBusExtension ( context . system ) < nl > private val db = DbExtension ( context . system ) . db < nl > < nl > def receive = waitForStart < nl > < nl > def waitForStart : Receive = { < nl > - case StartCall ( callerUserId , receiverUserId ) ⇒ < nl > + case StartCall ( callerUserId , receiverUserId , eventBusId ) ⇒ < nl > val update = UpdateIncomingCall ( id ) < nl > < nl > ( for { < nl > _ ← db . run ( WebrtcCallRepo . create ( WebrtcCall ( id , callerUserId , receiverUserId ) ) ) < nl > _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None , Some ( Webrtc . WeakGroup ) ) < nl > + _ ← eventBusExt . subscribe ( eventBusId , self ) < nl > } yield ( ) ) pipeTo self < nl > < nl > becomeStashing ( replyTo ⇒ { < nl > case ( ) ⇒ < nl > - replyTo ! CallStarted < nl > - context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) , scheduleEnd ( DefaultCallTimeout ) ) < nl > + replyTo ! StartCallAck < nl > + context become callInProgress ( eventBusId , System . currentTimeMillis ( ) , callerUserId , receiverUserId ) < nl > unstashAll ( ) < nl > case failure : Status . Failure ⇒ < nl > replyTo forward failure < nl > @ @ - 84 , 14 + 78 , 16 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > case _ ⇒ sender ( ) ! Status . Failure ( WebrtcCallErrors . CallNotStarted ) < nl > } < nl > < nl > - def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEndCaller : Cancellable , scheduledEndReceiver : Cancellable ) : Receive = { < nl > - def end ( ) : Future [ Unit ] = { < nl > + def callInProgress ( < nl > + eventBusId : String , < nl > + startTime : Long , < nl > + callerUserId : Int , < nl > + receiverUserId : Int < nl > + ) : Receive = { < nl > + def end ( ) : Unit = { < nl > val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt < nl > - val update = UpdateCallEnded ( id ) < nl > < nl > - for { < nl > - _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , None ) < nl > - _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None ) < nl > + ( for { < nl > _ ← dialogExt . sendMessage ( < nl > peer = ApiPeer ( ApiPeerType . Private , receiverUserId ) , < nl > senderUserId = callerUserId , < nl > @ @ - 101 , 7 + 97 , 11 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > message = ApiServiceMessage ( " Call ended " , Some ( ApiServiceExPhoneCall ( duration ) ) ) < nl > ) < nl > _ ← db . run ( WebrtcCallRepo . delete ( id ) ) < nl > - } yield ( ) < nl > + } yield PoisonPill ) pipeTo self onFailure { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to stop call " ) < nl > + context stop self < nl > + } < nl > } < nl > < nl > def withOrigin ( origin : Int ) ( f : Int ⇒ Any ) = < nl > @ @ - 113 , 65 + 113 , 21 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > sender ( ) ! Status . Failure ( WebrtcCallErrors . NotAParticipant ) < nl > < nl > { < nl > - case CallInProgress ( userId , timeout ) ⇒ < nl > - withOrigin ( userId ) { targetUserId ⇒ < nl > - / * < nl > - val newReceive = < nl > - if ( userId = = receiverUserId ) { < nl > - scheduledEndReceiver . cancel ( ) < nl > - callInProgress ( startTime , callerUserId , receiverUserId , scheduledEndCaller , scheduleEnd ( timeout . seconds ) ) < nl > - } else { < nl > - scheduledEndCaller . cancel ( ) < nl > - callInProgress ( startTime , callerUserId , receiverUserId , scheduleEnd ( timeout . seconds ) , scheduledEndReceiver ) < nl > - } < nl > - < nl > - val update : Update = ? ? ? < nl > - < nl > - ( for { < nl > - _ ← weakUpdExt . broadcastUserWeakUpdate ( targetUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > - } yield ( ) ) pipeTo self < nl > - < nl > - becomeStashing ( replyTo ⇒ { < nl > - case ( ) ⇒ < nl > - context become newReceive < nl > - unstashAll ( ) < nl > - replyTo ! CallInProgressAck < nl > - case failure @ Status . Failure ( cause ) ⇒ < nl > - replyTo ! failure < nl > - log . error ( cause , " Failed to process CallInProgress " ) < nl > - unstashAll ( ) < nl > - context . unbecome ( ) < nl > - } , discardOld = false ) * / < nl > - } < nl > - case CallSignal ( userId , pkg ) ⇒ < nl > - withOrigin ( userId ) { target ⇒ < nl > - / / TODO : stashing < nl > - < nl > - / * < nl > - val update : Update = ? ? ? < nl > - weakUpdExt . broadcastUserWeakUpdate ( target , update , Some ( s " webrtc _ call _ signal _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > - sender ( ) ! CallSignalAck < nl > - * / < nl > - } < nl > - case EndCall ( userId ) ⇒ < nl > - withOrigin ( userId ) { _ ⇒ < nl > - scheduledEndReceiver . cancel ( ) < nl > - scheduledEndCaller . cancel ( ) < nl > - val replyTo = sender ( ) < nl > - < nl > - end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onComplete { < nl > - case Success ( _ ) ⇒ replyTo ! EndCallAck < nl > - case Failure ( e ) ⇒ < nl > - replyTo ! Status . Failure ( e ) < nl > - log . error ( e , " Failed to end call " ) < nl > - } < nl > + case EventBus . Disposed ( _ ) ⇒ end ( ) < nl > + case EventBus . Message ( _ , userId , message ) ⇒ < nl > + ApiWebRTCSignaling . parseFrom ( message ) . right foreach { < nl > + case ApiAnswerCall ⇒ < nl > + context become callInProgress ( eventBusId , System . currentTimeMillis ( ) , callerUserId , receiverUserId ) < nl > + case ApiEndCall ⇒ < nl > + withOrigin ( userId ) ( _ ⇒ end ( ) ) < nl > + case _ ⇒ < nl > } < nl > + case GetInfo ⇒ < nl > + sender ( ) ! GetInfoAck ( eventBusId , callerUserId , Seq ( callerUserId , receiverUserId ) ) < nl > case _ : StartCall ⇒ sender ( ) ! WebrtcCallErrors . CallAlreadyStarted < nl > } < nl > } < nl > < nl > - def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) < nl > - < nl > override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { < nl > super . preRestart ( reason , message ) < nl > log . error ( reason , " Failure on message : { } " , message ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala < nl > index da62a6f . . cab508a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala < nl > @ @ - 6 , 6 + 6 , 7 @ @ import akka . cluster . sharding . ShardRegion . { ExtractShardId , ExtractEntityId } < nl > import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding } < nl > import akka . util . Timeout < nl > import im . actor . config . ActorConfig < nl > + import im . actor . types . _ < nl > < nl > import scala . concurrent . Future < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > @ @ - 32 , 20 + 33 , 14 @ @ final class WebrtcExtension ( system : ActorSystem ) extends Extension { < nl > ClusterSharding ( system ) < nl > . start ( " WebrtcCall " , WebrtcCallActor . props , ClusterShardingSettings ( system ) , extractEntityId , extractShardId ) < nl > < nl > - def doCall ( callerUserId : Int , receiverUserId : Int ) : Future [ Long ] = { < nl > + def doCall ( callerUserId : Int , receiverUserId : Int , eventBusId : String ) : Future [ Long ] = { < nl > val callId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > < nl > - region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId ) ) map ( _ ⇒ callId ) < nl > + region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId , eventBusId ) ) map ( _ ⇒ callId ) < nl > } < nl > < nl > - def endCall ( userId : Int , callId : Long ) : Future [ Unit ] = < nl > - region ? WebrtcCallEnvelope ( callId , EndCall ( userId ) ) map ( _ ⇒ ( ) ) < nl > - < nl > - def sendCallSignal ( userId : Int , callId : Long , content : Array [ Byte ] ) : Future [ Unit ] = < nl > - region ? WebrtcCallEnvelope ( callId , CallSignal ( userId , content ) ) map ( _ ⇒ ( ) ) < nl > - < nl > - def sendCallInProgress ( userId : Int , callId : Long , ptimeout : Int ) : Future [ Unit ] = < nl > - region ? WebrtcCallEnvelope ( callId , CallInProgress ( userId , ptimeout ) ) map ( _ ⇒ ( ) ) < nl > + def getInfo ( callId : Long ) : Future [ ( String , UserId , Seq [ UserId ] ) ] = < nl > + ( region ? WebrtcCallEnvelope ( callId , GetInfo ) ) . mapTo [ GetInfoAck ] map ( _ . tupled ) < nl > } < nl > < nl > object WebrtcExtension extends ExtensionIdProvider with ExtensionId [ WebrtcExtension ] { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > index 2e9bc0c . . 4738b70 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > @ @ - 4 , 8 + 4 , 10 @ @ import akka . actor . ActorSystem < nl > import akka . http . scaladsl . util . FastFuture < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . misc . ResponseVoid < nl > - import im . actor . api . rpc . peers . ApiOutPeer < nl > + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer , ApiOutPeer } < nl > import im . actor . api . rpc . webrtc . { ResponseGetCallInfo , ResponseDoCall , WebrtcService } < nl > + import im . actor . concurrent . FutureExt < nl > + import im . actor . server . acl . ACLUtils < nl > import im . actor . server . session . _ < nl > import im . actor . server . webrtc . { WebrtcCallErrors , WebrtcExtension , Webrtc } < nl > < nl > @ @ - 24 , 69 + 26 , 22 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi < nl > < nl > val webrtcExt = WebrtcExtension ( system ) < nl > < nl > - / * < nl > - override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > + override def jhandleGetCallInfo ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetCallInfo ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + ( eventBusId , callerUserId , participants ) ← webrtcExt . getInfo ( callId ) < nl > + users ← FutureExt . ftraverse ( participants ) ( ACLUtils . getUserOutPeer ( _ , client . authId ) ) < nl > + } yield Ok ( ResponseGetCallInfo ( ApiPeer ( ApiPeerType . Private , callerUserId ) , Vector . empty , users . toVector , eventBusId ) ) < nl > + } < nl > + < nl > + override def jhandleDoCall ( peer : ApiOutPeer , eventBusId : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > withOutPeerF ( peer ) { < nl > ( for { < nl > - callId ← webrtcExt . doCall ( client . userId , peer . id ) < nl > + callId ← webrtcExt . doCall ( client . userId , peer . id , eventBusId ) < nl > } yield Ok ( ResponseDoCall ( callId ) ) ) recover { < nl > case WebrtcCallErrors . CallAlreadyStarted ⇒ Error ( WebrtcErrors . CallAlreadyStareted ) < nl > } < nl > } < nl > } < nl > - < nl > - override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - authorized ( clientData ) { client ⇒ < nl > - ( for { < nl > - _ ← webrtcExt . endCall ( client . userId , callId ) < nl > - } yield Ok ( ResponseVoid ) ) recover { < nl > - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) < nl > - } < nl > - } < nl > - < nl > - override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - authorized ( clientData ) { client ⇒ < nl > - sessionRegion . ref ! < nl > - SessionEnvelope ( clientData . authId , clientData . sessionId ) < nl > - . withUnsubscribeFromWeak ( UnsubscribeFromWeak ( Some ( Webrtc . WeakGroup ) ) ) < nl > - FastFuture . successful ( Ok ( ResponseVoid ) ) < nl > - } < nl > - < nl > - override def jhandleCallInProgress ( callId : Long , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - authorized ( clientData ) { client ⇒ < nl > - ( for { < nl > - _ ← webrtcExt . sendCallInProgress ( client . userId , callId , timeout ) < nl > - } yield Ok ( ResponseVoid ) ) recover { < nl > - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) < nl > - } < nl > - } < nl > - < nl > - override def jhandleSubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - authorized ( clientData ) { client ⇒ < nl > - sessionRegion . ref ! < nl > - SessionEnvelope ( clientData . authId , clientData . sessionId ) < nl > - . withSubscribeToWeak ( SubscribeToWeak ( Some ( Webrtc . WeakGroup ) ) ) < nl > - FastFuture . successful ( Ok ( ResponseVoid ) ) < nl > - } < nl > - < nl > - override def jhandleSendCallSignal ( callId : Long , content : Array [ Byte ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - authorized ( clientData ) { client ⇒ < nl > - ( for { < nl > - _ ← webrtcExt . sendCallSignal ( client . userId , callId , content ) < nl > - } yield Ok ( ResponseVoid ) ) recover { < nl > - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) < nl > - } < nl > - } * / < nl > - override def jhandleGetCallInfo ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetCallInfo ] ] = < nl > - Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > - < nl > - override def jhandleRejectCall ( peer : ApiOutPeer , callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > - < nl > - override def jhandleJoinCall ( peer : ApiOutPeer , callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > - < nl > - override def jhandleDoCall ( peer : ApiOutPeer , eventBusId : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > - Future . failed ( new RuntimeException ( " Not implemented " ) ) < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > index 5e3d09e . . e2279cb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . sequence < nl > < nl > import akka . actor . _ < nl > + import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . codecs . UpdateBoxCodec < nl > @ @ - 9 , 11 + 10 , 16 @ @ import im . actor . api . rpc . sequence . { SeqUpdate , FatSeqUpdate , WeakUpdate } < nl > import im . actor . api . rpc . users . ApiUser < nl > import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } < nl > import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } < nl > + import im . actor . server . db . DbExtension < nl > import im . actor . server . group . GroupExtension < nl > + import im . actor . server . model . configs . Parameter < nl > import im . actor . server . mtproto . protocol . UpdateBox < nl > + import im . actor . server . persist . configs . ParameterRepo < nl > + import im . actor . server . persist . contact . UserContactRepo < nl > import im . actor . server . presences . _ < nl > import im . actor . server . user . UserExtension < nl > import org . joda . time . DateTime < nl > + import slick . dbio . DBIO < nl > < nl > import scala . concurrent . _ < nl > import scala . concurrent . duration . _ < nl > @ @ - 60 , 6 + 66 , 7 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , < nl > private val presenceExt = PresenceExtension ( system ) < nl > private val groupRresenceExt = GroupPresenceExtension ( system ) < nl > private val weakUpdatesExt = WeakUpdatesExtension ( system ) < nl > + private val db = DbExtension ( system ) . db < nl > < nl > private implicit val seqUpdExt : SeqUpdatesExtension = SeqUpdatesExtension ( context . system ) < nl > private var lastDateTime = new DateTime < nl > @ @ - 158 , 25 + 165 , 27 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , < nl > } < nl > case WeakUpdatesManager . UpdateReceived ( updateBox , reduceKey ) ⇒ < nl > sendUpdateBox ( updateBox , reduceKey ) < nl > - case PresenceState ( userId , presence , lastSeenAt ) ⇒ < nl > - val update : Update = < nl > + case p @ PresenceState ( _ , presence , lastSeenAt ) ⇒ < nl > + val updateFuture : Future [ Update ] = < nl > presence match { < nl > case Online ⇒ < nl > - UpdateUserOnline ( userId ) < nl > + FastFuture . successful ( UpdateUserOnline ( p . userId ) ) < nl > case Offline ⇒ < nl > lastSeenAt match { < nl > case Some ( date ) ⇒ < nl > - UpdateUserLastSeen ( userId , date . getMillis / 1000 ) < nl > + lastSeenOrOffline ( p . userId , date . getMillis / 1000 ) < nl > case None ⇒ < nl > - UpdateUserOffline ( userId ) < nl > + FastFuture . successful ( UpdateUserOffline ( p . userId ) ) < nl > } < nl > } < nl > < nl > - log . debug ( " Pushing presence { } " , update ) < nl > + updateFuture foreach { update ⇒ < nl > + log . debug ( " Pushing presence { } " , update ) < nl > < nl > - val updateBox = WeakUpdate ( nextDateTime ( ) . getMillis , update . header , update . toByteArray ) < nl > - val reduceKey = weakUpdatesExt . reduceKeyUser ( update . header , userId ) < nl > - sendUpdateBox ( updateBox , Some ( reduceKey ) ) < nl > + val updateBox = WeakUpdate ( nextDateTime ( ) . getMillis , update . header , update . toByteArray ) < nl > + val reduceKey = weakUpdatesExt . reduceKeyUser ( update . header , p . userId ) < nl > + sendUpdateBox ( updateBox , Some ( reduceKey ) ) < nl > + } < nl > case GroupPresenceState ( groupId , onlineCount ) ⇒ < nl > val update = UpdateGroupOnline ( groupId , onlineCount ) < nl > < nl > @ @ - 187 , 6 + 196 , 29 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , < nl > sendUpdateBox ( updateBox , Some ( reduceKey ) ) < nl > } < nl > < nl > + private def lastSeenOrOffline ( presenceUserId : Int , tsSeconds : Long ) : Future [ Update ] = { < nl > + db . run { < nl > + for { < nl > + selfCanLastSeen ← ParameterRepo . findValue ( userId , Parameter . Keys . Privacy . LastSeen , Parameter . Values . Privacy . LastSeen . Always . value ) < nl > + userCanLastSeen ← ParameterRepo . findValue ( presenceUserId , Parameter . Keys . Privacy . LastSeen , Parameter . Values . Privacy . LastSeen . Always . value ) < nl > + update ← if ( selfCanLastSeen = = Parameter . Values . Privacy . LastSeen . None . value | | < nl > + userCanLastSeen = = Parameter . Values . Privacy . LastSeen . None . value ) { < nl > + DBIO . successful ( UpdateUserOffline ( presenceUserId ) ) < nl > + } else if ( selfCanLastSeen = = Parameter . Values . Privacy . LastSeen . Contacts . value | | < nl > + userCanLastSeen = = Parameter . Values . Privacy . LastSeen . Contacts . value ) { < nl > + for { < nl > + isInContacts ← UserContactRepo . exists ( presenceUserId , userId ) < nl > + } yield { < nl > + if ( isInContacts ) < nl > + UpdateUserLastSeen ( presenceUserId , tsSeconds ) < nl > + else < nl > + UpdateUserOffline ( presenceUserId ) < nl > + } < nl > + } else DBIO . successful ( UpdateUserLastSeen ( presenceUserId , tsSeconds ) ) < nl > + } yield update < nl > + } < nl > + } < nl > + < nl > private def nextDateTime ( ) : DateTime = { < nl > val now = new DateTime < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > index 57fbdb7 . . 241a2bc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala < nl > @ @ - 51 , 5 + 51 , 4 @ @ object UserHook { < nl > abstract class BeforeEmailContactRegisteredHook ( system : ActorSystem ) extends Hook2 [ Int , String ] { < nl > def run ( userId : Int , email : String ) : Future [ Unit ] < nl > } < nl > - < nl > } < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala < nl > index 64309ac . . 765ea6e 100644 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala < nl > @ @ - 1 , 4 + 1 , 34 @ @ < nl > package im . actor . server . model . configs < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class Parameter ( userId : Int , key : String , value : Option [ String ] ) < nl > \ No newline at end of file < nl > + case class Parameter ( userId : Int , key : String , value : Option [ String ] ) < nl > + < nl > + object Parameter { < nl > + object Keys { < nl > + object Privacy { < nl > + val LastSeen = " privacy . last _ seen " < nl > + } < nl > + } < nl > + < nl > + sealed trait ParameterValue { < nl > + def value : String < nl > + } < nl > + < nl > + object Values { < nl > + object Privacy { < nl > + sealed trait LastSeen extends ParameterValue < nl > + < nl > + object LastSeen { < nl > + object Always extends LastSeen { < nl > + override def value : String = " always " < nl > + } < nl > + object Contacts extends LastSeen { < nl > + override def value : String = " contacts " < nl > + } < nl > + object None extends LastSeen { < nl > + override def value : String = " none " < nl > + } < nl > + } < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > index fd445e5 . . b4492ad 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > @ @ - 14 , 7 + 14 , 7 @ @ final class ParameterTable ( tag : Tag ) extends Table [ model . configs . Parameter ] ( tag , < nl > < nl > def value = column [ Option [ String ] ] ( " value " ) < nl > < nl > - def * = ( userId , key , value ) < > ( model . configs . Parameter . tupled , model . configs . Parameter . unapply ) < nl > + def * = ( userId , key , value ) < > ( ( model . configs . Parameter . apply _ ) . tupled , model . configs . Parameter . unapply ) < nl > } < nl > < nl > object ParameterRepo { < nl > @ @ - 41 , 6 + 41 , 9 @ @ object ParameterRepo { < nl > def findValue ( userId : Int , key : String ) ( implicit ec : ExecutionContext ) = < nl > firstByUserIdAndKeyC ( ( userId , key ) ) . result . headOption map ( _ . flatten ) < nl > < nl > + def findValue ( userId : Int , key : String , default : String ) ( implicit ec : ExecutionContext ) = < nl > + firstByUserIdAndKeyC ( ( userId , key ) ) . result . headOption map ( _ . flatten . getOrElse ( default ) ) < nl > + < nl > def findBooleanValue ( userId : Int , key : String , default : Boolean ) ( implicit ec : ExecutionContext ) = < nl > findValue ( userId , key ) map { < nl > case Some ( " false " ) ⇒ false < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > index 09eadda . . 47ce4bb 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala < nl > @ @ - 39 , 8 + 39 , 13 @ @ object UserContactRepo { < nl > def byPKDeleted ( ownerUserId : Int , contactUserId : Int ) = < nl > contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = true ) < nl > < nl > - def fetchAll = < nl > - active . result < nl > + def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ < nl > + byPKNotDeleted ( ownerUserId , contactUserId ) . exists < nl > + } < nl > + < nl > + def fetchAll = active . result < nl > + < nl > + def exists ( ownerUserId : Int , contactUserId : Int ) = existsC ( ( ownerUserId , contactUserId ) ) . result < nl > < nl > / / TODO : check usages - make sure they dont need phone number < nl > def find ( ownerUserId : Int , contactUserId : Int ) =

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json 
 index 81b3c84 . . dd57b91 100644 
 - - - a / actor - server / actor - core / src / main / actor - api / actor . json 
 + + + b / actor - server / actor - core / src / main / actor - api / actor . json 
 @ @ - 12293 , 10 + 12293 , 10 @ @ 
 { 
 " type " : " update " , 
 " content " : { 
 - " name " : " CallEnded " , 
 + " name " : " CallHandled " , 
 " header " : 53 , 
 " doc " : [ 
 - " Update about call end " , 
 + " Update about incoming call handled " , 
 { 
 " type " : " reference " , 
 " argument " : " callId " , 
 @ @ - 12314 , 43 + 12314 , 6 @ @ 
 } 
 } , 
 { 
 - " type " : " update " , 
 - " content " : { 
 - " name " : " CallRejected " , 
 - " header " : 56 , 
 - " doc " : [ 
 - " Update about call reject " , 
 - { 
 - " type " : " reference " , 
 - " argument " : " callId " , 
 - " category " : " full " , 
 - " description " : " Call Id " 
 - } , 
 - { 
 - " type " : " reference " , 
 - " argument " : " userId " , 
 - " category " : " full " , 
 - " description " : " User Id " 
 - } 
 - ] , 
 - " attributes " : [ 
 - { 
 - " type " : " int64 " , 
 - " id " : 1 , 
 - " name " : " callId " 
 - } , 
 - { 
 - " type " : { 
 - " type " : " alias " , 
 - " childType " : " userId " 
 - } , 
 - " id " : 2 , 
 - " name " : " userId " 
 - } 
 - ] 
 - } 
 - } , 
 - { 
 " type " : " rpc " , 
 " content " : { 
 " name " : " GetCallInfo " , 
 @ @ - 12497 , 83 + 12460 , 356 @ @ 
 } 
 } , 
 { 
 - " type " : " rpc " , 
 + " type " : " trait " , 
 " content " : { 
 - " name " : " JoinCall " , 
 - " header " : 2599 , 
 - " response " : { 
 - " type " : " reference " , 
 - " name " : " Void " 
 + " isContainer " : " true " , 
 + " name " : " WebRTCSignaling " , 
 + " attributes " : [ ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " AnswerCall " , 
 + " doc " : [ 
 + " Answer Call signal " 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 1 
 } , 
 + " attributes " : [ ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " EndCall " , 
 " doc " : [ 
 - " Answer Call " , 
 + " Ending Call signal " 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 2 
 + } , 
 + " attributes " : [ ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " Candidate " , 
 + " doc " : [ 
 + " Candidate signal " , 
 { 
 " type " : " reference " , 
 - " argument " : " peer " , 
 + " argument " : " sessionId " , 
 + " category " : " full " , 
 + " description " : " Session Id of candidate " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 3 
 + } , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 + } , 
 + " id " : 1 , 
 + " name " : " sessionId " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " Offer " , 
 + " doc " : [ 
 + " Offer signal " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " sessionId " , 
 " category " : " full " , 
 - " description " : " Call Peer " 
 + " description " : " Session Id of offer " 
 } , 
 { 
 " type " : " reference " , 
 - " argument " : " callId " , 
 + " argument " : " sdp " , 
 " category " : " full " , 
 - " description " : " Call Id " 
 + " description " : " Offer SDP " 
 } 
 ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 4 
 + } , 
 " attributes " : [ 
 { 
 " type " : { 
 - " type " : " struct " , 
 - " childType " : " OutPeer " 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 } , 
 " id " : 1 , 
 - " name " : " peer " 
 + " name " : " sessionId " 
 } , 
 { 
 - " type " : " int64 " , 
 + " type " : " string " , 
 " id " : 2 , 
 - " name " : " callId " 
 + " name " : " sdp " 
 } 
 ] 
 } 
 } , 
 { 
 - " type " : " rpc " , 
 + " type " : " struct " , 
 " content " : { 
 - " name " : " RejectCall " , 
 - " header " : 2607 , 
 - " response " : { 
 - " type " : " reference " , 
 - " name " : " Void " 
 + " name " : " Answer " , 
 + " doc " : [ 
 + " Answer signal " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " sessionId " , 
 + " category " : " full " , 
 + " description " : " Session Id of answer " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " sdp " , 
 + " category " : " full " , 
 + " description " : " Answer SDP " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 5 
 } , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 + } , 
 + " id " : 1 , 
 + " name " : " sessionId " 
 + } , 
 + { 
 + " type " : " string " , 
 + " id " : 2 , 
 + " name " : " sdp " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " NeedRenegotiate " , 
 " doc " : [ 
 - " End Call " , 
 + " Need renegotiate session . For example when streams are changed . " , 
 { 
 " type " : " reference " , 
 - " argument " : " peer " , 
 + " argument " : " sessionId " , 
 " category " : " full " , 
 - " description " : " Call Peer " 
 + " description " : " Session Id for renegotiation " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 6 
 + } , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 + } , 
 + " id " : 1 , 
 + " name " : " sessionId " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " ConnectedDevice " , 
 + " doc " : [ 
 + " Connected Device " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " device " , 
 + " category " : " full " , 
 + " description " : " Device Id " 
 } , 
 { 
 " type " : " reference " , 
 - " argument " : " callId " , 
 + " argument " : " isConnecting " , 
 " category " : " full " , 
 - " description " : " Call Id " 
 + " description " : " Is Connecting to device . Default is false . " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " isConnected " , 
 + " category " : " full " , 
 + " description " : " Is Connected to device . Default is false . " 
 } 
 ] , 
 " attributes " : [ 
 { 
 " type " : { 
 - " type " : " struct " , 
 - " childType " : " OutPeer " 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 } , 
 " id " : 1 , 
 - " name " : " peer " 
 + " name " : " device " 
 } , 
 { 
 - " type " : " int64 " , 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bool " 
 + } , 
 " id " : 2 , 
 - " name " : " callId " 
 + " name " : " isConnecting " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bool " 
 + } , 
 + " id " : 3 , 
 + " name " : " isConnected " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " ConnectedUser " , 
 + " doc " : [ 
 + " Connected User " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " Device uid " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " isConnecting " , 
 + " category " : " full " , 
 + " description " : " Is Connecting to user . Default is false . " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " isConnected " , 
 + " category " : " full " , 
 + " description " : " Is connected to user . Default is false . " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bool " 
 + } , 
 + " id " : 4 , 
 + " name " : " isConnecting " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bool " 
 + } , 
 + " id " : 5 , 
 + " name " : " isConnected " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " ActiveDevices " , 
 + " doc " : [ 
 + " List of current memb " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " users " , 
 + " category " : " full " , 
 + " description " : " Currently active users " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 7 
 + } , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " ConnectedUser " 
 + } 
 + } , 
 + " id " : 2 , 
 + " name " : " users " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " NeedOffer " , 
 + " doc " : [ 
 + " Notification from owner that offer is required " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User ' s Id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " device " , 
 + " category " : " full " , 
 + " description " : " Destination Device Id " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " WebRTCSignaling " , 
 + " key " : 8 
 + } , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " randomId " 
 + } , 
 + " id " : 2 , 
 + " name " : " device " 
 } 
 ] 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index c9231b4 . . b1fad34 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 378 , 10 + 378 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 context become initialized ( state . updated ( Unfavourited ) ) 
 
 / * * 
 - * check access hash 
 - * If ` optAccessHash ` is ` None ` - we simply don ' t check access hash 
 - * If ` optSenderAuthId ` is None , and we are validating access hash for private peer - it is invalid 
 - * / 
 + * check access hash 
 + * If ` optAccessHash ` is ` None ` - we simply don ' t check access hash 
 + * If ` optSenderAuthId ` is None , and we are validating access hash for private peer - it is invalid 
 + * / 
 private def validateAccessHash ( peer : Peer , optSenderAuthId : Option [ Long ] , optAccessHash : Option [ Long ] ) : Future [ Boolean ] = 
 optAccessHash map { hash ⇒ 
 peer . ` type ` match { 
 @ @ - 389 , 7 + 389 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 optSenderAuthId map { authId ⇒ userExt . checkAccessHash ( peer . id , authId , hash ) } getOrElse Future . successful ( false ) 
 case PeerType . Group ⇒ 
 groupExt . checkAccessHash ( peer . id , hash ) 
 - case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) 
 + case unknown ⇒ throw new RuntimeException ( s " Unknown peer type $ unknown " ) 
 } 
 } getOrElse Future . successful ( true ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala 
 index 18c108a . . 4a906d3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusExtension . scala 
 @ @ - 15 , 6 + 15 , 9 @ @ import scala . concurrent . Future 
 object EventBus { 
 type EventBusId = String 
 type DeviceId = Long 
 + 
 + final case class Message ( id : String , userId : Int , message : Array [ Byte ] ) 
 + final case class Disposed ( id : String ) 
 } 
 
 final class EventBusExtension ( system : ActorSystem ) extends Extension { 
 @ @ - 33 , 6 + 36 , 9 @ @ final class EventBusExtension ( system : ActorSystem ) extends Extension { 
 EventBusMediator . extractShardId 
 ) 
 
 + def subscribe ( id : String , consumer : ActorRef ) : Future [ Unit ] = 
 + ( region ? EventBusEnvelope ( id , Subscribe ( consumer ) ) ) map ( _ ⇒ ( ) ) 
 + 
 def create ( 
 clientUserId : UserId , 
 clientAuthId : AuthId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 index 8509e9d . . fa4ae6e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / eventbus / EventBusMediator . scala 
 @ @ - 35 , 6 + 35 , 9 @ @ private [ eventbus ] object EventBusMessages { 
 
 final case class Join ( clientUserId : UserId , clientAuthId : AuthId , timeout : Option [ Long ] ) extends EventBusMessage 
 final case class JoinAck ( deviceId : DeviceId ) 
 + 
 + final case class Subscribe ( ref : ActorRef ) extends EventBusMessage 
 + final case class SubscribeAck ( subscribe : Subscribe ) 
 } 
 
 object EventBusMediator { 
 @ @ - 64 , 6 + 67 , 7 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 val id = self . path . name 
 
 var owner : Option [ Int ] = None 
 + val internalConsumers = mutable . Set . empty [ ActorRef ] 
 
 object consumers { 
 private val a2d = mutable . Map . empty [ AuthId , ( UserId , DeviceId ) ] 
 @ @ - 104 , 6 + 108 , 11 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 } 
 } 
 
 + override def postStop ( ) : Unit = { 
 + super . postStop ( ) 
 + internalConsumers foreach ( _ ! EventBus . Disposed ( id ) ) 
 + } 
 + 
 def receive = { 
 case Create ( clientUserId , clientAuthId , timeoutOpt , isOwned ) ⇒ 
 if ( isOwned . contains ( true ) ) this . owner = Some ( clientUserId ) 
 @ @ - 133 , 6 + 142 , 9 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 } 
 } 
 
 + val msg = EventBus . Message ( id , clientUserId , message ) 
 + this . internalConsumers foreach ( _ ! msg ) 
 + 
 sender ( ) ! PostAck 
 case KeepAlive ( clientAuthId , timeoutOpt ) ⇒ 
 timeoutOpt match { 
 @ @ - 162 , 8 + 174 , 18 @ @ final class EventBusMediator extends Actor with ActorLogging { 
 broadcast ( UpdateEventBusDisposed ( id ) ) 
 context stop self 
 } else sender ( ) ! Status . Failure ( new RuntimeException ( " Attempt to dispose by not an owner " ) ) 
 + case Subscribe ( ref ) ⇒ 
 + this . internalConsumers . add ( ref ) 
 + context watch ref 
 + case Terminated ( ref ) ⇒ 
 + this . internalConsumers . remove ( ref ) 
 } 
 
 private def broadcast ( update : Update ) : Unit = 
 consumers . authIds foreach ( weakExt . pushUpdate ( _ , update , None , None ) ) 
 + 
 + override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { 
 + super . preRestart ( reason , message ) 
 + log . error ( reason , " Failure while processing message : { } " , message ) 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 index 5426045 . . 834f30d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 2 , 20 + 2 , 18 @ @ package im . actor . server . webrtc 
 
 import akka . actor . _ 
 import akka . pattern . pipe 
 - import im . actor . api . rpc . Update 
 import im . actor . api . rpc . messaging . { ApiServiceMessage , ApiServiceExPhoneCall } 
 import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } 
 import im . actor . api . rpc . webrtc . _ 
 import im . actor . concurrent . ActorStashing 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . eventbus . { EventBus , EventBusExtension } 
 import im . actor . server . persist . webrtc . WebrtcCallRepo 
 - import im . actor . server . sequence . { WeakUpdatesExtension , SeqUpdatesExtension } 
 + import im . actor . server . sequence . WeakUpdatesExtension 
 + import im . actor . types . _ 
 
 - import scala . concurrent . Future 
 - import scala . concurrent . duration . _ 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 - import scala . util . { Failure , Success } 
 
 sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( message ) 
 
 @ @ - 28 , 54 + 26 , 50 @ @ object WebrtcCallErrors { 
 sealed trait WebrtcCallMessage 
 
 object WebrtcCallMessages { 
 - final case class StartCall ( callerUserId : Int , receiverUserId : Int ) extends WebrtcCallMessage 
 - case object CallStarted 
 + final case class StartCall ( callerUserId : Int , receiverUserId : Int , eventBusId : String ) extends WebrtcCallMessage 
 + case object StartCallAck 
 
 - final case class CallInProgress ( userId : Int , timeout : Int ) extends WebrtcCallMessage 
 - object CallInProgressAck 
 - 
 - final case class CallSignal ( userId : Int , pkg : Array [ Byte ] ) extends WebrtcCallMessage 
 - object CallSignalAck 
 - 
 - final case class EndCall ( userId : Int ) extends WebrtcCallMessage 
 - object EndCallAck 
 + case object GetInfo extends WebrtcCallMessage 
 + final case class GetInfoAck ( eventBusId : String , callerUserId : UserId , participantUserIds : Seq [ UserId ] ) { 
 + val tupled = ( eventBusId , callerUserId , participantUserIds ) 
 + } 
 } 
 
 final case class WebrtcCallEnvelope ( id : Long , message : WebrtcCallMessage ) 
 
 object WebrtcCallActor { 
 val RegionTypeName = " WebrtcCall " 
 - val DefaultCallTimeout = 30 . seconds 
 
 def props = Props ( classOf [ WebrtcCallActor ] ) 
 } 
 
 private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 import WebrtcCallMessages . _ 
 - import WebrtcCallActor . _ 
 import context . dispatcher 
 
 private val id = self . path . name . toLong 
 
 private lazy val weakUpdExt = WeakUpdatesExtension ( context . system ) 
 private lazy val dialogExt = DialogExtension ( context . system ) 
 + private lazy val eventBusExt = EventBusExtension ( context . system ) 
 private val db = DbExtension ( context . system ) . db 
 
 def receive = waitForStart 
 
 def waitForStart : Receive = { 
 - case StartCall ( callerUserId , receiverUserId ) ⇒ 
 + case StartCall ( callerUserId , receiverUserId , eventBusId ) ⇒ 
 val update = UpdateIncomingCall ( id ) 
 
 ( for { 
 _ ← db . run ( WebrtcCallRepo . create ( WebrtcCall ( id , callerUserId , receiverUserId ) ) ) 
 _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None , Some ( Webrtc . WeakGroup ) ) 
 + _ ← eventBusExt . subscribe ( eventBusId , self ) 
 } yield ( ) ) pipeTo self 
 
 becomeStashing ( replyTo ⇒ { 
 case ( ) ⇒ 
 - replyTo ! CallStarted 
 - context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) , scheduleEnd ( DefaultCallTimeout ) ) 
 + replyTo ! StartCallAck 
 + context become callInProgress ( eventBusId , System . currentTimeMillis ( ) , callerUserId , receiverUserId ) 
 unstashAll ( ) 
 case failure : Status . Failure ⇒ 
 replyTo forward failure 
 @ @ - 84 , 14 + 78 , 16 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 case _ ⇒ sender ( ) ! Status . Failure ( WebrtcCallErrors . CallNotStarted ) 
 } 
 
 - def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEndCaller : Cancellable , scheduledEndReceiver : Cancellable ) : Receive = { 
 - def end ( ) : Future [ Unit ] = { 
 + def callInProgress ( 
 + eventBusId : String , 
 + startTime : Long , 
 + callerUserId : Int , 
 + receiverUserId : Int 
 + ) : Receive = { 
 + def end ( ) : Unit = { 
 val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt 
 - val update = UpdateCallEnded ( id ) 
 
 - for { 
 - _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , None ) 
 - _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None ) 
 + ( for { 
 _ ← dialogExt . sendMessage ( 
 peer = ApiPeer ( ApiPeerType . Private , receiverUserId ) , 
 senderUserId = callerUserId , 
 @ @ - 101 , 7 + 97 , 11 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 message = ApiServiceMessage ( " Call ended " , Some ( ApiServiceExPhoneCall ( duration ) ) ) 
 ) 
 _ ← db . run ( WebrtcCallRepo . delete ( id ) ) 
 - } yield ( ) 
 + } yield PoisonPill ) pipeTo self onFailure { 
 + case e ⇒ 
 + log . error ( e , " Failed to stop call " ) 
 + context stop self 
 + } 
 } 
 
 def withOrigin ( origin : Int ) ( f : Int ⇒ Any ) = 
 @ @ - 113 , 65 + 113 , 21 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 sender ( ) ! Status . Failure ( WebrtcCallErrors . NotAParticipant ) 
 
 { 
 - case CallInProgress ( userId , timeout ) ⇒ 
 - withOrigin ( userId ) { targetUserId ⇒ 
 - / * 
 - val newReceive = 
 - if ( userId = = receiverUserId ) { 
 - scheduledEndReceiver . cancel ( ) 
 - callInProgress ( startTime , callerUserId , receiverUserId , scheduledEndCaller , scheduleEnd ( timeout . seconds ) ) 
 - } else { 
 - scheduledEndCaller . cancel ( ) 
 - callInProgress ( startTime , callerUserId , receiverUserId , scheduleEnd ( timeout . seconds ) , scheduledEndReceiver ) 
 - } 
 - 
 - val update : Update = ? ? ? 
 - 
 - ( for { 
 - _ ← weakUpdExt . broadcastUserWeakUpdate ( targetUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 - } yield ( ) ) pipeTo self 
 - 
 - becomeStashing ( replyTo ⇒ { 
 - case ( ) ⇒ 
 - context become newReceive 
 - unstashAll ( ) 
 - replyTo ! CallInProgressAck 
 - case failure @ Status . Failure ( cause ) ⇒ 
 - replyTo ! failure 
 - log . error ( cause , " Failed to process CallInProgress " ) 
 - unstashAll ( ) 
 - context . unbecome ( ) 
 - } , discardOld = false ) * / 
 - } 
 - case CallSignal ( userId , pkg ) ⇒ 
 - withOrigin ( userId ) { target ⇒ 
 - / / TODO : stashing 
 - 
 - / * 
 - val update : Update = ? ? ? 
 - weakUpdExt . broadcastUserWeakUpdate ( target , update , Some ( s " webrtc _ call _ signal _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 - sender ( ) ! CallSignalAck 
 - * / 
 - } 
 - case EndCall ( userId ) ⇒ 
 - withOrigin ( userId ) { _ ⇒ 
 - scheduledEndReceiver . cancel ( ) 
 - scheduledEndCaller . cancel ( ) 
 - val replyTo = sender ( ) 
 - 
 - end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onComplete { 
 - case Success ( _ ) ⇒ replyTo ! EndCallAck 
 - case Failure ( e ) ⇒ 
 - replyTo ! Status . Failure ( e ) 
 - log . error ( e , " Failed to end call " ) 
 - } 
 + case EventBus . Disposed ( _ ) ⇒ end ( ) 
 + case EventBus . Message ( _ , userId , message ) ⇒ 
 + ApiWebRTCSignaling . parseFrom ( message ) . right foreach { 
 + case ApiAnswerCall ⇒ 
 + context become callInProgress ( eventBusId , System . currentTimeMillis ( ) , callerUserId , receiverUserId ) 
 + case ApiEndCall ⇒ 
 + withOrigin ( userId ) ( _ ⇒ end ( ) ) 
 + case _ ⇒ 
 } 
 + case GetInfo ⇒ 
 + sender ( ) ! GetInfoAck ( eventBusId , callerUserId , Seq ( callerUserId , receiverUserId ) ) 
 case _ : StartCall ⇒ sender ( ) ! WebrtcCallErrors . CallAlreadyStarted 
 } 
 } 
 
 - def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) 
 - 
 override def preRestart ( reason : Throwable , message : Option [ Any ] ) : Unit = { 
 super . preRestart ( reason , message ) 
 log . error ( reason , " Failure on message : { } " , message ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala 
 index da62a6f . . cab508a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala 
 @ @ - 6 , 6 + 6 , 7 @ @ import akka . cluster . sharding . ShardRegion . { ExtractShardId , ExtractEntityId } 
 import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding } 
 import akka . util . Timeout 
 import im . actor . config . ActorConfig 
 + import im . actor . types . _ 
 
 import scala . concurrent . Future 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 @ @ - 32 , 20 + 33 , 14 @ @ final class WebrtcExtension ( system : ActorSystem ) extends Extension { 
 ClusterSharding ( system ) 
 . start ( " WebrtcCall " , WebrtcCallActor . props , ClusterShardingSettings ( system ) , extractEntityId , extractShardId ) 
 
 - def doCall ( callerUserId : Int , receiverUserId : Int ) : Future [ Long ] = { 
 + def doCall ( callerUserId : Int , receiverUserId : Int , eventBusId : String ) : Future [ Long ] = { 
 val callId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 
 - region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId ) ) map ( _ ⇒ callId ) 
 + region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId , eventBusId ) ) map ( _ ⇒ callId ) 
 } 
 
 - def endCall ( userId : Int , callId : Long ) : Future [ Unit ] = 
 - region ? WebrtcCallEnvelope ( callId , EndCall ( userId ) ) map ( _ ⇒ ( ) ) 
 - 
 - def sendCallSignal ( userId : Int , callId : Long , content : Array [ Byte ] ) : Future [ Unit ] = 
 - region ? WebrtcCallEnvelope ( callId , CallSignal ( userId , content ) ) map ( _ ⇒ ( ) ) 
 - 
 - def sendCallInProgress ( userId : Int , callId : Long , ptimeout : Int ) : Future [ Unit ] = 
 - region ? WebrtcCallEnvelope ( callId , CallInProgress ( userId , ptimeout ) ) map ( _ ⇒ ( ) ) 
 + def getInfo ( callId : Long ) : Future [ ( String , UserId , Seq [ UserId ] ) ] = 
 + ( region ? WebrtcCallEnvelope ( callId , GetInfo ) ) . mapTo [ GetInfoAck ] map ( _ . tupled ) 
 } 
 
 object WebrtcExtension extends ExtensionIdProvider with ExtensionId [ WebrtcExtension ] { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 index 2e9bc0c . . 4738b70 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 @ @ - 4 , 8 + 4 , 10 @ @ import akka . actor . ActorSystem 
 import akka . http . scaladsl . util . FastFuture 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . misc . ResponseVoid 
 - import im . actor . api . rpc . peers . ApiOutPeer 
 + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer , ApiOutPeer } 
 import im . actor . api . rpc . webrtc . { ResponseGetCallInfo , ResponseDoCall , WebrtcService } 
 + import im . actor . concurrent . FutureExt 
 + import im . actor . server . acl . ACLUtils 
 import im . actor . server . session . _ 
 import im . actor . server . webrtc . { WebrtcCallErrors , WebrtcExtension , Webrtc } 
 
 @ @ - 24 , 69 + 26 , 22 @ @ final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : Sessi 
 
 val webrtcExt = WebrtcExtension ( system ) 
 
 - / * 
 - override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 + override def jhandleGetCallInfo ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetCallInfo ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + ( eventBusId , callerUserId , participants ) ← webrtcExt . getInfo ( callId ) 
 + users ← FutureExt . ftraverse ( participants ) ( ACLUtils . getUserOutPeer ( _ , client . authId ) ) 
 + } yield Ok ( ResponseGetCallInfo ( ApiPeer ( ApiPeerType . Private , callerUserId ) , Vector . empty , users . toVector , eventBusId ) ) 
 + } 
 + 
 + override def jhandleDoCall ( peer : ApiOutPeer , eventBusId : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 withOutPeerF ( peer ) { 
 ( for { 
 - callId ← webrtcExt . doCall ( client . userId , peer . id ) 
 + callId ← webrtcExt . doCall ( client . userId , peer . id , eventBusId ) 
 } yield Ok ( ResponseDoCall ( callId ) ) ) recover { 
 case WebrtcCallErrors . CallAlreadyStarted ⇒ Error ( WebrtcErrors . CallAlreadyStareted ) 
 } 
 } 
 } 
 - 
 - override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - authorized ( clientData ) { client ⇒ 
 - ( for { 
 - _ ← webrtcExt . endCall ( client . userId , callId ) 
 - } yield Ok ( ResponseVoid ) ) recover { 
 - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) 
 - } 
 - } 
 - 
 - override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - authorized ( clientData ) { client ⇒ 
 - sessionRegion . ref ! 
 - SessionEnvelope ( clientData . authId , clientData . sessionId ) 
 - . withUnsubscribeFromWeak ( UnsubscribeFromWeak ( Some ( Webrtc . WeakGroup ) ) ) 
 - FastFuture . successful ( Ok ( ResponseVoid ) ) 
 - } 
 - 
 - override def jhandleCallInProgress ( callId : Long , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - authorized ( clientData ) { client ⇒ 
 - ( for { 
 - _ ← webrtcExt . sendCallInProgress ( client . userId , callId , timeout ) 
 - } yield Ok ( ResponseVoid ) ) recover { 
 - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) 
 - } 
 - } 
 - 
 - override def jhandleSubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - authorized ( clientData ) { client ⇒ 
 - sessionRegion . ref ! 
 - SessionEnvelope ( clientData . authId , clientData . sessionId ) 
 - . withSubscribeToWeak ( SubscribeToWeak ( Some ( Webrtc . WeakGroup ) ) ) 
 - FastFuture . successful ( Ok ( ResponseVoid ) ) 
 - } 
 - 
 - override def jhandleSendCallSignal ( callId : Long , content : Array [ Byte ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - authorized ( clientData ) { client ⇒ 
 - ( for { 
 - _ ← webrtcExt . sendCallSignal ( client . userId , callId , content ) 
 - } yield Ok ( ResponseVoid ) ) recover { 
 - case WebrtcCallErrors . CallNotStarted ⇒ Error ( WebrtcErrors . CallNotStarted ) 
 - } 
 - } * / 
 - override def jhandleGetCallInfo ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseGetCallInfo ] ] = 
 - Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 - 
 - override def jhandleRejectCall ( peer : ApiOutPeer , callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 - 
 - override def jhandleJoinCall ( peer : ApiOutPeer , callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 - 
 - override def jhandleDoCall ( peer : ApiOutPeer , eventBusId : String , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 - Future . failed ( new RuntimeException ( " Not implemented " ) ) 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 index 5e3d09e . . e2279cb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . sequence 
 
 import akka . actor . _ 
 + import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . pipe 
 import akka . util . Timeout 
 import im . actor . api . rpc . codecs . UpdateBoxCodec 
 @ @ - 9 , 11 + 10 , 16 @ @ import im . actor . api . rpc . sequence . { SeqUpdate , FatSeqUpdate , WeakUpdate } 
 import im . actor . api . rpc . users . ApiUser 
 import im . actor . api . rpc . weak . { UpdateGroupOnline , UpdateUserLastSeen , UpdateUserOffline , UpdateUserOnline } 
 import im . actor . api . rpc . { Update , UpdateBox ⇒ ProtoUpdateBox } 
 + import im . actor . server . db . DbExtension 
 import im . actor . server . group . GroupExtension 
 + import im . actor . server . model . configs . Parameter 
 import im . actor . server . mtproto . protocol . UpdateBox 
 + import im . actor . server . persist . configs . ParameterRepo 
 + import im . actor . server . persist . contact . UserContactRepo 
 import im . actor . server . presences . _ 
 import im . actor . server . user . UserExtension 
 import org . joda . time . DateTime 
 + import slick . dbio . DBIO 
 
 import scala . concurrent . _ 
 import scala . concurrent . duration . _ 
 @ @ - 60 , 6 + 66 , 7 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , 
 private val presenceExt = PresenceExtension ( system ) 
 private val groupRresenceExt = GroupPresenceExtension ( system ) 
 private val weakUpdatesExt = WeakUpdatesExtension ( system ) 
 + private val db = DbExtension ( system ) . db 
 
 private implicit val seqUpdExt : SeqUpdatesExtension = SeqUpdatesExtension ( context . system ) 
 private var lastDateTime = new DateTime 
 @ @ - 158 , 25 + 165 , 27 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , 
 } 
 case WeakUpdatesManager . UpdateReceived ( updateBox , reduceKey ) ⇒ 
 sendUpdateBox ( updateBox , reduceKey ) 
 - case PresenceState ( userId , presence , lastSeenAt ) ⇒ 
 - val update : Update = 
 + case p @ PresenceState ( _ , presence , lastSeenAt ) ⇒ 
 + val updateFuture : Future [ Update ] = 
 presence match { 
 case Online ⇒ 
 - UpdateUserOnline ( userId ) 
 + FastFuture . successful ( UpdateUserOnline ( p . userId ) ) 
 case Offline ⇒ 
 lastSeenAt match { 
 case Some ( date ) ⇒ 
 - UpdateUserLastSeen ( userId , date . getMillis / 1000 ) 
 + lastSeenOrOffline ( p . userId , date . getMillis / 1000 ) 
 case None ⇒ 
 - UpdateUserOffline ( userId ) 
 + FastFuture . successful ( UpdateUserOffline ( p . userId ) ) 
 } 
 } 
 
 - log . debug ( " Pushing presence { } " , update ) 
 + updateFuture foreach { update ⇒ 
 + log . debug ( " Pushing presence { } " , update ) 
 
 - val updateBox = WeakUpdate ( nextDateTime ( ) . getMillis , update . header , update . toByteArray ) 
 - val reduceKey = weakUpdatesExt . reduceKeyUser ( update . header , userId ) 
 - sendUpdateBox ( updateBox , Some ( reduceKey ) ) 
 + val updateBox = WeakUpdate ( nextDateTime ( ) . getMillis , update . header , update . toByteArray ) 
 + val reduceKey = weakUpdatesExt . reduceKeyUser ( update . header , p . userId ) 
 + sendUpdateBox ( updateBox , Some ( reduceKey ) ) 
 + } 
 case GroupPresenceState ( groupId , onlineCount ) ⇒ 
 val update = UpdateGroupOnline ( groupId , onlineCount ) 
 
 @ @ - 187 , 6 + 196 , 29 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , 
 sendUpdateBox ( updateBox , Some ( reduceKey ) ) 
 } 
 
 + private def lastSeenOrOffline ( presenceUserId : Int , tsSeconds : Long ) : Future [ Update ] = { 
 + db . run { 
 + for { 
 + selfCanLastSeen ← ParameterRepo . findValue ( userId , Parameter . Keys . Privacy . LastSeen , Parameter . Values . Privacy . LastSeen . Always . value ) 
 + userCanLastSeen ← ParameterRepo . findValue ( presenceUserId , Parameter . Keys . Privacy . LastSeen , Parameter . Values . Privacy . LastSeen . Always . value ) 
 + update ← if ( selfCanLastSeen = = Parameter . Values . Privacy . LastSeen . None . value | | 
 + userCanLastSeen = = Parameter . Values . Privacy . LastSeen . None . value ) { 
 + DBIO . successful ( UpdateUserOffline ( presenceUserId ) ) 
 + } else if ( selfCanLastSeen = = Parameter . Values . Privacy . LastSeen . Contacts . value | | 
 + userCanLastSeen = = Parameter . Values . Privacy . LastSeen . Contacts . value ) { 
 + for { 
 + isInContacts ← UserContactRepo . exists ( presenceUserId , userId ) 
 + } yield { 
 + if ( isInContacts ) 
 + UpdateUserLastSeen ( presenceUserId , tsSeconds ) 
 + else 
 + UpdateUserOffline ( presenceUserId ) 
 + } 
 + } else DBIO . successful ( UpdateUserLastSeen ( presenceUserId , tsSeconds ) ) 
 + } yield update 
 + } 
 + } 
 + 
 private def nextDateTime ( ) : DateTime = { 
 val now = new DateTime 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 index 57fbdb7 . . 241a2bc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserExtension . scala 
 @ @ - 51 , 5 + 51 , 4 @ @ object UserHook { 
 abstract class BeforeEmailContactRegisteredHook ( system : ActorSystem ) extends Hook2 [ Int , String ] { 
 def run ( userId : Int , email : String ) : Future [ Unit ] 
 } 
 - 
 } 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala 
 index 64309ac . . 765ea6e 100644 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / configs / Parameter . scala 
 @ @ - 1 , 4 + 1 , 34 @ @ 
 package im . actor . server . model . configs 
 
 @ SerialVersionUID ( 1L ) 
 - case class Parameter ( userId : Int , key : String , value : Option [ String ] ) 
 \ No newline at end of file 
 + case class Parameter ( userId : Int , key : String , value : Option [ String ] ) 
 + 
 + object Parameter { 
 + object Keys { 
 + object Privacy { 
 + val LastSeen = " privacy . last _ seen " 
 + } 
 + } 
 + 
 + sealed trait ParameterValue { 
 + def value : String 
 + } 
 + 
 + object Values { 
 + object Privacy { 
 + sealed trait LastSeen extends ParameterValue 
 + 
 + object LastSeen { 
 + object Always extends LastSeen { 
 + override def value : String = " always " 
 + } 
 + object Contacts extends LastSeen { 
 + override def value : String = " contacts " 
 + } 
 + object None extends LastSeen { 
 + override def value : String = " none " 
 + } 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 index fd445e5 . . b4492ad 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 @ @ - 14 , 7 + 14 , 7 @ @ final class ParameterTable ( tag : Tag ) extends Table [ model . configs . Parameter ] ( tag , 
 
 def value = column [ Option [ String ] ] ( " value " ) 
 
 - def * = ( userId , key , value ) < > ( model . configs . Parameter . tupled , model . configs . Parameter . unapply ) 
 + def * = ( userId , key , value ) < > ( ( model . configs . Parameter . apply _ ) . tupled , model . configs . Parameter . unapply ) 
 } 
 
 object ParameterRepo { 
 @ @ - 41 , 6 + 41 , 9 @ @ object ParameterRepo { 
 def findValue ( userId : Int , key : String ) ( implicit ec : ExecutionContext ) = 
 firstByUserIdAndKeyC ( ( userId , key ) ) . result . headOption map ( _ . flatten ) 
 
 + def findValue ( userId : Int , key : String , default : String ) ( implicit ec : ExecutionContext ) = 
 + firstByUserIdAndKeyC ( ( userId , key ) ) . result . headOption map ( _ . flatten . getOrElse ( default ) ) 
 + 
 def findBooleanValue ( userId : Int , key : String , default : Boolean ) ( implicit ec : ExecutionContext ) = 
 findValue ( userId , key ) map { 
 case Some ( " false " ) ⇒ false 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 index 09eadda . . 47ce4bb 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / contact / UserContactRepo . scala 
 @ @ - 39 , 8 + 39 , 13 @ @ object UserContactRepo { 
 def byPKDeleted ( ownerUserId : Int , contactUserId : Int ) = 
 contacts . filter ( c ⇒ c . ownerUserId = = = ownerUserId & & c . contactUserId = = = contactUserId & & c . isDeleted = = = true ) 
 
 - def fetchAll = 
 - active . result 
 + def existsC = Compiled { ( ownerUserId : Rep [ Int ] , contactUserId : Rep [ Int ] ) ⇒ 
 + byPKNotDeleted ( ownerUserId , contactUserId ) . exists 
 + } 
 + 
 + def fetchAll = active . result 
 + 
 + def exists ( ownerUserId : Int , contactUserId : Int ) = existsC ( ( ownerUserId , contactUserId ) ) . result 
 
 / / TODO : check usages - make sure they dont need phone number 
 def find ( ownerUserId : Int , contactUserId : Int ) =
