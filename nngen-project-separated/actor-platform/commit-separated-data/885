BLEU SCORE: 0.4744325794453768

TEST MSG: fix ( server : auth ) : doubling ContactRegistered fixes # 325
GENERATED MSG: fix ( server : auth ) : mark registered in the same flow

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 9d71f70 . . 818cbe7 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . { LocalDateTime , ZoneOffset } < nl > import java . util . TimeZone < nl > < nl > import akka . actor . { ActorSystem , Status } < nl > + import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . pipe < nl > import im . actor . api . rpc . contacts . { UpdateContactsRemoved , UpdateContactRegistered , UpdateContactsAdded } < nl > import im . actor . api . rpc . messaging . _ < nl > @ @ - 166 , 28 + 167 , 36 @ @ private [ user ] trait UserCommandHandlers { < nl > } < nl > < nl > protected def addPhone ( user : UserState , phone : Long ) : Unit = < nl > - persistReply ( UserEvents . PhoneAdded ( now ( ) , phone ) , user ) { _ ⇒ < nl > - val rng = ThreadLocalSecureRandom . current ( ) < nl > - db . run ( for { < nl > - _ ← UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) < nl > - _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) < nl > - } yield { < nl > - AddPhoneAck ( ) < nl > - } ) andThen { < nl > - case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) < nl > + if ( user . phones . contains ( phone ) ) < nl > + sender ( ) ! AddPhoneAck ( ) < nl > + else { < nl > + persistReply ( UserEvents . PhoneAdded ( now ( ) , phone ) , user ) { _ ⇒ < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > + db . run ( for { < nl > + _ ← UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) < nl > + _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) < nl > + } yield { < nl > + AddPhoneAck ( ) < nl > + } ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) < nl > + } < nl > } < nl > } < nl > < nl > protected def addEmail ( user : UserState , email : String ) : Unit = < nl > - persistReply ( UserEvents . EmailAdded ( now ( ) , email ) , user ) { event ⇒ < nl > - val rng = ThreadLocalSecureRandom . current ( ) < nl > - db . run ( for { < nl > - _ ← UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) < nl > - _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) < nl > - } yield { < nl > - AddEmailAck ( ) < nl > - } ) andThen { < nl > - case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) < nl > + if ( user . emails . contains ( email ) ) < nl > + sender ( ) ! AddEmailAck ( ) < nl > + else { < nl > + persistReply ( UserEvents . EmailAdded ( now ( ) , email ) , user ) { event ⇒ < nl > + val rng = ThreadLocalSecureRandom . current ( ) < nl > + db . run ( for { < nl > + _ ← UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) < nl > + _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) < nl > + } yield { < nl > + AddEmailAck ( ) < nl > + } ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) < nl > + } < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > index 4989c9d . . 1f3c6f7 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 135 , 7 + 135 , 6 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > } < nl > } < nl > < nl > - < nl > override def postStop ( ) : Unit = { < nl > scheduledUpd foreach ( _ . cancel ( ) ) < nl > super . postStop ( )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 814c3ae . . 96a8e05 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 28 , 6 + 28 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . Future < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + import scala . util . Failure < nl > import scala . util . control . NoStackTrace < nl > < nl > sealed trait UserException extends RuntimeException < nl > @ @ - 144 , 12 + 145 , 12 @ @ private [ user ] trait UserCommandHandlers { < nl > val rng = ThreadLocalRandom . current ( ) < nl > db . run ( for { < nl > _ ← p . UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) < nl > + _ ← markContactRegistered ( user , phone , false ) < nl > } yield { < nl > - db . run ( markContactRegistered ( user , phone , false ) ) onFailure { < nl > - case e ⇒ log . error ( e , " Failed to mark phone contact registered " ) < nl > - } < nl > AddPhoneAck ( ) < nl > - } ) < nl > + } ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) < nl > + } < nl > } < nl > < nl > protected def addEmail ( user : User , email : String ) : Unit = < nl > @ @ - 157 , 12 + 158 , 12 @ @ private [ user ] trait UserCommandHandlers { < nl > val rng = ThreadLocalRandom . current ( ) < nl > db . run ( for { < nl > _ ← p . UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) < nl > + _ ← markContactRegistered ( user , email , false ) < nl > } yield { < nl > - db . run ( markContactRegistered ( user , email , false ) ) onFailure { < nl > - case e ⇒ log . error ( e , " Failed to mark email contact registered " ) < nl > - } < nl > AddEmailAck ( ) < nl > - } ) < nl > + } ) andThen { < nl > + case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) < nl > + } < nl > } < nl > < nl > protected def changeNickname ( user : User , clientAuthId : Long , nicknameOpt : Option [ String ] ) : Unit = {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 9d71f70 . . 818cbe7 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . { LocalDateTime , ZoneOffset } 
 import java . util . TimeZone 
 
 import akka . actor . { ActorSystem , Status } 
 + import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . pipe 
 import im . actor . api . rpc . contacts . { UpdateContactsRemoved , UpdateContactRegistered , UpdateContactsAdded } 
 import im . actor . api . rpc . messaging . _ 
 @ @ - 166 , 28 + 167 , 36 @ @ private [ user ] trait UserCommandHandlers { 
 } 
 
 protected def addPhone ( user : UserState , phone : Long ) : Unit = 
 - persistReply ( UserEvents . PhoneAdded ( now ( ) , phone ) , user ) { _ ⇒ 
 - val rng = ThreadLocalSecureRandom . current ( ) 
 - db . run ( for { 
 - _ ← UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) 
 - _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) 
 - } yield { 
 - AddPhoneAck ( ) 
 - } ) andThen { 
 - case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) 
 + if ( user . phones . contains ( phone ) ) 
 + sender ( ) ! AddPhoneAck ( ) 
 + else { 
 + persistReply ( UserEvents . PhoneAdded ( now ( ) , phone ) , user ) { _ ⇒ 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 + db . run ( for { 
 + _ ← UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) 
 + _ ← DBIO . from ( markContactRegistered ( user , phone , false ) ) 
 + } yield { 
 + AddPhoneAck ( ) 
 + } ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) 
 + } 
 } 
 } 
 
 protected def addEmail ( user : UserState , email : String ) : Unit = 
 - persistReply ( UserEvents . EmailAdded ( now ( ) , email ) , user ) { event ⇒ 
 - val rng = ThreadLocalSecureRandom . current ( ) 
 - db . run ( for { 
 - _ ← UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) 
 - _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) 
 - } yield { 
 - AddEmailAck ( ) 
 - } ) andThen { 
 - case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) 
 + if ( user . emails . contains ( email ) ) 
 + sender ( ) ! AddEmailAck ( ) 
 + else { 
 + persistReply ( UserEvents . EmailAdded ( now ( ) , email ) , user ) { event ⇒ 
 + val rng = ThreadLocalSecureRandom . current ( ) 
 + db . run ( for { 
 + _ ← UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) 
 + _ ← DBIO . from ( markContactRegistered ( user , email , false ) ) 
 + } yield { 
 + AddEmailAck ( ) 
 + } ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) 
 + } 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 index 4989c9d . . 1f3c6f7 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 135 , 7 + 135 , 6 @ @ private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 } 
 } 
 
 - 
 override def postStop ( ) : Unit = { 
 scheduledUpd foreach ( _ . cancel ( ) ) 
 super . postStop ( )

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 814c3ae . . 96a8e05 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 28 , 6 + 28 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . Future 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 + import scala . util . Failure 
 import scala . util . control . NoStackTrace 
 
 sealed trait UserException extends RuntimeException 
 @ @ - 144 , 12 + 145 , 12 @ @ private [ user ] trait UserCommandHandlers { 
 val rng = ThreadLocalRandom . current ( ) 
 db . run ( for { 
 _ ← p . UserPhoneRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , phone , " Mobile phone " ) 
 + _ ← markContactRegistered ( user , phone , false ) 
 } yield { 
 - db . run ( markContactRegistered ( user , phone , false ) ) onFailure { 
 - case e ⇒ log . error ( e , " Failed to mark phone contact registered " ) 
 - } 
 AddPhoneAck ( ) 
 - } ) 
 + } ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to add phone " ) 
 + } 
 } 
 
 protected def addEmail ( user : User , email : String ) : Unit = 
 @ @ - 157 , 12 + 158 , 12 @ @ private [ user ] trait UserCommandHandlers { 
 val rng = ThreadLocalRandom . current ( ) 
 db . run ( for { 
 _ ← p . UserEmailRepo . create ( rng . nextInt ( ) , userId , ACLUtils . nextAccessSalt ( rng ) , email , " Email " ) 
 + _ ← markContactRegistered ( user , email , false ) 
 } yield { 
 - db . run ( markContactRegistered ( user , email , false ) ) onFailure { 
 - case e ⇒ log . error ( e , " Failed to mark email contact registered " ) 
 - } 
 AddEmailAck ( ) 
 - } ) 
 + } ) andThen { 
 + case Failure ( e ) ⇒ log . error ( e , " Failed to add email " ) 
 + } 
 } 
 
 protected def changeNickname ( user : User , clientAuthId : Long , nicknameOpt : Option [ String ] ) : Unit = {
