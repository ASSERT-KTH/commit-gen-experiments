BLEU SCORE: 0.022473460321102867

TEST MSG: fix ( server : encryption ) : don ' t ignore ignoredKeyGroups
GENERATED MSG: Merge branch ' master ' of https : / / github . com / actorapp / actor - platform

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala < nl > index be6db900 . . 1ae29aa 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala < nl > @ @ - 207 , 15 + 207 , 23 @ @ final class EncryptionExtension ( system : ActorSystem ) extends Extension { < nl > actionT . value map ( _ . valueOr ( throw _ ) ) < nl > } < nl > < nl > - def checkBox ( box : ApiEncryptedBox ) : Future [ Either [ ( Vector [ ApiKeyGroupId ] , Vector [ ApiKeyGroupId ] ) , Map [ Int , Vector [ ( Int , ApiEncryptedBox ) ] ] ] ] = { < nl > + def checkBox ( < nl > + box : ApiEncryptedBox , < nl > + ignoredKeyGroups : Map [ Int , Set [ Int ] ] < nl > + ) : Future [ Either [ ( Vector [ ApiKeyGroupId ] , Vector [ ApiKeyGroupId ] ) , Map [ Int , Vector [ ( Int , ApiEncryptedBox ) ] ] ] ] = { < nl > val userChecksFu : Iterable [ Future [ ( Seq [ ApiKeyGroupId ] , Seq [ ApiKeyGroupId ] , Seq [ EncryptionKeyGroup ] ) ] ] = < nl > box . keys . groupBy ( _ . usersId ) map { < nl > case ( userId , keys ) ⇒ < nl > db . run ( EncryptionKeyGroupRepo . fetch ( userId ) ) map { kgs ⇒ < nl > / / kgs not presented in box < nl > + < nl > + val ignored = ignoredKeyGroups . getOrElse ( userId , Set . empty ) < nl > + < nl > val missingKgs = kgs . view < nl > . filterNot ( kg ⇒ keys . exists ( _ . keyGroupId = = kg . id ) ) < nl > - . map ( kg ⇒ ApiKeyGroupId ( userId , kg . id ) ) . force < nl > + . filterNot ( kg ⇒ ignored . contains ( kg . id ) ) < nl > + . map ( kg ⇒ ApiKeyGroupId ( userId , kg . id ) ) < nl > + . force < nl > < nl > / / kgs presented in box but deleted by receiver < nl > val obsKgs = keys . view < nl > @ @ - 236 , 15 + 244 , 15 @ @ final class EncryptionExtension ( system : ActorSystem ) extends Extension { < nl > if ( missing . nonEmpty | | obs . nonEmpty ) Left ( missing → obs ) < nl > else Right ( < nl > kgs < nl > - . groupBy ( _ . userId ) < nl > - . map { < nl > - case ( userId , ukgs ) ⇒ < nl > - ( userId , < nl > - ukgs map { kg ⇒ < nl > - val keys = box . keys . filter ( _ . keyGroupId = = kg . id ) < nl > - ( kg . authSid . get . value , box . copy ( keys = keys ) ) < nl > - } ) < nl > - } . toMap < nl > + . groupBy ( _ . userId ) < nl > + . map { < nl > + case ( userId , ukgs ) ⇒ < nl > + ( userId , < nl > + ukgs map { kg ⇒ < nl > + val keys = box . keys . filter ( _ . keyGroupId = = kg . id ) < nl > + ( kg . authSid . get . value , box . copy ( keys = keys ) ) < nl > + } ) < nl > + } < nl > ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala < nl > index 2a6c396 . . 8d70874 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala < nl > @ @ - 124 , 7 + 124 , 7 @ @ final class EncryptionServiceImpl ( implicit system : ActorSystem ) extends Encrypti < nl > db . run { < nl > withUserOutPeers ( destPeers ) { < nl > DBIO . from { < nl > - encExt . checkBox ( encryptedBox ) flatMap { < nl > + encExt . checkBox ( encryptedBox , ignoredKeyGroups . groupBy ( _ . userId ) . mapValues ( _ . map ( _ . keyGroupId ) . toSet ) ) flatMap { < nl > case Left ( ( missing , obs ) ) ⇒ < nl > FastFuture . successful ( Ok ( ResponseSendEncryptedPackage ( < nl > seq = None ,
NEAREST DIFF (one line): diff - - git a / README . MD b / README . MD < nl > index 8c53a78 . . 061c271 100644 < nl > - - - a / README . MD < nl > + + + b / README . MD < nl > @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa < nl > < nl > This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . < nl > < nl > + # Currently available clients < nl > + * Android 4 . 0 . 3 + < nl > + * iPhone / iPad 7 . 0 + < nl > + * Web < nl > + < nl > + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . < nl > + < nl > # Installation < nl > < nl > Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala 
 index be6db900 . . 1ae29aa 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / encryption / EncryptionExtension . scala 
 @ @ - 207 , 15 + 207 , 23 @ @ final class EncryptionExtension ( system : ActorSystem ) extends Extension { 
 actionT . value map ( _ . valueOr ( throw _ ) ) 
 } 
 
 - def checkBox ( box : ApiEncryptedBox ) : Future [ Either [ ( Vector [ ApiKeyGroupId ] , Vector [ ApiKeyGroupId ] ) , Map [ Int , Vector [ ( Int , ApiEncryptedBox ) ] ] ] ] = { 
 + def checkBox ( 
 + box : ApiEncryptedBox , 
 + ignoredKeyGroups : Map [ Int , Set [ Int ] ] 
 + ) : Future [ Either [ ( Vector [ ApiKeyGroupId ] , Vector [ ApiKeyGroupId ] ) , Map [ Int , Vector [ ( Int , ApiEncryptedBox ) ] ] ] ] = { 
 val userChecksFu : Iterable [ Future [ ( Seq [ ApiKeyGroupId ] , Seq [ ApiKeyGroupId ] , Seq [ EncryptionKeyGroup ] ) ] ] = 
 box . keys . groupBy ( _ . usersId ) map { 
 case ( userId , keys ) ⇒ 
 db . run ( EncryptionKeyGroupRepo . fetch ( userId ) ) map { kgs ⇒ 
 / / kgs not presented in box 
 + 
 + val ignored = ignoredKeyGroups . getOrElse ( userId , Set . empty ) 
 + 
 val missingKgs = kgs . view 
 . filterNot ( kg ⇒ keys . exists ( _ . keyGroupId = = kg . id ) ) 
 - . map ( kg ⇒ ApiKeyGroupId ( userId , kg . id ) ) . force 
 + . filterNot ( kg ⇒ ignored . contains ( kg . id ) ) 
 + . map ( kg ⇒ ApiKeyGroupId ( userId , kg . id ) ) 
 + . force 
 
 / / kgs presented in box but deleted by receiver 
 val obsKgs = keys . view 
 @ @ - 236 , 15 + 244 , 15 @ @ final class EncryptionExtension ( system : ActorSystem ) extends Extension { 
 if ( missing . nonEmpty | | obs . nonEmpty ) Left ( missing → obs ) 
 else Right ( 
 kgs 
 - . groupBy ( _ . userId ) 
 - . map { 
 - case ( userId , ukgs ) ⇒ 
 - ( userId , 
 - ukgs map { kg ⇒ 
 - val keys = box . keys . filter ( _ . keyGroupId = = kg . id ) 
 - ( kg . authSid . get . value , box . copy ( keys = keys ) ) 
 - } ) 
 - } . toMap 
 + . groupBy ( _ . userId ) 
 + . map { 
 + case ( userId , ukgs ) ⇒ 
 + ( userId , 
 + ukgs map { kg ⇒ 
 + val keys = box . keys . filter ( _ . keyGroupId = = kg . id ) 
 + ( kg . authSid . get . value , box . copy ( keys = keys ) ) 
 + } ) 
 + } 
 ) 
 } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala 
 index 2a6c396 . . 8d70874 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / encryption / EncryptionServiceImpl . scala 
 @ @ - 124 , 7 + 124 , 7 @ @ final class EncryptionServiceImpl ( implicit system : ActorSystem ) extends Encrypti 
 db . run { 
 withUserOutPeers ( destPeers ) { 
 DBIO . from { 
 - encExt . checkBox ( encryptedBox ) flatMap { 
 + encExt . checkBox ( encryptedBox , ignoredKeyGroups . groupBy ( _ . userId ) . mapValues ( _ . map ( _ . keyGroupId ) . toSet ) ) flatMap { 
 case Left ( ( missing , obs ) ) ⇒ 
 FastFuture . successful ( Ok ( ResponseSendEncryptedPackage ( 
 seq = None ,

NEAREST DIFF:
diff - - git a / README . MD b / README . MD 
 index 8c53a78 . . 061c271 100644 
 - - - a / README . MD 
 + + + b / README . MD 
 @ @ - 9 , 6 + 9 , 13 @ @ Actor Platform is good for improving enterprise communications , building a messa 
 
 This repository contains all source code of platform whereby you can start your server or / and build your iOS , Android , Web , or Desktop applications . 
 
 + # Currently available clients 
 + * Android 4 . 0 . 3 + 
 + * iPhone / iPad 7 . 0 + 
 + * Web 
 + 
 + It is very easy to [ implement your own ] ( http : / / actor . readme . io / docs / apps ) . 
 + 
 # Installation 
 
 Building mobile messaging application is a bit complex procedure and you need certain amount of preparations : have developer accounts in Google , Apple , have SSL certificates for your servers , integrate server with various services like SMS gate , push systems , etc . . .
