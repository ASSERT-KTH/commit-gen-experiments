BLEU SCORE: 0.18226810900726556

TEST MSG: fix ( server : groups , rpc ) : additional updates on join , invite , kick , leave ; fill group in group creation response
GENERATED MSG: fix ( server : groups ) : send self as a member in fat update on group creation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 38941dd . . a015494 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 84 , 8 + 84 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > randomId = cmd . randomId < nl > ) < nl > < nl > - val creatorUpdatesNew = refreshGroupUpdates ( newState ) < nl > - < nl > val serviceMessage = GroupServiceMessages . groupCreated < nl > < nl > / / TODO : remove deprecated < nl > @ @ - 126 , 11 + 124 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / new group api updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / send update about group info to group creator < nl > - _ ← FutureExt . ftraverse ( creatorUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . creatorUserId , update ) < nl > - } < nl > - < nl > / / send service message to group < nl > seqStateDate ← dialogExt . sendServerMessage ( < nl > apiGroupPeer , < nl > @ @ - 412 , 6 + 405 , 12 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) < nl > < nl > + val leftUserUpdatesNew = List ( < nl > + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > + ) < nl > + < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > < nl > val serviceMessage = GroupServiceMessages . userLeft < nl > @ @ - 459 , 11 + 458 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > deliveryTag = Some ( Optimization . GroupV2 ) < nl > ) < nl > < nl > - / / push empty group members list to left user < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . userId , < nl > - update = UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) < nl > - ) < nl > + / / push left user updates < nl > + / / • with empty group members < nl > + / / • that he can ' t view and invite members < nl > + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) < nl > + } < nl > + < nl > / / push left user that he is no longer a member < nl > SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . userId , < nl > @ @ - 492 , 7 + 493 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val kickedUserUpdatesNew : List [ Update ] = List ( < nl > UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > - UpdateGroupMemberChanged ( groupId , isMember = false ) < nl > + UpdateGroupMemberChanged ( groupId , isMember = false ) , < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) < nl > ) < nl > < nl > val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > @ @ - 546 , 6 + 549 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / push kicked user updates < nl > / / • with empty group members < nl > / / • that he is no longer a member of group < nl > + / / • that he can ' t view and invite members < nl > _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) < nl > } < nl > @ @ - 920 , 13 + 924 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / Updates that will be sent to user , when he enters group . < nl > / / Helps clients that have this group to refresh it ' s data . < nl > + / / TODO : review when chanels will be added < nl > private def refreshGroupUpdates ( newState : GroupState ) : List [ Update ] = List ( < nl > UpdateGroupMemberChanged ( groupId , isMember = true ) , < nl > UpdateGroupAboutChanged ( groupId , newState . about ) , < nl > UpdateGroupAvatarChanged ( groupId , newState . avatar ) , < nl > UpdateGroupTopicChanged ( groupId , newState . topic ) , < nl > UpdateGroupTitleChanged ( groupId , newState . title ) , < nl > - UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) < nl > + UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) , < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = true ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) < nl > / / UpdateGroupExtChanged ( groupId , newState . extension ) / / TODO : figure out and fix < nl > / / if ( bigGroup ) UpdateGroupMembersCountChanged ( groupId , newState . extension ) < nl > ) < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index a770be4 . . 8bff8e9 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 236 , 7 + 236 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > userIds = users . map ( _ . userId ) . toSet , < nl > typ < nl > ) < nl > - SeqStateDate ( seq , state , _ ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) < nl > + SeqStateDate ( seq , state , date ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) < nl > group ← groupExt . getApiStruct ( groupId , client . userId ) < nl > memberIds = GroupUtils . getUserIds ( group ) < nl > ( apiUsers , apiPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) < nl > @ @ - 245 , 7 + 245 , 8 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > state = state . toByteArray , < nl > group = group , < nl > users = apiUsers , < nl > - userPeers = apiPeers < nl > + userPeers = apiPeers , < nl > + date = date < nl > ) ) < nl > < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto < nl > index 64de736 . . 7dccc05 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / group . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / group . proto < nl > @ @ - 25 , 8 + 25 , 7 @ @ message GroupCommands { < nl > < nl > message CreateAck { < nl > required int64 access _ hash = 1 ; < nl > - required int32 seq = 2 ; < nl > - required bytes state = 3 ; < nl > + required SeqState seqstate = 2 ; < nl > required int64 date = 4 ; < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 81a977a . . 2099eac 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 37 , 82 + 37 , 74 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > import GroupEvents . _ < nl > < nl > protected def create ( groupId : Int , creatorUserId : Int , creatorAuthId : Long , title : String , randomId : Long , userIds : Set [ Int ] ) : Unit = { < nl > - val date = new DateTime < nl > - < nl > val rng = ThreadLocalRandom . current ( ) < nl > < nl > val accessHash = rng . nextLong ( ) < nl > - val botUserId = nextIntId ( rng ) < nl > - val botToken = accessToken ( rng ) < nl > - < nl > - val events = Vector ( < nl > - TSEvent ( now ( ) , GroupEvents . Created ( groupId , creatorUserId , accessHash , title ) ) , < nl > - TSEvent ( now ( ) , GroupEvents . BotAdded ( botUserId , botToken ) ) < nl > - ) < nl > < nl > userIds . filterNot ( _ = = creatorUserId ) foreach { userId ⇒ < nl > val randomId = rng . nextLong ( ) < nl > context . parent ! Invite ( groupId , userId , creatorUserId , creatorAuthId , randomId ) < nl > } < nl > < nl > - var stateMaybe : Option [ Group ] = None < nl > - < nl > - persist [ GeneratedMessage ] ( events ) { < nl > - case TSEvent ( ts , evt : GroupEvents . Created ) ⇒ < nl > - val group = initState ( ts , evt ) < nl > + val date = now ( ) < nl > + < nl > + val created = GroupEvents . Created ( groupId , creatorUserId , accessHash , title ) < nl > + val state = initState ( date , created ) < nl > + < nl > + persist ( TSEvent ( date , created ) ) { _ ⇒ < nl > + context become working ( state ) < nl > + < nl > + val serviceMessage = GroupServiceMessages . groupCreated < nl > + < nl > + val update = UpdateGroupInvite ( groupId = groupId , inviteUserId = creatorUserId , date = date . getMillis , randomId = randomId ) < nl > + < nl > + db . run ( < nl > + for { < nl > + _ ← p . Group . create ( < nl > + models . Group ( < nl > + id = groupId , < nl > + creatorUserId = state . creatorUserId , < nl > + accessHash = state . accessHash , < nl > + title = state . title , < nl > + isPublic = state . isPublic , < nl > + createdAt = state . createdAt , < nl > + about = None , < nl > + topic = None < nl > + ) , < nl > + randomId < nl > + ) < nl > + _ ← p . GroupUser . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > + _ ← HistoryUtils . writeHistoryMessage ( < nl > + models . Peer . privat ( creatorUserId ) , < nl > + models . Peer . group ( state . id ) , < nl > + date , < nl > + randomId , < nl > + serviceMessage . header , < nl > + serviceMessage . toByteArray < nl > + ) < nl > + seqstate ← if ( isBot ( state , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) < nl > + else DBIO . from ( UserOffice . broadcastClientUpdate ( creatorUserId , creatorAuthId , update , pushText = None , isFat = true , deliveryId = Some ( s " creategroup _ $ { randomId } " ) ) ) < nl > + } yield CreateAck ( state . accessHash , seqstate , date . getMillis ) < nl > + ) pipeTo sender ( ) onFailure { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to create a group " ) < nl > + } < nl > + } < nl > < nl > - stateMaybe = Some ( group ) < nl > + val botUserId = nextIntId ( rng ) < nl > + val botToken = accessToken ( rng ) < nl > + val botAdded = GroupEvents . BotAdded ( botUserId , botToken ) < nl > < nl > - val serviceMessage = GroupServiceMessages . groupCreated < nl > + persist ( TSEvent ( now ( ) , botAdded ) ) { tsEvt ⇒ < nl > + context become working ( updatedState ( tsEvt , state ) ) < nl > < nl > - val update = UpdateGroupInvite ( groupId = groupId , inviteUserId = creatorUserId , date = date . getMillis , randomId = randomId ) < nl > + val rng = ThreadLocalRandom . current ( ) < nl > < nl > - db . run ( < nl > - for { < nl > - _ ← p . Group . create ( < nl > - models . Group ( < nl > - id = groupId , < nl > - creatorUserId = group . creatorUserId , < nl > - accessHash = group . accessHash , < nl > - title = group . title , < nl > - isPublic = group . isPublic , < nl > - createdAt = group . createdAt , < nl > - about = None , < nl > - topic = None < nl > - ) , < nl > - randomId < nl > - ) < nl > - _ ← p . GroupUser . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) < nl > - _ ← HistoryUtils . writeHistoryMessage ( < nl > - models . Peer . privat ( creatorUserId ) , < nl > - models . Peer . group ( group . id ) , < nl > - date , < nl > - randomId , < nl > - serviceMessage . header , < nl > - serviceMessage . toByteArray < nl > - ) < nl > - SeqState ( seq , state ) ← if ( isBot ( group , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) < nl > - else DBIO . from ( UserOffice . broadcastClientUpdate ( creatorUserId , creatorAuthId , update , pushText = None , isFat = true , deliveryId = Some ( s " creategroup _ $ { randomId } " ) ) ) < nl > - } yield CreateAck ( group . accessHash , seq , state , date . getMillis ) < nl > - ) pipeTo sender ( ) onFailure { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to create a group " ) < nl > - } < nl > - < nl > - case evt @ TSEvent ( _ , GroupEvents . BotAdded ( userId , token ) ) ⇒ < nl > - stateMaybe = stateMaybe map { state ⇒ < nl > - val newState = updatedState ( evt , state ) < nl > - context become working ( newState ) < nl > - newState < nl > + UserOffice . create ( botUserId , nextAccessSalt ( rng ) , " Bot " , " US " , Sex . Unknown , isBot = true ) < nl > + . flatMap ( _ ⇒ db . run ( p . GroupBot . create ( groupId , botUserId , botToken ) ) ) onFailure { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to create group bot " ) < nl > } < nl > - < nl > - val rng = ThreadLocalRandom . current ( ) < nl > - < nl > - UserOffice . create ( userId , nextAccessSalt ( rng ) , " Bot " , " US " , Sex . Unknown , isBot = true ) < nl > - . flatMap ( _ ⇒ db . run ( p . GroupBot . create ( groupId , userId , token ) ) ) onFailure { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to create group bot " ) < nl > - } < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index 96c1d94 . . 70cea0c 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 132 , 8 + 132 , 8 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( < nl > val f = for ( res ← GroupOffice . create ( groupId , title , randomId , userIds ) ) yield { < nl > Ok ( ResponseCreateGroup ( < nl > groupPeer = GroupOutPeer ( groupId , res . accessHash ) , < nl > - seq = res . seq , < nl > - state = res . state . toByteArray , < nl > + seq = res . seqstate . seq , < nl > + state = res . seqstate . state . toByteArray , < nl > users = groupUserIds . toVector , < nl > date = res . date < nl > ) )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 38941dd . . a015494 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 84 , 8 + 84 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 randomId = cmd . randomId 
 ) 
 
 - val creatorUpdatesNew = refreshGroupUpdates ( newState ) 
 - 
 val serviceMessage = GroupServiceMessages . groupCreated 
 
 / / TODO : remove deprecated 
 @ @ - 126 , 11 + 124 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / new group api updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / send update about group info to group creator 
 - _ ← FutureExt . ftraverse ( creatorUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . creatorUserId , update ) 
 - } 
 - 
 / / send service message to group 
 seqStateDate ← dialogExt . sendServerMessage ( 
 apiGroupPeer , 
 @ @ - 412 , 6 + 405 , 12 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val updateObsolete = UpdateGroupUserLeaveObsolete ( groupId , cmd . userId , dateMillis , cmd . randomId ) 
 
 + val leftUserUpdatesNew = List ( 
 + UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 + ) 
 + 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 
 val serviceMessage = GroupServiceMessages . userLeft 
 @ @ - 459 , 11 + 458 , 13 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 deliveryTag = Some ( Optimization . GroupV2 ) 
 ) 
 
 - / / push empty group members list to left user 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . userId , 
 - update = UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) 
 - ) 
 + / / push left user updates 
 + / / • with empty group members 
 + / / • that he can ' t view and invite members 
 + _ ← FutureExt . ftraverse ( leftUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . userId , update ) 
 + } 
 + 
 / / push left user that he is no longer a member 
 SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . userId , 
 @ @ - 492 , 7 + 493 , 9 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val kickedUserUpdatesNew : List [ Update ] = List ( 
 UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 - UpdateGroupMemberChanged ( groupId , isMember = false ) 
 + UpdateGroupMemberChanged ( groupId , isMember = false ) , 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = false ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = false ) 
 ) 
 
 val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 @ @ - 546 , 6 + 549 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / push kicked user updates 
 / / • with empty group members 
 / / • that he is no longer a member of group 
 + / / • that he can ' t view and invite members 
 _ ← FutureExt . ftraverse ( kickedUserUpdatesNew ) { update ⇒ 
 seqUpdExt . deliverUserUpdate ( userId = cmd . kickedUserId , update ) 
 } 
 @ @ - 920 , 13 + 924 , 16 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / Updates that will be sent to user , when he enters group . 
 / / Helps clients that have this group to refresh it ' s data . 
 + / / TODO : review when chanels will be added 
 private def refreshGroupUpdates ( newState : GroupState ) : List [ Update ] = List ( 
 UpdateGroupMemberChanged ( groupId , isMember = true ) , 
 UpdateGroupAboutChanged ( groupId , newState . about ) , 
 UpdateGroupAvatarChanged ( groupId , newState . avatar ) , 
 UpdateGroupTopicChanged ( groupId , newState . topic ) , 
 UpdateGroupTitleChanged ( groupId , newState . title ) , 
 - UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) 
 + UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) , 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = true ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) 
 / / UpdateGroupExtChanged ( groupId , newState . extension ) / / TODO : figure out and fix 
 / / if ( bigGroup ) UpdateGroupMembersCountChanged ( groupId , newState . extension ) 
 ) 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index a770be4 . . 8bff8e9 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 236 , 7 + 236 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 userIds = users . map ( _ . userId ) . toSet , 
 typ 
 ) 
 - SeqStateDate ( seq , state , _ ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) 
 + SeqStateDate ( seq , state , date ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) 
 group ← groupExt . getApiStruct ( groupId , client . userId ) 
 memberIds = GroupUtils . getUserIds ( group ) 
 ( apiUsers , apiPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) 
 @ @ - 245 , 7 + 245 , 8 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 state = state . toByteArray , 
 group = group , 
 users = apiUsers , 
 - userPeers = apiPeers 
 + userPeers = apiPeers , 
 + date = date 
 ) ) 
 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / group . proto b / actor - server / actor - core / src / main / protobuf / group . proto 
 index 64de736 . . 7dccc05 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / group . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / group . proto 
 @ @ - 25 , 8 + 25 , 7 @ @ message GroupCommands { 
 
 message CreateAck { 
 required int64 access _ hash = 1 ; 
 - required int32 seq = 2 ; 
 - required bytes state = 3 ; 
 + required SeqState seqstate = 2 ; 
 required int64 date = 4 ; 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 81a977a . . 2099eac 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 37 , 82 + 37 , 74 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 import GroupEvents . _ 
 
 protected def create ( groupId : Int , creatorUserId : Int , creatorAuthId : Long , title : String , randomId : Long , userIds : Set [ Int ] ) : Unit = { 
 - val date = new DateTime 
 - 
 val rng = ThreadLocalRandom . current ( ) 
 
 val accessHash = rng . nextLong ( ) 
 - val botUserId = nextIntId ( rng ) 
 - val botToken = accessToken ( rng ) 
 - 
 - val events = Vector ( 
 - TSEvent ( now ( ) , GroupEvents . Created ( groupId , creatorUserId , accessHash , title ) ) , 
 - TSEvent ( now ( ) , GroupEvents . BotAdded ( botUserId , botToken ) ) 
 - ) 
 
 userIds . filterNot ( _ = = creatorUserId ) foreach { userId ⇒ 
 val randomId = rng . nextLong ( ) 
 context . parent ! Invite ( groupId , userId , creatorUserId , creatorAuthId , randomId ) 
 } 
 
 - var stateMaybe : Option [ Group ] = None 
 - 
 - persist [ GeneratedMessage ] ( events ) { 
 - case TSEvent ( ts , evt : GroupEvents . Created ) ⇒ 
 - val group = initState ( ts , evt ) 
 + val date = now ( ) 
 + 
 + val created = GroupEvents . Created ( groupId , creatorUserId , accessHash , title ) 
 + val state = initState ( date , created ) 
 + 
 + persist ( TSEvent ( date , created ) ) { _ ⇒ 
 + context become working ( state ) 
 + 
 + val serviceMessage = GroupServiceMessages . groupCreated 
 + 
 + val update = UpdateGroupInvite ( groupId = groupId , inviteUserId = creatorUserId , date = date . getMillis , randomId = randomId ) 
 + 
 + db . run ( 
 + for { 
 + _ ← p . Group . create ( 
 + models . Group ( 
 + id = groupId , 
 + creatorUserId = state . creatorUserId , 
 + accessHash = state . accessHash , 
 + title = state . title , 
 + isPublic = state . isPublic , 
 + createdAt = state . createdAt , 
 + about = None , 
 + topic = None 
 + ) , 
 + randomId 
 + ) 
 + _ ← p . GroupUser . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 + _ ← HistoryUtils . writeHistoryMessage ( 
 + models . Peer . privat ( creatorUserId ) , 
 + models . Peer . group ( state . id ) , 
 + date , 
 + randomId , 
 + serviceMessage . header , 
 + serviceMessage . toByteArray 
 + ) 
 + seqstate ← if ( isBot ( state , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) 
 + else DBIO . from ( UserOffice . broadcastClientUpdate ( creatorUserId , creatorAuthId , update , pushText = None , isFat = true , deliveryId = Some ( s " creategroup _ $ { randomId } " ) ) ) 
 + } yield CreateAck ( state . accessHash , seqstate , date . getMillis ) 
 + ) pipeTo sender ( ) onFailure { 
 + case e ⇒ 
 + log . error ( e , " Failed to create a group " ) 
 + } 
 + } 
 
 - stateMaybe = Some ( group ) 
 + val botUserId = nextIntId ( rng ) 
 + val botToken = accessToken ( rng ) 
 + val botAdded = GroupEvents . BotAdded ( botUserId , botToken ) 
 
 - val serviceMessage = GroupServiceMessages . groupCreated 
 + persist ( TSEvent ( now ( ) , botAdded ) ) { tsEvt ⇒ 
 + context become working ( updatedState ( tsEvt , state ) ) 
 
 - val update = UpdateGroupInvite ( groupId = groupId , inviteUserId = creatorUserId , date = date . getMillis , randomId = randomId ) 
 + val rng = ThreadLocalRandom . current ( ) 
 
 - db . run ( 
 - for { 
 - _ ← p . Group . create ( 
 - models . Group ( 
 - id = groupId , 
 - creatorUserId = group . creatorUserId , 
 - accessHash = group . accessHash , 
 - title = group . title , 
 - isPublic = group . isPublic , 
 - createdAt = group . createdAt , 
 - about = None , 
 - topic = None 
 - ) , 
 - randomId 
 - ) 
 - _ ← p . GroupUser . create ( groupId , creatorUserId , creatorUserId , date , None , isAdmin = true ) 
 - _ ← HistoryUtils . writeHistoryMessage ( 
 - models . Peer . privat ( creatorUserId ) , 
 - models . Peer . group ( group . id ) , 
 - date , 
 - randomId , 
 - serviceMessage . header , 
 - serviceMessage . toByteArray 
 - ) 
 - SeqState ( seq , state ) ← if ( isBot ( group , creatorUserId ) ) DBIO . successful ( SeqState ( 0 , ByteString . EMPTY ) ) 
 - else DBIO . from ( UserOffice . broadcastClientUpdate ( creatorUserId , creatorAuthId , update , pushText = None , isFat = true , deliveryId = Some ( s " creategroup _ $ { randomId } " ) ) ) 
 - } yield CreateAck ( group . accessHash , seq , state , date . getMillis ) 
 - ) pipeTo sender ( ) onFailure { 
 - case e ⇒ 
 - log . error ( e , " Failed to create a group " ) 
 - } 
 - 
 - case evt @ TSEvent ( _ , GroupEvents . BotAdded ( userId , token ) ) ⇒ 
 - stateMaybe = stateMaybe map { state ⇒ 
 - val newState = updatedState ( evt , state ) 
 - context become working ( newState ) 
 - newState 
 + UserOffice . create ( botUserId , nextAccessSalt ( rng ) , " Bot " , " US " , Sex . Unknown , isBot = true ) 
 + . flatMap ( _ ⇒ db . run ( p . GroupBot . create ( groupId , botUserId , botToken ) ) ) onFailure { 
 + case e ⇒ 
 + log . error ( e , " Failed to create group bot " ) 
 } 
 - 
 - val rng = ThreadLocalRandom . current ( ) 
 - 
 - UserOffice . create ( userId , nextAccessSalt ( rng ) , " Bot " , " US " , Sex . Unknown , isBot = true ) 
 - . flatMap ( _ ⇒ db . run ( p . GroupBot . create ( groupId , userId , token ) ) ) onFailure { 
 - case e ⇒ 
 - log . error ( e , " Failed to create group bot " ) 
 - } 
 } 
 } 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index 96c1d94 . . 70cea0c 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 132 , 8 + 132 , 8 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( 
 val f = for ( res ← GroupOffice . create ( groupId , title , randomId , userIds ) ) yield { 
 Ok ( ResponseCreateGroup ( 
 groupPeer = GroupOutPeer ( groupId , res . accessHash ) , 
 - seq = res . seq , 
 - state = res . state . toByteArray , 
 + seq = res . seqstate . seq , 
 + state = res . seqstate . state . toByteArray , 
 users = groupUserIds . toVector , 
 date = res . date 
 ) )
