BLEU SCORE: 0.12779458309114783

TEST MSG: chore ( server : cli ) : keygen
GENERATED MSG: fix ( server : sequence ) : user sequence migration fixes , cli migration

TEST DIFF (one line): diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > index 684761e . . dc8ffe2 100644 < nl > - - - a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > @ @ - 17 , 13 + 17 , 16 @ @ private case class Config ( < nl > command : String = " help " , < nl > createBot : CreateBot = CreateBot ( ) , < nl > updateIsAdmin : UpdateIsAdmin = UpdateIsAdmin ( ) , < nl > - httpApiTokenCreate : HttpApiTokenCreate = HttpApiTokenCreate ( ) < nl > + httpApiTokenCreate : HttpApiTokenCreate = HttpApiTokenCreate ( ) , < nl > + key : Key = Key ( ) < nl > ) < nl > < nl > private [ cli ] trait Request { < nl > type Response < nl > } < nl > < nl > + private [ cli ] case class Key ( create : Boolean = true , path : String = " actor - key " ) < nl > + < nl > private [ cli ] case class CreateBot ( < nl > username : String = " " , < nl > name : String = " " , < nl > @ @ - 56 , 6 + 59 , 7 @ @ private object Commands { < nl > val AdminRevoke = " admin - revoke " < nl > val MigrateUserSequence = " migrate - user - sequence " < nl > val HttpApiTokenCreate = " http - api - token - create " < nl > + val Key = " key " < nl > } < nl > < nl > object ActorCli extends App { < nl > @ @ - 100 , 11 + 104 , 22 @ @ object ActorCli extends App { < nl > c . copy ( httpApiTokenCreate = c . httpApiTokenCreate . copy ( isAdmin = true ) ) < nl > } < nl > ) < nl > + cmd ( Commands . Key ) action { ( _ , c ) ⇒ < nl > + c . copy ( command = Commands . Key ) < nl > + } children ( < nl > + opt [ Unit ] ( " create " ) abbr " c " required ( ) action { ( x , c ) ⇒ < nl > + c . copy ( key = c . key . copy ( create = true ) ) < nl > + } , < nl > + opt [ String ] ( " out " ) abbr " o " optional ( ) action { ( x , c ) ⇒ < nl > + c . copy ( key = c . key . copy ( path = x ) ) < nl > + } < nl > + ) < nl > } < nl > < nl > parser . parse ( args , Config ( ) ) foreach { config ⇒ < nl > val handlers = new CliHandlers < nl > val migrationHandlers = new MigrationHandlers < nl > + val securityHandlers = new SecurityHandlers < nl > < nl > config . command match { < nl > case Commands . Help ⇒ < nl > @ @ - 115 , 6 + 130 , 8 @ @ object ActorCli extends App { < nl > cmd ( handlers . updateIsAdmin ( config . updateIsAdmin ) ) < nl > case Commands . MigrateUserSequence ⇒ < nl > cmd ( migrationHandlers . userSequence ( ) , 2 . hours ) < nl > + case Commands . Key ⇒ < nl > + cmd ( securityHandlers . createKey ( config . key . path ) ) < nl > } < nl > < nl > def cmd ( f : Future [ Unit ] , timeout : Duration = 10 . seconds ) : Unit = { < nl > diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala < nl > new file mode 100644 < nl > index 0000000 . . c1931c6 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala < nl > @ @ - 0 , 0 + 1 , 58 @ @ < nl > + package im . actor . server . cli < nl > + < nl > + import java . security . SecureRandom < nl > + < nl > + import better . files . _ < nl > + import im . actor . crypto . Curve25519 < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + final class SecurityHandlers { < nl > + private val random = new SecureRandom ( ) < nl > + < nl > + def createKey ( path : String ) : Future [ Unit ] = { < nl > + val pubPath = path + " . pub " < nl > + val privatePath = path + " . private " < nl > + < nl > + val pubFile = File ( pubPath ) < nl > + val privateFile = File ( privatePath ) < nl > + < nl > + if ( pubFile . exists ) { < nl > + println ( s " File $ pubPath already exists ! " ) < nl > + Future . successful ( ( ) ) < nl > + } else if ( privateFile . exists ) { < nl > + println ( s " File $ privatePath already exists ! " ) < nl > + Future . successful ( ( ) ) < nl > + } else { < nl > + val randomBytes = new Array [ Byte ] ( 32 ) < nl > + random . nextBytes ( randomBytes ) < nl > + < nl > + val pair = Curve25519 . keyGen ( randomBytes ) < nl > + pubFile . write ( pair . getPublicKey ) < nl > + privateFile . write ( pair . getPrivateKey ) < nl > + < nl > + println ( < nl > + s " " " < nl > + | Created $ pubFile and $ privateFile < nl > + | You need to add the following to your server . conf : < nl > + | < nl > + | < nl > + | modules : { < nl > + | # . . . other modules < nl > + | security { < nl > + | # . . . other settings < nl > + | server - keys : [ < nl > + | # . . . other server keys < nl > + | { < nl > + | public : " $ pubPath " < nl > + | private : " $ privatePath " < nl > + | } < nl > + | ] < nl > + | } < nl > + | } < nl > + | " " " . stripMargin < nl > + ) < nl > + Future . successful ( ( ) ) < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 6ad163a . . cd23d73 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 161 , 7 + 161 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > mainClass in Compile : = Some ( " im . actor . server . cli . ActorCliApp " ) < nl > ) < nl > ) < nl > - . dependsOn ( actorCore ) < nl > + . dependsOn ( actorCore , actorFrontend ) < nl > < nl > lazy val actorCore = Project ( < nl > id = " actor - core " ,
NEAREST DIFF (one line): diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > index b6a4655 . . 0ab73c9 100644 < nl > - - - a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala < nl > @ @ - 49 , 6 + 49 , 7 @ @ private object Commands { < nl > val CreateBot = " create - bot " < nl > val AdminGrant = " admin - grant " < nl > val AdminRevoke = " admin - revoke " < nl > + val MigrateUserSequence = " migrate - user - sequence " < nl > } < nl > < nl > object ActorCli extends App { < nl > @ @ - 83 , 23 + 84 , 29 @ @ object ActorCli extends App { < nl > c . copy ( updateIsAdmin = UpdateIsAdmin ( x , isAdmin = false ) ) < nl > } < nl > ) < nl > + cmd ( Commands . MigrateUserSequence ) action { ( _ , c ) ⇒ < nl > + c . copy ( command = Commands . MigrateUserSequence ) < nl > + } < nl > } < nl > < nl > parser . parse ( args , Config ( ) ) foreach { config ⇒ < nl > val handlers = new CliHandlers < nl > + val migrationHandlers = new MigrationHandlers < nl > < nl > - cmd ( config . command match { < nl > + config . command match { < nl > case Commands . Help ⇒ < nl > - Future . successful ( parser . showUsage ) < nl > + cmd ( Future . successful ( parser . showUsage ) ) < nl > case Commands . CreateBot ⇒ < nl > - handlers . createBot ( config . createBot ) < nl > + cmd ( handlers . createBot ( config . createBot ) ) < nl > case Commands . AdminGrant | Commands . AdminRevoke ⇒ < nl > - handlers . updateIsAdmin ( config . updateIsAdmin ) < nl > - } ) < nl > + cmd ( handlers . updateIsAdmin ( config . updateIsAdmin ) ) < nl > + case Commands . MigrateUserSequence ⇒ < nl > + cmd ( migrationHandlers . userSequence ( ) , 2 . hours ) < nl > + } < nl > < nl > - def cmd ( f : Future [ Unit ] ) : Unit = { < nl > + def cmd ( f : Future [ Unit ] , timeout : Duration = 10 . seconds ) : Unit = { < nl > try { < nl > - Await . result ( f , 10 . seconds ) < nl > + Await . result ( f , timeout ) < nl > } finally { < nl > handlers . shutdown ( ) < nl > } < nl > diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala < nl > new file mode 100644 < nl > index 0000000 . . f68b0b3 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala < nl > @ @ - 0 , 0 + 1 , 39 @ @ < nl > + package im . actor . server . cli < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . stream . ActorMaterializer < nl > + import com . typesafe . config . ConfigFactory < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . server . db . DbExtension < nl > + import sql . migration . V20151108011300 _ _ FillUserSequence < nl > + < nl > + import scala . concurrent . _ < nl > + < nl > + final class MigrationHandlers { < nl > + def userSequence ( ) : Future [ Unit ] = { < nl > + val config = ActorConfig . load ( ConfigFactory . parseString ( < nl > + " " " < nl > + | akka { < nl > + | cluster . seed - nodes = [ ] < nl > + | remote { < nl > + | netty . tcp . hostname = " 127 . 0 . 0 . 1 " < nl > + | netty . tcp . port = 0 < nl > + | } < nl > + | } < nl > + " " " . stripMargin < nl > + ) ) < nl > + < nl > + implicit val system = ActorSystem ( " migrator " , config ) < nl > + implicit val ec = system . dispatcher < nl > + implicit val db = DbExtension ( system ) < nl > + implicit val mat = ActorMaterializer ( ) < nl > + < nl > + val migration = new V20151108011300 _ _ FillUserSequence < nl > + < nl > + Future { < nl > + blocking { < nl > + migration . migrate ( ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala < nl > index 5a43e95 . . cecb9f7 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . server . migrations < nl > < nl > import akka . actor . ActorSystem < nl > + import akka . stream . ActorMaterializer < nl > import slick . driver . PostgresDriver < nl > import sql . migration . V20151108011300 _ _ FillUserSequence < nl > < nl > @ @ - 13 , 7 + 14 , 8 @ @ object FillUserSequenceMigrator extends Migration { < nl > override protected def migrationTimeout : Duration = 1 . hour < nl > < nl > override protected def startMigration ( ) ( implicit system : ActorSystem , db : PostgresDriver . api . Database , ec : ExecutionContext ) : Future [ Unit ] = { < nl > - val migration = new V20151108011300 _ _ FillUserSequence ( system ) < nl > + implicit val mat = ActorMaterializer ( ) < nl > + val migration = new V20151108011300 _ _ FillUserSequence < nl > Future ( migration . migrate ( ) ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala b / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala < nl > index e7b15e7 . . 0ff981b 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala < nl > @ @ - 1 , 9 + 1 , 10 @ @ < nl > package sql . migration < nl > < nl > - import java . sql . SQLException < nl > import java . util . concurrent . { LinkedBlockingQueue , TimeUnit , ThreadPoolExecutor } < nl > < nl > import akka . actor . ActorSystem < nl > + import akka . stream . Materializer < nl > + import akka . stream . scaladsl . _ < nl > import com . google . protobuf . ByteString < nl > import com . typesafe . scalalogging . Logger < nl > import im . actor . server . db . DbExtension < nl > @ @ - 13 , 11 + 14 , 9 @ @ import org . slf4j . LoggerFactory < nl > import slick . driver . PostgresDriver . api . _ < nl > import slick . jdbc . { GetResult , SetParameter } < nl > < nl > - import scala . annotation . tailrec < nl > import scala . concurrent . { ExecutionContext , Future , Await } < nl > import scala . concurrent . duration . _ < nl > import scala . language . postfixOps < nl > - import scala . util . { Failure , Success } < nl > < nl > object V20151108011300 _ _ FillUserSequence { < nl > final case class Obsolete ( authId : Long , timestamp : Long , seq : Int , header : Int , data : Array [ Byte ] , userIds : String , groupIds : String ) < nl > @ @ - 47 , 36 + 46 , 41 @ @ object V20151108011300 _ _ FillUserSequence { < nl > groupIds = r . nextString ( ) < nl > ) ) < nl > val BulkSize = 300 < nl > + val Parallelism = 4 < nl > } < nl > < nl > - final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { < nl > + final class V20151108011300 _ _ FillUserSequence ( implicit system : ActorSystem , materializer : Materializer ) { < nl > import V20151108011300 _ _ FillUserSequence . _ < nl > < nl > private val queue = new LinkedBlockingQueue [ Runnable ] ( ) < nl > - private val executor = new ThreadPoolExecutor ( 100 , 100 , 1 , TimeUnit . HOURS , queue ) < nl > + private val executor = new ThreadPoolExecutor ( 10 , 10 , 1 , TimeUnit . HOURS , queue ) < nl > private implicit val ec = ExecutionContext . fromExecutor ( executor ) < nl > private val log = Logger ( LoggerFactory . getLogger ( getClass ) ) < nl > private val db = DbExtension ( system ) . db < nl > < nl > - / / implicit val get = ( GetResult . createGetTuple5 [ Long , Int , Blob , String , String ] _ ) < nl > - / / implicit val getObsolete = < nl > - / / GetResult . createGetTuple5 [ Long , Int , Blob , String , String ] < nl > - < nl > def migrate ( ) : Unit = { < nl > try { < nl > log . warn ( " Starting filling user sequence " ) < nl > - Await . result ( db . run ( { < nl > - for { < nl > - userIds ← UserRepo . allIds < nl > - groupedUserIds = userIds . grouped ( 50 ) < nl > - _ = log . warn ( s " Found users : $ { userIds } " ) < nl > - affected ← DBIO . from ( Future . traverse ( groupedUserIds ) { ids ⇒ < nl > - Future . sequence ( ids map ( id ⇒ db . run ( migrateUser ( id ) ) ) ) map ( _ . sum ) < nl > - } ) map ( _ . sum ) < nl > - } yield { < nl > - log . warn ( s " $ { affected } updates moved " ) < nl > - } < nl > - } . transactionally ) , 2 . hours ) < nl > + val count = < nl > + Await . result ( { < nl > + Source ( db . stream ( UserRepo . allIds ) ) < nl > + . mapAsync ( Parallelism ) { userId ⇒ < nl > + db . run ( for { < nl > + authIds ← AuthIdRepo . findIdByUserId ( userId ) < nl > + _ = log . warn ( s " Found $ { authIds . length } authIds for $ { userId } " ) < nl > + oldestOpt ← maxSeq ( authIds ) < nl > + } yield ( userId , oldestOpt ) ) < nl > + } . collect { < nl > + case ( userId , Some ( authId ) ) ⇒ ( userId , authId ) < nl > + } < nl > + . mapAsync ( Parallelism ) { < nl > + case ( userId , authId ) ⇒ < nl > + move ( userId , authId ) < nl > + } < nl > + . runFold ( 0 ) ( _ + _ ) < nl > + } , 2 . hours ) < nl > + < nl > + log . warn ( s " Migration complete ! Moved $ { count } updates " ) < nl > } catch { < nl > case e : Exception ⇒ < nl > log . error ( " Failed to migrate " , e ) < nl > @ @ - 84 , 24 + 88 , 43 @ @ final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { < nl > } < nl > } < nl > < nl > - private def migrateUser ( userId : Int ) : DBIO [ Int ] = { < nl > - log . warn ( s " Moving user : $ { userId } " ) < nl > - ( for { < nl > - authIds ← AuthIdRepo . findIdByUserId ( userId ) < nl > - _ = log . warn ( s " Found $ { authIds . length } authIds " ) < nl > - oldestOpt ← maxSeq ( authIds ) < nl > - copied ← oldestOpt map ( fill ( userId ) _ ) getOrElse DBIO . successful ( 0 ) < nl > - } yield { < nl > - log . warn ( s " Copied $ copied updates " ) < nl > - copied < nl > - } ) . asTry map { < nl > - case Success ( res ) ⇒ res < nl > - case Failure ( err : SQLException ) ⇒ < nl > - log . error ( " Failed to move user " , err . getNextException ) < nl > - throw err < nl > - case Failure ( err ) ⇒ < nl > - log . error ( " Failed to move user " , err ) < nl > - throw err < nl > + private def move ( userId : Int , authId : Long ) : Future [ Int ] = { < nl > + log . warn ( s " Moving user $ userId " ) < nl > + < nl > + db . run ( sql " " " SELECT seq FROM user _ sequence WHERE user _ id = $ userId ORDER BY seq DESC LIMIT 1 " " " . as [ Int ] ) . map ( _ . headOption . getOrElse ( 0 ) ) flatMap { startFrom ⇒ < nl > + < nl > + Source ( < nl > + db . stream ( sql " " " SELECT auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str FROM seq _ updates _ ngen WHERE auth _ id = $ authId and seq > $ startFrom " " " < nl > + . as [ Obsolete ] ) < nl > + ) < nl > + . grouped ( BulkSize ) < nl > + . mapAsync ( Parallelism ) { bulk ⇒ < nl > + val news = bulk map { < nl > + case Obsolete ( _ , timestamp , seq , header , data , userIds , groupIds ) ⇒ < nl > + New ( < nl > + userId = userId , < nl > + seq = seq , < nl > + timestamp = timestamp , < nl > + mapping = UpdateMapping ( < nl > + default = Some ( SerializedUpdate ( < nl > + header = header , < nl > + body = ByteString . copyFrom ( data ) , < nl > + userIds = userIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq , < nl > + groupIds = groupIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq < nl > + ) ) < nl > + ) . toByteArray < nl > + ) < nl > + } < nl > + < nl > + val action = newTable + + = news < nl > + < nl > + db . run ( action ) map ( _ . getOrElse ( 0 ) ) < nl > + } < nl > + . runFold ( 0 ) ( _ + _ ) < nl > + . map { count ⇒ < nl > + log . warn ( s " Moved $ { count } updates for user $ { userId } " ) < nl > + count < nl > + } < nl > } < nl > } < nl > < nl > @ @ - 113 , 44 + 136 , 5 @ @ final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { < nl > } yield Some ( seqs maxBy ( _ . _ 2 getOrElse 0 ) _ 1 ) < nl > } < nl > < nl > - private def fill ( userId : Int ) ( oldestAuthId : Long ) : DBIO [ Int ] = { < nl > - for { < nl > - obsoletes ← sql " " " SELECT auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str FROM seq _ updates _ ngen WHERE auth _ id = $ oldestAuthId " " " < nl > - . as [ Obsolete ] < nl > - affected ← move ( userId , obsoletes ) < nl > - } yield affected < nl > - } < nl > - < nl > - private def move ( userId : Int , obsoletes : Vector [ Obsolete ] ) : DBIO [ Int ] = { < nl > - DBIO . sequence ( bulks ( obsoletes , Vector . empty ) map { bulkObs ⇒ < nl > - val news = bulkObs . par map { < nl > - case Obsolete ( _ , timestamp , seq , header , data , userIds , groupIds ) ⇒ < nl > - New ( < nl > - userId = userId , < nl > - seq = seq , < nl > - timestamp = timestamp , < nl > - mapping = UpdateMapping ( < nl > - default = Some ( SerializedUpdate ( < nl > - header = header , < nl > - body = ByteString . copyFrom ( data ) , < nl > - userIds = userIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq , < nl > - groupIds = groupIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq < nl > - ) ) < nl > - ) . toByteArray < nl > - ) < nl > - } < nl > - < nl > - newTable + + = news . toVector < nl > - } ) map ( _ ⇒ obsoletes . length ) < nl > - } < nl > - < nl > - @ tailrec < nl > - private def bulks ( obsoletes : Vector [ Obsolete ] , result : Vector [ Vector [ Obsolete ] ] ) : Vector [ Vector [ Obsolete ] ] = { < nl > - obsoletes . splitAt ( BulkSize ) match { < nl > - case ( bulk , Vector ( ) ) ⇒ result : + bulk < nl > - case ( bulk , tail ) ⇒ bulks ( tail , result : + bulk ) < nl > - } < nl > - } < nl > - < nl > private def getSeq ( authId : Long ) = sql " " " SELECT seq FROM seq _ updates _ ngen WHERE auth _ id = $ authId ORDER BY timestamp DESC LIMIT 1 " " " . as [ Int ] . headOption < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index a2167f0 . . 14c35dd 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 13 , 14 + 13 , 14 @ @ import com . typesafe . config . { ConfigException , Config , ConfigFactory } < nl > import scala . util . { Failure , Success , Try } < nl > < nl > object ActorConfig { < nl > - def load ( ) : Config = { < nl > + def load ( defaults : Config = ConfigFactory . empty ( ) ) : Config = { < nl > val mainConfig = Option ( System . getProperty ( " actor . home " ) ) match { < nl > case Some ( home ) ⇒ < nl > ConfigFactory . load ( ConfigFactory . parseFile ( new File ( s " $ home / conf / server . conf " ) ) ) < nl > case None ⇒ ConfigFactory . load ( ) < nl > } < nl > < nl > - val config = ConfigFactory . parseString ( < nl > + val config = defaults . withFallback ( ConfigFactory . parseString ( < nl > s " " " < nl > | akka { < nl > | actor { < nl > @ @ - 44 , 7 + 44 , 7 @ @ object ActorConfig { < nl > | } < nl > | } < nl > " " " . stripMargin < nl > - ) < nl > + ) ) < nl > . withFallback ( mainConfig ) < nl > . withFallback ( ConfigFactory . parseResources ( " runtime . conf " ) ) < nl > . resolve ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > index 0b2b060 . . 3491bd9 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > @ @ - 57 , 9 + 57 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > < nl > val message = ApiTextMessage ( " Hello mr President . Zzz " , Vector . empty , None ) < nl > < nl > - def withError ( maxUpdateSize : Long ) = { < nl > + def withError ( maxUpdateSize : Long ) : Int = { < nl > val example = UpdateMessageContentChanged ( user2Peer , 1000L , message ) < nl > - maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) < nl > + ( maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) ) . toInt < nl > } < nl > < nl > / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total < nl > @ @ - 75 , 7 + 75 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > val diff = res . toOption . get < nl > inside ( res ) { < nl > case Ok ( ResponseGetDifference ( seq , state , users , updates , needMore , groups ) ) ⇒ < nl > - ( updates . map ( _ . toByteArray . length ) . sum < = withError ( config . maxDifferenceSize ) ) shouldEqual true < nl > + println ( user2 . id ) < nl > + println ( updates . map ( _ . update . length ) ) < nl > + updates . map ( _ . toByteArray . length ) . sum should be < = withError ( config . maxDifferenceSize ) < nl > needMore shouldEqual true < nl > totalUpdates + + = updates < nl > diff . seq shouldEqual updates . length < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala < nl > index 8e599d2 . . a465f48 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl < nl > import V20151108011300 _ _ FillUserSequence . _ < nl > < nl > it should " properly migrate updates from authId with max sequence " in maxSeq < nl > + it should " migrate new updates on second run " in secondRun < nl > < nl > implicit val getSeqUpdate = GetResult [ SeqUpdate ] ( r ⇒ SeqUpdate ( < nl > userId = r . nextInt ( ) , < nl > @ @ - 31 , 25 + 32 , 53 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl < nl > < nl > createUser ( ) < nl > < nl > - val seq1 = buildObsSeq ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) < nl > - val seq2 = buildObsSeq ( authId2 , BulkSize + 50 ) < nl > - val seq3 = buildObsSeq ( authId3 , ( BulkSize / 2 ) . toInt ) < nl > + fillObsolete ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) < nl > + fillObsolete ( authId2 , BulkSize + 50 ) < nl > + fillObsolete ( authId3 , BulkSize / 2 ) < nl > < nl > - whenReady ( db . run ( DBIO . sequence ( ( seq1 + + seq2 + + seq3 ) map { < nl > + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) < nl > + < nl > + checkValidSeq ( user1 . id , authId1 ) < nl > + } < nl > + < nl > + def secondRun ( ) = { < nl > + val ( user1 , authId1 , _ , _ ) = createUser ( ) < nl > + val ( authId2 , _ ) = createAuthId ( user1 . id ) < nl > + val ( authId3 , _ ) = createAuthId ( user1 . id ) < nl > + < nl > + val seq1 = fillObsolete ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) < nl > + fillObsolete ( authId2 , BulkSize + 50 ) < nl > + fillObsolete ( authId3 , BulkSize / 2 ) < nl > + < nl > + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) < nl > + < nl > + fillObsolete ( authId1 , 10 , seq1 . size + 1 ) < nl > + < nl > + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) < nl > + < nl > + checkValidSeq ( user1 . id , authId1 ) < nl > + } < nl > + < nl > + private def fillObsolete ( authId : Long , seq : Int , startFrom : Int = 1 ) : Seq [ Obsolete ] = { < nl > + val obss = buildObsSeq ( authId , seq , startFrom ) < nl > + < nl > + whenReady ( db . run ( DBIO . sequence ( obss map { < nl > case Obsolete ( authId , timestamp , seq , header , data , userIds , groupIds ) ⇒ < nl > sql " " " INSERT INTO seq _ updates _ ngen ( auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str ) < nl > VALUES ( $ authId , $ timestamp , $ seq , $ header , $ data , $ userIds , $ groupIds ) < nl > " " " . asUpdate < nl > } ) ) ) ( identity ) < nl > < nl > - new V20151108011300 _ _ FillUserSequence ( system ) . migrate ( ) < nl > - < nl > - checkValidSeq ( user1 . id , seq1 ) < nl > + obss < nl > } < nl > < nl > - private def checkValidSeq ( userId : Int , obsSeq : Seq [ Obsolete ] ) : Unit = { < nl > - Await . result ( db . run ( for ( seqs ← sql " " " SELECT * FROM user _ sequence " " " . as [ SeqUpdate ] ) yield { < nl > - assert ( seqs . size . toInt = = obsSeq . size . toInt , " wrong sequence size " ) < nl > + private def checkValidSeq ( userId : Int , oldestAuthId : Long ) : Unit = { < nl > + Await . result ( db . run ( for { < nl > + seqs ← sql " " " SELECT * FROM user _ sequence WHERE user _ id = $ userId ORDER BY seq ASC " " " . as [ SeqUpdate ] < nl > + obsSeq ← sql " " " SELECT seq FROM seq _ updates _ ngen WHERE auth _ id = $ oldestAuthId ORDER BY timestamp DESC LIMIT 1 " " " < nl > + . as [ Int ] . headOption . map ( _ . getOrElse ( 0 ) ) < nl > + } yield { < nl > + assert ( seqs . size . toInt = = obsSeq , " wrong sequence size " ) < nl > < nl > seqs . zipWithIndex foreach { < nl > case ( SeqUpdate ( ` userId ` , seq , timestamp , Some ( mappingBytes ) ) , index ) ⇒ < nl > @ @ - 71 , 8 + 100 , 8 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl < nl > } ) , patienceConfig . timeout . totalNanos . nanos ) < nl > } < nl > < nl > - private def buildObsSeq ( authId : Long , seq : Int ) = < nl > - for ( i ← 1 to seq ) yield { < nl > + private def buildObsSeq ( authId : Long , seq : Int , startFrom : Int = 1 ) = < nl > + for ( i ← startFrom to seq ) yield { < nl > val upd = UpdateContactsAdded ( Vector ( i ) ) < nl > Obsolete ( authId , i . toLong + 100 , i , upd . header , upd . toByteArray , s " $ i " , s " $ i , $ i " ) < nl > } < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 3c8e2cd . . 8968f1d 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 166 , 7 + 166 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { < nl > mainClass in Revolver . reStart : = Some ( " im . actor . server . cli . ActorCliApp " ) , < nl > mainClass in Compile : = Some ( " im . actor . server . cli . ActorCliApp " ) < nl > ) < nl > - ) < nl > + ) . dependsOn ( actorCore ) < nl > < nl > lazy val actorCore = Project ( < nl > id = " actor - core " , < nl > diff - - git a / actor - server / src / universal / bin / actor - cli b / actor - server / src / universal / bin / actor - cli < nl > index 3959107 . . 9684ac8 100755 < nl > - - - a / actor - server / src / universal / bin / actor - cli < nl > + + + b / actor - server / src / universal / bin / actor - cli < nl > @ @ - 4 , 4 + 4 , 4 @ @ set - eu < nl > < nl > HOME = " $ ( dirname " $ ( which " $ 0 " ) " ) / . . " < nl > < nl > - eval " $ HOME / bin / actor - main im . actor . server . cli . ActorCli - Dconfig . file = $ HOME / conf / cp . conf $ @ " < nl > + eval " $ HOME / bin / actor - main im . actor . server . cli . ActorCli $ @ "

TEST DIFF:
diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 index 684761e . . dc8ffe2 100644 
 - - - a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 @ @ - 17 , 13 + 17 , 16 @ @ private case class Config ( 
 command : String = " help " , 
 createBot : CreateBot = CreateBot ( ) , 
 updateIsAdmin : UpdateIsAdmin = UpdateIsAdmin ( ) , 
 - httpApiTokenCreate : HttpApiTokenCreate = HttpApiTokenCreate ( ) 
 + httpApiTokenCreate : HttpApiTokenCreate = HttpApiTokenCreate ( ) , 
 + key : Key = Key ( ) 
 ) 
 
 private [ cli ] trait Request { 
 type Response 
 } 
 
 + private [ cli ] case class Key ( create : Boolean = true , path : String = " actor - key " ) 
 + 
 private [ cli ] case class CreateBot ( 
 username : String = " " , 
 name : String = " " , 
 @ @ - 56 , 6 + 59 , 7 @ @ private object Commands { 
 val AdminRevoke = " admin - revoke " 
 val MigrateUserSequence = " migrate - user - sequence " 
 val HttpApiTokenCreate = " http - api - token - create " 
 + val Key = " key " 
 } 
 
 object ActorCli extends App { 
 @ @ - 100 , 11 + 104 , 22 @ @ object ActorCli extends App { 
 c . copy ( httpApiTokenCreate = c . httpApiTokenCreate . copy ( isAdmin = true ) ) 
 } 
 ) 
 + cmd ( Commands . Key ) action { ( _ , c ) ⇒ 
 + c . copy ( command = Commands . Key ) 
 + } children ( 
 + opt [ Unit ] ( " create " ) abbr " c " required ( ) action { ( x , c ) ⇒ 
 + c . copy ( key = c . key . copy ( create = true ) ) 
 + } , 
 + opt [ String ] ( " out " ) abbr " o " optional ( ) action { ( x , c ) ⇒ 
 + c . copy ( key = c . key . copy ( path = x ) ) 
 + } 
 + ) 
 } 
 
 parser . parse ( args , Config ( ) ) foreach { config ⇒ 
 val handlers = new CliHandlers 
 val migrationHandlers = new MigrationHandlers 
 + val securityHandlers = new SecurityHandlers 
 
 config . command match { 
 case Commands . Help ⇒ 
 @ @ - 115 , 6 + 130 , 8 @ @ object ActorCli extends App { 
 cmd ( handlers . updateIsAdmin ( config . updateIsAdmin ) ) 
 case Commands . MigrateUserSequence ⇒ 
 cmd ( migrationHandlers . userSequence ( ) , 2 . hours ) 
 + case Commands . Key ⇒ 
 + cmd ( securityHandlers . createKey ( config . key . path ) ) 
 } 
 
 def cmd ( f : Future [ Unit ] , timeout : Duration = 10 . seconds ) : Unit = { 
 diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala 
 new file mode 100644 
 index 0000000 . . c1931c6 
 - - - / dev / null 
 + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / SecurityHandlers . scala 
 @ @ - 0 , 0 + 1 , 58 @ @ 
 + package im . actor . server . cli 
 + 
 + import java . security . SecureRandom 
 + 
 + import better . files . _ 
 + import im . actor . crypto . Curve25519 
 + 
 + import scala . concurrent . Future 
 + 
 + final class SecurityHandlers { 
 + private val random = new SecureRandom ( ) 
 + 
 + def createKey ( path : String ) : Future [ Unit ] = { 
 + val pubPath = path + " . pub " 
 + val privatePath = path + " . private " 
 + 
 + val pubFile = File ( pubPath ) 
 + val privateFile = File ( privatePath ) 
 + 
 + if ( pubFile . exists ) { 
 + println ( s " File $ pubPath already exists ! " ) 
 + Future . successful ( ( ) ) 
 + } else if ( privateFile . exists ) { 
 + println ( s " File $ privatePath already exists ! " ) 
 + Future . successful ( ( ) ) 
 + } else { 
 + val randomBytes = new Array [ Byte ] ( 32 ) 
 + random . nextBytes ( randomBytes ) 
 + 
 + val pair = Curve25519 . keyGen ( randomBytes ) 
 + pubFile . write ( pair . getPublicKey ) 
 + privateFile . write ( pair . getPrivateKey ) 
 + 
 + println ( 
 + s " " " 
 + | Created $ pubFile and $ privateFile 
 + | You need to add the following to your server . conf : 
 + | 
 + | 
 + | modules : { 
 + | # . . . other modules 
 + | security { 
 + | # . . . other settings 
 + | server - keys : [ 
 + | # . . . other server keys 
 + | { 
 + | public : " $ pubPath " 
 + | private : " $ privatePath " 
 + | } 
 + | ] 
 + | } 
 + | } 
 + | " " " . stripMargin 
 + ) 
 + Future . successful ( ( ) ) 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 6ad163a . . cd23d73 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 161 , 7 + 161 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 mainClass in Compile : = Some ( " im . actor . server . cli . ActorCliApp " ) 
 ) 
 ) 
 - . dependsOn ( actorCore ) 
 + . dependsOn ( actorCore , actorFrontend ) 
 
 lazy val actorCore = Project ( 
 id = " actor - core " ,

NEAREST DIFF:
diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 index b6a4655 . . 0ab73c9 100644 
 - - - a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / ActorCli . scala 
 @ @ - 49 , 6 + 49 , 7 @ @ private object Commands { 
 val CreateBot = " create - bot " 
 val AdminGrant = " admin - grant " 
 val AdminRevoke = " admin - revoke " 
 + val MigrateUserSequence = " migrate - user - sequence " 
 } 
 
 object ActorCli extends App { 
 @ @ - 83 , 23 + 84 , 29 @ @ object ActorCli extends App { 
 c . copy ( updateIsAdmin = UpdateIsAdmin ( x , isAdmin = false ) ) 
 } 
 ) 
 + cmd ( Commands . MigrateUserSequence ) action { ( _ , c ) ⇒ 
 + c . copy ( command = Commands . MigrateUserSequence ) 
 + } 
 } 
 
 parser . parse ( args , Config ( ) ) foreach { config ⇒ 
 val handlers = new CliHandlers 
 + val migrationHandlers = new MigrationHandlers 
 
 - cmd ( config . command match { 
 + config . command match { 
 case Commands . Help ⇒ 
 - Future . successful ( parser . showUsage ) 
 + cmd ( Future . successful ( parser . showUsage ) ) 
 case Commands . CreateBot ⇒ 
 - handlers . createBot ( config . createBot ) 
 + cmd ( handlers . createBot ( config . createBot ) ) 
 case Commands . AdminGrant | Commands . AdminRevoke ⇒ 
 - handlers . updateIsAdmin ( config . updateIsAdmin ) 
 - } ) 
 + cmd ( handlers . updateIsAdmin ( config . updateIsAdmin ) ) 
 + case Commands . MigrateUserSequence ⇒ 
 + cmd ( migrationHandlers . userSequence ( ) , 2 . hours ) 
 + } 
 
 - def cmd ( f : Future [ Unit ] ) : Unit = { 
 + def cmd ( f : Future [ Unit ] , timeout : Duration = 10 . seconds ) : Unit = { 
 try { 
 - Await . result ( f , 10 . seconds ) 
 + Await . result ( f , timeout ) 
 } finally { 
 handlers . shutdown ( ) 
 } 
 diff - - git a / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala 
 new file mode 100644 
 index 0000000 . . f68b0b3 
 - - - / dev / null 
 + + + b / actor - server / actor - cli / src / main / scala / im / actor / server / cli / MigrationHandlers . scala 
 @ @ - 0 , 0 + 1 , 39 @ @ 
 + package im . actor . server . cli 
 + 
 + import akka . actor . ActorSystem 
 + import akka . stream . ActorMaterializer 
 + import com . typesafe . config . ConfigFactory 
 + import im . actor . config . ActorConfig 
 + import im . actor . server . db . DbExtension 
 + import sql . migration . V20151108011300 _ _ FillUserSequence 
 + 
 + import scala . concurrent . _ 
 + 
 + final class MigrationHandlers { 
 + def userSequence ( ) : Future [ Unit ] = { 
 + val config = ActorConfig . load ( ConfigFactory . parseString ( 
 + " " " 
 + | akka { 
 + | cluster . seed - nodes = [ ] 
 + | remote { 
 + | netty . tcp . hostname = " 127 . 0 . 0 . 1 " 
 + | netty . tcp . port = 0 
 + | } 
 + | } 
 + " " " . stripMargin 
 + ) ) 
 + 
 + implicit val system = ActorSystem ( " migrator " , config ) 
 + implicit val ec = system . dispatcher 
 + implicit val db = DbExtension ( system ) 
 + implicit val mat = ActorMaterializer ( ) 
 + 
 + val migration = new V20151108011300 _ _ FillUserSequence 
 + 
 + Future { 
 + blocking { 
 + migration . migrate ( ) 
 + } 
 + } 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala 
 index 5a43e95 . . cecb9f7 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / FillUserSequenceMigrator . scala 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . server . migrations 
 
 import akka . actor . ActorSystem 
 + import akka . stream . ActorMaterializer 
 import slick . driver . PostgresDriver 
 import sql . migration . V20151108011300 _ _ FillUserSequence 
 
 @ @ - 13 , 7 + 14 , 8 @ @ object FillUserSequenceMigrator extends Migration { 
 override protected def migrationTimeout : Duration = 1 . hour 
 
 override protected def startMigration ( ) ( implicit system : ActorSystem , db : PostgresDriver . api . Database , ec : ExecutionContext ) : Future [ Unit ] = { 
 - val migration = new V20151108011300 _ _ FillUserSequence ( system ) 
 + implicit val mat = ActorMaterializer ( ) 
 + val migration = new V20151108011300 _ _ FillUserSequence 
 Future ( migration . migrate ( ) ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala b / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala 
 index e7b15e7 . . 0ff981b 100644 
 - - - a / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala 
 + + + b / actor - server / actor - persist / src / main / scala / sql / migration / V20151108011300 _ _ FillUserSequence . scala 
 @ @ - 1 , 9 + 1 , 10 @ @ 
 package sql . migration 
 
 - import java . sql . SQLException 
 import java . util . concurrent . { LinkedBlockingQueue , TimeUnit , ThreadPoolExecutor } 
 
 import akka . actor . ActorSystem 
 + import akka . stream . Materializer 
 + import akka . stream . scaladsl . _ 
 import com . google . protobuf . ByteString 
 import com . typesafe . scalalogging . Logger 
 import im . actor . server . db . DbExtension 
 @ @ - 13 , 11 + 14 , 9 @ @ import org . slf4j . LoggerFactory 
 import slick . driver . PostgresDriver . api . _ 
 import slick . jdbc . { GetResult , SetParameter } 
 
 - import scala . annotation . tailrec 
 import scala . concurrent . { ExecutionContext , Future , Await } 
 import scala . concurrent . duration . _ 
 import scala . language . postfixOps 
 - import scala . util . { Failure , Success } 
 
 object V20151108011300 _ _ FillUserSequence { 
 final case class Obsolete ( authId : Long , timestamp : Long , seq : Int , header : Int , data : Array [ Byte ] , userIds : String , groupIds : String ) 
 @ @ - 47 , 36 + 46 , 41 @ @ object V20151108011300 _ _ FillUserSequence { 
 groupIds = r . nextString ( ) 
 ) ) 
 val BulkSize = 300 
 + val Parallelism = 4 
 } 
 
 - final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { 
 + final class V20151108011300 _ _ FillUserSequence ( implicit system : ActorSystem , materializer : Materializer ) { 
 import V20151108011300 _ _ FillUserSequence . _ 
 
 private val queue = new LinkedBlockingQueue [ Runnable ] ( ) 
 - private val executor = new ThreadPoolExecutor ( 100 , 100 , 1 , TimeUnit . HOURS , queue ) 
 + private val executor = new ThreadPoolExecutor ( 10 , 10 , 1 , TimeUnit . HOURS , queue ) 
 private implicit val ec = ExecutionContext . fromExecutor ( executor ) 
 private val log = Logger ( LoggerFactory . getLogger ( getClass ) ) 
 private val db = DbExtension ( system ) . db 
 
 - / / implicit val get = ( GetResult . createGetTuple5 [ Long , Int , Blob , String , String ] _ ) 
 - / / implicit val getObsolete = 
 - / / GetResult . createGetTuple5 [ Long , Int , Blob , String , String ] 
 - 
 def migrate ( ) : Unit = { 
 try { 
 log . warn ( " Starting filling user sequence " ) 
 - Await . result ( db . run ( { 
 - for { 
 - userIds ← UserRepo . allIds 
 - groupedUserIds = userIds . grouped ( 50 ) 
 - _ = log . warn ( s " Found users : $ { userIds } " ) 
 - affected ← DBIO . from ( Future . traverse ( groupedUserIds ) { ids ⇒ 
 - Future . sequence ( ids map ( id ⇒ db . run ( migrateUser ( id ) ) ) ) map ( _ . sum ) 
 - } ) map ( _ . sum ) 
 - } yield { 
 - log . warn ( s " $ { affected } updates moved " ) 
 - } 
 - } . transactionally ) , 2 . hours ) 
 + val count = 
 + Await . result ( { 
 + Source ( db . stream ( UserRepo . allIds ) ) 
 + . mapAsync ( Parallelism ) { userId ⇒ 
 + db . run ( for { 
 + authIds ← AuthIdRepo . findIdByUserId ( userId ) 
 + _ = log . warn ( s " Found $ { authIds . length } authIds for $ { userId } " ) 
 + oldestOpt ← maxSeq ( authIds ) 
 + } yield ( userId , oldestOpt ) ) 
 + } . collect { 
 + case ( userId , Some ( authId ) ) ⇒ ( userId , authId ) 
 + } 
 + . mapAsync ( Parallelism ) { 
 + case ( userId , authId ) ⇒ 
 + move ( userId , authId ) 
 + } 
 + . runFold ( 0 ) ( _ + _ ) 
 + } , 2 . hours ) 
 + 
 + log . warn ( s " Migration complete ! Moved $ { count } updates " ) 
 } catch { 
 case e : Exception ⇒ 
 log . error ( " Failed to migrate " , e ) 
 @ @ - 84 , 24 + 88 , 43 @ @ final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { 
 } 
 } 
 
 - private def migrateUser ( userId : Int ) : DBIO [ Int ] = { 
 - log . warn ( s " Moving user : $ { userId } " ) 
 - ( for { 
 - authIds ← AuthIdRepo . findIdByUserId ( userId ) 
 - _ = log . warn ( s " Found $ { authIds . length } authIds " ) 
 - oldestOpt ← maxSeq ( authIds ) 
 - copied ← oldestOpt map ( fill ( userId ) _ ) getOrElse DBIO . successful ( 0 ) 
 - } yield { 
 - log . warn ( s " Copied $ copied updates " ) 
 - copied 
 - } ) . asTry map { 
 - case Success ( res ) ⇒ res 
 - case Failure ( err : SQLException ) ⇒ 
 - log . error ( " Failed to move user " , err . getNextException ) 
 - throw err 
 - case Failure ( err ) ⇒ 
 - log . error ( " Failed to move user " , err ) 
 - throw err 
 + private def move ( userId : Int , authId : Long ) : Future [ Int ] = { 
 + log . warn ( s " Moving user $ userId " ) 
 + 
 + db . run ( sql " " " SELECT seq FROM user _ sequence WHERE user _ id = $ userId ORDER BY seq DESC LIMIT 1 " " " . as [ Int ] ) . map ( _ . headOption . getOrElse ( 0 ) ) flatMap { startFrom ⇒ 
 + 
 + Source ( 
 + db . stream ( sql " " " SELECT auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str FROM seq _ updates _ ngen WHERE auth _ id = $ authId and seq > $ startFrom " " " 
 + . as [ Obsolete ] ) 
 + ) 
 + . grouped ( BulkSize ) 
 + . mapAsync ( Parallelism ) { bulk ⇒ 
 + val news = bulk map { 
 + case Obsolete ( _ , timestamp , seq , header , data , userIds , groupIds ) ⇒ 
 + New ( 
 + userId = userId , 
 + seq = seq , 
 + timestamp = timestamp , 
 + mapping = UpdateMapping ( 
 + default = Some ( SerializedUpdate ( 
 + header = header , 
 + body = ByteString . copyFrom ( data ) , 
 + userIds = userIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq , 
 + groupIds = groupIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq 
 + ) ) 
 + ) . toByteArray 
 + ) 
 + } 
 + 
 + val action = newTable + + = news 
 + 
 + db . run ( action ) map ( _ . getOrElse ( 0 ) ) 
 + } 
 + . runFold ( 0 ) ( _ + _ ) 
 + . map { count ⇒ 
 + log . warn ( s " Moved $ { count } updates for user $ { userId } " ) 
 + count 
 + } 
 } 
 } 
 
 @ @ - 113 , 44 + 136 , 5 @ @ final class V20151108011300 _ _ FillUserSequence ( system : ActorSystem ) { 
 } yield Some ( seqs maxBy ( _ . _ 2 getOrElse 0 ) _ 1 ) 
 } 
 
 - private def fill ( userId : Int ) ( oldestAuthId : Long ) : DBIO [ Int ] = { 
 - for { 
 - obsoletes ← sql " " " SELECT auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str FROM seq _ updates _ ngen WHERE auth _ id = $ oldestAuthId " " " 
 - . as [ Obsolete ] 
 - affected ← move ( userId , obsoletes ) 
 - } yield affected 
 - } 
 - 
 - private def move ( userId : Int , obsoletes : Vector [ Obsolete ] ) : DBIO [ Int ] = { 
 - DBIO . sequence ( bulks ( obsoletes , Vector . empty ) map { bulkObs ⇒ 
 - val news = bulkObs . par map { 
 - case Obsolete ( _ , timestamp , seq , header , data , userIds , groupIds ) ⇒ 
 - New ( 
 - userId = userId , 
 - seq = seq , 
 - timestamp = timestamp , 
 - mapping = UpdateMapping ( 
 - default = Some ( SerializedUpdate ( 
 - header = header , 
 - body = ByteString . copyFrom ( data ) , 
 - userIds = userIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq , 
 - groupIds = groupIds . split ( " , " ) . view . filter ( _ . nonEmpty ) . map ( _ . toInt ) . toSeq 
 - ) ) 
 - ) . toByteArray 
 - ) 
 - } 
 - 
 - newTable + + = news . toVector 
 - } ) map ( _ ⇒ obsoletes . length ) 
 - } 
 - 
 - @ tailrec 
 - private def bulks ( obsoletes : Vector [ Obsolete ] , result : Vector [ Vector [ Obsolete ] ] ) : Vector [ Vector [ Obsolete ] ] = { 
 - obsoletes . splitAt ( BulkSize ) match { 
 - case ( bulk , Vector ( ) ) ⇒ result : + bulk 
 - case ( bulk , tail ) ⇒ bulks ( tail , result : + bulk ) 
 - } 
 - } 
 - 
 private def getSeq ( authId : Long ) = sql " " " SELECT seq FROM seq _ updates _ ngen WHERE auth _ id = $ authId ORDER BY timestamp DESC LIMIT 1 " " " . as [ Int ] . headOption 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index a2167f0 . . 14c35dd 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 13 , 14 + 13 , 14 @ @ import com . typesafe . config . { ConfigException , Config , ConfigFactory } 
 import scala . util . { Failure , Success , Try } 
 
 object ActorConfig { 
 - def load ( ) : Config = { 
 + def load ( defaults : Config = ConfigFactory . empty ( ) ) : Config = { 
 val mainConfig = Option ( System . getProperty ( " actor . home " ) ) match { 
 case Some ( home ) ⇒ 
 ConfigFactory . load ( ConfigFactory . parseFile ( new File ( s " $ home / conf / server . conf " ) ) ) 
 case None ⇒ ConfigFactory . load ( ) 
 } 
 
 - val config = ConfigFactory . parseString ( 
 + val config = defaults . withFallback ( ConfigFactory . parseString ( 
 s " " " 
 | akka { 
 | actor { 
 @ @ - 44 , 7 + 44 , 7 @ @ object ActorConfig { 
 | } 
 | } 
 " " " . stripMargin 
 - ) 
 + ) ) 
 . withFallback ( mainConfig ) 
 . withFallback ( ConfigFactory . parseResources ( " runtime . conf " ) ) 
 . resolve ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 index 0b2b060 . . 3491bd9 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 @ @ - 57 , 9 + 57 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 
 val message = ApiTextMessage ( " Hello mr President . Zzz " , Vector . empty , None ) 
 
 - def withError ( maxUpdateSize : Long ) = { 
 + def withError ( maxUpdateSize : Long ) : Int = { 
 val example = UpdateMessageContentChanged ( user2Peer , 1000L , message ) 
 - maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) 
 + ( maxUpdateSize * ( 1 + 5 . toDouble / example . getSerializedSize ) ) . toInt 
 } 
 
 / / serialized update size is : 40 bytes for body + 4 bytes for header , 44 bytes total 
 @ @ - 75 , 7 + 75 , 9 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 val diff = res . toOption . get 
 inside ( res ) { 
 case Ok ( ResponseGetDifference ( seq , state , users , updates , needMore , groups ) ) ⇒ 
 - ( updates . map ( _ . toByteArray . length ) . sum < = withError ( config . maxDifferenceSize ) ) shouldEqual true 
 + println ( user2 . id ) 
 + println ( updates . map ( _ . update . length ) ) 
 + updates . map ( _ . toByteArray . length ) . sum should be < = withError ( config . maxDifferenceSize ) 
 needMore shouldEqual true 
 totalUpdates + + = updates 
 diff . seq shouldEqual updates . length 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala 
 index 8e599d2 . . a465f48 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / V20151108011300 _ _ FillUserSequenceSpec . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl 
 import V20151108011300 _ _ FillUserSequence . _ 
 
 it should " properly migrate updates from authId with max sequence " in maxSeq 
 + it should " migrate new updates on second run " in secondRun 
 
 implicit val getSeqUpdate = GetResult [ SeqUpdate ] ( r ⇒ SeqUpdate ( 
 userId = r . nextInt ( ) , 
 @ @ - 31 , 25 + 32 , 53 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl 
 
 createUser ( ) 
 
 - val seq1 = buildObsSeq ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) 
 - val seq2 = buildObsSeq ( authId2 , BulkSize + 50 ) 
 - val seq3 = buildObsSeq ( authId3 , ( BulkSize / 2 ) . toInt ) 
 + fillObsolete ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) 
 + fillObsolete ( authId2 , BulkSize + 50 ) 
 + fillObsolete ( authId3 , BulkSize / 2 ) 
 
 - whenReady ( db . run ( DBIO . sequence ( ( seq1 + + seq2 + + seq3 ) map { 
 + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) 
 + 
 + checkValidSeq ( user1 . id , authId1 ) 
 + } 
 + 
 + def secondRun ( ) = { 
 + val ( user1 , authId1 , _ , _ ) = createUser ( ) 
 + val ( authId2 , _ ) = createAuthId ( user1 . id ) 
 + val ( authId3 , _ ) = createAuthId ( user1 . id ) 
 + 
 + val seq1 = fillObsolete ( authId1 , ( BulkSize * 1 . 5 ) . toInt ) 
 + fillObsolete ( authId2 , BulkSize + 50 ) 
 + fillObsolete ( authId3 , BulkSize / 2 ) 
 + 
 + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) 
 + 
 + fillObsolete ( authId1 , 10 , seq1 . size + 1 ) 
 + 
 + new V20151108011300 _ _ FillUserSequence ( ) . migrate ( ) 
 + 
 + checkValidSeq ( user1 . id , authId1 ) 
 + } 
 + 
 + private def fillObsolete ( authId : Long , seq : Int , startFrom : Int = 1 ) : Seq [ Obsolete ] = { 
 + val obss = buildObsSeq ( authId , seq , startFrom ) 
 + 
 + whenReady ( db . run ( DBIO . sequence ( obss map { 
 case Obsolete ( authId , timestamp , seq , header , data , userIds , groupIds ) ⇒ 
 sql " " " INSERT INTO seq _ updates _ ngen ( auth _ id , timestamp , seq , header , serialized _ data , user _ ids _ str , group _ ids _ str ) 
 VALUES ( $ authId , $ timestamp , $ seq , $ header , $ data , $ userIds , $ groupIds ) 
 " " " . asUpdate 
 } ) ) ) ( identity ) 
 
 - new V20151108011300 _ _ FillUserSequence ( system ) . migrate ( ) 
 - 
 - checkValidSeq ( user1 . id , seq1 ) 
 + obss 
 } 
 
 - private def checkValidSeq ( userId : Int , obsSeq : Seq [ Obsolete ] ) : Unit = { 
 - Await . result ( db . run ( for ( seqs ← sql " " " SELECT * FROM user _ sequence " " " . as [ SeqUpdate ] ) yield { 
 - assert ( seqs . size . toInt = = obsSeq . size . toInt , " wrong sequence size " ) 
 + private def checkValidSeq ( userId : Int , oldestAuthId : Long ) : Unit = { 
 + Await . result ( db . run ( for { 
 + seqs ← sql " " " SELECT * FROM user _ sequence WHERE user _ id = $ userId ORDER BY seq ASC " " " . as [ SeqUpdate ] 
 + obsSeq ← sql " " " SELECT seq FROM seq _ updates _ ngen WHERE auth _ id = $ oldestAuthId ORDER BY timestamp DESC LIMIT 1 " " " 
 + . as [ Int ] . headOption . map ( _ . getOrElse ( 0 ) ) 
 + } yield { 
 + assert ( seqs . size . toInt = = obsSeq , " wrong sequence size " ) 
 
 seqs . zipWithIndex foreach { 
 case ( SeqUpdate ( ` userId ` , seq , timestamp , Some ( mappingBytes ) ) , index ) ⇒ 
 @ @ - 71 , 8 + 100 , 8 @ @ final class V20151108011300 _ _ FillUserSequenceSpec extends BaseAppSuite with Impl 
 } ) , patienceConfig . timeout . totalNanos . nanos ) 
 } 
 
 - private def buildObsSeq ( authId : Long , seq : Int ) = 
 - for ( i ← 1 to seq ) yield { 
 + private def buildObsSeq ( authId : Long , seq : Int , startFrom : Int = 1 ) = 
 + for ( i ← startFrom to seq ) yield { 
 val upd = UpdateContactsAdded ( Vector ( i ) ) 
 Obsolete ( authId , i . toLong + 100 , i , upd . header , upd . toByteArray , s " $ i " , s " $ i , $ i " ) 
 } 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 3c8e2cd . . 8968f1d 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 166 , 7 + 166 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Publishing { 
 mainClass in Revolver . reStart : = Some ( " im . actor . server . cli . ActorCliApp " ) , 
 mainClass in Compile : = Some ( " im . actor . server . cli . ActorCliApp " ) 
 ) 
 - ) 
 + ) . dependsOn ( actorCore ) 
 
 lazy val actorCore = Project ( 
 id = " actor - core " , 
 diff - - git a / actor - server / src / universal / bin / actor - cli b / actor - server / src / universal / bin / actor - cli 
 index 3959107 . . 9684ac8 100755 
 - - - a / actor - server / src / universal / bin / actor - cli 
 + + + b / actor - server / src / universal / bin / actor - cli 
 @ @ - 4 , 4 + 4 , 4 @ @ set - eu 
 
 HOME = " $ ( dirname " $ ( which " $ 0 " ) " ) / . . " 
 
 - eval " $ HOME / bin / actor - main im . actor . server . cli . ActorCli - Dconfig . file = $ HOME / conf / cp . conf $ @ " 
 + eval " $ HOME / bin / actor - main im . actor . server . cli . ActorCli $ @ "
