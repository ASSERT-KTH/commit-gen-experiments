BLEU SCORE: 0.17202572313558198

TEST MSG: perf ( server : messaging ) : DialogRootStateSnapshot
GENERATED MSG: fix ( server : messaging ) : create dialog on WriteMessageSelf , DM and Group dialog groups by default

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 0678239 . . 6b9c6c4 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 32 , 6 + 32 , 11 @ @ message DialogGroup { < nl > repeated DialogInfo dialogs = 2 ; < nl > } < nl > < nl > + message DialogRootStateSnapshot { < nl > + repeated DialogGroup dialog _ groups = 1 ; < nl > + repeated DialogInfo archived = 2 ; < nl > + } < nl > + < nl > message DialogRootEvents { < nl > message Created { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootEvent " ; < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 1a5a772 . . 9cb4ace 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 43 , 22 + 43 , 57 @ @ private object SortableDialog { < nl > < nl > private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > < nl > + private object DialogRootState { < nl > + val initial = DialogRootState ( < nl > + Map ( < nl > + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) , < nl > + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) < nl > + ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) < nl > + ) < nl > + } < nl > + < nl > private final case class DialogRootState ( < nl > - active : Map [ DialogGroupType , Set [ Peer ] ] , < nl > + active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , < nl > activePeers : SortedSet [ SortableDialog ] , < nl > archived : SortedSet [ SortableDialog ] < nl > ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { < nl > import DialogRootEvents . _ < nl > < nl > override def updated ( e : DialogRootEvent ) : DialogRootState = e match { < nl > - case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > - case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) < nl > - case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > - case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) < nl > - case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) < nl > + case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > + case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) < nl > + case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > + case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) < nl > + case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) < nl > + } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { < nl > + case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { < nl > + val state = DialogRootState . initial . copy ( < nl > + archived = SortedSet ( < nl > + ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > + ) ( SortableDialog . ordering ) < nl > + ) < nl > + < nl > + dialogGroups . foldLeft ( state ) { < nl > + case ( acc , DialogGroup ( group , infos ) ) ⇒ < nl > + withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) < nl > + } < nl > + } < nl > } < nl > < nl > - override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this < nl > + override lazy val snapshot : Any = DialogRootStateSnapshot ( < nl > + dialogGroups = active . toSeq map { < nl > + case ( typ , sortableDialogs ) ⇒ < nl > + DialogGroup ( < nl > + typ , < nl > + sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > + ) < nl > + } , < nl > + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } < nl > + ) < nl > < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > @ @ - 67 , 7 + 102 , 7 @ @ private final case class DialogRootState ( < nl > else < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > - active = this . active + dialogGroup ( peer ) , < nl > + active = this . active + dialogGroup ( sortableDialog ) , < nl > archived = this . archived - sortableDialog < nl > ) < nl > } < nl > @ @ - 77 , 7 + 112 , 7 @ @ private final case class DialogRootState ( < nl > < nl > copy ( < nl > activePeers = this . activePeers - sortableDialog , < nl > - active = this . active mapValues ( _ - peer ) , < nl > + active = this . active mapValues ( _ - sortableDialog ) , < nl > archived = this . archived + sortableDialog < nl > ) < nl > } < nl > @ @ - 87 , 29 + 122 , 41 @ @ private final case class DialogRootState ( < nl > < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > - active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( peer , isFavourite = true ) , < nl > + active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > archived = this . archived - sortableDialog < nl > ) < nl > } < nl > < nl > - private def withUnfavouritedPeer ( peer : Peer ) = < nl > + private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > copy ( < nl > active = < nl > - ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( peer ) ) . filter { < nl > + ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false < nl > case _ ⇒ true < nl > } < nl > ) < nl > + } < nl > < nl > - private def dialogGroup ( peer : Peer , isFavourite : Boolean = false ) = { < nl > - val group = ( isFavourite , peer . typ ) match { < nl > + private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = < nl > + copy ( < nl > + active = this . active map { < nl > + case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) < nl > + case other ⇒ other < nl > + } , < nl > + activePeers = this . activePeers + + sortableDialogs < nl > + ) < nl > + < nl > + private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { < nl > + val group = ( isFavourite , sortableDialog . peer . typ ) match { < nl > case ( true , _ ) ⇒ DialogGroupType . Favourites < nl > case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages < nl > case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups < nl > case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > } < nl > < nl > - group → ( this . active . getOrElse ( group , Set . empty ) + peer ) < nl > + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . ordering ) ) + sortableDialog ) < nl > } < nl > } < nl > < nl > @ @ - 121 , 7 + 168 , 8 @ @ object DialogRoot { < nl > 45012 → classOf [ DialogRootEvents . Favourited ] , < nl > 45013 → classOf [ DialogRootEvents . Shown ] , < nl > 45014 → classOf [ DialogRootEvents . Unarchived ] , < nl > - 45015 → classOf [ DialogRootEvents . Unfavourited ] < nl > + 45015 → classOf [ DialogRootEvents . Unfavourited ] , < nl > + 45016 → classOf [ DialogRootStateSnapshot ] < nl > ) < nl > } < nl > < nl > @ @ - 170 , 7 + 218 , 10 @ @ private trait DialogRootQueryHandlers { < nl > } < nl > } < nl > < nl > - private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Processor [ DialogRootState , DialogRootEvent ] with DialogRootQueryHandlers { < nl > + private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) < nl > + extends Processor [ DialogRootState , DialogRootEvent ] < nl > + with IncrementalSnapshots [ DialogRootState , DialogRootEvent ] < nl > + with DialogRootQueryHandlers { < nl > import DialogRootEvents . _ < nl > import DialogRootQueries . _ < nl > import DialogRootCommands . _ < nl > @ @ - 182 , 14 + 233 , 7 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > override def persistenceId : String = s " DialogRoot _ $ userId " < nl > < nl > - override protected def getInitialState : DialogRootState = DialogRootState ( < nl > - Map ( < nl > - DialogGroupType . DirectMessages → Set . empty , < nl > - DialogGroupType . Groups → Set . empty < nl > - ) , < nl > - SortedSet . empty ( SortableDialog . ordering ) , < nl > - SortedSet . empty ( SortableDialog . ordering ) < nl > - ) < nl > + override protected def getInitialState : DialogRootState = DialogRootState . initial < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ getCounter ( ) < nl > @ @ - 282 , 7 + 326 , 7 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > < nl > - private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( peer ) ) < nl > + private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( SortableDialog ( Instant . MIN , peer ) ) ) < nl > < nl > private def dialogShown ( peer : Peer ) : Boolean = state . activePeers . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > < nl > @ @ - 306 , 8 + 350 , 8 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { < nl > val infosFutures = < nl > state . active map { < nl > - case ( group , peers ) ⇒ < nl > - FutureExt . ftraverse ( peers . toSeq ) ( getInfo ) < nl > + case ( group , sortableDialogs ) ⇒ < nl > + FutureExt . ftraverse ( sortableDialogs . toSeq ) ( sd ⇒ getInfo ( sd . peer ) ) < nl > . map ( infos ⇒ DialogGroup ( group , infos . map ( _ . getInfo ) ) ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 652fad2 . . cf67226 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > - import im . actor . server . dialog . DialogCommands . SendMessage < nl > + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } < nl > import im . actor . server . model . { Peer , PeerType } < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . UpdateChatGroupsChanged < nl > @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > override def persistenceId : String = s " DialogRoot _ $ userId " < nl > < nl > - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) < nl > + override protected def getInitialState : DialogRootState = DialogRootState ( < nl > + Map ( < nl > + DialogGroupType . DirectMessages → Set . empty , < nl > + DialogGroupType . Groups → Set . empty < nl > + ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) < nl > + ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ getCounter ( ) < nl > @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > override protected def handleCommand : Receive = { < nl > - case sm : SendMessage ⇒ < nl > - needShowDialog ( sm ) match { < nl > + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ < nl > + needShowDialog ( dc ) match { < nl > case Some ( peer ) ⇒ < nl > val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) < nl > < nl > persist ( e ) { _ ⇒ < nl > commit ( e ) < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > sendChatGroupsChanged ( ) < nl > } < nl > case None ⇒ < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > } < nl > case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) < nl > @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = archive $ { state . activePeers } " ) < nl > - < nl > if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) < nl > else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - println ( s " = = = archive result $ { state . activePeers } " ) < nl > - < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = unarchive $ { state . activePeers } " ) < nl > - < nl > if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) < nl > else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - < nl > - println ( s " = = = unarchive result $ { state . activePeers } " ) < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > } < nl > < nl > - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { < nl > - val checkPeer = < nl > - sm . getOrigin . typ match { < nl > - case PeerType . Group ⇒ sm . getDest < nl > - case PeerType . Private ⇒ < nl > - if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > - else sm . getDest < nl > - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > - } < nl > + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { < nl > + val checkPeerOpt = cmd match { < nl > + case sm : SendMessage ⇒ < nl > + Some ( sm . getOrigin . typ match { < nl > + case PeerType . Group ⇒ sm . getDest < nl > + case PeerType . Private ⇒ < nl > + if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > + else sm . getDest < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } ) < nl > + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) < nl > + case _ ⇒ None < nl > + } < nl > < nl > - if ( dialogShown ( checkPeer ) ) None < nl > - else Some ( checkPeer ) < nl > + checkPeerOpt flatMap { checkPeer ⇒ < nl > + if ( dialogShown ( checkPeer ) ) None < nl > + else Some ( checkPeer ) < nl > + } < nl > } < nl > < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 17e13c3 . . 7d8f59b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { < nl > final case class BotCommandAlreadyExists ( slashCommand : String ) < nl > extends UserError ( s " Bot command already exists : $ slashCommand " ) < nl > < nl > - final case object ContactNotFound extends UserError ( " Contact not found " ) < nl > + case object ContactNotFound extends UserError ( " Contact not found " ) < nl > < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 0678239 . . 6b9c6c4 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 32 , 6 + 32 , 11 @ @ message DialogGroup { 
 repeated DialogInfo dialogs = 2 ; 
 } 
 
 + message DialogRootStateSnapshot { 
 + repeated DialogGroup dialog _ groups = 1 ; 
 + repeated DialogInfo archived = 2 ; 
 + } 
 + 
 message DialogRootEvents { 
 message Created { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootEvent " ; 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 1a5a772 . . 9cb4ace 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 43 , 22 + 43 , 57 @ @ private object SortableDialog { 
 
 private case class SortableDialog ( ts : Instant , peer : Peer ) 
 
 + private object DialogRootState { 
 + val initial = DialogRootState ( 
 + Map ( 
 + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . ordering ) , 
 + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . ordering ) 
 + ) , 
 + SortedSet . empty ( SortableDialog . ordering ) , 
 + SortedSet . empty ( SortableDialog . ordering ) 
 + ) 
 + } 
 + 
 private final case class DialogRootState ( 
 - active : Map [ DialogGroupType , Set [ Peer ] ] , 
 + active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , 
 activePeers : SortedSet [ SortableDialog ] , 
 archived : SortedSet [ SortableDialog ] 
 ) extends ProcessorState [ DialogRootState , DialogRootEvent ] { 
 import DialogRootEvents . _ 
 
 override def updated ( e : DialogRootEvent ) : DialogRootState = e match { 
 - case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 - case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) 
 - case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 - case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) 
 - case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) 
 + case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 + case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) 
 + case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 + case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) 
 + case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) 
 + } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { 
 + case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { 
 + val state = DialogRootState . initial . copy ( 
 + archived = SortedSet ( 
 + ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 + ) ( SortableDialog . ordering ) 
 + ) 
 + 
 + dialogGroups . foldLeft ( state ) { 
 + case ( acc , DialogGroup ( group , infos ) ) ⇒ 
 + withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) 
 + } 
 + } 
 } 
 
 - override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this 
 + override lazy val snapshot : Any = DialogRootStateSnapshot ( 
 + dialogGroups = active . toSeq map { 
 + case ( typ , sortableDialogs ) ⇒ 
 + DialogGroup ( 
 + typ , 
 + sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 + ) 
 + } , 
 + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } 
 + ) 
 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 @ @ - 67 , 7 + 102 , 7 @ @ private final case class DialogRootState ( 
 else 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 - active = this . active + dialogGroup ( peer ) , 
 + active = this . active + dialogGroup ( sortableDialog ) , 
 archived = this . archived - sortableDialog 
 ) 
 } 
 @ @ - 77 , 7 + 112 , 7 @ @ private final case class DialogRootState ( 
 
 copy ( 
 activePeers = this . activePeers - sortableDialog , 
 - active = this . active mapValues ( _ - peer ) , 
 + active = this . active mapValues ( _ - sortableDialog ) , 
 archived = this . archived + sortableDialog 
 ) 
 } 
 @ @ - 87 , 29 + 122 , 41 @ @ private final case class DialogRootState ( 
 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 - active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( peer , isFavourite = true ) , 
 + active = this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 archived = this . archived - sortableDialog 
 ) 
 } 
 
 - private def withUnfavouritedPeer ( peer : Peer ) = 
 + private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 copy ( 
 active = 
 - ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( peer ) ) . filter { 
 + ( this . active . mapValues ( _ . filterNot ( _ = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false 
 case _ ⇒ true 
 } 
 ) 
 + } 
 
 - private def dialogGroup ( peer : Peer , isFavourite : Boolean = false ) = { 
 - val group = ( isFavourite , peer . typ ) match { 
 + private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = 
 + copy ( 
 + active = this . active map { 
 + case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) 
 + case other ⇒ other 
 + } , 
 + activePeers = this . activePeers + + sortableDialogs 
 + ) 
 + 
 + private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { 
 + val group = ( isFavourite , sortableDialog . peer . typ ) match { 
 case ( true , _ ) ⇒ DialogGroupType . Favourites 
 case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages 
 case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups 
 case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 } 
 
 - group → ( this . active . getOrElse ( group , Set . empty ) + peer ) 
 + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . ordering ) ) + sortableDialog ) 
 } 
 } 
 
 @ @ - 121 , 7 + 168 , 8 @ @ object DialogRoot { 
 45012 → classOf [ DialogRootEvents . Favourited ] , 
 45013 → classOf [ DialogRootEvents . Shown ] , 
 45014 → classOf [ DialogRootEvents . Unarchived ] , 
 - 45015 → classOf [ DialogRootEvents . Unfavourited ] 
 + 45015 → classOf [ DialogRootEvents . Unfavourited ] , 
 + 45016 → classOf [ DialogRootStateSnapshot ] 
 ) 
 } 
 
 @ @ - 170 , 7 + 218 , 10 @ @ private trait DialogRootQueryHandlers { 
 } 
 } 
 
 - private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Processor [ DialogRootState , DialogRootEvent ] with DialogRootQueryHandlers { 
 + private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) 
 + extends Processor [ DialogRootState , DialogRootEvent ] 
 + with IncrementalSnapshots [ DialogRootState , DialogRootEvent ] 
 + with DialogRootQueryHandlers { 
 import DialogRootEvents . _ 
 import DialogRootQueries . _ 
 import DialogRootCommands . _ 
 @ @ - 182 , 14 + 233 , 7 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 override def persistenceId : String = s " DialogRoot _ $ userId " 
 
 - override protected def getInitialState : DialogRootState = DialogRootState ( 
 - Map ( 
 - DialogGroupType . DirectMessages → Set . empty , 
 - DialogGroupType . Groups → Set . empty 
 - ) , 
 - SortedSet . empty ( SortableDialog . ordering ) , 
 - SortedSet . empty ( SortableDialog . ordering ) 
 - ) 
 + override protected def getInitialState : DialogRootState = DialogRootState . initial 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ getCounter ( ) 
 @ @ - 282 , 7 + 326 , 7 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 
 - private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( peer ) ) 
 + private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( SortableDialog ( Instant . MIN , peer ) ) ) 
 
 private def dialogShown ( peer : Peer ) : Boolean = state . activePeers . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 
 @ @ - 306 , 8 + 350 , 8 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { 
 val infosFutures = 
 state . active map { 
 - case ( group , peers ) ⇒ 
 - FutureExt . ftraverse ( peers . toSeq ) ( getInfo ) 
 + case ( group , sortableDialogs ) ⇒ 
 + FutureExt . ftraverse ( sortableDialogs . toSeq ) ( sd ⇒ getInfo ( sd . peer ) ) 
 . map ( infos ⇒ DialogGroup ( group , infos . map ( _ . getInfo ) ) ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 652fad2 . . cf67226 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 - import im . actor . server . dialog . DialogCommands . SendMessage 
 + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } 
 import im . actor . server . model . { Peer , PeerType } 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . UpdateChatGroupsChanged 
 @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 override def persistenceId : String = s " DialogRoot _ $ userId " 
 
 - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) 
 + override protected def getInitialState : DialogRootState = DialogRootState ( 
 + Map ( 
 + DialogGroupType . DirectMessages → Set . empty , 
 + DialogGroupType . Groups → Set . empty 
 + ) , 
 + SortedSet . empty ( SortableDialog . ordering ) , 
 + SortedSet . empty ( SortableDialog . ordering ) 
 + ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ getCounter ( ) 
 @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 override protected def handleCommand : Receive = { 
 - case sm : SendMessage ⇒ 
 - needShowDialog ( sm ) match { 
 + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ 
 + needShowDialog ( dc ) match { 
 case Some ( peer ) ⇒ 
 val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) 
 
 persist ( e ) { _ ⇒ 
 commit ( e ) 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 sendChatGroupsChanged ( ) 
 } 
 case None ⇒ 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 } 
 case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) 
 case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) 
 @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = archive $ { state . activePeers } " ) 
 - 
 if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) 
 else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - println ( s " = = = archive result $ { state . activePeers } " ) 
 - 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = unarchive $ { state . activePeers } " ) 
 - 
 if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) 
 else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - 
 - println ( s " = = = unarchive result $ { state . activePeers } " ) 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 } 
 
 - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { 
 - val checkPeer = 
 - sm . getOrigin . typ match { 
 - case PeerType . Group ⇒ sm . getDest 
 - case PeerType . Private ⇒ 
 - if ( selfPeer = = sm . getDest ) sm . getOrigin 
 - else sm . getDest 
 - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 - } 
 + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { 
 + val checkPeerOpt = cmd match { 
 + case sm : SendMessage ⇒ 
 + Some ( sm . getOrigin . typ match { 
 + case PeerType . Group ⇒ sm . getDest 
 + case PeerType . Private ⇒ 
 + if ( selfPeer = = sm . getDest ) sm . getOrigin 
 + else sm . getDest 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } ) 
 + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) 
 + case _ ⇒ None 
 + } 
 
 - if ( dialogShown ( checkPeer ) ) None 
 - else Some ( checkPeer ) 
 + checkPeerOpt flatMap { checkPeer ⇒ 
 + if ( dialogShown ( checkPeer ) ) None 
 + else Some ( checkPeer ) 
 + } 
 } 
 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 17e13c3 . . 7d8f59b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { 
 final case class BotCommandAlreadyExists ( slashCommand : String ) 
 extends UserError ( s " Bot command already exists : $ slashCommand " ) 
 
 - final case object ContactNotFound extends UserError ( " Contact not found " ) 
 + case object ContactNotFound extends UserError ( " Contact not found " ) 
 
 }
