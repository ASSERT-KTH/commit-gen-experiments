BLEU SCORE: 0.18798317647335086

TEST MSG: fix ( server ) : restrict creation of dialogs with unexistent users and groups
GENERATED MSG: feat ( server ) : UpdateCountersChanged on sends and reads

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index a6a0bf0 . . 8238406 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 12 , 7 + 12 , 7 @ @ import im . actor . serialization . ActorSerializer < nl > import im . actor . server . cqrs . ProcessorState < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } < nl > - import im . actor . server . persist . { HistoryMessageRepo , DialogRepo } < nl > + import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo , DialogRepo } < nl > import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > @ @ - 206 , 7 + 206 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > - _ ← DialogRepo . create ( dialog ) < nl > + exists ← peer . ` type ` match { < nl > + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > + } < nl > + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > } yield dialog < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala < nl > index 2b0cdca . . 1c0250b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala < nl > @ @ - 53 , 7 + 53 , 7 @ @ private final class LocalNamesMigrator ( promise : Promise [ Unit ] , ownerUserId : Int , < nl > < nl > db . run ( for { < nl > contact ← persist . contact . UserContactRepo . find ( ownerUserId , contactUserId ) < nl > - user ← persist . UserRepo . find ( contactUserId ) . headOption < nl > + user ← persist . UserRepo . find ( contactUserId ) < nl > } yield ( contact , user ) ) foreach { < nl > case ( Some ( contact ) , Some ( user ) ) ⇒ < nl > ( if ( contact . name . contains ( user . name ) ) { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala < nl > index 6ecd780 . . 7f7161d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala < nl > @ @ - 59 , 7 + 59 , 7 @ @ private final class UserMigrator ( promise : Promise [ Unit ] , userId : Int , db : Databa < nl > override def persistenceId = UserOffice . persistenceIdFor ( userId ) < nl > < nl > def migrate ( ) : Unit = { < nl > - db . run ( p . UserRepo . find ( userId ) . headOption ) foreach { < nl > + db . run ( p . UserRepo . find ( userId ) ) foreach { < nl > case Some ( user ) ⇒ < nl > db . run ( for { < nl > avatarOpt ← p . AvatarDataRepo . findByUserId ( userId ) . headOption < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > index 2a458b0 . . a04894b 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala < nl > @ @ - 83 , 7 + 83 , 7 @ @ object UserRepo { < nl > def fetchPeople = activeHumanUsers . result < nl > < nl > def find ( id : Int ) = < nl > - byIdC ( id ) . result < nl > + byIdC ( id ) . result . headOption < nl > < nl > def findName ( id : Int ) = < nl > nameById ( id ) . result . headOption < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > index e069e0f . . 1b5d822 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > @ @ - 23 , 7 + 23 , 7 @ @ object PeerHelpers { < nl > outPeer . ` type ` match { < nl > case ApiPeerType . Private ⇒ < nl > ( for { < nl > - optUser ← persist . UserRepo . find ( outPeer . id ) . headOption < nl > + optUser ← persist . UserRepo . find ( outPeer . id ) < nl > usererrOrUser ← validUser ( optUser ) < nl > hasherrOrUser ← DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) < nl > } yield hasherrOrUser ) . flatMap { < nl > @ @ - 176 , 7 + 176 , 7 @ @ object PeerHelpers { < nl > ec : ExecutionContext < nl > ) : DBIO [ Option [ Boolean ] ] = { < nl > for { < nl > - userOpt ← persist . UserRepo . find ( userId ) . headOption < nl > + userOpt ← persist . UserRepo . find ( userId ) < nl > } yield { < nl > userOpt map ( u ⇒ ACLUtils . userAccessHash ( client . authId , u . id , u . accessSalt ) = = accessHash ) < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index eaceac0 . . 0096cb2 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 600 , 7 + 600 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( < nl > } < nl > < nl > private def signIn ( authId : Long , userId : Int , countryCode : String , clientData : ClientData ) = { < nl > - persist . UserRepo . find ( userId ) . headOption . flatMap { < nl > + persist . UserRepo . find ( userId ) . flatMap { < nl > case None ⇒ throw new Exception ( " Failed to retrieve user " ) < nl > case Some ( user ) ⇒ < nl > for { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > index 2c5351b . . 92e6e17 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala < nl > @ @ - 67 , 7 + 67 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > for { < nl > client ← authorizedClient ( clientData ) < nl > ( clientPhones , clientEmails ) ← fromFuture ( userExt . getContactRecordsSet ( client . userId ) ) < nl > - user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) . headOption ) < nl > + user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) ) < nl > optPhone ← fromDBIO ( persist . UserPhoneRepo . findByUserId ( client . userId ) . headOption ) < nl > optEmail ← fromDBIO ( persist . UserEmailRepo . findByUserId ( client . userId ) . headOption ) < nl > < nl > @ @ - 131 , 7 + 131 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > override def jhandleAddContact ( userId : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { < nl > val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ < nl > val action = ( for { < nl > - optUser ← persist . UserRepo . find ( userId ) . headOption < nl > + optUser ← persist . UserRepo . find ( userId ) < nl > optNumber ← optUser . map ( user ⇒ persist . UserPhoneRepo . findByUserId ( user . id ) . headOption ) . getOrElse ( DBIO . successful ( None ) ) < nl > } yield { < nl > ( optUser , optNumber map ( _ . number ) ) < nl > @ @ - 188 , 7 + 188 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > < nl > private def findByNumber ( rawNumber : String , client : AuthorizedClientData ) : EitherT [ DBIO , RpcError , Vector [ ApiUser ] ] = { < nl > for { < nl > - clientUser ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) . headOption ) < nl > + clientUser ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) ) < nl > ( clientPhones , _ ) ← fromFuture ( userExt . getContactRecordsSet ( client . userId ) ) < nl > optPhone ← fromDBIO ( persist . UserPhoneRepo . findByUserId ( client . userId ) . headOption map ( _ . filterNot ( p ⇒ clientPhones . contains ( p . number ) ) ) ) < nl > normalizedPhone ← point ( PhoneNumberUtils . normalizeStr ( rawNumber , clientUser . countryCode ) ) < nl > @ @ - 249 , 7 + 249 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) < nl > userPhones ← persist . UserPhoneRepo . findByNumbers ( phoneNumbers ) < nl > ignoredContactsIds ← persist . contact . UserContactRepo . findContactIdsAll ( user . id ) < nl > uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) < nl > - usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . UserRepo . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries < nl > + usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . UserRepo . find ( p . userId ) map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries < nl > } yield { < nl > usersPhones . foldLeft ( ( immutable . Seq . empty [ ( model . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { < nl > case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > index 0022cac . . 1a93dd8 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala < nl > @ @ - 32 , 7 + 32 , 7 @ @ final class UsersServiceImpl ( implicit actorSystem : ActorSystem ) extends UsersSer < nl > authorized ( clientData ) { implicit client ⇒ < nl > StringUtils . validName ( name ) match { < nl > case \ / - ( validName ) ⇒ < nl > - db . run ( persist . UserRepo . find ( userId ) . headOption ) flatMap { < nl > + db . run ( persist . UserRepo . find ( userId ) ) flatMap { < nl > case Some ( user ) ⇒ < nl > if ( accessHash = = ACLUtils . userAccessHash ( client . authId , user ) ) { < nl > val seqstateF = db . run ( persist . contact . UserContactRepo . find ( client . userId , userId ) ) flatMap { < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > index 6f21494 . . f14e87f 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala < nl > @ @ - 26 , 13 + 26 , 13 @ @ import scalaz . { - \ / , \ / - } < nl > trait PersistenceHelpers { < nl > implicit val timeout = Timeout ( 5 . seconds ) < nl > < nl > - def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) . head ) , timeout . duration ) < nl > + def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) ) , timeout . duration ) . get < nl > } < nl > < nl > trait UserStructExtensions { < nl > implicit class ExtUser ( user : ApiUser ) { < nl > def asModel ( ) ( implicit db : Database ) : model . User = < nl > - Await . result ( db . run ( persist . UserRepo . find ( user . id ) . head ) , 3 . seconds ) < nl > + Await . result ( db . run ( persist . UserRepo . find ( user . id ) ) , 3 . seconds ) . get < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > index 81e2188 . . b426652 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala < nl > @ @ - 192 , 7 + 192 , 7 @ @ final class ProfileServiceSpec < nl > } < nl > } < nl > < nl > - whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) . headOption ) ) { optUser ⇒ < nl > + whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) ) ) { optUser ⇒ < nl > optUser shouldBe defined < nl > optUser . get . about shouldEqual about < nl > } < nl > @ @ - 210 , 7 + 210 , 7 @ @ final class ProfileServiceSpec < nl > } < nl > } < nl > < nl > - whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) . headOption ) ) { optUser ⇒ < nl > + whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) ) ) { optUser ⇒ < nl > optUser shouldBe defined < nl > optUser . get . about shouldEqual None < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala b / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala < nl > index bee8d0f . . 60e6daa 100644 < nl > - - - a / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala < nl > + + + b / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala < nl > @ @ - 14 , 6 + 14 , 11 @ @ object ActorSerializer { < nl > private val map = new MapBuilder [ Int , Class [ _ ] ] . maximumWeightedCapacity ( 1024 ) . build ( ) < nl > private val reverseMap = new MapBuilder [ Class [ _ ] , Int ] . maximumWeightedCapacity ( 1024 ) . build ( ) < nl > < nl > + def clean ( ) : Unit = { < nl > + map . clear ( ) < nl > + reverseMap . clear ( ) < nl > + } < nl > + < nl > def register ( id : Int , clazz : Class [ _ ] ) : Unit = { < nl > if ( map . containsKey ( id ) ) { < nl > if ( Option ( reverseMap . get ( clazz ) ) ! = Some ( id ) ) < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index e99629d . . 75eab83 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 162 , 7 + 162 , 12 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > protected def messageRead ( group : Group , readerUserId : Int , readerAuthId : Long , date : Long , readDate : Long ) : Unit = { < nl > db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) foreach { _ ⇒ < nl > UserOffice . getAuthIds ( readerUserId ) map { authIds ⇒ < nl > - db . run ( persistAndPushUpdates ( authIds . toSet , UpdateMessageReadByMe ( groupPeerStruct ( groupId ) , date ) , None ) ) < nl > + val authIdsSet = authIds . toSet < nl > + for { < nl > + counterUpdate ← db . run ( getUpdateCountersChanged ( readerUserId ) ) < nl > + _ ← persistAndPushUpdatesF ( authIdsSet , UpdateMessageReadByMe ( groupPeerStruct ( groupId ) , date ) , None ) < nl > + _ ← persistAndPushUpdatesF ( authIdsSet , counterUpdate , None ) < nl > + } yield ( ) < nl > } < nl > } < nl > < nl > @ @ - 185 , 16 + 190 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm < nl > } < nl > < nl > val groupPeer = groupPeerStruct ( groupId ) < nl > - val update = UpdateMessageRead ( groupPeer , date , readDate ) < nl > - val memberIds = group . members . keySet < nl > + val memberIds = group . members . keys . toSeq < nl > < nl > - val authIdsF = Future . sequence ( memberIds . filterNot ( _ = = readerUserId ) map ( UserOffice . getAuthIds ( _ ) ) ) map ( _ . flatten . toSet ) < nl > - < nl > - ( for { < nl > - _ ← db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) < nl > - authIds ← authIdsF < nl > - _ ← db . run ( persistAndPushUpdates ( authIds , update , None ) ) < nl > - } yield ( ) ) onFailure { < nl > + Future . sequence ( memberIds . filterNot ( _ = = readerUserId ) map { id ⇒ < nl > + for { < nl > + authIds ← UserOffice . getAuthIds ( id ) < nl > + authIdsSet = authIds . toSet < nl > + _ ← db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) < nl > + updateCounters ← db . run ( getUpdateCountersChanged ( id ) ) < nl > + _ ← persistAndPushUpdatesF ( authIdsSet , updateCounters , None ) < nl > + _ ← persistAndPushUpdatesF ( authIdsSet , UpdateMessageRead ( groupPeer , date , readDate ) , None ) < nl > + } yield ( ) < nl > + } ) onFailure { < nl > case e ⇒ < nl > log . error ( e , " Failed to mark messages read " ) < nl > } < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > index 9320437 . . 28ab0d0 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > @ @ - 1 , 8 + 1 , 10 @ @ < nl > package im . actor . server . office < nl > < nl > + import im . actor . api . rpc . counters . { UpdateCountersChanged , AppCounters } < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { Peer , PeerType } < nl > import im . actor . server . models < nl > + import im . actor . server . { persist ⇒ p } < nl > import im . actor . server . util . ContactsUtils < nl > import slick . dbio . DBIO < nl > < nl > @ @ - 46 , 4 + 48 , 10 @ @ trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ < nl > protected def privatePeerStruct ( userId : Int ) : Peer = Peer ( PeerType . Private , userId ) < nl > < nl > protected def groupPeerStruct ( groupId : Int ) : Peer = Peer ( PeerType . Group , groupId ) < nl > + < nl > + protected def getUpdateCountersChanged ( userId : Int ) : DBIO [ UpdateCountersChanged ] = for { < nl > + unreadTotal ← p . HistoryMessage . getUnreadTotal ( userId ) < nl > + unreadOpt = if ( unreadTotal = = 0 ) None else Some ( unreadTotal ) < nl > + } yield UpdateCountersChanged ( AppCounters ( unreadOpt ) ) < nl > + < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 697cb39 . . 6844299 100644 < nl > - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 126 , 6 + 126 , 8 @ @ private [ user ] trait UserCommandHandlers { < nl > for { < nl > senderUser ← getUserUnsafe ( senderUserId ) < nl > pushText ← getPushText ( message , senderUser , userId ) < nl > + counterUpdate ← getUpdateCountersChanged ( userId ) < nl > + _ ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , counterUpdate , None ) < nl > seqs ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , update , Some ( pushText ) , isFat ) < nl > } yield seqs < nl > } < nl > @ @ - 201 , 6 + 203 , 8 @ @ private [ user ] trait UserCommandHandlers { < nl > val update = UpdateMessageRead ( Peer ( PeerType . Private , readerUserId ) , date , readDate ) < nl > val readerUpdate = UpdateMessageReadByMe ( Peer ( PeerType . Private , userId ) , date ) < nl > for { < nl > + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) < nl > + _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None ) < nl > _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , None ) < nl > _ ← UserOffice . broadcastUserUpdate ( readerUserId , readerUpdate , None ) / / todo : may be replace with MessageReadOwn < nl > } yield { < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > index fc7dd0d . . 37aed9a 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala < nl > @ @ - 117 , 6 + 117 , 15 @ @ object HistoryMessage { < nl > . length < nl > . result < nl > < nl > + def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = { < nl > + val query = ( for { < nl > + d ← Dialog . dialogs . filter ( d ⇒ d . userId = = = userId ) < nl > + m ← notDeletedMessages . filter ( _ . senderUserId = ! = userId ) < nl > + if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt < nl > + } yield m . date ) . length < nl > + query . result < nl > + } < nl > + < nl > def haveMessagesBetween ( userId : Int , peer : models . Peer , minDate : DateTime , maxDate : DateTime ) = < nl > notDeletedMessages < nl > . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . toInt & & m . peerId = = = peer . id ) < nl > diff - - git a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > index 128c22a . . ad5439e 100644 < nl > - - - a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > + + + b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala < nl > @ @ - 383 , 6 + 383 , 7 @ @ object SeqUpdatesManager { < nl > case api . weak . UpdateUserOnline ( userId ) ⇒ singleUser ( userId ) < nl > case api . calls . UpdateCallRing ( user , _ ) ⇒ singleUser ( user . id ) < nl > case api . calls . UpdateCallEnd ( _ ) ⇒ empty < nl > + case api . counters . UpdateCountersChanged ( _ ) ⇒ empty < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > index 679056c . . e79a181 100644 < nl > - - - a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > + + + b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala < nl > @ @ - 2 , 6 + 2 , 8 @ @ package im . actor . server . push < nl > < nl > import java . util . concurrent . TimeUnit < nl > < nl > + import im . actor . server . persist . HistoryMessage < nl > + < nl > import scala . concurrent . { Future , ExecutionContext } < nl > import scala . concurrent . duration . _ < nl > import scala . util . { Failure , Success } < nl > @ @ - 238 , 7 + 240 , 7 @ @ class SeqUpdatesManagerActor ( < nl > for { < nl > optUserId ← p . AuthId . findUserId ( authId ) < nl > unread ← optUserId . map { userId ⇒ < nl > - unreadTotal ( userId ) < nl > + HistoryMessage . getUnreadTotal ( userId ) < nl > } getOrElse DBIO . successful ( 0 ) < nl > _ = applePusher . deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer , unread ) < nl > } yield ( ) < nl > @ @ - 276 , 12 + 278 , 4 @ @ class SeqUpdatesManagerActor ( < nl > < nl > private def sequenceState ( sequence : Int , state : Array [ Byte ] ) : SeqState = SeqState ( sequence , ByteString . copyFrom ( state ) ) < nl > < nl > - private def unreadTotal ( userId : Int ) : DBIO [ Int ] = { < nl > - val query = ( for { < nl > - d ← p . Dialog . dialogs . filter ( d ⇒ d . userId = = = userId ) < nl > - m ← p . HistoryMessage . notDeletedMessages . filter ( _ . senderUserId = ! = userId ) < nl > - if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt < nl > - } yield m . date ) . length < nl > - query . result < nl > - } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > index 4464391 . . 3dd68da 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala < nl > @ @ - 5 , 6 + 5 , 7 @ @ import akka . contrib . pattern . DistributedPubSubExtension < nl > import akka . stream . ActorMaterializer < nl > import im . actor . server . api . { CommonSerialization , ActorSpecHelpers } < nl > import im . actor . server . api . rpc . service . ServiceSpecHelpers < nl > + import im . actor . server . commons . serialization . ActorSerializer < nl > import org . scalatest . concurrent . ScalaFutures < nl > import org . scalatest . time . { Seconds , Span } < nl > import org . scalatest . { FlatSpecLike , Matchers } < nl > @ @ - 38 , 6 + 39 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { < nl > < nl > override def afterAll ( ) : Unit = { < nl > super . afterAll ( ) < nl > + ActorSerializer . clean ( ) < nl > db . close ( ) < nl > ds . close ( ) < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 97aa4bd . . 63727ef 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > + import im . actor . api . rpc . counters . UpdateCountersChanged < nl > + < nl > import scala . concurrent . Future < nl > import scala . util . Random < nl > < nl > @ @ - 97 , 14 + 99 , 17 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I < nl > } < nl > < nl > whenReady ( db . run ( persist . sequence . SeqUpdate . find ( user2AuthId ) ) ) { updates ⇒ < nl > - updates . length shouldEqual 1 < nl > + updates . length shouldEqual 2 < nl > < nl > - val update = updates . head < nl > + val update = updates ( 0 ) < nl > update . header shouldEqual UpdateMessage . header < nl > val seqUpdate = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( update . serializedData ) ) . right . toOption . get < nl > seqUpdate . peer shouldEqual Peer ( PeerType . Private , user . id ) < nl > seqUpdate . randomId shouldEqual randomId < nl > seqUpdate . senderUserId shouldEqual user . id < nl > + < nl > + val countersUpdate = updates ( 1 ) < nl > + countersUpdate . header shouldEqual UpdateCountersChanged . header < nl > } < nl > } < nl > < nl > @ @ - 151 , 9 + 156 , 12 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I < nl > val resp = respOption . get < nl > < nl > val updates = resp . updates < nl > - updates . length shouldEqual 1 < nl > + updates . length shouldEqual 2 < nl > + < nl > + val countersUpdate = UpdateCountersChanged . parseFrom ( CodedInputStream . newInstance ( updates ( 0 ) . update ) ) < nl > + countersUpdate should matchPattern { case Right ( _ : UpdateCountersChanged ) ⇒ } < nl > < nl > - val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > + val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates ( 1 ) . update ) ) < nl > message should matchPattern { case Right ( _ : UpdateMessage ) ⇒ } < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index a6a0bf0 . . 8238406 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 12 , 7 + 12 , 7 @ @ import im . actor . serialization . ActorSerializer 
 import im . actor . server . cqrs . ProcessorState 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } 
 - import im . actor . server . persist . { HistoryMessageRepo , DialogRepo } 
 + import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo , DialogRepo } 
 import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 @ @ - 206 , 7 + 206 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 - _ ← DialogRepo . create ( dialog ) 
 + exists ← peer . ` type ` match { 
 + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 + } 
 + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 } yield dialog 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala 
 index 2b0cdca . . 1c0250b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / migrations / LocalNamesMigrator . scala 
 @ @ - 53 , 7 + 53 , 7 @ @ private final class LocalNamesMigrator ( promise : Promise [ Unit ] , ownerUserId : Int , 
 
 db . run ( for { 
 contact ← persist . contact . UserContactRepo . find ( ownerUserId , contactUserId ) 
 - user ← persist . UserRepo . find ( contactUserId ) . headOption 
 + user ← persist . UserRepo . find ( contactUserId ) 
 } yield ( contact , user ) ) foreach { 
 case ( Some ( contact ) , Some ( user ) ) ⇒ 
 ( if ( contact . name . contains ( user . name ) ) { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala 
 index 6ecd780 . . 7f7161d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserMigrator . scala 
 @ @ - 59 , 7 + 59 , 7 @ @ private final class UserMigrator ( promise : Promise [ Unit ] , userId : Int , db : Databa 
 override def persistenceId = UserOffice . persistenceIdFor ( userId ) 
 
 def migrate ( ) : Unit = { 
 - db . run ( p . UserRepo . find ( userId ) . headOption ) foreach { 
 + db . run ( p . UserRepo . find ( userId ) ) foreach { 
 case Some ( user ) ⇒ 
 db . run ( for { 
 avatarOpt ← p . AvatarDataRepo . findByUserId ( userId ) . headOption 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 index 2a458b0 . . a04894b 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / UserRepo . scala 
 @ @ - 83 , 7 + 83 , 7 @ @ object UserRepo { 
 def fetchPeople = activeHumanUsers . result 
 
 def find ( id : Int ) = 
 - byIdC ( id ) . result 
 + byIdC ( id ) . result . headOption 
 
 def findName ( id : Int ) = 
 nameById ( id ) . result . headOption 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 index e069e0f . . 1b5d822 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 @ @ - 23 , 7 + 23 , 7 @ @ object PeerHelpers { 
 outPeer . ` type ` match { 
 case ApiPeerType . Private ⇒ 
 ( for { 
 - optUser ← persist . UserRepo . find ( outPeer . id ) . headOption 
 + optUser ← persist . UserRepo . find ( outPeer . id ) 
 usererrOrUser ← validUser ( optUser ) 
 hasherrOrUser ← DBIO . successful ( usererrOrUser . map ( validUserAccessHash ( outPeer . accessHash , _ ) ) ) 
 } yield hasherrOrUser ) . flatMap { 
 @ @ - 176 , 7 + 176 , 7 @ @ object PeerHelpers { 
 ec : ExecutionContext 
 ) : DBIO [ Option [ Boolean ] ] = { 
 for { 
 - userOpt ← persist . UserRepo . find ( userId ) . headOption 
 + userOpt ← persist . UserRepo . find ( userId ) 
 } yield { 
 userOpt map ( u ⇒ ACLUtils . userAccessHash ( client . authId , u . id , u . accessSalt ) = = accessHash ) 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index eaceac0 . . 0096cb2 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 600 , 7 + 600 , 7 @ @ final class AuthServiceImpl ( val activationContext : CodeActivation ) ( 
 } 
 
 private def signIn ( authId : Long , userId : Int , countryCode : String , clientData : ClientData ) = { 
 - persist . UserRepo . find ( userId ) . headOption . flatMap { 
 + persist . UserRepo . find ( userId ) . flatMap { 
 case None ⇒ throw new Exception ( " Failed to retrieve user " ) 
 case Some ( user ) ⇒ 
 for { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 index 2c5351b . . 92e6e17 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / contacts / ContactsServiceImpl . scala 
 @ @ - 67 , 7 + 67 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 for { 
 client ← authorizedClient ( clientData ) 
 ( clientPhones , clientEmails ) ← fromFuture ( userExt . getContactRecordsSet ( client . userId ) ) 
 - user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) . headOption ) 
 + user ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) ) 
 optPhone ← fromDBIO ( persist . UserPhoneRepo . findByUserId ( client . userId ) . headOption ) 
 optEmail ← fromDBIO ( persist . UserEmailRepo . findByUserId ( client . userId ) . headOption ) 
 
 @ @ - 131 , 7 + 131 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 override def jhandleAddContact ( userId : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseSeq ] ] = { 
 val authorizedAction = requireAuth ( clientData ) . map { implicit client ⇒ 
 val action = ( for { 
 - optUser ← persist . UserRepo . find ( userId ) . headOption 
 + optUser ← persist . UserRepo . find ( userId ) 
 optNumber ← optUser . map ( user ⇒ persist . UserPhoneRepo . findByUserId ( user . id ) . headOption ) . getOrElse ( DBIO . successful ( None ) ) 
 } yield { 
 ( optUser , optNumber map ( _ . number ) ) 
 @ @ - 188 , 7 + 188 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 
 private def findByNumber ( rawNumber : String , client : AuthorizedClientData ) : EitherT [ DBIO , RpcError , Vector [ ApiUser ] ] = { 
 for { 
 - clientUser ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) . headOption ) 
 + clientUser ← fromDBIOOption ( CommonErrors . UserNotFound ) ( persist . UserRepo . find ( client . userId ) ) 
 ( clientPhones , _ ) ← fromFuture ( userExt . getContactRecordsSet ( client . userId ) ) 
 optPhone ← fromDBIO ( persist . UserPhoneRepo . findByUserId ( client . userId ) . headOption map ( _ . filterNot ( p ⇒ clientPhones . contains ( p . number ) ) ) ) 
 normalizedPhone ← point ( PhoneNumberUtils . normalizeStr ( rawNumber , clientUser . countryCode ) ) 
 @ @ - 249 , 7 + 249 , 7 @ @ class ContactsServiceImpl ( implicit actorSystem : ActorSystem ) 
 userPhones ← persist . UserPhoneRepo . findByNumbers ( phoneNumbers ) 
 ignoredContactsIds ← persist . contact . UserContactRepo . findContactIdsAll ( user . id ) 
 uniquePhones = userPhones . filter ( p ⇒ ! ignoredContactsIds . contains ( p . userId ) ) 
 - usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . UserRepo . find ( p . userId ) . headOption map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries 
 + usersPhones ← DBIO . sequence ( uniquePhones map ( p ⇒ persist . UserRepo . find ( p . userId ) map ( _ . map ( ( _ , p . number ) ) ) ) ) map ( _ . flatten ) / / TODO : # perf lots of sql queries 
 } yield { 
 usersPhones . foldLeft ( ( immutable . Seq . empty [ ( model . User , Long , Option [ String ] ) ] , immutable . Set . empty [ Int ] , immutable . Set . empty [ Long ] ) ) { 
 case ( ( usersPhonesNames , newContactIds , registeredPhones ) , ( user , phone ) ) ⇒ 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 index 0022cac . . 1a93dd8 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / users / UsersServiceImpl . scala 
 @ @ - 32 , 7 + 32 , 7 @ @ final class UsersServiceImpl ( implicit actorSystem : ActorSystem ) extends UsersSer 
 authorized ( clientData ) { implicit client ⇒ 
 StringUtils . validName ( name ) match { 
 case \ / - ( validName ) ⇒ 
 - db . run ( persist . UserRepo . find ( userId ) . headOption ) flatMap { 
 + db . run ( persist . UserRepo . find ( userId ) ) flatMap { 
 case Some ( user ) ⇒ 
 if ( accessHash = = ACLUtils . userAccessHash ( client . authId , user ) ) { 
 val seqstateF = db . run ( persist . contact . UserContactRepo . find ( client . userId , userId ) ) flatMap { 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 index 6f21494 . . f14e87f 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / ServiceSpecHelpers . scala 
 @ @ - 26 , 13 + 26 , 13 @ @ import scalaz . { - \ / , \ / - } 
 trait PersistenceHelpers { 
 implicit val timeout = Timeout ( 5 . seconds ) 
 
 - def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) . head ) , timeout . duration ) 
 + def getUserModel ( userId : Int ) ( implicit db : Database ) = Await . result ( db . run ( persist . UserRepo . find ( userId ) ) , timeout . duration ) . get 
 } 
 
 trait UserStructExtensions { 
 implicit class ExtUser ( user : ApiUser ) { 
 def asModel ( ) ( implicit db : Database ) : model . User = 
 - Await . result ( db . run ( persist . UserRepo . find ( user . id ) . head ) , 3 . seconds ) 
 + Await . result ( db . run ( persist . UserRepo . find ( user . id ) ) , 3 . seconds ) . get 
 } 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 index 81e2188 . . b426652 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ProfileServiceSpec . scala 
 @ @ - 192 , 7 + 192 , 7 @ @ final class ProfileServiceSpec 
 } 
 } 
 
 - whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) . headOption ) ) { optUser ⇒ 
 + whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) ) ) { optUser ⇒ 
 optUser shouldBe defined 
 optUser . get . about shouldEqual about 
 } 
 @ @ - 210 , 7 + 210 , 7 @ @ final class ProfileServiceSpec 
 } 
 } 
 
 - whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) . headOption ) ) { optUser ⇒ 
 + whenReady ( db . run ( persist . UserRepo . find ( user1 . id ) ) ) { optUser ⇒ 
 optUser shouldBe defined 
 optUser . get . about shouldEqual None 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala b / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala 
 index bee8d0f . . 60e6daa 100644 
 - - - a / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala 
 + + + b / actor - server / actor - commons - base / src / main / scala / im / actor / server / commons / serialization / ActorSerializer . scala 
 @ @ - 14 , 6 + 14 , 11 @ @ object ActorSerializer { 
 private val map = new MapBuilder [ Int , Class [ _ ] ] . maximumWeightedCapacity ( 1024 ) . build ( ) 
 private val reverseMap = new MapBuilder [ Class [ _ ] , Int ] . maximumWeightedCapacity ( 1024 ) . build ( ) 
 
 + def clean ( ) : Unit = { 
 + map . clear ( ) 
 + reverseMap . clear ( ) 
 + } 
 + 
 def register ( id : Int , clazz : Class [ _ ] ) : Unit = { 
 if ( map . containsKey ( id ) ) { 
 if ( Option ( reverseMap . get ( clazz ) ) ! = Some ( id ) ) 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index e99629d . . 75eab83 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 162 , 7 + 162 , 12 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 protected def messageRead ( group : Group , readerUserId : Int , readerAuthId : Long , date : Long , readDate : Long ) : Unit = { 
 db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) foreach { _ ⇒ 
 UserOffice . getAuthIds ( readerUserId ) map { authIds ⇒ 
 - db . run ( persistAndPushUpdates ( authIds . toSet , UpdateMessageReadByMe ( groupPeerStruct ( groupId ) , date ) , None ) ) 
 + val authIdsSet = authIds . toSet 
 + for { 
 + counterUpdate ← db . run ( getUpdateCountersChanged ( readerUserId ) ) 
 + _ ← persistAndPushUpdatesF ( authIdsSet , UpdateMessageReadByMe ( groupPeerStruct ( groupId ) , date ) , None ) 
 + _ ← persistAndPushUpdatesF ( authIdsSet , counterUpdate , None ) 
 + } yield ( ) 
 } 
 } 
 
 @ @ - 185 , 16 + 190 , 18 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with GroupComm 
 } 
 
 val groupPeer = groupPeerStruct ( groupId ) 
 - val update = UpdateMessageRead ( groupPeer , date , readDate ) 
 - val memberIds = group . members . keySet 
 + val memberIds = group . members . keys . toSeq 
 
 - val authIdsF = Future . sequence ( memberIds . filterNot ( _ = = readerUserId ) map ( UserOffice . getAuthIds ( _ ) ) ) map ( _ . flatten . toSet ) 
 - 
 - ( for { 
 - _ ← db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) 
 - authIds ← authIdsF 
 - _ ← db . run ( persistAndPushUpdates ( authIds , update , None ) ) 
 - } yield ( ) ) onFailure { 
 + Future . sequence ( memberIds . filterNot ( _ = = readerUserId ) map { id ⇒ 
 + for { 
 + authIds ← UserOffice . getAuthIds ( id ) 
 + authIdsSet = authIds . toSet 
 + _ ← db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . group ( groupId ) , new DateTime ( date ) ) ) 
 + updateCounters ← db . run ( getUpdateCountersChanged ( id ) ) 
 + _ ← persistAndPushUpdatesF ( authIdsSet , updateCounters , None ) 
 + _ ← persistAndPushUpdatesF ( authIdsSet , UpdateMessageRead ( groupPeer , date , readDate ) , None ) 
 + } yield ( ) 
 + } ) onFailure { 
 case e ⇒ 
 log . error ( e , " Failed to mark messages read " ) 
 } 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 index 9320437 . . 28ab0d0 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 @ @ - 1 , 8 + 1 , 10 @ @ 
 package im . actor . server . office 
 
 + import im . actor . api . rpc . counters . { UpdateCountersChanged , AppCounters } 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { Peer , PeerType } 
 import im . actor . server . models 
 + import im . actor . server . { persist ⇒ p } 
 import im . actor . server . util . ContactsUtils 
 import slick . dbio . DBIO 
 
 @ @ - 46 , 4 + 48 , 10 @ @ trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ 
 protected def privatePeerStruct ( userId : Int ) : Peer = Peer ( PeerType . Private , userId ) 
 
 protected def groupPeerStruct ( groupId : Int ) : Peer = Peer ( PeerType . Group , groupId ) 
 + 
 + protected def getUpdateCountersChanged ( userId : Int ) : DBIO [ UpdateCountersChanged ] = for { 
 + unreadTotal ← p . HistoryMessage . getUnreadTotal ( userId ) 
 + unreadOpt = if ( unreadTotal = = 0 ) None else Some ( unreadTotal ) 
 + } yield UpdateCountersChanged ( AppCounters ( unreadOpt ) ) 
 + 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 697cb39 . . 6844299 100644 
 - - - a / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - cqrs / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 126 , 6 + 126 , 8 @ @ private [ user ] trait UserCommandHandlers { 
 for { 
 senderUser ← getUserUnsafe ( senderUserId ) 
 pushText ← getPushText ( message , senderUser , userId ) 
 + counterUpdate ← getUpdateCountersChanged ( userId ) 
 + _ ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , counterUpdate , None ) 
 seqs ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , update , Some ( pushText ) , isFat ) 
 } yield seqs 
 } 
 @ @ - 201 , 6 + 203 , 8 @ @ private [ user ] trait UserCommandHandlers { 
 val update = UpdateMessageRead ( Peer ( PeerType . Private , readerUserId ) , date , readDate ) 
 val readerUpdate = UpdateMessageReadByMe ( Peer ( PeerType . Private , userId ) , date ) 
 for { 
 + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) 
 + _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None ) 
 _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , None ) 
 _ ← UserOffice . broadcastUserUpdate ( readerUserId , readerUpdate , None ) / / todo : may be replace with MessageReadOwn 
 } yield { 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 index fc7dd0d . . 37aed9a 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessage . scala 
 @ @ - 117 , 6 + 117 , 15 @ @ object HistoryMessage { 
 . length 
 . result 
 
 + def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = { 
 + val query = ( for { 
 + d ← Dialog . dialogs . filter ( d ⇒ d . userId = = = userId ) 
 + m ← notDeletedMessages . filter ( _ . senderUserId = ! = userId ) 
 + if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt 
 + } yield m . date ) . length 
 + query . result 
 + } 
 + 
 def haveMessagesBetween ( userId : Int , peer : models . Peer , minDate : DateTime , maxDate : DateTime ) = 
 notDeletedMessages 
 . filter ( m ⇒ m . userId = = = userId & & m . peerType = = = peer . typ . toInt & & m . peerId = = = peer . id ) 
 diff - - git a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 index 128c22a . . ad5439e 100644 
 - - - a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 + + + b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManager . scala 
 @ @ - 383 , 6 + 383 , 7 @ @ object SeqUpdatesManager { 
 case api . weak . UpdateUserOnline ( userId ) ⇒ singleUser ( userId ) 
 case api . calls . UpdateCallRing ( user , _ ) ⇒ singleUser ( user . id ) 
 case api . calls . UpdateCallEnd ( _ ) ⇒ empty 
 + case api . counters . UpdateCountersChanged ( _ ) ⇒ empty 
 } 
 } 
 
 diff - - git a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 index 679056c . . e79a181 100644 
 - - - a / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 + + + b / actor - server / actor - push / src / main / scala / im / actor / server / push / SeqUpdatesManagerActor . scala 
 @ @ - 2 , 6 + 2 , 8 @ @ package im . actor . server . push 
 
 import java . util . concurrent . TimeUnit 
 
 + import im . actor . server . persist . HistoryMessage 
 + 
 import scala . concurrent . { Future , ExecutionContext } 
 import scala . concurrent . duration . _ 
 import scala . util . { Failure , Success } 
 @ @ - 238 , 7 + 240 , 7 @ @ class SeqUpdatesManagerActor ( 
 for { 
 optUserId ← p . AuthId . findUserId ( authId ) 
 unread ← optUserId . map { userId ⇒ 
 - unreadTotal ( userId ) 
 + HistoryMessage . getUnreadTotal ( userId ) 
 } getOrElse DBIO . successful ( 0 ) 
 _ = applePusher . deliverApplePush ( creds , authId , seqUpdate . seq , pushText , originPeer , unread ) 
 } yield ( ) 
 @ @ - 276 , 12 + 278 , 4 @ @ class SeqUpdatesManagerActor ( 
 
 private def sequenceState ( sequence : Int , state : Array [ Byte ] ) : SeqState = SeqState ( sequence , ByteString . copyFrom ( state ) ) 
 
 - private def unreadTotal ( userId : Int ) : DBIO [ Int ] = { 
 - val query = ( for { 
 - d ← p . Dialog . dialogs . filter ( d ⇒ d . userId = = = userId ) 
 - m ← p . HistoryMessage . notDeletedMessages . filter ( _ . senderUserId = ! = userId ) 
 - if m . userId = = = d . userId & & m . peerType = = = d . peerType & & m . peerId = = = d . peerId & & m . date > d . ownerLastReadAt 
 - } yield m . date ) . length 
 - query . result 
 - } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 index 4464391 . . 3dd68da 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / BaseAppSuite . scala 
 @ @ - 5 , 6 + 5 , 7 @ @ import akka . contrib . pattern . DistributedPubSubExtension 
 import akka . stream . ActorMaterializer 
 import im . actor . server . api . { CommonSerialization , ActorSpecHelpers } 
 import im . actor . server . api . rpc . service . ServiceSpecHelpers 
 + import im . actor . server . commons . serialization . ActorSerializer 
 import org . scalatest . concurrent . ScalaFutures 
 import org . scalatest . time . { Seconds , Span } 
 import org . scalatest . { FlatSpecLike , Matchers } 
 @ @ - 38 , 6 + 39 , 7 @ @ abstract class BaseAppSuite ( _ system : ActorSystem = { 
 
 override def afterAll ( ) : Unit = { 
 super . afterAll ( ) 
 + ActorSerializer . clean ( ) 
 db . close ( ) 
 ds . close ( ) 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 97aa4bd . . 63727ef 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 + import im . actor . api . rpc . counters . UpdateCountersChanged 
 + 
 import scala . concurrent . Future 
 import scala . util . Random 
 
 @ @ - 97 , 14 + 99 , 17 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I 
 } 
 
 whenReady ( db . run ( persist . sequence . SeqUpdate . find ( user2AuthId ) ) ) { updates ⇒ 
 - updates . length shouldEqual 1 
 + updates . length shouldEqual 2 
 
 - val update = updates . head 
 + val update = updates ( 0 ) 
 update . header shouldEqual UpdateMessage . header 
 val seqUpdate = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( update . serializedData ) ) . right . toOption . get 
 seqUpdate . peer shouldEqual Peer ( PeerType . Private , user . id ) 
 seqUpdate . randomId shouldEqual randomId 
 seqUpdate . senderUserId shouldEqual user . id 
 + 
 + val countersUpdate = updates ( 1 ) 
 + countersUpdate . header shouldEqual UpdateCountersChanged . header 
 } 
 } 
 
 @ @ - 151 , 9 + 156 , 12 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I 
 val resp = respOption . get 
 
 val updates = resp . updates 
 - updates . length shouldEqual 1 
 + updates . length shouldEqual 2 
 + 
 + val countersUpdate = UpdateCountersChanged . parseFrom ( CodedInputStream . newInstance ( updates ( 0 ) . update ) ) 
 + countersUpdate should matchPattern { case Right ( _ : UpdateCountersChanged ) ⇒ } 
 
 - val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 + val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates ( 1 ) . update ) ) 
 message should matchPattern { case Right ( _ : UpdateMessage ) ⇒ } 
 } 
 }
