BLEU SCORE: 0.12874330508144843

TEST MSG: fix ( server : user ) : run afterCreate user hook after user creation scope
GENERATED MSG: fix ( server ) : use localName from user structure

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 73b2432 . . 24d7279 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 30 , 7 + 30 , 7 @ @ import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . util . Failure < nl > + import scala . util . { Failure , Success } < nl > import scala . util . control . NoStackTrace < nl > < nl > abstract class UserError ( message : String ) extends RuntimeException ( message ) with NoStackTrace < nl > @ @ - 102 , 8 + 102 , 9 @ @ private [ user ] trait UserCommandHandlers { < nl > ) < nl > db . run ( for { < nl > _ ← p . UserRepo . create ( user ) < nl > - _ ← DBIO . from ( userExt . hooks . afterCreate . runAll ( user . id ) ) < nl > - } yield CreateAck ( ) ) < nl > + } yield CreateAck ( ) ) andThen { < nl > + case Success ( _ ) = > userExt . hooks . afterCreate . runAll ( user . id ) < nl > + } < nl > } < nl > } else { < nl > replyTo ! Status . Failure ( UserErrors . NicknameTaken ) < nl > diff - - git a / actor - server / notes / 1 . 0 . 130 . markdown b / actor - server / notes / 1 . 0 . 130 . markdown < nl > new file mode 100644 < nl > index 0000000 . . 548ab2b < nl > - - - / dev / null < nl > + + + b / actor - server / notes / 1 . 0 . 130 . markdown < nl > @ @ - 0 , 0 + 1 @ @ < nl > + * : bug : run afterCreate hook out of user creation scope < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > index 5117db0 . . d033def 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala < nl > @ @ - 1 , 11 + 1 , 9 @ @ < nl > package im . actor . server . office < nl > < nl > - import im . actor . api . rpc . counters . { UpdateCountersChanged , AppCounters } < nl > + import im . actor . api . rpc . counters . { AppCounters , UpdateCountersChanged } < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { Peer , PeerType } < nl > - import im . actor . server . models < nl > import im . actor . server . { persist ⇒ p } < nl > - import im . actor . server . util . ContactsUtils < nl > import slick . dbio . DBIO < nl > < nl > import scala . concurrent . ExecutionContext < nl > @ @ - 16 , 31 + 14 , 25 @ @ object PeerProcessor { < nl > < nl > trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ State , Event ] { < nl > < nl > - import ContactsUtils . _ < nl > - < nl > private implicit val ec : ExecutionContext = context . dispatcher < nl > < nl > protected var lastReadDate : Option [ Long ] = None < nl > protected var lastReceiveDate : Option [ Long ] = None < nl > < nl > - protected def getPushText ( message : Message , clientUser : models . User , outUser : Int ) = { < nl > + protected def getPushText ( message : Message , clientName : String , outUser : Int ) : String = { < nl > message match { < nl > case TextMessage ( text , _ , _ ) ⇒ < nl > - for ( localName ← getLocalNameOrDefault ( outUser , clientUser ) ) < nl > - yield formatAuthored ( localName , text ) < nl > + formatAuthored ( clientName , text ) < nl > case dm : DocumentMessage ⇒ < nl > - getLocalNameOrDefault ( outUser , clientUser ) map { localName ⇒ < nl > - dm . ext match { < nl > - case Some ( _ : DocumentExPhoto ) ⇒ < nl > - formatAuthored ( localName , " Photo " ) < nl > - case Some ( _ : DocumentExVideo ) ⇒ < nl > - formatAuthored ( localName , " Video " ) < nl > - case _ ⇒ < nl > - formatAuthored ( localName , dm . name ) < nl > - } < nl > + dm . ext match { < nl > + case Some ( _ : DocumentExPhoto ) ⇒ < nl > + formatAuthored ( clientName , " Photo " ) < nl > + case Some ( _ : DocumentExVideo ) ⇒ < nl > + formatAuthored ( clientName , " Video " ) < nl > + case _ ⇒ < nl > + formatAuthored ( clientName , dm . name ) < nl > } < nl > - case unsupported ⇒ < nl > - DBIO . successful ( " " ) < nl > + case unsupported ⇒ " " < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index dbfda99 . . 5af4c75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 123 , 15 + 123 , 14 @ @ private [ user ] trait UserCommandHandlers { < nl > randomId = randomId , < nl > message = message < nl > ) < nl > - db . run { < nl > - for { < nl > - senderUser ← getUserUnsafe ( senderUserId ) < nl > - pushText ← getPushText ( message , senderUser , userId ) < nl > - counterUpdate ← getUpdateCountersChanged ( userId ) < nl > - _ ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , counterUpdate , None , isFat = false ) < nl > - seqs ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , update , Some ( pushText ) , isFat ) < nl > - } yield seqs < nl > - } < nl > + for { < nl > + senderUser ← UserOffice . getApiStruct ( senderUserId , userId , getAuthIdUnsafe ( user ) ) < nl > + senderName = senderUser . localName . getOrElse ( senderUser . name ) < nl > + pushText = getPushText ( message , senderName , userId ) < nl > + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) < nl > + _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None , isFat = false ) < nl > + seqs ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , Some ( pushText ) , isFat ) < nl > + } yield seqs < nl > } < nl > < nl > protected def deliverOwnMessage ( user : User , peer : Peer , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) : Future [ SeqState ] = { < nl > @ @ - 328 , 4 + 327 , 8 @ @ private [ user ] trait UserCommandHandlers { < nl > } yield ( ) < nl > } < nl > < nl > + private def getAuthIdUnsafe ( user : User ) : Long = { < nl > + user . authIds . headOption . getOrElse ( throw new scala . Exception ( s " There was no authId for user $ { user . id } " ) ) < nl > + } < nl > + < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala < nl > index 280abc3 . . d443581 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala < nl > @ @ - 22 , 7 + 22 , 7 @ @ private [ user ] trait UserQueriesHandlers { < nl > } < nl > < nl > protected def getApiStruct ( state : User , clientUserId : Int , clientAuthId : Long ) : Unit = { < nl > - db . run ( p . contact . UserContact . findName ( clientUserId : Int , state . id ) . headOption map ( _ . getOrElse ( None ) ) ) . map { localName ⇒ < nl > + db . run ( p . contact . UserContact . findName ( clientUserId , state . id ) . headOption map ( _ . getOrElse ( None ) ) ) . map { localName ⇒ < nl > GetApiStructResponse ( ApiUser ( < nl > id = state . id , < nl > accessHash = ACLUtils . userAccessHash ( clientAuthId , state . id , state . accessSalt ) ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 73b2432 . . 24d7279 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 30 , 7 + 30 , 7 @ @ import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . Future 
 - import scala . util . Failure 
 + import scala . util . { Failure , Success } 
 import scala . util . control . NoStackTrace 
 
 abstract class UserError ( message : String ) extends RuntimeException ( message ) with NoStackTrace 
 @ @ - 102 , 8 + 102 , 9 @ @ private [ user ] trait UserCommandHandlers { 
 ) 
 db . run ( for { 
 _ ← p . UserRepo . create ( user ) 
 - _ ← DBIO . from ( userExt . hooks . afterCreate . runAll ( user . id ) ) 
 - } yield CreateAck ( ) ) 
 + } yield CreateAck ( ) ) andThen { 
 + case Success ( _ ) = > userExt . hooks . afterCreate . runAll ( user . id ) 
 + } 
 } 
 } else { 
 replyTo ! Status . Failure ( UserErrors . NicknameTaken ) 
 diff - - git a / actor - server / notes / 1 . 0 . 130 . markdown b / actor - server / notes / 1 . 0 . 130 . markdown 
 new file mode 100644 
 index 0000000 . . 548ab2b 
 - - - / dev / null 
 + + + b / actor - server / notes / 1 . 0 . 130 . markdown 
 @ @ - 0 , 0 + 1 @ @ 
 + * : bug : run afterCreate hook out of user creation scope 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 index 5117db0 . . d033def 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / office / PeerProcessor . scala 
 @ @ - 1 , 11 + 1 , 9 @ @ 
 package im . actor . server . office 
 
 - import im . actor . api . rpc . counters . { UpdateCountersChanged , AppCounters } 
 + import im . actor . api . rpc . counters . { AppCounters , UpdateCountersChanged } 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { Peer , PeerType } 
 - import im . actor . server . models 
 import im . actor . server . { persist ⇒ p } 
 - import im . actor . server . util . ContactsUtils 
 import slick . dbio . DBIO 
 
 import scala . concurrent . ExecutionContext 
 @ @ - 16 , 31 + 14 , 25 @ @ object PeerProcessor { 
 
 trait PeerProcessor [ State < : ProcessorState , Event < : AnyRef ] extends Processor [ State , Event ] { 
 
 - import ContactsUtils . _ 
 - 
 private implicit val ec : ExecutionContext = context . dispatcher 
 
 protected var lastReadDate : Option [ Long ] = None 
 protected var lastReceiveDate : Option [ Long ] = None 
 
 - protected def getPushText ( message : Message , clientUser : models . User , outUser : Int ) = { 
 + protected def getPushText ( message : Message , clientName : String , outUser : Int ) : String = { 
 message match { 
 case TextMessage ( text , _ , _ ) ⇒ 
 - for ( localName ← getLocalNameOrDefault ( outUser , clientUser ) ) 
 - yield formatAuthored ( localName , text ) 
 + formatAuthored ( clientName , text ) 
 case dm : DocumentMessage ⇒ 
 - getLocalNameOrDefault ( outUser , clientUser ) map { localName ⇒ 
 - dm . ext match { 
 - case Some ( _ : DocumentExPhoto ) ⇒ 
 - formatAuthored ( localName , " Photo " ) 
 - case Some ( _ : DocumentExVideo ) ⇒ 
 - formatAuthored ( localName , " Video " ) 
 - case _ ⇒ 
 - formatAuthored ( localName , dm . name ) 
 - } 
 + dm . ext match { 
 + case Some ( _ : DocumentExPhoto ) ⇒ 
 + formatAuthored ( clientName , " Photo " ) 
 + case Some ( _ : DocumentExVideo ) ⇒ 
 + formatAuthored ( clientName , " Video " ) 
 + case _ ⇒ 
 + formatAuthored ( clientName , dm . name ) 
 } 
 - case unsupported ⇒ 
 - DBIO . successful ( " " ) 
 + case unsupported ⇒ " " 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index dbfda99 . . 5af4c75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 123 , 15 + 123 , 14 @ @ private [ user ] trait UserCommandHandlers { 
 randomId = randomId , 
 message = message 
 ) 
 - db . run { 
 - for { 
 - senderUser ← getUserUnsafe ( senderUserId ) 
 - pushText ← getPushText ( message , senderUser , userId ) 
 - counterUpdate ← getUpdateCountersChanged ( userId ) 
 - _ ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , counterUpdate , None , isFat = false ) 
 - seqs ← SeqUpdatesManager . persistAndPushUpdates ( user . authIds , update , Some ( pushText ) , isFat ) 
 - } yield seqs 
 - } 
 + for { 
 + senderUser ← UserOffice . getApiStruct ( senderUserId , userId , getAuthIdUnsafe ( user ) ) 
 + senderName = senderUser . localName . getOrElse ( senderUser . name ) 
 + pushText = getPushText ( message , senderName , userId ) 
 + counterUpdate ← db . run ( getUpdateCountersChanged ( userId ) ) 
 + _ ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , counterUpdate , None , isFat = false ) 
 + seqs ← SeqUpdatesManager . persistAndPushUpdatesF ( user . authIds , update , Some ( pushText ) , isFat ) 
 + } yield seqs 
 } 
 
 protected def deliverOwnMessage ( user : User , peer : Peer , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) : Future [ SeqState ] = { 
 @ @ - 328 , 4 + 327 , 8 @ @ private [ user ] trait UserCommandHandlers { 
 } yield ( ) 
 } 
 
 + private def getAuthIdUnsafe ( user : User ) : Long = { 
 + user . authIds . headOption . getOrElse ( throw new scala . Exception ( s " There was no authId for user $ { user . id } " ) ) 
 + } 
 + 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala 
 index 280abc3 . . d443581 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserQueriesHandlers . scala 
 @ @ - 22 , 7 + 22 , 7 @ @ private [ user ] trait UserQueriesHandlers { 
 } 
 
 protected def getApiStruct ( state : User , clientUserId : Int , clientAuthId : Long ) : Unit = { 
 - db . run ( p . contact . UserContact . findName ( clientUserId : Int , state . id ) . headOption map ( _ . getOrElse ( None ) ) ) . map { localName ⇒ 
 + db . run ( p . contact . UserContact . findName ( clientUserId , state . id ) . headOption map ( _ . getOrElse ( None ) ) ) . map { localName ⇒ 
 GetApiStructResponse ( ApiUser ( 
 id = state . id , 
 accessHash = ACLUtils . userAccessHash ( clientAuthId , state . id , state . accessSalt ) ,
