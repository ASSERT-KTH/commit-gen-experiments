BLEU SCORE: 0.27007097700389543

TEST MSG: feat ( server ) : add array style raw service
GENERATED MSG: feat ( server : raw ) : map style raw service

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala < nl > new file mode 100644 < nl > index 0000000 . . 174a1fe < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala < nl > @ @ - 0 , 0 + 1 , 45 @ @ < nl > + package im . actor . api . rpc . raw < nl > + < nl > + import akka . actor . ActorSystem < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . collections . _ < nl > + import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + / / todo : find a better name . It is not array style already . Arrays just could be parsed to case classes for convinience < nl > + abstract class ArrayStyleRawApiService ( system : ActorSystem ) extends RawApiService ( system ) with RawValueParserTypeclassInstances { < nl > + import im . actor . api . rpc . FutureResultRpcCats . _ < nl > + import system . dispatcher < nl > + < nl > + type Request < nl > + < nl > + final override def handleRequests : Handler = implicit client ⇒ params ⇒ new PartialFunction [ String , Future [ Response ] ] { < nl > + override def isDefinedAt ( name : String ) : Boolean = validateRequests ( None ) . isDefinedAt ( name ) < nl > + < nl > + override def apply ( name : String ) : Future [ Response ] = { < nl > + ( for { < nl > + request ← fromEither ( validateRequests ( params ) ( name ) ) < nl > + result ← fromFutureEither ( processRequests ( client ) ( request ) ) < nl > + } yield result ) . value < nl > + } < nl > + } < nl > + < nl > + protected def validateRequests : Option [ ApiRawValue ] ⇒ PartialFunction [ String , RpcError Xor Request ] < nl > + < nl > + protected def processRequests : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > + < nl > + / * * < nl > + * Parse content of ` optParams ` to type T , < nl > + * Returns ` RawApiRpcErrors . InvalidParams ` if ` optParams ` is empty < nl > + * Returns ` RawApiRpcErrors . InvalidParams ` if it wasn ' t able to parse ` optParams ` to type T < nl > + * @ param optParams data that will be parsed . Should be non empty < nl > + * @ tparam T type to parse to < nl > + * / < nl > + final protected def parseParams [ T : RawValueParser ] ( optParams : Option [ ApiRawValue ] ) : RpcError Xor T = < nl > + for { < nl > + params ← Xor . fromOption ( optParams , RawApiRpcErrors . InvalidParams ) < nl > + result ← Xor . fromOption ( RawValueParser . parse [ T ] ( params ) , RawApiRpcErrors . InvalidParams ) < nl > + } yield result < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > index 5847d65 . . 6b75303 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > @ @ - 7 , 6 + 7 , 10 @ @ import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > < nl > import scala . concurrent . Future < nl > < nl > + object RawApiRpcErrors { < nl > + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) < nl > + } < nl > + < nl > / * * < nl > * Base class for raw service handlers . < nl > * / < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala < nl > index 223f560 . . 10a6d28 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala < nl > @ @ - 8 , 13 + 8 , 14 @ @ trait RawValueParser [ A ] { < nl > def parse ( raw : ApiRawValue ) : Option [ A ] < nl > } < nl > < nl > - / / target parsing type is ApiArrayValue < nl > - / / todo : add nesting < nl > - object RawValueParser { < nl > + object RawValueParser extends RawValueParserTypeclassInstances { < nl > def apply [ T : RawValueParser ] : RawValueParser [ T ] = implicitly [ RawValueParser [ T ] ] < nl > < nl > def parse [ A : RawValueParser ] ( raw : ApiRawValue ) : Option [ A ] = RawValueParser [ A ] . parse ( raw ) < nl > + } < nl > < nl > + / / todo : add nesting < nl > + trait RawValueParserTypeclassInstances { < nl > import shapeless . _ < nl > < nl > implicit val booleanParser = new RawValueParser [ Boolean ] { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > index 76388d8 . . 31b29e9 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import akka . actor . ActorSystem < nl > import cats . data . Xor < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . collections . _ < nl > - import im . actor . api . rpc . raw . { MapStyleRawApiService , RawApiService } < nl > + import im . actor . api . rpc . raw . { ArrayStyleRawApiService , MapStyleRawApiService , RawApiService } < nl > import im . actor . server . api . rpc . RawApiExtension < nl > import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > import play . api . libs . json . Json < nl > @ @ - 28 , 7 + 28 , 9 @ @ class RawServiceSpec < nl > < nl > it should " detect dynamically registered services " in e4 < nl > < nl > - it should " work with map style service " in e5 < nl > + it should " work with map style service " in mapStyle < nl > + < nl > + it should " work with array style service " in arrayStyle < nl > < nl > val service = new RawServiceImpl ( ) < nl > < nl > @ @ - 101 , 7 + 103 , 7 @ @ class RawServiceSpec < nl > } < nl > } < nl > < nl > - def e5 ( ) = { < nl > + def mapStyle ( ) = { < nl > RawApiExtension ( system ) . register ( " mapDictionary " , new MapStyleDictionaryService ( system ) ) < nl > < nl > whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ < nl > @ @ - 140 , 6 + 142 , 41 @ @ class RawServiceSpec < nl > < nl > } < nl > < nl > + def arrayStyle ( ) = { < nl > + RawApiExtension ( system ) . register ( " arrayDictionary " , new ArrayStyleDictionaryService ( system ) ) < nl > + < nl > + whenReady ( service . handleRawRequest ( " arrayDictionary " , " getWord " , Some ( ApiStringValue ( " culture " ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiArrayValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiStringValue ( DictionaryMeanings . Culture ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + val newWord = " thing " → " You know , the thing ! " < nl > + whenReady ( service . handleRawRequest ( " arrayDictionary " , " putWord " , Some ( ApiArrayValue ( Vector ( < nl > + ApiStringValue ( newWord . _ 1 ) , < nl > + ApiStringValue ( newWord . _ 2 ) < nl > + ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ rawValue . result shouldEqual ApiStringValue ( " true " ) < nl > + } < nl > + } < nl > + < nl > + whenReady ( service . handleRawRequest ( " arrayDictionary " , " getWord " , Some ( ApiStringValue ( newWord . _ 1 ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiArrayValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiStringValue ( newWord . _ 2 ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + } < nl > + < nl > / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service < nl > < nl > private object DictionaryMeanings { < nl > @ @ - 235 , 6 + 272 , 48 @ @ class RawServiceSpec < nl > } < nl > } < nl > < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments < nl > + * / < nl > + private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import im . actor . api . rpc . FutureResultRpcCats . _ < nl > + < nl > + sealed trait DictionaryRequest < nl > + case class GetWord ( word : String ) extends DictionaryRequest < nl > + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > + < nl > + private val kv = TrieMap . empty [ String , String ] < nl > + < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > + < nl > + override type Request = DictionaryRequest < nl > + < nl > + override protected def validateRequests = optParams ⇒ { < nl > + case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord < nl > + case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) < nl > + } < nl > + < nl > + override protected def processRequests = implicit client ⇒ { < nl > + case GetWord ( word ) ⇒ getWord ( word ) < nl > + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > + } < nl > + < nl > + def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + optValue ← point ( kv . get ( word ) ) < nl > + encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty < nl > + } yield ApiArrayValue ( encodedArr ) ) . value < nl > + } < nl > + < nl > + def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > + kv . put ( word , meaning ) < nl > + Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) < nl > + } < nl > + } < nl > + < nl > / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service < nl > < nl > private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala < nl > new file mode 100644 < nl > index 0000000 . . 058fac1 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala < nl > @ @ - 0 , 0 + 1 , 88 @ @ < nl > + package im . actor . rpc . raw < nl > + < nl > + import akka . actor . ActorSystem < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . { RpcError , AuthorizedClientData } < nl > + import im . actor . api . rpc . collections . _ < nl > + import play . api . libs . json . _ < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + trait ProductImplicits { < nl > + < nl > + / * * < nl > + * Implicit conversion for case classes and case objects . < nl > + * Allows to represent case class as ApiMap . < nl > + * Case classes with 0 fields and case objects are converted to empty ApiMap < nl > + * @ param product case class or case object < nl > + * / < nl > + implicit class Foo ( product : Product ) { < nl > + def asApiMap : ApiMapValue = { < nl > + / / case object or empty case class < nl > + if ( product . productArity = = 0 ) { < nl > + ApiMapValue ( Vector . empty [ ApiMapValueItem ] ) < nl > + } else { < nl > + val items = product . getClass . getDeclaredFields . foldLeft ( Vector . empty [ ApiMapValueItem ] ) { ( a , f ) ⇒ < nl > + f . setAccessible ( true ) < nl > + a : + ApiMapValueItem ( f . getName , toApiRawValue ( f . get ( product ) ) ) < nl > + } < nl > + ApiMapValue ( items ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + private def toApiRawValue : PartialFunction [ Any , ApiRawValue ] = { < nl > + case b : Boolean ⇒ ApiStringValue ( b . toString ) < nl > + case s : String ⇒ ApiStringValue ( s ) < nl > + case d : Double ⇒ ApiDoubleValue ( d ) < nl > + case i : Int ⇒ ApiInt32Value ( i ) < nl > + case l : Long ⇒ ApiInt64Value ( l ) < nl > + case s : Seq [ _ ] ⇒ ApiArrayValue ( ( s map toApiRawValue ) . toVector ) < nl > + case m : Map [ String @ unchecked , _ ] ⇒ < nl > + ApiMapValue ( m . toVector map { case ( k , v ) ⇒ ApiMapValueItem ( k , toApiRawValue ( v ) ) } ) < nl > + case p : Product ⇒ p . asApiMap < nl > + } < nl > + < nl > + } < nl > + < nl > + abstract class MapStyleRawApiService ( system : ActorSystem ) extends RawApiService ( system ) with ProductImplicits { < nl > + import im . actor . api . rpc . FutureResultRpcCats . _ < nl > + import system . dispatcher < nl > + < nl > + type Request < nl > + < nl > + final override def handleRequests : Handler = implicit client ⇒ params ⇒ new PartialFunction [ String , Future [ Response ] ] { < nl > + override def isDefinedAt ( name : String ) : Boolean = validateRequest ( None ) . isDefinedAt ( name ) < nl > + < nl > + override def apply ( name : String ) : Future [ Response ] = ( for { < nl > + request ← fromEither ( toRequest ( name , params ) ) < nl > + result ← fromFutureEither ( handleInternal ( client ) ( request ) ) < nl > + } yield result ) . value < nl > + } < nl > + < nl > + protected def validateRequest : Option [ JsObject ] ⇒ PartialFunction [ String , RpcError Xor Request ] < nl > + < nl > + protected def handleInternal : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > + < nl > + private def toRequest ( name : String , optParams : Option [ ApiRawValue ] ) : RpcError Xor Request = { < nl > + val jsParams = optParams map { params ⇒ < nl > + convert ( params ) match { < nl > + case o : JsObject ⇒ Xor . right ( Some ( o ) ) < nl > + case _ ⇒ Xor . left ( RpcError ( 400 , " INVALID _ PARAMS " , " Wrong parameter format ; should be MapValue " , false , None ) ) < nl > + } < nl > + } getOrElse Xor . right ( None ) < nl > + jsParams flatMap { o ⇒ validateRequest ( o ) ( name ) } < nl > + } < nl > + < nl > + private def convert ( raw : ApiRawValue ) : JsValue = raw match { < nl > + case ApiMapValue ( items ) ⇒ < nl > + val fields = items map { case ApiMapValueItem ( key , value ) ⇒ key → convert ( value ) } < nl > + JsObject ( fields ) < nl > + case ApiStringValue ( t ) ⇒ JsString ( t ) < nl > + case ApiDoubleValue ( d ) ⇒ JsNumber ( d ) < nl > + case ApiInt32Value ( i ) ⇒ JsNumber ( i ) < nl > + case ApiInt64Value ( l ) ⇒ JsNumber ( l ) < nl > + case ApiArrayValue ( values ) ⇒ JsArray ( values map convert ) < nl > + } < nl > + } < nl > + < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala < nl > index e0d918b . . f39a784 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala < nl > @ @ - 12 , 9 + 12 , 9 @ @ import scala . concurrent . Future < nl > * / < nl > abstract class RawApiService ( system : ActorSystem ) { < nl > < nl > - type Response = Future [ RpcError Xor ApiRawValue ] < nl > + type Response = RpcError Xor ApiRawValue < nl > < nl > - type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Response ] < nl > + type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] < nl > < nl > def handleRequests : Handler < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala < nl > index da24c5f . . e99399d 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala < nl > @ @ - 1 , 18 + 1 , 17 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import cats . data . Xor < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . collections . _ < nl > - import im . actor . rpc . raw . RawApiService < nl > + import im . actor . rpc . raw . { MapStyleRawApiService , RawApiService } < nl > import im . actor . server . api . rpc . RawApiExtension < nl > import im . actor . server . api . rpc . service . raw . RawServiceImpl < nl > import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } < nl > + import play . api . libs . json . Json < nl > < nl > import scala . collection . concurrent . TrieMap < nl > import scala . concurrent . Future < nl > - import scala . concurrent . duration . _ < nl > import scalaz . \ / - < nl > < nl > class RawServiceSpec < nl > @ @ - 30 , 6 + 29 , 8 @ @ class RawServiceSpec < nl > < nl > it should " detect dynamically registered services " in e4 < nl > < nl > + it should " work with map style service " in e5 < nl > + < nl > val service = new RawServiceImpl ( ) < nl > < nl > RawApiExtension ( system ) . register ( " dictionary " , new DictionaryService ( system ) ) < nl > @ @ - 101 , 6 + 102 , 45 @ @ class RawServiceSpec < nl > } < nl > } < nl > < nl > + def e5 ( ) = { < nl > + RawApiExtension ( system ) . register ( " mapDictionary " , new MapStyleDictionaryService ( system ) ) < nl > + < nl > + whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( DictionaryMeanings . Culture ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + val newWord = " thing " → " You know , the thing ! " < nl > + whenReady ( service . handleRawRequest ( " mapDictionary " , " putWord " , Some ( ApiMapValue ( Vector ( < nl > + ApiMapValueItem ( " word " , ApiStringValue ( newWord . _ 1 ) ) , < nl > + ApiMapValueItem ( " meaning " , ApiStringValue ( newWord . _ 2 ) ) < nl > + ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( newWord . _ 1 ) ) ) ) ) ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { < nl > + case ApiMapValue ( items ) ⇒ < nl > + items should have length 1 < nl > + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( newWord . _ 2 ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + } < nl > + < nl > / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service < nl > < nl > private object DictionaryMeanings { < nl > @ @ - 117 , 7 + 157 , 6 @ @ class RawServiceSpec < nl > import ServiceErrors . _ < nl > import im . actor . api . rpc . FutureResultRpcCats . _ < nl > < nl > - implicit val timeout = Timeout ( 20 . seconds ) < nl > private val kv = TrieMap . empty [ String , String ] < nl > < nl > kv . put ( " culture " , Culture ) < nl > @ @ - 129 , 7 + 168 , 7 @ @ class RawServiceSpec < nl > / / case " putWord " = > putWord ( ) < nl > } < nl > < nl > - def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Response = { < nl > + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > val ps = optParams flatMap { < nl > case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } < nl > case _ ⇒ None < nl > @ @ - 142 , 16 + 181 , 71 @ @ class RawServiceSpec < nl > } < nl > } < nl > < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments < nl > + * / < nl > + private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import ServiceErrors . _ < nl > + import im . actor . api . rpc . FutureResultRpcCats . _ < nl > + < nl > + sealed trait DictionaryRequest < nl > + case class GetWord ( word : String ) extends DictionaryRequest < nl > + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > + < nl > + implicit val getWordReads = Json . reads [ GetWord ] < nl > + implicit val putWordReads = Json . reads [ PutWord ] < nl > + < nl > + private val kv = TrieMap . empty [ String , String ] < nl > + < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > + < nl > + override type Request = DictionaryRequest < nl > + < nl > + override protected def validateRequest = optParams ⇒ { < nl > + case " getWord " ⇒ < nl > + for { < nl > + params ← Xor . fromOption ( optParams , InvalidParams ) < nl > + result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > + } yield result < nl > + case " putWord " ⇒ < nl > + for { < nl > + params ← Xor . fromOption ( optParams , InvalidParams ) < nl > + result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > + } yield result < nl > + } < nl > + < nl > + override protected def handleInternal = implicit client ⇒ { < nl > + case GetWord ( word ) ⇒ getWord ( word ) < nl > + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > + } < nl > + < nl > + def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + optValue ← point ( kv . get ( word ) ) < nl > + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > + } yield ApiMapValue ( result ) ) . value < nl > + } < nl > + < nl > + def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + _ ← point ( kv . put ( word , meaning ) ) < nl > + } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value < nl > + } < nl > + } < nl > + < nl > / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service < nl > < nl > - private final class EchoService ( system : ActorSystem ) extends RawApiService ( system ) { < nl > + private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { < nl > import ServiceErrors . _ < nl > < nl > override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > case " makeEcho " ⇒ echo ( params ) < nl > } < nl > < nl > - def echo ( params : Option [ ApiRawValue ] ) : Response = { < nl > + def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { < nl > val resp = extractStringFromMap ( params , " query " ) map { q ⇒ < nl > Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) < nl > } getOrElse Xor . left ( InvalidParams ) < nl > @ @ - 161 , 7 + 255 , 7 @ @ class RawServiceSpec < nl > < nl > private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = < nl > optParams flatMap { < nl > - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( ` key ` , ApiStringValue ( str ) ) ⇒ str } < nl > + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } < nl > case _ ⇒ None < nl > } < nl > < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 17be8ce . . a259645 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 172 , 8 + 172 , 7 @ @ object Dependencies { < nl > jodaTime , < nl > postgresJdbc , < nl > shardakka , < nl > - scrImageCore , < nl > - upickle < nl > + scrImageCore < nl > ) < nl > < nl > val enrich = shared + + Seq ( akkaActor , akkaHttp )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala 
 new file mode 100644 
 index 0000000 . . 174a1fe 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala 
 @ @ - 0 , 0 + 1 , 45 @ @ 
 + package im . actor . api . rpc . raw 
 + 
 + import akka . actor . ActorSystem 
 + import cats . data . Xor 
 + import im . actor . api . rpc . collections . _ 
 + import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 + 
 + import scala . concurrent . Future 
 + 
 + / / todo : find a better name . It is not array style already . Arrays just could be parsed to case classes for convinience 
 + abstract class ArrayStyleRawApiService ( system : ActorSystem ) extends RawApiService ( system ) with RawValueParserTypeclassInstances { 
 + import im . actor . api . rpc . FutureResultRpcCats . _ 
 + import system . dispatcher 
 + 
 + type Request 
 + 
 + final override def handleRequests : Handler = implicit client ⇒ params ⇒ new PartialFunction [ String , Future [ Response ] ] { 
 + override def isDefinedAt ( name : String ) : Boolean = validateRequests ( None ) . isDefinedAt ( name ) 
 + 
 + override def apply ( name : String ) : Future [ Response ] = { 
 + ( for { 
 + request ← fromEither ( validateRequests ( params ) ( name ) ) 
 + result ← fromFutureEither ( processRequests ( client ) ( request ) ) 
 + } yield result ) . value 
 + } 
 + } 
 + 
 + protected def validateRequests : Option [ ApiRawValue ] ⇒ PartialFunction [ String , RpcError Xor Request ] 
 + 
 + protected def processRequests : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 + 
 + / * * 
 + * Parse content of ` optParams ` to type T , 
 + * Returns ` RawApiRpcErrors . InvalidParams ` if ` optParams ` is empty 
 + * Returns ` RawApiRpcErrors . InvalidParams ` if it wasn ' t able to parse ` optParams ` to type T 
 + * @ param optParams data that will be parsed . Should be non empty 
 + * @ tparam T type to parse to 
 + * / 
 + final protected def parseParams [ T : RawValueParser ] ( optParams : Option [ ApiRawValue ] ) : RpcError Xor T = 
 + for { 
 + params ← Xor . fromOption ( optParams , RawApiRpcErrors . InvalidParams ) 
 + result ← Xor . fromOption ( RawValueParser . parse [ T ] ( params ) , RawApiRpcErrors . InvalidParams ) 
 + } yield result 
 + 
 + } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 index 5847d65 . . 6b75303 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 @ @ - 7 , 6 + 7 , 10 @ @ import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 
 import scala . concurrent . Future 
 
 + object RawApiRpcErrors { 
 + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) 
 + } 
 + 
 / * * 
 * Base class for raw service handlers . 
 * / 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala 
 index 223f560 . . 10a6d28 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawValueParser . scala 
 @ @ - 8 , 13 + 8 , 14 @ @ trait RawValueParser [ A ] { 
 def parse ( raw : ApiRawValue ) : Option [ A ] 
 } 
 
 - / / target parsing type is ApiArrayValue 
 - / / todo : add nesting 
 - object RawValueParser { 
 + object RawValueParser extends RawValueParserTypeclassInstances { 
 def apply [ T : RawValueParser ] : RawValueParser [ T ] = implicitly [ RawValueParser [ T ] ] 
 
 def parse [ A : RawValueParser ] ( raw : ApiRawValue ) : Option [ A ] = RawValueParser [ A ] . parse ( raw ) 
 + } 
 
 + / / todo : add nesting 
 + trait RawValueParserTypeclassInstances { 
 import shapeless . _ 
 
 implicit val booleanParser = new RawValueParser [ Boolean ] { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 index 76388d8 . . 31b29e9 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import akka . actor . ActorSystem 
 import cats . data . Xor 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . collections . _ 
 - import im . actor . api . rpc . raw . { MapStyleRawApiService , RawApiService } 
 + import im . actor . api . rpc . raw . { ArrayStyleRawApiService , MapStyleRawApiService , RawApiService } 
 import im . actor . server . api . rpc . RawApiExtension 
 import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 import play . api . libs . json . Json 
 @ @ - 28 , 7 + 28 , 9 @ @ class RawServiceSpec 
 
 it should " detect dynamically registered services " in e4 
 
 - it should " work with map style service " in e5 
 + it should " work with map style service " in mapStyle 
 + 
 + it should " work with array style service " in arrayStyle 
 
 val service = new RawServiceImpl ( ) 
 
 @ @ - 101 , 7 + 103 , 7 @ @ class RawServiceSpec 
 } 
 } 
 
 - def e5 ( ) = { 
 + def mapStyle ( ) = { 
 RawApiExtension ( system ) . register ( " mapDictionary " , new MapStyleDictionaryService ( system ) ) 
 
 whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ 
 @ @ - 140 , 6 + 142 , 41 @ @ class RawServiceSpec 
 
 } 
 
 + def arrayStyle ( ) = { 
 + RawApiExtension ( system ) . register ( " arrayDictionary " , new ArrayStyleDictionaryService ( system ) ) 
 + 
 + whenReady ( service . handleRawRequest ( " arrayDictionary " , " getWord " , Some ( ApiStringValue ( " culture " ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiArrayValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiStringValue ( DictionaryMeanings . Culture ) 
 + } 
 + } 
 + } 
 + 
 + val newWord = " thing " → " You know , the thing ! " 
 + whenReady ( service . handleRawRequest ( " arrayDictionary " , " putWord " , Some ( ApiArrayValue ( Vector ( 
 + ApiStringValue ( newWord . _ 1 ) , 
 + ApiStringValue ( newWord . _ 2 ) 
 + ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ rawValue . result shouldEqual ApiStringValue ( " true " ) 
 + } 
 + } 
 + 
 + whenReady ( service . handleRawRequest ( " arrayDictionary " , " getWord " , Some ( ApiStringValue ( newWord . _ 1 ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiArrayValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiStringValue ( newWord . _ 2 ) 
 + } 
 + } 
 + } 
 + 
 + } 
 + 
 / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service 
 
 private object DictionaryMeanings { 
 @ @ - 235 , 6 + 272 , 48 @ @ class RawServiceSpec 
 } 
 } 
 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments 
 + * / 
 + private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import im . actor . api . rpc . FutureResultRpcCats . _ 
 + 
 + sealed trait DictionaryRequest 
 + case class GetWord ( word : String ) extends DictionaryRequest 
 + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 + 
 + private val kv = TrieMap . empty [ String , String ] 
 + 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 + 
 + override type Request = DictionaryRequest 
 + 
 + override protected def validateRequests = optParams ⇒ { 
 + case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord 
 + case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) 
 + } 
 + 
 + override protected def processRequests = implicit client ⇒ { 
 + case GetWord ( word ) ⇒ getWord ( word ) 
 + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 + } 
 + 
 + def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 + ( for { 
 + optValue ← point ( kv . get ( word ) ) 
 + encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty 
 + } yield ApiArrayValue ( encodedArr ) ) . value 
 + } 
 + 
 + def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 + kv . put ( word , meaning ) 
 + Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) 
 + } 
 + } 
 + 
 / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service 
 
 private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) {

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala 
 new file mode 100644 
 index 0000000 . . 058fac1 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / MapStyleRawApiService . scala 
 @ @ - 0 , 0 + 1 , 88 @ @ 
 + package im . actor . rpc . raw 
 + 
 + import akka . actor . ActorSystem 
 + import cats . data . Xor 
 + import im . actor . api . rpc . { RpcError , AuthorizedClientData } 
 + import im . actor . api . rpc . collections . _ 
 + import play . api . libs . json . _ 
 + 
 + import scala . concurrent . Future 
 + 
 + trait ProductImplicits { 
 + 
 + / * * 
 + * Implicit conversion for case classes and case objects . 
 + * Allows to represent case class as ApiMap . 
 + * Case classes with 0 fields and case objects are converted to empty ApiMap 
 + * @ param product case class or case object 
 + * / 
 + implicit class Foo ( product : Product ) { 
 + def asApiMap : ApiMapValue = { 
 + / / case object or empty case class 
 + if ( product . productArity = = 0 ) { 
 + ApiMapValue ( Vector . empty [ ApiMapValueItem ] ) 
 + } else { 
 + val items = product . getClass . getDeclaredFields . foldLeft ( Vector . empty [ ApiMapValueItem ] ) { ( a , f ) ⇒ 
 + f . setAccessible ( true ) 
 + a : + ApiMapValueItem ( f . getName , toApiRawValue ( f . get ( product ) ) ) 
 + } 
 + ApiMapValue ( items ) 
 + } 
 + } 
 + } 
 + 
 + private def toApiRawValue : PartialFunction [ Any , ApiRawValue ] = { 
 + case b : Boolean ⇒ ApiStringValue ( b . toString ) 
 + case s : String ⇒ ApiStringValue ( s ) 
 + case d : Double ⇒ ApiDoubleValue ( d ) 
 + case i : Int ⇒ ApiInt32Value ( i ) 
 + case l : Long ⇒ ApiInt64Value ( l ) 
 + case s : Seq [ _ ] ⇒ ApiArrayValue ( ( s map toApiRawValue ) . toVector ) 
 + case m : Map [ String @ unchecked , _ ] ⇒ 
 + ApiMapValue ( m . toVector map { case ( k , v ) ⇒ ApiMapValueItem ( k , toApiRawValue ( v ) ) } ) 
 + case p : Product ⇒ p . asApiMap 
 + } 
 + 
 + } 
 + 
 + abstract class MapStyleRawApiService ( system : ActorSystem ) extends RawApiService ( system ) with ProductImplicits { 
 + import im . actor . api . rpc . FutureResultRpcCats . _ 
 + import system . dispatcher 
 + 
 + type Request 
 + 
 + final override def handleRequests : Handler = implicit client ⇒ params ⇒ new PartialFunction [ String , Future [ Response ] ] { 
 + override def isDefinedAt ( name : String ) : Boolean = validateRequest ( None ) . isDefinedAt ( name ) 
 + 
 + override def apply ( name : String ) : Future [ Response ] = ( for { 
 + request ← fromEither ( toRequest ( name , params ) ) 
 + result ← fromFutureEither ( handleInternal ( client ) ( request ) ) 
 + } yield result ) . value 
 + } 
 + 
 + protected def validateRequest : Option [ JsObject ] ⇒ PartialFunction [ String , RpcError Xor Request ] 
 + 
 + protected def handleInternal : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 + 
 + private def toRequest ( name : String , optParams : Option [ ApiRawValue ] ) : RpcError Xor Request = { 
 + val jsParams = optParams map { params ⇒ 
 + convert ( params ) match { 
 + case o : JsObject ⇒ Xor . right ( Some ( o ) ) 
 + case _ ⇒ Xor . left ( RpcError ( 400 , " INVALID _ PARAMS " , " Wrong parameter format ; should be MapValue " , false , None ) ) 
 + } 
 + } getOrElse Xor . right ( None ) 
 + jsParams flatMap { o ⇒ validateRequest ( o ) ( name ) } 
 + } 
 + 
 + private def convert ( raw : ApiRawValue ) : JsValue = raw match { 
 + case ApiMapValue ( items ) ⇒ 
 + val fields = items map { case ApiMapValueItem ( key , value ) ⇒ key → convert ( value ) } 
 + JsObject ( fields ) 
 + case ApiStringValue ( t ) ⇒ JsString ( t ) 
 + case ApiDoubleValue ( d ) ⇒ JsNumber ( d ) 
 + case ApiInt32Value ( i ) ⇒ JsNumber ( i ) 
 + case ApiInt64Value ( l ) ⇒ JsNumber ( l ) 
 + case ApiArrayValue ( values ) ⇒ JsArray ( values map convert ) 
 + } 
 + } 
 + 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala 
 index e0d918b . . f39a784 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / raw / RawApiService . scala 
 @ @ - 12 , 9 + 12 , 9 @ @ import scala . concurrent . Future 
 * / 
 abstract class RawApiService ( system : ActorSystem ) { 
 
 - type Response = Future [ RpcError Xor ApiRawValue ] 
 + type Response = RpcError Xor ApiRawValue 
 
 - type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Response ] 
 + type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] 
 
 def handleRequests : Handler 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala 
 index da24c5f . . e99399d 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / RawServiceSpec . scala 
 @ @ - 1 , 18 + 1 , 17 @ @ 
 package im . actor . server . api . rpc . service 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import cats . data . Xor 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . collections . _ 
 - import im . actor . rpc . raw . RawApiService 
 + import im . actor . rpc . raw . { MapStyleRawApiService , RawApiService } 
 import im . actor . server . api . rpc . RawApiExtension 
 import im . actor . server . api . rpc . service . raw . RawServiceImpl 
 import im . actor . server . { BaseAppSuite , ImplicitAuthService , ImplicitSessionRegion } 
 + import play . api . libs . json . Json 
 
 import scala . collection . concurrent . TrieMap 
 import scala . concurrent . Future 
 - import scala . concurrent . duration . _ 
 import scalaz . \ / - 
 
 class RawServiceSpec 
 @ @ - 30 , 6 + 29 , 8 @ @ class RawServiceSpec 
 
 it should " detect dynamically registered services " in e4 
 
 + it should " work with map style service " in e5 
 + 
 val service = new RawServiceImpl ( ) 
 
 RawApiExtension ( system ) . register ( " dictionary " , new DictionaryService ( system ) ) 
 @ @ - 101 , 6 + 102 , 45 @ @ class RawServiceSpec 
 } 
 } 
 
 + def e5 ( ) = { 
 + RawApiExtension ( system ) . register ( " mapDictionary " , new MapStyleDictionaryService ( system ) ) 
 + 
 + whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( " culture " ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( DictionaryMeanings . Culture ) ) 
 + } 
 + } 
 + } 
 + 
 + val newWord = " thing " → " You know , the thing ! " 
 + whenReady ( service . handleRawRequest ( " mapDictionary " , " putWord " , Some ( ApiMapValue ( Vector ( 
 + ApiMapValueItem ( " word " , ApiStringValue ( newWord . _ 1 ) ) , 
 + ApiMapValueItem ( " meaning " , ApiStringValue ( newWord . _ 2 ) ) 
 + ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) 
 + } 
 + } 
 + } 
 + 
 + whenReady ( service . handleRawRequest ( " mapDictionary " , " getWord " , Some ( ApiMapValue ( Vector ( ApiMapValueItem ( " word " , ApiStringValue ( newWord . _ 1 ) ) ) ) ) ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case \ / - ( rawValue ) ⇒ inside ( rawValue . result ) { 
 + case ApiMapValue ( items ) ⇒ 
 + items should have length 1 
 + items . head shouldEqual ApiMapValueItem ( " meaning " , ApiStringValue ( newWord . _ 2 ) ) 
 + } 
 + } 
 + } 
 + 
 + } 
 + 
 / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service 
 
 private object DictionaryMeanings { 
 @ @ - 117 , 7 + 157 , 6 @ @ class RawServiceSpec 
 import ServiceErrors . _ 
 import im . actor . api . rpc . FutureResultRpcCats . _ 
 
 - implicit val timeout = Timeout ( 20 . seconds ) 
 private val kv = TrieMap . empty [ String , String ] 
 
 kv . put ( " culture " , Culture ) 
 @ @ - 129 , 7 + 168 , 7 @ @ class RawServiceSpec 
 / / case " putWord " = > putWord ( ) 
 } 
 
 - def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Response = { 
 + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 val ps = optParams flatMap { 
 case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } 
 case _ ⇒ None 
 @ @ - 142 , 16 + 181 , 71 @ @ class RawServiceSpec 
 } 
 } 
 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments 
 + * / 
 + private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import ServiceErrors . _ 
 + import im . actor . api . rpc . FutureResultRpcCats . _ 
 + 
 + sealed trait DictionaryRequest 
 + case class GetWord ( word : String ) extends DictionaryRequest 
 + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 + 
 + implicit val getWordReads = Json . reads [ GetWord ] 
 + implicit val putWordReads = Json . reads [ PutWord ] 
 + 
 + private val kv = TrieMap . empty [ String , String ] 
 + 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 + 
 + override type Request = DictionaryRequest 
 + 
 + override protected def validateRequest = optParams ⇒ { 
 + case " getWord " ⇒ 
 + for { 
 + params ← Xor . fromOption ( optParams , InvalidParams ) 
 + result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 + } yield result 
 + case " putWord " ⇒ 
 + for { 
 + params ← Xor . fromOption ( optParams , InvalidParams ) 
 + result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 + } yield result 
 + } 
 + 
 + override protected def handleInternal = implicit client ⇒ { 
 + case GetWord ( word ) ⇒ getWord ( word ) 
 + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 + } 
 + 
 + def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 + ( for { 
 + optValue ← point ( kv . get ( word ) ) 
 + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 + } yield ApiMapValue ( result ) ) . value 
 + } 
 + 
 + def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 + ( for { 
 + _ ← point ( kv . put ( word , meaning ) ) 
 + } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value 
 + } 
 + } 
 + 
 / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service 
 
 - private final class EchoService ( system : ActorSystem ) extends RawApiService ( system ) { 
 + private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { 
 import ServiceErrors . _ 
 
 override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 case " makeEcho " ⇒ echo ( params ) 
 } 
 
 - def echo ( params : Option [ ApiRawValue ] ) : Response = { 
 + def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { 
 val resp = extractStringFromMap ( params , " query " ) map { q ⇒ 
 Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) 
 } getOrElse Xor . left ( InvalidParams ) 
 @ @ - 161 , 7 + 255 , 7 @ @ class RawServiceSpec 
 
 private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = 
 optParams flatMap { 
 - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( ` key ` , ApiStringValue ( str ) ) ⇒ str } 
 + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } 
 case _ ⇒ None 
 } 
 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 17be8ce . . a259645 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 172 , 8 + 172 , 7 @ @ object Dependencies { 
 jodaTime , 
 postgresJdbc , 
 shardakka , 
 - scrImageCore , 
 - upickle 
 + scrImageCore 
 ) 
 
 val enrich = shared + + Seq ( akkaActor , akkaHttp )
