BLEU SCORE: 0.28617394805234075

TEST MSG: feat ( core ) : Strip entities optimization support
GENERATED MSG: feat ( core ) : Adding encryption session actor and loading required keys

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java < nl > index c5efaf3 . . d63c00c 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java < nl > @ @ - 52 , 6 + 52 , 7 @ @ public class SequenceActor extends ModuleActor { < nl > private int seq ; < nl > private byte [ ] state ; < nl > private int finishedSeq ; < nl > + private byte [ ] finishedState ; < nl > < nl > private SequenceHandlerInt handler ; < nl > < nl > @ @ - 129 , 6 + 130 , 13 @ @ public class SequenceActor extends ModuleActor { < nl > Log . d ( TAG , " Handling update ended # " + seq ) ; < nl > onUpdatesApplied ( seq , state ) ; < nl > } < nl > + } ) . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + SequenceActor . this . seq = finishedSeq ; < nl > + SequenceActor . this . state = finishedState ; < nl > + invalidate ( ) ; < nl > + } < nl > } ) . done ( self ( ) ) ; < nl > < nl > / / Saving memory - only state < nl > @ @ - 148 , 7 + 156 , 9 @ @ public class SequenceActor extends ModuleActor { < nl > < nl > if ( seq < 0 ) { < nl > Log . d ( TAG , " Loading fresh state . . . " ) ; < nl > - request ( new RequestGetState ( new ArrayList < ApiUpdateOptimization > ( ) ) , new RpcCallback < ResponseSeq > ( ) { < nl > + ArrayList < ApiUpdateOptimization > optimizations = new ArrayList < > ( ) ; < nl > + optimizations . add ( ApiUpdateOptimization . STRIP _ ENTITIES ) ; < nl > + request ( new RequestGetState ( optimizations ) , new RpcCallback < ResponseSeq > ( ) { < nl > @ Override < nl > public void onResult ( ResponseSeq response ) { < nl > if ( isValidated ) { < nl > @ @ - 176 , 7 + 186 , 9 @ @ public class SequenceActor extends ModuleActor { < nl > Log . d ( TAG , " Loading difference . . . " ) ; < nl > onUpdateStarted ( ) ; < nl > final long loadStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > - request ( new RequestGetDifference ( seq , state , new ArrayList < ApiUpdateOptimization > ( ) ) , new RpcCallback < ResponseGetDifference > ( ) { < nl > + ArrayList < ApiUpdateOptimization > optimizations = new ArrayList < > ( ) ; < nl > + optimizations . add ( ApiUpdateOptimization . STRIP _ ENTITIES ) ; < nl > + request ( new RequestGetDifference ( seq , state , optimizations ) , new RpcCallback < ResponseGetDifference > ( ) { < nl > @ Override < nl > public void onResult ( final ResponseGetDifference response ) { < nl > if ( isValidated ) { < nl > @ @ - 237 , 6 + 249 , 7 @ @ public class SequenceActor extends ModuleActor { < nl > < nl > private void persistState ( int seq , byte [ ] state ) { < nl > finishedSeq = seq ; < nl > + finishedState = state ; < nl > preferences ( ) . putInt ( KEY _ SEQ , seq ) ; < nl > preferences ( ) . putBytes ( KEY _ STATE , state ) ; < nl > } < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java < nl > index d6e836b . . 12b1268 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java < nl > @ @ - 7 , 10 + 7 , 16 @ @ import java . util . ArrayList ; < nl > import java . util . List ; < nl > < nl > import im . actor . core . api . ApiGroup ; < nl > + import im . actor . core . api . ApiGroupOutPeer ; < nl > + import im . actor . core . api . ApiOutPeer ; < nl > import im . actor . core . api . ApiUpdateContainer ; < nl > import im . actor . core . api . ApiUser ; < nl > + import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . parser . UpdatesParser ; < nl > + import im . actor . core . api . rpc . RequestGetReferencedEntitites ; < nl > + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > import im . actor . core . api . rpc . ResponseGetDifference ; < nl > + import im . actor . core . api . rpc . ResponseGetReferencedEntitites ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . updates . UpdateProcessor ; < nl > import im . actor . core . modules . updates . internal . InternalUpdate ; < nl > @ @ - 20 , 7 + 26 , 10 @ @ import im . actor . core . network . parser . Update ; < nl > import im . actor . runtime . Log ; < nl > import im . actor . runtime . actors . ask . AskMessage ; < nl > import im . actor . runtime . function . Constructor ; < nl > + import im . actor . runtime . function . Consumer ; < nl > + import im . actor . runtime . function . Function ; < nl > import im . actor . runtime . promise . Promise ; < nl > + import im . actor . runtime . promise . PromiseFunc ; < nl > import im . actor . runtime . promise . PromiseResolver ; < nl > import im . actor . runtime . promise . Promises ; < nl > < nl > @ @ - 39 , 6 + 48 , 7 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > < nl > private UpdateProcessor processor ; < nl > private UpdatesParser updatesParser ; < nl > + private boolean isUpdating ; < nl > < nl > public SequenceHandlerActor ( ModuleContext context ) { < nl > super ( context ) ; < nl > @ @ - 75 , 7 + 85 , 8 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > afterApply . run ( ) ; < nl > } < nl > < nl > - private Promise < UpdateProcessed > onSeqUpdate ( int type , byte [ ] body , @ Nullable List < ApiUser > users , < nl > + private Promise < UpdateProcessed > onSeqUpdate ( int type , byte [ ] body , < nl > + @ Nullable List < ApiUser > users , < nl > @ Nullable List < ApiGroup > groups ) throws Exception { < nl > < nl > Update update ; < nl > @ @ - 87 , 13 + 98 , 12 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > return Promises . success ( new UpdateProcessed ( ) ) ; < nl > } < nl > < nl > - / / TODO : Implement < nl > - / / if ( groups = = null | | users = = null ) { < nl > - / / if ( processor . isCausesInvalidation ( update ) ) { < nl > - / / Log . w ( TAG , " Difference is required " ) ; < nl > - / / throw new RuntimeException ( ) ; < nl > - / / } < nl > - / / } < nl > + if ( groups = = null | | users = = null ) { < nl > + if ( processor . isCausesInvalidation ( update ) ) { < nl > + Log . w ( TAG , " Difference is required " ) ; < nl > + throw new RuntimeException ( " Difference is required " ) ; < nl > + } < nl > + } < nl > < nl > / / Processing update < nl > Log . d ( TAG , " Processing update : " + update ) ; < nl > @ @ - 112 , 9 + 122 , 9 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > return Promises . success ( new UpdateProcessed ( ) ) ; < nl > } < nl > < nl > - private Promise < UpdateProcessed > onDifferenceUpdate ( ResponseGetDifference difference ) { < nl > + private Promise < UpdateProcessed > onDifferenceUpdate ( final ResponseGetDifference difference ) { < nl > long parseStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > - ArrayList < Update > updates = new ArrayList < Update > ( ) ; < nl > + final ArrayList < Update > updates = new ArrayList < Update > ( ) ; < nl > for ( ApiUpdateContainer u : difference . getUpdates ( ) ) { < nl > try { < nl > updates . add ( updatesParser . read ( u . getUpdateHeader ( ) , u . getUpdate ( ) ) ) ; < nl > @ @ - 133 , 10 + 143 , 58 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > Log . d ( TAG , command ) ; < nl > } < nl > < nl > - long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > - processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; < nl > - Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; < nl > - return Promises . success ( new UpdateProcessed ( ) ) ; < nl > + final ArrayList < ApiUserOutPeer > pendingUserPeers = new ArrayList < > ( ) ; < nl > + final ArrayList < ApiGroupOutPeer > pendingGroupPeers = new ArrayList < > ( ) ; < nl > + for ( ApiUserOutPeer refPeer : difference . getUsersRefs ( ) ) { < nl > + if ( getUser ( refPeer . getUid ( ) ) ! = null ) { < nl > + continue ; < nl > + } < nl > + pendingUserPeers . add ( refPeer ) ; < nl > + } < nl > + for ( ApiGroupOutPeer refPeer : difference . getGroupsRefs ( ) ) { < nl > + if ( getGroup ( refPeer . getGroupId ( ) ) ! = null ) { < nl > + continue ; < nl > + } < nl > + pendingGroupPeers . add ( refPeer ) ; < nl > + } < nl > + < nl > + if ( pendingGroupPeers . size ( ) > 0 | | pendingUserPeers . size ( ) > 0 ) { < nl > + Log . d ( TAG , " Downloading pending peers ( users : " + pendingUserPeers . size ( ) + " , groups : " + pendingGroupPeers . size ( ) + " ) " ) ; < nl > + isUpdating = true ; < nl > + return new Promise < > ( new PromiseFunc < UpdateProcessed > ( ) { < nl > + @ Override < nl > + public void exec ( final PromiseResolver < UpdateProcessed > resolver ) { < nl > + api ( new RequestGetReferencedEntitites ( pendingUserPeers , pendingGroupPeers ) ) < nl > + . then ( new Consumer < ResponseGetReferencedEntitites > ( ) { < nl > + @ Override < nl > + public void apply ( ResponseGetReferencedEntitites responseGetReferencedEntitites ) { < nl > + Log . d ( TAG , " Pending peers downloaded " ) ; < nl > + processor . applyRelated ( responseGetReferencedEntitites . getUsers ( ) , < nl > + responseGetReferencedEntitites . getGroups ( ) , false ) ; < nl > + long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > + processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; < nl > + Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; < nl > + resolver . result ( new UpdateProcessed ( ) ) ; < nl > + unstashAll ( ) ; < nl > + isUpdating = false ; < nl > + } < nl > + } ) < nl > + . failure ( new Consumer < Exception > ( ) { < nl > + @ Override < nl > + public void apply ( Exception e ) { < nl > + resolver . error ( e ) ; < nl > + unstashAll ( ) ; < nl > + isUpdating = false ; < nl > + } < nl > + } ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; < nl > + processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; < nl > + Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; < nl > + return Promises . success ( new UpdateProcessed ( ) ) ; < nl > + } < nl > } < nl > < nl > @ Override < nl > @ @ - 150 , 9 + 208 , 17 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > e . printStackTrace ( ) ; < nl > } < nl > } else if ( message instanceof RelatedResponse ) { < nl > + if ( isUpdating ) { < nl > + stash ( ) ; < nl > + return ; < nl > + } < nl > onRelatedResponse ( ( ( RelatedResponse ) message ) . getRelatedUsers ( ) , ( ( RelatedResponse ) message ) . getRelatedGroups ( ) , < nl > ( ( RelatedResponse ) message ) . getAfterApply ( ) ) ; < nl > } else if ( message instanceof InternalUpdate ) { < nl > + if ( isUpdating ) { < nl > + stash ( ) ; < nl > + return ; < nl > + } < nl > onInternalUpdate ( ( InternalUpdate ) message ) ; < nl > } else { < nl > super . onReceive ( message ) ; < nl > @ @ - 163 , 9 + 229 , 17 @ @ public class SequenceHandlerActor extends ModuleActor { < nl > public Promise onAsk ( Object message ) throws Exception { < nl > if ( message instanceof SeqUpdate ) { < nl > SeqUpdate seqUpdate = ( SeqUpdate ) message ; < nl > + if ( isUpdating ) { < nl > + stash ( ) ; < nl > + return null ; < nl > + } < nl > return onSeqUpdate ( seqUpdate . type , seqUpdate . body , seqUpdate . users , seqUpdate . groups ) ; < nl > } else if ( message instanceof DifferenceUpdate ) { < nl > DifferenceUpdate differenceUpdate = ( DifferenceUpdate ) message ; < nl > + if ( isUpdating ) { < nl > + stash ( ) ; < nl > + return null ; < nl > + } < nl > return onDifferenceUpdate ( differenceUpdate . getDifference ( ) ) ; < nl > } else { < nl > return super . onAsk ( message ) ;
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java < nl > index f22e3e4 . . 6fc2e4b 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java < nl > @ @ - 1 , 37 + 1 , 32 @ @ < nl > package im . actor . core . modules . internal . encryption ; < nl > < nl > import java . util . ArrayList ; < nl > + import java . util . HashMap ; < nl > < nl > + import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > + import im . actor . core . api . ApiUserOutPeer ; < nl > + import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; < nl > + import im . actor . core . api . rpc . ResponsePublicKeyGroups ; < nl > + import im . actor . core . entity . User ; < nl > import im . actor . core . modules . ModuleContext ; < nl > import im . actor . core . modules . internal . encryption . entity . EncryptedBox ; < nl > - import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; < nl > + import im . actor . core . network . RpcCallback ; < nl > + import im . actor . core . network . RpcException ; < nl > import im . actor . core . util . ModuleActor ; < nl > - import im . actor . core . util . RandomUtils ; < nl > - import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > + import im . actor . runtime . actors . ActorCreator ; < nl > + import im . actor . runtime . actors . ActorRef ; < nl > import im . actor . runtime . actors . Future ; < nl > - import im . actor . runtime . actors . ask . AskCallback ; < nl > + import im . actor . runtime . actors . Props ; < nl > import im . actor . runtime . actors . ask . AskRequest ; < nl > - import im . actor . runtime . crypto . Curve25519 ; < nl > < nl > public class EncryptedStateActor extends ModuleActor { < nl > < nl > private static final String TAG = " EncryptedStateActor " ; < nl > < nl > private int uid ; < nl > - private EncryptionKey ownIdentityKey ; < nl > - private EncryptionKey theirIdentityKey ; < nl > - private EncryptionKey ownEphermalKey0 ; < nl > - private EncryptionKey theirEphermalKey0 ; < nl > - < nl > - private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; < nl > - private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; < nl > - < nl > - private EncryptionKey currentOwnKey ; < nl > - private EncryptionKey currentTheirKey ; < nl > - < nl > - private byte [ ] rootChainKey ; < nl > - < nl > + private ArrayList < ApiEncryptionKeyGroup > keyGroups ; < nl > + private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; < nl > private boolean isReady = false ; < nl > < nl > public EncryptedStateActor ( int uid , ModuleContext context ) { < nl > @ @ - 43 , 38 + 38 , 40 @ @ public class EncryptedStateActor extends ModuleActor { < nl > public void preStart ( ) { < nl > super . preStart ( ) ; < nl > < nl > - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > + if ( keyGroups = = null ) { < nl > Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > + User user = getUser ( uid ) ; < nl > + request ( new RequestLoadPublicKeyGroups ( new ApiUserOutPeer ( user . getUid ( ) , user . getAccessHash ( ) ) ) , new RpcCallback < ResponsePublicKeyGroups > ( ) { < nl > @ Override < nl > - public void onResult ( Object obj ) { < nl > - Log . d ( TAG , " Own keys loaded " ) ; < nl > - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > - ownIdentityKey = res . getIdentityKey ( ) ; < nl > - ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > - currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > - onOwnReady ( ) ; < nl > + public void onResult ( ResponsePublicKeyGroups response ) { < nl > + keyGroups = new ArrayList < ApiEncryptionKeyGroup > ( response . getPublicKeyGroups ( ) ) ; < nl > + onGroupsReady ( ) ; < nl > } < nl > < nl > @ Override < nl > - public void onError ( Exception e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Own keys error " ) ; < nl > + public void onError ( RpcException e ) { < nl > + Log . d ( TAG , " Error during loading public key groups " ) ; < nl > Log . e ( TAG , e ) ; < nl > < nl > + / / Do nothing < nl > } < nl > } ) ; < nl > } else { < nl > - onOwnReady ( ) ; < nl > + onGroupsReady ( ) ; < nl > } < nl > } < nl > < nl > - private void onOwnReady ( ) { < nl > - Log . w ( TAG , " Own keys ready " ) ; < nl > - } < nl > - < nl > - private void onTheirReady ( ) { < nl > + private void onGroupsReady ( ) { < nl > + Log . w ( TAG , " Groups ready # " + keyGroups . size ( ) ) ; < nl > < nl > + for ( final ApiEncryptionKeyGroup g : keyGroups ) { < nl > + sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptionSessionActor . class , new ActorCreator < EncryptionSessionActor > ( ) { < nl > + @ Override < nl > + public EncryptionSessionActor create ( ) { < nl > + return new EncryptionSessionActor ( context ( ) , uid , g ) ; < nl > + } < nl > + } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; < nl > + } < nl > } < nl > < nl > private void doEncrypt ( byte [ ] data , Future future ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java < nl > new file mode 100644 < nl > index 0000000 . . 119e3d5 < nl > - - - / dev / null < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java < nl > @ @ - 0 , 0 + 1 , 151 @ @ < nl > + package im . actor . core . modules . internal . encryption ; < nl > + < nl > + import java . util . ArrayList ; < nl > + < nl > + import im . actor . core . api . ApiEncryptionKey ; < nl > + import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > + import im . actor . core . api . ApiUserOutPeer ; < nl > + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; < nl > + import im . actor . core . api . rpc . ResponsePublicKeys ; < nl > + import im . actor . core . modules . ModuleContext ; < nl > + import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; < nl > + import im . actor . core . network . RpcCallback ; < nl > + import im . actor . core . network . RpcException ; < nl > + import im . actor . core . util . ModuleActor ; < nl > + import im . actor . core . util . RandomUtils ; < nl > + import im . actor . runtime . Crypto ; < nl > + import im . actor . runtime . Log ; < nl > + import im . actor . runtime . actors . Future ; < nl > + import im . actor . runtime . actors . ask . AskCallback ; < nl > + import im . actor . runtime . crypto . Curve25519 ; < nl > + < nl > + public class EncryptionSessionActor extends ModuleActor { < nl > + < nl > + private final String TAG ; < nl > + < nl > + private final int uid ; < nl > + private final ApiEncryptionKeyGroup encryptionKeyGroup ; < nl > + < nl > + private EncryptionKey ownIdentityKey ; < nl > + private EncryptionKey theirIdentityKey ; < nl > + private EncryptionKey ownEphermalKey0 ; < nl > + private EncryptionKey theirEphermalKey0 ; < nl > + < nl > + private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; < nl > + private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; < nl > + < nl > + private EncryptionKey currentOwnKey ; < nl > + private EncryptionKey currentTheirKey ; < nl > + < nl > + private byte [ ] rootChainKey ; < nl > + < nl > + private boolean isReady = false ; < nl > + < nl > + public EncryptionSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { < nl > + super ( context ) ; < nl > + this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; < nl > + this . uid = uid ; < nl > + this . encryptionKeyGroup = encryptionKeyGroup ; < nl > + } < nl > + < nl > + @ Override < nl > + public void preStart ( ) { < nl > + if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > + Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " Own keys loaded " ) ; < nl > + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > + ownIdentityKey = res . getIdentityKey ( ) ; < nl > + ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > + currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; < nl > + onOwnReady ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Own keys error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onOwnReady ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onOwnReady ( ) { < nl > + Log . w ( TAG , " Own keys ready " ) ; < nl > + < nl > + if ( theirEphermalKey0 = = null ) { < nl > + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + return ; < nl > + } < nl > + < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; < nl > + theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Their ephemeral error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void onTheirReady0 ( ) { < nl > + Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > + < nl > + if ( currentTheirKey = = null ) { < nl > + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + @ Override < nl > + public void onResult ( ResponsePublicKeys response ) { < nl > + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + return ; < nl > + } < nl > + < nl > + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; < nl > + allSet ( ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public void onError ( RpcException e ) { < nl > + / / Nothing to do < nl > + Log . w ( TAG , " Their ephemeral error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > + } < nl > + } ) ; < nl > + } else { < nl > + onTheirReady0 ( ) ; < nl > + } < nl > + } < nl > + < nl > + private void allSet ( ) { < nl > + Log . d ( TAG , " All keys are ready " ) ; < nl > + < nl > + } < nl > + < nl > + @ Override < nl > + public void onReceive ( Object message ) { < nl > + super . onReceive ( message ) ; < nl > + } < nl > + < nl > + @ Override < nl > + public boolean onAsk ( Object message , Future future ) { < nl > + return super . onAsk ( message , future ) ; < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java 
 index c5efaf3 . . d63c00c 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceActor . java 
 @ @ - 52 , 6 + 52 , 7 @ @ public class SequenceActor extends ModuleActor { 
 private int seq ; 
 private byte [ ] state ; 
 private int finishedSeq ; 
 + private byte [ ] finishedState ; 
 
 private SequenceHandlerInt handler ; 
 
 @ @ - 129 , 6 + 130 , 13 @ @ public class SequenceActor extends ModuleActor { 
 Log . d ( TAG , " Handling update ended # " + seq ) ; 
 onUpdatesApplied ( seq , state ) ; 
 } 
 + } ) . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + SequenceActor . this . seq = finishedSeq ; 
 + SequenceActor . this . state = finishedState ; 
 + invalidate ( ) ; 
 + } 
 } ) . done ( self ( ) ) ; 
 
 / / Saving memory - only state 
 @ @ - 148 , 7 + 156 , 9 @ @ public class SequenceActor extends ModuleActor { 
 
 if ( seq < 0 ) { 
 Log . d ( TAG , " Loading fresh state . . . " ) ; 
 - request ( new RequestGetState ( new ArrayList < ApiUpdateOptimization > ( ) ) , new RpcCallback < ResponseSeq > ( ) { 
 + ArrayList < ApiUpdateOptimization > optimizations = new ArrayList < > ( ) ; 
 + optimizations . add ( ApiUpdateOptimization . STRIP _ ENTITIES ) ; 
 + request ( new RequestGetState ( optimizations ) , new RpcCallback < ResponseSeq > ( ) { 
 @ Override 
 public void onResult ( ResponseSeq response ) { 
 if ( isValidated ) { 
 @ @ - 176 , 7 + 186 , 9 @ @ public class SequenceActor extends ModuleActor { 
 Log . d ( TAG , " Loading difference . . . " ) ; 
 onUpdateStarted ( ) ; 
 final long loadStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 - request ( new RequestGetDifference ( seq , state , new ArrayList < ApiUpdateOptimization > ( ) ) , new RpcCallback < ResponseGetDifference > ( ) { 
 + ArrayList < ApiUpdateOptimization > optimizations = new ArrayList < > ( ) ; 
 + optimizations . add ( ApiUpdateOptimization . STRIP _ ENTITIES ) ; 
 + request ( new RequestGetDifference ( seq , state , optimizations ) , new RpcCallback < ResponseGetDifference > ( ) { 
 @ Override 
 public void onResult ( final ResponseGetDifference response ) { 
 if ( isValidated ) { 
 @ @ - 237 , 6 + 249 , 7 @ @ public class SequenceActor extends ModuleActor { 
 
 private void persistState ( int seq , byte [ ] state ) { 
 finishedSeq = seq ; 
 + finishedState = state ; 
 preferences ( ) . putInt ( KEY _ SEQ , seq ) ; 
 preferences ( ) . putBytes ( KEY _ STATE , state ) ; 
 } 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java 
 index d6e836b . . 12b1268 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / sequence / SequenceHandlerActor . java 
 @ @ - 7 , 10 + 7 , 16 @ @ import java . util . ArrayList ; 
 import java . util . List ; 
 
 import im . actor . core . api . ApiGroup ; 
 + import im . actor . core . api . ApiGroupOutPeer ; 
 + import im . actor . core . api . ApiOutPeer ; 
 import im . actor . core . api . ApiUpdateContainer ; 
 import im . actor . core . api . ApiUser ; 
 + import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . parser . UpdatesParser ; 
 + import im . actor . core . api . rpc . RequestGetReferencedEntitites ; 
 + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 import im . actor . core . api . rpc . ResponseGetDifference ; 
 + import im . actor . core . api . rpc . ResponseGetReferencedEntitites ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . updates . UpdateProcessor ; 
 import im . actor . core . modules . updates . internal . InternalUpdate ; 
 @ @ - 20 , 7 + 26 , 10 @ @ import im . actor . core . network . parser . Update ; 
 import im . actor . runtime . Log ; 
 import im . actor . runtime . actors . ask . AskMessage ; 
 import im . actor . runtime . function . Constructor ; 
 + import im . actor . runtime . function . Consumer ; 
 + import im . actor . runtime . function . Function ; 
 import im . actor . runtime . promise . Promise ; 
 + import im . actor . runtime . promise . PromiseFunc ; 
 import im . actor . runtime . promise . PromiseResolver ; 
 import im . actor . runtime . promise . Promises ; 
 
 @ @ - 39 , 6 + 48 , 7 @ @ public class SequenceHandlerActor extends ModuleActor { 
 
 private UpdateProcessor processor ; 
 private UpdatesParser updatesParser ; 
 + private boolean isUpdating ; 
 
 public SequenceHandlerActor ( ModuleContext context ) { 
 super ( context ) ; 
 @ @ - 75 , 7 + 85 , 8 @ @ public class SequenceHandlerActor extends ModuleActor { 
 afterApply . run ( ) ; 
 } 
 
 - private Promise < UpdateProcessed > onSeqUpdate ( int type , byte [ ] body , @ Nullable List < ApiUser > users , 
 + private Promise < UpdateProcessed > onSeqUpdate ( int type , byte [ ] body , 
 + @ Nullable List < ApiUser > users , 
 @ Nullable List < ApiGroup > groups ) throws Exception { 
 
 Update update ; 
 @ @ - 87 , 13 + 98 , 12 @ @ public class SequenceHandlerActor extends ModuleActor { 
 return Promises . success ( new UpdateProcessed ( ) ) ; 
 } 
 
 - / / TODO : Implement 
 - / / if ( groups = = null | | users = = null ) { 
 - / / if ( processor . isCausesInvalidation ( update ) ) { 
 - / / Log . w ( TAG , " Difference is required " ) ; 
 - / / throw new RuntimeException ( ) ; 
 - / / } 
 - / / } 
 + if ( groups = = null | | users = = null ) { 
 + if ( processor . isCausesInvalidation ( update ) ) { 
 + Log . w ( TAG , " Difference is required " ) ; 
 + throw new RuntimeException ( " Difference is required " ) ; 
 + } 
 + } 
 
 / / Processing update 
 Log . d ( TAG , " Processing update : " + update ) ; 
 @ @ - 112 , 9 + 122 , 9 @ @ public class SequenceHandlerActor extends ModuleActor { 
 return Promises . success ( new UpdateProcessed ( ) ) ; 
 } 
 
 - private Promise < UpdateProcessed > onDifferenceUpdate ( ResponseGetDifference difference ) { 
 + private Promise < UpdateProcessed > onDifferenceUpdate ( final ResponseGetDifference difference ) { 
 long parseStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 - ArrayList < Update > updates = new ArrayList < Update > ( ) ; 
 + final ArrayList < Update > updates = new ArrayList < Update > ( ) ; 
 for ( ApiUpdateContainer u : difference . getUpdates ( ) ) { 
 try { 
 updates . add ( updatesParser . read ( u . getUpdateHeader ( ) , u . getUpdate ( ) ) ) ; 
 @ @ - 133 , 10 + 143 , 58 @ @ public class SequenceHandlerActor extends ModuleActor { 
 Log . d ( TAG , command ) ; 
 } 
 
 - long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 - processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; 
 - Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; 
 - return Promises . success ( new UpdateProcessed ( ) ) ; 
 + final ArrayList < ApiUserOutPeer > pendingUserPeers = new ArrayList < > ( ) ; 
 + final ArrayList < ApiGroupOutPeer > pendingGroupPeers = new ArrayList < > ( ) ; 
 + for ( ApiUserOutPeer refPeer : difference . getUsersRefs ( ) ) { 
 + if ( getUser ( refPeer . getUid ( ) ) ! = null ) { 
 + continue ; 
 + } 
 + pendingUserPeers . add ( refPeer ) ; 
 + } 
 + for ( ApiGroupOutPeer refPeer : difference . getGroupsRefs ( ) ) { 
 + if ( getGroup ( refPeer . getGroupId ( ) ) ! = null ) { 
 + continue ; 
 + } 
 + pendingGroupPeers . add ( refPeer ) ; 
 + } 
 + 
 + if ( pendingGroupPeers . size ( ) > 0 | | pendingUserPeers . size ( ) > 0 ) { 
 + Log . d ( TAG , " Downloading pending peers ( users : " + pendingUserPeers . size ( ) + " , groups : " + pendingGroupPeers . size ( ) + " ) " ) ; 
 + isUpdating = true ; 
 + return new Promise < > ( new PromiseFunc < UpdateProcessed > ( ) { 
 + @ Override 
 + public void exec ( final PromiseResolver < UpdateProcessed > resolver ) { 
 + api ( new RequestGetReferencedEntitites ( pendingUserPeers , pendingGroupPeers ) ) 
 + . then ( new Consumer < ResponseGetReferencedEntitites > ( ) { 
 + @ Override 
 + public void apply ( ResponseGetReferencedEntitites responseGetReferencedEntitites ) { 
 + Log . d ( TAG , " Pending peers downloaded " ) ; 
 + processor . applyRelated ( responseGetReferencedEntitites . getUsers ( ) , 
 + responseGetReferencedEntitites . getGroups ( ) , false ) ; 
 + long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 + processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; 
 + Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; 
 + resolver . result ( new UpdateProcessed ( ) ) ; 
 + unstashAll ( ) ; 
 + isUpdating = false ; 
 + } 
 + } ) 
 + . failure ( new Consumer < Exception > ( ) { 
 + @ Override 
 + public void apply ( Exception e ) { 
 + resolver . error ( e ) ; 
 + unstashAll ( ) ; 
 + isUpdating = false ; 
 + } 
 + } ) ; 
 + } 
 + } ) ; 
 + } else { 
 + long applyStart = im . actor . runtime . Runtime . getCurrentTime ( ) ; 
 + processor . applyDifferenceUpdate ( difference . getUsers ( ) , difference . getGroups ( ) , updates ) ; 
 + Log . d ( TAG , " Difference applied in " + ( im . actor . runtime . Runtime . getCurrentTime ( ) - applyStart ) + " ms " ) ; 
 + return Promises . success ( new UpdateProcessed ( ) ) ; 
 + } 
 } 
 
 @ Override 
 @ @ - 150 , 9 + 208 , 17 @ @ public class SequenceHandlerActor extends ModuleActor { 
 e . printStackTrace ( ) ; 
 } 
 } else if ( message instanceof RelatedResponse ) { 
 + if ( isUpdating ) { 
 + stash ( ) ; 
 + return ; 
 + } 
 onRelatedResponse ( ( ( RelatedResponse ) message ) . getRelatedUsers ( ) , ( ( RelatedResponse ) message ) . getRelatedGroups ( ) , 
 ( ( RelatedResponse ) message ) . getAfterApply ( ) ) ; 
 } else if ( message instanceof InternalUpdate ) { 
 + if ( isUpdating ) { 
 + stash ( ) ; 
 + return ; 
 + } 
 onInternalUpdate ( ( InternalUpdate ) message ) ; 
 } else { 
 super . onReceive ( message ) ; 
 @ @ - 163 , 9 + 229 , 17 @ @ public class SequenceHandlerActor extends ModuleActor { 
 public Promise onAsk ( Object message ) throws Exception { 
 if ( message instanceof SeqUpdate ) { 
 SeqUpdate seqUpdate = ( SeqUpdate ) message ; 
 + if ( isUpdating ) { 
 + stash ( ) ; 
 + return null ; 
 + } 
 return onSeqUpdate ( seqUpdate . type , seqUpdate . body , seqUpdate . users , seqUpdate . groups ) ; 
 } else if ( message instanceof DifferenceUpdate ) { 
 DifferenceUpdate differenceUpdate = ( DifferenceUpdate ) message ; 
 + if ( isUpdating ) { 
 + stash ( ) ; 
 + return null ; 
 + } 
 return onDifferenceUpdate ( differenceUpdate . getDifference ( ) ) ; 
 } else { 
 return super . onAsk ( message ) ;

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java 
 index f22e3e4 . . 6fc2e4b 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptedStateActor . java 
 @ @ - 1 , 37 + 1 , 32 @ @ 
 package im . actor . core . modules . internal . encryption ; 
 
 import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 
 + import im . actor . core . api . ApiEncryptionKeyGroup ; 
 + import im . actor . core . api . ApiUserOutPeer ; 
 + import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; 
 + import im . actor . core . api . rpc . ResponsePublicKeyGroups ; 
 + import im . actor . core . entity . User ; 
 import im . actor . core . modules . ModuleContext ; 
 import im . actor . core . modules . internal . encryption . entity . EncryptedBox ; 
 - import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; 
 + import im . actor . core . network . RpcCallback ; 
 + import im . actor . core . network . RpcException ; 
 import im . actor . core . util . ModuleActor ; 
 - import im . actor . core . util . RandomUtils ; 
 - import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 + import im . actor . runtime . actors . ActorCreator ; 
 + import im . actor . runtime . actors . ActorRef ; 
 import im . actor . runtime . actors . Future ; 
 - import im . actor . runtime . actors . ask . AskCallback ; 
 + import im . actor . runtime . actors . Props ; 
 import im . actor . runtime . actors . ask . AskRequest ; 
 - import im . actor . runtime . crypto . Curve25519 ; 
 
 public class EncryptedStateActor extends ModuleActor { 
 
 private static final String TAG = " EncryptedStateActor " ; 
 
 private int uid ; 
 - private EncryptionKey ownIdentityKey ; 
 - private EncryptionKey theirIdentityKey ; 
 - private EncryptionKey ownEphermalKey0 ; 
 - private EncryptionKey theirEphermalKey0 ; 
 - 
 - private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; 
 - private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; 
 - 
 - private EncryptionKey currentOwnKey ; 
 - private EncryptionKey currentTheirKey ; 
 - 
 - private byte [ ] rootChainKey ; 
 - 
 + private ArrayList < ApiEncryptionKeyGroup > keyGroups ; 
 + private HashMap < Integer , ActorRef > sessions = new HashMap < Integer , ActorRef > ( ) ; 
 private boolean isReady = false ; 
 
 public EncryptedStateActor ( int uid , ModuleContext context ) { 
 @ @ - 43 , 38 + 38 , 40 @ @ public class EncryptedStateActor extends ModuleActor { 
 public void preStart ( ) { 
 super . preStart ( ) ; 
 
 - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 + if ( keyGroups = = null ) { 
 Log . d ( TAG , " Loading own keys for conversation " ) ; 
 - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 + User user = getUser ( uid ) ; 
 + request ( new RequestLoadPublicKeyGroups ( new ApiUserOutPeer ( user . getUid ( ) , user . getAccessHash ( ) ) ) , new RpcCallback < ResponsePublicKeyGroups > ( ) { 
 @ Override 
 - public void onResult ( Object obj ) { 
 - Log . d ( TAG , " Own keys loaded " ) ; 
 - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 - ownIdentityKey = res . getIdentityKey ( ) ; 
 - ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 - currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 - onOwnReady ( ) ; 
 + public void onResult ( ResponsePublicKeyGroups response ) { 
 + keyGroups = new ArrayList < ApiEncryptionKeyGroup > ( response . getPublicKeyGroups ( ) ) ; 
 + onGroupsReady ( ) ; 
 } 
 
 @ Override 
 - public void onError ( Exception e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Own keys error " ) ; 
 + public void onError ( RpcException e ) { 
 + Log . d ( TAG , " Error during loading public key groups " ) ; 
 Log . e ( TAG , e ) ; 
 
 + / / Do nothing 
 } 
 } ) ; 
 } else { 
 - onOwnReady ( ) ; 
 + onGroupsReady ( ) ; 
 } 
 } 
 
 - private void onOwnReady ( ) { 
 - Log . w ( TAG , " Own keys ready " ) ; 
 - } 
 - 
 - private void onTheirReady ( ) { 
 + private void onGroupsReady ( ) { 
 + Log . w ( TAG , " Groups ready # " + keyGroups . size ( ) ) ; 
 
 + for ( final ApiEncryptionKeyGroup g : keyGroups ) { 
 + sessions . put ( g . getKeyGroupId ( ) , system ( ) . actorOf ( Props . create ( EncryptionSessionActor . class , new ActorCreator < EncryptionSessionActor > ( ) { 
 + @ Override 
 + public EncryptionSessionActor create ( ) { 
 + return new EncryptionSessionActor ( context ( ) , uid , g ) ; 
 + } 
 + } ) , getPath ( ) + " / k _ " + g . getKeyGroupId ( ) ) ) ; 
 + } 
 } 
 
 private void doEncrypt ( byte [ ] data , Future future ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java 
 new file mode 100644 
 index 0000000 . . 119e3d5 
 - - - / dev / null 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / internal / encryption / EncryptionSessionActor . java 
 @ @ - 0 , 0 + 1 , 151 @ @ 
 + package im . actor . core . modules . internal . encryption ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import im . actor . core . api . ApiEncryptionKey ; 
 + import im . actor . core . api . ApiEncryptionKeyGroup ; 
 + import im . actor . core . api . ApiUserOutPeer ; 
 + import im . actor . core . api . rpc . RequestLoadEphermalPublicKeys ; 
 + import im . actor . core . api . rpc . ResponsePublicKeys ; 
 + import im . actor . core . modules . ModuleContext ; 
 + import im . actor . core . modules . internal . encryption . entity . EncryptionKey ; 
 + import im . actor . core . network . RpcCallback ; 
 + import im . actor . core . network . RpcException ; 
 + import im . actor . core . util . ModuleActor ; 
 + import im . actor . core . util . RandomUtils ; 
 + import im . actor . runtime . Crypto ; 
 + import im . actor . runtime . Log ; 
 + import im . actor . runtime . actors . Future ; 
 + import im . actor . runtime . actors . ask . AskCallback ; 
 + import im . actor . runtime . crypto . Curve25519 ; 
 + 
 + public class EncryptionSessionActor extends ModuleActor { 
 + 
 + private final String TAG ; 
 + 
 + private final int uid ; 
 + private final ApiEncryptionKeyGroup encryptionKeyGroup ; 
 + 
 + private EncryptionKey ownIdentityKey ; 
 + private EncryptionKey theirIdentityKey ; 
 + private EncryptionKey ownEphermalKey0 ; 
 + private EncryptionKey theirEphermalKey0 ; 
 + 
 + private ArrayList < EncryptionKey > prevOwnKeys = new ArrayList < EncryptionKey > ( ) ; 
 + private ArrayList < EncryptionKey > prevTheirKeys = new ArrayList < EncryptionKey > ( ) ; 
 + 
 + private EncryptionKey currentOwnKey ; 
 + private EncryptionKey currentTheirKey ; 
 + 
 + private byte [ ] rootChainKey ; 
 + 
 + private boolean isReady = false ; 
 + 
 + public EncryptionSessionActor ( ModuleContext context , int uid , ApiEncryptionKeyGroup encryptionKeyGroup ) { 
 + super ( context ) ; 
 + this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; 
 + this . uid = uid ; 
 + this . encryptionKeyGroup = encryptionKeyGroup ; 
 + } 
 + 
 + @ Override 
 + public void preStart ( ) { 
 + if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 + Log . d ( TAG , " Loading own keys for conversation " ) ; 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " Own keys loaded " ) ; 
 + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 + ownIdentityKey = res . getIdentityKey ( ) ; 
 + ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 + currentOwnKey = new EncryptionKey ( RandomUtils . nextRid ( ) , Curve25519 . keyGen ( Crypto . randomBytes ( 64 ) ) ) ; 
 + onOwnReady ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( Exception e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Own keys error " ) ; 
 + Log . e ( TAG , e ) ; 
 + 
 + } 
 + } ) ; 
 + } else { 
 + onOwnReady ( ) ; 
 + } 
 + } 
 + 
 + private void onOwnReady ( ) { 
 + Log . w ( TAG , " Own keys ready " ) ; 
 + 
 + if ( theirEphermalKey0 = = null ) { 
 + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + Log . w ( TAG , " No ephemeral keys found " ) ; 
 + return ; 
 + } 
 + 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( 0 ) ; 
 + theirEphermalKey0 = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 + onTheirReady0 ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Their ephemeral error " ) ; 
 + Log . e ( TAG , e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + onTheirReady0 ( ) ; 
 + } 
 + } 
 + 
 + private void onTheirReady0 ( ) { 
 + Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 + 
 + if ( currentTheirKey = = null ) { 
 + request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + @ Override 
 + public void onResult ( ResponsePublicKeys response ) { 
 + if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + Log . w ( TAG , " No ephemeral keys found " ) ; 
 + return ; 
 + } 
 + 
 + ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + currentTheirKey = new EncryptionKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) , null ) ; 
 + allSet ( ) ; 
 + } 
 + 
 + @ Override 
 + public void onError ( RpcException e ) { 
 + / / Nothing to do 
 + Log . w ( TAG , " Their ephemeral error " ) ; 
 + Log . e ( TAG , e ) ; 
 + } 
 + } ) ; 
 + } else { 
 + onTheirReady0 ( ) ; 
 + } 
 + } 
 + 
 + private void allSet ( ) { 
 + Log . d ( TAG , " All keys are ready " ) ; 
 + 
 + } 
 + 
 + @ Override 
 + public void onReceive ( Object message ) { 
 + super . onReceive ( message ) ; 
 + } 
 + 
 + @ Override 
 + public boolean onAsk ( Object message , Future future ) { 
 + return super . onAsk ( message , future ) ; 
 + } 
 + }
