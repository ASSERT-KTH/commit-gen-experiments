BLEU SCORE: 0.8091067115702212

TEST MSG: feat ( server : groups ) :
GENERATED MSG: fix ( server : groups ) :

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index 5a87046 . . b600c77 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 309 , 13 + 309 , 17 @ @ private [ group ] final case class GroupState ( < nl > * 1 - canClear . Default is FALSE . < nl > * 2 - canLeave . Default is FALSE . < nl > * 3 - canDelete . Default is FALSE . < nl > + * 4 - canJoin . Default is FALSE . < nl > + * 5 - canViewInfo . Default is FALSE . < nl > * / < nl > / / TODO : add ApiGroupFullPermissions < nl > def groupFor ( userId : Int ) : Long = { < nl > ( ( toInt ( canSendMessage ( userId ) ) < < 0 ) + < nl > ( toInt ( canClear ( userId ) ) < < 1 ) + < nl > ( toInt ( canLeave ( userId ) ) < < 2 ) + < nl > - ( toInt ( canDelete ( userId ) ) < < 3 ) ) . toLong < nl > + ( toInt ( canDelete ( userId ) ) < < 3 ) + < nl > + ( toInt ( canJoin ( userId ) ) < < 4 ) + < nl > + ( toInt ( canViewInfo ( userId ) ) < < 5 ) ) . toLong < nl > } < nl > < nl > / * * < nl > @ @ - 344 , 6 + 348 , 13 @ @ private [ group ] final case class GroupState ( < nl > / / only owner can delete group < nl > def canDelete ( clientUserId : Int ) : Boolean = isOwner ( clientUserId ) < nl > < nl > + / / anyone can join in group with shared history < nl > + def canJoin ( clientUserId : Int ) : Boolean = isHistoryShared < nl > + < nl > + / / if history shared - anyone can view info < nl > + / / only members can view info in private groups < nl > + def canViewInfo ( clientUserId : Int ) : Boolean = isHistoryShared | | isMember ( clientUserId ) < nl > + < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / Full group permissions / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > index efbd494 . . 5c82a2a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala < nl > @ @ - 6 , 7 + 6 , 7 @ @ import akka . actor . Status < nl > import akka . pattern . pipe < nl > import im . actor . api . rpc . Update < nl > import im . actor . api . rpc . groups . _ < nl > - import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateMessage } < nl > + import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateChatDropCache , UpdateMessage } < nl > import im . actor . concurrent . FutureExt < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . group . GroupCommands . { Invite , Join , Kick , Leave } < nl > @ @ - 39 , 8 + 39 , 12 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > val memberIds = newState . memberIds < nl > val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > < nl > - / / if user ever been in this group - we should push these updates , < nl > - val inviteeUpdatesNew : Vector [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > + / / if user ever been in this group - we should push these updates < nl > + / / TODO : unify isHistoryShared usage < nl > + val inviteeUpdatesNew : Vector [ Update ] = { < nl > + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > + optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > + } < nl > < nl > val membersUpdateNew : Update = < nl > if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > @ @ - 219 , 9 + 223 , 12 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > / / that means we need to push all group - info related updates < nl > / / < nl > / / If user was invited to group by other member - we don ' t need to push group updates , < nl > - / / cause they we pushed already on invite step < nl > - val joiningUserUpdatesNew : Vector [ Update ] = < nl > - if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > + / / cause they were pushed already on invite step < nl > + / / TODO : unify isHistoryShared usage < nl > + val joiningUserUpdatesNew : Vector [ Update ] = { < nl > + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None < nl > + optDrop + + : ( if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) ) < nl > + } < nl > < nl > val membersUpdateNew : Update = < nl > if ( newState . groupType . isChannel ) / / if channel , or group is big enough < nl > @ @ - 594 , 6 + 601 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { < nl > / / Updates that will be sent to user , when he enters group . < nl > / / Helps clients that have this group to refresh it ' s data . < nl > private def refreshGroupUpdates ( newState : GroupState , userId : Int ) : Vector [ Update ] = Vector ( < nl > + UpdateChatDropCache ( apiGroupPeer ) , < nl > UpdateGroupMemberChanged ( groupId , isMember = true ) , < nl > UpdateGroupAboutChanged ( groupId , newState . about ) , < nl > UpdateGroupAvatarChanged ( groupId , newState . avatar ) ,
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > index bf17a9b . . 8254b34 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala < nl > @ @ - 14 , 6 + 14 , 7 @ @ import im . actor . server . acl . ACLUtils < nl > import im . actor . server . group . GroupCommands . { DeleteGroup , DismissUserAdmin , MakeHistoryShared , MakeUserAdmin , RevokeIntegrationToken , RevokeIntegrationTokenAck , TransferOwnership , UpdateAdminSettings , UpdateAdminSettingsAck } < nl > import im . actor . server . group . GroupErrors . { NotAMember , NotAdmin , UserAlreadyAdmin , UserAlreadyNotAdmin } < nl > import im . actor . server . group . GroupEvents . { AdminSettingsUpdated , AdminStatusChanged , GroupDeleted , HistoryBecameShared , IntegrationTokenRevoked , OwnerChanged } < nl > + import im . actor . server . names . { GlobalNameOwner , OwnerType } < nl > import im . actor . server . persist . { GroupBotRepo , GroupInviteTokenRepo , GroupUserRepo , HistoryMessageRepo } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > < nl > @ @ - 308 , 22 + 309 , 27 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { < nl > if ( ! state . permissions . canDelete ( cmd . clientUserId ) ) { < nl > sender ( ) ! noPermission < nl > } else { < nl > + val exMemberIds = state . memberIds < nl > + val exGlobalName = state . shortName < nl > + val exGroupType = state . groupType < nl > + < nl > persist ( GroupDeleted ( Instant . now , cmd . clientUserId ) ) { evt ⇒ < nl > - val newState = commit ( evt ) < nl > + commit ( evt ) < nl > < nl > val dateMillis = evt . ts . toEpochMilli < nl > val randomId = ACLUtils . randomLong ( ) < nl > + val ZeroPermissions = 0L < nl > < nl > val emptyPermissions = Vector ( < nl > - UpdateGroupPermissionsChanged ( groupId , newState . permissions . GroupEmpty ) , < nl > - UpdateGroupFullPermissionsChanged ( groupId , newState . permissions . FullGroupEmpty ) < nl > + UpdateGroupPermissionsChanged ( groupId , ZeroPermissions ) , < nl > + UpdateGroupFullPermissionsChanged ( groupId , ZeroPermissions ) < nl > ) < nl > < nl > val deleteGroupMembersUpdates : Vector [ Update ] = emptyPermissions + + < nl > Vector ( < nl > UpdateGroupMemberChanged ( groupId , isMember = false ) , < nl > / / if channel , or group is big enough < nl > - if ( newState . groupType . isChannel ) < nl > + if ( exGroupType . isChannel ) < nl > UpdateGroupMembersCountChanged ( groupId , membersCount = 0 ) < nl > else < nl > UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , < nl > @ @ - 331 , 7 + 337 , 7 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { < nl > ) < nl > < nl > / / TODO : remove deprecated . GroupInviteTokenRepo don ' t have replacement yet . < nl > - newState . memberIds foreach { userId ⇒ < nl > + exMemberIds foreach { userId ⇒ < nl > db . run ( < nl > for { < nl > _ ← GroupUserRepo . delete ( groupId , userId ) < nl > @ @ - 341 , 16 + 347 , 17 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { < nl > } < nl > < nl > val result : Future [ SeqState ] = for { < nl > - _ ← db . run ( HistoryMessageRepo . deleteAll ( cmd . clientUserId , apiGroupPeer . asModel ) ) < nl > + / / release global name of group < nl > + _ ← globalNamesStorage . updateOrRemove ( exGlobalName , newGlobalName = None , GlobalNameOwner ( OwnerType . Group , groupId ) ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / Groups V1 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push all members updates about other members left group < nl > - _ ← FutureExt . ftraverse ( newState . memberIds . toSeq ) { userId ⇒ < nl > + _ ← FutureExt . ftraverse ( exMemberIds . toSeq ) { userId ⇒ < nl > seqUpdExt . broadcastPeopleUpdate ( < nl > - userIds = newState . memberIds - userId , < nl > + userIds = exMemberIds - userId , < nl > update = UpdateGroupUserLeaveObsolete ( groupId , userId , dateMillis , randomId ) < nl > ) < nl > } < nl > @ @ - 358 , 15 + 365 , 21 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + < nl > + / / send all members update about group became empty ( no members ) < nl > _ ← Future . traverse ( deleteGroupMembersUpdates ) { update ⇒ < nl > - seqUpdExt . broadcastPeopleUpdate ( newState . memberIds , update ) < nl > + seqUpdExt . broadcastPeopleUpdate ( exMemberIds , update ) < nl > } < nl > - seqState ← seqUpdExt . broadcastClientUpdate ( < nl > - cmd . clientUserId , < nl > - cmd . clientAuthId , < nl > - bcastUserIds = state . memberIds - cmd . clientUserId , < nl > + < nl > + / / send all members except clientUserId ` UpdateChatClear ` < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = exMemberIds - cmd . clientUserId , < nl > update = UpdateChatClear ( apiGroupPeer ) < nl > ) < nl > + < nl > + / / delete dialog from client user ' s dialog list < nl > + / / history deletion happens inside < nl > + seqState ← dialogExt . delete ( cmd . clientUserId , cmd . clientAuthId , apiGroupPeer . asModel ) < nl > } yield seqState < nl > < nl > result pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index 96b2607 . . 3f2959e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 296 , 8 + 296 , 6 @ @ private [ group ] final case class GroupState ( < nl > def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupState = this < nl > < nl > object permissions { < nl > - val GroupEmpty = 0L < nl > - val FullGroupEmpty = 0L < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / General permissions / / < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > index dc766a5 . . b46ee46 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala < nl > @ @ - 90 , 6 + 90 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { < nl > * ` oldGlobalName ` = None , ` newGlobalName ` = Some ( " name " ) - insert new name < nl > * ` oldGlobalName ` = Some ( " oldName " ) , ` newGlobalName ` = Some ( " name " ) - update existing name < nl > * ` oldGlobalName ` = Some ( " oldName " ) , ` newGlobalName ` = None - delete existing name < nl > + * ` oldGlobalName ` = None , ` newGlobalName ` = None - does nothing < nl > * / < nl > def updateOrRemove ( oldGlobalName : Option [ String ] , newGlobalName : Option [ String ] , owner : GlobalNameOwner ) : Future [ Unit ] = { < nl > val deleteFu = ( oldGlobalName map delete ) getOrElse FastFuture . successful ( ( ) )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index 5a87046 . . b600c77 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 309 , 13 + 309 , 17 @ @ private [ group ] final case class GroupState ( 
 * 1 - canClear . Default is FALSE . 
 * 2 - canLeave . Default is FALSE . 
 * 3 - canDelete . Default is FALSE . 
 + * 4 - canJoin . Default is FALSE . 
 + * 5 - canViewInfo . Default is FALSE . 
 * / 
 / / TODO : add ApiGroupFullPermissions 
 def groupFor ( userId : Int ) : Long = { 
 ( ( toInt ( canSendMessage ( userId ) ) < < 0 ) + 
 ( toInt ( canClear ( userId ) ) < < 1 ) + 
 ( toInt ( canLeave ( userId ) ) < < 2 ) + 
 - ( toInt ( canDelete ( userId ) ) < < 3 ) ) . toLong 
 + ( toInt ( canDelete ( userId ) ) < < 3 ) + 
 + ( toInt ( canJoin ( userId ) ) < < 4 ) + 
 + ( toInt ( canViewInfo ( userId ) ) < < 5 ) ) . toLong 
 } 
 
 / * * 
 @ @ - 344 , 6 + 348 , 13 @ @ private [ group ] final case class GroupState ( 
 / / only owner can delete group 
 def canDelete ( clientUserId : Int ) : Boolean = isOwner ( clientUserId ) 
 
 + / / anyone can join in group with shared history 
 + def canJoin ( clientUserId : Int ) : Boolean = isHistoryShared 
 + 
 + / / if history shared - anyone can view info 
 + / / only members can view info in private groups 
 + def canViewInfo ( clientUserId : Int ) : Boolean = isHistoryShared | | isMember ( clientUserId ) 
 + 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / Full group permissions / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 index efbd494 . . 5c82a2a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / MemberCommandHandlers . scala 
 @ @ - 6 , 7 + 6 , 7 @ @ import akka . actor . Status 
 import akka . pattern . pipe 
 import im . actor . api . rpc . Update 
 import im . actor . api . rpc . groups . _ 
 - import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateMessage } 
 + import im . actor . api . rpc . messaging . { ApiServiceMessage , UpdateChatDropCache , UpdateMessage } 
 import im . actor . concurrent . FutureExt 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . group . GroupCommands . { Invite , Join , Kick , Leave } 
 @ @ - 39 , 8 + 39 , 12 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 val memberIds = newState . memberIds 
 val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 
 - / / if user ever been in this group - we should push these updates , 
 - val inviteeUpdatesNew : Vector [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 + / / if user ever been in this group - we should push these updates 
 + / / TODO : unify isHistoryShared usage 
 + val inviteeUpdatesNew : Vector [ Update ] = { 
 + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 + optDrop + + : refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 + } 
 
 val membersUpdateNew : Update = 
 if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 @ @ - 219 , 9 + 223 , 12 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 / / that means we need to push all group - info related updates 
 / / 
 / / If user was invited to group by other member - we don ' t need to push group updates , 
 - / / cause they we pushed already on invite step 
 - val joiningUserUpdatesNew : Vector [ Update ] = 
 - if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 + / / cause they were pushed already on invite step 
 + / / TODO : unify isHistoryShared usage 
 + val joiningUserUpdatesNew : Vector [ Update ] = { 
 + val optDrop = if ( newState . isHistoryShared ) Some ( UpdateChatDropCache ( apiGroupPeer ) ) else None 
 + optDrop + + : ( if ( wasInvited ) Vector . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) ) 
 + } 
 
 val membersUpdateNew : Update = 
 if ( newState . groupType . isChannel ) / / if channel , or group is big enough 
 @ @ - 594 , 6 + 601 , 7 @ @ private [ group ] trait MemberCommandHandlers extends GroupsImplicits { 
 / / Updates that will be sent to user , when he enters group . 
 / / Helps clients that have this group to refresh it ' s data . 
 private def refreshGroupUpdates ( newState : GroupState , userId : Int ) : Vector [ Update ] = Vector ( 
 + UpdateChatDropCache ( apiGroupPeer ) , 
 UpdateGroupMemberChanged ( groupId , isMember = true ) , 
 UpdateGroupAboutChanged ( groupId , newState . about ) , 
 UpdateGroupAvatarChanged ( groupId , newState . avatar ) ,

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 index bf17a9b . . 8254b34 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / AdminCommandHandlers . scala 
 @ @ - 14 , 6 + 14 , 7 @ @ import im . actor . server . acl . ACLUtils 
 import im . actor . server . group . GroupCommands . { DeleteGroup , DismissUserAdmin , MakeHistoryShared , MakeUserAdmin , RevokeIntegrationToken , RevokeIntegrationTokenAck , TransferOwnership , UpdateAdminSettings , UpdateAdminSettingsAck } 
 import im . actor . server . group . GroupErrors . { NotAMember , NotAdmin , UserAlreadyAdmin , UserAlreadyNotAdmin } 
 import im . actor . server . group . GroupEvents . { AdminSettingsUpdated , AdminStatusChanged , GroupDeleted , HistoryBecameShared , IntegrationTokenRevoked , OwnerChanged } 
 + import im . actor . server . names . { GlobalNameOwner , OwnerType } 
 import im . actor . server . persist . { GroupBotRepo , GroupInviteTokenRepo , GroupUserRepo , HistoryMessageRepo } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 
 @ @ - 308 , 22 + 309 , 27 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { 
 if ( ! state . permissions . canDelete ( cmd . clientUserId ) ) { 
 sender ( ) ! noPermission 
 } else { 
 + val exMemberIds = state . memberIds 
 + val exGlobalName = state . shortName 
 + val exGroupType = state . groupType 
 + 
 persist ( GroupDeleted ( Instant . now , cmd . clientUserId ) ) { evt ⇒ 
 - val newState = commit ( evt ) 
 + commit ( evt ) 
 
 val dateMillis = evt . ts . toEpochMilli 
 val randomId = ACLUtils . randomLong ( ) 
 + val ZeroPermissions = 0L 
 
 val emptyPermissions = Vector ( 
 - UpdateGroupPermissionsChanged ( groupId , newState . permissions . GroupEmpty ) , 
 - UpdateGroupFullPermissionsChanged ( groupId , newState . permissions . FullGroupEmpty ) 
 + UpdateGroupPermissionsChanged ( groupId , ZeroPermissions ) , 
 + UpdateGroupFullPermissionsChanged ( groupId , ZeroPermissions ) 
 ) 
 
 val deleteGroupMembersUpdates : Vector [ Update ] = emptyPermissions + + 
 Vector ( 
 UpdateGroupMemberChanged ( groupId , isMember = false ) , 
 / / if channel , or group is big enough 
 - if ( newState . groupType . isChannel ) 
 + if ( exGroupType . isChannel ) 
 UpdateGroupMembersCountChanged ( groupId , membersCount = 0 ) 
 else 
 UpdateGroupMembersUpdated ( groupId , members = Vector . empty ) , 
 @ @ - 331 , 7 + 337 , 7 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { 
 ) 
 
 / / TODO : remove deprecated . GroupInviteTokenRepo don ' t have replacement yet . 
 - newState . memberIds foreach { userId ⇒ 
 + exMemberIds foreach { userId ⇒ 
 db . run ( 
 for { 
 _ ← GroupUserRepo . delete ( groupId , userId ) 
 @ @ - 341 , 16 + 347 , 17 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { 
 } 
 
 val result : Future [ SeqState ] = for { 
 - _ ← db . run ( HistoryMessageRepo . deleteAll ( cmd . clientUserId , apiGroupPeer . asModel ) ) 
 + / / release global name of group 
 + _ ← globalNamesStorage . updateOrRemove ( exGlobalName , newGlobalName = None , GlobalNameOwner ( OwnerType . Group , groupId ) ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / Groups V1 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push all members updates about other members left group 
 - _ ← FutureExt . ftraverse ( newState . memberIds . toSeq ) { userId ⇒ 
 + _ ← FutureExt . ftraverse ( exMemberIds . toSeq ) { userId ⇒ 
 seqUpdExt . broadcastPeopleUpdate ( 
 - userIds = newState . memberIds - userId , 
 + userIds = exMemberIds - userId , 
 update = UpdateGroupUserLeaveObsolete ( groupId , userId , dateMillis , randomId ) 
 ) 
 } 
 @ @ - 358 , 15 + 365 , 21 @ @ private [ group ] trait AdminCommandHandlers extends GroupsImplicits { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + / / send all members update about group became empty ( no members ) 
 _ ← Future . traverse ( deleteGroupMembersUpdates ) { update ⇒ 
 - seqUpdExt . broadcastPeopleUpdate ( newState . memberIds , update ) 
 + seqUpdExt . broadcastPeopleUpdate ( exMemberIds , update ) 
 } 
 - seqState ← seqUpdExt . broadcastClientUpdate ( 
 - cmd . clientUserId , 
 - cmd . clientAuthId , 
 - bcastUserIds = state . memberIds - cmd . clientUserId , 
 + 
 + / / send all members except clientUserId ` UpdateChatClear ` 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = exMemberIds - cmd . clientUserId , 
 update = UpdateChatClear ( apiGroupPeer ) 
 ) 
 + 
 + / / delete dialog from client user ' s dialog list 
 + / / history deletion happens inside 
 + seqState ← dialogExt . delete ( cmd . clientUserId , cmd . clientAuthId , apiGroupPeer . asModel ) 
 } yield seqState 
 
 result pipeTo sender ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index 96b2607 . . 3f2959e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 296 , 8 + 296 , 6 @ @ private [ group ] final case class GroupState ( 
 def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupState = this 
 
 object permissions { 
 - val GroupEmpty = 0L 
 - val FullGroupEmpty = 0L 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / General permissions / / 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 index dc766a5 . . b46ee46 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / names / GlobalNamesStorage . scala 
 @ @ - 90 , 6 + 90 , 7 @ @ final class GlobalNamesStorageKeyValueStorage ( implicit system : ActorSystem ) { 
 * ` oldGlobalName ` = None , ` newGlobalName ` = Some ( " name " ) - insert new name 
 * ` oldGlobalName ` = Some ( " oldName " ) , ` newGlobalName ` = Some ( " name " ) - update existing name 
 * ` oldGlobalName ` = Some ( " oldName " ) , ` newGlobalName ` = None - delete existing name 
 + * ` oldGlobalName ` = None , ` newGlobalName ` = None - does nothing 
 * / 
 def updateOrRemove ( oldGlobalName : Option [ String ] , newGlobalName : Option [ String ] , owner : GlobalNameOwner ) : Future [ Unit ] = { 
 val deleteFu = ( oldGlobalName map delete ) getOrElse FastFuture . successful ( ( ) )
