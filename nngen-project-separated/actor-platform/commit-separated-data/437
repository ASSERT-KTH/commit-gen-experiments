BLEU SCORE: 0.5706745777055999

TEST MSG: fix ( server : messaging ) : no dialogs with itself
GENERATED MSG: fix ( server : messaging ) : fixed DialogRootMigration

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index dd9d551 . . 6f76a45 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 109 , 7 + 109 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > < nl > override def persistenceId : String = s " DialogRoot _ $ userId " < nl > < nl > - override protected def getInitialState : DialogRootState = DialogRootState . initial < nl > + override protected def getInitialState : DialogRootState = DialogRootState . initial ( userId ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ getCounter ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > index f5a63d2 . . 30b982a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 102 , 7 + 102 , 8 @ @ private [ dialog ] case class ActiveDialogs ( < nl > } < nl > < nl > private object DialogRootState { < nl > - val initial = DialogRootState ( < nl > + def initial ( userId : Int ) = DialogRootState ( < nl > + userId = userId , < nl > active = ActiveDialogs . empty , < nl > / / activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > mobile = SortedSet . empty ( SortableDialog . OrderingDesc ) , < nl > @ @ - 111 , 6 + 112 , 7 @ @ private object DialogRootState { < nl > } < nl > < nl > private [ dialog ] final case class DialogRootState ( < nl > + userId : Int , < nl > active : ActiveDialogs , < nl > / / activePeers : SortedSet [ SortableDialog ] , < nl > mobile : SortedSet [ SortableDialog ] , < nl > @ @ - 132 , 7 + 134 , 7 @ @ private [ dialog ] final case class DialogRootState ( < nl > < nl > override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { < nl > case DialogRootStateSnapshot ( dialogGroups , _ archived , _ mobile ) ⇒ { < nl > - val state = DialogRootState . initial . copy ( < nl > + val state = DialogRootState . initial ( userId ) . copy ( < nl > archived = SortedSet ( < nl > ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > ) ( SortableDialog . OrderingAsc ) , < nl > @ @ - 172 , 13 + 174 , 16 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withBumpedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - copy ( < nl > - mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) < nl > - ) < nl > + if ( mobile . exists ( _ . peer = = peer ) ) < nl > + copy ( < nl > + mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) < nl > + ) < nl > + else this < nl > } < nl > < nl > private def withNewPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + if ( peer . typ . isPrivate & & peer . id = = userId ) this < nl > + else if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) < nl > else { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > @ @ - 191 , 7 + 196 , 8 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withUnarchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - if ( this . active . exists ( _ . ts = = ts ) ) withUnarchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + if ( ! this . archived . exists ( _ . peer = = peer ) ) this < nl > + else if ( this . active . exists ( _ . ts = = ts ) ) withUnarchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > else { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > @ @ - 203 , 7 + 209 , 8 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + if ( ! this . active . exists ( _ . peer = = peer ) ) this < nl > + else if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > else { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > copy ( < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > index 6fc5cba . . bdad87b 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 16 , 11 + 16 , 14 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > it should " archive groups and DMs " in archive < nl > it should " order archived by date desc " in archivedOrder < nl > it should " not add to DMs or groups if already in favourites " in keepInFavourites < nl > + it should " not create dialogs with itself " in noDialogsWithItself < nl > < nl > import DialogRootEvents . _ < nl > < nl > + val userId = 31337 < nl > + < nl > def show ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > val bob = Peer . privat ( 2 ) < nl > @ @ - 33 , 7 + 36 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def mobileDialogs ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > val bob = Peer . privat ( 2 ) < nl > @ @ - 59 , 7 + 62 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def favouriteUnfavourite ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > < nl > @ @ - 73 , 7 + 76 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def keepInFavourites ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > val group = Peer . group ( 100 ) < nl > @ @ - 91 , 10 + 94 , 11 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def removeFromArchived ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > < nl > + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) < nl > probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) < nl > getArchivedPeers should be ( Seq ( alice ) ) < nl > checkSnapshot < nl > @ @ - 115 , 7 + 119 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def archive ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val group1 = Peer . group ( 1 ) < nl > val group2 = Peer . group ( 2 ) < nl > @ @ - 132 , 11 + 136 , 13 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > def archivedOrder ( ) = { < nl > - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > < nl > val alice = Peer . privat ( 1 ) < nl > val bob = Peer . privat ( 2 ) < nl > < nl > + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) < nl > + probe . commit ( Created ( Instant . now , Some ( bob ) ) ) < nl > probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) < nl > probe . commit ( Archived ( Instant . now , Some ( bob ) ) ) < nl > < nl > @ @ - 144 , 6 + 150 , 30 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > checkSnapshot < nl > } < nl > < nl > + def noDialogsWithItself ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) < nl > + < nl > + val alice = Peer . privat ( userId ) < nl > + < nl > + def checkNoAlice ( ) = { < nl > + probe . state . mobile shouldBe empty < nl > + probe . state . active . exists ( _ . peer = = alice ) shouldBe false < nl > + probe . state . archived shouldBe empty < nl > + } < nl > + < nl > + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) < nl > + checkNoAlice < nl > + < nl > + probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) < nl > + checkNoAlice < nl > + < nl > + probe . commit ( Bumped ( Instant . now , Some ( alice ) ) ) < nl > + checkNoAlice < nl > + < nl > + probe . commit ( Unarchived ( Instant . now , Some ( alice ) ) ) < nl > + checkNoAlice < nl > + } < nl > + < nl > private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > typ match { < nl > case DialogGroupType . Favourites ⇒ probe . state . active . favourites . toSeq . map ( _ . peer ) < nl > @ @ - 159 , 5 + 189 , 5 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > probe . state . archived . toSeq . map ( _ . peer ) < nl > < nl > private def checkSnapshot ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > - DialogRootState . initial . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) < nl > + DialogRootState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) < nl > } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > index 659eeca . . 9eb5d4a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala < nl > @ @ - 60 , 8 + 60 , 11 @ @ trait DialogProcessorMigration extends Processor [ DialogState ] { < nl > } < nl > } yield PersistEvents ( < nl > Initialized ( ) + : < nl > - newMessages . toList : + < nl > - MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) < nl > + ( newMessages . toList + + < nl > + List ( < nl > + MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , < nl > + MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) < nl > + ) ) < nl > ) ) pipeTo self < nl > case PersistEvents ( events ) ⇒ < nl > log . warning ( " Persisting events " ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > index 9a7b2ea . . 51f746e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 20 , 11 + 20 , 12 @ @ trait DialogRootQuery < nl > < nl > private object SortableDialog { < nl > val OrderingAsc = new Ordering [ SortableDialog ] { < nl > - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = { < nl > if ( x . peer = = y . peer ) 0 < nl > else if ( x . ts . isBefore ( y . ts ) ) - 1 < nl > else if ( x . ts . isAfter ( y . ts ) ) 1 < nl > else 0 < nl > + } < nl > } < nl > < nl > val OrderingDesc = new Ordering [ SortableDialog ] { < nl > @ @ - 36 , 7 + 37 , 15 @ @ private object SortableDialog { < nl > } < nl > } < nl > < nl > - private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > + private case class SortableDialog ( ts : Instant , peer : Peer ) { < nl > + override def hashCode = peer . hashCode ( ) < nl > + < nl > + override def equals ( obj : Any ) = < nl > + obj match { < nl > + case sd : SortableDialog ⇒ sd . peer = = peer < nl > + case _ ⇒ false < nl > + } < nl > + } < nl > < nl > private object ActiveDialogs { < nl > val empty = ActiveDialogs ( < nl > @ @ - 60 , 25 + 69 , 27 @ @ private [ dialog ] case class ActiveDialogs ( < nl > } < nl > < nl > def withoutPeer ( sd : SortableDialog ) = { < nl > - sd . peer . typ match { < nl > - case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites - sd ) < nl > - case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites - sd ) < nl > + val res = sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms . filterNot ( _ . peer = = sd . peer ) , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) < nl > + case PeerType . Group ⇒ copy ( groups = groups . filterNot ( _ . peer = = sd . peer ) , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) < nl > case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > } < nl > + println ( res . groups ) < nl > + res < nl > } < nl > < nl > def withFavouritedPeer ( sd : SortableDialog ) = { < nl > sd . peer . typ match { < nl > - case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites + sd ) < nl > - case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites + sd ) < nl > + case PeerType . Private ⇒ copy ( dms = dms . filterNot ( _ . peer = = sd . peer ) , favourites = favourites + sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups . filterNot ( _ . peer = = sd . peer ) , favourites = favourites + sd ) < nl > case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > } < nl > } < nl > < nl > def withUnfavouritedPeer ( sd : SortableDialog ) = { < nl > sd . peer . typ match { < nl > - case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites - sd ) < nl > - case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites - sd ) < nl > + case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) < nl > + case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) < nl > case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > index 00247f7 . . 66eb2de 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > @ @ - 111 , 6 + 111 , 49 @ @ final class UserDialogTable ( tag : Tag ) extends Table [ UserDialog ] ( tag , " user _ dialo < nl > < nl > object DialogRepo extends UserDialogOperations with DialogCommonOperations { < nl > < nl > + def create ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : DBIO [ Int ] = { < nl > + val dialogId = getDialogId ( Some ( dialog . userId ) , dialog . peer ) < nl > + < nl > + val common = DialogCommon ( < nl > + dialogId = dialogId , < nl > + lastMessageDate = dialog . lastMessageDate , < nl > + lastReceivedAt = dialog . lastReceivedAt , < nl > + lastReadAt = dialog . lastReadAt < nl > + ) < nl > + < nl > + val user = UserDialog ( < nl > + userId = dialog . userId , < nl > + peer = dialog . peer , < nl > + ownerLastReceivedAt = dialog . ownerLastReceivedAt , < nl > + ownerLastReadAt = dialog . ownerLastReadAt , < nl > + createdAt = dialog . createdAt , < nl > + shownAt = dialog . shownAt , < nl > + isFavourite = dialog . isFavourite , < nl > + archivedAt = dialog . archivedAt < nl > + ) < nl > + < nl > + for { < nl > + exists ← commonExists ( dialogId ) < nl > + result ← if ( exists ) { < nl > + UserDialogRepo . userDialogs + = user < nl > + } else { < nl > + for { < nl > + c ← ( DialogCommonRepo . dialogCommon + = common ) < nl > + . asTry < nl > + . flatMap { < nl > + case Failure ( e ) ⇒ < nl > + commonExists ( common . dialogId ) flatMap { < nl > + case true ⇒ DBIO . successful ( 1 ) < nl > + case false ⇒ DBIO . failed ( e ) < nl > + } < nl > + case Success ( res ) ⇒ DBIO . successful ( res ) < nl > + } < nl > + _ ← UserDialogRepo . userDialogs + = user < nl > + } yield c < nl > + } < nl > + } yield result < nl > + } < nl > + < nl > private val dialogs = for { < nl > c ← DialogCommonRepo . dialogCommon < nl > u ← UserDialogRepo . userDialogs if c . dialogId = = = repDialogId ( u . userId , u . peerId , u . peerType ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > index 717ebba . . 98d293b 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 12 , 6 + 12 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > it should " sort dialogs by appearing " in show < nl > it should " remove Favourites on Unfavourite " in favouriteUnfavourite < nl > it should " remove from Archived on Favourite or new message " in removeFromArchived < nl > + it should " archive groups and DMs " in archive < nl > it should " order archived by date desc " in archivedOrder < nl > < nl > import DialogRootEvents . _ < nl > @ @ - 69 , 6 + 70 , 23 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > checkSnapshot < nl > } < nl > < nl > + def archive ( ) = { < nl > + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > + < nl > + val group1 = Peer . group ( 1 ) < nl > + val group2 = Peer . group ( 2 ) < nl > + < nl > + probe . commit ( Created ( Instant . now , Some ( group1 ) ) ) < nl > + probe . commit ( Created ( Instant . now , Some ( group2 ) ) ) < nl > + < nl > + getGroupPeers ( DialogGroupType . Groups ) should be ( Seq ( group1 , group2 ) ) < nl > + < nl > + probe . commit ( Archived ( Instant . now , Some ( group1 ) ) ) < nl > + < nl > + getGroupPeers ( DialogGroupType . Groups ) should be ( Seq ( group2 ) ) < nl > + getArchivedPeers should be ( Seq ( group1 ) ) < nl > + } < nl > + < nl > def archivedOrder ( ) = { < nl > implicit val probe = ProcessorStateProbe ( DialogRootState . initial )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index dd9d551 . . 6f76a45 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 109 , 7 + 109 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 
 override def persistenceId : String = s " DialogRoot _ $ userId " 
 
 - override protected def getInitialState : DialogRootState = DialogRootState . initial 
 + override protected def getInitialState : DialogRootState = DialogRootState . initial ( userId ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ getCounter ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 index f5a63d2 . . 30b982a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 102 , 7 + 102 , 8 @ @ private [ dialog ] case class ActiveDialogs ( 
 } 
 
 private object DialogRootState { 
 - val initial = DialogRootState ( 
 + def initial ( userId : Int ) = DialogRootState ( 
 + userId = userId , 
 active = ActiveDialogs . empty , 
 / / activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 mobile = SortedSet . empty ( SortableDialog . OrderingDesc ) , 
 @ @ - 111 , 6 + 112 , 7 @ @ private object DialogRootState { 
 } 
 
 private [ dialog ] final case class DialogRootState ( 
 + userId : Int , 
 active : ActiveDialogs , 
 / / activePeers : SortedSet [ SortableDialog ] , 
 mobile : SortedSet [ SortableDialog ] , 
 @ @ - 132 , 7 + 134 , 7 @ @ private [ dialog ] final case class DialogRootState ( 
 
 override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { 
 case DialogRootStateSnapshot ( dialogGroups , _ archived , _ mobile ) ⇒ { 
 - val state = DialogRootState . initial . copy ( 
 + val state = DialogRootState . initial ( userId ) . copy ( 
 archived = SortedSet ( 
 ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 ) ( SortableDialog . OrderingAsc ) , 
 @ @ - 172 , 13 + 174 , 16 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withBumpedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - copy ( 
 - mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) 
 - ) 
 + if ( mobile . exists ( _ . peer = = peer ) ) 
 + copy ( 
 + mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) 
 + ) 
 + else this 
 } 
 
 private def withNewPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) 
 + if ( peer . typ . isPrivate & & peer . id = = userId ) this 
 + else if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) 
 else { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 @ @ - 191 , 7 + 196 , 8 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withUnarchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - if ( this . active . exists ( _ . ts = = ts ) ) withUnarchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 + if ( ! this . archived . exists ( _ . peer = = peer ) ) this 
 + else if ( this . active . exists ( _ . ts = = ts ) ) withUnarchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 else { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 @ @ - 203 , 7 + 209 , 8 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 + if ( ! this . active . exists ( _ . peer = = peer ) ) this 
 + else if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 else { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 copy ( 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 index 6fc5cba . . bdad87b 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 16 , 11 + 16 , 14 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 it should " archive groups and DMs " in archive 
 it should " order archived by date desc " in archivedOrder 
 it should " not add to DMs or groups if already in favourites " in keepInFavourites 
 + it should " not create dialogs with itself " in noDialogsWithItself 
 
 import DialogRootEvents . _ 
 
 + val userId = 31337 
 + 
 def show ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 val bob = Peer . privat ( 2 ) 
 @ @ - 33 , 7 + 36 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def mobileDialogs ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 val bob = Peer . privat ( 2 ) 
 @ @ - 59 , 7 + 62 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def favouriteUnfavourite ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 
 @ @ - 73 , 7 + 76 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def keepInFavourites ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 val group = Peer . group ( 100 ) 
 @ @ - 91 , 10 + 94 , 11 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def removeFromArchived ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 
 + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) 
 probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) 
 getArchivedPeers should be ( Seq ( alice ) ) 
 checkSnapshot 
 @ @ - 115 , 7 + 119 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def archive ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val group1 = Peer . group ( 1 ) 
 val group2 = Peer . group ( 2 ) 
 @ @ - 132 , 11 + 136 , 13 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 def archivedOrder ( ) = { 
 - implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 
 val alice = Peer . privat ( 1 ) 
 val bob = Peer . privat ( 2 ) 
 
 + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) 
 + probe . commit ( Created ( Instant . now , Some ( bob ) ) ) 
 probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) 
 probe . commit ( Archived ( Instant . now , Some ( bob ) ) ) 
 
 @ @ - 144 , 6 + 150 , 30 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 checkSnapshot 
 } 
 
 + def noDialogsWithItself ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ( userId ) ) 
 + 
 + val alice = Peer . privat ( userId ) 
 + 
 + def checkNoAlice ( ) = { 
 + probe . state . mobile shouldBe empty 
 + probe . state . active . exists ( _ . peer = = alice ) shouldBe false 
 + probe . state . archived shouldBe empty 
 + } 
 + 
 + probe . commit ( Created ( Instant . now , Some ( alice ) ) ) 
 + checkNoAlice 
 + 
 + probe . commit ( Archived ( Instant . now , Some ( alice ) ) ) 
 + checkNoAlice 
 + 
 + probe . commit ( Bumped ( Instant . now , Some ( alice ) ) ) 
 + checkNoAlice 
 + 
 + probe . commit ( Unarchived ( Instant . now , Some ( alice ) ) ) 
 + checkNoAlice 
 + } 
 + 
 private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 typ match { 
 case DialogGroupType . Favourites ⇒ probe . state . active . favourites . toSeq . map ( _ . peer ) 
 @ @ - 159 , 5 + 189 , 5 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 probe . state . archived . toSeq . map ( _ . peer ) 
 
 private def checkSnapshot ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 - DialogRootState . initial . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) 
 + DialogRootState . initial ( userId ) . withSnapshot ( SnapshotMetadata ( " " , 0 ) , probe . state . snapshot ) should be ( probe . state ) 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 index 659eeca . . 9eb5d4a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessorMigration . scala 
 @ @ - 60 , 8 + 60 , 11 @ @ trait DialogProcessorMigration extends Processor [ DialogState ] { 
 } 
 } yield PersistEvents ( 
 Initialized ( ) + : 
 - newMessages . toList : + 
 - MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) 
 + ( newMessages . toList + + 
 + List ( 
 + MessagesRead ( Instant . ofEpochMilli ( d . ownerLastReadAt . getMillis ) , readerUserId = userId ) , 
 + MessagesRead ( Instant . ofEpochMilli ( d . lastReadAt . getMillis ) ) 
 + ) ) 
 ) ) pipeTo self 
 case PersistEvents ( events ) ⇒ 
 log . warning ( " Persisting events " ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 index 9a7b2ea . . 51f746e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 20 , 11 + 20 , 12 @ @ trait DialogRootQuery 
 
 private object SortableDialog { 
 val OrderingAsc = new Ordering [ SortableDialog ] { 
 - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = { 
 if ( x . peer = = y . peer ) 0 
 else if ( x . ts . isBefore ( y . ts ) ) - 1 
 else if ( x . ts . isAfter ( y . ts ) ) 1 
 else 0 
 + } 
 } 
 
 val OrderingDesc = new Ordering [ SortableDialog ] { 
 @ @ - 36 , 7 + 37 , 15 @ @ private object SortableDialog { 
 } 
 } 
 
 - private case class SortableDialog ( ts : Instant , peer : Peer ) 
 + private case class SortableDialog ( ts : Instant , peer : Peer ) { 
 + override def hashCode = peer . hashCode ( ) 
 + 
 + override def equals ( obj : Any ) = 
 + obj match { 
 + case sd : SortableDialog ⇒ sd . peer = = peer 
 + case _ ⇒ false 
 + } 
 + } 
 
 private object ActiveDialogs { 
 val empty = ActiveDialogs ( 
 @ @ - 60 , 25 + 69 , 27 @ @ private [ dialog ] case class ActiveDialogs ( 
 } 
 
 def withoutPeer ( sd : SortableDialog ) = { 
 - sd . peer . typ match { 
 - case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites - sd ) 
 - case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites - sd ) 
 + val res = sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms . filterNot ( _ . peer = = sd . peer ) , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) 
 + case PeerType . Group ⇒ copy ( groups = groups . filterNot ( _ . peer = = sd . peer ) , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) 
 case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 } 
 + println ( res . groups ) 
 + res 
 } 
 
 def withFavouritedPeer ( sd : SortableDialog ) = { 
 sd . peer . typ match { 
 - case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites + sd ) 
 - case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites + sd ) 
 + case PeerType . Private ⇒ copy ( dms = dms . filterNot ( _ . peer = = sd . peer ) , favourites = favourites + sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups . filterNot ( _ . peer = = sd . peer ) , favourites = favourites + sd ) 
 case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 } 
 } 
 
 def withUnfavouritedPeer ( sd : SortableDialog ) = { 
 sd . peer . typ match { 
 - case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites - sd ) 
 - case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites - sd ) 
 + case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) 
 + case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites . filterNot ( _ . peer = = sd . peer ) ) 
 case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 } 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 index 00247f7 . . 66eb2de 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 @ @ - 111 , 6 + 111 , 49 @ @ final class UserDialogTable ( tag : Tag ) extends Table [ UserDialog ] ( tag , " user _ dialo 
 
 object DialogRepo extends UserDialogOperations with DialogCommonOperations { 
 
 + def create ( dialog : DialogObsolete ) ( implicit ec : ExecutionContext ) : DBIO [ Int ] = { 
 + val dialogId = getDialogId ( Some ( dialog . userId ) , dialog . peer ) 
 + 
 + val common = DialogCommon ( 
 + dialogId = dialogId , 
 + lastMessageDate = dialog . lastMessageDate , 
 + lastReceivedAt = dialog . lastReceivedAt , 
 + lastReadAt = dialog . lastReadAt 
 + ) 
 + 
 + val user = UserDialog ( 
 + userId = dialog . userId , 
 + peer = dialog . peer , 
 + ownerLastReceivedAt = dialog . ownerLastReceivedAt , 
 + ownerLastReadAt = dialog . ownerLastReadAt , 
 + createdAt = dialog . createdAt , 
 + shownAt = dialog . shownAt , 
 + isFavourite = dialog . isFavourite , 
 + archivedAt = dialog . archivedAt 
 + ) 
 + 
 + for { 
 + exists ← commonExists ( dialogId ) 
 + result ← if ( exists ) { 
 + UserDialogRepo . userDialogs + = user 
 + } else { 
 + for { 
 + c ← ( DialogCommonRepo . dialogCommon + = common ) 
 + . asTry 
 + . flatMap { 
 + case Failure ( e ) ⇒ 
 + commonExists ( common . dialogId ) flatMap { 
 + case true ⇒ DBIO . successful ( 1 ) 
 + case false ⇒ DBIO . failed ( e ) 
 + } 
 + case Success ( res ) ⇒ DBIO . successful ( res ) 
 + } 
 + _ ← UserDialogRepo . userDialogs + = user 
 + } yield c 
 + } 
 + } yield result 
 + } 
 + 
 private val dialogs = for { 
 c ← DialogCommonRepo . dialogCommon 
 u ← UserDialogRepo . userDialogs if c . dialogId = = = repDialogId ( u . userId , u . peerId , u . peerType ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 index 717ebba . . 98d293b 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 12 , 6 + 12 , 7 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 it should " sort dialogs by appearing " in show 
 it should " remove Favourites on Unfavourite " in favouriteUnfavourite 
 it should " remove from Archived on Favourite or new message " in removeFromArchived 
 + it should " archive groups and DMs " in archive 
 it should " order archived by date desc " in archivedOrder 
 
 import DialogRootEvents . _ 
 @ @ - 69 , 6 + 70 , 23 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 checkSnapshot 
 } 
 
 + def archive ( ) = { 
 + implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 + 
 + val group1 = Peer . group ( 1 ) 
 + val group2 = Peer . group ( 2 ) 
 + 
 + probe . commit ( Created ( Instant . now , Some ( group1 ) ) ) 
 + probe . commit ( Created ( Instant . now , Some ( group2 ) ) ) 
 + 
 + getGroupPeers ( DialogGroupType . Groups ) should be ( Seq ( group1 , group2 ) ) 
 + 
 + probe . commit ( Archived ( Instant . now , Some ( group1 ) ) ) 
 + 
 + getGroupPeers ( DialogGroupType . Groups ) should be ( Seq ( group2 ) ) 
 + getArchivedPeers should be ( Seq ( group1 ) ) 
 + } 
 + 
 def archivedOrder ( ) = { 
 implicit val probe = ProcessorStateProbe ( DialogRootState . initial )
