BLEU SCORE: 0.15133218633429316

TEST MSG: fix ( server : push ) : use another prefix for custom sound
GENERATED MSG: fix ( server ) : disable notifications for peers . fixes # 188

TEST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > index a6d98f8 . . d4e6fcb 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > @ @ - 51 , 7 + 51 , 7 @ @ object ParameterRepo { < nl > } < nl > < nl > def findPeerRingtone ( userId : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , String ) ] ] = < nl > - extractPeerParams [ ( Peer , String ) ] ( userId , prefix = s " category . mobile . ios . ringtone . chat . " ) { < nl > + extractPeerParams [ ( Peer , String ) ] ( userId , prefix = " app . ios . mobile . notification . chat . sound . " ) { < nl > case ( key , optValue ) ⇒ < nl > key . split ( " _ " ) . toList match { < nl > case " GROUP " : : id : : Nil ⇒ < nl > @ @ - 68 , 7 + 68 , 7 @ @ object ParameterRepo { < nl > case _ ⇒ true < nl > } < nl > < nl > - extractPeerParams [ ( Peer , Boolean ) ] ( userId , s " category . $ deviceType . notification . chat . " ) { < nl > + extractPeerParams [ ( Peer , Boolean ) ] ( userId , prefix = s " category . $ deviceType . notification . chat . " ) { < nl > case ( key , value ) ⇒ < nl > key . split ( " \ \ . " ) . toList match { < nl > case peerStr : : " enabled " : : Nil ⇒
NEAREST DIFF (one line): diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > index 0f15d4a . . 15b3fdf 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala < nl > @ @ - 61 , 7 + 61 , 7 @ @ object ParameterRepo { < nl > for ( rows ← byUserIdAndKeyLikeC ( ( userId , s " $ prefix % _ % . % " ) ) . result ) yield { < nl > rows flatMap { < nl > case Parameter ( _ , key , value ) ⇒ < nl > - key . drop ( prefix . length ) . split ( " . " ) . toList match { < nl > + key . drop ( prefix . length ) . split ( " \ \ . " ) . toList match { < nl > case peerStr : : " enabled " : : Nil ⇒ < nl > peerStr . split ( " _ " ) . toList match { < nl > case " GROUP " : : id : : Nil ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 728f63f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala < nl > @ @ - 0 , 0 + 1 , 66 @ @ < nl > + package im . actor . server . sequence < nl > + < nl > + import akka . actor . { Props , Actor } < nl > + import akka . pattern . ask < nl > + import im . actor . api . rpc . PeersImplicits < nl > + import im . actor . concurrent . ActorStashing < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . model . Peer < nl > + import im . actor . server . model . configs . Parameter < nl > + import im . actor . server . persist . configs . ParameterRepo < nl > + import im . actor . server . { ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > + import im . actor . server . api . rpc . service . configs . ConfigsServiceImpl < nl > + < nl > + class SettingControlSpec extends BaseAppSuite < nl > + with ImplicitAuthService < nl > + with ImplicitSessionRegion < nl > + with PeersImplicits { < nl > + < nl > + behavior of " Setting Control " < nl > + < nl > + " Setting " should " up to date setting " in settings ( ) < nl > + < nl > + private val configService = new ConfigsServiceImpl < nl > + < nl > + def settings ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + val groupId = 1752533455 < nl > + val param = Parameter ( alice . id , s " category . mobile . notification . chat . GROUP _ $ { groupId } . enabled " , Some ( " false " ) ) < nl > + whenReady ( DbExtension ( system ) . db . run ( ParameterRepo . createOrUpdate ( param ) ) ) ( identity ) < nl > + < nl > + val wrapperRef = system . actorOf ( SettingControlWrapper . props ( alice . id ) , " settingsWrapper " ) < nl > + < nl > + whenReady ( wrapperRef . ask ( GetSettings ) . mapTo [ AllNotificationSettings ] ) { settings ⇒ < nl > + val peersSpecific = settings . specific ( " mobile " ) . peers < nl > + peersSpecific should have size 1 < nl > + peersSpecific . get ( Peer . group ( groupId ) ) shouldEqual Some ( false ) < nl > + } < nl > + } < nl > + < nl > + case object GetSettings < nl > + < nl > + object SettingControlWrapper { < nl > + def props ( userId : Int ) = Props ( new SettingControlWrapper ( userId ) ) < nl > + } < nl > + < nl > + private final class SettingControlWrapper ( userId : Int ) extends Actor with ActorStashing { < nl > + < nl > + private val settingsControl = context . actorOf ( SettingsControl . props ( userId ) , " test - settings " ) < nl > + private var settings : AllNotificationSettings = _ < nl > + < nl > + def receive : Receive = receiveStashing ( replyTo ⇒ { < nl > + case s : AllNotificationSettings ⇒ < nl > + settings = s < nl > + context become initialized < nl > + unstashAll ( ) < nl > + } ) < nl > + < nl > + def initialized : Receive = { < nl > + case s : AllNotificationSettings ⇒ settings = s < nl > + case GetSettings ⇒ sender ( ) ! settings < nl > + } < nl > + < nl > + } < nl > + }

TEST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 index a6d98f8 . . d4e6fcb 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 @ @ - 51 , 7 + 51 , 7 @ @ object ParameterRepo { 
 } 
 
 def findPeerRingtone ( userId : Int ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ ( Peer , String ) ] ] = 
 - extractPeerParams [ ( Peer , String ) ] ( userId , prefix = s " category . mobile . ios . ringtone . chat . " ) { 
 + extractPeerParams [ ( Peer , String ) ] ( userId , prefix = " app . ios . mobile . notification . chat . sound . " ) { 
 case ( key , optValue ) ⇒ 
 key . split ( " _ " ) . toList match { 
 case " GROUP " : : id : : Nil ⇒ 
 @ @ - 68 , 7 + 68 , 7 @ @ object ParameterRepo { 
 case _ ⇒ true 
 } 
 
 - extractPeerParams [ ( Peer , Boolean ) ] ( userId , s " category . $ deviceType . notification . chat . " ) { 
 + extractPeerParams [ ( Peer , Boolean ) ] ( userId , prefix = s " category . $ deviceType . notification . chat . " ) { 
 case ( key , value ) ⇒ 
 key . split ( " \ \ . " ) . toList match { 
 case peerStr : : " enabled " : : Nil ⇒

NEAREST DIFF:
diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 index 0f15d4a . . 15b3fdf 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / configs / ParameterRepo . scala 
 @ @ - 61 , 7 + 61 , 7 @ @ object ParameterRepo { 
 for ( rows ← byUserIdAndKeyLikeC ( ( userId , s " $ prefix % _ % . % " ) ) . result ) yield { 
 rows flatMap { 
 case Parameter ( _ , key , value ) ⇒ 
 - key . drop ( prefix . length ) . split ( " . " ) . toList match { 
 + key . drop ( prefix . length ) . split ( " \ \ . " ) . toList match { 
 case peerStr : : " enabled " : : Nil ⇒ 
 peerStr . split ( " _ " ) . toList match { 
 case " GROUP " : : id : : Nil ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala 
 new file mode 100644 
 index 0000000 . . 728f63f 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / sequence / SettingControlSpec . scala 
 @ @ - 0 , 0 + 1 , 66 @ @ 
 + package im . actor . server . sequence 
 + 
 + import akka . actor . { Props , Actor } 
 + import akka . pattern . ask 
 + import im . actor . api . rpc . PeersImplicits 
 + import im . actor . concurrent . ActorStashing 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . model . Peer 
 + import im . actor . server . model . configs . Parameter 
 + import im . actor . server . persist . configs . ParameterRepo 
 + import im . actor . server . { ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 + import im . actor . server . api . rpc . service . configs . ConfigsServiceImpl 
 + 
 + class SettingControlSpec extends BaseAppSuite 
 + with ImplicitAuthService 
 + with ImplicitSessionRegion 
 + with PeersImplicits { 
 + 
 + behavior of " Setting Control " 
 + 
 + " Setting " should " up to date setting " in settings ( ) 
 + 
 + private val configService = new ConfigsServiceImpl 
 + 
 + def settings ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + 
 + val groupId = 1752533455 
 + val param = Parameter ( alice . id , s " category . mobile . notification . chat . GROUP _ $ { groupId } . enabled " , Some ( " false " ) ) 
 + whenReady ( DbExtension ( system ) . db . run ( ParameterRepo . createOrUpdate ( param ) ) ) ( identity ) 
 + 
 + val wrapperRef = system . actorOf ( SettingControlWrapper . props ( alice . id ) , " settingsWrapper " ) 
 + 
 + whenReady ( wrapperRef . ask ( GetSettings ) . mapTo [ AllNotificationSettings ] ) { settings ⇒ 
 + val peersSpecific = settings . specific ( " mobile " ) . peers 
 + peersSpecific should have size 1 
 + peersSpecific . get ( Peer . group ( groupId ) ) shouldEqual Some ( false ) 
 + } 
 + } 
 + 
 + case object GetSettings 
 + 
 + object SettingControlWrapper { 
 + def props ( userId : Int ) = Props ( new SettingControlWrapper ( userId ) ) 
 + } 
 + 
 + private final class SettingControlWrapper ( userId : Int ) extends Actor with ActorStashing { 
 + 
 + private val settingsControl = context . actorOf ( SettingsControl . props ( userId ) , " test - settings " ) 
 + private var settings : AllNotificationSettings = _ 
 + 
 + def receive : Receive = receiveStashing ( replyTo ⇒ { 
 + case s : AllNotificationSettings ⇒ 
 + settings = s 
 + context become initialized 
 + unstashAll ( ) 
 + } ) 
 + 
 + def initialized : Receive = { 
 + case s : AllNotificationSettings ⇒ settings = s 
 + case GetSettings ⇒ sender ( ) ! settings 
 + } 
 + 
 + } 
 + }
