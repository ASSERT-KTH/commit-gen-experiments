BLEU SCORE: 0.317023313852343

TEST MSG: feat ( core ) : Working end - to - end encryption
GENERATED MSG: feat ( core ) : More lightweight Encrypted Session initialization

TEST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > index fc92320 . . f5d5250 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java < nl > @ @ - 1 , 5 + 1 , 6 @ @ < nl > package im . actor . core . modules . encryption ; < nl > < nl > + import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > < nl > import im . actor . core . api . ApiEncryptedBox ; < nl > @ @ - 25 , 27 + 26 , 31 @ @ public class EncryptedMsgActor extends ModuleActor { < nl > < nl > private void doEncrypt ( int uid , ApiMessage message , final Future future ) { < nl > Log . d ( TAG , " doEncrypt " ) ; < nl > - ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . EncryptPackage ( message . toByteArray ( ) ) , new AskCallback ( ) { < nl > - @ Override < nl > - public void onResult ( Object obj ) { < nl > - Log . d ( TAG , " doEncrypt : onResult " ) ; < nl > - EncryptedBox encryptedBox = ( EncryptedBox ) obj ; < nl > - ArrayList < ApiEncyptedBoxKey > boxKeys = new ArrayList < ApiEncyptedBoxKey > ( ) ; < nl > - for ( EncryptedBoxKey b : encryptedBox . getKeys ( ) ) { < nl > - boxKeys . add ( new ApiEncyptedBoxKey ( b . getUid ( ) , < nl > - b . getKeyGroupId ( ) , " curve25519 " , b . getEncryptedKey ( ) ) ) ; < nl > + try { < nl > + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . EncryptPackage ( message . buildContainer ( ) ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + Log . d ( TAG , " doEncrypt : onResult " ) ; < nl > + EncryptedBox encryptedBox = ( EncryptedBox ) obj ; < nl > + ArrayList < ApiEncyptedBoxKey > boxKeys = new ArrayList < ApiEncyptedBoxKey > ( ) ; < nl > + for ( EncryptedBoxKey b : encryptedBox . getKeys ( ) ) { < nl > + boxKeys . add ( new ApiEncyptedBoxKey ( b . getUid ( ) , < nl > + b . getKeyGroupId ( ) , " curve25519 " , b . getEncryptedKey ( ) ) ) ; < nl > + } < nl > + ApiEncryptedBox apiEncryptedBox = new ApiEncryptedBox ( boxKeys , " aes - kuznechik " , encryptedBox . getEncryptedPackage ( ) ) ; < nl > + ApiEncryptedMessage apiEncryptedMessage = new ApiEncryptedMessage ( apiEncryptedBox ) ; < nl > + future . onResult ( new EncryptedMessage ( apiEncryptedMessage ) ) ; < nl > } < nl > - ApiEncryptedBox apiEncryptedBox = new ApiEncryptedBox ( boxKeys , " aes - kuznechik " , encryptedBox . getEncryptedPackage ( ) ) ; < nl > - ApiEncryptedMessage apiEncryptedMessage = new ApiEncryptedMessage ( apiEncryptedBox ) ; < nl > - future . onResult ( new EncryptedMessage ( apiEncryptedMessage ) ) ; < nl > - } < nl > < nl > - @ Override < nl > - public void onError ( Exception e ) { < nl > - Log . d ( TAG , " doEncrypt : onError " ) ; < nl > - future . onError ( e ) ; < nl > - } < nl > - } ) ; < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . d ( TAG , " doEncrypt : onError " ) ; < nl > + future . onError ( e ) ; < nl > + } < nl > + } ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + } < nl > } < nl > < nl > public void onDecrypt ( int uid , ApiEncryptedMessage message ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index bac687f . . b56a212 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 1 , 9 + 1 , 11 @ @ < nl > package im . actor . core . modules . encryption ; < nl > < nl > + import java . io . IOException ; < nl > import java . util . ArrayList ; < nl > import java . util . HashMap ; < nl > < nl > import im . actor . core . api . ApiEncryptionKeyGroup ; < nl > + import im . actor . core . api . ApiMessage ; < nl > import im . actor . core . api . ApiUserOutPeer ; < nl > import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; < nl > import im . actor . core . api . rpc . ResponsePublicKeyGroups ; < nl > @ @ - 148 , 15 + 150 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > future . onResult ( encryptedBox ) ; < nl > } < nl > < nl > - private void doDecrypt ( EncryptedBox data , final Future future ) { < nl > - int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > - byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > + private void doDecrypt ( final EncryptedBox data , final Future future ) { < nl > + final int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; < nl > + final byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > < nl > if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; < nl > byte [ ] encKey = null ; < nl > for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; < nl > + / / Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; < nl > if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > encKey = k . getEncryptedKey ( ) ; < nl > break ; < nl > @ @ - 168 , 14 + 170 , 30 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > } < nl > < nl > Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > - for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > - Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > - } < nl > + Log . d ( TAG , " EncKey : " + Hex . toHex ( encKey ) ) ; < nl > + / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; < nl > + / / } < nl > < nl > ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > Log . d ( TAG , " Decryption with key group : onResult " ) ; < nl > + EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; < nl > + < nl > + byte [ ] encData ; < nl > + try { < nl > + encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; < nl > + < nl > + ApiMessage message = ApiMessage . fromBytes ( encData ) ; < nl > + < nl > + Log . d ( TAG , " Box open : " + message ) ; < nl > + } catch ( IOException e ) { < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + return ; < nl > + } < nl > + < nl > future . onResult ( ) ; < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 0ff4699 . . c1783c7 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 242 , 11 + 242 , 27 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > - new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > + new RatchetPrivateKey ( ownEphermalKey . getKey ( ) ) , < nl > + new RatchetPublicKey ( theirEphermalKey . getPublicKey ( ) ) , < nl > master _ secret ) ; < nl > < nl > - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > + int messageIndex = outIndex + + ; < nl > + < nl > + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; < nl > + < nl > + Log . d ( TAG , " MS : " + Hex . toHex ( master _ secret ) ) ; < nl > + Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; < nl > + Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey0 . getKey ( ) ) ) ) ; < nl > + Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; < nl > + Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; < nl > + Log . d ( TAG , " RC : " + Hex . toHex ( rootChainKey ) ) ; < nl > + Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) ) ) ; < nl > + Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; < nl > + < nl > + Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; < nl > + Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; < nl > + Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; < nl > + Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > @ @ - 254 , 7 + 270 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , < nl > theirEphermalKey . getPublicKey ( ) , < nl > - ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / < nl > + ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / < nl > < nl > byte [ ] encrypted ; < nl > try { < nl > @ @ - 279 , 41 + 295 , 39 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > < nl > + / / Log . d ( TAG , " onDecrypt : Own " + Hex . toHex ( ownEphermalKey ) ) ; < nl > + / / Log . d ( TAG , " onDecrypt : Their " + Hex . toHex ( theirEphermalKey ) ) ; < nl > < nl > - Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; < nl > - Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > + Log . d ( TAG , " ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > + Log . d ( TAG , " theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > < nl > ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > - < nl > - Log . d ( TAG , " onDecrypt : onResultEphermal " ) ; < nl > - < nl > - final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey < nl > - = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > < nl > ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( theirEphermalKey0Id ) , < nl > new AskCallback ( ) { < nl > @ Override < nl > public void onResult ( Object obj ) { < nl > < nl > - Log . d ( TAG , " onDecrypt : onResultPrivate " ) ; < nl > - < nl > - final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey0 < nl > + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey0 < nl > = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; < nl > < nl > + Log . d ( TAG , " theirEphermalKey0 : " + Hex . toHex ( Curve25519 . keyGenPublic ( theirEphermalKey0 . getPrivateKey ( ) ) ) ) ; < nl > + < nl > ArrayList < Long > keys = new ArrayList < Long > ( ) ; < nl > keys . add ( ownEphermalKey0Id ) ; < nl > request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > - Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; < nl > - onDecrypt ( data , ownEphermalKey0 . getPrivateKey ( ) , < nl > - ownEphermalKey . getPrivateKey ( ) , < nl > - theirEphermalKey , < nl > - response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) , < nl > + byte [ ] ownEphermalKey0 = response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) ; < nl > + Log . d ( TAG , " ownEphermalKey0 : " + Hex . toHex ( ownEphermalKey0 ) ) ; < nl > + onDecrypt ( data , < nl > + ownEphermalKey0 , < nl > + ownEphermalKey , < nl > + theirEphermalKey0 . getPrivateKey ( ) , < nl > + theirEphermalKey . getPrivateKey ( ) , < nl > messageIndex , < nl > future ) ; < nl > } < nl > @ @ - 346 , 10 + 360 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > private void onDecrypt ( byte [ ] data , < nl > - byte [ ] ownEphemeralPrivateKey0 , < nl > - byte [ ] ownEphemeralPrivateKey , < nl > byte [ ] theirEphemeralKey0 , < nl > byte [ ] theirEphemeralKey , < nl > + byte [ ] ownEphemeralPrivateKey0 , < nl > + byte [ ] ownEphemeralPrivateKey , < nl > int index , < nl > Future future ) { < nl > < nl > @ @ - 368 , 8 + 382 , 36 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; < nl > < nl > + Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; < nl > + Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; < nl > + Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; < nl > + Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; < nl > + Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; < nl > + < nl > + Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; < nl > + Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; < nl > + Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; < nl > < nl > - future . onResult ( ) ; < nl > + Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; < nl > + Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; < nl > + Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; < nl > + Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; < nl > + < nl > + byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; < nl > + byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; < nl > + < nl > + byte [ ] plainText ; < nl > + try { < nl > + plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; < nl > + Log . d ( TAG , " Plain Text " ) ; < nl > + } catch ( IntegrityException e ) { < nl > + Log . d ( TAG , " Plain Text error " ) ; < nl > + e . printStackTrace ( ) ; < nl > + future . onError ( e ) ; < nl > + return ; < nl > + } < nl > + < nl > + future . onResult ( new DecryptedPackage ( plainText ) ) ; < nl > } < nl > < nl > @ Override < nl > @ @ - 423 , 4 + 465 , 17 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return data ; < nl > } < nl > } < nl > + < nl > + public static class DecryptedPackage { < nl > + < nl > + private byte [ ] data ; < nl > + < nl > + public DecryptedPackage ( byte [ ] data ) { < nl > + this . data = data ; < nl > + } < nl > + < nl > + public byte [ ] getData ( ) { < nl > + return data ; < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java < nl > index 113b17e . . d74c271 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java < nl > @ @ - 13 , 6 + 13 , 9 @ @ public class SHA256 implements Digest { < nl > < nl > @ Override < nl > public void update ( byte [ ] src , int offset , int length ) { < nl > + if ( length + offset > src . length ) { < nl > + throw new RuntimeException ( " Incorrect length " ) ; < nl > + } < nl > sha256Digest . update ( src , offset , length ) ; < nl > } < nl > < nl > diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java < nl > index fe29c11 . . a5678dc 100644 < nl > - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java < nl > + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java < nl > @ @ - 58 , 12 + 58 , 13 @ @ public class HKDF { < nl > hmac . doFinal ( result , 0 ) ; < nl > < nl > int digestSize = baseDigest . getDigestSize ( ) ; < nl > - int blockLength = Math . min ( outputSize - ( index + 1 ) * digestSize , digestSize ) ; < nl > - ByteStrings . write ( res , index * digestSize , result , 0 , blockLength ) ; < nl > + int blockLength = Math . min ( outputSize - offset , digestSize ) ; < nl > + ByteStrings . write ( res , offset , result , 0 , blockLength ) ; < nl > < nl > - prevHash = res ; < nl > + prevHash = result ; < nl > < nl > offset + = digestSize ; < nl > + index + + ; < nl > } < nl > < nl > return res ;
NEAREST DIFF (one line): diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > index 2d55d49 . . bac687f 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java < nl > @ @ - 153 , 14 + 153 , 19 @ @ public class EncryptedPeerActor extends ModuleActor { < nl > byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; < nl > < nl > if ( sessions . containsKey ( senderKeyGroup ) ) { < nl > - Log . d ( TAG , " Decryption with key group " ) ; < nl > + Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; < nl > byte [ ] encKey = null ; < nl > for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > + Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; < nl > if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { < nl > encKey = k . getEncryptedKey ( ) ; < nl > break ; < nl > } < nl > } < nl > + if ( encKey = = null ) { < nl > + Log . d ( TAG , " Unable to find encryption key in key group " ) ; < nl > + return ; < nl > + } < nl > < nl > Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; < nl > for ( EncryptedBoxKey k : data . getKeys ( ) ) { < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > index 50a0cc1 . . 0ff4699 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java < nl > @ @ - 20 , 7 + 20 , 6 @ @ import im . actor . runtime . Crypto ; < nl > import im . actor . runtime . Log ; < nl > import im . actor . runtime . actors . Future ; < nl > import im . actor . runtime . actors . ask . AskCallback ; < nl > - import im . actor . runtime . actors . ask . AskRequest ; < nl > import im . actor . runtime . crypto . Curve25519 ; < nl > import im . actor . runtime . crypto . IntegrityException ; < nl > import im . actor . runtime . crypto . box . ActorBox ; < nl > @ @ - 48 , 13 + 47 , 9 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > private OwnPrivateKey currentOwnKey ; < nl > private UserPublicKey currentTheirKey ; < nl > < nl > - private byte [ ] rootChainKey ; < nl > - < nl > private int outIndex = 0 ; < nl > private int inIndex = 0 ; < nl > < nl > - private boolean isReady = false ; < nl > - < nl > public EncryptedSessionActor ( ModuleContext context , int uid , UserKeysGroup encryptionKeyGroup ) { < nl > super ( context ) ; < nl > this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; < nl > @ @ - 65 , 36 + 60 , 104 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > @ Override < nl > public void preStart ( ) { < nl > - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { < nl > - Log . d ( TAG , " Loading own keys for conversation " ) ; < nl > - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > - @ Override < nl > - public void onResult ( Object obj ) { < nl > - Log . d ( TAG , " Own keys loaded " ) ; < nl > - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > - ownIdentityKey = res . getIdentityKey ( ) ; < nl > - ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > - currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; < nl > - onOwnReady ( ) ; < nl > - } < nl > + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { < nl > + @ Override < nl > + public void onResult ( Object obj ) { < nl > + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; < nl > + ownIdentityKey = res . getIdentityKey ( ) ; < nl > + ownEphermalKey0 = res . getEphemeralKey ( ) ; < nl > + currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; < nl > + } < nl > < nl > - @ Override < nl > - public void onError ( Exception e ) { < nl > - / / Nothing to do < nl > - Log . w ( TAG , " Own keys error " ) ; < nl > - Log . e ( TAG , e ) ; < nl > + @ Override < nl > + public void onError ( Exception e ) { < nl > + Log . w ( TAG , " Own keys error " ) ; < nl > + Log . e ( TAG , e ) ; < nl > < nl > - } < nl > - } ) ; < nl > - } else { < nl > - onOwnReady ( ) ; < nl > - } < nl > + / / Crashing Actor < nl > + throw new RuntimeException ( e ) ; < nl > + } < nl > + } ) ; < nl > } < nl > < nl > - private void onOwnReady ( ) { < nl > - Log . w ( TAG , " Own keys ready " ) ; < nl > - < nl > + / / private void onOwnReady ( ) { < nl > + / / Log . w ( TAG , " Own keys ready " ) ; < nl > + / / < nl > + / / if ( theirEphermalKey0 = = null ) { < nl > + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + / / @ Override < nl > + / / public void onResult ( ResponsePublicKeys response ) { < nl > + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + / / Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / < nl > + / / @ Override < nl > + / / public void onError ( RpcException e ) { < nl > + / / / / Nothing to do < nl > + / / Log . w ( TAG , " Their ephemeral error " ) ; < nl > + / / Log . e ( TAG , e ) ; < nl > + / / } < nl > + / / } ) ; < nl > + / / } else { < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / private void onTheirReady0 ( ) { < nl > + / / Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > + / / < nl > + / / if ( currentTheirKey = = null ) { < nl > + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + / / @ Override < nl > + / / public void onResult ( ResponsePublicKeys response ) { < nl > + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { < nl > + / / Log . w ( TAG , " No ephemeral keys found " ) ; < nl > + / / return ; < nl > + / / } < nl > + / / < nl > + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > + / / currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > + / / allSet ( ) ; < nl > + / / } < nl > + / / < nl > + / / @ Override < nl > + / / public void onError ( RpcException e ) { < nl > + / / / / Nothing to do < nl > + / / Log . w ( TAG , " Their ephemeral error " ) ; < nl > + / / Log . e ( TAG , e ) ; < nl > + / / } < nl > + / / } ) ; < nl > + / / } else { < nl > + / / onTheirReady0 ( ) ; < nl > + / / } < nl > + / / } < nl > + / / < nl > + / / private void allSet ( ) { < nl > + / / Log . d ( TAG , " All keys are ready " ) ; < nl > + / / isReady = true ; < nl > + / / < nl > + / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > + / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > + / / rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > + / / master _ secret ) ; < nl > + / / < nl > + / / unstashAll ( ) ; < nl > + / / } < nl > + < nl > + private boolean assumeEnabled ( final Runnable onOk ) { < nl > if ( theirEphermalKey0 = = null ) { < nl > + Log . w ( TAG , " Loading their ephemeral key0 " ) ; < nl > request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > @ @ - 105 , 7 + 168 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > - onTheirReady0 ( ) ; < nl > + onOk . run ( ) ; < nl > } < nl > < nl > @ Override < nl > @ @ - 115 , 15 + 178 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . e ( TAG , e ) ; < nl > } < nl > } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > + return false ; < nl > } < nl > - } < nl > - < nl > - private void onTheirReady0 ( ) { < nl > - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; < nl > - < nl > if ( currentTheirKey = = null ) { < nl > + Log . w ( TAG , " Loading their ephemeral key " ) ; < nl > request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > @ @ - 134 , 7 + 192 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; < nl > currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; < nl > - allSet ( ) ; < nl > + onOk . run ( ) ; < nl > } < nl > < nl > @ Override < nl > @ @ - 144 , 38 + 202 , 58 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > Log . e ( TAG , e ) ; < nl > } < nl > } ) ; < nl > - } else { < nl > - onTheirReady0 ( ) ; < nl > + return false ; < nl > + } < nl > + return true ; < nl > + } < nl > + < nl > + private void onEncrypt ( final byte [ ] data , final Future future ) { < nl > + < nl > + if ( ! assumeEnabled ( new Runnable ( ) { < nl > + @ Override < nl > + public void run ( ) { < nl > + onEncrypt ( data , future ) ; < nl > + } < nl > + } ) ) { < nl > + return ; < nl > } < nl > + < nl > + onEncrypt ( data , < nl > + ownEphermalKey0 , < nl > + currentOwnKey , < nl > + theirEphermalKey0 , < nl > + currentTheirKey , < nl > + future ) ; < nl > } < nl > < nl > - private void allSet ( ) { < nl > - Log . d ( TAG , " All keys are ready " ) ; < nl > - isReady = true ; < nl > + private void onEncrypt ( byte [ ] data , < nl > + OwnPrivateKey ownEphermalKey0 , < nl > + OwnPrivateKey ownEphermalKey , < nl > + UserPublicKey theirEphermalKey0 , < nl > + UserPublicKey theirEphermalKey , < nl > + Future future ) { < nl > + < nl > + Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > + Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > < nl > byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( < nl > new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , < nl > new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; < nl > - rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > + byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( < nl > new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , < nl > new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , < nl > master _ secret ) ; < nl > < nl > - unstashAll ( ) ; < nl > - } < nl > - < nl > - private void onEncrypt ( byte [ ] data , Future future ) { < nl > - < nl > ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; < nl > < nl > byte [ ] header = ByteStrings . merge ( < nl > ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , < nl > ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / < nl > ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / < nl > - Curve25519 . keyGenPublic ( currentOwnKey . getKey ( ) ) , < nl > - currentTheirKey . getPublicKey ( ) , < nl > + Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , < nl > + theirEphermalKey . getPublicKey ( ) , < nl > ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / < nl > < nl > byte [ ] encrypted ; < nl > @ @ - 187 , 41 + 265 , 22 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > return ; < nl > } < nl > < nl > - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; < nl > - < nl > - < nl > - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; < nl > - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; < nl > - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; < nl > - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; < nl > - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; < nl > - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; < nl > - < nl > - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; < nl > - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; < nl > - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; < nl > - < nl > - < nl > - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; < nl > - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; < nl > - < nl > - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; < nl > + future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; < nl > } < nl > < nl > private void onDecrypt ( final byte [ ] data , final Future future ) { < nl > - final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > + Log . d ( TAG , " onDecrypt " ) ; < nl > + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > + < nl > + final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; < nl > final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; < nl > final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; < nl > final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; < nl > final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; < nl > final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; < nl > < nl > - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; < nl > - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; < nl > + < nl > + Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; < nl > Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; < nl > Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; < nl > Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; < nl > @ @ - 247 , 8 + 306 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > < nl > ArrayList < Long > keys = new ArrayList < Long > ( ) ; < nl > keys . add ( ownEphermalKey0Id ) ; < nl > - < nl > - request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { < nl > @ Override < nl > public void onResult ( ResponsePublicKeys response ) { < nl > Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; < nl > @ @ - 295 , 6 + 353 , 8 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > int index , < nl > Future future ) { < nl > < nl > + Log . d ( TAG , " onDecrypt2 " ) ; < nl > + < nl > byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( < nl > new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , < nl > new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , < nl > @ @ - 313 , 16 + 373 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { < nl > } < nl > < nl > @ Override < nl > - public void onReceive ( Object message ) { < nl > - Log . d ( TAG , " msg : " + message ) ; < nl > - if ( ! isReady & & message instanceof AskRequest ) { < nl > - stash ( ) ; < nl > - return ; < nl > - } < nl > - super . onReceive ( message ) ; < nl > - } < nl > - < nl > - @ Override < nl > public boolean onAsk ( Object message , Future future ) { < nl > if ( message instanceof EncryptPackage ) { < nl > onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; < nl > diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > index a24abaa . . 72ceb4c 100644 < nl > - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java < nl > @ @ - 1 , 6 + 1 , 7 @ @ < nl > package im . actor . core . modules . encryption . entity ; < nl > < nl > import java . io . IOException ; < nl > + import java . util . ArrayList ; < nl > import java . util . List ; < nl > < nl > import im . actor . core . modules . encryption . Configuration ; < nl > @ @ - 77 , 7 + 78 , 13 @ @ public class OwnKeys extends BserObject { < nl > } < nl > < nl > public OwnPrivateKeyUploadable pickRandomEphemeralKey ( ) { < nl > - return ephemeralKeys [ RandomUtils . randomId ( ephemeralKeys . length ) ] ; < nl > + ArrayList < OwnPrivateKeyUploadable > uploadedKeys = new ArrayList < OwnPrivateKeyUploadable > ( ) ; < nl > + for ( OwnPrivateKeyUploadable u : ephemeralKeys ) { < nl > + if ( u . isUploaded ( ) ) { < nl > + uploadedKeys . add ( u ) ; < nl > + } < nl > + } < nl > + return uploadedKeys . get ( RandomUtils . randomId ( uploadedKeys . size ( ) ) ) ; < nl > } < nl > < nl > @ Override

TEST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 index fc92320 . . f5d5250 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedMsgActor . java 
 @ @ - 1 , 5 + 1 , 6 @ @ 
 package im . actor . core . modules . encryption ; 
 
 + import java . io . IOException ; 
 import java . util . ArrayList ; 
 
 import im . actor . core . api . ApiEncryptedBox ; 
 @ @ - 25 , 27 + 26 , 31 @ @ public class EncryptedMsgActor extends ModuleActor { 
 
 private void doEncrypt ( int uid , ApiMessage message , final Future future ) { 
 Log . d ( TAG , " doEncrypt " ) ; 
 - ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . EncryptPackage ( message . toByteArray ( ) ) , new AskCallback ( ) { 
 - @ Override 
 - public void onResult ( Object obj ) { 
 - Log . d ( TAG , " doEncrypt : onResult " ) ; 
 - EncryptedBox encryptedBox = ( EncryptedBox ) obj ; 
 - ArrayList < ApiEncyptedBoxKey > boxKeys = new ArrayList < ApiEncyptedBoxKey > ( ) ; 
 - for ( EncryptedBoxKey b : encryptedBox . getKeys ( ) ) { 
 - boxKeys . add ( new ApiEncyptedBoxKey ( b . getUid ( ) , 
 - b . getKeyGroupId ( ) , " curve25519 " , b . getEncryptedKey ( ) ) ) ; 
 + try { 
 + ask ( context ( ) . getEncryption ( ) . getEncryptedChatManager ( uid ) , new EncryptedPeerActor . EncryptPackage ( message . buildContainer ( ) ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + Log . d ( TAG , " doEncrypt : onResult " ) ; 
 + EncryptedBox encryptedBox = ( EncryptedBox ) obj ; 
 + ArrayList < ApiEncyptedBoxKey > boxKeys = new ArrayList < ApiEncyptedBoxKey > ( ) ; 
 + for ( EncryptedBoxKey b : encryptedBox . getKeys ( ) ) { 
 + boxKeys . add ( new ApiEncyptedBoxKey ( b . getUid ( ) , 
 + b . getKeyGroupId ( ) , " curve25519 " , b . getEncryptedKey ( ) ) ) ; 
 + } 
 + ApiEncryptedBox apiEncryptedBox = new ApiEncryptedBox ( boxKeys , " aes - kuznechik " , encryptedBox . getEncryptedPackage ( ) ) ; 
 + ApiEncryptedMessage apiEncryptedMessage = new ApiEncryptedMessage ( apiEncryptedBox ) ; 
 + future . onResult ( new EncryptedMessage ( apiEncryptedMessage ) ) ; 
 } 
 - ApiEncryptedBox apiEncryptedBox = new ApiEncryptedBox ( boxKeys , " aes - kuznechik " , encryptedBox . getEncryptedPackage ( ) ) ; 
 - ApiEncryptedMessage apiEncryptedMessage = new ApiEncryptedMessage ( apiEncryptedBox ) ; 
 - future . onResult ( new EncryptedMessage ( apiEncryptedMessage ) ) ; 
 - } 
 
 - @ Override 
 - public void onError ( Exception e ) { 
 - Log . d ( TAG , " doEncrypt : onError " ) ; 
 - future . onError ( e ) ; 
 - } 
 - } ) ; 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . d ( TAG , " doEncrypt : onError " ) ; 
 + future . onError ( e ) ; 
 + } 
 + } ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + } 
 } 
 
 public void onDecrypt ( int uid , ApiEncryptedMessage message ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index bac687f . . b56a212 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 1 , 9 + 1 , 11 @ @ 
 package im . actor . core . modules . encryption ; 
 
 + import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 
 import im . actor . core . api . ApiEncryptionKeyGroup ; 
 + import im . actor . core . api . ApiMessage ; 
 import im . actor . core . api . ApiUserOutPeer ; 
 import im . actor . core . api . rpc . RequestLoadPublicKeyGroups ; 
 import im . actor . core . api . rpc . ResponsePublicKeyGroups ; 
 @ @ - 148 , 15 + 150 , 15 @ @ public class EncryptedPeerActor extends ModuleActor { 
 future . onResult ( encryptedBox ) ; 
 } 
 
 - private void doDecrypt ( EncryptedBox data , final Future future ) { 
 - int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 - byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 + private void doDecrypt ( final EncryptedBox data , final Future future ) { 
 + final int senderKeyGroup = ByteStrings . bytesToInt ( ByteStrings . substring ( data . getEncryptedPackage ( ) , 0 , 4 ) ) ; 
 + final byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 
 if ( sessions . containsKey ( senderKeyGroup ) ) { 
 Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; 
 byte [ ] encKey = null ; 
 for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; 
 + / / Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; 
 if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 encKey = k . getEncryptedKey ( ) ; 
 break ; 
 @ @ - 168 , 14 + 170 , 30 @ @ public class EncryptedPeerActor extends ModuleActor { 
 } 
 
 Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 - for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 - Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 - } 
 + Log . d ( TAG , " EncKey : " + Hex . toHex ( encKey ) ) ; 
 + / / for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + / / Log . d ( TAG , " Key : " + Hex . toHex ( k . getEncryptedKey ( ) ) ) ; 
 + / / } 
 
 ask ( sessions . get ( senderKeyGroup ) , new EncryptedSessionActor . DecryptPackage ( encKey ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 Log . d ( TAG , " Decryption with key group : onResult " ) ; 
 + EncryptedSessionActor . DecryptedPackage decryptedPackage = ( EncryptedSessionActor . DecryptedPackage ) obj ; 
 + 
 + byte [ ] encData ; 
 + try { 
 + encData = ActorBox . openBox ( ByteStrings . intToBytes ( senderKeyGroup ) , encPackage , new ActorBoxKey ( decryptedPackage . getData ( ) ) ) ; 
 + 
 + ApiMessage message = ApiMessage . fromBytes ( encData ) ; 
 + 
 + Log . d ( TAG , " Box open : " + message ) ; 
 + } catch ( IOException e ) { 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + return ; 
 + } 
 + 
 future . onResult ( ) ; 
 } 
 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 0ff4699 . . c1783c7 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 242 , 11 + 242 , 27 @ @ public class EncryptedSessionActor extends ModuleActor { 
 new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 - new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 - new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 + new RatchetPrivateKey ( ownEphermalKey . getKey ( ) ) , 
 + new RatchetPublicKey ( theirEphermalKey . getPublicKey ( ) ) , 
 master _ secret ) ; 
 
 - ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 + int messageIndex = outIndex + + ; 
 + 
 + ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , messageIndex ) ; 
 + 
 + Log . d ( TAG , " MS : " + Hex . toHex ( master _ secret ) ) ; 
 + Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; 
 + Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey0 . getKey ( ) ) ) ) ; 
 + Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; 
 + Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; 
 + Log . d ( TAG , " RC : " + Hex . toHex ( rootChainKey ) ) ; 
 + Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) ) ) ; 
 + Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphermalKey . getPublicKey ( ) ) ) ; 
 + 
 + Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; 
 + Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; 
 + Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; 
 + Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 @ @ - 254 , 7 + 270 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , 
 theirEphermalKey . getPublicKey ( ) , 
 - ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / 
 + ByteStrings . intToBytes ( messageIndex ) ) ; / * Message Index * / 
 
 byte [ ] encrypted ; 
 try { 
 @ @ - 279 , 41 + 295 , 39 @ @ public class EncryptedSessionActor extends ModuleActor { 
 final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 
 + / / Log . d ( TAG , " onDecrypt : Own " + Hex . toHex ( ownEphermalKey ) ) ; 
 + / / Log . d ( TAG , " onDecrypt : Their " + Hex . toHex ( theirEphermalKey ) ) ; 
 
 - Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; 
 - Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 + Log . d ( TAG , " ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 + Log . d ( TAG , " theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 
 ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKey ( theirEphermalKey ) , new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 - 
 - Log . d ( TAG , " onDecrypt : onResultEphermal " ) ; 
 - 
 - final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey 
 - = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 
 ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchEphemeralPrivateKeyById ( theirEphermalKey0Id ) , 
 new AskCallback ( ) { 
 @ Override 
 public void onResult ( Object obj ) { 
 
 - Log . d ( TAG , " onDecrypt : onResultPrivate " ) ; 
 - 
 - final KeyManagerActor . FetchEphemeralPrivateKeyRes ownEphermalKey0 
 + final KeyManagerActor . FetchEphemeralPrivateKeyRes theirEphermalKey0 
 = ( KeyManagerActor . FetchEphemeralPrivateKeyRes ) obj ; 
 
 + Log . d ( TAG , " theirEphermalKey0 : " + Hex . toHex ( Curve25519 . keyGenPublic ( theirEphermalKey0 . getPrivateKey ( ) ) ) ) ; 
 + 
 ArrayList < Long > keys = new ArrayList < Long > ( ) ; 
 keys . add ( ownEphermalKey0Id ) ; 
 request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 - Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; 
 - onDecrypt ( data , ownEphermalKey0 . getPrivateKey ( ) , 
 - ownEphermalKey . getPrivateKey ( ) , 
 - theirEphermalKey , 
 - response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) , 
 + byte [ ] ownEphermalKey0 = response . getPublicKey ( ) . get ( 0 ) . getKeyMaterial ( ) ; 
 + Log . d ( TAG , " ownEphermalKey0 : " + Hex . toHex ( ownEphermalKey0 ) ) ; 
 + onDecrypt ( data , 
 + ownEphermalKey0 , 
 + ownEphermalKey , 
 + theirEphermalKey0 . getPrivateKey ( ) , 
 + theirEphermalKey . getPrivateKey ( ) , 
 messageIndex , 
 future ) ; 
 } 
 @ @ - 346 , 10 + 360 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 private void onDecrypt ( byte [ ] data , 
 - byte [ ] ownEphemeralPrivateKey0 , 
 - byte [ ] ownEphemeralPrivateKey , 
 byte [ ] theirEphemeralKey0 , 
 byte [ ] theirEphemeralKey , 
 + byte [ ] ownEphemeralPrivateKey0 , 
 + byte [ ] ownEphemeralPrivateKey , 
 int index , 
 Future future ) { 
 
 @ @ - 368 , 8 + 382 , 36 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rc , index ) ; 
 
 + Log . d ( TAG , " MS : " + Hex . toHex ( ms ) ) ; 
 + Log . d ( TAG , " MS _ 11 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownIdentityKey . getKey ( ) ) ) ) ; 
 + Log . d ( TAG , " MS _ 21 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey0 ) ) ) ; 
 + Log . d ( TAG , " MS _ 31 : " + Hex . toHex ( encryptionKeyGroup . getIdentityKey ( ) . getPublicKey ( ) ) ) ; 
 + Log . d ( TAG , " MS _ 41 : " + Hex . toHex ( theirEphemeralKey0 ) ) ; 
 + 
 + Log . d ( TAG , " RC : " + Hex . toHex ( rc ) ) ; 
 + Log . d ( TAG , " RC _ 1 : " + Hex . toHex ( Curve25519 . keyGenPublic ( ownEphemeralPrivateKey ) ) ) ; 
 + Log . d ( TAG , " RC _ 2 : " + Hex . toHex ( theirEphemeralKey ) ) ; 
 
 - future . onResult ( ) ; 
 + Log . d ( TAG , " AES : " + Hex . toHex ( ratchetMessageKey . getKeyAES ( ) ) ) ; 
 + Log . d ( TAG , " AES _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacAES ( ) ) ) ; 
 + Log . d ( TAG , " KUZ : " + Hex . toHex ( ratchetMessageKey . getKeyKuz ( ) ) ) ; 
 + Log . d ( TAG , " KUZ _ MAC : " + Hex . toHex ( ratchetMessageKey . getMacKuz ( ) ) ) ; 
 + 
 + byte [ ] header = ByteStrings . substring ( data , 0 , 88 ) ; 
 + byte [ ] pkg = ByteStrings . substring ( data , 88 , data . length - 88 ) ; 
 + 
 + byte [ ] plainText ; 
 + try { 
 + plainText = ActorBox . openBox ( header , pkg , ratchetMessageKey ) ; 
 + Log . d ( TAG , " Plain Text " ) ; 
 + } catch ( IntegrityException e ) { 
 + Log . d ( TAG , " Plain Text error " ) ; 
 + e . printStackTrace ( ) ; 
 + future . onError ( e ) ; 
 + return ; 
 + } 
 + 
 + future . onResult ( new DecryptedPackage ( plainText ) ) ; 
 } 
 
 @ Override 
 @ @ - 423 , 4 + 465 , 17 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return data ; 
 } 
 } 
 + 
 + public static class DecryptedPackage { 
 + 
 + private byte [ ] data ; 
 + 
 + public DecryptedPackage ( byte [ ] data ) { 
 + this . data = data ; 
 + } 
 + 
 + public byte [ ] getData ( ) { 
 + return data ; 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java 
 index 113b17e . . d74c271 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / digest / SHA256 . java 
 @ @ - 13 , 6 + 13 , 9 @ @ public class SHA256 implements Digest { 
 
 @ Override 
 public void update ( byte [ ] src , int offset , int length ) { 
 + if ( length + offset > src . length ) { 
 + throw new RuntimeException ( " Incorrect length " ) ; 
 + } 
 sha256Digest . update ( src , offset , length ) ; 
 } 
 
 diff - - git a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java 
 index fe29c11 . . a5678dc 100644 
 - - - a / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java 
 + + + b / actor - sdk / sdk - core / runtime / runtime - shared / src / main / java / im / actor / runtime / crypto / primitives / kdf / HKDF . java 
 @ @ - 58 , 12 + 58 , 13 @ @ public class HKDF { 
 hmac . doFinal ( result , 0 ) ; 
 
 int digestSize = baseDigest . getDigestSize ( ) ; 
 - int blockLength = Math . min ( outputSize - ( index + 1 ) * digestSize , digestSize ) ; 
 - ByteStrings . write ( res , index * digestSize , result , 0 , blockLength ) ; 
 + int blockLength = Math . min ( outputSize - offset , digestSize ) ; 
 + ByteStrings . write ( res , offset , result , 0 , blockLength ) ; 
 
 - prevHash = res ; 
 + prevHash = result ; 
 
 offset + = digestSize ; 
 + index + + ; 
 } 
 
 return res ;

NEAREST DIFF:
diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 index 2d55d49 . . bac687f 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedPeerActor . java 
 @ @ - 153 , 14 + 153 , 19 @ @ public class EncryptedPeerActor extends ModuleActor { 
 byte [ ] encPackage = ByteStrings . substring ( data . getEncryptedPackage ( ) , 4 , data . getEncryptedPackage ( ) . length - 4 ) ; 
 
 if ( sessions . containsKey ( senderKeyGroup ) ) { 
 - Log . d ( TAG , " Decryption with key group " ) ; 
 + Log . d ( TAG , " Decryption with key group # " + senderKeyGroup ) ; 
 byte [ ] encKey = null ; 
 for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 + Log . d ( TAG , " Key group : # " + k . getKeyGroupId ( ) + " # " + k . getUid ( ) ) ; 
 if ( k . getKeyGroupId ( ) = = ownKeyGroupId & & k . getUid ( ) = = myUid ( ) ) { 
 encKey = k . getEncryptedKey ( ) ; 
 break ; 
 } 
 } 
 + if ( encKey = = null ) { 
 + Log . d ( TAG , " Unable to find encryption key in key group " ) ; 
 + return ; 
 + } 
 
 Log . d ( TAG , " EncPackage : " + Hex . toHex ( encPackage ) ) ; 
 for ( EncryptedBoxKey k : data . getKeys ( ) ) { 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 index 50a0cc1 . . 0ff4699 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / EncryptedSessionActor . java 
 @ @ - 20 , 7 + 20 , 6 @ @ import im . actor . runtime . Crypto ; 
 import im . actor . runtime . Log ; 
 import im . actor . runtime . actors . Future ; 
 import im . actor . runtime . actors . ask . AskCallback ; 
 - import im . actor . runtime . actors . ask . AskRequest ; 
 import im . actor . runtime . crypto . Curve25519 ; 
 import im . actor . runtime . crypto . IntegrityException ; 
 import im . actor . runtime . crypto . box . ActorBox ; 
 @ @ - 48 , 13 + 47 , 9 @ @ public class EncryptedSessionActor extends ModuleActor { 
 private OwnPrivateKey currentOwnKey ; 
 private UserPublicKey currentTheirKey ; 
 
 - private byte [ ] rootChainKey ; 
 - 
 private int outIndex = 0 ; 
 private int inIndex = 0 ; 
 
 - private boolean isReady = false ; 
 - 
 public EncryptedSessionActor ( ModuleContext context , int uid , UserKeysGroup encryptionKeyGroup ) { 
 super ( context ) ; 
 this . TAG = " EncryptionSessionActor # " + uid + " _ " + encryptionKeyGroup . getKeyGroupId ( ) ; 
 @ @ - 65 , 36 + 60 , 104 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 @ Override 
 public void preStart ( ) { 
 - if ( ownIdentityKey = = null | | ownEphermalKey0 = = null | | currentOwnKey = = null ) { 
 - Log . d ( TAG , " Loading own keys for conversation " ) ; 
 - ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 - @ Override 
 - public void onResult ( Object obj ) { 
 - Log . d ( TAG , " Own keys loaded " ) ; 
 - KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 - ownIdentityKey = res . getIdentityKey ( ) ; 
 - ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 - currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; 
 - onOwnReady ( ) ; 
 - } 
 + ask ( context ( ) . getEncryption ( ) . getKeyManager ( ) , new KeyManagerActor . FetchOwnKey ( ) , new AskCallback ( ) { 
 + @ Override 
 + public void onResult ( Object obj ) { 
 + KeyManagerActor . FetchOwnKeyResult res = ( KeyManagerActor . FetchOwnKeyResult ) obj ; 
 + ownIdentityKey = res . getIdentityKey ( ) ; 
 + ownEphermalKey0 = res . getEphemeralKey ( ) ; 
 + currentOwnKey = new OwnPrivateKey ( RandomUtils . nextRid ( ) , " curve25519 " , Curve25519 . keyGenPrivate ( Crypto . randomBytes ( 64 ) ) ) ; 
 + } 
 
 - @ Override 
 - public void onError ( Exception e ) { 
 - / / Nothing to do 
 - Log . w ( TAG , " Own keys error " ) ; 
 - Log . e ( TAG , e ) ; 
 + @ Override 
 + public void onError ( Exception e ) { 
 + Log . w ( TAG , " Own keys error " ) ; 
 + Log . e ( TAG , e ) ; 
 
 - } 
 - } ) ; 
 - } else { 
 - onOwnReady ( ) ; 
 - } 
 + / / Crashing Actor 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } ) ; 
 } 
 
 - private void onOwnReady ( ) { 
 - Log . w ( TAG , " Own keys ready " ) ; 
 - 
 + / / private void onOwnReady ( ) { 
 + / / Log . w ( TAG , " Own keys ready " ) ; 
 + / / 
 + / / if ( theirEphermalKey0 = = null ) { 
 + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + / / @ Override 
 + / / public void onResult ( ResponsePublicKeys response ) { 
 + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + / / Log . w ( TAG , " No ephemeral keys found " ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + / / theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / 
 + / / @ Override 
 + / / public void onError ( RpcException e ) { 
 + / / / / Nothing to do 
 + / / Log . w ( TAG , " Their ephemeral error " ) ; 
 + / / Log . e ( TAG , e ) ; 
 + / / } 
 + / / } ) ; 
 + / / } else { 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / } 
 + / / 
 + / / private void onTheirReady0 ( ) { 
 + / / Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 + / / 
 + / / if ( currentTheirKey = = null ) { 
 + / / request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + / / @ Override 
 + / / public void onResult ( ResponsePublicKeys response ) { 
 + / / if ( response . getPublicKey ( ) . size ( ) = = 0 ) { 
 + / / Log . w ( TAG , " No ephemeral keys found " ) ; 
 + / / return ; 
 + / / } 
 + / / 
 + / / ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 + / / currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 + / / allSet ( ) ; 
 + / / } 
 + / / 
 + / / @ Override 
 + / / public void onError ( RpcException e ) { 
 + / / / / Nothing to do 
 + / / Log . w ( TAG , " Their ephemeral error " ) ; 
 + / / Log . e ( TAG , e ) ; 
 + / / } 
 + / / } ) ; 
 + / / } else { 
 + / / onTheirReady0 ( ) ; 
 + / / } 
 + / / } 
 + / / 
 + / / private void allSet ( ) { 
 + / / Log . d ( TAG , " All keys are ready " ) ; 
 + / / isReady = true ; 
 + / / 
 + / / byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 + / / new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 + / / new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 + / / rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + / / new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 + / / new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 + / / master _ secret ) ; 
 + / / 
 + / / unstashAll ( ) ; 
 + / / } 
 + 
 + private boolean assumeEnabled ( final Runnable onOk ) { 
 if ( theirEphermalKey0 = = null ) { 
 + Log . w ( TAG , " Loading their ephemeral key0 " ) ; 
 request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 @ @ - 105 , 7 + 168 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 theirEphermalKey0 = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 - onTheirReady0 ( ) ; 
 + onOk . run ( ) ; 
 } 
 
 @ Override 
 @ @ - 115 , 15 + 178 , 10 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . e ( TAG , e ) ; 
 } 
 } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 + return false ; 
 } 
 - } 
 - 
 - private void onTheirReady0 ( ) { 
 - Log . w ( TAG , " Their identity ephemeral keys ready " ) ; 
 - 
 if ( currentTheirKey = = null ) { 
 + Log . w ( TAG , " Loading their ephemeral key " ) ; 
 request ( new RequestLoadEphermalPublicKeys ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 @ @ - 134 , 7 + 192 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ApiEncryptionKey encryptionKey = response . getPublicKey ( ) . get ( RandomUtils . randomId ( response . getPublicKey ( ) . size ( ) ) ) ; 
 currentTheirKey = new UserPublicKey ( encryptionKey . getKeyId ( ) , encryptionKey . getKeyAlg ( ) , encryptionKey . getKeyMaterial ( ) ) ; 
 - allSet ( ) ; 
 + onOk . run ( ) ; 
 } 
 
 @ Override 
 @ @ - 144 , 38 + 202 , 58 @ @ public class EncryptedSessionActor extends ModuleActor { 
 Log . e ( TAG , e ) ; 
 } 
 } ) ; 
 - } else { 
 - onTheirReady0 ( ) ; 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 + private void onEncrypt ( final byte [ ] data , final Future future ) { 
 + 
 + if ( ! assumeEnabled ( new Runnable ( ) { 
 + @ Override 
 + public void run ( ) { 
 + onEncrypt ( data , future ) ; 
 + } 
 + } ) ) { 
 + return ; 
 } 
 + 
 + onEncrypt ( data , 
 + ownEphermalKey0 , 
 + currentOwnKey , 
 + theirEphermalKey0 , 
 + currentTheirKey , 
 + future ) ; 
 } 
 
 - private void allSet ( ) { 
 - Log . d ( TAG , " All keys are ready " ) ; 
 - isReady = true ; 
 + private void onEncrypt ( byte [ ] data , 
 + OwnPrivateKey ownEphermalKey0 , 
 + OwnPrivateKey ownEphermalKey , 
 + UserPublicKey theirEphermalKey0 , 
 + UserPublicKey theirEphermalKey , 
 + Future future ) { 
 + 
 + Log . w ( TAG , " Encrypting with : OwnKey0 : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 + Log . w ( TAG , " Encrypting with : TheirKey0 : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 
 byte [ ] master _ secret = RatchetMasterSecret . calculateMasterSecret ( 
 new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 new RatchetPublicKey ( theirIdentityKey . getPublicKey ( ) ) , 
 new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) ) ; 
 - rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 + byte [ ] rootChainKey = RatchetRootChainKey . makeRootChainKey ( 
 new RatchetPrivateKey ( ownEphermalKey0 . getKey ( ) ) , 
 new RatchetPublicKey ( theirEphermalKey0 . getPublicKey ( ) ) , 
 master _ secret ) ; 
 
 - unstashAll ( ) ; 
 - } 
 - 
 - private void onEncrypt ( byte [ ] data , Future future ) { 
 - 
 ActorBoxKey ratchetMessageKey = RatchetMessageKey . buildKey ( rootChainKey , 0 ) ; 
 
 byte [ ] header = ByteStrings . merge ( 
 ByteStrings . intToBytes ( encryptionKeyGroup . getKeyGroupId ( ) ) , 
 ByteStrings . longToBytes ( ownEphermalKey0 . getKeyId ( ) ) , / * Alice Initial Ephermal * / 
 ByteStrings . longToBytes ( theirEphermalKey0 . getKeyId ( ) ) , / * Bob Initial Ephermal * / 
 - Curve25519 . keyGenPublic ( currentOwnKey . getKey ( ) ) , 
 - currentTheirKey . getPublicKey ( ) , 
 + Curve25519 . keyGenPublic ( ownEphermalKey . getKey ( ) ) , 
 + theirEphermalKey . getPublicKey ( ) , 
 ByteStrings . intToBytes ( outIndex + + ) ) ; / * Message Index * / 
 
 byte [ ] encrypted ; 
 @ @ - 187 , 41 + 265 , 22 @ @ public class EncryptedSessionActor extends ModuleActor { 
 return ; 
 } 
 
 - byte [ ] pkg = ByteStrings . merge ( header , encrypted ) ; 
 - 
 - 
 - int keyGroupId = ByteStrings . bytesToInt ( pkg , 0 ) ; 
 - long ownEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 4 ) ; 
 - long theirEphermalKey0Id = ByteStrings . bytesToLong ( pkg , 12 ) ; 
 - byte [ ] ownEphermalKey = ByteStrings . substring ( pkg , 20 , 32 ) ; 
 - byte [ ] theirEphermalKey = ByteStrings . substring ( pkg , 52 , 32 ) ; 
 - int messageIndex = ByteStrings . bytesToInt ( pkg , 84 ) ; 
 - 
 - Log . d ( TAG , " onEncrypt : " + Hex . toHex ( pkg ) ) ; 
 - Log . d ( TAG , " onEncrypt : key group id : " + encryptionKeyGroup . getKeyGroupId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : ownEphermalKey0Id : " + ownEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : theirEphermalKey0Id : " + theirEphermalKey0 . getKeyId ( ) ) ; 
 - Log . d ( TAG , " onEncrypt : messageIndex : " + outIndex ) ; 
 - 
 - 
 - Log . d ( TAG , " onEncrypt : 2key group id : " + keyGroupId ) ; 
 - Log . d ( TAG , " onEncrypt : 2ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 - Log . d ( TAG , " onEncrypt : 2messageIndex : " + messageIndex ) ; 
 - 
 - future . onResult ( new EncryptedPackageRes ( pkg ) ) ; 
 + future . onResult ( new EncryptedPackageRes ( ByteStrings . merge ( header , encrypted ) ) ) ; 
 } 
 
 private void onDecrypt ( final byte [ ] data , final Future future ) { 
 - final int keyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 + Log . d ( TAG , " onDecrypt " ) ; 
 + Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 + 
 + final int ownKeyGroupId = ByteStrings . bytesToInt ( data , 0 ) ; 
 final long ownEphermalKey0Id = ByteStrings . bytesToLong ( data , 4 ) ; 
 final long theirEphermalKey0Id = ByteStrings . bytesToLong ( data , 12 ) ; 
 final byte [ ] ownEphermalKey = ByteStrings . substring ( data , 20 , 32 ) ; 
 final byte [ ] theirEphermalKey = ByteStrings . substring ( data , 52 , 32 ) ; 
 final int messageIndex = ByteStrings . bytesToInt ( data , 84 ) ; 
 
 - Log . d ( TAG , " onDecrypt : " + Hex . toHex ( data ) ) ; 
 - Log . d ( TAG , " onDecrypt : key group id : " + keyGroupId + " , " + data . length ) ; 
 + 
 + Log . d ( TAG , " onDecrypt : key group id : " + ownKeyGroupId + " , " + data . length ) ; 
 Log . d ( TAG , " onDecrypt : ownEphermalKey0Id : " + ownEphermalKey0Id ) ; 
 Log . d ( TAG , " onDecrypt : theirEphermalKey0Id : " + theirEphermalKey0Id ) ; 
 Log . d ( TAG , " onDecrypt : messageIndex : " + messageIndex ) ; 
 @ @ - 247 , 8 + 306 , 7 @ @ public class EncryptedSessionActor extends ModuleActor { 
 
 ArrayList < Long > keys = new ArrayList < Long > ( ) ; 
 keys . add ( ownEphermalKey0Id ) ; 
 - 
 - request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , keyGroupId , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 + request ( new RequestLoadPublicKey ( new ApiUserOutPeer ( uid , getUser ( uid ) . getAccessHash ( ) ) , encryptionKeyGroup . getKeyGroupId ( ) , keys ) , new RpcCallback < ResponsePublicKeys > ( ) { 
 @ Override 
 public void onResult ( ResponsePublicKeys response ) { 
 Log . d ( TAG , " onDecrypt : RequestLoadPublicKey " ) ; 
 @ @ - 295 , 6 + 353 , 8 @ @ public class EncryptedSessionActor extends ModuleActor { 
 int index , 
 Future future ) { 
 
 + Log . d ( TAG , " onDecrypt2 " ) ; 
 + 
 byte [ ] ms = RatchetMasterSecret . calculateMasterSecret ( 
 new RatchetPrivateKey ( ownIdentityKey . getKey ( ) ) , 
 new RatchetPrivateKey ( ownEphemeralPrivateKey0 ) , 
 @ @ - 313 , 16 + 373 , 6 @ @ public class EncryptedSessionActor extends ModuleActor { 
 } 
 
 @ Override 
 - public void onReceive ( Object message ) { 
 - Log . d ( TAG , " msg : " + message ) ; 
 - if ( ! isReady & & message instanceof AskRequest ) { 
 - stash ( ) ; 
 - return ; 
 - } 
 - super . onReceive ( message ) ; 
 - } 
 - 
 - @ Override 
 public boolean onAsk ( Object message , Future future ) { 
 if ( message instanceof EncryptPackage ) { 
 onEncrypt ( ( ( EncryptPackage ) message ) . getData ( ) , future ) ; 
 diff - - git a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 index a24abaa . . 72ceb4c 100644 
 - - - a / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 + + + b / actor - sdk / sdk - core / core / core - shared / src / main / java / im / actor / core / modules / encryption / entity / OwnKeys . java 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 package im . actor . core . modules . encryption . entity ; 
 
 import java . io . IOException ; 
 + import java . util . ArrayList ; 
 import java . util . List ; 
 
 import im . actor . core . modules . encryption . Configuration ; 
 @ @ - 77 , 7 + 78 , 13 @ @ public class OwnKeys extends BserObject { 
 } 
 
 public OwnPrivateKeyUploadable pickRandomEphemeralKey ( ) { 
 - return ephemeralKeys [ RandomUtils . randomId ( ephemeralKeys . length ) ] ; 
 + ArrayList < OwnPrivateKeyUploadable > uploadedKeys = new ArrayList < OwnPrivateKeyUploadable > ( ) ; 
 + for ( OwnPrivateKeyUploadable u : ephemeralKeys ) { 
 + if ( u . isUploaded ( ) ) { 
 + uploadedKeys . add ( u ) ; 
 + } 
 + } 
 + return uploadedKeys . get ( RandomUtils . randomId ( uploadedKeys . size ( ) ) ) ; 
 } 
 
 @ Override
