BLEU SCORE: 0.08812612679876433

TEST MSG: feat ( server : messaging ) : strip bad messages in history
GENERATED MSG: fix ( server ) : remove authId from UserOffice , unify message delivery

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala < nl > index 661dc92 . . db5ebc2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala < nl > @ @ - 1 , 5 + 1 , 6 @ @ < nl > package im . actor . api . rpc < nl > < nl > + import cats . data . Xor < nl > import com . google . protobuf . CodedInputStream < nl > import im . actor . api . rpc . messaging . { ApiMessage , ApiMessageContainer , ApiMessageReaction , ApiMessageState } < nl > import im . actor . server . model . { HistoryMessage , MessageReaction } < nl > @ @ - 8 , 36 + 9 , 33 @ @ import org . joda . time . DateTime < nl > trait HistoryImplicits { < nl > < nl > implicit class ExtHistoryMessageModel ( model : HistoryMessage ) { < nl > - def asStruct ( lastReceivedAt : DateTime , lastReadAt : DateTime , reactions : Seq [ MessageReaction ] ) : ApiMessageContainer = { < nl > + def asStruct ( < nl > + lastReceivedAt : DateTime , < nl > + lastReadAt : DateTime , < nl > + reactions : Seq [ MessageReaction ] < nl > + ) : Xor [ String , ApiMessageContainer ] = { < nl > val in = CodedInputStream . newInstance ( model . messageContentData ) < nl > - try { < nl > - ApiMessage . parseFrom ( in ) match { < nl > - case Right ( messageContent ) ⇒ < nl > - val state = if ( model . userId = = model . senderUserId ) { < nl > - if ( model . date . getMillis < = lastReadAt . getMillis ) { < nl > - Some ( ApiMessageState . Read ) < nl > - } else if ( model . date . getMillis < = lastReceivedAt . getMillis ) { < nl > - Some ( ApiMessageState . Received ) < nl > - } else { < nl > - Some ( ApiMessageState . Sent ) < nl > - } < nl > - } else { < nl > - None / / for incoming < nl > - } < nl > - < nl > - ApiMessageContainer ( < nl > - senderUserId = model . senderUserId , < nl > - randomId = model . randomId , < nl > - date = model . date . getMillis , < nl > - message = messageContent , < nl > - state = state , < nl > - reactions = reactions . toVector map ( r ⇒ ApiMessageReaction ( r . userIds . toVector , r . code ) ) < nl > - ) < nl > - case Left ( e ) ⇒ throw new Exception ( s " Failed to parse message content : $ e " ) < nl > + Xor . fromEither ( ApiMessage . parseFrom ( in ) ) map { messageContent ⇒ < nl > + val state = if ( model . userId = = model . senderUserId ) { < nl > + if ( model . date . getMillis < = lastReadAt . getMillis ) { < nl > + Some ( ApiMessageState . Read ) < nl > + } else if ( model . date . getMillis < = lastReceivedAt . getMillis ) { < nl > + Some ( ApiMessageState . Received ) < nl > + } else { < nl > + Some ( ApiMessageState . Sent ) < nl > + } < nl > + } else { < nl > + None / / for incoming < nl > } < nl > - } catch { < nl > - case e : Throwable ⇒ < nl > - throw e < nl > + < nl > + ApiMessageContainer ( < nl > + senderUserId = model . senderUserId , < nl > + randomId = model . randomId , < nl > + date = model . date . getMillis , < nl > + message = messageContent , < nl > + state = state , < nl > + reactions = reactions . toVector map ( r ⇒ ApiMessageReaction ( r . userIds . toVector , r . code ) ) < nl > + ) < nl > } < nl > } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index bad5d87 . . 2823baa 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 73 , 7 + 73 , 7 @ @ trait HistoryHandlers { < nl > . map ( _ filterNot ( dialogExt . dialogWithSelf ( client . userId , _ ) ) ) < nl > . flatMap { dialogModels ⇒ < nl > for { < nl > - dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) < nl > + dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) map ( _ . flatten ) < nl > ( users , groups ) ← getDialogsUsersGroups ( dialogs ) < nl > } yield { < nl > Ok ( ResponseLoadDialogs ( < nl > @ @ - 139 , 16 + 139 , 19 @ @ trait HistoryHandlers { < nl > . map ( _ . ofUser ( client . userId ) ) < nl > . foldLeft ( Vector . empty [ ApiMessageContainer ] , Set . empty [ Int ] ) { < nl > case ( ( msgs , uids ) , message ) ⇒ < nl > - val messageStruct = message . asStruct ( lastReceivedAt , lastReadAt , reactions . getOrElse ( message . randomId , Vector . empty ) ) < nl > - val newMsgs = msgs : + messageStruct < nl > - < nl > - val newUserIds = relatedUsers ( messageStruct . message ) + + < nl > - ( if ( message . senderUserId ! = client . userId ) < nl > - uids + message . senderUserId < nl > - else < nl > - uids ) < nl > - < nl > - ( newMsgs , newUserIds ) < nl > + message . asStruct ( lastReceivedAt , lastReadAt , reactions . getOrElse ( message . randomId , Vector . empty ) ) . toOption match { < nl > + case Some ( messageStruct ) ⇒ < nl > + val newMsgs = msgs : + messageStruct < nl > + < nl > + val newUserIds = relatedUsers ( messageStruct . message ) + + < nl > + ( if ( message . senderUserId ! = client . userId ) < nl > + uids + message . senderUserId < nl > + else < nl > + uids ) < nl > + < nl > + ( newMsgs , newUserIds ) < nl > + case None ⇒ ( msgs , uids ) < nl > + } < nl > } < nl > userStructs ← DBIO . from ( Future . sequence ( userIds . toVector map ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) ) ) < nl > } yield Ok ( ResponseLoadHistory ( messages , userStructs ) ) < nl > @ @ - 221 , 7 + 224 , 7 @ @ trait HistoryHandlers { < nl > optDatesAction map { _ getOrElse ( ZeroDate → ZeroDate ) } < nl > } < nl > < nl > - private def getDialogStruct ( dialogModel : Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ ApiDialog ] = { < nl > + private def getDialogStruct ( dialogModel : Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ Option [ ApiDialog ] ] = { < nl > withHistoryOwner ( dialogModel . peer , client . userId ) { historyOwner ⇒ < nl > for { < nl > ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( dialogModel . peer ) < nl > @ @ - 231 , 18 + 234 , 18 @ @ trait HistoryHandlers { < nl > } yield { < nl > val emptyMessageContent = ApiTextMessage ( text = " " , mentions = Vector . empty , ext = None ) < nl > val messageModel = messageOpt . getOrElse ( HistoryMessage ( dialogModel . userId , dialogModel . peer , new DateTime ( 0 ) , 0 , 0 , emptyMessageContent . header , emptyMessageContent . toByteArray , None ) ) < nl > - val message = messageModel . asStruct ( lastReceivedAt , lastReadAt , reactions ) < nl > - < nl > - ApiDialog ( < nl > - peer = dialogModel . peer . asStruct , < nl > - unreadCount = unreadCount , < nl > - sortDate = dialogModel . lastMessageDate . getMillis , < nl > - senderUserId = message . senderUserId , < nl > - randomId = message . randomId , < nl > - date = message . date , < nl > - message = message . message , < nl > - state = message . state < nl > - ) < nl > + messageModel . asStruct ( lastReceivedAt , lastReadAt , reactions ) . toOption map { message ⇒ < nl > + ApiDialog ( < nl > + peer = dialogModel . peer . asStruct , < nl > + unreadCount = unreadCount , < nl > + sortDate = dialogModel . lastMessageDate . getMillis , < nl > + senderUserId = message . senderUserId , < nl > + randomId = message . randomId , < nl > + date = message . date , < nl > + message = message . message , < nl > + state = message . state < nl > + ) < nl > + } < nl > } < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / user . proto b / actor - server / actor - peer - managers / src / main / protobuf / user . proto < nl > index 5a1ac21 . . 78a6a8d 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - peer - managers / src / main / protobuf / user . proto < nl > @ @ - 22 , 14 + 22 , 19 @ @ message UserEnvelope { < nl > MessageRead message _ read = 6 ; < nl > NewAuth new _ auth = 7 ; < nl > BroadcastUpdate broadcast _ update = 8 ; < nl > - DeliverGroupMessage deliver _ group _ message = 9 ; < nl > - DeliverOwnGroupMessage deliver _ own _ group _ Message = 10 ; < nl > + DeliverMessage deliver _ message = 9 ; < nl > + DeliverOwnMessage deliver _ own _ message = 10 ; < nl > + RemoveAuth remove _ auth = 11 ; < nl > } < nl > < nl > message NewAuth { < nl > required int64 auth _ id = 1 ; < nl > } < nl > < nl > + message RemoveAuth { < nl > + required int64 auth _ id = 1 ; < nl > + } < nl > + < nl > message NewAuthResponse { } < nl > < nl > message ChangeName { < nl > @ @ - 51 , 8 + 56 , 8 @ @ message UserEnvelope { < nl > required bool is _ fat = 6 ; < nl > } < nl > < nl > - message DeliverGroupMessage { < nl > - required int32 group _ id = 8 ; < nl > + message DeliverMessage { < nl > + required bytes peer = 8 [ ( scalapb . field ) . type = " im . actor . api . rpc . peers . Peer " ] ; < nl > required int32 sender _ user _ id = 1 ; < nl > required int64 random _ id = 3 ; < nl > required int64 date = 4 [ ( scalapb . field ) . type = " org . joda . time . DateTime " ] ; < nl > @ @ - 60 , 8 + 65 , 8 @ @ message UserEnvelope { < nl > required bool is _ fat = 6 ; < nl > } < nl > < nl > - message DeliverOwnGroupMessage { < nl > - required int32 group _ id = 8 ; < nl > + message DeliverOwnMessage { < nl > + required bytes peer = 8 [ ( scalapb . field ) . type = " im . actor . api . rpc . peers . Peer " ] ; < nl > required int64 sender _ auth _ id = 1 ; < nl > required int64 random _ id = 3 ; < nl > required int64 date = 4 [ ( scalapb . field ) . type = " org . joda . time . DateTime " ] ; < nl > @ @ - 110 , 5 + 115 , 9 @ @ message UserEvents { < nl > message AuthAdded { < nl > required int64 auth _ id = 1 ; < nl > } < nl > + < nl > + message AuthRemoved { < nl > + required int64 auth _ id = 1 ; < nl > + } < nl > } < nl > < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > index 0894657 . . 258e7f3 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > @ @ - 428 , 11 + 428 , 11 @ @ class GroupOfficeActor ( < nl > private def sendMessage ( senderUserId : Int , senderAuthId : Long , groupUsersIds : Set [ Int ] , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) : Future [ SeqStateDate ] = { < nl > members . keySet foreach { userId ⇒ < nl > if ( userId ! = senderUserId ) { < nl > - UserOffice . deliverGroupMessage ( userId , groupId , senderUserId , randomId , date , message , isFat ) < nl > + UserOffice . deliverMessage ( userId , groupPeer , senderUserId , randomId , date , message , isFat ) < nl > } < nl > } < nl > < nl > - UserOffice . deliverOwnGroupMessage ( senderUserId , groupId , senderAuthId , randomId , date , message , isFat ) map { < nl > + UserOffice . deliverOwnMessage ( senderUserId , groupPeer , senderAuthId , randomId , date , message , isFat ) map { < nl > case SeqState ( seq , state ) ⇒ SeqStateDate ( seq , state , date . getMillis ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > index 2e7eb97 . . a0fa40b 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . user < nl > < nl > + import im . actor . api . rpc . peers . Peer < nl > + < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > import akka . actor . _ < nl > @ @ - 26 , 6 + 28 , 14 @ @ object UserOffice { < nl > < nl > ) : Future [ Unit ] = ( userOfficeRegion . ref ? UserEnvelope ( userId ) . withNewAuth ( NewAuth ( authId ) ) ) map ( _ ⇒ ( ) ) < nl > < nl > + def removeAuth ( userId : Int , authId : Long ) ( < nl > + implicit < nl > + userOfficeRegion : UserOfficeRegion , < nl > + timeout : Timeout , < nl > + ec : ExecutionContext < nl > + < nl > + ) : Future [ Unit ] = ( userOfficeRegion . ref ? UserEnvelope ( userId ) . withRemoveAuth ( RemoveAuth ( authId ) ) ) map ( _ ⇒ ( ) ) < nl > + < nl > def sendMessage ( userId : Int , senderUserId : Int , senderAuthId : Long , accessHash : Long , randomId : Long , message : ApiMessage ) ( < nl > implicit < nl > peerManagerRegion : UserOfficeRegion , < nl > @ @ - 35 , 21 + 45 , 21 @ @ object UserOffice { < nl > ( peerManagerRegion . ref ? UserEnvelope ( userId ) . withSendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message ) ) ) . mapTo [ SeqStateDate ] < nl > } < nl > < nl > - def deliverGroupMessage ( userId : Int , groupId : Int , senderUserId : Int , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( < nl > + def deliverMessage ( userId : Int , peer : Peer , senderUserId : Int , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( < nl > implicit < nl > region : UserOfficeRegion , < nl > timeout : Timeout , < nl > ec : ExecutionContext < nl > ) : Unit = < nl > - region . ref ! UserEnvelope ( userId ) . withDeliverGroupMessage ( DeliverGroupMessage ( groupId , senderUserId , randomId , date , message , isFat ) ) < nl > + region . ref ! UserEnvelope ( userId ) . withDeliverMessage ( DeliverMessage ( peer , senderUserId , randomId , date , message , isFat ) ) < nl > < nl > - def deliverOwnGroupMessage ( userId : Int , groupId : Int , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( < nl > + def deliverOwnMessage ( userId : Int , peer : Peer , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( < nl > implicit < nl > region : UserOfficeRegion , < nl > timeout : Timeout , < nl > ec : ExecutionContext < nl > ) : Future [ SeqState ] = < nl > - ( region . ref ? UserEnvelope ( userId ) . withDeliverOwnGroupMessage ( DeliverOwnGroupMessage ( groupId , senderAuthId , randomId , date , message , isFat ) ) ) . mapTo [ SeqState ] < nl > + ( region . ref ? UserEnvelope ( userId ) . withDeliverOwnMessage ( DeliverOwnMessage ( peer , senderAuthId , randomId , date , message , isFat ) ) ) . mapTo [ SeqState ] < nl > < nl > def messageReceived ( userId : Int , receiverUserId : Int , receiverAuthId : Long , date : Long , receivedDate : Long ) ( implicit peerManagerRegion : UserOfficeRegion ) : Unit = { < nl > peerManagerRegion . ref ! UserEnvelope ( userId ) . withMessageReceived ( MessageReceived ( receiverUserId , receiverAuthId , date , receivedDate ) ) < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > index ef9b68f . . ad7b551 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > @ @ - 1 , 15 + 1 , 9 @ @ < nl > package im . actor . server . user < nl > < nl > - import scala . concurrent . ExecutionContext < nl > - import scala . util . { Failure , Success } < nl > - < nl > import akka . actor . { ActorLogging , Props , Status } < nl > import akka . pattern . pipe < nl > import akka . persistence . RecoveryFailure < nl > - import com . google . protobuf . ByteString < nl > - import org . joda . time . DateTime < nl > - import slick . driver . PostgresDriver . api . _ < nl > - < nl > + import akka . util . Timeout < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { Peer , PeerType } < nl > import im . actor . server . commons . serialization . ActorSerializer < nl > @ @ - 21 , 6 + 15 , 12 @ @ import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . social . { SocialManager , SocialManagerRegion } < nl > import im . actor . server . util . { HistoryUtils , UserUtils } < nl > + import org . joda . time . DateTime < nl > + import slick . driver . PostgresDriver . api . _ < nl > + < nl > + import scala . concurrent . { Future , ExecutionContext } < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . { Failure , Success } < nl > < nl > object UserOfficeActor { < nl > ActorSerializer . register ( 3000 , classOf [ UserEnvelope ] ) < nl > @ @ - 30 , 8 + 30 , 10 @ @ object UserOfficeActor { < nl > ActorSerializer . register ( 3004 , classOf [ UserEnvelope . MessageReceived ] ) < nl > ActorSerializer . register ( 3005 , classOf [ UserEnvelope . BroadcastUpdate ] ) < nl > ActorSerializer . register ( 3006 , classOf [ UserEnvelope . BroadcastUpdateResponse ] ) < nl > + ActorSerializer . register ( 3007 , classOf [ UserEnvelope . RemoveAuth ] ) < nl > < nl > ActorSerializer . register ( 4001 , classOf [ UserEvents . AuthAdded ] ) < nl > + ActorSerializer . register ( 4002 , classOf [ UserEvents . AuthRemoved ] ) < nl > < nl > def props ( < nl > implicit < nl > @ @ - 56 , 6 + 58 , 9 @ @ class UserOfficeActor ( < nl > import UserOffice . _ < nl > import UserUtils . _ < nl > < nl > + implicit val region : UserOfficeRegion = UserOfficeRegion ( context . parent ) < nl > + implicit private val timeout : Timeout = Timeout ( 10 . seconds ) < nl > + < nl > implicit private val ec : ExecutionContext = context . dispatcher < nl > < nl > private val userId = self . path . name . toInt < nl > @ @ - 72 , 21 + 77 , 29 @ @ class UserOfficeActor ( < nl > authIds + = authId < nl > sender ( ) ! Status . Success ( ( ) ) < nl > } < nl > - case Payload . DeliverGroupMessage ( DeliverGroupMessage ( groupId , senderUserId , randomId , date , message , isFat ) ) ⇒ < nl > + case Payload . RemoveAuth ( RemoveAuth ( authId ) ) ⇒ < nl > + persist ( UserEvents . AuthRemoved ( authId ) ) { _ ⇒ < nl > + authIds - = authId < nl > + sender ( ) ! Status . Success ( ( ) ) < nl > + } < nl > + case Payload . DeliverMessage ( DeliverMessage ( peer , senderUserId , randomId , date , message , isFat ) ) ⇒ < nl > val update = UpdateMessage ( < nl > - peer = Peer ( PeerType . Group , groupId ) , < nl > + peer = peer , < nl > senderUserId = senderUserId , < nl > date = date . getMillis , < nl > randomId = randomId , < nl > message = message < nl > ) < nl > - < nl > - persistAndPushUpdates ( authIds , update , None , isFat ) < nl > - case Payload . DeliverOwnGroupMessage ( DeliverOwnGroupMessage ( groupId , senderAuthId , randomId , date , message , isFat ) ) ⇒ < nl > - val groupPeer = Peer ( PeerType . Group , groupId ) < nl > - < nl > + db . run { < nl > + for { < nl > + senderUser ← getUserUnsafe ( senderUserId ) < nl > + pushText ← getPushText ( message , senderUser , userId ) < nl > + seqs ← persistAndPushUpdates ( authIds , update , Some ( pushText ) , isFat ) < nl > + } yield seqs < nl > + } < nl > + case Payload . DeliverOwnMessage ( DeliverOwnMessage ( peer , senderAuthId , randomId , date , message , isFat ) ) ⇒ < nl > val update = UpdateMessage ( < nl > - peer = groupPeer , < nl > + peer = peer , < nl > senderUserId = userId , < nl > date = date . getMillis , < nl > randomId = randomId , < nl > @ @ - 95 , 62 + 108 , 27 @ @ class UserOfficeActor ( < nl > < nl > persistAndPushUpdates ( authIds filterNot ( _ = = senderAuthId ) , update , None , isFat ) < nl > < nl > - val ownUpdate = UpdateMessageSent ( groupPeer , randomId , date . getMillis ) < nl > + val ownUpdate = UpdateMessageSent ( peer , randomId , date . getMillis ) < nl > db . run ( persistAndPushUpdate ( senderAuthId , ownUpdate , None , isFat ) ) pipeTo sender ( ) < nl > - / * < nl > - db . run { < nl > - for { < nl > - pushText < - getPushText ( message , userId , senderUserId ) < nl > - } yield { < nl > - persistAndPushUpdates ( authIds , update , pushText , isFat ) < nl > - } < nl > - } * / < nl > - case Payload . SendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message , _ ) ) ⇒ < nl > + case Payload . SendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message , isFat ) ) ⇒ < nl > + val replyTo = sender ( ) < nl > context become { < nl > case MessageSentComplete ⇒ < nl > unstashAll ( ) < nl > context become receiveCommand < nl > case msg ⇒ stash ( ) < nl > } < nl > - < nl > val date = new DateTime < nl > val dateMillis = date . getMillis < nl > < nl > - val replyTo = sender ( ) < nl > - < nl > - val peerUpdate = UpdateMessage ( < nl > - peer = privatePeerStruct ( senderUserId ) , < nl > - senderUserId = senderUserId , < nl > - date = dateMillis , < nl > - randomId = randomId , < nl > - message = message < nl > - ) < nl > - < nl > - val senderUpdate = UpdateMessage ( < nl > - peer = privatePeerStruct ( userId ) , < nl > - senderUserId = senderUserId , < nl > - date = dateMillis , < nl > - randomId = randomId , < nl > - message = message < nl > - ) < nl > - < nl > - val clientUpdate = UpdateMessageSent ( privatePeerStruct ( userId ) , randomId , dateMillis ) < nl > - < nl > - val sendFuture = db . run ( for { < nl > - < nl > - clientUser ← getUserUnsafe ( senderUserId ) < nl > - pushText ← getPushText ( message , clientUser , userId ) < nl > - < nl > - _ ← broadcastUserUpdate ( userId , peerUpdate , Some ( pushText ) ) < nl > - < nl > - _ ← notifyUserUpdate ( senderUserId , senderAuthId , senderUpdate , None ) < nl > - SeqState ( seq , state ) ← persistAndPushUpdate ( senderAuthId , clientUpdate , None ) < nl > + val sendFuture = for { < nl > + _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) < nl > + SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) < nl > + _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) < nl > } yield { < nl > - recordRelation ( senderUserId , userId ) < nl > db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) < nl > SeqStateDate ( seq , state , dateMillis ) < nl > - } ) < nl > - < nl > + } < nl > sendFuture onComplete { < nl > case Success ( seqstate ) ⇒ < nl > replyTo ! seqstate < nl > @ @ - 166 , 7 + 144 , 7 @ @ class UserOfficeActor ( < nl > val update = UpdateMessageReceived ( Peer ( PeerType . Private , receiverUserId ) , date , receivedDate ) < nl > < nl > db . run ( for { < nl > - _ ← broadcastUserUpdate ( userId , update , None ) < nl > + _ ← persistAndPushUpdates ( authIds , update , None ) < nl > } yield { < nl > / / TODO : report errors < nl > db . run ( markMessagesReceived ( models . Peer . privat ( receiverUserId ) , models . Peer . privat ( userId ) , new DateTime ( date ) ) ) < nl > @ @ - 182 , 8 + 160 , 8 @ @ class UserOfficeActor ( < nl > val readerUpdate = UpdateMessageReadByMe ( Peer ( PeerType . Private , userId ) , date ) < nl > < nl > db . run ( for { < nl > - _ ← broadcastUserUpdate ( userId , update , None ) < nl > - _ ← broadcastUserUpdate ( readerUserId , readerUpdate , None ) < nl > + _ ← persistAndPushUpdates ( authIds , update , None ) < nl > + _ ← broadcastUserUpdate ( readerUserId , readerUpdate , None ) / / todo : may be replace with MessageReadOwn < nl > } yield { < nl > / / TODO : report errors < nl > db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . privat ( userId ) , new DateTime ( date ) ) ) < nl > @ @ - 197 , 6 + 175 , 8 @ @ class UserOfficeActor ( < nl > override def receiveRecover = { < nl > case UserEvents . AuthAdded ( authId ) ⇒ < nl > authIds + = authId < nl > + case UserEvents . AuthRemoved ( authId ) ⇒ < nl > + authIds - = authId < nl > case RecoveryFailure ( e ) ⇒ < nl > log . error ( e , " Failed to recover " ) < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > index 9c9823a . . f5b36ce 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala < nl > @ @ - 179 , 6 + 179 , 7 @ @ trait AuthHelpers extends Helpers { < nl > system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) < nl > < nl > for { < nl > + _ ← DBIO . from ( UserOffice . removeAuth ( session . userId , session . authId ) ) < nl > _ ← persist . AuthSession . delete ( session . userId , session . id ) < nl > _ ← persist . AuthId . delete ( session . authId ) < nl > _ = deletePushCredentials ( session . authId )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala 
 index 661dc92 . . db5ebc2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / HistoryImplicits . scala 
 @ @ - 1 , 5 + 1 , 6 @ @ 
 package im . actor . api . rpc 
 
 + import cats . data . Xor 
 import com . google . protobuf . CodedInputStream 
 import im . actor . api . rpc . messaging . { ApiMessage , ApiMessageContainer , ApiMessageReaction , ApiMessageState } 
 import im . actor . server . model . { HistoryMessage , MessageReaction } 
 @ @ - 8 , 36 + 9 , 33 @ @ import org . joda . time . DateTime 
 trait HistoryImplicits { 
 
 implicit class ExtHistoryMessageModel ( model : HistoryMessage ) { 
 - def asStruct ( lastReceivedAt : DateTime , lastReadAt : DateTime , reactions : Seq [ MessageReaction ] ) : ApiMessageContainer = { 
 + def asStruct ( 
 + lastReceivedAt : DateTime , 
 + lastReadAt : DateTime , 
 + reactions : Seq [ MessageReaction ] 
 + ) : Xor [ String , ApiMessageContainer ] = { 
 val in = CodedInputStream . newInstance ( model . messageContentData ) 
 - try { 
 - ApiMessage . parseFrom ( in ) match { 
 - case Right ( messageContent ) ⇒ 
 - val state = if ( model . userId = = model . senderUserId ) { 
 - if ( model . date . getMillis < = lastReadAt . getMillis ) { 
 - Some ( ApiMessageState . Read ) 
 - } else if ( model . date . getMillis < = lastReceivedAt . getMillis ) { 
 - Some ( ApiMessageState . Received ) 
 - } else { 
 - Some ( ApiMessageState . Sent ) 
 - } 
 - } else { 
 - None / / for incoming 
 - } 
 - 
 - ApiMessageContainer ( 
 - senderUserId = model . senderUserId , 
 - randomId = model . randomId , 
 - date = model . date . getMillis , 
 - message = messageContent , 
 - state = state , 
 - reactions = reactions . toVector map ( r ⇒ ApiMessageReaction ( r . userIds . toVector , r . code ) ) 
 - ) 
 - case Left ( e ) ⇒ throw new Exception ( s " Failed to parse message content : $ e " ) 
 + Xor . fromEither ( ApiMessage . parseFrom ( in ) ) map { messageContent ⇒ 
 + val state = if ( model . userId = = model . senderUserId ) { 
 + if ( model . date . getMillis < = lastReadAt . getMillis ) { 
 + Some ( ApiMessageState . Read ) 
 + } else if ( model . date . getMillis < = lastReceivedAt . getMillis ) { 
 + Some ( ApiMessageState . Received ) 
 + } else { 
 + Some ( ApiMessageState . Sent ) 
 + } 
 + } else { 
 + None / / for incoming 
 } 
 - } catch { 
 - case e : Throwable ⇒ 
 - throw e 
 + 
 + ApiMessageContainer ( 
 + senderUserId = model . senderUserId , 
 + randomId = model . randomId , 
 + date = model . date . getMillis , 
 + message = messageContent , 
 + state = state , 
 + reactions = reactions . toVector map ( r ⇒ ApiMessageReaction ( r . userIds . toVector , r . code ) ) 
 + ) 
 } 
 } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index bad5d87 . . 2823baa 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 73 , 7 + 73 , 7 @ @ trait HistoryHandlers { 
 . map ( _ filterNot ( dialogExt . dialogWithSelf ( client . userId , _ ) ) ) 
 . flatMap { dialogModels ⇒ 
 for { 
 - dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) 
 + dialogs ← DBIO . sequence ( dialogModels map getDialogStruct ) map ( _ . flatten ) 
 ( users , groups ) ← getDialogsUsersGroups ( dialogs ) 
 } yield { 
 Ok ( ResponseLoadDialogs ( 
 @ @ - 139 , 16 + 139 , 19 @ @ trait HistoryHandlers { 
 . map ( _ . ofUser ( client . userId ) ) 
 . foldLeft ( Vector . empty [ ApiMessageContainer ] , Set . empty [ Int ] ) { 
 case ( ( msgs , uids ) , message ) ⇒ 
 - val messageStruct = message . asStruct ( lastReceivedAt , lastReadAt , reactions . getOrElse ( message . randomId , Vector . empty ) ) 
 - val newMsgs = msgs : + messageStruct 
 - 
 - val newUserIds = relatedUsers ( messageStruct . message ) + + 
 - ( if ( message . senderUserId ! = client . userId ) 
 - uids + message . senderUserId 
 - else 
 - uids ) 
 - 
 - ( newMsgs , newUserIds ) 
 + message . asStruct ( lastReceivedAt , lastReadAt , reactions . getOrElse ( message . randomId , Vector . empty ) ) . toOption match { 
 + case Some ( messageStruct ) ⇒ 
 + val newMsgs = msgs : + messageStruct 
 + 
 + val newUserIds = relatedUsers ( messageStruct . message ) + + 
 + ( if ( message . senderUserId ! = client . userId ) 
 + uids + message . senderUserId 
 + else 
 + uids ) 
 + 
 + ( newMsgs , newUserIds ) 
 + case None ⇒ ( msgs , uids ) 
 + } 
 } 
 userStructs ← DBIO . from ( Future . sequence ( userIds . toVector map ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) ) ) 
 } yield Ok ( ResponseLoadHistory ( messages , userStructs ) ) 
 @ @ - 221 , 7 + 224 , 7 @ @ trait HistoryHandlers { 
 optDatesAction map { _ getOrElse ( ZeroDate → ZeroDate ) } 
 } 
 
 - private def getDialogStruct ( dialogModel : Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ ApiDialog ] = { 
 + private def getDialogStruct ( dialogModel : Dialog ) ( implicit client : AuthorizedClientData ) : dbio . DBIO [ Option [ ApiDialog ] ] = { 
 withHistoryOwner ( dialogModel . peer , client . userId ) { historyOwner ⇒ 
 for { 
 ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( dialogModel . peer ) 
 @ @ - 231 , 18 + 234 , 18 @ @ trait HistoryHandlers { 
 } yield { 
 val emptyMessageContent = ApiTextMessage ( text = " " , mentions = Vector . empty , ext = None ) 
 val messageModel = messageOpt . getOrElse ( HistoryMessage ( dialogModel . userId , dialogModel . peer , new DateTime ( 0 ) , 0 , 0 , emptyMessageContent . header , emptyMessageContent . toByteArray , None ) ) 
 - val message = messageModel . asStruct ( lastReceivedAt , lastReadAt , reactions ) 
 - 
 - ApiDialog ( 
 - peer = dialogModel . peer . asStruct , 
 - unreadCount = unreadCount , 
 - sortDate = dialogModel . lastMessageDate . getMillis , 
 - senderUserId = message . senderUserId , 
 - randomId = message . randomId , 
 - date = message . date , 
 - message = message . message , 
 - state = message . state 
 - ) 
 + messageModel . asStruct ( lastReceivedAt , lastReadAt , reactions ) . toOption map { message ⇒ 
 + ApiDialog ( 
 + peer = dialogModel . peer . asStruct , 
 + unreadCount = unreadCount , 
 + sortDate = dialogModel . lastMessageDate . getMillis , 
 + senderUserId = message . senderUserId , 
 + randomId = message . randomId , 
 + date = message . date , 
 + message = message . message , 
 + state = message . state 
 + ) 
 + } 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - peer - managers / src / main / protobuf / user . proto b / actor - server / actor - peer - managers / src / main / protobuf / user . proto 
 index 5a1ac21 . . 78a6a8d 100644 
 - - - a / actor - server / actor - peer - managers / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - peer - managers / src / main / protobuf / user . proto 
 @ @ - 22 , 14 + 22 , 19 @ @ message UserEnvelope { 
 MessageRead message _ read = 6 ; 
 NewAuth new _ auth = 7 ; 
 BroadcastUpdate broadcast _ update = 8 ; 
 - DeliverGroupMessage deliver _ group _ message = 9 ; 
 - DeliverOwnGroupMessage deliver _ own _ group _ Message = 10 ; 
 + DeliverMessage deliver _ message = 9 ; 
 + DeliverOwnMessage deliver _ own _ message = 10 ; 
 + RemoveAuth remove _ auth = 11 ; 
 } 
 
 message NewAuth { 
 required int64 auth _ id = 1 ; 
 } 
 
 + message RemoveAuth { 
 + required int64 auth _ id = 1 ; 
 + } 
 + 
 message NewAuthResponse { } 
 
 message ChangeName { 
 @ @ - 51 , 8 + 56 , 8 @ @ message UserEnvelope { 
 required bool is _ fat = 6 ; 
 } 
 
 - message DeliverGroupMessage { 
 - required int32 group _ id = 8 ; 
 + message DeliverMessage { 
 + required bytes peer = 8 [ ( scalapb . field ) . type = " im . actor . api . rpc . peers . Peer " ] ; 
 required int32 sender _ user _ id = 1 ; 
 required int64 random _ id = 3 ; 
 required int64 date = 4 [ ( scalapb . field ) . type = " org . joda . time . DateTime " ] ; 
 @ @ - 60 , 8 + 65 , 8 @ @ message UserEnvelope { 
 required bool is _ fat = 6 ; 
 } 
 
 - message DeliverOwnGroupMessage { 
 - required int32 group _ id = 8 ; 
 + message DeliverOwnMessage { 
 + required bytes peer = 8 [ ( scalapb . field ) . type = " im . actor . api . rpc . peers . Peer " ] ; 
 required int64 sender _ auth _ id = 1 ; 
 required int64 random _ id = 3 ; 
 required int64 date = 4 [ ( scalapb . field ) . type = " org . joda . time . DateTime " ] ; 
 @ @ - 110 , 5 + 115 , 9 @ @ message UserEvents { 
 message AuthAdded { 
 required int64 auth _ id = 1 ; 
 } 
 + 
 + message AuthRemoved { 
 + required int64 auth _ id = 1 ; 
 + } 
 } 
 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 index 0894657 . . 258e7f3 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 @ @ - 428 , 11 + 428 , 11 @ @ class GroupOfficeActor ( 
 private def sendMessage ( senderUserId : Int , senderAuthId : Long , groupUsersIds : Set [ Int ] , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) : Future [ SeqStateDate ] = { 
 members . keySet foreach { userId ⇒ 
 if ( userId ! = senderUserId ) { 
 - UserOffice . deliverGroupMessage ( userId , groupId , senderUserId , randomId , date , message , isFat ) 
 + UserOffice . deliverMessage ( userId , groupPeer , senderUserId , randomId , date , message , isFat ) 
 } 
 } 
 
 - UserOffice . deliverOwnGroupMessage ( senderUserId , groupId , senderAuthId , randomId , date , message , isFat ) map { 
 + UserOffice . deliverOwnMessage ( senderUserId , groupPeer , senderAuthId , randomId , date , message , isFat ) map { 
 case SeqState ( seq , state ) ⇒ SeqStateDate ( seq , state , date . getMillis ) 
 } 
 } 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 index 2e7eb97 . . a0fa40b 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . user 
 
 + import im . actor . api . rpc . peers . Peer 
 + 
 import scala . concurrent . { ExecutionContext , Future } 
 
 import akka . actor . _ 
 @ @ - 26 , 6 + 28 , 14 @ @ object UserOffice { 
 
 ) : Future [ Unit ] = ( userOfficeRegion . ref ? UserEnvelope ( userId ) . withNewAuth ( NewAuth ( authId ) ) ) map ( _ ⇒ ( ) ) 
 
 + def removeAuth ( userId : Int , authId : Long ) ( 
 + implicit 
 + userOfficeRegion : UserOfficeRegion , 
 + timeout : Timeout , 
 + ec : ExecutionContext 
 + 
 + ) : Future [ Unit ] = ( userOfficeRegion . ref ? UserEnvelope ( userId ) . withRemoveAuth ( RemoveAuth ( authId ) ) ) map ( _ ⇒ ( ) ) 
 + 
 def sendMessage ( userId : Int , senderUserId : Int , senderAuthId : Long , accessHash : Long , randomId : Long , message : ApiMessage ) ( 
 implicit 
 peerManagerRegion : UserOfficeRegion , 
 @ @ - 35 , 21 + 45 , 21 @ @ object UserOffice { 
 ( peerManagerRegion . ref ? UserEnvelope ( userId ) . withSendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message ) ) ) . mapTo [ SeqStateDate ] 
 } 
 
 - def deliverGroupMessage ( userId : Int , groupId : Int , senderUserId : Int , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( 
 + def deliverMessage ( userId : Int , peer : Peer , senderUserId : Int , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( 
 implicit 
 region : UserOfficeRegion , 
 timeout : Timeout , 
 ec : ExecutionContext 
 ) : Unit = 
 - region . ref ! UserEnvelope ( userId ) . withDeliverGroupMessage ( DeliverGroupMessage ( groupId , senderUserId , randomId , date , message , isFat ) ) 
 + region . ref ! UserEnvelope ( userId ) . withDeliverMessage ( DeliverMessage ( peer , senderUserId , randomId , date , message , isFat ) ) 
 
 - def deliverOwnGroupMessage ( userId : Int , groupId : Int , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( 
 + def deliverOwnMessage ( userId : Int , peer : Peer , senderAuthId : Long , randomId : Long , date : DateTime , message : ApiMessage , isFat : Boolean ) ( 
 implicit 
 region : UserOfficeRegion , 
 timeout : Timeout , 
 ec : ExecutionContext 
 ) : Future [ SeqState ] = 
 - ( region . ref ? UserEnvelope ( userId ) . withDeliverOwnGroupMessage ( DeliverOwnGroupMessage ( groupId , senderAuthId , randomId , date , message , isFat ) ) ) . mapTo [ SeqState ] 
 + ( region . ref ? UserEnvelope ( userId ) . withDeliverOwnMessage ( DeliverOwnMessage ( peer , senderAuthId , randomId , date , message , isFat ) ) ) . mapTo [ SeqState ] 
 
 def messageReceived ( userId : Int , receiverUserId : Int , receiverAuthId : Long , date : Long , receivedDate : Long ) ( implicit peerManagerRegion : UserOfficeRegion ) : Unit = { 
 peerManagerRegion . ref ! UserEnvelope ( userId ) . withMessageReceived ( MessageReceived ( receiverUserId , receiverAuthId , date , receivedDate ) ) 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 index ef9b68f . . ad7b551 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 @ @ - 1 , 15 + 1 , 9 @ @ 
 package im . actor . server . user 
 
 - import scala . concurrent . ExecutionContext 
 - import scala . util . { Failure , Success } 
 - 
 import akka . actor . { ActorLogging , Props , Status } 
 import akka . pattern . pipe 
 import akka . persistence . RecoveryFailure 
 - import com . google . protobuf . ByteString 
 - import org . joda . time . DateTime 
 - import slick . driver . PostgresDriver . api . _ 
 - 
 + import akka . util . Timeout 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { Peer , PeerType } 
 import im . actor . server . commons . serialization . ActorSerializer 
 @ @ - 21 , 6 + 15 , 12 @ @ import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . social . { SocialManager , SocialManagerRegion } 
 import im . actor . server . util . { HistoryUtils , UserUtils } 
 + import org . joda . time . DateTime 
 + import slick . driver . PostgresDriver . api . _ 
 + 
 + import scala . concurrent . { Future , ExecutionContext } 
 + import scala . concurrent . duration . _ 
 + import scala . util . { Failure , Success } 
 
 object UserOfficeActor { 
 ActorSerializer . register ( 3000 , classOf [ UserEnvelope ] ) 
 @ @ - 30 , 8 + 30 , 10 @ @ object UserOfficeActor { 
 ActorSerializer . register ( 3004 , classOf [ UserEnvelope . MessageReceived ] ) 
 ActorSerializer . register ( 3005 , classOf [ UserEnvelope . BroadcastUpdate ] ) 
 ActorSerializer . register ( 3006 , classOf [ UserEnvelope . BroadcastUpdateResponse ] ) 
 + ActorSerializer . register ( 3007 , classOf [ UserEnvelope . RemoveAuth ] ) 
 
 ActorSerializer . register ( 4001 , classOf [ UserEvents . AuthAdded ] ) 
 + ActorSerializer . register ( 4002 , classOf [ UserEvents . AuthRemoved ] ) 
 
 def props ( 
 implicit 
 @ @ - 56 , 6 + 58 , 9 @ @ class UserOfficeActor ( 
 import UserOffice . _ 
 import UserUtils . _ 
 
 + implicit val region : UserOfficeRegion = UserOfficeRegion ( context . parent ) 
 + implicit private val timeout : Timeout = Timeout ( 10 . seconds ) 
 + 
 implicit private val ec : ExecutionContext = context . dispatcher 
 
 private val userId = self . path . name . toInt 
 @ @ - 72 , 21 + 77 , 29 @ @ class UserOfficeActor ( 
 authIds + = authId 
 sender ( ) ! Status . Success ( ( ) ) 
 } 
 - case Payload . DeliverGroupMessage ( DeliverGroupMessage ( groupId , senderUserId , randomId , date , message , isFat ) ) ⇒ 
 + case Payload . RemoveAuth ( RemoveAuth ( authId ) ) ⇒ 
 + persist ( UserEvents . AuthRemoved ( authId ) ) { _ ⇒ 
 + authIds - = authId 
 + sender ( ) ! Status . Success ( ( ) ) 
 + } 
 + case Payload . DeliverMessage ( DeliverMessage ( peer , senderUserId , randomId , date , message , isFat ) ) ⇒ 
 val update = UpdateMessage ( 
 - peer = Peer ( PeerType . Group , groupId ) , 
 + peer = peer , 
 senderUserId = senderUserId , 
 date = date . getMillis , 
 randomId = randomId , 
 message = message 
 ) 
 - 
 - persistAndPushUpdates ( authIds , update , None , isFat ) 
 - case Payload . DeliverOwnGroupMessage ( DeliverOwnGroupMessage ( groupId , senderAuthId , randomId , date , message , isFat ) ) ⇒ 
 - val groupPeer = Peer ( PeerType . Group , groupId ) 
 - 
 + db . run { 
 + for { 
 + senderUser ← getUserUnsafe ( senderUserId ) 
 + pushText ← getPushText ( message , senderUser , userId ) 
 + seqs ← persistAndPushUpdates ( authIds , update , Some ( pushText ) , isFat ) 
 + } yield seqs 
 + } 
 + case Payload . DeliverOwnMessage ( DeliverOwnMessage ( peer , senderAuthId , randomId , date , message , isFat ) ) ⇒ 
 val update = UpdateMessage ( 
 - peer = groupPeer , 
 + peer = peer , 
 senderUserId = userId , 
 date = date . getMillis , 
 randomId = randomId , 
 @ @ - 95 , 62 + 108 , 27 @ @ class UserOfficeActor ( 
 
 persistAndPushUpdates ( authIds filterNot ( _ = = senderAuthId ) , update , None , isFat ) 
 
 - val ownUpdate = UpdateMessageSent ( groupPeer , randomId , date . getMillis ) 
 + val ownUpdate = UpdateMessageSent ( peer , randomId , date . getMillis ) 
 db . run ( persistAndPushUpdate ( senderAuthId , ownUpdate , None , isFat ) ) pipeTo sender ( ) 
 - / * 
 - db . run { 
 - for { 
 - pushText < - getPushText ( message , userId , senderUserId ) 
 - } yield { 
 - persistAndPushUpdates ( authIds , update , pushText , isFat ) 
 - } 
 - } * / 
 - case Payload . SendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message , _ ) ) ⇒ 
 + case Payload . SendMessage ( SendMessage ( senderUserId , senderAuthId , accessHash , randomId , message , isFat ) ) ⇒ 
 + val replyTo = sender ( ) 
 context become { 
 case MessageSentComplete ⇒ 
 unstashAll ( ) 
 context become receiveCommand 
 case msg ⇒ stash ( ) 
 } 
 - 
 val date = new DateTime 
 val dateMillis = date . getMillis 
 
 - val replyTo = sender ( ) 
 - 
 - val peerUpdate = UpdateMessage ( 
 - peer = privatePeerStruct ( senderUserId ) , 
 - senderUserId = senderUserId , 
 - date = dateMillis , 
 - randomId = randomId , 
 - message = message 
 - ) 
 - 
 - val senderUpdate = UpdateMessage ( 
 - peer = privatePeerStruct ( userId ) , 
 - senderUserId = senderUserId , 
 - date = dateMillis , 
 - randomId = randomId , 
 - message = message 
 - ) 
 - 
 - val clientUpdate = UpdateMessageSent ( privatePeerStruct ( userId ) , randomId , dateMillis ) 
 - 
 - val sendFuture = db . run ( for { 
 - 
 - clientUser ← getUserUnsafe ( senderUserId ) 
 - pushText ← getPushText ( message , clientUser , userId ) 
 - 
 - _ ← broadcastUserUpdate ( userId , peerUpdate , Some ( pushText ) ) 
 - 
 - _ ← notifyUserUpdate ( senderUserId , senderAuthId , senderUpdate , None ) 
 - SeqState ( seq , state ) ← persistAndPushUpdate ( senderAuthId , clientUpdate , None ) 
 + val sendFuture = for { 
 + _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) 
 + SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) 
 + _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) 
 } yield { 
 - recordRelation ( senderUserId , userId ) 
 db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) 
 SeqStateDate ( seq , state , dateMillis ) 
 - } ) 
 - 
 + } 
 sendFuture onComplete { 
 case Success ( seqstate ) ⇒ 
 replyTo ! seqstate 
 @ @ - 166 , 7 + 144 , 7 @ @ class UserOfficeActor ( 
 val update = UpdateMessageReceived ( Peer ( PeerType . Private , receiverUserId ) , date , receivedDate ) 
 
 db . run ( for { 
 - _ ← broadcastUserUpdate ( userId , update , None ) 
 + _ ← persistAndPushUpdates ( authIds , update , None ) 
 } yield { 
 / / TODO : report errors 
 db . run ( markMessagesReceived ( models . Peer . privat ( receiverUserId ) , models . Peer . privat ( userId ) , new DateTime ( date ) ) ) 
 @ @ - 182 , 8 + 160 , 8 @ @ class UserOfficeActor ( 
 val readerUpdate = UpdateMessageReadByMe ( Peer ( PeerType . Private , userId ) , date ) 
 
 db . run ( for { 
 - _ ← broadcastUserUpdate ( userId , update , None ) 
 - _ ← broadcastUserUpdate ( readerUserId , readerUpdate , None ) 
 + _ ← persistAndPushUpdates ( authIds , update , None ) 
 + _ ← broadcastUserUpdate ( readerUserId , readerUpdate , None ) / / todo : may be replace with MessageReadOwn 
 } yield { 
 / / TODO : report errors 
 db . run ( markMessagesRead ( models . Peer . privat ( readerUserId ) , models . Peer . privat ( userId ) , new DateTime ( date ) ) ) 
 @ @ - 197 , 6 + 175 , 8 @ @ class UserOfficeActor ( 
 override def receiveRecover = { 
 case UserEvents . AuthAdded ( authId ) ⇒ 
 authIds + = authId 
 + case UserEvents . AuthRemoved ( authId ) ⇒ 
 + authIds - = authId 
 case RecoveryFailure ( e ) ⇒ 
 log . error ( e , " Failed to recover " ) 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 index 9c9823a . . f5b36ce 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthHelpers . scala 
 @ @ - 179 , 6 + 179 , 7 @ @ trait AuthHelpers extends Helpers { 
 system . log . debug ( s " Terminating AuthSession $ { session . id } of user $ { session . userId } and authId $ { session . authId } " ) 
 
 for { 
 + _ ← DBIO . from ( UserOffice . removeAuth ( session . userId , session . authId ) ) 
 _ ← persist . AuthSession . delete ( session . userId , session . id ) 
 _ ← persist . AuthId . delete ( session . authId ) 
 _ = deletePushCredentials ( session . authId )
