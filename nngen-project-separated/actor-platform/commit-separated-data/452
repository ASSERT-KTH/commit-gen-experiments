BLEU SCORE: 0.07791497608591347

TEST MSG: fix ( server : messaging ) : fixed dialog groups order
GENERATED MSG: feat ( server ) : ResumableProjection ; store message header in NewMessage , fixed GroupsServiceSpec

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index bb01b2d . . 271797d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 202 , 7 + 202 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > < nl > - private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( SortableDialog ( Instant . MIN , peer ) ) ) < nl > + private def isFavourited ( peer : Peer ) : Boolean = state . active . favourites . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > < nl > private def dialogShown ( peer : Peer ) : Boolean = state . activePeers . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > < nl > @ @ - 224 , 14 + 224 , 19 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > } < nl > < nl > protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { < nl > - val infosFutures = < nl > - state . active map { < nl > - case ( group , sortableDialogs ) ⇒ < nl > - FutureExt . ftraverse ( sortableDialogs . toSeq ) ( sd ⇒ getInfo ( sd . peer ) ) < nl > - . map ( infos ⇒ DialogGroup ( group , infos . map ( _ . getInfo ) ) ) < nl > - } < nl > - < nl > - Future . sequence ( infosFutures ) map ( _ . toSeq ) < nl > + for { < nl > + favInfos ← Future . sequence ( state . active . favourites map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > + groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > + dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > + } yield { < nl > + val base = List ( < nl > + DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , < nl > + DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) < nl > + ) < nl > + < nl > + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base < nl > + else base < nl > + } < nl > } < nl > < nl > private def sendChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > index c43a8bb . . 9a7b2ea 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . persistence . SnapshotMetadata < nl > import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } < nl > - import im . actor . server . model . { Peer , PeerType } < nl > + import im . actor . server . model . { Peer , PeerErrors , PeerType } < nl > < nl > import scala . collection . SortedSet < nl > < nl > @ @ - 38 , 19 + 38 , 62 @ @ private object SortableDialog { < nl > < nl > private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > < nl > + private object ActiveDialogs { < nl > + val empty = ActiveDialogs ( < nl > + SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + SortedSet . empty ( SortableDialog . OrderingAsc ) < nl > + ) < nl > + } < nl > + < nl > + private [ dialog ] case class ActiveDialogs ( < nl > + favourites : SortedSet [ SortableDialog ] , < nl > + groups : SortedSet [ SortableDialog ] , < nl > + dms : SortedSet [ SortableDialog ] < nl > + ) { < nl > + def withPeer ( sd : SortableDialog ) = { < nl > + sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms + sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups + sd ) < nl > + case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) < nl > + } < nl > + } < nl > + < nl > + def withoutPeer ( sd : SortableDialog ) = { < nl > + sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites - sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites - sd ) < nl > + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > + } < nl > + } < nl > + < nl > + def withFavouritedPeer ( sd : SortableDialog ) = { < nl > + sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites + sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites + sd ) < nl > + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > + } < nl > + } < nl > + < nl > + def withUnfavouritedPeer ( sd : SortableDialog ) = { < nl > + sd . peer . typ match { < nl > + case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites - sd ) < nl > + case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites - sd ) < nl > + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) < nl > + } < nl > + } < nl > + } < nl > + < nl > private object DialogRootState { < nl > val initial = DialogRootState ( < nl > - active = Map ( < nl > - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) < nl > - ) , < nl > + active = ActiveDialogs . empty , < nl > activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > archived = SortedSet . empty ( SortableDialog . OrderingDesc ) < nl > ) < nl > } < nl > < nl > private [ dialog ] final case class DialogRootState ( < nl > - active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , < nl > + active : ActiveDialogs , < nl > activePeers : SortedSet [ SortableDialog ] , < nl > archived : SortedSet [ SortableDialog ] < nl > ) extends ProcessorState [ DialogRootState ] { < nl > @ @ - 82 , 16 + 125 , 27 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > } < nl > < nl > - override lazy val snapshot : Any = DialogRootStateSnapshot ( < nl > - dialogGroups = active . toSeq map { < nl > - case ( typ , sortableDialogs ) ⇒ < nl > - DialogGroup ( < nl > - typ , < nl > - sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > - ) < nl > - } , < nl > - archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } < nl > - ) < nl > + override lazy val snapshot : Any = { < nl > + val favourites = DialogGroup ( < nl > + DialogGroupType . Favourites , < nl > + active . favourites . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > + ) < nl > + < nl > + val groups = DialogGroup ( < nl > + DialogGroupType . Groups , < nl > + active . groups . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > + ) < nl > + < nl > + val dms = DialogGroup ( < nl > + DialogGroupType . DirectMessages , < nl > + active . dms . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > + ) < nl > + < nl > + DialogRootStateSnapshot ( < nl > + dialogGroups = Seq ( favourites , groups , dms ) , < nl > + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } < nl > + ) < nl > + } < nl > < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > @ @ - 100 , 7 + 154 , 7 @ @ private [ dialog ] final case class DialogRootState ( < nl > else < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > - active = this . active + dialogGroup ( sortableDialog ) , < nl > + active = this . active . withPeer ( sortableDialog ) , < nl > archived = this . archived - sortableDialog < nl > ) < nl > } < nl > @ @ - 112 , 7 + 166 , 7 @ @ private [ dialog ] final case class DialogRootState ( < nl > else < nl > copy ( < nl > activePeers = this . activePeers - sortableDialog , < nl > - active = this . active mapValues ( _ - sortableDialog ) , < nl > + active = this . active . withoutPeer ( sortableDialog ) , < nl > archived = this . archived + sortableDialog < nl > ) < nl > } < nl > @ @ - 124 , 7 + 178 , 7 @ @ private [ dialog ] final case class DialogRootState ( < nl > else < nl > copy ( < nl > activePeers = this . activePeers + sortableDialog , < nl > - active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > + active = this . active . withFavouritedPeer ( sortableDialog ) , < nl > archived = this . archived - sortableDialog < nl > ) < nl > } < nl > @ @ - 133 , 36 + 187 , 21 @ @ private [ dialog ] final case class DialogRootState ( < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > copy ( < nl > - active = < nl > - ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > - case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false < nl > - case _ ⇒ true < nl > - } < nl > + active = this . active . withUnfavouritedPeer ( sortableDialog ) < nl > ) < nl > } < nl > < nl > private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { < nl > - val activeBase = < nl > - if ( this . active . contains ( group ) ) this . active < nl > - else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) < nl > + val newActive = group match { < nl > + case DialogGroupType . Favourites ⇒ active . copy ( favourites = active . favourites + + sortableDialogs ) < nl > + case DialogGroupType . Groups ⇒ active . copy ( groups = active . groups + + sortableDialogs ) < nl > + case DialogGroupType . DirectMessages ⇒ active . copy ( dms = active . dms + + sortableDialogs ) < nl > + case unknown ⇒ throw DialogErrors . UnknownDialogGroupType ( unknown ) < nl > + } < nl > < nl > copy ( < nl > - active = activeBase map { < nl > - case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) < nl > - case other ⇒ other < nl > - } , < nl > + active = newActive , < nl > activePeers = this . activePeers + + sortableDialogs < nl > ) < nl > } < nl > - < nl > - private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { < nl > - val group = ( isFavourite , sortableDialog . peer . typ ) match { < nl > - case ( true , _ ) ⇒ DialogGroupType . Favourites < nl > - case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages < nl > - case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups < nl > - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > - } < nl > - < nl > - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) < nl > - } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala < nl > index 413ee7e . . 2ee3dbc 100644 < nl > - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala < nl > @ @ - 1 , 5 + 1 , 9 @ @ < nl > package im . actor . server . model < nl > < nl > + object PeerErrors { < nl > + final case class UnknownPeerType ( typ : PeerType ) extends IllegalArgumentException ( s " Unknown peer type : $ typ " ) < nl > + } < nl > + < nl > trait PeerBase { < nl > val ` type ` : PeerType < nl > < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > index c8ee715 . . 74af68c 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala < nl > @ @ - 103 , 7 + 103 , 7 @ @ object HistoryMessageRepo { < nl > < nl > private val metaAfterC = Compiled { ( userId : Rep [ Int ] , peerType : Rep [ Int ] , peerId : Rep [ Int ] , date : Rep [ DateTime ] , limit : ConstColumn [ Long ] ) ⇒ < nl > byUserIdPeer ( userId , peerType , peerId ) < nl > - . filter ( _ . date > = date ) < nl > + . filter ( _ . date > date ) < nl > . sortBy ( _ . date . asc ) < nl > . take ( limit ) < nl > . map ( hm ⇒ ( hm . randomId , hm . date , hm . senderUserId , hm . messageContentHeader ) ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index e7c67fa . . 855a3b5 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 1 , 7 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadArchived , ResponseLoadGroupedDialogs } < nl > + import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > @ @ - 56 , 6 + 56 , 11 @ @ final class GroupedDialogsSpec < nl > case Ok ( ResponseLoadGroupedDialogs ( dgroups , users , groups , _ , _ ) ) ⇒ < nl > dgroups . length shouldBe 2 < nl > < nl > + dgroups . map ( _ . key ) should be ( Seq ( < nl > + DialogExtension . groupKey ( DialogGroupType . Groups ) , < nl > + DialogExtension . groupKey ( DialogGroupType . DirectMessages ) < nl > + ) ) < nl > + < nl > val ( gs , ps ) = dgroups . foldLeft ( IndexedSeq . empty [ ApiDialogShort ] , IndexedSeq . empty [ ApiDialogShort ] ) { < nl > case ( ( gs , ps ) , dg ) ⇒ < nl > dg . key match { < nl > @ @ - 236 , 6 + 241 , 11 @ @ final class GroupedDialogsSpec < nl > < nl > prepareDialogs ( bob ) < nl > whenReady ( service . handleFavouriteDialog ( bobPeer ) ) ( identity ) < nl > + < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs . map ( _ . key ) . head should be ( DialogExtension . groupKey ( DialogGroupType . Favourites ) ) < nl > + } < nl > + < nl > inside ( getDialogGroups ( DialogGroupType . Favourites ) ) { < nl > case Vector ( d ) ⇒ d . peer . id should equal ( bob . id ) < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > index ce70d26 . . 717ebba 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala < nl > @ @ - 9 , 7 + 9 , 6 @ @ import im . actor . server . cqrs . ProcessorStateProbe < nl > import im . actor . server . model . Peer < nl > < nl > final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > - it should " have DMs and Groups by default " in default < nl > it should " sort dialogs by appearing " in show < nl > it should " remove Favourites on Unfavourite " in favouriteUnfavourite < nl > it should " remove from Archived on Favourite or new message " in removeFromArchived < nl > @ @ - 17 , 11 + 16 , 6 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > < nl > import DialogRootEvents . _ < nl > < nl > - def default ( ) = { < nl > - val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > - probe . state . active . keys should be ( Set ( DialogGroupType . Groups , DialogGroupType . DirectMessages ) ) < nl > - } < nl > - < nl > def show ( ) = { < nl > implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) < nl > < nl > @ @ - 47 , 7 + 41 , 6 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > < nl > probe . commit ( Unfavourited ( Instant . now , Some ( alice ) ) ) < nl > < nl > - probe . state . active . keys shouldNot contain ( DialogGroupType . Favourites ) < nl > getGroupPeers ( DialogGroupType . DirectMessages ) should contain ( alice ) < nl > checkSnapshot < nl > } < nl > @ @ - 90 , 7 + 83 , 12 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { < nl > } < nl > < nl > private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > - probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer ) < nl > + typ match { < nl > + case DialogGroupType . Favourites ⇒ probe . state . active . favourites . toSeq . map ( _ . peer ) < nl > + case DialogGroupType . Groups ⇒ probe . state . active . groups . toSeq . map ( _ . peer ) < nl > + case DialogGroupType . DirectMessages ⇒ probe . state . active . dms . toSeq . map ( _ . peer ) < nl > + case unknown ⇒ throw DialogErrors . UnknownDialogGroupType ( unknown ) < nl > + } < nl > < nl > private def getActivePeers ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = < nl > probe . state . activePeers . toSeq . map ( _ . peer )
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > new file mode 100644 < nl > index 0000000 . . 6c559c3 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto < nl > @ @ - 0 , 0 + 1 , 20 @ @ < nl > + syntax = " proto3 " ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + import " scalapb / scalapb . proto " ; < nl > + < nl > + message ResumableProjectionEvents { < nl > + message OffsetWritten { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; < nl > + < nl > + int64 offset = 1 ; < nl > + } < nl > + } < nl > + < nl > + message ResumableProjectionState { < nl > + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; < nl > + < nl > + int64 offset = 1 ; < nl > + int32 hits = 2 ; < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 01c3afc . . b816596 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { < nl > int64 random _ id = 2 ; < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 sender _ user _ id = 3 ; < nl > + int32 message _ header = 4 ; < nl > } < nl > < nl > message MessagesReceived { < nl > @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { < nl > int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > int32 reader _ user _ id = 8 ; < nl > } < nl > + < nl > + message CounterReset { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 9f2b4eb . . b27c32b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException < nl > < nl > import akka . actor . ActorLogging < nl > import akka . pattern . pipe < nl > - import akka . persistence . { PersistentActor , RecoveryCompleted } < nl > + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } < nl > import im . actor . concurrent . AlertingActor < nl > < nl > import scala . concurrent . Future < nl > @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace < nl > < nl > trait ProcessorState [ S , E ] { < nl > def updated ( e : E ) : S < nl > + < nl > + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S < nl > } < nl > < nl > abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace < nl > @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist < nl > override final def receiveRecover = { < nl > case e : E ⇒ < nl > _ state = _ state . updated ( e ) < nl > + case SnapshotOffer ( metadata , snapshot ) ⇒ < nl > + _ state = _ state . withSnapshot ( metadata , snapshot ) < nl > case RecoveryCompleted ⇒ onRecoveryCompleted ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > new file mode 100644 < nl > index 0000000 . . ada9106 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala < nl > @ @ - 0 , 0 + 1 , 89 @ @ < nl > + package im . actor . server . cqrs < nl > + < nl > + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } < nl > + import akka . pattern . ask < nl > + import akka . http . scaladsl . util . FastFuture < nl > + import akka . persistence . SnapshotMetadata < nl > + import akka . util . Timeout < nl > + import im . actor . config . ActorConfig < nl > + import im . actor . serialization . ActorSerializer < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object ResumableProjection { < nl > + ActorSerializer . register ( < nl > + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , < nl > + 110002 → classOf [ ResumableProjectionState ] < nl > + ) < nl > + < nl > + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) < nl > + < nl > + private [ cqrs ] val maxHits = 20 < nl > + } < nl > + < nl > + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { < nl > + this : ResumableProjectionState ⇒ < nl > + < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def updated ( e : Event ) : ResumableProjectionState = e match { < nl > + case ow : OffsetWritten ⇒ < nl > + copy ( offset = ow . offset , hits = hits + 1 ) < nl > + } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { < nl > + case s : ResumableProjectionState ⇒ s < nl > + } < nl > + } < nl > + < nl > + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { < nl > + import factory . dispatcher < nl > + < nl > + private case class SaveOffset ( offset : Long ) < nl > + private object SaveOffsetAck < nl > + < nl > + private object GetOffset < nl > + private case class GetOffsetResponse ( offset : Long ) < nl > + < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private var isStopped = false < nl > + < nl > + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { < nl > + import ResumableProjectionEvents . _ < nl > + < nl > + override def persistenceId : String = s " RProj _ $ id " < nl > + < nl > + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) < nl > + < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) < nl > + } < nl > + < nl > + override protected def handleCommand : Receive = { < nl > + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > + if ( state . hits > 10 ) { < nl > + saveSnapshot ( state ) < nl > + setState ( state . copy ( hits = 0 ) ) < nl > + } < nl > + < nl > + sender ( ) ! SaveOffsetAck < nl > + } < nl > + } < nl > + } ) ) < nl > + < nl > + private def actor : ActorRef = < nl > + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) < nl > + else _ actor < nl > + < nl > + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) < nl > + < nl > + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def stop ( ) : Unit = { < nl > + actor ! PoisonPill < nl > + isStopped = true < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index e02e96e . . b8044bf 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > becomeStashing ( replyTo ⇒ ( { < nl > case seq : SeqStateDate ⇒ < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > replyTo ! seq < nl > unstashAll ( ) < nl > @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > throw new RuntimeException ( " No message date found in SendMessage " ) < nl > } < nl > < nl > - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ < nl > commit ( e ) < nl > < nl > if ( peer . typ = = PeerType . Private ) { < nl > @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > } else { < nl > - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ < nl > + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ < nl > commit ( e ) < nl > db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index ae2bb79 . . 9fdac80 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog < nl > import java . time . Instant < nl > < nl > import akka . actor . _ < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > import DialogEvents . _ < nl > < nl > override def updated ( e : DialogEvent ) : DialogState = e match { < nl > - case NewMessage ( randomId , date , senderUserId ) ⇒ < nl > + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ < nl > if ( senderUserId ! = userId ) { < nl > this . copy ( < nl > counter = counter + 1 , < nl > @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( < nl > case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ < nl > this . copy ( lastReadDate = date ) < nl > case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) < nl > + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this < nl > } < nl > < nl > object DialogProcessor { < nl > @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { < nl > ActorSerializer . register ( < nl > 40010 → classOf [ DialogEvents . MessagesRead ] , < nl > 40011 → classOf [ DialogEvents . MessagesReceived ] , < nl > - 40012 → classOf [ DialogEvents . NewMessage ] < nl > + 40012 → classOf [ DialogEvents . NewMessage ] , < nl > + 40013 → classOf [ DialogEvents . CounterReset ] < nl > ) < nl > } < nl > < nl > @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > protected implicit val system : ActorSystem = context . system < nl > < nl > + protected implicit val timeout = Timeout ( 5 . seconds ) < nl > + < nl > protected val db : Database = DbExtension ( system ) . db < nl > protected val userExt = UserExtension ( system ) < nl > protected val groupExt = GroupExtension ( system ) < nl > protected implicit val socialRegion = SocialExtension ( system ) . region < nl > - protected implicit val timeout = Timeout ( 5 . seconds ) < nl > - < nl > protected val dialogExt = DialogExtension ( system ) < nl > protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) < nl > protected val seqUpdExt = SeqUpdatesExtension ( context . system ) < nl > @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case GetCounter ( _ ) ⇒ < nl > - Future . successful ( GetCounterResponse ( state . counter ) ) < nl > - case GetInfo ( _ ) ⇒ Future . successful ( < nl > + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) < nl > + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ < nl > GetInfoResponse ( Some ( DialogInfo ( < nl > peer = Some ( peer ) , < nl > - counter = state . counter , < nl > + counter = counter , < nl > date = state . lastMessageDate , < nl > lastMessageDate = state . lastMessageDate , < nl > lastReceivedDate = state . lastReceiveDate , < nl > lastReadDate = state . lastReadDate < nl > ) ) ) < nl > - ) < nl > + } < nl > } < nl > < nl > override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > def reactions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) < nl > } < nl > < nl > / / when receiving this messages , dialog is required to take an action < nl > def actions ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * @ return does dialog owner accepts this command < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) < nl > + < nl > + private def getCounter ( ) : Future [ Int ] = { < nl > + groupExt . isMember ( peer . id , userId ) map { < nl > + case true ⇒ state . counter < nl > + case false ⇒ 0 < nl > + } < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index cf67226 . . 1a5a772 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRef , Props , Status } < nl > import akka . pattern . { ask , pipe } < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( < nl > case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) < nl > } < nl > < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this < nl > + < nl > private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index 9ed906a . . 10f3bc3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { < nl > def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = < nl > ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) < nl > < nl > + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = < nl > + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) < nl > + < nl > def getAccessHash ( groupId : Int ) : Future [ Long ] = < nl > ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > index c9ce341 . . 23fda9a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala < nl > @ @ - 1 , 8 + 1 , 9 @ @ < nl > package im . actor . server . group < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } < nl > + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } < nl > + import akka . persistence . SnapshotMetadata < nl > import im . actor . server . cqrs . ProcessorState < nl > - import im . actor . server . dialog . { DialogExtension , DialogCommands } < nl > + import im . actor . server . dialog . { DialogCommands , DialogExtension } < nl > < nl > import scala . concurrent . ExecutionContext < nl > < nl > @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( < nl > case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) < nl > case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this < nl > } < nl > < nl > private [ group ] sealed trait GroupPeerEvent < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > index 2de0cd1 . . 29b1a4b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRefFactory , Props } < nl > import akka . pattern . ask < nl > + import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import im . actor . api . rpc . users . UpdateUserLocalNameChanged < nl > import im . actor . server . cqrs . { Processor , ProcessorState } < nl > @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em < nl > this . copy ( localNames = localNames + ( contactUserId → localName ) ) < nl > } < nl > } < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this < nl > } < nl > < nl > private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > index 416b7cf . . 9e75b2c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala < nl > @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec < nl > < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount > 6 shouldEqual true < nl > + dialog . unreadCount should be > 6 < nl > } < nl > < nl > whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ < nl > @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec < nl > } < nl > val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) < nl > < nl > + { < nl > + implicit val clientData = clientData2 < nl > + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > + val dialog = resp . toOption . get . dialogs . head < nl > + dialog . unreadCount shouldBe 2 < nl > + } < nl > + } < nl > + < nl > for ( _ ← 1 to 6 ) { < nl > implicit val clientData = clientData1 < nl > whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } < nl > @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec < nl > implicit val clientData = clientData2 < nl > whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > val dialog = resp . toOption . get . dialogs . head < nl > - dialog . unreadCount shouldBe 6 < nl > + dialog . unreadCount shouldBe 8 < nl > } < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index bb01b2d . . 271797d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 202 , 7 + 202 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 
 - private def isFavourited ( peer : Peer ) : Boolean = state . active . get ( DialogGroupType . Favourites ) . exists ( _ . contains ( SortableDialog ( Instant . MIN , peer ) ) ) 
 + private def isFavourited ( peer : Peer ) : Boolean = state . active . favourites . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 
 private def dialogShown ( peer : Peer ) : Boolean = state . activePeers . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 
 @ @ - 224 , 14 + 224 , 19 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 } 
 
 protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { 
 - val infosFutures = 
 - state . active map { 
 - case ( group , sortableDialogs ) ⇒ 
 - FutureExt . ftraverse ( sortableDialogs . toSeq ) ( sd ⇒ getInfo ( sd . peer ) ) 
 - . map ( infos ⇒ DialogGroup ( group , infos . map ( _ . getInfo ) ) ) 
 - } 
 - 
 - Future . sequence ( infosFutures ) map ( _ . toSeq ) 
 + for { 
 + favInfos ← Future . sequence ( state . active . favourites map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 + groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 + dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 + } yield { 
 + val base = List ( 
 + DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , 
 + DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) 
 + ) 
 + 
 + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base 
 + else base 
 + } 
 } 
 
 private def sendChatGroupsChanged ( ignoreAuthSid : Option [ Int ] = None ) : Future [ SeqState ] = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 index c43a8bb . . 9a7b2ea 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . persistence . SnapshotMetadata 
 import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } 
 - import im . actor . server . model . { Peer , PeerType } 
 + import im . actor . server . model . { Peer , PeerErrors , PeerType } 
 
 import scala . collection . SortedSet 
 
 @ @ - 38 , 19 + 38 , 62 @ @ private object SortableDialog { 
 
 private case class SortableDialog ( ts : Instant , peer : Peer ) 
 
 + private object ActiveDialogs { 
 + val empty = ActiveDialogs ( 
 + SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + SortedSet . empty ( SortableDialog . OrderingAsc ) 
 + ) 
 + } 
 + 
 + private [ dialog ] case class ActiveDialogs ( 
 + favourites : SortedSet [ SortableDialog ] , 
 + groups : SortedSet [ SortableDialog ] , 
 + dms : SortedSet [ SortableDialog ] 
 + ) { 
 + def withPeer ( sd : SortableDialog ) = { 
 + sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms + sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups + sd ) 
 + case unknown ⇒ throw new PeerErrors . UnknownPeerType ( unknown ) 
 + } 
 + } 
 + 
 + def withoutPeer ( sd : SortableDialog ) = { 
 + sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites - sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites - sd ) 
 + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 + } 
 + } 
 + 
 + def withFavouritedPeer ( sd : SortableDialog ) = { 
 + sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms - sd , favourites = favourites + sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups - sd , favourites = favourites + sd ) 
 + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 + } 
 + } 
 + 
 + def withUnfavouritedPeer ( sd : SortableDialog ) = { 
 + sd . peer . typ match { 
 + case PeerType . Private ⇒ copy ( dms = dms + sd , favourites = favourites - sd ) 
 + case PeerType . Group ⇒ copy ( groups = groups + sd , favourites = favourites - sd ) 
 + case unknown ⇒ throw PeerErrors . UnknownPeerType ( unknown ) 
 + } 
 + } 
 + } 
 + 
 private object DialogRootState { 
 val initial = DialogRootState ( 
 - active = Map ( 
 - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) 
 - ) , 
 + active = ActiveDialogs . empty , 
 activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 archived = SortedSet . empty ( SortableDialog . OrderingDesc ) 
 ) 
 } 
 
 private [ dialog ] final case class DialogRootState ( 
 - active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , 
 + active : ActiveDialogs , 
 activePeers : SortedSet [ SortableDialog ] , 
 archived : SortedSet [ SortableDialog ] 
 ) extends ProcessorState [ DialogRootState ] { 
 @ @ - 82 , 16 + 125 , 27 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 } 
 
 - override lazy val snapshot : Any = DialogRootStateSnapshot ( 
 - dialogGroups = active . toSeq map { 
 - case ( typ , sortableDialogs ) ⇒ 
 - DialogGroup ( 
 - typ , 
 - sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 - ) 
 - } , 
 - archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } 
 - ) 
 + override lazy val snapshot : Any = { 
 + val favourites = DialogGroup ( 
 + DialogGroupType . Favourites , 
 + active . favourites . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 + ) 
 + 
 + val groups = DialogGroup ( 
 + DialogGroupType . Groups , 
 + active . groups . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 + ) 
 + 
 + val dms = DialogGroup ( 
 + DialogGroupType . DirectMessages , 
 + active . dms . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 + ) 
 + 
 + DialogRootStateSnapshot ( 
 + dialogGroups = Seq ( favourites , groups , dms ) , 
 + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } 
 + ) 
 + } 
 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 @ @ - 100 , 7 + 154 , 7 @ @ private [ dialog ] final case class DialogRootState ( 
 else 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 - active = this . active + dialogGroup ( sortableDialog ) , 
 + active = this . active . withPeer ( sortableDialog ) , 
 archived = this . archived - sortableDialog 
 ) 
 } 
 @ @ - 112 , 7 + 166 , 7 @ @ private [ dialog ] final case class DialogRootState ( 
 else 
 copy ( 
 activePeers = this . activePeers - sortableDialog , 
 - active = this . active mapValues ( _ - sortableDialog ) , 
 + active = this . active . withoutPeer ( sortableDialog ) , 
 archived = this . archived + sortableDialog 
 ) 
 } 
 @ @ - 124 , 7 + 178 , 7 @ @ private [ dialog ] final case class DialogRootState ( 
 else 
 copy ( 
 activePeers = this . activePeers + sortableDialog , 
 - active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 + active = this . active . withFavouritedPeer ( sortableDialog ) , 
 archived = this . archived - sortableDialog 
 ) 
 } 
 @ @ - 133 , 36 + 187 , 21 @ @ private [ dialog ] final case class DialogRootState ( 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 copy ( 
 - active = 
 - ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 - case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false 
 - case _ ⇒ true 
 - } 
 + active = this . active . withUnfavouritedPeer ( sortableDialog ) 
 ) 
 } 
 
 private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { 
 - val activeBase = 
 - if ( this . active . contains ( group ) ) this . active 
 - else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) 
 + val newActive = group match { 
 + case DialogGroupType . Favourites ⇒ active . copy ( favourites = active . favourites + + sortableDialogs ) 
 + case DialogGroupType . Groups ⇒ active . copy ( groups = active . groups + + sortableDialogs ) 
 + case DialogGroupType . DirectMessages ⇒ active . copy ( dms = active . dms + + sortableDialogs ) 
 + case unknown ⇒ throw DialogErrors . UnknownDialogGroupType ( unknown ) 
 + } 
 
 copy ( 
 - active = activeBase map { 
 - case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) 
 - case other ⇒ other 
 - } , 
 + active = newActive , 
 activePeers = this . activePeers + + sortableDialogs 
 ) 
 } 
 - 
 - private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { 
 - val group = ( isFavourite , sortableDialog . peer . typ ) match { 
 - case ( true , _ ) ⇒ DialogGroupType . Favourites 
 - case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages 
 - case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups 
 - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 - } 
 - 
 - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) 
 - } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala 
 index 413ee7e . . 2ee3dbc 100644 
 - - - a / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / PeerBase . scala 
 @ @ - 1 , 5 + 1 , 9 @ @ 
 package im . actor . server . model 
 
 + object PeerErrors { 
 + final case class UnknownPeerType ( typ : PeerType ) extends IllegalArgumentException ( s " Unknown peer type : $ typ " ) 
 + } 
 + 
 trait PeerBase { 
 val ` type ` : PeerType 
 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 index c8ee715 . . 74af68c 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / HistoryMessageRepo . scala 
 @ @ - 103 , 7 + 103 , 7 @ @ object HistoryMessageRepo { 
 
 private val metaAfterC = Compiled { ( userId : Rep [ Int ] , peerType : Rep [ Int ] , peerId : Rep [ Int ] , date : Rep [ DateTime ] , limit : ConstColumn [ Long ] ) ⇒ 
 byUserIdPeer ( userId , peerType , peerId ) 
 - . filter ( _ . date > = date ) 
 + . filter ( _ . date > date ) 
 . sortBy ( _ . date . asc ) 
 . take ( limit ) 
 . map ( hm ⇒ ( hm . randomId , hm . date , hm . senderUserId , hm . messageContentHeader ) ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index e7c67fa . . 855a3b5 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . messaging . { ApiDialogShort , ApiTextMessage , ResponseLoadArchived , ResponseLoadGroupedDialogs } 
 + import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeer , ApiPeerType } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 @ @ - 56 , 6 + 56 , 11 @ @ final class GroupedDialogsSpec 
 case Ok ( ResponseLoadGroupedDialogs ( dgroups , users , groups , _ , _ ) ) ⇒ 
 dgroups . length shouldBe 2 
 
 + dgroups . map ( _ . key ) should be ( Seq ( 
 + DialogExtension . groupKey ( DialogGroupType . Groups ) , 
 + DialogExtension . groupKey ( DialogGroupType . DirectMessages ) 
 + ) ) 
 + 
 val ( gs , ps ) = dgroups . foldLeft ( IndexedSeq . empty [ ApiDialogShort ] , IndexedSeq . empty [ ApiDialogShort ] ) { 
 case ( ( gs , ps ) , dg ) ⇒ 
 dg . key match { 
 @ @ - 236 , 6 + 241 , 11 @ @ final class GroupedDialogsSpec 
 
 prepareDialogs ( bob ) 
 whenReady ( service . handleFavouriteDialog ( bobPeer ) ) ( identity ) 
 + 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs . map ( _ . key ) . head should be ( DialogExtension . groupKey ( DialogGroupType . Favourites ) ) 
 + } 
 + 
 inside ( getDialogGroups ( DialogGroupType . Favourites ) ) { 
 case Vector ( d ) ⇒ d . peer . id should equal ( bob . id ) 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 index ce70d26 . . 717ebba 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogRootStateSpec . scala 
 @ @ - 9 , 7 + 9 , 6 @ @ import im . actor . server . cqrs . ProcessorStateProbe 
 import im . actor . server . model . Peer 
 
 final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 - it should " have DMs and Groups by default " in default 
 it should " sort dialogs by appearing " in show 
 it should " remove Favourites on Unfavourite " in favouriteUnfavourite 
 it should " remove from Archived on Favourite or new message " in removeFromArchived 
 @ @ - 17 , 11 + 16 , 6 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 
 import DialogRootEvents . _ 
 
 - def default ( ) = { 
 - val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 - probe . state . active . keys should be ( Set ( DialogGroupType . Groups , DialogGroupType . DirectMessages ) ) 
 - } 
 - 
 def show ( ) = { 
 implicit val probe = ProcessorStateProbe ( DialogRootState . initial ) 
 
 @ @ - 47 , 7 + 41 , 6 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 
 probe . commit ( Unfavourited ( Instant . now , Some ( alice ) ) ) 
 
 - probe . state . active . keys shouldNot contain ( DialogGroupType . Favourites ) 
 getGroupPeers ( DialogGroupType . DirectMessages ) should contain ( alice ) 
 checkSnapshot 
 } 
 @ @ - 90 , 7 + 83 , 12 @ @ final class DialogRootStateSpec extends ActorSuite with PeersImplicits { 
 } 
 
 private def getGroupPeers ( typ : DialogGroupType ) ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 - probe . state . active . get ( typ ) . get . toSeq . map ( _ . peer ) 
 + typ match { 
 + case DialogGroupType . Favourites ⇒ probe . state . active . favourites . toSeq . map ( _ . peer ) 
 + case DialogGroupType . Groups ⇒ probe . state . active . groups . toSeq . map ( _ . peer ) 
 + case DialogGroupType . DirectMessages ⇒ probe . state . active . dms . toSeq . map ( _ . peer ) 
 + case unknown ⇒ throw DialogErrors . UnknownDialogGroupType ( unknown ) 
 + } 
 
 private def getActivePeers ( implicit probe : ProcessorStateProbe [ DialogRootState ] ) = 
 probe . state . activePeers . toSeq . map ( _ . peer )

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / cqrs . proto b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 new file mode 100644 
 index 0000000 . . 6c559c3 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / protobuf / cqrs . proto 
 @ @ - 0 , 0 + 1 , 20 @ @ 
 + syntax = " proto3 " ; 
 + 
 + package im . actor . server ; 
 + 
 + import " scalapb / scalapb . proto " ; 
 + 
 + message ResumableProjectionEvents { 
 + message OffsetWritten { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . Event " ; 
 + 
 + int64 offset = 1 ; 
 + } 
 + } 
 + 
 + message ResumableProjectionState { 
 + option ( scalapb . message ) . extends = " im . actor . server . cqrs . ResumableProjectionStateBase " ; 
 + 
 + int64 offset = 1 ; 
 + int32 hits = 2 ; 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 01c3afc . . b816596 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 295 , 6 + 295 , 7 @ @ message DialogEvents { 
 int64 random _ id = 2 ; 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 sender _ user _ id = 3 ; 
 + int32 message _ header = 4 ; 
 } 
 
 message MessagesReceived { 
 @ @ - 309 , 4 + 310 , 8 @ @ message DialogEvents { 
 int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 int32 reader _ user _ id = 8 ; 
 } 
 + 
 + message CounterReset { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 9f2b4eb . . b27c32b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import java . sql . SQLException 
 
 import akka . actor . ActorLogging 
 import akka . pattern . pipe 
 - import akka . persistence . { PersistentActor , RecoveryCompleted } 
 + import akka . persistence . { PersistentActor , RecoveryCompleted , SnapshotMetadata , SnapshotOffer } 
 import im . actor . concurrent . AlertingActor 
 
 import scala . concurrent . Future 
 @ @ - 13 , 6 + 13 , 8 @ @ import scala . util . control . NoStackTrace 
 
 trait ProcessorState [ S , E ] { 
 def updated ( e : E ) : S 
 + 
 + def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : S 
 } 
 
 abstract class ProcessorError ( msg : String ) extends RuntimeException ( msg ) with NoStackTrace 
 @ @ - 50 , 6 + 52 , 8 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist 
 override final def receiveRecover = { 
 case e : E ⇒ 
 _ state = _ state . updated ( e ) 
 + case SnapshotOffer ( metadata , snapshot ) ⇒ 
 + _ state = _ state . withSnapshot ( metadata , snapshot ) 
 case RecoveryCompleted ⇒ onRecoveryCompleted ( ) 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 new file mode 100644 
 index 0000000 . . ada9106 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / ResumableProjection . scala 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + package im . actor . server . cqrs 
 + 
 + import akka . actor . { ActorRef , ActorRefFactory , PoisonPill , Props } 
 + import akka . pattern . ask 
 + import akka . http . scaladsl . util . FastFuture 
 + import akka . persistence . SnapshotMetadata 
 + import akka . util . Timeout 
 + import im . actor . config . ActorConfig 
 + import im . actor . serialization . ActorSerializer 
 + 
 + import scala . concurrent . Future 
 + 
 + object ResumableProjection { 
 + ActorSerializer . register ( 
 + 110001 → classOf [ ResumableProjectionEvents . OffsetWritten ] , 
 + 110002 → classOf [ ResumableProjectionState ] 
 + ) 
 + 
 + def apply ( id : String ) ( implicit factory : ActorRefFactory ) = new ResumableProjection ( id ) 
 + 
 + private [ cqrs ] val maxHits = 20 
 + } 
 + 
 + private [ cqrs ] trait ResumableProjectionStateBase extends ProcessorState [ ResumableProjectionState , Event ] { 
 + this : ResumableProjectionState ⇒ 
 + 
 + import ResumableProjectionEvents . _ 
 + 
 + override def updated ( e : Event ) : ResumableProjectionState = e match { 
 + case ow : OffsetWritten ⇒ 
 + copy ( offset = ow . offset , hits = hits + 1 ) 
 + } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : ResumableProjectionState = snapshot match { 
 + case s : ResumableProjectionState ⇒ s 
 + } 
 + } 
 + 
 + final class ResumableProjection ( id : String ) ( implicit factory : ActorRefFactory ) { 
 + import factory . dispatcher 
 + 
 + private case class SaveOffset ( offset : Long ) 
 + private object SaveOffsetAck 
 + 
 + private object GetOffset 
 + private case class GetOffsetResponse ( offset : Long ) 
 + 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private var isStopped = false 
 + 
 + private val _ actor = factory . actorOf ( Props ( new Processor [ ResumableProjectionState , Event ] { 
 + import ResumableProjectionEvents . _ 
 + 
 + override def persistenceId : String = s " RProj _ $ id " 
 + 
 + override protected def getInitialState : ResumableProjectionState = ResumableProjectionState ( 0L , 0 ) 
 + 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 + case GetOffset ⇒ FastFuture . successful ( GetOffsetResponse ( state . offset ) ) 
 + } 
 + 
 + override protected def handleCommand : Receive = { 
 + case SaveOffset ( offset ) ⇒ persist ( OffsetWritten ( offset ) ) { e ⇒ 
 + commit ( e ) 
 + 
 + if ( state . hits > 10 ) { 
 + saveSnapshot ( state ) 
 + setState ( state . copy ( hits = 0 ) ) 
 + } 
 + 
 + sender ( ) ! SaveOffsetAck 
 + } 
 + } 
 + } ) ) 
 + 
 + private def actor : ActorRef = 
 + if ( isStopped ) throw new IllegalStateException ( " Projection is stopped " ) 
 + else _ actor 
 + 
 + def latestOffset : Future [ Long ] = ( actor ? GetOffset ) . mapTo [ GetOffsetResponse ] map ( _ . offset ) 
 + 
 + def saveOffset ( offset : Long ) : Future [ Unit ] = ( actor ? SaveOffset ( offset ) ) map ( _ ⇒ ( ) ) 
 + 
 + def stop ( ) : Unit = { 
 + actor ! PoisonPill 
 + isStopped = true 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index e02e96e . . b8044bf 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 30 , 7 + 30 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 becomeStashing ( replyTo ⇒ ( { 
 case seq : SeqStateDate ⇒ 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 replyTo ! seq 
 unstashAll ( ) 
 @ @ - 70 , 7 + 70 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 throw new RuntimeException ( " No message date found in SendMessage " ) 
 } 
 
 - persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id ) ) { e ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate . value ) , sm . getOrigin . id , sm . message . header ) ) { e ⇒ 
 commit ( e ) 
 
 if ( peer . typ = = PeerType . Private ) { 
 @ @ - 97 , 7 + 97 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 sender ( ) ! Status . Failure ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 } else { 
 - persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId ) ) { e ⇒ 
 + persist ( NewMessage ( randomId , Instant . ofEpochMilli ( dateMillis ) , senderUserId , message . header ) ) { e ⇒ 
 commit ( e ) 
 db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 . map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index ae2bb79 . . 9fdac80 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 3 , 6 + 3 , 7 @ @ package im . actor . server . dialog 
 import java . time . Instant 
 
 import akka . actor . _ 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 @ @ - 55 , 7 + 56 , 7 @ @ private [ dialog ] final case class DialogState ( 
 import DialogEvents . _ 
 
 override def updated ( e : DialogEvent ) : DialogState = e match { 
 - case NewMessage ( randomId , date , senderUserId ) ⇒ 
 + case NewMessage ( randomId , date , senderUserId , messageHeader ) ⇒ 
 if ( senderUserId ! = userId ) { 
 this . copy ( 
 counter = counter + 1 , 
 @ @ - 69 , 7 + 70 , 10 @ @ private [ dialog ] final case class DialogState ( 
 case MessagesRead ( date , readerUserId ) if readerUserId ! = userId & & date . isAfter ( lastReadDate ) ⇒ 
 this . copy ( lastReadDate = date ) 
 case MessagesReceived ( date ) if date . isAfter ( lastReceiveDate ) ⇒ this . copy ( lastReceiveDate = date ) 
 + case CounterReset ( ) ⇒ this . copy ( counter = 0 , unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogState = this 
 } 
 
 object DialogProcessor { 
 @ @ - 78 , 7 + 82 , 8 @ @ object DialogProcessor { 
 ActorSerializer . register ( 
 40010 → classOf [ DialogEvents . MessagesRead ] , 
 40011 → classOf [ DialogEvents . MessagesReceived ] , 
 - 40012 → classOf [ DialogEvents . NewMessage ] 
 + 40012 → classOf [ DialogEvents . NewMessage ] , 
 + 40013 → classOf [ DialogEvents . CounterReset ] 
 ) 
 } 
 
 @ @ - 103 , 12 + 108 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 protected implicit val system : ActorSystem = context . system 
 
 + protected implicit val timeout = Timeout ( 5 . seconds ) 
 + 
 protected val db : Database = DbExtension ( system ) . db 
 protected val userExt = UserExtension ( system ) 
 protected val groupExt = GroupExtension ( system ) 
 protected implicit val socialRegion = SocialExtension ( system ) . region 
 - protected implicit val timeout = Timeout ( 5 . seconds ) 
 - 
 protected val dialogExt = DialogExtension ( system ) 
 protected val deliveryExt = dialogExt . getDeliveryExtension ( extensions ) 
 protected val seqUpdExt = SeqUpdatesExtension ( context . system ) 
 @ @ - 131 , 36 + 136 , 35 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case GetCounter ( _ ) ⇒ 
 - Future . successful ( GetCounterResponse ( state . counter ) ) 
 - case GetInfo ( _ ) ⇒ Future . successful ( 
 + case GetCounter ( _ ) ⇒ getCounter ( ) map ( GetCounterResponse ( _ ) ) 
 + case GetInfo ( _ ) ⇒ getCounter ( ) map { counter ⇒ 
 GetInfoResponse ( Some ( DialogInfo ( 
 peer = Some ( peer ) , 
 - counter = state . counter , 
 + counter = counter , 
 date = state . lastMessageDate , 
 lastMessageDate = state . lastMessageDate , 
 lastReceivedDate = state . lastReceiveDate , 
 lastReadDate = state . lastReadDate 
 ) ) ) 
 - ) 
 + } 
 } 
 
 override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 def reactions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( rr ) 
 } 
 
 / / when receiving this messages , dialog is required to take an action 
 def actions ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 @ @ - 191 , 4 + 195 , 11 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * @ return does dialog owner accepts this command 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . getDest = = selfPeer ) | | ( ( dc . getDest = = peer ) & & ( dc . getOrigin ! = selfPeer ) ) 
 + 
 + private def getCounter ( ) : Future [ Int ] = { 
 + groupExt . isMember ( peer . id , userId ) map { 
 + case true ⇒ state . counter 
 + case false ⇒ 0 
 + } 
 + } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index cf67226 . . 1a5a772 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRef , Props , Status } 
 import akka . pattern . { ask , pipe } 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 @ @ - 57 , 6 + 58 , 8 @ @ private final case class DialogRootState ( 
 case Unfavourited ( _ , Some ( peer ) ) ⇒ withUnfavouritedPeer ( peer ) 
 } 
 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = this 
 + 
 private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index 9ed906a . . 10f3bc3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 114 , 6 + 114 , 9 @ @ private [ group ] sealed trait Queries { 
 def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = 
 ( viewRegion . ref ? GetMembers ( groupId ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) 
 
 + def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = 
 + getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) 
 + 
 def getAccessHash ( groupId : Int ) : Future [ Long ] = 
 ( viewRegion . ref ? GetAccessHash ( groupId ) ) . mapTo [ GetAccessHashResponse ] map ( _ . accessHash ) 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 index c9ce341 . . 23fda9a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeer . scala 
 @ @ - 1 , 8 + 1 , 9 @ @ 
 package im . actor . server . group 
 
 - import akka . actor . { ActorSystem , ActorLogging , Actor , Props } 
 + import akka . actor . { Actor , ActorLogging , ActorSystem , Props } 
 + import akka . persistence . SnapshotMetadata 
 import im . actor . server . cqrs . ProcessorState 
 - import im . actor . server . dialog . { DialogExtension , DialogCommands } 
 + import im . actor . server . dialog . { DialogCommands , DialogExtension } 
 
 import scala . concurrent . ExecutionContext 
 
 @ @ - 21 , 6 + 22 , 8 @ @ private [ group ] case class GroupPeerState ( 
 case LastReceiveDateChanged ( date ) ⇒ this . copy ( lastReceiveDate = date ) 
 case LastReadDateChanged ( date ) ⇒ this . copy ( lastReadDate = date ) 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : GroupPeerState = this 
 } 
 
 private [ group ] sealed trait GroupPeerEvent 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 index 2de0cd1 . . 29b1a4b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserContacts . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRefFactory , Props } 
 import akka . pattern . ask 
 + import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import im . actor . api . rpc . users . UpdateUserLocalNameChanged 
 import im . actor . server . cqrs . { Processor , ProcessorState } 
 @ @ - 25 , 6 + 26 , 8 @ @ private final case class UserContactsState ( localNames : Map [ Int , String ] = Map . em 
 this . copy ( localNames = localNames + ( contactUserId → localName ) ) 
 } 
 } 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : UserContactsState = this 
 } 
 
 private [ user ] final class UserContacts ( userId : Int ) ( implicit factory : ActorRefFactory ) { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 index 416b7cf . . 9e75b2c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupsServiceSpec . scala 
 @ @ - 862 , 7 + 862 , 7 @ @ final class GroupsServiceSpec 
 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount > 6 shouldEqual true 
 + dialog . unreadCount should be > 6 
 } 
 
 whenReady ( service . handleLeaveGroup ( groupOutPeer , Random . nextLong ( ) ) ) { resp ⇒ 
 @ @ - 973 , 6 + 973 , 14 @ @ final class GroupsServiceSpec 
 } 
 val outPeer = ApiOutPeer ( ApiPeerType . Group , groupOutPeer . groupId , groupOutPeer . accessHash ) 
 
 + { 
 + implicit val clientData = clientData2 
 + whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 + val dialog = resp . toOption . get . dialogs . head 
 + dialog . unreadCount shouldBe 2 
 + } 
 + } 
 + 
 for ( _ ← 1 to 6 ) { 
 implicit val clientData = clientData1 
 whenReady ( messagingService . handleSendMessage ( outPeer , Random . nextLong ( ) , ApiTextMessage ( " hello public " , Vector . empty , None ) , None ) ) { _ ⇒ } 
 @ @ - 984 , 7 + 992 , 7 @ @ final class GroupsServiceSpec 
 implicit val clientData = clientData2 
 whenReady ( messagingService . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 val dialog = resp . toOption . get . dialogs . head 
 - dialog . unreadCount shouldBe 6 
 + dialog . unreadCount shouldBe 8 
 } 
 }
