BLEU SCORE: 0.17542198478193427

TEST MSG: fix ( server : core ) : keep random id unique
GENERATED MSG: fix ( server ) : fixed empty dialogs on UpdateContactRegistered

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 4b58c07 . . 8c6fabd 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 11 , 6 + 11 , 7 @ @ import im . actor . api . rpc . messaging . _ < nl > import im . actor . server . ApiConversions . _ < nl > import im . actor . server . dialog . HistoryUtils . _ < nl > import im . actor . server . model . _ < nl > + import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . persist . messaging . ReactionEventRepo < nl > import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > @ @ - 49 , 18 + 50 , 25 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > val message = sm . message < nl > PubSubExtension ( system ) . publish ( PeerMessage ( sm . getOrigin , sm . getDest , sm . randomId , sendDate , message ) ) < nl > < nl > - withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( < nl > - default = for { < nl > - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( Int64Value ( sendDate ) ) ) ) < nl > - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - / / _ = dialogExt . updateCounters ( peer , userId ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sendDate ) , < nl > - failed = for { < nl > - _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sendDate ) < nl > - ) < nl > + for { < nl > + exists ← db . run ( HistoryMessageRepo . existstWithRandomId ( userId , peer , sm . randomId ) ) < nl > + seqState ← if ( exists ) { < nl > + FastFuture . failed ( NotUniqueRandomId ) < nl > + } else { < nl > + withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( < nl > + default = for { < nl > + _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( Int64Value ( sendDate ) ) ) ) < nl > + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + / / _ = dialogExt . updateCounters ( peer , userId ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sendDate ) , < nl > + failed = for { < nl > + _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sendDate ) < nl > + ) < nl > + } < nl > + } yield seqState < nl > } < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 32e6416 . . b74fdcc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 29 , 54 + 29 , 48 @ @ object HistoryUtils { < nl > requirePrivatePeer ( fromPeer ) < nl > / / requireDifferentPeers ( fromPeer , toPeer ) < nl > < nl > - HistoryMessageRepo . existstWithRandomId ( fromPeer . id , toPeer , randomId ) flatMap { exists ⇒ < nl > - if ( exists ) { < nl > - DBIO . failed ( NotUniqueRandomId ) < nl > - } else { < nl > - if ( toPeer . typ = = PeerType . Private ) { < nl > - val outMessage = HistoryMessage ( < nl > - userId = fromPeer . id , < nl > - peer = toPeer , < nl > - date = date , < nl > - senderUserId = fromPeer . id , < nl > - randomId = randomId , < nl > - messageContentHeader = messageContentHeader , < nl > - messageContentData = messageContentData , < nl > - deletedAt = None < nl > - ) < nl > + if ( toPeer . typ = = PeerType . Private ) { < nl > + val outMessage = HistoryMessage ( < nl > + userId = fromPeer . id , < nl > + peer = toPeer , < nl > + date = date , < nl > + senderUserId = fromPeer . id , < nl > + randomId = randomId , < nl > + messageContentHeader = messageContentHeader , < nl > + messageContentData = messageContentData , < nl > + deletedAt = None < nl > + ) < nl > < nl > - val messages = < nl > - if ( fromPeer ! = toPeer ) { < nl > - Seq ( < nl > - outMessage , < nl > - outMessage . copy ( userId = toPeer . id , peer = fromPeer ) < nl > - ) < nl > - } else { < nl > - Seq ( outMessage ) < nl > - } < nl > + val messages = < nl > + if ( fromPeer ! = toPeer ) { < nl > + Seq ( < nl > + outMessage , < nl > + outMessage . copy ( userId = toPeer . id , peer = fromPeer ) < nl > + ) < nl > + } else { < nl > + Seq ( outMessage ) < nl > + } < nl > < nl > - for { < nl > - _ ← HistoryMessageRepo . create ( messages ) < nl > - } yield ( ) < nl > - } else if ( toPeer . typ = = PeerType . Group ) { < nl > - for { < nl > - isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) < nl > - _ ← if ( isHistoryShared ) { < nl > - val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > - HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) < nl > - } else { < nl > - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ < nl > - val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > - HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > - } < nl > - HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) < nl > - } < nl > - } < nl > - } yield ( ) < nl > + for { < nl > + _ ← HistoryMessageRepo . create ( messages ) < nl > + } yield ( ) < nl > + } else if ( toPeer . typ = = PeerType . Group ) { < nl > + for { < nl > + isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) < nl > + _ ← if ( isHistoryShared ) { < nl > + val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > + HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) < nl > } else { < nl > - DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) < nl > + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ < nl > + val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > + HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > + } < nl > + HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) < nl > + } < nl > } < nl > - } < nl > + } yield ( ) < nl > + } else { < nl > + DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) < nl > } < nl > } < nl > < nl > @ @ - 90 , 21 + 84 , 16 @ @ object HistoryUtils { < nl > messageContentData : Array [ Byte ] < nl > ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { < nl > for { < nl > - exists ← HistoryMessageRepo . existstWithRandomId ( userId , toPeer , randomId ) < nl > - _ ← if ( exists ) { < nl > - DBIO . failed ( NotUniqueRandomId ) < nl > - } else { < nl > - HistoryMessageRepo . create ( HistoryMessage ( < nl > - userId = userId , < nl > - peer = toPeer , < nl > - date = date , < nl > - senderUserId = senderUserId , < nl > - randomId = randomId , < nl > - messageContentHeader = messageContentHeader , < nl > - messageContentData = messageContentData , < nl > - deletedAt = None < nl > - ) ) < nl > - } < nl > + _ ← HistoryMessageRepo . create ( HistoryMessage ( < nl > + userId = userId , < nl > + peer = toPeer , < nl > + date = date , < nl > + senderUserId = senderUserId , < nl > + randomId = randomId , < nl > + messageContentHeader = messageContentHeader , < nl > + messageContentData = messageContentData , < nl > + deletedAt = None < nl > + ) ) < nl > } yield ( ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 72dde09 . . 23156bc 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 510 , 10 + 510 , 14 @ @ class MessagingServiceSpec < nl > < nl > val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > < nl > + val bobClientData = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + val aliceClientData1 = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) < nl > + val aliceClientData2 = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) < nl > + < nl > val RandomId = 22L < nl > < nl > { < nl > - implicit val cd = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) < nl > + implicit val cd = aliceClientData1 < nl > whenReady ( service . handleSendMessage ( < nl > getOutPeer ( bob . id , aliceAuthId1 ) , < nl > RandomId , < nl > @ @ - 524 , 12 + 528 , 13 @ @ class MessagingServiceSpec < nl > resp should matchPattern { < nl > case Ok ( _ ) ⇒ < nl > } < nl > - < nl > } < nl > } < nl > < nl > + val bobSeq = getCurrentSeq ( bobClientData ) < nl > + < nl > { < nl > - implicit val cd = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) < nl > + implicit val cd = aliceClientData2 < nl > whenReady ( service . handleSendMessage ( < nl > getOutPeer ( bob . id , aliceAuthId2 ) , < nl > RandomId , < nl > @ @ - 544 , 7 + 549 , 16 @ @ class MessagingServiceSpec < nl > } < nl > < nl > { < nl > - implicit val cd = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + implicit val cd = bobClientData < nl > + expectNoUpdate ( bobSeq , classOf [ UpdateMessage ] ) < nl > + expectNoUpdate ( bobSeq , classOf [ UpdateCountersChanged ] ) < nl > + } < nl > + < nl > + val aliceSeq1 = getCurrentSeq ( aliceClientData1 ) < nl > + val aliceSeq2 = getCurrentSeq ( aliceClientData2 ) < nl > + < nl > + { < nl > + implicit val cd = bobClientData < nl > whenReady ( service . handleSendMessage ( < nl > getOutPeer ( alice . id , bobAuthId ) , < nl > RandomId , < nl > @ @ - 557 , 6 + 571 , 19 @ @ class MessagingServiceSpec < nl > } < nl > } < nl > } < nl > + < nl > + { < nl > + implicit val cd = aliceClientData1 < nl > + expectNoUpdate ( aliceSeq1 , classOf [ UpdateMessage ] ) < nl > + expectNoUpdate ( aliceSeq1 , classOf [ UpdateCountersChanged ] ) < nl > + } < nl > + < nl > + { < nl > + implicit val cd = aliceClientData2 < nl > + expectNoUpdate ( aliceSeq2 , classOf [ UpdateMessage ] ) < nl > + expectNoUpdate ( aliceSeq2 , classOf [ UpdateCountersChanged ] ) < nl > + } < nl > + < nl > } < nl > < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala < nl > index a15e60c . . c716efb 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala < nl > @ @ - 408 , 7 + 408 , 7 @ @ class ReadsSpec extends ActorSuite { < nl > < nl > readMessages . size shouldEqual unreadMessages . size < nl > / / this one doesn ' t hold < nl > - / / readMessagesIds . size shouldEqual unreadMessages . size < nl > + / / readMessagesIds . size shouldEqual unreadMessages . size < nl > newUnreadMessages . size shouldEqual 0 < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 93eb1d5 . . 473391e 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 25 , 6 + 25 , 7 @ @ message DialogCommands { < nl > Delete delete = 8 ; < nl > SetReaction set _ reaction = 9 ; < nl > RemoveReaction remove _ reaction = 10 ; < nl > + WriteMessageSelf write _ message _ self = 11 ; < nl > } < nl > } < nl > < nl > @ @ - 40 , 6 + 41 , 18 @ @ message DialogCommands { < nl > < nl > message WriteMessageAck { } < nl > < nl > + message WriteMessageSelf { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; < nl > + < nl > + required Peer dest = 1 ; < nl > + required int32 senderUserId = 6 ; < nl > + required int64 date = 3 ; < nl > + required int64 random _ id = 4 ; < nl > + required bytes message = 5 [ ( scalapb . field ) . type = " im . actor . api . rpc . messaging . ApiMessage " ] ; < nl > + } < nl > + < nl > + message WriteMessageSelfAck { } < nl > + < nl > message SendMessage { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 44dd451 . . b504cf8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 64 , 32 + 64 , 33 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > message : ApiMessage < nl > ) : Unit = { < nl > val date = new DateTime ( dateMillis ) < nl > - val fut = < nl > - message match { < nl > - case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( _ ) ) ) ⇒ < nl > - db . run ( HistoryMessageRepo . create ( < nl > - HistoryMessage ( < nl > - userId = peer . id , / / figure out what should be there < nl > - peer = selfPeer , < nl > - date = date , < nl > - senderUserId = userId , < nl > - randomId = randomId , < nl > - messageContentHeader = message . header , < nl > - messageContentData = message . toByteArray , < nl > - deletedAt = None < nl > - ) < nl > - ) ) < nl > - case _ ⇒ < nl > - db . run ( writeHistoryMessage ( < nl > - selfPeer , < nl > - peer , < nl > - date , < nl > - randomId , < nl > - message . header , < nl > - message . toByteArray < nl > - ) ) < nl > + < nl > + db . run ( writeHistoryMessage ( < nl > + selfPeer , < nl > + peer , < nl > + date , < nl > + randomId , < nl > + message . header , < nl > + message . toByteArray < nl > + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + } < nl > + < nl > + protected def writeMessageSelf ( < nl > + senderUserId : Int , < nl > + dateMillis : Long , < nl > + randomId : Long , < nl > + message : ApiMessage < nl > + ) : Unit = { < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + val result = < nl > + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) < nl > + } else { < nl > + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > } < nl > - fut map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + < nl > + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > } < nl > < nl > protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 5b4ea34 . . 122c465 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 93 , 6 + 93 , 25 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > + def writeMessageSelf ( < nl > + userId : Int , < nl > + peer : ApiPeer , < nl > + senderUserId : Int , < nl > + date : DateTime , < nl > + randomId : Long , < nl > + message : ApiMessage < nl > + ) : Future [ Unit ] = < nl > + withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { < nl > + ( userExt . processorRegion . ref ? < nl > + Envelope ( Peer . privat ( userId ) ) . withWriteMessageSelf ( WriteMessageSelf ( < nl > + dest = peer . asModel , < nl > + senderUserId , < nl > + date . getMillis , < nl > + randomId , < nl > + message < nl > + ) ) ) map ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 9e5f924 . . f25ce13 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 126 , 20 + 126 , 21 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > } ) < nl > < nl > def initialized ( state : DialogState ) : Receive = { < nl > - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > - case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) < nl > - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > - case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) < nl > + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received < nl > + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages < nl > + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read < nl > + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) < nl > + case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) < nl > + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) < nl > + case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) < nl > case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > - case Show ( _ ) ⇒ show ( state ) < nl > - case Hide ( _ ) ⇒ hide ( state ) < nl > - case Delete ( _ ) ⇒ delete ( state ) < nl > + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > + case Show ( _ ) ⇒ show ( state ) < nl > + case Hide ( _ ) ⇒ hide ( state ) < nl > + case Delete ( _ ) ⇒ delete ( state ) < nl > } < nl > < nl > / * * < nl > @ @ - 172 , 6 + 173 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index cdd223e . . 9178f48 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . dialog < nl > import akka . actor . ActorSystem < nl > import im . actor . server . group . { GroupExtension , GroupUtils } < nl > import im . actor . server . model . { HistoryMessage , PeerType , Peer } < nl > - import im . actor . server . { persist } < nl > + import im . actor . server . persist . { GroupUserRepo , DialogRepo , HistoryMessageRepo } < nl > import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > @ @ - 52 , 9 + 52 , 9 @ @ object HistoryUtils { < nl > } < nl > < nl > for { < nl > - _ ← persist . HistoryMessageRepo . create ( messages ) < nl > - _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← HistoryMessageRepo . create ( messages ) < nl > + _ ← DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > + _ ← DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > @ @ - 63 , 16 + 63 , 16 @ @ object HistoryUtils { < nl > val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > < nl > for { < nl > - _ ← persist . DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) < nl > - _ ← persist . HistoryMessageRepo . create ( historyMessage ) < nl > + _ ← DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) < nl > + _ ← HistoryMessageRepo . create ( historyMessage ) < nl > } yield ( ) < nl > } else { < nl > val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > } < nl > - val dialogAction = persist . DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) < nl > + val dialogAction = DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) < nl > < nl > - DBIO . sequence ( Seq ( dialogAction , persist . HistoryMessageRepo . create ( historyMessages ) map ( _ . getOrElse ( 0 ) ) ) ) map ( _ ⇒ ( ) ) < nl > + DBIO . sequence ( Seq ( dialogAction , HistoryMessageRepo . create ( historyMessages ) map ( _ . getOrElse ( 0 ) ) ) ) map ( _ ⇒ ( ) ) < nl > } < nl > } < nl > } < nl > @ @ - 81 , 6 + 81 , 30 @ @ object HistoryUtils { < nl > } < nl > } < nl > < nl > + private [ dialog ] def writeHistoryMessageSelf ( < nl > + userId : Int , < nl > + toPeer : Peer , < nl > + senderUserId : Int , < nl > + date : DateTime , < nl > + randomId : Long , < nl > + messageContentHeader : Int , < nl > + messageContentData : Array [ Byte ] < nl > + ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { < nl > + for { < nl > + _ ← HistoryMessageRepo . create ( HistoryMessage ( < nl > + userId = userId , < nl > + peer = toPeer , < nl > + date = date , < nl > + senderUserId = senderUserId , < nl > + randomId = randomId , < nl > + messageContentHeader = messageContentHeader , < nl > + messageContentData = messageContentData , < nl > + deletedAt = None < nl > + ) ) < nl > + _ ← DialogRepo . updateLastMessageDate ( userId , toPeer , date ) < nl > + } yield ( ) < nl > + } < nl > + < nl > private [ dialog ] def markMessagesReceived ( byPeer : Peer , peer : Peer , date : DateTime ) ( implicit system : ActorSystem , ec : ExecutionContext ) : DBIO [ Unit ] = { < nl > requirePrivatePeer ( byPeer ) < nl > / / requireDifferentPeers ( byPeer , peer ) < nl > @ @ - 89 , 17 + 113 , 17 @ @ object HistoryUtils { < nl > case PeerType . Private ⇒ < nl > / / TODO : # perf do in single query < nl > DBIO . sequence ( Seq ( < nl > - persist . DialogRepo . updateLastReceivedAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , < nl > - persist . DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , peer , date ) < nl > + DialogRepo . updateLastReceivedAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , < nl > + DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , peer , date ) < nl > ) ) map ( _ ⇒ ( ) ) < nl > case PeerType . Group ⇒ < nl > withGroup ( peer . id ) { _ ⇒ < nl > - persist . GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ < nl > + GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ < nl > / / TODO : # perf update dialogs in one query < nl > < nl > - val selfAction = persist . DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) < nl > + val selfAction = DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) < nl > val otherGroupUserIds = groupUserIds . view . filterNot ( _ = = byPeer . id ) . toSet < nl > - val otherAction = persist . DialogRepo . updateLastReceivedAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) < nl > + val otherAction = DialogRepo . updateLastReceivedAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) < nl > < nl > selfAction andThen otherAction map ( _ ⇒ ( ) ) < nl > } < nl > @ @ - 116 , 18 + 140 , 18 @ @ object HistoryUtils { < nl > case PeerType . Private ⇒ < nl > / / TODO : # perf do in single query < nl > DBIO . sequence ( Seq ( < nl > - persist . DialogRepo . updateLastReadAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , < nl > - persist . DialogRepo . updateOwnerLastReadAt ( byPeer . id , peer , date ) < nl > + DialogRepo . updateLastReadAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , < nl > + DialogRepo . updateOwnerLastReadAt ( byPeer . id , peer , date ) < nl > ) ) map ( _ ⇒ ( ) ) < nl > case PeerType . Group ⇒ < nl > withGroup ( peer . id ) { _ ⇒ < nl > - persist . GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ < nl > + GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ < nl > / / TODO : # perf update dialogs in one query < nl > < nl > - val selfAction = persist . DialogRepo . updateOwnerLastReadAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) < nl > + val selfAction = DialogRepo . updateOwnerLastReadAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) < nl > < nl > val otherGroupUserIds = groupUserIds . view . filterNot ( _ = = byPeer . id ) . toSet < nl > - val otherAction = persist . DialogRepo . updateLastReadAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) < nl > + val otherAction = DialogRepo . updateLastReadAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) < nl > < nl > selfAction andThen otherAction map ( _ ⇒ ( ) ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index f27b916 . . 733f5f0 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 346 , 8 + 346 , 9 @ @ private [ user ] trait UserCommandHandlers { < nl > _ ← userExt . addContact ( contact . ownerUserId , user . id , localName , Some ( phoneNumber ) , None ) < nl > _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactRegistered , Some ( s " $ { localName . getOrElse ( user . name ) } registered " ) , isFat = true , deliveryId = None ) < nl > _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactsAdded , None , isFat = false , deliveryId = None ) < nl > - _ ← dialogExt . writeMessage ( < nl > - ApiPeer ( ApiPeerType . Private , contact . ownerUserId ) , < nl > + _ ← dialogExt . writeMessageSelf ( < nl > + contact . ownerUserId , < nl > + ApiPeer ( ApiPeerType . Private , user . id ) , < nl > user . id , < nl > date , < nl > randomId , < nl > @ @ - 377 , 8 + 378 , 9 @ @ private [ user ] trait UserCommandHandlers { < nl > _ ← userExt . addContact ( contact . ownerUserId , user . id , localName , None , Some ( email ) ) < nl > _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactRegistered , Some ( serviceMessage . text ) , isFat = true , deliveryId = None ) < nl > _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactsAdded , None , isFat = false , deliveryId = None ) < nl > - _ ← dialogExt . writeMessage ( < nl > - ApiPeer ( ApiPeerType . Private , contact . ownerUserId ) , < nl > + _ ← dialogExt . writeMessageSelf ( < nl > + contact . ownerUserId , < nl > + ApiPeer ( ApiPeerType . Private , user . id ) , < nl > user . id , < nl > date , < nl > randomId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > index 337ba36 . . 841b357 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala < nl > @ @ - 15 , 7 + 15 , 9 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e < nl > private val selfPeer = Peer . privat ( userId ) < nl > < nl > def receive : Receive = { < nl > + / / Forward to a group or a corresponding user dialog < nl > case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc < nl > + / / Forward to a dest user dialog < nl > case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc < nl > case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . d9bb6c5 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala < nl > @ @ - 0 , 0 + 1 , 78 @ @ < nl > + package im . actor . server . user < nl > + < nl > + import im . actor . api . rpc . contacts . UpdateContactRegistered < nl > + import im . actor . api . rpc . messaging . _ < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . persist . contact . UnregisteredEmailContactRepo < nl > + import im . actor . server . _ < nl > + < nl > + final class ContactRegisteredSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with MessagingSpecHelpers with SeqUpdateMatchers { < nl > + it should " notify ContactRegistered " in notifyContactRegistered ( ) < nl > + it should " not create dialog with contacts which receive ContactRegistered " in notCreateDialog ( ) < nl > + < nl > + private lazy val msgService = MessagingServiceImpl ( ) < nl > + < nl > + def notifyContactRegistered ( ) = { < nl > + val ( alice , bob ) = createUserRegisterContact ( ) < nl > + implicit val clientData = alice < nl > + < nl > + expectUpdate ( classOf [ UpdateContactRegistered ] ) ( _ ⇒ ( ) ) < nl > + < nl > + Thread . sleep ( 300 ) < nl > + < nl > + whenReady ( msgService . handleLoadDialogs ( 0 , 100 ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseLoadDialogs ( _ , _ , Vector ( dialog ) ) ) ⇒ < nl > + dialog . peer should = = = ( ApiPeer ( ApiPeerType . Private , bob . authData . get . userId ) ) < nl > + < nl > + inside ( dialog . message ) { < nl > + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ < nl > + userId should = = = ( bob . authData . get . userId ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( getOutPeer ( bob . authData . get . userId , clientData . authId ) , 0 , 100 ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseLoadHistory ( Vector ( hm ) , _ ) ) ⇒ < nl > + inside ( hm . message ) { < nl > + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ < nl > + userId should = = = ( bob . authData . get . userId ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def notCreateDialog ( ) = { < nl > + val ( alice , bob ) = createUserRegisterContact ( ) < nl > + implicit val clientData = bob < nl > + < nl > + whenReady ( msgService . handleLoadDialogs ( 0 , 100 ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseLoadDialogs ( _ , _ , Vector ( ) ) ) ⇒ < nl > + } < nl > + } < nl > + < nl > + whenReady ( msgService . handleLoadHistory ( getOutPeer ( alice . authData . get . userId , bob . authId ) , 0 , 100 ) ) { resp ⇒ < nl > + inside ( resp ) { < nl > + case Ok ( ResponseLoadHistory ( Vector ( ) , Vector ( ) ) ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + < nl > + private def createUserRegisterContact ( ) : ( ClientData , ClientData ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val aliceClientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + whenReady ( db . run ( UnregisteredEmailContactRepo . create ( " test @ acme . com " , alice . id , None ) ) ) ( identity ) < nl > + < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val bobClientData = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + < nl > + whenReady ( UserExtension ( system ) . addEmail ( bob . id , " test @ acme . com " ) ) ( identity ) < nl > + < nl > + ( aliceClientData , bobClientData ) < nl > + } < nl > + } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 4b58c07 . . 8c6fabd 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 11 , 6 + 11 , 7 @ @ import im . actor . api . rpc . messaging . _ 
 import im . actor . server . ApiConversions . _ 
 import im . actor . server . dialog . HistoryUtils . _ 
 import im . actor . server . model . _ 
 + import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . persist . messaging . ReactionEventRepo 
 import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 @ @ - 49 , 18 + 50 , 25 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 val message = sm . message 
 PubSubExtension ( system ) . publish ( PeerMessage ( sm . getOrigin , sm . getDest , sm . randomId , sendDate , message ) ) 
 
 - withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( 
 - default = for { 
 - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( Int64Value ( sendDate ) ) ) ) 
 - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 - / / _ = dialogExt . updateCounters ( peer , userId ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sendDate ) , 
 - failed = for { 
 - _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sendDate ) 
 - ) 
 + for { 
 + exists ← db . run ( HistoryMessageRepo . existstWithRandomId ( userId , peer , sm . randomId ) ) 
 + seqState ← if ( exists ) { 
 + FastFuture . failed ( NotUniqueRandomId ) 
 + } else { 
 + withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( 
 + default = for { 
 + _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( Int64Value ( sendDate ) ) ) ) 
 + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 + / / _ = dialogExt . updateCounters ( peer , userId ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sendDate ) , 
 + failed = for { 
 + _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sendDate ) 
 + ) 
 + } 
 + } yield seqState 
 } 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 32e6416 . . b74fdcc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 29 , 54 + 29 , 48 @ @ object HistoryUtils { 
 requirePrivatePeer ( fromPeer ) 
 / / requireDifferentPeers ( fromPeer , toPeer ) 
 
 - HistoryMessageRepo . existstWithRandomId ( fromPeer . id , toPeer , randomId ) flatMap { exists ⇒ 
 - if ( exists ) { 
 - DBIO . failed ( NotUniqueRandomId ) 
 - } else { 
 - if ( toPeer . typ = = PeerType . Private ) { 
 - val outMessage = HistoryMessage ( 
 - userId = fromPeer . id , 
 - peer = toPeer , 
 - date = date , 
 - senderUserId = fromPeer . id , 
 - randomId = randomId , 
 - messageContentHeader = messageContentHeader , 
 - messageContentData = messageContentData , 
 - deletedAt = None 
 - ) 
 + if ( toPeer . typ = = PeerType . Private ) { 
 + val outMessage = HistoryMessage ( 
 + userId = fromPeer . id , 
 + peer = toPeer , 
 + date = date , 
 + senderUserId = fromPeer . id , 
 + randomId = randomId , 
 + messageContentHeader = messageContentHeader , 
 + messageContentData = messageContentData , 
 + deletedAt = None 
 + ) 
 
 - val messages = 
 - if ( fromPeer ! = toPeer ) { 
 - Seq ( 
 - outMessage , 
 - outMessage . copy ( userId = toPeer . id , peer = fromPeer ) 
 - ) 
 - } else { 
 - Seq ( outMessage ) 
 - } 
 + val messages = 
 + if ( fromPeer ! = toPeer ) { 
 + Seq ( 
 + outMessage , 
 + outMessage . copy ( userId = toPeer . id , peer = fromPeer ) 
 + ) 
 + } else { 
 + Seq ( outMessage ) 
 + } 
 
 - for { 
 - _ ← HistoryMessageRepo . create ( messages ) 
 - } yield ( ) 
 - } else if ( toPeer . typ = = PeerType . Group ) { 
 - for { 
 - isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) 
 - _ ← if ( isHistoryShared ) { 
 - val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 - HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) 
 - } else { 
 - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ 
 - val historyMessages = groupUserIds . map { groupUserId ⇒ 
 - HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 - } 
 - HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) 
 - } 
 - } 
 - } yield ( ) 
 + for { 
 + _ ← HistoryMessageRepo . create ( messages ) 
 + } yield ( ) 
 + } else if ( toPeer . typ = = PeerType . Group ) { 
 + for { 
 + isHistoryShared ← DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) 
 + _ ← if ( isHistoryShared ) { 
 + val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 + HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) 
 } else { 
 - DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) 
 + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ 
 + val historyMessages = groupUserIds . map { groupUserId ⇒ 
 + HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 + } 
 + HistoryMessageRepo . create ( historyMessages ) map ( _ ⇒ ( ) ) 
 + } 
 } 
 - } 
 + } yield ( ) 
 + } else { 
 + DBIO . failed ( new Exception ( " PeerType is not supported " ) with NoStackTrace ) 
 } 
 } 
 
 @ @ - 90 , 21 + 84 , 16 @ @ object HistoryUtils { 
 messageContentData : Array [ Byte ] 
 ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { 
 for { 
 - exists ← HistoryMessageRepo . existstWithRandomId ( userId , toPeer , randomId ) 
 - _ ← if ( exists ) { 
 - DBIO . failed ( NotUniqueRandomId ) 
 - } else { 
 - HistoryMessageRepo . create ( HistoryMessage ( 
 - userId = userId , 
 - peer = toPeer , 
 - date = date , 
 - senderUserId = senderUserId , 
 - randomId = randomId , 
 - messageContentHeader = messageContentHeader , 
 - messageContentData = messageContentData , 
 - deletedAt = None 
 - ) ) 
 - } 
 + _ ← HistoryMessageRepo . create ( HistoryMessage ( 
 + userId = userId , 
 + peer = toPeer , 
 + date = date , 
 + senderUserId = senderUserId , 
 + randomId = randomId , 
 + messageContentHeader = messageContentHeader , 
 + messageContentData = messageContentData , 
 + deletedAt = None 
 + ) ) 
 } yield ( ) 
 } 
 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 72dde09 . . 23156bc 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 510 , 10 + 510 , 14 @ @ class MessagingServiceSpec 
 
 val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 
 + val bobClientData = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + val aliceClientData1 = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) 
 + val aliceClientData2 = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) 
 + 
 val RandomId = 22L 
 
 { 
 - implicit val cd = ClientData ( aliceAuthId1 , 1 , Some ( AuthData ( alice . id , aliceAuthSid1 , 42 ) ) ) 
 + implicit val cd = aliceClientData1 
 whenReady ( service . handleSendMessage ( 
 getOutPeer ( bob . id , aliceAuthId1 ) , 
 RandomId , 
 @ @ - 524 , 12 + 528 , 13 @ @ class MessagingServiceSpec 
 resp should matchPattern { 
 case Ok ( _ ) ⇒ 
 } 
 - 
 } 
 } 
 
 + val bobSeq = getCurrentSeq ( bobClientData ) 
 + 
 { 
 - implicit val cd = ClientData ( aliceAuthId2 , 1 , Some ( AuthData ( alice . id , aliceAuthSid2 , 42 ) ) ) 
 + implicit val cd = aliceClientData2 
 whenReady ( service . handleSendMessage ( 
 getOutPeer ( bob . id , aliceAuthId2 ) , 
 RandomId , 
 @ @ - 544 , 7 + 549 , 16 @ @ class MessagingServiceSpec 
 } 
 
 { 
 - implicit val cd = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + implicit val cd = bobClientData 
 + expectNoUpdate ( bobSeq , classOf [ UpdateMessage ] ) 
 + expectNoUpdate ( bobSeq , classOf [ UpdateCountersChanged ] ) 
 + } 
 + 
 + val aliceSeq1 = getCurrentSeq ( aliceClientData1 ) 
 + val aliceSeq2 = getCurrentSeq ( aliceClientData2 ) 
 + 
 + { 
 + implicit val cd = bobClientData 
 whenReady ( service . handleSendMessage ( 
 getOutPeer ( alice . id , bobAuthId ) , 
 RandomId , 
 @ @ - 557 , 6 + 571 , 19 @ @ class MessagingServiceSpec 
 } 
 } 
 } 
 + 
 + { 
 + implicit val cd = aliceClientData1 
 + expectNoUpdate ( aliceSeq1 , classOf [ UpdateMessage ] ) 
 + expectNoUpdate ( aliceSeq1 , classOf [ UpdateCountersChanged ] ) 
 + } 
 + 
 + { 
 + implicit val cd = aliceClientData2 
 + expectNoUpdate ( aliceSeq2 , classOf [ UpdateMessage ] ) 
 + expectNoUpdate ( aliceSeq2 , classOf [ UpdateCountersChanged ] ) 
 + } 
 + 
 } 
 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala 
 index a15e60c . . c716efb 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / ReadsSpec . scala 
 @ @ - 408 , 7 + 408 , 7 @ @ class ReadsSpec extends ActorSuite { 
 
 readMessages . size shouldEqual unreadMessages . size 
 / / this one doesn ' t hold 
 - / / readMessagesIds . size shouldEqual unreadMessages . size 
 + / / readMessagesIds . size shouldEqual unreadMessages . size 
 newUnreadMessages . size shouldEqual 0 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 93eb1d5 . . 473391e 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 25 , 6 + 25 , 7 @ @ message DialogCommands { 
 Delete delete = 8 ; 
 SetReaction set _ reaction = 9 ; 
 RemoveReaction remove _ reaction = 10 ; 
 + WriteMessageSelf write _ message _ self = 11 ; 
 } 
 } 
 
 @ @ - 40 , 6 + 41 , 18 @ @ message DialogCommands { 
 
 message WriteMessageAck { } 
 
 + message WriteMessageSelf { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogCommand " ; 
 + 
 + required Peer dest = 1 ; 
 + required int32 senderUserId = 6 ; 
 + required int64 date = 3 ; 
 + required int64 random _ id = 4 ; 
 + required bytes message = 5 [ ( scalapb . field ) . type = " im . actor . api . rpc . messaging . ApiMessage " ] ; 
 + } 
 + 
 + message WriteMessageSelfAck { } 
 + 
 message SendMessage { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 44dd451 . . b504cf8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 64 , 32 + 64 , 33 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 message : ApiMessage 
 ) : Unit = { 
 val date = new DateTime ( dateMillis ) 
 - val fut = 
 - message match { 
 - case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( _ ) ) ) ⇒ 
 - db . run ( HistoryMessageRepo . create ( 
 - HistoryMessage ( 
 - userId = peer . id , / / figure out what should be there 
 - peer = selfPeer , 
 - date = date , 
 - senderUserId = userId , 
 - randomId = randomId , 
 - messageContentHeader = message . header , 
 - messageContentData = message . toByteArray , 
 - deletedAt = None 
 - ) 
 - ) ) 
 - case _ ⇒ 
 - db . run ( writeHistoryMessage ( 
 - selfPeer , 
 - peer , 
 - date , 
 - randomId , 
 - message . header , 
 - message . toByteArray 
 - ) ) 
 + 
 + db . run ( writeHistoryMessage ( 
 + selfPeer , 
 + peer , 
 + date , 
 + randomId , 
 + message . header , 
 + message . toByteArray 
 + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + } 
 + 
 + protected def writeMessageSelf ( 
 + senderUserId : Int , 
 + dateMillis : Long , 
 + randomId : Long , 
 + message : ApiMessage 
 + ) : Unit = { 
 + val date = new DateTime ( dateMillis ) 
 + 
 + val result = 
 + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) 
 + } else { 
 + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 } 
 - fut map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + 
 + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 } 
 
 protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 5b4ea34 . . 122c465 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 93 , 6 + 93 , 25 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 + def writeMessageSelf ( 
 + userId : Int , 
 + peer : ApiPeer , 
 + senderUserId : Int , 
 + date : DateTime , 
 + randomId : Long , 
 + message : ApiMessage 
 + ) : Future [ Unit ] = 
 + withValidPeer ( Peer . privat ( userId ) , peer . id , Future . successful ( ( ) ) ) { 
 + ( userExt . processorRegion . ref ? 
 + Envelope ( Peer . privat ( userId ) ) . withWriteMessageSelf ( WriteMessageSelf ( 
 + dest = peer . asModel , 
 + senderUserId , 
 + date . getMillis , 
 + randomId , 
 + message 
 + ) ) ) map ( _ ⇒ ( ) ) 
 + } 
 + 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 9e5f924 . . f25ce13 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 126 , 20 + 126 , 21 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 } ) 
 
 def initialized ( state : DialogState ) : Receive = { 
 - case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 - case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 - case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 - case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 - case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) 
 - case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 - case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) 
 + case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 + case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 + case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( state , mrv ) / / User ' s messages been received 
 + case mrd : MessageRead if invokes ( mrd ) ⇒ messageRead ( state , mrd ) / / User reads messages 
 + case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( state , mrd ) / / User ' s messages been read 
 + case sr : SetReaction if invokes ( sr ) ⇒ setReaction ( state , sr ) 
 + case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( state , sr ) 
 + case rr : RemoveReaction if invokes ( rr ) ⇒ removeReaction ( state , rr ) 
 + case rr : RemoveReaction if accepts ( rr ) ⇒ ackRemoveReaction ( state , rr ) 
 case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 - case Show ( _ ) ⇒ show ( state ) 
 - case Hide ( _ ) ⇒ hide ( state ) 
 - case Delete ( _ ) ⇒ delete ( state ) 
 + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 + case Show ( _ ) ⇒ show ( state ) 
 + case Hide ( _ ) ⇒ hide ( state ) 
 + case Delete ( _ ) ⇒ delete ( state ) 
 } 
 
 / * * 
 @ @ - 172 , 6 + 173 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index cdd223e . . 9178f48 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . server . dialog 
 import akka . actor . ActorSystem 
 import im . actor . server . group . { GroupExtension , GroupUtils } 
 import im . actor . server . model . { HistoryMessage , PeerType , Peer } 
 - import im . actor . server . { persist } 
 + import im . actor . server . persist . { GroupUserRepo , DialogRepo , HistoryMessageRepo } 
 import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 @ @ - 52 , 9 + 52 , 9 @ @ object HistoryUtils { 
 } 
 
 for { 
 - _ ← persist . HistoryMessageRepo . create ( messages ) 
 - _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← HistoryMessageRepo . create ( messages ) 
 + _ ← DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 + _ ← DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 @ @ - 63 , 16 + 63 , 16 @ @ object HistoryUtils { 
 val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 
 for { 
 - _ ← persist . DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) 
 - _ ← persist . HistoryMessageRepo . create ( historyMessage ) 
 + _ ← DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) 
 + _ ← HistoryMessageRepo . create ( historyMessage ) 
 } yield ( ) 
 } else { 
 val historyMessages = groupUserIds . map { groupUserId ⇒ 
 HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 } 
 - val dialogAction = persist . DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) 
 + val dialogAction = DialogRepo . updateLastMessageDates ( groupUserIds . toSet , toPeer , date ) 
 
 - DBIO . sequence ( Seq ( dialogAction , persist . HistoryMessageRepo . create ( historyMessages ) map ( _ . getOrElse ( 0 ) ) ) ) map ( _ ⇒ ( ) ) 
 + DBIO . sequence ( Seq ( dialogAction , HistoryMessageRepo . create ( historyMessages ) map ( _ . getOrElse ( 0 ) ) ) ) map ( _ ⇒ ( ) ) 
 } 
 } 
 } 
 @ @ - 81 , 6 + 81 , 30 @ @ object HistoryUtils { 
 } 
 } 
 
 + private [ dialog ] def writeHistoryMessageSelf ( 
 + userId : Int , 
 + toPeer : Peer , 
 + senderUserId : Int , 
 + date : DateTime , 
 + randomId : Long , 
 + messageContentHeader : Int , 
 + messageContentData : Array [ Byte ] 
 + ) ( implicit ec : ExecutionContext ) : DBIO [ Unit ] = { 
 + for { 
 + _ ← HistoryMessageRepo . create ( HistoryMessage ( 
 + userId = userId , 
 + peer = toPeer , 
 + date = date , 
 + senderUserId = senderUserId , 
 + randomId = randomId , 
 + messageContentHeader = messageContentHeader , 
 + messageContentData = messageContentData , 
 + deletedAt = None 
 + ) ) 
 + _ ← DialogRepo . updateLastMessageDate ( userId , toPeer , date ) 
 + } yield ( ) 
 + } 
 + 
 private [ dialog ] def markMessagesReceived ( byPeer : Peer , peer : Peer , date : DateTime ) ( implicit system : ActorSystem , ec : ExecutionContext ) : DBIO [ Unit ] = { 
 requirePrivatePeer ( byPeer ) 
 / / requireDifferentPeers ( byPeer , peer ) 
 @ @ - 89 , 17 + 113 , 17 @ @ object HistoryUtils { 
 case PeerType . Private ⇒ 
 / / TODO : # perf do in single query 
 DBIO . sequence ( Seq ( 
 - persist . DialogRepo . updateLastReceivedAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , 
 - persist . DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , peer , date ) 
 + DialogRepo . updateLastReceivedAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , 
 + DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , peer , date ) 
 ) ) map ( _ ⇒ ( ) ) 
 case PeerType . Group ⇒ 
 withGroup ( peer . id ) { _ ⇒ 
 - persist . GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ 
 + GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ 
 / / TODO : # perf update dialogs in one query 
 
 - val selfAction = persist . DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) 
 + val selfAction = DialogRepo . updateOwnerLastReceivedAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) 
 val otherGroupUserIds = groupUserIds . view . filterNot ( _ = = byPeer . id ) . toSet 
 - val otherAction = persist . DialogRepo . updateLastReceivedAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) 
 + val otherAction = DialogRepo . updateLastReceivedAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) 
 
 selfAction andThen otherAction map ( _ ⇒ ( ) ) 
 } 
 @ @ - 116 , 18 + 140 , 18 @ @ object HistoryUtils { 
 case PeerType . Private ⇒ 
 / / TODO : # perf do in single query 
 DBIO . sequence ( Seq ( 
 - persist . DialogRepo . updateLastReadAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , 
 - persist . DialogRepo . updateOwnerLastReadAt ( byPeer . id , peer , date ) 
 + DialogRepo . updateLastReadAt ( peer . id , Peer ( PeerType . Private , byPeer . id ) , date ) , 
 + DialogRepo . updateOwnerLastReadAt ( byPeer . id , peer , date ) 
 ) ) map ( _ ⇒ ( ) ) 
 case PeerType . Group ⇒ 
 withGroup ( peer . id ) { _ ⇒ 
 - persist . GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ 
 + GroupUserRepo . findUserIds ( peer . id ) flatMap { groupUserIds ⇒ 
 / / TODO : # perf update dialogs in one query 
 
 - val selfAction = persist . DialogRepo . updateOwnerLastReadAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) 
 + val selfAction = DialogRepo . updateOwnerLastReadAt ( byPeer . id , Peer ( PeerType . Group , peer . id ) , date ) 
 
 val otherGroupUserIds = groupUserIds . view . filterNot ( _ = = byPeer . id ) . toSet 
 - val otherAction = persist . DialogRepo . updateLastReadAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) 
 + val otherAction = DialogRepo . updateLastReadAt ( otherGroupUserIds , Peer ( PeerType . Group , peer . id ) , date ) 
 
 selfAction andThen otherAction map ( _ ⇒ ( ) ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index f27b916 . . 733f5f0 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 346 , 8 + 346 , 9 @ @ private [ user ] trait UserCommandHandlers { 
 _ ← userExt . addContact ( contact . ownerUserId , user . id , localName , Some ( phoneNumber ) , None ) 
 _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactRegistered , Some ( s " $ { localName . getOrElse ( user . name ) } registered " ) , isFat = true , deliveryId = None ) 
 _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactsAdded , None , isFat = false , deliveryId = None ) 
 - _ ← dialogExt . writeMessage ( 
 - ApiPeer ( ApiPeerType . Private , contact . ownerUserId ) , 
 + _ ← dialogExt . writeMessageSelf ( 
 + contact . ownerUserId , 
 + ApiPeer ( ApiPeerType . Private , user . id ) , 
 user . id , 
 date , 
 randomId , 
 @ @ - 377 , 8 + 378 , 9 @ @ private [ user ] trait UserCommandHandlers { 
 _ ← userExt . addContact ( contact . ownerUserId , user . id , localName , None , Some ( email ) ) 
 _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactRegistered , Some ( serviceMessage . text ) , isFat = true , deliveryId = None ) 
 _ ← userExt . broadcastUserUpdate ( contact . ownerUserId , updateContactsAdded , None , isFat = false , deliveryId = None ) 
 - _ ← dialogExt . writeMessage ( 
 - ApiPeer ( ApiPeerType . Private , contact . ownerUserId ) , 
 + _ ← dialogExt . writeMessageSelf ( 
 + contact . ownerUserId , 
 + ApiPeer ( ApiPeerType . Private , user . id ) , 
 user . id , 
 date , 
 randomId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 index 337ba36 . . 841b357 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserPeer . scala 
 @ @ - 15 , 7 + 15 , 9 @ @ private [ user ] final class UserPeer ( userId : Int , extensions : Seq [ ApiExtension ] ) e 
 private val selfPeer = Peer . privat ( userId ) 
 
 def receive : Receive = { 
 + / / Forward to a group or a corresponding user dialog 
 case dc : DirectDialogCommand ⇒ dialogRef ( dc ) forward dc 
 + / / Forward to a dest user dialog 
 case dc : DialogCommand ⇒ dialogRef ( dc . dest ) forward dc 
 case other ⇒ context . system . log . debug ( " Unmatched message : { } " , other ) 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala 
 new file mode 100644 
 index 0000000 . . d9bb6c5 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / user / ContactRegisteredSpec . scala 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + package im . actor . server . user 
 + 
 + import im . actor . api . rpc . contacts . UpdateContactRegistered 
 + import im . actor . api . rpc . messaging . _ 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . persist . contact . UnregisteredEmailContactRepo 
 + import im . actor . server . _ 
 + 
 + final class ContactRegisteredSpec extends BaseAppSuite with ImplicitAuthService with ImplicitSessionRegion with MessagingSpecHelpers with SeqUpdateMatchers { 
 + it should " notify ContactRegistered " in notifyContactRegistered ( ) 
 + it should " not create dialog with contacts which receive ContactRegistered " in notCreateDialog ( ) 
 + 
 + private lazy val msgService = MessagingServiceImpl ( ) 
 + 
 + def notifyContactRegistered ( ) = { 
 + val ( alice , bob ) = createUserRegisterContact ( ) 
 + implicit val clientData = alice 
 + 
 + expectUpdate ( classOf [ UpdateContactRegistered ] ) ( _ ⇒ ( ) ) 
 + 
 + Thread . sleep ( 300 ) 
 + 
 + whenReady ( msgService . handleLoadDialogs ( 0 , 100 ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseLoadDialogs ( _ , _ , Vector ( dialog ) ) ) ⇒ 
 + dialog . peer should = = = ( ApiPeer ( ApiPeerType . Private , bob . authData . get . userId ) ) 
 + 
 + inside ( dialog . message ) { 
 + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ 
 + userId should = = = ( bob . authData . get . userId ) 
 + } 
 + } 
 + } 
 + 
 + whenReady ( msgService . handleLoadHistory ( getOutPeer ( bob . authData . get . userId , clientData . authId ) , 0 , 100 ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseLoadHistory ( Vector ( hm ) , _ ) ) ⇒ 
 + inside ( hm . message ) { 
 + case ApiServiceMessage ( _ , Some ( ApiServiceExContactRegistered ( userId ) ) ) ⇒ 
 + userId should = = = ( bob . authData . get . userId ) 
 + } 
 + } 
 + } 
 + } 
 + 
 + def notCreateDialog ( ) = { 
 + val ( alice , bob ) = createUserRegisterContact ( ) 
 + implicit val clientData = bob 
 + 
 + whenReady ( msgService . handleLoadDialogs ( 0 , 100 ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseLoadDialogs ( _ , _ , Vector ( ) ) ) ⇒ 
 + } 
 + } 
 + 
 + whenReady ( msgService . handleLoadHistory ( getOutPeer ( alice . authData . get . userId , bob . authId ) , 0 , 100 ) ) { resp ⇒ 
 + inside ( resp ) { 
 + case Ok ( ResponseLoadHistory ( Vector ( ) , Vector ( ) ) ) ⇒ 
 + } 
 + } 
 + } 
 + 
 + private def createUserRegisterContact ( ) : ( ClientData , ClientData ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val aliceClientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + whenReady ( db . run ( UnregisteredEmailContactRepo . create ( " test @ acme . com " , alice . id , None ) ) ) ( identity ) 
 + 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val bobClientData = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + 
 + whenReady ( UserExtension ( system ) . addEmail ( bob . id , " test @ acme . com " ) ) ( identity ) 
 + 
 + ( aliceClientData , bobClientData ) 
 + } 
 + } 
 \ No newline at end of file
