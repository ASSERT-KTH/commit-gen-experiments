BLEU SCORE: 0.0844991782262014

TEST MSG: fix ( server : tests ) : compilation error
GENERATED MSG: test ( http - api ) : specs for avatar urls

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > index 93f7522 . . 2f485fc 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala < nl > @ @ - 309 , 7 + 309 , 7 @ @ final class HttpApiFrontendSpec < nl > < nl > def groupInvitesOk ( ) = { < nl > val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) < nl > - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > method = HttpMethods . GET , < nl > @ @ - 331 , 12 + 331 , 12 @ @ final class HttpApiFrontendSpec < nl > < nl > whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) ) { result ⇒ < nl > result should matchPattern { case Right ( _ ) ⇒ } < nl > - val avatar = ImageUtils . getAvatarData ( model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > + val avatar = ImageUtils . getAvatarData ( im . actor . server . model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > whenReady ( db . run ( persist . AvatarDataRepo . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) < nl > } < nl > < nl > val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) < nl > - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > @ @ - 372 , 13 + 372 , 13 @ @ final class HttpApiFrontendSpec < nl > whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) ) { result ⇒ < nl > result should matchPattern { case Right ( _ ) ⇒ } < nl > val avatar = < nl > - ImageUtils . getAvatarData ( model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > + ImageUtils . getAvatarData ( im . actor . server . model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > . copy ( smallAvatarFileId = None , smallAvatarFileHash = None , smallAvatarFileSize = None ) < nl > whenReady ( db . run ( persist . AvatarDataRepo . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) < nl > } < nl > < nl > val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) < nl > - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ < nl > val request = HttpRequest ( < nl > method = HttpMethods . GET ,
NEAREST DIFF (one line): diff - - git a / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > index 70df684 . . 08605eb 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala < nl > @ @ - 1 , 7 + 1 , 10 @ @ < nl > package im . actor . server . http < nl > < nl > + import java . nio . file . Paths < nl > + < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > + import org . scalatest . Inside . _ < nl > import akka . http . scaladsl . Http < nl > import akka . http . scaladsl . model . { HttpMethods , HttpRequest , StatusCodes } < nl > import akka . util . ByteString < nl > @ @ - 11 , 13 + 14 , 14 @ @ import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient < nl > import play . api . libs . json . _ < nl > < nl > import im . actor . api . rpc . ClientData < nl > + import im . actor . server . api . http . json . { JsonImplicits , AvatarUrls } < nl > import im . actor . server . api . http . { HttpApiConfig , HttpApiFrontend } < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . { GroupsServiceHelpers , messaging } < nl > import im . actor . server . peermanagers . { GroupPeerManager , PrivatePeerManager } < nl > import im . actor . server . presences . { GroupPresenceManager , PresenceManager } < nl > import im . actor . server . social . SocialManager < nl > - import im . actor . server . util . ACLUtils < nl > + import im . actor . server . util . { ImageUtils , FileUtils , ACLUtils } < nl > import im . actor . server . { BaseAppSuite , models , persist } < nl > < nl > class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > @ @ - 31 , 6 + 35 , 10 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > < nl > it should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) < nl > < nl > + it should " respond with JSON message with avatar full links to group invite info with correct invite token " in t . groupInvitesAvatars1 ( ) < nl > + < nl > + it should " respond with JSON message with avatar partial links to group invite info with correct invite token " in t . groupInvitesAvatars2 ( ) < nl > + < nl > it should " respond with Not Acceptable to group invite info with invalid invite token " in t . groupInvitesInvalid ( ) < nl > < nl > it should " respond BadRequest " in t . malformedMessage ( ) < nl > @ @ - 147 , 6 + 155 , 80 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { < nl > } < nl > } < nl > < nl > + def groupInvitesAvatars1 ( ) = { < nl > + val avatarFile = Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) . toFile < nl > + val fileLocation = whenReady ( db . run ( FileUtils . uploadFile ( bucketName , " avatar " , avatarFile ) ) ) ( identity ) < nl > + whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) , bucketName ) ) ) { result ⇒ < nl > + result should matchPattern { case Right ( _ ) ⇒ } < nl > + val avatar = ImageUtils . getAvatarData ( models . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > + whenReady ( db . run ( persist . AvatarData . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > + val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) < nl > + val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > + whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ < nl > + val request = HttpRequest ( < nl > + method = HttpMethods . GET , < nl > + uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " < nl > + ) < nl > + val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + resp . status shouldEqual StatusCodes . OK < nl > + whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > + import JsonImplicits . avatarUrlsFormat < nl > + < nl > + val response = Json . parse ( body ) < nl > + ( response \ " groupTitle " ) . as [ String ] shouldEqual groupName < nl > + ( response \ " inviterName " ) . as [ String ] shouldEqual user1 . name < nl > + val avatarUrls = ( response \ " groupAvatars " ) . as [ AvatarUrls ] < nl > + inside ( avatarUrls ) { < nl > + case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ < nl > + List ( small , large , full ) foreach ( _ should startWith ( s " https : / / $ bucketName . s3 . amazonaws . com " ) ) < nl > + } < nl > + ( response \ " inviterAvatars " ) . as [ AvatarUrls ] should matchPattern { < nl > + case AvatarUrls ( None , None , None ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def groupInvitesAvatars2 ( ) = { < nl > + val avatarFile = Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) . toFile < nl > + val fileLocation = whenReady ( db . run ( FileUtils . uploadFile ( bucketName , " avatar " , avatarFile ) ) ) ( identity ) < nl > + whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) , bucketName ) ) ) { result ⇒ < nl > + result should matchPattern { case Right ( _ ) ⇒ } < nl > + val avatar = < nl > + ImageUtils . getAvatarData ( models . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) < nl > + . copy ( smallAvatarFileId = None , smallAvatarFileHash = None , smallAvatarFileSize = None ) < nl > + whenReady ( db . run ( persist . AvatarData . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > + val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) < nl > + val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) < nl > + whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ < nl > + val request = HttpRequest ( < nl > + method = HttpMethods . GET , < nl > + uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " < nl > + ) < nl > + val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) < nl > + resp . status shouldEqual StatusCodes . OK < nl > + whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ < nl > + import JsonImplicits . avatarUrlsFormat < nl > + < nl > + val response = Json . parse ( body ) < nl > + ( response \ " groupTitle " ) . as [ String ] shouldEqual groupName < nl > + ( response \ " inviterName " ) . as [ String ] shouldEqual user1 . name < nl > + val avatarUrls = ( response \ " groupAvatars " ) . as [ AvatarUrls ] < nl > + inside ( avatarUrls ) { < nl > + case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ < nl > + List ( large , full ) foreach ( _ should startWith ( s " https : / / $ bucketName . s3 . amazonaws . com " ) ) < nl > + } < nl > + ( response \ " inviterAvatars " ) . as [ AvatarUrls ] should matchPattern { < nl > + case AvatarUrls ( None , None , None ) ⇒ < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > def groupInvitesInvalid ( ) = { < nl > val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " < nl > val request = HttpRequest (

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 index 93f7522 . . 2f485fc 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / http / HttpApiFrontendSpec . scala 
 @ @ - 309 , 7 + 309 , 7 @ @ final class HttpApiFrontendSpec 
 
 def groupInvitesOk ( ) = { 
 val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) 
 - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 method = HttpMethods . GET , 
 @ @ - 331 , 12 + 331 , 12 @ @ final class HttpApiFrontendSpec 
 
 whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) ) { result ⇒ 
 result should matchPattern { case Right ( _ ) ⇒ } 
 - val avatar = ImageUtils . getAvatarData ( model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 + val avatar = ImageUtils . getAvatarData ( im . actor . server . model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 whenReady ( db . run ( persist . AvatarDataRepo . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) 
 } 
 
 val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) 
 - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 @ @ - 372 , 13 + 372 , 13 @ @ final class HttpApiFrontendSpec 
 whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) ) ) ) { result ⇒ 
 result should matchPattern { case Right ( _ ) ⇒ } 
 val avatar = 
 - ImageUtils . getAvatarData ( model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 + ImageUtils . getAvatarData ( im . actor . server . model . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 . copy ( smallAvatarFileId = None , smallAvatarFileHash = None , smallAvatarFileSize = None ) 
 whenReady ( db . run ( persist . AvatarDataRepo . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) 
 } 
 
 val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) 
 - val inviteToken = model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 + val inviteToken = im . actor . server . model . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 whenReady ( db . run ( persist . GroupInviteTokenRepo . create ( inviteToken ) ) ) { _ ⇒ 
 val request = HttpRequest ( 
 method = HttpMethods . GET ,

NEAREST DIFF:
diff - - git a / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala b / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 index 70df684 . . 08605eb 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / http / HttpApiFrontendSpec . scala 
 @ @ - 1 , 7 + 1 , 10 @ @ 
 package im . actor . server . http 
 
 + import java . nio . file . Paths 
 + 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 + import org . scalatest . Inside . _ 
 import akka . http . scaladsl . Http 
 import akka . http . scaladsl . model . { HttpMethods , HttpRequest , StatusCodes } 
 import akka . util . ByteString 
 @ @ - 11 , 13 + 14 , 14 @ @ import com . github . dwhjames . awswrap . s3 . AmazonS3ScalaClient 
 import play . api . libs . json . _ 
 
 import im . actor . api . rpc . ClientData 
 + import im . actor . server . api . http . json . { JsonImplicits , AvatarUrls } 
 import im . actor . server . api . http . { HttpApiConfig , HttpApiFrontend } 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . { GroupsServiceHelpers , messaging } 
 import im . actor . server . peermanagers . { GroupPeerManager , PrivatePeerManager } 
 import im . actor . server . presences . { GroupPresenceManager , PresenceManager } 
 import im . actor . server . social . SocialManager 
 - import im . actor . server . util . ACLUtils 
 + import im . actor . server . util . { ImageUtils , FileUtils , ACLUtils } 
 import im . actor . server . { BaseAppSuite , models , persist } 
 
 class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 @ @ - 31 , 6 + 35 , 10 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 
 it should " respond with JSON message to group invite info with correct invite token " in t . groupInvitesOk ( ) 
 
 + it should " respond with JSON message with avatar full links to group invite info with correct invite token " in t . groupInvitesAvatars1 ( ) 
 + 
 + it should " respond with JSON message with avatar partial links to group invite info with correct invite token " in t . groupInvitesAvatars2 ( ) 
 + 
 it should " respond with Not Acceptable to group invite info with invalid invite token " in t . groupInvitesInvalid ( ) 
 
 it should " respond BadRequest " in t . malformedMessage ( ) 
 @ @ - 147 , 6 + 155 , 80 @ @ class HttpApiFrontendSpec extends BaseAppSuite with GroupsServiceHelpers { 
 } 
 } 
 
 + def groupInvitesAvatars1 ( ) = { 
 + val avatarFile = Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) . toFile 
 + val fileLocation = whenReady ( db . run ( FileUtils . uploadFile ( bucketName , " avatar " , avatarFile ) ) ) ( identity ) 
 + whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) , bucketName ) ) ) { result ⇒ 
 + result should matchPattern { case Right ( _ ) ⇒ } 
 + val avatar = ImageUtils . getAvatarData ( models . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 + whenReady ( db . run ( persist . AvatarData . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) 
 + } 
 + 
 + val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) 
 + val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 + whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ 
 + val request = HttpRequest ( 
 + method = HttpMethods . GET , 
 + uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " 
 + ) 
 + val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + resp . status shouldEqual StatusCodes . OK 
 + whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 + import JsonImplicits . avatarUrlsFormat 
 + 
 + val response = Json . parse ( body ) 
 + ( response \ " groupTitle " ) . as [ String ] shouldEqual groupName 
 + ( response \ " inviterName " ) . as [ String ] shouldEqual user1 . name 
 + val avatarUrls = ( response \ " groupAvatars " ) . as [ AvatarUrls ] 
 + inside ( avatarUrls ) { 
 + case AvatarUrls ( Some ( small ) , Some ( large ) , Some ( full ) ) ⇒ 
 + List ( small , large , full ) foreach ( _ should startWith ( s " https : / / $ bucketName . s3 . amazonaws . com " ) ) 
 + } 
 + ( response \ " inviterAvatars " ) . as [ AvatarUrls ] should matchPattern { 
 + case AvatarUrls ( None , None , None ) ⇒ 
 + } 
 + } 
 + } 
 + } 
 + 
 + def groupInvitesAvatars2 ( ) = { 
 + val avatarFile = Paths . get ( getClass . getResource ( " / valid - avatar . jpg " ) . toURI ) . toFile 
 + val fileLocation = whenReady ( db . run ( FileUtils . uploadFile ( bucketName , " avatar " , avatarFile ) ) ) ( identity ) 
 + whenReady ( db . run ( ImageUtils . scaleAvatar ( fileLocation . fileId , ThreadLocalRandom . current ( ) , bucketName ) ) ) { result ⇒ 
 + result should matchPattern { case Right ( _ ) ⇒ } 
 + val avatar = 
 + ImageUtils . getAvatarData ( models . AvatarData . OfGroup , groupOutPeer . groupId , result . right . toOption . get ) 
 + . copy ( smallAvatarFileId = None , smallAvatarFileHash = None , smallAvatarFileSize = None ) 
 + whenReady ( db . run ( persist . AvatarData . createOrUpdate ( avatar ) ) ) ( _ ⇒ ( ) ) 
 + } 
 + 
 + val token = ACLUtils . accessToken ( ThreadLocalRandom . current ( ) ) 
 + val inviteToken = models . GroupInviteToken ( groupOutPeer . groupId , user1 . id , token ) 
 + whenReady ( db . run ( persist . GroupInviteToken . create ( inviteToken ) ) ) { _ ⇒ 
 + val request = HttpRequest ( 
 + method = HttpMethods . GET , 
 + uri = s " http : / / $ { config . interface } : $ { config . port } / v1 / groups / invites / $ token " 
 + ) 
 + val resp = whenReady ( http . singleRequest ( request ) ) ( identity ) 
 + resp . status shouldEqual StatusCodes . OK 
 + whenReady ( resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) . map ( _ . decodeString ( " utf - 8 " ) ) ) { body ⇒ 
 + import JsonImplicits . avatarUrlsFormat 
 + 
 + val response = Json . parse ( body ) 
 + ( response \ " groupTitle " ) . as [ String ] shouldEqual groupName 
 + ( response \ " inviterName " ) . as [ String ] shouldEqual user1 . name 
 + val avatarUrls = ( response \ " groupAvatars " ) . as [ AvatarUrls ] 
 + inside ( avatarUrls ) { 
 + case AvatarUrls ( None , Some ( large ) , Some ( full ) ) ⇒ 
 + List ( large , full ) foreach ( _ should startWith ( s " https : / / $ bucketName . s3 . amazonaws . com " ) ) 
 + } 
 + ( response \ " inviterAvatars " ) . as [ AvatarUrls ] should matchPattern { 
 + case AvatarUrls ( None , None , None ) ⇒ 
 + } 
 + } 
 + } 
 + } 
 + 
 def groupInvitesInvalid ( ) = { 
 val invalidToken = " Dkajsdljasdlkjaskdj329u90u32jdjlksRandom _ stuff " 
 val request = HttpRequest (
