BLEU SCORE: 0.021476912089159066

TEST MSG: refactor ( server : messaging ) : eventsoursed counter ( service messages still don ' t count )
GENERATED MSG: Merge commit ' 8123e8c970ae311aa02d4c9e0196dbfb802e15a6 '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index ba67e8b . . dab5dcf 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 20 , 6 + 20 , 16 @ @ message DialogRootEvents { < nl > } < nl > } < nl > < nl > + message DialogRootQueries { < nl > + message GetCounter { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootQuery " ; < nl > + } < nl > + < nl > + message GetCounterResponse { < nl > + required int32 counter = 1 ; < nl > + } < nl > + } < nl > + < nl > message DialogCommands { < nl > < nl > message Envelope { < nl > @ @ - 173 , 4 + 183 , 34 @ @ message DialogCommands { < nl > } < nl > < nl > message UpdateCountersAck { } < nl > + } < nl > + < nl > + message DialogQueries { < nl > + message GetApiStruct { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogQuery " ; < nl > + } < nl > + < nl > + message GetCounter { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogQuery " ; < nl > + } < nl > + < nl > + message GetCounterResponse { < nl > + required int32 counter = 1 ; < nl > + } < nl > + } < nl > + < nl > + message DialogEvents { < nl > + message NewMessage { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + < nl > + required int64 random _ id = 2 ; < nl > + required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + required bool is _ incoming = 3 ; < nl > + } < nl > + < nl > + message MessagesRead { < nl > + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; < nl > + < nl > + required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto < nl > index fd139ff . . 7118e40 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / user . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / user . proto < nl > @ @ - 12 , 6 + 12 , 7 @ @ import " scalapb / scalapb . proto " ; < nl > import " sequence . proto " ; < nl > import " file . proto " ; < nl > import " bots . proto " ; < nl > + import " dialog . proto " ; < nl > < nl > message UserState { < nl > option ( scalapb . message ) . extends = " im . actor . server . office . ProcessorState " ; < nl > @ @ - 330 , 6 + 331 , 13 @ @ message UserQueries { < nl > } < nl > } < nl > < nl > + message DialogRootEnvelope { < nl > + required int32 user _ id = 1 ; < nl > + oneof query { < nl > + DialogRootQueries . GetCounter get _ counter = 2 ; < nl > + } < nl > + } < nl > + < nl > message UserEvents { < nl > message AuthAdded { < nl > option ( scalapb . message ) . extends = " im . actor . server . user . UserEvent " ; < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > index 3940ca1 . . 31f9933 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala < nl > @ @ - 54 , 4 + 54 , 6 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist < nl > protected def reply ( msg : AnyRef ) : Unit = sender ( ) ! msg < nl > < nl > protected def replyFuture ( msgFuture : Future [ Any ] ) : Unit = msgFuture pipeTo sender ( ) < nl > + < nl > + protected def setState ( state : S ) = this . _ state = state < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 68ca482 . . 0942b94 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 25 , 45 + 25 , 50 @ @ import scala . util . Failure < nl > trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > this : DialogProcessor ⇒ < nl > < nl > + import DialogEvents . _ < nl > + import DialogEventsObsolete . _ < nl > + < nl > import DialogCommands . _ < nl > import DialogEvents . _ < nl > < nl > protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > - withCreated ( s ) { state ⇒ < nl > - becomeStashing ( replyTo ⇒ ( { < nl > - case seq : SeqStateDate ⇒ < nl > + becomeStashing ( replyTo ⇒ ( { < nl > + case seq : SeqStateDate ⇒ < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , isIncoming = false ) ) { e ⇒ < nl > + commit ( e ) < nl > replyTo ! seq < nl > if ( state . isArchived ) { < nl > self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > updateMessageDate ( state , seq . date ) < nl > unstashAll ( ) < nl > - case fail : Status . Failure ⇒ < nl > - log . error ( fail . cause , " Failed to send message " ) < nl > - replyTo forward fail < nl > - context unbecome ( ) < nl > - unstashAll ( ) < nl > - } : Receive ) orElse reactions ( state ) , discardOld = false ) < nl > - < nl > - withValidAccessHash ( sm . dest , sm . senderAuthId , sm . accessHash ) { < nl > - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > - val sendDate = calcSendDate ( state ) < nl > - val message = sm . message < nl > - PubSubExtension ( system ) . publish ( PeerMessage ( sm . origin , sm . dest , sm . randomId , sendDate , message ) ) < nl > - < nl > - withNonBlockedPeer [ SeqStateDate ] ( userId , sm . dest ) ( < nl > - default = for { < nl > - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) < nl > - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - _ = dialogExt . updateCounters ( peer , userId ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sendDate ) , < nl > - failed = for { < nl > - _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sendDate ) < nl > - ) < nl > + context . become ( receiveCommand ) < nl > } < nl > + case fail : Status . Failure ⇒ < nl > + log . error ( fail . cause , " Failed to send message " ) < nl > + replyTo forward fail < nl > + context . become ( receiveCommand ) < nl > + unstashAll ( ) < nl > + } : Receive ) orElse reactions ( state ) , discardOld = true ) < nl > + < nl > + withValidAccessHash ( sm . dest , sm . senderAuthId , sm . accessHash ) { < nl > + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > + val sendDate = calcSendDate ( state ) < nl > + val message = sm . message < nl > + PubSubExtension ( system ) . publish ( PeerMessage ( sm . origin , sm . dest , sm . randomId , sendDate , message ) ) < nl > + < nl > + withNonBlockedPeer [ SeqStateDate ] ( userId , sm . dest ) ( < nl > + default = for { < nl > + _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) < nl > + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + _ = dialogExt . updateCounters ( peer , userId ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sendDate ) , < nl > + failed = for { < nl > + _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sendDate ) < nl > + ) < nl > } < nl > } < nl > } < nl > @ @ - 74 , 9 + 79 , 14 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > . pipeTo ( sender ( ) ) < nl > } < nl > < nl > - protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = < nl > - withCreated ( s ) { state ⇒ < nl > - val messageDate = sm . date getOrElse { throw new RuntimeException ( " No message date found in SendMessage " ) } < nl > + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > + val messageDate = sm . date getOrElse { < nl > + throw new RuntimeException ( " No message date found in SendMessage " ) < nl > + } < nl > + < nl > + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate ) , isIncoming = true ) ) { e ⇒ < nl > + commit ( e ) < nl > + < nl > if ( peer . typ = = PeerType . Private ) { < nl > SocialManager . recordRelation ( sm . origin . id , userId ) < nl > SocialManager . recordRelation ( userId , sm . origin . id ) < nl > @ @ - 87 , 28 + 97 , 30 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > . pipeTo ( sender ( ) ) onSuccess { < nl > case _ ⇒ < nl > - if ( state . isArchived ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + if ( state . isArchived ) { < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > } < nl > } < nl > + } < nl > < nl > protected def writeMessage ( < nl > s : DialogState , < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = < nl > - withCreated ( s ) { _ ⇒ < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > - db . run ( writeHistoryMessage ( < nl > - selfPeer , < nl > - peer , < nl > - date , < nl > - randomId , < nl > - message . header , < nl > - message . toByteArray < nl > - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + ) : Unit = { < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + db . run ( writeHistoryMessage ( < nl > + selfPeer , < nl > + peer , < nl > + date , < nl > + randomId , < nl > + message . header , < nl > + message . toByteArray < nl > + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def writeMessageSelf ( < nl > s : DialogState , < nl > @ @ - 116 , 17 + 128 , 16 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = < nl > - withCreated ( s ) { _ ⇒ < nl > - val result = < nl > - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > - } else { < nl > - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > - } < nl > + ) : Unit = { < nl > + val result = < nl > + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > + } else { < nl > + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) < nl > + } < nl > < nl > - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > val mustReceive = mustMakeReceive ( state , mr ) < nl > @ @ - 360 , 25 + 371 , 25 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { < nl > ( mr . date > state . lastReadDate ) & & ( mr . date < = mr . now | | mr . date < = state . lastMessageDate ) < nl > < nl > protected def updateMessageDate ( state : DialogState , date : Long ) : Unit = < nl > - context become initialized ( state . updated ( LastMessageDate ( date ) ) ) < nl > + commit ( LastMessageDate ( date ) ) < nl > < nl > private def updateReceiveDate ( state : DialogState , date : Long ) : Unit = < nl > - context become initialized ( state . updated ( LastReceiveDate ( date ) ) ) < nl > + commit ( LastReceiveDate ( date ) ) < nl > < nl > private def updateReadDate ( state : DialogState , date : Long ) : Unit = < nl > - context become initialized ( state . updated ( LastReadDate ( date ) ) ) < nl > + commit ( LastReadDate ( date ) ) < nl > < nl > private def updateArchived ( state : DialogState ) : Unit = < nl > - context become initialized ( state . updated ( Archived ) ) < nl > + commit ( Archived ) < nl > < nl > private def updateShown ( state : DialogState ) : Unit = < nl > - context become initialized ( state . updated ( Shown ) ) < nl > + commit ( Shown ) < nl > < nl > private def updateFavourited ( state : DialogState ) : Unit = < nl > - context become initialized ( state . updated ( Favourited ) ) < nl > + commit ( Favourited ) < nl > < nl > private def updateUnfavourited ( state : DialogState ) : Unit = < nl > - context become initialized ( state . updated ( Unfavourited ) ) < nl > + commit ( Unfavourited ) < nl > < nl > / * * < nl > * check access hash and execute ` f ` , if access hash is valid < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index bf11096 . . a8eddbd 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . server . persist . messaging . ReactionEventRepo < nl > import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . pubsub . { PeerMessage , PubSubExtension } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > - import im . actor . server . user . UserExtension < nl > + import im . actor . server . user . { DialogRootEnvelope , UserExtension } < nl > import im . actor . types . _ < nl > import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > @ @ - 246 , 7 + 246 , 10 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } < nl > } < nl > < nl > - def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = HistoryMessageRepo . getUnreadTotal ( userId ) < nl > + def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = < nl > + DBIO . from ( < nl > + ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetCounter ( DialogRootQueries . GetCounter ( ) ) ) . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) < nl > + ) < nl > < nl > def getUnreadCount ( clientUserId : Int , historyOwner : Int , peer : Peer , ownerLastReadAt : DateTime ) : DBIO [ Int ] = { < nl > if ( isSharedUser ( historyOwner ) ) { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index d7eb024 . . 420dc93 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 1 , 32 + 1 , 34 @ @ < nl > package im . actor . server . dialog < nl > < nl > + import java . time . Instant < nl > + < nl > import akka . actor . _ < nl > - import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . misc . ApiExtension < nl > - import im . actor . concurrent . { ActorFutures , StashingActor , AlertingActor } < nl > + import im . actor . concurrent . { ActorFutures , AlertingActor , StashingActor } < nl > import im . actor . serialization . ActorSerializer < nl > - import im . actor . server . cqrs . ProcessorState < nl > + import im . actor . server . cqrs . _ < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . group . GroupExtension < nl > - import im . actor . server . model . { DialogObsolete ⇒ DialogModel , PeerType , Peer } < nl > - import im . actor . server . persist . dialog . DialogRepo < nl > - import im . actor . server . persist . { GroupRepo , UserRepo } < nl > - import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } < nl > + import im . actor . server . model . { Peer , DialogObsolete ⇒ DialogModel } < nl > + import im . actor . server . sequence . { SeqStateDate , SeqUpdatesExtension } < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > - import org . joda . time . DateTime < nl > - import slick . dbio . DBIO < nl > import slick . driver . PostgresDriver . api . Database < nl > < nl > + import scala . collection . immutable < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > - private [ dialog ] sealed trait DialogEvent < nl > + private [ dialog ] trait DialogEvent extends TaggedEvent { < nl > + override def tags : Set [ String ] = Set ( " dialog " ) < nl > + } < nl > + < nl > + trait DialogQuery < nl > < nl > - object DialogEvents { < nl > + object DialogEventsObsolete { < nl > < nl > private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent < nl > < nl > @ @ - 40 , 7 + 42 , 6 @ @ object DialogEvents { < nl > < nl > private [ dialog ] case object Favourited extends DialogEvent < nl > private [ dialog ] case object Unfavourited extends DialogEvent < nl > - < nl > } < nl > < nl > private [ dialog ] object DialogState { < nl > @ @ - 50 , 29 + 51 , 53 @ @ private [ dialog ] object DialogState { < nl > lastReadDate : Long , < nl > isFavourite : Boolean , < nl > isCreated : Boolean , < nl > - isArchived : Boolean < nl > - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isFavourite , isCreated , isArchived ) < nl > + isArchived : Boolean , < nl > + counter : Int < nl > + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isFavourite , isCreated , isArchived , counter , immutable . SortedSet . empty ( UnreadMessage . ordering ) ) < nl > < nl > - def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = < nl > + def fromModel ( model : DialogModel , isCreated : Boolean , counter : Int ) : DialogState = < nl > DialogState ( < nl > model . lastMessageDate . getMillis , < nl > model . ownerLastReceivedAt . getMillis , < nl > model . ownerLastReadAt . getMillis , < nl > model . isFavourite , < nl > isCreated = isCreated , < nl > - isArchived = model . archivedAt . isDefined < nl > + isArchived = model . archivedAt . isDefined , < nl > + counter , < nl > + immutable . SortedSet . empty ( UnreadMessage . ordering ) < nl > ) < nl > } < nl > < nl > + private object UnreadMessage { < nl > + val ordering = new Ordering [ UnreadMessage ] { < nl > + override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = < nl > + if ( x . date . isBefore ( y . date ) ) - 1 < nl > + else if ( x . date . isAfter ( y . date ) ) 1 < nl > + else 0 < nl > + } < nl > + } < nl > + < nl > + private case class UnreadMessage ( date : Instant , randomId : Long ) { < nl > + override def hashCode ( ) : Int = randomId . hashCode ( ) < nl > + < nl > + override def equals ( obj : scala . Any ) : Boolean = obj match { < nl > + case um : UnreadMessage ⇒ randomId = = um . randomId < nl > + case _ ⇒ false < nl > + } < nl > + } < nl > + < nl > private [ dialog ] final case class DialogState ( < nl > lastMessageDate : Long , / / we don ' t use it now anywhere . should we remove it ? < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isFavourite : Boolean , < nl > isCreated : Boolean , < nl > - isArchived : Boolean < nl > + isArchived : Boolean , < nl > + counter : Int , < nl > + unreadMessages : immutable . SortedSet [ UnreadMessage ] < nl > ) extends ProcessorState [ DialogState , DialogEvent ] { < nl > import DialogEvents . _ < nl > + import DialogEventsObsolete . _ < nl > override def updated ( e : DialogEvent ) : DialogState = e match { < nl > case LastMessageDate ( date ) if date > this . lastMessageDate ⇒ this . copy ( lastMessageDate = date ) < nl > case LastReceiveDate ( date ) if date > this . lastReceiveDate ⇒ this . copy ( lastReceiveDate = date ) < nl > @ @ - 81 , 6 + 106 , 13 @ @ private [ dialog ] final case class DialogState ( < nl > case Archived ⇒ this . copy ( isArchived = true ) < nl > case Favourited ⇒ this . copy ( isFavourite = true ) < nl > case Unfavourited ⇒ this . copy ( isFavourite = false ) < nl > + case NewMessage ( randomId , date , isIncoming ) ⇒ < nl > + if ( isIncoming ) { < nl > + this . copy ( counter = counter + 1 , unreadMessages = unreadMessages + UnreadMessage ( date , randomId ) ) < nl > + } else this < nl > + case MessagesRead ( date ) ⇒ < nl > + val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) < nl > + this . copy ( counter = newUnreadMessages . size , unreadMessages = newUnreadMessages ) < nl > case _ ⇒ this < nl > } < nl > } < nl > @ @ - 105 , 14 + 137 , 17 @ @ object DialogProcessor { < nl > def props ( userId : Int , peer : Peer , extensions : Seq [ ApiExtension ] ) : Props = < nl > Props ( classOf [ DialogProcessor ] , userId , peer , extensions ) < nl > < nl > + private [ dialog ] def persistenceId ( peer : Peer ) = s " Dialog _ $ { peer . typ . index } _ $ { peer . id } " < nl > } < nl > < nl > private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , extensions : Seq [ ApiExtension ] ) < nl > - extends AlertingActor < nl > + extends Processor [ DialogState , DialogEvent ] < nl > + with AlertingActor < nl > with DialogCommandHandlers < nl > with ActorFutures < nl > with StashingActor { < nl > import DialogCommands . _ < nl > + import DialogQueries . _ < nl > import DialogProcessor . _ < nl > < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > @ @ - 133 , 20 + 168 , 15 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = < nl > createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > < nl > - override def preStart ( ) = init ( ) < nl > + override def persistenceId : String = DialogProcessor . persistenceId ( peer ) < nl > < nl > - def receive = initializing < nl > + override protected def getInitialState : DialogState = DialogState ( 0 , 0 , 0 , false , false , false , 0 , immutable . SortedSet . empty ( UnreadMessage . ordering ) ) < nl > < nl > - def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > - case state : DialogState ⇒ < nl > - context become initialized ( state ) < nl > - unstashAll ( ) < nl > - case Status . Failure ( cause ) ⇒ < nl > - log . error ( cause , " Failed to init dialog " ) < nl > - self ! Kill < nl > - } ) < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > + case GetCounter ( ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) < nl > + } < nl > < nl > - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) < nl > + override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > def reactions ( state : DialogState ) : Receive = { < nl > @ @ - 158 , 7 + 188 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > - / / when receiving this messages , dialog required to take action < nl > + / / when receiving this messages , dialog is required to take an action < nl > def actions ( state : DialogState ) : Receive = { < nl > case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages < nl > @ @ - 199 , 44 + 229 , 4 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * @ return does dialog owner accepts this command < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > - < nl > - private def init ( ) : Unit = { < nl > - ( for { < nl > - optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) < nl > - initState ← optDialog match { < nl > - case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) < nl > - case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) < nl > - } < nl > - } yield initState ) pipeTo self < nl > - } < nl > - < nl > - protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { < nl > - if ( state . isCreated ) f ( state ) < nl > - else { < nl > - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > - val replyTo = sender ( ) < nl > - < nl > - db . run ( for { < nl > - exists ← peer . ` type ` match { < nl > - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > - } < nl > - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) < nl > - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > - } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) < nl > - < nl > - becomeStashing ( replyTo ⇒ { < nl > - case state : DialogState ⇒ < nl > - context become initialized ( state ) < nl > - unstashAll ( ) < nl > - f ( state ) < nl > - case Status . Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to create dialog " ) < nl > - self ! Kill < nl > - } , discardOld = true ) < nl > - } < nl > - } < nl > - < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index fc4b47c . . f452074 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 3 , 11 + 3 , 15 @ @ package im . actor . server . dialog < nl > import java . time . Instant < nl > < nl > import akka . actor . { ActorRef , Props } < nl > + import akka . pattern . ask < nl > + import akka . util . Timeout < nl > + import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > import im . actor . server . dialog . DialogCommands . SendMessage < nl > import im . actor . server . model . { Peer , PeerType } < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . misc . ApiExtension < nl > + import im . actor . config . ActorConfig < nl > < nl > import scala . concurrent . Future < nl > < nl > @ @ - 53 , 6 + 57 , 10 @ @ object DialogRoot { < nl > < nl > private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Processor [ DialogRootState , DialogRootEvent ] { < nl > import DialogRootEvents . _ < nl > + import DialogRootQueries . _ < nl > + import context . dispatcher < nl > + < nl > + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > < nl > private val selfPeer : Peer = Peer . privat ( userId ) < nl > < nl > @ @ - 60 , 7 + 68 , 16 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , Set . empty , Set . empty ) < nl > < nl > - override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = PartialFunction . empty < nl > + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > + case GetCounter ( ) ⇒ < nl > + val refs = state . activePeers . toSeq map dialogRef < nl > + < nl > + for { < nl > + counters ← FutureExt . ftraverse ( refs ) { ref ⇒ < nl > + ( ref ? DialogQueries . GetCounter ( ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) < nl > + } < nl > + } yield GetCounterResponse ( counters . sum ) < nl > + } < nl > < nl > override protected def handleCommand : Receive = { < nl > case sm : SendMessage ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > index f517d23 . . 9df98f2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala < nl > @ @ - 11 , 7 + 11 , 7 @ @ import im . actor . serialization . ActorSerializer < nl > import im . actor . server . bots . BotCommand < nl > import im . actor . server . cqrs . TaggedEvent < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . { DialogCommand , DialogExtension , DialogRoot } < nl > + import im . actor . server . dialog . _ < nl > import im . actor . server . office . { PeerProcessor , StopOffice } < nl > import im . actor . server . sequence . SeqUpdatesExtension < nl > import im . actor . server . social . { SocialExtension , SocialManagerRegion } < nl > @ @ - 245 , 6 + 245 , 8 @ @ private [ user ] final class UserProcessor < nl > case StopOffice ⇒ context stop self < nl > case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) < nl > case dc : DialogCommand ⇒ dialogRoot ( state . internalExtensions ) forward dc < nl > + case dq : DialogQuery ⇒ dialogRoot ( state . internalExtensions ) forward dq < nl > + case drq : DialogRootQuery ⇒ dialogRoot ( state . internalExtensions ) forward drq < nl > } < nl > < nl > override protected def handleQuery ( state : UserState ) : Receive = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > index 28319df . . c475692 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala < nl > @ @ - 26 , 6 + 26 , 8 @ @ object UserProcessorRegion { < nl > } < nl > case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > } < nl > + case e @ DialogRootEnvelope ( userId , query ) ⇒ < nl > + ( userId . toString , e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( query . number ) ) ) < nl > } < nl > } < nl > < nl > @ @ - 36 , 6 + 38 , 7 @ @ object UserProcessorRegion { < nl > case Peer ( PeerType . Private , userId ) ⇒ ( userId % 100 ) . toString < nl > case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) < nl > } < nl > + case DialogRootEnvelope ( userId , query ) ⇒ ( userId % 100 ) . toString < nl > } < nl > < nl > val typeName = " UserProcessor " < nl > diff - - git a / actor - server / actor - models / src / main / protobuf / model . proto b / actor - server / actor - models / src / main / protobuf / model . proto < nl > index a296bea . . 3fa66af 100644 < nl > - - - a / actor - server / actor - models / src / main / protobuf / model . proto < nl > + + + b / actor - server / actor - models / src / main / protobuf / model . proto < nl > @ @ - 83 , 4 + 83 , 5 @ @ message DeviceFeature { < nl > int64 auth _ id = 1 ; < nl > string name = 2 ; < nl > bytes args = 3 ; < nl > - } < nl > \ No newline at end of file < nl > + } < nl > + < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala < nl > index dd3a69c . . 78c39d4 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala < nl > @ @ - 43 , 10 + 43 , 8 @ @ final class GlobalCountersSpec < nl > { < nl > implicit val clientData = aliceClientData < nl > < nl > - / / make sure that own messages does not count < nl > - for ( i ← 1 to 15 ) { < nl > - sendMessageToGroup ( groupPeer . groupId , textMessage ( s " Hello back $ i " ) ) < nl > - } < nl > + / / make sure that own messages don ' t count < nl > + sendMessageToGroup ( groupPeer . groupId , textMessage ( s " Hello back " ) ) < nl > < nl > expectUpdate ( classOf [ UpdateCountersChanged ] ) { upd ⇒ < nl > / / 2 initializing messages and 10 messages from bob
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index 641806f . . 71c4080 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > < nl > for { < nl > - senderName ← userExt . getName ( receiverUserId , senderUserId ) < nl > + senderName ← userExt . getName ( senderUserId , receiverUserId ) < nl > pushText ← getPushText ( peer , receiverUserId , senderName , message ) < nl > _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > receiverUserId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 4181a2e . . 3230c26 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > + import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > import slick . driver . PostgresDriver . api . Database < nl > @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > - val dialog = DialogModel ( userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b45cc33 . . d2c2ddb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > throw e < nl > } ) pipeTo sender ( ) < nl > sendFuture onSuccess { < nl > - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) < nl > + case SeqStateDate ( _ , _ , date ) ⇒ < nl > + self ! LastOwnMessageDate ( date ) < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > } < nl > < nl > @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > deliveryExt < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > + < nl > val future = < nl > ( for { < nl > _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 55230de . . 01a8d62 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + sealed trait DialogGroup { < nl > + def key : String < nl > + def title : String < nl > + } < nl > + < nl > + object DialogGroups { < nl > + object Privates extends DialogGroup { < nl > + override def key : String = " privates " < nl > + < nl > + override def title : String = " Private " < nl > + } < nl > + < nl > + object Groups extends DialogGroup { < nl > + override def key : String = " groups " < nl > + < nl > + override def title : String = " Groups " < nl > + } < nl > + } < nl > + < nl > sealed trait DialogExtension extends Extension < nl > < nl > final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { < nl > @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > peer match { < nl > - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > failed < nl > case _ ⇒ f < nl > } < nl > < nl > def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > val sender = Peer . privat ( senderUserId ) < nl > val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > } yield Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > ) < nl > } ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 4219e8c . . d3a6b75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { < nl > for { < nl > _ ← persist . HistoryMessageRepo . create ( messages ) < nl > _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > index 9475e63 . . 912092d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A < nl > private val db = DbExtension ( system ) . db < nl > < nl > def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { < nl > - < < < < < < < Updated upstream < nl > - applePushManager . getInstance ( creds . apnsKey ) match { < nl > - case Some ( mgr ) ⇒ < nl > - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > - val builder = < nl > - new ApnsPayloadBuilder ( ) < nl > - . addCustomProperty ( " seq " , seq ) < nl > - . setContentAvailable ( true ) < nl > - = = = = = = = < nl > withMgr ( creds . apnsKey ) { mgr ⇒ < nl > log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) < nl > - > > > > > > > Stashed changes < nl > - < nl > + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > + val builder = < nl > + new ApnsPayloadBuilder ( ) < nl > + . addCustomProperty ( " seq " , seq ) < nl > + . setContentAvailable ( true ) < nl > builder . setBadgeNumber ( unreadTotal ) < nl > < nl > val payload = builder . buildWithDefaultMaximumLength ( ) < nl > < nl > mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) < nl > } < nl > - case None ⇒ < nl > - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > index 191aa44 . . a59b5b2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { < nl > def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { < nl > phones . headOption match { < nl > case Some ( phone ) ⇒ Some ( phone . number ) < nl > - case None ⇒ Some ( 0L ) < nl > + case None ⇒ Some ( 0L ) < nl > } < nl > } < nl > < nl > def normalizeLocalName ( name : Option [ String ] ) = name match { < nl > - case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > - case _ ⇒ None < nl > + case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > + case _ ⇒ None < nl > } < nl > < nl > def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 9bf22b0 . . d215e44 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . model . StatusCode < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . model . { HttpMethod , StatusCode } < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString < nl > import cats . data . OptionT < nl > import cats . std . future . _ < nl > import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > - import im . actor . api . rpc . messaging . ApiJsonMessage < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . UpdateRawUpdate < nl > import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } < nl > import im . actor . server . bot . { BotExtension , BotServerBlueprint } < nl > - import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . model . AuthSession < nl > import im . actor . server . user . UserExtension < nl > import play . api . libs . json . _ < nl > import upickle . default . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . control . NoStackTrace < nl > import scala . util . { Failure , Success } < nl > < nl > @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > < nl > override def routes : Route = < nl > path ( " bots " / " hooks " / Segment ) { token ⇒ < nl > - post { < nl > - extractRequest { request ⇒ < nl > - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > + extractRequest { request ⇒ < nl > + val method = request . method < nl > + val queryString = request . uri . queryString ( ) < nl > + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > < nl > - val sendMessageF = for { < nl > - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > - res ← sendMessage ( headers , data , token ) < nl > - } yield res < nl > + val sendMessageF = for { < nl > + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + res ← sendMessage ( method , queryString , headers , data , token ) < nl > + } yield res < nl > < nl > - onComplete ( sendMessageF ) { < nl > - case Success ( result ) ⇒ < nl > - result match { < nl > - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) < nl > - } < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to handle bot hook " ) < nl > - complete ( InternalServerError ) < nl > - } < nl > + onComplete ( sendMessageF ) { < nl > + case Success ( result ) ⇒ < nl > + result match { < nl > + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > + case Right ( _ ) ⇒ < nl > + val response = < nl > + " " " < nl > + | < html > < nl > + | < head > < nl > + | < title > Please , return to the app < / title > < nl > + | < style > < nl > + | . element { < nl > + | position : relative ; < nl > + | top : 50 % ; < nl > + | transform : translateY ( - 50 % ) ; < nl > + | } < nl > + | < / style > < nl > + | < / head > < nl > + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > < nl > + | < / html > < nl > + " " " . stripMargin < nl > + complete ( OK → Status ( response ) ) < nl > + } < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to handle bot hook " ) < nl > + complete ( InternalServerError ) < nl > } < nl > } < nl > } ~ path ( " bots " / Segment ) { token ⇒ < nl > @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > } < nl > } < nl > < nl > - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > ( for { < nl > hook ← OptionT ( botExt . findWebHook ( token ) ) < nl > _ ← OptionT . pure ( userExt . broadcastUserUpdate ( < nl > @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > " dataType " → JsString ( " HookData " ) , < nl > " data " → JsObject ( Map ( < nl > " name " → JsString ( hook . name ) , < nl > + " method " → JsString ( method . name ) , < nl > + " queryString " → ( queryString map JsString getOrElse JsNull ) , < nl > " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , < nl > " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) < nl > ) ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index f7b0742 . . f9c82b0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index 14c35dd . . 66d4ebf 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { < nl > | " com . trueaccord . scalapb . GeneratedMessage " = actor < nl > | } < nl > | } < nl > + | < nl > + | cluster . sharding . state - store - mode = " ddata " < nl > | } < nl > " " " . stripMargin < nl > ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3d25a02 . . 72dc6c1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 27 + 1 , 52 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogGroup < nl > + import org . scalatest . concurrent . ScalaFutures < nl > < nl > - import scala . concurrent . Await < nl > + import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers { < nl > - val timeout : Timeout < nl > + trait MessagingSpecHelpers extends ScalaFutures { < nl > + implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > - msgService : MessagingService , < nl > - system : ActorSystem < nl > + msgService : MessagingService < nl > ) : Unit = { < nl > - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) < nl > + } < nl > } < nl > < nl > def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + < nl > + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs map { < nl > + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs < nl > + } toMap < nl > + } < nl > + } < nl > + < nl > + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { < nl > + val dgs = getDialogGroups ( ) < nl > + dgs get group . key match { < nl > + case Some ( ds ) ⇒ ds < nl > + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) < nl > + } < nl > + } < nl > + < nl > + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { < nl > + users foreach { user ⇒ < nl > + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) < nl > + Thread . sleep ( 1 ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 85ba87d . . fe02129 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . _ < nl > + import im . actor . server . dialog . DialogGroups < nl > < nl > import scala . concurrent . { Await , Future } < nl > import scala . concurrent . duration . _ < nl > @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec < nl > extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > - with GroupsServiceHelpers { < nl > + with GroupsServiceHelpers < nl > + with MessagingSpecHelpers { < nl > " LoadGroupedDialogs " should " load groups and privates " in loadGrouped < nl > < nl > - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > - private val service = MessagingServiceImpl ( ) < nl > + " Dialogs " should " appear in top on new incoming message " in incomingGoTop < nl > + it should " appear in top on new outgoing message " in outgoingGoTop < nl > + < nl > + " Hidden dialogs " should " appear on new message " in appearHidden < nl > + it should " appear on show " in appearShown < nl > + < nl > + import DialogGroups . _ < nl > + < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > def loadGrouped ( ) = { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec < nl > } < nl > } < nl > } < nl > + < nl > + def incomingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = bobClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val dgs = getDialogGroups ( ) < nl > + val privates = dgs ( Privates . key ) < nl > + privates . size should equal ( 2 ) < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + privates . last . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val privates = getDialogGroups ( Privates ) < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + } < nl > + < nl > + def outgoingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + prepareDialogs ( bob , eve ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > + < nl > + def appearHidden ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > + < nl > + def appearShown ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index ba67e8b . . dab5dcf 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 20 , 6 + 20 , 16 @ @ message DialogRootEvents { 
 } 
 } 
 
 + message DialogRootQueries { 
 + message GetCounter { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogRootQuery " ; 
 + } 
 + 
 + message GetCounterResponse { 
 + required int32 counter = 1 ; 
 + } 
 + } 
 + 
 message DialogCommands { 
 
 message Envelope { 
 @ @ - 173 , 4 + 183 , 34 @ @ message DialogCommands { 
 } 
 
 message UpdateCountersAck { } 
 + } 
 + 
 + message DialogQueries { 
 + message GetApiStruct { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogQuery " ; 
 + } 
 + 
 + message GetCounter { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogQuery " ; 
 + } 
 + 
 + message GetCounterResponse { 
 + required int32 counter = 1 ; 
 + } 
 + } 
 + 
 + message DialogEvents { 
 + message NewMessage { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + 
 + required int64 random _ id = 2 ; 
 + required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + required bool is _ incoming = 3 ; 
 + } 
 + 
 + message MessagesRead { 
 + option ( scalapb . message ) . extends = " im . actor . server . dialog . DialogEvent " ; 
 + 
 + required int64 date = 1 [ ( scalapb . field ) . type = " java . time . Instant " ] ; 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / protobuf / user . proto b / actor - server / actor - core / src / main / protobuf / user . proto 
 index fd139ff . . 7118e40 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / user . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / user . proto 
 @ @ - 12 , 6 + 12 , 7 @ @ import " scalapb / scalapb . proto " ; 
 import " sequence . proto " ; 
 import " file . proto " ; 
 import " bots . proto " ; 
 + import " dialog . proto " ; 
 
 message UserState { 
 option ( scalapb . message ) . extends = " im . actor . server . office . ProcessorState " ; 
 @ @ - 330 , 6 + 331 , 13 @ @ message UserQueries { 
 } 
 } 
 
 + message DialogRootEnvelope { 
 + required int32 user _ id = 1 ; 
 + oneof query { 
 + DialogRootQueries . GetCounter get _ counter = 2 ; 
 + } 
 + } 
 + 
 message UserEvents { 
 message AuthAdded { 
 option ( scalapb . message ) . extends = " im . actor . server . user . UserEvent " ; 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 index 3940ca1 . . 31f9933 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / cqrs / Processor . scala 
 @ @ - 54 , 4 + 54 , 6 @ @ abstract class Processor [ S < : ProcessorState [ S , E ] , E : ClassTag ] extends Persist 
 protected def reply ( msg : AnyRef ) : Unit = sender ( ) ! msg 
 
 protected def replyFuture ( msgFuture : Future [ Any ] ) : Unit = msgFuture pipeTo sender ( ) 
 + 
 + protected def setState ( state : S ) = this . _ state = state 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 68ca482 . . 0942b94 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 25 , 45 + 25 , 50 @ @ import scala . util . Failure 
 trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 this : DialogProcessor ⇒ 
 
 + import DialogEvents . _ 
 + import DialogEventsObsolete . _ 
 + 
 import DialogCommands . _ 
 import DialogEvents . _ 
 
 protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 - withCreated ( s ) { state ⇒ 
 - becomeStashing ( replyTo ⇒ ( { 
 - case seq : SeqStateDate ⇒ 
 + becomeStashing ( replyTo ⇒ ( { 
 + case seq : SeqStateDate ⇒ 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( seq . date ) , isIncoming = false ) ) { e ⇒ 
 + commit ( e ) 
 replyTo ! seq 
 if ( state . isArchived ) { 
 self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 updateMessageDate ( state , seq . date ) 
 unstashAll ( ) 
 - case fail : Status . Failure ⇒ 
 - log . error ( fail . cause , " Failed to send message " ) 
 - replyTo forward fail 
 - context unbecome ( ) 
 - unstashAll ( ) 
 - } : Receive ) orElse reactions ( state ) , discardOld = false ) 
 - 
 - withValidAccessHash ( sm . dest , sm . senderAuthId , sm . accessHash ) { 
 - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 - val sendDate = calcSendDate ( state ) 
 - val message = sm . message 
 - PubSubExtension ( system ) . publish ( PeerMessage ( sm . origin , sm . dest , sm . randomId , sendDate , message ) ) 
 - 
 - withNonBlockedPeer [ SeqStateDate ] ( userId , sm . dest ) ( 
 - default = for { 
 - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) 
 - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 - _ = dialogExt . updateCounters ( peer , userId ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sendDate ) , 
 - failed = for { 
 - _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sendDate ) 
 - ) 
 + context . become ( receiveCommand ) 
 } 
 + case fail : Status . Failure ⇒ 
 + log . error ( fail . cause , " Failed to send message " ) 
 + replyTo forward fail 
 + context . become ( receiveCommand ) 
 + unstashAll ( ) 
 + } : Receive ) orElse reactions ( state ) , discardOld = true ) 
 + 
 + withValidAccessHash ( sm . dest , sm . senderAuthId , sm . accessHash ) { 
 + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 + val sendDate = calcSendDate ( state ) 
 + val message = sm . message 
 + PubSubExtension ( system ) . publish ( PeerMessage ( sm . origin , sm . dest , sm . randomId , sendDate , message ) ) 
 + 
 + withNonBlockedPeer [ SeqStateDate ] ( userId , sm . dest ) ( 
 + default = for { 
 + _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) 
 + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 + _ = dialogExt . updateCounters ( peer , userId ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sendDate ) , 
 + failed = for { 
 + _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sendDate , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sendDate ) 
 + ) 
 } 
 } 
 } 
 @ @ - 74 , 9 + 79 , 14 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 . pipeTo ( sender ( ) ) 
 } 
 
 - protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = 
 - withCreated ( s ) { state ⇒ 
 - val messageDate = sm . date getOrElse { throw new RuntimeException ( " No message date found in SendMessage " ) } 
 + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 + val messageDate = sm . date getOrElse { 
 + throw new RuntimeException ( " No message date found in SendMessage " ) 
 + } 
 + 
 + persist ( NewMessage ( sm . randomId , Instant . ofEpochMilli ( messageDate ) , isIncoming = true ) ) { e ⇒ 
 + commit ( e ) 
 + 
 if ( peer . typ = = PeerType . Private ) { 
 SocialManager . recordRelation ( sm . origin . id , userId ) 
 SocialManager . recordRelation ( userId , sm . origin . id ) 
 @ @ - 87 , 28 + 97 , 30 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 . pipeTo ( sender ( ) ) onSuccess { 
 case _ ⇒ 
 - if ( state . isArchived ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + if ( state . isArchived ) { 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 } 
 } 
 + } 
 
 protected def writeMessage ( 
 s : DialogState , 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = 
 - withCreated ( s ) { _ ⇒ 
 - val date = new DateTime ( dateMillis ) 
 - 
 - db . run ( writeHistoryMessage ( 
 - selfPeer , 
 - peer , 
 - date , 
 - randomId , 
 - message . header , 
 - message . toByteArray 
 - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 - } 
 + ) : Unit = { 
 + val date = new DateTime ( dateMillis ) 
 + 
 + db . run ( writeHistoryMessage ( 
 + selfPeer , 
 + peer , 
 + date , 
 + randomId , 
 + message . header , 
 + message . toByteArray 
 + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def writeMessageSelf ( 
 s : DialogState , 
 @ @ - 116 , 17 + 128 , 16 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = 
 - withCreated ( s ) { _ ⇒ 
 - val result = 
 - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 - } else { 
 - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 - } 
 + ) : Unit = { 
 + val result = 
 + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 + } else { 
 + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , new DateTime ( dateMillis ) , randomId , message . header , message . toByteArray ) ) 
 + } 
 
 - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 - } 
 + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 val mustReceive = mustMakeReceive ( state , mr ) 
 @ @ - 360 , 25 + 371 , 25 @ @ trait DialogCommandHandlers extends PeersImplicits with UserACL { 
 ( mr . date > state . lastReadDate ) & & ( mr . date < = mr . now | | mr . date < = state . lastMessageDate ) 
 
 protected def updateMessageDate ( state : DialogState , date : Long ) : Unit = 
 - context become initialized ( state . updated ( LastMessageDate ( date ) ) ) 
 + commit ( LastMessageDate ( date ) ) 
 
 private def updateReceiveDate ( state : DialogState , date : Long ) : Unit = 
 - context become initialized ( state . updated ( LastReceiveDate ( date ) ) ) 
 + commit ( LastReceiveDate ( date ) ) 
 
 private def updateReadDate ( state : DialogState , date : Long ) : Unit = 
 - context become initialized ( state . updated ( LastReadDate ( date ) ) ) 
 + commit ( LastReadDate ( date ) ) 
 
 private def updateArchived ( state : DialogState ) : Unit = 
 - context become initialized ( state . updated ( Archived ) ) 
 + commit ( Archived ) 
 
 private def updateShown ( state : DialogState ) : Unit = 
 - context become initialized ( state . updated ( Shown ) ) 
 + commit ( Shown ) 
 
 private def updateFavourited ( state : DialogState ) : Unit = 
 - context become initialized ( state . updated ( Favourited ) ) 
 + commit ( Favourited ) 
 
 private def updateUnfavourited ( state : DialogState ) : Unit = 
 - context become initialized ( state . updated ( Unfavourited ) ) 
 + commit ( Unfavourited ) 
 
 / * * 
 * check access hash and execute ` f ` , if access hash is valid 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index bf11096 . . a8eddbd 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 20 , 7 + 20 , 7 @ @ import im . actor . server . persist . messaging . ReactionEventRepo 
 import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . pubsub . { PeerMessage , PubSubExtension } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 - import im . actor . server . user . UserExtension 
 + import im . actor . server . user . { DialogRootEnvelope , UserExtension } 
 import im . actor . types . _ 
 import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 @ @ - 246 , 7 + 246 , 10 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } 
 } 
 
 - def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = HistoryMessageRepo . getUnreadTotal ( userId ) 
 + def getUnreadTotal ( userId : Int ) : DBIO [ Int ] = 
 + DBIO . from ( 
 + ( processorRegion ( Peer . privat ( userId ) ) ? DialogRootEnvelope ( userId ) . withGetCounter ( DialogRootQueries . GetCounter ( ) ) ) . mapTo [ DialogRootQueries . GetCounterResponse ] map ( _ . counter ) 
 + ) 
 
 def getUnreadCount ( clientUserId : Int , historyOwner : Int , peer : Peer , ownerLastReadAt : DateTime ) : DBIO [ Int ] = { 
 if ( isSharedUser ( historyOwner ) ) { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index d7eb024 . . 420dc93 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 1 , 32 + 1 , 34 @ @ 
 package im . actor . server . dialog 
 
 + import java . time . Instant 
 + 
 import akka . actor . _ 
 - import akka . pattern . pipe 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . misc . ApiExtension 
 - import im . actor . concurrent . { ActorFutures , StashingActor , AlertingActor } 
 + import im . actor . concurrent . { ActorFutures , AlertingActor , StashingActor } 
 import im . actor . serialization . ActorSerializer 
 - import im . actor . server . cqrs . ProcessorState 
 + import im . actor . server . cqrs . _ 
 import im . actor . server . db . DbExtension 
 import im . actor . server . group . GroupExtension 
 - import im . actor . server . model . { DialogObsolete ⇒ DialogModel , PeerType , Peer } 
 - import im . actor . server . persist . dialog . DialogRepo 
 - import im . actor . server . persist . { GroupRepo , UserRepo } 
 - import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } 
 + import im . actor . server . model . { Peer , DialogObsolete ⇒ DialogModel } 
 + import im . actor . server . sequence . { SeqStateDate , SeqUpdatesExtension } 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 - import org . joda . time . DateTime 
 - import slick . dbio . DBIO 
 import slick . driver . PostgresDriver . api . Database 
 
 + import scala . collection . immutable 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 - private [ dialog ] sealed trait DialogEvent 
 + private [ dialog ] trait DialogEvent extends TaggedEvent { 
 + override def tags : Set [ String ] = Set ( " dialog " ) 
 + } 
 + 
 + trait DialogQuery 
 
 - object DialogEvents { 
 + object DialogEventsObsolete { 
 
 private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent 
 
 @ @ - 40 , 7 + 42 , 6 @ @ object DialogEvents { 
 
 private [ dialog ] case object Favourited extends DialogEvent 
 private [ dialog ] case object Unfavourited extends DialogEvent 
 - 
 } 
 
 private [ dialog ] object DialogState { 
 @ @ - 50 , 29 + 51 , 53 @ @ private [ dialog ] object DialogState { 
 lastReadDate : Long , 
 isFavourite : Boolean , 
 isCreated : Boolean , 
 - isArchived : Boolean 
 - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isFavourite , isCreated , isArchived ) 
 + isArchived : Boolean , 
 + counter : Int 
 + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isFavourite , isCreated , isArchived , counter , immutable . SortedSet . empty ( UnreadMessage . ordering ) ) 
 
 - def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = 
 + def fromModel ( model : DialogModel , isCreated : Boolean , counter : Int ) : DialogState = 
 DialogState ( 
 model . lastMessageDate . getMillis , 
 model . ownerLastReceivedAt . getMillis , 
 model . ownerLastReadAt . getMillis , 
 model . isFavourite , 
 isCreated = isCreated , 
 - isArchived = model . archivedAt . isDefined 
 + isArchived = model . archivedAt . isDefined , 
 + counter , 
 + immutable . SortedSet . empty ( UnreadMessage . ordering ) 
 ) 
 } 
 
 + private object UnreadMessage { 
 + val ordering = new Ordering [ UnreadMessage ] { 
 + override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = 
 + if ( x . date . isBefore ( y . date ) ) - 1 
 + else if ( x . date . isAfter ( y . date ) ) 1 
 + else 0 
 + } 
 + } 
 + 
 + private case class UnreadMessage ( date : Instant , randomId : Long ) { 
 + override def hashCode ( ) : Int = randomId . hashCode ( ) 
 + 
 + override def equals ( obj : scala . Any ) : Boolean = obj match { 
 + case um : UnreadMessage ⇒ randomId = = um . randomId 
 + case _ ⇒ false 
 + } 
 + } 
 + 
 private [ dialog ] final case class DialogState ( 
 lastMessageDate : Long , / / we don ' t use it now anywhere . should we remove it ? 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isFavourite : Boolean , 
 isCreated : Boolean , 
 - isArchived : Boolean 
 + isArchived : Boolean , 
 + counter : Int , 
 + unreadMessages : immutable . SortedSet [ UnreadMessage ] 
 ) extends ProcessorState [ DialogState , DialogEvent ] { 
 import DialogEvents . _ 
 + import DialogEventsObsolete . _ 
 override def updated ( e : DialogEvent ) : DialogState = e match { 
 case LastMessageDate ( date ) if date > this . lastMessageDate ⇒ this . copy ( lastMessageDate = date ) 
 case LastReceiveDate ( date ) if date > this . lastReceiveDate ⇒ this . copy ( lastReceiveDate = date ) 
 @ @ - 81 , 6 + 106 , 13 @ @ private [ dialog ] final case class DialogState ( 
 case Archived ⇒ this . copy ( isArchived = true ) 
 case Favourited ⇒ this . copy ( isFavourite = true ) 
 case Unfavourited ⇒ this . copy ( isFavourite = false ) 
 + case NewMessage ( randomId , date , isIncoming ) ⇒ 
 + if ( isIncoming ) { 
 + this . copy ( counter = counter + 1 , unreadMessages = unreadMessages + UnreadMessage ( date , randomId ) ) 
 + } else this 
 + case MessagesRead ( date ) ⇒ 
 + val newUnreadMessages = unreadMessages . dropWhile ( um ⇒ um . date . isBefore ( date ) | | um . date = = date ) 
 + this . copy ( counter = newUnreadMessages . size , unreadMessages = newUnreadMessages ) 
 case _ ⇒ this 
 } 
 } 
 @ @ - 105 , 14 + 137 , 17 @ @ object DialogProcessor { 
 def props ( userId : Int , peer : Peer , extensions : Seq [ ApiExtension ] ) : Props = 
 Props ( classOf [ DialogProcessor ] , userId , peer , extensions ) 
 
 + private [ dialog ] def persistenceId ( peer : Peer ) = s " Dialog _ $ { peer . typ . index } _ $ { peer . id } " 
 } 
 
 private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , extensions : Seq [ ApiExtension ] ) 
 - extends AlertingActor 
 + extends Processor [ DialogState , DialogEvent ] 
 + with AlertingActor 
 with DialogCommandHandlers 
 with ActorFutures 
 with StashingActor { 
 import DialogCommands . _ 
 + import DialogQueries . _ 
 import DialogProcessor . _ 
 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 @ @ - 133 , 20 + 168 , 15 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = 
 createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 
 - override def preStart ( ) = init ( ) 
 + override def persistenceId : String = DialogProcessor . persistenceId ( peer ) 
 
 - def receive = initializing 
 + override protected def getInitialState : DialogState = DialogState ( 0 , 0 , 0 , false , false , false , 0 , immutable . SortedSet . empty ( UnreadMessage . ordering ) ) 
 
 - def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 - case state : DialogState ⇒ 
 - context become initialized ( state ) 
 - unstashAll ( ) 
 - case Status . Failure ( cause ) ⇒ 
 - log . error ( cause , " Failed to init dialog " ) 
 - self ! Kill 
 - } ) 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 + case GetCounter ( ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) 
 + } 
 
 - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) 
 + override protected def handleCommand : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 def reactions ( state : DialogState ) : Receive = { 
 @ @ - 158 , 7 + 188 , 7 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 - / / when receiving this messages , dialog required to take action 
 + / / when receiving this messages , dialog is required to take an action 
 def actions ( state : DialogState ) : Receive = { 
 case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 case mrv : MessageReceived if invokes ( mrv ) ⇒ messageReceived ( state , mrv ) / / User received messages 
 @ @ - 199 , 44 + 229 , 4 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * @ return does dialog owner accepts this command 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 - 
 - private def init ( ) : Unit = { 
 - ( for { 
 - optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) 
 - initState ← optDialog match { 
 - case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) 
 - case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) 
 - } 
 - } yield initState ) pipeTo self 
 - } 
 - 
 - protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { 
 - if ( state . isCreated ) f ( state ) 
 - else { 
 - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 - val replyTo = sender ( ) 
 - 
 - db . run ( for { 
 - exists ← peer . ` type ` match { 
 - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 - } 
 - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) 
 - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 - } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) 
 - 
 - becomeStashing ( replyTo ⇒ { 
 - case state : DialogState ⇒ 
 - context become initialized ( state ) 
 - unstashAll ( ) 
 - f ( state ) 
 - case Status . Failure ( e ) ⇒ 
 - log . error ( e , " Failed to create dialog " ) 
 - self ! Kill 
 - } , discardOld = true ) 
 - } 
 - } 
 - 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index fc4b47c . . f452074 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 3 , 11 + 3 , 15 @ @ package im . actor . server . dialog 
 import java . time . Instant 
 
 import akka . actor . { ActorRef , Props } 
 + import akka . pattern . ask 
 + import akka . util . Timeout 
 + import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 import im . actor . server . dialog . DialogCommands . SendMessage 
 import im . actor . server . model . { Peer , PeerType } 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . misc . ApiExtension 
 + import im . actor . config . ActorConfig 
 
 import scala . concurrent . Future 
 
 @ @ - 53 , 6 + 57 , 10 @ @ object DialogRoot { 
 
 private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Processor [ DialogRootState , DialogRootEvent ] { 
 import DialogRootEvents . _ 
 + import DialogRootQueries . _ 
 + import context . dispatcher 
 + 
 + private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 
 private val selfPeer : Peer = Peer . privat ( userId ) 
 
 @ @ - 60 , 7 + 68 , 16 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , Set . empty , Set . empty ) 
 
 - override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = PartialFunction . empty 
 + override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 + case GetCounter ( ) ⇒ 
 + val refs = state . activePeers . toSeq map dialogRef 
 + 
 + for { 
 + counters ← FutureExt . ftraverse ( refs ) { ref ⇒ 
 + ( ref ? DialogQueries . GetCounter ( ) ) . mapTo [ DialogQueries . GetCounterResponse ] map ( _ . counter ) 
 + } 
 + } yield GetCounterResponse ( counters . sum ) 
 + } 
 
 override protected def handleCommand : Receive = { 
 case sm : SendMessage ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 index f517d23 . . 9df98f2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessor . scala 
 @ @ - 11 , 7 + 11 , 7 @ @ import im . actor . serialization . ActorSerializer 
 import im . actor . server . bots . BotCommand 
 import im . actor . server . cqrs . TaggedEvent 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . { DialogCommand , DialogExtension , DialogRoot } 
 + import im . actor . server . dialog . _ 
 import im . actor . server . office . { PeerProcessor , StopOffice } 
 import im . actor . server . sequence . SeqUpdatesExtension 
 import im . actor . server . social . { SocialExtension , SocialManagerRegion } 
 @ @ - 245 , 6 + 245 , 8 @ @ private [ user ] final class UserProcessor 
 case StopOffice ⇒ context stop self 
 case ReceiveTimeout ⇒ context . parent ! ShardRegion . Passivate ( stopMessage = StopOffice ) 
 case dc : DialogCommand ⇒ dialogRoot ( state . internalExtensions ) forward dc 
 + case dq : DialogQuery ⇒ dialogRoot ( state . internalExtensions ) forward dq 
 + case drq : DialogRootQuery ⇒ dialogRoot ( state . internalExtensions ) forward drq 
 } 
 
 override protected def handleQuery ( state : UserState ) : Receive = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 index 28319df . . c475692 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserProcessorRegion . scala 
 @ @ - 26 , 6 + 26 , 8 @ @ object UserProcessorRegion { 
 } 
 case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 } 
 + case e @ DialogRootEnvelope ( userId , query ) ⇒ 
 + ( userId . toString , e . getField ( DialogRootEnvelope . descriptor . findFieldByNumber ( query . number ) ) ) 
 } 
 } 
 
 @ @ - 36 , 6 + 38 , 7 @ @ object UserProcessorRegion { 
 case Peer ( PeerType . Private , userId ) ⇒ ( userId % 100 ) . toString 
 case Peer ( peerType , _ ) ⇒ throw new RuntimeException ( s " DialogCommand with peerType : $ peerType passed in UserProcessor " ) 
 } 
 + case DialogRootEnvelope ( userId , query ) ⇒ ( userId % 100 ) . toString 
 } 
 
 val typeName = " UserProcessor " 
 diff - - git a / actor - server / actor - models / src / main / protobuf / model . proto b / actor - server / actor - models / src / main / protobuf / model . proto 
 index a296bea . . 3fa66af 100644 
 - - - a / actor - server / actor - models / src / main / protobuf / model . proto 
 + + + b / actor - server / actor - models / src / main / protobuf / model . proto 
 @ @ - 83 , 4 + 83 , 5 @ @ message DeviceFeature { 
 int64 auth _ id = 1 ; 
 string name = 2 ; 
 bytes args = 3 ; 
 - } 
 \ No newline at end of file 
 + } 
 + 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala 
 index dd3a69c . . 78c39d4 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / GlobalCountersSpec . scala 
 @ @ - 43 , 10 + 43 , 8 @ @ final class GlobalCountersSpec 
 { 
 implicit val clientData = aliceClientData 
 
 - / / make sure that own messages does not count 
 - for ( i ← 1 to 15 ) { 
 - sendMessageToGroup ( groupPeer . groupId , textMessage ( s " Hello back $ i " ) ) 
 - } 
 + / / make sure that own messages don ' t count 
 + sendMessageToGroup ( groupPeer . groupId , textMessage ( s " Hello back " ) ) 
 
 expectUpdate ( classOf [ UpdateCountersChanged ] ) { upd ⇒ 
 / / 2 initializing messages and 10 messages from bob

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index 641806f . . 71c4080 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 
 for { 
 - senderName ← userExt . getName ( receiverUserId , senderUserId ) 
 + senderName ← userExt . getName ( senderUserId , receiverUserId ) 
 pushText ← getPushText ( peer , receiverUserId , senderName , message ) 
 _ ← seqUpdatesExt . deliverSingleUpdate ( 
 receiverUserId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 4181a2e . . 3230c26 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 + import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 import slick . driver . PostgresDriver . api . Database 
 @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 - val dialog = DialogModel ( userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b45cc33 . . d2c2ddb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 throw e 
 } ) pipeTo sender ( ) 
 sendFuture onSuccess { 
 - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) 
 + case SeqStateDate ( _ , _ , date ) ⇒ 
 + self ! LastOwnMessageDate ( date ) 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 } 
 
 @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 deliveryExt 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 + 
 val future = 
 ( for { 
 _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 55230de . . 01a8d62 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + sealed trait DialogGroup { 
 + def key : String 
 + def title : String 
 + } 
 + 
 + object DialogGroups { 
 + object Privates extends DialogGroup { 
 + override def key : String = " privates " 
 + 
 + override def title : String = " Private " 
 + } 
 + 
 + object Groups extends DialogGroup { 
 + override def key : String = " groups " 
 + 
 + override def title : String = " Groups " 
 + } 
 + } 
 + 
 sealed trait DialogExtension extends Extension 
 
 final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { 
 @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 peer match { 
 - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 failed 
 case _ ⇒ f 
 } 
 
 def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 val sender = Peer . privat ( senderUserId ) 
 val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 } yield Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 ) 
 } ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 4219e8c . . d3a6b75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { 
 for { 
 _ ← persist . HistoryMessageRepo . create ( messages ) 
 _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 index 9475e63 . . 912092d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A 
 private val db = DbExtension ( system ) . db 
 
 def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { 
 - < < < < < < < Updated upstream 
 - applePushManager . getInstance ( creds . apnsKey ) match { 
 - case Some ( mgr ) ⇒ 
 - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 - val builder = 
 - new ApnsPayloadBuilder ( ) 
 - . addCustomProperty ( " seq " , seq ) 
 - . setContentAvailable ( true ) 
 - = = = = = = = 
 withMgr ( creds . apnsKey ) { mgr ⇒ 
 log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) 
 - > > > > > > > Stashed changes 
 - 
 + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 + val builder = 
 + new ApnsPayloadBuilder ( ) 
 + . addCustomProperty ( " seq " , seq ) 
 + . setContentAvailable ( true ) 
 builder . setBadgeNumber ( unreadTotal ) 
 
 val payload = builder . buildWithDefaultMaximumLength ( ) 
 
 mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) 
 } 
 - case None ⇒ 
 - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 index 191aa44 . . a59b5b2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { 
 def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { 
 phones . headOption match { 
 case Some ( phone ) ⇒ Some ( phone . number ) 
 - case None ⇒ Some ( 0L ) 
 + case None ⇒ Some ( 0L ) 
 } 
 } 
 
 def normalizeLocalName ( name : Option [ String ] ) = name match { 
 - case n @ Some ( name ) if name . nonEmpty ⇒ n 
 - case _ ⇒ None 
 + case n @ Some ( name ) if name . nonEmpty ⇒ n 
 + case _ ⇒ None 
 } 
 
 def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 9bf22b0 . . d215e44 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . model . StatusCode 
 import akka . http . scaladsl . model . StatusCodes . _ 
 import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . model . { HttpMethod , StatusCode } 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString 
 import cats . data . OptionT 
 import cats . std . future . _ 
 import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 - import im . actor . api . rpc . messaging . ApiJsonMessage 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . UpdateRawUpdate 
 import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } 
 import im . actor . server . bot . { BotExtension , BotServerBlueprint } 
 - import im . actor . server . dialog . DialogExtension 
 import im . actor . server . model . AuthSession 
 import im . actor . server . user . UserExtension 
 import play . api . libs . json . _ 
 import upickle . default . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . control . NoStackTrace 
 import scala . util . { Failure , Success } 
 
 @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 
 override def routes : Route = 
 path ( " bots " / " hooks " / Segment ) { token ⇒ 
 - post { 
 - extractRequest { request ⇒ 
 - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 + extractRequest { request ⇒ 
 + val method = request . method 
 + val queryString = request . uri . queryString ( ) 
 + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 
 - val sendMessageF = for { 
 - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 - res ← sendMessage ( headers , data , token ) 
 - } yield res 
 + val sendMessageF = for { 
 + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 + res ← sendMessage ( method , queryString , headers , data , token ) 
 + } yield res 
 
 - onComplete ( sendMessageF ) { 
 - case Success ( result ) ⇒ 
 - result match { 
 - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) 
 - } 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to handle bot hook " ) 
 - complete ( InternalServerError ) 
 - } 
 + onComplete ( sendMessageF ) { 
 + case Success ( result ) ⇒ 
 + result match { 
 + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 + case Right ( _ ) ⇒ 
 + val response = 
 + " " " 
 + | < html > 
 + | < head > 
 + | < title > Please , return to the app < / title > 
 + | < style > 
 + | . element { 
 + | position : relative ; 
 + | top : 50 % ; 
 + | transform : translateY ( - 50 % ) ; 
 + | } 
 + | < / style > 
 + | < / head > 
 + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > 
 + | < / html > 
 + " " " . stripMargin 
 + complete ( OK → Status ( response ) ) 
 + } 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to handle bot hook " ) 
 + complete ( InternalServerError ) 
 } 
 } 
 } ~ path ( " bots " / Segment ) { token ⇒ 
 @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 } 
 } 
 
 - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 ( for { 
 hook ← OptionT ( botExt . findWebHook ( token ) ) 
 _ ← OptionT . pure ( userExt . broadcastUserUpdate ( 
 @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 " dataType " → JsString ( " HookData " ) , 
 " data " → JsObject ( Map ( 
 " name " → JsString ( hook . name ) , 
 + " method " → JsString ( method . name ) , 
 + " queryString " → ( queryString map JsString getOrElse JsNull ) , 
 " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , 
 " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) 
 ) ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index f7b0742 . . f9c82b0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index 14c35dd . . 66d4ebf 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { 
 | " com . trueaccord . scalapb . GeneratedMessage " = actor 
 | } 
 | } 
 + | 
 + | cluster . sharding . state - store - mode = " ddata " 
 | } 
 " " " . stripMargin 
 ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3d25a02 . . 72dc6c1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 27 + 1 , 52 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import im . actor . api . rpc . ClientData 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogGroup 
 + import org . scalatest . concurrent . ScalaFutures 
 
 - import scala . concurrent . Await 
 + import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers { 
 - val timeout : Timeout 
 + trait MessagingSpecHelpers extends ScalaFutures { 
 + implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 - msgService : MessagingService , 
 - system : ActorSystem 
 + msgService : MessagingService 
 ) : Unit = { 
 - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) 
 + } 
 } 
 
 def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + 
 + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs map { 
 + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs 
 + } toMap 
 + } 
 + } 
 + 
 + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { 
 + val dgs = getDialogGroups ( ) 
 + dgs get group . key match { 
 + case Some ( ds ) ⇒ ds 
 + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) 
 + } 
 + } 
 + 
 + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { 
 + users foreach { user ⇒ 
 + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) 
 + Thread . sleep ( 1 ) 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 85ba87d . . fe02129 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . _ 
 + import im . actor . server . dialog . DialogGroups 
 
 import scala . concurrent . { Await , Future } 
 import scala . concurrent . duration . _ 
 @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec 
 extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 - with GroupsServiceHelpers { 
 + with GroupsServiceHelpers 
 + with MessagingSpecHelpers { 
 " LoadGroupedDialogs " should " load groups and privates " in loadGrouped 
 
 - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 - private val service = MessagingServiceImpl ( ) 
 + " Dialogs " should " appear in top on new incoming message " in incomingGoTop 
 + it should " appear in top on new outgoing message " in outgoingGoTop 
 + 
 + " Hidden dialogs " should " appear on new message " in appearHidden 
 + it should " appear on show " in appearShown 
 + 
 + import DialogGroups . _ 
 + 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + private implicit lazy val service = MessagingServiceImpl ( ) 
 
 def loadGrouped ( ) = { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec 
 } 
 } 
 } 
 + 
 + def incomingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = bobClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val dgs = getDialogGroups ( ) 
 + val privates = dgs ( Privates . key ) 
 + privates . size should equal ( 2 ) 
 + privates . head . peer . id should equal ( bob . id ) 
 + privates . last . peer . id should equal ( eve . id ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val privates = getDialogGroups ( Privates ) 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + } 
 + 
 + def outgoingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + prepareDialogs ( bob , eve ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( bob . id ) 
 + } 
 + } 
 + 
 + def appearHidden ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 + 
 + def appearShown ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 } 
 \ No newline at end of file
