BLEU SCORE: 0.392814650900513

TEST MSG: test ( server ) : start writing Group V2 tests
GENERATED MSG: test ( server ) : UpdateChatGroupsChanged hack

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala < nl > new file mode 100644 < nl > index 0000000 . . 752ed6f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala < nl > @ @ - 0 , 0 + 1 , 170 @ @ < nl > + package im . actor . server . api . rpc . service . groups . v2 < nl > + < nl > + import cats . data . Xor < nl > + import im . actor . api . rpc . groups . { ApiGroupType , UpdateGroupInviteObsolete } < nl > + import im . actor . api . rpc . messaging . UpdateMessage < nl > + import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiUserOutPeer } < nl > + import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits , RpcError , RpcResponse } < nl > + import im . actor . api . rpc . sequence . ApiUpdateOptimization < nl > + import im . actor . server . _ < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . group . { GroupExtension , GroupServiceMessages , GroupType } < nl > + import im . actor . server . sequence . SeqState < nl > + import im . actor . server . user . UserExtension < nl > + import im . actor . util . ThreadLocalSecureRandom < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + class GroupV2GroupSpec extends BaseAppSuite < nl > + / / with GroupsServiceHelpers < nl > + with MessageParsing < nl > + / / with MessagingSpecHelpers < nl > + with ImplicitSequenceService < nl > + with ImplicitAuthService < nl > + with ImplicitMessagingService < nl > + with ImplicitSessionRegion < nl > + with SeqUpdateMatchers < nl > + with PeersImplicits { < nl > + < nl > + behavior of " Groups V2 API " < nl > + < nl > + it should " create group and return correct members list " in create < nl > + < nl > + it should " allow ONLY group members to invite other users " in invite < nl > + < nl > + / / it should " allow only group admin to change about " in changeAbout < nl > + < nl > + / / it should " allow only group admin to revoke integration token " in revokeToken < nl > + < nl > + / / join < nl > + / / invite < nl > + / / kick < nl > + / / leave < nl > + / / change actions by admin < nl > + / / change actions by non - admin < nl > + < nl > + val optimizations = Vector ( ApiUpdateOptimization . GROUPS _ V2 , ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + < nl > + val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) < nl > + val groupExt = GroupExtension ( system ) < nl > + < nl > + val groupService = new GroupsServiceImpl ( groupInviteConfig ) < nl > + < nl > + val userExt = UserExtension ( system ) < nl > + < nl > + def create ( ) : Unit = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + val aliceOutPeer = getUserOutPeer ( alice . id , aliceAuthId ) < nl > + < nl > + val members = 1 to 20 map { i ⇒ < nl > + val ( user , authId , authSid , _ ) = createUser ( ) < nl > + getUserOutPeer ( user . id , aliceAuthId ) < nl > + } < nl > + < nl > + val title = " V2 first group " < nl > + val randomId = nextRandomId ( ) < nl > + val createResp = response ( groupService . handleCreateGroup ( < nl > + randomId , < nl > + title = title , < nl > + users = members , < nl > + groupType = None , < nl > + optimizations = optimizations < nl > + ) ) < nl > + < nl > + / / members checks < nl > + createResp . users shouldBe empty / / strip entities optimization < nl > + createResp . userPeers should not be empty < nl > + createResp . userPeers should have length 21 / / 20 invited users + 1 creator < nl > + createResp . group . membersCount shouldEqual Some ( 21 ) < nl > + createResp . userPeers should contain theSameElementsAs ( members : + aliceOutPeer ) < nl > + < nl > + / / group properties checks < nl > + createResp . group . groupType shouldEqual Some ( ApiGroupType . GROUP ) < nl > + createResp . group . title shouldEqual title < nl > + createResp . group . isHidden shouldEqual Some ( false ) < nl > + < nl > + / / membership checks < nl > + createResp . group . isMember shouldEqual Some ( true ) < nl > + createResp . group . isAdmin shouldEqual Some ( true ) < nl > + createResp . group . creatorUserId shouldEqual alice . id < nl > + < nl > + / / Group V2 updates < nl > + expectUpdate ( classOf [ UpdateMessage ] ) { upd ⇒ < nl > + upd . randomId shouldEqual randomId < nl > + upd . message shouldEqual GroupServiceMessages . groupCreated < nl > + } < nl > + < nl > + / / There should be no Group V1 updates < nl > + expectNoUpdate ( emptyState , classOf [ UpdateGroupInviteObsolete ] ) < nl > + } < nl > + < nl > + def invite ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( carol , _ , _ , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + < nl > + val aliceClientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + val bobClientData = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + < nl > + val randomId = nextRandomId ( ) < nl > + val ( seqState , groupOutPeer ) = { < nl > + implicit val cd = aliceClientData < nl > + val createResp = response ( groupService . handleCreateGroup ( < nl > + randomId , < nl > + title = " Invite check group " , < nl > + users = Vector . empty , < nl > + groupType = None , < nl > + optimizations = optimizations < nl > + ) ) < nl > + val group = createResp . group < nl > + group . membersCount shouldEqual Some ( 1 ) < nl > + group . members should have length 1 < nl > + group . members map ( _ . userId ) shouldEqual Vector ( alice . id ) < nl > + < nl > + mkSeqState ( createResp . seq , createResp . state ) → ApiGroupOutPeer ( group . id , group . accessHash ) < nl > + } < nl > + < nl > + / / Don ' t allow non - member to invite other users < nl > + { < nl > + implicit val cd = bobClientData < nl > + whenReady ( groupService . handleInviteUser ( < nl > + groupOutPeer , < nl > + nextRandomId ( ) , < nl > + getUserOutPeer ( carol . id , bobAuthId ) , < nl > + optimizations < nl > + ) ) { _ should matchForbidden } < nl > + } < nl > + < nl > + / / Allow group member to invite other users < nl > + { < nl > + implicit val cd = aliceClientData < nl > + val randomId = nextRandomId ( ) < nl > + whenReady ( groupService . handleInviteUser ( < nl > + groupOutPeer , < nl > + randomId , < nl > + getUserOutPeer ( bob . id , aliceAuthId ) , < nl > + optimizations < nl > + ) ) { resp ⇒ < nl > + < nl > + } < nl > + < nl > + } < nl > + < nl > + } < nl > + < nl > + private def response [ A < : RpcResponse ] ( result : Future [ RpcError Xor A ] ) : A = { < nl > + val r = result . futureValue < nl > + r should matchPattern { < nl > + case Ok ( _ ) ⇒ < nl > + } < nl > + r . getOrElse ( fail ( " Rpc response was not OK " ) ) < nl > + } < nl > + < nl > + private def nextRandomId ( ) = ThreadLocalSecureRandom . current ( ) . nextLong ( ) < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > index 70166d1 . . 6f0e15d 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala < nl > @ @ - 4 , 12 + 4 , 15 @ @ import com . typesafe . config . ConfigFactory < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . contacts . UpdateContactsAdded < nl > import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } < nl > - import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessageContentChanged } < nl > + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateChatGroupsChanged , UpdateMessageContentChanged } < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . { ApiUpdateContainer , ApiUpdateOptimization , ResponseGetDifference , UpdateEmptyUpdate } < nl > import im . actor . server . _ < nl > - import im . actor . server . api . rpc . service . sequence . SequenceServiceConfig < nl > + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > + import im . actor . server . dialog . { DialogExtension , DialogGroupKeys } < nl > import im . actor . server . sequence . { CommonState , CommonStateVersion , UserSequence } < nl > < nl > import scala . concurrent . Future < nl > @ @ - 25 , 6 + 28 , 7 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > } ) with ImplicitSessionRegion < nl > with ImplicitAuthService < nl > with SeqUpdateMatchers < nl > + with GroupsServiceHelpers < nl > with ImplicitSequenceService { < nl > < nl > behavior of " Sequence service " < nl > @ @ - 34 , 11 + 38 , 13 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > it should " not produce empty difference if there is one update bigger than difference size limit " in bigUpdate < nl > it should " map updates correctly " in mapUpdates < nl > it should " exclude optimized updates from sequence " in optimizedUpdates < nl > + it should " return single UpdateChatGroupsChanged in difference as if it was applied after all message reads " in chatGroupChanged < nl > < nl > private val config = SequenceServiceConfig . load ( ) . get < nl > < nl > - implicit lazy val service = new sequence . SequenceServiceImpl ( config ) < nl > - implicit lazy val msgService = messaging . MessagingServiceImpl ( ) < nl > + implicit lazy val service = new SequenceServiceImpl ( config ) < nl > + implicit lazy val msgService = MessagingServiceImpl ( ) < nl > + implicit lazy val groupService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > < nl > def getState ( ) = { < nl > val ( user , authId , authSid , _ ) = createUser ( ) < nl > @ @ - 271 , 4 + 277 , 75 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { < nl > } < nl > } < nl > } < nl > + < nl > + def chatGroupChanged ( ) : Unit = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + < nl > + val sessionId = createSessionId ( ) < nl > + val aliceClientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) < nl > + < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + < nl > + val group = { < nl > + implicit val cd = aliceClientData < nl > + createGroup ( " Some group " , Set ( bob . id ) ) . groupPeer < nl > + } < nl > + < nl > + val groupReadDates = { < nl > + implicit val cd = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + 1 to 20 map { i ⇒ < nl > + sendMessageToGroup ( group . groupId , textMessage ( s " Hello in group $ i " ) ) . _ 2 . date < nl > + } < nl > + } < nl > + < nl > + val bobReadDates = { < nl > + implicit val cd = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) < nl > + 1 to 20 map { i ⇒ < nl > + sendMessageToUser ( alice . id , s " Hello $ i " ) . _ 2 . date < nl > + } < nl > + } < nl > + < nl > + { < nl > + implicit val cd = aliceClientData < nl > + whenReady ( msgService . handleFavouriteDialog ( getOutPeer ( bob . id , aliceAuthId ) ) ) ( identity ) < nl > + < nl > + / / read 5 messages , 15 left < nl > + whenReady ( msgService . handleMessageRead ( getOutPeer ( bob . id , aliceAuthId ) , bobReadDates ( 4 ) ) ) ( identity ) < nl > + < nl > + whenReady ( msgService . handleUnfavouriteDialog ( getOutPeer ( bob . id , aliceAuthId ) ) ) ( identity ) < nl > + / / read 10 messages , 10 left < nl > + whenReady ( msgService . handleMessageRead ( getOutPeer ( bob . id , aliceAuthId ) , bobReadDates ( 9 ) ) ) ( identity ) < nl > + < nl > + / / read all messages in group < nl > + whenReady ( msgService . handleMessageRead ( group . asOutPeer , groupReadDates . last ) ) ( identity ) < nl > + } < nl > + < nl > + { < nl > + implicit val cd = aliceClientData < nl > + < nl > + whenReady ( service . handleGetDifference ( 0 , Array . empty , Vector . empty ) ) { res ⇒ < nl > + inside ( res ) { < nl > + case Ok ( rsp : ResponseGetDifference ) ⇒ < nl > + val groupedChatsUpdates = rsp . updates . filter ( _ . updateHeader = = UpdateChatGroupsChanged . header ) < nl > + groupedChatsUpdates should have length 1 < nl > + } < nl > + } < nl > + < nl > + expectUpdate ( classOf [ UpdateChatGroupsChanged ] ) { upd ⇒ < nl > + val optDirect = upd . dialogs . find ( _ . key = = DialogGroupKeys . Direct ) < nl > + optDirect shouldBe defined < nl > + < nl > + val bobsDialog = optDirect . get . dialogs . find ( _ . peer . id = = bob . id ) < nl > + bobsDialog . get . counter shouldEqual 10 < nl > + < nl > + val optGroups = upd . dialogs . find ( _ . key = = DialogGroupKeys . Groups ) < nl > + optGroups shouldBe defined < nl > + < nl > + val groupDialog = optGroups . get . dialogs . find ( _ . peer . id = = group . groupId ) < nl > + groupDialog . get . counter shouldEqual 0 < nl > + } < nl > + } < nl > + < nl > + } < nl > + < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala 
 new file mode 100644 
 index 0000000 . . 752ed6f 
 - - - / dev / null 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / groups / v2 / GroupV2GroupSpec . scala 
 @ @ - 0 , 0 + 1 , 170 @ @ 
 + package im . actor . server . api . rpc . service . groups . v2 
 + 
 + import cats . data . Xor 
 + import im . actor . api . rpc . groups . { ApiGroupType , UpdateGroupInviteObsolete } 
 + import im . actor . api . rpc . messaging . UpdateMessage 
 + import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiUserOutPeer } 
 + import im . actor . api . rpc . { AuthData , ClientData , Ok , PeersImplicits , RpcError , RpcResponse } 
 + import im . actor . api . rpc . sequence . ApiUpdateOptimization 
 + import im . actor . server . _ 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . group . { GroupExtension , GroupServiceMessages , GroupType } 
 + import im . actor . server . sequence . SeqState 
 + import im . actor . server . user . UserExtension 
 + import im . actor . util . ThreadLocalSecureRandom 
 + 
 + import scala . concurrent . Future 
 + 
 + class GroupV2GroupSpec extends BaseAppSuite 
 + / / with GroupsServiceHelpers 
 + with MessageParsing 
 + / / with MessagingSpecHelpers 
 + with ImplicitSequenceService 
 + with ImplicitAuthService 
 + with ImplicitMessagingService 
 + with ImplicitSessionRegion 
 + with SeqUpdateMatchers 
 + with PeersImplicits { 
 + 
 + behavior of " Groups V2 API " 
 + 
 + it should " create group and return correct members list " in create 
 + 
 + it should " allow ONLY group members to invite other users " in invite 
 + 
 + / / it should " allow only group admin to change about " in changeAbout 
 + 
 + / / it should " allow only group admin to revoke integration token " in revokeToken 
 + 
 + / / join 
 + / / invite 
 + / / kick 
 + / / leave 
 + / / change actions by admin 
 + / / change actions by non - admin 
 + 
 + val optimizations = Vector ( ApiUpdateOptimization . GROUPS _ V2 , ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + 
 + val groupInviteConfig = GroupInviteConfig ( " http : / / actor . im " ) 
 + val groupExt = GroupExtension ( system ) 
 + 
 + val groupService = new GroupsServiceImpl ( groupInviteConfig ) 
 + 
 + val userExt = UserExtension ( system ) 
 + 
 + def create ( ) : Unit = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val sessionId = createSessionId ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + val aliceOutPeer = getUserOutPeer ( alice . id , aliceAuthId ) 
 + 
 + val members = 1 to 20 map { i ⇒ 
 + val ( user , authId , authSid , _ ) = createUser ( ) 
 + getUserOutPeer ( user . id , aliceAuthId ) 
 + } 
 + 
 + val title = " V2 first group " 
 + val randomId = nextRandomId ( ) 
 + val createResp = response ( groupService . handleCreateGroup ( 
 + randomId , 
 + title = title , 
 + users = members , 
 + groupType = None , 
 + optimizations = optimizations 
 + ) ) 
 + 
 + / / members checks 
 + createResp . users shouldBe empty / / strip entities optimization 
 + createResp . userPeers should not be empty 
 + createResp . userPeers should have length 21 / / 20 invited users + 1 creator 
 + createResp . group . membersCount shouldEqual Some ( 21 ) 
 + createResp . userPeers should contain theSameElementsAs ( members : + aliceOutPeer ) 
 + 
 + / / group properties checks 
 + createResp . group . groupType shouldEqual Some ( ApiGroupType . GROUP ) 
 + createResp . group . title shouldEqual title 
 + createResp . group . isHidden shouldEqual Some ( false ) 
 + 
 + / / membership checks 
 + createResp . group . isMember shouldEqual Some ( true ) 
 + createResp . group . isAdmin shouldEqual Some ( true ) 
 + createResp . group . creatorUserId shouldEqual alice . id 
 + 
 + / / Group V2 updates 
 + expectUpdate ( classOf [ UpdateMessage ] ) { upd ⇒ 
 + upd . randomId shouldEqual randomId 
 + upd . message shouldEqual GroupServiceMessages . groupCreated 
 + } 
 + 
 + / / There should be no Group V1 updates 
 + expectNoUpdate ( emptyState , classOf [ UpdateGroupInviteObsolete ] ) 
 + } 
 + 
 + def invite ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( carol , _ , _ , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + 
 + val aliceClientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + val bobClientData = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + 
 + val randomId = nextRandomId ( ) 
 + val ( seqState , groupOutPeer ) = { 
 + implicit val cd = aliceClientData 
 + val createResp = response ( groupService . handleCreateGroup ( 
 + randomId , 
 + title = " Invite check group " , 
 + users = Vector . empty , 
 + groupType = None , 
 + optimizations = optimizations 
 + ) ) 
 + val group = createResp . group 
 + group . membersCount shouldEqual Some ( 1 ) 
 + group . members should have length 1 
 + group . members map ( _ . userId ) shouldEqual Vector ( alice . id ) 
 + 
 + mkSeqState ( createResp . seq , createResp . state ) → ApiGroupOutPeer ( group . id , group . accessHash ) 
 + } 
 + 
 + / / Don ' t allow non - member to invite other users 
 + { 
 + implicit val cd = bobClientData 
 + whenReady ( groupService . handleInviteUser ( 
 + groupOutPeer , 
 + nextRandomId ( ) , 
 + getUserOutPeer ( carol . id , bobAuthId ) , 
 + optimizations 
 + ) ) { _ should matchForbidden } 
 + } 
 + 
 + / / Allow group member to invite other users 
 + { 
 + implicit val cd = aliceClientData 
 + val randomId = nextRandomId ( ) 
 + whenReady ( groupService . handleInviteUser ( 
 + groupOutPeer , 
 + randomId , 
 + getUserOutPeer ( bob . id , aliceAuthId ) , 
 + optimizations 
 + ) ) { resp ⇒ 
 + 
 + } 
 + 
 + } 
 + 
 + } 
 + 
 + private def response [ A < : RpcResponse ] ( result : Future [ RpcError Xor A ] ) : A = { 
 + val r = result . futureValue 
 + r should matchPattern { 
 + case Ok ( _ ) ⇒ 
 + } 
 + r . getOrElse ( fail ( " Rpc response was not OK " ) ) 
 + } 
 + 
 + private def nextRandomId ( ) = ThreadLocalSecureRandom . current ( ) . nextLong ( ) 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 index 70166d1 . . 6f0e15d 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / SequenceServiceSpec . scala 
 @ @ - 4 , 12 + 4 , 15 @ @ import com . typesafe . config . ConfigFactory 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . contacts . UpdateContactsAdded 
 import im . actor . api . rpc . counters . { ApiAppCounters , UpdateCountersChanged } 
 - import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateMessageContentChanged } 
 + import im . actor . api . rpc . messaging . { ApiTextMessage , UpdateChatGroupsChanged , UpdateMessageContentChanged } 
 import im . actor . api . rpc . misc . ResponseSeq 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . { ApiUpdateContainer , ApiUpdateOptimization , ResponseGetDifference , UpdateEmptyUpdate } 
 import im . actor . server . _ 
 - import im . actor . server . api . rpc . service . sequence . SequenceServiceConfig 
 + import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 + import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 + import im . actor . server . dialog . { DialogExtension , DialogGroupKeys } 
 import im . actor . server . sequence . { CommonState , CommonStateVersion , UserSequence } 
 
 import scala . concurrent . Future 
 @ @ - 25 , 6 + 28 , 7 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 } ) with ImplicitSessionRegion 
 with ImplicitAuthService 
 with SeqUpdateMatchers 
 + with GroupsServiceHelpers 
 with ImplicitSequenceService { 
 
 behavior of " Sequence service " 
 @ @ - 34 , 11 + 38 , 13 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 it should " not produce empty difference if there is one update bigger than difference size limit " in bigUpdate 
 it should " map updates correctly " in mapUpdates 
 it should " exclude optimized updates from sequence " in optimizedUpdates 
 + it should " return single UpdateChatGroupsChanged in difference as if it was applied after all message reads " in chatGroupChanged 
 
 private val config = SequenceServiceConfig . load ( ) . get 
 
 - implicit lazy val service = new sequence . SequenceServiceImpl ( config ) 
 - implicit lazy val msgService = messaging . MessagingServiceImpl ( ) 
 + implicit lazy val service = new SequenceServiceImpl ( config ) 
 + implicit lazy val msgService = MessagingServiceImpl ( ) 
 + implicit lazy val groupService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 
 def getState ( ) = { 
 val ( user , authId , authSid , _ ) = createUser ( ) 
 @ @ - 271 , 4 + 277 , 75 @ @ final class SequenceServiceSpec extends BaseAppSuite ( { 
 } 
 } 
 } 
 + 
 + def chatGroupChanged ( ) : Unit = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + 
 + val sessionId = createSessionId ( ) 
 + val aliceClientData = ClientData ( aliceAuthId , sessionId , Some ( AuthData ( alice . id , aliceAuthSid , 42 ) ) ) 
 + 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + 
 + val group = { 
 + implicit val cd = aliceClientData 
 + createGroup ( " Some group " , Set ( bob . id ) ) . groupPeer 
 + } 
 + 
 + val groupReadDates = { 
 + implicit val cd = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + 1 to 20 map { i ⇒ 
 + sendMessageToGroup ( group . groupId , textMessage ( s " Hello in group $ i " ) ) . _ 2 . date 
 + } 
 + } 
 + 
 + val bobReadDates = { 
 + implicit val cd = ClientData ( bobAuthId , sessionId , Some ( AuthData ( bob . id , bobAuthSid , 42 ) ) ) 
 + 1 to 20 map { i ⇒ 
 + sendMessageToUser ( alice . id , s " Hello $ i " ) . _ 2 . date 
 + } 
 + } 
 + 
 + { 
 + implicit val cd = aliceClientData 
 + whenReady ( msgService . handleFavouriteDialog ( getOutPeer ( bob . id , aliceAuthId ) ) ) ( identity ) 
 + 
 + / / read 5 messages , 15 left 
 + whenReady ( msgService . handleMessageRead ( getOutPeer ( bob . id , aliceAuthId ) , bobReadDates ( 4 ) ) ) ( identity ) 
 + 
 + whenReady ( msgService . handleUnfavouriteDialog ( getOutPeer ( bob . id , aliceAuthId ) ) ) ( identity ) 
 + / / read 10 messages , 10 left 
 + whenReady ( msgService . handleMessageRead ( getOutPeer ( bob . id , aliceAuthId ) , bobReadDates ( 9 ) ) ) ( identity ) 
 + 
 + / / read all messages in group 
 + whenReady ( msgService . handleMessageRead ( group . asOutPeer , groupReadDates . last ) ) ( identity ) 
 + } 
 + 
 + { 
 + implicit val cd = aliceClientData 
 + 
 + whenReady ( service . handleGetDifference ( 0 , Array . empty , Vector . empty ) ) { res ⇒ 
 + inside ( res ) { 
 + case Ok ( rsp : ResponseGetDifference ) ⇒ 
 + val groupedChatsUpdates = rsp . updates . filter ( _ . updateHeader = = UpdateChatGroupsChanged . header ) 
 + groupedChatsUpdates should have length 1 
 + } 
 + } 
 + 
 + expectUpdate ( classOf [ UpdateChatGroupsChanged ] ) { upd ⇒ 
 + val optDirect = upd . dialogs . find ( _ . key = = DialogGroupKeys . Direct ) 
 + optDirect shouldBe defined 
 + 
 + val bobsDialog = optDirect . get . dialogs . find ( _ . peer . id = = bob . id ) 
 + bobsDialog . get . counter shouldEqual 10 
 + 
 + val optGroups = upd . dialogs . find ( _ . key = = DialogGroupKeys . Groups ) 
 + optGroups shouldBe defined 
 + 
 + val groupDialog = optGroups . get . dialogs . find ( _ . peer . id = = group . groupId ) 
 + groupDialog . get . counter shouldEqual 0 
 + } 
 + } 
 + 
 + } 
 + 
 }
