BLEU SCORE: 0.46924700641055994

TEST MSG: fix ( server : push ) : make google push notifications work
GENERATED MSG: perf ( server : push ) : async google push via HTTP

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala < nl > index 2294488 . . 576cf0a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala < nl > @ @ - 1 , 15 + 1 , 11 @ @ < nl > package im . actor . server . sequence < nl > < nl > + import akka . NotUsed < nl > import akka . actor . _ < nl > import akka . event . Logging < nl > - import akka . http . scaladsl . Http < nl > - import akka . http . scaladsl . model . _ < nl > - import akka . http . scaladsl . settings . ConnectionPoolSettings < nl > - import akka . http . scaladsl . util . FastFuture < nl > - import akka . stream . { ActorMaterializer , Materializer } < nl > + import akka . stream . ActorMaterializer < nl > import akka . stream . actor . ActorPublisher < nl > - import akka . stream . scaladsl . Source < nl > - import akka . util . ByteString < nl > + import akka . stream . scaladsl . { Flow , Source } < nl > import cats . data . Xor < nl > import com . github . kxbmap . configs . syntax . _ < nl > import com . typesafe . config . Config < nl > @ @ - 19 , 6 + 15 , 9 @ @ import im . actor . server . persist . push . GooglePushCredentialsRepo < nl > import io . circe . generic . auto . _ < nl > import io . circe . jawn . _ < nl > import io . circe . syntax . _ < nl > + import spray . client . pipelining . _ < nl > + import spray . http . HttpHeaders . Authorization < nl > + import spray . http . _ < nl > < nl > import scala . annotation . tailrec < nl > import scala . concurrent . Future < nl > @ @ - 73 , 18 + 72 , 10 @ @ final class GooglePushExtension ( system : ActorSystem ) extends Extension { < nl > < nl > Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) < nl > . via ( GooglePushDelivery . flow ) < nl > - . mapAsync ( 1 ) { < nl > - case ( Success ( resp ) , delivery ) ⇒ < nl > - if ( resp . status = = StatusCodes . OK ) { < nl > - resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) map ( bs ⇒ Xor . Right ( bs → delivery ) ) < nl > - } else FastFuture . successful ( Xor . Left ( new RuntimeException ( s " Failed to deliver message , StatusCode was not OK : $ { resp . status } " ) ) ) < nl > - case ( Failure ( e ) , delivery ) ⇒ < nl > - FastFuture . successful ( Xor . Left ( e ) ) < nl > - } < nl > . runForeach { < nl > / / TODO : flatten < nl > - case Xor . Right ( ( bs , delivery ) ) ⇒ < nl > - parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { < nl > + case Xor . Right ( ( body , delivery ) ) ⇒ < nl > + parse ( body ) match { < nl > case Xor . Right ( json ) ⇒ < nl > json . asObject match { < nl > case Some ( obj ) ⇒ < nl > @ @ - 141 , 14 + 132 , 18 @ @ private object GooglePushDelivery { < nl > < nl > def props = Props ( classOf [ GooglePushDelivery ] ) < nl > < nl > - def flow ( implicit system : ActorSystem , mat : Materializer ) = { < nl > - val maxConnections = system . settings . config . getInt ( " services . google . push . max - connections " ) < nl > - < nl > - Http ( system ) < nl > - . cachedHostConnectionPoolHttps [ GooglePushDelivery . Delivery ] ( < nl > - " gcm - http . googleapis . com " , < nl > - settings = ConnectionPoolSettings ( system ) . withMaxConnections ( maxConnections ) < nl > - ) < nl > + def flow ( implicit system : ActorSystem ) : Flow [ ( HttpRequest , Delivery ) , Xor [ RuntimeException , ( String , Delivery ) ] , NotUsed ] = { < nl > + import system . dispatcher < nl > + val pipeline = sendReceive < nl > + Flow [ ( HttpRequest , GooglePushDelivery . Delivery ) ] . mapAsync ( 1 ) { < nl > + case ( req , del ) ⇒ < nl > + pipeline ( req ) map { resp ⇒ < nl > + if ( resp . status = = StatusCodes . OK ) < nl > + Xor . Right ( resp . entity . data . asString ( HttpCharsets . ` UTF - 8 ` ) → del ) < nl > + else < nl > + Xor . Left ( new RuntimeException ( s " Failed to deliver message , StatusCode was not OK : $ { resp . status } " ) ) < nl > + } < nl > + } < nl > } < nl > } < nl > < nl > @ @ - 157 , 15 + 152 , 15 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog < nl > import GooglePushDelivery . _ < nl > < nl > private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] < nl > - private val uri = Uri ( " / gcm / send " ) < nl > + private val uri = Uri ( " https : / / gcm - http . googleapis . com / gcm / send " ) < nl > < nl > def receive = { < nl > case d : Delivery if buf . size = = MaxQueue ⇒ < nl > - log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) < nl > + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery : = = = = = = = = = delivery . key : { } , message : { } " , MaxQueue , d . key , d . m ) < nl > case d : Delivery ⇒ < nl > - if ( buf . isEmpty & & totalDemand > 0 ) < nl > + if ( buf . isEmpty & & totalDemand > 0 ) { < nl > onNext ( mkJob ( d ) ) < nl > - else { < nl > + } else { < nl > this . buf : + = mkJob ( d ) < nl > deliverBuf ( ) < nl > } < nl > @ @ - 189 , 7 + 184 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog < nl > HttpRequest ( < nl > method = HttpMethods . POST , < nl > uri = uri , < nl > - headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , < nl > + headers = List ( Authorization ( GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , < nl > entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . noSpaces ) < nl > ) → d < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > index d7d65c1 . . 06345e9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala < nl > @ @ - 1 , 10 + 1 , 27 @ @ < nl > package im . actor . server . sequence < nl > < nl > - import scala . util . Try < nl > + import akka . actor . _ < nl > + import akka . event . Logging < nl > + import akka . http . ConnectionPoolSettings < nl > + import akka . http . scaladsl . Http < nl > + import akka . http . scaladsl . model . _ < nl > + import akka . stream . Materializer < nl > + import akka . stream . actor . ActorPublisher < nl > + import akka . stream . scaladsl . Source < nl > + import akka . util . ByteString < nl > + import cats . data . Xor < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . persist . push . GooglePushCredentialsRepo < nl > + import io . circe . generic . auto . _ < nl > < nl > import com . github . kxbmap . configs . _ < nl > - import com . google . android . gcm . server . Sender < nl > import com . typesafe . config . Config < nl > + import io . circe . jawn . _ < nl > + import io . circe . syntax . _ < nl > + < nl > + import scala . annotation . tailrec < nl > + import scala . concurrent . Future < nl > + import scala . util . { Failure , Success , Try } < nl > < nl > case class GooglePushKey ( projectId : Long , key : String ) < nl > < nl > @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { < nl > } yield GooglePushManagerConfig ( keys ) < nl > } < nl > < nl > - final class GooglePushManager ( config : GooglePushManagerConfig ) { < nl > - private val senders : Map [ Long , Sender ] = < nl > + final case class GooglePushMessage ( < nl > + collapseKey : Option [ String ] , < nl > + data : Option [ Map [ String , String ] ] < nl > + ) < nl > + < nl > + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { < nl > + < nl > + import system . dispatcher < nl > + < nl > + private val log = Logging ( system , getClass ) < nl > + private val db = DbExtension ( system ) . db < nl > + < nl > + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) < nl > + < nl > + / / TODO : flatten < nl > + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) < nl > + . via ( GooglePushDelivery . flow ) < nl > + . runForeach { < nl > + case ( Success ( resp ) , delivery ) ⇒ < nl > + if ( resp . status = = StatusCodes . OK ) { < nl > + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ < nl > + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { < nl > + case Xor . Right ( json ) ⇒ < nl > + json . asObject match { < nl > + case Some ( obj ) ⇒ < nl > + obj ( " error " ) flatMap ( _ . asString ) foreach { < nl > + case " InvalidRegistration " ⇒ < nl > + log . warning ( " Invalid registration , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case " NotRegistered " ⇒ < nl > + log . warning ( " Token is not registered , deleting " ) < nl > + remove ( delivery . regId ) < nl > + case other ⇒ < nl > + log . warning ( " Error in GCM response : { } " , other ) < nl > + } < nl > + case None ⇒ < nl > + log . error ( " Expected JSON Object but got : { } " , json ) < nl > + } < nl > + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) < nl > + } < nl > + } < nl > + } else log . error ( " Status code was not OK : { } " , resp . status ) < nl > + case ( Failure ( e ) , delivery ) ⇒ < nl > + log . error ( e , " Failed to deliver message : { } " , delivery . m ) < nl > + } < nl > + < nl > + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) < nl > + < nl > + private val keys : Map [ Long , String ] = < nl > ( config . keys map { < nl > - case GooglePushKey ( projectId , key ) ⇒ < nl > - val sender = new Sender ( key ) < nl > - ( projectId → sender ) < nl > + case GooglePushKey ( projectId , key ) ⇒ projectId → key < nl > } ) . toMap < nl > < nl > - def getInstance ( key : Long ) : Option [ Sender ] = < nl > - senders . get ( key ) < nl > + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = < nl > + keys get projectId match { < nl > + case Some ( key ) ⇒ < nl > + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) < nl > + case None ⇒ < nl > + log . warning ( " Key not found for projectId : { } " , projectId ) < nl > + } < nl > + } < nl > + < nl > + private object GooglePushDelivery { < nl > + < nl > + object Tick < nl > + < nl > + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) < nl > + < nl > + private val MaxQueue = 100000 < nl > + private val MaxConnections = 4 < nl > + < nl > + def props = Props ( classOf [ GooglePushDelivery ] ) < nl > + < nl > + def flow ( implicit system : ActorSystem , mat : Materializer ) = < nl > + Http ( system ) < nl > + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( < nl > + " gcm - http . googleapis . com " , < nl > + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) < nl > + ) < nl > + } < nl > + < nl > + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { < nl > + < nl > + import GooglePushDelivery . _ < nl > + < nl > + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] < nl > + < nl > + def receive = { < nl > + case d : Delivery if buf . size = = MaxQueue ⇒ < nl > + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) < nl > + case d : Delivery ⇒ < nl > + if ( buf . isEmpty & & totalDemand > 0 ) < nl > + onNext ( mkJob ( d ) ) < nl > + else { < nl > + this . buf : + = mkJob ( d ) < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + @ tailrec def deliverBuf ( ) : Unit = < nl > + if ( totalDemand > 0 ) { < nl > + if ( totalDemand < = Int . MaxValue ) { < nl > + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) < nl > + buf = keep < nl > + use foreach onNext < nl > + } else { < nl > + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) < nl > + buf = keep < nl > + use foreach onNext < nl > + deliverBuf ( ) < nl > + } < nl > + } < nl > + < nl > + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = < nl > + HttpRequest ( < nl > + method = HttpMethods . POST , < nl > + uri = Uri ( " / gcm / send " ) , < nl > + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , < nl > + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) < nl > + ) → d < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > index 1985d73 . . 8376311 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala < nl > @ @ - 1 , 29 + 1 , 16 @ @ < nl > package im . actor . server . sequence < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . event . Logging < nl > - import com . google . android . gcm . server . { Sender , Message } < nl > import im . actor . server . model . push . GooglePushCredentials < nl > < nl > - import scala . concurrent . { ExecutionContext , Future , blocking } < nl > - < nl > private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { < nl > - import system . dispatcher < nl > - < nl > - private val Retries = 3 < nl > - < nl > - private val log = Logging ( system , getClass ) < nl > - < nl > def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val message = < nl > - new Message . Builder ( ) < nl > - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - . build ( ) < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > < nl > def deliverVisible ( < nl > @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : < nl > isSoundEnabled : Boolean , < nl > isVibrationEnabled : Boolean < nl > ) : Unit = { < nl > - withMgr ( creds . projectId ) { implicit mgr ⇒ < nl > - val builder = new Message . Builder ( ) < nl > - . collapseKey ( s " seq - visible - $ { userId . toString } " ) < nl > - . addData ( " seq " , seq . toString ) < nl > - < nl > - val message = < nl > + val message = GooglePushMessage ( < nl > + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , < nl > + data = Some ( Map ( " seq " → seq . toString ) + + ( < nl > data . text match { < nl > case text if text . nonEmpty & & isTextEnabled ⇒ < nl > - builder < nl > - . addData ( " message " , text ) < nl > - . build ( ) < nl > - case _ ⇒ builder . build ( ) < nl > + Map ( " message " → text ) < nl > + case _ ⇒ Map . empty < nl > } < nl > + ) ) < nl > + ) < nl > < nl > - send ( message , creds . regId , Retries ) < nl > - } < nl > - } < nl > - < nl > - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = < nl > - googlePushManager . getInstance ( projectId ) match { < nl > - case Some ( mgr ) ⇒ f ( mgr ) < nl > - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) < nl > - } < nl > - < nl > - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { < nl > - blocking { < nl > - mgr . send ( message , regId , Retries ) < nl > - } < nl > + googlePushManager . send ( creds . projectId , creds . regId , message ) < nl > } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > index c2ce0b7 . . 5a7b0cb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala < nl > @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ < nl > import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } < nl > import akka . event . Logging < nl > import akka . pattern . ask < nl > + import akka . stream . ActorMaterializer < nl > import akka . util . Timeout < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . Update < nl > @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi < nl > override def lookup = SeqUpdatesExtension < nl > < nl > override def createExtension ( system : ExtendedActorSystem ) = { < nl > + implicit val _ system = system < nl > + implicit val mat = ActorMaterializer ( ) < nl > val log = Logging ( system , getClass ) < nl > < nl > try { < nl > diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > index 08827c4 . . c37af44 100644 < nl > - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala < nl > @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . _ < nl > import akka . stream . ActorMaterializer < nl > - import akka . stream . scaladsl . Source < nl > - import akka . util . ByteString < nl > import im . actor . server . api . http . HttpHandler < nl > import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } < nl > import im . actor . util . log . AnyRefLogSource < nl > < nl > - import scala . concurrent . { ExecutionContext , Future } < nl > + import scala . concurrent . ExecutionContext < nl > import scala . util . { Failure , Success } < nl > < nl > private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index a259645 . . 5e32937 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { < nl > < nl > val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " < nl > < nl > - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " < nl > val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " < nl > < nl > val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " < nl > @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { < nl > akkaClusterSharding , < nl > akkaDdata , < nl > caffeine , < nl > - gcmServer , < nl > pushy , < nl > jodaTime , < nl > postgresJdbc ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala 
 index 2294488 . . 576cf0a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushExtension . scala 
 @ @ - 1 , 15 + 1 , 11 @ @ 
 package im . actor . server . sequence 
 
 + import akka . NotUsed 
 import akka . actor . _ 
 import akka . event . Logging 
 - import akka . http . scaladsl . Http 
 - import akka . http . scaladsl . model . _ 
 - import akka . http . scaladsl . settings . ConnectionPoolSettings 
 - import akka . http . scaladsl . util . FastFuture 
 - import akka . stream . { ActorMaterializer , Materializer } 
 + import akka . stream . ActorMaterializer 
 import akka . stream . actor . ActorPublisher 
 - import akka . stream . scaladsl . Source 
 - import akka . util . ByteString 
 + import akka . stream . scaladsl . { Flow , Source } 
 import cats . data . Xor 
 import com . github . kxbmap . configs . syntax . _ 
 import com . typesafe . config . Config 
 @ @ - 19 , 6 + 15 , 9 @ @ import im . actor . server . persist . push . GooglePushCredentialsRepo 
 import io . circe . generic . auto . _ 
 import io . circe . jawn . _ 
 import io . circe . syntax . _ 
 + import spray . client . pipelining . _ 
 + import spray . http . HttpHeaders . Authorization 
 + import spray . http . _ 
 
 import scala . annotation . tailrec 
 import scala . concurrent . Future 
 @ @ - 73 , 18 + 72 , 10 @ @ final class GooglePushExtension ( system : ActorSystem ) extends Extension { 
 
 Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) 
 . via ( GooglePushDelivery . flow ) 
 - . mapAsync ( 1 ) { 
 - case ( Success ( resp ) , delivery ) ⇒ 
 - if ( resp . status = = StatusCodes . OK ) { 
 - resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) map ( bs ⇒ Xor . Right ( bs → delivery ) ) 
 - } else FastFuture . successful ( Xor . Left ( new RuntimeException ( s " Failed to deliver message , StatusCode was not OK : $ { resp . status } " ) ) ) 
 - case ( Failure ( e ) , delivery ) ⇒ 
 - FastFuture . successful ( Xor . Left ( e ) ) 
 - } 
 . runForeach { 
 / / TODO : flatten 
 - case Xor . Right ( ( bs , delivery ) ) ⇒ 
 - parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { 
 + case Xor . Right ( ( body , delivery ) ) ⇒ 
 + parse ( body ) match { 
 case Xor . Right ( json ) ⇒ 
 json . asObject match { 
 case Some ( obj ) ⇒ 
 @ @ - 141 , 14 + 132 , 18 @ @ private object GooglePushDelivery { 
 
 def props = Props ( classOf [ GooglePushDelivery ] ) 
 
 - def flow ( implicit system : ActorSystem , mat : Materializer ) = { 
 - val maxConnections = system . settings . config . getInt ( " services . google . push . max - connections " ) 
 - 
 - Http ( system ) 
 - . cachedHostConnectionPoolHttps [ GooglePushDelivery . Delivery ] ( 
 - " gcm - http . googleapis . com " , 
 - settings = ConnectionPoolSettings ( system ) . withMaxConnections ( maxConnections ) 
 - ) 
 + def flow ( implicit system : ActorSystem ) : Flow [ ( HttpRequest , Delivery ) , Xor [ RuntimeException , ( String , Delivery ) ] , NotUsed ] = { 
 + import system . dispatcher 
 + val pipeline = sendReceive 
 + Flow [ ( HttpRequest , GooglePushDelivery . Delivery ) ] . mapAsync ( 1 ) { 
 + case ( req , del ) ⇒ 
 + pipeline ( req ) map { resp ⇒ 
 + if ( resp . status = = StatusCodes . OK ) 
 + Xor . Right ( resp . entity . data . asString ( HttpCharsets . ` UTF - 8 ` ) → del ) 
 + else 
 + Xor . Left ( new RuntimeException ( s " Failed to deliver message , StatusCode was not OK : $ { resp . status } " ) ) 
 + } 
 + } 
 } 
 } 
 
 @ @ - 157 , 15 + 152 , 15 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog 
 import GooglePushDelivery . _ 
 
 private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] 
 - private val uri = Uri ( " / gcm / send " ) 
 + private val uri = Uri ( " https : / / gcm - http . googleapis . com / gcm / send " ) 
 
 def receive = { 
 case d : Delivery if buf . size = = MaxQueue ⇒ 
 - log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) 
 + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery : = = = = = = = = = delivery . key : { } , message : { } " , MaxQueue , d . key , d . m ) 
 case d : Delivery ⇒ 
 - if ( buf . isEmpty & & totalDemand > 0 ) 
 + if ( buf . isEmpty & & totalDemand > 0 ) { 
 onNext ( mkJob ( d ) ) 
 - else { 
 + } else { 
 this . buf : + = mkJob ( d ) 
 deliverBuf ( ) 
 } 
 @ @ - 189 , 7 + 184 , 7 @ @ private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , Goog 
 HttpRequest ( 
 method = HttpMethods . POST , 
 uri = uri , 
 - headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , 
 + headers = List ( Authorization ( GenericHttpCredentials ( s " key = $ { d . key } " , Map . empty [ String , String ] ) ) ) , 
 entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . noSpaces ) 
 ) → d 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 index d7d65c1 . . 06345e9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushManager . scala 
 @ @ - 1 , 10 + 1 , 27 @ @ 
 package im . actor . server . sequence 
 
 - import scala . util . Try 
 + import akka . actor . _ 
 + import akka . event . Logging 
 + import akka . http . ConnectionPoolSettings 
 + import akka . http . scaladsl . Http 
 + import akka . http . scaladsl . model . _ 
 + import akka . stream . Materializer 
 + import akka . stream . actor . ActorPublisher 
 + import akka . stream . scaladsl . Source 
 + import akka . util . ByteString 
 + import cats . data . Xor 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . persist . push . GooglePushCredentialsRepo 
 + import io . circe . generic . auto . _ 
 
 import com . github . kxbmap . configs . _ 
 - import com . google . android . gcm . server . Sender 
 import com . typesafe . config . Config 
 + import io . circe . jawn . _ 
 + import io . circe . syntax . _ 
 + 
 + import scala . annotation . tailrec 
 + import scala . concurrent . Future 
 + import scala . util . { Failure , Success , Try } 
 
 case class GooglePushKey ( projectId : Long , key : String ) 
 
 @ @ - 27 , 14 + 44 , 124 @ @ object GooglePushManagerConfig { 
 } yield GooglePushManagerConfig ( keys ) 
 } 
 
 - final class GooglePushManager ( config : GooglePushManagerConfig ) { 
 - private val senders : Map [ Long , Sender ] = 
 + final case class GooglePushMessage ( 
 + collapseKey : Option [ String ] , 
 + data : Option [ Map [ String , String ] ] 
 + ) 
 + 
 + final class GooglePushManager ( config : GooglePushManagerConfig ) ( implicit system : ActorSystem , mat : Materializer ) { 
 + 
 + import system . dispatcher 
 + 
 + private val log = Logging ( system , getClass ) 
 + private val db = DbExtension ( system ) . db 
 + 
 + private val deliveryPublisher = system . actorOf ( GooglePushDelivery . props , " google - push - delivery " ) 
 + 
 + / / TODO : flatten 
 + Source . fromPublisher ( ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] ( deliveryPublisher ) ) 
 + . via ( GooglePushDelivery . flow ) 
 + . runForeach { 
 + case ( Success ( resp ) , delivery ) ⇒ 
 + if ( resp . status = = StatusCodes . OK ) { 
 + resp . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) foreach { bs ⇒ 
 + parse ( new String ( bs . toArray , " UTF - 8 " ) ) match { 
 + case Xor . Right ( json ) ⇒ 
 + json . asObject match { 
 + case Some ( obj ) ⇒ 
 + obj ( " error " ) flatMap ( _ . asString ) foreach { 
 + case " InvalidRegistration " ⇒ 
 + log . warning ( " Invalid registration , deleting " ) 
 + remove ( delivery . regId ) 
 + case " NotRegistered " ⇒ 
 + log . warning ( " Token is not registered , deleting " ) 
 + remove ( delivery . regId ) 
 + case other ⇒ 
 + log . warning ( " Error in GCM response : { } " , other ) 
 + } 
 + case None ⇒ 
 + log . error ( " Expected JSON Object but got : { } " , json ) 
 + } 
 + case Xor . Left ( failure ) ⇒ log . error ( failure . underlying , " Failed to parse response " ) 
 + } 
 + } 
 + } else log . error ( " Status code was not OK : { } " , resp . status ) 
 + case ( Failure ( e ) , delivery ) ⇒ 
 + log . error ( e , " Failed to deliver message : { } " , delivery . m ) 
 + } 
 + 
 + private def remove ( regId : String ) : Future [ Int ] = db . run ( GooglePushCredentialsRepo . deleteByToken ( regId ) ) 
 + 
 + private val keys : Map [ Long , String ] = 
 ( config . keys map { 
 - case GooglePushKey ( projectId , key ) ⇒ 
 - val sender = new Sender ( key ) 
 - ( projectId → sender ) 
 + case GooglePushKey ( projectId , key ) ⇒ projectId → key 
 } ) . toMap 
 
 - def getInstance ( key : Long ) : Option [ Sender ] = 
 - senders . get ( key ) 
 + def send ( projectId : Long , regId : String , message : GooglePushMessage ) : Unit = 
 + keys get projectId match { 
 + case Some ( key ) ⇒ 
 + deliveryPublisher ! GooglePushDelivery . Delivery ( message , key , regId ) 
 + case None ⇒ 
 + log . warning ( " Key not found for projectId : { } " , projectId ) 
 + } 
 + } 
 + 
 + private object GooglePushDelivery { 
 + 
 + object Tick 
 + 
 + final case class Delivery ( m : GooglePushMessage , key : String , regId : String ) 
 + 
 + private val MaxQueue = 100000 
 + private val MaxConnections = 4 
 + 
 + def props = Props ( classOf [ GooglePushDelivery ] ) 
 + 
 + def flow ( implicit system : ActorSystem , mat : Materializer ) = 
 + Http ( system ) 
 + . cachedHostConnectionPoolTls [ GooglePushDelivery . Delivery ] ( 
 + " gcm - http . googleapis . com " , 
 + settings = ConnectionPoolSettings ( system ) . copy ( maxConnections = MaxConnections ) 
 + ) 
 + } 
 + 
 + private final class GooglePushDelivery extends ActorPublisher [ ( HttpRequest , GooglePushDelivery . Delivery ) ] with ActorLogging { 
 + 
 + import GooglePushDelivery . _ 
 + 
 + private [ this ] var buf = Vector . empty [ ( HttpRequest , Delivery ) ] 
 + 
 + def receive = { 
 + case d : Delivery if buf . size = = MaxQueue ⇒ 
 + log . error ( " Current queue is already at size MaxQueue : { } , ignoring delivery " , MaxQueue ) 
 + case d : Delivery ⇒ 
 + if ( buf . isEmpty & & totalDemand > 0 ) 
 + onNext ( mkJob ( d ) ) 
 + else { 
 + this . buf : + = mkJob ( d ) 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + @ tailrec def deliverBuf ( ) : Unit = 
 + if ( totalDemand > 0 ) { 
 + if ( totalDemand < = Int . MaxValue ) { 
 + val ( use , keep ) = buf . splitAt ( totalDemand . toInt ) 
 + buf = keep 
 + use foreach onNext 
 + } else { 
 + val ( use , keep ) = buf . splitAt ( Int . MaxValue ) 
 + buf = keep 
 + use foreach onNext 
 + deliverBuf ( ) 
 + } 
 + } 
 + 
 + private def mkJob ( d : Delivery ) : ( HttpRequest , Delivery ) = 
 + HttpRequest ( 
 + method = HttpMethods . POST , 
 + uri = Uri ( " / gcm / send " ) , 
 + headers = List ( headers . Authorization ( headers . GenericHttpCredentials ( s " key = $ { d . regId } " , Map . empty [ String , String ] ) ) ) , 
 + entity = HttpEntity ( ContentTypes . ` application / json ` , d . m . asJson . toString ( ) ) 
 + ) → d 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 index 1985d73 . . 8376311 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / GooglePushProvider . scala 
 @ @ - 1 , 29 + 1 , 16 @ @ 
 package im . actor . server . sequence 
 
 import akka . actor . ActorSystem 
 - import akka . event . Logging 
 - import com . google . android . gcm . server . { Sender , Message } 
 import im . actor . server . model . push . GooglePushCredentials 
 
 - import scala . concurrent . { ExecutionContext , Future , blocking } 
 - 
 private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : GooglePushManager , system : ActorSystem ) extends PushProvider { 
 - import system . dispatcher 
 - 
 - private val Retries = 3 
 - 
 - private val log = Logging ( system , getClass ) 
 - 
 def deliverInvisible ( seq : Int , creds : GooglePushCredentials ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val message = 
 - new Message . Builder ( ) 
 - . collapseKey ( s " seq - invisible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - . build ( ) 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - invisible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 
 def deliverVisible ( 
 @ @ - 34 , 33 + 21 , 17 @ @ private [ sequence ] final class GooglePushProvider ( userId : Int , googlePushManager : 
 isSoundEnabled : Boolean , 
 isVibrationEnabled : Boolean 
 ) : Unit = { 
 - withMgr ( creds . projectId ) { implicit mgr ⇒ 
 - val builder = new Message . Builder ( ) 
 - . collapseKey ( s " seq - visible - $ { userId . toString } " ) 
 - . addData ( " seq " , seq . toString ) 
 - 
 - val message = 
 + val message = GooglePushMessage ( 
 + collapseKey = Some ( s " seq - visible - $ { userId . toString } " ) , 
 + data = Some ( Map ( " seq " → seq . toString ) + + ( 
 data . text match { 
 case text if text . nonEmpty & & isTextEnabled ⇒ 
 - builder 
 - . addData ( " message " , text ) 
 - . build ( ) 
 - case _ ⇒ builder . build ( ) 
 + Map ( " message " → text ) 
 + case _ ⇒ Map . empty 
 } 
 + ) ) 
 + ) 
 
 - send ( message , creds . regId , Retries ) 
 - } 
 - } 
 - 
 - private def withMgr [ A ] ( projectId : Long ) ( f : Sender ⇒ A ) = 
 - googlePushManager . getInstance ( projectId ) match { 
 - case Some ( mgr ) ⇒ f ( mgr ) 
 - case None ⇒ log . warning ( " No google push configured for project - id : { } " , projectId ) 
 - } 
 - 
 - private def send ( message : Message , regId : String , retries : Int ) ( implicit mgr : Sender , ec : ExecutionContext ) : Unit = Future { 
 - blocking { 
 - mgr . send ( message , regId , Retries ) 
 - } 
 + googlePushManager . send ( creds . projectId , creds . regId , message ) 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 index c2ce0b7 . . 5a7b0cb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / SeqUpdatesExtension . scala 
 @ @ - 4 , 6 + 4 , 7 @ @ import akka . actor . _ 
 import akka . cluster . pubsub . { DistributedPubSub , DistributedPubSubMediator } 
 import akka . event . Logging 
 import akka . pattern . ask 
 + import akka . stream . ActorMaterializer 
 import akka . util . Timeout 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . Update 
 @ @ - 239 , 6 + 240 , 8 @ @ object SeqUpdatesExtension extends ExtensionId [ SeqUpdatesExtension ] with Extensi 
 override def lookup = SeqUpdatesExtension 
 
 override def createExtension ( system : ExtendedActorSystem ) = { 
 + implicit val _ system = system 
 + implicit val mat = ActorMaterializer ( ) 
 val log = Logging ( system , getClass ) 
 
 try { 
 diff - - git a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 index 08827c4 . . c37af44 100644 
 - - - a / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 + + + b / actor - server / actor - fs - adapters / src / main / scala / im / actor / server / file / local / http / FilesHttpHandler . scala 
 @ @ - 9 , 13 + 9 , 11 @ @ import akka . http . scaladsl . model . StatusCodes . OK 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . _ 
 import akka . stream . ActorMaterializer 
 - import akka . stream . scaladsl . Source 
 - import akka . util . ByteString 
 import im . actor . server . api . http . HttpHandler 
 import im . actor . server . file . local . { FileStorageOperations , LocalFileStorageConfig , RequestSigning } 
 import im . actor . util . log . AnyRefLogSource 
 
 - import scala . concurrent . { ExecutionContext , Future } 
 + import scala . concurrent . ExecutionContext 
 import scala . util . { Failure , Success } 
 
 private [ local ] final class FilesHttpHandler ( storageConfig : LocalFileStorageConfig ) ( implicit val system : ActorSystem ) 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index a259645 . . 5e32937 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 104 , 7 + 104 , 6 @ @ object Dependencies { 
 
 val tyrex = " tyrex " % " tyrex " % " 1 . 0 . 1 " 
 
 - val gcmServer = " com . google . android . gcm " % " gcm - server " % " 1 . 0 . 2 " 
 val pushy = " com . relayrides " % " pushy " % " 0 . 4 . 3 " 
 
 val logbackClassic = " ch . qos . logback " % " logback - classic " % " 1 . 1 . 2 " 
 @ @ - 167 , 7 + 166 , 6 @ @ object Dependencies { 
 akkaClusterSharding , 
 akkaDdata , 
 caffeine , 
 - gcmServer , 
 pushy , 
 jodaTime , 
 postgresJdbc ,
