BLEU SCORE: 0.7598356856515925

TEST MSG: Update key - creation . md
GENERATED MSG: Create key - creation . md

TEST DIFF (one line): diff - - git a / docs / protocol / key - creation . md b / docs / protocol / key - creation . md < nl > index cdd1f1f . . 96cd3e8 100644 < nl > - - - a / docs / protocol / key - creation . md < nl > + + + b / docs / protocol / key - creation . md < nl > @ @ - 5 , 6 + 5 , 8 @ @ But we think that can be a problem in some cases on the server side as this key < nl > < nl > Eventually , in rev4 of MTProto we will eliminate using of TLS for better speed and security . < nl > < nl > + MTProtoV2 uses Curve25519 for performing DH for calculating AuthKey < nl > + < nl > # Changes in Transport ' s Package < nl > < nl > Adding new ` ` ` signature ` ` ` field for signing each package . Depends on authId server will use signature or not . < nl > @ @ - 24 , 22 + 26 , 24 @ @ Package { < nl > # New Requesting Authentication Key < nl > Old method of AuthId creation will continue to work , but rev3 introduces new way of more secure way to get AuthId and AuthKey . < nl > < nl > - First app need to request starting of Auth Key creation : < nl > + # # # # Server ' s Key Loading < nl > + < nl > + Before start Client MUST send ` ` ` RequestStartGetServerKeys ` ` ` message : < nl > ` ` ` < nl > - RequestStartAuthKey { < nl > + RequestStartGetServerKeys { < nl > HEADER = 0xE0 < nl > } < nl > ` ` ` < nl > < nl > - Server will return truncated to 8 bytes of SHA - 256 of available keys < nl > + Server MUST return list of truncated to 8 bytes of SHA - 256 of available keys < nl > ` ` ` < nl > - ResponseStartAuthKey { < nl > + ResponseStartGetServerKeys { < nl > HEADER = 0xE1 < nl > availableKeys : longs < nl > } < nl > ` ` ` < nl > < nl > - Client requests required key : < nl > + Client requests required key < nl > ` ` ` < nl > ResponseGetServerKey { < nl > HEADER = 0xE2 < nl > @ @ - 55 , 3 + 59 , 22 @ @ ResponseGetServerKey { < nl > key : bytes < nl > } < nl > ` ` ` < nl > + < nl > + # # # # Starting AuthKey creation < nl > + < nl > + Before begin you need to securely generate random long value - randomId . This is temprorary unique id used by server to identify authentication session . Server doesn ' t try to scope authentication procedure to single connection and even to single server and this value helps it to identify state of DH . If collision will take place it will only lead to DH failure and nothing more . < nl > + < nl > + ` ` ` < nl > + RequestStartDH { < nl > + HEADER = 0xE4 < nl > + / / Securely generated random id of key creation < nl > + randomId : long < nl > + / / Used keyId for Diffie - Hellman start < nl > + keyId : long < nl > + < nl > + / / DH parameter used for encryption < nl > + dh _ x : bytes < nl > + / / Encrypted DH request < nl > + encrypted : bytes < nl > + } < nl > + ` ` `
NEAREST DIFF (one line): diff - - git a / docs / protocol / key - creation . md b / docs / protocol / key - creation . md < nl > new file mode 100644 < nl > index 0000000 . . cdd1f1f < nl > - - - / dev / null < nl > + + + b / docs / protocol / key - creation . md < nl > @ @ - 0 , 0 + 1 , 57 @ @ < nl > + # Authentication Key < nl > + < nl > + In rev3 of protocol MTProto v2 introduces a better way of authentication of requests . In previous versions server tell authKey explictly and client apps need to pass it to every request for authentication . This is not a problem as TLS is required and everything is encrypted by default already . < nl > + But we think that can be a problem in some cases on the server side as this key flaws around the server and can occasionaly appear in server ' s logs . On the other side application might need to have some shared secret for performing various security related tasks , for example , sigining voice call requests . < nl > + < nl > + Eventually , in rev4 of MTProto we will eliminate using of TLS for better speed and security . < nl > + < nl > + # Changes in Transport ' s Package < nl > + < nl > + Adding new ` ` ` signature ` ` ` field for signing each package . Depends on authId server will use signature or not . < nl > + ` ` ` < nl > + Package { < nl > + / / unique identifier that is constant thru all application lifetime < nl > + authId : long < nl > + / / random identifier of current session < nl > + sessionId : long < nl > + / / message < nl > + message : Message < nl > + / / signature < nl > + signature : bytes < nl > + } < nl > + ` ` ` < nl > + < nl > + # New Requesting Authentication Key < nl > + Old method of AuthId creation will continue to work , but rev3 introduces new way of more secure way to get AuthId and AuthKey . < nl > + < nl > + First app need to request starting of Auth Key creation : < nl > + ` ` ` < nl > + RequestStartAuthKey { < nl > + HEADER = 0xE0 < nl > + } < nl > + ` ` ` < nl > + < nl > + Server will return truncated to 8 bytes of SHA - 256 of available keys < nl > + ` ` ` < nl > + ResponseStartAuthKey { < nl > + HEADER = 0xE1 < nl > + availableKeys : longs < nl > + } < nl > + ` ` ` < nl > + < nl > + Client requests required key : < nl > + ` ` ` < nl > + ResponseGetServerKey { < nl > + HEADER = 0xE2 < nl > + keyId : long < nl > + } < nl > + ` ` ` < nl > + < nl > + Server return raw key data . Client MUST to check received key by comparing FULL hash that is hardcoded inside application . Again , DON ' T compare truncated hashes - this is insecure . Client can skip downloading keys if it have built - in keys installed . < nl > + ` ` ` < nl > + ResponseGetServerKey { < nl > + HEADER = 0xE3 < nl > + keyId : long < nl > + key : bytes < nl > + } < nl > + ` ` `

TEST DIFF:
diff - - git a / docs / protocol / key - creation . md b / docs / protocol / key - creation . md 
 index cdd1f1f . . 96cd3e8 100644 
 - - - a / docs / protocol / key - creation . md 
 + + + b / docs / protocol / key - creation . md 
 @ @ - 5 , 6 + 5 , 8 @ @ But we think that can be a problem in some cases on the server side as this key 
 
 Eventually , in rev4 of MTProto we will eliminate using of TLS for better speed and security . 
 
 + MTProtoV2 uses Curve25519 for performing DH for calculating AuthKey 
 + 
 # Changes in Transport ' s Package 
 
 Adding new ` ` ` signature ` ` ` field for signing each package . Depends on authId server will use signature or not . 
 @ @ - 24 , 22 + 26 , 24 @ @ Package { 
 # New Requesting Authentication Key 
 Old method of AuthId creation will continue to work , but rev3 introduces new way of more secure way to get AuthId and AuthKey . 
 
 - First app need to request starting of Auth Key creation : 
 + # # # # Server ' s Key Loading 
 + 
 + Before start Client MUST send ` ` ` RequestStartGetServerKeys ` ` ` message : 
 ` ` ` 
 - RequestStartAuthKey { 
 + RequestStartGetServerKeys { 
 HEADER = 0xE0 
 } 
 ` ` ` 
 
 - Server will return truncated to 8 bytes of SHA - 256 of available keys 
 + Server MUST return list of truncated to 8 bytes of SHA - 256 of available keys 
 ` ` ` 
 - ResponseStartAuthKey { 
 + ResponseStartGetServerKeys { 
 HEADER = 0xE1 
 availableKeys : longs 
 } 
 ` ` ` 
 
 - Client requests required key : 
 + Client requests required key 
 ` ` ` 
 ResponseGetServerKey { 
 HEADER = 0xE2 
 @ @ - 55 , 3 + 59 , 22 @ @ ResponseGetServerKey { 
 key : bytes 
 } 
 ` ` ` 
 + 
 + # # # # Starting AuthKey creation 
 + 
 + Before begin you need to securely generate random long value - randomId . This is temprorary unique id used by server to identify authentication session . Server doesn ' t try to scope authentication procedure to single connection and even to single server and this value helps it to identify state of DH . If collision will take place it will only lead to DH failure and nothing more . 
 + 
 + ` ` ` 
 + RequestStartDH { 
 + HEADER = 0xE4 
 + / / Securely generated random id of key creation 
 + randomId : long 
 + / / Used keyId for Diffie - Hellman start 
 + keyId : long 
 + 
 + / / DH parameter used for encryption 
 + dh _ x : bytes 
 + / / Encrypted DH request 
 + encrypted : bytes 
 + } 
 + ` ` `

NEAREST DIFF:
diff - - git a / docs / protocol / key - creation . md b / docs / protocol / key - creation . md 
 new file mode 100644 
 index 0000000 . . cdd1f1f 
 - - - / dev / null 
 + + + b / docs / protocol / key - creation . md 
 @ @ - 0 , 0 + 1 , 57 @ @ 
 + # Authentication Key 
 + 
 + In rev3 of protocol MTProto v2 introduces a better way of authentication of requests . In previous versions server tell authKey explictly and client apps need to pass it to every request for authentication . This is not a problem as TLS is required and everything is encrypted by default already . 
 + But we think that can be a problem in some cases on the server side as this key flaws around the server and can occasionaly appear in server ' s logs . On the other side application might need to have some shared secret for performing various security related tasks , for example , sigining voice call requests . 
 + 
 + Eventually , in rev4 of MTProto we will eliminate using of TLS for better speed and security . 
 + 
 + # Changes in Transport ' s Package 
 + 
 + Adding new ` ` ` signature ` ` ` field for signing each package . Depends on authId server will use signature or not . 
 + ` ` ` 
 + Package { 
 + / / unique identifier that is constant thru all application lifetime 
 + authId : long 
 + / / random identifier of current session 
 + sessionId : long 
 + / / message 
 + message : Message 
 + / / signature 
 + signature : bytes 
 + } 
 + ` ` ` 
 + 
 + # New Requesting Authentication Key 
 + Old method of AuthId creation will continue to work , but rev3 introduces new way of more secure way to get AuthId and AuthKey . 
 + 
 + First app need to request starting of Auth Key creation : 
 + ` ` ` 
 + RequestStartAuthKey { 
 + HEADER = 0xE0 
 + } 
 + ` ` ` 
 + 
 + Server will return truncated to 8 bytes of SHA - 256 of available keys 
 + ` ` ` 
 + ResponseStartAuthKey { 
 + HEADER = 0xE1 
 + availableKeys : longs 
 + } 
 + ` ` ` 
 + 
 + Client requests required key : 
 + ` ` ` 
 + ResponseGetServerKey { 
 + HEADER = 0xE2 
 + keyId : long 
 + } 
 + ` ` ` 
 + 
 + Server return raw key data . Client MUST to check received key by comparing FULL hash that is hardcoded inside application . Again , DON ' T compare truncated hashes - this is insecure . Client can skip downloading keys if it have built - in keys installed . 
 + ` ` ` 
 + ResponseGetServerKey { 
 + HEADER = 0xE3 
 + keyId : long 
 + key : bytes 
 + } 
 + ` ` `
