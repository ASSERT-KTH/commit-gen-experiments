BLEU SCORE: 0.052096969065434415

TEST MSG: test ( server ) : remove obsolete dashboard specs
GENERATED MSG: fix ( dashboard ) : models validaition via play json , custom phone validation , tests

TEST DIFF (one line): diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala < nl > deleted file mode 100644 < nl > index bbba56e . . 0000000 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala < nl > + + + / dev / null < nl > @ @ - 1 , 29 + 0 , 0 @ @ < nl > - / / package im . actor . server . dashboard < nl > - / / < nl > - / / import org . scalatest . concurrent . ScalaFutures < nl > - / / import org . scalatest . time . { Seconds , Span } < nl > - / / import org . scalatest . { BeforeAndAfterAll , FlatSpec , Matchers } < nl > - / / import slick . driver . PostgresDriver < nl > - / / < nl > - / / import im . actor . server . SqlSpecHelpers < nl > - / / < nl > - / / trait BasicDashboardSpec < nl > - / / extends FlatSpec < nl > - / / with SqlSpecHelpers < nl > - / / with ScalaFutures < nl > - / / with Matchers < nl > - / / with BeforeAndAfterAll { < nl > - / / < nl > - / / override implicit def patienceConfig : PatienceConfig = < nl > - / / new PatienceConfig ( timeout = Span ( 5 , Seconds ) ) < nl > - / / < nl > - / / lazy val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) < nl > - / / < nl > - / / override def afterAll ( ) : Unit = { < nl > - / / super . afterAll ( ) < nl > - / / database . ioExecutionContext < nl > - / / database . close ( ) < nl > - / / ds . close ( ) < nl > - / / } < nl > - / / < nl > - / / } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala < nl > deleted file mode 100644 < nl > index 3280482 . . 0000000 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala < nl > + + + / dev / null < nl > @ @ - 1 , 177 + 0 , 0 @ @ < nl > - / / package im . actor . server . dashboard < nl > - / / < nl > - / / import scala . concurrent . ExecutionContext . Implicits . global < nl > - / / import scala . concurrent . forkjoin . ThreadLocalRandom < nl > - / / < nl > - / / import com . github . tminglei . slickpg . LTree < nl > - / / import play . api . http . HeaderNames < nl > - / / import play . api . libs . iteratee . Input < nl > - / / import play . api . libs . json . { JsArray , Json } < nl > - / / import play . api . test . FakeRequest < nl > - / / import play . api . test . Helpers . _ < nl > - / / < nl > - / / import im . actor . server . dashboard . controllers . Departments < nl > - / / import im . actor . server . util . IdUtils < nl > - / / import im . actor . server . { models , persist } < nl > - / / < nl > - / / class DepartmentsSpec extends BasicDashboardSpec { < nl > - / / < nl > - / / behavior of " Departments controller " < nl > - / / < nl > - / / " request " should " not authorize " in s . notAuthorized ( ) < nl > - / / < nl > - / / " create dept " should " create new dept with given name and struct " in s . createDept ( ) < nl > - / / < nl > - / / " create dept " should " not create dept when request with invalid json body comes " in s . createDeptInvaidJson ( ) < nl > - / / < nl > - / / " update dept " should " change name to given one " in s . updateDept ( ) < nl > - / / < nl > - / / " update dept " should " not update dept when request with invalid json body comes " in s . updateDeptInvalidJson ( ) < nl > - / / < nl > - / / " delete dept " should " mark dept as deleted at current date " in s . deleteDept ( ) < nl > - / / < nl > - / / " get dept " should " return given dept with all subdepts " in s . getDept ( ) < nl > - / / < nl > - / / case class Dept ( name : String , struct : String ) < nl > - / / < nl > - / / object Depts { < nl > - / / val root = Dept ( " root " , " 1 " ) < nl > - / / val main = Dept ( " Main dept " , " 1 . 1 " ) < nl > - / / val subDept = Dept ( " First sub dept " , " 1 . 1 . 1 " ) < nl > - / / } < nl > - / / < nl > - / / object s { < nl > - / / < nl > - / / val token = " secret " < nl > - / / < nl > - / / def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) < nl > - / / < nl > - / / val authorizedGET = authorized ( GET ) < nl > - / / val authorizedDELETE = authorized ( DELETE ) < nl > - / / val authorizedPUT = authorized ( PUT ) < nl > - / / val authorizedPOST = authorized ( POST ) < nl > - / / < nl > - / / val manager = models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) < nl > - / / < nl > - / / class TestController extends Departments { < nl > - / / override val db = database < nl > - / / } < nl > - / / < nl > - / / val deptsController = new TestController ( ) < nl > - / / < nl > - / / def notAuthorized ( ) = { < nl > - / / val result = deptsController . get ( " 1 . 1 " ) ( FakeRequest ( ) ) < nl > - / / status ( result ) shouldEqual 401 < nl > - / / } < nl > - / / < nl > - / / def createDept ( ) = { < nl > - / / whenReady ( database . run ( persist . Manager . create ( manager ) ) ) { _ ⇒ < nl > - / / val dept = makeDept ( Depts . root ) < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > - / / val body = Json . toJson ( Map ( " title " → dept . name , " struct " → dept . struct . toString ) ) . toString ( ) < nl > - / / val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 201 < nl > - / / < nl > - / / val deptId = ( contentAsJson ( result ) \ " id " ) . as [ Int ] < nl > - / / whenReady ( database . run ( persist . Department . find ( Depts . root . struct ) . headOption ) ) { optDept ⇒ < nl > - / / optDept shouldBe defined < nl > - / / optDept . map { fromDb ⇒ < nl > - / / fromDb . name shouldEqual dept . name < nl > - / / fromDb . struct shouldEqual dept . struct < nl > - / / fromDb . deletedAt should not be defined < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def createDeptInvaidJson ( ) = { < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > - / / val body = Json . toJson ( Map ( " titleZZZ " → " Sales dept 2 " , " struct " → " 2 . 2 . 1 " ) ) . toString ( ) < nl > - / / val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 406 < nl > - / / } < nl > - / / < nl > - / / def updateDept ( ) = { < nl > - / / whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . main ) ) ) ) { _ ⇒ < nl > - / / val newTitle = " Uber Main dept " < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > - / / val body = Json . toJson ( Map ( " title " → newTitle ) ) . toString ( ) < nl > - / / val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 202 < nl > - / / < nl > - / / whenReady ( database . run ( persist . Department . find ( Depts . main . struct ) . headOption ) ) { optDept ⇒ < nl > - / / optDept shouldBe defined < nl > - / / optDept . map { < nl > - / / _ . name shouldEqual newTitle < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / val r = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > - / / val b = Json . toJson ( Map ( " title " → Depts . main . name ) ) . toString ( ) < nl > - / / deptsController . update ( Depts . main . struct ) ( r ) . feed ( Input . El ( b . getBytes ) ) . flatMap ( _ . run ) < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def updateDeptInvalidJson ( ) = { < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > - / / val body = Json . toJson ( Map ( " titleZZZ " → " Some other dept " ) ) . toString ( ) < nl > - / / val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 406 < nl > - / / } < nl > - / / < nl > - / / def deleteDept ( ) = { < nl > - / / whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . subDept ) ) ) ) { _ ⇒ < nl > - / / val delete = deptsController . delete ( Depts . subDept . struct ) ( authorizedDELETE ) < nl > - / / status ( delete ) shouldEqual 202 < nl > - / / whenReady ( database . run ( persist . Department . find ( Depts . subDept . struct ) . headOption ) ) { optDept ⇒ < nl > - / / optDept . map { < nl > - / / _ . deletedAt shouldBe defined < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def getDept ( ) = { < nl > - / / val get = deptsController . get ( Depts . root . struct ) ( authorizedGET ) < nl > - / / status ( get ) shouldEqual 200 < nl > - / / < nl > - / / val depts = contentAsJson ( get ) . as [ JsArray ] < nl > - / / depts . value should have length 1 < nl > - / / < nl > - / / val root = depts ( 0 ) < nl > - / / ( root \ " title " ) . as [ String ] shouldEqual Depts . root . name < nl > - / / ( root \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . root . struct ) . value . mkString . toInt < nl > - / / ( root \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . root . struct ) . toString < nl > - / / val rootItems = ( root \ " items " ) . as [ JsArray ] < nl > - / / rootItems . value should have length 1 < nl > - / / < nl > - / / val main = rootItems ( 0 ) < nl > - / / ( main \ " title " ) . as [ String ] shouldEqual Depts . main . name < nl > - / / ( main \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . main . struct ) . value . mkString . toInt < nl > - / / ( main \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . main . struct ) . toString < nl > - / / val mainItems = ( main \ " items " ) . as [ JsArray ] < nl > - / / mainItems . value should have length 1 < nl > - / / < nl > - / / val subDept = mainItems ( 0 ) < nl > - / / ( subDept \ " title " ) . as [ String ] shouldEqual Depts . subDept . name < nl > - / / ( subDept \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . subDept . struct ) . value . mkString . toInt < nl > - / / ( subDept \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . subDept . struct ) . toString < nl > - / / val subDeptItems = ( subDept \ " items " ) . as [ JsArray ] < nl > - / / subDeptItems . value shouldBe empty < nl > - / / } < nl > - / / < nl > - / / def makeDept ( dept : Dept ) = { < nl > - / / val rnd = ThreadLocalRandom . current ( ) < nl > - / / models . Department ( IdUtils . nextIntId ( rnd ) , dept . name , LTree ( dept . struct ) ) < nl > - / / } < nl > - / / < nl > - / / } < nl > - / / < nl > - / / } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala < nl > deleted file mode 100644 < nl > index 36fd38d . . 0000000 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala < nl > + + + / dev / null < nl > @ @ - 1 , 279 + 0 , 0 @ @ < nl > - / / package im . actor . server . dashboard < nl > - / / < nl > - / / import scala . concurrent . ExecutionContext . Implicits . global < nl > - / / import scala . concurrent . forkjoin . ThreadLocalRandom < nl > - / / < nl > - / / import com . github . tminglei . slickpg . LTree < nl > - / / import play . api . http . HeaderNames < nl > - / / import play . api . libs . iteratee . Input < nl > - / / import play . api . libs . json . { JsArray , JsValue , Json } < nl > - / / import play . api . test . FakeRequest < nl > - / / import play . api . test . Helpers . _ < nl > - / / < nl > - / / import im . actor . server . dashboard . controllers . Users < nl > - / / import im . actor . server . util . { ACLUtils , IdUtils } < nl > - / / import im . actor . server . { models , persist } < nl > - / / < nl > - / / class UsersSpec extends BasicDashboardSpec { < nl > - / / < nl > - / / behavior of " Users controller " < nl > - / / < nl > - / / " get user " should " not authorize " in s . notAuthorized ( ) < nl > - / / < nl > - / / " get user " should " not find user " in s . notFound ( ) < nl > - / / < nl > - / / " get user " should " find single user " in s . singleUser ( ) < nl > - / / < nl > - / / " get user " should " find right user by id from multiple users " in s . byUserId ( ) < nl > - / / < nl > - / / " get user " should " find find user with phone " in s . userWithPhone ( ) < nl > - / / < nl > - / / " delete user " should " mark user as deleted at current date " in s . deleteUser ( ) < nl > - / / < nl > - / / " update user " should " change name to one given in request body " in s . updateUserName ( ) < nl > - / / < nl > - / / " update user " should " not update user when request with invalid json body comes " in s . updateUserInvalidJson ( ) < nl > - / / < nl > - / / " create user " should " create new user with given name and phone " in s . createUser ( ) < nl > - / / < nl > - / / " create user " should " not create user when request with invalid json body comes " in s . createUserInvalidJson ( ) < nl > - / / < nl > - / / " create user " should " not create user with invalid phone " in s . createUserInvalidPhone ( ) < nl > - / / < nl > - / / " create user " should " not create user when phone number duplicates " in s . createUserDuplicateNumber ( ) < nl > - / / < nl > - / / val rnd = ThreadLocalRandom . current ( ) < nl > - / / < nl > - / / object s { < nl > - / / < nl > - / / class TestController extends Users { < nl > - / / override val db = database < nl > - / / } < nl > - / / < nl > - / / val token = " secret " < nl > - / / < nl > - / / def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) < nl > - / / < nl > - / / val authorizedGET = authorized ( GET ) < nl > - / / val authorizedDELETE = authorized ( DELETE ) < nl > - / / val authorizedPUT = authorized ( PUT ) < nl > - / / val authorizedPOST = authorized ( POST ) < nl > - / / < nl > - / / def notAuthorized ( ) = { < nl > - / / val result = new TestController ( ) . get ( 22 ) ( FakeRequest ( ) ) < nl > - / / status ( result ) shouldEqual 401 < nl > - / / } < nl > - / / < nl > - / / def notFound ( ) = { < nl > - / / whenReady ( database . run ( persist . Manager . create ( models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) ) ) ) { _ ⇒ < nl > - / / val result = new TestController ( ) . get ( 22 ) ( authorizedGET ) < nl > - / / status ( result ) shouldEqual 404 < nl > - / / ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldEqual " No such user found " < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def singleUser ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ < nl > - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) < nl > - / / status ( result ) shouldEqual 200 < nl > - / / val userResult : JsValue = contentAsJson ( result ) < nl > - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id < nl > - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name < nl > - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 < nl > - / / ( userResult \ " phones " ) . as [ JsArray ] . value shouldBe empty < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def userWithPhone ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / val phone = genPhone ( user . id , 75552223311L ) < nl > - / / whenReady ( database . run { < nl > - / / for { < nl > - / / _ ← persist . User . create ( user ) < nl > - / / _ ← persist . UserPhone . create ( phone ) < nl > - / / } yield ( ) < nl > - / / } ) { _ ⇒ < nl > - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) < nl > - / / status ( result ) shouldEqual 200 < nl > - / / val userResult : JsValue = contentAsJson ( result ) < nl > - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id < nl > - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name < nl > - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 < nl > - / / ( userResult \ " phones " ) . as [ JsArray ] . value should have length 1 < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def byUserId ( ) = { < nl > - / / whenReady ( database . run { < nl > - / / for { < nl > - / / _ ← persist . User . create ( genUser ( ) ) < nl > - / / user = genUser ( ) < nl > - / / _ ← persist . User . create ( user ) < nl > - / / } yield user < nl > - / / } ) { user ⇒ < nl > - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) < nl > - / / status ( result ) shouldEqual 200 < nl > - / / val userResult : JsValue = contentAsJson ( result ) < nl > - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id < nl > - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name < nl > - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def deleteUser ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ < nl > - / / val delete = new TestController ( ) . delete ( user . id ) ( authorizedDELETE ) < nl > - / / status ( delete ) shouldEqual 202 < nl > - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ < nl > - / / optUser . map { < nl > - / / _ . deletedAt shouldBe defined < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def updateUserName ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ < nl > - / / < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val update = authorizedPUT . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val result = new TestController ( ) . update ( user . id ) ( update ) . < nl > - / / feed ( Input . El ( Json . toJson ( Map ( " name " → " George Bush " ) ) . toString ( ) . getBytes ) ) . < nl > - / / flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 202 < nl > - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ < nl > - / / optUser . map { < nl > - / / _ . name shouldEqual " George Bush " < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def updateUserInvalidJson ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ < nl > - / / < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val update = authorizedPUT . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val result = new TestController ( ) . update ( user . id ) ( update ) . < nl > - / / feed ( Input . El ( Json . toJson ( Map ( " nameZZZZ " → " George Bush " ) ) . toString ( ) . getBytes ) ) . < nl > - / / flatMap ( _ . run ) < nl > - / / < nl > - / / status ( result ) shouldEqual 406 < nl > - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ < nl > - / / optUser . map { < nl > - / / _ . name shouldEqual user . name < nl > - / / } getOrElse fail < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def createUser ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / val phone = genPhone ( user . id , 75552223312L ) < nl > - / / val dept = " 1 . 1 " < nl > - / / < nl > - / / val department = models . Department ( 1 , " main dept " , LTree ( dept ) ) < nl > - / / whenReady ( database . run ( persist . Department . create ( department ) ) ) { _ ⇒ < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val body = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > - / / status ( result ) shouldEqual 201 < nl > - / / < nl > - / / val userId = ( contentAsJson ( result ) \ " id " ) . as [ Int ] < nl > - / / < nl > - / / whenReady ( database . run { < nl > - / / for { < nl > - / / user ← persist . User . find ( userId ) . headOption < nl > - / / phone ← persist . UserPhone . findByUserId ( userId ) < nl > - / / } yield ( user , phone ) < nl > - / / } ) { up ⇒ < nl > - / / val ( uptUser , phones ) = up < nl > - / / uptUser shouldBe defined < nl > - / / uptUser . map { u ⇒ < nl > - / / u . name shouldEqual user . name < nl > - / / u . sex shouldEqual user . sex < nl > - / / u . state shouldEqual user . state < nl > - / / u . countryCode shouldEqual " RU " / / from Accept language header < nl > - / / u . deletedAt shouldEqual user . deletedAt < nl > - / / } getOrElse fail < nl > - / / phones should have length 1 < nl > - / / phones . map { < nl > - / / _ . number shouldEqual phone . number < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def createUserInvalidJson ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / val phone = genPhone ( user . id , 75552223312L ) < nl > - / / val dept = " 1 . 1 " < nl > - / / < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phoneZZ " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > - / / status ( result ) shouldEqual 406 < nl > - / / } < nl > - / / < nl > - / / def createUserInvalidPhone ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / val phone = genPhone ( user . id , 1 ) < nl > - / / val dept = " 1 . 1 " < nl > - / / < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > - / / status ( result ) shouldEqual 406 < nl > - / / } < nl > - / / < nl > - / / def createUserDuplicateNumber ( ) = { < nl > - / / val user = genUser ( ) < nl > - / / val phone = genPhone ( user . id , 75552223312L ) < nl > - / / val dept = " 1 . 1 " < nl > - / / < nl > - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > - / / val request = authorizedPOST . < nl > - / / withHeaders ( < nl > - / / HeaderNames . CONTENT _ TYPE → " application / json " , < nl > - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > - / / ) < nl > - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > - / / status ( result ) shouldEqual 406 < nl > - / / ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldBe s " User with phone $ { phone . number } already exists " < nl > - / / } < nl > - / / } < nl > - / / < nl > - / / def genUser ( ) : models . User = models . User ( IdUtils . nextIntId ( rnd ) , ACLUtils . nextAccessSalt ( rnd ) , " Henry Ford " , " US " , models . NoSex , models . UserState . Registered ) < nl > - / / < nl > - / / def genPhone ( userId : Int , phone : Long ) = models . UserPhone ( IdUtils . nextIntId ( rnd ) , userId , ACLUtils . nextAccessSalt ( rnd ) , phone , " Mobile phone " ) < nl > - / / < nl > - / / } < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index fbd1a79 . . 5f96705 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 105 , 7 + 105 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing { < nl > . settings ( releaseSettings ) < nl > . dependsOn ( actorServerSdk ) < nl > . aggregate ( < nl > - / / actorDashboard , < nl > actorServerSdk , < nl > actorTestkit , < nl > actorTests
NEAREST DIFF (one line): diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala < nl > index c06511a . . fba4aa3 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala < nl > @ @ - 20 , 7 + 20 , 7 @ @ class Application extends Controller { < nl > request . body . validate [ LoginForm ] . map { form ⇒ < nl > db . run { < nl > ( for { < nl > - optManager ← persist . Manager . findByEmail ( form . email ) . headOption < nl > + optManager ← persist . Manager . findByEmail ( form . email ) < nl > optAuthCode ← persist . AuthSmsCode . findByPhoneNumber ( form . email . toLong ) . headOption / / TODO : write persist . AuthSmsCode . findByEmail ( form . email ) implementation < nl > } yield ( optManager , optAuthCode ) ) . flatMap { < nl > case ( Some ( manager ) , Some ( authCode ) ) ⇒ < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala < nl > index 296d484 . . 988d59d 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala < nl > @ @ - 8 , 8 + 8 , 8 @ @ import play . api . mvc . { BodyParsers , Controller } < nl > import slick . dbio . DBIO < nl > < nl > import im . actor . server . dashboard . controllers . utils . DepartmentUtils . _ < nl > - import im . actor . server . dashboard . controllers . utils . { AuthAction , Db } < nl > import im . actor . server . dashboard . controllers . utils . json . DepartmentsJsonImplicits . _ < nl > + import im . actor . server . dashboard . controllers . utils . { AuthAction , Db } < nl > import im . actor . server . { models , persist } < nl > < nl > class Departments extends Controller { < nl > @ @ - 32 , 13 + 32 , 14 @ @ class Departments extends Controller { < nl > } < nl > < nl > def create = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ < nl > - request . body . validate [ models . Department ] . map { department ⇒ < nl > - db . run { < nl > + request . body . validate [ models . Department ] . fold ( < nl > + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , < nl > + department ⇒ db . run { < nl > for { < nl > _ ← persist . Department . create ( department ) < nl > } yield Created ( Json . toJson ( Map ( " id " → department . id ) ) ) < nl > } < nl > - } getOrElse Future ( BadRequest ) < nl > + ) < nl > } < nl > < nl > def get ( struct : String ) = AuthAction . async { request ⇒ < nl > @ @ - 48 , 15 + 49 , 14 @ @ class Departments extends Controller { < nl > } < nl > < nl > def update ( struct : String ) = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ < nl > - request . body . validate [ Option [ String ] ] . map { optName ⇒ < nl > - db . run { < nl > + request . body . validate [ DepartmentUpdate ] . fold ( < nl > + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , < nl > + update ⇒ db . run { < nl > for { < nl > - _ ← optName . map { < nl > - persist . Department . setName ( struct , _ ) < nl > - } getOrElse DBIO . successful ( Ok ) < nl > + _ ← persist . Department . setName ( struct , update . title ) < nl > } yield Accepted < nl > } < nl > - } getOrElse Future ( BadRequest ) < nl > + ) < nl > } < nl > < nl > def delete ( struct : String ) = AuthAction . async { _ ⇒ < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala < nl > index 098adbd . . f91cc23 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala < nl > @ @ - 1 , 11 + 1 , 11 @ @ < nl > package im . actor . server . dashboard . controllers < nl > < nl > - import java . sql . SQLException < nl > - < nl > import scala . concurrent . Future < nl > < nl > import play . api . libs . concurrent . Execution . Implicits . _ < nl > + import play . api . libs . json . { JsError , Json } < nl > import play . api . mvc . { Action , BodyParsers , Controller } < nl > + import slick . dbio . DBIO < nl > < nl > import im . actor . server . dashboard . controllers . utils . Db . _ < nl > import im . actor . server . dashboard . controllers . utils . json . ManagersJsonImplicits . _ < nl > @ @ - 14 , 11 + 14 , 23 @ @ import im . actor . server . { models , persist } < nl > class Managers extends Controller { < nl > < nl > def create = Action . async ( BodyParsers . parse . json ) { request ⇒ < nl > - request . body . validate [ models . Manager ] map { manager ⇒ < nl > - db . run ( persist . Manager . create ( manager ) ) . < nl > - map { res ⇒ Created } . < nl > - recover { case e : SQLException ⇒ BadRequest ( e . getMessage ) } < nl > - } getOrElse Future ( BadRequest ) < nl > + request . body . validate [ models . Manager ] . fold ( < nl > + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , < nl > + fromRequest ⇒ db . run { < nl > + for { < nl > + duplicate ← persist . Manager . findByEmail ( fromRequest . email ) < nl > + result ← duplicate . map { d ⇒ < nl > + DBIO . successful ( < nl > + NotAcceptable ( Json . toJson ( Map ( " message " → s " Manager with email $ { fromRequest . email } already exists " ) ) ) < nl > + ) < nl > + } getOrElse { < nl > + for { < nl > + _ ← persist . Manager . create ( fromRequest ) < nl > + } yield Created < nl > + } < nl > + } yield result < nl > + } < nl > + ) < nl > } < nl > < nl > } < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala < nl > index 4926f7d . . ccc3bea 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala < nl > @ @ - 30 , 34 + 30 , 39 @ @ class Users extends Controller { < nl > } < nl > < nl > def create = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ < nl > - request . body . validate [ Lang2CompleteUser ] . map { userAndPhone ⇒ < nl > - db . run { < nl > - userAndPhone ( request . acceptLanguages . headOption ) match { < nl > - case Some ( ( user , struct , phone ) ) ⇒ < nl > + request . body . validate [ CompleteUser ] ( userReads ( request . acceptLanguages . headOption ) ) . fold ( < nl > + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , < nl > + completeUser ⇒ db . run { < nl > + for { < nl > + dept ← persist . Department . find ( completeUser . struct ) . headOption < nl > + result ← dept . map { d ⇒ < nl > for { < nl > - dept ← persist . Department . find ( struct ) . headOption < nl > - result ← dept . map { d ⇒ < nl > + optPhone ← persist . UserPhone . findByPhoneNumber ( completeUser . phone . number ) . headOption < nl > + result ← optPhone . map { phone ⇒ < nl > + DBIO . successful ( < nl > + NotAcceptable ( Json . toJson ( Map ( " message " → s " User with phone $ { phone . number } already exists " ) ) ) < nl > + ) < nl > + } getOrElse { < nl > for { < nl > - _ ← persist . User . create ( user ) < nl > - _ ← persist . UserPhone . create ( phone ) < nl > - _ ← persist . UserDepartment . create ( user . id , d . id ) < nl > - } yield Created ( Json . toJson ( Map ( " id " → user . id ) ) ) < nl > - } getOrElse DBIO . successful ( BadRequest ( Json . toJson ( Map ( " message " → " No user was created " ) ) ) ) < nl > + _ ← persist . User . create ( completeUser . user ) < nl > + _ ← persist . UserPhone . create ( completeUser . phone ) < nl > + _ ← persist . UserDepartment . create ( completeUser . user . id , d . id ) < nl > + } yield Created ( Json . toJson ( Map ( " id " → completeUser . user . id ) ) ) < nl > + } < nl > } yield result < nl > - case _ ⇒ DBIO . successful ( BadRequest ( Json . toJson ( Map ( " message " → " No name and phone provided " ) ) ) ) < nl > - } < nl > + } getOrElse DBIO . successful ( NotAcceptable ( Json . toJson ( Map ( " message " → " User was not created because no such department exist " ) ) ) ) < nl > + } yield result < nl > } < nl > - } getOrElse Future ( BadRequest ) < nl > + ) < nl > } < nl > < nl > def update ( id : Int ) = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ < nl > - request . body . validate [ Option [ String ] ] . map { optName ⇒ < nl > - db . run { < nl > - for { < nl > - _ ← optName . map { persist . User . setName ( id , _ ) } getOrElse DBIO . successful ( Ok ) < nl > - } yield Accepted < nl > + request . body . validate [ UserUpdate ] . fold ( < nl > + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , < nl > + update ⇒ db . run { < nl > + for ( _ ← persist . User . setName ( id , update . name ) ) yield Accepted < nl > } < nl > - } getOrElse Future ( BadRequest ) < nl > + ) < nl > } < nl > < nl > def delete ( id : Int ) = AuthAction . async { request ⇒ < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala < nl > deleted file mode 100644 < nl > index 67ab3da . . 0000000 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala < nl > + + + / dev / null < nl > @ @ - 1 , 11 + 0 , 0 @ @ < nl > - package im . actor . server . dashboard < nl > - < nl > - import play . api . i18n . Lang < nl > - < nl > - import im . actor . server . models < nl > - < nl > - package object controllers { < nl > - < nl > - type Lang2CompleteUser = Option [ Lang ] ⇒ Option [ ( models . User , String , models . UserPhone ) ] < nl > - < nl > - } < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala < nl > index 54fba92 . . 3d2b47b 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import com . github . tminglei . slickpg . LTree < nl > import play . api . libs . functional . syntax . _ < nl > import play . api . libs . json . _ < nl > < nl > - import Common . _ < nl > import im . actor . server . dashboard . controllers . utils . NestedDept < nl > + import im . actor . server . dashboard . controllers . utils . json . Common . _ < nl > import im . actor . server . models < nl > import im . actor . server . util . IdUtils < nl > < nl > @ @ - 31 , 7 + 31 , 9 @ @ object DepartmentsJsonImplicits { < nl > ( JsPath \ " struct " ) . read [ String ] ( length ) < nl > ) ( makeDepartment _ ) < nl > < nl > - implicit val deptUpdateReads : Reads [ Option [ String ] ] = ( JsPath \ " title " ) . readNullable [ String ] ( length ) < nl > + case class DepartmentUpdate ( title : String ) < nl > + < nl > + implicit val deptUpdateReads : Reads [ DepartmentUpdate ] = ( JsPath \ " title " ) . read [ String ] ( length ) . map { DepartmentUpdate } < nl > < nl > private def makeDepartment ( name : String , struct : String ) : models . Department = { < nl > val rnd = ThreadLocalRandom . current ( ) < nl > diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala < nl > index be0d2c1 . . 33d09b8 100644 < nl > - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala < nl > + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala < nl > @ @ - 2 , 10 + 2 , 11 @ @ package im . actor . server . dashboard . controllers . utils . json < nl > < nl > import scala . concurrent . forkjoin . ThreadLocalRandom < nl > < nl > + import play . api . data . validation . ValidationError < nl > + import play . api . i18n . Lang < nl > import play . api . libs . functional . syntax . _ < nl > import play . api . libs . json . _ < nl > < nl > - import im . actor . server . dashboard . controllers . _ < nl > import im . actor . server . dashboard . controllers . utils . json . Common . _ < nl > import im . actor . server . models < nl > import im . actor . server . util . IdUtils . _ < nl > @ @ - 22 , 23 + 23 , 31 @ @ object UsersJsonImplicits { < nl > ) < nl > } < nl > < nl > - implicit val userReads : Reads [ Lang2CompleteUser ] = ( < nl > - ( JsPath \ " name " ) . read [ String ] ( length ) and < nl > - ( JsPath \ " dept " ) . read [ String ] ( length ) and < nl > - ( JsPath \ " phone " ) . read [ String ] ( length ) < nl > - ) ( makeUserAndPhone _ ) < nl > + def userReads ( lang : Option [ Lang ] ) : Reads [ CompleteUser ] = { < nl > + val language = lang . getOrElse ( Lang ( " RU " ) ) . language . toUpperCase < nl > + ( ( JsPath \ " name " ) . read [ String ] ( length ) and < nl > + ( JsPath \ " dept " ) . read [ String ] ( length ) and < nl > + ( JsPath \ " phone " ) . read [ String ] ( validPhone ( language ) ) ) ( makeUserAndPhone ( language ) _ ) < nl > + } < nl > + < nl > + def validPhone ( language : String ) ( implicit reads : Reads [ String ] ) : Reads [ String ] = < nl > + Reads [ String ] ( js ⇒ reads . reads ( js ) . filter ( ValidationError ( " error . invalidPhone " , js ) ) { phone ⇒ < nl > + PhoneNumber . isValid ( phone , language ) < nl > + } ) < nl > + < nl > + case class UserUpdate ( name : String ) < nl > + < nl > + implicit val userUpdateReads : Reads [ UserUpdate ] = ( JsPath \ " name " ) . read [ String ] ( length ) . map { UserUpdate } < nl > < nl > - implicit val userUpdateReads : Reads [ Option [ String ] ] = ( JsPath \ " name " ) . readNullable [ String ] ( length ) < nl > + case class CompleteUser ( user : models . User , struct : String , phone : models . UserPhone ) < nl > < nl > - private def makeUserAndPhone ( name : String , struct : String , phone : String ) : Lang2CompleteUser = { lang ⇒ < nl > + private def makeUserAndPhone ( language : String ) ( name : String , struct : String , phone : String ) : CompleteUser = { < nl > val rnd = ThreadLocalRandom . current ( ) < nl > val ( userId , phoneId ) = ( nextIntId ( rnd ) , nextIntId ( rnd ) ) < nl > - for { < nl > - code ← lang . map { _ . language . toUpperCase } < nl > - normalizedPhone ← PhoneNumber . normalizeStr ( phone , code ) < nl > - user = models . User ( userId , ACLUtils . nextAccessSalt ( rnd ) , name , code , models . NoSex , models . UserState . Registered ) < nl > - userPhone = models . UserPhone ( phoneId , userId , ACLUtils . nextAccessSalt ( rnd ) , normalizedPhone , " Mobile phone " ) < nl > - } yield ( user , struct , userPhone ) < nl > + val normalizedPhone = PhoneNumber . tryNormalize ( phone . toLong , language ) < nl > + val user = models . User ( userId , ACLUtils . nextAccessSalt ( rnd ) , name , language , models . NoSex , models . UserState . Registered ) < nl > + val userPhone = models . UserPhone ( phoneId , userId , ACLUtils . nextAccessSalt ( rnd ) , normalizedPhone , " Mobile phone " ) < nl > + CompleteUser ( user , struct , userPhone ) < nl > } < nl > < nl > } < nl > diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala b / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala < nl > index 3dd283d . . 709797e 100644 < nl > - - - a / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala < nl > + + + b / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala < nl > @ @ - 23 , 6 + 23 , 6 @ @ object Manager { < nl > managers + = manager < nl > < nl > def findByEmail ( email : String ) = < nl > - managers . filter ( _ . email = = = email ) . result < nl > + managers . filter ( _ . email = = = email ) . result . headOption < nl > < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala < nl > index dbdc6a7 . . 88bca84 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala < nl > @ @ - 1 , 7 + 1 , 7 @ @ < nl > package im . actor . server . dashboard < nl > < nl > - import org . scalatest . { BeforeAndAfterAll , Matchers , FlatSpec } < nl > import org . scalatest . concurrent . ScalaFutures < nl > + import org . scalatest . { BeforeAndAfterAll , FlatSpec , Matchers } < nl > import slick . driver . PostgresDriver < nl > < nl > import im . actor . server . SqlSpecHelpers < nl > @ @ - 13 , 7 + 13 , 7 @ @ trait BasicDashboardSpec < nl > with Matchers < nl > with BeforeAndAfterAll { < nl > < nl > - val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) < nl > + lazy val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) < nl > < nl > override def afterAll ( ) : Unit = { < nl > super . afterAll ( ) < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala < nl > index 11183a2 . . f874d35 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala < nl > @ @ - 22 , 8 + 22 , 12 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > < nl > " create dept " should " create new dept with given name and struct " in s . createDept ( ) < nl > < nl > + " create dept " should " not create dept when request with invalid json body comes " in s . createDeptInvaidJson ( ) < nl > + < nl > " update dept " should " change name to given one " in s . updateDept ( ) < nl > < nl > + " update dept " should " not update dept when request with invalid json body comes " in s . updateDeptInvalidJson ( ) < nl > + < nl > " delete dept " should " mark dept as deleted at current date " in s . deleteDept ( ) < nl > < nl > " get dept " should " return given dept with all subdepts " in s . getDept ( ) < nl > @ @ - 41 , 16 + 45 , 18 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > val token = " secret " < nl > < nl > def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) < nl > + < nl > val authorizedGET = authorized ( GET ) < nl > val authorizedDELETE = authorized ( DELETE ) < nl > val authorizedPUT = authorized ( PUT ) < nl > val authorizedPOST = authorized ( POST ) < nl > < nl > - val manager = persist . Manager . create ( models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) ) < nl > + val manager = models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) < nl > < nl > class TestController extends Departments { < nl > override val db = database < nl > } < nl > + < nl > val deptsController = new TestController ( ) < nl > < nl > def notAuthorized ( ) = { < nl > @ @ - 59 , 7 + 65 , 7 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > } < nl > < nl > def createDept ( ) = { < nl > - whenReady ( database . run ( manager ) ) { _ ⇒ < nl > + whenReady ( database . run ( persist . Manager . create ( manager ) ) ) { _ ⇒ < nl > val dept = makeDept ( Depts . root ) < nl > / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > @ @ - 80 , 6 + 86 , 15 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > } < nl > } < nl > < nl > + def createDeptInvaidJson ( ) = { < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > + val body = Json . toJson ( Map ( " titleZZZ " → " Sales dept 2 " , " struct " → " 2 . 2 . 1 " ) ) . toString ( ) < nl > + val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > + < nl > + status ( result ) shouldEqual 406 < nl > + } < nl > + < nl > def updateDept ( ) = { < nl > whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . main ) ) ) ) { _ ⇒ < nl > val newTitle = " Uber Main dept " < nl > @ @ - 92 , 7 + 107 , 9 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > < nl > whenReady ( database . run ( persist . Department . find ( Depts . main . struct ) . headOption ) ) { optDept ⇒ < nl > optDept shouldBe defined < nl > - optDept . map { _ . name shouldEqual newTitle } getOrElse fail < nl > + optDept . map { < nl > + _ . name shouldEqual newTitle < nl > + } getOrElse fail < nl > } < nl > val r = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > val b = Json . toJson ( Map ( " title " → Depts . main . name ) ) . toString ( ) < nl > @ @ - 100 , 12 + 117 , 23 @ @ class DepartmentsSpec extends BasicDashboardSpec { < nl > } < nl > } < nl > < nl > + def updateDeptInvalidJson ( ) = { < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) < nl > + val body = Json . toJson ( Map ( " titleZZZ " → " Some other dept " ) ) . toString ( ) < nl > + val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) < nl > + < nl > + status ( result ) shouldEqual 406 < nl > + } < nl > + < nl > def deleteDept ( ) = { < nl > whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . subDept ) ) ) ) { _ ⇒ < nl > val delete = deptsController . delete ( Depts . subDept . struct ) ( authorizedDELETE ) < nl > status ( delete ) shouldEqual 202 < nl > whenReady ( database . run ( persist . Department . find ( Depts . subDept . struct ) . headOption ) ) { optDept ⇒ < nl > - optDept . map { _ . deletedAt shouldBe defined } getOrElse fail < nl > + optDept . map { < nl > + _ . deletedAt shouldBe defined < nl > + } getOrElse fail < nl > } < nl > } < nl > } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala < nl > index df20aba . . 1665849 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala < nl > @ @ - 32 , 8 + 32 , 16 @ @ class UsersSpec extends BasicDashboardSpec { < nl > < nl > " update user " should " change name to one given in request body " in s . updateUserName ( ) < nl > < nl > + " update user " should " not update user when request with invalid json body comes " in s . updateUserInvalidJson ( ) < nl > + < nl > " create user " should " create new user with given name and phone " in s . createUser ( ) < nl > < nl > + " create user " should " not create user when request with invalid json body comes " in s . createUserInvalidJson ( ) < nl > + < nl > + " create user " should " not create user with invalid phone " in s . createUserInvalidPhone ( ) < nl > + < nl > + " create user " should " not create user when phone number duplicates " in s . createUserDuplicateNumber ( ) < nl > + < nl > val rnd = ThreadLocalRandom . current ( ) < nl > < nl > object s { < nl > @ @ - 45 , 6 + 53 , 7 @ @ class UsersSpec extends BasicDashboardSpec { < nl > val token = " secret " < nl > < nl > def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) < nl > + < nl > val authorizedGET = authorized ( GET ) < nl > val authorizedDELETE = authorized ( DELETE ) < nl > val authorizedPUT = authorized ( PUT ) < nl > @ @ - 148 , 6 + 157 , 29 @ @ class UsersSpec extends BasicDashboardSpec { < nl > } < nl > } < nl > < nl > + def updateUserInvalidJson ( ) = { < nl > + val user = genUser ( ) < nl > + whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ < nl > + < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val update = authorizedPUT . < nl > + withHeaders ( < nl > + HeaderNames . CONTENT _ TYPE → " application / json " , < nl > + HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > + ) < nl > + val result = new TestController ( ) . update ( user . id ) ( update ) . < nl > + feed ( Input . El ( Json . toJson ( Map ( " nameZZZZ " → " George Bush " ) ) . toString ( ) . getBytes ) ) . < nl > + flatMap ( _ . run ) < nl > + < nl > + status ( result ) shouldEqual 406 < nl > + whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ < nl > + optUser . map { < nl > + _ . name shouldEqual user . name < nl > + } getOrElse fail < nl > + } < nl > + } < nl > + } < nl > + < nl > def createUser ( ) = { < nl > val user = genUser ( ) < nl > val phone = genPhone ( user . id , 75552223312L ) < nl > @ @ - 189 , 6 + 221 , 55 @ @ class UsersSpec extends BasicDashboardSpec { < nl > } < nl > } < nl > } < nl > + < nl > + def createUserInvalidJson ( ) = { < nl > + val user = genUser ( ) < nl > + val phone = genPhone ( user . id , 75552223312L ) < nl > + val dept = " 1 . 1 " < nl > + < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val request = authorizedPOST . < nl > + withHeaders ( < nl > + HeaderNames . CONTENT _ TYPE → " application / json " , < nl > + HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > + ) < nl > + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phoneZZ " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > + status ( result ) shouldEqual 406 < nl > + } < nl > + < nl > + def createUserInvalidPhone ( ) = { < nl > + val user = genUser ( ) < nl > + val phone = genPhone ( user . id , 1 ) < nl > + val dept = " 1 . 1 " < nl > + < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val request = authorizedPOST . < nl > + withHeaders ( < nl > + HeaderNames . CONTENT _ TYPE → " application / json " , < nl > + HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > + ) < nl > + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > + status ( result ) shouldEqual 406 < nl > + } < nl > + < nl > + def createUserDuplicateNumber ( ) = { < nl > + val user = genUser ( ) < nl > + val phone = genPhone ( user . id , 75552223312L ) < nl > + val dept = " 1 . 1 " < nl > + < nl > + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / < nl > + val request = authorizedPOST . < nl > + withHeaders ( < nl > + HeaderNames . CONTENT _ TYPE → " application / json " , < nl > + HeaderNames . ACCEPT _ LANGUAGE → " RU " < nl > + ) < nl > + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) < nl > + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) < nl > + status ( result ) shouldEqual 406 < nl > + ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldBe s " User with phone $ { phone . number } already exists " < nl > + } < nl > } < nl > < nl > def genUser ( ) : models . User = models . User ( IdUtils . nextIntId ( rnd ) , ACLUtils . nextAccessSalt ( rnd ) , " Henry Ford " , " US " , models . NoSex , models . UserState . Registered )

TEST DIFF:
diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala 
 deleted file mode 100644 
 index bbba56e . . 0000000 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala 
 + + + / dev / null 
 @ @ - 1 , 29 + 0 , 0 @ @ 
 - / / package im . actor . server . dashboard 
 - / / 
 - / / import org . scalatest . concurrent . ScalaFutures 
 - / / import org . scalatest . time . { Seconds , Span } 
 - / / import org . scalatest . { BeforeAndAfterAll , FlatSpec , Matchers } 
 - / / import slick . driver . PostgresDriver 
 - / / 
 - / / import im . actor . server . SqlSpecHelpers 
 - / / 
 - / / trait BasicDashboardSpec 
 - / / extends FlatSpec 
 - / / with SqlSpecHelpers 
 - / / with ScalaFutures 
 - / / with Matchers 
 - / / with BeforeAndAfterAll { 
 - / / 
 - / / override implicit def patienceConfig : PatienceConfig = 
 - / / new PatienceConfig ( timeout = Span ( 5 , Seconds ) ) 
 - / / 
 - / / lazy val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) 
 - / / 
 - / / override def afterAll ( ) : Unit = { 
 - / / super . afterAll ( ) 
 - / / database . ioExecutionContext 
 - / / database . close ( ) 
 - / / ds . close ( ) 
 - / / } 
 - / / 
 - / / } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala 
 deleted file mode 100644 
 index 3280482 . . 0000000 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala 
 + + + / dev / null 
 @ @ - 1 , 177 + 0 , 0 @ @ 
 - / / package im . actor . server . dashboard 
 - / / 
 - / / import scala . concurrent . ExecutionContext . Implicits . global 
 - / / import scala . concurrent . forkjoin . ThreadLocalRandom 
 - / / 
 - / / import com . github . tminglei . slickpg . LTree 
 - / / import play . api . http . HeaderNames 
 - / / import play . api . libs . iteratee . Input 
 - / / import play . api . libs . json . { JsArray , Json } 
 - / / import play . api . test . FakeRequest 
 - / / import play . api . test . Helpers . _ 
 - / / 
 - / / import im . actor . server . dashboard . controllers . Departments 
 - / / import im . actor . server . util . IdUtils 
 - / / import im . actor . server . { models , persist } 
 - / / 
 - / / class DepartmentsSpec extends BasicDashboardSpec { 
 - / / 
 - / / behavior of " Departments controller " 
 - / / 
 - / / " request " should " not authorize " in s . notAuthorized ( ) 
 - / / 
 - / / " create dept " should " create new dept with given name and struct " in s . createDept ( ) 
 - / / 
 - / / " create dept " should " not create dept when request with invalid json body comes " in s . createDeptInvaidJson ( ) 
 - / / 
 - / / " update dept " should " change name to given one " in s . updateDept ( ) 
 - / / 
 - / / " update dept " should " not update dept when request with invalid json body comes " in s . updateDeptInvalidJson ( ) 
 - / / 
 - / / " delete dept " should " mark dept as deleted at current date " in s . deleteDept ( ) 
 - / / 
 - / / " get dept " should " return given dept with all subdepts " in s . getDept ( ) 
 - / / 
 - / / case class Dept ( name : String , struct : String ) 
 - / / 
 - / / object Depts { 
 - / / val root = Dept ( " root " , " 1 " ) 
 - / / val main = Dept ( " Main dept " , " 1 . 1 " ) 
 - / / val subDept = Dept ( " First sub dept " , " 1 . 1 . 1 " ) 
 - / / } 
 - / / 
 - / / object s { 
 - / / 
 - / / val token = " secret " 
 - / / 
 - / / def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) 
 - / / 
 - / / val authorizedGET = authorized ( GET ) 
 - / / val authorizedDELETE = authorized ( DELETE ) 
 - / / val authorizedPUT = authorized ( PUT ) 
 - / / val authorizedPOST = authorized ( POST ) 
 - / / 
 - / / val manager = models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) 
 - / / 
 - / / class TestController extends Departments { 
 - / / override val db = database 
 - / / } 
 - / / 
 - / / val deptsController = new TestController ( ) 
 - / / 
 - / / def notAuthorized ( ) = { 
 - / / val result = deptsController . get ( " 1 . 1 " ) ( FakeRequest ( ) ) 
 - / / status ( result ) shouldEqual 401 
 - / / } 
 - / / 
 - / / def createDept ( ) = { 
 - / / whenReady ( database . run ( persist . Manager . create ( manager ) ) ) { _ ⇒ 
 - / / val dept = makeDept ( Depts . root ) 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 - / / val body = Json . toJson ( Map ( " title " → dept . name , " struct " → dept . struct . toString ) ) . toString ( ) 
 - / / val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 201 
 - / / 
 - / / val deptId = ( contentAsJson ( result ) \ " id " ) . as [ Int ] 
 - / / whenReady ( database . run ( persist . Department . find ( Depts . root . struct ) . headOption ) ) { optDept ⇒ 
 - / / optDept shouldBe defined 
 - / / optDept . map { fromDb ⇒ 
 - / / fromDb . name shouldEqual dept . name 
 - / / fromDb . struct shouldEqual dept . struct 
 - / / fromDb . deletedAt should not be defined 
 - / / } getOrElse fail 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def createDeptInvaidJson ( ) = { 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 - / / val body = Json . toJson ( Map ( " titleZZZ " → " Sales dept 2 " , " struct " → " 2 . 2 . 1 " ) ) . toString ( ) 
 - / / val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 406 
 - / / } 
 - / / 
 - / / def updateDept ( ) = { 
 - / / whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . main ) ) ) ) { _ ⇒ 
 - / / val newTitle = " Uber Main dept " 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 - / / val body = Json . toJson ( Map ( " title " → newTitle ) ) . toString ( ) 
 - / / val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 202 
 - / / 
 - / / whenReady ( database . run ( persist . Department . find ( Depts . main . struct ) . headOption ) ) { optDept ⇒ 
 - / / optDept shouldBe defined 
 - / / optDept . map { 
 - / / _ . name shouldEqual newTitle 
 - / / } getOrElse fail 
 - / / } 
 - / / val r = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 - / / val b = Json . toJson ( Map ( " title " → Depts . main . name ) ) . toString ( ) 
 - / / deptsController . update ( Depts . main . struct ) ( r ) . feed ( Input . El ( b . getBytes ) ) . flatMap ( _ . run ) 
 - / / } 
 - / / } 
 - / / 
 - / / def updateDeptInvalidJson ( ) = { 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 - / / val body = Json . toJson ( Map ( " titleZZZ " → " Some other dept " ) ) . toString ( ) 
 - / / val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 406 
 - / / } 
 - / / 
 - / / def deleteDept ( ) = { 
 - / / whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . subDept ) ) ) ) { _ ⇒ 
 - / / val delete = deptsController . delete ( Depts . subDept . struct ) ( authorizedDELETE ) 
 - / / status ( delete ) shouldEqual 202 
 - / / whenReady ( database . run ( persist . Department . find ( Depts . subDept . struct ) . headOption ) ) { optDept ⇒ 
 - / / optDept . map { 
 - / / _ . deletedAt shouldBe defined 
 - / / } getOrElse fail 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def getDept ( ) = { 
 - / / val get = deptsController . get ( Depts . root . struct ) ( authorizedGET ) 
 - / / status ( get ) shouldEqual 200 
 - / / 
 - / / val depts = contentAsJson ( get ) . as [ JsArray ] 
 - / / depts . value should have length 1 
 - / / 
 - / / val root = depts ( 0 ) 
 - / / ( root \ " title " ) . as [ String ] shouldEqual Depts . root . name 
 - / / ( root \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . root . struct ) . value . mkString . toInt 
 - / / ( root \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . root . struct ) . toString 
 - / / val rootItems = ( root \ " items " ) . as [ JsArray ] 
 - / / rootItems . value should have length 1 
 - / / 
 - / / val main = rootItems ( 0 ) 
 - / / ( main \ " title " ) . as [ String ] shouldEqual Depts . main . name 
 - / / ( main \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . main . struct ) . value . mkString . toInt 
 - / / ( main \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . main . struct ) . toString 
 - / / val mainItems = ( main \ " items " ) . as [ JsArray ] 
 - / / mainItems . value should have length 1 
 - / / 
 - / / val subDept = mainItems ( 0 ) 
 - / / ( subDept \ " title " ) . as [ String ] shouldEqual Depts . subDept . name 
 - / / ( subDept \ " id " ) . as [ Int ] shouldEqual LTree ( Depts . subDept . struct ) . value . mkString . toInt 
 - / / ( subDept \ " internal - id " ) . as [ String ] shouldEqual LTree ( Depts . subDept . struct ) . toString 
 - / / val subDeptItems = ( subDept \ " items " ) . as [ JsArray ] 
 - / / subDeptItems . value shouldBe empty 
 - / / } 
 - / / 
 - / / def makeDept ( dept : Dept ) = { 
 - / / val rnd = ThreadLocalRandom . current ( ) 
 - / / models . Department ( IdUtils . nextIntId ( rnd ) , dept . name , LTree ( dept . struct ) ) 
 - / / } 
 - / / 
 - / / } 
 - / / 
 - / / } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala 
 deleted file mode 100644 
 index 36fd38d . . 0000000 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala 
 + + + / dev / null 
 @ @ - 1 , 279 + 0 , 0 @ @ 
 - / / package im . actor . server . dashboard 
 - / / 
 - / / import scala . concurrent . ExecutionContext . Implicits . global 
 - / / import scala . concurrent . forkjoin . ThreadLocalRandom 
 - / / 
 - / / import com . github . tminglei . slickpg . LTree 
 - / / import play . api . http . HeaderNames 
 - / / import play . api . libs . iteratee . Input 
 - / / import play . api . libs . json . { JsArray , JsValue , Json } 
 - / / import play . api . test . FakeRequest 
 - / / import play . api . test . Helpers . _ 
 - / / 
 - / / import im . actor . server . dashboard . controllers . Users 
 - / / import im . actor . server . util . { ACLUtils , IdUtils } 
 - / / import im . actor . server . { models , persist } 
 - / / 
 - / / class UsersSpec extends BasicDashboardSpec { 
 - / / 
 - / / behavior of " Users controller " 
 - / / 
 - / / " get user " should " not authorize " in s . notAuthorized ( ) 
 - / / 
 - / / " get user " should " not find user " in s . notFound ( ) 
 - / / 
 - / / " get user " should " find single user " in s . singleUser ( ) 
 - / / 
 - / / " get user " should " find right user by id from multiple users " in s . byUserId ( ) 
 - / / 
 - / / " get user " should " find find user with phone " in s . userWithPhone ( ) 
 - / / 
 - / / " delete user " should " mark user as deleted at current date " in s . deleteUser ( ) 
 - / / 
 - / / " update user " should " change name to one given in request body " in s . updateUserName ( ) 
 - / / 
 - / / " update user " should " not update user when request with invalid json body comes " in s . updateUserInvalidJson ( ) 
 - / / 
 - / / " create user " should " create new user with given name and phone " in s . createUser ( ) 
 - / / 
 - / / " create user " should " not create user when request with invalid json body comes " in s . createUserInvalidJson ( ) 
 - / / 
 - / / " create user " should " not create user with invalid phone " in s . createUserInvalidPhone ( ) 
 - / / 
 - / / " create user " should " not create user when phone number duplicates " in s . createUserDuplicateNumber ( ) 
 - / / 
 - / / val rnd = ThreadLocalRandom . current ( ) 
 - / / 
 - / / object s { 
 - / / 
 - / / class TestController extends Users { 
 - / / override val db = database 
 - / / } 
 - / / 
 - / / val token = " secret " 
 - / / 
 - / / def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) 
 - / / 
 - / / val authorizedGET = authorized ( GET ) 
 - / / val authorizedDELETE = authorized ( DELETE ) 
 - / / val authorizedPUT = authorized ( PUT ) 
 - / / val authorizedPOST = authorized ( POST ) 
 - / / 
 - / / def notAuthorized ( ) = { 
 - / / val result = new TestController ( ) . get ( 22 ) ( FakeRequest ( ) ) 
 - / / status ( result ) shouldEqual 401 
 - / / } 
 - / / 
 - / / def notFound ( ) = { 
 - / / whenReady ( database . run ( persist . Manager . create ( models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) ) ) ) { _ ⇒ 
 - / / val result = new TestController ( ) . get ( 22 ) ( authorizedGET ) 
 - / / status ( result ) shouldEqual 404 
 - / / ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldEqual " No such user found " 
 - / / } 
 - / / } 
 - / / 
 - / / def singleUser ( ) = { 
 - / / val user = genUser ( ) 
 - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ 
 - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) 
 - / / status ( result ) shouldEqual 200 
 - / / val userResult : JsValue = contentAsJson ( result ) 
 - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id 
 - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name 
 - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 
 - / / ( userResult \ " phones " ) . as [ JsArray ] . value shouldBe empty 
 - / / } 
 - / / } 
 - / / 
 - / / def userWithPhone ( ) = { 
 - / / val user = genUser ( ) 
 - / / val phone = genPhone ( user . id , 75552223311L ) 
 - / / whenReady ( database . run { 
 - / / for { 
 - / / _ ← persist . User . create ( user ) 
 - / / _ ← persist . UserPhone . create ( phone ) 
 - / / } yield ( ) 
 - / / } ) { _ ⇒ 
 - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) 
 - / / status ( result ) shouldEqual 200 
 - / / val userResult : JsValue = contentAsJson ( result ) 
 - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id 
 - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name 
 - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 
 - / / ( userResult \ " phones " ) . as [ JsArray ] . value should have length 1 
 - / / } 
 - / / } 
 - / / 
 - / / def byUserId ( ) = { 
 - / / whenReady ( database . run { 
 - / / for { 
 - / / _ ← persist . User . create ( genUser ( ) ) 
 - / / user = genUser ( ) 
 - / / _ ← persist . User . create ( user ) 
 - / / } yield user 
 - / / } ) { user ⇒ 
 - / / val result = new TestController ( ) . get ( user . id ) ( authorizedGET ) 
 - / / status ( result ) shouldEqual 200 
 - / / val userResult : JsValue = contentAsJson ( result ) 
 - / / ( userResult \ " id " ) . as [ Int ] shouldEqual user . id 
 - / / ( userResult \ " name " ) . as [ String ] shouldEqual user . name 
 - / / ( userResult \ " sex " ) . as [ Int ] shouldEqual 1 
 - / / } 
 - / / } 
 - / / 
 - / / def deleteUser ( ) = { 
 - / / val user = genUser ( ) 
 - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ 
 - / / val delete = new TestController ( ) . delete ( user . id ) ( authorizedDELETE ) 
 - / / status ( delete ) shouldEqual 202 
 - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ 
 - / / optUser . map { 
 - / / _ . deletedAt shouldBe defined 
 - / / } getOrElse fail 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def updateUserName ( ) = { 
 - / / val user = genUser ( ) 
 - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ 
 - / / 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val update = authorizedPUT . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val result = new TestController ( ) . update ( user . id ) ( update ) . 
 - / / feed ( Input . El ( Json . toJson ( Map ( " name " → " George Bush " ) ) . toString ( ) . getBytes ) ) . 
 - / / flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 202 
 - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ 
 - / / optUser . map { 
 - / / _ . name shouldEqual " George Bush " 
 - / / } getOrElse fail 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def updateUserInvalidJson ( ) = { 
 - / / val user = genUser ( ) 
 - / / whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ 
 - / / 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val update = authorizedPUT . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val result = new TestController ( ) . update ( user . id ) ( update ) . 
 - / / feed ( Input . El ( Json . toJson ( Map ( " nameZZZZ " → " George Bush " ) ) . toString ( ) . getBytes ) ) . 
 - / / flatMap ( _ . run ) 
 - / / 
 - / / status ( result ) shouldEqual 406 
 - / / whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ 
 - / / optUser . map { 
 - / / _ . name shouldEqual user . name 
 - / / } getOrElse fail 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def createUser ( ) = { 
 - / / val user = genUser ( ) 
 - / / val phone = genPhone ( user . id , 75552223312L ) 
 - / / val dept = " 1 . 1 " 
 - / / 
 - / / val department = models . Department ( 1 , " main dept " , LTree ( dept ) ) 
 - / / whenReady ( database . run ( persist . Department . create ( department ) ) ) { _ ⇒ 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val body = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 - / / status ( result ) shouldEqual 201 
 - / / 
 - / / val userId = ( contentAsJson ( result ) \ " id " ) . as [ Int ] 
 - / / 
 - / / whenReady ( database . run { 
 - / / for { 
 - / / user ← persist . User . find ( userId ) . headOption 
 - / / phone ← persist . UserPhone . findByUserId ( userId ) 
 - / / } yield ( user , phone ) 
 - / / } ) { up ⇒ 
 - / / val ( uptUser , phones ) = up 
 - / / uptUser shouldBe defined 
 - / / uptUser . map { u ⇒ 
 - / / u . name shouldEqual user . name 
 - / / u . sex shouldEqual user . sex 
 - / / u . state shouldEqual user . state 
 - / / u . countryCode shouldEqual " RU " / / from Accept language header 
 - / / u . deletedAt shouldEqual user . deletedAt 
 - / / } getOrElse fail 
 - / / phones should have length 1 
 - / / phones . map { 
 - / / _ . number shouldEqual phone . number 
 - / / } 
 - / / } 
 - / / } 
 - / / } 
 - / / 
 - / / def createUserInvalidJson ( ) = { 
 - / / val user = genUser ( ) 
 - / / val phone = genPhone ( user . id , 75552223312L ) 
 - / / val dept = " 1 . 1 " 
 - / / 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phoneZZ " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 - / / status ( result ) shouldEqual 406 
 - / / } 
 - / / 
 - / / def createUserInvalidPhone ( ) = { 
 - / / val user = genUser ( ) 
 - / / val phone = genPhone ( user . id , 1 ) 
 - / / val dept = " 1 . 1 " 
 - / / 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 - / / status ( result ) shouldEqual 406 
 - / / } 
 - / / 
 - / / def createUserDuplicateNumber ( ) = { 
 - / / val user = genUser ( ) 
 - / / val phone = genPhone ( user . id , 75552223312L ) 
 - / / val dept = " 1 . 1 " 
 - / / 
 - / / / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 - / / val request = authorizedPOST . 
 - / / withHeaders ( 
 - / / HeaderNames . CONTENT _ TYPE → " application / json " , 
 - / / HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 - / / ) 
 - / / val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 - / / val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 - / / status ( result ) shouldEqual 406 
 - / / ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldBe s " User with phone $ { phone . number } already exists " 
 - / / } 
 - / / } 
 - / / 
 - / / def genUser ( ) : models . User = models . User ( IdUtils . nextIntId ( rnd ) , ACLUtils . nextAccessSalt ( rnd ) , " Henry Ford " , " US " , models . NoSex , models . UserState . Registered ) 
 - / / 
 - / / def genPhone ( userId : Int , phone : Long ) = models . UserPhone ( IdUtils . nextIntId ( rnd ) , userId , ACLUtils . nextAccessSalt ( rnd ) , phone , " Mobile phone " ) 
 - / / 
 - / / } 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index fbd1a79 . . 5f96705 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 105 , 7 + 105 , 6 @ @ object Build extends sbt . Build with Versioning with Releasing { 
 . settings ( releaseSettings ) 
 . dependsOn ( actorServerSdk ) 
 . aggregate ( 
 - / / actorDashboard , 
 actorServerSdk , 
 actorTestkit , 
 actorTests

NEAREST DIFF:
diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala 
 index c06511a . . fba4aa3 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Application . scala 
 @ @ - 20 , 7 + 20 , 7 @ @ class Application extends Controller { 
 request . body . validate [ LoginForm ] . map { form ⇒ 
 db . run { 
 ( for { 
 - optManager ← persist . Manager . findByEmail ( form . email ) . headOption 
 + optManager ← persist . Manager . findByEmail ( form . email ) 
 optAuthCode ← persist . AuthSmsCode . findByPhoneNumber ( form . email . toLong ) . headOption / / TODO : write persist . AuthSmsCode . findByEmail ( form . email ) implementation 
 } yield ( optManager , optAuthCode ) ) . flatMap { 
 case ( Some ( manager ) , Some ( authCode ) ) ⇒ 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala 
 index 296d484 . . 988d59d 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Departments . scala 
 @ @ - 8 , 8 + 8 , 8 @ @ import play . api . mvc . { BodyParsers , Controller } 
 import slick . dbio . DBIO 
 
 import im . actor . server . dashboard . controllers . utils . DepartmentUtils . _ 
 - import im . actor . server . dashboard . controllers . utils . { AuthAction , Db } 
 import im . actor . server . dashboard . controllers . utils . json . DepartmentsJsonImplicits . _ 
 + import im . actor . server . dashboard . controllers . utils . { AuthAction , Db } 
 import im . actor . server . { models , persist } 
 
 class Departments extends Controller { 
 @ @ - 32 , 13 + 32 , 14 @ @ class Departments extends Controller { 
 } 
 
 def create = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ 
 - request . body . validate [ models . Department ] . map { department ⇒ 
 - db . run { 
 + request . body . validate [ models . Department ] . fold ( 
 + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , 
 + department ⇒ db . run { 
 for { 
 _ ← persist . Department . create ( department ) 
 } yield Created ( Json . toJson ( Map ( " id " → department . id ) ) ) 
 } 
 - } getOrElse Future ( BadRequest ) 
 + ) 
 } 
 
 def get ( struct : String ) = AuthAction . async { request ⇒ 
 @ @ - 48 , 15 + 49 , 14 @ @ class Departments extends Controller { 
 } 
 
 def update ( struct : String ) = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ 
 - request . body . validate [ Option [ String ] ] . map { optName ⇒ 
 - db . run { 
 + request . body . validate [ DepartmentUpdate ] . fold ( 
 + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , 
 + update ⇒ db . run { 
 for { 
 - _ ← optName . map { 
 - persist . Department . setName ( struct , _ ) 
 - } getOrElse DBIO . successful ( Ok ) 
 + _ ← persist . Department . setName ( struct , update . title ) 
 } yield Accepted 
 } 
 - } getOrElse Future ( BadRequest ) 
 + ) 
 } 
 
 def delete ( struct : String ) = AuthAction . async { _ ⇒ 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala 
 index 098adbd . . f91cc23 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Managers . scala 
 @ @ - 1 , 11 + 1 , 11 @ @ 
 package im . actor . server . dashboard . controllers 
 
 - import java . sql . SQLException 
 - 
 import scala . concurrent . Future 
 
 import play . api . libs . concurrent . Execution . Implicits . _ 
 + import play . api . libs . json . { JsError , Json } 
 import play . api . mvc . { Action , BodyParsers , Controller } 
 + import slick . dbio . DBIO 
 
 import im . actor . server . dashboard . controllers . utils . Db . _ 
 import im . actor . server . dashboard . controllers . utils . json . ManagersJsonImplicits . _ 
 @ @ - 14 , 11 + 14 , 23 @ @ import im . actor . server . { models , persist } 
 class Managers extends Controller { 
 
 def create = Action . async ( BodyParsers . parse . json ) { request ⇒ 
 - request . body . validate [ models . Manager ] map { manager ⇒ 
 - db . run ( persist . Manager . create ( manager ) ) . 
 - map { res ⇒ Created } . 
 - recover { case e : SQLException ⇒ BadRequest ( e . getMessage ) } 
 - } getOrElse Future ( BadRequest ) 
 + request . body . validate [ models . Manager ] . fold ( 
 + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , 
 + fromRequest ⇒ db . run { 
 + for { 
 + duplicate ← persist . Manager . findByEmail ( fromRequest . email ) 
 + result ← duplicate . map { d ⇒ 
 + DBIO . successful ( 
 + NotAcceptable ( Json . toJson ( Map ( " message " → s " Manager with email $ { fromRequest . email } already exists " ) ) ) 
 + ) 
 + } getOrElse { 
 + for { 
 + _ ← persist . Manager . create ( fromRequest ) 
 + } yield Created 
 + } 
 + } yield result 
 + } 
 + ) 
 } 
 
 } 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala 
 index 4926f7d . . ccc3bea 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / Users . scala 
 @ @ - 30 , 34 + 30 , 39 @ @ class Users extends Controller { 
 } 
 
 def create = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ 
 - request . body . validate [ Lang2CompleteUser ] . map { userAndPhone ⇒ 
 - db . run { 
 - userAndPhone ( request . acceptLanguages . headOption ) match { 
 - case Some ( ( user , struct , phone ) ) ⇒ 
 + request . body . validate [ CompleteUser ] ( userReads ( request . acceptLanguages . headOption ) ) . fold ( 
 + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , 
 + completeUser ⇒ db . run { 
 + for { 
 + dept ← persist . Department . find ( completeUser . struct ) . headOption 
 + result ← dept . map { d ⇒ 
 for { 
 - dept ← persist . Department . find ( struct ) . headOption 
 - result ← dept . map { d ⇒ 
 + optPhone ← persist . UserPhone . findByPhoneNumber ( completeUser . phone . number ) . headOption 
 + result ← optPhone . map { phone ⇒ 
 + DBIO . successful ( 
 + NotAcceptable ( Json . toJson ( Map ( " message " → s " User with phone $ { phone . number } already exists " ) ) ) 
 + ) 
 + } getOrElse { 
 for { 
 - _ ← persist . User . create ( user ) 
 - _ ← persist . UserPhone . create ( phone ) 
 - _ ← persist . UserDepartment . create ( user . id , d . id ) 
 - } yield Created ( Json . toJson ( Map ( " id " → user . id ) ) ) 
 - } getOrElse DBIO . successful ( BadRequest ( Json . toJson ( Map ( " message " → " No user was created " ) ) ) ) 
 + _ ← persist . User . create ( completeUser . user ) 
 + _ ← persist . UserPhone . create ( completeUser . phone ) 
 + _ ← persist . UserDepartment . create ( completeUser . user . id , d . id ) 
 + } yield Created ( Json . toJson ( Map ( " id " → completeUser . user . id ) ) ) 
 + } 
 } yield result 
 - case _ ⇒ DBIO . successful ( BadRequest ( Json . toJson ( Map ( " message " → " No name and phone provided " ) ) ) ) 
 - } 
 + } getOrElse DBIO . successful ( NotAcceptable ( Json . toJson ( Map ( " message " → " User was not created because no such department exist " ) ) ) ) 
 + } yield result 
 } 
 - } getOrElse Future ( BadRequest ) 
 + ) 
 } 
 
 def update ( id : Int ) = AuthAction . async ( BodyParsers . parse . json ) { request ⇒ 
 - request . body . validate [ Option [ String ] ] . map { optName ⇒ 
 - db . run { 
 - for { 
 - _ ← optName . map { persist . User . setName ( id , _ ) } getOrElse DBIO . successful ( Ok ) 
 - } yield Accepted 
 + request . body . validate [ UserUpdate ] . fold ( 
 + errors ⇒ Future . successful ( NotAcceptable ( Json . toJson ( JsError . toFlatJson ( errors ) ) ) ) , 
 + update ⇒ db . run { 
 + for ( _ ← persist . User . setName ( id , update . name ) ) yield Accepted 
 } 
 - } getOrElse Future ( BadRequest ) 
 + ) 
 } 
 
 def delete ( id : Int ) = AuthAction . async { request ⇒ 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala 
 deleted file mode 100644 
 index 67ab3da . . 0000000 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / package . scala 
 + + + / dev / null 
 @ @ - 1 , 11 + 0 , 0 @ @ 
 - package im . actor . server . dashboard 
 - 
 - import play . api . i18n . Lang 
 - 
 - import im . actor . server . models 
 - 
 - package object controllers { 
 - 
 - type Lang2CompleteUser = Option [ Lang ] ⇒ Option [ ( models . User , String , models . UserPhone ) ] 
 - 
 - } 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala 
 index 54fba92 . . 3d2b47b 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / DepartmentsJsonImplicits . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import com . github . tminglei . slickpg . LTree 
 import play . api . libs . functional . syntax . _ 
 import play . api . libs . json . _ 
 
 - import Common . _ 
 import im . actor . server . dashboard . controllers . utils . NestedDept 
 + import im . actor . server . dashboard . controllers . utils . json . Common . _ 
 import im . actor . server . models 
 import im . actor . server . util . IdUtils 
 
 @ @ - 31 , 7 + 31 , 9 @ @ object DepartmentsJsonImplicits { 
 ( JsPath \ " struct " ) . read [ String ] ( length ) 
 ) ( makeDepartment _ ) 
 
 - implicit val deptUpdateReads : Reads [ Option [ String ] ] = ( JsPath \ " title " ) . readNullable [ String ] ( length ) 
 + case class DepartmentUpdate ( title : String ) 
 + 
 + implicit val deptUpdateReads : Reads [ DepartmentUpdate ] = ( JsPath \ " title " ) . read [ String ] ( length ) . map { DepartmentUpdate } 
 
 private def makeDepartment ( name : String , struct : String ) : models . Department = { 
 val rnd = ThreadLocalRandom . current ( ) 
 diff - - git a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala 
 index be0d2c1 . . 33d09b8 100644 
 - - - a / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala 
 + + + b / actor - dashboard / app / im / actor / server / dashboard / controllers / utils / json / UsersJsonImplicits . scala 
 @ @ - 2 , 10 + 2 , 11 @ @ package im . actor . server . dashboard . controllers . utils . json 
 
 import scala . concurrent . forkjoin . ThreadLocalRandom 
 
 + import play . api . data . validation . ValidationError 
 + import play . api . i18n . Lang 
 import play . api . libs . functional . syntax . _ 
 import play . api . libs . json . _ 
 
 - import im . actor . server . dashboard . controllers . _ 
 import im . actor . server . dashboard . controllers . utils . json . Common . _ 
 import im . actor . server . models 
 import im . actor . server . util . IdUtils . _ 
 @ @ - 22 , 23 + 23 , 31 @ @ object UsersJsonImplicits { 
 ) 
 } 
 
 - implicit val userReads : Reads [ Lang2CompleteUser ] = ( 
 - ( JsPath \ " name " ) . read [ String ] ( length ) and 
 - ( JsPath \ " dept " ) . read [ String ] ( length ) and 
 - ( JsPath \ " phone " ) . read [ String ] ( length ) 
 - ) ( makeUserAndPhone _ ) 
 + def userReads ( lang : Option [ Lang ] ) : Reads [ CompleteUser ] = { 
 + val language = lang . getOrElse ( Lang ( " RU " ) ) . language . toUpperCase 
 + ( ( JsPath \ " name " ) . read [ String ] ( length ) and 
 + ( JsPath \ " dept " ) . read [ String ] ( length ) and 
 + ( JsPath \ " phone " ) . read [ String ] ( validPhone ( language ) ) ) ( makeUserAndPhone ( language ) _ ) 
 + } 
 + 
 + def validPhone ( language : String ) ( implicit reads : Reads [ String ] ) : Reads [ String ] = 
 + Reads [ String ] ( js ⇒ reads . reads ( js ) . filter ( ValidationError ( " error . invalidPhone " , js ) ) { phone ⇒ 
 + PhoneNumber . isValid ( phone , language ) 
 + } ) 
 + 
 + case class UserUpdate ( name : String ) 
 + 
 + implicit val userUpdateReads : Reads [ UserUpdate ] = ( JsPath \ " name " ) . read [ String ] ( length ) . map { UserUpdate } 
 
 - implicit val userUpdateReads : Reads [ Option [ String ] ] = ( JsPath \ " name " ) . readNullable [ String ] ( length ) 
 + case class CompleteUser ( user : models . User , struct : String , phone : models . UserPhone ) 
 
 - private def makeUserAndPhone ( name : String , struct : String , phone : String ) : Lang2CompleteUser = { lang ⇒ 
 + private def makeUserAndPhone ( language : String ) ( name : String , struct : String , phone : String ) : CompleteUser = { 
 val rnd = ThreadLocalRandom . current ( ) 
 val ( userId , phoneId ) = ( nextIntId ( rnd ) , nextIntId ( rnd ) ) 
 - for { 
 - code ← lang . map { _ . language . toUpperCase } 
 - normalizedPhone ← PhoneNumber . normalizeStr ( phone , code ) 
 - user = models . User ( userId , ACLUtils . nextAccessSalt ( rnd ) , name , code , models . NoSex , models . UserState . Registered ) 
 - userPhone = models . UserPhone ( phoneId , userId , ACLUtils . nextAccessSalt ( rnd ) , normalizedPhone , " Mobile phone " ) 
 - } yield ( user , struct , userPhone ) 
 + val normalizedPhone = PhoneNumber . tryNormalize ( phone . toLong , language ) 
 + val user = models . User ( userId , ACLUtils . nextAccessSalt ( rnd ) , name , language , models . NoSex , models . UserState . Registered ) 
 + val userPhone = models . UserPhone ( phoneId , userId , ACLUtils . nextAccessSalt ( rnd ) , normalizedPhone , " Mobile phone " ) 
 + CompleteUser ( user , struct , userPhone ) 
 } 
 
 } 
 diff - - git a / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala b / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala 
 index 3dd283d . . 709797e 100644 
 - - - a / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala 
 + + + b / actor - persist / src / main / scala / im / actor / server / persist / Manager . scala 
 @ @ - 23 , 6 + 23 , 6 @ @ object Manager { 
 managers + = manager 
 
 def findByEmail ( email : String ) = 
 - managers . filter ( _ . email = = = email ) . result 
 + managers . filter ( _ . email = = = email ) . result . headOption 
 
 } 
 \ No newline at end of file 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala 
 index dbdc6a7 . . 88bca84 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / BasicDashboardSpec . scala 
 @ @ - 1 , 7 + 1 , 7 @ @ 
 package im . actor . server . dashboard 
 
 - import org . scalatest . { BeforeAndAfterAll , Matchers , FlatSpec } 
 import org . scalatest . concurrent . ScalaFutures 
 + import org . scalatest . { BeforeAndAfterAll , FlatSpec , Matchers } 
 import slick . driver . PostgresDriver 
 
 import im . actor . server . SqlSpecHelpers 
 @ @ - 13 , 7 + 13 , 7 @ @ trait BasicDashboardSpec 
 with Matchers 
 with BeforeAndAfterAll { 
 
 - val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) 
 + lazy val ( ds , database : PostgresDriver . backend . DatabaseDef ) = migrateAndInitDb ( ) 
 
 override def afterAll ( ) : Unit = { 
 super . afterAll ( ) 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala 
 index 11183a2 . . f874d35 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / DepartmentsSpec . scala 
 @ @ - 22 , 8 + 22 , 12 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 
 " create dept " should " create new dept with given name and struct " in s . createDept ( ) 
 
 + " create dept " should " not create dept when request with invalid json body comes " in s . createDeptInvaidJson ( ) 
 + 
 " update dept " should " change name to given one " in s . updateDept ( ) 
 
 + " update dept " should " not update dept when request with invalid json body comes " in s . updateDeptInvalidJson ( ) 
 + 
 " delete dept " should " mark dept as deleted at current date " in s . deleteDept ( ) 
 
 " get dept " should " return given dept with all subdepts " in s . getDept ( ) 
 @ @ - 41 , 16 + 45 , 18 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 val token = " secret " 
 
 def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) 
 + 
 val authorizedGET = authorized ( GET ) 
 val authorizedDELETE = authorized ( DELETE ) 
 val authorizedPUT = authorized ( PUT ) 
 val authorizedPOST = authorized ( POST ) 
 
 - val manager = persist . Manager . create ( models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) ) 
 + val manager = models . Manager ( 1 , " Homer " , " Simpson " , " sm . actor . im " , token , " hs @ gmail . com " ) 
 
 class TestController extends Departments { 
 override val db = database 
 } 
 + 
 val deptsController = new TestController ( ) 
 
 def notAuthorized ( ) = { 
 @ @ - 59 , 7 + 65 , 7 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 } 
 
 def createDept ( ) = { 
 - whenReady ( database . run ( manager ) ) { _ ⇒ 
 + whenReady ( database . run ( persist . Manager . create ( manager ) ) ) { _ ⇒ 
 val dept = makeDept ( Depts . root ) 
 / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 @ @ - 80 , 6 + 86 , 15 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 } 
 } 
 
 + def createDeptInvaidJson ( ) = { 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val request = authorizedPOST . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 + val body = Json . toJson ( Map ( " titleZZZ " → " Sales dept 2 " , " struct " → " 2 . 2 . 1 " ) ) . toString ( ) 
 + val result = deptsController . create ( ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 + 
 + status ( result ) shouldEqual 406 
 + } 
 + 
 def updateDept ( ) = { 
 whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . main ) ) ) ) { _ ⇒ 
 val newTitle = " Uber Main dept " 
 @ @ - 92 , 7 + 107 , 9 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 
 whenReady ( database . run ( persist . Department . find ( Depts . main . struct ) . headOption ) ) { optDept ⇒ 
 optDept shouldBe defined 
 - optDept . map { _ . name shouldEqual newTitle } getOrElse fail 
 + optDept . map { 
 + _ . name shouldEqual newTitle 
 + } getOrElse fail 
 } 
 val r = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 val b = Json . toJson ( Map ( " title " → Depts . main . name ) ) . toString ( ) 
 @ @ - 100 , 12 + 117 , 23 @ @ class DepartmentsSpec extends BasicDashboardSpec { 
 } 
 } 
 
 + def updateDeptInvalidJson ( ) = { 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val request = authorizedPUT . withHeaders ( HeaderNames . CONTENT _ TYPE → " application / json " ) 
 + val body = Json . toJson ( Map ( " titleZZZ " → " Some other dept " ) ) . toString ( ) 
 + val result = deptsController . update ( Depts . main . struct ) ( request ) . feed ( Input . El ( body . getBytes ) ) . flatMap ( _ . run ) 
 + 
 + status ( result ) shouldEqual 406 
 + } 
 + 
 def deleteDept ( ) = { 
 whenReady ( database . run ( persist . Department . create ( makeDept ( Depts . subDept ) ) ) ) { _ ⇒ 
 val delete = deptsController . delete ( Depts . subDept . struct ) ( authorizedDELETE ) 
 status ( delete ) shouldEqual 202 
 whenReady ( database . run ( persist . Department . find ( Depts . subDept . struct ) . headOption ) ) { optDept ⇒ 
 - optDept . map { _ . deletedAt shouldBe defined } getOrElse fail 
 + optDept . map { 
 + _ . deletedAt shouldBe defined 
 + } getOrElse fail 
 } 
 } 
 } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala b / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala 
 index df20aba . . 1665849 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / dashboard / UsersSpec . scala 
 @ @ - 32 , 8 + 32 , 16 @ @ class UsersSpec extends BasicDashboardSpec { 
 
 " update user " should " change name to one given in request body " in s . updateUserName ( ) 
 
 + " update user " should " not update user when request with invalid json body comes " in s . updateUserInvalidJson ( ) 
 + 
 " create user " should " create new user with given name and phone " in s . createUser ( ) 
 
 + " create user " should " not create user when request with invalid json body comes " in s . createUserInvalidJson ( ) 
 + 
 + " create user " should " not create user with invalid phone " in s . createUserInvalidPhone ( ) 
 + 
 + " create user " should " not create user when phone number duplicates " in s . createUserDuplicateNumber ( ) 
 + 
 val rnd = ThreadLocalRandom . current ( ) 
 
 object s { 
 @ @ - 45 , 6 + 53 , 7 @ @ class UsersSpec extends BasicDashboardSpec { 
 val token = " secret " 
 
 def authorized ( method : String ) = FakeRequest ( method , s " / users ? auth - token = $ token " ) 
 + 
 val authorizedGET = authorized ( GET ) 
 val authorizedDELETE = authorized ( DELETE ) 
 val authorizedPUT = authorized ( PUT ) 
 @ @ - 148 , 6 + 157 , 29 @ @ class UsersSpec extends BasicDashboardSpec { 
 } 
 } 
 
 + def updateUserInvalidJson ( ) = { 
 + val user = genUser ( ) 
 + whenReady ( database . run ( persist . User . create ( user ) ) ) { _ ⇒ 
 + 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val update = authorizedPUT . 
 + withHeaders ( 
 + HeaderNames . CONTENT _ TYPE → " application / json " , 
 + HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 + ) 
 + val result = new TestController ( ) . update ( user . id ) ( update ) . 
 + feed ( Input . El ( Json . toJson ( Map ( " nameZZZZ " → " George Bush " ) ) . toString ( ) . getBytes ) ) . 
 + flatMap ( _ . run ) 
 + 
 + status ( result ) shouldEqual 406 
 + whenReady ( database . run ( persist . User . find ( user . id ) . headOption ) ) { optUser ⇒ 
 + optUser . map { 
 + _ . name shouldEqual user . name 
 + } getOrElse fail 
 + } 
 + } 
 + } 
 + 
 def createUser ( ) = { 
 val user = genUser ( ) 
 val phone = genPhone ( user . id , 75552223312L ) 
 @ @ - 189 , 6 + 221 , 55 @ @ class UsersSpec extends BasicDashboardSpec { 
 } 
 } 
 } 
 + 
 + def createUserInvalidJson ( ) = { 
 + val user = genUser ( ) 
 + val phone = genPhone ( user . id , 75552223312L ) 
 + val dept = " 1 . 1 " 
 + 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val request = authorizedPOST . 
 + withHeaders ( 
 + HeaderNames . CONTENT _ TYPE → " application / json " , 
 + HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 + ) 
 + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phoneZZ " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 + status ( result ) shouldEqual 406 
 + } 
 + 
 + def createUserInvalidPhone ( ) = { 
 + val user = genUser ( ) 
 + val phone = genPhone ( user . id , 1 ) 
 + val dept = " 1 . 1 " 
 + 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val request = authorizedPOST . 
 + withHeaders ( 
 + HeaderNames . CONTENT _ TYPE → " application / json " , 
 + HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 + ) 
 + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 + status ( result ) shouldEqual 406 
 + } 
 + 
 + def createUserDuplicateNumber ( ) = { 
 + val user = genUser ( ) 
 + val phone = genPhone ( user . id , 75552223312L ) 
 + val dept = " 1 . 1 " 
 + 
 + / / ugly workaround for this bug https : / / revoltingcode . wordpress . com / 2013 / 10 / 27 / play - framework - 2 - controller - testing - with - json - body - parser / 
 + val request = authorizedPOST . 
 + withHeaders ( 
 + HeaderNames . CONTENT _ TYPE → " application / json " , 
 + HeaderNames . ACCEPT _ LANGUAGE → " RU " 
 + ) 
 + val invalidBody = Json . toJson ( Map ( " name " → user . name , " phone " → phone . number . toString , " dept " → dept ) ) . toString ( ) 
 + val result = new TestController ( ) . create ( ) ( request ) . feed ( Input . El ( invalidBody . getBytes ) ) . flatMap ( _ . run ) 
 + status ( result ) shouldEqual 406 
 + ( contentAsJson ( result ) \ " message " ) . as [ String ] shouldBe s " User with phone $ { phone . number } already exists " 
 + } 
 } 
 
 def genUser ( ) : models . User = models . User ( IdUtils . nextIntId ( rnd ) , ACLUtils . nextAccessSalt ( rnd ) , " Henry Ford " , " US " , models . NoSex , models . UserState . Registered )
