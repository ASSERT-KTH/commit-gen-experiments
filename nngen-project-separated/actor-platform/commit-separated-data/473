BLEU SCORE: 0.30895757752065417

TEST MSG: test ( server ) : fixed MessagingServiceHistorySpec
GENERATED MSG: fix ( server ) : make messaging spec pass

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 4ec7576 . . 8f30f65 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > import slick . driver . PostgresDriver . api . Database < nl > < nl > - import scala . collection . immutable < nl > + import scala . collection . SortedSet < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > @ @ - 50 , 7 + 50 , 7 @ @ private [ dialog ] final case class DialogState ( < nl > lastReceiveDate : Instant , < nl > lastReadDate : Instant , < nl > counter : Int , < nl > - unreadMessages : immutable . SortedSet [ UnreadMessage ] < nl > + unreadMessages : SortedSet [ UnreadMessage ] < nl > ) extends ProcessorState [ DialogState , DialogEvent ] { < nl > import DialogEvents . _ < nl > < nl > @ @ - 76 , 16 + 76 , 6 @ @ object DialogProcessor { < nl > < nl > def register ( ) : Unit = { < nl > ActorSerializer . register ( < nl > - 40000 → classOf [ DialogCommands . SendMessage ] , < nl > - 40001 → classOf [ DialogCommands . MessageReceived ] , < nl > - 40002 → classOf [ DialogCommands . MessageReceivedAck ] , < nl > - 40003 → classOf [ DialogCommands . MessageRead ] , < nl > - 40004 → classOf [ DialogCommands . MessageReadAck ] , < nl > - 40005 → classOf [ DialogCommands . WriteMessage ] , < nl > - 40006 → classOf [ DialogCommands . WriteMessageAck ] , < nl > - < nl > - 40009 → classOf [ DialogEnvelope ] , < nl > - < nl > 40010 → classOf [ DialogEvents . MessagesRead ] , < nl > 40011 → classOf [ DialogEvents . MessagesReceived ] , < nl > 40012 → classOf [ DialogEvents . NewMessage ] < nl > @ @ - 137 , 11 + 127 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > lastReceiveDate = Instant . ofEpochMilli ( 0 ) , < nl > lastReadDate = Instant . ofEpochMilli ( 0 ) , < nl > counter = 0 , < nl > - unreadMessages = immutable . SortedSet . empty ( UnreadMessage . ordering ) < nl > + unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) < nl > ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case GetCounter ( _ ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) < nl > + case GetCounter ( _ ) ⇒ < nl > + Future . successful ( GetCounterResponse ( state . counter ) ) < nl > case GetInfo ( _ ) ⇒ Future . successful ( < nl > GetInfoResponse ( Some ( DialogInfo ( < nl > peer = Some ( peer ) , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 8e901d6 . . 652fad2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 134 , 8 + 134 , 6 @ @ private trait DialogRootQueryHandlers { < nl > private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > < nl > def getDialogs ( endDate : Instant , limit : Int ) : Future [ GetDialogsResponse ] = { < nl > - println ( s " = = = getDialogs $ { state . activePeers } " ) < nl > - < nl > val dialogs = < nl > endDateTimeFrom ( endDate ) match { < nl > case Some ( _ ) ⇒ state . activePeers . view . filter ( sd ⇒ sd . ts . isBefore ( endDate ) | | sd . ts = = endDate ) . take ( limit ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 47f66e1 . . 526db40 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . db . DbExtension < nl > - import im . actor . server . dialog . { DialogExtension , DialogGroup , DialogGroupType } < nl > + import im . actor . server . dialog . { DialogExtension , DialogGroupType } < nl > import im . actor . server . model . DialogObsolete < nl > import im . actor . server . persist . dialog . DialogRepo < nl > import im . actor . server . sequence . SeqStateDate < nl > @ @ - 22 , 6 + 22 , 8 @ @ import scala . util . Random < nl > trait MessagingSpecHelpers extends ScalaFutures with PeersImplicits with Matchers { < nl > implicit val system : ActorSystem < nl > < nl > + lazy val dialogExt = DialogExtension ( system ) < nl > + < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala < nl > index e03c1ac . . d21d4cc 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala < nl > @ @ - 1 , 5 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > + import java . time . Instant < nl > + < nl > import im . actor . api . rpc . Implicits . _ < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . counters . UpdateCountersChanged < nl > @ @ - 11 , 8 + 13 , 7 @ @ import im . actor . server . _ < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . group . GroupExtension < nl > - import im . actor . server . model . PeerType < nl > - import im . actor . server . persist . dialog . DialogRepo < nl > + import im . actor . server . model . { Peer , PeerType } < nl > < nl > import scala . concurrent . Future < nl > import scala . util . Random < nl > @ @ - 242 , 15 + 243 , 15 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > Thread . sleep ( 100 ) / / Let peer managers write to db < nl > < nl > - whenReady ( db . run ( DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Private , user2 . id ) ) ) ) { dialogOpt ⇒ < nl > - dialogOpt . get . lastReceivedAt . getMillis should be < startDate + 3000 < nl > - dialogOpt . get . lastReceivedAt . getMillis should be > startDate + 1000 < nl > + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Private , user2 . id ) ) ) { info ⇒ < nl > + info . lastReceivedDate . toEpochMilli should be < startDate + 3000 < nl > + info . lastReceivedDate . toEpochMilli should be > startDate + 1000 < nl > } < nl > } < nl > < nl > { < nl > implicit val clientData = clientData1 < nl > - expectUpdates ( < nl > + expectUpdatesUnordered ( < nl > classOf [ UpdateChatGroupsChanged ] , < nl > classOf [ UpdateMessageSent ] , < nl > classOf [ UpdateMessageSent ] , < nl > @ @ - 275 , 29 + 276 , 27 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > val user1AccessHash = ACLUtils . userAccessHash ( authId21 , user1 . id , getUserModel ( user1 . id ) . accessSalt ) < nl > val user1Peer = peers . ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) < nl > < nl > - val user2AccessHash = ACLUtils . userAccessHash ( authId1 , user2 . id , getUserModel ( user2 . id ) . accessSalt ) < nl > - val user2Peer = peers . ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) < nl > - < nl > - val startDate = { < nl > + val ( date1 , date2 , date3 ) = { < nl > implicit val clientData = clientData1 < nl > < nl > - val startDate = System . currentTimeMillis ( ) < nl > + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) < nl > + val date1 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > < nl > - val sendMessages = Future . sequence ( Seq ( < nl > - service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , < nl > - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , < nl > - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) < nl > - ) ) < nl > + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) < nl > + val date2 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > < nl > - whenReady ( sendMessages ) ( _ ⇒ ( ) ) < nl > + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) < nl > + val date3 = Instant . now ( ) < nl > < nl > - startDate < nl > + ( date1 , date2 , date3 ) < nl > } < nl > < nl > { < nl > implicit val clientData = clientData21 < nl > < nl > - whenReady ( service . handleMessageRead ( user1Peer , startDate + 2000 ) ) { resp ⇒ < nl > + whenReady ( service . handleMessageRead ( user1Peer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ < nl > resp should matchPattern { < nl > case Ok ( ResponseVoid ) ⇒ < nl > } < nl > @ @ - 305 , 10 + 304 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > Thread . sleep ( 100 ) / / Let peer managers write to db < nl > < nl > - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Private , user2 . id ) ) ) ) { optDialog ⇒ < nl > - val dialog = optDialog . get < nl > - dialog . lastReadAt . getMillis should be < startDate + 3000 < nl > - dialog . lastReadAt . getMillis should be > startDate + 1000 < nl > + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Private , user2 . id ) ) ) { info ⇒ < nl > + info . lastReadDate . toEpochMilli should be < date3 . toEpochMilli < nl > + info . lastReadDate . toEpochMilli should be > date1 . toEpochMilli < nl > } < nl > < nl > whenReady ( service . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > @ @ - 320 , 7 + 318 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > { < nl > implicit val clientData = clientData1 < nl > - expectUpdates ( < nl > + expectUpdatesUnordered ( < nl > classOf [ UpdateChatGroupsChanged ] , < nl > classOf [ UpdateMessageSent ] , < nl > classOf [ UpdateMessageSent ] , < nl > @ @ - 331 , 7 + 329 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > { < nl > implicit val clientData = clientData21 < nl > - expectUpdates ( < nl > + expectUpdatesUnordered ( < nl > classOf [ UpdateChatGroupsChanged ] , < nl > classOf [ UpdateMessage ] , < nl > / / classOf [ UpdateCountersChanged ] , < nl > @ @ - 425 , 22 + 423 , 27 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > val startDate = System . currentTimeMillis ( ) < nl > < nl > - { < nl > + val ( date1 , date2 , date3 ) = { < nl > implicit val clientData = clientData1 < nl > < nl > - val sendMessages = Future . sequence ( Seq ( < nl > - service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , < nl > - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , < nl > - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) < nl > - ) ) < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) < nl > + val date1 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > < nl > - whenReady ( sendMessages ) ( _ ⇒ ( ) ) < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) < nl > + val date2 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > + < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) < nl > + val date3 = Instant . now ( ) < nl > + < nl > + ( date1 , date2 , date3 ) < nl > } < nl > < nl > { < nl > implicit val clientData = clientData2 < nl > < nl > - whenReady ( service . handleMessageReceived ( groupOutPeer . asOutPeer , startDate + 2000 ) ) { resp ⇒ < nl > + whenReady ( service . handleMessageReceived ( groupOutPeer . asOutPeer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ < nl > resp should matchPattern { < nl > case Ok ( ResponseVoid ) ⇒ < nl > } < nl > @ @ - 448 , 9 + 451 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > Thread . sleep ( 100 ) / / Let peer managers write to db < nl > < nl > - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) ) { dialogOpt ⇒ < nl > - dialogOpt . get . lastReceivedAt . getMillis should be < startDate + 3000 < nl > - dialogOpt . get . lastReceivedAt . getMillis should be > startDate + 1000 < nl > + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) { info ⇒ < nl > + info . lastReceivedDate . toEpochMilli should be < date3 . toEpochMilli < nl > + info . lastReceivedDate . toEpochMilli should be > date1 . toEpochMilli < nl > } < nl > } < nl > < nl > @ @ - 479 , 18 + 482 , 21 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > createGroup ( " Fun group " , Set ( user2 . id ) ) . groupPeer < nl > } < nl > < nl > - val startDate = System . currentTimeMillis ( ) < nl > - < nl > - { < nl > + val ( date1 , date2 , date3 ) = { < nl > implicit val clientData = clientData1 < nl > < nl > - val sendMessages = Future . sequence ( Seq ( < nl > - service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , < nl > - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , < nl > - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) < nl > - ) ) < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) < nl > + val date1 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > < nl > - whenReady ( sendMessages ) ( _ ⇒ ( ) ) < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) < nl > + val date2 = Instant . now ( ) < nl > + Thread . sleep ( 100 ) < nl > + < nl > + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) < nl > + val date3 = Instant . now ( ) < nl > + < nl > + ( date1 , date2 , date3 ) < nl > } < nl > < nl > Thread . sleep ( 300 ) < nl > @ @ - 498 , 7 + 504 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > { < nl > implicit val clientData = clientData2 < nl > < nl > - whenReady ( service . handleMessageRead ( groupOutPeer . asOutPeer , startDate + 2000 ) ) { resp ⇒ < nl > + whenReady ( service . handleMessageRead ( groupOutPeer . asOutPeer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ < nl > resp should matchPattern { < nl > case Ok ( ResponseVoid ) ⇒ < nl > } < nl > @ @ - 506 , 9 + 512 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH < nl > < nl > Thread . sleep ( 300 ) < nl > < nl > - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) ) { dialogOpt ⇒ < nl > - dialogOpt . get . lastReadAt . getMillis should be < startDate + 3000 < nl > - dialogOpt . get . lastReadAt . getMillis should be > startDate + 1000 < nl > + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) { info ⇒ < nl > + info . lastReadDate . toEpochMilli should be < date3 . toEpochMilli < nl > + info . lastReadDate . toEpochMilli should be > date1 . toEpochMilli < nl > } < nl > < nl > whenReady ( service . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > index eadc9ed . . dfba5fe 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala < nl > @ @ - 24 , 8 + 24 , 6 @ @ final class DialogProcessorSpec extends BaseAppSuite < nl > < nl > it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) < nl > < nl > - private val dialogExt = DialogExtension ( system ) < nl > - < nl > private val messService = MessagingServiceImpl ( ) < nl > < nl > def noTimeout ( ) = {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > index 35e0450 . . a8b4741 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala < nl > @ @ - 113 , 6 + 113 , 10 @ @ class GroupOfficeActor ( < nl > < nl > context . setReceiveTimeout ( 15 . minutes ) < nl > < nl > + / / type AuthIdRandomId = ( Long , Long ) < nl > + / / implicit val sendResponseCache : Cache [ AuthIdRandomId , Future [ SeqStateDate ] ] = < nl > + / / CacheHelpers . createCache [ AuthIdRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > + < nl > / * < nl > TODO : turn into migration < nl > initialize ( ) pipeTo self onFailure { < nl > @ @ - 148 , 6 + 152 , 7 @ @ class GroupOfficeActor ( < nl > case _ : GroupEvents . Created ⇒ < nl > this . title = title < nl > this . creatorUserId = creatorUserId < nl > + this . accessHash = accessHash < nl > < nl > val group = models . Group ( < nl > id = groupId , < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > index 0ddb0d4 . . eafd943 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala < nl > @ @ - 22 , 6 + 22 , 8 @ @ object UserOffice { < nl > < nl > case object InvalidAccessHash extends Exception with NoStackTrace < nl > < nl > + case object FailedToFetchInfo < nl > + < nl > def persistenceIdFor ( userId : Int ) : String = s " user _ $ { userId } " < nl > < nl > def auth ( userId : Int , authId : Long ) ( < nl > diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > index 4e66423 . . b417592 100644 < nl > - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala < nl > @ @ - 1 , 13 + 1 , 13 @ @ < nl > package im . actor . server . user < nl > < nl > - import akka . actor . { ActorSystem , ActorLogging , Props , Status } < nl > + import akka . actor . _ < nl > import akka . pattern . pipe < nl > import akka . persistence . RecoveryFailure < nl > import akka . util . Timeout < nl > + import com . github . benmanes . caffeine . cache . Cache < nl > import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . peers . { Peer , PeerType } < nl > import im . actor . server . commons . serialization . ActorSerializer < nl > - import im . actor . server . models < nl > import im . actor . server . office . PeerOffice < nl > import im . actor . server . office . PeerOffice . MessageSentComplete < nl > import im . actor . server . office . user . { UserEnvelope , UserEvents } < nl > @ @ - 15 , 12 + 15 , 13 @ @ import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } < nl > import im . actor . server . sequence . { SeqState , SeqStateDate } < nl > import im . actor . server . social . { SocialManager , SocialManagerRegion } < nl > import im . actor . server . util . { ACLUtils , HistoryUtils , UserUtils } < nl > - import im . actor . server . { persist ⇒ p } < nl > + import im . actor . server . { models , persist ⇒ p } < nl > + import im . actor . utils . cache . CacheHelpers < nl > import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > - import scala . concurrent . { Future , ExecutionContext } < nl > import scala . concurrent . duration . _ < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > import scala . util . { Failure , Success } < nl > < nl > object UserOfficeActor { < nl > @ @ - 64 , 6 + 65 , 8 @ @ class UserOfficeActor ( < nl > import UserOffice . _ < nl > import UserUtils . _ < nl > < nl > + private val MaxCacheSize = 100L < nl > + < nl > implicit val region : UserOfficeRegion = UserOfficeRegion ( context . parent ) < nl > implicit private val timeout : Timeout = Timeout ( 10 . seconds ) < nl > < nl > @ @ - 79 , 15 + 82 , 27 @ @ class UserOfficeActor ( < nl > private [ this ] var authIds = Set . empty [ Long ] < nl > private [ this ] var accessSalt : Option [ String ] = None < nl > < nl > - def receiveCommand = { < nl > - case Payload . UserInfo ( UserInfo ( salt ) ) ⇒ < nl > - persist ( UserEvents . UserInfoAdded ( salt ) ) { _ ⇒ < nl > - accessSalt = Some ( salt ) < nl > - } < nl > + type AuthIdRandomId = ( Long , Long ) < nl > + implicit val sendResponseCache : Cache [ AuthIdRandomId , Future [ SeqStateDate ] ] = < nl > + CacheHelpers . createCache [ AuthIdRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > + < nl > + def receiveCommand : Receive = { < nl > case Payload . NewAuth ( NewAuth ( authId ) ) ⇒ < nl > persist ( UserEvents . AuthAdded ( authId ) ) { _ ⇒ < nl > authIds + = authId < nl > - if ( accessSalt . isEmpty ) initAccessSalt ( ) < nl > + if ( accessSalt . isEmpty ) { < nl > + initAccessSalt ( ) < nl > + context become { < nl > + case Payload . UserInfo ( UserEnvelope . UserInfo ( salt ) ) ⇒ < nl > + persist ( UserEvents . UserInfoAdded ( salt ) ) { _ ⇒ < nl > + accessSalt = Some ( salt ) < nl > + unstashAll ( ) < nl > + context become receiveCommand < nl > + } < nl > + case FailedToFetchInfo ⇒ self ! Kill < nl > + case msg ⇒ stash ( ) < nl > + } < nl > + } < nl > sender ( ) ! Status . Success ( ( ) ) < nl > } < nl > case Payload . RemoveAuth ( RemoveAuth ( authId ) ) ⇒ < nl > @ @ - 138 , 14 + 153 , 17 @ @ class UserOfficeActor ( < nl > val date = new DateTime < nl > val dateMillis = date . getMillis < nl > < nl > - val sendFuture = for { < nl > - _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) < nl > - SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) < nl > - _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) < nl > - } yield { < nl > - db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) < nl > - SeqStateDate ( seq , state , dateMillis ) < nl > - } < nl > + val sendFuture : Future [ SeqStateDate ] = < nl > + CacheHelpers . withCachedResult ( senderAuthId → randomId ) { ( ) ⇒ < nl > + for { < nl > + _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) < nl > + SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) < nl > + _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) < nl > + } yield { < nl > + db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) < nl > + SeqStateDate ( seq , state , dateMillis ) < nl > + } < nl > + } < nl > sendFuture onComplete { < nl > case Success ( seqstate ) ⇒ < nl > replyTo ! seqstate < nl > @ @ - 196 , 7 + 214 , 7 @ @ class UserOfficeActor ( < nl > } < nl > } < nl > < nl > - override def receiveRecover = { < nl > + override def receiveRecover : Receive = { < nl > case UserEvents . AuthAdded ( authId ) ⇒ < nl > authIds + = authId < nl > case UserEvents . AuthRemoved ( authId ) ⇒ < nl > @ @ - 213 , 8 + 231 , 8 @ @ class UserOfficeActor ( < nl > < nl > private def initAccessSalt ( ) : Unit = < nl > db . run ( p . User . find ( userId ) . headOption ) onComplete { < nl > - case Success ( user ) ⇒ user . map ( _ . accessSalt ) foreach { salt ⇒ self ! UserEnvelope . UserInfo ( salt ) } < nl > - case Failure ( _ ) ⇒ < nl > + case Success ( user ) ⇒ user . map ( _ . accessSalt ) foreach { salt ⇒ self ! Payload . UserInfo ( UserEnvelope . UserInfo ( salt ) ) } < nl > + case Failure ( _ ) ⇒ self ! FailedToFetchInfo < nl > } < nl > < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index a1056a7 . . 508a587 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 30 , 16 + 30 , 18 @ @ import im . actor . server . { ImplicitFileStorageAdapter , BaseAppSuite , persist } < nl > class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with ImplicitFileStorageAdapter { < nl > behavior of " MessagingService " < nl > < nl > - " Messaging " should " send messages " in s . privat . sendMessage < nl > + " Private Messaging " should " send messages " in s . privat . sendMessage < nl > < nl > it should " not repeat message sending with same authId and RandomId " in s . privat . cached < nl > < nl > - it should " send group messages " in s . group . sendMessage < nl > + " Group Messaging " should " send messages " in s . group . sendMessage < nl > < nl > it should " not send messages when user is not in group " in s . group . restrictAlienUser < nl > < nl > it should " publish messages in PubSub " in s . pubsub . publish < nl > < nl > + it should " not repeat message sending with same authId and RandomId " in s . group . cached < nl > + < nl > val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) < nl > < nl > object s { < nl > @ @ - 131 , 11 + 133 , 11 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I < nl > < nl > val randomId = Random . nextLong ( ) < nl > val actions = Future . sequence ( List ( < nl > - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , < nl > - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , < nl > - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , < nl > - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , < nl > - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) < nl > + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 4 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 5 " , Vector . empty , None ) ) < nl > ) ) < nl > < nl > whenReady ( actions ) { resps ⇒ < nl > @ @ - 253 , 6 + 255 , 46 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I < nl > } < nl > < nl > } < nl > + < nl > + def cached ( ) : Unit = { < nl > + val randomId = Random . nextLong ( ) < nl > + val actions = Future . sequence ( List ( < nl > + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 4 " , Vector . empty , None ) ) , < nl > + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 5 " , Vector . empty , None ) ) < nl > + ) ) < nl > + < nl > + / / in sendMessage ( ) example seq is 1002 , so it should be 1003 here < nl > + whenReady ( actions ) { resps ⇒ < nl > + resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1000 , _ , _ ) ) ⇒ } ) < nl > + } < nl > + < nl > + / / whenReady ( sequenceService . jhandleGetDifference ( 1002 , Array . empty , clientData ) ) { result ⇒ < nl > + / / val respOption = result . toOption < nl > + / / respOption shouldBe defined < nl > + / / val resp = respOption . get < nl > + / / < nl > + / / val updates = resp . updates < nl > + / / updates . length shouldEqual 1 < nl > + / / < nl > + / / val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > + / / message should matchPattern { case Right ( _ : UpdateMessageSent ) ⇒ } < nl > + / / } < nl > + / / < nl > + / / whenReady ( sequenceService . jhandleGetDifference ( 1002 , Array . empty , ClientData ( user2AuthId , sessionId , Some ( user2 . id ) ) ) ) { result ⇒ < nl > + / / val respOption = result . toOption < nl > + / / respOption shouldBe defined < nl > + / / val resp = respOption . get < nl > + / / < nl > + / / val updates = resp . updates < nl > + / / updates . length shouldEqual 1 < nl > + / / < nl > + / / val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) < nl > + / / message should matchPattern { case Right ( _ : UpdateMessage ) ⇒ } < nl > + / / } < nl > + } < nl > } < nl > < nl > object pubsub { < nl > diff - - git a / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala b / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala < nl > index 0b8933c . . c161386 100644 < nl > - - - a / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala < nl > + + + b / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala < nl > @ @ - 1 , 15 + 1 , 29 @ @ < nl > package im . actor . utils . cache < nl > < nl > - import java . util . function . Function < nl > + import com . github . benmanes . caffeine . cache . { Cache , Caffeine } < nl > < nl > - import com . github . benmanes . caffeine . cache . { Cache , Caffeine } < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > < nl > object CacheHelpers { < nl > < nl > def createCache [ K < : AnyRef , V < : AnyRef ] ( maxSize : Long ) : Cache [ K , V ] = Caffeine . newBuilder ( ) . maximumSize ( maxSize ) . build [ K , V ] < nl > < nl > - def withCachedResult [ K , V ] ( key : K ) ( f : ⇒ V ) ( implicit cache : Cache [ K , V ] ) = { < nl > - cache . get ( key , new Function [ K , V ] { def apply ( k : K ) = f } ) < nl > - } < nl > + def withCachedResult [ K , V ] ( key : K ) ( computation : ( ) ⇒ Future [ V ] ) ( < nl > + implicit < nl > + cache : Cache [ K , Future [ V ] ] , < nl > + ec : ExecutionContext < nl > + ) = < nl > + Option ( cache getIfPresent key ) match { < nl > + case Some ( result ) ⇒ result < nl > + case None ⇒ < nl > + val result = computation ( ) < nl > + cache . put ( key , result ) < nl > + < nl > + result onFailure { < nl > + case _ ⇒ cache . invalidate ( key ) < nl > + } < nl > + < nl > + result < nl > + } < nl > < nl > } < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index 46fda7b . . 1acb48e 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 203 , 7 + 203 , 7 @ @ object Build extends sbt . Build { < nl > settings = defaultSettings + + Seq ( < nl > libraryDependencies + + = Dependencies . peerManagers < nl > ) < nl > - ) . dependsOn ( actorModels , actorPush % PB . protobufConfig , actorPush , actorSocial , actorUtils ) < nl > + ) . dependsOn ( actorModels , actorPush % PB . protobufConfig , actorPush , actorSocial , actorUtils , actorUtilsCache ) < nl > . aggregate ( actorPush ) < nl > < nl > lazy val actorSession = Project ( < nl > @ @ - 255 , 7 + 255 , 6 @ @ object Build extends sbt . Build { < nl > actorSms , < nl > actorSocial , < nl > actorUtils , < nl > - actorUtilsCache , < nl > actorUtilsHttp , < nl > actorVoximplant )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 4ec7576 . . 8f30f65 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 18 , 7 + 18 , 7 @ @ import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 import slick . driver . PostgresDriver . api . Database 
 
 - import scala . collection . immutable 
 + import scala . collection . SortedSet 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 @ @ - 50 , 7 + 50 , 7 @ @ private [ dialog ] final case class DialogState ( 
 lastReceiveDate : Instant , 
 lastReadDate : Instant , 
 counter : Int , 
 - unreadMessages : immutable . SortedSet [ UnreadMessage ] 
 + unreadMessages : SortedSet [ UnreadMessage ] 
 ) extends ProcessorState [ DialogState , DialogEvent ] { 
 import DialogEvents . _ 
 
 @ @ - 76 , 16 + 76 , 6 @ @ object DialogProcessor { 
 
 def register ( ) : Unit = { 
 ActorSerializer . register ( 
 - 40000 → classOf [ DialogCommands . SendMessage ] , 
 - 40001 → classOf [ DialogCommands . MessageReceived ] , 
 - 40002 → classOf [ DialogCommands . MessageReceivedAck ] , 
 - 40003 → classOf [ DialogCommands . MessageRead ] , 
 - 40004 → classOf [ DialogCommands . MessageReadAck ] , 
 - 40005 → classOf [ DialogCommands . WriteMessage ] , 
 - 40006 → classOf [ DialogCommands . WriteMessageAck ] , 
 - 
 - 40009 → classOf [ DialogEnvelope ] , 
 - 
 40010 → classOf [ DialogEvents . MessagesRead ] , 
 40011 → classOf [ DialogEvents . MessagesReceived ] , 
 40012 → classOf [ DialogEvents . NewMessage ] 
 @ @ - 137 , 11 + 127 , 12 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 lastReceiveDate = Instant . ofEpochMilli ( 0 ) , 
 lastReadDate = Instant . ofEpochMilli ( 0 ) , 
 counter = 0 , 
 - unreadMessages = immutable . SortedSet . empty ( UnreadMessage . ordering ) 
 + unreadMessages = SortedSet . empty ( UnreadMessage . ordering ) 
 ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case GetCounter ( _ ) ⇒ Future . successful ( GetCounterResponse ( state . counter ) ) 
 + case GetCounter ( _ ) ⇒ 
 + Future . successful ( GetCounterResponse ( state . counter ) ) 
 case GetInfo ( _ ) ⇒ Future . successful ( 
 GetInfoResponse ( Some ( DialogInfo ( 
 peer = Some ( peer ) , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 8e901d6 . . 652fad2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 134 , 8 + 134 , 6 @ @ private trait DialogRootQueryHandlers { 
 private implicit val timeout = Timeout ( ActorConfig . defaultTimeout ) 
 
 def getDialogs ( endDate : Instant , limit : Int ) : Future [ GetDialogsResponse ] = { 
 - println ( s " = = = getDialogs $ { state . activePeers } " ) 
 - 
 val dialogs = 
 endDateTimeFrom ( endDate ) match { 
 case Some ( _ ) ⇒ state . activePeers . view . filter ( sd ⇒ sd . ts . isBefore ( endDate ) | | sd . ts = = endDate ) . take ( limit ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 47f66e1 . . 526db40 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 8 , 7 + 8 , 7 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . db . DbExtension 
 - import im . actor . server . dialog . { DialogExtension , DialogGroup , DialogGroupType } 
 + import im . actor . server . dialog . { DialogExtension , DialogGroupType } 
 import im . actor . server . model . DialogObsolete 
 import im . actor . server . persist . dialog . DialogRepo 
 import im . actor . server . sequence . SeqStateDate 
 @ @ - 22 , 6 + 22 , 8 @ @ import scala . util . Random 
 trait MessagingSpecHelpers extends ScalaFutures with PeersImplicits with Matchers { 
 implicit val system : ActorSystem 
 
 + lazy val dialogExt = DialogExtension ( system ) 
 + 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala 
 index e03c1ac . . d21d4cc 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceHistorySpec . scala 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 + import java . time . Instant 
 + 
 import im . actor . api . rpc . Implicits . _ 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . counters . UpdateCountersChanged 
 @ @ - 11 , 8 + 13 , 7 @ @ import im . actor . server . _ 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . group . GroupExtension 
 - import im . actor . server . model . PeerType 
 - import im . actor . server . persist . dialog . DialogRepo 
 + import im . actor . server . model . { Peer , PeerType } 
 
 import scala . concurrent . Future 
 import scala . util . Random 
 @ @ - 242 , 15 + 243 , 15 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 Thread . sleep ( 100 ) / / Let peer managers write to db 
 
 - whenReady ( db . run ( DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Private , user2 . id ) ) ) ) { dialogOpt ⇒ 
 - dialogOpt . get . lastReceivedAt . getMillis should be < startDate + 3000 
 - dialogOpt . get . lastReceivedAt . getMillis should be > startDate + 1000 
 + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Private , user2 . id ) ) ) { info ⇒ 
 + info . lastReceivedDate . toEpochMilli should be < startDate + 3000 
 + info . lastReceivedDate . toEpochMilli should be > startDate + 1000 
 } 
 } 
 
 { 
 implicit val clientData = clientData1 
 - expectUpdates ( 
 + expectUpdatesUnordered ( 
 classOf [ UpdateChatGroupsChanged ] , 
 classOf [ UpdateMessageSent ] , 
 classOf [ UpdateMessageSent ] , 
 @ @ - 275 , 29 + 276 , 27 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 val user1AccessHash = ACLUtils . userAccessHash ( authId21 , user1 . id , getUserModel ( user1 . id ) . accessSalt ) 
 val user1Peer = peers . ApiOutPeer ( ApiPeerType . Private , user1 . id , user1AccessHash ) 
 
 - val user2AccessHash = ACLUtils . userAccessHash ( authId1 , user2 . id , getUserModel ( user2 . id ) . accessSalt ) 
 - val user2Peer = peers . ApiOutPeer ( ApiPeerType . Private , user2 . id , user2AccessHash ) 
 - 
 - val startDate = { 
 + val ( date1 , date2 , date3 ) = { 
 implicit val clientData = clientData1 
 
 - val startDate = System . currentTimeMillis ( ) 
 + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) 
 + val date1 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 
 - val sendMessages = Future . sequence ( Seq ( 
 - service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , 
 - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , 
 - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( user2Peer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) 
 - ) ) 
 + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) 
 + val date2 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 
 - whenReady ( sendMessages ) ( _ ⇒ ( ) ) 
 + sendMessageToUser ( user2 . id , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) 
 + val date3 = Instant . now ( ) 
 
 - startDate 
 + ( date1 , date2 , date3 ) 
 } 
 
 { 
 implicit val clientData = clientData21 
 
 - whenReady ( service . handleMessageRead ( user1Peer , startDate + 2000 ) ) { resp ⇒ 
 + whenReady ( service . handleMessageRead ( user1Peer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ 
 resp should matchPattern { 
 case Ok ( ResponseVoid ) ⇒ 
 } 
 @ @ - 305 , 10 + 304 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 Thread . sleep ( 100 ) / / Let peer managers write to db 
 
 - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Private , user2 . id ) ) ) ) { optDialog ⇒ 
 - val dialog = optDialog . get 
 - dialog . lastReadAt . getMillis should be < startDate + 3000 
 - dialog . lastReadAt . getMillis should be > startDate + 1000 
 + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Private , user2 . id ) ) ) { info ⇒ 
 + info . lastReadDate . toEpochMilli should be < date3 . toEpochMilli 
 + info . lastReadDate . toEpochMilli should be > date1 . toEpochMilli 
 } 
 
 whenReady ( service . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 @ @ - 320 , 7 + 318 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 { 
 implicit val clientData = clientData1 
 - expectUpdates ( 
 + expectUpdatesUnordered ( 
 classOf [ UpdateChatGroupsChanged ] , 
 classOf [ UpdateMessageSent ] , 
 classOf [ UpdateMessageSent ] , 
 @ @ - 331 , 7 + 329 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 { 
 implicit val clientData = clientData21 
 - expectUpdates ( 
 + expectUpdatesUnordered ( 
 classOf [ UpdateChatGroupsChanged ] , 
 classOf [ UpdateMessage ] , 
 / / classOf [ UpdateCountersChanged ] , 
 @ @ - 425 , 22 + 423 , 27 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 val startDate = System . currentTimeMillis ( ) 
 
 - { 
 + val ( date1 , date2 , date3 ) = { 
 implicit val clientData = clientData1 
 
 - val sendMessages = Future . sequence ( Seq ( 
 - service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , 
 - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , 
 - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) 
 - ) ) 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) 
 + val date1 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 
 - whenReady ( sendMessages ) ( _ ⇒ ( ) ) 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) 
 + val date2 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 + 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) 
 + val date3 = Instant . now ( ) 
 + 
 + ( date1 , date2 , date3 ) 
 } 
 
 { 
 implicit val clientData = clientData2 
 
 - whenReady ( service . handleMessageReceived ( groupOutPeer . asOutPeer , startDate + 2000 ) ) { resp ⇒ 
 + whenReady ( service . handleMessageReceived ( groupOutPeer . asOutPeer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ 
 resp should matchPattern { 
 case Ok ( ResponseVoid ) ⇒ 
 } 
 @ @ - 448 , 9 + 451 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 Thread . sleep ( 100 ) / / Let peer managers write to db 
 
 - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) ) { dialogOpt ⇒ 
 - dialogOpt . get . lastReceivedAt . getMillis should be < startDate + 3000 
 - dialogOpt . get . lastReceivedAt . getMillis should be > startDate + 1000 
 + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) { info ⇒ 
 + info . lastReceivedDate . toEpochMilli should be < date3 . toEpochMilli 
 + info . lastReceivedDate . toEpochMilli should be > date1 . toEpochMilli 
 } 
 } 
 
 @ @ - 479 , 18 + 482 , 21 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 createGroup ( " Fun group " , Set ( user2 . id ) ) . groupPeer 
 } 
 
 - val startDate = System . currentTimeMillis ( ) 
 - 
 - { 
 + val ( date1 , date2 , date3 ) = { 
 implicit val clientData = clientData1 
 
 - val sendMessages = Future . sequence ( Seq ( 
 - service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) , None ) , 
 - futureSleep ( 1500 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) , None ) ) , 
 - futureSleep ( 3000 ) . flatMap ( _ ⇒ service . handleSendMessage ( groupOutPeer . asOutPeer , Random . nextLong ( ) , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) , None ) ) 
 - ) ) 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) 
 + val date1 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 
 - whenReady ( sendMessages ) ( _ ⇒ ( ) ) 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) 
 + val date2 = Instant . now ( ) 
 + Thread . sleep ( 100 ) 
 + 
 + sendMessageToGroup ( groupOutPeer . groupId , ApiTextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) 
 + val date3 = Instant . now ( ) 
 + 
 + ( date1 , date2 , date3 ) 
 } 
 
 Thread . sleep ( 300 ) 
 @ @ - 498 , 7 + 504 , 7 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 { 
 implicit val clientData = clientData2 
 
 - whenReady ( service . handleMessageRead ( groupOutPeer . asOutPeer , startDate + 2000 ) ) { resp ⇒ 
 + whenReady ( service . handleMessageRead ( groupOutPeer . asOutPeer , date2 . plusMillis ( 1 ) . toEpochMilli ) ) { resp ⇒ 
 resp should matchPattern { 
 case Ok ( ResponseVoid ) ⇒ 
 } 
 @ @ - 506 , 9 + 512 , 9 @ @ final class MessagingServiceHistorySpec extends BaseAppSuite with GroupsServiceH 
 
 Thread . sleep ( 300 ) 
 
 - whenReady ( db . run ( persist . dialog . DialogRepo . findDialog ( user1 . id , model . Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) ) { dialogOpt ⇒ 
 - dialogOpt . get . lastReadAt . getMillis should be < startDate + 3000 
 - dialogOpt . get . lastReadAt . getMillis should be > startDate + 1000 
 + whenReady ( dialogExt . getDialogInfo ( user1 . id , Peer ( PeerType . Group , groupOutPeer . groupId ) ) ) { info ⇒ 
 + info . lastReadDate . toEpochMilli should be < date3 . toEpochMilli 
 + info . lastReadDate . toEpochMilli should be > date1 . toEpochMilli 
 } 
 
 whenReady ( service . handleLoadDialogs ( Long . MaxValue , 100 ) ) { resp ⇒ 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 index eadc9ed . . dfba5fe 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / dialog / DialogProcessorSpec . scala 
 @ @ - 24 , 8 + 24 , 6 @ @ final class DialogProcessorSpec extends BaseAppSuite 
 
 it should " not allow duplicated timestamp in messages " in uniqueTimestamp ( ) 
 
 - private val dialogExt = DialogExtension ( system ) 
 - 
 private val messService = MessagingServiceImpl ( ) 
 
 def noTimeout ( ) = {

NEAREST DIFF:
diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 index 35e0450 . . a8b4741 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / group / GroupOfficeActor . scala 
 @ @ - 113 , 6 + 113 , 10 @ @ class GroupOfficeActor ( 
 
 context . setReceiveTimeout ( 15 . minutes ) 
 
 + / / type AuthIdRandomId = ( Long , Long ) 
 + / / implicit val sendResponseCache : Cache [ AuthIdRandomId , Future [ SeqStateDate ] ] = 
 + / / CacheHelpers . createCache [ AuthIdRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 + 
 / * 
 TODO : turn into migration 
 initialize ( ) pipeTo self onFailure { 
 @ @ - 148 , 6 + 152 , 7 @ @ class GroupOfficeActor ( 
 case _ : GroupEvents . Created ⇒ 
 this . title = title 
 this . creatorUserId = creatorUserId 
 + this . accessHash = accessHash 
 
 val group = models . Group ( 
 id = groupId , 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 index 0ddb0d4 . . eafd943 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOffice . scala 
 @ @ - 22 , 6 + 22 , 8 @ @ object UserOffice { 
 
 case object InvalidAccessHash extends Exception with NoStackTrace 
 
 + case object FailedToFetchInfo 
 + 
 def persistenceIdFor ( userId : Int ) : String = s " user _ $ { userId } " 
 
 def auth ( userId : Int , authId : Long ) ( 
 diff - - git a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 index 4e66423 . . b417592 100644 
 - - - a / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 + + + b / actor - server / actor - peer - managers / src / main / scala / im / actor / server / user / UserOfficeActor . scala 
 @ @ - 1 , 13 + 1 , 13 @ @ 
 package im . actor . server . user 
 
 - import akka . actor . { ActorSystem , ActorLogging , Props , Status } 
 + import akka . actor . _ 
 import akka . pattern . pipe 
 import akka . persistence . RecoveryFailure 
 import akka . util . Timeout 
 + import com . github . benmanes . caffeine . cache . Cache 
 import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . peers . { Peer , PeerType } 
 import im . actor . server . commons . serialization . ActorSerializer 
 - import im . actor . server . models 
 import im . actor . server . office . PeerOffice 
 import im . actor . server . office . PeerOffice . MessageSentComplete 
 import im . actor . server . office . user . { UserEnvelope , UserEvents } 
 @ @ - 15 , 12 + 15 , 13 @ @ import im . actor . server . push . { SeqUpdatesManager , SeqUpdatesManagerRegion } 
 import im . actor . server . sequence . { SeqState , SeqStateDate } 
 import im . actor . server . social . { SocialManager , SocialManagerRegion } 
 import im . actor . server . util . { ACLUtils , HistoryUtils , UserUtils } 
 - import im . actor . server . { persist ⇒ p } 
 + import im . actor . server . { models , persist ⇒ p } 
 + import im . actor . utils . cache . CacheHelpers 
 import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 - import scala . concurrent . { Future , ExecutionContext } 
 import scala . concurrent . duration . _ 
 + import scala . concurrent . { ExecutionContext , Future } 
 import scala . util . { Failure , Success } 
 
 object UserOfficeActor { 
 @ @ - 64 , 6 + 65 , 8 @ @ class UserOfficeActor ( 
 import UserOffice . _ 
 import UserUtils . _ 
 
 + private val MaxCacheSize = 100L 
 + 
 implicit val region : UserOfficeRegion = UserOfficeRegion ( context . parent ) 
 implicit private val timeout : Timeout = Timeout ( 10 . seconds ) 
 
 @ @ - 79 , 15 + 82 , 27 @ @ class UserOfficeActor ( 
 private [ this ] var authIds = Set . empty [ Long ] 
 private [ this ] var accessSalt : Option [ String ] = None 
 
 - def receiveCommand = { 
 - case Payload . UserInfo ( UserInfo ( salt ) ) ⇒ 
 - persist ( UserEvents . UserInfoAdded ( salt ) ) { _ ⇒ 
 - accessSalt = Some ( salt ) 
 - } 
 + type AuthIdRandomId = ( Long , Long ) 
 + implicit val sendResponseCache : Cache [ AuthIdRandomId , Future [ SeqStateDate ] ] = 
 + CacheHelpers . createCache [ AuthIdRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 + 
 + def receiveCommand : Receive = { 
 case Payload . NewAuth ( NewAuth ( authId ) ) ⇒ 
 persist ( UserEvents . AuthAdded ( authId ) ) { _ ⇒ 
 authIds + = authId 
 - if ( accessSalt . isEmpty ) initAccessSalt ( ) 
 + if ( accessSalt . isEmpty ) { 
 + initAccessSalt ( ) 
 + context become { 
 + case Payload . UserInfo ( UserEnvelope . UserInfo ( salt ) ) ⇒ 
 + persist ( UserEvents . UserInfoAdded ( salt ) ) { _ ⇒ 
 + accessSalt = Some ( salt ) 
 + unstashAll ( ) 
 + context become receiveCommand 
 + } 
 + case FailedToFetchInfo ⇒ self ! Kill 
 + case msg ⇒ stash ( ) 
 + } 
 + } 
 sender ( ) ! Status . Success ( ( ) ) 
 } 
 case Payload . RemoveAuth ( RemoveAuth ( authId ) ) ⇒ 
 @ @ - 138 , 14 + 153 , 17 @ @ class UserOfficeActor ( 
 val date = new DateTime 
 val dateMillis = date . getMillis 
 
 - val sendFuture = for { 
 - _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) 
 - SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) 
 - _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) 
 - } yield { 
 - db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) 
 - SeqStateDate ( seq , state , dateMillis ) 
 - } 
 + val sendFuture : Future [ SeqStateDate ] = 
 + CacheHelpers . withCachedResult ( senderAuthId → randomId ) { ( ) ⇒ 
 + for { 
 + _ ← Future . successful ( UserOffice . deliverMessage ( userId , privatePeerStruct ( senderUserId ) , senderUserId , randomId , date , message , isFat ) ) 
 + SeqState ( seq , state ) ← UserOffice . deliverOwnMessage ( senderUserId , privatePeerStruct ( userId ) , senderAuthId , randomId , date , message , isFat ) 
 + _ ← Future . successful ( recordRelation ( senderUserId , userId ) ) 
 + } yield { 
 + db . run ( writeHistoryMessage ( models . Peer . privat ( senderUserId ) , models . Peer . privat ( userId ) , date , randomId , message . header , message . toByteArray ) ) 
 + SeqStateDate ( seq , state , dateMillis ) 
 + } 
 + } 
 sendFuture onComplete { 
 case Success ( seqstate ) ⇒ 
 replyTo ! seqstate 
 @ @ - 196 , 7 + 214 , 7 @ @ class UserOfficeActor ( 
 } 
 } 
 
 - override def receiveRecover = { 
 + override def receiveRecover : Receive = { 
 case UserEvents . AuthAdded ( authId ) ⇒ 
 authIds + = authId 
 case UserEvents . AuthRemoved ( authId ) ⇒ 
 @ @ - 213 , 8 + 231 , 8 @ @ class UserOfficeActor ( 
 
 private def initAccessSalt ( ) : Unit = 
 db . run ( p . User . find ( userId ) . headOption ) onComplete { 
 - case Success ( user ) ⇒ user . map ( _ . accessSalt ) foreach { salt ⇒ self ! UserEnvelope . UserInfo ( salt ) } 
 - case Failure ( _ ) ⇒ 
 + case Success ( user ) ⇒ user . map ( _ . accessSalt ) foreach { salt ⇒ self ! Payload . UserInfo ( UserEnvelope . UserInfo ( salt ) ) } 
 + case Failure ( _ ) ⇒ self ! FailedToFetchInfo 
 } 
 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index a1056a7 . . 508a587 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 30 , 16 + 30 , 18 @ @ import im . actor . server . { ImplicitFileStorageAdapter , BaseAppSuite , persist } 
 class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with ImplicitFileStorageAdapter { 
 behavior of " MessagingService " 
 
 - " Messaging " should " send messages " in s . privat . sendMessage 
 + " Private Messaging " should " send messages " in s . privat . sendMessage 
 
 it should " not repeat message sending with same authId and RandomId " in s . privat . cached 
 
 - it should " send group messages " in s . group . sendMessage 
 + " Group Messaging " should " send messages " in s . group . sendMessage 
 
 it should " not send messages when user is not in group " in s . group . restrictAlienUser 
 
 it should " publish messages in PubSub " in s . pubsub . publish 
 
 + it should " not repeat message sending with same authId and RandomId " in s . group . cached 
 + 
 val awsCredentials = new EnvironmentVariableCredentialsProvider ( ) 
 
 object s { 
 @ @ - 131 , 11 + 133 , 11 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I 
 
 val randomId = Random . nextLong ( ) 
 val actions = Future . sequence ( List ( 
 - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , 
 - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , 
 - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , 
 - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) , 
 - service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva " , Vector . empty , None ) ) 
 + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 4 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( user2Peer , randomId , TextMessage ( " Hi Shiva 5 " , Vector . empty , None ) ) 
 ) ) 
 
 whenReady ( actions ) { resps ⇒ 
 @ @ - 253 , 6 + 255 , 46 @ @ class MessagingServiceSpec extends BaseAppSuite with GroupsServiceHelpers with I 
 } 
 
 } 
 + 
 + def cached ( ) : Unit = { 
 + val randomId = Random . nextLong ( ) 
 + val actions = Future . sequence ( List ( 
 + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 1 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 2 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 3 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 4 " , Vector . empty , None ) ) , 
 + service . handleSendMessage ( groupOutPeer . asOutPeer , randomId , TextMessage ( " Hi Shiva 5 " , Vector . empty , None ) ) 
 + ) ) 
 + 
 + / / in sendMessage ( ) example seq is 1002 , so it should be 1003 here 
 + whenReady ( actions ) { resps ⇒ 
 + resps foreach ( _ should matchPattern { case Ok ( ResponseSeqDate ( 1000 , _ , _ ) ) ⇒ } ) 
 + } 
 + 
 + / / whenReady ( sequenceService . jhandleGetDifference ( 1002 , Array . empty , clientData ) ) { result ⇒ 
 + / / val respOption = result . toOption 
 + / / respOption shouldBe defined 
 + / / val resp = respOption . get 
 + / / 
 + / / val updates = resp . updates 
 + / / updates . length shouldEqual 1 
 + / / 
 + / / val message = UpdateMessageSent . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 + / / message should matchPattern { case Right ( _ : UpdateMessageSent ) ⇒ } 
 + / / } 
 + / / 
 + / / whenReady ( sequenceService . jhandleGetDifference ( 1002 , Array . empty , ClientData ( user2AuthId , sessionId , Some ( user2 . id ) ) ) ) { result ⇒ 
 + / / val respOption = result . toOption 
 + / / respOption shouldBe defined 
 + / / val resp = respOption . get 
 + / / 
 + / / val updates = resp . updates 
 + / / updates . length shouldEqual 1 
 + / / 
 + / / val message = UpdateMessage . parseFrom ( CodedInputStream . newInstance ( updates . last . update ) ) 
 + / / message should matchPattern { case Right ( _ : UpdateMessage ) ⇒ } 
 + / / } 
 + } 
 } 
 
 object pubsub { 
 diff - - git a / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala b / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala 
 index 0b8933c . . c161386 100644 
 - - - a / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala 
 + + + b / actor - server / actor - utils - cache / src / main / scala / im / actor / utils / cache / CacheHelpers . scala 
 @ @ - 1 , 15 + 1 , 29 @ @ 
 package im . actor . utils . cache 
 
 - import java . util . function . Function 
 + import com . github . benmanes . caffeine . cache . { Cache , Caffeine } 
 
 - import com . github . benmanes . caffeine . cache . { Cache , Caffeine } 
 + import scala . concurrent . { ExecutionContext , Future } 
 
 object CacheHelpers { 
 
 def createCache [ K < : AnyRef , V < : AnyRef ] ( maxSize : Long ) : Cache [ K , V ] = Caffeine . newBuilder ( ) . maximumSize ( maxSize ) . build [ K , V ] 
 
 - def withCachedResult [ K , V ] ( key : K ) ( f : ⇒ V ) ( implicit cache : Cache [ K , V ] ) = { 
 - cache . get ( key , new Function [ K , V ] { def apply ( k : K ) = f } ) 
 - } 
 + def withCachedResult [ K , V ] ( key : K ) ( computation : ( ) ⇒ Future [ V ] ) ( 
 + implicit 
 + cache : Cache [ K , Future [ V ] ] , 
 + ec : ExecutionContext 
 + ) = 
 + Option ( cache getIfPresent key ) match { 
 + case Some ( result ) ⇒ result 
 + case None ⇒ 
 + val result = computation ( ) 
 + cache . put ( key , result ) 
 + 
 + result onFailure { 
 + case _ ⇒ cache . invalidate ( key ) 
 + } 
 + 
 + result 
 + } 
 
 } 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index 46fda7b . . 1acb48e 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 203 , 7 + 203 , 7 @ @ object Build extends sbt . Build { 
 settings = defaultSettings + + Seq ( 
 libraryDependencies + + = Dependencies . peerManagers 
 ) 
 - ) . dependsOn ( actorModels , actorPush % PB . protobufConfig , actorPush , actorSocial , actorUtils ) 
 + ) . dependsOn ( actorModels , actorPush % PB . protobufConfig , actorPush , actorSocial , actorUtils , actorUtilsCache ) 
 . aggregate ( actorPush ) 
 
 lazy val actorSession = Project ( 
 @ @ - 255 , 7 + 255 , 6 @ @ object Build extends sbt . Build { 
 actorSms , 
 actorSocial , 
 actorUtils , 
 - actorUtilsCache , 
 actorUtilsHttp , 
 actorVoximplant )
