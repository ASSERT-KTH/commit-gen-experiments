BLEU SCORE: 0.17965205598154216

TEST MSG: Update basic - principles . md
GENERATED MSG: Create level - transport . md

TEST DIFF (one line): diff - - git a / docs / s2s / basic - principles . md b / docs / s2s / basic - principles . md < nl > index de1c37a . . 1c7506a 100644 < nl > - - - a / docs / s2s / basic - principles . md < nl > + + + b / docs / s2s / basic - principles . md < nl > @ @ - 18 , 7 + 18 , 7 @ @ Protocol is JSON - based , but can be easily transformed to any form of key - value f < nl > # # Data Types < nl > < nl > * * * Server Address * * - Array of Host Names and ports for connecting to server . There are different ports for different transports . < nl > - * * * Sequence Updates * * - updates that affects persistent state of a conversation or entyty . For example : new message , group member invite , user ' s avatar change , etc . . . < nl > + * * * Strong Updates * * - updates that affects persistent state of a conversation or entyty . For example : new message , group member invite , user ' s avatar change , etc . . . < nl > * * * Weak Updates * * - ephermal updates that is usually notification about temporary state and doesn ' t need to be stored in any offline storage . For example : typing notifications , online / offline notifications , etc . . . < nl > * * * Requests * * - Abstract request - response from one server to another . < nl > < nl > @ @ - 30 , 6 + 30 , 68 @ @ As MTProto v2 server - server protocol is divided to layers . < nl > * Protection Level - level that encrypt everything and checks data integrity . Not included in current draft . < nl > * Basic API level - API requests and update support . Defines how it is posslbe to make requests from server to server and how to receive updates even throught 3rd party servers . < nl > < nl > + # # Basic API level < nl > + < nl > + Basic API level have PUSH and RPC support . RPC and PUSH are both request - response entities with minor differences in how they work . < nl > + < nl > + # # # # Push < nl > + As we mentioned before , protocol is push - based and all responsibility of push delivery is on sender ' s side . < nl > + < nl > + ` ` ` json < nl > + { < nl > + " weak " : [ < nl > + { < nl > + " update " : " typing " , < nl > + " user _ id " : " uid " , < nl > + " peer " : { < nl > + " type " : " group " , < nl > + " id " : 11223344 < nl > + } < nl > + } < nl > + ] , < nl > + " strong " : [ < nl > + { < nl > + " update " : " message " , < nl > + " peer " : { < nl > + " type " : " group " , < nl > + " id " : 11223344 < nl > + } , < nl > + " content " : { < nl > + " type " : " text " , < nl > + " text " : " Hello Wordl ! " < nl > + } < nl > + } < nl > + ] , < nl > + " seq " : 234234 < nl > + } < nl > + ` ` ` < nl > + < nl > + Response OK < nl > + ` ` ` json < nl > + { < nl > + " receive " : " ok " , < nl > + " seq " : 234234 < nl > + } < nl > + ` ` ` < nl > + < nl > + Response Hole Detected < nl > + Response when in seq updates hole is detected . Sender need to resend all * * STRONG * * updates starting from returned seq . < nl > + ` ` ` json < nl > + { < nl > + " receive " : " hole _ detected " , < nl > + " seq " : 234234 < nl > + } < nl > + ` ` ` < nl > + < nl > + Response Wait < nl > + Response when request need to be repeated in ` wait ` seconds < nl > + ` ` ` json < nl > + { < nl > + " receive " : " wait " , < nl > + " wait " : 123 < nl > + } < nl > + ` ` ` < nl > + < nl > # # Transport Level : HTTPS < nl > < nl > Each server * * MUST * * support HTTPS transport . HTTPS transport is not RESTful API and just transport wrapper to our API .
NEAREST DIFF (one line): diff - - git a / docs / protocol / level - transport . md b / docs / protocol / level - transport . md < nl > new file mode 100644 < nl > index 0000000 . . d735b35 < nl > - - - / dev / null < nl > + + + b / docs / protocol / level - transport . md < nl > @ @ - 0 , 0 + 1 , 207 @ @ < nl > + # Transport Level < nl > + Level for organization reliable package transmition < nl > + < nl > + Transport Level is main and most complex part of protocol . < nl > + < nl > + Main goals of Transport Level < nl > + * Fast connection recreation < nl > + * Minimize traffic amount < nl > + * Connection - agnostic package transmition < nl > + * Recovering after connection die < nl > + * Recovering after server die < nl > + * Work in networks that work on buggy hardware that breaks connection in random situations < nl > + < nl > + In reference protocol implementation only single active connection is used . This assumption makes implementation much more simpler and avoid some weird behaviour when new connection die and old one is still working . < nl > + < nl > + # # Packages < nl > + < nl > + Each transport level package is a structure < nl > + < nl > + ` ` ` < nl > + / / Message Container < nl > + Message { < nl > + 	 / / message identifier < nl > + messageId : long < nl > + / / message body < nl > + message : byte < nl > + } < nl > + < nl > + Package { < nl > + 	 / / unique identifier that is constant thru all application lifetime < nl > + 	 authId : long < nl > + / / random identifier of current session < nl > + sessionId : long < nl > + / / message < nl > + message : Message < nl > + } < nl > + ` ` ` < nl > + < nl > + # # Requesting Auth Id < nl > + < nl > + Before sending and receiving packages it is required to perform ` ` ` authId ` ` ` calculation . In current revision ` ` ` authId ` ` ` is requested by simple special API request . In future version ` ` ` authId ` ` ` will be calculated by performing Diffie - Hellman key exchange . We assume that getting ` ` ` authId ` ` ` is implemented separately and is not part of main MTProto implementation . < nl > + < nl > + During getting ` ` ` authId ` ` ` authId / sessionId is required to be zero for all other operations authId and sessionId can ' t be zero . < nl > + < nl > + ` ` ` < nl > + RequestAuthId { < nl > + 	 HEADER = 0xF0 < nl > + } < nl > + < nl > + ResponseAuthId { < nl > + 	 HEADER = 0xF1 < nl > + authId : long < nl > + } < nl > + ` ` ` < nl > + < nl > + # # RPC and Push Packages < nl > + < nl > + Clients can perform various RPC Requests and get RPC Responses . Server can send Push packages for notification client about updates . < nl > + < nl > + # # # Hint : Messages Priority < nl > + When implementing protocol it is useful to have ability to mark some RPC Requests as high priority and send them always as separate packages and before any other packages . This technic can reduce message send latency . < nl > + < nl > + ` ` ` < nl > + ProtoRpcRequest { < nl > + HEADER = 0x03 < nl > + / / Request body < nl > + payload : bytes < nl > + } < nl > + < nl > + ProtoRpcResponse { < nl > + HEADER = 0x04 < nl > + / / messageId from Message that contains ProtoRpcRequest < nl > + messageId : long < nl > + / / Response body < nl > + payload : bytes < nl > + } < nl > + < nl > + ProtoPush { < nl > + HEADER = 0x05 < nl > + / / Push body < nl > + payload : bytes < nl > + } < nl > + ` ` ` < nl > + < nl > + # # Service Packages < nl > + < nl > + Service packages are packages that used for keeping everything in sync . < nl > + # # # Acknowledge < nl > + Receiving of most messages need to be confirmed by receiver side . ProtoRpcResponse is automatically marking ProtoRpcRequest as confirmed . < nl > + For explicitly marking package as received used MessageAck ( that doesn ' t need to be acknowledged ) . < nl > + Behaviour of server side MessageAck and cleint side MessageAck is a bit different . Server try to send Acks as fast as it can and try to group all acks . < nl > + Client send confirm : < nl > + * When new connection is created : first message is always MessageAck if available . < nl > + * When unconfirmed buffer contains more than 10 messages < nl > + * When client need to send some normal priority packages : client group it with MessageAck < nl > + * When uncorfirmed buffer is older than 1 minute < nl > + < nl > + ` ` ` < nl > + MessageAck { < nl > + HEADER = 0x06 < nl > + / / Message Identificators for confirmation < nl > + messageIds : longs < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # Resend < nl > + < nl > + When sent message is not confirmed then other side can try to resend message or notify about other side about sent message . Usually this is performed when new connection is created or confirmation doesn ' t arrived in 1 minute . < nl > + < nl > + If package is greater than 1kb peer can send notification about sent package for avoiding double - sending . When other peer gets notification about sent message it need to response with MessageAck or RequestResend depends on if peer received this message . < nl > + < nl > + ` ` ` < nl > + / / Notification about unsent message ( usually ProtoRpcRequest or ProtoPush ) < nl > + UnsentMessage { < nl > + HEADER = 0x07 < nl > + / / Sent Message Id < nl > + messageId : long < nl > + / / Size of message in bytes < nl > + len : int < nl > + } < nl > + < nl > + / / Notification about unsent ProtoRpcResponse < nl > + UnsentResponse { < nl > + HEADER = 0x08 < nl > + / / Sent Message Id < nl > + messageId : long < nl > + / / Request Message Id < nl > + requestMessageId : long < nl > + / / Size of message in bytes < nl > + len : int < nl > + } < nl > + < nl > + / / Requesting resending of message < nl > + RequestResend { < nl > + HEADER = 0x09 < nl > + / / Message Id for resend < nl > + messageId : long < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # NewSessionCreated < nl > + * * Most important part of protocol . * * NewSessionCreated is client notification about session recreation because of performing Session Garbage Collection or because of Server Failure . < nl > + When client receive NewSessionCreated it need to resend all ProtoRpcRequests , resubscribe to all events . All Session state is dropped when NewSessionCreated arrive . When client generate new session id then server send NewSessionCreated because there are never was a session with this id . NewSessionCreated are expected to appear randomly in any situation and client side code need to correctly implement it ' s support . < nl > + < nl > + ` ` ` < nl > + NewSession { < nl > + HEADER = 0x0C < nl > + / / Created Session Id < nl > + sessionId : long < nl > + / / Message Id of Message that created session < nl > + messageId : long < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # SessionHello < nl > + Notification about session and auth id in session . Useful when connection is recreated , but there are no suitable data to send . < nl > + < nl > + ` ` ` < nl > + SessionHello { < nl > + 	 HEADER = 0x0F < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # SessionLost < nl > + Notification about session of connection is lost . Client need to perform any request or send SessionHello package < nl > + < nl > + ` ` ` < nl > + SessionLost { < nl > + 	 HEADER = 0x10 < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # AuthIdInvalid < nl > + < nl > + Client ' s AuthId dies and connection is closed after sending this message < nl > + < nl > + ` ` ` < nl > + AuthIdInvalid { < nl > + 	 HEADER = 0x11 < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # Drop < nl > + Drop is a package for notification about some problem with processing package . After sending Drop server close connection . < nl > + ` ` ` < nl > + Drop { < nl > + HEADER = 0x0D < nl > + / / Message Id of message that causes Drop . May be zero if not available < nl > + messageId : long < nl > + / / Error Message < nl > + errorMessage : String < nl > + } < nl > + ` ` ` < nl > + < nl > + # # # Container < nl > + < nl > + For grouping messages into containers protocol uses Container package < nl > + < nl > + ` ` ` < nl > + Container { < nl > + HEADER = 0x0A < nl > + / / Messages count < nl > + count : varint < nl > + / / Messages in container < nl > + data : Message [ ] < nl > + } < nl > + ` ` `

TEST DIFF:
diff - - git a / docs / s2s / basic - principles . md b / docs / s2s / basic - principles . md 
 index de1c37a . . 1c7506a 100644 
 - - - a / docs / s2s / basic - principles . md 
 + + + b / docs / s2s / basic - principles . md 
 @ @ - 18 , 7 + 18 , 7 @ @ Protocol is JSON - based , but can be easily transformed to any form of key - value f 
 # # Data Types 
 
 * * * Server Address * * - Array of Host Names and ports for connecting to server . There are different ports for different transports . 
 - * * * Sequence Updates * * - updates that affects persistent state of a conversation or entyty . For example : new message , group member invite , user ' s avatar change , etc . . . 
 + * * * Strong Updates * * - updates that affects persistent state of a conversation or entyty . For example : new message , group member invite , user ' s avatar change , etc . . . 
 * * * Weak Updates * * - ephermal updates that is usually notification about temporary state and doesn ' t need to be stored in any offline storage . For example : typing notifications , online / offline notifications , etc . . . 
 * * * Requests * * - Abstract request - response from one server to another . 
 
 @ @ - 30 , 6 + 30 , 68 @ @ As MTProto v2 server - server protocol is divided to layers . 
 * Protection Level - level that encrypt everything and checks data integrity . Not included in current draft . 
 * Basic API level - API requests and update support . Defines how it is posslbe to make requests from server to server and how to receive updates even throught 3rd party servers . 
 
 + # # Basic API level 
 + 
 + Basic API level have PUSH and RPC support . RPC and PUSH are both request - response entities with minor differences in how they work . 
 + 
 + # # # # Push 
 + As we mentioned before , protocol is push - based and all responsibility of push delivery is on sender ' s side . 
 + 
 + ` ` ` json 
 + { 
 + " weak " : [ 
 + { 
 + " update " : " typing " , 
 + " user _ id " : " uid " , 
 + " peer " : { 
 + " type " : " group " , 
 + " id " : 11223344 
 + } 
 + } 
 + ] , 
 + " strong " : [ 
 + { 
 + " update " : " message " , 
 + " peer " : { 
 + " type " : " group " , 
 + " id " : 11223344 
 + } , 
 + " content " : { 
 + " type " : " text " , 
 + " text " : " Hello Wordl ! " 
 + } 
 + } 
 + ] , 
 + " seq " : 234234 
 + } 
 + ` ` ` 
 + 
 + Response OK 
 + ` ` ` json 
 + { 
 + " receive " : " ok " , 
 + " seq " : 234234 
 + } 
 + ` ` ` 
 + 
 + Response Hole Detected 
 + Response when in seq updates hole is detected . Sender need to resend all * * STRONG * * updates starting from returned seq . 
 + ` ` ` json 
 + { 
 + " receive " : " hole _ detected " , 
 + " seq " : 234234 
 + } 
 + ` ` ` 
 + 
 + Response Wait 
 + Response when request need to be repeated in ` wait ` seconds 
 + ` ` ` json 
 + { 
 + " receive " : " wait " , 
 + " wait " : 123 
 + } 
 + ` ` ` 
 + 
 # # Transport Level : HTTPS 
 
 Each server * * MUST * * support HTTPS transport . HTTPS transport is not RESTful API and just transport wrapper to our API .

NEAREST DIFF:
diff - - git a / docs / protocol / level - transport . md b / docs / protocol / level - transport . md 
 new file mode 100644 
 index 0000000 . . d735b35 
 - - - / dev / null 
 + + + b / docs / protocol / level - transport . md 
 @ @ - 0 , 0 + 1 , 207 @ @ 
 + # Transport Level 
 + Level for organization reliable package transmition 
 + 
 + Transport Level is main and most complex part of protocol . 
 + 
 + Main goals of Transport Level 
 + * Fast connection recreation 
 + * Minimize traffic amount 
 + * Connection - agnostic package transmition 
 + * Recovering after connection die 
 + * Recovering after server die 
 + * Work in networks that work on buggy hardware that breaks connection in random situations 
 + 
 + In reference protocol implementation only single active connection is used . This assumption makes implementation much more simpler and avoid some weird behaviour when new connection die and old one is still working . 
 + 
 + # # Packages 
 + 
 + Each transport level package is a structure 
 + 
 + ` ` ` 
 + / / Message Container 
 + Message { 
 + 	 / / message identifier 
 + messageId : long 
 + / / message body 
 + message : byte 
 + } 
 + 
 + Package { 
 + 	 / / unique identifier that is constant thru all application lifetime 
 + 	 authId : long 
 + / / random identifier of current session 
 + sessionId : long 
 + / / message 
 + message : Message 
 + } 
 + ` ` ` 
 + 
 + # # Requesting Auth Id 
 + 
 + Before sending and receiving packages it is required to perform ` ` ` authId ` ` ` calculation . In current revision ` ` ` authId ` ` ` is requested by simple special API request . In future version ` ` ` authId ` ` ` will be calculated by performing Diffie - Hellman key exchange . We assume that getting ` ` ` authId ` ` ` is implemented separately and is not part of main MTProto implementation . 
 + 
 + During getting ` ` ` authId ` ` ` authId / sessionId is required to be zero for all other operations authId and sessionId can ' t be zero . 
 + 
 + ` ` ` 
 + RequestAuthId { 
 + 	 HEADER = 0xF0 
 + } 
 + 
 + ResponseAuthId { 
 + 	 HEADER = 0xF1 
 + authId : long 
 + } 
 + ` ` ` 
 + 
 + # # RPC and Push Packages 
 + 
 + Clients can perform various RPC Requests and get RPC Responses . Server can send Push packages for notification client about updates . 
 + 
 + # # # Hint : Messages Priority 
 + When implementing protocol it is useful to have ability to mark some RPC Requests as high priority and send them always as separate packages and before any other packages . This technic can reduce message send latency . 
 + 
 + ` ` ` 
 + ProtoRpcRequest { 
 + HEADER = 0x03 
 + / / Request body 
 + payload : bytes 
 + } 
 + 
 + ProtoRpcResponse { 
 + HEADER = 0x04 
 + / / messageId from Message that contains ProtoRpcRequest 
 + messageId : long 
 + / / Response body 
 + payload : bytes 
 + } 
 + 
 + ProtoPush { 
 + HEADER = 0x05 
 + / / Push body 
 + payload : bytes 
 + } 
 + ` ` ` 
 + 
 + # # Service Packages 
 + 
 + Service packages are packages that used for keeping everything in sync . 
 + # # # Acknowledge 
 + Receiving of most messages need to be confirmed by receiver side . ProtoRpcResponse is automatically marking ProtoRpcRequest as confirmed . 
 + For explicitly marking package as received used MessageAck ( that doesn ' t need to be acknowledged ) . 
 + Behaviour of server side MessageAck and cleint side MessageAck is a bit different . Server try to send Acks as fast as it can and try to group all acks . 
 + Client send confirm : 
 + * When new connection is created : first message is always MessageAck if available . 
 + * When unconfirmed buffer contains more than 10 messages 
 + * When client need to send some normal priority packages : client group it with MessageAck 
 + * When uncorfirmed buffer is older than 1 minute 
 + 
 + ` ` ` 
 + MessageAck { 
 + HEADER = 0x06 
 + / / Message Identificators for confirmation 
 + messageIds : longs 
 + } 
 + ` ` ` 
 + 
 + # # # Resend 
 + 
 + When sent message is not confirmed then other side can try to resend message or notify about other side about sent message . Usually this is performed when new connection is created or confirmation doesn ' t arrived in 1 minute . 
 + 
 + If package is greater than 1kb peer can send notification about sent package for avoiding double - sending . When other peer gets notification about sent message it need to response with MessageAck or RequestResend depends on if peer received this message . 
 + 
 + ` ` ` 
 + / / Notification about unsent message ( usually ProtoRpcRequest or ProtoPush ) 
 + UnsentMessage { 
 + HEADER = 0x07 
 + / / Sent Message Id 
 + messageId : long 
 + / / Size of message in bytes 
 + len : int 
 + } 
 + 
 + / / Notification about unsent ProtoRpcResponse 
 + UnsentResponse { 
 + HEADER = 0x08 
 + / / Sent Message Id 
 + messageId : long 
 + / / Request Message Id 
 + requestMessageId : long 
 + / / Size of message in bytes 
 + len : int 
 + } 
 + 
 + / / Requesting resending of message 
 + RequestResend { 
 + HEADER = 0x09 
 + / / Message Id for resend 
 + messageId : long 
 + } 
 + ` ` ` 
 + 
 + # # # NewSessionCreated 
 + * * Most important part of protocol . * * NewSessionCreated is client notification about session recreation because of performing Session Garbage Collection or because of Server Failure . 
 + When client receive NewSessionCreated it need to resend all ProtoRpcRequests , resubscribe to all events . All Session state is dropped when NewSessionCreated arrive . When client generate new session id then server send NewSessionCreated because there are never was a session with this id . NewSessionCreated are expected to appear randomly in any situation and client side code need to correctly implement it ' s support . 
 + 
 + ` ` ` 
 + NewSession { 
 + HEADER = 0x0C 
 + / / Created Session Id 
 + sessionId : long 
 + / / Message Id of Message that created session 
 + messageId : long 
 + } 
 + ` ` ` 
 + 
 + # # # SessionHello 
 + Notification about session and auth id in session . Useful when connection is recreated , but there are no suitable data to send . 
 + 
 + ` ` ` 
 + SessionHello { 
 + 	 HEADER = 0x0F 
 + } 
 + ` ` ` 
 + 
 + # # # SessionLost 
 + Notification about session of connection is lost . Client need to perform any request or send SessionHello package 
 + 
 + ` ` ` 
 + SessionLost { 
 + 	 HEADER = 0x10 
 + } 
 + ` ` ` 
 + 
 + # # # AuthIdInvalid 
 + 
 + Client ' s AuthId dies and connection is closed after sending this message 
 + 
 + ` ` ` 
 + AuthIdInvalid { 
 + 	 HEADER = 0x11 
 + } 
 + ` ` ` 
 + 
 + # # # Drop 
 + Drop is a package for notification about some problem with processing package . After sending Drop server close connection . 
 + ` ` ` 
 + Drop { 
 + HEADER = 0x0D 
 + / / Message Id of message that causes Drop . May be zero if not available 
 + messageId : long 
 + / / Error Message 
 + errorMessage : String 
 + } 
 + ` ` ` 
 + 
 + # # # Container 
 + 
 + For grouping messages into containers protocol uses Container package 
 + 
 + ` ` ` 
 + Container { 
 + HEADER = 0x0A 
 + / / Messages count 
 + count : varint 
 + / / Messages in container 
 + data : Message [ ] 
 + } 
 + ` ` `
