BLEU SCORE: 0.013139808552042212

TEST MSG: fix ( server : group , rpc ) : reduce members load with GroupV2 optimization
GENERATED MSG: Merge commit ' 8123e8c970ae311aa02d4c9e0196dbfb802e15a6 '

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / groupV2 . proto b / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > index d402520 . . 47be829 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > @ @ - 236 , 6 + 236 , 7 @ @ message GroupQueries { < nl > option ( scalapb . message ) . extends = " GroupQuery " ; < nl > < nl > int32 client _ user _ id = 1 ; < nl > + bool load _ group _ members = 2 ; < nl > } < nl > < nl > message GetApiStructResponse { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index 646e0cc . . 44b1b3f 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 148 , 10 + 148 , 10 @ @ private [ group ] sealed trait Queries { < nl > GroupEnvelope ( groupId ) < nl > . withGetIntegrationToken ( GetIntegrationToken ( clientUserId = None ) ) ) . mapTo [ GetIntegrationTokenResponse ] map ( _ . token ) < nl > < nl > - def getApiStruct ( groupId : Int , clientUserId : Int ) : Future [ ApiGroup ] = < nl > + def getApiStruct ( groupId : Int , clientUserId : Int , loadGroupMembers : Boolean = true ) : Future [ ApiGroup ] = < nl > ( viewRegion . ref ? < nl > GroupEnvelope ( groupId ) < nl > - . withGetApiStruct ( GetApiStruct ( clientUserId ) ) ) . mapTo [ GetApiStructResponse ] map ( _ . struct ) < nl > + . withGetApiStruct ( GetApiStruct ( clientUserId , loadGroupMembers ) ) ) . mapTo [ GetApiStructResponse ] map ( _ . struct ) < nl > < nl > def getApiFullStruct ( groupId : Int , clientUserId : Int ) : Future [ ApiGroupFull ] = < nl > ( viewRegion . ref ? < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index 009961c . . 4e68890 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 169 , 20 + 169 , 20 @ @ private [ group ] final class GroupProcessor < nl > } < nl > < nl > protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > - case _ : GroupQuery if state . isNotCreated ⇒ FastFuture . failed ( GroupNotFound ( groupId ) ) < nl > + case _ : GroupQuery if state . isNotCreated ⇒ FastFuture . failed ( GroupNotFound ( groupId ) ) < nl > / / case _ : GroupQuery if state . isDeleted ⇒ FastFuture . failed ( GroupAlreadyDeleted ( groupId ) ) / / TODO : figure out how to propperly handle group deletion < nl > - case GetAccessHash ( ) ⇒ getAccessHash < nl > - case GetTitle ( ) ⇒ getTitle < nl > - case GetIntegrationToken ( optClient ) ⇒ getIntegrationToken ( optClient ) < nl > - case GetMembers ( ) ⇒ getMembers < nl > - case LoadMembers ( clientUserId , limit , offset ) ⇒ loadMembers ( clientUserId , limit , offset ) < nl > - case IsChannel ( ) ⇒ isChannel < nl > - case IsHistoryShared ( ) ⇒ isHistoryShared < nl > - case GetApiStruct ( clientUserId ) ⇒ getApiStruct ( clientUserId ) < nl > - case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) < nl > - case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) < nl > - case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) < nl > - case LoadAdminSettings ( clientUserId ) ⇒ loadAdminSettings ( clientUserId ) < nl > + case GetAccessHash ( ) ⇒ getAccessHash < nl > + case GetTitle ( ) ⇒ getTitle < nl > + case GetIntegrationToken ( optClient ) ⇒ getIntegrationToken ( optClient ) < nl > + case GetMembers ( ) ⇒ getMembers < nl > + case LoadMembers ( clientUserId , limit , offset ) ⇒ loadMembers ( clientUserId , limit , offset ) < nl > + case IsChannel ( ) ⇒ isChannel < nl > + case IsHistoryShared ( ) ⇒ isHistoryShared < nl > + case GetApiStruct ( clientUserId , loadGroupMembers ) ⇒ getApiStruct ( clientUserId , loadGroupMembers ) < nl > + case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) < nl > + case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) < nl > + case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) < nl > + case LoadAdminSettings ( clientUserId ) ⇒ loadAdminSettings ( clientUserId ) < nl > } < nl > < nl > override def afterCommit ( e : Event ) = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > index 7742bb7 . . 79c9396 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > @ @ - 89 , 7 + 89 , 7 @ @ trait GroupQueryHandlers { < nl > < nl > / / TODO : add ext ! < nl > / / TODO : what if state changes during request ? < nl > - protected def getApiStruct ( clientUserId : Int ) = { < nl > + protected def getApiStruct ( clientUserId : Int , loadGroupMembers : Boolean ) = { < nl > val isMember = state . isMember ( clientUserId ) < nl > val ( members , count ) = membersAndCount ( state , clientUserId ) < nl > < nl > @ @ - 102 , 7 + 102 , 7 @ @ trait GroupQueryHandlers { < nl > avatar = state . avatar , < nl > isMember = Some ( isMember ) , < nl > creatorUserId = state . creatorUserId , < nl > - members = members , < nl > + members = if ( loadGroupMembers ) members else Vector . empty , < nl > createDate = extractCreatedAtMillis ( state ) , < nl > isAdmin = Some ( state . isAdmin ( clientUserId ) ) , < nl > theme = state . topic , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala < nl > index 4452337 . . ab0ea66 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala < nl > @ @ - 12 , 7 + 12 , 7 @ @ object GroupUtils { < nl > def getUserIds ( group : ApiGroup ) : Set [ Int ] = < nl > group . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) . toSet + group . creatorUserId < nl > < nl > - def getUserIds ( groups : Seq [ ApiGroup ] ) : Set [ Int ] = < nl > + private def getUserIds ( groups : Seq [ ApiGroup ] ) : Set [ Int ] = < nl > groups . foldLeft ( Set . empty [ Int ] ) ( _ + + getUserIds ( _ ) ) < nl > < nl > def getGroupsUsers ( groupIds : Seq [ Int ] , userIds : Seq [ Int ] , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) : Future [ ( Seq [ ApiGroup ] , Seq [ ApiUser ] ) ] = { < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala < nl > new file mode 100644 < nl > index 0000000 . . 9fba440 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala < nl > @ @ - 0 , 0 + 1 , 149 @ @ < nl > + package im . actor . api . rpc < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . groups . ApiGroup < nl > + import im . actor . api . rpc . messaging . _ < nl > + import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiPeerType , ApiUserOutPeer } < nl > + import im . actor . api . rpc . users . ApiUser < nl > + import im . actor . server . dialog . HistoryUtils < nl > + import im . actor . server . group . GroupExtension < nl > + import im . actor . server . user . UserExtension < nl > + < nl > + import scala . concurrent . Future < nl > + < nl > + object EntitiesHelpers { < nl > + < nl > + private type UsersOrPeers = ( Vector [ ApiUser ] , Vector [ ApiUserOutPeer ] ) < nl > + < nl > + private type GroupsOrPeers = ( Vector [ ApiGroup ] , Vector [ ApiGroupOutPeer ] ) < nl > + < nl > + / * * < nl > + * Load users and groups presented in ` dialogs ` . < nl > + * If ` stripEntities = true ` , return user and group peers instead of groups and users < nl > + * If ` loadGroupMembers = true ` members will be presented in ` ApiGroup ` object and loaded as users / user peers , < nl > + * otherwise exclude members from users / user peers and ` ApiGroup ` object . < nl > + * / < nl > + def usersAndGroupsByDialogs ( < nl > + dialogs : Seq [ ApiDialog ] , < nl > + stripEntities : Boolean , < nl > + loadGroupMembers : Boolean < nl > + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { < nl > + val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { < nl > + case ( ( uacc , gacc ) , dialog ) ⇒ < nl > + dialog . peer . ` type ` match { < nl > + case ApiPeerType . Private | ApiPeerType . EncryptedPrivate ⇒ < nl > + ( uacc + + relatedUsers ( dialog . message ) + + Set ( dialog . peer . id , dialog . senderUserId ) , gacc ) < nl > + case ApiPeerType . Group ⇒ < nl > + ( uacc + + relatedUsers ( dialog . message ) + dialog . senderUserId , gacc + dialog . peer . id ) < nl > + } < nl > + } < nl > + usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) < nl > + } < nl > + < nl > + def usersAndGroupsByShortDialogs ( < nl > + dialogs : Seq [ ApiDialogShort ] , < nl > + stripEntities : Boolean , < nl > + loadGroupMembers : Boolean < nl > + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { < nl > + val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { < nl > + case ( ( uids , gids ) , dialog ) ⇒ < nl > + dialog . peer . ` type ` match { < nl > + case ApiPeerType . Group ⇒ ( uids , gids + dialog . peer . id ) < nl > + case ApiPeerType . Private | ApiPeerType . EncryptedPrivate ⇒ ( uids + dialog . peer . id , gids ) < nl > + } < nl > + } < nl > + usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) < nl > + } < nl > + < nl > + def usersAndGroupsByIds ( < nl > + groupIds : Set [ Int ] , < nl > + userIds : Set [ Int ] , < nl > + stripEntities : Boolean , < nl > + loadGroupMembers : Boolean < nl > + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { < nl > + import system . dispatcher < nl > + < nl > + for { < nl > + ( groupsOrPeers , groupUserIds ) ← groupsOrPeers ( groupIds , stripEntities , loadGroupMembers ) < nl > + usersOrPeers ← usersOrPeers ( ( userIds + + groupUserIds ) . toVector , stripEntities ) < nl > + } yield ( < nl > + usersOrPeers , < nl > + groupsOrPeers < nl > + ) < nl > + } < nl > + < nl > + / / get groups or group peers and ids of group members if needed < nl > + private def groupsOrPeers ( < nl > + groupIds : Set [ Int ] , < nl > + stripEntities : Boolean , < nl > + loadGroupMembers : Boolean < nl > + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( GroupsOrPeers , Set [ Int ] ) ] = { < nl > + import system . dispatcher < nl > + < nl > + for { < nl > + groups ← Future . sequence ( groupIds map ( GroupExtension ( system ) . getApiStruct ( _ , client . userId , loadGroupMembers ) ) ) < nl > + groupUserIds = if ( loadGroupMembers ) < nl > + groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) < nl > + else < nl > + Set . empty [ Int ] < nl > + groupsOrPeers = if ( stripEntities ) { < nl > + Vector . empty [ ApiGroup ] → ( groups map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) ) . toVector < nl > + } else { < nl > + groups . toVector → Vector . empty [ ApiGroupOutPeer ] < nl > + } < nl > + } yield ( < nl > + groupsOrPeers , < nl > + groupUserIds < nl > + ) < nl > + } < nl > + < nl > + / / TODO : merge together with method in GroupServiceImpl < nl > + def usersOrPeers ( userIds : Vector [ Int ] , stripEntities : Boolean ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ UsersOrPeers ] = { < nl > + import system . dispatcher < nl > + if ( stripEntities ) { < nl > + val users = Vector . empty [ ApiUser ] < nl > + val peers = Future . sequence ( userIds filterNot ( _ = = HistoryUtils . SharedUserId ) map { userId ⇒ < nl > + UserExtension ( system ) . getAccessHash ( userId , client . authId ) map ( hash ⇒ ApiUserOutPeer ( userId , hash ) ) < nl > + } ) < nl > + peers map ( users → _ ) < nl > + } else { < nl > + val users = Future . sequence ( userIds filterNot ( _ = = HistoryUtils . SharedUserId ) map { userId ⇒ < nl > + UserExtension ( system ) . getApiStruct ( userId , client . userId , client . authId ) < nl > + } ) < nl > + val peers = Vector . empty [ ApiUserOutPeer ] < nl > + users map ( _ → peers ) < nl > + } < nl > + } < nl > + < nl > + def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { < nl > + message match { < nl > + case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty < nl > + case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet < nl > + case _ : ApiJsonMessage ⇒ Set . empty < nl > + case _ : ApiEmptyMessage ⇒ Set . empty < nl > + case _ : ApiDocumentMessage ⇒ Set . empty < nl > + case _ : ApiStickerMessage ⇒ Set . empty < nl > + case _ : ApiUnsupportedMessage ⇒ Set . empty < nl > + case _ : ApiBinaryMessage ⇒ Set . empty < nl > + case _ : ApiEncryptedMessage ⇒ Set . empty < nl > + } < nl > + } < nl > + < nl > + private def relatedUsers ( ext : ApiServiceEx ) : Set [ Int ] = < nl > + ext match { < nl > + case ApiServiceExContactRegistered ( userId ) ⇒ Set ( userId ) < nl > + case ApiServiceExChangedAvatar ( _ ) ⇒ Set . empty < nl > + case ApiServiceExChangedTitle ( _ ) ⇒ Set . empty < nl > + case ApiServiceExChangedTopic ( _ ) ⇒ Set . empty < nl > + case ApiServiceExChangedAbout ( _ ) ⇒ Set . empty < nl > + case ApiServiceExGroupCreated | _ : ApiServiceExGroupCreated ⇒ Set . empty < nl > + case ApiServiceExPhoneCall ( _ ) ⇒ Set . empty < nl > + case ApiServiceExPhoneMissed | _ : ApiServiceExPhoneMissed ⇒ Set . empty < nl > + case ApiServiceExUserInvited ( invitedUserId ) ⇒ Set ( invitedUserId ) < nl > + case ApiServiceExUserJoined | _ : ApiServiceExUserJoined ⇒ Set . empty < nl > + case ApiServiceExUserKicked ( kickedUserId ) ⇒ Set ( kickedUserId ) < nl > + case ApiServiceExUserLeft | _ : ApiServiceExUserLeft ⇒ Set . empty < nl > + case _ : ApiServiceExChatArchived | _ : ApiServiceExChatRestored ⇒ Set . empty < nl > + } < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > index 3abe5e9 . . d0c9916 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala < nl > @ @ - 35 , 6 + 35 , 7 @ @ import scala . concurrent . { ExecutionContext , Future } < nl > < nl > final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit actorSystem : ActorSystem ) extends GroupsService { < nl > < nl > + import EntitiesHelpers . _ < nl > import FileHelpers . _ < nl > import FutureResultRpc . _ < nl > import GroupCommands . _ < nl > @ @ - 286 , 6 + 287 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > addOptimizations ( optimizations ) < nl > withUserOutPeers ( users ) { < nl > val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + < nl > val groupId = nextIntId ( ) < nl > val typ = groupType map { < nl > case ApiGroupType . GROUP ⇒ GroupType . General < nl > @ @ - 305 , 13 + 307 , 13 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > SeqStateDate ( seq , state , date ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) < nl > group ← groupExt . getApiStruct ( groupId , client . userId ) < nl > memberIds = GroupUtils . getUserIds ( group ) < nl > - ( apiUsers , apiPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) < nl > + ( users , userPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) < nl > } yield Ok ( ResponseCreateGroup ( < nl > seq = seq , < nl > state = state . toByteArray , < nl > group = group , < nl > - users = apiUsers , < nl > - userPeers = apiPeers , < nl > + users = users , < nl > + userPeers = userPeers , < nl > date = date < nl > ) ) < nl > < nl > @ @ - 410 , 16 + 412 , 17 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > invitingUserId = optInviter < nl > ) ) < nl > ( ( SeqStateDate ( seq , state , date ) , userIds , randomId ) ) = joinResp < nl > - usersPeers ← fromFuture ( usersOrPeers ( userIds , stripEntities ) ) < nl > + up ← fromFuture ( usersOrPeers ( userIds , stripEntities ) ) < nl > + ( users , userPeers ) = up < nl > groupStruct ← fromFuture ( groupExt . getApiStruct ( groupId , client . userId ) ) < nl > } yield ResponseJoinGroup ( < nl > groupStruct , < nl > seq , < nl > state . toByteArray , < nl > date , < nl > - usersPeers . _ 1 , < nl > + users , < nl > randomId , < nl > - usersPeers . _ 2 < nl > + userPeers < nl > ) < nl > < nl > action . value < nl > @ @ - 523 , 21 + 526 , 6 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act < nl > } < nl > } < nl > < nl > - private def usersOrPeers ( userIds : Vector [ Int ] , stripEntities : Boolean ) ( implicit client : AuthorizedClientData ) : Future [ ( Vector [ ApiUser ] , Vector [ ApiUserOutPeer ] ) ] = < nl > - if ( stripEntities ) { < nl > - val users = Vector . empty [ ApiUser ] < nl > - val peers = Future . sequence ( userIds map { userId ⇒ < nl > - userExt . getAccessHash ( userId , client . authId ) map ( hash ⇒ ApiUserOutPeer ( userId , hash ) ) < nl > - } ) < nl > - peers map ( users → _ ) < nl > - } else { < nl > - val users = Future . sequence ( userIds map { userId ⇒ < nl > - userExt . getApiStruct ( userId , client . userId , client . authId ) < nl > - } ) < nl > - val peers = Vector . empty [ ApiUserOutPeer ] < nl > - users map ( _ → peers ) < nl > - } < nl > - < nl > private val inviteUriBase = s " $ { groupInviteConfig . baseUrl } / join / " < nl > < nl > private def genInviteUrl ( token : String ) = s " $ inviteUriBase $ token " < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index f1a718f . . 561f51e 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 5 , 19 + 5 , 16 @ @ import java . time . Instant < nl > import akka . http . scaladsl . util . FastFuture < nl > import im . actor . api . rpc . PeerHelpers . _ < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . groups . ApiGroup < nl > - import im . actor . api . rpc . messaging . { ApiEmptyMessage , _ } < nl > + import im . actor . api . rpc . messaging . _ < nl > import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } < nl > - import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiOutPeer , ApiPeerType , ApiUserOutPeer } < nl > + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . ApiUpdateOptimization < nl > - import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . dialog . HistoryUtils < nl > - import im . actor . server . group . { CanSendMessageInfo , GroupUtils } < nl > + import im . actor . server . group . CanSendMessageInfo < nl > import im . actor . server . model . Peer < nl > import im . actor . server . persist . contact . UserContactRepo < nl > import im . actor . server . persist . HistoryMessageRepo < nl > import im . actor . server . sequence . SeqState < nl > - import im . actor . server . user . UserUtils < nl > import org . joda . time . DateTime < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > @ @ - 27 , 8 + 24 , 8 @ @ import scala . language . postfixOps < nl > trait HistoryHandlers { < nl > self : MessagingServiceImpl ⇒ < nl > < nl > - import DBIOResultRpc . _ < nl > import HistoryUtils . _ < nl > + import EntitiesHelpers . _ < nl > import Implicits . _ < nl > < nl > private val CantDelete = Error ( CommonRpcErrors . forbidden ( " You can ' t delete these messages " ) ) < nl > @ @ - 87 , 20 + 84 , 20 @ @ trait HistoryHandlers { < nl > clientData : ClientData < nl > ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) < nl > + < nl > for { < nl > ( dialogs , nextOffset ) ← dialogExt . fetchArchivedApiDialogs ( client . userId , offset , limit ) < nl > - ( users , groups ) ← getDialogsUsersGroups ( dialogs . toSeq ) < nl > - } yield { < nl > - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > - Ok ( ResponseLoadArchived ( < nl > - dialogs = dialogs . toVector , < nl > - nextOffset = nextOffset , < nl > - groups = if ( stripEntities ) Vector . empty else groups . toVector , < nl > - users = if ( stripEntities ) Vector . empty else users . toVector , < nl > - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , < nl > - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) < nl > - ) ) < nl > - } < nl > + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByDialogs ( dialogs . toSeq , stripEntities , loadGroupMembers ) < nl > + } yield Ok ( ResponseLoadArchived ( < nl > + dialogs = dialogs . toVector , < nl > + nextOffset = nextOffset , < nl > + groups = groups , < nl > + users = users , < nl > + userPeers = userPeers , < nl > + groupPeers = groupPeers < nl > + ) ) < nl > } < nl > < nl > override def doHandleLoadDialogs ( < nl > @ @ - 110 , 20 + 107 , 19 @ @ trait HistoryHandlers { < nl > clientData : ClientData < nl > ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) < nl > + < nl > for { < nl > dialogs ← dialogExt . fetchApiDialogs ( client . userId , Instant . ofEpochMilli ( endDate ) , limit ) < nl > - ( users , groups ) ← getDialogsUsersGroups ( dialogs . toSeq ) < nl > - } yield { < nl > - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > - < nl > - Ok ( ResponseLoadDialogs ( < nl > - groups = if ( stripEntities ) Vector . empty else groups . toVector , < nl > - users = if ( stripEntities ) Vector . empty else users . toVector , < nl > - dialogs = dialogs . toVector , < nl > - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , < nl > - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) < nl > - ) ) < nl > - } < nl > + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByDialogs ( dialogs . toSeq , stripEntities , loadGroupMembers ) < nl > + } yield Ok ( ResponseLoadDialogs ( < nl > + groups = groups , < nl > + users = users , < nl > + dialogs = dialogs . toVector , < nl > + userPeers = userPeers , < nl > + groupPeers = groupPeers < nl > + ) ) < nl > } < nl > < nl > override def doHandleLoadGroupedDialogs ( < nl > @ @ - 131 , 32 + 127 , 27 @ @ trait HistoryHandlers { < nl > clientData : ClientData < nl > ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = < nl > authorized ( clientData ) { implicit client ⇒ < nl > + val stripEntities = optimizations contains ApiUpdateOptimization . STRIP _ ENTITIES < nl > + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) < nl > + < nl > for { < nl > dialogGroups ← dialogExt . fetchApiGroupedDialogs ( client . userId ) < nl > - ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { < nl > - case ( ( uids , gids ) , dialog ) ⇒ < nl > - dialog . peer . ` type ` match { < nl > - case ApiPeerType . Group ⇒ ( uids , gids : + dialog . peer . id ) < nl > - case ApiPeerType . Private ⇒ ( uids : + dialog . peer . id , gids ) < nl > - } < nl > - } < nl > - / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers < nl > - ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) < nl > + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByShortDialogs ( < nl > + dialogs = dialogGroups . flatMap ( _ . dialogs ) , < nl > + stripEntities , < nl > + loadGroupMembers < nl > + ) < nl > archivedExist ← dialogExt . fetchArchivedDialogs ( client . userId , None , 1 ) map ( _ . _ 1 . nonEmpty ) < nl > showInvite ← db . run ( UserContactRepo . count ( client . userId ) ) map ( _ < 5 ) < nl > - } yield { < nl > - val stripEntities = optimizations contains ApiUpdateOptimization . STRIP _ ENTITIES < nl > - < nl > - Ok ( ResponseLoadGroupedDialogs ( < nl > - dialogs = dialogGroups , < nl > - users = if ( stripEntities ) Vector . empty else users . toVector , < nl > - groups = if ( stripEntities ) Vector . empty else groups . toVector , < nl > - showArchived = Some ( archivedExist ) , < nl > - showInvite = Some ( showInvite ) , < nl > - userPeers = if ( stripEntities ) users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) else Vector . empty , < nl > - groupPeers = if ( stripEntities ) groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) else Vector . empty < nl > - ) ) < nl > - } < nl > + } yield Ok ( ResponseLoadGroupedDialogs ( < nl > + dialogs = dialogGroups , < nl > + users = users , < nl > + groups = groups , < nl > + showArchived = Some ( archivedExist ) , < nl > + showInvite = Some ( showInvite ) , < nl > + userPeers = userPeers , < nl > + groupPeers = groupPeers < nl > + ) ) < nl > } < nl > < nl > override def doHandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = < nl > @ @ - 197 , 6 + 188 , 9 @ @ trait HistoryHandlers { < nl > authorized ( clientData ) { implicit client ⇒ < nl > withOutPeer ( peer ) { < nl > val modelPeer = peer . asModel < nl > + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) < nl > + < nl > val action = for { < nl > historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) < nl > ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( modelPeer ) < nl > @ @ - 226 , 19 + 220 , 14 @ @ trait HistoryHandlers { < nl > case None ⇒ ( msgs , uids , guids ) < nl > } < nl > } < nl > - users ← DBIO . from ( Future . sequence ( userIds . toVector map ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) ) ) < nl > - groups ← DBIO . from ( Future . sequence ( groupIds . toVector map ( groupExt . getApiStruct ( _ , client . userId ) ) ) ) < nl > - } yield { < nl > - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > - < nl > - Ok ( ResponseLoadHistory ( < nl > - history = messages , < nl > - users = if ( stripEntities ) Vector . empty else users , < nl > - userPeers = users map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , < nl > - groups = if ( stripEntities ) Vector . empty else groups , < nl > - groupPeers = groups map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) < nl > - ) ) < nl > - } < nl > + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← DBIO . from ( usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) ) < nl > + } yield Ok ( ResponseLoadHistory ( < nl > + history = messages , < nl > + users = users , < nl > + userPeers = userPeers , < nl > + groups = groups , < nl > + groupPeers = groupPeers < nl > + ) ) < nl > db . run ( action ) < nl > } < nl > } < nl > @ @ - 316 , 51 + 305 , 4 @ @ trait HistoryHandlers { < nl > } yield ( new DateTime ( info . lastReceivedDate . toEpochMilli ) , new DateTime ( info . lastReadDate . toEpochMilli ) ) ) < nl > } < nl > < nl > - private def getDialogsUsersGroups ( dialogs : Seq [ ApiDialog ] ) ( implicit client : AuthorizedClientData ) : Future [ ( Set [ ApiUser ] , Set [ ApiGroup ] ) ] = { < nl > - val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { < nl > - case ( ( uacc , gacc ) , dialog ) ⇒ < nl > - if ( dialog . peer . ` type ` = = ApiPeerType . Private ) { < nl > - ( uacc + + relatedUsers ( dialog . message ) + + Set ( dialog . peer . id , dialog . senderUserId ) , gacc ) < nl > - } else { < nl > - ( uacc + + relatedUsers ( dialog . message ) + dialog . senderUserId , gacc + dialog . peer . id ) < nl > - } < nl > - } < nl > - < nl > - for { < nl > - groups ← Future . sequence ( groupIds map ( groupExt . getApiStruct ( _ , client . userId ) ) ) < nl > - groupUserIds = groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) < nl > - users ← Future . sequence ( ( userIds + + groupUserIds ) . filterNot ( _ = = 0 ) map ( UserUtils . safeGetUser ( _ , client . userId , client . authId ) ) ) map ( _ . flatten ) < nl > - } yield ( users , groups ) < nl > - } < nl > - < nl > - private def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { < nl > - message match { < nl > - case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty < nl > - case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet < nl > - case ApiJsonMessage ( _ ) ⇒ Set . empty < nl > - case _ : ApiEmptyMessage ⇒ Set . empty < nl > - case _ : ApiDocumentMessage ⇒ Set . empty < nl > - case _ : ApiStickerMessage ⇒ Set . empty < nl > - case _ : ApiUnsupportedMessage ⇒ Set . empty < nl > - case _ : ApiBinaryMessage ⇒ Set . empty < nl > - case _ : ApiEncryptedMessage ⇒ Set . empty < nl > - } < nl > - } < nl > - < nl > - private def relatedUsers ( ext : ApiServiceEx ) : Set [ Int ] = < nl > - ext match { < nl > - case ApiServiceExContactRegistered ( userId ) ⇒ Set ( userId ) < nl > - case ApiServiceExChangedAvatar ( _ ) ⇒ Set . empty < nl > - case ApiServiceExChangedTitle ( _ ) ⇒ Set . empty < nl > - case ApiServiceExChangedTopic ( _ ) ⇒ Set . empty < nl > - case ApiServiceExChangedAbout ( _ ) ⇒ Set . empty < nl > - case ApiServiceExGroupCreated | _ : ApiServiceExGroupCreated ⇒ Set . empty < nl > - case ApiServiceExPhoneCall ( _ ) ⇒ Set . empty < nl > - case ApiServiceExPhoneMissed | _ : ApiServiceExPhoneMissed ⇒ Set . empty < nl > - case ApiServiceExUserInvited ( invitedUserId ) ⇒ Set ( invitedUserId ) < nl > - case ApiServiceExUserJoined | _ : ApiServiceExUserJoined ⇒ Set . empty < nl > - case ApiServiceExUserKicked ( kickedUserId ) ⇒ Set ( kickedUserId ) < nl > - case ApiServiceExUserLeft | _ : ApiServiceExUserLeft ⇒ Set . empty < nl > - case _ : ApiServiceExChatArchived | _ : ApiServiceExChatRestored ⇒ Set . empty < nl > - } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > index 16ce785 . . 9b21287 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala < nl > @ @ - 76 , 29 + 76 , 31 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { < nl > text : Option [ String ] , < nl > optimizations : IndexedSeq [ ApiUpdateOptimization . Value ] < nl > ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { < nl > + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) < nl > + < nl > for { < nl > results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) < nl > - ( groupIds , userIds , searchResults ) = ( results foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { < nl > + ( groupIds , userIds , searchResults ) = ( results foldLeft ( Set . empty [ Int ] , Set . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { < nl > case ( acc @ ( gids , uids , rslts ) , found @ ApiPeerSearchResult ( peer , _ ) ) ⇒ < nl > if ( rslts . exists ( _ . peer = = peer ) ) { < nl > acc < nl > } else { < nl > peer . ` type ` match { < nl > - case ApiPeerType . Private ⇒ ( gids , uids : + peer . id , rslts : + found ) < nl > - case ApiPeerType . Group ⇒ ( gids : + peer . id , uids , rslts : + found ) < nl > + case ApiPeerType . Private ⇒ ( gids , uids + peer . id , rslts : + found ) < nl > + case ApiPeerType . Group ⇒ ( gids + peer . id , uids , rslts : + found ) < nl > } < nl > } < nl > } < nl > - / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers < nl > - ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) < nl > + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← EntitiesHelpers . usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) < nl > } yield { < nl > - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) < nl > + < nl > Ok ( ResponsePeerSearch ( < nl > searchResults = searchResults , < nl > - users = if ( stripEntities ) Vector . empty else users . toVector , < nl > - groups = if ( stripEntities ) Vector . empty else groups . toVector , < nl > - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , < nl > - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) < nl > + users = users , < nl > + groups = groups , < nl > + userPeers = userPeers , < nl > + groupPeers = groupPeers < nl > ) ) < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > index 641806f . . 71c4080 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala < nl > @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) < nl > ) < nl > < nl > for { < nl > - senderName ← userExt . getName ( receiverUserId , senderUserId ) < nl > + senderName ← userExt . getName ( senderUserId , receiverUserId ) < nl > pushText ← getPushText ( peer , receiverUserId , senderName , message ) < nl > _ ← seqUpdatesExt . deliverSingleUpdate ( < nl > receiverUserId , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > index 4181a2e . . 3230c26 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala < nl > @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > import im . actor . util . cache . CacheHelpers . _ < nl > + import org . joda . time . DateTime < nl > import slick . dbio . DBIO < nl > < nl > import slick . driver . PostgresDriver . api . Database < nl > @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : < nl > dialog ← optDialog match { < nl > case Some ( dialog ) ⇒ DBIO . successful ( dialog ) < nl > case None ⇒ < nl > - val dialog = DialogModel ( userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > for { < nl > _ ← DialogRepo . create ( dialog ) < nl > _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b45cc33 . . d2c2ddb 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > throw e < nl > } ) pipeTo sender ( ) < nl > sendFuture onSuccess { < nl > - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) < nl > + case SeqStateDate ( _ , _ , date ) ⇒ < nl > + self ! LastOwnMessageDate ( date ) < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > } < nl > } < nl > < nl > @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > deliveryExt < nl > . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > < nl > / / onSuccess ( fu ) { _ = > < nl > / / updatePeerMessageDate ( ) < nl > @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > if ( state . isHidden ) < nl > sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) < nl > else { < nl > + < nl > val future = < nl > ( for { < nl > _ ← db . run ( DialogRepo . hide ( userId , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index 55230de . . 01a8d62 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > < nl > + sealed trait DialogGroup { < nl > + def key : String < nl > + def title : String < nl > + } < nl > + < nl > + object DialogGroups { < nl > + object Privates extends DialogGroup { < nl > + override def key : String = " privates " < nl > + < nl > + override def title : String = " Private " < nl > + } < nl > + < nl > + object Groups extends DialogGroup { < nl > + override def key : String = " groups " < nl > + < nl > + override def title : String = " Groups " < nl > + } < nl > + } < nl > + < nl > sealed trait DialogExtension extends Extension < nl > < nl > final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { < nl > @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > < nl > private val log = Logging ( system , getClass ) < nl > < nl > - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = < nl > peer match { < nl > - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ < nl > + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ < nl > log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) < nl > failed < nl > case _ ⇒ f < nl > } < nl > < nl > def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { < nl > val date = Instant . now ( ) . toEpochMilli < nl > val sender = Peer . privat ( senderUserId ) < nl > val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) < nl > @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > randomId : Long , < nl > message : ApiMessage < nl > ) : Future [ Unit ] = < nl > - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { < nl > val sender = Peer . privat ( senderUserId ) < nl > val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) < nl > ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) < nl > } < nl > < nl > def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val receiver = Peer . privat ( receiverUserId ) < nl > val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) < nl > @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) < nl > < nl > def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = < nl > - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { < nl > + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { < nl > val now = Instant . now ( ) . toEpochMilli < nl > val reader = Peer . privat ( readerUserId ) < nl > val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) < nl > @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) < nl > < nl > def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = < nl > - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { < nl > + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] < nl > + } < nl > < nl > def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { < nl > extensions match { < nl > @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > def isSharedUser ( userId : Int ) : Boolean = userId = = 0 < nl > < nl > def getGroupedDialogs ( userId : Int ) = { < nl > - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ < nl > val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { < nl > case ( ( groupModels , privateModels ) , dialog ) ⇒ < nl > if ( dialog . peer . typ = = PeerType . Group ) < nl > @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) < nl > privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) < nl > } yield Vector ( < nl > - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , < nl > - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) < nl > + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , < nl > + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) < nl > ) < nl > } ) < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index 4219e8c . . d3a6b75 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { < nl > for { < nl > _ ← persist . HistoryMessageRepo . create ( messages ) < nl > _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) < nl > - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) < nl > } yield ( ) < nl > } else if ( toPeer . typ = = PeerType . Group ) { < nl > DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > index 9475e63 . . 912092d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala < nl > @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A < nl > private val db = DbExtension ( system ) . db < nl > < nl > def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { < nl > - < < < < < < < Updated upstream < nl > - applePushManager . getInstance ( creds . apnsKey ) match { < nl > - case Some ( mgr ) ⇒ < nl > - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > - val builder = < nl > - new ApnsPayloadBuilder ( ) < nl > - . addCustomProperty ( " seq " , seq ) < nl > - . setContentAvailable ( true ) < nl > - = = = = = = = < nl > withMgr ( creds . apnsKey ) { mgr ⇒ < nl > log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) < nl > - > > > > > > > Stashed changes < nl > - < nl > + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ < nl > + val builder = < nl > + new ApnsPayloadBuilder ( ) < nl > + . addCustomProperty ( " seq " , seq ) < nl > + . setContentAvailable ( true ) < nl > builder . setBadgeNumber ( unreadTotal ) < nl > < nl > val payload = builder . buildWithDefaultMaximumLength ( ) < nl > < nl > mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) < nl > } < nl > - case None ⇒ < nl > - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > index 191aa44 . . a59b5b2 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala < nl > @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { < nl > def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { < nl > phones . headOption match { < nl > case Some ( phone ) ⇒ Some ( phone . number ) < nl > - case None ⇒ Some ( 0L ) < nl > + case None ⇒ Some ( 0L ) < nl > } < nl > } < nl > < nl > def normalizeLocalName ( name : Option [ String ] ) = name match { < nl > - case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > - case _ ⇒ None < nl > + case n @ Some ( name ) if name . nonEmpty ⇒ n < nl > + case _ ⇒ None < nl > } < nl > < nl > def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { < nl > diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > index 9bf22b0 . . d215e44 100644 < nl > - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala < nl > @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots < nl > import java . util . Base64 < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . http . scaladsl . model . StatusCode < nl > import akka . http . scaladsl . model . StatusCodes . _ < nl > import akka . http . scaladsl . model . ws . { Message , TextMessage } < nl > + import akka . http . scaladsl . model . { HttpMethod , StatusCode } < nl > import akka . http . scaladsl . server . Directives . _ < nl > import akka . http . scaladsl . server . Route < nl > import akka . stream . Materializer < nl > @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString < nl > import cats . data . OptionT < nl > import cats . std . future . _ < nl > import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > - import im . actor . api . rpc . messaging . ApiJsonMessage < nl > - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > import im . actor . api . rpc . sequence . UpdateRawUpdate < nl > import im . actor . server . api . http . RoutesHandler < nl > import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } < nl > import im . actor . server . bot . { BotExtension , BotServerBlueprint } < nl > - import im . actor . server . dialog . DialogExtension < nl > import im . actor . server . model . AuthSession < nl > import im . actor . server . user . UserExtension < nl > import play . api . libs . json . _ < nl > import upickle . default . _ < nl > < nl > import scala . concurrent . Future < nl > - import scala . concurrent . forkjoin . ThreadLocalRandom < nl > import scala . util . control . NoStackTrace < nl > import scala . util . { Failure , Success } < nl > < nl > @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > < nl > override def routes : Route = < nl > path ( " bots " / " hooks " / Segment ) { token ⇒ < nl > - post { < nl > - extractRequest { request ⇒ < nl > - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > + extractRequest { request ⇒ < nl > + val method = request . method < nl > + val queryString = request . uri . queryString ( ) < nl > + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) < nl > < nl > - val sendMessageF = for { < nl > - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > - res ← sendMessage ( headers , data , token ) < nl > - } yield res < nl > + val sendMessageF = for { < nl > + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) < nl > + res ← sendMessage ( method , queryString , headers , data , token ) < nl > + } yield res < nl > < nl > - onComplete ( sendMessageF ) { < nl > - case Success ( result ) ⇒ < nl > - result match { < nl > - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) < nl > - } < nl > - case Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to handle bot hook " ) < nl > - complete ( InternalServerError ) < nl > - } < nl > + onComplete ( sendMessageF ) { < nl > + case Success ( result ) ⇒ < nl > + result match { < nl > + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) < nl > + case Right ( _ ) ⇒ < nl > + val response = < nl > + " " " < nl > + | < html > < nl > + | < head > < nl > + | < title > Please , return to the app < / title > < nl > + | < style > < nl > + | . element { < nl > + | position : relative ; < nl > + | top : 50 % ; < nl > + | transform : translateY ( - 50 % ) ; < nl > + | } < nl > + | < / style > < nl > + | < / head > < nl > + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > < nl > + | < / html > < nl > + " " " . stripMargin < nl > + complete ( OK → Status ( response ) ) < nl > + } < nl > + case Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to handle bot hook " ) < nl > + complete ( InternalServerError ) < nl > } < nl > } < nl > } ~ path ( " bots " / Segment ) { token ⇒ < nl > @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > } < nl > } < nl > < nl > - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { < nl > ( for { < nl > hook ← OptionT ( botExt . findWebHook ( token ) ) < nl > _ ← OptionT . pure ( userExt . broadcastUserUpdate ( < nl > @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material < nl > " dataType " → JsString ( " HookData " ) , < nl > " data " → JsObject ( Map ( < nl > " name " → JsString ( hook . name ) , < nl > + " method " → JsString ( method . name ) , < nl > + " queryString " → ( queryString map JsString getOrElse JsNull ) , < nl > " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , < nl > " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) < nl > ) ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > index f7b0742 . . f9c82b0 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala < nl > @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { < nl > def findLastReadBefore ( date : DateTime , userId : Int ) = < nl > dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result < nl > < nl > - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) < nl > + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > < nl > def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = < nl > findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) < nl > diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > index 14c35dd . . 66d4ebf 100644 < nl > - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala < nl > @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { < nl > | " com . trueaccord . scalapb . GeneratedMessage " = actor < nl > | } < nl > | } < nl > + | < nl > + | cluster . sharding . state - store - mode = " ddata " < nl > | } < nl > " " " . stripMargin < nl > ) ) < nl > diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > index 3d25a02 . . 72dc6c1 100644 < nl > - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala < nl > @ @ - 1 , 27 + 1 , 52 @ @ < nl > package im . actor . server < nl > < nl > import akka . actor . ActorSystem < nl > - import akka . util . Timeout < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } < nl > + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } < nl > import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } < nl > + import im . actor . api . rpc . users . ApiUser < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . dialog . DialogGroup < nl > + import org . scalatest . concurrent . ScalaFutures < nl > < nl > - import scala . concurrent . Await < nl > + import scala . language . postfixOps < nl > import scala . util . Random < nl > < nl > - trait MessagingSpecHelpers { < nl > - val timeout : Timeout < nl > + trait MessagingSpecHelpers extends ScalaFutures { < nl > + implicit val system : ActorSystem < nl > < nl > def sendMessageToUser ( userId : Int , message : ApiMessage ) ( < nl > implicit < nl > clientData : ClientData , < nl > - msgService : MessagingService , < nl > - system : ActorSystem < nl > + msgService : MessagingService < nl > ) : Unit = { < nl > - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) < nl > - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) < nl > + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ < nl > + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) < nl > + } < nl > } < nl > < nl > def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) < nl > + < nl > + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { < nl > + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ < nl > + resp . toOption . get . dialogs map { < nl > + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs < nl > + } toMap < nl > + } < nl > + } < nl > + < nl > + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { < nl > + val dgs = getDialogGroups ( ) < nl > + dgs get group . key match { < nl > + case Some ( ds ) ⇒ ds < nl > + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) < nl > + } < nl > + } < nl > + < nl > + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { < nl > + users foreach { user ⇒ < nl > + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) < nl > + Thread . sleep ( 1 ) < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > index 85ba87d . . fe02129 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala < nl > @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } < nl > import im . actor . server . acl . ACLUtils < nl > import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } < nl > - import org . scalatest . Inside . _ < nl > + import im . actor . server . _ < nl > + import im . actor . server . dialog . DialogGroups < nl > < nl > import scala . concurrent . { Await , Future } < nl > import scala . concurrent . duration . _ < nl > @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec < nl > extends BaseAppSuite < nl > with ImplicitAuthService < nl > with ImplicitSessionRegion < nl > - with GroupsServiceHelpers { < nl > + with GroupsServiceHelpers < nl > + with MessagingSpecHelpers { < nl > " LoadGroupedDialogs " should " load groups and privates " in loadGrouped < nl > < nl > - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > - private val service = MessagingServiceImpl ( ) < nl > + " Dialogs " should " appear in top on new incoming message " in incomingGoTop < nl > + it should " appear in top on new outgoing message " in outgoingGoTop < nl > + < nl > + " Hidden dialogs " should " appear on new message " in appearHidden < nl > + it should " appear on show " in appearShown < nl > + < nl > + import DialogGroups . _ < nl > + < nl > + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) < nl > + private implicit lazy val service = MessagingServiceImpl ( ) < nl > < nl > def loadGrouped ( ) = { < nl > val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) < nl > @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec < nl > } < nl > } < nl > } < nl > + < nl > + def incomingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) < nl > + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) < nl > + < nl > + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) < nl > + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = bobClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val dgs = getDialogGroups ( ) < nl > + val privates = dgs ( Privates . key ) < nl > + privates . size should equal ( 2 ) < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + privates . last . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + Thread . sleep ( 1 ) < nl > + < nl > + { < nl > + implicit val clientData = eveClient < nl > + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) < nl > + } < nl > + < nl > + { < nl > + implicit val clientData = aliceClient < nl > + val privates = getDialogGroups ( Privates ) < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + } < nl > + < nl > + def outgoingGoTop ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + val ( eve , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + < nl > + prepareDialogs ( bob , eve ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( eve . id ) < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) < nl > + < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case privates ⇒ < nl > + privates . head . peer . id should equal ( bob . id ) < nl > + } < nl > + } < nl > + < nl > + def appearHidden ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > + < nl > + def appearShown ( ) = { < nl > + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) < nl > + val ( bob , _ , _ , _ ) = createUser ( ) < nl > + < nl > + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) < nl > + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) < nl > + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) < nl > + < nl > + prepareDialogs ( bob ) < nl > + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( ) ⇒ < nl > + } < nl > + < nl > + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) < nl > + inside ( getDialogGroups ( Privates ) ) { < nl > + case Vector ( _ ) ⇒ < nl > + } < nl > + } < nl > } < nl > \ No newline at end of file

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / groupV2 . proto b / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 index d402520 . . 47be829 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 @ @ - 236 , 6 + 236 , 7 @ @ message GroupQueries { 
 option ( scalapb . message ) . extends = " GroupQuery " ; 
 
 int32 client _ user _ id = 1 ; 
 + bool load _ group _ members = 2 ; 
 } 
 
 message GetApiStructResponse { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index 646e0cc . . 44b1b3f 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 148 , 10 + 148 , 10 @ @ private [ group ] sealed trait Queries { 
 GroupEnvelope ( groupId ) 
 . withGetIntegrationToken ( GetIntegrationToken ( clientUserId = None ) ) ) . mapTo [ GetIntegrationTokenResponse ] map ( _ . token ) 
 
 - def getApiStruct ( groupId : Int , clientUserId : Int ) : Future [ ApiGroup ] = 
 + def getApiStruct ( groupId : Int , clientUserId : Int , loadGroupMembers : Boolean = true ) : Future [ ApiGroup ] = 
 ( viewRegion . ref ? 
 GroupEnvelope ( groupId ) 
 - . withGetApiStruct ( GetApiStruct ( clientUserId ) ) ) . mapTo [ GetApiStructResponse ] map ( _ . struct ) 
 + . withGetApiStruct ( GetApiStruct ( clientUserId , loadGroupMembers ) ) ) . mapTo [ GetApiStructResponse ] map ( _ . struct ) 
 
 def getApiFullStruct ( groupId : Int , clientUserId : Int ) : Future [ ApiGroupFull ] = 
 ( viewRegion . ref ? 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index 009961c . . 4e68890 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 169 , 20 + 169 , 20 @ @ private [ group ] final class GroupProcessor 
 } 
 
 protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 - case _ : GroupQuery if state . isNotCreated ⇒ FastFuture . failed ( GroupNotFound ( groupId ) ) 
 + case _ : GroupQuery if state . isNotCreated ⇒ FastFuture . failed ( GroupNotFound ( groupId ) ) 
 / / case _ : GroupQuery if state . isDeleted ⇒ FastFuture . failed ( GroupAlreadyDeleted ( groupId ) ) / / TODO : figure out how to propperly handle group deletion 
 - case GetAccessHash ( ) ⇒ getAccessHash 
 - case GetTitle ( ) ⇒ getTitle 
 - case GetIntegrationToken ( optClient ) ⇒ getIntegrationToken ( optClient ) 
 - case GetMembers ( ) ⇒ getMembers 
 - case LoadMembers ( clientUserId , limit , offset ) ⇒ loadMembers ( clientUserId , limit , offset ) 
 - case IsChannel ( ) ⇒ isChannel 
 - case IsHistoryShared ( ) ⇒ isHistoryShared 
 - case GetApiStruct ( clientUserId ) ⇒ getApiStruct ( clientUserId ) 
 - case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) 
 - case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) 
 - case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) 
 - case LoadAdminSettings ( clientUserId ) ⇒ loadAdminSettings ( clientUserId ) 
 + case GetAccessHash ( ) ⇒ getAccessHash 
 + case GetTitle ( ) ⇒ getTitle 
 + case GetIntegrationToken ( optClient ) ⇒ getIntegrationToken ( optClient ) 
 + case GetMembers ( ) ⇒ getMembers 
 + case LoadMembers ( clientUserId , limit , offset ) ⇒ loadMembers ( clientUserId , limit , offset ) 
 + case IsChannel ( ) ⇒ isChannel 
 + case IsHistoryShared ( ) ⇒ isHistoryShared 
 + case GetApiStruct ( clientUserId , loadGroupMembers ) ⇒ getApiStruct ( clientUserId , loadGroupMembers ) 
 + case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) 
 + case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) 
 + case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) 
 + case LoadAdminSettings ( clientUserId ) ⇒ loadAdminSettings ( clientUserId ) 
 } 
 
 override def afterCommit ( e : Event ) = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 index 7742bb7 . . 79c9396 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 @ @ - 89 , 7 + 89 , 7 @ @ trait GroupQueryHandlers { 
 
 / / TODO : add ext ! 
 / / TODO : what if state changes during request ? 
 - protected def getApiStruct ( clientUserId : Int ) = { 
 + protected def getApiStruct ( clientUserId : Int , loadGroupMembers : Boolean ) = { 
 val isMember = state . isMember ( clientUserId ) 
 val ( members , count ) = membersAndCount ( state , clientUserId ) 
 
 @ @ - 102 , 7 + 102 , 7 @ @ trait GroupQueryHandlers { 
 avatar = state . avatar , 
 isMember = Some ( isMember ) , 
 creatorUserId = state . creatorUserId , 
 - members = members , 
 + members = if ( loadGroupMembers ) members else Vector . empty , 
 createDate = extractCreatedAtMillis ( state ) , 
 isAdmin = Some ( state . isAdmin ( clientUserId ) ) , 
 theme = state . topic , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala 
 index 4452337 . . ab0ea66 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupUtils . scala 
 @ @ - 12 , 7 + 12 , 7 @ @ object GroupUtils { 
 def getUserIds ( group : ApiGroup ) : Set [ Int ] = 
 group . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) . toSet + group . creatorUserId 
 
 - def getUserIds ( groups : Seq [ ApiGroup ] ) : Set [ Int ] = 
 + private def getUserIds ( groups : Seq [ ApiGroup ] ) : Set [ Int ] = 
 groups . foldLeft ( Set . empty [ Int ] ) ( _ + + getUserIds ( _ ) ) 
 
 def getGroupsUsers ( groupIds : Seq [ Int ] , userIds : Seq [ Int ] , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) : Future [ ( Seq [ ApiGroup ] , Seq [ ApiUser ] ) ] = { 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala 
 new file mode 100644 
 index 0000000 . . 9fba440 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / EntitiesHelpers . scala 
 @ @ - 0 , 0 + 1 , 149 @ @ 
 + package im . actor . api . rpc 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . groups . ApiGroup 
 + import im . actor . api . rpc . messaging . _ 
 + import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiPeerType , ApiUserOutPeer } 
 + import im . actor . api . rpc . users . ApiUser 
 + import im . actor . server . dialog . HistoryUtils 
 + import im . actor . server . group . GroupExtension 
 + import im . actor . server . user . UserExtension 
 + 
 + import scala . concurrent . Future 
 + 
 + object EntitiesHelpers { 
 + 
 + private type UsersOrPeers = ( Vector [ ApiUser ] , Vector [ ApiUserOutPeer ] ) 
 + 
 + private type GroupsOrPeers = ( Vector [ ApiGroup ] , Vector [ ApiGroupOutPeer ] ) 
 + 
 + / * * 
 + * Load users and groups presented in ` dialogs ` . 
 + * If ` stripEntities = true ` , return user and group peers instead of groups and users 
 + * If ` loadGroupMembers = true ` members will be presented in ` ApiGroup ` object and loaded as users / user peers , 
 + * otherwise exclude members from users / user peers and ` ApiGroup ` object . 
 + * / 
 + def usersAndGroupsByDialogs ( 
 + dialogs : Seq [ ApiDialog ] , 
 + stripEntities : Boolean , 
 + loadGroupMembers : Boolean 
 + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { 
 + val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { 
 + case ( ( uacc , gacc ) , dialog ) ⇒ 
 + dialog . peer . ` type ` match { 
 + case ApiPeerType . Private | ApiPeerType . EncryptedPrivate ⇒ 
 + ( uacc + + relatedUsers ( dialog . message ) + + Set ( dialog . peer . id , dialog . senderUserId ) , gacc ) 
 + case ApiPeerType . Group ⇒ 
 + ( uacc + + relatedUsers ( dialog . message ) + dialog . senderUserId , gacc + dialog . peer . id ) 
 + } 
 + } 
 + usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) 
 + } 
 + 
 + def usersAndGroupsByShortDialogs ( 
 + dialogs : Seq [ ApiDialogShort ] , 
 + stripEntities : Boolean , 
 + loadGroupMembers : Boolean 
 + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { 
 + val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { 
 + case ( ( uids , gids ) , dialog ) ⇒ 
 + dialog . peer . ` type ` match { 
 + case ApiPeerType . Group ⇒ ( uids , gids + dialog . peer . id ) 
 + case ApiPeerType . Private | ApiPeerType . EncryptedPrivate ⇒ ( uids + dialog . peer . id , gids ) 
 + } 
 + } 
 + usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) 
 + } 
 + 
 + def usersAndGroupsByIds ( 
 + groupIds : Set [ Int ] , 
 + userIds : Set [ Int ] , 
 + stripEntities : Boolean , 
 + loadGroupMembers : Boolean 
 + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( UsersOrPeers , GroupsOrPeers ) ] = { 
 + import system . dispatcher 
 + 
 + for { 
 + ( groupsOrPeers , groupUserIds ) ← groupsOrPeers ( groupIds , stripEntities , loadGroupMembers ) 
 + usersOrPeers ← usersOrPeers ( ( userIds + + groupUserIds ) . toVector , stripEntities ) 
 + } yield ( 
 + usersOrPeers , 
 + groupsOrPeers 
 + ) 
 + } 
 + 
 + / / get groups or group peers and ids of group members if needed 
 + private def groupsOrPeers ( 
 + groupIds : Set [ Int ] , 
 + stripEntities : Boolean , 
 + loadGroupMembers : Boolean 
 + ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ ( GroupsOrPeers , Set [ Int ] ) ] = { 
 + import system . dispatcher 
 + 
 + for { 
 + groups ← Future . sequence ( groupIds map ( GroupExtension ( system ) . getApiStruct ( _ , client . userId , loadGroupMembers ) ) ) 
 + groupUserIds = if ( loadGroupMembers ) 
 + groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) 
 + else 
 + Set . empty [ Int ] 
 + groupsOrPeers = if ( stripEntities ) { 
 + Vector . empty [ ApiGroup ] → ( groups map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) ) . toVector 
 + } else { 
 + groups . toVector → Vector . empty [ ApiGroupOutPeer ] 
 + } 
 + } yield ( 
 + groupsOrPeers , 
 + groupUserIds 
 + ) 
 + } 
 + 
 + / / TODO : merge together with method in GroupServiceImpl 
 + def usersOrPeers ( userIds : Vector [ Int ] , stripEntities : Boolean ) ( implicit client : AuthorizedClientData , system : ActorSystem ) : Future [ UsersOrPeers ] = { 
 + import system . dispatcher 
 + if ( stripEntities ) { 
 + val users = Vector . empty [ ApiUser ] 
 + val peers = Future . sequence ( userIds filterNot ( _ = = HistoryUtils . SharedUserId ) map { userId ⇒ 
 + UserExtension ( system ) . getAccessHash ( userId , client . authId ) map ( hash ⇒ ApiUserOutPeer ( userId , hash ) ) 
 + } ) 
 + peers map ( users → _ ) 
 + } else { 
 + val users = Future . sequence ( userIds filterNot ( _ = = HistoryUtils . SharedUserId ) map { userId ⇒ 
 + UserExtension ( system ) . getApiStruct ( userId , client . userId , client . authId ) 
 + } ) 
 + val peers = Vector . empty [ ApiUserOutPeer ] 
 + users map ( _ → peers ) 
 + } 
 + } 
 + 
 + def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { 
 + message match { 
 + case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty 
 + case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet 
 + case _ : ApiJsonMessage ⇒ Set . empty 
 + case _ : ApiEmptyMessage ⇒ Set . empty 
 + case _ : ApiDocumentMessage ⇒ Set . empty 
 + case _ : ApiStickerMessage ⇒ Set . empty 
 + case _ : ApiUnsupportedMessage ⇒ Set . empty 
 + case _ : ApiBinaryMessage ⇒ Set . empty 
 + case _ : ApiEncryptedMessage ⇒ Set . empty 
 + } 
 + } 
 + 
 + private def relatedUsers ( ext : ApiServiceEx ) : Set [ Int ] = 
 + ext match { 
 + case ApiServiceExContactRegistered ( userId ) ⇒ Set ( userId ) 
 + case ApiServiceExChangedAvatar ( _ ) ⇒ Set . empty 
 + case ApiServiceExChangedTitle ( _ ) ⇒ Set . empty 
 + case ApiServiceExChangedTopic ( _ ) ⇒ Set . empty 
 + case ApiServiceExChangedAbout ( _ ) ⇒ Set . empty 
 + case ApiServiceExGroupCreated | _ : ApiServiceExGroupCreated ⇒ Set . empty 
 + case ApiServiceExPhoneCall ( _ ) ⇒ Set . empty 
 + case ApiServiceExPhoneMissed | _ : ApiServiceExPhoneMissed ⇒ Set . empty 
 + case ApiServiceExUserInvited ( invitedUserId ) ⇒ Set ( invitedUserId ) 
 + case ApiServiceExUserJoined | _ : ApiServiceExUserJoined ⇒ Set . empty 
 + case ApiServiceExUserKicked ( kickedUserId ) ⇒ Set ( kickedUserId ) 
 + case ApiServiceExUserLeft | _ : ApiServiceExUserLeft ⇒ Set . empty 
 + case _ : ApiServiceExChatArchived | _ : ApiServiceExChatRestored ⇒ Set . empty 
 + } 
 + 
 + } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 index 3abe5e9 . . d0c9916 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / groups / GroupsServiceImpl . scala 
 @ @ - 35 , 6 + 35 , 7 @ @ import scala . concurrent . { ExecutionContext , Future } 
 
 final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit actorSystem : ActorSystem ) extends GroupsService { 
 
 + import EntitiesHelpers . _ 
 import FileHelpers . _ 
 import FutureResultRpc . _ 
 import GroupCommands . _ 
 @ @ - 286 , 6 + 287 , 7 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 addOptimizations ( optimizations ) 
 withUserOutPeers ( users ) { 
 val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + 
 val groupId = nextIntId ( ) 
 val typ = groupType map { 
 case ApiGroupType . GROUP ⇒ GroupType . General 
 @ @ - 305 , 13 + 307 , 13 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 SeqStateDate ( seq , state , date ) = seqStateDate . getOrElse ( throw NoSeqStateDate ) 
 group ← groupExt . getApiStruct ( groupId , client . userId ) 
 memberIds = GroupUtils . getUserIds ( group ) 
 - ( apiUsers , apiPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) 
 + ( users , userPeers ) ← usersOrPeers ( memberIds . toVector , stripEntities ) 
 } yield Ok ( ResponseCreateGroup ( 
 seq = seq , 
 state = state . toByteArray , 
 group = group , 
 - users = apiUsers , 
 - userPeers = apiPeers , 
 + users = users , 
 + userPeers = userPeers , 
 date = date 
 ) ) 
 
 @ @ - 410 , 16 + 412 , 17 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 invitingUserId = optInviter 
 ) ) 
 ( ( SeqStateDate ( seq , state , date ) , userIds , randomId ) ) = joinResp 
 - usersPeers ← fromFuture ( usersOrPeers ( userIds , stripEntities ) ) 
 + up ← fromFuture ( usersOrPeers ( userIds , stripEntities ) ) 
 + ( users , userPeers ) = up 
 groupStruct ← fromFuture ( groupExt . getApiStruct ( groupId , client . userId ) ) 
 } yield ResponseJoinGroup ( 
 groupStruct , 
 seq , 
 state . toByteArray , 
 date , 
 - usersPeers . _ 1 , 
 + users , 
 randomId , 
 - usersPeers . _ 2 
 + userPeers 
 ) 
 
 action . value 
 @ @ - 523 , 21 + 526 , 6 @ @ final class GroupsServiceImpl ( groupInviteConfig : GroupInviteConfig ) ( implicit act 
 } 
 } 
 
 - private def usersOrPeers ( userIds : Vector [ Int ] , stripEntities : Boolean ) ( implicit client : AuthorizedClientData ) : Future [ ( Vector [ ApiUser ] , Vector [ ApiUserOutPeer ] ) ] = 
 - if ( stripEntities ) { 
 - val users = Vector . empty [ ApiUser ] 
 - val peers = Future . sequence ( userIds map { userId ⇒ 
 - userExt . getAccessHash ( userId , client . authId ) map ( hash ⇒ ApiUserOutPeer ( userId , hash ) ) 
 - } ) 
 - peers map ( users → _ ) 
 - } else { 
 - val users = Future . sequence ( userIds map { userId ⇒ 
 - userExt . getApiStruct ( userId , client . userId , client . authId ) 
 - } ) 
 - val peers = Vector . empty [ ApiUserOutPeer ] 
 - users map ( _ → peers ) 
 - } 
 - 
 private val inviteUriBase = s " $ { groupInviteConfig . baseUrl } / join / " 
 
 private def genInviteUrl ( token : String ) = s " $ inviteUriBase $ token " 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index f1a718f . . 561f51e 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 5 , 19 + 5 , 16 @ @ import java . time . Instant 
 import akka . http . scaladsl . util . FastFuture 
 import im . actor . api . rpc . PeerHelpers . _ 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . groups . ApiGroup 
 - import im . actor . api . rpc . messaging . { ApiEmptyMessage , _ } 
 + import im . actor . api . rpc . messaging . _ 
 import im . actor . api . rpc . misc . { ResponseSeq , ResponseVoid } 
 - import im . actor . api . rpc . peers . { ApiGroupOutPeer , ApiOutPeer , ApiPeerType , ApiUserOutPeer } 
 + import im . actor . api . rpc . peers . { ApiOutPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . ApiUpdateOptimization 
 - import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . dialog . HistoryUtils 
 - import im . actor . server . group . { CanSendMessageInfo , GroupUtils } 
 + import im . actor . server . group . CanSendMessageInfo 
 import im . actor . server . model . Peer 
 import im . actor . server . persist . contact . UserContactRepo 
 import im . actor . server . persist . HistoryMessageRepo 
 import im . actor . server . sequence . SeqState 
 - import im . actor . server . user . UserUtils 
 import org . joda . time . DateTime 
 import slick . driver . PostgresDriver . api . _ 
 
 @ @ - 27 , 8 + 24 , 8 @ @ import scala . language . postfixOps 
 trait HistoryHandlers { 
 self : MessagingServiceImpl ⇒ 
 
 - import DBIOResultRpc . _ 
 import HistoryUtils . _ 
 + import EntitiesHelpers . _ 
 import Implicits . _ 
 
 private val CantDelete = Error ( CommonRpcErrors . forbidden ( " You can ' t delete these messages " ) ) 
 @ @ - 87 , 20 + 84 , 20 @ @ trait HistoryHandlers { 
 clientData : ClientData 
 ) : Future [ HandlerResult [ ResponseLoadArchived ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) 
 + 
 for { 
 ( dialogs , nextOffset ) ← dialogExt . fetchArchivedApiDialogs ( client . userId , offset , limit ) 
 - ( users , groups ) ← getDialogsUsersGroups ( dialogs . toSeq ) 
 - } yield { 
 - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 - Ok ( ResponseLoadArchived ( 
 - dialogs = dialogs . toVector , 
 - nextOffset = nextOffset , 
 - groups = if ( stripEntities ) Vector . empty else groups . toVector , 
 - users = if ( stripEntities ) Vector . empty else users . toVector , 
 - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , 
 - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) 
 - ) ) 
 - } 
 + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByDialogs ( dialogs . toSeq , stripEntities , loadGroupMembers ) 
 + } yield Ok ( ResponseLoadArchived ( 
 + dialogs = dialogs . toVector , 
 + nextOffset = nextOffset , 
 + groups = groups , 
 + users = users , 
 + userPeers = userPeers , 
 + groupPeers = groupPeers 
 + ) ) 
 } 
 
 override def doHandleLoadDialogs ( 
 @ @ - 110 , 20 + 107 , 19 @ @ trait HistoryHandlers { 
 clientData : ClientData 
 ) : Future [ HandlerResult [ ResponseLoadDialogs ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) 
 + 
 for { 
 dialogs ← dialogExt . fetchApiDialogs ( client . userId , Instant . ofEpochMilli ( endDate ) , limit ) 
 - ( users , groups ) ← getDialogsUsersGroups ( dialogs . toSeq ) 
 - } yield { 
 - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 - 
 - Ok ( ResponseLoadDialogs ( 
 - groups = if ( stripEntities ) Vector . empty else groups . toVector , 
 - users = if ( stripEntities ) Vector . empty else users . toVector , 
 - dialogs = dialogs . toVector , 
 - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , 
 - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) 
 - ) ) 
 - } 
 + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByDialogs ( dialogs . toSeq , stripEntities , loadGroupMembers ) 
 + } yield Ok ( ResponseLoadDialogs ( 
 + groups = groups , 
 + users = users , 
 + dialogs = dialogs . toVector , 
 + userPeers = userPeers , 
 + groupPeers = groupPeers 
 + ) ) 
 } 
 
 override def doHandleLoadGroupedDialogs ( 
 @ @ - 131 , 32 + 127 , 27 @ @ trait HistoryHandlers { 
 clientData : ClientData 
 ) : Future [ HandlerResult [ ResponseLoadGroupedDialogs ] ] = 
 authorized ( clientData ) { implicit client ⇒ 
 + val stripEntities = optimizations contains ApiUpdateOptimization . STRIP _ ENTITIES 
 + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) 
 + 
 for { 
 dialogGroups ← dialogExt . fetchApiGroupedDialogs ( client . userId ) 
 - ( userIds , groupIds ) = dialogGroups . view . flatMap ( _ . dialogs ) . foldLeft ( ( Seq . empty [ Int ] , Seq . empty [ Int ] ) ) { 
 - case ( ( uids , gids ) , dialog ) ⇒ 
 - dialog . peer . ` type ` match { 
 - case ApiPeerType . Group ⇒ ( uids , gids : + dialog . peer . id ) 
 - case ApiPeerType . Private ⇒ ( uids : + dialog . peer . id , gids ) 
 - } 
 - } 
 - / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers 
 - ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) 
 + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← usersAndGroupsByShortDialogs ( 
 + dialogs = dialogGroups . flatMap ( _ . dialogs ) , 
 + stripEntities , 
 + loadGroupMembers 
 + ) 
 archivedExist ← dialogExt . fetchArchivedDialogs ( client . userId , None , 1 ) map ( _ . _ 1 . nonEmpty ) 
 showInvite ← db . run ( UserContactRepo . count ( client . userId ) ) map ( _ < 5 ) 
 - } yield { 
 - val stripEntities = optimizations contains ApiUpdateOptimization . STRIP _ ENTITIES 
 - 
 - Ok ( ResponseLoadGroupedDialogs ( 
 - dialogs = dialogGroups , 
 - users = if ( stripEntities ) Vector . empty else users . toVector , 
 - groups = if ( stripEntities ) Vector . empty else groups . toVector , 
 - showArchived = Some ( archivedExist ) , 
 - showInvite = Some ( showInvite ) , 
 - userPeers = if ( stripEntities ) users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) else Vector . empty , 
 - groupPeers = if ( stripEntities ) groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) else Vector . empty 
 - ) ) 
 - } 
 + } yield Ok ( ResponseLoadGroupedDialogs ( 
 + dialogs = dialogGroups , 
 + users = users , 
 + groups = groups , 
 + showArchived = Some ( archivedExist ) , 
 + showInvite = Some ( showInvite ) , 
 + userPeers = userPeers , 
 + groupPeers = groupPeers 
 + ) ) 
 } 
 
 override def doHandleHideDialog ( peer : ApiOutPeer , clientData : ClientData ) : Future [ HandlerResult [ ResponseDialogsOrder ] ] = 
 @ @ - 197 , 6 + 188 , 9 @ @ trait HistoryHandlers { 
 authorized ( clientData ) { implicit client ⇒ 
 withOutPeer ( peer ) { 
 val modelPeer = peer . asModel 
 + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) 
 + 
 val action = for { 
 historyOwner ← DBIO . from ( getHistoryOwner ( modelPeer , client . userId ) ) 
 ( lastReceivedAt , lastReadAt ) ← getLastReceiveReadDates ( modelPeer ) 
 @ @ - 226 , 19 + 220 , 14 @ @ trait HistoryHandlers { 
 case None ⇒ ( msgs , uids , guids ) 
 } 
 } 
 - users ← DBIO . from ( Future . sequence ( userIds . toVector map ( userExt . getApiStruct ( _ , client . userId , client . authId ) ) ) ) 
 - groups ← DBIO . from ( Future . sequence ( groupIds . toVector map ( groupExt . getApiStruct ( _ , client . userId ) ) ) ) 
 - } yield { 
 - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 - 
 - Ok ( ResponseLoadHistory ( 
 - history = messages , 
 - users = if ( stripEntities ) Vector . empty else users , 
 - userPeers = users map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , 
 - groups = if ( stripEntities ) Vector . empty else groups , 
 - groupPeers = groups map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) 
 - ) ) 
 - } 
 + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← DBIO . from ( usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) ) 
 + } yield Ok ( ResponseLoadHistory ( 
 + history = messages , 
 + users = users , 
 + userPeers = userPeers , 
 + groups = groups , 
 + groupPeers = groupPeers 
 + ) ) 
 db . run ( action ) 
 } 
 } 
 @ @ - 316 , 51 + 305 , 4 @ @ trait HistoryHandlers { 
 } yield ( new DateTime ( info . lastReceivedDate . toEpochMilli ) , new DateTime ( info . lastReadDate . toEpochMilli ) ) ) 
 } 
 
 - private def getDialogsUsersGroups ( dialogs : Seq [ ApiDialog ] ) ( implicit client : AuthorizedClientData ) : Future [ ( Set [ ApiUser ] , Set [ ApiGroup ] ) ] = { 
 - val ( userIds , groupIds ) = dialogs . foldLeft ( ( Set . empty [ Int ] , Set . empty [ Int ] ) ) { 
 - case ( ( uacc , gacc ) , dialog ) ⇒ 
 - if ( dialog . peer . ` type ` = = ApiPeerType . Private ) { 
 - ( uacc + + relatedUsers ( dialog . message ) + + Set ( dialog . peer . id , dialog . senderUserId ) , gacc ) 
 - } else { 
 - ( uacc + + relatedUsers ( dialog . message ) + dialog . senderUserId , gacc + dialog . peer . id ) 
 - } 
 - } 
 - 
 - for { 
 - groups ← Future . sequence ( groupIds map ( groupExt . getApiStruct ( _ , client . userId ) ) ) 
 - groupUserIds = groups . flatMap ( g ⇒ g . members . flatMap ( m ⇒ Seq ( m . userId , m . inviterUserId ) ) : + g . creatorUserId ) 
 - users ← Future . sequence ( ( userIds + + groupUserIds ) . filterNot ( _ = = 0 ) map ( UserUtils . safeGetUser ( _ , client . userId , client . authId ) ) ) map ( _ . flatten ) 
 - } yield ( users , groups ) 
 - } 
 - 
 - private def relatedUsers ( message : ApiMessage ) : Set [ Int ] = { 
 - message match { 
 - case ApiServiceMessage ( _ , extOpt ) ⇒ extOpt map relatedUsers getOrElse Set . empty 
 - case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet 
 - case ApiJsonMessage ( _ ) ⇒ Set . empty 
 - case _ : ApiEmptyMessage ⇒ Set . empty 
 - case _ : ApiDocumentMessage ⇒ Set . empty 
 - case _ : ApiStickerMessage ⇒ Set . empty 
 - case _ : ApiUnsupportedMessage ⇒ Set . empty 
 - case _ : ApiBinaryMessage ⇒ Set . empty 
 - case _ : ApiEncryptedMessage ⇒ Set . empty 
 - } 
 - } 
 - 
 - private def relatedUsers ( ext : ApiServiceEx ) : Set [ Int ] = 
 - ext match { 
 - case ApiServiceExContactRegistered ( userId ) ⇒ Set ( userId ) 
 - case ApiServiceExChangedAvatar ( _ ) ⇒ Set . empty 
 - case ApiServiceExChangedTitle ( _ ) ⇒ Set . empty 
 - case ApiServiceExChangedTopic ( _ ) ⇒ Set . empty 
 - case ApiServiceExChangedAbout ( _ ) ⇒ Set . empty 
 - case ApiServiceExGroupCreated | _ : ApiServiceExGroupCreated ⇒ Set . empty 
 - case ApiServiceExPhoneCall ( _ ) ⇒ Set . empty 
 - case ApiServiceExPhoneMissed | _ : ApiServiceExPhoneMissed ⇒ Set . empty 
 - case ApiServiceExUserInvited ( invitedUserId ) ⇒ Set ( invitedUserId ) 
 - case ApiServiceExUserJoined | _ : ApiServiceExUserJoined ⇒ Set . empty 
 - case ApiServiceExUserKicked ( kickedUserId ) ⇒ Set ( kickedUserId ) 
 - case ApiServiceExUserLeft | _ : ApiServiceExUserLeft ⇒ Set . empty 
 - case _ : ApiServiceExChatArchived | _ : ApiServiceExChatRestored ⇒ Set . empty 
 - } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 index 16ce785 . . 9b21287 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / search / SearchServiceImpl . scala 
 @ @ - 76 , 29 + 76 , 31 @ @ class SearchServiceImpl ( implicit system : ActorSystem ) extends SearchService { 
 text : Option [ String ] , 
 optimizations : IndexedSeq [ ApiUpdateOptimization . Value ] 
 ) ( implicit client : AuthorizedClientData ) : Future [ HandlerResult [ ResponsePeerSearch ] ] = { 
 + val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + val loadGroupMembers = ! optimizations . contains ( ApiUpdateOptimization . GROUPS _ V2 ) 
 + 
 for { 
 results ← FutureExt . ftraverse ( pts ) ( search ( _ , text ) ) . map ( _ . reduce ( _ + + _ ) ) 
 - ( groupIds , userIds , searchResults ) = ( results foldLeft ( Vector . empty [ Int ] , Vector . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { 
 + ( groupIds , userIds , searchResults ) = ( results foldLeft ( Set . empty [ Int ] , Set . empty [ Int ] , Vector . empty [ ApiPeerSearchResult ] ) ) { 
 case ( acc @ ( gids , uids , rslts ) , found @ ApiPeerSearchResult ( peer , _ ) ) ⇒ 
 if ( rslts . exists ( _ . peer = = peer ) ) { 
 acc 
 } else { 
 peer . ` type ` match { 
 - case ApiPeerType . Private ⇒ ( gids , uids : + peer . id , rslts : + found ) 
 - case ApiPeerType . Group ⇒ ( gids : + peer . id , uids , rslts : + found ) 
 + case ApiPeerType . Private ⇒ ( gids , uids + peer . id , rslts : + found ) 
 + case ApiPeerType . Group ⇒ ( gids + peer . id , uids , rslts : + found ) 
 } 
 } 
 } 
 - / / TODO : make like here : im . actor . server . api . rpc . service . groups . GroupsServiceImpl . usersOrPeers 
 - ( groups , users ) ← GroupUtils . getGroupsUsers ( groupIds , userIds , client . userId , client . authId ) 
 + ( ( users , userPeers ) , ( groups , groupPeers ) ) ← EntitiesHelpers . usersAndGroupsByIds ( groupIds , userIds , stripEntities , loadGroupMembers ) 
 } yield { 
 - val stripEntities = optimizations . contains ( ApiUpdateOptimization . STRIP _ ENTITIES ) 
 + 
 Ok ( ResponsePeerSearch ( 
 searchResults = searchResults , 
 - users = if ( stripEntities ) Vector . empty else users . toVector , 
 - groups = if ( stripEntities ) Vector . empty else groups . toVector , 
 - userPeers = users . toVector map ( u ⇒ ApiUserOutPeer ( u . id , u . accessHash ) ) , 
 - groupPeers = groups . toVector map ( g ⇒ ApiGroupOutPeer ( g . id , g . accessHash ) ) 
 + users = users , 
 + groups = groups , 
 + userPeers = userPeers , 
 + groupPeers = groupPeers 
 ) ) 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 index 641806f . . 71c4080 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / ActorDelivery . scala 
 @ @ - 43 , 7 + 43 , 7 @ @ final class ActorDelivery ( ) ( implicit val system : ActorSystem ) 
 ) 
 
 for { 
 - senderName ← userExt . getName ( receiverUserId , senderUserId ) 
 + senderName ← userExt . getName ( senderUserId , receiverUserId ) 
 pushText ← getPushText ( peer , receiverUserId , senderName , message ) 
 _ ← seqUpdatesExt . deliverSingleUpdate ( 
 receiverUserId , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 index 4181a2e . . 3230c26 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / Dialog . scala 
 @ @ - 16 , 6 + 16 , 7 @ @ import im . actor . server . sequence . SeqStateDate 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 import im . actor . util . cache . CacheHelpers . _ 
 + import org . joda . time . DateTime 
 import slick . dbio . DBIO 
 
 import slick . driver . PostgresDriver . api . Database 
 @ @ - 170 , 7 + 171 , 7 @ @ private [ dialog ] final class Dialog ( val userId : Int , val peer : Peer , extensions : 
 dialog ← optDialog match { 
 case Some ( dialog ) ⇒ DBIO . successful ( dialog ) 
 case None ⇒ 
 - val dialog = DialogModel ( userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 for { 
 _ ← DialogRepo . create ( dialog ) 
 _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b45cc33 . . d2c2ddb 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 35 , 7 + 35 , 10 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 throw e 
 } ) pipeTo sender ( ) 
 sendFuture onSuccess { 
 - case SeqStateDate ( _ , _ , date ) ⇒ self ! LastOwnMessageDate ( date ) 
 + case SeqStateDate ( _ , _ , date ) ⇒ 
 + self ! LastOwnMessageDate ( date ) 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 } 
 } 
 
 @ @ - 45 , 10 + 48 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 deliveryExt 
 . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) 
 - 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 
 / / onSuccess ( fu ) { _ = > 
 / / updatePeerMessageDate ( ) 
 @ @ - 160 , 6 + 164 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 if ( state . isHidden ) 
 sender ! Status . Failure ( DialogErrors . DialogAlreadyHidden ( peer ) ) 
 else { 
 + 
 val future = 
 ( for { 
 _ ← db . run ( DialogRepo . hide ( userId , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index 55230de . . 01a8d62 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 24 , 6 + 24 , 25 @ @ import slick . dbio . DBIO 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 
 + sealed trait DialogGroup { 
 + def key : String 
 + def title : String 
 + } 
 + 
 + object DialogGroups { 
 + object Privates extends DialogGroup { 
 + override def key : String = " privates " 
 + 
 + override def title : String = " Private " 
 + } 
 + 
 + object Groups extends DialogGroup { 
 + override def key : String = " groups " 
 + 
 + override def title : String = " Groups " 
 + } 
 + } 
 + 
 sealed trait DialogExtension extends Extension 
 
 final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension with PeersImplicits { 
 @ @ - 41 , 16 + 60 , 16 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 
 private val log = Logging ( system , getClass ) 
 
 - private def withValidPeer [ A ] ( peer : ApiPeer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 + private def withValidPeer [ A ] ( peer : Peer , senderUserId : Int , failed : ⇒ A ) ( f : ⇒ A ) : A = 
 peer match { 
 - case ApiPeer ( ApiPeerType . Private , id ) if id = = senderUserId ⇒ 
 + case Peer ( PeerType . Private , id ) if id = = senderUserId ⇒ 
 log . error ( s " Attempt to work with yourself , userId : $ senderUserId " ) 
 failed 
 case _ ⇒ f 
 } 
 
 def sendMessage ( peer : ApiPeer , senderUserId : Int , senderAuthSid : Int , randomId : Long , message : ApiMessage , isFat : Boolean = false ) : Future [ SeqStateDate ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( SeqStateDate ( ) ) ) { 
 val date = Instant . now ( ) . toEpochMilli 
 val sender = Peer . privat ( senderUserId ) 
 val sendMessage = SendMessage ( sender , peer . asModel , senderAuthSid , date , randomId , message , isFat ) 
 @ @ - 67 , 14 + 86 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 randomId : Long , 
 message : ApiMessage 
 ) : Future [ Unit ] = 
 - withValidPeer ( peer , senderUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , senderUserId , Future . successful ( ( ) ) ) { 
 val sender = Peer . privat ( senderUserId ) 
 val writeMessage = WriteMessage ( sender , peer . asModel , date . getMillis , randomId , message ) 
 ( userExt . processorRegion . ref ? Envelope ( sender ) . withWriteMessage ( writeMessage ) ) . mapTo [ WriteMessageAck ] map ( _ ⇒ ( ) ) 
 } 
 
 def messageReceived ( peer : ApiPeer , receiverUserId : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , receiverUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , receiverUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val receiver = Peer . privat ( receiverUserId ) 
 val messageReceived = MessageReceived ( receiver , peer . asModel , date , now ) 
 @ @ - 85 , 7 + 104 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageReceived ( mr ) ) . mapTo [ MessageReceivedAck ] map ( _ ⇒ ( ) ) 
 
 def messageRead ( peer : ApiPeer , readerUserId : Int , readerAuthSid : Int , date : Long ) : Future [ Unit ] = 
 - withValidPeer ( peer , readerUserId , Future . successful ( ( ) ) ) { 
 + withValidPeer ( peer . asModel , readerUserId , Future . successful ( ( ) ) ) { 
 val now = Instant . now ( ) . toEpochMilli 
 val reader = Peer . privat ( readerUserId ) 
 val messageRead = MessageRead ( reader , peer . asModel , readerAuthSid , date , now ) 
 @ @ - 96 , 10 + 115 , 14 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 ( processorRegion ( peer ) ? Envelope ( peer ) . withMessageRead ( mr ) ) . mapTo [ MessageReadAck ] map ( _ ⇒ ( ) ) 
 
 def show ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withShow ( Show ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def hide ( userId : Int , peer : Peer ) : Future [ SeqState ] = 
 - ( userExt . processorRegion . ref ? Envelope ( peer ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + withValidPeer ( peer , userId , Future . failed [ SeqState ] ( DialogErrors . MessageToSelf ) ) { 
 + ( userExt . processorRegion . ref ? Envelope ( Peer . privat ( userId ) ) . withHide ( Hide ( peer ) ) ) . mapTo [ SeqState ] 
 + } 
 
 def getDeliveryExtension ( extensions : Seq [ ApiExtension ] ) : DeliveryExtension = { 
 extensions match { 
 @ @ - 135 , 7 + 158 , 7 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 def isSharedUser ( userId : Int ) : Boolean = userId = = 0 
 
 def getGroupedDialogs ( userId : Int ) = { 
 - db . run ( DialogRepo . findNotArchivedSortByCreatedAt ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 + db . run ( DialogRepo . findNotArchivedSortByLastMessageData ( userId , None , Int . MaxValue ) flatMap { dialogModels ⇒ 
 val ( groupModels , privateModels ) = dialogModels . foldLeft ( ( Vector . empty [ DialogModel ] , Vector . empty [ DialogModel ] ) ) { 
 case ( ( groupModels , privateModels ) , dialog ) ⇒ 
 if ( dialog . peer . typ = = PeerType . Group ) 
 @ @ - 148 , 8 + 171 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 groupDialogs ← DBIO . sequence ( groupModels map getDialogShort ) 
 privateDialogs ← DBIO . sequence ( privateModels map getDialogShort ) 
 } yield Vector ( 
 - ApiDialogGroup ( " Groups " , " groups " , groupDialogs ) , 
 - ApiDialogGroup ( " Private " , " privates " , privateDialogs . toVector ) 
 + ApiDialogGroup ( DialogGroups . Groups . title , DialogGroups . Groups . key , groupDialogs ) , 
 + ApiDialogGroup ( DialogGroups . Privates . title , DialogGroups . Privates . key , privateDialogs . toVector ) 
 ) 
 } ) 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index 4219e8c . . d3a6b75 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 54 , 7 + 54 , 7 @ @ object HistoryUtils { 
 for { 
 _ ← persist . HistoryMessageRepo . create ( messages ) 
 _ ← persist . DialogRepo . updateLastMessageDate ( fromPeer . id , toPeer , date ) 
 - res ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 + _ ← persist . DialogRepo . updateLastMessageDate ( toPeer . id , fromPeer , date ) 
 } yield ( ) 
 } else if ( toPeer . typ = = PeerType . Group ) { 
 DBIO . from ( GroupExtension ( system ) . isHistoryShared ( toPeer . id ) ) flatMap { isHistoryShared ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 index 9475e63 . . 912092d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / ApplePushProvider . scala 
 @ @ - 15 , 27 + 15 , 19 @ @ private [ sequence ] final class ApplePushProvider ( userId : Int , applePushManager : A 
 private val db = DbExtension ( system ) . db 
 
 def deliverInvisible ( seq : Int , creds : ApplePushCredentials ) : Unit = { 
 - < < < < < < < Updated upstream 
 - applePushManager . getInstance ( creds . apnsKey ) match { 
 - case Some ( mgr ) ⇒ 
 - db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 - val builder = 
 - new ApnsPayloadBuilder ( ) 
 - . addCustomProperty ( " seq " , seq ) 
 - . setContentAvailable ( true ) 
 - = = = = = = = 
 withMgr ( creds . apnsKey ) { mgr ⇒ 
 log . debug ( " Delivering invisible ( seq : { } ) to apnsKey : { } " , seq , creds . apnsKey ) 
 - > > > > > > > Stashed changes 
 - 
 + db . run ( HistoryMessageRepo . getUnreadTotal ( userId ) ) foreach { unreadTotal ⇒ 
 + val builder = 
 + new ApnsPayloadBuilder ( ) 
 + . addCustomProperty ( " seq " , seq ) 
 + . setContentAvailable ( true ) 
 builder . setBadgeNumber ( unreadTotal ) 
 
 val payload = builder . buildWithDefaultMaximumLength ( ) 
 
 mgr . getQueue . add ( new SimpleApnsPushNotification ( creds . token . toByteArray , payload ) ) 
 } 
 - case None ⇒ 
 - log . warning ( " No apple push configured for apns - key : { } " , creds . apnsKey ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 index 191aa44 . . a59b5b2 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserUtils . scala 
 @ @ - 40 , 13 + 40 , 13 @ @ object UserUtils { 
 def userPhone ( u : model . User , phones : Seq [ UserPhone ] ) : Option [ Long ] = { 
 phones . headOption match { 
 case Some ( phone ) ⇒ Some ( phone . number ) 
 - case None ⇒ Some ( 0L ) 
 + case None ⇒ Some ( 0L ) 
 } 
 } 
 
 def normalizeLocalName ( name : Option [ String ] ) = name match { 
 - case n @ Some ( name ) if name . nonEmpty ⇒ n 
 - case _ ⇒ None 
 + case n @ Some ( name ) if name . nonEmpty ⇒ n 
 + case _ ⇒ None 
 } 
 
 def safeGetUser ( userId : Int , clientUserId : Int , clientAuthId : Long ) ( implicit system : ActorSystem ) = { 
 diff - - git a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 index 9bf22b0 . . d215e44 100644 
 - - - a / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 + + + b / actor - server / actor - http - api / src / main / scala / im / actor / server / api / http / bots / BotsHandler . scala 
 @ @ - 3 , 9 + 3 , 9 @ @ package im . actor . server . api . http . bots 
 import java . util . Base64 
 
 import akka . actor . ActorSystem 
 - import akka . http . scaladsl . model . StatusCode 
 import akka . http . scaladsl . model . StatusCodes . _ 
 import akka . http . scaladsl . model . ws . { Message , TextMessage } 
 + import akka . http . scaladsl . model . { HttpMethod , StatusCode } 
 import akka . http . scaladsl . server . Directives . _ 
 import akka . http . scaladsl . server . Route 
 import akka . stream . Materializer 
 @ @ - 14 , 20 + 14 , 16 @ @ import akka . util . ByteString 
 import cats . data . OptionT 
 import cats . std . future . _ 
 import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 - import im . actor . api . rpc . messaging . ApiJsonMessage 
 - import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 import im . actor . api . rpc . sequence . UpdateRawUpdate 
 import im . actor . server . api . http . RoutesHandler 
 import im . actor . server . api . http . json . { ContentUnmarshaller , JsValueUnmarshaller , JsonFormatters , Status } 
 import im . actor . server . bot . { BotExtension , BotServerBlueprint } 
 - import im . actor . server . dialog . DialogExtension 
 import im . actor . server . model . AuthSession 
 import im . actor . server . user . UserExtension 
 import play . api . libs . json . _ 
 import upickle . default . _ 
 
 import scala . concurrent . Future 
 - import scala . concurrent . forkjoin . ThreadLocalRandom 
 import scala . util . control . NoStackTrace 
 import scala . util . { Failure , Success } 
 
 @ @ - 42 , 25 + 38 , 42 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 
 override def routes : Route = 
 path ( " bots " / " hooks " / Segment ) { token ⇒ 
 - post { 
 - extractRequest { request ⇒ 
 - val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 + extractRequest { request ⇒ 
 + val method = request . method 
 + val queryString = request . uri . queryString ( ) 
 + val headers = request . headers . map ( header ⇒ header . name ( ) → header . value ( ) ) 
 
 - val sendMessageF = for { 
 - data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 - res ← sendMessage ( headers , data , token ) 
 - } yield res 
 + val sendMessageF = for { 
 + data ← request . entity . dataBytes . runFold ( ByteString . empty ) ( _ + + _ ) 
 + res ← sendMessage ( method , queryString , headers , data , token ) 
 + } yield res 
 
 - onComplete ( sendMessageF ) { 
 - case Success ( result ) ⇒ 
 - result match { 
 - case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 - case Right ( _ ) ⇒ complete ( OK → Status ( " ok " ) ) 
 - } 
 - case Failure ( e ) ⇒ 
 - log . error ( e , " Failed to handle bot hook " ) 
 - complete ( InternalServerError ) 
 - } 
 + onComplete ( sendMessageF ) { 
 + case Success ( result ) ⇒ 
 + result match { 
 + case Left ( statusCode ) ⇒ complete ( statusCode → Status ( " failure " ) ) 
 + case Right ( _ ) ⇒ 
 + val response = 
 + " " " 
 + | < html > 
 + | < head > 
 + | < title > Please , return to the app < / title > 
 + | < style > 
 + | . element { 
 + | position : relative ; 
 + | top : 50 % ; 
 + | transform : translateY ( - 50 % ) ; 
 + | } 
 + | < / style > 
 + | < / head > 
 + | < body > < center id = " message " > < h3 > Please , return to the app . < / h1 > < / center > < / body > 
 + | < / html > 
 + " " " . stripMargin 
 + complete ( OK → Status ( response ) ) 
 + } 
 + case Failure ( e ) ⇒ 
 + log . error ( e , " Failed to handle bot hook " ) 
 + complete ( InternalServerError ) 
 } 
 } 
 } ~ path ( " bots " / Segment ) { token ⇒ 
 @ @ - 84 , 7 + 97 , 7 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 } 
 } 
 
 - private def sendMessage ( headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 + private def sendMessage ( method : HttpMethod , queryString : Option [ String ] , headers : Seq [ ( String , String ) ] , data : ByteString , token : String ) : Future [ Either [ StatusCode , Unit ] ] = { 
 ( for { 
 hook ← OptionT ( botExt . findWebHook ( token ) ) 
 _ ← OptionT . pure ( userExt . broadcastUserUpdate ( 
 @ @ - 95 , 6 + 108 , 8 @ @ private [ http ] final class BotsHandler ( implicit system : ActorSystem , val material 
 " dataType " → JsString ( " HookData " ) , 
 " data " → JsObject ( Map ( 
 " name " → JsString ( hook . name ) , 
 + " method " → JsString ( method . name ) , 
 + " queryString " → ( queryString map JsString getOrElse JsNull ) , 
 " headers " → JsObject ( headers map { case ( name , value ) ⇒ name → JsString ( value ) } ) , 
 " body " → JsString ( Base64 . getEncoder . encodeToString ( data . toArray ) ) 
 ) ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 index f7b0742 . . f9c82b0 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / DialogRepo . scala 
 @ @ - 148 , 8 + 148 , 8 @ @ object DialogRepo { 
 def findLastReadBefore ( date : DateTime , userId : Int ) = 
 dialogs . filter ( d ⇒ d . userId = = = userId & & d . ownerLastReadAt < date ) . result 
 
 - def findNotArchivedSortByCreatedAt ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 - findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . createdAt . asc , fetchHidden ) 
 + def findNotArchivedSortByLastMessageData ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 + findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 
 def findNotArchived ( userId : Int , dateOpt : Option [ DateTime ] , limit : Int , fetchHidden : Boolean = false ) ( implicit ec : ExecutionContext ) : DBIO [ Seq [ Dialog ] ] = 
 findNotArchived ( userId , dateOpt : Option [ DateTime ] , limit , _ . lastMessageDate . desc , fetchHidden ) 
 diff - - git a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 index 14c35dd . . 66d4ebf 100644 
 - - - a / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 + + + b / actor - server / actor - runtime / src / main / scala / im / actor / config / ActorConfig . scala 
 @ @ - 42 , 6 + 42 , 8 @ @ object ActorConfig { 
 | " com . trueaccord . scalapb . GeneratedMessage " = actor 
 | } 
 | } 
 + | 
 + | cluster . sharding . state - store - mode = " ddata " 
 | } 
 " " " . stripMargin 
 ) ) 
 diff - - git a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 index 3d25a02 . . 72dc6c1 100644 
 - - - a / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 + + + b / actor - server / actor - testkit / src / main / scala / im / actor / server / MessagingSpecHelpers . scala 
 @ @ - 1 , 27 + 1 , 52 @ @ 
 package im . actor . server 
 
 import akka . actor . ActorSystem 
 - import akka . util . Timeout 
 import im . actor . api . rpc . ClientData 
 - import im . actor . api . rpc . messaging . { ApiMessage , ApiTextMessage , MessagingService } 
 + import im . actor . api . rpc . messaging . { ApiDialogGroup , ApiDialogShort , ApiMessage , ApiTextMessage , _ } 
 import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType } 
 + import im . actor . api . rpc . users . ApiUser 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . dialog . DialogGroup 
 + import org . scalatest . concurrent . ScalaFutures 
 
 - import scala . concurrent . Await 
 + import scala . language . postfixOps 
 import scala . util . Random 
 
 - trait MessagingSpecHelpers { 
 - val timeout : Timeout 
 + trait MessagingSpecHelpers extends ScalaFutures { 
 + implicit val system : ActorSystem 
 
 def sendMessageToUser ( userId : Int , message : ApiMessage ) ( 
 implicit 
 clientData : ClientData , 
 - msgService : MessagingService , 
 - system : ActorSystem 
 + msgService : MessagingService 
 ) : Unit = { 
 - val peer = Await . result ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) , timeout . duration ) 
 - Await . result ( msgService . handleSendMessage ( peer , Random . nextLong , message ) , timeout . duration ) 
 + whenReady ( ACLUtils . getOutPeer ( ApiPeer ( ApiPeerType . Private , userId ) , clientData . authId ) ) { peer ⇒ 
 + whenReady ( msgService . handleSendMessage ( peer , Random . nextLong , message ) ) ( identity ) 
 + } 
 } 
 
 def textMessage ( text : String ) = ApiTextMessage ( text , Vector . empty , None ) 
 + 
 + def getDialogGroups ( ) ( implicit clientData : ClientData , service : MessagingService ) : Map [ String , IndexedSeq [ ApiDialogShort ] ] = { 
 + whenReady ( service . handleLoadGroupedDialogs ( ) ) { resp ⇒ 
 + resp . toOption . get . dialogs map { 
 + case ApiDialogGroup ( _ , key , dialogs ) ⇒ key → dialogs 
 + } toMap 
 + } 
 + } 
 + 
 + def getDialogGroups ( group : DialogGroup ) ( implicit clientData : ClientData , service : MessagingService ) : IndexedSeq [ ApiDialogShort ] = { 
 + val dgs = getDialogGroups ( ) 
 + dgs get group . key match { 
 + case Some ( ds ) ⇒ ds 
 + case None ⇒ throw new RuntimeException ( s " Group $ group not found in $ dgs " ) 
 + } 
 + } 
 + 
 + def prepareDialogs ( users : ApiUser * ) ( implicit clientData : ClientData , service : MessagingService ) : Unit = { 
 + users foreach { user ⇒ 
 + sendMessageToUser ( user . id , textMessage ( s " Hi , I am $ { user . name } ! " ) ) 
 + Thread . sleep ( 1 ) 
 + } 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 index 85ba87d . . fe02129 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / GroupedDialogsSpec . scala 
 @ @ - 6 , 8 + 6 , 8 @ @ import im . actor . api . rpc . peers . { ApiPeer , ApiPeerType , ApiOutPeer } 
 import im . actor . server . acl . ACLUtils 
 import im . actor . server . api . rpc . service . groups . { GroupInviteConfig , GroupsServiceImpl } 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 - import im . actor . server . { GroupsServiceHelpers , ImplicitSessionRegion , ImplicitAuthService , BaseAppSuite } 
 - import org . scalatest . Inside . _ 
 + import im . actor . server . _ 
 + import im . actor . server . dialog . DialogGroups 
 
 import scala . concurrent . { Await , Future } 
 import scala . concurrent . duration . _ 
 @ @ - 17 , 11 + 17 , 20 @ @ final class GroupedDialogsSpec 
 extends BaseAppSuite 
 with ImplicitAuthService 
 with ImplicitSessionRegion 
 - with GroupsServiceHelpers { 
 + with GroupsServiceHelpers 
 + with MessagingSpecHelpers { 
 " LoadGroupedDialogs " should " load groups and privates " in loadGrouped 
 
 - private implicit val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 - private val service = MessagingServiceImpl ( ) 
 + " Dialogs " should " appear in top on new incoming message " in incomingGoTop 
 + it should " appear in top on new outgoing message " in outgoingGoTop 
 + 
 + " Hidden dialogs " should " appear on new message " in appearHidden 
 + it should " appear on show " in appearShown 
 + 
 + import DialogGroups . _ 
 + 
 + private implicit lazy val groupsService = new GroupsServiceImpl ( GroupInviteConfig ( " " ) ) 
 + private implicit lazy val service = MessagingServiceImpl ( ) 
 
 def loadGrouped ( ) = { 
 val ( user1 , authId1 , authSid1 , _ ) = createUser ( ) 
 @ @ - 68 , 4 + 77 , 110 @ @ final class GroupedDialogsSpec 
 } 
 } 
 } 
 + 
 + def incomingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , bobAuthId , bobAuthSid , _ ) = createUser ( ) 
 + val ( eve , eveAuthId , eveAuthSid , _ ) = createUser ( ) 
 + 
 + val aliceClient = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobClient = ClientData ( bobAuthId , 1 , Some ( AuthData ( bob . id , bobAuthSid ) ) ) 
 + val eveClient = ClientData ( eveAuthId , 1 , Some ( AuthData ( eve . id , eveAuthSid ) ) ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Eve " , Vector . empty , None ) ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = bobClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , I am Bob " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val dgs = getDialogGroups ( ) 
 + val privates = dgs ( Privates . key ) 
 + privates . size should equal ( 2 ) 
 + privates . head . peer . id should equal ( bob . id ) 
 + privates . last . peer . id should equal ( eve . id ) 
 + } 
 + 
 + Thread . sleep ( 1 ) 
 + 
 + { 
 + implicit val clientData = eveClient 
 + sendMessageToUser ( alice . id , ApiTextMessage ( " Hi , It ' s Eve again ! " , Vector . empty , None ) ) 
 + } 
 + 
 + { 
 + implicit val clientData = aliceClient 
 + val privates = getDialogGroups ( Privates ) 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + } 
 + 
 + def outgoingGoTop ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + val ( eve , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + 
 + prepareDialogs ( bob , eve ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( eve . id ) 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Go to top ! " ) ) 
 + 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case privates ⇒ 
 + privates . head . peer . id should equal ( bob . id ) 
 + } 
 + } 
 + 
 + def appearHidden ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 + 
 + def appearShown ( ) = { 
 + val ( alice , aliceAuthId , aliceAuthSid , _ ) = createUser ( ) 
 + val ( bob , _ , _ , _ ) = createUser ( ) 
 + 
 + implicit val clientData = ClientData ( aliceAuthId , 1 , Some ( AuthData ( alice . id , aliceAuthSid ) ) ) 
 + val bobPeer = getOutPeer ( bob . id , aliceAuthId ) 
 + sendMessageToUser ( bob . id , textMessage ( " Hi Bob ! " ) ) 
 + 
 + prepareDialogs ( bob ) 
 + whenReady ( service . handleHideDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( ) ⇒ 
 + } 
 + 
 + whenReady ( service . handleShowDialog ( bobPeer ) ) ( identity ) 
 + inside ( getDialogGroups ( Privates ) ) { 
 + case Vector ( _ ) ⇒ 
 + } 
 + } 
 } 
 \ No newline at end of file
