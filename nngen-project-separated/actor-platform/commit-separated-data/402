BLEU SCORE: 0.1933662852715576

TEST MSG: perf ( server : messaging ) : faster DialogRootState
GENERATED MSG: fix ( server : messaging ) : create dialog on WriteMessageSelf , DM and Group dialog groups by default

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 46ecda6 . . 1f43c7c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 136 , 7 + 136 , 10 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > val events = if ( isCreated ) { < nl > ( if ( ! isShown ) List ( Unarchived ( now , peerOpt ) ) else List . empty ) + + < nl > ( if ( ! isDialogOnTop ( peer ) ) List ( Bumped ( now , peerOpt ) ) else List . empty ) < nl > - } else List ( Created ( now , peerOpt ) ) < nl > + } else { < nl > + log . debug ( " Creating dialog with peer type : { } id : { } " , peerOpt . get . ` type ` , peerOpt . get . id ) < nl > + List ( Created ( now , peerOpt ) ) < nl > + } < nl > < nl > persistAll ( events ) ( e ⇒ commit ( e ) ) < nl > < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > index ee424bc . . 0c6fec5 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 108 , 15 + 108 , 17 @ @ private object DialogRootState { < nl > userId = userId , < nl > active = ActiveDialogs . empty , < nl > mobile = SortedSet . empty ( SortableDialog . OrderingDesc ) , < nl > + mobilePeers = Set . empty [ Peer ] , < nl > archived = SortedSet . empty ( SortableDialog . OrderingDesc ) < nl > ) < nl > } < nl > < nl > private [ dialog ] final case class DialogRootState ( < nl > - userId : Int , < nl > - active : ActiveDialogs , < nl > - mobile : SortedSet [ SortableDialog ] , < nl > - archived : SortedSet [ SortableDialog ] < nl > + userId : Int , < nl > + active : ActiveDialogs , < nl > + mobile : SortedSet [ SortableDialog ] , < nl > + mobilePeers : Set [ Peer ] , < nl > + archived : SortedSet [ SortableDialog ] < nl > ) extends ProcessorState [ DialogRootState ] { < nl > import DialogRootEvents . _ < nl > < nl > @ @ - 140 , 7 + 142 , 8 @ @ private [ dialog ] final case class DialogRootState ( < nl > ) ( SortableDialog . OrderingAsc ) , < nl > mobile = SortedSet ( < nl > ( _ mobile map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > - ) ( SortableDialog . OrderingDesc ) < nl > + ) ( SortableDialog . OrderingDesc ) , < nl > + mobilePeers = _ mobile . map ( _ . getPeer ) . toSet < nl > ) < nl > < nl > dialogGroups . foldLeft ( state ) { < nl > @ @ - 174 , 8 + 177 , 8 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withBumpedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - if ( mobile . exists ( _ . ts = = ts ) ) withBumpedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else if ( mobile . exists ( _ . peer = = peer ) ) < nl > + if ( mobile . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withBumpedPeer ( mobile . head . ts . plusMillis ( 1 ) , peer ) < nl > + else if ( mobilePeers . contains ( peer ) ) < nl > copy ( < nl > mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) < nl > ) < nl > @ @ - 184 , 14 + 187 , 15 @ @ private [ dialog ] final case class DialogRootState ( < nl > < nl > private def withNewPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > if ( peer . typ . isPrivate & & peer . id = = userId ) this < nl > - else if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + else if ( this . mobile . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withNewPeer ( mobile . head . ts . plusMillis ( 1 ) , peer ) < nl > else { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > < nl > copy ( < nl > active = this . active . withPeer ( peer ) , < nl > archived = this . archived . filterNot ( _ . peer = = peer ) , < nl > - mobile = this . mobile + sortableDialog < nl > + mobile = this . mobile + sortableDialog , < nl > + mobilePeers = this . mobilePeers + peer < nl > ) < nl > } < nl > } < nl > @ @ - 199 , 8 + 203 , 6 @ @ private [ dialog ] final case class DialogRootState ( < nl > private def withUnarchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > if ( ! this . archived . exists ( _ . peer = = peer ) ) this < nl > else { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > copy ( < nl > active = this . active . withPeer ( peer ) , < nl > archived = this . archived . filterNot ( _ . peer = = peer ) < nl > @ @ - 209 , 8 + 211 , 8 @ @ private [ dialog ] final case class DialogRootState ( < nl > } < nl > < nl > private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - if ( peer . typ . isPrivate & & peer . id = = userId ) this < nl > - else if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + if ( ( peer . typ . isPrivate & & peer . id = = userId ) | | archived . exists ( _ . peer = = peer ) ) this < nl > + else if ( archived . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withArchivedPeer ( archived . head . ts . plusMillis ( 1 ) , peer ) < nl > else { < nl > val sortableDialog = SortableDialog ( ts , peer ) < nl > copy ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > index e3dfb93 . . b74fdcc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala < nl > @ @ - 61 , 7 + 61 , 7 @ @ object HistoryUtils { < nl > val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) < nl > } else { < nl > - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds = > < nl > + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ < nl > val historyMessages = groupUserIds . map { groupUserId ⇒ < nl > HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index 652fad2 . . cf67226 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } < nl > import akka . util . Timeout < nl > import im . actor . concurrent . _ < nl > import im . actor . server . cqrs . _ < nl > - import im . actor . server . dialog . DialogCommands . SendMessage < nl > + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } < nl > import im . actor . server . model . { Peer , PeerType } < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . messaging . UpdateChatGroupsChanged < nl > @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > < nl > override def persistenceId : String = s " DialogRoot _ $ userId " < nl > < nl > - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) < nl > + override protected def getInitialState : DialogRootState = DialogRootState ( < nl > + Map ( < nl > + DialogGroupType . DirectMessages → Set . empty , < nl > + DialogGroupType . Groups → Set . empty < nl > + ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) , < nl > + SortedSet . empty ( SortableDialog . ordering ) < nl > + ) < nl > < nl > override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { < nl > case GetCounter ( ) ⇒ getCounter ( ) < nl > @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > override protected def handleCommand : Receive = { < nl > - case sm : SendMessage ⇒ < nl > - needShowDialog ( sm ) match { < nl > + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ < nl > + needShowDialog ( dc ) match { < nl > case Some ( peer ) ⇒ < nl > val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) < nl > < nl > persist ( e ) { _ ⇒ < nl > commit ( e ) < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > sendChatGroupsChanged ( ) < nl > } < nl > case None ⇒ < nl > - handleDialogCommand ( sm ) < nl > + handleDialogCommand ( dc ) < nl > } < nl > case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) < nl > case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) < nl > @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > < nl > private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = archive $ { state . activePeers } " ) < nl > - < nl > if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) < nl > else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - println ( s " = = = archive result $ { state . activePeers } " ) < nl > - < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > < nl > private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { < nl > - println ( s " = = = unarchive $ { state . activePeers } " ) < nl > - < nl > if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) < nl > else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ < nl > commit ( e ) < nl > - < nl > - println ( s " = = = unarchive result $ { state . activePeers } " ) < nl > sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) < nl > } < nl > } < nl > @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro < nl > } < nl > } < nl > < nl > - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { < nl > - val checkPeer = < nl > - sm . getOrigin . typ match { < nl > - case PeerType . Group ⇒ sm . getDest < nl > - case PeerType . Private ⇒ < nl > - if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > - else sm . getDest < nl > - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > - } < nl > + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { < nl > + val checkPeerOpt = cmd match { < nl > + case sm : SendMessage ⇒ < nl > + Some ( sm . getOrigin . typ match { < nl > + case PeerType . Group ⇒ sm . getDest < nl > + case PeerType . Private ⇒ < nl > + if ( selfPeer = = sm . getDest ) sm . getOrigin < nl > + else sm . getDest < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } ) < nl > + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) < nl > + case _ ⇒ None < nl > + } < nl > < nl > - if ( dialogShown ( checkPeer ) ) None < nl > - else Some ( checkPeer ) < nl > + checkPeerOpt flatMap { checkPeer ⇒ < nl > + if ( dialogShown ( checkPeer ) ) None < nl > + else Some ( checkPeer ) < nl > + } < nl > } < nl > < nl > private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > index 17e13c3 . . 7d8f59b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala < nl > @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { < nl > final case class BotCommandAlreadyExists ( slashCommand : String ) < nl > extends UserError ( s " Bot command already exists : $ slashCommand " ) < nl > < nl > - final case object ContactNotFound extends UserError ( " Contact not found " ) < nl > + case object ContactNotFound extends UserError ( " Contact not found " ) < nl > < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 46ecda6 . . 1f43c7c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 136 , 7 + 136 , 10 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 val events = if ( isCreated ) { 
 ( if ( ! isShown ) List ( Unarchived ( now , peerOpt ) ) else List . empty ) + + 
 ( if ( ! isDialogOnTop ( peer ) ) List ( Bumped ( now , peerOpt ) ) else List . empty ) 
 - } else List ( Created ( now , peerOpt ) ) 
 + } else { 
 + log . debug ( " Creating dialog with peer type : { } id : { } " , peerOpt . get . ` type ` , peerOpt . get . id ) 
 + List ( Created ( now , peerOpt ) ) 
 + } 
 
 persistAll ( events ) ( e ⇒ commit ( e ) ) 
 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 index ee424bc . . 0c6fec5 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 108 , 15 + 108 , 17 @ @ private object DialogRootState { 
 userId = userId , 
 active = ActiveDialogs . empty , 
 mobile = SortedSet . empty ( SortableDialog . OrderingDesc ) , 
 + mobilePeers = Set . empty [ Peer ] , 
 archived = SortedSet . empty ( SortableDialog . OrderingDesc ) 
 ) 
 } 
 
 private [ dialog ] final case class DialogRootState ( 
 - userId : Int , 
 - active : ActiveDialogs , 
 - mobile : SortedSet [ SortableDialog ] , 
 - archived : SortedSet [ SortableDialog ] 
 + userId : Int , 
 + active : ActiveDialogs , 
 + mobile : SortedSet [ SortableDialog ] , 
 + mobilePeers : Set [ Peer ] , 
 + archived : SortedSet [ SortableDialog ] 
 ) extends ProcessorState [ DialogRootState ] { 
 import DialogRootEvents . _ 
 
 @ @ - 140 , 7 + 142 , 8 @ @ private [ dialog ] final case class DialogRootState ( 
 ) ( SortableDialog . OrderingAsc ) , 
 mobile = SortedSet ( 
 ( _ mobile map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 - ) ( SortableDialog . OrderingDesc ) 
 + ) ( SortableDialog . OrderingDesc ) , 
 + mobilePeers = _ mobile . map ( _ . getPeer ) . toSet 
 ) 
 
 dialogGroups . foldLeft ( state ) { 
 @ @ - 174 , 8 + 177 , 8 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withBumpedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - if ( mobile . exists ( _ . ts = = ts ) ) withBumpedPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else if ( mobile . exists ( _ . peer = = peer ) ) 
 + if ( mobile . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withBumpedPeer ( mobile . head . ts . plusMillis ( 1 ) , peer ) 
 + else if ( mobilePeers . contains ( peer ) ) 
 copy ( 
 mobile = mobile . filterNot ( _ . peer = = peer ) + SortableDialog ( ts , peer ) 
 ) 
 @ @ - 184 , 14 + 187 , 15 @ @ private [ dialog ] final case class DialogRootState ( 
 
 private def withNewPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 if ( peer . typ . isPrivate & & peer . id = = userId ) this 
 - else if ( this . mobile . exists ( _ . ts = = ts ) ) withNewPeer ( ts . plusMillis ( 1 ) , peer ) 
 + else if ( this . mobile . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withNewPeer ( mobile . head . ts . plusMillis ( 1 ) , peer ) 
 else { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 
 copy ( 
 active = this . active . withPeer ( peer ) , 
 archived = this . archived . filterNot ( _ . peer = = peer ) , 
 - mobile = this . mobile + sortableDialog 
 + mobile = this . mobile + sortableDialog , 
 + mobilePeers = this . mobilePeers + peer 
 ) 
 } 
 } 
 @ @ - 199 , 8 + 203 , 6 @ @ private [ dialog ] final case class DialogRootState ( 
 private def withUnarchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 if ( ! this . archived . exists ( _ . peer = = peer ) ) this 
 else { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 copy ( 
 active = this . active . withPeer ( peer ) , 
 archived = this . archived . filterNot ( _ . peer = = peer ) 
 @ @ - 209 , 8 + 211 , 8 @ @ private [ dialog ] final case class DialogRootState ( 
 } 
 
 private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - if ( peer . typ . isPrivate & & peer . id = = userId ) this 
 - else if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 + if ( ( peer . typ . isPrivate & & peer . id = = userId ) | | archived . exists ( _ . peer = = peer ) ) this 
 + else if ( archived . headOption . exists ( sd ⇒ sd . ts = = ts | | sd . ts . isAfter ( ts ) ) ) withArchivedPeer ( archived . head . ts . plusMillis ( 1 ) , peer ) 
 else { 
 val sortableDialog = SortableDialog ( ts , peer ) 
 copy ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 index e3dfb93 . . b74fdcc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / HistoryUtils . scala 
 @ @ - 61 , 7 + 61 , 7 @ @ object HistoryUtils { 
 val historyMessage = HistoryMessage ( SharedUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 HistoryMessageRepo . create ( historyMessage ) map ( _ ⇒ ( ) ) 
 } else { 
 - DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds = > 
 + DBIO . from ( GroupExtension ( system ) . getMemberIds ( toPeer . id ) ) map ( _ . _ 1 ) flatMap { groupUserIds ⇒ 
 val historyMessages = groupUserIds . map { groupUserId ⇒ 
 HistoryMessage ( groupUserId , toPeer , date , fromPeer . id , randomId , messageContentHeader , messageContentData , None ) 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index 652fad2 . . cf67226 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 7 , 7 + 7 , 7 @ @ import akka . pattern . { ask , pipe } 
 import akka . util . Timeout 
 import im . actor . concurrent . _ 
 import im . actor . server . cqrs . _ 
 - import im . actor . server . dialog . DialogCommands . SendMessage 
 + import im . actor . server . dialog . DialogCommands . { SendMessage , WriteMessageSelf } 
 import im . actor . server . model . { Peer , PeerType } 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . messaging . UpdateChatGroupsChanged 
 @ @ - 179 , 7 + 179 , 14 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 
 override def persistenceId : String = s " DialogRoot _ $ userId " 
 
 - override protected def getInitialState : DialogRootState = DialogRootState ( Map . empty , SortedSet . empty ( SortableDialog . ordering ) , SortedSet . empty ( SortableDialog . ordering ) ) 
 + override protected def getInitialState : DialogRootState = DialogRootState ( 
 + Map ( 
 + DialogGroupType . DirectMessages → Set . empty , 
 + DialogGroupType . Groups → Set . empty 
 + ) , 
 + SortedSet . empty ( SortableDialog . ordering ) , 
 + SortedSet . empty ( SortableDialog . ordering ) 
 + ) 
 
 override protected def handleQuery : PartialFunction [ Any , Future [ Any ] ] = { 
 case GetCounter ( ) ⇒ getCounter ( ) 
 @ @ - 188 , 18 + 195 , 18 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 override protected def handleCommand : Receive = { 
 - case sm : SendMessage ⇒ 
 - needShowDialog ( sm ) match { 
 + case dc : DialogCommand if dc . isInstanceOf [ SendMessage ] | | dc . isInstanceOf [ WriteMessageSelf ] ⇒ 
 + needShowDialog ( dc ) match { 
 case Some ( peer ) ⇒ 
 val e = if ( isArchived ( peer ) ) Unarchived ( Instant . now ( ) , Some ( peer ) ) else Created ( Instant . now ( ) , Some ( peer ) ) 
 
 persist ( e ) { _ ⇒ 
 commit ( e ) 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 sendChatGroupsChanged ( ) 
 } 
 case None ⇒ 
 - handleDialogCommand ( sm ) 
 + handleDialogCommand ( dc ) 
 } 
 case Archive ( Some ( peer ) , clientAuthSid ) ⇒ archive ( peer , clientAuthSid map ( _ . value ) ) 
 case Unarchive ( Some ( peer ) , clientAuthSid ) ⇒ unarchive ( peer , clientAuthSid map ( _ . value ) ) 
 @ @ - 219 , 25 + 226 , 17 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 
 private def archive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = archive $ { state . activePeers } " ) 
 - 
 if ( isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyArchived ( peer ) ) 
 else persist ( Archived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - println ( s " = = = archive result $ { state . activePeers } " ) 
 - 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 
 private def unarchive ( peer : Peer , clientAuthSid : Option [ Int ] ) = { 
 - println ( s " = = = unarchive $ { state . activePeers } " ) 
 - 
 if ( ! isArchived ( peer ) ) sender ( ) ! Status . Failure ( DialogErrors . DialogAlreadyShown ( peer ) ) 
 else persist ( Unarchived ( Instant . now ( ) , Some ( peer ) ) ) { e ⇒ 
 commit ( e ) 
 - 
 - println ( s " = = = unarchive result $ { state . activePeers } " ) 
 sendChatGroupsChanged ( clientAuthSid ) pipeTo sender ( ) 
 } 
 } 
 @ @ - 258 , 18 + 257 , 24 @ @ private class DialogRoot ( userId : Int , extensions : Seq [ ApiExtension ] ) extends Pro 
 } 
 } 
 
 - private def needShowDialog ( sm : SendMessage ) : Option [ Peer ] = { 
 - val checkPeer = 
 - sm . getOrigin . typ match { 
 - case PeerType . Group ⇒ sm . getDest 
 - case PeerType . Private ⇒ 
 - if ( selfPeer = = sm . getDest ) sm . getOrigin 
 - else sm . getDest 
 - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 - } 
 + private def needShowDialog ( cmd : DialogCommand ) : Option [ Peer ] = { 
 + val checkPeerOpt = cmd match { 
 + case sm : SendMessage ⇒ 
 + Some ( sm . getOrigin . typ match { 
 + case PeerType . Group ⇒ sm . getDest 
 + case PeerType . Private ⇒ 
 + if ( selfPeer = = sm . getDest ) sm . getOrigin 
 + else sm . getDest 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } ) 
 + case wm : WriteMessageSelf ⇒ Some ( wm . getDest ) 
 + case _ ⇒ None 
 + } 
 
 - if ( dialogShown ( checkPeer ) ) None 
 - else Some ( checkPeer ) 
 + checkPeerOpt flatMap { checkPeer ⇒ 
 + if ( dialogShown ( checkPeer ) ) None 
 + else Some ( checkPeer ) 
 + } 
 } 
 
 private def isArchived ( peer : Peer ) : Boolean = state . archived . contains ( SortableDialog ( Instant . MIN , peer ) ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 index 17e13c3 . . 7d8f59b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / user / UserCommandHandlers . scala 
 @ @ - 59 , 7 + 59 , 7 @ @ object UserErrors { 
 final case class BotCommandAlreadyExists ( slashCommand : String ) 
 extends UserError ( s " Bot command already exists : $ slashCommand " ) 
 
 - final case object ContactNotFound extends UserError ( " Contact not found " ) 
 + case object ContactNotFound extends UserError ( " Contact not found " ) 
 
 }
