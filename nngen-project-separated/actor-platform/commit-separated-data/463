BLEU SCORE: 0.38058030016749456

TEST MSG: refactor ( server : messaging ) : move DialogRootState to a separate file
GENERATED MSG: fix ( server : messaging ) : fixed dialog creation problems

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index d9b3252 . . 6a0b95e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 4 , 7 + 4 , 6 @ @ import java . time . Instant < nl > < nl > import akka . actor . { ActorRef , Props , Status } < nl > import akka . pattern . { ask , pipe } < nl > - import akka . persistence . SnapshotMetadata < nl > import akka . util . Timeout < nl > import com . google . protobuf . wrappers . Int64Value < nl > import im . actor . concurrent . _ < nl > @ @ - 19 , 167 + 18 , 8 @ @ import im . actor . serialization . ActorSerializer < nl > import im . actor . server . dialog . DialogQueries . GetInfoResponse < nl > import im . actor . server . sequence . { PushRules , SeqState , SeqUpdatesExtension } < nl > < nl > - import scala . collection . SortedSet < nl > import scala . concurrent . Future < nl > < nl > - trait DialogRootEvent extends TaggedEvent { < nl > - val ts : Instant < nl > - < nl > - override def tags : Set [ String ] = Set ( " dialogRoot " ) < nl > - } < nl > - < nl > - trait DialogRootCommand < nl > - < nl > - trait DialogRootQuery < nl > - < nl > - private object SortableDialog { < nl > - val OrderingAsc = new Ordering [ SortableDialog ] { < nl > - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > - if ( x . peer = = y . peer ) 0 < nl > - else if ( x . ts . isBefore ( y . ts ) ) - 1 < nl > - else if ( x . ts . isAfter ( y . ts ) ) 1 < nl > - else 0 < nl > - } < nl > - < nl > - val OrderingDesc = new Ordering [ SortableDialog ] { < nl > - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > - if ( x . peer = = y . peer ) 0 < nl > - else if ( x . ts . isBefore ( y . ts ) ) 1 < nl > - else if ( x . ts . isAfter ( y . ts ) ) - 1 < nl > - else 0 < nl > - } < nl > - } < nl > - < nl > - private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > - < nl > - private object DialogRootState { < nl > - val initial = DialogRootState ( < nl > - active = Map ( < nl > - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) < nl > - ) , < nl > - activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > - archived = SortedSet . empty ( SortableDialog . OrderingDesc ) < nl > - ) < nl > - } < nl > - < nl > - private final case class DialogRootState ( < nl > - active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , < nl > - activePeers : SortedSet [ SortableDialog ] , < nl > - archived : SortedSet [ SortableDialog ] < nl > - ) extends ProcessorState [ DialogRootState ] { < nl > - import DialogRootEvents . _ < nl > - < nl > - override def updated ( e : Event ) : DialogRootState = e match { < nl > - case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > - case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) < nl > - case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > - case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) < nl > - case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) < nl > - } < nl > - < nl > - lazy val allPeers = activePeers + + archived < nl > - < nl > - override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { < nl > - case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { < nl > - val state = DialogRootState . initial . copy ( < nl > - archived = SortedSet ( < nl > - ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > - ) ( SortableDialog . OrderingAsc ) < nl > - ) < nl > - < nl > - dialogGroups . foldLeft ( state ) { < nl > - case ( acc , DialogGroup ( group , infos ) ) ⇒ < nl > - acc . withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) < nl > - } < nl > - } < nl > - } < nl > - < nl > - override lazy val snapshot : Any = DialogRootStateSnapshot ( < nl > - dialogGroups = active . toSeq map { < nl > - case ( typ , sortableDialogs ) ⇒ < nl > - DialogGroup ( < nl > - typ , < nl > - sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > - ) < nl > - } , < nl > - archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } < nl > - ) < nl > - < nl > - private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > - if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else < nl > - copy ( < nl > - activePeers = this . activePeers + sortableDialog , < nl > - active = this . active + dialogGroup ( sortableDialog ) , < nl > - archived = this . archived - sortableDialog < nl > - ) < nl > - } < nl > - < nl > - private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > - if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else < nl > - copy ( < nl > - activePeers = this . activePeers - sortableDialog , < nl > - active = this . active mapValues ( _ - sortableDialog ) , < nl > - archived = this . archived + sortableDialog < nl > - ) < nl > - } < nl > - < nl > - private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > - if ( activePeers . exists ( _ . ts = = ts ) ) withFavouritedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > - else < nl > - copy ( < nl > - activePeers = this . activePeers + sortableDialog , < nl > - active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > - archived = this . archived - sortableDialog < nl > - ) < nl > - } < nl > - < nl > - private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { < nl > - val sortableDialog = SortableDialog ( ts , peer ) < nl > - < nl > - copy ( < nl > - active = < nl > - ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > - case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false < nl > - case _ ⇒ true < nl > - } < nl > - ) < nl > - } < nl > - < nl > - private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { < nl > - val activeBase = < nl > - if ( this . active . contains ( group ) ) this . active < nl > - else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) < nl > - < nl > - copy ( < nl > - active = activeBase map { < nl > - case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) < nl > - case other ⇒ other < nl > - } , < nl > - activePeers = this . activePeers + + sortableDialogs < nl > - ) < nl > - } < nl > - < nl > - private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { < nl > - val group = ( isFavourite , sortableDialog . peer . typ ) match { < nl > - case ( true , _ ) ⇒ DialogGroupType . Favourites < nl > - case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages < nl > - case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups < nl > - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > - } < nl > - < nl > - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) < nl > - } < nl > - } < nl > - < nl > object DialogRoot { < nl > private [ dialog ] def register ( ) = { < nl > ActorSerializer . register ( < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > new file mode 100644 < nl > index 0000000 . . 58b76bc < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala < nl > @ @ - 0 , 0 + 1 , 167 @ @ < nl > + package im . actor . server . dialog < nl > + < nl > + import java . time . Instant < nl > + < nl > + import akka . persistence . SnapshotMetadata < nl > + import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } < nl > + import im . actor . server . model . { Peer , PeerType } < nl > + < nl > + import scala . collection . SortedSet < nl > + < nl > + trait DialogRootEvent extends TaggedEvent { < nl > + val ts : Instant < nl > + < nl > + override def tags : Set [ String ] = Set ( " dialogRoot " ) < nl > + } < nl > + < nl > + trait DialogRootCommand < nl > + < nl > + trait DialogRootQuery < nl > + < nl > + private object SortableDialog { < nl > + val OrderingAsc = new Ordering [ SortableDialog ] { < nl > + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > + if ( x . peer = = y . peer ) 0 < nl > + else if ( x . ts . isBefore ( y . ts ) ) - 1 < nl > + else if ( x . ts . isAfter ( y . ts ) ) 1 < nl > + else 0 < nl > + } < nl > + < nl > + val OrderingDesc = new Ordering [ SortableDialog ] { < nl > + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = < nl > + if ( x . peer = = y . peer ) 0 < nl > + else if ( x . ts . isBefore ( y . ts ) ) 1 < nl > + else if ( x . ts . isAfter ( y . ts ) ) - 1 < nl > + else 0 < nl > + } < nl > + } < nl > + < nl > + private case class SortableDialog ( ts : Instant , peer : Peer ) < nl > + < nl > + private object DialogRootState { < nl > + val initial = DialogRootState ( < nl > + active = Map ( < nl > + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) < nl > + ) , < nl > + activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , < nl > + archived = SortedSet . empty ( SortableDialog . OrderingDesc ) < nl > + ) < nl > + } < nl > + < nl > + private final case class DialogRootState ( < nl > + active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , < nl > + activePeers : SortedSet [ SortableDialog ] , < nl > + archived : SortedSet [ SortableDialog ] < nl > + ) extends ProcessorState [ DialogRootState ] { < nl > + import DialogRootEvents . _ < nl > + < nl > + override def updated ( e : Event ) : DialogRootState = e match { < nl > + case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > + case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) < nl > + case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) < nl > + case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) < nl > + case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) < nl > + } < nl > + < nl > + lazy val allPeers = activePeers + + archived < nl > + < nl > + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { < nl > + case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { < nl > + val state = DialogRootState . initial . copy ( < nl > + archived = SortedSet ( < nl > + ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * < nl > + ) ( SortableDialog . OrderingAsc ) < nl > + ) < nl > + < nl > + dialogGroups . foldLeft ( state ) { < nl > + case ( acc , DialogGroup ( group , infos ) ) ⇒ < nl > + acc . withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) < nl > + } < nl > + } < nl > + } < nl > + < nl > + override lazy val snapshot : Any = DialogRootStateSnapshot ( < nl > + dialogGroups = active . toSeq map { < nl > + case ( typ , sortableDialogs ) ⇒ < nl > + DialogGroup ( < nl > + typ , < nl > + sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) < nl > + ) < nl > + } , < nl > + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } < nl > + ) < nl > + < nl > + private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > + if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + else < nl > + copy ( < nl > + activePeers = this . activePeers + sortableDialog , < nl > + active = this . active + dialogGroup ( sortableDialog ) , < nl > + archived = this . archived - sortableDialog < nl > + ) < nl > + } < nl > + < nl > + private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > + if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + else < nl > + copy ( < nl > + activePeers = this . activePeers - sortableDialog , < nl > + active = this . active mapValues ( _ - sortableDialog ) , < nl > + archived = this . archived + sortableDialog < nl > + ) < nl > + } < nl > + < nl > + private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > + if ( activePeers . exists ( _ . ts = = ts ) ) withFavouritedPeer ( ts . plusMillis ( 1 ) , peer ) < nl > + else < nl > + copy ( < nl > + activePeers = this . activePeers + sortableDialog , < nl > + active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , < nl > + archived = this . archived - sortableDialog < nl > + ) < nl > + } < nl > + < nl > + private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { < nl > + val sortableDialog = SortableDialog ( ts , peer ) < nl > + < nl > + copy ( < nl > + active = < nl > + ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { < nl > + case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false < nl > + case _ ⇒ true < nl > + } < nl > + ) < nl > + } < nl > + < nl > + private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { < nl > + val activeBase = < nl > + if ( this . active . contains ( group ) ) this . active < nl > + else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) < nl > + < nl > + copy ( < nl > + active = activeBase map { < nl > + case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) < nl > + case other ⇒ other < nl > + } , < nl > + activePeers = this . activePeers + + sortableDialogs < nl > + ) < nl > + } < nl > + < nl > + private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { < nl > + val group = ( isFavourite , sortableDialog . peer . typ ) match { < nl > + case ( true , _ ) ⇒ DialogGroupType . Favourites < nl > + case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages < nl > + case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups < nl > + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) < nl > + } < nl > + < nl > + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) < nl > + } < nl > + } < nl > \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index b73e615 . . c26a25e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 25 , 31 + 25 , 35 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > import DialogCommands . _ < nl > import DialogEvents . _ < nl > < nl > - protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > - becomeStashing ( replyTo ⇒ ( { < nl > - case seq : SeqStateDate ⇒ < nl > - replyTo ! seq < nl > - if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > - updateMessageDate ( state , sm . date ) < nl > - unstashAll ( ) < nl > - case fail : Status . Failure ⇒ < nl > - replyTo forward fail < nl > - unstashAll ( ) < nl > - } : Receive ) orElse reactions ( isHidden = state . isHidden ) ) < nl > - < nl > - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > - ( for { < nl > - _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > - message = sm . message < nl > - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) < nl > - _ ← dialogExt . updateCounters ( peer , userId ) < nl > - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) < nl > - } yield SeqStateDate ( seq , state , sm . date ) ) recover { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to send message " ) < nl > - throw e < nl > - } < nl > - } pipeTo self < nl > + protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { < nl > + withCreated ( s ) { state ⇒ < nl > + becomeStashing ( replyTo ⇒ ( { < nl > + case seq : SeqStateDate ⇒ < nl > + replyTo ! seq < nl > + if ( state . isHidden ) { < nl > + self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } < nl > + updateMessageDate ( state , sm . date ) < nl > + unstashAll ( ) < nl > + case fail : Status . Failure ⇒ < nl > + replyTo forward fail < nl > + unstashAll ( ) < nl > + } : Receive ) orElse reactions ( state ) , discardOld = true ) < nl > + < nl > + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > + ( for { < nl > + _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > + message = sm . message < nl > + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + _ ← dialogExt . updateCounters ( peer , userId ) < nl > + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) < nl > + } yield SeqStateDate ( seq , state , sm . date ) ) recover { < nl > + case e ⇒ < nl > + log . error ( e , " Failed to send message " ) < nl > + throw e < nl > + } < nl > + } pipeTo self < nl > + } < nl > } < nl > < nl > protected def updateCountersChanged ( ) : Unit = { < nl > @ @ - 58 , 55 + 62 , 60 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > . pipeTo ( sender ( ) ) < nl > } < nl > < nl > - protected def ackSendMessage ( isHidden : Boolean , sm : SendMessage ) : Unit = { < nl > - if ( peer . typ = = PeerType . Private ) { < nl > - SocialManager . recordRelation ( sm . origin . id , userId ) < nl > - SocialManager . recordRelation ( userId , sm . origin . id ) < nl > - } < nl > - < nl > - deliveryExt < nl > - . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > - . map ( _ ⇒ SendMessageAck ( ) ) < nl > - . pipeTo ( sender ( ) ) onSuccess { < nl > - case _ ⇒ < nl > - if ( isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = < nl > + withCreated ( s ) { state ⇒ < nl > + if ( peer . typ = = PeerType . Private ) { < nl > + SocialManager . recordRelation ( sm . origin . id , userId ) < nl > + SocialManager . recordRelation ( userId , sm . origin . id ) < nl > } < nl > - } < nl > + < nl > + deliveryExt < nl > + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) < nl > + . map ( _ ⇒ SendMessageAck ( ) ) < nl > + . pipeTo ( sender ( ) ) onSuccess { < nl > + case _ ⇒ < nl > + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + } < nl > + } < nl > < nl > protected def writeMessage ( < nl > + s : DialogState , < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = { < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > - db . run ( writeHistoryMessage ( < nl > - selfPeer , < nl > - peer , < nl > - date , < nl > - randomId , < nl > - message . header , < nl > - message . toByteArray < nl > - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + ) : Unit = < nl > + withCreated ( s ) { _ ⇒ < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + db . run ( writeHistoryMessage ( < nl > + selfPeer , < nl > + peer , < nl > + date , < nl > + randomId , < nl > + message . header , < nl > + message . toByteArray < nl > + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def writeMessageSelf ( < nl > + s : DialogState , < nl > senderUserId : Int , < nl > dateMillis : Long , < nl > randomId : Long , < nl > message : ApiMessage < nl > - ) : Unit = { < nl > - val date = new DateTime ( dateMillis ) < nl > - < nl > - val result = < nl > - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) < nl > - } else { < nl > - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > - } < nl > - < nl > - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > - } < nl > + ) : Unit = < nl > + withCreated ( s ) { _ ⇒ < nl > + val date = new DateTime ( dateMillis ) < nl > + < nl > + val result = < nl > + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { < nl > + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) < nl > + } else { < nl > + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) < nl > + } < nl > + < nl > + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) < nl > + } < nl > < nl > protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { < nl > val mustReceive = mustMakeReceive ( state , mr ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > index 8330296 . . c4f6144 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala < nl > @ @ - 6 , 7 + 6 , 6 @ @ import akka . actor . _ < nl > import akka . pattern . pipe < nl > import akka . util . Timeout < nl > import com . github . benmanes . caffeine . cache . Cache < nl > - import im . actor . api . rpc . messaging . ApiTextMessage < nl > import im . actor . api . rpc . misc . ApiExtension < nl > import im . actor . concurrent . { ActorFutures , ActorStashing } < nl > import im . actor . serialization . ActorSerializer < nl > @ @ - 14 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } < nl > import im . actor . server . persist . dialog . DialogRepo < nl > - import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo } < nl > + import im . actor . server . persist . { GroupRepo , UserRepo } < nl > import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } < nl > import im . actor . server . social . SocialExtension < nl > import im . actor . server . user . UserExtension < nl > @ @ - 30 , 29 + 29 , 6 @ @ object DialogEvents { < nl > < nl > private [ dialog ] sealed trait DialogEvent < nl > < nl > - sealed trait InitState < nl > - < nl > - private [ dialog ] object Initialized { < nl > - def fromDialog ( dialog : DialogModel ) : Initialized = < nl > - Initialized ( < nl > - dialog . lastMessageDate . getMillis , < nl > - dialog . ownerLastReceivedAt . getMillis , < nl > - dialog . ownerLastReadAt . getMillis , < nl > - dialog . shownAt . isEmpty , < nl > - dialog . isFavourite < nl > - ) < nl > - } < nl > - < nl > - private [ dialog ] final case class Initialized ( < nl > - lastMessageDate : Long , < nl > - lastReceiveDate : Long , < nl > - lastReadDate : Long , < nl > - isHidden : Boolean , < nl > - isFavourite : Boolean < nl > - ) extends DialogEvent with InitState < nl > - < nl > - private [ dialog ] case object Uninitialized extends DialogEvent with InitState < nl > - < nl > private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent < nl > < nl > private [ dialog ] final case class LastReceiveDate ( date : Long ) extends DialogEvent < nl > @ @ - 73 , 8 + 49 , 19 @ @ private [ dialog ] object DialogState { < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > - isFavourite : Boolean < nl > - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) < nl > + isFavourite : Boolean , < nl > + isCreated : Boolean < nl > + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isCreated ) < nl > + < nl > + def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = < nl > + DialogState ( < nl > + model . lastMessageDate . getMillis , < nl > + model . ownerLastReceivedAt . getMillis , < nl > + model . ownerLastReadAt . getMillis , < nl > + model . shownAt . isEmpty , < nl > + model . isFavourite , < nl > + isCreated = isCreated < nl > + ) < nl > } < nl > < nl > private [ dialog ] final case class DialogState ( < nl > @ @ - 82 , 7 + 69 , 8 @ @ private [ dialog ] final case class DialogState ( < nl > lastReceiveDate : Long , < nl > lastReadDate : Long , < nl > isHidden : Boolean , < nl > - isFavourite : Boolean < nl > + isFavourite : Boolean , < nl > + isCreated : Boolean < nl > ) extends ProcessorState [ DialogState ] { < nl > import DialogEvents . _ < nl > override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { < nl > @ @ - 126 , 7 + 114 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > with ActorFutures < nl > with ActorStashing { < nl > import DialogCommands . _ < nl > - import DialogEvents . _ < nl > import DialogProcessor . _ < nl > < nl > protected implicit val ec : ExecutionContext = context . dispatcher < nl > @ @ - 146 , 49 + 133 , 24 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = < nl > createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) < nl > < nl > - override def receive : Receive = initializing < nl > + override def preStart ( ) = init ( ) < nl > < nl > - def initializing : Receive = { < nl > - case msg ⇒ < nl > - stash ( ) < nl > - becomeStashing ( replyTo ⇒ ( { < nl > - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ⇒ < nl > - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ) < nl > - unstashAll ( ) < nl > - case Status . Failure ( e ) ⇒ < nl > - log . error ( e , " Failed to init dialog " ) < nl > - self ! Kill < nl > - } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) < nl > - < nl > - ( for { < nl > - state ← initialState < nl > - resultMessage ← state match { < nl > - case init : Initialized ⇒ Future . successful ( init ) < nl > - case Uninitialized ⇒ < nl > - if ( isWriteOperation ( msg ) ) { < nl > - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > - db . run ( for { < nl > - exists ← peer . ` type ` match { < nl > - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > - } < nl > - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) < nl > - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > - } yield Initialized . fromDialog ( dialog ) ) < nl > - } else { < nl > - Future . successful ( msg ) < nl > - } < nl > - } < nl > - } yield resultMessage ) . to ( self , sender ( ) ) < nl > - } < nl > + def receive = initializing < nl > + < nl > + def initializing : Receive = receiveStashing ( replyTo ⇒ { < nl > + case state : DialogState ⇒ < nl > + context become initialized ( state ) < nl > + unstashAll ( ) < nl > + case Status . Failure ( cause ) ⇒ < nl > + log . error ( cause , " Failed to init dialog " ) < nl > + self ! Kill < nl > + } ) < nl > < nl > - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) < nl > + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) < nl > < nl > / / when receiving this messages , dialog reacts on other dialog ' s action < nl > - def reactions ( isHidden : Boolean ) : Receive = { < nl > - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( isHidden , sm ) / / User ' s message been sent < nl > + def reactions ( state : DialogState ) : Receive = { < nl > + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent < nl > case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received < nl > case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read < nl > case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) < nl > @ @ - 196 , 11 + 158 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case uc : UpdateCounters ⇒ updateCountersChanged ( ) < nl > } < nl > < nl > - def dummyActions : Receive = { < nl > - case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) < nl > - case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) < nl > - } < nl > - < nl > / / when receiving this messages , dialog required to take action < nl > def actions ( state : DialogState ) : Receive = { < nl > case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message < nl > @ @ - 213 , 8 + 170 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > case Favourite ( _ ) ⇒ favourite ( state ) < nl > case Unfavourite ( _ ) ⇒ unfavourite ( state ) < nl > case Delete ( _ ) ⇒ delete ( state ) < nl > - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) < nl > - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) < nl > + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( state , date , randomId , message ) < nl > + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) < nl > } < nl > < nl > / * * < nl > @ @ - 243 , 18 + 200 , 43 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext < nl > * / < nl > private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) < nl > < nl > - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { < nl > - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true < nl > - case _ ⇒ false < nl > - } < nl > - < nl > - private def initialState : Future [ InitState ] = < nl > - for { < nl > + private def init ( ) : Unit = { < nl > + ( for { < nl > optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) < nl > initState ← optDialog match { < nl > - case Some ( dialog ) ⇒ Future . successful ( Initialized . fromDialog ( dialog ) ) < nl > - case None ⇒ Future . successful ( Uninitialized ) < nl > + case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) < nl > + case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) < nl > } < nl > - } yield initState < nl > + } yield initState ) pipeTo self < nl > + } < nl > + < nl > + protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { < nl > + if ( state . isCreated ) f ( state ) < nl > + else { < nl > + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) < nl > + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) < nl > + val replyTo = sender ( ) < nl > + < nl > + db . run ( for { < nl > + exists ← peer . ` type ` match { < nl > + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) < nl > + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) < nl > + } < nl > + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) < nl > + _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) < nl > + } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) < nl > + < nl > + becomeStashing ( replyTo ⇒ { < nl > + case state : DialogState ⇒ < nl > + context become initialized ( state ) < nl > + unstashAll ( ) < nl > + f ( state ) < nl > + case Status . Failure ( e ) ⇒ < nl > + log . error ( e , " Failed to create dialog " ) < nl > + self ! Kill < nl > + } , discardOld = true ) < nl > + } < nl > + } < nl > < nl > } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > index 797646d . . 962bb84 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala < nl > @ @ - 10 , 11 + 10 , 13 @ @ import scala . concurrent . ExecutionContext < nl > object DialogCommonRepo { < nl > val dialogCommon = TableQuery [ DialogCommonTable ] < nl > < nl > - private def byPK ( dialogId : Rep [ String ] ) = { < nl > + private def byPK ( dialogId : Rep [ String ] ) = < nl > dialogCommon . filter ( _ . dialogId = = = dialogId ) < nl > - } < nl > + < nl > + private def exists ( dialogId : Rep [ String ] ) = byPK ( dialogId ) . exists < nl > < nl > val byPKC = Compiled ( byPK _ ) < nl > + val existsC = Compiled ( exists _ ) < nl > } < nl > < nl > trait DialogCommonOperations extends DialogId { < nl > @ @ - 23 , 8 + 25 , 7 @ @ trait DialogCommonOperations extends DialogId { < nl > def findCommon ( userId : Option [ Int ] , peer : Peer ) : DBIO [ Option [ DialogCommon ] ] = < nl > byPKC . applied ( getDialogId ( userId , peer ) ) . result . headOption < nl > < nl > - def commonExists ( dialogId : String ) = < nl > - byPKC . applied ( dialogId ) . exists . result < nl > + def commonExists ( dialogId : String ) = existsC ( dialogId ) . result < nl > < nl > def updateLastMessageDatePrivate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { < nl > requirePrivate ( peer ) < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > index 1befed8 . . b478eba 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala < nl > @ @ - 8 , 6 + 8 , 7 @ @ import org . joda . time . DateTime < nl > import slick . lifted . ColumnOrdered < nl > < nl > import scala . concurrent . ExecutionContext < nl > + import scala . util . { Success , Failure } < nl > < nl > final class DialogCommonTable ( tag : Tag ) extends Table [ DialogCommon ] ( tag , " dialog _ commons " ) { < nl > < nl > @ @ - 151 , 7 + 152 , 16 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { < nl > UserDialogRepo . userDialogs + = user < nl > } else { < nl > for { < nl > - c ← DialogCommonRepo . dialogCommon + = common < nl > + c ← ( DialogCommonRepo . dialogCommon + = common ) < nl > + . asTry < nl > + . flatMap { < nl > + case Failure ( e ) ⇒ < nl > + commonExists ( common . dialogId ) flatMap { < nl > + case true ⇒ DBIO . successful ( 1 ) < nl > + case false ⇒ DBIO . failed ( e ) < nl > + } < nl > + case Success ( res ) ⇒ DBIO . successful ( res ) < nl > + } < nl > _ ← UserDialogRepo . userDialogs + = user < nl > } yield c < nl > }

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index d9b3252 . . 6a0b95e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 4 , 7 + 4 , 6 @ @ import java . time . Instant 
 
 import akka . actor . { ActorRef , Props , Status } 
 import akka . pattern . { ask , pipe } 
 - import akka . persistence . SnapshotMetadata 
 import akka . util . Timeout 
 import com . google . protobuf . wrappers . Int64Value 
 import im . actor . concurrent . _ 
 @ @ - 19 , 167 + 18 , 8 @ @ import im . actor . serialization . ActorSerializer 
 import im . actor . server . dialog . DialogQueries . GetInfoResponse 
 import im . actor . server . sequence . { PushRules , SeqState , SeqUpdatesExtension } 
 
 - import scala . collection . SortedSet 
 import scala . concurrent . Future 
 
 - trait DialogRootEvent extends TaggedEvent { 
 - val ts : Instant 
 - 
 - override def tags : Set [ String ] = Set ( " dialogRoot " ) 
 - } 
 - 
 - trait DialogRootCommand 
 - 
 - trait DialogRootQuery 
 - 
 - private object SortableDialog { 
 - val OrderingAsc = new Ordering [ SortableDialog ] { 
 - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 - if ( x . peer = = y . peer ) 0 
 - else if ( x . ts . isBefore ( y . ts ) ) - 1 
 - else if ( x . ts . isAfter ( y . ts ) ) 1 
 - else 0 
 - } 
 - 
 - val OrderingDesc = new Ordering [ SortableDialog ] { 
 - override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 - if ( x . peer = = y . peer ) 0 
 - else if ( x . ts . isBefore ( y . ts ) ) 1 
 - else if ( x . ts . isAfter ( y . ts ) ) - 1 
 - else 0 
 - } 
 - } 
 - 
 - private case class SortableDialog ( ts : Instant , peer : Peer ) 
 - 
 - private object DialogRootState { 
 - val initial = DialogRootState ( 
 - active = Map ( 
 - DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 - DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) 
 - ) , 
 - activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 - archived = SortedSet . empty ( SortableDialog . OrderingDesc ) 
 - ) 
 - } 
 - 
 - private final case class DialogRootState ( 
 - active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , 
 - activePeers : SortedSet [ SortableDialog ] , 
 - archived : SortedSet [ SortableDialog ] 
 - ) extends ProcessorState [ DialogRootState ] { 
 - import DialogRootEvents . _ 
 - 
 - override def updated ( e : Event ) : DialogRootState = e match { 
 - case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 - case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) 
 - case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 - case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) 
 - case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) 
 - } 
 - 
 - lazy val allPeers = activePeers + + archived 
 - 
 - override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { 
 - case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { 
 - val state = DialogRootState . initial . copy ( 
 - archived = SortedSet ( 
 - ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 - ) ( SortableDialog . OrderingAsc ) 
 - ) 
 - 
 - dialogGroups . foldLeft ( state ) { 
 - case ( acc , DialogGroup ( group , infos ) ) ⇒ 
 - acc . withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) 
 - } 
 - } 
 - } 
 - 
 - override lazy val snapshot : Any = DialogRootStateSnapshot ( 
 - dialogGroups = active . toSeq map { 
 - case ( typ , sortableDialogs ) ⇒ 
 - DialogGroup ( 
 - typ , 
 - sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 - ) 
 - } , 
 - archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } 
 - ) 
 - 
 - private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 - if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else 
 - copy ( 
 - activePeers = this . activePeers + sortableDialog , 
 - active = this . active + dialogGroup ( sortableDialog ) , 
 - archived = this . archived - sortableDialog 
 - ) 
 - } 
 - 
 - private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 - if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else 
 - copy ( 
 - activePeers = this . activePeers - sortableDialog , 
 - active = this . active mapValues ( _ - sortableDialog ) , 
 - archived = this . archived + sortableDialog 
 - ) 
 - } 
 - 
 - private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 - if ( activePeers . exists ( _ . ts = = ts ) ) withFavouritedPeer ( ts . plusMillis ( 1 ) , peer ) 
 - else 
 - copy ( 
 - activePeers = this . activePeers + sortableDialog , 
 - active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 - archived = this . archived - sortableDialog 
 - ) 
 - } 
 - 
 - private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { 
 - val sortableDialog = SortableDialog ( ts , peer ) 
 - 
 - copy ( 
 - active = 
 - ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 - case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false 
 - case _ ⇒ true 
 - } 
 - ) 
 - } 
 - 
 - private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { 
 - val activeBase = 
 - if ( this . active . contains ( group ) ) this . active 
 - else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) 
 - 
 - copy ( 
 - active = activeBase map { 
 - case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) 
 - case other ⇒ other 
 - } , 
 - activePeers = this . activePeers + + sortableDialogs 
 - ) 
 - } 
 - 
 - private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { 
 - val group = ( isFavourite , sortableDialog . peer . typ ) match { 
 - case ( true , _ ) ⇒ DialogGroupType . Favourites 
 - case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages 
 - case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups 
 - case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 - } 
 - 
 - group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) 
 - } 
 - } 
 - 
 object DialogRoot { 
 private [ dialog ] def register ( ) = { 
 ActorSerializer . register ( 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 new file mode 100644 
 index 0000000 . . 58b76bc 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRootState . scala 
 @ @ - 0 , 0 + 1 , 167 @ @ 
 + package im . actor . server . dialog 
 + 
 + import java . time . Instant 
 + 
 + import akka . persistence . SnapshotMetadata 
 + import im . actor . server . cqrs . { Event , ProcessorState , TaggedEvent } 
 + import im . actor . server . model . { Peer , PeerType } 
 + 
 + import scala . collection . SortedSet 
 + 
 + trait DialogRootEvent extends TaggedEvent { 
 + val ts : Instant 
 + 
 + override def tags : Set [ String ] = Set ( " dialogRoot " ) 
 + } 
 + 
 + trait DialogRootCommand 
 + 
 + trait DialogRootQuery 
 + 
 + private object SortableDialog { 
 + val OrderingAsc = new Ordering [ SortableDialog ] { 
 + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 + if ( x . peer = = y . peer ) 0 
 + else if ( x . ts . isBefore ( y . ts ) ) - 1 
 + else if ( x . ts . isAfter ( y . ts ) ) 1 
 + else 0 
 + } 
 + 
 + val OrderingDesc = new Ordering [ SortableDialog ] { 
 + override def compare ( x : SortableDialog , y : SortableDialog ) : Int = 
 + if ( x . peer = = y . peer ) 0 
 + else if ( x . ts . isBefore ( y . ts ) ) 1 
 + else if ( x . ts . isAfter ( y . ts ) ) - 1 
 + else 0 
 + } 
 + } 
 + 
 + private case class SortableDialog ( ts : Instant , peer : Peer ) 
 + 
 + private object DialogRootState { 
 + val initial = DialogRootState ( 
 + active = Map ( 
 + DialogGroupType . Groups → SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + DialogGroupType . DirectMessages → SortedSet . empty ( SortableDialog . OrderingAsc ) 
 + ) , 
 + activePeers = SortedSet . empty ( SortableDialog . OrderingAsc ) , 
 + archived = SortedSet . empty ( SortableDialog . OrderingDesc ) 
 + ) 
 + } 
 + 
 + private final case class DialogRootState ( 
 + active : Map [ DialogGroupType , SortedSet [ SortableDialog ] ] , 
 + activePeers : SortedSet [ SortableDialog ] , 
 + archived : SortedSet [ SortableDialog ] 
 + ) extends ProcessorState [ DialogRootState ] { 
 + import DialogRootEvents . _ 
 + 
 + override def updated ( e : Event ) : DialogRootState = e match { 
 + case Created ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 + case Archived ( ts , Some ( peer ) ) ⇒ withArchivedPeer ( ts , peer ) 
 + case Unarchived ( ts , Some ( peer ) ) ⇒ withShownPeer ( ts , peer ) 
 + case Favourited ( ts , Some ( peer ) ) ⇒ withFavouritedPeer ( ts , peer ) 
 + case Unfavourited ( ts , Some ( peer ) ) ⇒ withUnfavouritedPeer ( ts , peer ) 
 + } 
 + 
 + lazy val allPeers = activePeers + + archived 
 + 
 + override def withSnapshot ( metadata : SnapshotMetadata , snapshot : Any ) : DialogRootState = snapshot match { 
 + case DialogRootStateSnapshot ( dialogGroups , _ archived ) ⇒ { 
 + val state = DialogRootState . initial . copy ( 
 + archived = SortedSet ( 
 + ( _ archived map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) : _ * 
 + ) ( SortableDialog . OrderingAsc ) 
 + ) 
 + 
 + dialogGroups . foldLeft ( state ) { 
 + case ( acc , DialogGroup ( group , infos ) ) ⇒ 
 + acc . withDialogsInGroup ( group , infos map ( di ⇒ SortableDialog ( di . date , di . getPeer ) ) ) 
 + } 
 + } 
 + } 
 + 
 + override lazy val snapshot : Any = DialogRootStateSnapshot ( 
 + dialogGroups = active . toSeq map { 
 + case ( typ , sortableDialogs ) ⇒ 
 + DialogGroup ( 
 + typ , 
 + sortableDialogs . toSeq map ( sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) ) 
 + ) 
 + } , 
 + archived = archived . toSeq map { sd ⇒ DialogInfo ( Some ( sd . peer ) , date = sd . ts ) } 
 + ) 
 + 
 + private def withShownPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 + if ( this . activePeers . exists ( _ . ts = = ts ) ) withShownPeer ( ts . plusMillis ( 1 ) , peer ) 
 + else 
 + copy ( 
 + activePeers = this . activePeers + sortableDialog , 
 + active = this . active + dialogGroup ( sortableDialog ) , 
 + archived = this . archived - sortableDialog 
 + ) 
 + } 
 + 
 + private def withArchivedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 + if ( archived . exists ( _ . ts = = ts ) ) withArchivedPeer ( ts . plusMillis ( 1 ) , peer ) 
 + else 
 + copy ( 
 + activePeers = this . activePeers - sortableDialog , 
 + active = this . active mapValues ( _ - sortableDialog ) , 
 + archived = this . archived + sortableDialog 
 + ) 
 + } 
 + 
 + private def withFavouritedPeer ( ts : Instant , peer : Peer ) : DialogRootState = { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 + if ( activePeers . exists ( _ . ts = = ts ) ) withFavouritedPeer ( ts . plusMillis ( 1 ) , peer ) 
 + else 
 + copy ( 
 + activePeers = this . activePeers + sortableDialog , 
 + active = this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog , isFavourite = true ) , 
 + archived = this . archived - sortableDialog 
 + ) 
 + } 
 + 
 + private def withUnfavouritedPeer ( ts : Instant , peer : Peer ) = { 
 + val sortableDialog = SortableDialog ( ts , peer ) 
 + 
 + copy ( 
 + active = 
 + ( this . active . mapValues ( _ . filterNot ( _ . peer = = peer ) ) + dialogGroup ( sortableDialog ) ) . filter { 
 + case ( DialogGroupType . Favourites , peers ) if peers . isEmpty ⇒ false 
 + case _ ⇒ true 
 + } 
 + ) 
 + } 
 + 
 + private def withDialogsInGroup ( group : DialogGroupType , sortableDialogs : Seq [ SortableDialog ] ) = { 
 + val activeBase = 
 + if ( this . active . contains ( group ) ) this . active 
 + else this . active + ( group → SortedSet . empty ( SortableDialog . OrderingAsc ) ) 
 + 
 + copy ( 
 + active = activeBase map { 
 + case ( ` group ` , dialogs ) ⇒ ( group , dialogs + + sortableDialogs ) 
 + case other ⇒ other 
 + } , 
 + activePeers = this . activePeers + + sortableDialogs 
 + ) 
 + } 
 + 
 + private def dialogGroup ( sortableDialog : SortableDialog , isFavourite : Boolean = false ) = { 
 + val group = ( isFavourite , sortableDialog . peer . typ ) match { 
 + case ( true , _ ) ⇒ DialogGroupType . Favourites 
 + case ( false , PeerType . Private ) ⇒ DialogGroupType . DirectMessages 
 + case ( false , PeerType . Group ) ⇒ DialogGroupType . Groups 
 + case _ ⇒ throw new RuntimeException ( " Unknown peer type " ) 
 + } 
 + 
 + group → ( this . active . getOrElse ( group , SortedSet . empty ( SortableDialog . OrderingAsc ) ) + sortableDialog ) 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index b73e615 . . c26a25e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 25 , 31 + 25 , 35 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 import DialogCommands . _ 
 import DialogEvents . _ 
 
 - protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 - becomeStashing ( replyTo ⇒ ( { 
 - case seq : SeqStateDate ⇒ 
 - replyTo ! seq 
 - if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 - updateMessageDate ( state , sm . date ) 
 - unstashAll ( ) 
 - case fail : Status . Failure ⇒ 
 - replyTo forward fail 
 - unstashAll ( ) 
 - } : Receive ) orElse reactions ( isHidden = state . isHidden ) ) 
 - 
 - withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 - ( for { 
 - _ ← dialogExt . ackSendMessage ( peer , sm ) 
 - message = sm . message 
 - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) 
 - _ ← dialogExt . updateCounters ( peer , userId ) 
 - SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) 
 - } yield SeqStateDate ( seq , state , sm . date ) ) recover { 
 - case e ⇒ 
 - log . error ( e , " Failed to send message " ) 
 - throw e 
 - } 
 - } pipeTo self 
 + protected def sendMessage ( s : DialogState , sm : SendMessage ) : Unit = { 
 + withCreated ( s ) { state ⇒ 
 + becomeStashing ( replyTo ⇒ ( { 
 + case seq : SeqStateDate ⇒ 
 + replyTo ! seq 
 + if ( state . isHidden ) { 
 + self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } 
 + updateMessageDate ( state , sm . date ) 
 + unstashAll ( ) 
 + case fail : Status . Failure ⇒ 
 + replyTo forward fail 
 + unstashAll ( ) 
 + } : Receive ) orElse reactions ( state ) , discardOld = true ) 
 + 
 + withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 + ( for { 
 + _ ← dialogExt . ackSendMessage ( peer , sm ) 
 + message = sm . message 
 + _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sm . date ) , sm . randomId , message . header , message . toByteArray ) ) 
 + _ ← dialogExt . updateCounters ( peer , userId ) 
 + SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , sm . senderAuthSid , peer , sm . randomId , sm . date , message , sm . isFat ) 
 + } yield SeqStateDate ( seq , state , sm . date ) ) recover { 
 + case e ⇒ 
 + log . error ( e , " Failed to send message " ) 
 + throw e 
 + } 
 + } pipeTo self 
 + } 
 } 
 
 protected def updateCountersChanged ( ) : Unit = { 
 @ @ - 58 , 55 + 62 , 60 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 . pipeTo ( sender ( ) ) 
 } 
 
 - protected def ackSendMessage ( isHidden : Boolean , sm : SendMessage ) : Unit = { 
 - if ( peer . typ = = PeerType . Private ) { 
 - SocialManager . recordRelation ( sm . origin . id , userId ) 
 - SocialManager . recordRelation ( userId , sm . origin . id ) 
 - } 
 - 
 - deliveryExt 
 - . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 - . map ( _ ⇒ SendMessageAck ( ) ) 
 - . pipeTo ( sender ( ) ) onSuccess { 
 - case _ ⇒ 
 - if ( isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + protected def ackSendMessage ( s : DialogState , sm : SendMessage ) : Unit = 
 + withCreated ( s ) { state ⇒ 
 + if ( peer . typ = = PeerType . Private ) { 
 + SocialManager . recordRelation ( sm . origin . id , userId ) 
 + SocialManager . recordRelation ( userId , sm . origin . id ) 
 } 
 - } 
 + 
 + deliveryExt 
 + . receiverDelivery ( userId , sm . origin . id , peer , sm . randomId , sm . date , sm . message , sm . isFat ) 
 + . map ( _ ⇒ SendMessageAck ( ) ) 
 + . pipeTo ( sender ( ) ) onSuccess { 
 + case _ ⇒ 
 + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + } 
 + } 
 
 protected def writeMessage ( 
 + s : DialogState , 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = { 
 - val date = new DateTime ( dateMillis ) 
 - 
 - db . run ( writeHistoryMessage ( 
 - selfPeer , 
 - peer , 
 - date , 
 - randomId , 
 - message . header , 
 - message . toByteArray 
 - ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 - } 
 + ) : Unit = 
 + withCreated ( s ) { _ ⇒ 
 + val date = new DateTime ( dateMillis ) 
 + 
 + db . run ( writeHistoryMessage ( 
 + selfPeer , 
 + peer , 
 + date , 
 + randomId , 
 + message . header , 
 + message . toByteArray 
 + ) ) map ( _ ⇒ WriteMessageAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def writeMessageSelf ( 
 + s : DialogState , 
 senderUserId : Int , 
 dateMillis : Long , 
 randomId : Long , 
 message : ApiMessage 
 - ) : Unit = { 
 - val date = new DateTime ( dateMillis ) 
 - 
 - val result = 
 - if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 - Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ { senderUserId } in dialog of user $ { userId } with user $ { peer . id } " ) ) 
 - } else { 
 - db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 - } 
 - 
 - result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 - } 
 + ) : Unit = 
 + withCreated ( s ) { _ ⇒ 
 + val date = new DateTime ( dateMillis ) 
 + 
 + val result = 
 + if ( peer . ` type ` = = PeerType . Private & & peer . id ! = senderUserId & & userId ! = senderUserId ) { 
 + Future . failed ( new RuntimeException ( s " writeMessageSelf with senderUserId $ senderUserId in dialog of user $ userId with user $ { peer . id } " ) ) 
 + } else { 
 + db . run ( writeHistoryMessageSelf ( userId , peer , senderUserId , date , randomId , message . header , message . toByteArray ) ) 
 + } 
 + 
 + result map ( _ ⇒ WriteMessageSelfAck ( ) ) pipeTo sender ( ) 
 + } 
 
 protected def messageReceived ( state : DialogState , mr : MessageReceived ) : Unit = { 
 val mustReceive = mustMakeReceive ( state , mr ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 index 8330296 . . c4f6144 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogProcessor . scala 
 @ @ - 6 , 7 + 6 , 6 @ @ import akka . actor . _ 
 import akka . pattern . pipe 
 import akka . util . Timeout 
 import com . github . benmanes . caffeine . cache . Cache 
 - import im . actor . api . rpc . messaging . ApiTextMessage 
 import im . actor . api . rpc . misc . ApiExtension 
 import im . actor . concurrent . { ActorFutures , ActorStashing } 
 import im . actor . serialization . ActorSerializer 
 @ @ - 14 , 7 + 13 , 7 @ @ import im . actor . server . cqrs . ProcessorState 
 import im . actor . server . db . DbExtension 
 import im . actor . server . model . { Dialog ⇒ DialogModel , PeerType , Peer } 
 import im . actor . server . persist . dialog . DialogRepo 
 - import im . actor . server . persist . { GroupRepo , UserRepo , HistoryMessageRepo } 
 + import im . actor . server . persist . { GroupRepo , UserRepo } 
 import im . actor . server . sequence . { SeqUpdatesExtension , SeqStateDate } 
 import im . actor . server . social . SocialExtension 
 import im . actor . server . user . UserExtension 
 @ @ - 30 , 29 + 29 , 6 @ @ object DialogEvents { 
 
 private [ dialog ] sealed trait DialogEvent 
 
 - sealed trait InitState 
 - 
 - private [ dialog ] object Initialized { 
 - def fromDialog ( dialog : DialogModel ) : Initialized = 
 - Initialized ( 
 - dialog . lastMessageDate . getMillis , 
 - dialog . ownerLastReceivedAt . getMillis , 
 - dialog . ownerLastReadAt . getMillis , 
 - dialog . shownAt . isEmpty , 
 - dialog . isFavourite 
 - ) 
 - } 
 - 
 - private [ dialog ] final case class Initialized ( 
 - lastMessageDate : Long , 
 - lastReceiveDate : Long , 
 - lastReadDate : Long , 
 - isHidden : Boolean , 
 - isFavourite : Boolean 
 - ) extends DialogEvent with InitState 
 - 
 - private [ dialog ] case object Uninitialized extends DialogEvent with InitState 
 - 
 private [ dialog ] final case class LastMessageDate ( date : Long ) extends DialogEvent 
 
 private [ dialog ] final case class LastReceiveDate ( date : Long ) extends DialogEvent 
 @ @ - 73 , 8 + 49 , 19 @ @ private [ dialog ] object DialogState { 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 - isFavourite : Boolean 
 - ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) 
 + isFavourite : Boolean , 
 + isCreated : Boolean 
 + ) = DialogState ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite , isCreated ) 
 + 
 + def fromModel ( model : DialogModel , isCreated : Boolean ) : DialogState = 
 + DialogState ( 
 + model . lastMessageDate . getMillis , 
 + model . ownerLastReceivedAt . getMillis , 
 + model . ownerLastReadAt . getMillis , 
 + model . shownAt . isEmpty , 
 + model . isFavourite , 
 + isCreated = isCreated 
 + ) 
 } 
 
 private [ dialog ] final case class DialogState ( 
 @ @ - 82 , 7 + 69 , 8 @ @ private [ dialog ] final case class DialogState ( 
 lastReceiveDate : Long , 
 lastReadDate : Long , 
 isHidden : Boolean , 
 - isFavourite : Boolean 
 + isFavourite : Boolean , 
 + isCreated : Boolean 
 ) extends ProcessorState [ DialogState ] { 
 import DialogEvents . _ 
 override def updated ( e : AnyRef , ts : Instant ) : DialogState = e match { 
 @ @ - 126 , 7 + 114 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 with ActorFutures 
 with ActorStashing { 
 import DialogCommands . _ 
 - import DialogEvents . _ 
 import DialogProcessor . _ 
 
 protected implicit val ec : ExecutionContext = context . dispatcher 
 @ @ - 146 , 49 + 133 , 24 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 protected implicit val sendResponseCache : Cache [ AuthSidRandomId , Future [ SeqStateDate ] ] = 
 createCache [ AuthSidRandomId , Future [ SeqStateDate ] ] ( MaxCacheSize ) 
 
 - override def receive : Receive = initializing 
 + override def preStart ( ) = init ( ) 
 
 - def initializing : Receive = { 
 - case msg ⇒ 
 - stash ( ) 
 - becomeStashing ( replyTo ⇒ ( { 
 - case Initialized ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ⇒ 
 - context become initialized ( DialogState . init ( lastMessageDate , lastReceiveDate , lastReadDate , isHidden , isFavourite ) ) 
 - unstashAll ( ) 
 - case Status . Failure ( e ) ⇒ 
 - log . error ( e , " Failed to init dialog " ) 
 - self ! Kill 
 - } : Receive ) orElse reactions ( isHidden = false ) orElse dummyActions ) 
 - 
 - ( for { 
 - state ← initialState 
 - resultMessage ← state match { 
 - case init : Initialized ⇒ Future . successful ( init ) 
 - case Uninitialized ⇒ 
 - if ( isWriteOperation ( msg ) ) { 
 - log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 - val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 - db . run ( for { 
 - exists ← peer . ` type ` match { 
 - case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 - case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 - } 
 - _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ { peer } does not exist " ) ) 
 - _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 - } yield Initialized . fromDialog ( dialog ) ) 
 - } else { 
 - Future . successful ( msg ) 
 - } 
 - } 
 - } yield resultMessage ) . to ( self , sender ( ) ) 
 - } 
 + def receive = initializing 
 + 
 + def initializing : Receive = receiveStashing ( replyTo ⇒ { 
 + case state : DialogState ⇒ 
 + context become initialized ( state ) 
 + unstashAll ( ) 
 + case Status . Failure ( cause ) ⇒ 
 + log . error ( cause , " Failed to init dialog " ) 
 + self ! Kill 
 + } ) 
 
 - def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( isHidden = state . isHidden ) 
 + def initialized ( state : DialogState ) : Receive = actions ( state ) orElse reactions ( state ) 
 
 / / when receiving this messages , dialog reacts on other dialog ' s action 
 - def reactions ( isHidden : Boolean ) : Receive = { 
 - case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( isHidden , sm ) / / User ' s message been sent 
 + def reactions ( state : DialogState ) : Receive = { 
 + case sm : SendMessage if accepts ( sm ) ⇒ ackSendMessage ( state , sm ) / / User ' s message been sent 
 case mrv : MessageReceived if accepts ( mrv ) ⇒ ackMessageReceived ( mrv ) / / User ' s messages been received 
 case mrd : MessageRead if accepts ( mrd ) ⇒ ackMessageRead ( mrd ) / / User ' s messages been read 
 case sr : SetReaction if accepts ( sr ) ⇒ ackSetReaction ( sr ) 
 @ @ - 196 , 11 + 158 , 6 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case uc : UpdateCounters ⇒ updateCountersChanged ( ) 
 } 
 
 - def dummyActions : Receive = { 
 - case mrv : MessageReceived if invokes ( mrv ) ⇒ Future . successful ( MessageReceivedAck ( ) ) pipeTo sender ( ) 
 - case mrd : MessageRead if invokes ( mrd ) ⇒ Future . successful ( MessageReadAck ( ) ) pipeTo sender ( ) 
 - } 
 - 
 / / when receiving this messages , dialog required to take action 
 def actions ( state : DialogState ) : Receive = { 
 case sm : SendMessage if invokes ( sm ) ⇒ sendMessage ( state , sm ) / / User sends message 
 @ @ - 213 , 8 + 170 , 8 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 case Favourite ( _ ) ⇒ favourite ( state ) 
 case Unfavourite ( _ ) ⇒ unfavourite ( state ) 
 case Delete ( _ ) ⇒ delete ( state ) 
 - case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( date , randomId , message ) 
 - case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( senderUserId , date , randomId , message ) 
 + case WriteMessage ( _ , _ , date , randomId , message ) ⇒ writeMessage ( state , date , randomId , message ) 
 + case WriteMessageSelf ( _ , senderUserId , date , randomId , message ) ⇒ writeMessageSelf ( state , senderUserId , date , randomId , message ) 
 } 
 
 / * * 
 @ @ - 243 , 18 + 200 , 43 @ @ private [ dialog ] final class DialogProcessor ( val userId : Int , val peer : Peer , ext 
 * / 
 private def accepts ( dc : DirectDialogCommand ) = ( dc . dest = = selfPeer ) | | ( ( dc . dest = = peer ) & & ( dc . origin ! = selfPeer ) ) 
 
 - private def isWriteOperation : PartialFunction [ Any , Boolean ] = { 
 - case _ : SendMessage | _ : WriteMessage | _ : WriteMessageSelf ⇒ true 
 - case _ ⇒ false 
 - } 
 - 
 - private def initialState : Future [ InitState ] = 
 - for { 
 + private def init ( ) : Unit = { 
 + ( for { 
 optDialog ← db . run ( DialogRepo . findDialog ( userId , peer ) ) 
 initState ← optDialog match { 
 - case Some ( dialog ) ⇒ Future . successful ( Initialized . fromDialog ( dialog ) ) 
 - case None ⇒ Future . successful ( Uninitialized ) 
 + case Some ( dialog ) ⇒ Future . successful ( DialogState . fromModel ( dialog , isCreated = true ) ) 
 + case None ⇒ Future . successful ( DialogState . fromModel ( DialogModel ( userId , peer ) , isCreated = false ) ) 
 } 
 - } yield initState 
 + } yield initState ) pipeTo self 
 + } 
 + 
 + protected def withCreated ( state : DialogState ) ( f : DialogState ⇒ Unit ) : Unit = { 
 + if ( state . isCreated ) f ( state ) 
 + else { 
 + log . debug ( " Creating dialog for userId : { } , peer : { } " , userId , peer ) 
 + val dialog = DialogModel . withLastMessageDate ( userId , peer , new DateTime ) 
 + val replyTo = sender ( ) 
 + 
 + db . run ( for { 
 + exists ← peer . ` type ` match { 
 + case PeerType . Private ⇒ UserRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case PeerType . Group ⇒ GroupRepo . find ( peer . id ) map ( _ . isDefined ) 
 + case unknown ⇒ DBIO . failed ( new RuntimeException ( s " Unknown peer type $ unknown " ) ) 
 + } 
 + _ ← if ( exists ) DialogRepo . create ( dialog ) else DBIO . failed ( new RuntimeException ( s " Entity $ peer does not exist " ) ) 
 + _ ← DBIO . from ( userExt . notifyDialogsChanged ( userId ) ) 
 + } yield DialogState . fromModel ( dialog , isCreated = true ) ) . to ( self , replyTo ) 
 + 
 + becomeStashing ( replyTo ⇒ { 
 + case state : DialogState ⇒ 
 + context become initialized ( state ) 
 + unstashAll ( ) 
 + f ( state ) 
 + case Status . Failure ( e ) ⇒ 
 + log . error ( e , " Failed to create dialog " ) 
 + self ! Kill 
 + } , discardOld = true ) 
 + } 
 + } 
 
 } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 index 797646d . . 962bb84 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogCommonOperations . scala 
 @ @ - 10 , 11 + 10 , 13 @ @ import scala . concurrent . ExecutionContext 
 object DialogCommonRepo { 
 val dialogCommon = TableQuery [ DialogCommonTable ] 
 
 - private def byPK ( dialogId : Rep [ String ] ) = { 
 + private def byPK ( dialogId : Rep [ String ] ) = 
 dialogCommon . filter ( _ . dialogId = = = dialogId ) 
 - } 
 + 
 + private def exists ( dialogId : Rep [ String ] ) = byPK ( dialogId ) . exists 
 
 val byPKC = Compiled ( byPK _ ) 
 + val existsC = Compiled ( exists _ ) 
 } 
 
 trait DialogCommonOperations extends DialogId { 
 @ @ - 23 , 8 + 25 , 7 @ @ trait DialogCommonOperations extends DialogId { 
 def findCommon ( userId : Option [ Int ] , peer : Peer ) : DBIO [ Option [ DialogCommon ] ] = 
 byPKC . applied ( getDialogId ( userId , peer ) ) . result . headOption 
 
 - def commonExists ( dialogId : String ) = 
 - byPKC . applied ( dialogId ) . exists . result 
 + def commonExists ( dialogId : String ) = existsC ( dialogId ) . result 
 
 def updateLastMessageDatePrivate ( userId : Int , peer : Peer , lastMessageDate : DateTime ) ( implicit ec : ExecutionContext ) = { 
 requirePrivate ( peer ) 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 index 1befed8 . . b478eba 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / dialog / DialogRepo . scala 
 @ @ - 8 , 6 + 8 , 7 @ @ import org . joda . time . DateTime 
 import slick . lifted . ColumnOrdered 
 
 import scala . concurrent . ExecutionContext 
 + import scala . util . { Success , Failure } 
 
 final class DialogCommonTable ( tag : Tag ) extends Table [ DialogCommon ] ( tag , " dialog _ commons " ) { 
 
 @ @ - 151 , 7 + 152 , 16 @ @ object DialogRepo extends UserDialogOperations with DialogCommonOperations { 
 UserDialogRepo . userDialogs + = user 
 } else { 
 for { 
 - c ← DialogCommonRepo . dialogCommon + = common 
 + c ← ( DialogCommonRepo . dialogCommon + = common ) 
 + . asTry 
 + . flatMap { 
 + case Failure ( e ) ⇒ 
 + commonExists ( common . dialogId ) flatMap { 
 + case true ⇒ DBIO . successful ( 1 ) 
 + case false ⇒ DBIO . failed ( e ) 
 + } 
 + case Success ( res ) ⇒ DBIO . successful ( res ) 
 + } 
 _ ← UserDialogRepo . userDialogs + = user 
 } yield c 
 }
