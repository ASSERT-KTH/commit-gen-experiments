BLEU SCORE: 0.1171291646655074

TEST MSG: fix ( server : messaging ) : don ' t swallow message in DialogState if it has the same date as the lates one
GENERATED MSG: fix ( server : core ) : stash messages on dialog send

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 4523646 . . e992d97 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 45 , 7 + 45 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > < nl > withValidAccessHash ( sm . getDest , sm . senderAuthId map ( _ . value ) , sm . accessHash map ( _ . value ) ) { < nl > withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > - val sendDate = calcSendDate ( state ) < nl > + val sendDate = calcSendDate < nl > val message = sm . message < nl > PubSubExtension ( system ) . publish ( PeerMessage ( sm . getOrigin , sm . getDest , sm . randomId , sendDate , message ) ) < nl > < nl > @ @ - 212 , 12 + 212 , 12 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > * When ` candidate ` date is same as last message date , we increment ` candidate ` value by 1 , < nl > * thus resulting date can possibly be in future < nl > * < nl > - * @ param state current dialog state < nl > * @ return unique message date in current dialog < nl > * / < nl > - private def calcSendDate ( state : DialogState ) : Long = { < nl > - val candidate = Instant . now . toEpochMilli < nl > - if ( state . lastMessageDate . toEpochMilli = = candidate ) state . lastMessageDate . toEpochMilli + 1 else candidate < nl > + private def calcSendDate ( ) : Long = { < nl > + val candidate = state . nextDate . toEpochMilli < nl > + if ( state . lastMessageDate . toEpochMilli = = candidate ) state . lastMessageDate . toEpochMilli + 1 < nl > + else candidate < nl > } < nl > < nl > / * * < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > index 90cdc4b . . 11a47a1 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala < nl > @ @ - 23 , 8 + 23 , 7 @ @ trait DialogQuery { < nl > private object UnreadMessage { < nl > val OrderingAsc = new Ordering [ UnreadMessage ] { < nl > override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = < nl > - if ( x . randomId = = y . randomId ) 0 < nl > - else if ( x . date . isBefore ( y . date ) ) - 1 < nl > + if ( x . date . isBefore ( y . date ) ) - 1 < nl > else if ( x . date . isAfter ( y . date ) ) 1 < nl > else 0 < nl > } < nl > @ @ - 129 , 4 + 128 , 10 @ @ private [ dialog ] final case class DialogState ( < nl > counter = counter , < nl > unreadMessages = unreadMessagesMap < nl > ) < nl > + < nl > + private [ dialog ] def nextDate : Instant = { < nl > + val now = Instant . now ( ) < nl > + if ( unreadMessages . lastOption . exists ( _ . date = = now ) ) now . plusMillis ( 1L ) < nl > + else now < nl > + } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 838c001 . . 5903fd3 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 26 , 7 + 26 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > import DialogEvents . _ < nl > < nl > protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { < nl > - ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > + val sendFuture = ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { < nl > for { < nl > _ ← dialogExt . ackSendMessage ( peer , sm ) < nl > message = sm . message < nl > @ @ - 38 , 12 + 38 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { < nl > case e ⇒ < nl > log . error ( e , " Failed to send message " ) < nl > throw e < nl > - } ) pipeTo sender ( ) onSuccess { < nl > - case _ ⇒ < nl > - if ( state . isHidden ) < nl > - self . tell ( Show ( peer ) , ActorRef . noSender ) < nl > + } ) pipeTo sender ( ) < nl > + onSuccess ( sendFuture ) { result ⇒ < nl > + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } < nl > + updateMessageDate ( state , sm . date , checkOpen = true ) < nl > } < nl > - updateMessageDate ( state , sm . date , checkOpen = true ) < nl > } < nl > < nl > protected def updateCountersChanged ( ) : Unit = {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 4523646 . . e992d97 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 45 , 7 + 45 , 7 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 
 withValidAccessHash ( sm . getDest , sm . senderAuthId map ( _ . value ) , sm . accessHash map ( _ . value ) ) { 
 withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 - val sendDate = calcSendDate ( state ) 
 + val sendDate = calcSendDate 
 val message = sm . message 
 PubSubExtension ( system ) . publish ( PeerMessage ( sm . getOrigin , sm . getDest , sm . randomId , sendDate , message ) ) 
 
 @ @ - 212 , 12 + 212 , 12 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 * When ` candidate ` date is same as last message date , we increment ` candidate ` value by 1 , 
 * thus resulting date can possibly be in future 
 * 
 - * @ param state current dialog state 
 * @ return unique message date in current dialog 
 * / 
 - private def calcSendDate ( state : DialogState ) : Long = { 
 - val candidate = Instant . now . toEpochMilli 
 - if ( state . lastMessageDate . toEpochMilli = = candidate ) state . lastMessageDate . toEpochMilli + 1 else candidate 
 + private def calcSendDate ( ) : Long = { 
 + val candidate = state . nextDate . toEpochMilli 
 + if ( state . lastMessageDate . toEpochMilli = = candidate ) state . lastMessageDate . toEpochMilli + 1 
 + else candidate 
 } 
 
 / * * 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 index 90cdc4b . . 11a47a1 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogState . scala 
 @ @ - 23 , 8 + 23 , 7 @ @ trait DialogQuery { 
 private object UnreadMessage { 
 val OrderingAsc = new Ordering [ UnreadMessage ] { 
 override def compare ( x : UnreadMessage , y : UnreadMessage ) : Int = 
 - if ( x . randomId = = y . randomId ) 0 
 - else if ( x . date . isBefore ( y . date ) ) - 1 
 + if ( x . date . isBefore ( y . date ) ) - 1 
 else if ( x . date . isAfter ( y . date ) ) 1 
 else 0 
 } 
 @ @ - 129 , 4 + 128 , 10 @ @ private [ dialog ] final case class DialogState ( 
 counter = counter , 
 unreadMessages = unreadMessagesMap 
 ) 
 + 
 + private [ dialog ] def nextDate : Instant = { 
 + val now = Instant . now ( ) 
 + if ( unreadMessages . lastOption . exists ( _ . date = = now ) ) now . plusMillis ( 1L ) 
 + else now 
 + } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 838c001 . . 5903fd3 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 26 , 7 + 26 , 7 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 import DialogEvents . _ 
 
 protected def sendMessage ( state : DialogState , sm : SendMessage ) : Unit = { 
 - ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 + val sendFuture = ( withCachedFuture [ AuthSidRandomId , SeqStateDate ] ( sm . senderAuthSid → sm . randomId ) { 
 for { 
 _ ← dialogExt . ackSendMessage ( peer , sm ) 
 message = sm . message 
 @ @ - 38 , 12 + 38 , 11 @ @ trait DialogCommandHandlers extends UpdateCounters with PeersImplicits { 
 case e ⇒ 
 log . error ( e , " Failed to send message " ) 
 throw e 
 - } ) pipeTo sender ( ) onSuccess { 
 - case _ ⇒ 
 - if ( state . isHidden ) 
 - self . tell ( Show ( peer ) , ActorRef . noSender ) 
 + } ) pipeTo sender ( ) 
 + onSuccess ( sendFuture ) { result ⇒ 
 + if ( state . isHidden ) { self . tell ( Show ( peer ) , ActorRef . noSender ) } 
 + updateMessageDate ( state , sm . date , checkOpen = true ) 
 } 
 - updateMessageDate ( state , sm . date , checkOpen = true ) 
 } 
 
 protected def updateCountersChanged ( ) : Unit = {
