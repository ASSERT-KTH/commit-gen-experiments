BLEU SCORE: 0.177655053068759

TEST MSG: feat ( server ) : webrtc calls api
GENERATED MSG: feat ( server : stickers ) : sticker service initial implementation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json < nl > index 1d17e98 . . 7ff86cd 100644 < nl > - - - a / actor - server / actor - core / src / main / actor - api / actor . json < nl > + + + b / actor - server / actor - core / src / main / actor - api / actor . json < nl > @ @ - 30 , 6 + 30 , 14 @ @ < nl > { < nl > " type " : " int32 " , < nl > " alias " : " groupId " < nl > + } , < nl > + { < nl > + " type " : " int32 " , < nl > + " alias " : " keyId " < nl > + } , < nl > + { < nl > + " type " : " int32 " , < nl > + " alias " : " keyGroupId " < nl > } < nl > ] , < nl > " sections " : [ < nl > @ @ - 11324 , 7 + 11332 , 7 @ @ < nl > } , < nl > { < nl > " type " : " reference " , < nl > - " argument " : " package " , < nl > + " argument " : " content " , < nl > " category " : " full " , < nl > " description " : " Signaling raw package " < nl > } < nl > @ @ - 11338 , 7 + 11346 , 7 @ @ < nl > { < nl > " type " : " bytes " , < nl > " id " : 2 , < nl > - " name " : " package " < nl > + " name " : " content " < nl > } < nl > ] < nl > } < nl > @ @ - 11383 , 6 + 11391 , 65 @ @ < nl > { < nl > " type " : " rpc " , < nl > " content " : { < nl > + " name " : " DoCall " , < nl > + " header " : 2597 , < nl > + " response " : { < nl > + " type " : " anonymous " , < nl > + " header " : 2598 , < nl > + " doc " : [ < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " callId " , < nl > + " category " : " full " , < nl > + " description " : " Call Id " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 1 , < nl > + " name " : " callId " < nl > + } < nl > + ] < nl > + } , < nl > + " doc " : [ < nl > + " Do Call . Right after a call client need to start sending CallInProgress " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " peer " , < nl > + " category " : " full " , < nl > + " description " : " destination peer " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " timeout " , < nl > + " category " : " hidden " , < nl > + " description " : " Call timeout " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " OutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " peer " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " sec " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " timeout " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > " name " : " EndCall " , < nl > " header " : 2595 , < nl > " response " : { < nl > @ @ - 11447 , 6 + 11514 , 44 @ @ < nl > } < nl > ] < nl > } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " SendCallSignal " , < nl > + " header " : 2599 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " Void " < nl > + } , < nl > + " doc " : [ < nl > + " Sending call signal message " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " callId " , < nl > + " category " : " full " , < nl > + " description " : " Call Id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " content " , < nl > + " category " : " full " , < nl > + " description " : " Signaling raw package " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 1 , < nl > + " name " : " callId " < nl > + } , < nl > + { < nl > + " type " : " bytes " , < nl > + " id " : 2 , < nl > + " name " : " content " < nl > + } < nl > + ] < nl > + } < nl > } < nl > ] < nl > } , < nl > @ @ - 12200 , 14 + 12305 , 420 @ @ < nl > " package " : " encryption " , < nl > " doc " : [ < nl > " Package that include encryption support " , < nl > - " Key types : " , < nl > - " * Curve25519 - https : / / en . wikipedia . org / wiki / Curve25519 " , < nl > - " * Ed25519 - http : / / ed25519 . cr . yp . to / " , < nl > - " * RSA2048 " , < nl > - " * RSA4096 " < nl > + " Key alg types : " , < nl > + " * curve25519 - https : / / en . wikipedia . org / wiki / Curve25519 " , < nl > + " * rsa - 2048 " , < nl > + " * rsa - 4096 " , < nl > + " * aes - 128 " , < nl > + " * kuznechik - 128 " < nl > ] , < nl > " items " : [ < nl > { < nl > + " type " : " comment " , < nl > + " content " : " Public Keys " < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " EncryptionPublicKeyGroup " , < nl > + " doc " : [ < nl > + " Encryption Key Group " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroupId " , < nl > + " category " : " full " , < nl > + " description " : " Key Group Id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " publicKeys " , < nl > + " category " : " hidden " , < nl > + " description " : " Public keys of Key Group " < nl > + } < nl > + ] , < nl > + " expandable " : " true " , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " keyGroupId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " keyGroupId " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " EncryptionPublicKey " < nl > + } < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " publicKeys " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " EncryptionPublicKey " , < nl > + " doc " : [ < nl > + " Encryption Public Key " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyId " , < nl > + " category " : " full " , < nl > + " description " : " Key Id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyAlg " , < nl > + " category " : " full " , < nl > + " description " : " Key Algorithm " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyMaterial " , < nl > + " category " : " compact " , < nl > + " description " : " Public key material . Can be null , but always not null for LoadPublicKey " < nl > + } < nl > + ] , < nl > + " expandable " : " true " , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 1 , < nl > + " name " : " keyId " < nl > + } , < nl > + { < nl > + " type " : " string " , < nl > + " id " : 2 , < nl > + " name " : " keyAlg " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bytes " < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " keyMaterial " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bytes " < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " keyHash " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " response " , < nl > + " content " : { < nl > + " name " : " PublicKeys " , < nl > + " header " : 2602 , < nl > + " doc " : [ < nl > + " Public Keys response " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " publicKey " , < nl > + " category " : " full " , < nl > + " description " : " Public keys " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " EncryptionPublicKey " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " publicKey " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " response " , < nl > + " content " : { < nl > + " name " : " PublicKeyGroups " , < nl > + " header " : 2604 , < nl > + " doc " : [ < nl > + " Public key groups response " < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " EncryptionPublicKeyGroup " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " publicKeyGroups " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadPublicKeyGroups " , < nl > + " header " : 2601 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " PublicKeyGroups " < nl > + } , < nl > + " doc " : [ < nl > + " Loading Public key groups " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " userPeer " , < nl > + " category " : " full " , < nl > + " description " : " User ' s peer " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " userPeer " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadPublicKey " , < nl > + " header " : 2605 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " PublicKeys " < nl > + } , < nl > + " doc " : [ < nl > + " Loading public key explictly " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " userPeer " , < nl > + " category " : " full " , < nl > + " description " : " User ' s peer " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroupId " , < nl > + " category " : " full " , < nl > + " description " : " Key group ' s id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyIds " , < nl > + " category " : " full " , < nl > + " description " : " Key ids for loading " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " userPeer " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " keyGroupId " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : " int64 " < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " keyIds " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadEphermalPublicKeys " , < nl > + " header " : 2603 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " PublicKeys " < nl > + } , < nl > + " doc " : [ < nl > + " Loading ephermal public keys " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " userPeer " , < nl > + " category " : " full " , < nl > + " description " : " User ' s peer " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroupId " , < nl > + " category " : " full " , < nl > + " description " : " User ' s key group id " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " UserOutPeer " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " userPeer " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " keyGroupId " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " PublicKeyGroupChanged " , < nl > + " header " : 103 , < nl > + " doc " : [ < nl > + " Update about public key group changed " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User ' s id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroup " , < nl > + " category " : " full " , < nl > + " description " : " Updated Key Group " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " EncryptionPublicKeyGroup " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " keyGroup " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " PublicKeyGroupAdded " , < nl > + " header " : 104 , < nl > + " doc " : [ < nl > + " Update about public key group added " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User ' s id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroup " , < nl > + " category " : " full " , < nl > + " description " : " Added Key Group " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " EncryptionPublicKeyGroup " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " keyGroup " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " PublicKeyGroupRemoved " , < nl > + " header " : 105 , < nl > + " doc " : [ < nl > + " Update about public key group removed " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " uid " , < nl > + " category " : " full " , < nl > + " description " : " User ' s id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " keyGroupId " , < nl > + " category " : " hidden " , < nl > + " description " : " Removed Key Group Id " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " userId " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " uid " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " keyGroupId " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " keyGroupId " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " comment " , < nl > + " content " : " Device Side " < nl > + } , < nl > + { < nl > " type " : " struct " , < nl > " content " : { < nl > " name " : " EncryptionDevice " , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > index e2279cb . . 759781e 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala < nl > @ @ - 95 , 7 + 95 , 7 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , < nl > seqUpdExt . subscribe ( userId , self ) pipeTo self < nl > } < nl > case SubscribeToWeak ⇒ < nl > - weakUpdatesExt . subscribe ( authId , self ) onFailure { < nl > + weakUpdatesExt . subscribe ( authId , self , None ) onFailure { < nl > case e ⇒ < nl > self ! SubscribeToWeak < nl > log . error ( e , " Failed to subscribe to weak updates " ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala < nl > index 0d29157 . . 95c95dc 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala < nl > @ @ - 22 , 10 + 22 , 10 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt < nl > private val region = WeakUpdatesManagerRegion . startRegion ( ) ( system ) < nl > private lazy val userExt = UserExtension ( system ) < nl > < nl > - def broadcastUserWeakUpdate ( userId : Int , update : Update , reduceKey : Option [ String ] ) : Future [ Unit ] = { < nl > + def broadcastUserWeakUpdate ( userId : Int , update : Update , reduceKey : Option [ String ] , group : Option [ String ] = None ) : Future [ Unit ] = { < nl > val header = update . header < nl > val serializedData = update . toByteArray < nl > - val msg = PushUpdate ( header , serializedData , reduceKey ) < nl > + val msg = PushUpdate ( header , serializedData , reduceKey , group ) < nl > < nl > for ( authIds ← userExt . getAuthIds ( userId ) ) yield { < nl > authIds foreach { authId ⇒ < nl > @ @ - 34 , 10 + 34 , 10 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt < nl > } < nl > } < nl > < nl > - def pushUpdate ( authId : Long , update : Update , reduceKey : Option [ String ] ) : Unit = { < nl > + def pushUpdate ( authId : Long , update : Update , reduceKey : Option [ String ] , group : Option [ String ] ) : Unit = { < nl > val header = update . header < nl > val serializedData = update . toByteArray < nl > - region . ref ! Envelope ( authId , PushUpdate ( header , serializedData , reduceKey ) ) < nl > + region . ref ! Envelope ( authId , PushUpdate ( header , serializedData , reduceKey , group ) ) < nl > } < nl > < nl > def reduceKey ( updateHeader : Int , peer : ApiPeer ) : String = s " $ updateHeader - $ { peer . ` type ` . id } - $ { peer . id } " < nl > @ @ - 48 , 9 + 48 , 8 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt < nl > < nl > def reduceKeyGroup ( updateHeader : Int , groupId : Int ) : String = s " $ updateHeader - $ { ApiPeerType . Group . id } - $ groupId " < nl > < nl > - private [ sequence ] def subscribe ( authId : Long , consumer : ActorRef ) : Future [ Unit ] = < nl > - region . ref . ask ( Envelope ( authId , Subscribe ( consumer ) ) ) . mapTo [ SubscribeAck ] . map ( _ ⇒ ( ) ) < nl > - < nl > + private [ sequence ] def subscribe ( authId : Long , consumer : ActorRef , group : Option [ String ] ) : Future [ Unit ] = < nl > + region . ref . ask ( Envelope ( authId , Subscribe ( consumer , group : Option [ String ] ) ) ) . mapTo [ SubscribeAck ] . map ( _ ⇒ ( ) ) < nl > } < nl > < nl > object WeakUpdatesExtension extends ExtensionId [ WeakUpdatesExtensionImpl ] with ExtensionIdProvider { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala < nl > index 502bdc1 . . 1bcb628 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala < nl > @ @ - 6 , 21 + 6 , 21 @ @ import im . actor . api . rpc . sequence . WeakUpdate < nl > object WeakUpdatesManager { < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - private [ sequence ] case class Envelope ( authId : Long , payload : Message ) < nl > + private [ sequence ] final case class Envelope ( authId : Long , payload : Message ) < nl > < nl > private [ sequence ] sealed trait Message < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - private [ sequence ] case class PushUpdate ( header : Int , serializedData : Array [ Byte ] , reduceKey : Option [ String ] ) extends Message < nl > + private [ sequence ] final case class PushUpdate ( header : Int , serializedData : Array [ Byte ] , reduceKey : Option [ String ] , group : Option [ String ] ) extends Message < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - private [ sequence ] case class Subscribe ( consumer : ActorRef ) extends Message < nl > + private [ sequence ] final case class Subscribe ( consumer : ActorRef , group : Option [ String ] ) extends Message < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - private [ sequence ] case class SubscribeAck ( consumer : ActorRef ) extends Message < nl > + private [ sequence ] final case class SubscribeAck ( subscribe : Subscribe ) extends Message < nl > < nl > @ SerialVersionUID ( 1L ) < nl > - case class UpdateReceived ( update : WeakUpdate , reduceKey : Option [ String ] ) < nl > + final case class UpdateReceived ( update : WeakUpdate , reduceKey : Option [ String ] ) < nl > < nl > def props = Props ( classOf [ WeakUpdatesManager ] ) < nl > } < nl > @ @ - 29 , 21 + 29 , 33 @ @ private final class WeakUpdatesManager extends Actor with ActorLogging { < nl > < nl > import WeakUpdatesManager . _ < nl > < nl > + type ConsumerDescriptor = ( ActorRef , Option [ String ] ) < nl > + < nl > / / TODO : set receive timeout < nl > < nl > def receive = working ( Set . empty ) < nl > < nl > - def working ( consumers : Set [ ActorRef ] ) : Receive = { < nl > - case Envelope ( authId , PushUpdate ( header , serializedData , reduceKey ) ) ⇒ < nl > + def working ( consumers : Set [ ConsumerDescriptor ] ) : Receive = { < nl > + case Envelope ( authId , PushUpdate ( header , serializedData , reduceKey , groupOpt ) ) ⇒ < nl > val event = UpdateReceived ( WeakUpdate ( System . currentTimeMillis ( ) , header , serializedData ) , reduceKey ) < nl > - consumers foreach ( _ ! event ) < nl > - case Envelope ( _ , Subscribe ( consumer ) ) ⇒ < nl > + < nl > + groupOpt match { < nl > + case Some ( group ) ⇒ < nl > + consumers . view < nl > + . filter ( _ . _ 2 . exists ( _ = = group ) ) < nl > + . map ( _ . _ 1 ) < nl > + . foreach ( _ ! event ) < nl > + case None ⇒ < nl > + consumers . foreach ( _ . _ 1 ! event ) < nl > + } < nl > + case Envelope ( _ , sub @ Subscribe ( consumer , groupOpt ) ) ⇒ < nl > context . watch ( consumer ) < nl > - context . become ( working ( consumers + consumer ) ) < nl > - sender ( ) ! SubscribeAck ( consumer ) < nl > + < nl > + context . become ( working ( consumers + ( consumer → groupOpt ) ) ) < nl > + sender ( ) ! SubscribeAck ( sub ) < nl > < nl > log . debug ( " Consumer subscribed { } " , consumer ) < nl > case Terminated ( consumer ) ⇒ < nl > - context . become ( working ( consumers - consumer ) ) < nl > + context . become ( working ( consumers . filterNot ( _ . _ 1 = = consumer ) ) ) < nl > } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > new file mode 100644 < nl > index 0000000 . . 0ffc3f7 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala < nl > @ @ - 0 , 0 + 1 , 145 @ @ < nl > + package im . actor . server . webrtc < nl > + < nl > + import akka . actor . _ < nl > + import akka . pattern . pipe < nl > + import im . actor . api . rpc . messaging . { ApiServiceMessage , ApiServiceExPhoneCall } < nl > + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } < nl > + import im . actor . api . rpc . webrtc . _ < nl > + import im . actor . concurrent . ActorStashing < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . dialog . DialogExtension < nl > + import im . actor . server . persist . webrtc . WebrtcCallRepo < nl > + import im . actor . server . sequence . { WeakUpdatesExtension , SeqUpdatesExtension } < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . concurrent . duration . _ < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + < nl > + sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( message ) < nl > + < nl > + object WebrtcCallErrors { < nl > + object NotAParticipant extends WebrtcCallError ( " Not participant " ) < nl > + } < nl > + < nl > + sealed trait WebrtcCallMessages < nl > + < nl > + object WebrtcCallMessages { < nl > + final case class StartCall ( callerUserId : Int , receiverUserId : Int ) extends WebrtcCallMessages < nl > + case object CallStarted < nl > + < nl > + final case class CallInProgress ( userId : Int , timeout : Int ) extends WebrtcCallMessages < nl > + < nl > + final case class CallSignal ( userId : Int , pkg : Array [ Byte ] ) extends WebrtcCallMessages < nl > + < nl > + case class EndCall ( userId : Int ) extends WebrtcCallMessages < nl > + } < nl > + < nl > + final case class WebrtcCallEnvelope ( id : Long , message : WebrtcCallMessages ) < nl > + < nl > + object WebrtcCallActor { < nl > + val RegionTypeName = " WebrtcCall " < nl > + val DefaultCallTimeout = 30 . seconds < nl > + < nl > + def props = Props ( classOf [ WebrtcCallActor ] ) < nl > + } < nl > + < nl > + private final class WebrtcCallActor extends ActorStashing with ActorLogging { < nl > + import WebrtcCallMessages . _ < nl > + import WebrtcCallActor . _ < nl > + import context . dispatcher < nl > + < nl > + private val id = self . path . name . toLong < nl > + < nl > + private lazy val weakUpdExt = WeakUpdatesExtension ( context . system ) < nl > + private lazy val dialogExt = DialogExtension ( context . system ) < nl > + private val db = DbExtension ( context . system ) . db < nl > + < nl > + def receive = waitForStart < nl > + < nl > + def waitForStart : Receive = { < nl > + case StartCall ( callerUserId , receiverUserId ) ⇒ < nl > + val update = UpdateIncomingCall ( id , callerUserId ) < nl > + < nl > + ( for { < nl > + _ ← db . run ( WebrtcCallRepo . create ( WebrtcCall ( id , callerUserId , receiverUserId ) ) ) < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None , Some ( Webrtc . WeakGroup ) ) < nl > + } yield ( ) ) pipeTo self < nl > + < nl > + becomeStashing ( replyTo ⇒ { < nl > + case ( ) ⇒ < nl > + replyTo ! CallStarted < nl > + context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) ) < nl > + unstashAll ( ) < nl > + case failure : Status . Failure ⇒ < nl > + replyTo forward failure < nl > + throw failure . cause < nl > + } , discardOld = true ) < nl > + } < nl > + < nl > + def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEnd : Cancellable ) : Receive = { < nl > + def end ( ) : Future [ Unit ] = { < nl > + val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt < nl > + val update = UpdateCallEnded ( id ) < nl > + < nl > + for { < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , None ) < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None ) < nl > + _ ← dialogExt . sendMessage ( < nl > + peer = ApiPeer ( ApiPeerType . Private , receiverUserId ) , < nl > + senderUserId = callerUserId , < nl > + senderAuthSid = 0 , < nl > + randomId = ThreadLocalRandom . current ( ) . nextLong , < nl > + message = ApiServiceMessage ( " Call ended " , Some ( ApiServiceExPhoneCall ( duration ) ) ) < nl > + ) < nl > + _ ← db . run ( WebrtcCallRepo . delete ( id ) ) < nl > + } yield ( ) < nl > + } < nl > + < nl > + def withOrigin ( origin : Int ) ( f : Int ⇒ Any ) = < nl > + if ( callerUserId = = origin ) < nl > + f ( receiverUserId ) < nl > + else if ( receiverUserId = = origin ) < nl > + f ( callerUserId ) < nl > + else < nl > + sender ( ) ! Status . Failure ( WebrtcCallErrors . NotAParticipant ) < nl > + < nl > + { < nl > + case CallInProgress ( userId , timeout ) ⇒ < nl > + withOrigin ( userId ) { _ ⇒ < nl > + scheduledEnd . cancel ( ) < nl > + scheduleEnd ( timeout . seconds ) < nl > + val update = UpdateCallInProgress ( id , timeout ) < nl > + < nl > + ( for { < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > + _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > + } yield ( ) ) pipeTo self < nl > + < nl > + becomeStashing ( replyTo ⇒ { < nl > + case ( ) ⇒ < nl > + context . unbecome ( ) < nl > + unstashAll ( ) < nl > + case failure : Status . Failure ⇒ < nl > + end ( ) < nl > + throw failure . cause < nl > + } , discardOld = false ) < nl > + } < nl > + case CallSignal ( userId , pkg ) ⇒ < nl > + withOrigin ( userId ) { target ⇒ < nl > + / / TODO : stashing < nl > + val update = UpdateCallSignal ( id , pkg ) < nl > + weakUpdExt . broadcastUserWeakUpdate ( target , update , Some ( s " webrtc _ call _ signal _ $ id " ) , Some ( Webrtc . WeakGroup ) ) < nl > + } < nl > + case EndCall ( userId ) ⇒ < nl > + withOrigin ( userId ) { _ ⇒ < nl > + scheduledEnd . cancel ( ) < nl > + < nl > + end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onFailure { < nl > + case e ⇒ log . error ( e , " Failed to end call " ) < nl > + } < nl > + } < nl > + } < nl > + } < nl > + < nl > + def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala < nl > new file mode 100644 < nl > index 0000000 . . da62a6f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala < nl > @ @ - 0 , 0 + 1 , 55 @ @ < nl > + package im . actor . server . webrtc < nl > + < nl > + import akka . actor . _ < nl > + import akka . pattern . ask < nl > + import akka . cluster . sharding . ShardRegion . { ExtractShardId , ExtractEntityId } < nl > + import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding } < nl > + import akka . util . Timeout < nl > + import im . actor . config . ActorConfig < nl > + < nl > + import scala . concurrent . Future < nl > + import scala . concurrent . forkjoin . ThreadLocalRandom < nl > + < nl > + object Webrtc { < nl > + val WeakGroup = " webrtc _ calls " < nl > + } < nl > + < nl > + final class WebrtcExtension ( system : ActorSystem ) extends Extension { < nl > + import im . actor . server . webrtc . WebrtcCallMessages . _ < nl > + import system . dispatcher < nl > + < nl > + private implicit val timeout : Timeout = Timeout ( ActorConfig . defaultTimeout ) < nl > + < nl > + private val extractEntityId : ExtractEntityId = { < nl > + case WebrtcCallEnvelope ( id , message ) ⇒ ( id . toString , message ) < nl > + } < nl > + < nl > + private val extractShardId : ExtractShardId = { < nl > + case WebrtcCallEnvelope ( id , _ ) ⇒ ( id % 100 ) . toString < nl > + } < nl > + < nl > + private val region = < nl > + ClusterSharding ( system ) < nl > + . start ( " WebrtcCall " , WebrtcCallActor . props , ClusterShardingSettings ( system ) , extractEntityId , extractShardId ) < nl > + < nl > + def doCall ( callerUserId : Int , receiverUserId : Int ) : Future [ Long ] = { < nl > + val callId = ThreadLocalRandom . current ( ) . nextLong ( ) < nl > + < nl > + region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId ) ) map ( _ ⇒ callId ) < nl > + } < nl > + < nl > + def endCall ( userId : Int , callId : Long ) : Future [ Unit ] = < nl > + region ? WebrtcCallEnvelope ( callId , EndCall ( userId ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def sendCallSignal ( userId : Int , callId : Long , content : Array [ Byte ] ) : Future [ Unit ] = < nl > + region ? WebrtcCallEnvelope ( callId , CallSignal ( userId , content ) ) map ( _ ⇒ ( ) ) < nl > + < nl > + def sendCallInProgress ( userId : Int , callId : Long , ptimeout : Int ) : Future [ Unit ] = < nl > + region ? WebrtcCallEnvelope ( callId , CallInProgress ( userId , ptimeout ) ) map ( _ ⇒ ( ) ) < nl > + } < nl > + < nl > + object WebrtcExtension extends ExtensionIdProvider with ExtensionId [ WebrtcExtension ] { < nl > + override def lookup ( ) : ExtensionId [ _ < : Extension ] = WebrtcExtension < nl > + < nl > + override def createExtension ( system : ExtendedActorSystem ) : WebrtcExtension = new WebrtcExtension ( system ) < nl > + } < nl > diff - - git a / actor - server / actor - models / src / main / protobuf / model / webrtc . proto b / actor - server / actor - models / src / main / protobuf / model / webrtc . proto < nl > new file mode 100644 < nl > index 0000000 . . cee383f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - models / src / main / protobuf / model / webrtc . proto < nl > @ @ - 0 , 0 + 1 , 15 @ @ < nl > + syntax = ' proto3 ' ; < nl > + < nl > + package im . actor . server ; < nl > + < nl > + import " scalapb / scalapb . proto " ; < nl > + < nl > + option ( scalapb . options ) = { < nl > + import : " im . actor . server . model . ModelTypeMappers . _ " < nl > + } ; < nl > + < nl > + message WebrtcCall { < nl > + int64 id = 1 ; < nl > + int32 initiator _ user _ id = 2 ; < nl > + int32 receiver _ user _ id = 3 ; < nl > + } < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql < nl > new file mode 100644 < nl > index 0000000 . . 8cda014 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql < nl > @ @ - 0 , 0 + 1 , 6 @ @ < nl > + CREATE TABLE device _ features ( < nl > + auth _ id BIGINT NOT NULL , < nl > + name TEXT NOT NULL , < nl > + args BYTEA NOT NULL , < nl > + PRIMARY KEY ( auth _ id ) < nl > + ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql < nl > new file mode 100644 < nl > index 0000000 . . 492e29e < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql < nl > @ @ - 0 , 0 + 1 , 6 @ @ < nl > + CREATE TABLE webrtc _ calls ( < nl > + id BIGINT NOT NULL , < nl > + initiator _ user _ id INT NOT NULL , < nl > + receiver _ user _ id INT NOT NULL , < nl > + PRIMARY KEY id < nl > + ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . fd8cea2 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala < nl > @ @ - 0 , 0 + 1 , 28 @ @ < nl > + package im . actor . server . persist . webrtc < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . webrtc . WebrtcCall < nl > + < nl > + final class WebrtcCallTable ( tag : Tag ) extends Table [ WebrtcCall ] ( tag , " webrtc _ calls " ) { < nl > + def id = column [ Long ] ( " id " , O . PrimaryKey ) < nl > + < nl > + def initiatorUserId = column [ Int ] ( " initiator _ user _ id " ) < nl > + < nl > + def receiverUserId = column [ Int ] ( " receiver _ user _ id " ) < nl > + < nl > + def * = ( id , initiatorUserId , receiverUserId ) < > ( ( WebrtcCall . apply _ ) . tupled , WebrtcCall . unapply ) < nl > + } < nl > + < nl > + object WebrtcCallRepo { < nl > + val webrtcCalls = TableQuery [ WebrtcCallTable ] < nl > + < nl > + val byPKC = Compiled { id : Rep [ Long ] ⇒ < nl > + webrtcCalls filter ( _ . id = = = id ) < nl > + } < nl > + < nl > + def create ( call : WebrtcCall ) = webrtcCalls + = call < nl > + < nl > + def find ( id : Long ) = byPKC ( id ) . result . headOption < nl > + < nl > + def delete ( id : Long ) = byPKC ( id ) . delete < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > index 1b5d822 . . 81e5924 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala < nl > @ @ - 1 , 9 + 1 , 10 @ @ < nl > package im . actor . api . rpc < nl > < nl > import im . actor . server . acl . ACLUtils < nl > + import im . actor . server . db . DbExtension < nl > < nl > import scala . collection . immutable < nl > - import scala . concurrent . ExecutionContext < nl > + import scala . concurrent . { Future , ExecutionContext } < nl > import scalaz . _ < nl > < nl > import akka . actor . _ < nl > @ @ - 15 , 6 + 16 , 13 @ @ import im . actor . util . misc . StringUtils < nl > import im . actor . server . { model , persist } < nl > < nl > object PeerHelpers { < nl > + def withOutPeerF [ R < : RpcResponse ] ( < nl > + outPeer : ApiOutPeer < nl > + ) ( < nl > + f : ⇒ Future [ RpcError \ / R ] < nl > + ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : Future [ RpcError \ / R ] = < nl > + DbExtension ( actorSystem ) . db . run ( withOutPeer ( outPeer ) ( DBIO . from ( f ) ) ) < nl > + < nl > def withOutPeer [ R < : RpcResponse ] ( < nl > outPeer : ApiOutPeer < nl > ) ( < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . a58ada7 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 66 @ @ < nl > + package im . actor . server . api . rpc . service . webrtc < nl > + < nl > + import akka . actor . ActorSystem < nl > + import akka . http . scaladsl . util . FastFuture < nl > + import im . actor . api . rpc . _ < nl > + import im . actor . api . rpc . misc . ResponseVoid < nl > + import im . actor . api . rpc . peers . ApiOutPeer < nl > + import im . actor . api . rpc . webrtc . { ResponseDoCall , WebrtcService } < nl > + import im . actor . server . session . _ < nl > + import im . actor . server . webrtc . { WebrtcExtension , Webrtc } < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : SessionRegion ) extends WebrtcService { < nl > + import PeerHelpers . _ < nl > + < nl > + override implicit protected val ec : ExecutionContext = system . dispatcher < nl > + < nl > + val webrtcExt = WebrtcExtension ( system ) < nl > + < nl > + override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = < nl > + authorized ( clientData ) { implicit client ⇒ < nl > + withOutPeerF ( peer ) { < nl > + for { < nl > + callId ← webrtcExt . doCall ( client . userId , peer . id ) < nl > + } yield Ok ( ResponseDoCall ( callId ) ) < nl > + } < nl > + } < nl > + < nl > + override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + _ ← webrtcExt . endCall ( client . userId , callId ) < nl > + } yield Ok ( ResponseVoid ) < nl > + } < nl > + < nl > + override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + sessionRegion . ref ! < nl > + SessionEnvelope ( clientData . authId , clientData . sessionId ) < nl > + . withUnsubscribeFromWeak ( UnsubscribeFromWeak ( Some ( Webrtc . WeakGroup ) ) ) < nl > + FastFuture . successful ( Ok ( ResponseVoid ) ) < nl > + } < nl > + < nl > + override def jhandleCallInProgress ( callId : Long , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + _ ← webrtcExt . sendCallInProgress ( client . userId , callId , timeout ) < nl > + } yield Ok ( ResponseVoid ) < nl > + } < nl > + < nl > + override def jhandleSubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + sessionRegion . ref ! < nl > + SessionEnvelope ( clientData . authId , clientData . sessionId ) < nl > + . withSubscribeToWeak ( SubscribeToWeak ( Some ( Webrtc . WeakGroup ) ) ) < nl > + FastFuture . successful ( Ok ( ResponseVoid ) ) < nl > + } < nl > + < nl > + override def jhandleSendCallSignal ( callId : Long , content : Array [ Byte ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + for { < nl > + _ ← webrtcExt . sendCallSignal ( client . userId , callId , content ) < nl > + } yield Ok ( ResponseVoid ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > index d2aff17 . . 77b49b3 100644 < nl > - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > @ @ - 26 , 7 + 26 , 7 @ @ import im . actor . server . api . rpc . service . users . UsersServiceImpl < nl > import im . actor . server . api . rpc . service . weak . WeakServiceImpl < nl > import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl < nl > import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl < nl > - import im . actor . server . bot . ActorBot < nl > + import im . actor . server . bot . { BotExtension , ActorBot } < nl > import im . actor . server . cli . ActorCliService < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . dialog . { DialogExtension , DialogProcessor } < nl > @ @ - 251 , 6 + 251 , 9 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( < nl > featuresService < nl > ) < nl > < nl > + system . log . warning ( " Starting BotExtension " ) < nl > + BotExtension ( system ) < nl > + < nl > system . log . warning ( " Starting ActorBot " ) < nl > ActorBot . start ( ) < nl > < nl > diff - - git a / actor - server / actor - session - messages / src / main / protobuf / session . proto b / actor - server / actor - session - messages / src / main / protobuf / session . proto < nl > index 1c08672 . . d01c0bd 100644 < nl > - - - a / actor - server / actor - session - messages / src / main / protobuf / session . proto < nl > + + + b / actor - server / actor - session - messages / src / main / protobuf / session . proto < nl > @ @ - 21 , 6 + 21 , 8 @ @ message SessionEnvelope { < nl > SubscribeToGroupOnline subscribe _ to _ group _ online = 7 ; < nl > SubscribeFromGroupOnline subscribe _ from _ group _ online = 8 ; < nl > SubscribeToSeq subscribe _ to _ seq = 9 ; < nl > + SubscribeToWeak subscribe _ to _ weak = 10 ; < nl > + UnsubscribeFromWeak unsubscribe _ from _ weak = 11 ; < nl > } < nl > } < nl > < nl > @ @ - 61 , 4 + 63 , 14 @ @ message SubscribeFromGroupOnline { < nl > < nl > message SubscribeToSeq { < nl > option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; < nl > + } < nl > + < nl > + message SubscribeToWeak { < nl > + option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; < nl > + optional string group = 1 ; < nl > + } < nl > + < nl > + message UnsubscribeFromWeak { < nl > + option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; < nl > + optional string group = 1 ; < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 936187b . . 74e353a 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ < nl > < nl > object Dependencies { < nl > object V { < nl > - val actorCommons = " 0 . 0 . 8 " < nl > + val actorCommons = " 0 . 0 . 9 " < nl > val actorBotkit = " 1 . 0 . 66 " < nl > val akka = " 2 . 4 . 0 " < nl > val akkaExperimental = " 2 . 0 . 2 "
NEAREST DIFF (one line): diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala < nl > index 6137afb . . 8162272 100644 < nl > - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala < nl > + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala < nl > @ @ - 57 , 6 + 57 , 7 @ @ trait ApiToBotConversions { < nl > thumb , < nl > ext ) ⇒ DocumentMessage ( fileId , accessHash , fileSize . toLong , name , mimeType , thumb , ext ) < nl > case ApiServiceMessage ( text , _ ) ⇒ ServiceMessage ( text ) < nl > + case _ : ApiStickerMessage ⇒ UnsupportedMessage < nl > case _ : ApiUnsupportedMessage ⇒ UnsupportedMessage < nl > } < nl > < nl > diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json < nl > index 4cd3afa . . b1c9292 100644 < nl > - - - a / actor - server / actor - core / src / main / actor - api / actor . json < nl > + + + b / actor - server / actor - core / src / main / actor - api / actor . json < nl > @ @ - 3806 , 6 + 3806 , 112 @ @ < nl > { < nl > " type " : " struct " , < nl > " content " : { < nl > + " name " : " StickerMessage " , < nl > + " doc " : [ < nl > + " Sticker message " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " stickerId " , < nl > + " category " : " full " , < nl > + " description " : " Optional Unique ID of sticker " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " fastPreview " , < nl > + " category " : " full " , < nl > + " description " : " Optional Fast preview of sticker in webp format " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " image512 " , < nl > + " category " : " full " , < nl > + " description " : " Optional 512x512 sticker image in webp format " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " image256 " , < nl > + " category " : " full " , < nl > + " description " : " Optional 256x256 sticker image in webp format " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " stickerCollectionId " , < nl > + " category " : " full " , < nl > + " description " : " Optional Collection ID " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " stickerCollectionAccessHash " , < nl > + " category " : " full " , < nl > + " description " : " Optional Collection Access Hash " < nl > + } < nl > + ] , < nl > + " trait " : { < nl > + " name " : " Message " , < nl > + " key " : 6 < nl > + } , < nl > + " expandable " : " true " , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " int32 " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " stickerId " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " bytes " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " fastPreview " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " ImageLocation " < nl > + } < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " image512 " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " ImageLocation " < nl > + } < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " image256 " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " int32 " < nl > + } , < nl > + " id " : 5 , < nl > + " name " : " stickerCollectionId " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " int64 " < nl > + } , < nl > + " id " : 6 , < nl > + " name " : " stickerCollectionAccessHash " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > " name " : " DialogShort " , < nl > " doc " : [ < nl > " Short Dialog from grouped conversation list " , < nl > @ @ - 7649 , 6 + 7755 , 433 @ @ < nl > ] < nl > } , < nl > { < nl > + " title " : " Stickers " , < nl > + " package " : " stickers " , < nl > + " doc " : [ < nl > + " Stickers support in Actor " < nl > + ] , < nl > + " items " : [ < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " StickerDescriptor " , < nl > + " doc " : [ < nl > + " Descriptor of a Sticker " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " id " , < nl > + " category " : " full " , < nl > + " description " : " Sticker unique id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " emoji " , < nl > + " category " : " full " , < nl > + " description " : " Emoji code for sticker " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " image128 " , < nl > + " category " : " full " , < nl > + " description " : " Image of sticker 128x128 in WebP format " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " image512 " , < nl > + " category " : " full " , < nl > + " description " : " Image of sticker 512x512 in WebP format " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " image256 " , < nl > + " category " : " full " , < nl > + " description " : " Image of sticker 256x256 in WebP format " < nl > + } < nl > + ] , < nl > + " expandable " : " true " , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 1 , < nl > + " name " : " id " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : " string " < nl > + } , < nl > + " id " : 2 , < nl > + " name " : " emoji " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " ImageLocation " < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " image128 " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " ImageLocation " < nl > + } < nl > + } , < nl > + " id " : 4 , < nl > + " name " : " image512 " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " opt " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " ImageLocation " < nl > + } < nl > + } , < nl > + " id " : 5 , < nl > + " name " : " image256 " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " struct " , < nl > + " content " : { < nl > + " name " : " StickerCollection " , < nl > + " doc " : [ < nl > + " Sticker collection " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " id " , < nl > + " category " : " full " , < nl > + " description " : " Unique id of a collection " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " accessHash " , < nl > + " category " : " full " , < nl > + " description " : " Access Hash of a collection " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " stickers " , < nl > + " category " : " compact " , < nl > + " description " : " Sticker list " < nl > + } < nl > + ] , < nl > + " expandable " : " true " , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 1 , < nl > + " name " : " id " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " accessHash " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerDescriptor " < nl > + } < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " stickers " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " response " , < nl > + " content " : { < nl > + " name " : " StickersReponse " , < nl > + " header " : 240 , < nl > + " doc " : [ < nl > + " Stickers response " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " collections " , < nl > + " category " : " full " , < nl > + " description " : " Sticker collections " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " seq " , < nl > + " category " : " full " , < nl > + " description " : " Seq of update " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " state " , < nl > + " category " : " full " , < nl > + " description " : " State of update " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerCollection " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " collections " < nl > + } , < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 2 , < nl > + " name " : " seq " < nl > + } , < nl > + { < nl > + " type " : { < nl > + " type " : " alias " , < nl > + " childType " : " seq _ state " < nl > + } , < nl > + " id " : 3 , < nl > + " name " : " state " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadOwnStickers " , < nl > + " header " : 238 , < nl > + " response " : { < nl > + " type " : " anonymous " , < nl > + " header " : 239 , < nl > + " doc " : [ < nl > + " Own Stickers collections " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " ownStickers " , < nl > + " category " : " hidden " , < nl > + " description " : " Own sticker collections " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerCollection " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " ownStickers " < nl > + } < nl > + ] < nl > + } , < nl > + " doc " : [ < nl > + " Loading own stickers " < nl > + ] , < nl > + " attributes " : [ ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " OwnStickersChanged " , < nl > + " header " : 161 , < nl > + " doc " : [ < nl > + " Own Stickers changed " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " collections " , < nl > + " category " : " compact " , < nl > + " description " : " New own sticker collections " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerCollection " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " collections " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " update " , < nl > + " content " : { < nl > + " name " : " StickerCollectionsChanged " , < nl > + " header " : 164 , < nl > + " doc " : [ < nl > + " Sticker collection changed " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " collections " , < nl > + " category " : " full " , < nl > + " description " : " Updated sticker collections " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " list " , < nl > + " childType " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerCollection " < nl > + } < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " collections " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " AddStickerCollection " , < nl > + " header " : 244 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " StickersReponse " < nl > + } , < nl > + " doc " : [ < nl > + " Adding sticker collection " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " id " , < nl > + " category " : " full " , < nl > + " description " : " Collection id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " accessHash " , < nl > + " category " : " full " , < nl > + " description " : " Collection access hash " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 1 , < nl > + " name " : " id " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " accessHash " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " RemoveStickerCollection " , < nl > + " header " : 245 , < nl > + " response " : { < nl > + " type " : " reference " , < nl > + " name " : " StickersReponse " < nl > + } , < nl > + " doc " : [ < nl > + " Removing sticker collection " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " id " , < nl > + " category " : " full " , < nl > + " description " : " Collection id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " accessHash " , < nl > + " category " : " full " , < nl > + " description " : " Collection access hash " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 1 , < nl > + " name " : " id " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " accessHash " < nl > + } < nl > + ] < nl > + } < nl > + } , < nl > + { < nl > + " type " : " rpc " , < nl > + " content " : { < nl > + " name " : " LoadStickerCollection " , < nl > + " header " : 246 , < nl > + " response " : { < nl > + " type " : " anonymous " , < nl > + " header " : 247 , < nl > + " doc " : [ < nl > + " Loaded collection " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " collection " , < nl > + " category " : " full " , < nl > + " description " : " Collection of stickers " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : { < nl > + " type " : " struct " , < nl > + " childType " : " StickerCollection " < nl > + } , < nl > + " id " : 1 , < nl > + " name " : " collection " < nl > + } < nl > + ] < nl > + } , < nl > + " doc " : [ < nl > + " Loading stickers " , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " id " , < nl > + " category " : " full " , < nl > + " description " : " Collection id " < nl > + } , < nl > + { < nl > + " type " : " reference " , < nl > + " argument " : " accessHash " , < nl > + " category " : " full " , < nl > + " description " : " Collection access hash " < nl > + } < nl > + ] , < nl > + " attributes " : [ < nl > + { < nl > + " type " : " int32 " , < nl > + " id " : 1 , < nl > + " name " : " id " < nl > + } , < nl > + { < nl > + " type " : " int64 " , < nl > + " id " : 2 , < nl > + " name " : " accessHash " < nl > + } < nl > + ] < nl > + } < nl > + } < nl > + ] < nl > + } , < nl > + { < nl > " title " : " Search " , < nl > " package " : " search " , < nl > " doc " : [ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala < nl > index b397af8 . . c7a682a 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala < nl > @ @ - 33 , 5 + 33 , 7 @ @ object FutureResultRpcCats extends FutureInstances with EitherInstances { < nl > < nl > def fromBoolean [ A ] ( failure : RpcError ) ( oa : Boolean ) : Result [ Unit ] = Result [ Unit ] ( Future . successful ( if ( oa ) right ( ( ) ) else left ( failure ) ) ) < nl > < nl > - implicit def toScalaz [ A ] ( catsResult : RpcError Xor A ) : RpcError \ / A = catsResult . fold ( - \ / ( _ ) , \ / - ( _ ) ) < nl > + implicit class ToScalaz [ A ] ( catsResult : RpcError Xor A ) { < nl > + def toScalaz : RpcError \ / A = catsResult . fold ( - \ / ( _ ) , \ / - ( _ ) ) < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > index 3421414 . . 4dea619 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala < nl > @ @ - 43 , 6 + 43 , 12 @ @ object ACLUtils { < nl > def fileAccessHash ( fileId : Long , accessSalt : String ) ( implicit s : ActorSystem ) : Long = < nl > hash ( s " $ fileId : $ accessSalt : $ { secretKey ( ) } " ) < nl > < nl > + def stickerPackAccessHash ( id : Int , ownerUserId : Int , accessSalt : String ) ( implicit s : ActorSystem ) : Long = < nl > + hash ( s " $ id : $ ownerUserId : $ accessSalt : $ { secretKey ( ) } " ) < nl > + < nl > + def stickerPackAccessHash ( pack : model . StickerPack ) ( implicit s : ActorSystem ) : Long = < nl > + stickerPackAccessHash ( pack . id , pack . ownerUserId , pack . accessSalt ) < nl > + < nl > def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = < nl > DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) < nl > < nl > diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala < nl > new file mode 100644 < nl > index 0000000 . . 4a9a2fd < nl > - - - / dev / null < nl > + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala < nl > @ @ - 0 , 0 + 1 , 20 @ @ < nl > + package im . actor . server . model < nl > + < nl > + case class StickerData ( < nl > + id : Int , < nl > + packId : Int , < nl > + emoji : Option [ String ] , < nl > + image128FileId : Long , < nl > + image128FileHash : Long , < nl > + image128FileSize : Long , < nl > + image256FileId : Option [ Long ] , < nl > + image256FileHash : Option [ Long ] , < nl > + image256FileSize : Option [ Long ] , < nl > + image512FileId : Option [ Long ] , < nl > + image512FileHash : Option [ Long ] , < nl > + image512FileSize : Option [ Long ] < nl > + ) < nl > + < nl > + case class StickerPack ( id : Int , accessSalt : String , ownerUserId : Int , isDefault : Boolean ) < nl > + < nl > + case class OwnStickerPack ( userId : Int , packId : Int ) < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql < nl > new file mode 100644 < nl > index 0000000 . . 380f7cf < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql < nl > @ @ - 0 , 0 + 1 , 29 @ @ < nl > + create table sticker _ packs ( < nl > + id int not null , < nl > + access _ salt varchar ( 255 ) not null , < nl > + owner _ user _ id int not null , < nl > + is _ default boolean not null default false , < nl > + primary key ( id ) < nl > + ) ; < nl > + < nl > + create table own _ sticker _ packs ( < nl > + user _ id int not null , < nl > + pack _ id int not null , < nl > + primary key ( user _ id , pack _ id ) < nl > + ) ; < nl > + < nl > + create table sticker _ data ( < nl > + id int not null , < nl > + pack _ id int not null , < nl > + emoji varchar ( 16 ) , < nl > + image _ 128 _ file _ id bigint not null , < nl > + image _ 128 _ file _ hash bigint not null , < nl > + image _ 128 _ file _ size bigint not null , < nl > + image _ 256 _ file _ id bigint , < nl > + image _ 256 _ file _ hash bigint , < nl > + image _ 256 _ file _ size bigint , < nl > + image _ 512 _ file _ id bigint , < nl > + image _ 512 _ file _ hash bigint , < nl > + image _ 512 _ file _ size bigint , < nl > + primary key ( id , pack _ id ) < nl > + ) ; < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . c37a529 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala < nl > @ @ - 0 , 0 + 1 , 30 @ @ < nl > + package im . actor . server . persist < nl > + < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . model . OwnStickerPack < nl > + import slick . dbio . Effect . Read < nl > + import slick . profile . FixedSqlStreamingAction < nl > + < nl > + class OwnStickerPackTable ( tag : Tag ) extends Table [ OwnStickerPack ] ( tag , " own _ sticker _ packs " ) { < nl > + def userId = column [ Int ] ( " user _ id " , O . PrimaryKey ) < nl > + def packId = column [ Int ] ( " pack _ id " , O . PrimaryKey ) < nl > + < nl > + def * = ( userId , packId ) < > ( OwnStickerPack . tupled , OwnStickerPack . unapply ) < nl > + } < nl > + < nl > + object OwnStickerPackRepo { < nl > + < nl > + val ownStickerPacks = TableQuery [ OwnStickerPackTable ] < nl > + < nl > + def create ( userId : Int , packId : Int ) = < nl > + ownStickerPacks + = OwnStickerPack ( userId , packId ) < nl > + < nl > + def delete ( userId : Int , packId : Int ) = < nl > + ownStickerPacks . filter ( p ⇒ p . userId = = = userId & & p . packId = = = packId ) . delete < nl > + < nl > + def findPackIds ( userId : Int ) : DBIO [ Seq [ Int ] ] = ownStickerPacks . filter ( _ . userId = = = userId ) . map ( _ . packId ) . result < nl > + < nl > + def exists ( userId : Int , packId : Int ) : DBIO [ Boolean ] = < nl > + ownStickerPacks . filter ( p ⇒ p . userId = = = userId & & p . packId = = = packId ) . exists . result < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . 4d5046d < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala < nl > @ @ - 0 , 0 + 1 , 44 @ @ < nl > + package im . actor . server . persist < nl > + < nl > + import im . actor . server . model . StickerData < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + < nl > + class StickerDataTable ( tag : Tag ) extends Table [ StickerData ] ( tag , " sticker _ data " ) { < nl > + def id = column [ Int ] ( " id " , O . PrimaryKey ) < nl > + def packId = column [ Int ] ( " pack _ id " , O . PrimaryKey ) < nl > + def emoji = column [ Option [ String ] ] ( " emoji " ) < nl > + def image128FileId = column [ Long ] ( " image _ 128 _ file _ id " ) < nl > + def image128FileHash = column [ Long ] ( " image _ 128 _ file _ hash " ) < nl > + def image128FileSize = column [ Long ] ( " image _ 128 _ file _ size " ) < nl > + def image256FileId = column [ Option [ Long ] ] ( " image _ 256 _ file _ id " ) < nl > + def image256FileHash = column [ Option [ Long ] ] ( " image _ 256 _ file _ hash " ) < nl > + def image256FileSize = column [ Option [ Long ] ] ( " image _ 256 _ file _ size " ) < nl > + def image512FileId = column [ Option [ Long ] ] ( " image _ 512 _ file _ id " ) < nl > + def image512FileHash = column [ Option [ Long ] ] ( " image _ 512 _ file _ hash " ) < nl > + def image512FileSize = column [ Option [ Long ] ] ( " image _ 512 _ file _ size " ) < nl > + < nl > + def * = ( < nl > + id , < nl > + packId , < nl > + emoji , < nl > + image128FileId , < nl > + image128FileHash , < nl > + image128FileSize , < nl > + image256FileId , < nl > + image256FileHash , < nl > + image256FileSize , < nl > + image512FileId , < nl > + image512FileHash , < nl > + image512FileSize < nl > + ) < > ( StickerData . tupled , StickerData . unapply ) < nl > + } < nl > + < nl > + object StickerDataRepo { < nl > + < nl > + val stickerDatas = TableQuery [ StickerDataTable ] < nl > + < nl > + def find ( id : Int ) = stickerDatas . filter ( _ . id = = = id ) . result < nl > + < nl > + def findByPack ( packId : Int ) = stickerDatas . filter ( _ . packId = = = packId ) . result < nl > + < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala < nl > new file mode 100644 < nl > index 0000000 . . f0d560f < nl > - - - / dev / null < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala < nl > @ @ - 0 , 0 + 1 , 33 @ @ < nl > + package im . actor . server . persist < nl > + < nl > + import slick . lifted . Tag < nl > + import im . actor . server . db . ActorPostgresDriver . api . _ < nl > + import im . actor . server . model . StickerPack < nl > + < nl > + class StickerPackTable ( tag : Tag ) extends Table [ StickerPack ] ( tag , " sticker _ packs " ) { < nl > + def id = column [ Int ] ( " id " , O . PrimaryKey ) < nl > + def accessSalt = column [ String ] ( " access _ salt " ) < nl > + def ownerUserId = column [ Int ] ( " owner _ user _ id " ) < nl > + def isDefault = column [ Boolean ] ( " is _ default " ) < nl > + < nl > + def * = ( id , accessSalt , ownerUserId , isDefault ) < > ( StickerPack . tupled , StickerPack . unapply ) < nl > + } < nl > + < nl > + object StickerPackRepo { < nl > + val stickerPacks = TableQuery [ StickerPackTable ] < nl > + < nl > + def create ( pack : StickerPack ) = < nl > + stickerPacks + = pack < nl > + < nl > + / / def findDefaultPacks = stickerPacks . filter ( _ . isDefault ) . result < nl > + < nl > + / / def findOwnPacks ( userId : Int ) = stickerPacks . filter ( p ⇒ p . isDefault | | p . ownerUserId = = = userId ) . result < nl > + < nl > + def find ( id : Int ) = stickerPacks . filter ( _ . id = = = id ) . result . headOption < nl > + < nl > + def find ( ids : Seq [ Int ] , withDefault : Boolean = true ) : DBIO [ Seq [ StickerPack ] ] = < nl > + ( if ( withDefault ) < nl > + stickerPacks . filter ( p ⇒ p . isDefault | | ( p . id inSet ids . toSet ) ) < nl > + else < nl > + stickerPacks . filter ( p ⇒ p . id inSet ids ) ) . result < nl > + } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > index e5dbaf9 . . ed8255e 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala < nl > @ @ - 270 , 6 + 270 , 7 @ @ trait HistoryHandlers { < nl > case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet < nl > case ApiJsonMessage ( _ ) ⇒ Set . empty < nl > case _ : ApiDocumentMessage ⇒ Set . empty < nl > + case _ : ApiStickerMessage ⇒ Set . empty < nl > case _ : ApiUnsupportedMessage ⇒ Set . empty < nl > } < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala < nl > new file mode 100644 < nl > index 0000000 . . 8f347c3 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala < nl > @ @ - 0 , 0 + 1 , 34 @ @ < nl > + package im . actor . server . api . rpc . service . stickers < nl > + < nl > + import im . actor . api . rpc . files . { ApiFileLocation , ApiImageLocation } < nl > + import im . actor . api . rpc . stickers . ApiStickerDescriptor < nl > + import im . actor . server . model . StickerData < nl > + < nl > + import scala . language . implicitConversions < nl > + < nl > + trait ImplicitConversions { < nl > + < nl > + implicit def stickerToApi ( s : StickerData ) : ApiStickerDescriptor = { < nl > + ApiStickerDescriptor ( < nl > + s . id , < nl > + s . emoji , < nl > + imageLocation ( s . image128FileId , s . image128FileHash , 128 , s . image128FileSize ) , < nl > + optImageLocation ( s . image512FileId , s . image512FileHash , 512 , s . image512FileSize ) , < nl > + optImageLocation ( s . image256FileId , s . image256FileHash , 256 , s . image256FileSize ) < nl > + ) < nl > + } < nl > + < nl > + implicit def stickerToApi ( stickers : Seq [ StickerData ] ) : IndexedSeq [ ApiStickerDescriptor ] = < nl > + stickers . toVector map stickerToApi < nl > + < nl > + private def imageLocation ( fileId : Long , fileHash : Long , side : Int , fileSize : Long ) : ApiImageLocation = < nl > + ApiImageLocation ( ApiFileLocation ( fileId , fileHash ) , side , side , fileSize . toInt ) < nl > + < nl > + private def optImageLocation ( fileId : Option [ Long ] , fileHash : Option [ Long ] , side : Int , fileSize : Option [ Long ] ) : Option [ ApiImageLocation ] = < nl > + for { < nl > + id ← fileId < nl > + hash ← fileHash < nl > + size ← fileSize < nl > + } yield imageLocation ( id , hash , side , size ) < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala < nl > new file mode 100644 < nl > index 0000000 . . dac5053 < nl > - - - / dev / null < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala < nl > @ @ - 0 , 0 + 1 , 81 @ @ < nl > + package im . actor . server . api . rpc . service . stickers < nl > + < nl > + import akka . actor . ActorSystem < nl > + import im . actor . api . rpc . stickers . _ < nl > + import im . actor . api . rpc . { ClientData , _ } < nl > + import im . actor . server . acl . ACLUtils . stickerPackAccessHash < nl > + import im . actor . server . db . DbExtension < nl > + import im . actor . server . persist < nl > + import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } < nl > + import slick . dbio . DBIO < nl > + < nl > + import scala . concurrent . { ExecutionContext , Future } < nl > + < nl > + object StickerPackErrors { < nl > + val PackNotFound = RpcError ( 404 , " PACK _ NOT _ FOUND " , " Sticker pack not found " , false , None ) < nl > + val AlreadyAdded = RpcError ( 400 , " PACK _ ALREADY _ ADDED " , " Sticker pack already added " , false , None ) < nl > + val AlreadyRemoved = RpcError ( 400 , " PACK _ ALREADY _ REMOVED " , " Sticker pack already removed " , false , None ) < nl > + } < nl > + < nl > + class StickersServiceImpl ( implicit actorSystem : ActorSystem ) extends StickersService with ImplicitConversions { < nl > + < nl > + import FutureResultRpcCats . _ < nl > + import StickerPackErrors . _ < nl > + < nl > + override implicit protected val ec : ExecutionContext = actorSystem . dispatcher < nl > + < nl > + private val db = DbExtension ( actorSystem ) . db < nl > + private val seqUpdExt = SeqUpdatesExtension ( actorSystem ) < nl > + < nl > + override def jhandleLoadStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadStickerCollection ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + ( for { < nl > + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) < nl > + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) < nl > + stickers ← fromFuture ( db . run ( persist . StickerDataRepo . findByPack ( pack . id ) ) ) < nl > + } yield ResponseLoadStickerCollection ( ApiStickerCollection ( pack . id , accessHash , stickers ) ) ) . value map ( _ . toScalaz ) < nl > + } < nl > + < nl > + override def jhandleRemoveStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseStickersReponse ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + ( for { < nl > + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) < nl > + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) < nl > + _ ← fromFutureBoolean ( AlreadyRemoved ) ( db . run ( persist . OwnStickerPackRepo . exists ( client . userId , pack . id ) map ! = ) ) < nl > + _ ← fromFuture ( db . run ( persist . OwnStickerPackRepo . delete ( client . userId , pack . id ) ) ) < nl > + seqState ← fromFuture ( seqUpdExt . getSeqState ( client . userId ) ) < nl > + SeqState ( seq , state ) = seqState < nl > + stickers ← fromFuture ( db . run ( getStickerPacks ( client . userId ) ) ) < nl > + } yield ResponseStickersReponse ( stickers , seq , state . toByteArray ) ) . value map ( _ . toScalaz ) < nl > + } < nl > + < nl > + override def jhandleAddStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseStickersReponse ] ] = < nl > + authorized ( clientData ) { client ⇒ < nl > + ( for { < nl > + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) < nl > + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) < nl > + _ ← fromFutureBoolean ( AlreadyAdded ) ( db . run ( persist . OwnStickerPackRepo . exists ( client . userId , pack . id ) ) ) < nl > + _ ← fromFuture ( db . run ( persist . OwnStickerPackRepo . create ( client . userId , pack . id ) ) ) < nl > + seqState ← fromFuture ( seqUpdExt . getSeqState ( client . userId ) ) < nl > + SeqState ( seq , state ) = seqState < nl > + stickers ← fromFuture ( db . run ( getStickerPacks ( client . userId ) ) ) < nl > + } yield ResponseStickersReponse ( stickers , seq , state . toByteArray ) ) . value map ( _ . toScalaz ) < nl > + } < nl > + < nl > + override def jhandleLoadOwnStickers ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadOwnStickers ] ] = { < nl > + val action = requireAuth ( clientData ) map { implicit client ⇒ < nl > + getStickerPacks ( client . userId ) map ( stickers ⇒ Ok ( ResponseLoadOwnStickers ( stickers ) ) ) < nl > + } < nl > + db . run ( toDBIOAction ( action ) ) < nl > + } < nl > + < nl > + private def getStickerPacks ( userId : Int ) : DBIO [ Vector [ ApiStickerCollection ] ] = < nl > + for { < nl > + packIds ← persist . OwnStickerPackRepo . findPackIds ( userId ) < nl > + packs ← persist . StickerPackRepo . find ( packIds ) < nl > + stickerCollections ← DBIO . sequence ( packs . toVector map { pack ⇒ < nl > + for ( stickers ← persist . StickerDataRepo . findByPack ( pack . id ) ) yield ApiStickerCollection ( pack . id , stickerPackAccessHash ( pack ) , stickers ) < nl > + } ) < nl > + } yield stickerCollections < nl > + < nl > + } < nl > diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > index 885ffff . . 2ef537a 100644 < nl > - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala < nl > @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . server . api . rpc . service . profile . ProfileServiceImpl < nl > import im . actor . server . api . rpc . service . pubgroups . PubgroupsServiceImpl < nl > import im . actor . server . api . rpc . service . push . PushServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > + import im . actor . server . api . rpc . service . stickers . StickersServiceImpl < nl > import im . actor . server . api . rpc . service . users . UsersServiceImpl < nl > import im . actor . server . api . rpc . service . weak . WeakServiceImpl < nl > import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl < nl > @ @ - 49 , 7 + 50 , 8 @ @ final case class ActorServer ( system : ActorSystem ) < nl > object ActorServer { < nl > / * * < nl > * Creates a new Actor Server builder < nl > - * @ return < nl > + * < nl > + * @ return < nl > * / < nl > def newBuilder : ActorServerBuilder = ActorServerBuilder ( ) < nl > } < nl > @ @ - 71 , 7 + 73 , 8 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( < nl > < nl > / * * < nl > * Starts a server < nl > - * @ return < nl > + * < nl > + * @ return < nl > * / < nl > def start ( ) : ActorServer = { < nl > SessionMessage . register ( ) < nl > @ @ - 216 , 6 + 219 , 9 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( < nl > system . log . debug ( " Starting DeviceService " ) < nl > val deviceService = new DeviceServiceImpl < nl > < nl > + system . log . debug ( " Starting StickersServiceImpl " ) < nl > + val stickerService = new StickersServiceImpl < nl > + < nl > val services = Seq ( < nl > authService , < nl > contactsService , < nl > @ @ - 231 , 7 + 237 , 8 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( < nl > profileService , < nl > integrationsService , < nl > webactionsService , < nl > - deviceService < nl > + deviceService , < nl > + stickerService < nl > ) < nl > < nl > system . log . warning ( " Starting ActorBot " )

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json 
 index 1d17e98 . . 7ff86cd 100644 
 - - - a / actor - server / actor - core / src / main / actor - api / actor . json 
 + + + b / actor - server / actor - core / src / main / actor - api / actor . json 
 @ @ - 30 , 6 + 30 , 14 @ @ 
 { 
 " type " : " int32 " , 
 " alias " : " groupId " 
 + } , 
 + { 
 + " type " : " int32 " , 
 + " alias " : " keyId " 
 + } , 
 + { 
 + " type " : " int32 " , 
 + " alias " : " keyGroupId " 
 } 
 ] , 
 " sections " : [ 
 @ @ - 11324 , 7 + 11332 , 7 @ @ 
 } , 
 { 
 " type " : " reference " , 
 - " argument " : " package " , 
 + " argument " : " content " , 
 " category " : " full " , 
 " description " : " Signaling raw package " 
 } 
 @ @ - 11338 , 7 + 11346 , 7 @ @ 
 { 
 " type " : " bytes " , 
 " id " : 2 , 
 - " name " : " package " 
 + " name " : " content " 
 } 
 ] 
 } 
 @ @ - 11383 , 6 + 11391 , 65 @ @ 
 { 
 " type " : " rpc " , 
 " content " : { 
 + " name " : " DoCall " , 
 + " header " : 2597 , 
 + " response " : { 
 + " type " : " anonymous " , 
 + " header " : 2598 , 
 + " doc " : [ 
 + { 
 + " type " : " reference " , 
 + " argument " : " callId " , 
 + " category " : " full " , 
 + " description " : " Call Id " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " int64 " , 
 + " id " : 1 , 
 + " name " : " callId " 
 + } 
 + ] 
 + } , 
 + " doc " : [ 
 + " Do Call . Right after a call client need to start sending CallInProgress " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " peer " , 
 + " category " : " full " , 
 + " description " : " destination peer " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " timeout " , 
 + " category " : " hidden " , 
 + " description " : " Call timeout " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " OutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " peer " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " sec " 
 + } , 
 + " id " : 2 , 
 + " name " : " timeout " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 " name " : " EndCall " , 
 " header " : 2595 , 
 " response " : { 
 @ @ - 11447 , 6 + 11514 , 44 @ @ 
 } 
 ] 
 } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " SendCallSignal " , 
 + " header " : 2599 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " Void " 
 + } , 
 + " doc " : [ 
 + " Sending call signal message " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " callId " , 
 + " category " : " full " , 
 + " description " : " Call Id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " content " , 
 + " category " : " full " , 
 + " description " : " Signaling raw package " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " int64 " , 
 + " id " : 1 , 
 + " name " : " callId " 
 + } , 
 + { 
 + " type " : " bytes " , 
 + " id " : 2 , 
 + " name " : " content " 
 + } 
 + ] 
 + } 
 } 
 ] 
 } , 
 @ @ - 12200 , 14 + 12305 , 420 @ @ 
 " package " : " encryption " , 
 " doc " : [ 
 " Package that include encryption support " , 
 - " Key types : " , 
 - " * Curve25519 - https : / / en . wikipedia . org / wiki / Curve25519 " , 
 - " * Ed25519 - http : / / ed25519 . cr . yp . to / " , 
 - " * RSA2048 " , 
 - " * RSA4096 " 
 + " Key alg types : " , 
 + " * curve25519 - https : / / en . wikipedia . org / wiki / Curve25519 " , 
 + " * rsa - 2048 " , 
 + " * rsa - 4096 " , 
 + " * aes - 128 " , 
 + " * kuznechik - 128 " 
 ] , 
 " items " : [ 
 { 
 + " type " : " comment " , 
 + " content " : " Public Keys " 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " EncryptionPublicKeyGroup " , 
 + " doc " : [ 
 + " Encryption Key Group " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroupId " , 
 + " category " : " full " , 
 + " description " : " Key Group Id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " publicKeys " , 
 + " category " : " hidden " , 
 + " description " : " Public keys of Key Group " 
 + } 
 + ] , 
 + " expandable " : " true " , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " keyGroupId " 
 + } , 
 + " id " : 1 , 
 + " name " : " keyGroupId " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " EncryptionPublicKey " 
 + } 
 + } , 
 + " id " : 4 , 
 + " name " : " publicKeys " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " EncryptionPublicKey " , 
 + " doc " : [ 
 + " Encryption Public Key " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyId " , 
 + " category " : " full " , 
 + " description " : " Key Id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyAlg " , 
 + " category " : " full " , 
 + " description " : " Key Algorithm " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyMaterial " , 
 + " category " : " compact " , 
 + " description " : " Public key material . Can be null , but always not null for LoadPublicKey " 
 + } 
 + ] , 
 + " expandable " : " true " , 
 + " attributes " : [ 
 + { 
 + " type " : " int64 " , 
 + " id " : 1 , 
 + " name " : " keyId " 
 + } , 
 + { 
 + " type " : " string " , 
 + " id " : 2 , 
 + " name " : " keyAlg " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bytes " 
 + } , 
 + " id " : 3 , 
 + " name " : " keyMaterial " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bytes " 
 + } , 
 + " id " : 4 , 
 + " name " : " keyHash " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " response " , 
 + " content " : { 
 + " name " : " PublicKeys " , 
 + " header " : 2602 , 
 + " doc " : [ 
 + " Public Keys response " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " publicKey " , 
 + " category " : " full " , 
 + " description " : " Public keys " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " EncryptionPublicKey " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " publicKey " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " response " , 
 + " content " : { 
 + " name " : " PublicKeyGroups " , 
 + " header " : 2604 , 
 + " doc " : [ 
 + " Public key groups response " 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " EncryptionPublicKeyGroup " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " publicKeyGroups " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadPublicKeyGroups " , 
 + " header " : 2601 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " PublicKeyGroups " 
 + } , 
 + " doc " : [ 
 + " Loading Public key groups " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " userPeer " , 
 + " category " : " full " , 
 + " description " : " User ' s peer " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " userPeer " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadPublicKey " , 
 + " header " : 2605 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " PublicKeys " 
 + } , 
 + " doc " : [ 
 + " Loading public key explictly " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " userPeer " , 
 + " category " : " full " , 
 + " description " : " User ' s peer " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroupId " , 
 + " category " : " full " , 
 + " description " : " Key group ' s id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyIds " , 
 + " category " : " full " , 
 + " description " : " Key ids for loading " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " userPeer " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " keyGroupId " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : " int64 " 
 + } , 
 + " id " : 3 , 
 + " name " : " keyIds " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadEphermalPublicKeys " , 
 + " header " : 2603 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " PublicKeys " 
 + } , 
 + " doc " : [ 
 + " Loading ephermal public keys " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " userPeer " , 
 + " category " : " full " , 
 + " description " : " User ' s peer " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroupId " , 
 + " category " : " full " , 
 + " description " : " User ' s key group id " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " UserOutPeer " 
 + } , 
 + " id " : 1 , 
 + " name " : " userPeer " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " keyGroupId " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " PublicKeyGroupChanged " , 
 + " header " : 103 , 
 + " doc " : [ 
 + " Update about public key group changed " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User ' s id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroup " , 
 + " category " : " full " , 
 + " description " : " Updated Key Group " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " EncryptionPublicKeyGroup " 
 + } , 
 + " id " : 2 , 
 + " name " : " keyGroup " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " PublicKeyGroupAdded " , 
 + " header " : 104 , 
 + " doc " : [ 
 + " Update about public key group added " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User ' s id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroup " , 
 + " category " : " full " , 
 + " description " : " Added Key Group " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " EncryptionPublicKeyGroup " 
 + } , 
 + " id " : 2 , 
 + " name " : " keyGroup " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " PublicKeyGroupRemoved " , 
 + " header " : 105 , 
 + " doc " : [ 
 + " Update about public key group removed " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " uid " , 
 + " category " : " full " , 
 + " description " : " User ' s id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " keyGroupId " , 
 + " category " : " hidden " , 
 + " description " : " Removed Key Group Id " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " userId " 
 + } , 
 + " id " : 1 , 
 + " name " : " uid " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " keyGroupId " 
 + } , 
 + " id " : 2 , 
 + " name " : " keyGroupId " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " comment " , 
 + " content " : " Device Side " 
 + } , 
 + { 
 " type " : " struct " , 
 " content " : { 
 " name " : " EncryptionDevice " , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 index e2279cb . . 759781e 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / UpdatesConsumer . scala 
 @ @ - 95 , 7 + 95 , 7 @ @ private [ sequence ] class UpdatesConsumer ( userId : Int , authId : Long , authSid : Int , 
 seqUpdExt . subscribe ( userId , self ) pipeTo self 
 } 
 case SubscribeToWeak ⇒ 
 - weakUpdatesExt . subscribe ( authId , self ) onFailure { 
 + weakUpdatesExt . subscribe ( authId , self , None ) onFailure { 
 case e ⇒ 
 self ! SubscribeToWeak 
 log . error ( e , " Failed to subscribe to weak updates " ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala 
 index 0d29157 . . 95c95dc 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesExtension . scala 
 @ @ - 22 , 10 + 22 , 10 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt 
 private val region = WeakUpdatesManagerRegion . startRegion ( ) ( system ) 
 private lazy val userExt = UserExtension ( system ) 
 
 - def broadcastUserWeakUpdate ( userId : Int , update : Update , reduceKey : Option [ String ] ) : Future [ Unit ] = { 
 + def broadcastUserWeakUpdate ( userId : Int , update : Update , reduceKey : Option [ String ] , group : Option [ String ] = None ) : Future [ Unit ] = { 
 val header = update . header 
 val serializedData = update . toByteArray 
 - val msg = PushUpdate ( header , serializedData , reduceKey ) 
 + val msg = PushUpdate ( header , serializedData , reduceKey , group ) 
 
 for ( authIds ← userExt . getAuthIds ( userId ) ) yield { 
 authIds foreach { authId ⇒ 
 @ @ - 34 , 10 + 34 , 10 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt 
 } 
 } 
 
 - def pushUpdate ( authId : Long , update : Update , reduceKey : Option [ String ] ) : Unit = { 
 + def pushUpdate ( authId : Long , update : Update , reduceKey : Option [ String ] , group : Option [ String ] ) : Unit = { 
 val header = update . header 
 val serializedData = update . toByteArray 
 - region . ref ! Envelope ( authId , PushUpdate ( header , serializedData , reduceKey ) ) 
 + region . ref ! Envelope ( authId , PushUpdate ( header , serializedData , reduceKey , group ) ) 
 } 
 
 def reduceKey ( updateHeader : Int , peer : ApiPeer ) : String = s " $ updateHeader - $ { peer . ` type ` . id } - $ { peer . id } " 
 @ @ - 48 , 9 + 48 , 8 @ @ final class WeakUpdatesExtensionImpl ( system : ActorSystem ) extends WeakUpdatesExt 
 
 def reduceKeyGroup ( updateHeader : Int , groupId : Int ) : String = s " $ updateHeader - $ { ApiPeerType . Group . id } - $ groupId " 
 
 - private [ sequence ] def subscribe ( authId : Long , consumer : ActorRef ) : Future [ Unit ] = 
 - region . ref . ask ( Envelope ( authId , Subscribe ( consumer ) ) ) . mapTo [ SubscribeAck ] . map ( _ ⇒ ( ) ) 
 - 
 + private [ sequence ] def subscribe ( authId : Long , consumer : ActorRef , group : Option [ String ] ) : Future [ Unit ] = 
 + region . ref . ask ( Envelope ( authId , Subscribe ( consumer , group : Option [ String ] ) ) ) . mapTo [ SubscribeAck ] . map ( _ ⇒ ( ) ) 
 } 
 
 object WeakUpdatesExtension extends ExtensionId [ WeakUpdatesExtensionImpl ] with ExtensionIdProvider { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala 
 index 502bdc1 . . 1bcb628 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / sequence / WeakUpdatesManager . scala 
 @ @ - 6 , 21 + 6 , 21 @ @ import im . actor . api . rpc . sequence . WeakUpdate 
 object WeakUpdatesManager { 
 
 @ SerialVersionUID ( 1L ) 
 - private [ sequence ] case class Envelope ( authId : Long , payload : Message ) 
 + private [ sequence ] final case class Envelope ( authId : Long , payload : Message ) 
 
 private [ sequence ] sealed trait Message 
 
 @ SerialVersionUID ( 1L ) 
 - private [ sequence ] case class PushUpdate ( header : Int , serializedData : Array [ Byte ] , reduceKey : Option [ String ] ) extends Message 
 + private [ sequence ] final case class PushUpdate ( header : Int , serializedData : Array [ Byte ] , reduceKey : Option [ String ] , group : Option [ String ] ) extends Message 
 
 @ SerialVersionUID ( 1L ) 
 - private [ sequence ] case class Subscribe ( consumer : ActorRef ) extends Message 
 + private [ sequence ] final case class Subscribe ( consumer : ActorRef , group : Option [ String ] ) extends Message 
 
 @ SerialVersionUID ( 1L ) 
 - private [ sequence ] case class SubscribeAck ( consumer : ActorRef ) extends Message 
 + private [ sequence ] final case class SubscribeAck ( subscribe : Subscribe ) extends Message 
 
 @ SerialVersionUID ( 1L ) 
 - case class UpdateReceived ( update : WeakUpdate , reduceKey : Option [ String ] ) 
 + final case class UpdateReceived ( update : WeakUpdate , reduceKey : Option [ String ] ) 
 
 def props = Props ( classOf [ WeakUpdatesManager ] ) 
 } 
 @ @ - 29 , 21 + 29 , 33 @ @ private final class WeakUpdatesManager extends Actor with ActorLogging { 
 
 import WeakUpdatesManager . _ 
 
 + type ConsumerDescriptor = ( ActorRef , Option [ String ] ) 
 + 
 / / TODO : set receive timeout 
 
 def receive = working ( Set . empty ) 
 
 - def working ( consumers : Set [ ActorRef ] ) : Receive = { 
 - case Envelope ( authId , PushUpdate ( header , serializedData , reduceKey ) ) ⇒ 
 + def working ( consumers : Set [ ConsumerDescriptor ] ) : Receive = { 
 + case Envelope ( authId , PushUpdate ( header , serializedData , reduceKey , groupOpt ) ) ⇒ 
 val event = UpdateReceived ( WeakUpdate ( System . currentTimeMillis ( ) , header , serializedData ) , reduceKey ) 
 - consumers foreach ( _ ! event ) 
 - case Envelope ( _ , Subscribe ( consumer ) ) ⇒ 
 + 
 + groupOpt match { 
 + case Some ( group ) ⇒ 
 + consumers . view 
 + . filter ( _ . _ 2 . exists ( _ = = group ) ) 
 + . map ( _ . _ 1 ) 
 + . foreach ( _ ! event ) 
 + case None ⇒ 
 + consumers . foreach ( _ . _ 1 ! event ) 
 + } 
 + case Envelope ( _ , sub @ Subscribe ( consumer , groupOpt ) ) ⇒ 
 context . watch ( consumer ) 
 - context . become ( working ( consumers + consumer ) ) 
 - sender ( ) ! SubscribeAck ( consumer ) 
 + 
 + context . become ( working ( consumers + ( consumer → groupOpt ) ) ) 
 + sender ( ) ! SubscribeAck ( sub ) 
 
 log . debug ( " Consumer subscribed { } " , consumer ) 
 case Terminated ( consumer ) ⇒ 
 - context . become ( working ( consumers - consumer ) ) 
 + context . become ( working ( consumers . filterNot ( _ . _ 1 = = consumer ) ) ) 
 } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 new file mode 100644 
 index 0000000 . . 0ffc3f7 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcCallActor . scala 
 @ @ - 0 , 0 + 1 , 145 @ @ 
 + package im . actor . server . webrtc 
 + 
 + import akka . actor . _ 
 + import akka . pattern . pipe 
 + import im . actor . api . rpc . messaging . { ApiServiceMessage , ApiServiceExPhoneCall } 
 + import im . actor . api . rpc . peers . { ApiPeerType , ApiPeer } 
 + import im . actor . api . rpc . webrtc . _ 
 + import im . actor . concurrent . ActorStashing 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . dialog . DialogExtension 
 + import im . actor . server . persist . webrtc . WebrtcCallRepo 
 + import im . actor . server . sequence . { WeakUpdatesExtension , SeqUpdatesExtension } 
 + 
 + import scala . concurrent . Future 
 + import scala . concurrent . duration . _ 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + 
 + sealed abstract class WebrtcCallError ( message : String ) extends RuntimeException ( message ) 
 + 
 + object WebrtcCallErrors { 
 + object NotAParticipant extends WebrtcCallError ( " Not participant " ) 
 + } 
 + 
 + sealed trait WebrtcCallMessages 
 + 
 + object WebrtcCallMessages { 
 + final case class StartCall ( callerUserId : Int , receiverUserId : Int ) extends WebrtcCallMessages 
 + case object CallStarted 
 + 
 + final case class CallInProgress ( userId : Int , timeout : Int ) extends WebrtcCallMessages 
 + 
 + final case class CallSignal ( userId : Int , pkg : Array [ Byte ] ) extends WebrtcCallMessages 
 + 
 + case class EndCall ( userId : Int ) extends WebrtcCallMessages 
 + } 
 + 
 + final case class WebrtcCallEnvelope ( id : Long , message : WebrtcCallMessages ) 
 + 
 + object WebrtcCallActor { 
 + val RegionTypeName = " WebrtcCall " 
 + val DefaultCallTimeout = 30 . seconds 
 + 
 + def props = Props ( classOf [ WebrtcCallActor ] ) 
 + } 
 + 
 + private final class WebrtcCallActor extends ActorStashing with ActorLogging { 
 + import WebrtcCallMessages . _ 
 + import WebrtcCallActor . _ 
 + import context . dispatcher 
 + 
 + private val id = self . path . name . toLong 
 + 
 + private lazy val weakUpdExt = WeakUpdatesExtension ( context . system ) 
 + private lazy val dialogExt = DialogExtension ( context . system ) 
 + private val db = DbExtension ( context . system ) . db 
 + 
 + def receive = waitForStart 
 + 
 + def waitForStart : Receive = { 
 + case StartCall ( callerUserId , receiverUserId ) ⇒ 
 + val update = UpdateIncomingCall ( id , callerUserId ) 
 + 
 + ( for { 
 + _ ← db . run ( WebrtcCallRepo . create ( WebrtcCall ( id , callerUserId , receiverUserId ) ) ) 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None , Some ( Webrtc . WeakGroup ) ) 
 + } yield ( ) ) pipeTo self 
 + 
 + becomeStashing ( replyTo ⇒ { 
 + case ( ) ⇒ 
 + replyTo ! CallStarted 
 + context become callInProgress ( System . currentTimeMillis ( ) , callerUserId , receiverUserId , scheduleEnd ( DefaultCallTimeout ) ) 
 + unstashAll ( ) 
 + case failure : Status . Failure ⇒ 
 + replyTo forward failure 
 + throw failure . cause 
 + } , discardOld = true ) 
 + } 
 + 
 + def callInProgress ( startTime : Long , callerUserId : Int , receiverUserId : Int , scheduledEnd : Cancellable ) : Receive = { 
 + def end ( ) : Future [ Unit ] = { 
 + val duration = ( ( System . currentTimeMillis ( ) - startTime ) / 1000 ) . toInt 
 + val update = UpdateCallEnded ( id ) 
 + 
 + for { 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , None ) 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , None ) 
 + _ ← dialogExt . sendMessage ( 
 + peer = ApiPeer ( ApiPeerType . Private , receiverUserId ) , 
 + senderUserId = callerUserId , 
 + senderAuthSid = 0 , 
 + randomId = ThreadLocalRandom . current ( ) . nextLong , 
 + message = ApiServiceMessage ( " Call ended " , Some ( ApiServiceExPhoneCall ( duration ) ) ) 
 + ) 
 + _ ← db . run ( WebrtcCallRepo . delete ( id ) ) 
 + } yield ( ) 
 + } 
 + 
 + def withOrigin ( origin : Int ) ( f : Int ⇒ Any ) = 
 + if ( callerUserId = = origin ) 
 + f ( receiverUserId ) 
 + else if ( receiverUserId = = origin ) 
 + f ( callerUserId ) 
 + else 
 + sender ( ) ! Status . Failure ( WebrtcCallErrors . NotAParticipant ) 
 + 
 + { 
 + case CallInProgress ( userId , timeout ) ⇒ 
 + withOrigin ( userId ) { _ ⇒ 
 + scheduledEnd . cancel ( ) 
 + scheduleEnd ( timeout . seconds ) 
 + val update = UpdateCallInProgress ( id , timeout ) 
 + 
 + ( for { 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( receiverUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 + _ ← weakUpdExt . broadcastUserWeakUpdate ( callerUserId , update , Some ( s " webrtc _ call _ inprogress _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 + } yield ( ) ) pipeTo self 
 + 
 + becomeStashing ( replyTo ⇒ { 
 + case ( ) ⇒ 
 + context . unbecome ( ) 
 + unstashAll ( ) 
 + case failure : Status . Failure ⇒ 
 + end ( ) 
 + throw failure . cause 
 + } , discardOld = false ) 
 + } 
 + case CallSignal ( userId , pkg ) ⇒ 
 + withOrigin ( userId ) { target ⇒ 
 + / / TODO : stashing 
 + val update = UpdateCallSignal ( id , pkg ) 
 + weakUpdExt . broadcastUserWeakUpdate ( target , update , Some ( s " webrtc _ call _ signal _ $ id " ) , Some ( Webrtc . WeakGroup ) ) 
 + } 
 + case EndCall ( userId ) ⇒ 
 + withOrigin ( userId ) { _ ⇒ 
 + scheduledEnd . cancel ( ) 
 + 
 + end ( ) map ( _ ⇒ PoisonPill ) pipeTo self onFailure { 
 + case e ⇒ log . error ( e , " Failed to end call " ) 
 + } 
 + } 
 + } 
 + } 
 + 
 + def scheduleEnd ( timeout : FiniteDuration ) : Cancellable = context . system . scheduler . scheduleOnce ( timeout , self , EndCall ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala 
 new file mode 100644 
 index 0000000 . . da62a6f 
 - - - / dev / null 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / webrtc / WebrtcExtension . scala 
 @ @ - 0 , 0 + 1 , 55 @ @ 
 + package im . actor . server . webrtc 
 + 
 + import akka . actor . _ 
 + import akka . pattern . ask 
 + import akka . cluster . sharding . ShardRegion . { ExtractShardId , ExtractEntityId } 
 + import akka . cluster . sharding . { ClusterShardingSettings , ClusterSharding } 
 + import akka . util . Timeout 
 + import im . actor . config . ActorConfig 
 + 
 + import scala . concurrent . Future 
 + import scala . concurrent . forkjoin . ThreadLocalRandom 
 + 
 + object Webrtc { 
 + val WeakGroup = " webrtc _ calls " 
 + } 
 + 
 + final class WebrtcExtension ( system : ActorSystem ) extends Extension { 
 + import im . actor . server . webrtc . WebrtcCallMessages . _ 
 + import system . dispatcher 
 + 
 + private implicit val timeout : Timeout = Timeout ( ActorConfig . defaultTimeout ) 
 + 
 + private val extractEntityId : ExtractEntityId = { 
 + case WebrtcCallEnvelope ( id , message ) ⇒ ( id . toString , message ) 
 + } 
 + 
 + private val extractShardId : ExtractShardId = { 
 + case WebrtcCallEnvelope ( id , _ ) ⇒ ( id % 100 ) . toString 
 + } 
 + 
 + private val region = 
 + ClusterSharding ( system ) 
 + . start ( " WebrtcCall " , WebrtcCallActor . props , ClusterShardingSettings ( system ) , extractEntityId , extractShardId ) 
 + 
 + def doCall ( callerUserId : Int , receiverUserId : Int ) : Future [ Long ] = { 
 + val callId = ThreadLocalRandom . current ( ) . nextLong ( ) 
 + 
 + region ? WebrtcCallEnvelope ( callId , StartCall ( callerUserId , receiverUserId ) ) map ( _ ⇒ callId ) 
 + } 
 + 
 + def endCall ( userId : Int , callId : Long ) : Future [ Unit ] = 
 + region ? WebrtcCallEnvelope ( callId , EndCall ( userId ) ) map ( _ ⇒ ( ) ) 
 + 
 + def sendCallSignal ( userId : Int , callId : Long , content : Array [ Byte ] ) : Future [ Unit ] = 
 + region ? WebrtcCallEnvelope ( callId , CallSignal ( userId , content ) ) map ( _ ⇒ ( ) ) 
 + 
 + def sendCallInProgress ( userId : Int , callId : Long , ptimeout : Int ) : Future [ Unit ] = 
 + region ? WebrtcCallEnvelope ( callId , CallInProgress ( userId , ptimeout ) ) map ( _ ⇒ ( ) ) 
 + } 
 + 
 + object WebrtcExtension extends ExtensionIdProvider with ExtensionId [ WebrtcExtension ] { 
 + override def lookup ( ) : ExtensionId [ _ < : Extension ] = WebrtcExtension 
 + 
 + override def createExtension ( system : ExtendedActorSystem ) : WebrtcExtension = new WebrtcExtension ( system ) 
 + } 
 diff - - git a / actor - server / actor - models / src / main / protobuf / model / webrtc . proto b / actor - server / actor - models / src / main / protobuf / model / webrtc . proto 
 new file mode 100644 
 index 0000000 . . cee383f 
 - - - / dev / null 
 + + + b / actor - server / actor - models / src / main / protobuf / model / webrtc . proto 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + syntax = ' proto3 ' ; 
 + 
 + package im . actor . server ; 
 + 
 + import " scalapb / scalapb . proto " ; 
 + 
 + option ( scalapb . options ) = { 
 + import : " im . actor . server . model . ModelTypeMappers . _ " 
 + } ; 
 + 
 + message WebrtcCall { 
 + int64 id = 1 ; 
 + int32 initiator _ user _ id = 2 ; 
 + int32 receiver _ user _ id = 3 ; 
 + } 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql 
 new file mode 100644 
 index 0000000 . . 8cda014 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234110 _ _ CreateFeatures . sql 
 @ @ - 0 , 0 + 1 , 6 @ @ 
 + CREATE TABLE device _ features ( 
 + auth _ id BIGINT NOT NULL , 
 + name TEXT NOT NULL , 
 + args BYTEA NOT NULL , 
 + PRIMARY KEY ( auth _ id ) 
 + ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql 
 new file mode 100644 
 index 0000000 . . 492e29e 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20160110234231 _ _ CreateWebrtcCalls . sql 
 @ @ - 0 , 0 + 1 , 6 @ @ 
 + CREATE TABLE webrtc _ calls ( 
 + id BIGINT NOT NULL , 
 + initiator _ user _ id INT NOT NULL , 
 + receiver _ user _ id INT NOT NULL , 
 + PRIMARY KEY id 
 + ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala 
 new file mode 100644 
 index 0000000 . . fd8cea2 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / webrtc / WebrtcCallRepo . scala 
 @ @ - 0 , 0 + 1 , 28 @ @ 
 + package im . actor . server . persist . webrtc 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . webrtc . WebrtcCall 
 + 
 + final class WebrtcCallTable ( tag : Tag ) extends Table [ WebrtcCall ] ( tag , " webrtc _ calls " ) { 
 + def id = column [ Long ] ( " id " , O . PrimaryKey ) 
 + 
 + def initiatorUserId = column [ Int ] ( " initiator _ user _ id " ) 
 + 
 + def receiverUserId = column [ Int ] ( " receiver _ user _ id " ) 
 + 
 + def * = ( id , initiatorUserId , receiverUserId ) < > ( ( WebrtcCall . apply _ ) . tupled , WebrtcCall . unapply ) 
 + } 
 + 
 + object WebrtcCallRepo { 
 + val webrtcCalls = TableQuery [ WebrtcCallTable ] 
 + 
 + val byPKC = Compiled { id : Rep [ Long ] ⇒ 
 + webrtcCalls filter ( _ . id = = = id ) 
 + } 
 + 
 + def create ( call : WebrtcCall ) = webrtcCalls + = call 
 + 
 + def find ( id : Long ) = byPKC ( id ) . result . headOption 
 + 
 + def delete ( id : Long ) = byPKC ( id ) . delete 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 index 1b5d822 . . 81e5924 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / api / rpc / PeerHelpers . scala 
 @ @ - 1 , 9 + 1 , 10 @ @ 
 package im . actor . api . rpc 
 
 import im . actor . server . acl . ACLUtils 
 + import im . actor . server . db . DbExtension 
 
 import scala . collection . immutable 
 - import scala . concurrent . ExecutionContext 
 + import scala . concurrent . { Future , ExecutionContext } 
 import scalaz . _ 
 
 import akka . actor . _ 
 @ @ - 15 , 6 + 16 , 13 @ @ import im . actor . util . misc . StringUtils 
 import im . actor . server . { model , persist } 
 
 object PeerHelpers { 
 + def withOutPeerF [ R < : RpcResponse ] ( 
 + outPeer : ApiOutPeer 
 + ) ( 
 + f : ⇒ Future [ RpcError \ / R ] 
 + ) ( implicit client : AuthorizedClientData , actorSystem : ActorSystem , ec : ExecutionContext ) : Future [ RpcError \ / R ] = 
 + DbExtension ( actorSystem ) . db . run ( withOutPeer ( outPeer ) ( DBIO . from ( f ) ) ) 
 + 
 def withOutPeer [ R < : RpcResponse ] ( 
 outPeer : ApiOutPeer 
 ) ( 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . a58ada7 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / webrtc / WebrtcServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 66 @ @ 
 + package im . actor . server . api . rpc . service . webrtc 
 + 
 + import akka . actor . ActorSystem 
 + import akka . http . scaladsl . util . FastFuture 
 + import im . actor . api . rpc . _ 
 + import im . actor . api . rpc . misc . ResponseVoid 
 + import im . actor . api . rpc . peers . ApiOutPeer 
 + import im . actor . api . rpc . webrtc . { ResponseDoCall , WebrtcService } 
 + import im . actor . server . session . _ 
 + import im . actor . server . webrtc . { WebrtcExtension , Webrtc } 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + final class WebrtcServiceImpl ( implicit system : ActorSystem , sessionRegion : SessionRegion ) extends WebrtcService { 
 + import PeerHelpers . _ 
 + 
 + override implicit protected val ec : ExecutionContext = system . dispatcher 
 + 
 + val webrtcExt = WebrtcExtension ( system ) 
 + 
 + override def jhandleDoCall ( peer : ApiOutPeer , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseDoCall ] ] = 
 + authorized ( clientData ) { implicit client ⇒ 
 + withOutPeerF ( peer ) { 
 + for { 
 + callId ← webrtcExt . doCall ( client . userId , peer . id ) 
 + } yield Ok ( ResponseDoCall ( callId ) ) 
 + } 
 + } 
 + 
 + override def jhandleEndCall ( callId : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + _ ← webrtcExt . endCall ( client . userId , callId ) 
 + } yield Ok ( ResponseVoid ) 
 + } 
 + 
 + override def jhandleUnsubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + sessionRegion . ref ! 
 + SessionEnvelope ( clientData . authId , clientData . sessionId ) 
 + . withUnsubscribeFromWeak ( UnsubscribeFromWeak ( Some ( Webrtc . WeakGroup ) ) ) 
 + FastFuture . successful ( Ok ( ResponseVoid ) ) 
 + } 
 + 
 + override def jhandleCallInProgress ( callId : Long , timeout : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + _ ← webrtcExt . sendCallInProgress ( client . userId , callId , timeout ) 
 + } yield Ok ( ResponseVoid ) 
 + } 
 + 
 + override def jhandleSubscribeToCalls ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + sessionRegion . ref ! 
 + SessionEnvelope ( clientData . authId , clientData . sessionId ) 
 + . withSubscribeToWeak ( SubscribeToWeak ( Some ( Webrtc . WeakGroup ) ) ) 
 + FastFuture . successful ( Ok ( ResponseVoid ) ) 
 + } 
 + 
 + override def jhandleSendCallSignal ( callId : Long , content : Array [ Byte ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + for { 
 + _ ← webrtcExt . sendCallSignal ( client . userId , callId , content ) 
 + } yield Ok ( ResponseVoid ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 index d2aff17 . . 77b49b3 100644 
 - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 @ @ - 26 , 7 + 26 , 7 @ @ import im . actor . server . api . rpc . service . users . UsersServiceImpl 
 import im . actor . server . api . rpc . service . weak . WeakServiceImpl 
 import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl 
 import im . actor . server . api . rpc . service . webhooks . IntegrationsServiceImpl 
 - import im . actor . server . bot . ActorBot 
 + import im . actor . server . bot . { BotExtension , ActorBot } 
 import im . actor . server . cli . ActorCliService 
 import im . actor . server . db . DbExtension 
 import im . actor . server . dialog . { DialogExtension , DialogProcessor } 
 @ @ - 251 , 6 + 251 , 9 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( 
 featuresService 
 ) 
 
 + system . log . warning ( " Starting BotExtension " ) 
 + BotExtension ( system ) 
 + 
 system . log . warning ( " Starting ActorBot " ) 
 ActorBot . start ( ) 
 
 diff - - git a / actor - server / actor - session - messages / src / main / protobuf / session . proto b / actor - server / actor - session - messages / src / main / protobuf / session . proto 
 index 1c08672 . . d01c0bd 100644 
 - - - a / actor - server / actor - session - messages / src / main / protobuf / session . proto 
 + + + b / actor - server / actor - session - messages / src / main / protobuf / session . proto 
 @ @ - 21 , 6 + 21 , 8 @ @ message SessionEnvelope { 
 SubscribeToGroupOnline subscribe _ to _ group _ online = 7 ; 
 SubscribeFromGroupOnline subscribe _ from _ group _ online = 8 ; 
 SubscribeToSeq subscribe _ to _ seq = 9 ; 
 + SubscribeToWeak subscribe _ to _ weak = 10 ; 
 + UnsubscribeFromWeak unsubscribe _ from _ weak = 11 ; 
 } 
 } 
 
 @ @ - 61 , 4 + 63 , 14 @ @ message SubscribeFromGroupOnline { 
 
 message SubscribeToSeq { 
 option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; 
 + } 
 + 
 + message SubscribeToWeak { 
 + option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; 
 + optional string group = 1 ; 
 + } 
 + 
 + message UnsubscribeFromWeak { 
 + option ( scalapb . message ) . extends = " im . actor . server . session . SubscribeCommand " ; 
 + optional string group = 1 ; 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 936187b . . 74e353a 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 4 , 7 + 4 , 7 @ @ import sbt . _ 
 
 object Dependencies { 
 object V { 
 - val actorCommons = " 0 . 0 . 8 " 
 + val actorCommons = " 0 . 0 . 9 " 
 val actorBotkit = " 1 . 0 . 66 " 
 val akka = " 2 . 4 . 0 " 
 val akkaExperimental = " 2 . 0 . 2 "

NEAREST DIFF:
diff - - git a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala 
 index 6137afb . . 8162272 100644 
 - - - a / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala 
 + + + b / actor - server / actor - bots / src / main / scala / im / actor / server / bot / ApiToBotConversions . scala 
 @ @ - 57 , 6 + 57 , 7 @ @ trait ApiToBotConversions { 
 thumb , 
 ext ) ⇒ DocumentMessage ( fileId , accessHash , fileSize . toLong , name , mimeType , thumb , ext ) 
 case ApiServiceMessage ( text , _ ) ⇒ ServiceMessage ( text ) 
 + case _ : ApiStickerMessage ⇒ UnsupportedMessage 
 case _ : ApiUnsupportedMessage ⇒ UnsupportedMessage 
 } 
 
 diff - - git a / actor - server / actor - core / src / main / actor - api / actor . json b / actor - server / actor - core / src / main / actor - api / actor . json 
 index 4cd3afa . . b1c9292 100644 
 - - - a / actor - server / actor - core / src / main / actor - api / actor . json 
 + + + b / actor - server / actor - core / src / main / actor - api / actor . json 
 @ @ - 3806 , 6 + 3806 , 112 @ @ 
 { 
 " type " : " struct " , 
 " content " : { 
 + " name " : " StickerMessage " , 
 + " doc " : [ 
 + " Sticker message " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " stickerId " , 
 + " category " : " full " , 
 + " description " : " Optional Unique ID of sticker " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " fastPreview " , 
 + " category " : " full " , 
 + " description " : " Optional Fast preview of sticker in webp format " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " image512 " , 
 + " category " : " full " , 
 + " description " : " Optional 512x512 sticker image in webp format " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " image256 " , 
 + " category " : " full " , 
 + " description " : " Optional 256x256 sticker image in webp format " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " stickerCollectionId " , 
 + " category " : " full " , 
 + " description " : " Optional Collection ID " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " stickerCollectionAccessHash " , 
 + " category " : " full " , 
 + " description " : " Optional Collection Access Hash " 
 + } 
 + ] , 
 + " trait " : { 
 + " name " : " Message " , 
 + " key " : 6 
 + } , 
 + " expandable " : " true " , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " int32 " 
 + } , 
 + " id " : 1 , 
 + " name " : " stickerId " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " bytes " 
 + } , 
 + " id " : 2 , 
 + " name " : " fastPreview " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " ImageLocation " 
 + } 
 + } , 
 + " id " : 3 , 
 + " name " : " image512 " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " ImageLocation " 
 + } 
 + } , 
 + " id " : 4 , 
 + " name " : " image256 " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " int32 " 
 + } , 
 + " id " : 5 , 
 + " name " : " stickerCollectionId " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " int64 " 
 + } , 
 + " id " : 6 , 
 + " name " : " stickerCollectionAccessHash " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 " name " : " DialogShort " , 
 " doc " : [ 
 " Short Dialog from grouped conversation list " , 
 @ @ - 7649 , 6 + 7755 , 433 @ @ 
 ] 
 } , 
 { 
 + " title " : " Stickers " , 
 + " package " : " stickers " , 
 + " doc " : [ 
 + " Stickers support in Actor " 
 + ] , 
 + " items " : [ 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " StickerDescriptor " , 
 + " doc " : [ 
 + " Descriptor of a Sticker " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " id " , 
 + " category " : " full " , 
 + " description " : " Sticker unique id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " emoji " , 
 + " category " : " full " , 
 + " description " : " Emoji code for sticker " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " image128 " , 
 + " category " : " full " , 
 + " description " : " Image of sticker 128x128 in WebP format " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " image512 " , 
 + " category " : " full " , 
 + " description " : " Image of sticker 512x512 in WebP format " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " image256 " , 
 + " category " : " full " , 
 + " description " : " Image of sticker 256x256 in WebP format " 
 + } 
 + ] , 
 + " expandable " : " true " , 
 + " attributes " : [ 
 + { 
 + " type " : " int32 " , 
 + " id " : 1 , 
 + " name " : " id " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : " string " 
 + } , 
 + " id " : 2 , 
 + " name " : " emoji " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " ImageLocation " 
 + } , 
 + " id " : 3 , 
 + " name " : " image128 " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " ImageLocation " 
 + } 
 + } , 
 + " id " : 4 , 
 + " name " : " image512 " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " opt " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " ImageLocation " 
 + } 
 + } , 
 + " id " : 5 , 
 + " name " : " image256 " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " struct " , 
 + " content " : { 
 + " name " : " StickerCollection " , 
 + " doc " : [ 
 + " Sticker collection " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " id " , 
 + " category " : " full " , 
 + " description " : " Unique id of a collection " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " accessHash " , 
 + " category " : " full " , 
 + " description " : " Access Hash of a collection " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " stickers " , 
 + " category " : " compact " , 
 + " description " : " Sticker list " 
 + } 
 + ] , 
 + " expandable " : " true " , 
 + " attributes " : [ 
 + { 
 + " type " : " int32 " , 
 + " id " : 1 , 
 + " name " : " id " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " accessHash " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " StickerDescriptor " 
 + } 
 + } , 
 + " id " : 3 , 
 + " name " : " stickers " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " response " , 
 + " content " : { 
 + " name " : " StickersReponse " , 
 + " header " : 240 , 
 + " doc " : [ 
 + " Stickers response " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " collections " , 
 + " category " : " full " , 
 + " description " : " Sticker collections " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " seq " , 
 + " category " : " full " , 
 + " description " : " Seq of update " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " state " , 
 + " category " : " full " , 
 + " description " : " State of update " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " StickerCollection " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " collections " 
 + } , 
 + { 
 + " type " : " int32 " , 
 + " id " : 2 , 
 + " name " : " seq " 
 + } , 
 + { 
 + " type " : { 
 + " type " : " alias " , 
 + " childType " : " seq _ state " 
 + } , 
 + " id " : 3 , 
 + " name " : " state " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadOwnStickers " , 
 + " header " : 238 , 
 + " response " : { 
 + " type " : " anonymous " , 
 + " header " : 239 , 
 + " doc " : [ 
 + " Own Stickers collections " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " ownStickers " , 
 + " category " : " hidden " , 
 + " description " : " Own sticker collections " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " StickerCollection " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " ownStickers " 
 + } 
 + ] 
 + } , 
 + " doc " : [ 
 + " Loading own stickers " 
 + ] , 
 + " attributes " : [ ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " OwnStickersChanged " , 
 + " header " : 161 , 
 + " doc " : [ 
 + " Own Stickers changed " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " collections " , 
 + " category " : " compact " , 
 + " description " : " New own sticker collections " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " StickerCollection " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " collections " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " update " , 
 + " content " : { 
 + " name " : " StickerCollectionsChanged " , 
 + " header " : 164 , 
 + " doc " : [ 
 + " Sticker collection changed " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " collections " , 
 + " category " : " full " , 
 + " description " : " Updated sticker collections " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " list " , 
 + " childType " : { 
 + " type " : " struct " , 
 + " childType " : " StickerCollection " 
 + } 
 + } , 
 + " id " : 1 , 
 + " name " : " collections " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " AddStickerCollection " , 
 + " header " : 244 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " StickersReponse " 
 + } , 
 + " doc " : [ 
 + " Adding sticker collection " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " id " , 
 + " category " : " full " , 
 + " description " : " Collection id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " accessHash " , 
 + " category " : " full " , 
 + " description " : " Collection access hash " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " int32 " , 
 + " id " : 1 , 
 + " name " : " id " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " accessHash " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " RemoveStickerCollection " , 
 + " header " : 245 , 
 + " response " : { 
 + " type " : " reference " , 
 + " name " : " StickersReponse " 
 + } , 
 + " doc " : [ 
 + " Removing sticker collection " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " id " , 
 + " category " : " full " , 
 + " description " : " Collection id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " accessHash " , 
 + " category " : " full " , 
 + " description " : " Collection access hash " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " int32 " , 
 + " id " : 1 , 
 + " name " : " id " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " accessHash " 
 + } 
 + ] 
 + } 
 + } , 
 + { 
 + " type " : " rpc " , 
 + " content " : { 
 + " name " : " LoadStickerCollection " , 
 + " header " : 246 , 
 + " response " : { 
 + " type " : " anonymous " , 
 + " header " : 247 , 
 + " doc " : [ 
 + " Loaded collection " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " collection " , 
 + " category " : " full " , 
 + " description " : " Collection of stickers " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : { 
 + " type " : " struct " , 
 + " childType " : " StickerCollection " 
 + } , 
 + " id " : 1 , 
 + " name " : " collection " 
 + } 
 + ] 
 + } , 
 + " doc " : [ 
 + " Loading stickers " , 
 + { 
 + " type " : " reference " , 
 + " argument " : " id " , 
 + " category " : " full " , 
 + " description " : " Collection id " 
 + } , 
 + { 
 + " type " : " reference " , 
 + " argument " : " accessHash " , 
 + " category " : " full " , 
 + " description " : " Collection access hash " 
 + } 
 + ] , 
 + " attributes " : [ 
 + { 
 + " type " : " int32 " , 
 + " id " : 1 , 
 + " name " : " id " 
 + } , 
 + { 
 + " type " : " int64 " , 
 + " id " : 2 , 
 + " name " : " accessHash " 
 + } 
 + ] 
 + } 
 + } 
 + ] 
 + } , 
 + { 
 " title " : " Search " , 
 " package " : " search " , 
 " doc " : [ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala b / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala 
 index b397af8 . . c7a682a 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / rpc / FutureResultRpcCats . scala 
 @ @ - 33 , 5 + 33 , 7 @ @ object FutureResultRpcCats extends FutureInstances with EitherInstances { 
 
 def fromBoolean [ A ] ( failure : RpcError ) ( oa : Boolean ) : Result [ Unit ] = Result [ Unit ] ( Future . successful ( if ( oa ) right ( ( ) ) else left ( failure ) ) ) 
 
 - implicit def toScalaz [ A ] ( catsResult : RpcError Xor A ) : RpcError \ / A = catsResult . fold ( - \ / ( _ ) , \ / - ( _ ) ) 
 + implicit class ToScalaz [ A ] ( catsResult : RpcError Xor A ) { 
 + def toScalaz : RpcError \ / A = catsResult . fold ( - \ / ( _ ) , \ / - ( _ ) ) 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 index 3421414 . . 4dea619 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / acl / ACLUtils . scala 
 @ @ - 43 , 6 + 43 , 12 @ @ object ACLUtils { 
 def fileAccessHash ( fileId : Long , accessSalt : String ) ( implicit s : ActorSystem ) : Long = 
 hash ( s " $ fileId : $ accessSalt : $ { secretKey ( ) } " ) 
 
 + def stickerPackAccessHash ( id : Int , ownerUserId : Int , accessSalt : String ) ( implicit s : ActorSystem ) : Long = 
 + hash ( s " $ id : $ ownerUserId : $ accessSalt : $ { secretKey ( ) } " ) 
 + 
 + def stickerPackAccessHash ( pack : model . StickerPack ) ( implicit s : ActorSystem ) : Long = 
 + stickerPackAccessHash ( pack . id , pack . ownerUserId , pack . accessSalt ) 
 + 
 def authTransactionHash ( accessSalt : String ) ( implicit s : ActorSystem ) : String = 
 DigestUtils . sha1Hex ( s " $ accessSalt : $ { secretKey ( ) } " ) 
 
 diff - - git a / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala b / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala 
 new file mode 100644 
 index 0000000 . . 4a9a2fd 
 - - - / dev / null 
 + + + b / actor - server / actor - models / src / main / scala / im / actor / server / model / stickers . scala 
 @ @ - 0 , 0 + 1 , 20 @ @ 
 + package im . actor . server . model 
 + 
 + case class StickerData ( 
 + id : Int , 
 + packId : Int , 
 + emoji : Option [ String ] , 
 + image128FileId : Long , 
 + image128FileHash : Long , 
 + image128FileSize : Long , 
 + image256FileId : Option [ Long ] , 
 + image256FileHash : Option [ Long ] , 
 + image256FileSize : Option [ Long ] , 
 + image512FileId : Option [ Long ] , 
 + image512FileHash : Option [ Long ] , 
 + image512FileSize : Option [ Long ] 
 + ) 
 + 
 + case class StickerPack ( id : Int , accessSalt : String , ownerUserId : Int , isDefault : Boolean ) 
 + 
 + case class OwnStickerPack ( userId : Int , packId : Int ) 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql b / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql 
 new file mode 100644 
 index 0000000 . . 380f7cf 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / resources / sql / migration / V20151207212343 _ _ AddStickers . sql 
 @ @ - 0 , 0 + 1 , 29 @ @ 
 + create table sticker _ packs ( 
 + id int not null , 
 + access _ salt varchar ( 255 ) not null , 
 + owner _ user _ id int not null , 
 + is _ default boolean not null default false , 
 + primary key ( id ) 
 + ) ; 
 + 
 + create table own _ sticker _ packs ( 
 + user _ id int not null , 
 + pack _ id int not null , 
 + primary key ( user _ id , pack _ id ) 
 + ) ; 
 + 
 + create table sticker _ data ( 
 + id int not null , 
 + pack _ id int not null , 
 + emoji varchar ( 16 ) , 
 + image _ 128 _ file _ id bigint not null , 
 + image _ 128 _ file _ hash bigint not null , 
 + image _ 128 _ file _ size bigint not null , 
 + image _ 256 _ file _ id bigint , 
 + image _ 256 _ file _ hash bigint , 
 + image _ 256 _ file _ size bigint , 
 + image _ 512 _ file _ id bigint , 
 + image _ 512 _ file _ hash bigint , 
 + image _ 512 _ file _ size bigint , 
 + primary key ( id , pack _ id ) 
 + ) ; 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala 
 new file mode 100644 
 index 0000000 . . c37a529 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / OwnStickerPackRepo . scala 
 @ @ - 0 , 0 + 1 , 30 @ @ 
 + package im . actor . server . persist 
 + 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . model . OwnStickerPack 
 + import slick . dbio . Effect . Read 
 + import slick . profile . FixedSqlStreamingAction 
 + 
 + class OwnStickerPackTable ( tag : Tag ) extends Table [ OwnStickerPack ] ( tag , " own _ sticker _ packs " ) { 
 + def userId = column [ Int ] ( " user _ id " , O . PrimaryKey ) 
 + def packId = column [ Int ] ( " pack _ id " , O . PrimaryKey ) 
 + 
 + def * = ( userId , packId ) < > ( OwnStickerPack . tupled , OwnStickerPack . unapply ) 
 + } 
 + 
 + object OwnStickerPackRepo { 
 + 
 + val ownStickerPacks = TableQuery [ OwnStickerPackTable ] 
 + 
 + def create ( userId : Int , packId : Int ) = 
 + ownStickerPacks + = OwnStickerPack ( userId , packId ) 
 + 
 + def delete ( userId : Int , packId : Int ) = 
 + ownStickerPacks . filter ( p ⇒ p . userId = = = userId & & p . packId = = = packId ) . delete 
 + 
 + def findPackIds ( userId : Int ) : DBIO [ Seq [ Int ] ] = ownStickerPacks . filter ( _ . userId = = = userId ) . map ( _ . packId ) . result 
 + 
 + def exists ( userId : Int , packId : Int ) : DBIO [ Boolean ] = 
 + ownStickerPacks . filter ( p ⇒ p . userId = = = userId & & p . packId = = = packId ) . exists . result 
 + 
 + } 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala 
 new file mode 100644 
 index 0000000 . . 4d5046d 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerDataRepo . scala 
 @ @ - 0 , 0 + 1 , 44 @ @ 
 + package im . actor . server . persist 
 + 
 + import im . actor . server . model . StickerData 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + 
 + class StickerDataTable ( tag : Tag ) extends Table [ StickerData ] ( tag , " sticker _ data " ) { 
 + def id = column [ Int ] ( " id " , O . PrimaryKey ) 
 + def packId = column [ Int ] ( " pack _ id " , O . PrimaryKey ) 
 + def emoji = column [ Option [ String ] ] ( " emoji " ) 
 + def image128FileId = column [ Long ] ( " image _ 128 _ file _ id " ) 
 + def image128FileHash = column [ Long ] ( " image _ 128 _ file _ hash " ) 
 + def image128FileSize = column [ Long ] ( " image _ 128 _ file _ size " ) 
 + def image256FileId = column [ Option [ Long ] ] ( " image _ 256 _ file _ id " ) 
 + def image256FileHash = column [ Option [ Long ] ] ( " image _ 256 _ file _ hash " ) 
 + def image256FileSize = column [ Option [ Long ] ] ( " image _ 256 _ file _ size " ) 
 + def image512FileId = column [ Option [ Long ] ] ( " image _ 512 _ file _ id " ) 
 + def image512FileHash = column [ Option [ Long ] ] ( " image _ 512 _ file _ hash " ) 
 + def image512FileSize = column [ Option [ Long ] ] ( " image _ 512 _ file _ size " ) 
 + 
 + def * = ( 
 + id , 
 + packId , 
 + emoji , 
 + image128FileId , 
 + image128FileHash , 
 + image128FileSize , 
 + image256FileId , 
 + image256FileHash , 
 + image256FileSize , 
 + image512FileId , 
 + image512FileHash , 
 + image512FileSize 
 + ) < > ( StickerData . tupled , StickerData . unapply ) 
 + } 
 + 
 + object StickerDataRepo { 
 + 
 + val stickerDatas = TableQuery [ StickerDataTable ] 
 + 
 + def find ( id : Int ) = stickerDatas . filter ( _ . id = = = id ) . result 
 + 
 + def findByPack ( packId : Int ) = stickerDatas . filter ( _ . packId = = = packId ) . result 
 + 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala 
 new file mode 100644 
 index 0000000 . . f0d560f 
 - - - / dev / null 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / StickerPackRepo . scala 
 @ @ - 0 , 0 + 1 , 33 @ @ 
 + package im . actor . server . persist 
 + 
 + import slick . lifted . Tag 
 + import im . actor . server . db . ActorPostgresDriver . api . _ 
 + import im . actor . server . model . StickerPack 
 + 
 + class StickerPackTable ( tag : Tag ) extends Table [ StickerPack ] ( tag , " sticker _ packs " ) { 
 + def id = column [ Int ] ( " id " , O . PrimaryKey ) 
 + def accessSalt = column [ String ] ( " access _ salt " ) 
 + def ownerUserId = column [ Int ] ( " owner _ user _ id " ) 
 + def isDefault = column [ Boolean ] ( " is _ default " ) 
 + 
 + def * = ( id , accessSalt , ownerUserId , isDefault ) < > ( StickerPack . tupled , StickerPack . unapply ) 
 + } 
 + 
 + object StickerPackRepo { 
 + val stickerPacks = TableQuery [ StickerPackTable ] 
 + 
 + def create ( pack : StickerPack ) = 
 + stickerPacks + = pack 
 + 
 + / / def findDefaultPacks = stickerPacks . filter ( _ . isDefault ) . result 
 + 
 + / / def findOwnPacks ( userId : Int ) = stickerPacks . filter ( p ⇒ p . isDefault | | p . ownerUserId = = = userId ) . result 
 + 
 + def find ( id : Int ) = stickerPacks . filter ( _ . id = = = id ) . result . headOption 
 + 
 + def find ( ids : Seq [ Int ] , withDefault : Boolean = true ) : DBIO [ Seq [ StickerPack ] ] = 
 + ( if ( withDefault ) 
 + stickerPacks . filter ( p ⇒ p . isDefault | | ( p . id inSet ids . toSet ) ) 
 + else 
 + stickerPacks . filter ( p ⇒ p . id inSet ids ) ) . result 
 + } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 index e5dbaf9 . . ed8255e 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / HistoryHandlers . scala 
 @ @ - 270 , 6 + 270 , 7 @ @ trait HistoryHandlers { 
 case ApiTextMessage ( _ , mentions , _ ) ⇒ mentions . toSet 
 case ApiJsonMessage ( _ ) ⇒ Set . empty 
 case _ : ApiDocumentMessage ⇒ Set . empty 
 + case _ : ApiStickerMessage ⇒ Set . empty 
 case _ : ApiUnsupportedMessage ⇒ Set . empty 
 } 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala 
 new file mode 100644 
 index 0000000 . . 8f347c3 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / ImplicitConversions . scala 
 @ @ - 0 , 0 + 1 , 34 @ @ 
 + package im . actor . server . api . rpc . service . stickers 
 + 
 + import im . actor . api . rpc . files . { ApiFileLocation , ApiImageLocation } 
 + import im . actor . api . rpc . stickers . ApiStickerDescriptor 
 + import im . actor . server . model . StickerData 
 + 
 + import scala . language . implicitConversions 
 + 
 + trait ImplicitConversions { 
 + 
 + implicit def stickerToApi ( s : StickerData ) : ApiStickerDescriptor = { 
 + ApiStickerDescriptor ( 
 + s . id , 
 + s . emoji , 
 + imageLocation ( s . image128FileId , s . image128FileHash , 128 , s . image128FileSize ) , 
 + optImageLocation ( s . image512FileId , s . image512FileHash , 512 , s . image512FileSize ) , 
 + optImageLocation ( s . image256FileId , s . image256FileHash , 256 , s . image256FileSize ) 
 + ) 
 + } 
 + 
 + implicit def stickerToApi ( stickers : Seq [ StickerData ] ) : IndexedSeq [ ApiStickerDescriptor ] = 
 + stickers . toVector map stickerToApi 
 + 
 + private def imageLocation ( fileId : Long , fileHash : Long , side : Int , fileSize : Long ) : ApiImageLocation = 
 + ApiImageLocation ( ApiFileLocation ( fileId , fileHash ) , side , side , fileSize . toInt ) 
 + 
 + private def optImageLocation ( fileId : Option [ Long ] , fileHash : Option [ Long ] , side : Int , fileSize : Option [ Long ] ) : Option [ ApiImageLocation ] = 
 + for { 
 + id ← fileId 
 + hash ← fileHash 
 + size ← fileSize 
 + } yield imageLocation ( id , hash , side , size ) 
 + 
 + } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala 
 new file mode 100644 
 index 0000000 . . dac5053 
 - - - / dev / null 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / stickers / StickersServiceImpl . scala 
 @ @ - 0 , 0 + 1 , 81 @ @ 
 + package im . actor . server . api . rpc . service . stickers 
 + 
 + import akka . actor . ActorSystem 
 + import im . actor . api . rpc . stickers . _ 
 + import im . actor . api . rpc . { ClientData , _ } 
 + import im . actor . server . acl . ACLUtils . stickerPackAccessHash 
 + import im . actor . server . db . DbExtension 
 + import im . actor . server . persist 
 + import im . actor . server . sequence . { SeqState , SeqUpdatesExtension } 
 + import slick . dbio . DBIO 
 + 
 + import scala . concurrent . { ExecutionContext , Future } 
 + 
 + object StickerPackErrors { 
 + val PackNotFound = RpcError ( 404 , " PACK _ NOT _ FOUND " , " Sticker pack not found " , false , None ) 
 + val AlreadyAdded = RpcError ( 400 , " PACK _ ALREADY _ ADDED " , " Sticker pack already added " , false , None ) 
 + val AlreadyRemoved = RpcError ( 400 , " PACK _ ALREADY _ REMOVED " , " Sticker pack already removed " , false , None ) 
 + } 
 + 
 + class StickersServiceImpl ( implicit actorSystem : ActorSystem ) extends StickersService with ImplicitConversions { 
 + 
 + import FutureResultRpcCats . _ 
 + import StickerPackErrors . _ 
 + 
 + override implicit protected val ec : ExecutionContext = actorSystem . dispatcher 
 + 
 + private val db = DbExtension ( actorSystem ) . db 
 + private val seqUpdExt = SeqUpdatesExtension ( actorSystem ) 
 + 
 + override def jhandleLoadStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadStickerCollection ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + ( for { 
 + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) 
 + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) 
 + stickers ← fromFuture ( db . run ( persist . StickerDataRepo . findByPack ( pack . id ) ) ) 
 + } yield ResponseLoadStickerCollection ( ApiStickerCollection ( pack . id , accessHash , stickers ) ) ) . value map ( _ . toScalaz ) 
 + } 
 + 
 + override def jhandleRemoveStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseStickersReponse ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + ( for { 
 + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) 
 + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) 
 + _ ← fromFutureBoolean ( AlreadyRemoved ) ( db . run ( persist . OwnStickerPackRepo . exists ( client . userId , pack . id ) map ! = ) ) 
 + _ ← fromFuture ( db . run ( persist . OwnStickerPackRepo . delete ( client . userId , pack . id ) ) ) 
 + seqState ← fromFuture ( seqUpdExt . getSeqState ( client . userId ) ) 
 + SeqState ( seq , state ) = seqState 
 + stickers ← fromFuture ( db . run ( getStickerPacks ( client . userId ) ) ) 
 + } yield ResponseStickersReponse ( stickers , seq , state . toByteArray ) ) . value map ( _ . toScalaz ) 
 + } 
 + 
 + override def jhandleAddStickerCollection ( id : Int , accessHash : Long , clientData : ClientData ) : Future [ HandlerResult [ ResponseStickersReponse ] ] = 
 + authorized ( clientData ) { client ⇒ 
 + ( for { 
 + pack ← fromFutureOption ( PackNotFound ) ( db . run ( persist . StickerPackRepo . find ( id ) ) ) 
 + _ ← fromBoolean ( CommonErrors . InvalidAccessHash ) ( stickerPackAccessHash ( pack ) = = accessHash ) 
 + _ ← fromFutureBoolean ( AlreadyAdded ) ( db . run ( persist . OwnStickerPackRepo . exists ( client . userId , pack . id ) ) ) 
 + _ ← fromFuture ( db . run ( persist . OwnStickerPackRepo . create ( client . userId , pack . id ) ) ) 
 + seqState ← fromFuture ( seqUpdExt . getSeqState ( client . userId ) ) 
 + SeqState ( seq , state ) = seqState 
 + stickers ← fromFuture ( db . run ( getStickerPacks ( client . userId ) ) ) 
 + } yield ResponseStickersReponse ( stickers , seq , state . toByteArray ) ) . value map ( _ . toScalaz ) 
 + } 
 + 
 + override def jhandleLoadOwnStickers ( clientData : ClientData ) : Future [ HandlerResult [ ResponseLoadOwnStickers ] ] = { 
 + val action = requireAuth ( clientData ) map { implicit client ⇒ 
 + getStickerPacks ( client . userId ) map ( stickers ⇒ Ok ( ResponseLoadOwnStickers ( stickers ) ) ) 
 + } 
 + db . run ( toDBIOAction ( action ) ) 
 + } 
 + 
 + private def getStickerPacks ( userId : Int ) : DBIO [ Vector [ ApiStickerCollection ] ] = 
 + for { 
 + packIds ← persist . OwnStickerPackRepo . findPackIds ( userId ) 
 + packs ← persist . StickerPackRepo . find ( packIds ) 
 + stickerCollections ← DBIO . sequence ( packs . toVector map { pack ⇒ 
 + for ( stickers ← persist . StickerDataRepo . findByPack ( pack . id ) ) yield ApiStickerCollection ( pack . id , stickerPackAccessHash ( pack ) , stickers ) 
 + } ) 
 + } yield stickerCollections 
 + 
 + } 
 diff - - git a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 index 885ffff . . 2ef537a 100644 
 - - - a / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 + + + b / actor - server / actor - server - sdk / src / main / scala / im / actor / server / ActorServer . scala 
 @ @ - 21 , 6 + 21 , 7 @ @ import im . actor . server . api . rpc . service . profile . ProfileServiceImpl 
 import im . actor . server . api . rpc . service . pubgroups . PubgroupsServiceImpl 
 import im . actor . server . api . rpc . service . push . PushServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 + import im . actor . server . api . rpc . service . stickers . StickersServiceImpl 
 import im . actor . server . api . rpc . service . users . UsersServiceImpl 
 import im . actor . server . api . rpc . service . weak . WeakServiceImpl 
 import im . actor . server . api . rpc . service . webactions . WebactionsServiceImpl 
 @ @ - 49 , 7 + 50 , 8 @ @ final case class ActorServer ( system : ActorSystem ) 
 object ActorServer { 
 / * * 
 * Creates a new Actor Server builder 
 - * @ return 
 + * 
 + * @ return 
 * / 
 def newBuilder : ActorServerBuilder = ActorServerBuilder ( ) 
 } 
 @ @ - 71 , 7 + 73 , 8 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( 
 
 / * * 
 * Starts a server 
 - * @ return 
 + * 
 + * @ return 
 * / 
 def start ( ) : ActorServer = { 
 SessionMessage . register ( ) 
 @ @ - 216 , 6 + 219 , 9 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( 
 system . log . debug ( " Starting DeviceService " ) 
 val deviceService = new DeviceServiceImpl 
 
 + system . log . debug ( " Starting StickersServiceImpl " ) 
 + val stickerService = new StickersServiceImpl 
 + 
 val services = Seq ( 
 authService , 
 contactsService , 
 @ @ - 231 , 7 + 237 , 8 @ @ final case class ActorServerBuilder ( defaultConfig : Config = ConfigFactory . empty ( 
 profileService , 
 integrationsService , 
 webactionsService , 
 - deviceService 
 + deviceService , 
 + stickerService 
 ) 
 
 system . log . warning ( " Starting ActorBot " )
