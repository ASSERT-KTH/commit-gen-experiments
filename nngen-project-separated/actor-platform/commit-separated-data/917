BLEU SCORE: 0.20958712452883563

TEST MSG: fix ( server ) : telesign activation
GENERATED MSG: fix ( server : auth ) : improve activation logic

TEST DIFF (one line): diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala < nl > index cb8793c . . 81c5948 100644 < nl > - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala < nl > + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala < nl > @ @ - 41 , 23 + 41 , 21 @ @ private [ activation ] final class TelesignProvider ( _ system : ActorSystem ) extends A < nl > < nl > override def send ( txHash : String , code : Code ) : Future [ CodeFailure Xor Unit ] = code match { < nl > case s : SmsCode ⇒ < nl > - if ( isTestPhone ( s . phone ) ) { < nl > - Future . successful ( Xor . right ( ( ) ) ) < nl > - } else { < nl > - for { < nl > - resp ← ( smsStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) < nl > - _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) < nl > - } yield resp < nl > - } < nl > + for { < nl > + resp ← if ( isTestPhone ( s . phone ) ) < nl > + Future . successful ( Xor . right ( ( ) ) ) < nl > + else < nl > + ( smsStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) < nl > + _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) < nl > + } yield resp < nl > case c : CallCode ⇒ < nl > - if ( isTestPhone ( c . phone ) ) { < nl > - Future . successful ( Xor . right ( ( ) ) ) < nl > - } else { < nl > - for { < nl > - resp ← ( callStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) < nl > - _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) < nl > - } yield resp < nl > - } < nl > + for { < nl > + resp ← if ( isTestPhone ( c . phone ) ) < nl > + Future . successful ( Xor . right ( ( ) ) ) < nl > + else < nl > + ( callStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) < nl > + _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) < nl > + } yield resp < nl > case other ⇒ throw new RuntimeException ( s " This provider can ' t handle code of type : $ { other . getClass } " ) < nl > } < nl > }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala < nl > index 23f1360 . . cd30bde 100644 < nl > - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala < nl > + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala < nl > @ @ - 4 , 7 + 4 , 31 @ @ object Activation { < nl > sealed trait Code { < nl > def code : String < nl > } < nl > - final case class SmsCode ( phone : Long , code : String ) extends Code < nl > - final case class CallCode ( phone : Long , code : String , language : String ) extends Code < nl > - final case class EmailCode ( email : String , code : String ) extends Code < nl > + sealed trait PhoneCode extends Code { < nl > + def phone : Long < nl > + } < nl > + final case class SmsCode ( phone : Long , code : String ) extends PhoneCode { < nl > + override def equals ( that : Any ) : Boolean = < nl > + that match { < nl > + case that : SmsCode ⇒ this . phone = = that . phone < nl > + case _ ⇒ false < nl > + } < nl > + override def hashCode ( ) : Int = phone . hashCode ( ) < nl > + } < nl > + final case class CallCode ( phone : Long , code : String , language : String ) extends PhoneCode { < nl > + override def equals ( that : Any ) : Boolean = < nl > + that match { < nl > + case that : CallCode ⇒ this . phone = = that . phone < nl > + case _ ⇒ false < nl > + } < nl > + override def hashCode ( ) : Int = phone . hashCode ( ) < nl > + } < nl > + final case class EmailCode ( email : String , code : String ) extends Code { < nl > + override def equals ( that : Any ) : Boolean = < nl > + that match { < nl > + case that : EmailCode ⇒ this . email = = that . email < nl > + case _ ⇒ false < nl > + } < nl > + override def hashCode ( ) : Int = email . hashCode ( ) < nl > + } < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > index abd0e61 . . 1c6616c 100644 < nl > - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala < nl > @ @ - 1 , 15 + 1 , 17 @ @ < nl > package im . actor . server . activation . gate < nl > < nl > + import akka . http . scaladsl . marshalling . Marshal < nl > + import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport < nl > + < nl > import scala . concurrent . { ExecutionContext , Future } < nl > import scalaz . { - \ / , \ / , \ / - } < nl > < nl > import akka . actor . ActorSystem < nl > import akka . http . scaladsl . Http < nl > import akka . http . scaladsl . model . HttpMethods . { GET , POST } < nl > - import akka . http . scaladsl . model . { HttpRequest , Uri } < nl > + import akka . http . scaladsl . model . { RequestEntity , HttpRequest , Uri } < nl > import akka . http . scaladsl . unmarshalling . Unmarshal < nl > import akka . stream . Materializer < nl > - import play . api . libs . json . Json < nl > import slick . dbio . DBIO < nl > < nl > import im . actor . server . activation . Activation . Code < nl > @ @ - 22 , 21 + 24 , 18 @ @ class GateCodeActivation ( config : GateConfig ) ( < nl > system : ActorSystem , < nl > val materializer : Materializer , < nl > ec : ExecutionContext < nl > - ) extends CodeActivation with JsonImplicits { < nl > + ) extends CodeActivation with JsonImplicits with PlayJsonSupport { < nl > < nl > private [ this ] val http = Http ( ) < nl > < nl > override def send ( optTransactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = { < nl > - val request = HttpRequest ( < nl > - method = POST , < nl > - uri = s " $ { config . uri } / v1 / codes / send " , < nl > - entity = Json . toJson ( code ) . toString < nl > - ) < nl > - < nl > - system . log . debug ( " Requesting code send with { } " , request ) < nl > - < nl > val codeResponse : Future [ CodeResponse ] = for { < nl > - resp ← http . singleRequest ( request . withHeaders ( ` X - Auth - Token ` ( config . authToken ) ) ) < nl > + entity ← Marshal ( code ) . to [ RequestEntity ] < nl > + request = HttpRequest ( method = POST , uri = s " $ { config . uri } / v1 / codes / send " ) < nl > + . withEntity ( entity ) < nl > + . withHeaders ( ` X - Auth - Token ` ( config . authToken ) ) < nl > + _ = system . log . debug ( " Requesting code send with { } " , request ) < nl > + resp ← http . singleRequest ( request ) < nl > codeResp ← Unmarshal ( resp ) . to [ CodeResponse ] < nl > } yield codeResp < nl > < nl > @ @ - 45 , 7 + 44 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( < nl > result ← codeResponse match { < nl > case CodeHash ( hash ) ⇒ < nl > optTransactionHash . map { transactionHash ⇒ < nl > - for ( _ ← persist . auth . GateAuthCode . create ( transactionHash , hash ) ) yield \ / - ( ( ) ) < nl > + for ( _ ← persist . auth . GateAuthCode . createOrUpdate ( transactionHash , hash ) ) yield \ / - ( ( ) ) < nl > } getOrElse DBIO . successful ( \ / - ( ( ) ) ) < nl > case CodeError ( message ) ⇒ < nl > DBIO . successful ( - \ / ( message ) ) < nl > diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala < nl > index 83c60fe . . 13ec452 100644 < nl > - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala < nl > + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala < nl > @ @ - 4 , 10 + 4 , 11 @ @ import java . time . temporal . ChronoUnit . _ < nl > import java . time . { LocalDateTime , ZoneOffset } < nl > < nl > import akka . actor . _ < nl > + import akka . pattern . ask < nl > import akka . stream . Materializer < nl > + import akka . util . Timeout < nl > import im . actor . server . activation . Activation . { CallCode , Code , EmailCode , SmsCode } < nl > import im . actor . server . activation . _ < nl > - import im . actor . server . activation . internal . InternalCodeActivation . Send < nl > import im . actor . server . email . { EmailSender , Message } < nl > import im . actor . server . models . AuthCode < nl > import im . actor . server . persist < nl > @ @ - 16 , 7 + 17 , 7 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import scala . concurrent . duration . _ < nl > import scala . concurrent . { ExecutionContext , Future } < nl > - import scalaz . { \ / , \ / - } < nl > + import scalaz . { - \ / , \ / , \ / - } < nl > < nl > object InternalCodeActivation { < nl > < nl > @ @ - 24 , 6 + 25 , 8 @ @ object InternalCodeActivation { < nl > < nl > private [ activation ] final case class Send ( code : Code ) < nl > < nl > + private [ activation ] case class SendAck ( result : String \ / Unit ) < nl > + < nl > private [ activation ] final case class ForgetSentCode ( code : Code ) extends Message < nl > < nl > def newContext ( config : ActivationConfig , smsEngine : AuthSmsEngine , callEngine : AuthCallEngine , emailSender : EmailSender ) ( < nl > @ @ - 42 , 16 + 45 , 15 @ @ object InternalCodeActivation { < nl > < nl > private [ activation ] class InternalCodeActivation ( activationActor : ActorRef , config : ActivationConfig ) ( implicit db : Database , ec : ExecutionContext ) extends CodeActivation { < nl > < nl > + import InternalCodeActivation . _ < nl > import im . actor . server . activation . Activation . _ < nl > < nl > - def send ( transactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = transactionHash match { < nl > - case Some ( hash ) ⇒ < nl > - for { < nl > - _ ← persist . AuthCode . createOrUpdate ( hash , code . code ) < nl > - result ← DBIO . from ( send ( code ) ) < nl > - } yield result < nl > - case None ⇒ DBIO . successful ( \ / - ( send ( code ) ) ) < nl > - } < nl > + implicit val timeout : Timeout = Timeout ( 20 . seconds ) < nl > + < nl > + def send ( transactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = ( transactionHash match { < nl > + case Some ( hash ) ⇒ for ( _ ← persist . AuthCode . createOrUpdate ( hash , code . code ) ) yield ( ) < nl > + case None ⇒ DBIO . successful ( ( ) ) < nl > + } ) flatMap ( _ ⇒ DBIO . from ( sendCode ( code ) ) ) < nl > < nl > def validate ( transactionHash : String , code : String ) : DBIO [ ValidationResponse ] = < nl > for { < nl > @ @ - 74 , 14 + 76 , 11 @ @ private [ activation ] class InternalCodeActivation ( activationActor : ActorRef , conf < nl > private def isExpired ( code : AuthCode ) : Boolean = < nl > code . createdAt . plus ( config . expiration . toMillis , MILLIS ) . isBefore ( LocalDateTime . now ( ZoneOffset . UTC ) ) < nl > < nl > - private def send ( code : Code ) : Future [ String \ / Unit ] = { < nl > + private def sendCode ( code : Code ) : Future [ String \ / Unit ] = < nl > code match { < nl > - case SmsCode ( phone , _ ) ⇒ if ( ! isTestPhone ( phone ) ) activationActor ! Send ( code ) < nl > - case CallCode ( phone , _ , _ ) ⇒ if ( ! isTestPhone ( phone ) ) activationActor ! Send ( code ) < nl > - case _ : EmailCode ⇒ activationActor ! Send ( code ) < nl > + case p : PhoneCode if isTestPhone ( p . phone ) ⇒ Future . successful ( \ / - ( ( ) ) ) < nl > + case _ ⇒ ( activationActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) < nl > } < nl > - Future . successful ( \ / - ( ( ) ) ) < nl > - } < nl > < nl > private def isTestPhone ( number : Long ) : Boolean = number . toString . startsWith ( " 7555 " ) < nl > } < nl > @ @ - 105 , 25 + 104 , 29 @ @ class Activation ( repeatLimit : Duration , smsEngine : AuthSmsEngine , callEngine : Au < nl > system . scheduler . scheduleOnce ( repeatLimit . toMillis . millis , self , ForgetSentCode ( code ) ) < nl > < nl > override def receive : Receive = { < nl > - case Send ( code ) ⇒ sendCode ( code ) < nl > + case Send ( code ) ⇒ < nl > + val replyTo = sender ( ) < nl > + sendCode ( code ) foreach { resp ⇒ replyTo ! SendAck ( resp ) } < nl > case ForgetSentCode ( code ) ⇒ forgetSentCode ( code ) < nl > } < nl > < nl > - private def sendCode ( code : Code ) : Unit = { < nl > + private def sendCode ( code : Code ) : Future [ String \ / Unit ] = { < nl > if ( codeWasNotSent ( code ) ) { < nl > log . debug ( s " Sending $ code " ) < nl > < nl > rememberSentCode ( code ) < nl > < nl > - code match { < nl > + ( code match { < nl > case SmsCode ( phone , c ) ⇒ smsEngine . sendCode ( phone , c ) < nl > case CallCode ( phone , c , language ) ⇒ callEngine . sendCode ( phone , c , language ) < nl > case EmailCode ( email , c ) ⇒ emailSender . send ( Message ( email , " Actor activation code " , s " $ c is your Actor code " ) ) < nl > - } < nl > - < nl > - forgetSentCodeAfterDelay ( code ) < nl > + } ) map { _ ⇒ < nl > + forgetSentCodeAfterDelay ( code ) < nl > + \ / - ( ( ) ) < nl > + } recover { case e ⇒ - \ / ( " Unable to send code " ) } < nl > } else { < nl > log . debug ( s " Ignoring send $ code " ) < nl > + Future . successful ( - \ / ( " Attempt to get code later " ) ) < nl > } < nl > } < nl > < nl > diff - - git a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala < nl > index b2029b7 . . 06d7e8b 100644 < nl > - - - a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala < nl > + + + b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala < nl > @ @ - 28 , 7 + 28 , 7 @ @ abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with A < nl > def onReceive ( message : Object ) : Unit = { } < nl > < nl > def receive = internalReceive orElse { < nl > - case message = > < nl > + case message ⇒ < nl > onReceive ( message . asInstanceOf [ Object ] ) < nl > } < nl > < nl > @ @ - 37 , 9 + 37 , 9 @ @ abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with A < nl > val prefix = " Actor will restart . " < nl > < nl > message match { < nl > - case Some ( msg ) = > < nl > + case Some ( msg ) ⇒ < nl > log . error ( reason , prefix + " Last message received : { } " , msg ) < nl > - case None = > < nl > + case None ⇒ < nl > log . error ( reason , prefix ) < nl > } < nl > < nl > diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala < nl > index b468bd0 . . 1a38ff7 100644 < nl > - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala < nl > + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala < nl > @ @ - 16 , 8 + 16 , 8 @ @ object GateAuthCode { < nl > < nl > val active = codes . filter ( _ . isDeleted = = = false ) < nl > < nl > - def create ( transactionHash : String , codeHash : String ) = < nl > - codes + = models . auth . GateAuthCode ( transactionHash , codeHash ) < nl > + def createOrUpdate ( transactionHash : String , codeHash : String ) = < nl > + codes . insertOrUpdate ( models . auth . GateAuthCode ( transactionHash , codeHash ) ) < nl > < nl > def find ( transactionHash : String ) = < nl > active . filter ( _ . transactionHash = = = transactionHash ) . result . headOption < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > index f00e668 . . 73da5be 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala < nl > @ @ - 20 , 4 + 20 , 6 @ @ object AuthErrors { < nl > val OAuthUserIdDoesNotMatch = RpcError ( 400 , " WRONG _ OAUTH2 _ USER _ ID " , " Email does not match one provided on the first step . " , false , None ) < nl > val ActivationServiceError = RpcError ( 500 , " ACTIVATION _ SERVICE _ ERROR " , " Error occured in activation service . Try again later . " , true , None ) < nl > val InvalidAuthCodeHash = RpcError ( 400 , " CODE _ HASH _ INVALID " , " " , false , None ) < nl > + < nl > + def activationFailure ( message : String ) = RpcError ( 500 , " ACTIVATION _ ERROR " , message , false , None ) < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index f3dca4d . . 8f8a585 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 150 , 20 + 150 , 16 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > normalizedPhone ← fromOption ( AuthErrors . PhoneNumberInvalid ) ( normalizeLong ( phoneNumber ) . headOption ) < nl > optAuthTransaction ← fromDBIO ( persist . auth . AuthPhoneTransaction . findByPhoneAndDeviceHash ( normalizedPhone , deviceHash ) ) < nl > transactionHash ← optAuthTransaction match { < nl > - case Some ( transaction ) ⇒ < nl > - val hash = transaction . transactionHash < nl > - for { < nl > - _ ← fromDBIO ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( hash ) ) ) < nl > - } yield hash < nl > + case Some ( transaction ) ⇒ point ( transaction . transactionHash ) < nl > case None ⇒ < nl > val accessSalt = ACLUtils . nextAccessSalt ( ) < nl > val transactionHash = ACLUtils . authTransactionHash ( accessSalt ) < nl > val phoneAuthTransaction = models . AuthPhoneTransaction ( normalizedPhone , transactionHash , appId , apiKey , deviceHash , deviceTitle , accessSalt ) < nl > for { < nl > _ ← fromDBIO ( persist . auth . AuthPhoneTransaction . create ( phoneAuthTransaction ) ) < nl > - _ ← fromDBIO ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) < nl > } yield transactionHash < nl > } < nl > + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) < nl > isRegistered ← fromDBIO ( persist . UserPhone . exists ( normalizedPhone ) ) < nl > } yield ResponseStartPhoneAuth ( transactionHash , isRegistered ) < nl > db . run ( action . run ) < nl > @ @ - 173 , 7 + 169 , 8 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > val action = for { < nl > tx ← fromDBIOOption ( AuthErrors . PhoneCodeExpired ) ( persist . auth . AuthPhoneTransaction . find ( transactionHash ) ) < nl > code ← fromDBIO ( persist . AuthCode . findByTransactionHash ( tx . transactionHash ) map ( _ map ( _ . code ) getOrElse ( genSmsCode ( tx . phoneNumber ) ) ) ) < nl > - _ ← fromDBIO ( sendCallCode ( tx . phoneNumber , genSmsCode ( tx . phoneNumber ) , Some ( transactionHash ) , PhoneNumberUtils . normalizeWithCountry ( tx . phoneNumber ) . headOption . map ( _ . _ 2 ) . getOrElse ( " en " ) ) ) < nl > + lang = PhoneNumberUtils . normalizeWithCountry ( tx . phoneNumber ) . headOption . map ( _ . _ 2 ) . getOrElse ( " en " ) < nl > + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendCallCode ( tx . phoneNumber , genSmsCode ( tx . phoneNumber ) , Some ( transactionHash ) , lang ) ) < nl > } yield ResponseVoid < nl > < nl > db . run ( action . run ) < nl > @ @ - 228 , 7 + 225 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > activationType match { < nl > case CODE ⇒ < nl > for { < nl > - _ ← fromDBIO ( sendEmailCode ( email , genCode ( ) , hash ) ) < nl > + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendEmailCode ( email , genCode ( ) , hash ) ) < nl > } yield hash < nl > case OAUTH2 ⇒ < nl > point ( hash ) < nl > @ @ - 241 , 7 + 238 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) < nl > case CODE ⇒ < nl > for { < nl > _ ← fromDBIO ( persist . auth . AuthEmailTransaction . create ( emailAuthTransaction ) ) < nl > - _ ← fromDBIO ( sendEmailCode ( email , genCode ( ) , transactionHash ) ) < nl > + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendEmailCode ( email , genCode ( ) , transactionHash ) ) < nl > } yield transactionHash < nl > case OAUTH2 ⇒ < nl > for { < nl > diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala < nl > index 51af876 . . cf75189 100644 < nl > - - - a / actor - server / project / Dependencies . scala < nl > + + + b / actor - server / project / Dependencies . scala < nl > @ @ - 101 , 7 + 101 , 7 @ @ object Dependencies { < nl > akkaSlf4j , akkaActor , akkaStream < nl > ) < nl > < nl > - val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) < nl > + val activation = shared + + Seq ( akkaActor , akkaHttp , akkaHttpPlayJson , playJson ) < nl > < nl > val bot = shared + + Seq ( upickle )

TEST DIFF:
diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala 
 index cb8793c . . 81c5948 100644 
 - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala 
 + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / telesign / TelesignProvider . scala 
 @ @ - 41 , 23 + 41 , 21 @ @ private [ activation ] final class TelesignProvider ( _ system : ActorSystem ) extends A 
 
 override def send ( txHash : String , code : Code ) : Future [ CodeFailure Xor Unit ] = code match { 
 case s : SmsCode ⇒ 
 - if ( isTestPhone ( s . phone ) ) { 
 - Future . successful ( Xor . right ( ( ) ) ) 
 - } else { 
 - for { 
 - resp ← ( smsStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) 
 - _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) 
 - } yield resp 
 - } 
 + for { 
 + resp ← if ( isTestPhone ( s . phone ) ) 
 + Future . successful ( Xor . right ( ( ) ) ) 
 + else 
 + ( smsStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) 
 + _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) 
 + } yield resp 
 case c : CallCode ⇒ 
 - if ( isTestPhone ( c . phone ) ) { 
 - Future . successful ( Xor . right ( ( ) ) ) 
 - } else { 
 - for { 
 - resp ← ( callStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) 
 - _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) 
 - } yield resp 
 - } 
 + for { 
 + resp ← if ( isTestPhone ( c . phone ) ) 
 + Future . successful ( Xor . right ( ( ) ) ) 
 + else 
 + ( callStateActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) 
 + _ ← createAuthCodeIfNeeded ( resp , txHash , code . code ) 
 + } yield resp 
 case other ⇒ throw new RuntimeException ( s " This provider can ' t handle code of type : $ { other . getClass } " ) 
 } 
 }

NEAREST DIFF:
diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala 
 index 23f1360 . . cd30bde 100644 
 - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala 
 + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / Activation . scala 
 @ @ - 4 , 7 + 4 , 31 @ @ object Activation { 
 sealed trait Code { 
 def code : String 
 } 
 - final case class SmsCode ( phone : Long , code : String ) extends Code 
 - final case class CallCode ( phone : Long , code : String , language : String ) extends Code 
 - final case class EmailCode ( email : String , code : String ) extends Code 
 + sealed trait PhoneCode extends Code { 
 + def phone : Long 
 + } 
 + final case class SmsCode ( phone : Long , code : String ) extends PhoneCode { 
 + override def equals ( that : Any ) : Boolean = 
 + that match { 
 + case that : SmsCode ⇒ this . phone = = that . phone 
 + case _ ⇒ false 
 + } 
 + override def hashCode ( ) : Int = phone . hashCode ( ) 
 + } 
 + final case class CallCode ( phone : Long , code : String , language : String ) extends PhoneCode { 
 + override def equals ( that : Any ) : Boolean = 
 + that match { 
 + case that : CallCode ⇒ this . phone = = that . phone 
 + case _ ⇒ false 
 + } 
 + override def hashCode ( ) : Int = phone . hashCode ( ) 
 + } 
 + final case class EmailCode ( email : String , code : String ) extends Code { 
 + override def equals ( that : Any ) : Boolean = 
 + that match { 
 + case that : EmailCode ⇒ this . email = = that . email 
 + case _ ⇒ false 
 + } 
 + override def hashCode ( ) : Int = email . hashCode ( ) 
 + } 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 index abd0e61 . . 1c6616c 100644 
 - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / gate / GateCodeActivation . scala 
 @ @ - 1 , 15 + 1 , 17 @ @ 
 package im . actor . server . activation . gate 
 
 + import akka . http . scaladsl . marshalling . Marshal 
 + import de . heikoseeberger . akkahttpplayjson . PlayJsonSupport 
 + 
 import scala . concurrent . { ExecutionContext , Future } 
 import scalaz . { - \ / , \ / , \ / - } 
 
 import akka . actor . ActorSystem 
 import akka . http . scaladsl . Http 
 import akka . http . scaladsl . model . HttpMethods . { GET , POST } 
 - import akka . http . scaladsl . model . { HttpRequest , Uri } 
 + import akka . http . scaladsl . model . { RequestEntity , HttpRequest , Uri } 
 import akka . http . scaladsl . unmarshalling . Unmarshal 
 import akka . stream . Materializer 
 - import play . api . libs . json . Json 
 import slick . dbio . DBIO 
 
 import im . actor . server . activation . Activation . Code 
 @ @ - 22 , 21 + 24 , 18 @ @ class GateCodeActivation ( config : GateConfig ) ( 
 system : ActorSystem , 
 val materializer : Materializer , 
 ec : ExecutionContext 
 - ) extends CodeActivation with JsonImplicits { 
 + ) extends CodeActivation with JsonImplicits with PlayJsonSupport { 
 
 private [ this ] val http = Http ( ) 
 
 override def send ( optTransactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = { 
 - val request = HttpRequest ( 
 - method = POST , 
 - uri = s " $ { config . uri } / v1 / codes / send " , 
 - entity = Json . toJson ( code ) . toString 
 - ) 
 - 
 - system . log . debug ( " Requesting code send with { } " , request ) 
 - 
 val codeResponse : Future [ CodeResponse ] = for { 
 - resp ← http . singleRequest ( request . withHeaders ( ` X - Auth - Token ` ( config . authToken ) ) ) 
 + entity ← Marshal ( code ) . to [ RequestEntity ] 
 + request = HttpRequest ( method = POST , uri = s " $ { config . uri } / v1 / codes / send " ) 
 + . withEntity ( entity ) 
 + . withHeaders ( ` X - Auth - Token ` ( config . authToken ) ) 
 + _ = system . log . debug ( " Requesting code send with { } " , request ) 
 + resp ← http . singleRequest ( request ) 
 codeResp ← Unmarshal ( resp ) . to [ CodeResponse ] 
 } yield codeResp 
 
 @ @ - 45 , 7 + 44 , 7 @ @ class GateCodeActivation ( config : GateConfig ) ( 
 result ← codeResponse match { 
 case CodeHash ( hash ) ⇒ 
 optTransactionHash . map { transactionHash ⇒ 
 - for ( _ ← persist . auth . GateAuthCode . create ( transactionHash , hash ) ) yield \ / - ( ( ) ) 
 + for ( _ ← persist . auth . GateAuthCode . createOrUpdate ( transactionHash , hash ) ) yield \ / - ( ( ) ) 
 } getOrElse DBIO . successful ( \ / - ( ( ) ) ) 
 case CodeError ( message ) ⇒ 
 DBIO . successful ( - \ / ( message ) ) 
 diff - - git a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala 
 index 83c60fe . . 13ec452 100644 
 - - - a / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala 
 + + + b / actor - server / actor - activation / src / main / scala / im / actor / server / activation / internal / InternalCodeActivation . scala 
 @ @ - 4 , 10 + 4 , 11 @ @ import java . time . temporal . ChronoUnit . _ 
 import java . time . { LocalDateTime , ZoneOffset } 
 
 import akka . actor . _ 
 + import akka . pattern . ask 
 import akka . stream . Materializer 
 + import akka . util . Timeout 
 import im . actor . server . activation . Activation . { CallCode , Code , EmailCode , SmsCode } 
 import im . actor . server . activation . _ 
 - import im . actor . server . activation . internal . InternalCodeActivation . Send 
 import im . actor . server . email . { EmailSender , Message } 
 import im . actor . server . models . AuthCode 
 import im . actor . server . persist 
 @ @ - 16 , 7 + 17 , 7 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import scala . concurrent . duration . _ 
 import scala . concurrent . { ExecutionContext , Future } 
 - import scalaz . { \ / , \ / - } 
 + import scalaz . { - \ / , \ / , \ / - } 
 
 object InternalCodeActivation { 
 
 @ @ - 24 , 6 + 25 , 8 @ @ object InternalCodeActivation { 
 
 private [ activation ] final case class Send ( code : Code ) 
 
 + private [ activation ] case class SendAck ( result : String \ / Unit ) 
 + 
 private [ activation ] final case class ForgetSentCode ( code : Code ) extends Message 
 
 def newContext ( config : ActivationConfig , smsEngine : AuthSmsEngine , callEngine : AuthCallEngine , emailSender : EmailSender ) ( 
 @ @ - 42 , 16 + 45 , 15 @ @ object InternalCodeActivation { 
 
 private [ activation ] class InternalCodeActivation ( activationActor : ActorRef , config : ActivationConfig ) ( implicit db : Database , ec : ExecutionContext ) extends CodeActivation { 
 
 + import InternalCodeActivation . _ 
 import im . actor . server . activation . Activation . _ 
 
 - def send ( transactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = transactionHash match { 
 - case Some ( hash ) ⇒ 
 - for { 
 - _ ← persist . AuthCode . createOrUpdate ( hash , code . code ) 
 - result ← DBIO . from ( send ( code ) ) 
 - } yield result 
 - case None ⇒ DBIO . successful ( \ / - ( send ( code ) ) ) 
 - } 
 + implicit val timeout : Timeout = Timeout ( 20 . seconds ) 
 + 
 + def send ( transactionHash : Option [ String ] , code : Code ) : DBIO [ String \ / Unit ] = ( transactionHash match { 
 + case Some ( hash ) ⇒ for ( _ ← persist . AuthCode . createOrUpdate ( hash , code . code ) ) yield ( ) 
 + case None ⇒ DBIO . successful ( ( ) ) 
 + } ) flatMap ( _ ⇒ DBIO . from ( sendCode ( code ) ) ) 
 
 def validate ( transactionHash : String , code : String ) : DBIO [ ValidationResponse ] = 
 for { 
 @ @ - 74 , 14 + 76 , 11 @ @ private [ activation ] class InternalCodeActivation ( activationActor : ActorRef , conf 
 private def isExpired ( code : AuthCode ) : Boolean = 
 code . createdAt . plus ( config . expiration . toMillis , MILLIS ) . isBefore ( LocalDateTime . now ( ZoneOffset . UTC ) ) 
 
 - private def send ( code : Code ) : Future [ String \ / Unit ] = { 
 + private def sendCode ( code : Code ) : Future [ String \ / Unit ] = 
 code match { 
 - case SmsCode ( phone , _ ) ⇒ if ( ! isTestPhone ( phone ) ) activationActor ! Send ( code ) 
 - case CallCode ( phone , _ , _ ) ⇒ if ( ! isTestPhone ( phone ) ) activationActor ! Send ( code ) 
 - case _ : EmailCode ⇒ activationActor ! Send ( code ) 
 + case p : PhoneCode if isTestPhone ( p . phone ) ⇒ Future . successful ( \ / - ( ( ) ) ) 
 + case _ ⇒ ( activationActor ? Send ( code ) ) . mapTo [ SendAck ] . map ( _ . result ) 
 } 
 - Future . successful ( \ / - ( ( ) ) ) 
 - } 
 
 private def isTestPhone ( number : Long ) : Boolean = number . toString . startsWith ( " 7555 " ) 
 } 
 @ @ - 105 , 25 + 104 , 29 @ @ class Activation ( repeatLimit : Duration , smsEngine : AuthSmsEngine , callEngine : Au 
 system . scheduler . scheduleOnce ( repeatLimit . toMillis . millis , self , ForgetSentCode ( code ) ) 
 
 override def receive : Receive = { 
 - case Send ( code ) ⇒ sendCode ( code ) 
 + case Send ( code ) ⇒ 
 + val replyTo = sender ( ) 
 + sendCode ( code ) foreach { resp ⇒ replyTo ! SendAck ( resp ) } 
 case ForgetSentCode ( code ) ⇒ forgetSentCode ( code ) 
 } 
 
 - private def sendCode ( code : Code ) : Unit = { 
 + private def sendCode ( code : Code ) : Future [ String \ / Unit ] = { 
 if ( codeWasNotSent ( code ) ) { 
 log . debug ( s " Sending $ code " ) 
 
 rememberSentCode ( code ) 
 
 - code match { 
 + ( code match { 
 case SmsCode ( phone , c ) ⇒ smsEngine . sendCode ( phone , c ) 
 case CallCode ( phone , c , language ) ⇒ callEngine . sendCode ( phone , c , language ) 
 case EmailCode ( email , c ) ⇒ emailSender . send ( Message ( email , " Actor activation code " , s " $ c is your Actor code " ) ) 
 - } 
 - 
 - forgetSentCodeAfterDelay ( code ) 
 + } ) map { _ ⇒ 
 + forgetSentCodeAfterDelay ( code ) 
 + \ / - ( ( ) ) 
 + } recover { case e ⇒ - \ / ( " Unable to send code " ) } 
 } else { 
 log . debug ( s " Ignoring send $ code " ) 
 + Future . successful ( - \ / ( " Attempt to get code later " ) ) 
 } 
 } 
 
 diff - - git a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala 
 index b2029b7 . . 06d7e8b 100644 
 - - - a / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala 
 + + + b / actor - server / actor - botkit / src / main / scala / im / actor / botkit / RemoteBot . scala 
 @ @ - 28 , 7 + 28 , 7 @ @ abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with A 
 def onReceive ( message : Object ) : Unit = { } 
 
 def receive = internalReceive orElse { 
 - case message = > 
 + case message ⇒ 
 onReceive ( message . asInstanceOf [ Object ] ) 
 } 
 
 @ @ - 37 , 9 + 37 , 9 @ @ abstract class RemoteBot ( token : String , endpoint : String ) extends BotBase with A 
 val prefix = " Actor will restart . " 
 
 message match { 
 - case Some ( msg ) = > 
 + case Some ( msg ) ⇒ 
 log . error ( reason , prefix + " Last message received : { } " , msg ) 
 - case None = > 
 + case None ⇒ 
 log . error ( reason , prefix ) 
 } 
 
 diff - - git a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala 
 index b468bd0 . . 1a38ff7 100644 
 - - - a / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala 
 + + + b / actor - server / actor - persist / src / main / scala / im / actor / server / persist / auth / GateAuthCode . scala 
 @ @ - 16 , 8 + 16 , 8 @ @ object GateAuthCode { 
 
 val active = codes . filter ( _ . isDeleted = = = false ) 
 
 - def create ( transactionHash : String , codeHash : String ) = 
 - codes + = models . auth . GateAuthCode ( transactionHash , codeHash ) 
 + def createOrUpdate ( transactionHash : String , codeHash : String ) = 
 + codes . insertOrUpdate ( models . auth . GateAuthCode ( transactionHash , codeHash ) ) 
 
 def find ( transactionHash : String ) = 
 active . filter ( _ . transactionHash = = = transactionHash ) . result . headOption 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 index f00e668 . . 73da5be 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthErrors . scala 
 @ @ - 20 , 4 + 20 , 6 @ @ object AuthErrors { 
 val OAuthUserIdDoesNotMatch = RpcError ( 400 , " WRONG _ OAUTH2 _ USER _ ID " , " Email does not match one provided on the first step . " , false , None ) 
 val ActivationServiceError = RpcError ( 500 , " ACTIVATION _ SERVICE _ ERROR " , " Error occured in activation service . Try again later . " , true , None ) 
 val InvalidAuthCodeHash = RpcError ( 400 , " CODE _ HASH _ INVALID " , " " , false , None ) 
 + 
 + def activationFailure ( message : String ) = RpcError ( 500 , " ACTIVATION _ ERROR " , message , false , None ) 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index f3dca4d . . 8f8a585 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 150 , 20 + 150 , 16 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 normalizedPhone ← fromOption ( AuthErrors . PhoneNumberInvalid ) ( normalizeLong ( phoneNumber ) . headOption ) 
 optAuthTransaction ← fromDBIO ( persist . auth . AuthPhoneTransaction . findByPhoneAndDeviceHash ( normalizedPhone , deviceHash ) ) 
 transactionHash ← optAuthTransaction match { 
 - case Some ( transaction ) ⇒ 
 - val hash = transaction . transactionHash 
 - for { 
 - _ ← fromDBIO ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( hash ) ) ) 
 - } yield hash 
 + case Some ( transaction ) ⇒ point ( transaction . transactionHash ) 
 case None ⇒ 
 val accessSalt = ACLUtils . nextAccessSalt ( ) 
 val transactionHash = ACLUtils . authTransactionHash ( accessSalt ) 
 val phoneAuthTransaction = models . AuthPhoneTransaction ( normalizedPhone , transactionHash , appId , apiKey , deviceHash , deviceTitle , accessSalt ) 
 for { 
 _ ← fromDBIO ( persist . auth . AuthPhoneTransaction . create ( phoneAuthTransaction ) ) 
 - _ ← fromDBIO ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) 
 } yield transactionHash 
 } 
 + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendSmsCode ( normalizedPhone , genSmsCode ( normalizedPhone ) , Some ( transactionHash ) ) ) 
 isRegistered ← fromDBIO ( persist . UserPhone . exists ( normalizedPhone ) ) 
 } yield ResponseStartPhoneAuth ( transactionHash , isRegistered ) 
 db . run ( action . run ) 
 @ @ - 173 , 7 + 169 , 8 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 val action = for { 
 tx ← fromDBIOOption ( AuthErrors . PhoneCodeExpired ) ( persist . auth . AuthPhoneTransaction . find ( transactionHash ) ) 
 code ← fromDBIO ( persist . AuthCode . findByTransactionHash ( tx . transactionHash ) map ( _ map ( _ . code ) getOrElse ( genSmsCode ( tx . phoneNumber ) ) ) ) 
 - _ ← fromDBIO ( sendCallCode ( tx . phoneNumber , genSmsCode ( tx . phoneNumber ) , Some ( transactionHash ) , PhoneNumberUtils . normalizeWithCountry ( tx . phoneNumber ) . headOption . map ( _ . _ 2 ) . getOrElse ( " en " ) ) ) 
 + lang = PhoneNumberUtils . normalizeWithCountry ( tx . phoneNumber ) . headOption . map ( _ . _ 2 ) . getOrElse ( " en " ) 
 + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendCallCode ( tx . phoneNumber , genSmsCode ( tx . phoneNumber ) , Some ( transactionHash ) , lang ) ) 
 } yield ResponseVoid 
 
 db . run ( action . run ) 
 @ @ - 228 , 7 + 225 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 activationType match { 
 case CODE ⇒ 
 for { 
 - _ ← fromDBIO ( sendEmailCode ( email , genCode ( ) , hash ) ) 
 + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendEmailCode ( email , genCode ( ) , hash ) ) 
 } yield hash 
 case OAUTH2 ⇒ 
 point ( hash ) 
 @ @ - 241 , 7 + 238 , 7 @ @ class AuthServiceImpl ( val activationContext : CodeActivation , mediator : ActorRef ) 
 case CODE ⇒ 
 for { 
 _ ← fromDBIO ( persist . auth . AuthEmailTransaction . create ( emailAuthTransaction ) ) 
 - _ ← fromDBIO ( sendEmailCode ( email , genCode ( ) , transactionHash ) ) 
 + _ ← fromDBIOEither [ Unit , String ] ( err ⇒ AuthErrors . activationFailure ( err ) ) ( sendEmailCode ( email , genCode ( ) , transactionHash ) ) 
 } yield transactionHash 
 case OAUTH2 ⇒ 
 for { 
 diff - - git a / actor - server / project / Dependencies . scala b / actor - server / project / Dependencies . scala 
 index 51af876 . . cf75189 100644 
 - - - a / actor - server / project / Dependencies . scala 
 + + + b / actor - server / project / Dependencies . scala 
 @ @ - 101 , 7 + 101 , 7 @ @ object Dependencies { 
 akkaSlf4j , akkaActor , akkaStream 
 ) 
 
 - val activation = shared + + Seq ( akkaActor , akkaHttp , playJson ) 
 + val activation = shared + + Seq ( akkaActor , akkaHttp , akkaHttpPlayJson , playJson ) 
 
 val bot = shared + + Seq ( upickle )
