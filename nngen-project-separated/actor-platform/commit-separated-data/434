BLEU SCORE: 0.805312203079627

TEST MSG: Revert " feat ( server : messaging ) : sort groups and DMs by alphabetic order "
GENERATED MSG: feat ( server : messaging ) : sort groups and DMs by alphabetic order

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index d094908 . . f11648d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 245 , 16 + 245 , 16 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > < nl > protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { < nl > for { < nl > - favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > - groupInfos ← Future . sequence ( state . active . groups . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > - dmInfos ← Future . sequence ( state . active . dms . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > + favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sortFavourites < nl > + groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > + dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > } yield { < nl > val base = List ( < nl > - DialogGroup ( DialogGroupType . Groups , groupInfos ) , < nl > - DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) < nl > + DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , < nl > + DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) < nl > ) < nl > < nl > - if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base < nl > + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base < nl > else base < nl > } < nl > } < nl > @ @ - 271 , 7 + 271 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = < nl > ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] < nl > < nl > - private def sort ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { < nl > + private def sortFavourites ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { < nl > for { < nl > infosNames ← Future . sequence ( infos map ( info ⇒ getName ( info . getPeer ) map ( info → _ ) ) ) < nl > } yield infosNames . sortWith {
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > index f11648d . . d094908 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala < nl > @ @ - 245 , 16 + 245 , 16 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > < nl > protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { < nl > for { < nl > - favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sortFavourites < nl > - groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > - dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) < nl > + favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > + groupInfos ← Future . sequence ( state . active . groups . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > + dmInfos ← Future . sequence ( state . active . dms . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort < nl > } yield { < nl > val base = List ( < nl > - DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , < nl > - DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) < nl > + DialogGroup ( DialogGroupType . Groups , groupInfos ) , < nl > + DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) < nl > ) < nl > < nl > - if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base < nl > + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base < nl > else base < nl > } < nl > } < nl > @ @ - 271 , 7 + 271 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) < nl > protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = < nl > ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] < nl > < nl > - private def sortFavourites ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { < nl > + private def sort ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { < nl > for { < nl > infosNames ← Future . sequence ( infos map ( info ⇒ getName ( info . getPeer ) map ( info → _ ) ) ) < nl > } yield infosNames . sortWith {

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index d094908 . . f11648d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 245 , 16 + 245 , 16 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 
 protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { 
 for { 
 - favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 - groupInfos ← Future . sequence ( state . active . groups . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 - dmInfos ← Future . sequence ( state . active . dms . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 + favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sortFavourites 
 + groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 + dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 } yield { 
 val base = List ( 
 - DialogGroup ( DialogGroupType . Groups , groupInfos ) , 
 - DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) 
 + DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , 
 + DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) 
 ) 
 
 - if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base 
 + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base 
 else base 
 } 
 } 
 @ @ - 271 , 7 + 271 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = 
 ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] 
 
 - private def sort ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { 
 + private def sortFavourites ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { 
 for { 
 infosNames ← Future . sequence ( infos map ( info ⇒ getName ( info . getPeer ) map ( info → _ ) ) ) 
 } yield infosNames . sortWith {

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 index f11648d . . d094908 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogRoot . scala 
 @ @ - 245 , 16 + 245 , 16 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 
 protected def fetchDialogGroups ( ) : Future [ Seq [ DialogGroup ] ] = { 
 for { 
 - favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sortFavourites 
 - groupInfos ← Future . sequence ( state . active . groups map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 - dmInfos ← Future . sequence ( state . active . dms map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) 
 + favInfos ← Future . sequence ( state . active . favourites . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 + groupInfos ← Future . sequence ( state . active . groups . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 + dmInfos ← Future . sequence ( state . active . dms . toSeq map ( sd ⇒ getInfo ( sd . peer ) map ( _ . getInfo ) ) ) flatMap sort 
 } yield { 
 val base = List ( 
 - DialogGroup ( DialogGroupType . Groups , groupInfos . toSeq ) , 
 - DialogGroup ( DialogGroupType . DirectMessages , dmInfos . toSeq ) 
 + DialogGroup ( DialogGroupType . Groups , groupInfos ) , 
 + DialogGroup ( DialogGroupType . DirectMessages , dmInfos ) 
 ) 
 
 - if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos . toSeq ) : : base 
 + if ( favInfos . nonEmpty ) DialogGroup ( DialogGroupType . Favourites , favInfos ) : : base 
 else base 
 } 
 } 
 @ @ - 271 , 7 + 271 , 7 @ @ private class DialogRoot ( val userId : Int , extensions : Seq [ ApiExtension ] ) 
 protected def getInfo ( peer : Peer ) : Future [ DialogQueries . GetInfoResponse ] = 
 ( dialogRef ( peer ) ? DialogQueries . GetInfo ( Some ( peer ) ) ) . mapTo [ GetInfoResponse ] 
 
 - private def sortFavourites ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { 
 + private def sort ( infos : Seq [ DialogInfo ] ) : Future [ Seq [ DialogInfo ] ] = { 
 for { 
 infosNames ← Future . sequence ( infos map ( info ⇒ getName ( info . getPeer ) map ( info → _ ) ) ) 
 } yield infosNames . sortWith {
