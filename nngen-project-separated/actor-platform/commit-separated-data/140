BLEU SCORE: 0.7013967267997694

TEST MSG: wip ( server ) : channels progress
GENERATED MSG: wip ( server ) : channels logic implementation

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index e66f708 . . 85a5734 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 205 , 36 + 205 , 62 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / TODO : remove deprecated < nl > db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) < nl > < nl > - / / def inviteGROUPUpdates : Future [ SeqState ] = < nl > - / / for { < nl > - / / _ ← seqUpdExt . deliverUserUpdate ( < nl > - / / userId = cmd . inviteeUserId , < nl > - / / membersUpdateNew , < nl > - / / pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > - / / deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > - / / ) < nl > - / / < nl > - / / / / push all group updates to inviteeUserId < nl > - / / _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > - / / seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > - / / } < nl > - / / < nl > - / / / / push updated members list to all group members except inviteeUserId < nl > - / / seqState ← seqUpdExt . broadcastClientUpdate ( < nl > - / / userId = cmd . inviterUserId , < nl > - / / authId = cmd . inviterAuthId , < nl > - / / bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > - / / update = membersUpdateNew , < nl > - / / deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > - / / ) < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / } yield seqState < nl > - < nl > - / / def inviteCHANNELUpdates : Future [ SeqState ] = if ( newState . isAdmin ( ) ) < nl > - / / for { < nl > - / / < nl > - / / < nl > - / / } yield ( ) < nl > + def inviteGROUPUpdates : Future [ SeqState ] = < nl > + for { < nl > + / / push updated members list to inviteeUserId , < nl > + _ ← seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + membersUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > + < nl > + / / push all " refresh group " updates to inviteeUserId < nl > + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + } < nl > + < nl > + / / push updated members list to all group members except inviteeUserId < nl > + seqState ← seqUpdExt . broadcastClientUpdate ( < nl > + userId = cmd . inviterUserId , < nl > + authId = cmd . inviterAuthId , < nl > + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > + update = membersUpdateNew , < nl > + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + } yield seqState < nl > + < nl > + def inviteCHANNELUpdates : Future [ SeqState ] = < nl > + for { < nl > + / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . < nl > + / / invitee could be admin , if he created this group , and turning back < nl > + _ ← if ( newState . isAdmin ( cmd . inviteeUserId ) ) { < nl > + seqUpdExt . deliverUserUpdate ( < nl > + userId = cmd . inviteeUserId , < nl > + membersUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > + } else { < nl > + FastFuture . successful ( ( ) ) < nl > + } < nl > + < nl > + / / push all " refresh group " updates to inviteeUserId < nl > + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + } < nl > + < nl > + / / push updated members list to all ADMINS < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + userIds = newState . adminIds , < nl > + update = membersUpdateNew , < nl > + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > + ) < nl > + < nl > + / / get current SeqState for inviter user < nl > + seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) < nl > + } yield seqState < nl > < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > @ @ - 270 , 29 + 296 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / push updated members list to inviteeUserId , < nl > - _ ← seqUpdExt . deliverUserUpdate ( < nl > - userId = cmd . inviteeUserId , < nl > - membersUpdateNew , < nl > - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > - < nl > - / / push all group updates to inviteeUserId < nl > - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > - } < nl > - < nl > - / / push updated members list to all group members except inviteeUserId < nl > - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > - userId = cmd . inviterUserId , < nl > - authId = cmd . inviterAuthId , < nl > - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > - update = membersUpdateNew , < nl > - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > - ) < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates < nl > < nl > / / explicitly send service message < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > @ @ - 344 , 9 + 348 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > val joiningUserUpdatesNew : List [ Update ] = < nl > if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > < nl > - / / н у ж н о о т п р а в и т ь е м у а п д е й т о ч л е н а х в г р у п п е . < nl > - / / в с е м н у ж н о о т п р а в и т ь а п д е й т о и з м е н и в ш и х с я ч л е н а х в г р у п п е . м о ж н о в л ю б о м с л у ч а е о т п р а в и т ь < nl > - < nl > / / push to everyone , including joining user . < nl > / / if joining user wasn ' t invited - send update as FatSeqUpdate < nl > / / update date when member got into group < nl > @ @ - 366 , 24 + 367 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > isAdmin = false < nl > ) ) < nl > < nl > - val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > + def joinGROUPUpdates : Future [ SeqState ] = < nl > for { < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / old group api updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - < nl > - / / push update about members to all users , except joining user < nl > - _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > - memberIds - cmd . joiningUserId , < nl > - membersUpdateObsolete , < nl > - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > - deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " < nl > - ) < nl > - < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / Groups V2 API updates / / < nl > - / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - < nl > / / push all group updates to joiningUserId < nl > _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > @ @ - 391 , 7 + 376 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > / / push updated members list to joining user , < nl > / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( < nl > + seqState ← seqUpdExt . deliverClientUpdate ( < nl > userId = cmd . joiningUserId , < nl > authId = cmd . joiningUserAuthId , < nl > update = membersUpdateNew , < nl > @ @ - 406 , 6 + 391 , 57 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > membersUpdateNew , < nl > deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > ) < nl > + } yield seqState < nl > + < nl > + def joinCHANNELUpdates : Future [ SeqState ] = < nl > + for { < nl > + / / push all group updates to joiningUserId < nl > + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ < nl > + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) < nl > + } < nl > + < nl > + / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . < nl > + / / joining user can be admin , if he created this group , and turning back < nl > + / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? < nl > + seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { < nl > + seqUpdExt . deliverClientUpdate ( < nl > + userId = cmd . joiningUserId , < nl > + authId = cmd . joiningUserAuthId , < nl > + update = membersUpdateNew , < nl > + pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here < nl > + deliveryId = s " join _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > + } else { < nl > + seqUpdExt . getSeqState ( cmd . joiningUserId , cmd . joiningUserAuthId ) < nl > + } < nl > + < nl > + / / push updated members list to all ADMINS < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + newState . adminIds - cmd . joiningUserId , < nl > + membersUpdateNew , < nl > + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > + } yield seqState < nl > + < nl > + val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = < nl > + for { < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / old group api updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + < nl > + / / push update about members to all users , except joining user < nl > + _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > + memberIds - cmd . joiningUserId , < nl > + membersUpdateObsolete , < nl > + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , < nl > + deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " < nl > + ) < nl > + < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / Groups V2 API updates / / < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + < nl > + SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates < nl > < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > apiGroupPeer , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index fbe9d2d . . ac29c3c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 74 , 6 + 74 , 8 @ @ private [ group ] final case class GroupState ( < nl > < nl > def memberIds = members . keySet / / TODO : Maybe lazy val . immutable anyway < nl > < nl > + def adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet / / TODO : Maybe lazy val . immutable anyway < nl > + < nl > def membersCount = members . size / / TODO : Maybe lazy val . immutable anyway < nl > < nl > def isMember ( userId : Int ) : Boolean = members . contains ( userId ) < nl > diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala < nl > index f35f67f . . 59786e3 100644 < nl > - - - a / actor - server / project / Build . scala < nl > + + + b / actor - server / project / Build . scala < nl > @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm < nl > import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging < nl > import com . typesafe . sbt . packager . debian . JDebPackaging < nl > < nl > - object Build extends sbt . Build with Versioning with Releasing with Packaging { < nl > + object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { < nl > val ScalaVersion = " 2 . 11 . 8 " < nl > val BotKitVersion = getVersion < nl > < nl > @ @ - 89 , 6 + 89 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging { < nl > " actor " , < nl > file ( " . " ) , < nl > settings = < nl > + startUpSettings + + < nl > packagingSettings + + < nl > defaultSettingsServer + + < nl > Revolver . settings + + < nl > diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala < nl > new file mode 100644 < nl > index 0000000 . . 62ca90f < nl > - - - / dev / null < nl > + + + b / actor - server / project / StartHook . scala < nl > @ @ - 0 , 0 + 1 , 15 @ @ < nl > + package im . actor < nl > + < nl > + import sbt . Keys . _ < nl > + import sbt . _ < nl > + < nl > + private [ actor ] trait StartHook { < nl > + lazy val startUpSettings = Seq ( < nl > + onLoad in Global : = { state = > < nl > + < nl > + println ( " = = = = = = = = = = = = = = hello world " ) < nl > + state < nl > + } < nl > + ) < nl > + < nl > + }
NEAREST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > index 0910ff5 . . bd5016f 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto < nl > @ @ - 259 , 7 + 259 , 9 @ @ message DialogCommands { < nl > google . protobuf . StringValue delivery _ tag = 13 ; < nl > } < nl > < nl > - message SendMessageAck { } < nl > + message SendMessageAck { < nl > + Peer updated _ sender = 1 ; < nl > + } < nl > < nl > message MessageReceived { < nl > option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; < nl > diff - - git a / actor - server / actor - core / src / main / protobuf / groupV2 . proto b / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > index f00627b . . 405a836 100644 < nl > - - - a / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > + + + b / actor - server / actor - core / src / main / protobuf / groupV2 . proto < nl > @ @ - 39 , 13 + 39 , 14 @ @ message GroupEnvelope { < nl > GroupQueries . GetAccessHash get _ access _ hash = 15 ; < nl > GroupQueries . GetTitle get _ title = 16 ; < nl > GroupQueries . GetIntegrationToken get _ integration _ token = 17 ; < nl > - GroupQueries . GetMembers get _ members = 18 ; < nl > + GroupQueries . GetMembers get _ members = 18 ; / / internalGetMembers < nl > GroupQueries . LoadMembers load _ members = 19 ; < nl > GroupQueries . IsPublic is _ public = 20 ; < nl > GroupQueries . IsHistoryShared is _ history _ shared = 21 ; < nl > GroupQueries . GetApiStruct get _ api _ struct = 22 ; < nl > GroupQueries . GetApiFullStruct get _ api _ full _ struct = 23 ; < nl > GroupQueries . CheckAccessHash check _ access _ hash = 24 ; < nl > + GroupQueries . CanSendMessage can _ send _ message = 26 ; < nl > } < nl > DialogEnvelope dialog _ envelope = 25 ; < nl > } < nl > @ @ - 273 , 4 + 274 , 17 @ @ message GroupQueries { < nl > repeated int32 user _ ids = 1 ; < nl > google . protobuf . BytesValue offset = 2 ; / / should it be Option [ Array [ Byte ] ] < nl > } < nl > + < nl > + message CanSendMessage { < nl > + option ( scalapb . message ) . extends = " GroupQuery " ; < nl > + < nl > + int32 client _ user _ id = 1 ; < nl > + } < nl > + < nl > + message CanSendMessageResponse { < nl > + bool can _ send = 1 ; < nl > + bool is _ channel = 2 ; < nl > + repeated int32 member _ ids = 3 ; < nl > + google . protobuf . Int32Value bot _ id = 4 ; < nl > + } < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > index 478c984 . . 548cd03 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala < nl > @ @ - 58 , 15 + 58 , 19 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { < nl > case false ⇒ < nl > withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( < nl > default = for { < nl > - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) < nl > - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > + SendMessageAck ( updatedSender ) ← dialogExt . ackSendMessage ( peer , sm . withDate ( sendDate ) ) < nl > + finalPeer = updatedSender getOrElse selfPeer < nl > + _ ← db . run ( writeHistoryMessage ( finalPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > / / _ = dialogExt . updateCounters ( peer , userId ) < nl > + / / not sure about sender user id . It could be wrong when we have updatedSender ! < nl > SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) < nl > } yield SeqStateDate ( seq , state , sendDate ) , < nl > failed = for { < nl > _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) < nl > SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) < nl > - } yield SeqStateDate ( seq , state , sendDate ) < nl > + } yield { < nl > + SeqStateDate ( seq , state , sendDate ) < nl > + } < nl > ) < nl > } < nl > } yield seqStateDate < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > index f90749a . . 69a2611 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala < nl > @ @ - 152 , 8 + 152 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit < nl > } yield seqStateDate . copy ( seq = seq , state = state ) < nl > } < nl > < nl > - def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ Unit ] = < nl > - ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) < nl > + def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ SendMessageAck ] = < nl > + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] < nl > < nl > def writeMessage ( < nl > peer : ApiPeer , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > index 9fa5cb7 . . e66f708 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala < nl > @ @ - 121 , 7 + 121 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / send service message to group < nl > @ @ - 176 , 15 + 176 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > < nl > val dateMillis = evt . ts . toEpochMilli < nl > val memberIds = newState . memberIds < nl > - val members = newState . members . values . map ( _ . asStruct ) . toVector < nl > + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector < nl > < nl > / / if user ever been in this group - we should push these updates , < nl > / / but don ' t push them if user is first time in group . in this case we should push FatSeqUpdate < nl > - val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState ) < nl > + val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) < nl > < nl > / / send everyone in group , including invitee . < nl > / / send ` FatSeqUpdate ` if this user invited to group for first time . < nl > - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) < nl > + val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , apiMembers ) < nl > < nl > val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( < nl > groupId , < nl > @ @ - 205 , 6 + 205 , 37 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / TODO : remove deprecated < nl > db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) < nl > < nl > + / / def inviteGROUPUpdates : Future [ SeqState ] = < nl > + / / for { < nl > + / / _ ← seqUpdExt . deliverUserUpdate ( < nl > + / / userId = cmd . inviteeUserId , < nl > + / / membersUpdateNew , < nl > + / / pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , < nl > + / / deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " < nl > + / / ) < nl > + / / < nl > + / / / / push all group updates to inviteeUserId < nl > + / / _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ < nl > + / / seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) < nl > + / / } < nl > + / / < nl > + / / / / push updated members list to all group members except inviteeUserId < nl > + / / seqState ← seqUpdExt . broadcastClientUpdate ( < nl > + / / userId = cmd . inviterUserId , < nl > + / / authId = cmd . inviterAuthId , < nl > + / / bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , < nl > + / / update = membersUpdateNew , < nl > + / / deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > + / / ) < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > + / / } yield seqState < nl > + < nl > + / / def inviteCHANNELUpdates : Future [ SeqState ] = if ( newState . isAdmin ( ) ) < nl > + / / for { < nl > + / / < nl > + / / < nl > + / / } yield ( ) < nl > + < nl > val result : Future [ SeqStateDate ] = for { < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / old group api updates / / < nl > @ @ - 236 , 9 + 267 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > / / push updated members list to inviteeUserId , < nl > _ ← seqUpdExt . deliverUserUpdate ( < nl > userId = cmd . inviteeUserId , < nl > @ @ - 260 , 6 + 292 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > update = membersUpdateNew , < nl > deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " < nl > ) < nl > + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / explicitly send service message < nl > SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( < nl > @ @ - 309 , 7 + 342 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / If user was invited to group by other member - we don ' t need to push group updates , < nl > / / cause they we pushed already on invite step < nl > val joiningUserUpdatesNew : List [ Update ] = < nl > - if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState ) < nl > + if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) < nl > < nl > / / н у ж н о о т п р а в и т ь е м у а п д е й т о ч л е н а х в г р у п п е . < nl > / / в с е м н у ж н о о т п р а в и т ь а п д е й т о и з м е н и в ш и х с я ч л е н а х в г р у п п е . м о ж н о в л ю б о м с л у ч а е о т п р а в и т ь < nl > @ @ - 348 , 7 + 381 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push all group updates to joiningUserId < nl > @ @ - 440 , 7 + 473 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push updated members list to all group members < nl > @ @ - 526 , 7 + 559 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > / / push updated members list to all group members . Don ' t push to kicked user ! < nl > @ @ - 561 , 6 + 594 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > + / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateAvatar ( cmd : UpdateAvatar ) : Unit = { < nl > if ( state . nonMember ( cmd . clientUserId ) ) { < nl > sender ( ) ! notMember < nl > @ @ - 585 , 7 + 619 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > _ ← seqUpdExt . broadcastClientUpdate ( cmd . clientUserId , cmd . clientAuthId , memberIds , updateObsolete ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 609 , 6 + 643 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > + / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateTitle ( cmd : UpdateTitle ) : Unit = { < nl > val title = cmd . title < nl > if ( state . nonMember ( cmd . clientUserId ) ) { < nl > @ @ - 651 , 7 + 686 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 677 , 6 + 712 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > } < nl > } < nl > < nl > + / / TODO : channels , don ' t allow non - admin to change topic < nl > protected def updateTopic ( cmd : UpdateTopic ) : Unit = { < nl > def isValidTopic ( topic : Option [ String ] ) = topic . forall ( _ . length < 255 ) < nl > < nl > @ @ - 722 , 7 + 758 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 786 , 7 + 822 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( < nl > @ @ - 872 , 7 + 908 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > ) < nl > < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > - / / new group api updates / / < nl > + / / Groups V2 API updates / / < nl > / / / / / / / / / / / / / / / / / / / / / / / / / / / < nl > < nl > _ ← seqUpdExt . broadcastPeopleUpdate ( < nl > @ @ - 928 , 15 + 964 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { < nl > / / Updates that will be sent to user , when he enters group . < nl > / / Helps clients that have this group to refresh it ' s data . < nl > / / TODO : review when chanels will be added < nl > - private def refreshGroupUpdates ( newState : GroupState ) : List [ Update ] = List ( < nl > + private def refreshGroupUpdates ( newState : GroupState , userId : Int ) : List [ Update ] = List ( < nl > UpdateGroupMemberChanged ( groupId , isMember = true ) , < nl > UpdateGroupAboutChanged ( groupId , newState . about ) , < nl > UpdateGroupAvatarChanged ( groupId , newState . avatar ) , < nl > UpdateGroupTopicChanged ( groupId , newState . topic ) , < nl > UpdateGroupTitleChanged ( groupId , newState . title ) , < nl > UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) , < nl > - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = true ) , < nl > - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) < nl > + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = newState . canViewMembers ( userId ) ) , < nl > + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) / / TODO : figure out right value < nl > / / UpdateGroupExtChanged ( groupId , newState . extension ) / / TODO : figure out and fix < nl > / / if ( bigGroup ) UpdateGroupMembersCountChanged ( groupId , newState . extension ) < nl > ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > index d350a26 . . b599ef8 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala < nl > @ @ - 150 , 11 + 150 , 21 @ @ private [ group ] sealed trait Queries { < nl > . withCheckAccessHash ( CheckAccessHash ( hash ) ) ) . mapTo [ CheckAccessHashResponse ] map ( _ . isCorrect ) < nl > < nl > / / ( memberIds , invitedUserIds , botId ) < nl > - def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = < nl > + / / TODO : should be signed as internal API , and become narrowly scoped < nl > + def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = / / TODO : prepare for channel < nl > ( viewRegion . ref ? < nl > GroupEnvelope ( groupId ) < nl > . withGetMembers ( GetMembers ( ) ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) < nl > < nl > + def canSendMessage ( groupId : Int , clientUserId : Int ) : Future [ CanSendMessageInfo ] = < nl > + ( viewRegion . ref ? < nl > + GroupEnvelope ( groupId ) < nl > + . withCanSendMessage ( CanSendMessage ( clientUserId ) ) ) . mapTo [ CanSendMessageResponse ] map { < nl > + case CanSendMessageResponse ( canSend , isChannel , memberIds , botId ) ⇒ < nl > + CanSendMessageInfo ( canSend , isChannel , memberIds . toSet , botId ) < nl > + } < nl > + < nl > + / / TODO : move to separate Query . < nl > def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = < nl > getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) < nl > < nl > @ @ - 173 , 3 + 183 , 10 @ @ private [ group ] sealed trait Queries { < nl > GroupEnvelope ( groupId ) < nl > . withLoadMembers ( LoadMembers ( clientUserId , limit , offset map ByteString . copyFrom ) ) ) . mapTo [ LoadMembersResponse ] map ( r ⇒ r . userIds → r . offset . map ( _ . toByteArray ) ) < nl > } < nl > + < nl > + final case class CanSendMessageInfo ( < nl > + canSend : Boolean , < nl > + isChannel : Boolean , < nl > + memberIds : Set [ Int ] , < nl > + botId : Option [ Int ] < nl > + ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > index 3523f87 . . bca7533 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala < nl > @ @ - 1 , 11 + 1 , 10 @ @ < nl > package im . actor . server . group < nl > < nl > - import akka . actor . Status < nl > import akka . http . scaladsl . util . FastFuture < nl > import akka . pattern . pipe < nl > import im . actor . api . rpc . PeersImplicits < nl > import im . actor . server . dialog . DialogCommands . _ < nl > - import im . actor . server . group . GroupErrors . NotAMember < nl > + import im . actor . server . group . GroupErrors . { NotAMember , NotAdmin } < nl > import im . actor . server . model . Peer < nl > < nl > import scala . concurrent . Future < nl > @ @ - 17 , 8 + 16 , 18 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { < nl > < nl > protected def incomingMessage ( state : GroupPeerState , sm : SendMessage ) : Unit = { < nl > val senderUserId = sm . getOrigin . id < nl > - ( withMemberIds ( groupId ) { ( memberIds , _ , optBot ) ⇒ < nl > - if ( canSend ( memberIds , optBot , senderUserId ) ) { < nl > + < nl > + val result : Future [ SendMessageAck ] = groupExt . canSendMessage ( groupId , senderUserId ) flatMap { < nl > + case CanSendMessageInfo ( true , isChannel , memberIds , optBotId ) ⇒ < nl > + val ( ack , smUpdated ) = if ( isChannel ) { < nl > + optBotId map { botId ⇒ < nl > + val botPeer = Peer . privat ( botId ) < nl > + SendMessageAck ( ) . withUpdatedSender ( botPeer ) → sm . withOrigin ( botPeer ) < nl > + } getOrElse ( SendMessageAck ( ) → sm ) < nl > + } else { < nl > + SendMessageAck ( ) → sm < nl > + } < nl > + < nl > val receiverIds = sm . forUserId match { < nl > case Some ( id ) if memberIds . contains ( id ) ⇒ Seq ( id ) < nl > case _ ⇒ memberIds - senderUserId < nl > @ @ - 26 , 18 + 35 , 23 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { < nl > < nl > for { < nl > _ ← Future . traverse ( receiverIds ) { userId ⇒ < nl > - dialogExt . ackSendMessage ( Peer . privat ( userId ) , sm ) < nl > + dialogExt . ackSendMessage ( Peer . privat ( userId ) , smUpdated ) < nl > } < nl > } yield { < nl > self ! LastSenderIdChanged ( senderUserId ) < nl > - SendMessageAck ( ) < nl > + ack < nl > } < nl > - } else FastFuture . successful ( Status . Failure ( NotAMember ) ) < nl > - } recover { < nl > - case e ⇒ < nl > - log . error ( e , " Failed to send message " ) < nl > - throw e < nl > - } ) pipeTo sender ( ) < nl > + case CanSendMessageInfo ( false , true , _ , _ ) ⇒ < nl > + FastFuture . failed ( NotAdmin ) < nl > + case CanSendMessageInfo ( false , _ , _ , _ ) ⇒ < nl > + FastFuture . failed ( NotAMember ) < nl > + } < nl > + < nl > + result onFailure { < nl > + case e : Exception ⇒ log . error ( e , " Failed to send message " ) < nl > + } < nl > + < nl > + result pipeTo sender ( ) < nl > } < nl > < nl > protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > index fb053f1 . . 5d56240 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala < nl > @ @ - 45 , 6 + 45 , 7 @ @ object GroupProcessor { < nl > 20017 → classOf [ GroupCommands . MakeUserAdmin ] , < nl > 20018 → classOf [ GroupCommands . RevokeIntegrationToken ] , < nl > 20020 → classOf [ GroupCommands . RevokeIntegrationTokenAck ] , < nl > + 20021 → classOf [ GroupCommands . TransferOwnership ] , < nl > < nl > 21001 → classOf [ GroupQueries . GetIntegrationToken ] , < nl > 21002 → classOf [ GroupQueries . GetIntegrationTokenResponse ] , < nl > @ @ - 60 , 6 + 61 , 11 @ @ object GroupProcessor { < nl > 21013 → classOf [ GroupQueries . GetAccessHashResponse ] , < nl > 21014 → classOf [ GroupQueries . IsHistoryShared ] , < nl > 21015 → classOf [ GroupQueries . IsHistorySharedResponse ] , < nl > + 21016 → classOf [ GroupQueries . GetTitle ] , < nl > + 21017 → classOf [ GroupQueries . LoadMembers ] , < nl > + 21018 → classOf [ GroupQueries . GetApiFullStruct ] , < nl > + 21019 → classOf [ GroupQueries . CanSendMessage ] , < nl > + 21020 → classOf [ GroupQueries . CanSendMessageResponse ] , < nl > < nl > 22003 → classOf [ GroupEvents . UserInvited ] , < nl > 22004 → classOf [ GroupEvents . UserJoined ] , < nl > @ @ - 153 , 6 + 159 , 7 @ @ private [ group ] final class GroupProcessor < nl > case GetApiStruct ( clientUserId ) ⇒ getApiStruct ( clientUserId ) < nl > case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) < nl > case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) < nl > + case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) < nl > } < nl > < nl > def persistenceId : String = GroupProcessor . persistenceIdFor ( groupId ) < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > index 517d00e . . 62655a9 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala < nl > @ @ - 7 , 6 + 7 , 9 @ @ import com . google . protobuf . ByteString < nl > import com . google . protobuf . wrappers . Int32Value < nl > import im . actor . api . rpc . groups . { ApiGroup , ApiGroupFull , ApiGroupType , ApiMember } < nl > import im . actor . server . group . GroupQueries . _ < nl > + import im . actor . server . group . GroupType . { Channel , General , Public } < nl > + < nl > + import scala . concurrent . Future < nl > < nl > trait GroupQueryHandlers { < nl > self : GroupProcessor ⇒ < nl > @ @ - 19 , 14 + 22 , 16 @ @ trait GroupQueryHandlers { < nl > protected def getTitle = < nl > FastFuture . successful ( GetTitleResponse ( state . title ) ) < nl > < nl > - protected def getIntegrationToken ( optUserId : Option [ Int ] ) = { < nl > + protected def getIntegrationToken ( optUserId : Option [ Int ] ) : Future [ GetIntegrationTokenResponse ] = { < nl > val canViewToken = optUserId . forall ( state . isAdmin ) < nl > FastFuture . successful ( GetIntegrationTokenResponse ( < nl > if ( canViewToken ) state . bot . map ( _ . token ) else None < nl > ) ) < nl > } < nl > < nl > - protected def getMembers = < nl > + / / TODO : do something with this method . Will this method used in " client " context . < nl > + / / If not - don ' t change it . Maybe rename to ` getMembersInternal ` < nl > + protected def getMembers : Future [ GetMembersResponse ] = < nl > FastFuture . successful { < nl > GetMembersResponse ( < nl > memberIds = state . members . keySet . toSeq , < nl > @ @ - 35 , 22 + 40 , 33 @ @ trait GroupQueryHandlers { < nl > ) < nl > } < nl > < nl > - protected def loadMembers ( clientUserId : Int , limit : Int , offsetBs : Option [ ByteString ] ) = { < nl > - implicit val mat = ActorMaterializer ( ) < nl > - val offset = offsetBs map ( _ . toByteArray ) map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 < nl > - < nl > - for { < nl > - ( userIds , nextOffset ) ← Source ( state . members . keySet ) < nl > - . mapAsync ( 1 ) ( userId ⇒ userExt . getName ( userId , clientUserId ) map ( userId → _ ) ) < nl > - . runFold ( Vector . empty [ ( Int , String ) ] ) ( _ : + _ ) map { users ⇒ < nl > - val tail = users . sortBy ( _ . _ 2 ) . map ( _ . _ 1 ) . drop ( offset ) < nl > - val nextOffset = if ( tail . length > limit ) Some ( Int32Value ( offset + limit ) . toByteArray ) else None < nl > - ( tail . take ( limit ) , nextOffset ) < nl > - } < nl > - } yield LoadMembersResponse ( < nl > - userIds = userIds , < nl > - offset = nextOffset map ByteString . copyFrom < nl > - ) < nl > + / / TODO : rewrite to sort by online + name . Won ' t work like this < nl > + / / we can subscribe group object to group onlines ! When online comes , we reorder key - set . Use that key set as source . < nl > + protected def loadMembers ( clientUserId : Int , limit : Int , offsetBs : Option [ ByteString ] ) : Future [ LoadMembersResponse ] = { < nl > + def load = { < nl > + implicit val mat = ActorMaterializer ( ) < nl > + val offset = offsetBs map ( _ . toByteArray ) map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 < nl > + < nl > + for { < nl > + ( userIds , nextOffset ) ← Source ( state . members . keySet ) < nl > + . mapAsync ( 1 ) ( userId ⇒ userExt . getName ( userId , clientUserId ) map ( userId → _ ) ) < nl > + . runFold ( Vector . empty [ ( Int , String ) ] ) ( _ : + _ ) map { users ⇒ < nl > + val tail = users . sortBy ( _ . _ 2 ) . map ( _ . _ 1 ) . drop ( offset ) < nl > + val nextOffset = if ( tail . length > limit ) Some ( Int32Value ( offset + limit ) . toByteArray ) else None < nl > + ( tail . take ( limit ) , nextOffset ) < nl > + } < nl > + } yield LoadMembersResponse ( < nl > + userIds = userIds , < nl > + offset = nextOffset map ByteString . copyFrom < nl > + ) < nl > + } < nl > + < nl > + state . typ match { < nl > + case General | Public ⇒ load < nl > + case Channel ⇒ < nl > + if ( state . isAdmin ( clientUserId ) ) load < nl > + else FastFuture . successful ( LoadMembersResponse ( Seq . empty , offsetBs ) ) < nl > + } < nl > } < nl > < nl > protected def isPublic = < nl > @ @ - 63 , 7 + 79 , 7 @ @ trait GroupQueryHandlers { < nl > / / TODO : what if state changes during request ? < nl > protected def getApiStruct ( clientUserId : Int ) = { < nl > val isMember = state . isMember ( clientUserId ) < nl > - val apiMembers = getApiMembers ( state , clientUserId ) < nl > + val ( members , count ) = membersAndCount ( state , clientUserId ) < nl > < nl > FastFuture . successful { < nl > GetApiStructResponse ( < nl > @ @ - 74 , 14 + 90 , 14 @ @ trait GroupQueryHandlers { < nl > avatar = state . avatar , < nl > isMember = Some ( isMember ) , < nl > creatorUserId = state . creatorUserId , < nl > - members = apiMembers , < nl > - createDate = extractCreatedMillis ( state ) , < nl > + members = members , < nl > + createDate = extractCreatedAtMillis ( state ) , < nl > isAdmin = Some ( state . isAdmin ( clientUserId ) ) , < nl > theme = state . topic , < nl > about = state . about , < nl > isHidden = Some ( state . isHidden ) , < nl > ext = None , < nl > - membersCount = Some ( apiMembers . size ) , < nl > + membersCount = Some ( count ) , < nl > groupType = Some ( state . typ match { < nl > case GroupType . Channel ⇒ ApiGroupType . CHANNEL < nl > case GroupType . General | GroupType . Public | GroupType . Unrecognized ( _ ) ⇒ ApiGroupType . GROUP < nl > @ @ - 101 , 13 + 117 , 13 @ @ trait GroupQueryHandlers { < nl > theme = state . topic , < nl > about = state . about , < nl > ownerUserId = state . creatorUserId , < nl > - createDate = extractCreatedMillis ( state ) , < nl > + createDate = extractCreatedAtMillis ( state ) , < nl > ext = None , < nl > - canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , < nl > - canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , < nl > + canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , / / TODO : revisit < nl > + canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , / / TODO : revisit < nl > isSharedHistory = Some ( state . isHistoryShared ) , < nl > isAsyncMembers = Some ( state . members . size > 100 ) , < nl > - members = getApiMembers ( state , clientUserId ) < nl > + members = membersAndCount ( state , clientUserId ) . _ 1 < nl > ) < nl > ) < nl > } < nl > @ @ - 115 , 15 + 131 , 50 @ @ trait GroupQueryHandlers { < nl > protected def checkAccessHash ( hash : Long ) = < nl > FastFuture . successful ( CheckAccessHashResponse ( isCorrect = state . accessHash = = hash ) ) < nl > < nl > - private def extractCreatedMillis ( group : GroupState ) : Long = < nl > + protected def canSendMessage ( clientUserId : Int ) : Future [ CanSendMessageResponse ] = < nl > + FastFuture . successful { < nl > + val canSend = state . bot . exists ( _ . userId = = clientUserId ) | | { < nl > + state . typ match { < nl > + case General | Public ⇒ state . isMember ( clientUserId ) < nl > + case Channel ⇒ state . isAdmin ( clientUserId ) < nl > + } < nl > + } < nl > + CanSendMessageResponse ( < nl > + canSend = canSend , < nl > + isChannel = state . typ . isChannel , < nl > + memberIds = state . memberIds . toSeq , < nl > + botId = state . bot . map ( _ . userId ) < nl > + ) < nl > + } < nl > + < nl > + private def extractCreatedAtMillis ( group : GroupState ) : Long = < nl > group . createdAt . map ( _ . toEpochMilli ) . getOrElse ( throw new RuntimeException ( " No date created provided for group ! " ) ) < nl > < nl > - private def getApiMembers ( group : GroupState , clientUserId : Int ) = < nl > + / * * < nl > + * Return group members , and number of members . < nl > + * If ` clientUserId ` is not a group member , return empty members list and 0 < nl > + * For ` General ` and ` Public ` groups return all members and their number . < nl > + * For ` Channel ` return members list only if ` clientUserId ` is group admin . Otherwise return empty members list and real members count < nl > + * / < nl > + private def membersAndCount ( group : GroupState , clientUserId : Int ) : ( Vector [ ApiMember ] , Int ) = { < nl > + def apiMembers = group . members . toVector map { < nl > + case ( _ , m ) ⇒ < nl > + ApiMember ( m . userId , m . inviterUserId , m . invitedAt . toEpochMilli , Some ( m . isAdmin ) ) < nl > + } < nl > + < nl > if ( state . isMember ( clientUserId ) ) { < nl > - group . members . toVector map { < nl > - case ( _ , m ) ⇒ < nl > - ApiMember ( m . userId , m . inviterUserId , m . invitedAt . toEpochMilli , Some ( m . isAdmin ) ) < nl > + state . typ match { < nl > + case General | Public ⇒ < nl > + apiMembers → group . membersCount < nl > + case Channel ⇒ < nl > + if ( state . isAdmin ( clientUserId ) ) < nl > + apiMembers → group . membersCount < nl > + else < nl > + Vector . empty [ ApiMember ] → group . membersCount < nl > } < nl > - } else Vector . empty [ ApiMember ] < nl > + } else { < nl > + Vector . empty [ ApiMember ] → 0 < nl > + } < nl > + } < nl > < nl > } < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > index 128d3da . . fbe9d2d 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala < nl > @ @ - 58 , 7 + 58 , 7 @ @ private [ group ] final case class GroupState ( < nl > about : Option [ String ] , < nl > avatar : Option [ Avatar ] , < nl > topic : Option [ String ] , < nl > - typ : GroupType , < nl > + typ : GroupType , / / TODO : rename to groupType < nl > isHidden : Boolean , < nl > isHistoryShared : Boolean , < nl > < nl > @ @ - 86 , 18 + 86 , 21 @ @ private [ group ] final case class GroupState ( < nl > < nl > def isAdmin ( userId : Int ) : Boolean = members . get ( userId ) exists ( _ . isAdmin ) < nl > < nl > + / / owner will be super - admin in case of channels < nl > def isOwner ( userId : Int ) : Boolean = userId = = ownerUserId < nl > < nl > def isExUser ( userId : Int ) : Boolean = exUserIds . contains ( userId ) < nl > < nl > + / / in case of general / public can view members if user is member < nl > + / / in case of channel can view members only if clientUserId is admin < nl > def canViewMembers ( clientUserId : Int ) = < nl > - ( typ . isGeneral | | typ . isPublic ) & & isMember ( clientUserId ) < nl > + ( ( typ . isGeneral | | typ . isPublic ) | | isAdmin ( clientUserId ) ) & & isMember ( clientUserId ) < nl > < nl > + / * * < nl > + * For now , all members can invite other users to group < nl > + * / < nl > def canInvitePeople ( clientUserId : Int ) = isMember ( clientUserId ) < nl > < nl > - def canViewMembers ( group : GroupState , userId : Int ) = < nl > - ( group . typ . isGeneral | | group . typ . isPublic ) & & isMember ( userId ) < nl > - < nl > def isNotCreated = createdAt . isEmpty / / TODO : Maybe val . immutable anyway < nl > < nl > def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > index 5933fce . . 2b7eb07 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala < nl > @ @ - 30 , 6 + 30 , 7 @ @ final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem < nl > < nl > override def onFailure : PartialFunction [ Throwable , RpcError ] = { < nl > case GroupErrors . NotAMember ⇒ CommonRpcErrors . forbidden ( " You are not a group member . " ) < nl > + case GroupErrors . NotAdmin ⇒ CommonRpcErrors . forbidden ( " Only admin can perform this action . " ) < nl > case DialogErrors . MessageToSelf ⇒ CommonRpcErrors . forbidden ( " Sending messages to self is not allowed . " ) < nl > case InvalidAccessHash ⇒ CommonRpcErrors . InvalidAccessHash < nl > case DialogErrors . DialogAlreadyArchived ( peer ) ⇒

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index e66f708 . . 85a5734 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 205 , 36 + 205 , 62 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / TODO : remove deprecated 
 db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) 
 
 - / / def inviteGROUPUpdates : Future [ SeqState ] = 
 - / / for { 
 - / / _ ← seqUpdExt . deliverUserUpdate ( 
 - / / userId = cmd . inviteeUserId , 
 - / / membersUpdateNew , 
 - / / pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 - / / deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 - / / ) 
 - / / 
 - / / / / push all group updates to inviteeUserId 
 - / / _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 - / / seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 - / / } 
 - / / 
 - / / / / push updated members list to all group members except inviteeUserId 
 - / / seqState ← seqUpdExt . broadcastClientUpdate ( 
 - / / userId = cmd . inviterUserId , 
 - / / authId = cmd . inviterAuthId , 
 - / / bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 - / / update = membersUpdateNew , 
 - / / deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 - / / ) 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / } yield seqState 
 - 
 - / / def inviteCHANNELUpdates : Future [ SeqState ] = if ( newState . isAdmin ( ) ) 
 - / / for { 
 - / / 
 - / / 
 - / / } yield ( ) 
 + def inviteGROUPUpdates : Future [ SeqState ] = 
 + for { 
 + / / push updated members list to inviteeUserId , 
 + _ ← seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + membersUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 + 
 + / / push all " refresh group " updates to inviteeUserId 
 + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + } 
 + 
 + / / push updated members list to all group members except inviteeUserId 
 + seqState ← seqUpdExt . broadcastClientUpdate ( 
 + userId = cmd . inviterUserId , 
 + authId = cmd . inviterAuthId , 
 + bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 + update = membersUpdateNew , 
 + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + } yield seqState 
 + 
 + def inviteCHANNELUpdates : Future [ SeqState ] = 
 + for { 
 + / / push ` UpdateGroupMembersUpdated ` to invitee only if he is admin . 
 + / / invitee could be admin , if he created this group , and turning back 
 + _ ← if ( newState . isAdmin ( cmd . inviteeUserId ) ) { 
 + seqUpdExt . deliverUserUpdate ( 
 + userId = cmd . inviteeUserId , 
 + membersUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 + deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 + } else { 
 + FastFuture . successful ( ( ) ) 
 + } 
 + 
 + / / push all " refresh group " updates to inviteeUserId 
 + _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + } 
 + 
 + / / push updated members list to all ADMINS 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + userIds = newState . adminIds , 
 + update = membersUpdateNew , 
 + deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 + ) 
 + 
 + / / get current SeqState for inviter user 
 + seqState ← seqUpdExt . getSeqState ( cmd . inviterUserId , cmd . inviterAuthId ) 
 + } yield seqState 
 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 @ @ - 270 , 29 + 296 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / push updated members list to inviteeUserId , 
 - _ ← seqUpdExt . deliverUserUpdate ( 
 - userId = cmd . inviteeUserId , 
 - membersUpdateNew , 
 - pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 - deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 - 
 - / / push all group updates to inviteeUserId 
 - _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 - seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 - } 
 - 
 - / / push updated members list to all group members except inviteeUserId 
 - SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 - userId = cmd . inviterUserId , 
 - authId = cmd . inviterAuthId , 
 - bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 - update = membersUpdateNew , 
 - deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 - ) 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + SeqState ( seq , state ) ← if ( newState . typ . isChannel ) inviteCHANNELUpdates else inviteGROUPUpdates 
 
 / / explicitly send service message 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 @ @ - 344 , 9 + 348 , 6 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 val joiningUserUpdatesNew : List [ Update ] = 
 if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 
 - / / н у ж н о о т п р а в и т ь е м у а п д е й т о ч л е н а х в г р у п п е . 
 - / / в с е м н у ж н о о т п р а в и т ь а п д е й т о и з м е н и в ш и х с я ч л е н а х в г р у п п е . м о ж н о в л ю б о м с л у ч а е о т п р а в и т ь 
 - 
 / / push to everyone , including joining user . 
 / / if joining user wasn ' t invited - send update as FatSeqUpdate 
 / / update date when member got into group 
 @ @ - 366 , 24 + 367 , 8 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 isAdmin = false 
 ) ) 
 
 - val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 + def joinGROUPUpdates : Future [ SeqState ] = 
 for { 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / old group api updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - 
 - / / push update about members to all users , except joining user 
 - _ ← seqUpdExt . broadcastPeopleUpdate ( 
 - memberIds - cmd . joiningUserId , 
 - membersUpdateObsolete , 
 - pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 - deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " 
 - ) 
 - 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / Groups V2 API updates / / 
 - / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - 
 / / push all group updates to joiningUserId 
 _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 @ @ - 391 , 7 + 376 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 / / push updated members list to joining user , 
 / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 - SeqState ( seq , state ) ← seqUpdExt . deliverClientUpdate ( 
 + seqState ← seqUpdExt . deliverClientUpdate ( 
 userId = cmd . joiningUserId , 
 authId = cmd . joiningUserAuthId , 
 update = membersUpdateNew , 
 @ @ - 406 , 6 + 391 , 57 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 membersUpdateNew , 
 deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 ) 
 + } yield seqState 
 + 
 + def joinCHANNELUpdates : Future [ SeqState ] = 
 + for { 
 + / / push all group updates to joiningUserId 
 + _ ← FutureExt . ftraverse ( joiningUserUpdatesNew ) { update ⇒ 
 + seqUpdExt . deliverUserUpdate ( userId = cmd . joiningUserId , update ) 
 + } 
 + 
 + / / push ` UpdateGroupMembersUpdated ` to joining user only if he is admin . 
 + / / joining user can be admin , if he created this group , and turning back 
 + / / TODO ? ? ? : isFat = ! wasInvited - is it correct ? 
 + seqState ← if ( newState . isAdmin ( cmd . joiningUserId ) ) { 
 + seqUpdExt . deliverClientUpdate ( 
 + userId = cmd . joiningUserId , 
 + authId = cmd . joiningUserAuthId , 
 + update = membersUpdateNew , 
 + pushRules = seqUpdExt . pushRules ( isFat = ! wasInvited , None ) , / / ! wasInvited means that user came for first time here 
 + deliveryId = s " join _ $ { groupId } _ $ { randomId } " 
 + ) 
 + } else { 
 + seqUpdExt . getSeqState ( cmd . joiningUserId , cmd . joiningUserAuthId ) 
 + } 
 + 
 + / / push updated members list to all ADMINS 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + newState . adminIds - cmd . joiningUserId , 
 + membersUpdateNew , 
 + deliveryId = s " userjoined _ $ { groupId } _ $ { randomId } " 
 + ) 
 + } yield seqState 
 + 
 + val result : Future [ ( SeqStateDate , Vector [ Int ] , Long ) ] = 
 + for { 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / old group api updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + / / push update about members to all users , except joining user 
 + _ ← seqUpdExt . broadcastPeopleUpdate ( 
 + memberIds - cmd . joiningUserId , 
 + membersUpdateObsolete , 
 + pushRules = seqUpdExt . pushRules ( isFat = true , None ) , 
 + deliveryId = s " userjoined _ obsolete _ $ { groupId } _ $ { randomId } " 
 + ) 
 + 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / Groups V2 API updates / / 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + 
 + SeqState ( seq , state ) ← if ( newState . typ . isChannel ) joinCHANNELUpdates else joinGROUPUpdates 
 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 apiGroupPeer , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index fbe9d2d . . ac29c3c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 74 , 6 + 74 , 8 @ @ private [ group ] final case class GroupState ( 
 
 def memberIds = members . keySet / / TODO : Maybe lazy val . immutable anyway 
 
 + def adminIds = ( members filter ( _ . _ 2 . isAdmin = = true ) ) . keySet / / TODO : Maybe lazy val . immutable anyway 
 + 
 def membersCount = members . size / / TODO : Maybe lazy val . immutable anyway 
 
 def isMember ( userId : Int ) : Boolean = members . contains ( userId ) 
 diff - - git a / actor - server / project / Build . scala b / actor - server / project / Build . scala 
 index f35f67f . . 59786e3 100644 
 - - - a / actor - server / project / Build . scala 
 + + + b / actor - server / project / Build . scala 
 @ @ - 9 , 7 + 9 , 7 @ @ import com . typesafe . sbt . SbtMultiJvm . MultiJvmKeys . MultiJvm 
 import com . typesafe . sbt . packager . archetypes . JavaServerAppPackaging 
 import com . typesafe . sbt . packager . debian . JDebPackaging 
 
 - object Build extends sbt . Build with Versioning with Releasing with Packaging { 
 + object Build extends sbt . Build with Versioning with Releasing with Packaging with StartHook { 
 val ScalaVersion = " 2 . 11 . 8 " 
 val BotKitVersion = getVersion 
 
 @ @ - 89 , 6 + 89 , 7 @ @ object Build extends sbt . Build with Versioning with Releasing with Packaging { 
 " actor " , 
 file ( " . " ) , 
 settings = 
 + startUpSettings + + 
 packagingSettings + + 
 defaultSettingsServer + + 
 Revolver . settings + + 
 diff - - git a / actor - server / project / StartHook . scala b / actor - server / project / StartHook . scala 
 new file mode 100644 
 index 0000000 . . 62ca90f 
 - - - / dev / null 
 + + + b / actor - server / project / StartHook . scala 
 @ @ - 0 , 0 + 1 , 15 @ @ 
 + package im . actor 
 + 
 + import sbt . Keys . _ 
 + import sbt . _ 
 + 
 + private [ actor ] trait StartHook { 
 + lazy val startUpSettings = Seq ( 
 + onLoad in Global : = { state = > 
 + 
 + println ( " = = = = = = = = = = = = = = hello world " ) 
 + state 
 + } 
 + ) 
 + 
 + }

NEAREST DIFF:
diff - - git a / actor - server / actor - core / src / main / protobuf / dialog . proto b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 index 0910ff5 . . bd5016f 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / dialog . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / dialog . proto 
 @ @ - 259 , 7 + 259 , 9 @ @ message DialogCommands { 
 google . protobuf . StringValue delivery _ tag = 13 ; 
 } 
 
 - message SendMessageAck { } 
 + message SendMessageAck { 
 + Peer updated _ sender = 1 ; 
 + } 
 
 message MessageReceived { 
 option ( scalapb . message ) . extends = " im . actor . server . dialog . DirectDialogCommand " ; 
 diff - - git a / actor - server / actor - core / src / main / protobuf / groupV2 . proto b / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 index f00627b . . 405a836 100644 
 - - - a / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 + + + b / actor - server / actor - core / src / main / protobuf / groupV2 . proto 
 @ @ - 39 , 13 + 39 , 14 @ @ message GroupEnvelope { 
 GroupQueries . GetAccessHash get _ access _ hash = 15 ; 
 GroupQueries . GetTitle get _ title = 16 ; 
 GroupQueries . GetIntegrationToken get _ integration _ token = 17 ; 
 - GroupQueries . GetMembers get _ members = 18 ; 
 + GroupQueries . GetMembers get _ members = 18 ; / / internalGetMembers 
 GroupQueries . LoadMembers load _ members = 19 ; 
 GroupQueries . IsPublic is _ public = 20 ; 
 GroupQueries . IsHistoryShared is _ history _ shared = 21 ; 
 GroupQueries . GetApiStruct get _ api _ struct = 22 ; 
 GroupQueries . GetApiFullStruct get _ api _ full _ struct = 23 ; 
 GroupQueries . CheckAccessHash check _ access _ hash = 24 ; 
 + GroupQueries . CanSendMessage can _ send _ message = 26 ; 
 } 
 DialogEnvelope dialog _ envelope = 25 ; 
 } 
 @ @ - 273 , 4 + 274 , 17 @ @ message GroupQueries { 
 repeated int32 user _ ids = 1 ; 
 google . protobuf . BytesValue offset = 2 ; / / should it be Option [ Array [ Byte ] ] 
 } 
 + 
 + message CanSendMessage { 
 + option ( scalapb . message ) . extends = " GroupQuery " ; 
 + 
 + int32 client _ user _ id = 1 ; 
 + } 
 + 
 + message CanSendMessageResponse { 
 + bool can _ send = 1 ; 
 + bool is _ channel = 2 ; 
 + repeated int32 member _ ids = 3 ; 
 + google . protobuf . Int32Value bot _ id = 4 ; 
 + } 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 index 478c984 . . 548cd03 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogCommandHandlers . scala 
 @ @ - 58 , 15 + 58 , 19 @ @ trait DialogCommandHandlers extends PeersImplicits with UserAcl { 
 case false ⇒ 
 withNonBlockedPeer [ SeqStateDate ] ( userId , sm . getDest ) ( 
 default = for { 
 - _ ← dialogExt . ackSendMessage ( peer , sm . copy ( date = Some ( sendDate ) ) ) 
 - _ ← db . run ( writeHistoryMessage ( selfPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 + SendMessageAck ( updatedSender ) ← dialogExt . ackSendMessage ( peer , sm . withDate ( sendDate ) ) 
 + finalPeer = updatedSender getOrElse selfPeer 
 + _ ← db . run ( writeHistoryMessage ( finalPeer , peer , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 / / _ = dialogExt . updateCounters ( peer , userId ) 
 + / / not sure about sender user id . It could be wrong when we have updatedSender ! 
 SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) 
 } yield SeqStateDate ( seq , state , sendDate ) , 
 failed = for { 
 _ ← db . run ( writeHistoryMessageSelf ( userId , peer , userId , new DateTime ( sendDate ) , sm . randomId , message . header , message . toByteArray ) ) 
 SeqState ( seq , state ) ← deliveryExt . senderDelivery ( userId , optClientAuthId , peer , sm . randomId , sendDate , message , sm . isFat , sm . deliveryTag ) 
 - } yield SeqStateDate ( seq , state , sendDate ) 
 + } yield { 
 + SeqStateDate ( seq , state , sendDate ) 
 + } 
 ) 
 } 
 } yield seqStateDate 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 index f90749a . . 69a2611 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / dialog / DialogExtension . scala 
 @ @ - 152 , 8 + 152 , 8 @ @ final class DialogExtensionImpl ( system : ActorSystem ) extends DialogExtension wit 
 } yield seqStateDate . copy ( seq = seq , state = state ) 
 } 
 
 - def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ Unit ] = 
 - ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] map ( _ ⇒ ( ) ) 
 + def ackSendMessage ( peer : Peer , sm : SendMessage ) : Future [ SendMessageAck ] = 
 + ( processorRegion ( peer ) ? envelope ( peer , DialogEnvelope ( ) . withSendMessage ( sm ) ) ) . mapTo [ SendMessageAck ] 
 
 def writeMessage ( 
 peer : ApiPeer , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 index 9fa5cb7 . . e66f708 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupCommandHandlers . scala 
 @ @ - 121 , 7 + 121 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / send service message to group 
 @ @ - 176 , 15 + 176 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 
 val dateMillis = evt . ts . toEpochMilli 
 val memberIds = newState . memberIds 
 - val members = newState . members . values . map ( _ . asStruct ) . toVector 
 + val apiMembers = newState . members . values . map ( _ . asStruct ) . toVector 
 
 / / if user ever been in this group - we should push these updates , 
 / / but don ' t push them if user is first time in group . in this case we should push FatSeqUpdate 
 - val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState ) 
 + val inviteeUpdatesNew : List [ Update ] = refreshGroupUpdates ( newState , cmd . inviteeUserId ) 
 
 / / send everyone in group , including invitee . 
 / / send ` FatSeqUpdate ` if this user invited to group for first time . 
 - val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , members ) 
 + val membersUpdateNew = UpdateGroupMembersUpdated ( groupId , apiMembers ) 
 
 val inviteeUpdateObsolete = UpdateGroupInviteObsolete ( 
 groupId , 
 @ @ - 205 , 6 + 205 , 37 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / TODO : remove deprecated 
 db . run ( GroupUserRepo . create ( groupId , cmd . inviteeUserId , cmd . inviterUserId , evt . ts , None , isAdmin = false ) ) 
 
 + / / def inviteGROUPUpdates : Future [ SeqState ] = 
 + / / for { 
 + / / _ ← seqUpdExt . deliverUserUpdate ( 
 + / / userId = cmd . inviteeUserId , 
 + / / membersUpdateNew , 
 + / / pushRules = seqUpdExt . pushRules ( isFat = ! inviteeIsExUser , Some ( PushTexts . Invited ) ) , 
 + / / deliveryId = s " invite _ $ { groupId } _ $ { cmd . randomId } " 
 + / / ) 
 + / / 
 + / / / / push all group updates to inviteeUserId 
 + / / _ ← FutureExt . ftraverse ( inviteeUpdatesNew ) { update ⇒ 
 + / / seqUpdExt . deliverUserUpdate ( userId = cmd . inviteeUserId , update ) 
 + / / } 
 + / / 
 + / / / / push updated members list to all group members except inviteeUserId 
 + / / seqState ← seqUpdExt . broadcastClientUpdate ( 
 + / / userId = cmd . inviterUserId , 
 + / / authId = cmd . inviterAuthId , 
 + / / bcastUserIds = ( memberIds - cmd . inviterUserId ) - cmd . inviteeUserId , 
 + / / update = membersUpdateNew , 
 + / / deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 + / / ) 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 + / / } yield seqState 
 + 
 + / / def inviteCHANNELUpdates : Future [ SeqState ] = if ( newState . isAdmin ( ) ) 
 + / / for { 
 + / / 
 + / / 
 + / / } yield ( ) 
 + 
 val result : Future [ SeqStateDate ] = for { 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / old group api updates / / 
 @ @ - 236 , 9 + 267 , 10 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 / / push updated members list to inviteeUserId , 
 _ ← seqUpdExt . deliverUserUpdate ( 
 userId = cmd . inviteeUserId , 
 @ @ - 260 , 6 + 292 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 update = membersUpdateNew , 
 deliveryId = s " useradded _ $ { groupId } _ $ { cmd . randomId } " 
 ) 
 + / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / explicitly send service message 
 SeqStateDate ( _ , _ , date ) ← dialogExt . sendServerMessage ( 
 @ @ - 309 , 7 + 342 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / If user was invited to group by other member - we don ' t need to push group updates , 
 / / cause they we pushed already on invite step 
 val joiningUserUpdatesNew : List [ Update ] = 
 - if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState ) 
 + if ( wasInvited ) List . empty [ Update ] else refreshGroupUpdates ( newState , cmd . joiningUserId ) 
 
 / / н у ж н о о т п р а в и т ь е м у а п д е й т о ч л е н а х в г р у п п е . 
 / / в с е м н у ж н о о т п р а в и т ь а п д е й т о и з м е н и в ш и х с я ч л е н а х в г р у п п е . м о ж н о в л ю б о м с л у ч а е о т п р а в и т ь 
 @ @ - 348 , 7 + 381 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push all group updates to joiningUserId 
 @ @ - 440 , 7 + 473 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push updated members list to all group members 
 @ @ - 526 , 7 + 559 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 / / push updated members list to all group members . Don ' t push to kicked user ! 
 @ @ - 561 , 6 + 594 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 + / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateAvatar ( cmd : UpdateAvatar ) : Unit = { 
 if ( state . nonMember ( cmd . clientUserId ) ) { 
 sender ( ) ! notMember 
 @ @ - 585 , 7 + 619 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 _ ← seqUpdExt . broadcastClientUpdate ( cmd . clientUserId , cmd . clientAuthId , memberIds , updateObsolete ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 609 , 6 + 643 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 + / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateTitle ( cmd : UpdateTitle ) : Unit = { 
 val title = cmd . title 
 if ( state . nonMember ( cmd . clientUserId ) ) { 
 @ @ - 651 , 7 + 686 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 677 , 6 + 712 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 } 
 } 
 
 + / / TODO : channels , don ' t allow non - admin to change topic 
 protected def updateTopic ( cmd : UpdateTopic ) : Unit = { 
 def isValidTopic ( topic : Option [ String ] ) = topic . forall ( _ . length < 255 ) 
 
 @ @ - 722 , 7 + 758 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 786 , 7 + 822 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 SeqState ( seq , state ) ← seqUpdExt . broadcastClientUpdate ( 
 @ @ - 872 , 7 + 908 , 7 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 ) 
 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 - / / new group api updates / / 
 + / / Groups V2 API updates / / 
 / / / / / / / / / / / / / / / / / / / / / / / / / / / 
 
 _ ← seqUpdExt . broadcastPeopleUpdate ( 
 @ @ - 928 , 15 + 964 , 15 @ @ private [ group ] trait GroupCommandHandlers extends GroupsImplicits with UserAcl { 
 / / Updates that will be sent to user , when he enters group . 
 / / Helps clients that have this group to refresh it ' s data . 
 / / TODO : review when chanels will be added 
 - private def refreshGroupUpdates ( newState : GroupState ) : List [ Update ] = List ( 
 + private def refreshGroupUpdates ( newState : GroupState , userId : Int ) : List [ Update ] = List ( 
 UpdateGroupMemberChanged ( groupId , isMember = true ) , 
 UpdateGroupAboutChanged ( groupId , newState . about ) , 
 UpdateGroupAvatarChanged ( groupId , newState . avatar ) , 
 UpdateGroupTopicChanged ( groupId , newState . topic ) , 
 UpdateGroupTitleChanged ( groupId , newState . title ) , 
 UpdateGroupOwnerChanged ( groupId , newState . ownerUserId ) , 
 - UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = true ) , 
 - UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) 
 + UpdateGroupCanViewMembersChanged ( groupId , canViewMembers = newState . canViewMembers ( userId ) ) , 
 + UpdateGroupCanInviteMembersChanged ( groupId , canInviteMembers = true ) / / TODO : figure out right value 
 / / UpdateGroupExtChanged ( groupId , newState . extension ) / / TODO : figure out and fix 
 / / if ( bigGroup ) UpdateGroupMembersCountChanged ( groupId , newState . extension ) 
 ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 index d350a26 . . b599ef8 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupOperations . scala 
 @ @ - 150 , 11 + 150 , 21 @ @ private [ group ] sealed trait Queries { 
 . withCheckAccessHash ( CheckAccessHash ( hash ) ) ) . mapTo [ CheckAccessHashResponse ] map ( _ . isCorrect ) 
 
 / / ( memberIds , invitedUserIds , botId ) 
 - def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = 
 + / / TODO : should be signed as internal API , and become narrowly scoped 
 + def getMemberIds ( groupId : Int ) : Future [ ( Seq [ Int ] , Seq [ Int ] , Option [ Int ] ) ] = / / TODO : prepare for channel 
 ( viewRegion . ref ? 
 GroupEnvelope ( groupId ) 
 . withGetMembers ( GetMembers ( ) ) ) . mapTo [ GetMembersResponse ] map ( r ⇒ ( r . memberIds , r . invitedUserIds , r . botId ) ) 
 
 + def canSendMessage ( groupId : Int , clientUserId : Int ) : Future [ CanSendMessageInfo ] = 
 + ( viewRegion . ref ? 
 + GroupEnvelope ( groupId ) 
 + . withCanSendMessage ( CanSendMessage ( clientUserId ) ) ) . mapTo [ CanSendMessageResponse ] map { 
 + case CanSendMessageResponse ( canSend , isChannel , memberIds , botId ) ⇒ 
 + CanSendMessageInfo ( canSend , isChannel , memberIds . toSet , botId ) 
 + } 
 + 
 + / / TODO : move to separate Query . 
 def isMember ( groupId : Int , userId : Int ) : Future [ Boolean ] = 
 getMemberIds ( groupId ) map ( _ . _ 1 . contains ( userId ) ) 
 
 @ @ - 173 , 3 + 183 , 10 @ @ private [ group ] sealed trait Queries { 
 GroupEnvelope ( groupId ) 
 . withLoadMembers ( LoadMembers ( clientUserId , limit , offset map ByteString . copyFrom ) ) ) . mapTo [ LoadMembersResponse ] map ( r ⇒ r . userIds → r . offset . map ( _ . toByteArray ) ) 
 } 
 + 
 + final case class CanSendMessageInfo ( 
 + canSend : Boolean , 
 + isChannel : Boolean , 
 + memberIds : Set [ Int ] , 
 + botId : Option [ Int ] 
 + ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 index 3523f87 . . bca7533 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupPeerCommandHandlers . scala 
 @ @ - 1 , 11 + 1 , 10 @ @ 
 package im . actor . server . group 
 
 - import akka . actor . Status 
 import akka . http . scaladsl . util . FastFuture 
 import akka . pattern . pipe 
 import im . actor . api . rpc . PeersImplicits 
 import im . actor . server . dialog . DialogCommands . _ 
 - import im . actor . server . group . GroupErrors . NotAMember 
 + import im . actor . server . group . GroupErrors . { NotAMember , NotAdmin } 
 import im . actor . server . model . Peer 
 
 import scala . concurrent . Future 
 @ @ - 17 , 8 + 16 , 18 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { 
 
 protected def incomingMessage ( state : GroupPeerState , sm : SendMessage ) : Unit = { 
 val senderUserId = sm . getOrigin . id 
 - ( withMemberIds ( groupId ) { ( memberIds , _ , optBot ) ⇒ 
 - if ( canSend ( memberIds , optBot , senderUserId ) ) { 
 + 
 + val result : Future [ SendMessageAck ] = groupExt . canSendMessage ( groupId , senderUserId ) flatMap { 
 + case CanSendMessageInfo ( true , isChannel , memberIds , optBotId ) ⇒ 
 + val ( ack , smUpdated ) = if ( isChannel ) { 
 + optBotId map { botId ⇒ 
 + val botPeer = Peer . privat ( botId ) 
 + SendMessageAck ( ) . withUpdatedSender ( botPeer ) → sm . withOrigin ( botPeer ) 
 + } getOrElse ( SendMessageAck ( ) → sm ) 
 + } else { 
 + SendMessageAck ( ) → sm 
 + } 
 + 
 val receiverIds = sm . forUserId match { 
 case Some ( id ) if memberIds . contains ( id ) ⇒ Seq ( id ) 
 case _ ⇒ memberIds - senderUserId 
 @ @ - 26 , 18 + 35 , 23 @ @ trait GroupPeerCommandHandlers extends PeersImplicits { 
 
 for { 
 _ ← Future . traverse ( receiverIds ) { userId ⇒ 
 - dialogExt . ackSendMessage ( Peer . privat ( userId ) , sm ) 
 + dialogExt . ackSendMessage ( Peer . privat ( userId ) , smUpdated ) 
 } 
 } yield { 
 self ! LastSenderIdChanged ( senderUserId ) 
 - SendMessageAck ( ) 
 + ack 
 } 
 - } else FastFuture . successful ( Status . Failure ( NotAMember ) ) 
 - } recover { 
 - case e ⇒ 
 - log . error ( e , " Failed to send message " ) 
 - throw e 
 - } ) pipeTo sender ( ) 
 + case CanSendMessageInfo ( false , true , _ , _ ) ⇒ 
 + FastFuture . failed ( NotAdmin ) 
 + case CanSendMessageInfo ( false , _ , _ , _ ) ⇒ 
 + FastFuture . failed ( NotAMember ) 
 + } 
 + 
 + result onFailure { 
 + case e : Exception ⇒ log . error ( e , " Failed to send message " ) 
 + } 
 + 
 + result pipeTo sender ( ) 
 } 
 
 protected def messageReceived ( state : GroupPeerState , mr : MessageReceived ) = { 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 index fb053f1 . . 5d56240 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupProcessor . scala 
 @ @ - 45 , 6 + 45 , 7 @ @ object GroupProcessor { 
 20017 → classOf [ GroupCommands . MakeUserAdmin ] , 
 20018 → classOf [ GroupCommands . RevokeIntegrationToken ] , 
 20020 → classOf [ GroupCommands . RevokeIntegrationTokenAck ] , 
 + 20021 → classOf [ GroupCommands . TransferOwnership ] , 
 
 21001 → classOf [ GroupQueries . GetIntegrationToken ] , 
 21002 → classOf [ GroupQueries . GetIntegrationTokenResponse ] , 
 @ @ - 60 , 6 + 61 , 11 @ @ object GroupProcessor { 
 21013 → classOf [ GroupQueries . GetAccessHashResponse ] , 
 21014 → classOf [ GroupQueries . IsHistoryShared ] , 
 21015 → classOf [ GroupQueries . IsHistorySharedResponse ] , 
 + 21016 → classOf [ GroupQueries . GetTitle ] , 
 + 21017 → classOf [ GroupQueries . LoadMembers ] , 
 + 21018 → classOf [ GroupQueries . GetApiFullStruct ] , 
 + 21019 → classOf [ GroupQueries . CanSendMessage ] , 
 + 21020 → classOf [ GroupQueries . CanSendMessageResponse ] , 
 
 22003 → classOf [ GroupEvents . UserInvited ] , 
 22004 → classOf [ GroupEvents . UserJoined ] , 
 @ @ - 153 , 6 + 159 , 7 @ @ private [ group ] final class GroupProcessor 
 case GetApiStruct ( clientUserId ) ⇒ getApiStruct ( clientUserId ) 
 case GetApiFullStruct ( clientUserId ) ⇒ getApiFullStruct ( clientUserId ) 
 case CheckAccessHash ( accessHash ) ⇒ checkAccessHash ( accessHash ) 
 + case CanSendMessage ( clientUserId ) ⇒ canSendMessage ( clientUserId ) 
 } 
 
 def persistenceId : String = GroupProcessor . persistenceIdFor ( groupId ) 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 index 517d00e . . 62655a9 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupQueryHandlers . scala 
 @ @ - 7 , 6 + 7 , 9 @ @ import com . google . protobuf . ByteString 
 import com . google . protobuf . wrappers . Int32Value 
 import im . actor . api . rpc . groups . { ApiGroup , ApiGroupFull , ApiGroupType , ApiMember } 
 import im . actor . server . group . GroupQueries . _ 
 + import im . actor . server . group . GroupType . { Channel , General , Public } 
 + 
 + import scala . concurrent . Future 
 
 trait GroupQueryHandlers { 
 self : GroupProcessor ⇒ 
 @ @ - 19 , 14 + 22 , 16 @ @ trait GroupQueryHandlers { 
 protected def getTitle = 
 FastFuture . successful ( GetTitleResponse ( state . title ) ) 
 
 - protected def getIntegrationToken ( optUserId : Option [ Int ] ) = { 
 + protected def getIntegrationToken ( optUserId : Option [ Int ] ) : Future [ GetIntegrationTokenResponse ] = { 
 val canViewToken = optUserId . forall ( state . isAdmin ) 
 FastFuture . successful ( GetIntegrationTokenResponse ( 
 if ( canViewToken ) state . bot . map ( _ . token ) else None 
 ) ) 
 } 
 
 - protected def getMembers = 
 + / / TODO : do something with this method . Will this method used in " client " context . 
 + / / If not - don ' t change it . Maybe rename to ` getMembersInternal ` 
 + protected def getMembers : Future [ GetMembersResponse ] = 
 FastFuture . successful { 
 GetMembersResponse ( 
 memberIds = state . members . keySet . toSeq , 
 @ @ - 35 , 22 + 40 , 33 @ @ trait GroupQueryHandlers { 
 ) 
 } 
 
 - protected def loadMembers ( clientUserId : Int , limit : Int , offsetBs : Option [ ByteString ] ) = { 
 - implicit val mat = ActorMaterializer ( ) 
 - val offset = offsetBs map ( _ . toByteArray ) map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 
 - 
 - for { 
 - ( userIds , nextOffset ) ← Source ( state . members . keySet ) 
 - . mapAsync ( 1 ) ( userId ⇒ userExt . getName ( userId , clientUserId ) map ( userId → _ ) ) 
 - . runFold ( Vector . empty [ ( Int , String ) ] ) ( _ : + _ ) map { users ⇒ 
 - val tail = users . sortBy ( _ . _ 2 ) . map ( _ . _ 1 ) . drop ( offset ) 
 - val nextOffset = if ( tail . length > limit ) Some ( Int32Value ( offset + limit ) . toByteArray ) else None 
 - ( tail . take ( limit ) , nextOffset ) 
 - } 
 - } yield LoadMembersResponse ( 
 - userIds = userIds , 
 - offset = nextOffset map ByteString . copyFrom 
 - ) 
 + / / TODO : rewrite to sort by online + name . Won ' t work like this 
 + / / we can subscribe group object to group onlines ! When online comes , we reorder key - set . Use that key set as source . 
 + protected def loadMembers ( clientUserId : Int , limit : Int , offsetBs : Option [ ByteString ] ) : Future [ LoadMembersResponse ] = { 
 + def load = { 
 + implicit val mat = ActorMaterializer ( ) 
 + val offset = offsetBs map ( _ . toByteArray ) map ( Int32Value . parseFrom ( _ ) . value ) getOrElse 0 
 + 
 + for { 
 + ( userIds , nextOffset ) ← Source ( state . members . keySet ) 
 + . mapAsync ( 1 ) ( userId ⇒ userExt . getName ( userId , clientUserId ) map ( userId → _ ) ) 
 + . runFold ( Vector . empty [ ( Int , String ) ] ) ( _ : + _ ) map { users ⇒ 
 + val tail = users . sortBy ( _ . _ 2 ) . map ( _ . _ 1 ) . drop ( offset ) 
 + val nextOffset = if ( tail . length > limit ) Some ( Int32Value ( offset + limit ) . toByteArray ) else None 
 + ( tail . take ( limit ) , nextOffset ) 
 + } 
 + } yield LoadMembersResponse ( 
 + userIds = userIds , 
 + offset = nextOffset map ByteString . copyFrom 
 + ) 
 + } 
 + 
 + state . typ match { 
 + case General | Public ⇒ load 
 + case Channel ⇒ 
 + if ( state . isAdmin ( clientUserId ) ) load 
 + else FastFuture . successful ( LoadMembersResponse ( Seq . empty , offsetBs ) ) 
 + } 
 } 
 
 protected def isPublic = 
 @ @ - 63 , 7 + 79 , 7 @ @ trait GroupQueryHandlers { 
 / / TODO : what if state changes during request ? 
 protected def getApiStruct ( clientUserId : Int ) = { 
 val isMember = state . isMember ( clientUserId ) 
 - val apiMembers = getApiMembers ( state , clientUserId ) 
 + val ( members , count ) = membersAndCount ( state , clientUserId ) 
 
 FastFuture . successful { 
 GetApiStructResponse ( 
 @ @ - 74 , 14 + 90 , 14 @ @ trait GroupQueryHandlers { 
 avatar = state . avatar , 
 isMember = Some ( isMember ) , 
 creatorUserId = state . creatorUserId , 
 - members = apiMembers , 
 - createDate = extractCreatedMillis ( state ) , 
 + members = members , 
 + createDate = extractCreatedAtMillis ( state ) , 
 isAdmin = Some ( state . isAdmin ( clientUserId ) ) , 
 theme = state . topic , 
 about = state . about , 
 isHidden = Some ( state . isHidden ) , 
 ext = None , 
 - membersCount = Some ( apiMembers . size ) , 
 + membersCount = Some ( count ) , 
 groupType = Some ( state . typ match { 
 case GroupType . Channel ⇒ ApiGroupType . CHANNEL 
 case GroupType . General | GroupType . Public | GroupType . Unrecognized ( _ ) ⇒ ApiGroupType . GROUP 
 @ @ - 101 , 13 + 117 , 13 @ @ trait GroupQueryHandlers { 
 theme = state . topic , 
 about = state . about , 
 ownerUserId = state . creatorUserId , 
 - createDate = extractCreatedMillis ( state ) , 
 + createDate = extractCreatedAtMillis ( state ) , 
 ext = None , 
 - canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , 
 - canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , 
 + canViewMembers = Some ( state . canViewMembers ( clientUserId ) ) , / / TODO : revisit 
 + canInvitePeople = Some ( state . canInvitePeople ( clientUserId ) ) , / / TODO : revisit 
 isSharedHistory = Some ( state . isHistoryShared ) , 
 isAsyncMembers = Some ( state . members . size > 100 ) , 
 - members = getApiMembers ( state , clientUserId ) 
 + members = membersAndCount ( state , clientUserId ) . _ 1 
 ) 
 ) 
 } 
 @ @ - 115 , 15 + 131 , 50 @ @ trait GroupQueryHandlers { 
 protected def checkAccessHash ( hash : Long ) = 
 FastFuture . successful ( CheckAccessHashResponse ( isCorrect = state . accessHash = = hash ) ) 
 
 - private def extractCreatedMillis ( group : GroupState ) : Long = 
 + protected def canSendMessage ( clientUserId : Int ) : Future [ CanSendMessageResponse ] = 
 + FastFuture . successful { 
 + val canSend = state . bot . exists ( _ . userId = = clientUserId ) | | { 
 + state . typ match { 
 + case General | Public ⇒ state . isMember ( clientUserId ) 
 + case Channel ⇒ state . isAdmin ( clientUserId ) 
 + } 
 + } 
 + CanSendMessageResponse ( 
 + canSend = canSend , 
 + isChannel = state . typ . isChannel , 
 + memberIds = state . memberIds . toSeq , 
 + botId = state . bot . map ( _ . userId ) 
 + ) 
 + } 
 + 
 + private def extractCreatedAtMillis ( group : GroupState ) : Long = 
 group . createdAt . map ( _ . toEpochMilli ) . getOrElse ( throw new RuntimeException ( " No date created provided for group ! " ) ) 
 
 - private def getApiMembers ( group : GroupState , clientUserId : Int ) = 
 + / * * 
 + * Return group members , and number of members . 
 + * If ` clientUserId ` is not a group member , return empty members list and 0 
 + * For ` General ` and ` Public ` groups return all members and their number . 
 + * For ` Channel ` return members list only if ` clientUserId ` is group admin . Otherwise return empty members list and real members count 
 + * / 
 + private def membersAndCount ( group : GroupState , clientUserId : Int ) : ( Vector [ ApiMember ] , Int ) = { 
 + def apiMembers = group . members . toVector map { 
 + case ( _ , m ) ⇒ 
 + ApiMember ( m . userId , m . inviterUserId , m . invitedAt . toEpochMilli , Some ( m . isAdmin ) ) 
 + } 
 + 
 if ( state . isMember ( clientUserId ) ) { 
 - group . members . toVector map { 
 - case ( _ , m ) ⇒ 
 - ApiMember ( m . userId , m . inviterUserId , m . invitedAt . toEpochMilli , Some ( m . isAdmin ) ) 
 + state . typ match { 
 + case General | Public ⇒ 
 + apiMembers → group . membersCount 
 + case Channel ⇒ 
 + if ( state . isAdmin ( clientUserId ) ) 
 + apiMembers → group . membersCount 
 + else 
 + Vector . empty [ ApiMember ] → group . membersCount 
 } 
 - } else Vector . empty [ ApiMember ] 
 + } else { 
 + Vector . empty [ ApiMember ] → 0 
 + } 
 + } 
 
 } 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 index 128d3da . . fbe9d2d 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / server / group / GroupState . scala 
 @ @ - 58 , 7 + 58 , 7 @ @ private [ group ] final case class GroupState ( 
 about : Option [ String ] , 
 avatar : Option [ Avatar ] , 
 topic : Option [ String ] , 
 - typ : GroupType , 
 + typ : GroupType , / / TODO : rename to groupType 
 isHidden : Boolean , 
 isHistoryShared : Boolean , 
 
 @ @ - 86 , 18 + 86 , 21 @ @ private [ group ] final case class GroupState ( 
 
 def isAdmin ( userId : Int ) : Boolean = members . get ( userId ) exists ( _ . isAdmin ) 
 
 + / / owner will be super - admin in case of channels 
 def isOwner ( userId : Int ) : Boolean = userId = = ownerUserId 
 
 def isExUser ( userId : Int ) : Boolean = exUserIds . contains ( userId ) 
 
 + / / in case of general / public can view members if user is member 
 + / / in case of channel can view members only if clientUserId is admin 
 def canViewMembers ( clientUserId : Int ) = 
 - ( typ . isGeneral | | typ . isPublic ) & & isMember ( clientUserId ) 
 + ( ( typ . isGeneral | | typ . isPublic ) | | isAdmin ( clientUserId ) ) & & isMember ( clientUserId ) 
 
 + / * * 
 + * For now , all members can invite other users to group 
 + * / 
 def canInvitePeople ( clientUserId : Int ) = isMember ( clientUserId ) 
 
 - def canViewMembers ( group : GroupState , userId : Int ) = 
 - ( group . typ . isGeneral | | group . typ . isPublic ) & & isMember ( userId ) 
 - 
 def isNotCreated = createdAt . isEmpty / / TODO : Maybe val . immutable anyway 
 
 def isCreated = createdAt . nonEmpty / / TODO : Maybe val . immutable anyway 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 index 5933fce . . 2b7eb07 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / messaging / MessagingServiceImpl . scala 
 @ @ - 30 , 6 + 30 , 7 @ @ final class MessagingServiceImpl ( implicit protected val actorSystem : ActorSystem 
 
 override def onFailure : PartialFunction [ Throwable , RpcError ] = { 
 case GroupErrors . NotAMember ⇒ CommonRpcErrors . forbidden ( " You are not a group member . " ) 
 + case GroupErrors . NotAdmin ⇒ CommonRpcErrors . forbidden ( " Only admin can perform this action . " ) 
 case DialogErrors . MessageToSelf ⇒ CommonRpcErrors . forbidden ( " Sending messages to self is not allowed . " ) 
 case InvalidAccessHash ⇒ CommonRpcErrors . InvalidAccessHash 
 case DialogErrors . DialogAlreadyArchived ( peer ) ⇒
