BLEU SCORE: 0.03741943603457605

TEST MSG: fix ( server : session , server : raw ) : don ' t cache big responses ; raw services no longer require auth
GENERATED MSG: feat ( rpc ) : ability to attach services to already running RpcApiService

TEST DIFF (one line): diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala < nl > index b5d186c . . 100b50b 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw < nl > import akka . actor . ActorSystem < nl > import cats . data . Xor < nl > import im . actor . api . rpc . collections . _ < nl > - import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > + import im . actor . api . rpc . { ClientData , RpcError } < nl > < nl > import scala . concurrent . Future < nl > < nl > @ @ - 27 , 7 + 27 , 7 @ @ abstract class ArrayStyleRawApiService ( system : ActorSystem ) extends RawApiServic < nl > < nl > protected def validateRequests : Option [ ApiRawValue ] ⇒ PartialFunction [ String , RpcError Xor Request ] < nl > < nl > - protected def processRequests : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > + protected def processRequests : ClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > < nl > / * * < nl > * Parse content of ` optParams ` to type T , < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala < nl > index cd5edd6 . . f35e64c 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw < nl > import akka . actor . ActorSystem < nl > import cats . data . Xor < nl > import im . actor . api . rpc . collections . _ < nl > - import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > + import im . actor . api . rpc . { ClientData , RpcError } < nl > import play . api . libs . json . _ < nl > < nl > import scala . concurrent . Future < nl > @ @ - 63 , 7 + 63 , 7 @ @ abstract class MapStyleRawApiService ( system : ActorSystem ) extends RawApiService ( < nl > < nl > protected def validateRequest : Option [ JsObject ] ⇒ PartialFunction [ String , RpcError Xor Request ] < nl > < nl > - protected def handleInternal : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > + protected def handleInternal : ClientData ⇒ PartialFunction [ Request , Future [ Response ] ] < nl > < nl > private def toRequest ( name : String , optParams : Option [ ApiRawValue ] ) : RpcError Xor Request = { < nl > val jsParams = optParams map { params ⇒ < nl > diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > index 6b75303 . . 2a9c0dd 100644 < nl > - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala < nl > @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw < nl > import akka . actor . ActorSystem < nl > import cats . data . Xor < nl > import im . actor . api . rpc . collections . ApiRawValue < nl > - import im . actor . api . rpc . { AuthorizedClientData , RpcError } < nl > + import im . actor . api . rpc . { ClientData , RpcError } < nl > < nl > import scala . concurrent . Future < nl > < nl > @ @ - 18 , 7 + 18 , 7 @ @ abstract class RawApiService ( system : ActorSystem ) { < nl > < nl > type Response = RpcError Xor ApiRawValue < nl > < nl > - type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] < nl > + type Handler = ClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] < nl > < nl > def handleRequests : Handler < nl > < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > index f395dd6 . . 959aaa7 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala < nl > @ @ - 5 , 7 + 5 , 7 @ @ import cats . data . Xor < nl > import im . actor . api . rpc . collections . ApiRawValue < nl > import im . actor . api . rpc . FutureResultRpc < nl > import im . actor . api . rpc . raw . RawApiService < nl > - import im . actor . api . rpc . { AuthorizedClientData , CommonRpcErrors , RpcError } < nl > + import im . actor . api . rpc . { AuthorizedClientData , ClientData , CommonRpcErrors , RpcError } < nl > < nl > import scala . collection . concurrent . TrieMap < nl > import scala . concurrent . Future < nl > @ @ - 27 , 10 + 27 , 10 @ @ private [ rpc ] final class RawApiExtensionImpl ( system : ExtendedActorSystem ) extend < nl > < nl > def register ( serviceSeq : Seq [ ( String , RawApiService ) ] ) : Unit = services + + = serviceSeq < nl > < nl > - def handle ( service : String , method : String , params : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ RpcError Xor ApiRawValue ] = < nl > + def handle ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ RpcError Xor ApiRawValue ] = < nl > ( for { < nl > serviceHandler ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( services . get ( service ) ) < nl > - response ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( client ) ( params ) . lift ( method ) ) < nl > + response ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( clientData ) ( params ) . lift ( method ) ) < nl > result ← fromFutureXor ( response ) < nl > } yield result ) . value < nl > } < nl > diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > index 414cdf9 . . aacc408 100644 < nl > - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala < nl > @ @ - 17 , 8 + 17 , 6 @ @ final class RawServiceImpl ( implicit system : ActorSystem ) extends RawService { < nl > private val rawApiExt = RawApiExtension ( system ) < nl > < nl > override def doHandleRawRequest ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseRawRequest ] ] = < nl > - authorized ( clientData ) { implicit client ⇒ < nl > - ( for ( result ← fromFutureXor ( rawApiExt . handle ( service , method , params ) ) ) < nl > - yield ResponseRawRequest ( result ) ) . value < nl > - } < nl > + ( for ( result ← fromFutureXor ( rawApiExt . handle ( service , method , params , clientData ) ) ) < nl > + yield ResponseRawRequest ( result ) ) . value < nl > } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf < nl > index 3f8a726 . . 8a335a9 100644 < nl > - - - a / actor - server / actor - session / src / main / resources / reference . conf < nl > + + + b / actor - server / actor - session / src / main / resources / reference . conf < nl > @ @ - 9 , 7 + 9 , 8 @ @ session { < nl > } < nl > < nl > rpc { < nl > + max - cached - result - size : 20 KiB < nl > ack - delay : 15 seconds < nl > - max - cache - size : 10 < nl > + max - cached - results : 10 < nl > } < nl > } < nl > diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > index f52dcc4 . . 1d36cb3 100644 < nl > - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala < nl > @ @ - 3 , 7 + 3 , 8 @ @ package im . actor . server . session < nl > import akka . actor . _ < nl > import akka . pattern . pipe < nl > import akka . stream . actor . _ < nl > - import im . actor . api . rpc . { RpcInternalError , RpcResult } < nl > + import com . github . kxbmap . configs . Bytes < nl > + import im . actor . api . rpc . { RpcError , RpcInternalError , RpcOk , RpcResult } < nl > import im . actor . server . api . rpc . RpcApiService . RpcResponse < nl > import im . actor . server . api . rpc . { RpcApiExtension , RpcApiService } < nl > import im . actor . util . cache . CacheHelpers . _ < nl > @ @ - 28 , 7 + 29 , 7 @ @ private [ session ] object RpcHandler { < nl > type AckOrResult = Either [ Long , RpcResult ] < nl > } < nl > < nl > - private [ session ] case class RpcConfig ( maxCacheSize : Long , ackDelay : FiniteDuration ) < nl > + private [ session ] case class RpcConfig ( maxCachedResults : Long , maxCachedResultSize : Bytes , ackDelay : FiniteDuration ) < nl > < nl > private [ session ] object RequestHandler { < nl > private [ session ] def props ( promise : Promise [ RpcApiService . RpcResponse ] , service : ActorRef , request : RpcApiService . HandleRpcRequest ) = < nl > @ @ - 86 , 7 + 87 , 9 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit < nl > private [ this ] var requestQueue = Map . empty [ Long , Cancellable ] < nl > < nl > private [ this ] var protoMessageQueue = immutable . Queue . empty [ ( Option [ RpcResult ] , Long ) ] < nl > - private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCacheSize ) < nl > + < nl > + / / FIXME : invalidate on incoming ack < nl > + private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCachedResults ) < nl > < nl > def subscriber : Receive = { < nl > case OnNext ( HandleRpcRequest ( messageId , requestBytes , clientData ) ) ⇒ < nl > @ @ - 129 , 6 + 132 , 9 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit < nl > case RpcApiService . RpcResponse ( messageId , result ) ⇒ < nl > log . debug ( " Received RpcResponse for messageId : { } , publishing " , messageId ) < nl > < nl > + if ( ! canCache ( result ) ) < nl > + responseCache . invalidate ( messageId ) < nl > + < nl > requestQueue . get ( messageId ) foreach ( _ . cancel ( ) ) < nl > requestQueue - = messageId < nl > enqueue ( Some ( result ) , messageId ) < nl > @ @ - 140 , 6 + 146 , 16 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit < nl > case Cancel ⇒ context . stop ( self ) < nl > } < nl > < nl > + private def canCache ( result : RpcResult ) : Boolean = { < nl > + val size = result match { < nl > + case RpcOk ( res ) ⇒ res . getSerializedSize < nl > + case err : RpcError ⇒ err . data . map ( _ . getSerializedSize ) . getOrElse ( 0 ) + err . userMessage . length < nl > + case _ ⇒ 0 < nl > + } < nl > + < nl > + size > config . maxCachedResultSize . value < nl > + } < nl > + < nl > private def enqueueAck ( requestMessageId : Long ) : Unit = enqueue ( None , requestMessageId ) < nl > < nl > private def enqueue ( res : Option [ RpcResult ] , requestMessageId : Long ) : Unit = { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > index d5ac284 . . 6f0dca5 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala < nl > @ @ - 175 , 169 + 175 , 172 @ @ class RawServiceSpec < nl > } < nl > < nl > } < nl > + } < nl > < nl > - / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service < nl > - < nl > - private object DictionaryMeanings { < nl > - val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " < nl > - val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " < nl > - val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " < nl > - } < nl > - < nl > - / * * < nl > - * Example raw api service that stores and retrieves words from dictionary . < nl > - * / < nl > - private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { < nl > - import DictionaryMeanings . _ < nl > - import ServiceErrors . _ < nl > - import im . actor . api . rpc . FutureResultRpc . _ < nl > - < nl > - private val kv = TrieMap . empty [ String , String ] < nl > - < nl > - kv . put ( " culture " , Culture ) < nl > - kv . put ( " science " , Science ) < nl > - kv . put ( " software " , Software ) < nl > + private object ServiceErrors { < nl > + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) < nl > + } < nl > < nl > - override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > - case " getWord " ⇒ getWord ( params ) < nl > - / / case " putWord " = > putWord ( ) < nl > - } < nl > + class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { < nl > + import ServiceErrors . _ < nl > < nl > - def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > - val ps = optParams flatMap { < nl > - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } < nl > - case _ ⇒ None < nl > - } < nl > - ( for { < nl > - key ← fromOption ( InvalidParams ) ( ps ) < nl > - optValue ← point ( kv . get ( key ) ) < nl > - result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > - } yield ApiMapValue ( result ) ) . value < nl > - } < nl > + override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > + case " makeEcho " ⇒ echo ( params ) < nl > } < nl > < nl > - / * * < nl > - * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments < nl > - * / < nl > - private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { < nl > - import DictionaryMeanings . _ < nl > - import ServiceErrors . _ < nl > - import im . actor . api . rpc . FutureResultRpc . _ < nl > - < nl > - sealed trait DictionaryRequest < nl > - case class GetWord ( word : String ) extends DictionaryRequest < nl > - case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > - < nl > - implicit val getWordReads = Json . reads [ GetWord ] < nl > - implicit val putWordReads = Json . reads [ PutWord ] < nl > - < nl > - private val kv = TrieMap . empty [ String , String ] < nl > - < nl > - kv . put ( " culture " , Culture ) < nl > - kv . put ( " science " , Science ) < nl > - kv . put ( " software " , Software ) < nl > - < nl > - override type Request = DictionaryRequest < nl > - < nl > - override protected def validateRequest = optParams ⇒ { < nl > - case " getWord " ⇒ < nl > - for { < nl > - params ← Xor . fromOption ( optParams , InvalidParams ) < nl > - result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > - } yield result < nl > - case " putWord " ⇒ < nl > - for { < nl > - params ← Xor . fromOption ( optParams , InvalidParams ) < nl > - result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > - } yield result < nl > - } < nl > + def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { < nl > + onEcho ( ) < nl > + val resp = extractStringFromMap ( params , " query " ) map { q ⇒ < nl > + Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) < nl > + } getOrElse Xor . left ( InvalidParams ) < nl > + Future . successful ( resp ) < nl > + } < nl > < nl > - override protected def handleInternal = implicit client ⇒ { < nl > - case GetWord ( word ) ⇒ getWord ( word ) < nl > - case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > + private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = < nl > + optParams flatMap { < nl > + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } < nl > + case _ ⇒ None < nl > } < nl > < nl > - def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > - ( for { < nl > - optValue ← point ( kv . get ( word ) ) < nl > - result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > - } yield ApiMapValue ( result ) ) . value < nl > - } < nl > + def onEcho ( ) : Unit = { } < nl > + } < nl > < nl > - def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > - ( for { < nl > - _ ← point ( kv . put ( word , meaning ) ) < nl > - } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value < nl > - } < nl > - } < nl > + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service < nl > < nl > - / * * < nl > - * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments < nl > - * / < nl > - private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { < nl > - import DictionaryMeanings . _ < nl > - import im . actor . api . rpc . FutureResultRpc . _ < nl > + private object DictionaryMeanings { < nl > + val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " < nl > + val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " < nl > + val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " < nl > + } < nl > < nl > - sealed trait DictionaryRequest < nl > - case class GetWord ( word : String ) extends DictionaryRequest < nl > - case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . < nl > + * / < nl > + private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import ServiceErrors . _ < nl > + import im . actor . api . rpc . FutureResultRpc . _ < nl > + import system . dispatcher < nl > < nl > - private val kv = TrieMap . empty [ String , String ] < nl > + private val kv = TrieMap . empty [ String , String ] < nl > < nl > - kv . put ( " culture " , Culture ) < nl > - kv . put ( " science " , Science ) < nl > - kv . put ( " software " , Software ) < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > < nl > - override type Request = DictionaryRequest < nl > + override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > + case " getWord " ⇒ getWord ( params ) < nl > + / / case " putWord " = > putWord ( ) < nl > + } < nl > < nl > - override protected def validateRequests = optParams ⇒ { < nl > - case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord < nl > - case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) < nl > + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : ClientData ) : Future [ Response ] = { < nl > + val ps = optParams flatMap { < nl > + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } < nl > + case _ ⇒ None < nl > } < nl > + ( for { < nl > + key ← fromOption ( InvalidParams ) ( ps ) < nl > + optValue ← point ( kv . get ( key ) ) < nl > + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > + } yield ApiMapValue ( result ) ) . value < nl > + } < nl > + } < nl > < nl > - override protected def processRequests = implicit client ⇒ { < nl > - case GetWord ( word ) ⇒ getWord ( word ) < nl > - case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > - } < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments < nl > + * / < nl > + private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import ServiceErrors . _ < nl > + import im . actor . api . rpc . FutureResultRpc . _ < nl > + import system . dispatcher < nl > + < nl > + sealed trait DictionaryRequest < nl > + case class GetWord ( word : String ) extends DictionaryRequest < nl > + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > + < nl > + implicit val getWordReads = Json . reads [ GetWord ] < nl > + implicit val putWordReads = Json . reads [ PutWord ] < nl > + < nl > + private val kv = TrieMap . empty [ String , String ] < nl > + < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > + < nl > + override type Request = DictionaryRequest < nl > + < nl > + override protected def validateRequest = optParams ⇒ { < nl > + case " getWord " ⇒ < nl > + for { < nl > + params ← Xor . fromOption ( optParams , InvalidParams ) < nl > + result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > + } yield result < nl > + case " putWord " ⇒ < nl > + for { < nl > + params ← Xor . fromOption ( optParams , InvalidParams ) < nl > + result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) < nl > + } yield result < nl > + } < nl > < nl > - def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > - ( for { < nl > - optValue ← point ( kv . get ( word ) ) < nl > - encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty < nl > - } yield ApiArrayValue ( encodedArr ) ) . value < nl > - } < nl > + override protected def handleInternal = implicit client ⇒ { < nl > + case GetWord ( word ) ⇒ getWord ( word ) < nl > + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > + } < nl > < nl > - def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { < nl > - kv . put ( word , meaning ) < nl > - Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) < nl > - } < nl > + def getWord ( word : String ) ( implicit client : ClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + optValue ← point ( kv . get ( word ) ) < nl > + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty < nl > + } yield ApiMapValue ( result ) ) . value < nl > } < nl > < nl > - / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service < nl > + def putWord ( word : String , meaning : String ) ( implicit client : ClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + _ ← point ( kv . put ( word , meaning ) ) < nl > + } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value < nl > + } < nl > + } < nl > < nl > - private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { < nl > - import ServiceErrors . _ < nl > + / * * < nl > + * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments < nl > + * / < nl > + private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { < nl > + import DictionaryMeanings . _ < nl > + import im . actor . api . rpc . FutureResultRpc . _ < nl > + import system . dispatcher < nl > < nl > - override def handleRequests : Handler = implicit client ⇒ params ⇒ { < nl > - case " makeEcho " ⇒ echo ( params ) < nl > - } < nl > + sealed trait DictionaryRequest < nl > + case class GetWord ( word : String ) extends DictionaryRequest < nl > + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest < nl > < nl > - def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { < nl > - val resp = extractStringFromMap ( params , " query " ) map { q ⇒ < nl > - Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) < nl > - } getOrElse Xor . left ( InvalidParams ) < nl > - Future . successful ( resp ) < nl > - } < nl > + private val kv = TrieMap . empty [ String , String ] < nl > + < nl > + kv . put ( " culture " , Culture ) < nl > + kv . put ( " science " , Science ) < nl > + kv . put ( " software " , Software ) < nl > + < nl > + override type Request = DictionaryRequest < nl > + < nl > + override protected def validateRequests = optParams ⇒ { < nl > + case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord < nl > + case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) < nl > } < nl > < nl > - private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = < nl > - optParams flatMap { < nl > - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } < nl > - case _ ⇒ None < nl > - } < nl > + override protected def processRequests = implicit client ⇒ { < nl > + case GetWord ( word ) ⇒ getWord ( word ) < nl > + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) < nl > + } < nl > < nl > - private object ServiceErrors { < nl > - val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) < nl > + def getWord ( word : String ) ( implicit client : ClientData ) : Future [ Response ] = { < nl > + ( for { < nl > + optValue ← point ( kv . get ( word ) ) < nl > + encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty < nl > + } yield ApiArrayValue ( encodedArr ) ) . value < nl > } < nl > < nl > - } < nl > + def putWord ( word : String , meaning : String ) ( implicit client : ClientData ) : Future [ Response ] = { < nl > + kv . put ( word , meaning ) < nl > + Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) < nl > + } < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > index 83c5071 . . 5fc185e 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala < nl > @ @ - 7 , 6 + 7 , 7 @ @ import im . actor . server . api . rpc . RpcApiExtension < nl > import im . actor . server . api . rpc . service . auth . AuthServiceImpl < nl > import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl < nl > import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl < nl > + import im . actor . server . api . rpc . service . raw . RawServiceImpl < nl > import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } < nl > import im . actor . server . db . DbExtension < nl > import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } < nl > @ @ - 48 , 16 + 49 , 17 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { < nl > < nl > implicit val sessionRegion = Session . startRegionProxy ( ) < nl > < nl > - protected val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) < nl > + protected lazy val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) < nl > protected implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) < nl > protected implicit val authService = new AuthServiceImpl < nl > - protected val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get < nl > + protected lazy val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get < nl > protected lazy val sequenceService = new SequenceServiceImpl ( sequenceConfig ) < nl > protected lazy val messagingService = MessagingServiceImpl ( ) < nl > protected lazy val contactsService = new ContactsServiceImpl ( ) < nl > + protected lazy val rawService = new RawServiceImpl ( ) < nl > < nl > override def beforeAll = { < nl > - RpcApiExtension ( system ) . register ( Seq ( authService , sequenceService , messagingService , contactsService ) ) < nl > + RpcApiExtension ( system ) . register ( Seq ( authService , sequenceService , messagingService , contactsService , rawService ) ) < nl > } < nl > < nl > protected def createAuthId ( ) : Long = { < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > index 64352df . . cc58a3c 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala < nl > @ @ - 3 , 14 + 3 , 16 @ @ package im . actor . server . session < nl > import akka . testkit . TestProbe < nl > import com . typesafe . config . ConfigFactory < nl > import im . actor . api . rpc . _ < nl > - import im . actor . api . rpc . auth . { ResponseStartPhoneAuth , RequestStartPhoneAuth } < nl > + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } < nl > import im . actor . api . rpc . codecs . RequestCodec < nl > - import im . actor . api . rpc . contacts . { UpdateContactsAdded , UpdateContactRegistered } < nl > + import im . actor . api . rpc . contacts . { UpdateContactRegistered , UpdateContactsAdded } < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > + import im . actor . api . rpc . raw . RequestRawRequest < nl > import im . actor . api . rpc . sequence . RequestGetState < nl > import im . actor . api . rpc . weak . { UpdateUserOffline , UpdateUserOnline } < nl > - import im . actor . concurrent . FutureExt < nl > import im . actor . server . ActorSpecification < nl > + import im . actor . server . api . rpc . RawApiExtension < nl > + import im . actor . server . api . rpc . service . raw . EchoService < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } < nl > < nl > @ @ - 36 , 7 + 38 , 7 @ @ final class SessionResendSpec extends BaseSessionSpec ( < nl > it should " resend updates if no ack received within ack - timeout " in Sessions ( ) . resendUpdates < nl > it should " not resend messages when another came with the same reduceKey ( weak ) " in Sessions ( ) . reduceKeyWeak < nl > it should " not resend messages when another came with the same reduceKey ( seq ) " in Sessions ( ) . reduceKeySeq < nl > - it should " schedule one resend after subsequent requests with the same messageId " in Sessions ( ) . eee < nl > + it should " schedule one resend after subsequent requests with the same messageId " in Sessions ( ) . oneResendForCached < nl > < nl > case class Sessions ( ) { < nl > val weakUpdatesExt = WeakUpdatesExtension ( system ) < nl > @ @ - 304 , 7 + 306 , 7 @ @ final class SessionResendSpec extends BaseSessionSpec ( < nl > expectContactsAdded ( authId , sessionId , 4 ) < nl > } < nl > < nl > - def eee ( ) : Unit = { < nl > + def oneResendForCached ( ) : Unit = { < nl > implicit val probe = TestProbe ( ) < nl > < nl > val authId = createAuthId ( ) < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 2abd8e7 . . c7151f5 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 4 , 27 + 4 , 32 @ @ import akka . testkit . TestProbe < nl > import com . google . protobuf . ByteString < nl > import im . actor . api . rpc . auth . _ < nl > import im . actor . api . rpc . codecs . _ < nl > + import im . actor . api . rpc . collections . ApiStringValue < nl > import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } < nl > import im . actor . api . rpc . messaging . RequestLoadDialogs < nl > import im . actor . api . rpc . misc . ResponseVoid < nl > import im . actor . api . rpc . peers . ApiUserOutPeer < nl > import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } < nl > import im . actor . api . rpc . misc . ResponseSeq < nl > + import im . actor . api . rpc . raw . RequestRawRequest < nl > import im . actor . api . rpc . weak . UpdateUserOffline < nl > import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } < nl > + import im . actor . server . api . rpc . RawApiExtension < nl > import im . actor . server . api . rpc . service . auth . AuthErrors < nl > + import im . actor . server . api . rpc . service . raw . EchoService < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . _ < nl > import im . actor . server . persist . AuthSessionRepo < nl > import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } < nl > import im . actor . server . user . UserExtension < nl > + import org . scalatest . BeforeAndAfterEach < nl > import scodec . bits . _ < nl > < nl > import scala . concurrent . Await < nl > import scala . concurrent . duration . _ < nl > import scala . util . Random < nl > < nl > - final class SessionSpec extends BaseSessionSpec { < nl > + final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { < nl > behavior of " Session actor " < nl > < nl > it should " send Drop on message on wrong message box " in sessions ( ) . wrongMessageBox < nl > @ @ - 37 , 6 + 42 , 14 @ @ final class SessionSpec extends BaseSessionSpec { < nl > it should " receive fat updates " in sessions ( ) . fatSeq < nl > it should " react to SessionHello " in sessions ( ) . hello < nl > it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong < nl > + it should " cache small results " in sessions ( ) . cacheSmallResults < nl > + it should " not cache big requests " in sessions ( ) . notCacheBigRequests < nl > + < nl > + var count = 0 < nl > + < nl > + override def beforeEach = { < nl > + RawApiExtension ( system ) . register ( " echo " , new EchoService ( system ) { override def onEcho ( ) = count + = 1 } ) < nl > + } < nl > < nl > case class sessions ( ) { < nl > < nl > @ @ - 371 , 5 + 384 , 65 @ @ final class SessionSpec extends BaseSessionSpec { < nl > expectMessageAck ( messageId ) < nl > probe . expectNoMsg ( ) < nl > } < nl > + < nl > + def cacheSmallResults ( ) : Unit = { < nl > + implicit val probe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + < nl > + val helloMessageId = Random . nextLong ( ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , helloMessageId , SessionHello ) < nl > + expectNewSession ( authId , sessionId , helloMessageId ) < nl > + expectMessageAck ( ) < nl > + < nl > + val messageId = Random . nextLong ( ) < nl > + count = 0 < nl > + < nl > + for ( _ ← 1 to 3 ) < nl > + sendRequest ( < nl > + authId , < nl > + sessionId , < nl > + sessionRegion . ref , < nl > + messageId , < nl > + RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( " . . . " ) ) ) < nl > + ) < nl > + < nl > + for ( _ ← 1 to 3 ) < nl > + expectRpcResult ( authId , sessionId , ignoreAcks = true ) < nl > + < nl > + count shouldBe 1 < nl > + } < nl > + < nl > + def notCacheBigRequests ( ) : Unit = { < nl > + implicit val probe = TestProbe ( ) < nl > + < nl > + val authId = createAuthId ( ) < nl > + val sessionId = Random . nextLong ( ) < nl > + < nl > + val helloMessageId = Random . nextLong ( ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion . ref , helloMessageId , SessionHello ) < nl > + expectNewSession ( authId , sessionId , helloMessageId ) < nl > + expectMessageAck ( ) < nl > + < nl > + val longString = List . range ( 1 , 40000 ) . map ( _ ⇒ " . " ) . mkString < nl > + < nl > + val messageId = Random . nextLong ( ) < nl > + count = 0 < nl > + < nl > + for ( _ ← 1 to 3 ) < nl > + sendRequest ( < nl > + authId , < nl > + sessionId , < nl > + sessionRegion . ref , < nl > + messageId , < nl > + RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( longString ) ) ) < nl > + ) < nl > + < nl > + for ( _ ← 1 to 3 ) < nl > + expectRpcResult ( authId , sessionId , ignoreAcks = true ) < nl > + < nl > + count shouldBe 3 < nl > + } < nl > } < nl > } < nl > diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > index a2c36b3 . . 135a57a 100644 < nl > - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala < nl > @ @ - 55 , 7 + 55 , 7 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { < nl > update . asInstanceOf [ T ] < nl > } < nl > < nl > - protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { < nl > + protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty , ignoreAcks : Boolean = false ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { < nl > val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet < nl > < nl > if ( messages . size ! = expectAckFor . size + 1 ) { < nl > @ @ - 71 , 7 + 71 , 8 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { < nl > } < nl > } < nl > < nl > - ackIds shouldEqual expectAckFor < nl > + if ( ! ignoreAcks ) < nl > + ackIds shouldEqual expectAckFor < nl > < nl > rest match { < nl > case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒
NEAREST DIFF (one line): diff - - git a / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala b / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala < nl > index 41ec6fe . . d00b7ab 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala < nl > @ @ - 51 , 7 + 51 , 7 @ @ package object rpc extends { < nl > < nl > def requireAuth ( implicit clientData : ClientData ) : MaybeAuthorized [ AuthorizedClientData ] = < nl > clientData . optUserId match { < nl > - case Some ( userId ) = > Authorized ( AuthorizedClientData ( clientData . authId , userId ) ) < nl > + case Some ( userId ) = > Authorized ( AuthorizedClientData ( clientData . authId , clientData . sessionId , userId ) ) < nl > case None = > NotAuthorized < nl > } < nl > < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala < nl > index 2d70f73 . . aab7dfe 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala < nl > @ @ - 10 , 7 + 10 , 6 @ @ import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . codecs . _ < nl > - import im . actor . server . api . rpc . service . auth . AuthServiceImpl < nl > < nl > object RpcApiService { < nl > < nl > @ @ - 20 , 56 + 19 , 53 @ @ object RpcApiService { < nl > @ SerialVersionUID ( 1L ) < nl > case class RpcResponse ( messageId : Long , responseBytes : BitVector ) < nl > < nl > - def props ( ) ( implicit db : Database ) = Props ( classOf [ RpcApiService ] , db ) < nl > - < nl > @ SerialVersionUID ( 1L ) < nl > - private [ rpc ] case object Initialize < nl > + case class AttachService ( service : Service ) < nl > < nl > + def props ( ) ( implicit db : Database ) = Props ( classOf [ RpcApiService ] , db ) < nl > } < nl > < nl > class RpcApiService ( implicit db : Database ) extends Actor with ActorLogging { < nl > < nl > import RpcApiService . _ < nl > < nl > - type Chain = PartialFunction [ RpcRequest , ClientData = > Future [ RpcError \ / RpcOk ] ] < nl > - < nl > - implicit val ec : ExecutionContext = context . dispatcher < nl > + private type Chain = PartialFunction [ RpcRequest , ClientData = > Future [ RpcError \ / RpcOk ] ] < nl > < nl > - override def preStart ( ) : Unit = { < nl > - super . preStart ( ) < nl > - self ! Initialize < nl > - } < nl > + implicit private val ec : ExecutionContext = context . dispatcher < nl > < nl > - def receive : Receive = { < nl > - case Initialize = > < nl > - implicit val s = context . system < nl > + def receive = initialized ( Set . empty ) < nl > < nl > - val services : Seq [ Service ] = Seq ( new AuthServiceImpl ) < nl > - val chain : Chain = services . map ( _ . handleRequestPartial ) . reduce { ( a , b ) = > < nl > - a . orElse ( b ) < nl > + def initialized ( services : Set [ Service ] ) : Receive = { < nl > + val chain : Chain = < nl > + if ( services . isEmpty ) { < nl > + PartialFunction . empty < nl > + } else { < nl > + services . map ( _ . handleRequestPartial ) . reduce { ( a , b ) = > < nl > + a . orElse ( b ) < nl > + } < nl > } < nl > < nl > - context . become ( initialized ( chain ) , discardOld = true ) < nl > - } < nl > - < nl > - def initialized ( chain : Chain ) : Receive = { < nl > - case HandleRpcRequest ( messageId , requestBytes , clientData ) = > < nl > - RequestCodec . decode ( requestBytes ) . require map { < nl > - case Request ( rpcRequest ) = > < nl > - val result = < nl > - if ( chain . isDefinedAt ( rpcRequest ) ) { < nl > - chain ( rpcRequest ) ( clientData ) < nl > - } else { < nl > - log . error ( " Unsupported request { } " , rpcRequest ) < nl > - Future . successful ( Error ( CommonErrors . UnsupportedRequest ) ) < nl > - } < nl > - < nl > - result < nl > - . map ( _ . fold ( err = > err , ok = > ok ) ) < nl > - . map ( result = > RpcResponse ( messageId , RpcResultCodec . encode ( result ) . require ) ) < nl > - . pipeTo ( sender ( ) ) < nl > - case _ = > < nl > - Future . successful ( CommonErrors . UnsupportedRequest ) < nl > - } < nl > + { < nl > + case AttachService ( service ) = > < nl > + context . become ( initialized ( services + service ) , discardOld = true ) < nl > + case HandleRpcRequest ( messageId , requestBytes , clientData ) = > < nl > + RequestCodec . decode ( requestBytes ) . require map { < nl > + case Request ( rpcRequest ) = > < nl > + val result = < nl > + if ( chain . isDefinedAt ( rpcRequest ) ) { < nl > + chain ( rpcRequest ) ( clientData ) < nl > + } else { < nl > + log . error ( " Unsupported request { } " , rpcRequest ) < nl > + Future . successful ( Error ( CommonErrors . UnsupportedRequest ) ) < nl > + } < nl > + < nl > + result < nl > + . map ( _ . fold ( err = > err , ok = > ok ) ) < nl > + . map ( result = > RpcResponse ( messageId , RpcResultCodec . encode ( result ) . require ) ) < nl > + . pipeTo ( sender ( ) ) < nl > + case _ = > < nl > + Future . successful ( CommonErrors . UnsupportedRequest ) < nl > + } < nl > + } < nl > } < nl > } < nl > diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > index f0fc6a2 . . a9a0de6 100644 < nl > - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala < nl > @ @ - 1 , 6 + 1 , 14 @ @ < nl > package im . actor . server . api . rpc . service . auth < nl > < nl > - import akka . actor . ActorSystem < nl > + < nl > + import scala . concurrent . _ , forkjoin . ThreadLocalRandom < nl > + import scalaz . _ < nl > + < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > + import org . joda . time . DateTime < nl > + import shapeless . _ < nl > + import slick . dbio . DBIO < nl > + import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . _ < nl > import im . actor . api . rpc . auth . _ < nl > @ @ - 8 , 17 + 16 , 9 @ @ import im . actor . api . rpc . misc . _ < nl > import im . actor . server . api . util < nl > import im . actor . server . models < nl > import im . actor . server . persist < nl > + import im . actor . server . session . _ < nl > < nl > - import org . joda . time . DateTime < nl > - < nl > - import scala . concurrent . _ , forkjoin . ThreadLocalRandom < nl > - < nl > - import scalaz . _ , std . either . _ < nl > - import shapeless . _ < nl > - import slick . dbio . DBIO < nl > - import slick . driver . PostgresDriver . api . _ < nl > - < nl > - class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) extends AuthService with Helpers { < nl > + class AuthServiceImpl ( sessionRegion : ActorRef ) ( implicit val actorSystem : ActorSystem , val db : Database ) extends AuthService with Helpers { < nl > private trait SignType < nl > private case class Up ( name : String , isSilent : Boolean ) extends SignType < nl > private case object In extends SignType < nl > @ @ - 74 , 8 + 74 , 14 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e < nl > ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > throw new NotImplementedError ( ) < nl > < nl > - override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > - throw new NotImplementedError ( ) < nl > + override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { < nl > + val action = requireAuth ( clientData ) map { implicit client = > < nl > + DBIO . successful ( Ok ( misc . ResponseVoid ) ) < nl > + } < nl > + < nl > + db . run ( toDBIOAction ( action ) ) < nl > + } < nl > + < nl > < nl > override def jhandleSignIn ( < nl > rawPhoneNumber : Long , < nl > @ @ - 169 , 7 + 175 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e < nl > / / Phone already exists , fall back to SignIn < nl > case Some ( phone ) = > < nl > withValidPublicKey ( rawPublicKey ) { publicKey = > < nl > - signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode ) < nl > + signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode , clientData ) < nl > } < nl > } < nl > ) < nl > @ @ - 179 , 7 + 185 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e < nl > case None = > DBIO . successful ( Error ( Errors . PhoneNumberUnoccupied ) ) < nl > case Some ( phone ) = > < nl > persist . AuthSmsCode . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( < nl > - signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode ) < nl > + signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode , clientData ) < nl > ) < nl > } < nl > } < nl > @ @ - 219 , 7 + 225 , 16 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e < nl > case error @ - \ / ( _ ) = > DBIO . successful ( error ) < nl > } < nl > < nl > - db . run ( action ) < nl > + for ( result < - db . run ( action . transactionally ) ) < nl > + yield { < nl > + result match { < nl > + case Ok ( r : ResponseAuth ) = > < nl > + sessionRegion ! SessionMessage . envelope ( SessionMessage . UserAuthorized ( r . user . id ) ) ( clientData ) < nl > + case _ = > < nl > + } < nl > + < nl > + result < nl > + } < nl > } < nl > } < nl > } < nl > @ @ - 230 , 7 + 245 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e < nl > override def jhandleTerminateSession ( id : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = < nl > throw new NotImplementedError ( ) < nl > < nl > - private def signIn ( authId : Long , userId : Int , pkData : Array [ Byte ] , pkHash : Long , countryCode : String ) = { < nl > + private def signIn ( authId : Long , userId : Int , pkData : Array [ Byte ] , pkHash : Long , countryCode : String , clientData : ClientData ) = { < nl > persist . User . find ( userId ) . headOption . flatMap { < nl > case None = > DBIO . successful ( Error ( CommonErrors . Internal ) ) < nl > case Some ( user ) = > < nl > diff - - git a / actor - session - messages / src / main / scala / im / actor / server / session / package . scala b / actor - session - messages / src / main / scala / im / actor / server / session / package . scala < nl > new file mode 100644 < nl > index 0000000 . . acaf954 < nl > - - - / dev / null < nl > + + + b / actor - session - messages / src / main / scala / im / actor / server / session / package . scala < nl > @ @ - 0 , 0 + 1 , 26 @ @ < nl > + package im . actor . server . session < nl > + < nl > + import im . actor . api . rpc . BaseClientData < nl > + import im . actor . server . mtproto . protocol . ProtoMessage < nl > + < nl > + sealed trait SessionMessage < nl > + < nl > + object SessionMessage { < nl > + @ SerialVersionUID ( 1L ) < nl > + private [ session ] case class Envelope ( authId : Long , sessionId : Long , message : SessionMessage ) < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + case class HandleMessageBox ( messageBoxBytes : Array [ Byte ] ) extends SessionMessage < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + case class SendProtoMessage ( message : ProtoMessage ) extends SessionMessage < nl > + < nl > + @ SerialVersionUID ( 1L ) < nl > + case class UserAuthorized ( userId : Int ) extends SessionMessage < nl > + < nl > + def envelope ( authId : Long , sessionId : Long , message : SessionMessage ) : Envelope = < nl > + Envelope ( authId , sessionId , message ) < nl > + < nl > + def envelope ( message : SessionMessage ) ( implicit clientData : BaseClientData ) : Envelope = < nl > + envelope ( clientData . authId , clientData . sessionId , message ) < nl > + } < nl > \ No newline at end of file < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > index 7a09dee . . 3640612 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala < nl > @ @ - 3 , 40 + 3 , 45 @ @ package im . actor . server . session < nl > import scala . collection . mutable < nl > < nl > import akka . actor . _ < nl > + import akka . contrib . pattern . { ClusterSharding , ShardRegion } < nl > import akka . stream . FlowMaterializer < nl > import akka . stream . actor . _ < nl > import akka . stream . scaladsl . _ < nl > import scodec . _ < nl > import scodec . bits . _ < nl > - import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . rpc . ClientData < nl > - import im . actor . server . api . rpc . RpcApiService < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . _ < nl > < nl > object Session { < nl > < nl > - sealed trait SessionMessage < nl > + import SessionMessage . _ < nl > < nl > - @ SerialVersionUID ( 1L ) < nl > - case class Envelope ( authId : Long , sessionId : Long , msg : SessionMessage ) < nl > + private [ this ] val idExtractor : ShardRegion . IdExtractor = { < nl > + case env @ Envelope ( authId , sessionId , payload ) = > ( authId . toString + " - " + sessionId . toString , env ) < nl > + } < nl > < nl > - @ SerialVersionUID ( 1L ) < nl > - case class HandleMessageBox ( messageBoxBytes : Array [ Byte ] ) extends SessionMessage < nl > + private [ this ] val shardResolver : ShardRegion . ShardResolver = msg = > msg match { < nl > + case Envelope ( authId , sessionId , _ ) = > ( authId % 32 ) . toString / / TODO : configurable < nl > + } < nl > < nl > - @ SerialVersionUID ( 1L ) < nl > - case class SendProtoMessage ( message : ProtoMessage ) extends SessionMessage < nl > + def startRegion ( props : Option [ Props ] ) ( implicit system : ActorSystem ) : ActorRef = < nl > + ClusterSharding ( system ) . start ( < nl > + typeName = " Session " , < nl > + entryProps = props , < nl > + idExtractor = idExtractor , < nl > + shardResolver = shardResolver < nl > + ) < nl > < nl > - def props ( ) ( implicit materializer : FlowMaterializer , database : Database ) = Props ( classOf [ Session ] , materializer , database ) < nl > + def props ( rpcApiService : ActorRef ) ( implicit materializer : FlowMaterializer ) = Props ( classOf [ Session ] , rpcApiService , materializer ) < nl > } < nl > < nl > - class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Actor with ActorLogging with MessageIdHelper { < nl > + class Session ( rpcApiService : ActorRef ) ( implicit materializer : FlowMaterializer ) extends Actor with ActorLogging with MessageIdHelper { < nl > < nl > - import Session . _ < nl > + import SessionMessage . _ < nl > < nl > - var newSessionSent : Boolean = false < nl > var optUserId : Option [ Int ] = None < nl > val clients = mutable . Set . empty [ ActorRef ] < nl > < nl > @ @ - 53 , 7 + 58 , 6 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > < nl > val sessionMessagePublisher = context . actorOf ( SessionMessagePublisher . props ( ) ) < nl > val rpcResponsePublisher = context . actorOf ( RpcResponseManager . props ( ) ) < nl > - val rpcApiService = context . actorOf ( RpcApiService . props ( ) ) / / TODO : make it adaptive router < nl > < nl > val source = Source ( ActorPublisher [ SessionStream . SessionStreamMessage ] ( sessionMessagePublisher ) ) < nl > val graph = SessionStream . graph ( < nl > @ @ - 66 , 14 + 70 , 13 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > val flow = rpcResponseSource . to ( Sink . foreach [ ProtoMessage ] ( m = > self ! SendProtoMessage ( m ) ) ) < nl > flow . run ( ) < nl > < nl > - sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , optUserId ) ) < nl > + sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , sessionId , optUserId ) ) < nl > < nl > - context become receiveResolved ( authId , sessionId , sessionMessagePublisher ) < nl > + context . become ( receiveResolved ( authId , sessionId , sessionMessagePublisher ) ) < nl > } < nl > case Terminated ( client ) = > < nl > clients . remove ( client ) < nl > - case unmatched = > < nl > - log . error ( " Received unmatched message { } " , unmatched ) < nl > + case unmatched = > handleUnmatched ( unmatched ) < nl > } < nl > < nl > def receiveResolved ( authId : Long , sessionId : Long , publisher : ActorRef ) : Receive = { < nl > @ @ - 90 , 6 + 93 , 7 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > sendProtoMessage ( authId , sessionId , protoMessage ) < nl > case Terminated ( client ) = > < nl > clients . remove ( client ) < nl > + case unmatched = > handleUnmatched ( unmatched ) < nl > } < nl > < nl > private def recordClient ( client : ActorRef ) : Unit = { < nl > @ @ - 97 , 15 + 101 , 21 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > context watch client < nl > } < nl > < nl > - private def handleSessionMessage ( < nl > - authId : Long , < nl > - sessionId : Long , < nl > - client : ActorRef , msg : SessionMessage , publisher : ActorRef < nl > - ) : Unit = msg match { < nl > - case HandleMessageBox ( messageBoxBytes ) = > < nl > - withValidMessageBox ( client , messageBoxBytes ) ( publisher . tell ( _ , self ) ) < nl > - case SendProtoMessage ( protoMessage ) = > < nl > - sendProtoMessage ( authId , sessionId , protoMessage ) < nl > + private def handleSessionMessage ( authId : Long , < nl > + sessionId : Long , < nl > + client : ActorRef , < nl > + message : SessionMessage , < nl > + publisher : ActorRef ) : Unit = { < nl > + log . debug ( " Session message { } " , message ) < nl > + message match { < nl > + case HandleMessageBox ( messageBoxBytes ) = > < nl > + withValidMessageBox ( client , messageBoxBytes ) ( mb = > publisher ! Tuple2 ( mb , ClientData ( authId , sessionId , optUserId ) ) ) < nl > + case SendProtoMessage ( protoMessage ) = > < nl > + sendProtoMessage ( authId , sessionId , protoMessage ) < nl > + case UserAuthorized ( userId ) = > < nl > + log . debug ( " User { } authorized session { } " , userId , sessionId ) < nl > + this . optUserId = Some ( userId ) < nl > + } < nl > } < nl > < nl > private def sendProtoMessage ( authId : Long , sessionId : Long , message : ProtoMessage ) : Unit = { < nl > @ @ - 116 , 8 + 126 , 9 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > decodeMessageBox ( messageBoxBytes ) match { < nl > case Some ( mb ) = > f ( mb ) < nl > case None = > < nl > - client ! Drop ( 0 , 0 , " Cannot parse message box " ) < nl > - context stop self < nl > + log . warning ( " Failed to parse MessageBox . Droping client . " ) < nl > + client ! Drop ( 0 , 0 , " Cannot parse MessageBox " ) < nl > + context . stop ( self ) < nl > } < nl > < nl > private def decodeMessageBox ( messageBoxBytes : Array [ Byte ] ) : Option [ MessageBox ] = < nl > @ @ - 138 , 4 + 149 , 7 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act < nl > private def sendProtoMessage ( authId : Long , sessionId : Long ) ( client : ActorRef , message : ProtoMessage ) : Unit = { < nl > client ! packProtoMessage ( authId , sessionId , message ) < nl > } < nl > + < nl > + private def handleUnmatched ( message : Any ) = < nl > + log . error ( " Received unmatched message { } " , message ) < nl > } < nl > diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala b / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala < nl > index 94f9bf8 . . 607ce87 100644 < nl > - - - a / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala < nl > + + + b / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala < nl > @ @ - 1 , 21 + 1 , 22 @ @ < nl > package im . actor . server . session < nl > < nl > + import scala . annotation . tailrec < nl > + import scala . collection . immutable < nl > + < nl > import akka . actor . _ < nl > import akka . stream . actor . _ < nl > - import akka . stream . scaladsl . _ < nl > < nl > import im . actor . api . rpc . ClientData < nl > import im . actor . server . mtproto . protocol . MessageBox < nl > < nl > - import scala . annotation . tailrec < nl > - import scala . collection . immutable < nl > - < nl > private [ session ] object SessionMessagePublisher { < nl > def props ( ) = Props [ SessionMessagePublisher ] < nl > } < nl > < nl > private [ session ] class SessionMessagePublisher extends ActorPublisher [ SessionStream . SessionStreamMessage ] with ActorLogging { < nl > + < nl > import ActorPublisherMessage . _ < nl > + < nl > import SessionStream . _ < nl > < nl > / / TODO : MaxQueueSize < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > index e07376d . . d506b45 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala < nl > @ @ - 1 , 15 + 1 , 12 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > - import im . actor . api . { rpc = > api } < nl > - import im . actor . server . models < nl > - import im . actor . server . persist < nl > - import im . actor . server . SqlSpecHelpers < nl > - import im . actor . util . testing . _ < nl > - < nl > - import scala . concurrent . _ < nl > + import im . actor . api . { rpc = > api } < nl > + import im . actor . server . api . rpc . RpcApiService < nl > + import im . actor . server . { models , persist } < nl > + import im . actor . server . session . Session < nl > < nl > class AuthServiceSpec extends BaseServiceSpec { < nl > - def is = sequential ^ s2 " " " < nl > + def is = sequential ^ s2 " " " < nl > < nl > AuthService < nl > SendAuthCode $ sendAuthCode < nl > @ @ - 25 , 27 + 22 , 30 @ @ class AuthServiceSpec extends BaseServiceSpec { < nl > not fail if number already exists $ { s . sendAuthCode . e1 } < nl > " " " < nl > < nl > - def signUp = s2 " " " < nl > + def signUp = s2 " " " < nl > SignUp handler should < nl > respond ok to a valid request $ { s . signUp ( ) . e1 } < nl > " " " < nl > < nl > - def signIn = s2 " " " < nl > + def signIn = s2 " " " < nl > SignIn handler should < nl > respond with PhoneNumberUnoccupied if phone is not registered $ { s . signIn ( ) . unoccupied } < nl > respond ok to a valid request $ { s . signIn ( ) . valid } < nl > " " " < nl > < nl > object s { < nl > - implicit val service = new auth . AuthServiceImpl ( ) < nl > + val rpcApiService = system . actorOf ( RpcApiService . props ( ) ) < nl > + val sessionRegion = Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) < nl > < nl > implicit val ec = system . dispatcher < nl > + implicit val service = new auth . AuthServiceImpl ( sessionRegion ) < nl > < nl > object sendAuthCode { < nl > val authId = createAuthId ( ) ( service . db ) < nl > + val sessionId = createSessionId ( ) < nl > val phoneNumber = buildPhone ( ) < nl > < nl > - implicit val clientData = api . ClientData ( authId , None ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , None ) < nl > < nl > def e1 = { < nl > service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) must beOkLike { < nl > @ @ - 54 , 12 + 54 , 13 @ @ class AuthServiceSpec extends BaseServiceSpec { < nl > } < nl > } < nl > < nl > - case class signUp ( ) { < nl > + case class signUp ( ) { < nl > val authId = createAuthId ( ) ( service . db ) < nl > + val sessionId = createSessionId ( ) < nl > val phoneNumber = buildPhone ( ) < nl > val smsHash = getSmsHash ( authId , phoneNumber ) < nl > < nl > - implicit val clientData = api . ClientData ( authId , None ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , None ) < nl > < nl > def e1 = { < nl > service . handleSignUp ( < nl > @ @ - 81 , 9 + 82 , 10 @ @ class AuthServiceSpec extends BaseServiceSpec { < nl > < nl > case class signIn ( ) { < nl > val authId = createAuthId ( ) ( service . db ) < nl > + val sessionId = createSessionId ( ) < nl > val phoneNumber = buildPhone ( ) < nl > < nl > - implicit val clientData = api . ClientData ( authId , None ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , None ) < nl > < nl > def unoccupied = { < nl > val smsHash = getSmsHash ( authId , phoneNumber ) < nl > @ @ - 119 , 9 + 121 , 11 @ @ class AuthServiceSpec extends BaseServiceSpec { < nl > ) must beOkLike { < nl > case rsp : api . auth . ResponseAuth = > < nl > service . db . run ( persist . AuthId . find ( authId ) . head ) must be _ = = ( models . AuthId ( authId , Some ( rsp . user . id ) ) ) . await and < nl > - ( service . db . run ( persist . UserPublicKey . find ( rsp . user . id , authId ) . headOption ) must beSome [ models . UserPublicKey ] . await ) < nl > + ( service . db . run ( persist . UserPublicKey . find ( rsp . user . id , authId ) . headOption ) must beSome [ models . UserPublicKey ] . await ) < nl > } . await < nl > } < nl > } < nl > + < nl > } < nl > + < nl > } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala < nl > index 0950fbe . . f66356c 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala < nl > @ @ - 1 , 6 + 1 , 6 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > - import com . typesafe . config . ConfigFactory < nl > + import akka . stream . ActorFlowMaterializer < nl > import org . specs2 . matcher . ThrownExpectations < nl > import org . specs2 . specification . core . Fragments < nl > < nl > @ @ - 14 , 6 + 14 , 7 @ @ trait BaseServiceSpec < nl > with ServiceSpecHelpers < nl > with HandlerMatchers { < nl > implicit lazy val ( ds , db ) = migrateAndInitDb ( ) < nl > + implicit val flowMaterializer = ActorFlowMaterializer ( ) < nl > < nl > override def map ( fragments : = > Fragments ) = < nl > super . map ( fragments ) ^ step ( closeDb ( ) ) < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > index 89ebfdd . . 34b04a4 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala < nl > @ @ - 1 , 12 + 1 , 12 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > - import scala . concurrent . _ , duration . _ < nl > + import scala . concurrent . _ < nl > + import scala . concurrent . duration . _ < nl > < nl > import slick . dbio . DBIO < nl > < nl > import im . actor . api . { rpc = > api } < nl > import im . actor . server . api . util < nl > - import im . actor . server . persist < nl > import im . actor . server . push . SeqUpdatesManager < nl > < nl > class ContactsServiceSpec extends BaseServiceSpec { < nl > @ @ - 22 , 9 + 22 , 11 @ @ class ContactsServiceSpec extends BaseServiceSpec { < nl > < nl > object s { < nl > val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) < nl > + val rpcApiService = buildRpcApiService ( ) < nl > + val sessionRegion = buildSessionRegion ( rpcApiService ) < nl > < nl > implicit val service = new contacts . ContactsServiceImpl ( seqUpdManagerRegion ) < nl > - implicit val authService = buildAuthService ( ) < nl > + implicit val authService = buildAuthService ( sessionRegion ) < nl > implicit val ec = system . dispatcher < nl > < nl > def addContact ( userId : Int , userAccessSalt : String ) ( implicit clientData : api . ClientData ) = { < nl > @ @ - 33 , 7 + 35 , 8 @ @ class ContactsServiceSpec extends BaseServiceSpec { < nl > < nl > object getcontacts { < nl > val ( user , authId , _ ) = createUser ( ) < nl > - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) < nl > < nl > val userModels = for ( i < - 1 to 3 ) yield { < nl > val user = createUser ( ) . _ 1 . asModel ( ) < nl > @ @ - 60 , 6 + 63 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { < nl > < nl > object addremove { < nl > val authId = createAuthId ( ) < nl > + val sessionId = createSessionId ( ) < nl > val phoneNumber = buildPhone ( ) < nl > val user = createUser ( authId , phoneNumber ) < nl > < nl > @ @ - 67 , 7 + 71 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { < nl > val user2Model = getUserModel ( user2 . id ) < nl > val user2AccessHash = util . ACL . userAccessHash ( authId , user2 . id , user2Model . accessSalt ) < nl > < nl > - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) < nl > < nl > def add ( firstRun : Boolean = true , expectedUpdSeq : Int = 1001 ) = { < nl > service . handleAddContact ( user2 . id , user2AccessHash ) must beOkLike { < nl > @ @ - 96 , 5 + 100 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { < nl > < nl > def addAfterRemove = add ( firstRun = false , expectedUpdSeq = 1004 ) < nl > } < nl > + < nl > } < nl > + < nl > } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala < nl > index 394cf2a . . 8d3522d 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala < nl > @ @ - 1 , 8 + 1 , 7 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > - import scala . concurrent . _ , duration . _ < nl > - < nl > - import slick . driver . PostgresDriver . api . Database < nl > + import scala . concurrent . _ < nl > + import scala . concurrent . duration . _ < nl > < nl > import im . actor . api . { rpc = > api } < nl > import im . actor . server . api . util < nl > @ @ - 15 , 12 + 14 , 15 @ @ class EncryptionServiceSpec extends BaseServiceSpec { < nl > " " " < nl > < nl > object s { < nl > - implicit val service = new encryption . EncryptionServiceImpl < nl > + val rpcApiService = buildRpcApiService ( ) < nl > + val sessionRegion = buildSessionRegion ( rpcApiService ) < nl > < nl > - implicit val authService = buildAuthService ( ) < nl > + implicit val service = new encryption . EncryptionServiceImpl < nl > + implicit val authService = buildAuthService ( sessionRegion ) < nl > implicit val ec = system . dispatcher < nl > < nl > val authId = createAuthId ( ) < nl > + val sessionId = createSessionId ( ) < nl > val phoneNumber = buildPhone ( ) < nl > < nl > val user = createUser ( authId , phoneNumber ) < nl > @ @ - 30 , 7 + 32 , 7 @ @ class EncryptionServiceSpec extends BaseServiceSpec { < nl > < nl > val user2 = createUser ( authId2 , phoneNumber2 ) < nl > < nl > - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) < nl > < nl > def e1 = { < nl > val user2Model = Await . result ( db . run ( persist . User . find ( user2 . id ) . head ) , 1 . second ) < nl > @ @ - 46 , 9 + 48 , 10 @ @ class EncryptionServiceSpec extends BaseServiceSpec { < nl > ) < nl > ) must beOkLike { < nl > case api . encryption . ResponseGetPublicKeys ( Vector ( < nl > - pk @ api . encryption . PublicKey ( user2 . id , user2pk . hash , _ ) < nl > + pk @ api . encryption . PublicKey ( user2 . id , user2pk . hash , _ ) < nl > ) ) if pk . key . sameElements ( user2pk . data ) = > ok < nl > } . await < nl > } < nl > } < nl > + < nl > } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > index 8e49b8e . . ea3ed41 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala < nl > @ @ - 1 , 12 + 1 , 8 @ @ < nl > package im . actor . server . api . rpc . service < nl > < nl > - import scala . concurrent . _ , duration . _ < nl > - < nl > - import slick . dbio . DBIO < nl > - < nl > - import im . actor . api . { rpc = > api } , api . Implicits . _ < nl > + import im . actor . api . rpc . Implicits . _ < nl > + import im . actor . api . { rpc = > api } < nl > import im . actor . server . api . util < nl > - import im . actor . server . persist < nl > import im . actor . server . push . SeqUpdatesManager < nl > < nl > class MessagingServiceSpec extends BaseServiceSpec { < nl > @ @ - 17 , 14 + 13 , 17 @ @ class MessagingServiceSpec extends BaseServiceSpec { < nl > < nl > object s { < nl > val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) < nl > + val rpcApiService = buildRpcApiService ( ) < nl > + val sessionRegion = buildSessionRegion ( rpcApiService ) < nl > < nl > implicit val service = new messaging . MessagingServiceImpl ( seqUpdManagerRegion ) < nl > - implicit val authService = buildAuthService ( ) < nl > + implicit val authService = buildAuthService ( sessionRegion ) < nl > implicit val ec = system . dispatcher < nl > < nl > object privat { < nl > val ( user , authId , _ ) = createUser ( ) < nl > - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) < nl > + val sessionId = createSessionId ( ) < nl > + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) < nl > < nl > val ( user2 , _ , _ ) = createUser ( ) < nl > val user2Model = getUserModel ( user2 . id ) < nl > @ @ - 37 , 5 + 36 , 7 @ @ class MessagingServiceSpec extends BaseServiceSpec { < nl > } . await < nl > } < nl > } < nl > + < nl > } < nl > + < nl > } < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > index 122b23a . . ed30067 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala < nl > @ @ - 2 , 14 + 2 , 17 @ @ package im . actor . server . api . rpc . service < nl > < nl > import scala . concurrent . _ , duration . _ < nl > < nl > - import akka . actor . ActorSystem < nl > + import akka . actor . { ActorRef , ActorSystem } < nl > + import akka . stream . FlowMaterializer < nl > import akka . util . Timeout < nl > import eu . codearte . jfairy . Fairy < nl > import slick . driver . PostgresDriver . api . _ < nl > < nl > import im . actor . api . { rpc = > api } < nl > + import im . actor . server . api . rpc . RpcApiService < nl > import im . actor . server . models < nl > import im . actor . server . persist < nl > + import im . actor . server . session . Session < nl > < nl > trait PersistenceHelpers { < nl > implicit val timeout = Timeout ( 5 . seconds ) < nl > @ @ - 32 , 15 + 35 , 18 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > } < nl > < nl > def createAuthId ( ) ( implicit db : Database ) : Long = { < nl > - val authId = scala . util . Random . nextLong < nl > + val authId = scala . util . Random . nextLong ( ) < nl > < nl > Await . result ( db . run ( persist . AuthId . create ( authId , None ) ) , 1 . second ) < nl > authId < nl > } < nl > < nl > + def createSessionId ( ) : Long = < nl > + scala . util . Random . nextLong ( ) < nl > + < nl > def getSmsHash ( authId : Long , phoneNumber : Long ) ( implicit service : api . auth . AuthService , system : ActorSystem ) : String = withoutLogs { < nl > val api . auth . ResponseSendAuthCode ( smsHash , _ ) = < nl > - Await . result ( service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) ( api . ClientData ( authId , None ) ) , 1 . second ) . toOption . get < nl > + Await . result ( service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) ( api . ClientData ( authId , scala . util . Random . nextLong ( ) , None ) ) , 1 . second ) . toOption . get < nl > smsHash < nl > } < nl > < nl > @ @ - 64 , 12 + 70 , 17 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { < nl > appId = 42 , < nl > appKey = " appKey " , < nl > isSilent = false < nl > - ) ( api . ClientData ( authId , None ) ) , 1 . second ) . toOption . get < nl > + ) ( api . ClientData ( authId , scala . util . Random . nextLong ( ) , None ) ) , 1 . second ) . toOption . get < nl > < nl > rsp . user < nl > } < nl > < nl > - def buildAuthService ( ) ( implicit system : ActorSystem , database : Database ) = new auth . AuthServiceImpl ( ) < nl > + def buildRpcApiService ( ) ( implicit system : ActorSystem , db : Database ) = system . actorOf ( RpcApiService . props ( ) ) < nl > + < nl > + def buildSessionRegion ( rpcApiService : ActorRef ) ( implicit system : ActorSystem , flowMaterializer : FlowMaterializer ) = < nl > + Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) < nl > + < nl > + def buildAuthService ( sessionRegion : ActorRef ) ( implicit system : ActorSystem , database : Database ) = new auth . AuthServiceImpl ( sessionRegion ) < nl > < nl > protected def withoutLogs [ A ] ( f : = > A ) ( implicit system : ActorSystem ) : A = { < nl > val logger = org . slf4j . LoggerFactory . getLogger ( org . slf4j . Logger . ROOT _ LOGGER _ NAME ) . asInstanceOf [ ch . qos . logback . classic . Logger ] < nl > diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > index 26199a4 . . 39fd86a 100644 < nl > - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala < nl > @ @ - 1 , 45 + 1 , 56 @ @ < nl > package im . actor . server . session < nl > < nl > + import scala . concurrent . duration . _ < nl > + import scala . util . Random < nl > + < nl > import akka . actor . _ < nl > import akka . stream . ActorFlowMaterializer < nl > import akka . testkit . TestProbe < nl > - import org . specs2 . Specification < nl > + import org . specs2 . matcher . ThrownExpectations < nl > + import scodec . bits . _ < nl > < nl > - import im . actor . api . rpc . { RpcResult , RpcOk , Request } < nl > - import im . actor . api . rpc . auth . { ResponseSendAuthCode , RequestSendAuthCode } < nl > + import im . actor . api . rpc . auth . { ResponseAuth , RequestSignUp , RequestSignOut , RequestSendAuthCode , ResponseSendAuthCode } < nl > import im . actor . api . rpc . codecs . _ < nl > - import im . actor . server . api . rpc . { RpcResultCodec , RpcOkCodec } < nl > + import im . actor . api . rpc . misc . ResponseVoid < nl > + import im . actor . api . rpc . { Request , RpcOk , RpcResult } < nl > + import im . actor . server . SqlSpecHelpers < nl > + import im . actor . server . api . rpc . service . auth . AuthServiceImpl < nl > + import im . actor . server . api . rpc . { RpcApiService , RpcResultCodec } < nl > import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec < nl > import im . actor . server . mtproto . protocol . _ < nl > import im . actor . server . mtproto . transport . _ < nl > import im . actor . util . testing . _ < nl > < nl > - import scala . concurrent . duration . _ < nl > - import scala . util . Random < nl > - < nl > - import scodec . bits . _ < nl > - < nl > - import im . actor . server . SqlSpecHelpers < nl > - < nl > - class SessionSpec extends ActorSpecification with SqlSpecHelpers { < nl > + class SessionSpec extends ActorSpecification with SqlSpecHelpers with ThrownExpectations { < nl > def is = sequential ^ s2 " " " < nl > Session Actor should < nl > send Drop on message on wrong message box $ { sessions ( ) . e1 } < nl > send NewSession on first HandleMessageBox $ { sessions ( ) . e2 } < nl > reply to RpcRequestBox $ { sessions ( ) . e3 } < nl > + handle user authorization $ { sessions ( ) . e4 } < nl > " " " < nl > < nl > case class sessions ( ) { < nl > - import Session . _ < nl > + < nl > + import SessionMessage . _ < nl > + < nl > implicit val materializer = ActorFlowMaterializer ( ) < nl > implicit val ( ds , db ) = migrateAndInitDb ( ) < nl > < nl > val authId = Random . nextLong ( ) < nl > - val sessionId = Random . nextLong ( ) < nl > - val session = system . actorOf ( Session . props ( ) , s " Session - $ authId - $ sessionId " ) < nl > + < nl > + val rpcApiService = system . actorOf ( RpcApiService . props ( ) ) < nl > + val sessionRegion = Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) < nl > + < nl > + val authService = new AuthServiceImpl ( sessionRegion ) < nl > + rpcApiService ! RpcApiService . AttachService ( authService ) < nl > + < nl > val probe = TestProbe ( ) < nl > < nl > def e1 ( ) = { < nl > + val sessionId = Random . nextLong ( ) < nl > + val session = system . actorOf ( Session . props ( rpcApiService ) ) < nl > + < nl > sendEnvelope ( authId , sessionId , session , HandleMessageBox ( BitVector . empty . toByteArray ) ) < nl > < nl > probe watch session < nl > @ @ - 49 , 20 + 60 , 22 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { < nl > } < nl > < nl > def e2 ( ) = { < nl > + val sessionId = Random . nextLong ( ) < nl > val messageId = Random . nextLong ( ) < nl > < nl > val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require < nl > - sendMessageBox ( authId , sessionId , session , messageId , RpcRequestBox ( encodedRequest ) ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion , messageId , RpcRequestBox ( encodedRequest ) ) < nl > < nl > expectNewSession ( authId , sessionId , messageId ) < nl > probe . receiveOne ( 1 . second ) < nl > } < nl > < nl > def e3 ( ) = { < nl > + val sessionId = Random . nextLong ( ) < nl > val messageId = Random . nextLong ( ) < nl > < nl > val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require < nl > - sendMessageBox ( authId , sessionId , session , messageId , RpcRequestBox ( encodedRequest ) ) < nl > + sendMessageBox ( authId , sessionId , sessionRegion , messageId , RpcRequestBox ( encodedRequest ) ) < nl > < nl > expectNewSession ( authId , sessionId , messageId ) < nl > receiveRpcResult ( ) must beLike { < nl > @ @ - 70 , 6 + 83 , 45 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { < nl > } < nl > } < nl > < nl > + def e4 ( ) = { < nl > + val sessionId = Random . nextLong ( ) < nl > + < nl > + val firstMessageId = Random . nextLong ( ) < nl > + val phoneNumber = 75550000000L < nl > + < nl > + val encodedCodeRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require < nl > + sendMessageBox ( authId , sessionId , sessionRegion , firstMessageId , RpcRequestBox ( encodedCodeRequest ) ) < nl > + < nl > + expectNewSession ( authId , sessionId , firstMessageId ) < nl > + < nl > + val smsHash = receiveRpcResult ( ) . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash < nl > + < nl > + val encodedSignUpRequest = RequestCodec . encode ( Request ( RequestSignUp ( < nl > + phoneNumber = phoneNumber , < nl > + smsHash = smsHash , < nl > + smsCode = " 0000 " , < nl > + name = " Wayne Brain " , < nl > + publicKey = Array ( 1 , 2 , 3 ) , < nl > + deviceHash = Array ( 4 , 5 , 6 ) , < nl > + deviceTitle = " Specs virtual device " , < nl > + appId = 1 , < nl > + appKey = " appKey " , < nl > + isSilent = false < nl > + ) ) ) . require < nl > + sendMessageBox ( authId , sessionId , sessionRegion , Random . nextLong ( ) , RpcRequestBox ( encodedSignUpRequest ) ) < nl > + < nl > + receiveRpcResult ( ) must beLike { < nl > + case RpcOk ( ResponseAuth ( _ , _ , _ ) ) = > ok < nl > + } < nl > + < nl > + val encodedSignOutRequest = RequestCodec . encode ( Request ( RequestSignOut ) ) . require < nl > + sendMessageBox ( authId , sessionId , sessionRegion , Random . nextLong ( ) , RpcRequestBox ( encodedSignOutRequest ) ) < nl > + < nl > + receiveRpcResult ( ) must beLike { < nl > + case RpcOk ( ResponseVoid ) = > ok < nl > + } < nl > + } < nl > + < nl > private def receiveRpcResult ( ) : RpcResult = { < nl > Option ( probe . receiveOne ( 1 . second ) ) match { < nl > case Some ( MTPackage ( authId , sessionId , mbBytes ) ) = > < nl > @ @ - 109 , 4 + 161 , 5 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { < nl > } < nl > < nl > } < nl > + < nl > } < nl > diff - - git a / project / Build . scala b / project / Build . scala < nl > index 9fa0dc9 . . 5c5ad64 100644 < nl > - - - a / project / Build . scala < nl > + + + b / project / Build . scala < nl > @ @ - 84 , 6 + 84 , 12 @ @ object Build extends sbt . Build { < nl > ) < nl > ) . dependsOn ( actorPersist , actorFrontend , actorCodecs , actorApi , actorRpcApi ) < nl > < nl > + lazy val actorSessionMessages = Project ( < nl > + id = " actor - session - messages " , < nl > + base = file ( " actor - session - messages " ) , < nl > + settings = defaultSettings < nl > + ) . dependsOn ( actorApi ) < nl > + < nl > lazy val actorPush = Project ( < nl > id = " actor - push " , < nl > base = file ( " actor - push " ) , < nl > @ @ - 109 , 7 + 115 , 7 @ @ object Build extends sbt . Build { < nl > settings = defaultSettings + + Seq ( < nl > libraryDependencies + + = Dependencies . rpcApi < nl > ) < nl > - ) . dependsOn ( actorApi , actorCodecs , actorPersist , actorPush ) < nl > + ) . dependsOn ( actorApi , actorCodecs , actorPersist , actorPush , actorSessionMessages ) < nl > < nl > lazy val actorFrontend = Project ( < nl > id = " actor - frontend " ,

TEST DIFF:
diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala 
 index b5d186c . . 100b50b 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / ArrayStyleRawApiService . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw 
 import akka . actor . ActorSystem 
 import cats . data . Xor 
 import im . actor . api . rpc . collections . _ 
 - import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 + import im . actor . api . rpc . { ClientData , RpcError } 
 
 import scala . concurrent . Future 
 
 @ @ - 27 , 7 + 27 , 7 @ @ abstract class ArrayStyleRawApiService ( system : ActorSystem ) extends RawApiServic 
 
 protected def validateRequests : Option [ ApiRawValue ] ⇒ PartialFunction [ String , RpcError Xor Request ] 
 
 - protected def processRequests : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 + protected def processRequests : ClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 
 / * * 
 * Parse content of ` optParams ` to type T , 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala 
 index cd5edd6 . . f35e64c 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / MapStyleRawApiService . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw 
 import akka . actor . ActorSystem 
 import cats . data . Xor 
 import im . actor . api . rpc . collections . _ 
 - import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 + import im . actor . api . rpc . { ClientData , RpcError } 
 import play . api . libs . json . _ 
 
 import scala . concurrent . Future 
 @ @ - 63 , 7 + 63 , 7 @ @ abstract class MapStyleRawApiService ( system : ActorSystem ) extends RawApiService ( 
 
 protected def validateRequest : Option [ JsObject ] ⇒ PartialFunction [ String , RpcError Xor Request ] 
 
 - protected def handleInternal : AuthorizedClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 + protected def handleInternal : ClientData ⇒ PartialFunction [ Request , Future [ Response ] ] 
 
 private def toRequest ( name : String , optParams : Option [ ApiRawValue ] ) : RpcError Xor Request = { 
 val jsParams = optParams map { params ⇒ 
 diff - - git a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 index 6b75303 . . 2a9c0dd 100644 
 - - - a / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 + + + b / actor - server / actor - core / src / main / scala / im / actor / api / rpc / raw / RawApiService . scala 
 @ @ - 3 , 7 + 3 , 7 @ @ package im . actor . api . rpc . raw 
 import akka . actor . ActorSystem 
 import cats . data . Xor 
 import im . actor . api . rpc . collections . ApiRawValue 
 - import im . actor . api . rpc . { AuthorizedClientData , RpcError } 
 + import im . actor . api . rpc . { ClientData , RpcError } 
 
 import scala . concurrent . Future 
 
 @ @ - 18 , 7 + 18 , 7 @ @ abstract class RawApiService ( system : ActorSystem ) { 
 
 type Response = RpcError Xor ApiRawValue 
 
 - type Handler = AuthorizedClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] 
 + type Handler = ClientData ⇒ Option [ ApiRawValue ] ⇒ PartialFunction [ String , Future [ Response ] ] 
 
 def handleRequests : Handler 
 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 index f395dd6 . . 959aaa7 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RawApiExtension . scala 
 @ @ - 5 , 7 + 5 , 7 @ @ import cats . data . Xor 
 import im . actor . api . rpc . collections . ApiRawValue 
 import im . actor . api . rpc . FutureResultRpc 
 import im . actor . api . rpc . raw . RawApiService 
 - import im . actor . api . rpc . { AuthorizedClientData , CommonRpcErrors , RpcError } 
 + import im . actor . api . rpc . { AuthorizedClientData , ClientData , CommonRpcErrors , RpcError } 
 
 import scala . collection . concurrent . TrieMap 
 import scala . concurrent . Future 
 @ @ - 27 , 10 + 27 , 10 @ @ private [ rpc ] final class RawApiExtensionImpl ( system : ExtendedActorSystem ) extend 
 
 def register ( serviceSeq : Seq [ ( String , RawApiService ) ] ) : Unit = services + + = serviceSeq 
 
 - def handle ( service : String , method : String , params : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ RpcError Xor ApiRawValue ] = 
 + def handle ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ RpcError Xor ApiRawValue ] = 
 ( for { 
 serviceHandler ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( services . get ( service ) ) 
 - response ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( client ) ( params ) . lift ( method ) ) 
 + response ← fromOption ( CommonRpcErrors . UnsupportedRequest ) ( serviceHandler . handleRequests ( clientData ) ( params ) . lift ( method ) ) 
 result ← fromFutureXor ( response ) 
 } yield result ) . value 
 } 
 diff - - git a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 index 414cdf9 . . aacc408 100644 
 - - - a / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 + + + b / actor - server / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / raw / RawServiceImpl . scala 
 @ @ - 17 , 8 + 17 , 6 @ @ final class RawServiceImpl ( implicit system : ActorSystem ) extends RawService { 
 private val rawApiExt = RawApiExtension ( system ) 
 
 override def doHandleRawRequest ( service : String , method : String , params : Option [ ApiRawValue ] , clientData : ClientData ) : Future [ HandlerResult [ ResponseRawRequest ] ] = 
 - authorized ( clientData ) { implicit client ⇒ 
 - ( for ( result ← fromFutureXor ( rawApiExt . handle ( service , method , params ) ) ) 
 - yield ResponseRawRequest ( result ) ) . value 
 - } 
 + ( for ( result ← fromFutureXor ( rawApiExt . handle ( service , method , params , clientData ) ) ) 
 + yield ResponseRawRequest ( result ) ) . value 
 } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - session / src / main / resources / reference . conf b / actor - server / actor - session / src / main / resources / reference . conf 
 index 3f8a726 . . 8a335a9 100644 
 - - - a / actor - server / actor - session / src / main / resources / reference . conf 
 + + + b / actor - server / actor - session / src / main / resources / reference . conf 
 @ @ - 9 , 7 + 9 , 8 @ @ session { 
 } 
 
 rpc { 
 + max - cached - result - size : 20 KiB 
 ack - delay : 15 seconds 
 - max - cache - size : 10 
 + max - cached - results : 10 
 } 
 } 
 diff - - git a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 index f52dcc4 . . 1d36cb3 100644 
 - - - a / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 + + + b / actor - server / actor - session / src / main / scala / im / actor / server / session / RpcHandler . scala 
 @ @ - 3 , 7 + 3 , 8 @ @ package im . actor . server . session 
 import akka . actor . _ 
 import akka . pattern . pipe 
 import akka . stream . actor . _ 
 - import im . actor . api . rpc . { RpcInternalError , RpcResult } 
 + import com . github . kxbmap . configs . Bytes 
 + import im . actor . api . rpc . { RpcError , RpcInternalError , RpcOk , RpcResult } 
 import im . actor . server . api . rpc . RpcApiService . RpcResponse 
 import im . actor . server . api . rpc . { RpcApiExtension , RpcApiService } 
 import im . actor . util . cache . CacheHelpers . _ 
 @ @ - 28 , 7 + 29 , 7 @ @ private [ session ] object RpcHandler { 
 type AckOrResult = Either [ Long , RpcResult ] 
 } 
 
 - private [ session ] case class RpcConfig ( maxCacheSize : Long , ackDelay : FiniteDuration ) 
 + private [ session ] case class RpcConfig ( maxCachedResults : Long , maxCachedResultSize : Bytes , ackDelay : FiniteDuration ) 
 
 private [ session ] object RequestHandler { 
 private [ session ] def props ( promise : Promise [ RpcApiService . RpcResponse ] , service : ActorRef , request : RpcApiService . HandleRpcRequest ) = 
 @ @ - 86 , 7 + 87 , 9 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit 
 private [ this ] var requestQueue = Map . empty [ Long , Cancellable ] 
 
 private [ this ] var protoMessageQueue = immutable . Queue . empty [ ( Option [ RpcResult ] , Long ) ] 
 - private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCacheSize ) 
 + 
 + / / FIXME : invalidate on incoming ack 
 + private [ this ] val responseCache = createCache [ java . lang . Long , Future [ RpcApiService . RpcResponse ] ] ( config . maxCachedResults ) 
 
 def subscriber : Receive = { 
 case OnNext ( HandleRpcRequest ( messageId , requestBytes , clientData ) ) ⇒ 
 @ @ - 129 , 6 + 132 , 9 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit 
 case RpcApiService . RpcResponse ( messageId , result ) ⇒ 
 log . debug ( " Received RpcResponse for messageId : { } , publishing " , messageId ) 
 
 + if ( ! canCache ( result ) ) 
 + responseCache . invalidate ( messageId ) 
 + 
 requestQueue . get ( messageId ) foreach ( _ . cancel ( ) ) 
 requestQueue - = messageId 
 enqueue ( Some ( result ) , messageId ) 
 @ @ - 140 , 6 + 146 , 16 @ @ private [ session ] class RpcHandler ( config : RpcConfig ) extends ActorSubscriber wit 
 case Cancel ⇒ context . stop ( self ) 
 } 
 
 + private def canCache ( result : RpcResult ) : Boolean = { 
 + val size = result match { 
 + case RpcOk ( res ) ⇒ res . getSerializedSize 
 + case err : RpcError ⇒ err . data . map ( _ . getSerializedSize ) . getOrElse ( 0 ) + err . userMessage . length 
 + case _ ⇒ 0 
 + } 
 + 
 + size > config . maxCachedResultSize . value 
 + } 
 + 
 private def enqueueAck ( requestMessageId : Long ) : Unit = enqueue ( None , requestMessageId ) 
 
 private def enqueue ( res : Option [ RpcResult ] , requestMessageId : Long ) : Unit = { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 index d5ac284 . . 6f0dca5 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / api / rpc / service / raw / RawServiceSpec . scala 
 @ @ - 175 , 169 + 175 , 172 @ @ class RawServiceSpec 
 } 
 
 } 
 + } 
 
 - / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service 
 - 
 - private object DictionaryMeanings { 
 - val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " 
 - val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " 
 - val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " 
 - } 
 - 
 - / * * 
 - * Example raw api service that stores and retrieves words from dictionary . 
 - * / 
 - private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { 
 - import DictionaryMeanings . _ 
 - import ServiceErrors . _ 
 - import im . actor . api . rpc . FutureResultRpc . _ 
 - 
 - private val kv = TrieMap . empty [ String , String ] 
 - 
 - kv . put ( " culture " , Culture ) 
 - kv . put ( " science " , Science ) 
 - kv . put ( " software " , Software ) 
 + private object ServiceErrors { 
 + val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) 
 + } 
 
 - override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 - case " getWord " ⇒ getWord ( params ) 
 - / / case " putWord " = > putWord ( ) 
 - } 
 + class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { 
 + import ServiceErrors . _ 
 
 - def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 - val ps = optParams flatMap { 
 - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } 
 - case _ ⇒ None 
 - } 
 - ( for { 
 - key ← fromOption ( InvalidParams ) ( ps ) 
 - optValue ← point ( kv . get ( key ) ) 
 - result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 - } yield ApiMapValue ( result ) ) . value 
 - } 
 + override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 + case " makeEcho " ⇒ echo ( params ) 
 } 
 
 - / * * 
 - * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments 
 - * / 
 - private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { 
 - import DictionaryMeanings . _ 
 - import ServiceErrors . _ 
 - import im . actor . api . rpc . FutureResultRpc . _ 
 - 
 - sealed trait DictionaryRequest 
 - case class GetWord ( word : String ) extends DictionaryRequest 
 - case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 - 
 - implicit val getWordReads = Json . reads [ GetWord ] 
 - implicit val putWordReads = Json . reads [ PutWord ] 
 - 
 - private val kv = TrieMap . empty [ String , String ] 
 - 
 - kv . put ( " culture " , Culture ) 
 - kv . put ( " science " , Science ) 
 - kv . put ( " software " , Software ) 
 - 
 - override type Request = DictionaryRequest 
 - 
 - override protected def validateRequest = optParams ⇒ { 
 - case " getWord " ⇒ 
 - for { 
 - params ← Xor . fromOption ( optParams , InvalidParams ) 
 - result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 - } yield result 
 - case " putWord " ⇒ 
 - for { 
 - params ← Xor . fromOption ( optParams , InvalidParams ) 
 - result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 - } yield result 
 - } 
 + def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { 
 + onEcho ( ) 
 + val resp = extractStringFromMap ( params , " query " ) map { q ⇒ 
 + Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) 
 + } getOrElse Xor . left ( InvalidParams ) 
 + Future . successful ( resp ) 
 + } 
 
 - override protected def handleInternal = implicit client ⇒ { 
 - case GetWord ( word ) ⇒ getWord ( word ) 
 - case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 + private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = 
 + optParams flatMap { 
 + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } 
 + case _ ⇒ None 
 } 
 
 - def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 - ( for { 
 - optValue ← point ( kv . get ( word ) ) 
 - result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 - } yield ApiMapValue ( result ) ) . value 
 - } 
 + def onEcho ( ) : Unit = { } 
 + } 
 
 - def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 - ( for { 
 - _ ← point ( kv . put ( word , meaning ) ) 
 - } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value 
 - } 
 - } 
 + / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Dictionary service 
 
 - / * * 
 - * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments 
 - * / 
 - private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { 
 - import DictionaryMeanings . _ 
 - import im . actor . api . rpc . FutureResultRpc . _ 
 + private object DictionaryMeanings { 
 + val Culture = " Anthropology . the sum total of ways of living built up by a group of human beings and transmitted from one generation to another . " 
 + val Science = " Knowledge , as of facts or principles ; knowledge gained by systematic study . " 
 + val Software = " Computers . the programs used to direct the operation of a computer , as well as documentation giving instructions on how to use them . " 
 + } 
 
 - sealed trait DictionaryRequest 
 - case class GetWord ( word : String ) extends DictionaryRequest 
 - case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . 
 + * / 
 + private final class DictionaryService ( system : ActorSystem ) extends RawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import ServiceErrors . _ 
 + import im . actor . api . rpc . FutureResultRpc . _ 
 + import system . dispatcher 
 
 - private val kv = TrieMap . empty [ String , String ] 
 + private val kv = TrieMap . empty [ String , String ] 
 
 - kv . put ( " culture " , Culture ) 
 - kv . put ( " science " , Science ) 
 - kv . put ( " software " , Software ) 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 
 - override type Request = DictionaryRequest 
 + override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 + case " getWord " ⇒ getWord ( params ) 
 + / / case " putWord " = > putWord ( ) 
 + } 
 
 - override protected def validateRequests = optParams ⇒ { 
 - case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord 
 - case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) 
 + def getWord ( optParams : Option [ ApiRawValue ] ) ( implicit client : ClientData ) : Future [ Response ] = { 
 + val ps = optParams flatMap { 
 + case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( " word " , ApiStringValue ( str ) ) ⇒ str } 
 + case _ ⇒ None 
 } 
 + ( for { 
 + key ← fromOption ( InvalidParams ) ( ps ) 
 + optValue ← point ( kv . get ( key ) ) 
 + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 + } yield ApiMapValue ( result ) ) . value 
 + } 
 + } 
 
 - override protected def processRequests = implicit client ⇒ { 
 - case GetWord ( word ) ⇒ getWord ( word ) 
 - case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 - } 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . Implemented with MapStyle arguments 
 + * / 
 + private final class MapStyleDictionaryService ( system : ActorSystem ) extends MapStyleRawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import ServiceErrors . _ 
 + import im . actor . api . rpc . FutureResultRpc . _ 
 + import system . dispatcher 
 + 
 + sealed trait DictionaryRequest 
 + case class GetWord ( word : String ) extends DictionaryRequest 
 + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 + 
 + implicit val getWordReads = Json . reads [ GetWord ] 
 + implicit val putWordReads = Json . reads [ PutWord ] 
 + 
 + private val kv = TrieMap . empty [ String , String ] 
 + 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 + 
 + override type Request = DictionaryRequest 
 + 
 + override protected def validateRequest = optParams ⇒ { 
 + case " getWord " ⇒ 
 + for { 
 + params ← Xor . fromOption ( optParams , InvalidParams ) 
 + result ← Xor . fromEither ( params . validate [ GetWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 + } yield result 
 + case " putWord " ⇒ 
 + for { 
 + params ← Xor . fromOption ( optParams , InvalidParams ) 
 + result ← Xor . fromEither ( params . validate [ PutWord ] . asEither ) leftMap ( _ ⇒ InvalidParams ) 
 + } yield result 
 + } 
 
 - def getWord ( word : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 - ( for { 
 - optValue ← point ( kv . get ( word ) ) 
 - encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty 
 - } yield ApiArrayValue ( encodedArr ) ) . value 
 - } 
 + override protected def handleInternal = implicit client ⇒ { 
 + case GetWord ( word ) ⇒ getWord ( word ) 
 + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 + } 
 
 - def putWord ( word : String , meaning : String ) ( implicit client : AuthorizedClientData ) : Future [ Response ] = { 
 - kv . put ( word , meaning ) 
 - Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) 
 - } 
 + def getWord ( word : String ) ( implicit client : ClientData ) : Future [ Response ] = { 
 + ( for { 
 + optValue ← point ( kv . get ( word ) ) 
 + result = optValue map { e ⇒ Vector ( ApiMapValueItem ( " meaning " , ApiStringValue ( e ) ) ) } getOrElse Vector . empty 
 + } yield ApiMapValue ( result ) ) . value 
 } 
 
 - / / = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = Echo service 
 + def putWord ( word : String , meaning : String ) ( implicit client : ClientData ) : Future [ Response ] = { 
 + ( for { 
 + _ ← point ( kv . put ( word , meaning ) ) 
 + } yield ApiMapValue ( Vector ( ApiMapValueItem ( " result " , ApiStringValue ( " true " ) ) ) ) ) . value 
 + } 
 + } 
 
 - private final class EchoService ( val system : ActorSystem ) extends RawApiService ( system ) { 
 - import ServiceErrors . _ 
 + / * * 
 + * Example raw api service that stores and retrieves words from dictionary . Implemented with Array - style arguments 
 + * / 
 + private final class ArrayStyleDictionaryService ( system : ActorSystem ) extends ArrayStyleRawApiService ( system ) { 
 + import DictionaryMeanings . _ 
 + import im . actor . api . rpc . FutureResultRpc . _ 
 + import system . dispatcher 
 
 - override def handleRequests : Handler = implicit client ⇒ params ⇒ { 
 - case " makeEcho " ⇒ echo ( params ) 
 - } 
 + sealed trait DictionaryRequest 
 + case class GetWord ( word : String ) extends DictionaryRequest 
 + case class PutWord ( word : String , meaning : String ) extends DictionaryRequest 
 
 - def echo ( params : Option [ ApiRawValue ] ) : Future [ Response ] = { 
 - val resp = extractStringFromMap ( params , " query " ) map { q ⇒ 
 - Xor . right ( ApiMapValue ( Vector ( ApiMapValueItem ( " echo " , ApiStringValue ( s " $ q you back ! " ) ) ) ) ) 
 - } getOrElse Xor . left ( InvalidParams ) 
 - Future . successful ( resp ) 
 - } 
 + private val kv = TrieMap . empty [ String , String ] 
 + 
 + kv . put ( " culture " , Culture ) 
 + kv . put ( " science " , Science ) 
 + kv . put ( " software " , Software ) 
 + 
 + override type Request = DictionaryRequest 
 + 
 + override protected def validateRequests = optParams ⇒ { 
 + case " getWord " ⇒ parseParams [ String ] ( optParams ) map GetWord 
 + case " putWord " ⇒ parseParams [ PutWord ] ( optParams ) 
 } 
 
 - private def extractStringFromMap ( optParams : Option [ ApiRawValue ] , key : String ) : Option [ String ] = 
 - optParams flatMap { 
 - case ApiMapValue ( items ) ⇒ items collectFirst { case ApiMapValueItem ( _ , ApiStringValue ( str ) ) ⇒ str } 
 - case _ ⇒ None 
 - } 
 + override protected def processRequests = implicit client ⇒ { 
 + case GetWord ( word ) ⇒ getWord ( word ) 
 + case PutWord ( word , meaning ) ⇒ putWord ( word , meaning ) 
 + } 
 
 - private object ServiceErrors { 
 - val InvalidParams = RpcError ( 400 , " INVALID _ PARAMS " , " " , canTryAgain = true , None ) 
 + def getWord ( word : String ) ( implicit client : ClientData ) : Future [ Response ] = { 
 + ( for { 
 + optValue ← point ( kv . get ( word ) ) 
 + encodedArr = optValue map { e ⇒ Vector ( ApiStringValue ( e ) ) } getOrElse Vector . empty 
 + } yield ApiArrayValue ( encodedArr ) ) . value 
 } 
 
 - } 
 + def putWord ( word : String , meaning : String ) ( implicit client : ClientData ) : Future [ Response ] = { 
 + kv . put ( word , meaning ) 
 + Future . successful ( Xor . right ( ApiStringValue ( " true " ) ) ) 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 index 83c5071 . . 5fc185e 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / BaseSessionSpec . scala 
 @ @ - 7 , 6 + 7 , 7 @ @ import im . actor . server . api . rpc . RpcApiExtension 
 import im . actor . server . api . rpc . service . auth . AuthServiceImpl 
 import im . actor . server . api . rpc . service . contacts . ContactsServiceImpl 
 import im . actor . server . api . rpc . service . messaging . MessagingServiceImpl 
 + import im . actor . server . api . rpc . service . raw . RawServiceImpl 
 import im . actor . server . api . rpc . service . sequence . { SequenceServiceConfig , SequenceServiceImpl } 
 import im . actor . server . db . DbExtension 
 import im . actor . server . oauth . { GoogleProvider , OAuth2GoogleConfig } 
 @ @ - 48 , 16 + 49 , 17 @ @ abstract class BaseSessionSpec ( _ system : ActorSystem = { 
 
 implicit val sessionRegion = Session . startRegionProxy ( ) 
 
 - protected val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) 
 + protected lazy val oauthGoogleConfig = OAuth2GoogleConfig . load ( system . settings . config . getConfig ( " services . google . oauth " ) ) 
 protected implicit val oauth2Service = new GoogleProvider ( oauthGoogleConfig ) 
 protected implicit val authService = new AuthServiceImpl 
 - protected val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get 
 + protected lazy val sequenceConfig = SequenceServiceConfig . load ( ) . toOption . get 
 protected lazy val sequenceService = new SequenceServiceImpl ( sequenceConfig ) 
 protected lazy val messagingService = MessagingServiceImpl ( ) 
 protected lazy val contactsService = new ContactsServiceImpl ( ) 
 + protected lazy val rawService = new RawServiceImpl ( ) 
 
 override def beforeAll = { 
 - RpcApiExtension ( system ) . register ( Seq ( authService , sequenceService , messagingService , contactsService ) ) 
 + RpcApiExtension ( system ) . register ( Seq ( authService , sequenceService , messagingService , contactsService , rawService ) ) 
 } 
 
 protected def createAuthId ( ) : Long = { 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 index 64352df . . cc58a3c 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionResendSpec . scala 
 @ @ - 3 , 14 + 3 , 16 @ @ package im . actor . server . session 
 import akka . testkit . TestProbe 
 import com . typesafe . config . ConfigFactory 
 import im . actor . api . rpc . _ 
 - import im . actor . api . rpc . auth . { ResponseStartPhoneAuth , RequestStartPhoneAuth } 
 + import im . actor . api . rpc . auth . { RequestStartPhoneAuth , ResponseStartPhoneAuth } 
 import im . actor . api . rpc . codecs . RequestCodec 
 - import im . actor . api . rpc . contacts . { UpdateContactsAdded , UpdateContactRegistered } 
 + import im . actor . api . rpc . contacts . { UpdateContactRegistered , UpdateContactsAdded } 
 import im . actor . api . rpc . misc . ResponseSeq 
 + import im . actor . api . rpc . raw . RequestRawRequest 
 import im . actor . api . rpc . sequence . RequestGetState 
 import im . actor . api . rpc . weak . { UpdateUserOffline , UpdateUserOnline } 
 - import im . actor . concurrent . FutureExt 
 import im . actor . server . ActorSpecification 
 + import im . actor . server . api . rpc . RawApiExtension 
 + import im . actor . server . api . rpc . service . raw . EchoService 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . sequence . { SeqUpdatesExtension , WeakUpdatesExtension } 
 
 @ @ - 36 , 7 + 38 , 7 @ @ final class SessionResendSpec extends BaseSessionSpec ( 
 it should " resend updates if no ack received within ack - timeout " in Sessions ( ) . resendUpdates 
 it should " not resend messages when another came with the same reduceKey ( weak ) " in Sessions ( ) . reduceKeyWeak 
 it should " not resend messages when another came with the same reduceKey ( seq ) " in Sessions ( ) . reduceKeySeq 
 - it should " schedule one resend after subsequent requests with the same messageId " in Sessions ( ) . eee 
 + it should " schedule one resend after subsequent requests with the same messageId " in Sessions ( ) . oneResendForCached 
 
 case class Sessions ( ) { 
 val weakUpdatesExt = WeakUpdatesExtension ( system ) 
 @ @ - 304 , 7 + 306 , 7 @ @ final class SessionResendSpec extends BaseSessionSpec ( 
 expectContactsAdded ( authId , sessionId , 4 ) 
 } 
 
 - def eee ( ) : Unit = { 
 + def oneResendForCached ( ) : Unit = { 
 implicit val probe = TestProbe ( ) 
 
 val authId = createAuthId ( ) 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 2abd8e7 . . c7151f5 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 4 , 27 + 4 , 32 @ @ import akka . testkit . TestProbe 
 import com . google . protobuf . ByteString 
 import im . actor . api . rpc . auth . _ 
 import im . actor . api . rpc . codecs . _ 
 + import im . actor . api . rpc . collections . ApiStringValue 
 import im . actor . api . rpc . contacts . { RequestGetContacts , UpdateContactRegistered } 
 import im . actor . api . rpc . messaging . RequestLoadDialogs 
 import im . actor . api . rpc . misc . ResponseVoid 
 import im . actor . api . rpc . peers . ApiUserOutPeer 
 import im . actor . api . rpc . sequence . { RequestGetDifference , RequestGetState , RequestSubscribeToOnline , UpdateRawUpdate } 
 import im . actor . api . rpc . misc . ResponseSeq 
 + import im . actor . api . rpc . raw . RequestRawRequest 
 import im . actor . api . rpc . weak . UpdateUserOffline 
 import im . actor . api . rpc . { AuthorizedClientData , Request , RpcOk } 
 + import im . actor . server . api . rpc . RawApiExtension 
 import im . actor . server . api . rpc . service . auth . AuthErrors 
 + import im . actor . server . api . rpc . service . raw . EchoService 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . _ 
 import im . actor . server . persist . AuthSessionRepo 
 import im . actor . server . sequence . { SeqUpdatesExtension , UserSequence , WeakUpdatesExtension } 
 import im . actor . server . user . UserExtension 
 + import org . scalatest . BeforeAndAfterEach 
 import scodec . bits . _ 
 
 import scala . concurrent . Await 
 import scala . concurrent . duration . _ 
 import scala . util . Random 
 
 - final class SessionSpec extends BaseSessionSpec { 
 + final class SessionSpec extends BaseSessionSpec with BeforeAndAfterEach { 
 behavior of " Session actor " 
 
 it should " send Drop on message on wrong message box " in sessions ( ) . wrongMessageBox 
 @ @ - 37 , 6 + 42 , 14 @ @ final class SessionSpec extends BaseSessionSpec { 
 it should " receive fat updates " in sessions ( ) . fatSeq 
 it should " react to SessionHello " in sessions ( ) . hello 
 it should " send SeqUpdateTooLong " in sessions ( ) . seqUpdateTooLong 
 + it should " cache small results " in sessions ( ) . cacheSmallResults 
 + it should " not cache big requests " in sessions ( ) . notCacheBigRequests 
 + 
 + var count = 0 
 + 
 + override def beforeEach = { 
 + RawApiExtension ( system ) . register ( " echo " , new EchoService ( system ) { override def onEcho ( ) = count + = 1 } ) 
 + } 
 
 case class sessions ( ) { 
 
 @ @ - 371 , 5 + 384 , 65 @ @ final class SessionSpec extends BaseSessionSpec { 
 expectMessageAck ( messageId ) 
 probe . expectNoMsg ( ) 
 } 
 + 
 + def cacheSmallResults ( ) : Unit = { 
 + implicit val probe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + 
 + val helloMessageId = Random . nextLong ( ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , helloMessageId , SessionHello ) 
 + expectNewSession ( authId , sessionId , helloMessageId ) 
 + expectMessageAck ( ) 
 + 
 + val messageId = Random . nextLong ( ) 
 + count = 0 
 + 
 + for ( _ ← 1 to 3 ) 
 + sendRequest ( 
 + authId , 
 + sessionId , 
 + sessionRegion . ref , 
 + messageId , 
 + RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( " . . . " ) ) ) 
 + ) 
 + 
 + for ( _ ← 1 to 3 ) 
 + expectRpcResult ( authId , sessionId , ignoreAcks = true ) 
 + 
 + count shouldBe 1 
 + } 
 + 
 + def notCacheBigRequests ( ) : Unit = { 
 + implicit val probe = TestProbe ( ) 
 + 
 + val authId = createAuthId ( ) 
 + val sessionId = Random . nextLong ( ) 
 + 
 + val helloMessageId = Random . nextLong ( ) 
 + sendMessageBox ( authId , sessionId , sessionRegion . ref , helloMessageId , SessionHello ) 
 + expectNewSession ( authId , sessionId , helloMessageId ) 
 + expectMessageAck ( ) 
 + 
 + val longString = List . range ( 1 , 40000 ) . map ( _ ⇒ " . " ) . mkString 
 + 
 + val messageId = Random . nextLong ( ) 
 + count = 0 
 + 
 + for ( _ ← 1 to 3 ) 
 + sendRequest ( 
 + authId , 
 + sessionId , 
 + sessionRegion . ref , 
 + messageId , 
 + RequestRawRequest ( " echo " , " makeEcho " , Some ( ApiStringValue ( longString ) ) ) 
 + ) 
 + 
 + for ( _ ← 1 to 3 ) 
 + expectRpcResult ( authId , sessionId , ignoreAcks = true ) 
 + 
 + count shouldBe 3 
 + } 
 } 
 } 
 diff - - git a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 index a2c36b3 . . 135a57a 100644 
 - - - a / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 + + + b / actor - server / actor - tests / src / test / scala / im / actor / server / session / SessionSpecHelpers . scala 
 @ @ - 55 , 7 + 55 , 7 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { 
 update . asInstanceOf [ T ] 
 } 
 
 - protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { 
 + protected def expectRpcResult ( authId : Long , sessionId : Long , sendAckAt : Option [ Duration ] = Some ( 0 . seconds ) , expectAckFor : Set [ Long ] = Set . empty , ignoreAcks : Boolean = false ) ( implicit probe : TestProbe , sessionRegion : SessionRegion ) : RpcResult = { 
 val messages = probe . receiveN ( 1 + expectAckFor . size , patienceConfig . timeout . totalNanos . nano ) . toSet 
 
 if ( messages . size ! = expectAckFor . size + 1 ) { 
 @ @ - 71 , 7 + 71 , 8 @ @ trait SessionSpecHelpers extends AbstractPatienceConfiguration with Matchers { 
 } 
 } 
 
 - ackIds shouldEqual expectAckFor 
 + if ( ! ignoreAcks ) 
 + ackIds shouldEqual expectAckFor 
 
 rest match { 
 case Vector ( ( messageId , ProtoRpcResponse ( _ , rpcResultBytes ) ) ) ⇒

NEAREST DIFF:
diff - - git a / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala b / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala 
 index 41ec6fe . . d00b7ab 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / api / rpc / package . scala 
 @ @ - 51 , 7 + 51 , 7 @ @ package object rpc extends { 
 
 def requireAuth ( implicit clientData : ClientData ) : MaybeAuthorized [ AuthorizedClientData ] = 
 clientData . optUserId match { 
 - case Some ( userId ) = > Authorized ( AuthorizedClientData ( clientData . authId , userId ) ) 
 + case Some ( userId ) = > Authorized ( AuthorizedClientData ( clientData . authId , clientData . sessionId , userId ) ) 
 case None = > NotAuthorized 
 } 
 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala 
 index 2d70f73 . . aab7dfe 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / RpcApiService . scala 
 @ @ - 10 , 7 + 10 , 6 @ @ import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . codecs . _ 
 - import im . actor . server . api . rpc . service . auth . AuthServiceImpl 
 
 object RpcApiService { 
 
 @ @ - 20 , 56 + 19 , 53 @ @ object RpcApiService { 
 @ SerialVersionUID ( 1L ) 
 case class RpcResponse ( messageId : Long , responseBytes : BitVector ) 
 
 - def props ( ) ( implicit db : Database ) = Props ( classOf [ RpcApiService ] , db ) 
 - 
 @ SerialVersionUID ( 1L ) 
 - private [ rpc ] case object Initialize 
 + case class AttachService ( service : Service ) 
 
 + def props ( ) ( implicit db : Database ) = Props ( classOf [ RpcApiService ] , db ) 
 } 
 
 class RpcApiService ( implicit db : Database ) extends Actor with ActorLogging { 
 
 import RpcApiService . _ 
 
 - type Chain = PartialFunction [ RpcRequest , ClientData = > Future [ RpcError \ / RpcOk ] ] 
 - 
 - implicit val ec : ExecutionContext = context . dispatcher 
 + private type Chain = PartialFunction [ RpcRequest , ClientData = > Future [ RpcError \ / RpcOk ] ] 
 
 - override def preStart ( ) : Unit = { 
 - super . preStart ( ) 
 - self ! Initialize 
 - } 
 + implicit private val ec : ExecutionContext = context . dispatcher 
 
 - def receive : Receive = { 
 - case Initialize = > 
 - implicit val s = context . system 
 + def receive = initialized ( Set . empty ) 
 
 - val services : Seq [ Service ] = Seq ( new AuthServiceImpl ) 
 - val chain : Chain = services . map ( _ . handleRequestPartial ) . reduce { ( a , b ) = > 
 - a . orElse ( b ) 
 + def initialized ( services : Set [ Service ] ) : Receive = { 
 + val chain : Chain = 
 + if ( services . isEmpty ) { 
 + PartialFunction . empty 
 + } else { 
 + services . map ( _ . handleRequestPartial ) . reduce { ( a , b ) = > 
 + a . orElse ( b ) 
 + } 
 } 
 
 - context . become ( initialized ( chain ) , discardOld = true ) 
 - } 
 - 
 - def initialized ( chain : Chain ) : Receive = { 
 - case HandleRpcRequest ( messageId , requestBytes , clientData ) = > 
 - RequestCodec . decode ( requestBytes ) . require map { 
 - case Request ( rpcRequest ) = > 
 - val result = 
 - if ( chain . isDefinedAt ( rpcRequest ) ) { 
 - chain ( rpcRequest ) ( clientData ) 
 - } else { 
 - log . error ( " Unsupported request { } " , rpcRequest ) 
 - Future . successful ( Error ( CommonErrors . UnsupportedRequest ) ) 
 - } 
 - 
 - result 
 - . map ( _ . fold ( err = > err , ok = > ok ) ) 
 - . map ( result = > RpcResponse ( messageId , RpcResultCodec . encode ( result ) . require ) ) 
 - . pipeTo ( sender ( ) ) 
 - case _ = > 
 - Future . successful ( CommonErrors . UnsupportedRequest ) 
 - } 
 + { 
 + case AttachService ( service ) = > 
 + context . become ( initialized ( services + service ) , discardOld = true ) 
 + case HandleRpcRequest ( messageId , requestBytes , clientData ) = > 
 + RequestCodec . decode ( requestBytes ) . require map { 
 + case Request ( rpcRequest ) = > 
 + val result = 
 + if ( chain . isDefinedAt ( rpcRequest ) ) { 
 + chain ( rpcRequest ) ( clientData ) 
 + } else { 
 + log . error ( " Unsupported request { } " , rpcRequest ) 
 + Future . successful ( Error ( CommonErrors . UnsupportedRequest ) ) 
 + } 
 + 
 + result 
 + . map ( _ . fold ( err = > err , ok = > ok ) ) 
 + . map ( result = > RpcResponse ( messageId , RpcResultCodec . encode ( result ) . require ) ) 
 + . pipeTo ( sender ( ) ) 
 + case _ = > 
 + Future . successful ( CommonErrors . UnsupportedRequest ) 
 + } 
 + } 
 } 
 } 
 diff - - git a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 index f0fc6a2 . . a9a0de6 100644 
 - - - a / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 + + + b / actor - rpc - api / src / main / scala / im / actor / server / api / rpc / service / auth / AuthServiceImpl . scala 
 @ @ - 1 , 6 + 1 , 14 @ @ 
 package im . actor . server . api . rpc . service . auth 
 
 - import akka . actor . ActorSystem 
 + 
 + import scala . concurrent . _ , forkjoin . ThreadLocalRandom 
 + import scalaz . _ 
 + 
 + import akka . actor . { ActorRef , ActorSystem } 
 + import org . joda . time . DateTime 
 + import shapeless . _ 
 + import slick . dbio . DBIO 
 + import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . _ 
 import im . actor . api . rpc . auth . _ 
 @ @ - 8 , 17 + 16 , 9 @ @ import im . actor . api . rpc . misc . _ 
 import im . actor . server . api . util 
 import im . actor . server . models 
 import im . actor . server . persist 
 + import im . actor . server . session . _ 
 
 - import org . joda . time . DateTime 
 - 
 - import scala . concurrent . _ , forkjoin . ThreadLocalRandom 
 - 
 - import scalaz . _ , std . either . _ 
 - import shapeless . _ 
 - import slick . dbio . DBIO 
 - import slick . driver . PostgresDriver . api . _ 
 - 
 - class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) extends AuthService with Helpers { 
 + class AuthServiceImpl ( sessionRegion : ActorRef ) ( implicit val actorSystem : ActorSystem , val db : Database ) extends AuthService with Helpers { 
 private trait SignType 
 private case class Up ( name : String , isSilent : Boolean ) extends SignType 
 private case object In extends SignType 
 @ @ - 74 , 8 + 74 , 14 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e 
 ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 throw new NotImplementedError ( ) 
 
 - override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 - throw new NotImplementedError ( ) 
 + override def jhandleSignOut ( clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = { 
 + val action = requireAuth ( clientData ) map { implicit client = > 
 + DBIO . successful ( Ok ( misc . ResponseVoid ) ) 
 + } 
 + 
 + db . run ( toDBIOAction ( action ) ) 
 + } 
 + 
 
 override def jhandleSignIn ( 
 rawPhoneNumber : Long , 
 @ @ - 169 , 7 + 175 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e 
 / / Phone already exists , fall back to SignIn 
 case Some ( phone ) = > 
 withValidPublicKey ( rawPublicKey ) { publicKey = > 
 - signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode ) 
 + signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode , clientData ) 
 } 
 } 
 ) 
 @ @ - 179 , 7 + 185 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e 
 case None = > DBIO . successful ( Error ( Errors . PhoneNumberUnoccupied ) ) 
 case Some ( phone ) = > 
 persist . AuthSmsCode . deleteByPhoneNumber ( normPhoneNumber ) . andThen ( 
 - signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode ) 
 + signIn ( clientData . authId , phone . userId , publicKey , keyHash ( publicKey ) , countryCode , clientData ) 
 ) 
 } 
 } 
 @ @ - 219 , 7 + 225 , 16 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e 
 case error @ - \ / ( _ ) = > DBIO . successful ( error ) 
 } 
 
 - db . run ( action ) 
 + for ( result < - db . run ( action . transactionally ) ) 
 + yield { 
 + result match { 
 + case Ok ( r : ResponseAuth ) = > 
 + sessionRegion ! SessionMessage . envelope ( SessionMessage . UserAuthorized ( r . user . id ) ) ( clientData ) 
 + case _ = > 
 + } 
 + 
 + result 
 + } 
 } 
 } 
 } 
 @ @ - 230 , 7 + 245 , 7 @ @ class AuthServiceImpl ( implicit val actorSystem : ActorSystem , val db : Database ) e 
 override def jhandleTerminateSession ( id : Int , clientData : ClientData ) : Future [ HandlerResult [ ResponseVoid ] ] = 
 throw new NotImplementedError ( ) 
 
 - private def signIn ( authId : Long , userId : Int , pkData : Array [ Byte ] , pkHash : Long , countryCode : String ) = { 
 + private def signIn ( authId : Long , userId : Int , pkData : Array [ Byte ] , pkHash : Long , countryCode : String , clientData : ClientData ) = { 
 persist . User . find ( userId ) . headOption . flatMap { 
 case None = > DBIO . successful ( Error ( CommonErrors . Internal ) ) 
 case Some ( user ) = > 
 diff - - git a / actor - session - messages / src / main / scala / im / actor / server / session / package . scala b / actor - session - messages / src / main / scala / im / actor / server / session / package . scala 
 new file mode 100644 
 index 0000000 . . acaf954 
 - - - / dev / null 
 + + + b / actor - session - messages / src / main / scala / im / actor / server / session / package . scala 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + package im . actor . server . session 
 + 
 + import im . actor . api . rpc . BaseClientData 
 + import im . actor . server . mtproto . protocol . ProtoMessage 
 + 
 + sealed trait SessionMessage 
 + 
 + object SessionMessage { 
 + @ SerialVersionUID ( 1L ) 
 + private [ session ] case class Envelope ( authId : Long , sessionId : Long , message : SessionMessage ) 
 + 
 + @ SerialVersionUID ( 1L ) 
 + case class HandleMessageBox ( messageBoxBytes : Array [ Byte ] ) extends SessionMessage 
 + 
 + @ SerialVersionUID ( 1L ) 
 + case class SendProtoMessage ( message : ProtoMessage ) extends SessionMessage 
 + 
 + @ SerialVersionUID ( 1L ) 
 + case class UserAuthorized ( userId : Int ) extends SessionMessage 
 + 
 + def envelope ( authId : Long , sessionId : Long , message : SessionMessage ) : Envelope = 
 + Envelope ( authId , sessionId , message ) 
 + 
 + def envelope ( message : SessionMessage ) ( implicit clientData : BaseClientData ) : Envelope = 
 + envelope ( clientData . authId , clientData . sessionId , message ) 
 + } 
 \ No newline at end of file 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / Session . scala b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 index 7a09dee . . 3640612 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / Session . scala 
 @ @ - 3 , 40 + 3 , 45 @ @ package im . actor . server . session 
 import scala . collection . mutable 
 
 import akka . actor . _ 
 + import akka . contrib . pattern . { ClusterSharding , ShardRegion } 
 import akka . stream . FlowMaterializer 
 import akka . stream . actor . _ 
 import akka . stream . scaladsl . _ 
 import scodec . _ 
 import scodec . bits . _ 
 - import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . rpc . ClientData 
 - import im . actor . server . api . rpc . RpcApiService 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . _ 
 
 object Session { 
 
 - sealed trait SessionMessage 
 + import SessionMessage . _ 
 
 - @ SerialVersionUID ( 1L ) 
 - case class Envelope ( authId : Long , sessionId : Long , msg : SessionMessage ) 
 + private [ this ] val idExtractor : ShardRegion . IdExtractor = { 
 + case env @ Envelope ( authId , sessionId , payload ) = > ( authId . toString + " - " + sessionId . toString , env ) 
 + } 
 
 - @ SerialVersionUID ( 1L ) 
 - case class HandleMessageBox ( messageBoxBytes : Array [ Byte ] ) extends SessionMessage 
 + private [ this ] val shardResolver : ShardRegion . ShardResolver = msg = > msg match { 
 + case Envelope ( authId , sessionId , _ ) = > ( authId % 32 ) . toString / / TODO : configurable 
 + } 
 
 - @ SerialVersionUID ( 1L ) 
 - case class SendProtoMessage ( message : ProtoMessage ) extends SessionMessage 
 + def startRegion ( props : Option [ Props ] ) ( implicit system : ActorSystem ) : ActorRef = 
 + ClusterSharding ( system ) . start ( 
 + typeName = " Session " , 
 + entryProps = props , 
 + idExtractor = idExtractor , 
 + shardResolver = shardResolver 
 + ) 
 
 - def props ( ) ( implicit materializer : FlowMaterializer , database : Database ) = Props ( classOf [ Session ] , materializer , database ) 
 + def props ( rpcApiService : ActorRef ) ( implicit materializer : FlowMaterializer ) = Props ( classOf [ Session ] , rpcApiService , materializer ) 
 } 
 
 - class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Actor with ActorLogging with MessageIdHelper { 
 + class Session ( rpcApiService : ActorRef ) ( implicit materializer : FlowMaterializer ) extends Actor with ActorLogging with MessageIdHelper { 
 
 - import Session . _ 
 + import SessionMessage . _ 
 
 - var newSessionSent : Boolean = false 
 var optUserId : Option [ Int ] = None 
 val clients = mutable . Set . empty [ ActorRef ] 
 
 @ @ - 53 , 7 + 58 , 6 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 
 val sessionMessagePublisher = context . actorOf ( SessionMessagePublisher . props ( ) ) 
 val rpcResponsePublisher = context . actorOf ( RpcResponseManager . props ( ) ) 
 - val rpcApiService = context . actorOf ( RpcApiService . props ( ) ) / / TODO : make it adaptive router 
 
 val source = Source ( ActorPublisher [ SessionStream . SessionStreamMessage ] ( sessionMessagePublisher ) ) 
 val graph = SessionStream . graph ( 
 @ @ - 66 , 14 + 70 , 13 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 val flow = rpcResponseSource . to ( Sink . foreach [ ProtoMessage ] ( m = > self ! SendProtoMessage ( m ) ) ) 
 flow . run ( ) 
 
 - sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , optUserId ) ) 
 + sessionMessagePublisher ! Tuple2 ( mb , ClientData ( authId , sessionId , optUserId ) ) 
 
 - context become receiveResolved ( authId , sessionId , sessionMessagePublisher ) 
 + context . become ( receiveResolved ( authId , sessionId , sessionMessagePublisher ) ) 
 } 
 case Terminated ( client ) = > 
 clients . remove ( client ) 
 - case unmatched = > 
 - log . error ( " Received unmatched message { } " , unmatched ) 
 + case unmatched = > handleUnmatched ( unmatched ) 
 } 
 
 def receiveResolved ( authId : Long , sessionId : Long , publisher : ActorRef ) : Receive = { 
 @ @ - 90 , 6 + 93 , 7 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 sendProtoMessage ( authId , sessionId , protoMessage ) 
 case Terminated ( client ) = > 
 clients . remove ( client ) 
 + case unmatched = > handleUnmatched ( unmatched ) 
 } 
 
 private def recordClient ( client : ActorRef ) : Unit = { 
 @ @ - 97 , 15 + 101 , 21 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 context watch client 
 } 
 
 - private def handleSessionMessage ( 
 - authId : Long , 
 - sessionId : Long , 
 - client : ActorRef , msg : SessionMessage , publisher : ActorRef 
 - ) : Unit = msg match { 
 - case HandleMessageBox ( messageBoxBytes ) = > 
 - withValidMessageBox ( client , messageBoxBytes ) ( publisher . tell ( _ , self ) ) 
 - case SendProtoMessage ( protoMessage ) = > 
 - sendProtoMessage ( authId , sessionId , protoMessage ) 
 + private def handleSessionMessage ( authId : Long , 
 + sessionId : Long , 
 + client : ActorRef , 
 + message : SessionMessage , 
 + publisher : ActorRef ) : Unit = { 
 + log . debug ( " Session message { } " , message ) 
 + message match { 
 + case HandleMessageBox ( messageBoxBytes ) = > 
 + withValidMessageBox ( client , messageBoxBytes ) ( mb = > publisher ! Tuple2 ( mb , ClientData ( authId , sessionId , optUserId ) ) ) 
 + case SendProtoMessage ( protoMessage ) = > 
 + sendProtoMessage ( authId , sessionId , protoMessage ) 
 + case UserAuthorized ( userId ) = > 
 + log . debug ( " User { } authorized session { } " , userId , sessionId ) 
 + this . optUserId = Some ( userId ) 
 + } 
 } 
 
 private def sendProtoMessage ( authId : Long , sessionId : Long , message : ProtoMessage ) : Unit = { 
 @ @ - 116 , 8 + 126 , 9 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 decodeMessageBox ( messageBoxBytes ) match { 
 case Some ( mb ) = > f ( mb ) 
 case None = > 
 - client ! Drop ( 0 , 0 , " Cannot parse message box " ) 
 - context stop self 
 + log . warning ( " Failed to parse MessageBox . Droping client . " ) 
 + client ! Drop ( 0 , 0 , " Cannot parse MessageBox " ) 
 + context . stop ( self ) 
 } 
 
 private def decodeMessageBox ( messageBoxBytes : Array [ Byte ] ) : Option [ MessageBox ] = 
 @ @ - 138 , 4 + 149 , 7 @ @ class Session ( implicit materializer : FlowMaterializer , db : Database ) extends Act 
 private def sendProtoMessage ( authId : Long , sessionId : Long ) ( client : ActorRef , message : ProtoMessage ) : Unit = { 
 client ! packProtoMessage ( authId , sessionId , message ) 
 } 
 + 
 + private def handleUnmatched ( message : Any ) = 
 + log . error ( " Received unmatched message { } " , message ) 
 } 
 diff - - git a / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala b / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala 
 index 94f9bf8 . . 607ce87 100644 
 - - - a / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala 
 + + + b / actor - session / src / main / scala / im / actor / server / session / SessionMessagePublisher . scala 
 @ @ - 1 , 21 + 1 , 22 @ @ 
 package im . actor . server . session 
 
 + import scala . annotation . tailrec 
 + import scala . collection . immutable 
 + 
 import akka . actor . _ 
 import akka . stream . actor . _ 
 - import akka . stream . scaladsl . _ 
 
 import im . actor . api . rpc . ClientData 
 import im . actor . server . mtproto . protocol . MessageBox 
 
 - import scala . annotation . tailrec 
 - import scala . collection . immutable 
 - 
 private [ session ] object SessionMessagePublisher { 
 def props ( ) = Props [ SessionMessagePublisher ] 
 } 
 
 private [ session ] class SessionMessagePublisher extends ActorPublisher [ SessionStream . SessionStreamMessage ] with ActorLogging { 
 + 
 import ActorPublisherMessage . _ 
 + 
 import SessionStream . _ 
 
 / / TODO : MaxQueueSize 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 index e07376d . . d506b45 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / AuthServiceSpec . scala 
 @ @ - 1 , 15 + 1 , 12 @ @ 
 package im . actor . server . api . rpc . service 
 
 - import im . actor . api . { rpc = > api } 
 - import im . actor . server . models 
 - import im . actor . server . persist 
 - import im . actor . server . SqlSpecHelpers 
 - import im . actor . util . testing . _ 
 - 
 - import scala . concurrent . _ 
 + import im . actor . api . { rpc = > api } 
 + import im . actor . server . api . rpc . RpcApiService 
 + import im . actor . server . { models , persist } 
 + import im . actor . server . session . Session 
 
 class AuthServiceSpec extends BaseServiceSpec { 
 - def is = sequential ^ s2 " " " 
 + def is = sequential ^ s2 " " " 
 
 AuthService 
 SendAuthCode $ sendAuthCode 
 @ @ - 25 , 27 + 22 , 30 @ @ class AuthServiceSpec extends BaseServiceSpec { 
 not fail if number already exists $ { s . sendAuthCode . e1 } 
 " " " 
 
 - def signUp = s2 " " " 
 + def signUp = s2 " " " 
 SignUp handler should 
 respond ok to a valid request $ { s . signUp ( ) . e1 } 
 " " " 
 
 - def signIn = s2 " " " 
 + def signIn = s2 " " " 
 SignIn handler should 
 respond with PhoneNumberUnoccupied if phone is not registered $ { s . signIn ( ) . unoccupied } 
 respond ok to a valid request $ { s . signIn ( ) . valid } 
 " " " 
 
 object s { 
 - implicit val service = new auth . AuthServiceImpl ( ) 
 + val rpcApiService = system . actorOf ( RpcApiService . props ( ) ) 
 + val sessionRegion = Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) 
 
 implicit val ec = system . dispatcher 
 + implicit val service = new auth . AuthServiceImpl ( sessionRegion ) 
 
 object sendAuthCode { 
 val authId = createAuthId ( ) ( service . db ) 
 + val sessionId = createSessionId ( ) 
 val phoneNumber = buildPhone ( ) 
 
 - implicit val clientData = api . ClientData ( authId , None ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , None ) 
 
 def e1 = { 
 service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) must beOkLike { 
 @ @ - 54 , 12 + 54 , 13 @ @ class AuthServiceSpec extends BaseServiceSpec { 
 } 
 } 
 
 - case class signUp ( ) { 
 + case class signUp ( ) { 
 val authId = createAuthId ( ) ( service . db ) 
 + val sessionId = createSessionId ( ) 
 val phoneNumber = buildPhone ( ) 
 val smsHash = getSmsHash ( authId , phoneNumber ) 
 
 - implicit val clientData = api . ClientData ( authId , None ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , None ) 
 
 def e1 = { 
 service . handleSignUp ( 
 @ @ - 81 , 9 + 82 , 10 @ @ class AuthServiceSpec extends BaseServiceSpec { 
 
 case class signIn ( ) { 
 val authId = createAuthId ( ) ( service . db ) 
 + val sessionId = createSessionId ( ) 
 val phoneNumber = buildPhone ( ) 
 
 - implicit val clientData = api . ClientData ( authId , None ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , None ) 
 
 def unoccupied = { 
 val smsHash = getSmsHash ( authId , phoneNumber ) 
 @ @ - 119 , 9 + 121 , 11 @ @ class AuthServiceSpec extends BaseServiceSpec { 
 ) must beOkLike { 
 case rsp : api . auth . ResponseAuth = > 
 service . db . run ( persist . AuthId . find ( authId ) . head ) must be _ = = ( models . AuthId ( authId , Some ( rsp . user . id ) ) ) . await and 
 - ( service . db . run ( persist . UserPublicKey . find ( rsp . user . id , authId ) . headOption ) must beSome [ models . UserPublicKey ] . await ) 
 + ( service . db . run ( persist . UserPublicKey . find ( rsp . user . id , authId ) . headOption ) must beSome [ models . UserPublicKey ] . await ) 
 } . await 
 } 
 } 
 + 
 } 
 + 
 } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala 
 index 0950fbe . . f66356c 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / BaseServiceSpec . scala 
 @ @ - 1 , 6 + 1 , 6 @ @ 
 package im . actor . server . api . rpc . service 
 
 - import com . typesafe . config . ConfigFactory 
 + import akka . stream . ActorFlowMaterializer 
 import org . specs2 . matcher . ThrownExpectations 
 import org . specs2 . specification . core . Fragments 
 
 @ @ - 14 , 6 + 14 , 7 @ @ trait BaseServiceSpec 
 with ServiceSpecHelpers 
 with HandlerMatchers { 
 implicit lazy val ( ds , db ) = migrateAndInitDb ( ) 
 + implicit val flowMaterializer = ActorFlowMaterializer ( ) 
 
 override def map ( fragments : = > Fragments ) = 
 super . map ( fragments ) ^ step ( closeDb ( ) ) 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 index 89ebfdd . . 34b04a4 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ContactsServiceSpec . scala 
 @ @ - 1 , 12 + 1 , 12 @ @ 
 package im . actor . server . api . rpc . service 
 
 - import scala . concurrent . _ , duration . _ 
 + import scala . concurrent . _ 
 + import scala . concurrent . duration . _ 
 
 import slick . dbio . DBIO 
 
 import im . actor . api . { rpc = > api } 
 import im . actor . server . api . util 
 - import im . actor . server . persist 
 import im . actor . server . push . SeqUpdatesManager 
 
 class ContactsServiceSpec extends BaseServiceSpec { 
 @ @ - 22 , 9 + 22 , 11 @ @ class ContactsServiceSpec extends BaseServiceSpec { 
 
 object s { 
 val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) 
 + val rpcApiService = buildRpcApiService ( ) 
 + val sessionRegion = buildSessionRegion ( rpcApiService ) 
 
 implicit val service = new contacts . ContactsServiceImpl ( seqUpdManagerRegion ) 
 - implicit val authService = buildAuthService ( ) 
 + implicit val authService = buildAuthService ( sessionRegion ) 
 implicit val ec = system . dispatcher 
 
 def addContact ( userId : Int , userAccessSalt : String ) ( implicit clientData : api . ClientData ) = { 
 @ @ - 33 , 7 + 35 , 8 @ @ class ContactsServiceSpec extends BaseServiceSpec { 
 
 object getcontacts { 
 val ( user , authId , _ ) = createUser ( ) 
 - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) 
 
 val userModels = for ( i < - 1 to 3 ) yield { 
 val user = createUser ( ) . _ 1 . asModel ( ) 
 @ @ - 60 , 6 + 63 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { 
 
 object addremove { 
 val authId = createAuthId ( ) 
 + val sessionId = createSessionId ( ) 
 val phoneNumber = buildPhone ( ) 
 val user = createUser ( authId , phoneNumber ) 
 
 @ @ - 67 , 7 + 71 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { 
 val user2Model = getUserModel ( user2 . id ) 
 val user2AccessHash = util . ACL . userAccessHash ( authId , user2 . id , user2Model . accessSalt ) 
 
 - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) 
 
 def add ( firstRun : Boolean = true , expectedUpdSeq : Int = 1001 ) = { 
 service . handleAddContact ( user2 . id , user2AccessHash ) must beOkLike { 
 @ @ - 96 , 5 + 100 , 7 @ @ class ContactsServiceSpec extends BaseServiceSpec { 
 
 def addAfterRemove = add ( firstRun = false , expectedUpdSeq = 1004 ) 
 } 
 + 
 } 
 + 
 } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala 
 index 394cf2a . . 8d3522d 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / EncryptionServiceSpec . scala 
 @ @ - 1 , 8 + 1 , 7 @ @ 
 package im . actor . server . api . rpc . service 
 
 - import scala . concurrent . _ , duration . _ 
 - 
 - import slick . driver . PostgresDriver . api . Database 
 + import scala . concurrent . _ 
 + import scala . concurrent . duration . _ 
 
 import im . actor . api . { rpc = > api } 
 import im . actor . server . api . util 
 @ @ - 15 , 12 + 14 , 15 @ @ class EncryptionServiceSpec extends BaseServiceSpec { 
 " " " 
 
 object s { 
 - implicit val service = new encryption . EncryptionServiceImpl 
 + val rpcApiService = buildRpcApiService ( ) 
 + val sessionRegion = buildSessionRegion ( rpcApiService ) 
 
 - implicit val authService = buildAuthService ( ) 
 + implicit val service = new encryption . EncryptionServiceImpl 
 + implicit val authService = buildAuthService ( sessionRegion ) 
 implicit val ec = system . dispatcher 
 
 val authId = createAuthId ( ) 
 + val sessionId = createSessionId ( ) 
 val phoneNumber = buildPhone ( ) 
 
 val user = createUser ( authId , phoneNumber ) 
 @ @ - 30 , 7 + 32 , 7 @ @ class EncryptionServiceSpec extends BaseServiceSpec { 
 
 val user2 = createUser ( authId2 , phoneNumber2 ) 
 
 - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) 
 
 def e1 = { 
 val user2Model = Await . result ( db . run ( persist . User . find ( user2 . id ) . head ) , 1 . second ) 
 @ @ - 46 , 9 + 48 , 10 @ @ class EncryptionServiceSpec extends BaseServiceSpec { 
 ) 
 ) must beOkLike { 
 case api . encryption . ResponseGetPublicKeys ( Vector ( 
 - pk @ api . encryption . PublicKey ( user2 . id , user2pk . hash , _ ) 
 + pk @ api . encryption . PublicKey ( user2 . id , user2pk . hash , _ ) 
 ) ) if pk . key . sameElements ( user2pk . data ) = > ok 
 } . await 
 } 
 } 
 + 
 } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 index 8e49b8e . . ea3ed41 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / MessagingServiceSpec . scala 
 @ @ - 1 , 12 + 1 , 8 @ @ 
 package im . actor . server . api . rpc . service 
 
 - import scala . concurrent . _ , duration . _ 
 - 
 - import slick . dbio . DBIO 
 - 
 - import im . actor . api . { rpc = > api } , api . Implicits . _ 
 + import im . actor . api . rpc . Implicits . _ 
 + import im . actor . api . { rpc = > api } 
 import im . actor . server . api . util 
 - import im . actor . server . persist 
 import im . actor . server . push . SeqUpdatesManager 
 
 class MessagingServiceSpec extends BaseServiceSpec { 
 @ @ - 17 , 14 + 13 , 17 @ @ class MessagingServiceSpec extends BaseServiceSpec { 
 
 object s { 
 val seqUpdManagerRegion = SeqUpdatesManager . startRegion ( ) 
 + val rpcApiService = buildRpcApiService ( ) 
 + val sessionRegion = buildSessionRegion ( rpcApiService ) 
 
 implicit val service = new messaging . MessagingServiceImpl ( seqUpdManagerRegion ) 
 - implicit val authService = buildAuthService ( ) 
 + implicit val authService = buildAuthService ( sessionRegion ) 
 implicit val ec = system . dispatcher 
 
 object privat { 
 val ( user , authId , _ ) = createUser ( ) 
 - implicit val clientData = api . ClientData ( authId , Some ( user . id ) ) 
 + val sessionId = createSessionId ( ) 
 + implicit val clientData = api . ClientData ( authId , sessionId , Some ( user . id ) ) 
 
 val ( user2 , _ , _ ) = createUser ( ) 
 val user2Model = getUserModel ( user2 . id ) 
 @ @ - 37 , 5 + 36 , 7 @ @ class MessagingServiceSpec extends BaseServiceSpec { 
 } . await 
 } 
 } 
 + 
 } 
 + 
 } 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 index 122b23a . . ed30067 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / api / rpc / service / ServiceSpecHelpers . scala 
 @ @ - 2 , 14 + 2 , 17 @ @ package im . actor . server . api . rpc . service 
 
 import scala . concurrent . _ , duration . _ 
 
 - import akka . actor . ActorSystem 
 + import akka . actor . { ActorRef , ActorSystem } 
 + import akka . stream . FlowMaterializer 
 import akka . util . Timeout 
 import eu . codearte . jfairy . Fairy 
 import slick . driver . PostgresDriver . api . _ 
 
 import im . actor . api . { rpc = > api } 
 + import im . actor . server . api . rpc . RpcApiService 
 import im . actor . server . models 
 import im . actor . server . persist 
 + import im . actor . server . session . Session 
 
 trait PersistenceHelpers { 
 implicit val timeout = Timeout ( 5 . seconds ) 
 @ @ - 32 , 15 + 35 , 18 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 } 
 
 def createAuthId ( ) ( implicit db : Database ) : Long = { 
 - val authId = scala . util . Random . nextLong 
 + val authId = scala . util . Random . nextLong ( ) 
 
 Await . result ( db . run ( persist . AuthId . create ( authId , None ) ) , 1 . second ) 
 authId 
 } 
 
 + def createSessionId ( ) : Long = 
 + scala . util . Random . nextLong ( ) 
 + 
 def getSmsHash ( authId : Long , phoneNumber : Long ) ( implicit service : api . auth . AuthService , system : ActorSystem ) : String = withoutLogs { 
 val api . auth . ResponseSendAuthCode ( smsHash , _ ) = 
 - Await . result ( service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) ( api . ClientData ( authId , None ) ) , 1 . second ) . toOption . get 
 + Await . result ( service . handleSendAuthCode ( phoneNumber , 1 , " apiKey " ) ( api . ClientData ( authId , scala . util . Random . nextLong ( ) , None ) ) , 1 . second ) . toOption . get 
 smsHash 
 } 
 
 @ @ - 64 , 12 + 70 , 17 @ @ trait ServiceSpecHelpers extends PersistenceHelpers with UserStructExtensions { 
 appId = 42 , 
 appKey = " appKey " , 
 isSilent = false 
 - ) ( api . ClientData ( authId , None ) ) , 1 . second ) . toOption . get 
 + ) ( api . ClientData ( authId , scala . util . Random . nextLong ( ) , None ) ) , 1 . second ) . toOption . get 
 
 rsp . user 
 } 
 
 - def buildAuthService ( ) ( implicit system : ActorSystem , database : Database ) = new auth . AuthServiceImpl ( ) 
 + def buildRpcApiService ( ) ( implicit system : ActorSystem , db : Database ) = system . actorOf ( RpcApiService . props ( ) ) 
 + 
 + def buildSessionRegion ( rpcApiService : ActorRef ) ( implicit system : ActorSystem , flowMaterializer : FlowMaterializer ) = 
 + Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) 
 + 
 + def buildAuthService ( sessionRegion : ActorRef ) ( implicit system : ActorSystem , database : Database ) = new auth . AuthServiceImpl ( sessionRegion ) 
 
 protected def withoutLogs [ A ] ( f : = > A ) ( implicit system : ActorSystem ) : A = { 
 val logger = org . slf4j . LoggerFactory . getLogger ( org . slf4j . Logger . ROOT _ LOGGER _ NAME ) . asInstanceOf [ ch . qos . logback . classic . Logger ] 
 diff - - git a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 index 26199a4 . . 39fd86a 100644 
 - - - a / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 + + + b / actor - tests / src / test / scala / im / actor / server / session / SessionSpec . scala 
 @ @ - 1 , 45 + 1 , 56 @ @ 
 package im . actor . server . session 
 
 + import scala . concurrent . duration . _ 
 + import scala . util . Random 
 + 
 import akka . actor . _ 
 import akka . stream . ActorFlowMaterializer 
 import akka . testkit . TestProbe 
 - import org . specs2 . Specification 
 + import org . specs2 . matcher . ThrownExpectations 
 + import scodec . bits . _ 
 
 - import im . actor . api . rpc . { RpcResult , RpcOk , Request } 
 - import im . actor . api . rpc . auth . { ResponseSendAuthCode , RequestSendAuthCode } 
 + import im . actor . api . rpc . auth . { ResponseAuth , RequestSignUp , RequestSignOut , RequestSendAuthCode , ResponseSendAuthCode } 
 import im . actor . api . rpc . codecs . _ 
 - import im . actor . server . api . rpc . { RpcResultCodec , RpcOkCodec } 
 + import im . actor . api . rpc . misc . ResponseVoid 
 + import im . actor . api . rpc . { Request , RpcOk , RpcResult } 
 + import im . actor . server . SqlSpecHelpers 
 + import im . actor . server . api . rpc . service . auth . AuthServiceImpl 
 + import im . actor . server . api . rpc . { RpcApiService , RpcResultCodec } 
 import im . actor . server . mtproto . codecs . protocol . MessageBoxCodec 
 import im . actor . server . mtproto . protocol . _ 
 import im . actor . server . mtproto . transport . _ 
 import im . actor . util . testing . _ 
 
 - import scala . concurrent . duration . _ 
 - import scala . util . Random 
 - 
 - import scodec . bits . _ 
 - 
 - import im . actor . server . SqlSpecHelpers 
 - 
 - class SessionSpec extends ActorSpecification with SqlSpecHelpers { 
 + class SessionSpec extends ActorSpecification with SqlSpecHelpers with ThrownExpectations { 
 def is = sequential ^ s2 " " " 
 Session Actor should 
 send Drop on message on wrong message box $ { sessions ( ) . e1 } 
 send NewSession on first HandleMessageBox $ { sessions ( ) . e2 } 
 reply to RpcRequestBox $ { sessions ( ) . e3 } 
 + handle user authorization $ { sessions ( ) . e4 } 
 " " " 
 
 case class sessions ( ) { 
 - import Session . _ 
 + 
 + import SessionMessage . _ 
 + 
 implicit val materializer = ActorFlowMaterializer ( ) 
 implicit val ( ds , db ) = migrateAndInitDb ( ) 
 
 val authId = Random . nextLong ( ) 
 - val sessionId = Random . nextLong ( ) 
 - val session = system . actorOf ( Session . props ( ) , s " Session - $ authId - $ sessionId " ) 
 + 
 + val rpcApiService = system . actorOf ( RpcApiService . props ( ) ) 
 + val sessionRegion = Session . startRegion ( Some ( Session . props ( rpcApiService ) ) ) 
 + 
 + val authService = new AuthServiceImpl ( sessionRegion ) 
 + rpcApiService ! RpcApiService . AttachService ( authService ) 
 + 
 val probe = TestProbe ( ) 
 
 def e1 ( ) = { 
 + val sessionId = Random . nextLong ( ) 
 + val session = system . actorOf ( Session . props ( rpcApiService ) ) 
 + 
 sendEnvelope ( authId , sessionId , session , HandleMessageBox ( BitVector . empty . toByteArray ) ) 
 
 probe watch session 
 @ @ - 49 , 20 + 60 , 22 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { 
 } 
 
 def e2 ( ) = { 
 + val sessionId = Random . nextLong ( ) 
 val messageId = Random . nextLong ( ) 
 
 val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require 
 - sendMessageBox ( authId , sessionId , session , messageId , RpcRequestBox ( encodedRequest ) ) 
 + sendMessageBox ( authId , sessionId , sessionRegion , messageId , RpcRequestBox ( encodedRequest ) ) 
 
 expectNewSession ( authId , sessionId , messageId ) 
 probe . receiveOne ( 1 . second ) 
 } 
 
 def e3 ( ) = { 
 + val sessionId = Random . nextLong ( ) 
 val messageId = Random . nextLong ( ) 
 
 val encodedRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( 75553333333L , 1 , " apiKey " ) ) ) . require 
 - sendMessageBox ( authId , sessionId , session , messageId , RpcRequestBox ( encodedRequest ) ) 
 + sendMessageBox ( authId , sessionId , sessionRegion , messageId , RpcRequestBox ( encodedRequest ) ) 
 
 expectNewSession ( authId , sessionId , messageId ) 
 receiveRpcResult ( ) must beLike { 
 @ @ - 70 , 6 + 83 , 45 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { 
 } 
 } 
 
 + def e4 ( ) = { 
 + val sessionId = Random . nextLong ( ) 
 + 
 + val firstMessageId = Random . nextLong ( ) 
 + val phoneNumber = 75550000000L 
 + 
 + val encodedCodeRequest = RequestCodec . encode ( Request ( RequestSendAuthCode ( phoneNumber , 1 , " apiKey " ) ) ) . require 
 + sendMessageBox ( authId , sessionId , sessionRegion , firstMessageId , RpcRequestBox ( encodedCodeRequest ) ) 
 + 
 + expectNewSession ( authId , sessionId , firstMessageId ) 
 + 
 + val smsHash = receiveRpcResult ( ) . asInstanceOf [ RpcOk ] . response . asInstanceOf [ ResponseSendAuthCode ] . smsHash 
 + 
 + val encodedSignUpRequest = RequestCodec . encode ( Request ( RequestSignUp ( 
 + phoneNumber = phoneNumber , 
 + smsHash = smsHash , 
 + smsCode = " 0000 " , 
 + name = " Wayne Brain " , 
 + publicKey = Array ( 1 , 2 , 3 ) , 
 + deviceHash = Array ( 4 , 5 , 6 ) , 
 + deviceTitle = " Specs virtual device " , 
 + appId = 1 , 
 + appKey = " appKey " , 
 + isSilent = false 
 + ) ) ) . require 
 + sendMessageBox ( authId , sessionId , sessionRegion , Random . nextLong ( ) , RpcRequestBox ( encodedSignUpRequest ) ) 
 + 
 + receiveRpcResult ( ) must beLike { 
 + case RpcOk ( ResponseAuth ( _ , _ , _ ) ) = > ok 
 + } 
 + 
 + val encodedSignOutRequest = RequestCodec . encode ( Request ( RequestSignOut ) ) . require 
 + sendMessageBox ( authId , sessionId , sessionRegion , Random . nextLong ( ) , RpcRequestBox ( encodedSignOutRequest ) ) 
 + 
 + receiveRpcResult ( ) must beLike { 
 + case RpcOk ( ResponseVoid ) = > ok 
 + } 
 + } 
 + 
 private def receiveRpcResult ( ) : RpcResult = { 
 Option ( probe . receiveOne ( 1 . second ) ) match { 
 case Some ( MTPackage ( authId , sessionId , mbBytes ) ) = > 
 @ @ - 109 , 4 + 161 , 5 @ @ class SessionSpec extends ActorSpecification with SqlSpecHelpers { 
 } 
 
 } 
 + 
 } 
 diff - - git a / project / Build . scala b / project / Build . scala 
 index 9fa0dc9 . . 5c5ad64 100644 
 - - - a / project / Build . scala 
 + + + b / project / Build . scala 
 @ @ - 84 , 6 + 84 , 12 @ @ object Build extends sbt . Build { 
 ) 
 ) . dependsOn ( actorPersist , actorFrontend , actorCodecs , actorApi , actorRpcApi ) 
 
 + lazy val actorSessionMessages = Project ( 
 + id = " actor - session - messages " , 
 + base = file ( " actor - session - messages " ) , 
 + settings = defaultSettings 
 + ) . dependsOn ( actorApi ) 
 + 
 lazy val actorPush = Project ( 
 id = " actor - push " , 
 base = file ( " actor - push " ) , 
 @ @ - 109 , 7 + 115 , 7 @ @ object Build extends sbt . Build { 
 settings = defaultSettings + + Seq ( 
 libraryDependencies + + = Dependencies . rpcApi 
 ) 
 - ) . dependsOn ( actorApi , actorCodecs , actorPersist , actorPush ) 
 + ) . dependsOn ( actorApi , actorCodecs , actorPersist , actorPush , actorSessionMessages ) 
 
 lazy val actorFrontend = Project ( 
 id = " actor - frontend " ,
