BLEU SCORE: 0.007869270985473822

TEST MSG: Include snippet of query in SyntaxError messages
GENERATED MSG: add nodeprobe cli tool . patch by Eric Evans ; reviewed by jbellis for CASSANDRA - 211

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1781ef3 . . 89f9b7c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 6 , 6 + 6 , 7 @ @ <nl> * Adjust MT depth based on # of partition validating ( CASSANDRA - 5263 ) <nl> * Optimise NativeCell comparisons ( CASSANDRA - 6755 ) <nl> * Configurable client timeout for cqlsh ( CASSANDRA - 7516 ) <nl> + * Include snippet of CQL query near syntax error in messages ( CASSANDRA - 7111 ) <nl> <nl> <nl> 2 . 1 . 0 - final <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index 948cd5e . . 9dcc268 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 51 , 7 + 51 , 7 @ @ options { <nl> } <nl> <nl> @ members { <nl> - private final List < String > recognitionErrors = new ArrayList < String > ( ) ; <nl> + private final List < ErrorListener > listeners = new ArrayList < ErrorListener > ( ) ; <nl> private final List < ColumnIdentifier > bindVariables = new ArrayList < ColumnIdentifier > ( ) ; <nl> <nl> public static final Set < String > reservedTypeNames = new HashSet < String > ( ) <nl> @ @ - 94 , 27 + 94 , 26 @ @ options { <nl> return marker ; <nl> } <nl> <nl> - public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) <nl> + public void addErrorListener ( ErrorListener listener ) <nl> { <nl> - String hdr = getErrorHeader ( e ) ; <nl> - String msg = getErrorMessage ( e , tokenNames ) ; <nl> - recognitionErrors . add ( hdr + " " + msg ) ; <nl> + this . listeners . add ( listener ) ; <nl> } <nl> <nl> - public void addRecognitionError ( String msg ) <nl> + public void removeErrorListener ( ErrorListener listener ) <nl> { <nl> - recognitionErrors . add ( msg ) ; <nl> + this . listeners . remove ( listener ) ; <nl> } <nl> <nl> - public List < String > getRecognitionErrors ( ) <nl> + public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) <nl> { <nl> - return recognitionErrors ; <nl> + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) <nl> + listeners . get ( i ) . syntaxError ( this , tokenNames , e ) ; <nl> } <nl> <nl> - public void throwLastRecognitionError ( ) throws SyntaxException <nl> + private void addRecognitionError ( String msg ) <nl> { <nl> - if ( recognitionErrors . size ( ) > 0 ) <nl> - throw new SyntaxException ( recognitionErrors . get ( ( recognitionErrors . size ( ) - 1 ) ) ) ; <nl> + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) <nl> + listeners . get ( i ) . syntaxError ( this , msg ) ; <nl> } <nl> <nl> public Map < String , String > convertPropertyMap ( Maps . Literal map ) <nl> @ @ - 189 , 24 + 188 , 22 @ @ options { <nl> return tokens . remove ( 0 ) ; <nl> } <nl> <nl> - private List < String > recognitionErrors = new ArrayList < String > ( ) ; <nl> + private final List < ErrorListener > listeners = new ArrayList < ErrorListener > ( ) ; <nl> <nl> - public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) <nl> + public void addErrorListener ( ErrorListener listener ) <nl> { <nl> - String hdr = getErrorHeader ( e ) ; <nl> - String msg = getErrorMessage ( e , tokenNames ) ; <nl> - recognitionErrors . add ( hdr + " " + msg ) ; <nl> + this . listeners . add ( listener ) ; <nl> } <nl> <nl> - public List < String > getRecognitionErrors ( ) <nl> + public void removeErrorListener ( ErrorListener listener ) <nl> { <nl> - return recognitionErrors ; <nl> + this . listeners . remove ( listener ) ; <nl> } <nl> <nl> - public void throwLastRecognitionError ( ) throws SyntaxException <nl> + public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) <nl> { <nl> - if ( recognitionErrors . size ( ) > 0 ) <nl> - throw new SyntaxException ( recognitionErrors . get ( ( recognitionErrors . size ( ) - 1 ) ) ) ; <nl> + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) <nl> + listeners . get ( i ) . syntaxError ( this , tokenNames , e ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ErrorCollector . java b / src / java / org / apache / cassandra / cql3 / ErrorCollector . java <nl> new file mode 100644 <nl> index 0000000 . . 41536f5 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / ErrorCollector . java <nl> @ @ - 0 , 0 + 1 , 242 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import java . util . LinkedList ; <nl> + <nl> + import org . antlr . runtime . BaseRecognizer ; <nl> + import org . antlr . runtime . Parser ; <nl> + import org . antlr . runtime . RecognitionException ; <nl> + import org . antlr . runtime . Token ; <nl> + import org . antlr . runtime . TokenStream ; <nl> + import org . apache . cassandra . exceptions . SyntaxException ; <nl> + <nl> + / * * <nl> + * < code > ErrorListener < / code > that collect and enhance the errors send by the CQL lexer and parser . <nl> + * / <nl> + public final class ErrorCollector implements ErrorListener <nl> + { <nl> + / * * <nl> + * The offset of the first token of the snippet . <nl> + * / <nl> + private static final int FIRST _ TOKEN _ OFFSET = 10 ; <nl> + <nl> + / * * <nl> + * The offset of the last token of the snippet . <nl> + * / <nl> + private static final int LAST _ TOKEN _ OFFSET = 2 ; <nl> + <nl> + / * * <nl> + * The CQL query . <nl> + * / <nl> + private final String query ; <nl> + <nl> + / * * <nl> + * The error messages . <nl> + * / <nl> + private final LinkedList < String > errorMsgs = new LinkedList < > ( ) ; <nl> + <nl> + / * * <nl> + * Creates a new < code > ErrorCollector < / code > instance to collect the syntax errors associated to the specified CQL <nl> + * query . <nl> + * <nl> + * @ param query the CQL query that will be parsed <nl> + * / <nl> + public ErrorCollector ( String query ) <nl> + { <nl> + this . query = query ; <nl> + } <nl> + <nl> + / * * <nl> + * { @ inheritDoc } <nl> + * / <nl> + @ Override <nl> + public void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) <nl> + { <nl> + String hdr = recognizer . getErrorHeader ( e ) ; <nl> + String msg = recognizer . getErrorMessage ( e , tokenNames ) ; <nl> + <nl> + StringBuilder builder = new StringBuilder ( ) . append ( hdr ) <nl> + . append ( ' ' ) <nl> + . append ( msg ) ; <nl> + <nl> + if ( recognizer instanceof Parser ) <nl> + appendQuerySnippet ( ( Parser ) recognizer , builder ) ; <nl> + <nl> + errorMsgs . add ( builder . toString ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * { @ inheritDoc } <nl> + * / <nl> + @ Override <nl> + public void syntaxError ( BaseRecognizer recognizer , String errorMsg ) <nl> + { <nl> + errorMsgs . add ( errorMsg ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Throws the last syntax error found by the lexer or the parser if it exists . <nl> + * <nl> + * @ throws SyntaxException the syntax error . <nl> + * / <nl> + public void throwLastSyntaxError ( ) throws SyntaxException <nl> + { <nl> + if ( ! errorMsgs . isEmpty ( ) ) <nl> + throw new SyntaxException ( errorMsgs . getLast ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Appends a query snippet to the message to help the user to understand the problem . <nl> + * <nl> + * @ param parser the parser used to parse the query <nl> + * @ param builder the < code > StringBuilder < / code > used to build the error message <nl> + * / <nl> + private void appendQuerySnippet ( Parser parser , StringBuilder builder ) <nl> + { <nl> + TokenStream tokenStream = parser . getTokenStream ( ) ; <nl> + int index = tokenStream . index ( ) ; <nl> + int size = tokenStream . size ( ) ; <nl> + <nl> + Token from = tokenStream . get ( getSnippetFirstTokenIndex ( index ) ) ; <nl> + Token to = tokenStream . get ( getSnippetLastTokenIndex ( index , size ) ) ; <nl> + Token offending = tokenStream . get ( index ) ; <nl> + <nl> + appendSnippet ( builder , from , to , offending ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Appends a query snippet to the message to help the user to understand the problem . <nl> + * <nl> + * @ param from the first token to include within the snippet <nl> + * @ param to the last token to include within the snippet <nl> + * @ param offending the token which is responsible for the error <nl> + * / <nl> + final void appendSnippet ( StringBuilder builder , <nl> + Token from , <nl> + Token to , <nl> + Token offending ) <nl> + { <nl> + String [ ] lines = query . split ( " \ n " ) ; <nl> + <nl> + boolean includeQueryStart = ( from . getLine ( ) = = 1 ) & & ( from . getCharPositionInLine ( ) = = 0 ) ; <nl> + boolean includeQueryEnd = ( to . getLine ( ) = = lines . length ) <nl> + & & ( getLastCharPositionInLine ( to ) = = lines [ lines . length - 1 ] . length ( ) ) ; <nl> + <nl> + builder . append ( " ( " ) ; <nl> + <nl> + if ( ! includeQueryStart ) <nl> + builder . append ( " . . . " ) ; <nl> + <nl> + lines [ lineIndex ( to ) ] = lines [ lineIndex ( to ) ] . substring ( 0 , getLastCharPositionInLine ( to ) ) ; <nl> + lines [ lineIndex ( offending ) ] = highlightToken ( lines [ lineIndex ( offending ) ] , offending ) ; <nl> + lines [ lineIndex ( from ) ] = lines [ lineIndex ( from ) ] . substring ( from . getCharPositionInLine ( ) ) ; <nl> + <nl> + for ( int i = lineIndex ( from ) , m = lineIndex ( to ) ; i < = m ; i + + ) <nl> + builder . append ( lines [ i ] ) ; <nl> + <nl> + if ( ! includeQueryEnd ) <nl> + builder . append ( " . . . " ) ; <nl> + <nl> + builder . append ( " ) " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Puts the specified token within square brackets . <nl> + * <nl> + * @ param line the line containing the token <nl> + * @ param token the token to put within square brackets <nl> + * / <nl> + private static String highlightToken ( String line , Token token ) <nl> + { <nl> + String newLine = insertChar ( line , getLastCharPositionInLine ( token ) , ' ] ' ) ; <nl> + return insertChar ( newLine , token . getCharPositionInLine ( ) , ' [ ' ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the index of the last character relative to the beginning of the line 0 . . n - 1 <nl> + * <nl> + * @ param token the token <nl> + * @ return the index of the last character relative to the beginning of the line 0 . . n - 1 <nl> + * / <nl> + private static int getLastCharPositionInLine ( Token token ) <nl> + { <nl> + return token . getCharPositionInLine ( ) + getLength ( token ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return the token length . <nl> + * <nl> + * @ param token the token <nl> + * @ return the token length <nl> + * / <nl> + private static int getLength ( Token token ) <nl> + { <nl> + return token . getText ( ) . length ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Inserts a character at a given position within a < code > String < / code > . <nl> + * <nl> + * @ param s the < code > String < / code > in which the character must be inserted <nl> + * @ param index the position where the character must be inserted <nl> + * @ param c the character to insert <nl> + * @ return the modified < code > String < / code > <nl> + * / <nl> + private static String insertChar ( String s , int index , char c ) <nl> + { <nl> + return new StringBuilder ( ) . append ( s . substring ( 0 , index ) ) <nl> + . append ( c ) <nl> + . append ( s . substring ( index ) ) <nl> + . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the index of the line number on which this token was matched ; index = 0 . . n - 1 <nl> + * <nl> + * @ param token the token <nl> + * @ return the index of the line number on which this token was matched ; index = 0 . . n - 1 <nl> + * / <nl> + private static int lineIndex ( Token token ) <nl> + { <nl> + return token . getLine ( ) - 1 ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the index of the last token which is part of the snippet . <nl> + * <nl> + * @ param index the index of the token causing the error <nl> + * @ param size the total number of tokens <nl> + * @ return the index of the last token which is part of the snippet . <nl> + * / <nl> + private static int getSnippetLastTokenIndex ( int index , int size ) <nl> + { <nl> + return Math . min ( size - 1 , index + LAST _ TOKEN _ OFFSET ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the index of the first token which is part of the snippet . <nl> + * <nl> + * @ param index the index of the token causing the error <nl> + * @ return the index of the first token which is part of the snippet . <nl> + * / <nl> + private static int getSnippetFirstTokenIndex ( int index ) <nl> + { <nl> + return Math . max ( 0 , index - FIRST _ TOKEN _ OFFSET ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ErrorListener . java b / src / java / org / apache / cassandra / cql3 / ErrorListener . java <nl> new file mode 100644 <nl> index 0000000 . . 0bf891a <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / ErrorListener . java <nl> @ @ - 0 , 0 + 1 , 44 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . antlr . runtime . BaseRecognizer ; <nl> + import org . antlr . runtime . RecognitionException ; <nl> + <nl> + / * * <nl> + * Listener used to collect the syntax errors emitted by the Lexer and Parser . <nl> + * / <nl> + public interface ErrorListener <nl> + { <nl> + / * * <nl> + * Invoked when a syntax error occurs . <nl> + * <nl> + * @ param recognizer the parser or lexer that emitted the error <nl> + * @ param tokenNames the token names <nl> + * @ param e the exception <nl> + * / <nl> + void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) ; <nl> + <nl> + / * * <nl> + * Invoked when a syntax error with a specified message occurs . <nl> + * <nl> + * @ param recognizer the parser or lexer that emitted the error <nl> + * @ param errorMsg the error message <nl> + * / <nl> + void syntaxError ( BaseRecognizer recognizer , String errorMsg ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 86362f7 . . 4994342 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 442 , 18 + 442 , 21 @ @ public class QueryProcessor implements QueryHandler <nl> try <nl> { <nl> / / Lexer and parser <nl> + ErrorCollector errorCollector = new ErrorCollector ( queryStr ) ; <nl> CharStream stream = new ANTLRStringStream ( queryStr ) ; <nl> CqlLexer lexer = new CqlLexer ( stream ) ; <nl> + lexer . addErrorListener ( errorCollector ) ; <nl> + <nl> TokenStream tokenStream = new CommonTokenStream ( lexer ) ; <nl> CqlParser parser = new CqlParser ( tokenStream ) ; <nl> + parser . addErrorListener ( errorCollector ) ; <nl> <nl> / / Parse the query string to a statement instance <nl> ParsedStatement statement = parser . query ( ) ; <nl> <nl> - / / The lexer and parser queue up any errors they may have encountered <nl> - / / along the way , if necessary , we turn them into exceptions here . <nl> - lexer . throwLastRecognitionError ( ) ; <nl> - parser . throwLastRecognitionError ( ) ; <nl> + / / The errorCollector has queue up any errors that the lexer and parser may have encountered <nl> + / / along the way , if necessary , we turn the last error into exceptions here . <nl> + errorCollector . throwLastSyntaxError ( ) ; <nl> <nl> return statement ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java b / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java <nl> new file mode 100644 <nl> index 0000000 . . d122eb5 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java <nl> @ @ - 0 , 0 + 1 , 90 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . antlr . runtime . ANTLRStringStream ; <nl> + import org . antlr . runtime . BaseRecognizer ; <nl> + import org . antlr . runtime . CharStream ; <nl> + import org . antlr . runtime . CommonTokenStream ; <nl> + import org . antlr . runtime . RecognitionException ; <nl> + import org . antlr . runtime . TokenStream ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + public class CqlParserTest <nl> + { <nl> + @ Test <nl> + public void testAddErrorListener ( ) throws Exception <nl> + { <nl> + SyntaxErrorCounter firstCounter = new SyntaxErrorCounter ( ) ; <nl> + SyntaxErrorCounter secondCounter = new SyntaxErrorCounter ( ) ; <nl> + <nl> + CharStream stream = new ANTLRStringStream ( " SELECT * FORM test ; " ) ; <nl> + CqlLexer lexer = new CqlLexer ( stream ) ; <nl> + <nl> + TokenStream tokenStream = new CommonTokenStream ( lexer ) ; <nl> + CqlParser parser = new CqlParser ( tokenStream ) ; <nl> + parser . addErrorListener ( firstCounter ) ; <nl> + parser . addErrorListener ( secondCounter ) ; <nl> + <nl> + parser . query ( ) ; <nl> + <nl> + assertEquals ( 1 , firstCounter . count ) ; <nl> + assertEquals ( 1 , secondCounter . count ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRemoveErrorListener ( ) throws Exception <nl> + { <nl> + SyntaxErrorCounter firstCounter = new SyntaxErrorCounter ( ) ; <nl> + SyntaxErrorCounter secondCounter = new SyntaxErrorCounter ( ) ; <nl> + <nl> + CharStream stream = new ANTLRStringStream ( " SELECT * FORM test ; " ) ; <nl> + CqlLexer lexer = new CqlLexer ( stream ) ; <nl> + <nl> + TokenStream tokenStream = new CommonTokenStream ( lexer ) ; <nl> + CqlParser parser = new CqlParser ( tokenStream ) ; <nl> + parser . addErrorListener ( firstCounter ) ; <nl> + parser . addErrorListener ( secondCounter ) ; <nl> + parser . removeErrorListener ( secondCounter ) ; <nl> + <nl> + parser . query ( ) ; <nl> + <nl> + assertEquals ( 1 , firstCounter . count ) ; <nl> + assertEquals ( 0 , secondCounter . count ) ; <nl> + } <nl> + <nl> + private static final class SyntaxErrorCounter implements ErrorListener <nl> + { <nl> + private int count ; <nl> + <nl> + @ Override <nl> + public void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) <nl> + { <nl> + count + + ; <nl> + } <nl> + <nl> + @ Override <nl> + public void syntaxError ( BaseRecognizer recognizer , String errorMsg ) <nl> + { <nl> + count + + ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java b / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java <nl> new file mode 100644 <nl> index 0000000 . . 4f5db34 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java <nl> @ @ - 0 , 0 + 1 , 218 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . antlr . runtime . CharStream ; <nl> + import org . antlr . runtime . Token ; <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + <nl> + public class ErrorCollectorTest <nl> + { <nl> + @ Test <nl> + public void testAppendSnippetWithEmptyQuery ( ) <nl> + { <nl> + String query = " ; " ; <nl> + <nl> + ErrorCollector collector = new ErrorCollector ( query ) ; <nl> + <nl> + StringBuilder builder = new StringBuilder ( ) ; <nl> + <nl> + Token from = new MockToken ( 1 , 0 , " ; " ) ; <nl> + Token to = new MockToken ( 1 , 0 , " ; " ) ; <nl> + Token offending = new MockToken ( 1 , 0 , " ; " ) ; <nl> + <nl> + collector . appendSnippet ( builder , from , to , offending ) ; <nl> + <nl> + String expected = " ( [ ; ] ) " ; <nl> + <nl> + assertEquals ( expected , builder . toString ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAppendSnippetWithOneLines ( ) <nl> + { <nl> + String query = " select * from users where user _ name = ' ' test ' ' ; " ; <nl> + <nl> + ErrorCollector collector = new ErrorCollector ( query ) ; <nl> + <nl> + StringBuilder builder = new StringBuilder ( ) ; <nl> + <nl> + Token from = new MockToken ( 1 , 25 , " " ) ; <nl> + Token to = new MockToken ( 1 , 46 , " ; " ) ; <nl> + Token offending = new MockToken ( 1 , 40 , " test " ) ; <nl> + <nl> + collector . appendSnippet ( builder , from , to , offending ) ; <nl> + <nl> + String expected = " ( . . . user _ name = ' ' [ test ] ' ' ; ) " ; <nl> + <nl> + assertEquals ( expected , builder . toString ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAppendSnippetOnSecondLine ( ) <nl> + { <nl> + String query = " select * from users \ n " + <nl> + " where user _ name = ' ' test ' ' ; " ; <nl> + <nl> + ErrorCollector collector = new ErrorCollector ( query ) ; <nl> + <nl> + StringBuilder builder = new StringBuilder ( ) ; <nl> + <nl> + Token from = new MockToken ( 2 , 5 , " " ) ; <nl> + Token to = new MockToken ( 2 , 26 , " ; " ) ; <nl> + Token offending = new MockToken ( 2 , 20 , " test " ) ; <nl> + <nl> + collector . appendSnippet ( builder , from , to , offending ) ; <nl> + <nl> + String expected = " ( . . . user _ name = ' ' [ test ] ' ' ; ) " ; <nl> + <nl> + assertEquals ( expected , builder . toString ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAppendSnippetWithSnippetOverTwoLines ( ) <nl> + { <nl> + String query = " select * from users where user _ name \ n " + <nl> + " = ' ' test ' ' ; " ; <nl> + <nl> + ErrorCollector collector = new ErrorCollector ( query ) ; <nl> + <nl> + StringBuilder builder = new StringBuilder ( ) ; <nl> + <nl> + Token from = new MockToken ( 1 , 20 , " where " ) ; <nl> + Token to = new MockToken ( 2 , 9 , " ' " ) ; <nl> + Token offending = new MockToken ( 2 , 4 , " test " ) ; <nl> + <nl> + collector . appendSnippet ( builder , from , to , offending ) ; <nl> + <nl> + String expected = " ( . . . where user _ name = ' ' [ test ] ' ' . . . ) " ; <nl> + <nl> + assertEquals ( expected , builder . toString ( ) ) ; <nl> + } <nl> + <nl> + private final static class MockToken implements Token <nl> + { <nl> + / * * <nl> + * The line number on which this token was matched ; line = 1 . . n <nl> + * / <nl> + private int line ; <nl> + <nl> + / * * <nl> + * The index of the first character relative to the beginning of the line 0 . . n - 1 <nl> + * / <nl> + private int charPositionInLine ; <nl> + <nl> + / * * <nl> + * The text of the token <nl> + * / <nl> + private String text ; <nl> + <nl> + public MockToken ( int line , int charPositionInLine , String text ) <nl> + { <nl> + this . line = line ; <nl> + this . charPositionInLine = charPositionInLine ; <nl> + this . text = text ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getChannel ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getCharPositionInLine ( ) <nl> + { <nl> + return charPositionInLine ; <nl> + } <nl> + <nl> + @ Override <nl> + public CharStream getInputStream ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getLine ( ) <nl> + { <nl> + return line ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getText ( ) <nl> + { <nl> + return text ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getTokenIndex ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int getType ( ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setChannel ( int channel ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setCharPositionInLine ( int charPositionInLine ) <nl> + { <nl> + this . charPositionInLine = charPositionInLine ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setInputStream ( CharStream inputStream ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setLine ( int line ) <nl> + { <nl> + this . line = line ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setText ( String text ) <nl> + { <nl> + this . text = text ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setTokenIndex ( int tokenIndex ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void setType ( int type ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / bin / nodeprobe b / bin / nodeprobe <nl> new file mode 100755 <nl> index 0000000 . . beb3c36 <nl> - - - / dev / null <nl> + + + b / bin / nodeprobe <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + # ! / bin / sh <nl> + # Licensed to the Apache Software Foundation ( ASF ) under one <nl> + # or more contributor license agreements . See the NOTICE file <nl> + # distributed with this work for additional information <nl> + # regarding copyright ownership . The ASF licenses this file <nl> + # to you under the Apache License , Version 2 . 0 ( the <nl> + # " License " ) ; you may not use this file except in compliance <nl> + # with the License . You may obtain a copy of the License at <nl> + # <nl> + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + # <nl> + # Unless required by applicable law or agreed to in writing , software <nl> + # distributed under the License is distributed on an " AS IS " BASIS , <nl> + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + # See the License for the specific language governing permissions and <nl> + # limitations under the License . <nl> + <nl> + <nl> + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then <nl> + for include in / usr / share / cassandra / cassandra . in . sh \ <nl> + / usr / local / share / cassandra / cassandra . in . sh \ <nl> + / opt / cassandra / cassandra . in . sh \ <nl> + ` dirname $ 0 ` / cassandra . in . sh ; do <nl> + if [ - r $ include ] ; then <nl> + . $ include <nl> + break <nl> + fi <nl> + done <nl> + elif [ - r $ CASSANDRA _ INCLUDE ] ; then <nl> + . $ CASSANDRA _ INCLUDE <nl> + fi <nl> + <nl> + if [ - z $ CASSANDRA _ CONF - o - z $ CLASSPATH ] ; then <nl> + echo " You must set the CASSANDRA _ CONF and CLASSPATH vars " > & 2 <nl> + exit 1 <nl> + fi <nl> + <nl> + # Special - case path variables . <nl> + case " ` uname ` " in <nl> + CYGWIN * ) <nl> + CLASSPATH = ` cygpath - p - w " $ CLASSPATH " ` <nl> + CASSANDRA _ CONF = ` cygpath - p - w " $ CASSANDRA _ CONF " ` <nl> + ; ; <nl> + esac <nl> + <nl> + java - cp $ CLASSPATH - Dstorage - config = $ CASSANDRA _ CONF \ <nl> + org . apache . cassandra . tools . NodeProbe $ @ <nl> + <nl> + # vi : ai sw = 4 ts = 4 tw = 0 et <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> new file mode 100644 <nl> index 0000000 . . b1acbb4 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 0 , 0 + 1 , 434 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . tools ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . io . PrintStream ; <nl> + import java . lang . management . ManagementFactory ; <nl> + import java . lang . management . MemoryMXBean ; <nl> + import java . lang . management . MemoryUsage ; <nl> + import java . lang . management . RuntimeMXBean ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import javax . management . JMX ; <nl> + import javax . management . MBeanServerConnection ; <nl> + import javax . management . MalformedObjectNameException ; <nl> + import javax . management . ObjectName ; <nl> + import javax . management . remote . JMXConnector ; <nl> + import javax . management . remote . JMXConnectorFactory ; <nl> + import javax . management . remote . JMXServiceURL ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . net . EndPoint ; <nl> + import org . apache . cassandra . service . StorageServiceMBean ; <nl> + import org . apache . commons . cli . CommandLine ; <nl> + import org . apache . commons . cli . CommandLineParser ; <nl> + import org . apache . commons . cli . HelpFormatter ; <nl> + import org . apache . commons . cli . Option ; <nl> + import org . apache . commons . cli . Options ; <nl> + import org . apache . commons . cli . ParseException ; <nl> + import org . apache . commons . cli . PosixParser ; <nl> + <nl> + / * * <nl> + * JMX client operations for Cassandra . <nl> + * / <nl> + public class NodeProbe <nl> + { <nl> + private static final String fmtUrl = " service : jmx : rmi : / / / jndi / rmi : / / % s : % d / jmxrmi " ; <nl> + private static final String ssObjName = " org . apache . cassandra . service : type = StorageService " ; <nl> + private static final String HOST _ OPTION = " host " ; <nl> + private static final String PORT _ OPTION = " port " ; <nl> + private static final int defaultPort = 8080 ; <nl> + private static Options options = null ; <nl> + private CommandLine cmd = null ; <nl> + private String host ; <nl> + private int port ; <nl> + <nl> + private MBeanServerConnection mbeanServerConn ; <nl> + private StorageServiceMBean ssProxy ; <nl> + private MemoryMXBean memProxy ; <nl> + private RuntimeMXBean runtimeProxy ; <nl> + <nl> + static <nl> + { <nl> + options = new Options ( ) ; <nl> + Option optHost = new Option ( HOST _ OPTION , true , " node hostname or ip address " ) ; <nl> + optHost . setRequired ( true ) ; <nl> + options . addOption ( optHost ) ; <nl> + options . addOption ( PORT _ OPTION , true , " remote jmx agent port number " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using command - line arguments . <nl> + * <nl> + * @ param cmdArgs list of arguments passed on the command line <nl> + * @ throws ParseException for missing required , or unrecognized options <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + private NodeProbe ( String [ ] cmdArgs ) throws ParseException , IOException <nl> + { <nl> + parseArgs ( cmdArgs ) ; <nl> + this . host = cmd . getOptionValue ( HOST _ OPTION ) ; <nl> + <nl> + String portNum = cmd . getOptionValue ( PORT _ OPTION ) ; <nl> + if ( portNum ! = null ) <nl> + { <nl> + try <nl> + { <nl> + this . port = Integer . parseInt ( portNum ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ParseException ( " Port must be a number " ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + this . port = defaultPort ; <nl> + } <nl> + <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using the specified JMX host and port . <nl> + * <nl> + * @ param host hostname or IP address of the JMX agent <nl> + * @ param port TCP port of the remote JMX agent <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + public NodeProbe ( String host , int port ) throws IOException <nl> + { <nl> + this . host = host ; <nl> + this . port = port ; <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using the specified JMX host and default port . <nl> + * <nl> + * @ param host hostname or IP address of the JMX agent <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + public NodeProbe ( String host ) throws IOException <nl> + { <nl> + this . host = host ; <nl> + this . port = defaultPort ; <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Create a connection to the JMX agent and setup the M [ X ] Bean proxies . <nl> + * <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + private void connect ( ) throws IOException <nl> + { <nl> + JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; <nl> + JMXConnector jmxc = JMXConnectorFactory . connect ( jmxUrl , null ) ; <nl> + mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; <nl> + <nl> + try <nl> + { <nl> + ObjectName name = new ObjectName ( ssObjName ) ; <nl> + ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; <nl> + } catch ( MalformedObjectNameException e ) <nl> + { <nl> + throw new RuntimeException ( <nl> + " Invalid ObjectName ? Please report this as a bug . " , e ) ; <nl> + } <nl> + <nl> + memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , <nl> + ManagementFactory . MEMORY _ MXBEAN _ NAME , MemoryMXBean . class ) ; <nl> + runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( <nl> + mbeanServerConn , ManagementFactory . RUNTIME _ MXBEAN _ NAME , RuntimeMXBean . class ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve a map of range to end points that describe the ring topology <nl> + * of a Cassandra cluster . <nl> + * <nl> + * @ return mapping of ranges to end points <nl> + * / <nl> + public Map < Range , List < EndPoint > > getRangeToEndpointMap ( ) <nl> + { <nl> + return ssProxy . getRangeToEndPointMap ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve the list of live nodes in the cluster , where " liveness " is <nl> + * determined by the failure detector of the node being queried . The <nl> + * returned string is a space delimited list of host : port end points . <nl> + * <nl> + * @ return space delimited list of nodes <nl> + * / <nl> + public String getLiveNodes ( ) <nl> + { <nl> + return ssProxy . getLiveNodes ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve the list of unreachable nodes in the cluster , as determined <nl> + * by this node ' s failure detector . The returned string is a space <nl> + * delimited list of host : port end points . <nl> + * <nl> + * @ return space delimited list of nodes <nl> + * / <nl> + public String getUnreachableNodes ( ) <nl> + { <nl> + return ssProxy . getUnreachableNodes ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Fetch a string representation of the token . <nl> + * <nl> + * @ return a string token <nl> + * / <nl> + public String getToken ( ) <nl> + { <nl> + return ssProxy . getToken ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return the generation value for this node . <nl> + * <nl> + * @ return generation number <nl> + * / <nl> + public int getCurrentGenerationNumber ( ) <nl> + { <nl> + return ssProxy . getCurrentGenerationNumber ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve a textual representation of the on - disk size of data <nl> + * stored on this node . <nl> + * <nl> + * @ return the size description <nl> + * / <nl> + public String getLoadInfo ( ) <nl> + { <nl> + return ssProxy . getLoadInfo ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Trigger a cleanup of keys on all tables . <nl> + * / <nl> + public void forceTableCleanup ( ) <nl> + { <nl> + ssProxy . forceTableCleanup ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Trigger compaction of all tables . <nl> + * / <nl> + public void forceTableCompaction ( ) <nl> + { <nl> + ssProxy . forceTableCompaction ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Write a textual representation of the Cassandra ring . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printRing ( PrintStream outs ) <nl> + { <nl> + Map < Range , List < EndPoint > > rangeMap = getRangeToEndpointMap ( ) ; <nl> + <nl> + / / Print range - to - endpoint mapping <nl> + int counter = 0 ; <nl> + for ( Range range : rangeMap . keySet ( ) ) { <nl> + List < EndPoint > endpoints = rangeMap . get ( range ) ; <nl> + <nl> + outs . print ( String . format ( " % - 46s " , range . left ( ) ) ) ; <nl> + outs . print ( String . format ( " % 2d " , endpoints . size ( ) ) ) ; <nl> + outs . print ( String . format ( " % - 15s " , endpoints . get ( 0 ) . getHost ( ) ) ) ; <nl> + <nl> + String asciiRingArt ; <nl> + if ( counter = = 0 ) <nl> + { <nl> + asciiRingArt = " | < - - | " ; <nl> + } <nl> + else if ( counter = = ( rangeMap . size ( ) - 1 ) ) <nl> + { <nl> + asciiRingArt = " | - - > | " ; <nl> + } <nl> + else <nl> + { <nl> + if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) = = 0 ) ) <nl> + { <nl> + asciiRingArt = " v | " ; <nl> + } <nl> + else if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) ! = 0 ) ) <nl> + { <nl> + asciiRingArt = " | ^ " ; <nl> + } <nl> + else <nl> + { <nl> + asciiRingArt = " | | " ; <nl> + } <nl> + } <nl> + outs . println ( asciiRingArt ) ; <nl> + <nl> + counter + + ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Write a list of nodes with corresponding status . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printCluster ( PrintStream outs ) <nl> + { <nl> + for ( String upNode : getLiveNodes ( ) . split ( " \ \ s + " ) ) <nl> + { <nl> + if ( upNode . length ( ) > 0 ) <nl> + { <nl> + outs . println ( String . format ( " % - 21s up " , upNode ) ) ; <nl> + } <nl> + } <nl> + <nl> + for ( String downNode : getUnreachableNodes ( ) . split ( " \ \ s + " ) ) <nl> + { <nl> + if ( downNode . length ( ) > 0 ) <nl> + { <nl> + outs . println ( String . format ( " % - 21s down " , downNode ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Write node information . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printInfo ( PrintStream outs ) <nl> + { <nl> + outs . println ( getToken ( ) ) ; <nl> + outs . println ( String . format ( " % - 17s : % s " , " Load Info " , getLoadInfo ( ) ) ) ; <nl> + outs . println ( String . format ( " % - 17s : % s " , " Generation No " , getCurrentGenerationNumber ( ) ) ) ; <nl> + <nl> + / / Uptime <nl> + long secondsUp = runtimeProxy . getUptime ( ) / 1000 ; <nl> + outs . println ( String . format ( " % - 17s : % d " , " Uptime ( seconds ) " , secondsUp ) ) ; <nl> + <nl> + / / Memory usage <nl> + MemoryUsage heapUsage = memProxy . getHeapMemoryUsage ( ) ; <nl> + double memUsed = ( double ) heapUsage . getUsed ( ) / ( 1024 * 1024 ) ; <nl> + double memMax = ( double ) heapUsage . getMax ( ) / ( 1024 * 1024 ) ; <nl> + outs . println ( String . format ( " % - 17s : % . 2f / % . 2f " , " Heap Memory ( MB ) " , memUsed , memMax ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve any non - option arguments passed on the command line . <nl> + * <nl> + * @ return non - option command args <nl> + * / <nl> + private String [ ] getArgs ( ) <nl> + { <nl> + return cmd . getArgs ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Parse the supplied command line arguments . <nl> + * <nl> + * @ param args arguments passed on the command line <nl> + * @ throws ParseException for missing required , or unrecognized options <nl> + * / <nl> + private void parseArgs ( String [ ] args ) throws ParseException <nl> + { <nl> + CommandLineParser parser = new PosixParser ( ) ; <nl> + cmd = parser . parse ( options , args ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Prints usage information to stdout . <nl> + * / <nl> + private static void printUsage ( ) <nl> + { <nl> + HelpFormatter hf = new HelpFormatter ( ) ; <nl> + String header = String . format ( <nl> + " % nAvailable commands : ring , cluster , info , cleanup , compact " ) ; <nl> + String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; <nl> + hf . printHelp ( usage , " " , options , header ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ param args <nl> + * / <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + NodeProbe probe = null ; <nl> + try <nl> + { <nl> + probe = new NodeProbe ( args ) ; <nl> + } <nl> + catch ( ParseException pe ) <nl> + { <nl> + System . err . println ( pe . getMessage ( ) ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + catch ( IOException ioe ) <nl> + { <nl> + System . err . println ( " Error connecting to remote JMX agent ! " ) ; <nl> + ioe . printStackTrace ( ) ; <nl> + System . exit ( 3 ) ; <nl> + } <nl> + <nl> + if ( probe . getArgs ( ) . length < 1 ) <nl> + { <nl> + System . err . println ( " Missing argument for command . " ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + / / Execute the requested command . <nl> + String cmdName = probe . getArgs ( ) [ 0 ] ; <nl> + if ( cmdName . equals ( " ring " ) ) <nl> + { <nl> + probe . printRing ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " cluster " ) ) <nl> + { <nl> + probe . printCluster ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " info " ) ) <nl> + { <nl> + probe . printInfo ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " cleanup " ) ) <nl> + { <nl> + probe . forceTableCleanup ( ) ; <nl> + } <nl> + else if ( cmdName . equals ( " compact " ) ) <nl> + { <nl> + probe . forceTableCompaction ( ) ; <nl> + } <nl> + else <nl> + { <nl> + System . err . println ( " Unrecognized command : " + cmdName + " . " ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + System . exit ( 0 ) ; <nl> + } <nl> + <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1781ef3 . . 89f9b7c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 6 , 6 + 6 , 7 @ @ 
 * Adjust MT depth based on # of partition validating ( CASSANDRA - 5263 ) 
 * Optimise NativeCell comparisons ( CASSANDRA - 6755 ) 
 * Configurable client timeout for cqlsh ( CASSANDRA - 7516 ) 
 + * Include snippet of CQL query near syntax error in messages ( CASSANDRA - 7111 ) 
 
 
 2 . 1 . 0 - final 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index 948cd5e . . 9dcc268 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 51 , 7 + 51 , 7 @ @ options { 
 } 
 
 @ members { 
 - private final List < String > recognitionErrors = new ArrayList < String > ( ) ; 
 + private final List < ErrorListener > listeners = new ArrayList < ErrorListener > ( ) ; 
 private final List < ColumnIdentifier > bindVariables = new ArrayList < ColumnIdentifier > ( ) ; 
 
 public static final Set < String > reservedTypeNames = new HashSet < String > ( ) 
 @ @ - 94 , 27 + 94 , 26 @ @ options { 
 return marker ; 
 } 
 
 - public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) 
 + public void addErrorListener ( ErrorListener listener ) 
 { 
 - String hdr = getErrorHeader ( e ) ; 
 - String msg = getErrorMessage ( e , tokenNames ) ; 
 - recognitionErrors . add ( hdr + " " + msg ) ; 
 + this . listeners . add ( listener ) ; 
 } 
 
 - public void addRecognitionError ( String msg ) 
 + public void removeErrorListener ( ErrorListener listener ) 
 { 
 - recognitionErrors . add ( msg ) ; 
 + this . listeners . remove ( listener ) ; 
 } 
 
 - public List < String > getRecognitionErrors ( ) 
 + public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) 
 { 
 - return recognitionErrors ; 
 + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) 
 + listeners . get ( i ) . syntaxError ( this , tokenNames , e ) ; 
 } 
 
 - public void throwLastRecognitionError ( ) throws SyntaxException 
 + private void addRecognitionError ( String msg ) 
 { 
 - if ( recognitionErrors . size ( ) > 0 ) 
 - throw new SyntaxException ( recognitionErrors . get ( ( recognitionErrors . size ( ) - 1 ) ) ) ; 
 + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) 
 + listeners . get ( i ) . syntaxError ( this , msg ) ; 
 } 
 
 public Map < String , String > convertPropertyMap ( Maps . Literal map ) 
 @ @ - 189 , 24 + 188 , 22 @ @ options { 
 return tokens . remove ( 0 ) ; 
 } 
 
 - private List < String > recognitionErrors = new ArrayList < String > ( ) ; 
 + private final List < ErrorListener > listeners = new ArrayList < ErrorListener > ( ) ; 
 
 - public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) 
 + public void addErrorListener ( ErrorListener listener ) 
 { 
 - String hdr = getErrorHeader ( e ) ; 
 - String msg = getErrorMessage ( e , tokenNames ) ; 
 - recognitionErrors . add ( hdr + " " + msg ) ; 
 + this . listeners . add ( listener ) ; 
 } 
 
 - public List < String > getRecognitionErrors ( ) 
 + public void removeErrorListener ( ErrorListener listener ) 
 { 
 - return recognitionErrors ; 
 + this . listeners . remove ( listener ) ; 
 } 
 
 - public void throwLastRecognitionError ( ) throws SyntaxException 
 + public void displayRecognitionError ( String [ ] tokenNames , RecognitionException e ) 
 { 
 - if ( recognitionErrors . size ( ) > 0 ) 
 - throw new SyntaxException ( recognitionErrors . get ( ( recognitionErrors . size ( ) - 1 ) ) ) ; 
 + for ( int i = 0 , m = listeners . size ( ) ; i < m ; i + + ) 
 + listeners . get ( i ) . syntaxError ( this , tokenNames , e ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ErrorCollector . java b / src / java / org / apache / cassandra / cql3 / ErrorCollector . java 
 new file mode 100644 
 index 0000000 . . 41536f5 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / ErrorCollector . java 
 @ @ - 0 , 0 + 1 , 242 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import java . util . LinkedList ; 
 + 
 + import org . antlr . runtime . BaseRecognizer ; 
 + import org . antlr . runtime . Parser ; 
 + import org . antlr . runtime . RecognitionException ; 
 + import org . antlr . runtime . Token ; 
 + import org . antlr . runtime . TokenStream ; 
 + import org . apache . cassandra . exceptions . SyntaxException ; 
 + 
 + / * * 
 + * < code > ErrorListener < / code > that collect and enhance the errors send by the CQL lexer and parser . 
 + * / 
 + public final class ErrorCollector implements ErrorListener 
 + { 
 + / * * 
 + * The offset of the first token of the snippet . 
 + * / 
 + private static final int FIRST _ TOKEN _ OFFSET = 10 ; 
 + 
 + / * * 
 + * The offset of the last token of the snippet . 
 + * / 
 + private static final int LAST _ TOKEN _ OFFSET = 2 ; 
 + 
 + / * * 
 + * The CQL query . 
 + * / 
 + private final String query ; 
 + 
 + / * * 
 + * The error messages . 
 + * / 
 + private final LinkedList < String > errorMsgs = new LinkedList < > ( ) ; 
 + 
 + / * * 
 + * Creates a new < code > ErrorCollector < / code > instance to collect the syntax errors associated to the specified CQL 
 + * query . 
 + * 
 + * @ param query the CQL query that will be parsed 
 + * / 
 + public ErrorCollector ( String query ) 
 + { 
 + this . query = query ; 
 + } 
 + 
 + / * * 
 + * { @ inheritDoc } 
 + * / 
 + @ Override 
 + public void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) 
 + { 
 + String hdr = recognizer . getErrorHeader ( e ) ; 
 + String msg = recognizer . getErrorMessage ( e , tokenNames ) ; 
 + 
 + StringBuilder builder = new StringBuilder ( ) . append ( hdr ) 
 + . append ( ' ' ) 
 + . append ( msg ) ; 
 + 
 + if ( recognizer instanceof Parser ) 
 + appendQuerySnippet ( ( Parser ) recognizer , builder ) ; 
 + 
 + errorMsgs . add ( builder . toString ( ) ) ; 
 + } 
 + 
 + / * * 
 + * { @ inheritDoc } 
 + * / 
 + @ Override 
 + public void syntaxError ( BaseRecognizer recognizer , String errorMsg ) 
 + { 
 + errorMsgs . add ( errorMsg ) ; 
 + } 
 + 
 + / * * 
 + * Throws the last syntax error found by the lexer or the parser if it exists . 
 + * 
 + * @ throws SyntaxException the syntax error . 
 + * / 
 + public void throwLastSyntaxError ( ) throws SyntaxException 
 + { 
 + if ( ! errorMsgs . isEmpty ( ) ) 
 + throw new SyntaxException ( errorMsgs . getLast ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Appends a query snippet to the message to help the user to understand the problem . 
 + * 
 + * @ param parser the parser used to parse the query 
 + * @ param builder the < code > StringBuilder < / code > used to build the error message 
 + * / 
 + private void appendQuerySnippet ( Parser parser , StringBuilder builder ) 
 + { 
 + TokenStream tokenStream = parser . getTokenStream ( ) ; 
 + int index = tokenStream . index ( ) ; 
 + int size = tokenStream . size ( ) ; 
 + 
 + Token from = tokenStream . get ( getSnippetFirstTokenIndex ( index ) ) ; 
 + Token to = tokenStream . get ( getSnippetLastTokenIndex ( index , size ) ) ; 
 + Token offending = tokenStream . get ( index ) ; 
 + 
 + appendSnippet ( builder , from , to , offending ) ; 
 + } 
 + 
 + / * * 
 + * Appends a query snippet to the message to help the user to understand the problem . 
 + * 
 + * @ param from the first token to include within the snippet 
 + * @ param to the last token to include within the snippet 
 + * @ param offending the token which is responsible for the error 
 + * / 
 + final void appendSnippet ( StringBuilder builder , 
 + Token from , 
 + Token to , 
 + Token offending ) 
 + { 
 + String [ ] lines = query . split ( " \ n " ) ; 
 + 
 + boolean includeQueryStart = ( from . getLine ( ) = = 1 ) & & ( from . getCharPositionInLine ( ) = = 0 ) ; 
 + boolean includeQueryEnd = ( to . getLine ( ) = = lines . length ) 
 + & & ( getLastCharPositionInLine ( to ) = = lines [ lines . length - 1 ] . length ( ) ) ; 
 + 
 + builder . append ( " ( " ) ; 
 + 
 + if ( ! includeQueryStart ) 
 + builder . append ( " . . . " ) ; 
 + 
 + lines [ lineIndex ( to ) ] = lines [ lineIndex ( to ) ] . substring ( 0 , getLastCharPositionInLine ( to ) ) ; 
 + lines [ lineIndex ( offending ) ] = highlightToken ( lines [ lineIndex ( offending ) ] , offending ) ; 
 + lines [ lineIndex ( from ) ] = lines [ lineIndex ( from ) ] . substring ( from . getCharPositionInLine ( ) ) ; 
 + 
 + for ( int i = lineIndex ( from ) , m = lineIndex ( to ) ; i < = m ; i + + ) 
 + builder . append ( lines [ i ] ) ; 
 + 
 + if ( ! includeQueryEnd ) 
 + builder . append ( " . . . " ) ; 
 + 
 + builder . append ( " ) " ) ; 
 + } 
 + 
 + / * * 
 + * Puts the specified token within square brackets . 
 + * 
 + * @ param line the line containing the token 
 + * @ param token the token to put within square brackets 
 + * / 
 + private static String highlightToken ( String line , Token token ) 
 + { 
 + String newLine = insertChar ( line , getLastCharPositionInLine ( token ) , ' ] ' ) ; 
 + return insertChar ( newLine , token . getCharPositionInLine ( ) , ' [ ' ) ; 
 + } 
 + 
 + / * * 
 + * Returns the index of the last character relative to the beginning of the line 0 . . n - 1 
 + * 
 + * @ param token the token 
 + * @ return the index of the last character relative to the beginning of the line 0 . . n - 1 
 + * / 
 + private static int getLastCharPositionInLine ( Token token ) 
 + { 
 + return token . getCharPositionInLine ( ) + getLength ( token ) ; 
 + } 
 + 
 + / * * 
 + * Return the token length . 
 + * 
 + * @ param token the token 
 + * @ return the token length 
 + * / 
 + private static int getLength ( Token token ) 
 + { 
 + return token . getText ( ) . length ( ) ; 
 + } 
 + 
 + / * * 
 + * Inserts a character at a given position within a < code > String < / code > . 
 + * 
 + * @ param s the < code > String < / code > in which the character must be inserted 
 + * @ param index the position where the character must be inserted 
 + * @ param c the character to insert 
 + * @ return the modified < code > String < / code > 
 + * / 
 + private static String insertChar ( String s , int index , char c ) 
 + { 
 + return new StringBuilder ( ) . append ( s . substring ( 0 , index ) ) 
 + . append ( c ) 
 + . append ( s . substring ( index ) ) 
 + . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Returns the index of the line number on which this token was matched ; index = 0 . . n - 1 
 + * 
 + * @ param token the token 
 + * @ return the index of the line number on which this token was matched ; index = 0 . . n - 1 
 + * / 
 + private static int lineIndex ( Token token ) 
 + { 
 + return token . getLine ( ) - 1 ; 
 + } 
 + 
 + / * * 
 + * Returns the index of the last token which is part of the snippet . 
 + * 
 + * @ param index the index of the token causing the error 
 + * @ param size the total number of tokens 
 + * @ return the index of the last token which is part of the snippet . 
 + * / 
 + private static int getSnippetLastTokenIndex ( int index , int size ) 
 + { 
 + return Math . min ( size - 1 , index + LAST _ TOKEN _ OFFSET ) ; 
 + } 
 + 
 + / * * 
 + * Returns the index of the first token which is part of the snippet . 
 + * 
 + * @ param index the index of the token causing the error 
 + * @ return the index of the first token which is part of the snippet . 
 + * / 
 + private static int getSnippetFirstTokenIndex ( int index ) 
 + { 
 + return Math . max ( 0 , index - FIRST _ TOKEN _ OFFSET ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ErrorListener . java b / src / java / org / apache / cassandra / cql3 / ErrorListener . java 
 new file mode 100644 
 index 0000000 . . 0bf891a 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / ErrorListener . java 
 @ @ - 0 , 0 + 1 , 44 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . antlr . runtime . BaseRecognizer ; 
 + import org . antlr . runtime . RecognitionException ; 
 + 
 + / * * 
 + * Listener used to collect the syntax errors emitted by the Lexer and Parser . 
 + * / 
 + public interface ErrorListener 
 + { 
 + / * * 
 + * Invoked when a syntax error occurs . 
 + * 
 + * @ param recognizer the parser or lexer that emitted the error 
 + * @ param tokenNames the token names 
 + * @ param e the exception 
 + * / 
 + void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) ; 
 + 
 + / * * 
 + * Invoked when a syntax error with a specified message occurs . 
 + * 
 + * @ param recognizer the parser or lexer that emitted the error 
 + * @ param errorMsg the error message 
 + * / 
 + void syntaxError ( BaseRecognizer recognizer , String errorMsg ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 86362f7 . . 4994342 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 442 , 18 + 442 , 21 @ @ public class QueryProcessor implements QueryHandler 
 try 
 { 
 / / Lexer and parser 
 + ErrorCollector errorCollector = new ErrorCollector ( queryStr ) ; 
 CharStream stream = new ANTLRStringStream ( queryStr ) ; 
 CqlLexer lexer = new CqlLexer ( stream ) ; 
 + lexer . addErrorListener ( errorCollector ) ; 
 + 
 TokenStream tokenStream = new CommonTokenStream ( lexer ) ; 
 CqlParser parser = new CqlParser ( tokenStream ) ; 
 + parser . addErrorListener ( errorCollector ) ; 
 
 / / Parse the query string to a statement instance 
 ParsedStatement statement = parser . query ( ) ; 
 
 - / / The lexer and parser queue up any errors they may have encountered 
 - / / along the way , if necessary , we turn them into exceptions here . 
 - lexer . throwLastRecognitionError ( ) ; 
 - parser . throwLastRecognitionError ( ) ; 
 + / / The errorCollector has queue up any errors that the lexer and parser may have encountered 
 + / / along the way , if necessary , we turn the last error into exceptions here . 
 + errorCollector . throwLastSyntaxError ( ) ; 
 
 return statement ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java b / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java 
 new file mode 100644 
 index 0000000 . . d122eb5 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / CqlParserTest . java 
 @ @ - 0 , 0 + 1 , 90 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . antlr . runtime . ANTLRStringStream ; 
 + import org . antlr . runtime . BaseRecognizer ; 
 + import org . antlr . runtime . CharStream ; 
 + import org . antlr . runtime . CommonTokenStream ; 
 + import org . antlr . runtime . RecognitionException ; 
 + import org . antlr . runtime . TokenStream ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + public class CqlParserTest 
 + { 
 + @ Test 
 + public void testAddErrorListener ( ) throws Exception 
 + { 
 + SyntaxErrorCounter firstCounter = new SyntaxErrorCounter ( ) ; 
 + SyntaxErrorCounter secondCounter = new SyntaxErrorCounter ( ) ; 
 + 
 + CharStream stream = new ANTLRStringStream ( " SELECT * FORM test ; " ) ; 
 + CqlLexer lexer = new CqlLexer ( stream ) ; 
 + 
 + TokenStream tokenStream = new CommonTokenStream ( lexer ) ; 
 + CqlParser parser = new CqlParser ( tokenStream ) ; 
 + parser . addErrorListener ( firstCounter ) ; 
 + parser . addErrorListener ( secondCounter ) ; 
 + 
 + parser . query ( ) ; 
 + 
 + assertEquals ( 1 , firstCounter . count ) ; 
 + assertEquals ( 1 , secondCounter . count ) ; 
 + } 
 + 
 + @ Test 
 + public void testRemoveErrorListener ( ) throws Exception 
 + { 
 + SyntaxErrorCounter firstCounter = new SyntaxErrorCounter ( ) ; 
 + SyntaxErrorCounter secondCounter = new SyntaxErrorCounter ( ) ; 
 + 
 + CharStream stream = new ANTLRStringStream ( " SELECT * FORM test ; " ) ; 
 + CqlLexer lexer = new CqlLexer ( stream ) ; 
 + 
 + TokenStream tokenStream = new CommonTokenStream ( lexer ) ; 
 + CqlParser parser = new CqlParser ( tokenStream ) ; 
 + parser . addErrorListener ( firstCounter ) ; 
 + parser . addErrorListener ( secondCounter ) ; 
 + parser . removeErrorListener ( secondCounter ) ; 
 + 
 + parser . query ( ) ; 
 + 
 + assertEquals ( 1 , firstCounter . count ) ; 
 + assertEquals ( 0 , secondCounter . count ) ; 
 + } 
 + 
 + private static final class SyntaxErrorCounter implements ErrorListener 
 + { 
 + private int count ; 
 + 
 + @ Override 
 + public void syntaxError ( BaseRecognizer recognizer , String [ ] tokenNames , RecognitionException e ) 
 + { 
 + count + + ; 
 + } 
 + 
 + @ Override 
 + public void syntaxError ( BaseRecognizer recognizer , String errorMsg ) 
 + { 
 + count + + ; 
 + } 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java b / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java 
 new file mode 100644 
 index 0000000 . . 4f5db34 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / ErrorCollectorTest . java 
 @ @ - 0 , 0 + 1 , 218 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . antlr . runtime . CharStream ; 
 + import org . antlr . runtime . Token ; 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + 
 + public class ErrorCollectorTest 
 + { 
 + @ Test 
 + public void testAppendSnippetWithEmptyQuery ( ) 
 + { 
 + String query = " ; " ; 
 + 
 + ErrorCollector collector = new ErrorCollector ( query ) ; 
 + 
 + StringBuilder builder = new StringBuilder ( ) ; 
 + 
 + Token from = new MockToken ( 1 , 0 , " ; " ) ; 
 + Token to = new MockToken ( 1 , 0 , " ; " ) ; 
 + Token offending = new MockToken ( 1 , 0 , " ; " ) ; 
 + 
 + collector . appendSnippet ( builder , from , to , offending ) ; 
 + 
 + String expected = " ( [ ; ] ) " ; 
 + 
 + assertEquals ( expected , builder . toString ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAppendSnippetWithOneLines ( ) 
 + { 
 + String query = " select * from users where user _ name = ' ' test ' ' ; " ; 
 + 
 + ErrorCollector collector = new ErrorCollector ( query ) ; 
 + 
 + StringBuilder builder = new StringBuilder ( ) ; 
 + 
 + Token from = new MockToken ( 1 , 25 , " " ) ; 
 + Token to = new MockToken ( 1 , 46 , " ; " ) ; 
 + Token offending = new MockToken ( 1 , 40 , " test " ) ; 
 + 
 + collector . appendSnippet ( builder , from , to , offending ) ; 
 + 
 + String expected = " ( . . . user _ name = ' ' [ test ] ' ' ; ) " ; 
 + 
 + assertEquals ( expected , builder . toString ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAppendSnippetOnSecondLine ( ) 
 + { 
 + String query = " select * from users \ n " + 
 + " where user _ name = ' ' test ' ' ; " ; 
 + 
 + ErrorCollector collector = new ErrorCollector ( query ) ; 
 + 
 + StringBuilder builder = new StringBuilder ( ) ; 
 + 
 + Token from = new MockToken ( 2 , 5 , " " ) ; 
 + Token to = new MockToken ( 2 , 26 , " ; " ) ; 
 + Token offending = new MockToken ( 2 , 20 , " test " ) ; 
 + 
 + collector . appendSnippet ( builder , from , to , offending ) ; 
 + 
 + String expected = " ( . . . user _ name = ' ' [ test ] ' ' ; ) " ; 
 + 
 + assertEquals ( expected , builder . toString ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testAppendSnippetWithSnippetOverTwoLines ( ) 
 + { 
 + String query = " select * from users where user _ name \ n " + 
 + " = ' ' test ' ' ; " ; 
 + 
 + ErrorCollector collector = new ErrorCollector ( query ) ; 
 + 
 + StringBuilder builder = new StringBuilder ( ) ; 
 + 
 + Token from = new MockToken ( 1 , 20 , " where " ) ; 
 + Token to = new MockToken ( 2 , 9 , " ' " ) ; 
 + Token offending = new MockToken ( 2 , 4 , " test " ) ; 
 + 
 + collector . appendSnippet ( builder , from , to , offending ) ; 
 + 
 + String expected = " ( . . . where user _ name = ' ' [ test ] ' ' . . . ) " ; 
 + 
 + assertEquals ( expected , builder . toString ( ) ) ; 
 + } 
 + 
 + private final static class MockToken implements Token 
 + { 
 + / * * 
 + * The line number on which this token was matched ; line = 1 . . n 
 + * / 
 + private int line ; 
 + 
 + / * * 
 + * The index of the first character relative to the beginning of the line 0 . . n - 1 
 + * / 
 + private int charPositionInLine ; 
 + 
 + / * * 
 + * The text of the token 
 + * / 
 + private String text ; 
 + 
 + public MockToken ( int line , int charPositionInLine , String text ) 
 + { 
 + this . line = line ; 
 + this . charPositionInLine = charPositionInLine ; 
 + this . text = text ; 
 + } 
 + 
 + @ Override 
 + public int getChannel ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public int getCharPositionInLine ( ) 
 + { 
 + return charPositionInLine ; 
 + } 
 + 
 + @ Override 
 + public CharStream getInputStream ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public int getLine ( ) 
 + { 
 + return line ; 
 + } 
 + 
 + @ Override 
 + public String getText ( ) 
 + { 
 + return text ; 
 + } 
 + 
 + @ Override 
 + public int getTokenIndex ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public int getType ( ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public void setChannel ( int channel ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public void setCharPositionInLine ( int charPositionInLine ) 
 + { 
 + this . charPositionInLine = charPositionInLine ; 
 + } 
 + 
 + @ Override 
 + public void setInputStream ( CharStream inputStream ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public void setLine ( int line ) 
 + { 
 + this . line = line ; 
 + } 
 + 
 + @ Override 
 + public void setText ( String text ) 
 + { 
 + this . text = text ; 
 + } 
 + 
 + @ Override 
 + public void setTokenIndex ( int tokenIndex ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public void setType ( int type ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / bin / nodeprobe b / bin / nodeprobe 
 new file mode 100755 
 index 0000000 . . beb3c36 
 - - - / dev / null 
 + + + b / bin / nodeprobe 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + # ! / bin / sh 
 + # Licensed to the Apache Software Foundation ( ASF ) under one 
 + # or more contributor license agreements . See the NOTICE file 
 + # distributed with this work for additional information 
 + # regarding copyright ownership . The ASF licenses this file 
 + # to you under the Apache License , Version 2 . 0 ( the 
 + # " License " ) ; you may not use this file except in compliance 
 + # with the License . You may obtain a copy of the License at 
 + # 
 + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + # 
 + # Unless required by applicable law or agreed to in writing , software 
 + # distributed under the License is distributed on an " AS IS " BASIS , 
 + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + # See the License for the specific language governing permissions and 
 + # limitations under the License . 
 + 
 + 
 + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then 
 + for include in / usr / share / cassandra / cassandra . in . sh \ 
 + / usr / local / share / cassandra / cassandra . in . sh \ 
 + / opt / cassandra / cassandra . in . sh \ 
 + ` dirname $ 0 ` / cassandra . in . sh ; do 
 + if [ - r $ include ] ; then 
 + . $ include 
 + break 
 + fi 
 + done 
 + elif [ - r $ CASSANDRA _ INCLUDE ] ; then 
 + . $ CASSANDRA _ INCLUDE 
 + fi 
 + 
 + if [ - z $ CASSANDRA _ CONF - o - z $ CLASSPATH ] ; then 
 + echo " You must set the CASSANDRA _ CONF and CLASSPATH vars " > & 2 
 + exit 1 
 + fi 
 + 
 + # Special - case path variables . 
 + case " ` uname ` " in 
 + CYGWIN * ) 
 + CLASSPATH = ` cygpath - p - w " $ CLASSPATH " ` 
 + CASSANDRA _ CONF = ` cygpath - p - w " $ CASSANDRA _ CONF " ` 
 + ; ; 
 + esac 
 + 
 + java - cp $ CLASSPATH - Dstorage - config = $ CASSANDRA _ CONF \ 
 + org . apache . cassandra . tools . NodeProbe $ @ 
 + 
 + # vi : ai sw = 4 ts = 4 tw = 0 et 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 new file mode 100644 
 index 0000000 . . b1acbb4 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 0 , 0 + 1 , 434 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . tools ; 
 + 
 + import java . io . IOException ; 
 + import java . io . PrintStream ; 
 + import java . lang . management . ManagementFactory ; 
 + import java . lang . management . MemoryMXBean ; 
 + import java . lang . management . MemoryUsage ; 
 + import java . lang . management . RuntimeMXBean ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import javax . management . JMX ; 
 + import javax . management . MBeanServerConnection ; 
 + import javax . management . MalformedObjectNameException ; 
 + import javax . management . ObjectName ; 
 + import javax . management . remote . JMXConnector ; 
 + import javax . management . remote . JMXConnectorFactory ; 
 + import javax . management . remote . JMXServiceURL ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . net . EndPoint ; 
 + import org . apache . cassandra . service . StorageServiceMBean ; 
 + import org . apache . commons . cli . CommandLine ; 
 + import org . apache . commons . cli . CommandLineParser ; 
 + import org . apache . commons . cli . HelpFormatter ; 
 + import org . apache . commons . cli . Option ; 
 + import org . apache . commons . cli . Options ; 
 + import org . apache . commons . cli . ParseException ; 
 + import org . apache . commons . cli . PosixParser ; 
 + 
 + / * * 
 + * JMX client operations for Cassandra . 
 + * / 
 + public class NodeProbe 
 + { 
 + private static final String fmtUrl = " service : jmx : rmi : / / / jndi / rmi : / / % s : % d / jmxrmi " ; 
 + private static final String ssObjName = " org . apache . cassandra . service : type = StorageService " ; 
 + private static final String HOST _ OPTION = " host " ; 
 + private static final String PORT _ OPTION = " port " ; 
 + private static final int defaultPort = 8080 ; 
 + private static Options options = null ; 
 + private CommandLine cmd = null ; 
 + private String host ; 
 + private int port ; 
 + 
 + private MBeanServerConnection mbeanServerConn ; 
 + private StorageServiceMBean ssProxy ; 
 + private MemoryMXBean memProxy ; 
 + private RuntimeMXBean runtimeProxy ; 
 + 
 + static 
 + { 
 + options = new Options ( ) ; 
 + Option optHost = new Option ( HOST _ OPTION , true , " node hostname or ip address " ) ; 
 + optHost . setRequired ( true ) ; 
 + options . addOption ( optHost ) ; 
 + options . addOption ( PORT _ OPTION , true , " remote jmx agent port number " ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using command - line arguments . 
 + * 
 + * @ param cmdArgs list of arguments passed on the command line 
 + * @ throws ParseException for missing required , or unrecognized options 
 + * @ throws IOException on connection failures 
 + * / 
 + private NodeProbe ( String [ ] cmdArgs ) throws ParseException , IOException 
 + { 
 + parseArgs ( cmdArgs ) ; 
 + this . host = cmd . getOptionValue ( HOST _ OPTION ) ; 
 + 
 + String portNum = cmd . getOptionValue ( PORT _ OPTION ) ; 
 + if ( portNum ! = null ) 
 + { 
 + try 
 + { 
 + this . port = Integer . parseInt ( portNum ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ParseException ( " Port must be a number " ) ; 
 + } 
 + } 
 + else 
 + { 
 + this . port = defaultPort ; 
 + } 
 + 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using the specified JMX host and port . 
 + * 
 + * @ param host hostname or IP address of the JMX agent 
 + * @ param port TCP port of the remote JMX agent 
 + * @ throws IOException on connection failures 
 + * / 
 + public NodeProbe ( String host , int port ) throws IOException 
 + { 
 + this . host = host ; 
 + this . port = port ; 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using the specified JMX host and default port . 
 + * 
 + * @ param host hostname or IP address of the JMX agent 
 + * @ throws IOException on connection failures 
 + * / 
 + public NodeProbe ( String host ) throws IOException 
 + { 
 + this . host = host ; 
 + this . port = defaultPort ; 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Create a connection to the JMX agent and setup the M [ X ] Bean proxies . 
 + * 
 + * @ throws IOException on connection failures 
 + * / 
 + private void connect ( ) throws IOException 
 + { 
 + JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; 
 + JMXConnector jmxc = JMXConnectorFactory . connect ( jmxUrl , null ) ; 
 + mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; 
 + 
 + try 
 + { 
 + ObjectName name = new ObjectName ( ssObjName ) ; 
 + ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; 
 + } catch ( MalformedObjectNameException e ) 
 + { 
 + throw new RuntimeException ( 
 + " Invalid ObjectName ? Please report this as a bug . " , e ) ; 
 + } 
 + 
 + memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , 
 + ManagementFactory . MEMORY _ MXBEAN _ NAME , MemoryMXBean . class ) ; 
 + runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( 
 + mbeanServerConn , ManagementFactory . RUNTIME _ MXBEAN _ NAME , RuntimeMXBean . class ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve a map of range to end points that describe the ring topology 
 + * of a Cassandra cluster . 
 + * 
 + * @ return mapping of ranges to end points 
 + * / 
 + public Map < Range , List < EndPoint > > getRangeToEndpointMap ( ) 
 + { 
 + return ssProxy . getRangeToEndPointMap ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve the list of live nodes in the cluster , where " liveness " is 
 + * determined by the failure detector of the node being queried . The 
 + * returned string is a space delimited list of host : port end points . 
 + * 
 + * @ return space delimited list of nodes 
 + * / 
 + public String getLiveNodes ( ) 
 + { 
 + return ssProxy . getLiveNodes ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve the list of unreachable nodes in the cluster , as determined 
 + * by this node ' s failure detector . The returned string is a space 
 + * delimited list of host : port end points . 
 + * 
 + * @ return space delimited list of nodes 
 + * / 
 + public String getUnreachableNodes ( ) 
 + { 
 + return ssProxy . getUnreachableNodes ( ) ; 
 + } 
 + 
 + / * * 
 + * Fetch a string representation of the token . 
 + * 
 + * @ return a string token 
 + * / 
 + public String getToken ( ) 
 + { 
 + return ssProxy . getToken ( ) ; 
 + } 
 + 
 + / * * 
 + * Return the generation value for this node . 
 + * 
 + * @ return generation number 
 + * / 
 + public int getCurrentGenerationNumber ( ) 
 + { 
 + return ssProxy . getCurrentGenerationNumber ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve a textual representation of the on - disk size of data 
 + * stored on this node . 
 + * 
 + * @ return the size description 
 + * / 
 + public String getLoadInfo ( ) 
 + { 
 + return ssProxy . getLoadInfo ( ) ; 
 + } 
 + 
 + / * * 
 + * Trigger a cleanup of keys on all tables . 
 + * / 
 + public void forceTableCleanup ( ) 
 + { 
 + ssProxy . forceTableCleanup ( ) ; 
 + } 
 + 
 + / * * 
 + * Trigger compaction of all tables . 
 + * / 
 + public void forceTableCompaction ( ) 
 + { 
 + ssProxy . forceTableCompaction ( ) ; 
 + } 
 + 
 + / * * 
 + * Write a textual representation of the Cassandra ring . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printRing ( PrintStream outs ) 
 + { 
 + Map < Range , List < EndPoint > > rangeMap = getRangeToEndpointMap ( ) ; 
 + 
 + / / Print range - to - endpoint mapping 
 + int counter = 0 ; 
 + for ( Range range : rangeMap . keySet ( ) ) { 
 + List < EndPoint > endpoints = rangeMap . get ( range ) ; 
 + 
 + outs . print ( String . format ( " % - 46s " , range . left ( ) ) ) ; 
 + outs . print ( String . format ( " % 2d " , endpoints . size ( ) ) ) ; 
 + outs . print ( String . format ( " % - 15s " , endpoints . get ( 0 ) . getHost ( ) ) ) ; 
 + 
 + String asciiRingArt ; 
 + if ( counter = = 0 ) 
 + { 
 + asciiRingArt = " | < - - | " ; 
 + } 
 + else if ( counter = = ( rangeMap . size ( ) - 1 ) ) 
 + { 
 + asciiRingArt = " | - - > | " ; 
 + } 
 + else 
 + { 
 + if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) = = 0 ) ) 
 + { 
 + asciiRingArt = " v | " ; 
 + } 
 + else if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) ! = 0 ) ) 
 + { 
 + asciiRingArt = " | ^ " ; 
 + } 
 + else 
 + { 
 + asciiRingArt = " | | " ; 
 + } 
 + } 
 + outs . println ( asciiRingArt ) ; 
 + 
 + counter + + ; 
 + } 
 + } 
 + 
 + / * * 
 + * Write a list of nodes with corresponding status . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printCluster ( PrintStream outs ) 
 + { 
 + for ( String upNode : getLiveNodes ( ) . split ( " \ \ s + " ) ) 
 + { 
 + if ( upNode . length ( ) > 0 ) 
 + { 
 + outs . println ( String . format ( " % - 21s up " , upNode ) ) ; 
 + } 
 + } 
 + 
 + for ( String downNode : getUnreachableNodes ( ) . split ( " \ \ s + " ) ) 
 + { 
 + if ( downNode . length ( ) > 0 ) 
 + { 
 + outs . println ( String . format ( " % - 21s down " , downNode ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Write node information . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printInfo ( PrintStream outs ) 
 + { 
 + outs . println ( getToken ( ) ) ; 
 + outs . println ( String . format ( " % - 17s : % s " , " Load Info " , getLoadInfo ( ) ) ) ; 
 + outs . println ( String . format ( " % - 17s : % s " , " Generation No " , getCurrentGenerationNumber ( ) ) ) ; 
 + 
 + / / Uptime 
 + long secondsUp = runtimeProxy . getUptime ( ) / 1000 ; 
 + outs . println ( String . format ( " % - 17s : % d " , " Uptime ( seconds ) " , secondsUp ) ) ; 
 + 
 + / / Memory usage 
 + MemoryUsage heapUsage = memProxy . getHeapMemoryUsage ( ) ; 
 + double memUsed = ( double ) heapUsage . getUsed ( ) / ( 1024 * 1024 ) ; 
 + double memMax = ( double ) heapUsage . getMax ( ) / ( 1024 * 1024 ) ; 
 + outs . println ( String . format ( " % - 17s : % . 2f / % . 2f " , " Heap Memory ( MB ) " , memUsed , memMax ) ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve any non - option arguments passed on the command line . 
 + * 
 + * @ return non - option command args 
 + * / 
 + private String [ ] getArgs ( ) 
 + { 
 + return cmd . getArgs ( ) ; 
 + } 
 + 
 + / * * 
 + * Parse the supplied command line arguments . 
 + * 
 + * @ param args arguments passed on the command line 
 + * @ throws ParseException for missing required , or unrecognized options 
 + * / 
 + private void parseArgs ( String [ ] args ) throws ParseException 
 + { 
 + CommandLineParser parser = new PosixParser ( ) ; 
 + cmd = parser . parse ( options , args ) ; 
 + } 
 + 
 + / * * 
 + * Prints usage information to stdout . 
 + * / 
 + private static void printUsage ( ) 
 + { 
 + HelpFormatter hf = new HelpFormatter ( ) ; 
 + String header = String . format ( 
 + " % nAvailable commands : ring , cluster , info , cleanup , compact " ) ; 
 + String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; 
 + hf . printHelp ( usage , " " , options , header ) ; 
 + } 
 + 
 + / * * 
 + * @ param args 
 + * / 
 + public static void main ( String [ ] args ) 
 + { 
 + NodeProbe probe = null ; 
 + try 
 + { 
 + probe = new NodeProbe ( args ) ; 
 + } 
 + catch ( ParseException pe ) 
 + { 
 + System . err . println ( pe . getMessage ( ) ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + catch ( IOException ioe ) 
 + { 
 + System . err . println ( " Error connecting to remote JMX agent ! " ) ; 
 + ioe . printStackTrace ( ) ; 
 + System . exit ( 3 ) ; 
 + } 
 + 
 + if ( probe . getArgs ( ) . length < 1 ) 
 + { 
 + System . err . println ( " Missing argument for command . " ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + / / Execute the requested command . 
 + String cmdName = probe . getArgs ( ) [ 0 ] ; 
 + if ( cmdName . equals ( " ring " ) ) 
 + { 
 + probe . printRing ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " cluster " ) ) 
 + { 
 + probe . printCluster ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " info " ) ) 
 + { 
 + probe . printInfo ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " cleanup " ) ) 
 + { 
 + probe . forceTableCleanup ( ) ; 
 + } 
 + else if ( cmdName . equals ( " compact " ) ) 
 + { 
 + probe . forceTableCompaction ( ) ; 
 + } 
 + else 
 + { 
 + System . err . println ( " Unrecognized command : " + cmdName + " . " ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + System . exit ( 0 ) ; 
 + } 
 + 
 + }
