BLEU SCORE: 0.08295193507109855

TEST MSG: Fix handling of cells for removed column when reading legacy sstables
GENERATED MSG: Properly handle range tombstones when reading old format sstables

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index 40b9fd3 . . 3ba96a6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 649 , 7 + 649 , 7 @ @ public abstract class LegacyLayout <nl> <nl> boolean foundOne = false ; <nl> LegacyAtom atom ; <nl> - while ( ( atom = readLegacyAtom ( metadata , in , false ) ) ! = null ) <nl> + while ( ( atom = readLegacyAtomSkippingUnknownColumn ( metadata , in ) ) ! = null ) <nl> { <nl> if ( atom . isCell ( ) ) <nl> { <nl> @ @ - 672 , 6 + 672 , 23 @ @ public abstract class LegacyLayout <nl> return foundOne ? builder . build ( ) : Rows . EMPTY _ STATIC _ ROW ; <nl> } <nl> <nl> + private static LegacyAtom readLegacyAtomSkippingUnknownColumn ( CFMetaData metadata , DataInputPlus in ) <nl> + throws IOException <nl> + { <nl> + while ( true ) <nl> + { <nl> + try <nl> + { <nl> + return readLegacyAtom ( metadata , in , false ) ; <nl> + } <nl> + catch ( UnknownColumnException e ) <nl> + { <nl> + / / Simply skip , as the method name implies . <nl> + } <nl> + } <nl> + <nl> + } <nl> + <nl> private static Row getNextRow ( CellGrouper grouper , PeekingIterator < ? extends LegacyAtom > cells ) <nl> { <nl> if ( ! cells . hasNext ( ) ) <nl> @ @ - 1020 , 29 + 1037 , 36 @ @ public abstract class LegacyLayout <nl> } ; <nl> } <nl> <nl> - public static LegacyAtom readLegacyAtom ( CFMetaData metadata , DataInputPlus in , boolean readAllAsDynamic ) throws IOException <nl> + public static LegacyAtom readLegacyAtom ( CFMetaData metadata , DataInputPlus in , boolean readAllAsDynamic ) <nl> + throws IOException , UnknownColumnException <nl> { <nl> - while ( true ) <nl> - { <nl> - ByteBuffer cellname = ByteBufferUtil . readWithShortLength ( in ) ; <nl> - if ( ! cellname . hasRemaining ( ) ) <nl> - return null ; / / END _ OF _ ROW <nl> - <nl> - try <nl> - { <nl> - int b = in . readUnsignedByte ( ) ; <nl> - return ( b & RANGE _ TOMBSTONE _ MASK ) ! = 0 <nl> - ? readLegacyRangeTombstoneBody ( metadata , in , cellname ) <nl> - : readLegacyCellBody ( metadata , in , cellname , b , SerializationHelper . Flag . LOCAL , readAllAsDynamic ) ; <nl> - } <nl> - catch ( UnknownColumnException e ) <nl> - { <nl> - / / We can get there if we read a cell for a dropped column , and ff that is the case , <nl> - / / then simply ignore the cell is fine . But also not that we ignore if it ' s the <nl> - / / system keyspace because for those table we actually remove columns without registering <nl> - / / them in the dropped columns <nl> - assert metadata . ksName . equals ( SystemKeyspace . NAME ) | | metadata . getDroppedColumnDefinition ( e . columnName ) ! = null : e . getMessage ( ) ; <nl> - } <nl> + ByteBuffer cellname = ByteBufferUtil . readWithShortLength ( in ) ; <nl> + if ( ! cellname . hasRemaining ( ) ) <nl> + return null ; / / END _ OF _ ROW <nl> + <nl> + try <nl> + { <nl> + int b = in . readUnsignedByte ( ) ; <nl> + return ( b & RANGE _ TOMBSTONE _ MASK ) ! = 0 <nl> + ? readLegacyRangeTombstoneBody ( metadata , in , cellname ) <nl> + : readLegacyCellBody ( metadata , in , cellname , b , SerializationHelper . Flag . LOCAL , readAllAsDynamic ) ; <nl> + } <nl> + catch ( UnknownColumnException e ) <nl> + { <nl> + / / We legitimately can get here in 2 cases : <nl> + / / 1 ) for system tables , because we ' ve unceremoniously removed columns ( without registering them as dropped ) <nl> + / / 2 ) for dropped columns . <nl> + / / In any other case , there is a mismatch between the schema and the data , and we complain loudly in <nl> + / / that case . Note that if we are in a legit case of an unknown column , we want to simply skip that cell , <nl> + / / but we don ' t do this here and re - throw the exception because the calling code sometimes has to know <nl> + / / about this happening . This does mean code calling this method should handle this case properly . <nl> + if ( ! metadata . ksName . equals ( SystemKeyspace . NAME ) & & metadata . getDroppedColumnDefinition ( e . columnName ) = = null ) <nl> + throw new IllegalStateException ( String . format ( " Got cell for unknown column % s in sstable of % s . % s : " + <nl> + " This suggest a problem with the schema which doesn ' t list " + <nl> + " this column . Even if that column was dropped , it should have " + <nl> + " been listed as such " , metadata . ksName , metadata . cfName , UTF8Type . instance . compose ( e . columnName ) ) , e ) ; <nl> + <nl> + throw e ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java b / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java <nl> index ea65633 . . 0aa5741 100644 <nl> - - - a / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java <nl> + + + b / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java <nl> @ @ - 274 , 16 + 274 , 26 @ @ public abstract class UnfilteredDeserializer <nl> <nl> private LegacyLayout . LegacyAtom readAtom ( ) <nl> { <nl> - try <nl> - { <nl> - long pos = currentPosition ( ) ; <nl> - LegacyLayout . LegacyAtom atom = LegacyLayout . readLegacyAtom ( metadata , in , readAllAsDynamic ) ; <nl> - bytesReadForNextAtom = currentPosition ( ) - pos ; <nl> - return atom ; <nl> - } <nl> - catch ( IOException e ) <nl> + while ( true ) <nl> { <nl> - throw new IOError ( e ) ; <nl> + try <nl> + { <nl> + long pos = currentPosition ( ) ; <nl> + LegacyLayout . LegacyAtom atom = LegacyLayout . readLegacyAtom ( metadata , in , readAllAsDynamic ) ; <nl> + bytesReadForNextAtom = currentPosition ( ) - pos ; <nl> + return atom ; <nl> + } <nl> + catch ( UnknownColumnException e ) <nl> + { <nl> + / / This is ok , see LegacyLayout . readLegacyAtom ( ) for why this only happens in case were we ' re ok <nl> + / / skipping the cell . We do want to catch this at this level however because when that happen , <nl> + / / we should * not * count the byte of that discarded cell as part of the bytes for the atom <nl> + / / we will eventually return , as doing so could throw the logic bytesReadForNextAtom participates in . <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 407 , 6 + 417 , 7 @ @ public abstract class UnfilteredDeserializer <nl> saved = null ; <nl> iterator . clearState ( ) ; <nl> lastConsumedPosition = currentPosition ( ) ; <nl> + bytesReadForNextAtom = 0 ; <nl> } <nl> <nl> / / Groups atoms from the input into proper Unfiltered .
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index 40b9fd3 . . 3ba96a6 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 649 , 7 + 649 , 7 @ @ public abstract class LegacyLayout 
 
 boolean foundOne = false ; 
 LegacyAtom atom ; 
 - while ( ( atom = readLegacyAtom ( metadata , in , false ) ) ! = null ) 
 + while ( ( atom = readLegacyAtomSkippingUnknownColumn ( metadata , in ) ) ! = null ) 
 { 
 if ( atom . isCell ( ) ) 
 { 
 @ @ - 672 , 6 + 672 , 23 @ @ public abstract class LegacyLayout 
 return foundOne ? builder . build ( ) : Rows . EMPTY _ STATIC _ ROW ; 
 } 
 
 + private static LegacyAtom readLegacyAtomSkippingUnknownColumn ( CFMetaData metadata , DataInputPlus in ) 
 + throws IOException 
 + { 
 + while ( true ) 
 + { 
 + try 
 + { 
 + return readLegacyAtom ( metadata , in , false ) ; 
 + } 
 + catch ( UnknownColumnException e ) 
 + { 
 + / / Simply skip , as the method name implies . 
 + } 
 + } 
 + 
 + } 
 + 
 private static Row getNextRow ( CellGrouper grouper , PeekingIterator < ? extends LegacyAtom > cells ) 
 { 
 if ( ! cells . hasNext ( ) ) 
 @ @ - 1020 , 29 + 1037 , 36 @ @ public abstract class LegacyLayout 
 } ; 
 } 
 
 - public static LegacyAtom readLegacyAtom ( CFMetaData metadata , DataInputPlus in , boolean readAllAsDynamic ) throws IOException 
 + public static LegacyAtom readLegacyAtom ( CFMetaData metadata , DataInputPlus in , boolean readAllAsDynamic ) 
 + throws IOException , UnknownColumnException 
 { 
 - while ( true ) 
 - { 
 - ByteBuffer cellname = ByteBufferUtil . readWithShortLength ( in ) ; 
 - if ( ! cellname . hasRemaining ( ) ) 
 - return null ; / / END _ OF _ ROW 
 - 
 - try 
 - { 
 - int b = in . readUnsignedByte ( ) ; 
 - return ( b & RANGE _ TOMBSTONE _ MASK ) ! = 0 
 - ? readLegacyRangeTombstoneBody ( metadata , in , cellname ) 
 - : readLegacyCellBody ( metadata , in , cellname , b , SerializationHelper . Flag . LOCAL , readAllAsDynamic ) ; 
 - } 
 - catch ( UnknownColumnException e ) 
 - { 
 - / / We can get there if we read a cell for a dropped column , and ff that is the case , 
 - / / then simply ignore the cell is fine . But also not that we ignore if it ' s the 
 - / / system keyspace because for those table we actually remove columns without registering 
 - / / them in the dropped columns 
 - assert metadata . ksName . equals ( SystemKeyspace . NAME ) | | metadata . getDroppedColumnDefinition ( e . columnName ) ! = null : e . getMessage ( ) ; 
 - } 
 + ByteBuffer cellname = ByteBufferUtil . readWithShortLength ( in ) ; 
 + if ( ! cellname . hasRemaining ( ) ) 
 + return null ; / / END _ OF _ ROW 
 + 
 + try 
 + { 
 + int b = in . readUnsignedByte ( ) ; 
 + return ( b & RANGE _ TOMBSTONE _ MASK ) ! = 0 
 + ? readLegacyRangeTombstoneBody ( metadata , in , cellname ) 
 + : readLegacyCellBody ( metadata , in , cellname , b , SerializationHelper . Flag . LOCAL , readAllAsDynamic ) ; 
 + } 
 + catch ( UnknownColumnException e ) 
 + { 
 + / / We legitimately can get here in 2 cases : 
 + / / 1 ) for system tables , because we ' ve unceremoniously removed columns ( without registering them as dropped ) 
 + / / 2 ) for dropped columns . 
 + / / In any other case , there is a mismatch between the schema and the data , and we complain loudly in 
 + / / that case . Note that if we are in a legit case of an unknown column , we want to simply skip that cell , 
 + / / but we don ' t do this here and re - throw the exception because the calling code sometimes has to know 
 + / / about this happening . This does mean code calling this method should handle this case properly . 
 + if ( ! metadata . ksName . equals ( SystemKeyspace . NAME ) & & metadata . getDroppedColumnDefinition ( e . columnName ) = = null ) 
 + throw new IllegalStateException ( String . format ( " Got cell for unknown column % s in sstable of % s . % s : " + 
 + " This suggest a problem with the schema which doesn ' t list " + 
 + " this column . Even if that column was dropped , it should have " + 
 + " been listed as such " , metadata . ksName , metadata . cfName , UTF8Type . instance . compose ( e . columnName ) ) , e ) ; 
 + 
 + throw e ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java b / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java 
 index ea65633 . . 0aa5741 100644 
 - - - a / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java 
 + + + b / src / java / org / apache / cassandra / db / UnfilteredDeserializer . java 
 @ @ - 274 , 16 + 274 , 26 @ @ public abstract class UnfilteredDeserializer 
 
 private LegacyLayout . LegacyAtom readAtom ( ) 
 { 
 - try 
 - { 
 - long pos = currentPosition ( ) ; 
 - LegacyLayout . LegacyAtom atom = LegacyLayout . readLegacyAtom ( metadata , in , readAllAsDynamic ) ; 
 - bytesReadForNextAtom = currentPosition ( ) - pos ; 
 - return atom ; 
 - } 
 - catch ( IOException e ) 
 + while ( true ) 
 { 
 - throw new IOError ( e ) ; 
 + try 
 + { 
 + long pos = currentPosition ( ) ; 
 + LegacyLayout . LegacyAtom atom = LegacyLayout . readLegacyAtom ( metadata , in , readAllAsDynamic ) ; 
 + bytesReadForNextAtom = currentPosition ( ) - pos ; 
 + return atom ; 
 + } 
 + catch ( UnknownColumnException e ) 
 + { 
 + / / This is ok , see LegacyLayout . readLegacyAtom ( ) for why this only happens in case were we ' re ok 
 + / / skipping the cell . We do want to catch this at this level however because when that happen , 
 + / / we should * not * count the byte of that discarded cell as part of the bytes for the atom 
 + / / we will eventually return , as doing so could throw the logic bytesReadForNextAtom participates in . 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 } 
 } 
 
 @ @ - 407 , 6 + 417 , 7 @ @ public abstract class UnfilteredDeserializer 
 saved = null ; 
 iterator . clearState ( ) ; 
 lastConsumedPosition = currentPosition ( ) ; 
 + bytesReadForNextAtom = 0 ; 
 } 
 
 / / Groups atoms from the input into proper Unfiltered .

NEAREST DIFF:
ELIMINATEDSENTENCE
