BLEU SCORE: 0.05522397783539471

TEST MSG: Fix New SASI view creation during Index Redistribution
GENERATED MSG: Avoid rebuilding SASI indexes containing no values

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0e4346b . . d70b381 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 11 . 3 <nl> + * Fix New SASI view creation during Index Redistribution ( CASSANDRA - 14055 ) <nl> * Remove string formatting lines from BufferPool hot path ( CASSANDRA - 14416 ) <nl> * Update metrics to 3 . 1 . 5 ( CASSANDRA - 12924 ) <nl> * Detect OpenJDK jvm type and architecture ( CASSANDRA - 12793 ) <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / view / View . java b / src / java / org / apache / cassandra / index / sasi / conf / view / View . java <nl> index 25f32d9 . . b0afc5b 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / view / View . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / view / View . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . index . sasi . conf . view ; <nl> <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> + import java . util . stream . Collectors ; <nl> <nl> import org . apache . cassandra . index . sasi . SSTableIndex ; <nl> import org . apache . cassandra . index . sasi . conf . ColumnIndex ; <nl> @ @ - 59 , 10 + 60 , 15 @ @ public class View implements Iterable < SSTableIndex > <nl> : new RangeTermTree . Builder ( index . getMode ( ) . mode , validator ) ; <nl> <nl> List < Interval < Key , SSTableIndex > > keyIntervals = new ArrayList < > ( ) ; <nl> - for ( SSTableIndex sstableIndex : Iterables . concat ( currentView , newIndexes ) ) <nl> + / / Ensure oldSSTables and newIndexes are disjoint ( in index redistribution case the intersection can be non - empty ) . <nl> + / / also favor newIndexes over currentView in case an SSTable has been re - opened ( also occurs during redistribution ) <nl> + / / See CASSANDRA - 14055 <nl> + Collection < SSTableReader > toRemove = new HashSet < > ( oldSSTables ) ; <nl> + toRemove . removeAll ( newIndexes . stream ( ) . map ( SSTableIndex : : getSSTable ) . collect ( Collectors . toSet ( ) ) ) ; <nl> + for ( SSTableIndex sstableIndex : Iterables . concat ( newIndexes , currentView ) ) <nl> { <nl> SSTableReader sstable = sstableIndex . getSSTable ( ) ; <nl> - if ( oldSSTables . contains ( sstable ) | | sstable . isMarkedCompacted ( ) | | newView . containsKey ( sstable . descriptor ) ) <nl> + if ( toRemove . contains ( sstable ) | | sstable . isMarkedCompacted ( ) | | newView . containsKey ( sstable . descriptor ) ) <nl> { <nl> sstableIndex . release ( ) ; <nl> continue ; <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> index 1b2f97d . . a57af61 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ <nl> package org . apache . cassandra . index . sasi ; <nl> <nl> import java . io . FileWriter ; <nl> + import java . io . IOException ; <nl> import java . io . Writer ; <nl> import java . nio . ByteBuffer ; <nl> import java . nio . file . FileSystems ; <nl> @ @ - 60 , 6 + 61 , 7 @ @ import org . apache . cassandra . index . sasi . exceptions . TimeQuotaExceededException ; <nl> import org . apache . cassandra . index . sasi . memory . IndexMemtable ; <nl> import org . apache . cassandra . index . sasi . plan . QueryController ; <nl> import org . apache . cassandra . index . sasi . plan . QueryPlan ; <nl> + import org . apache . cassandra . io . sstable . IndexSummaryManager ; <nl> import org . apache . cassandra . io . sstable . SSTable ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> import org . apache . cassandra . schema . KeyspaceMetadata ; <nl> @ @ - 898 , 6 + 900 , 77 @ @ public class SASIIndexTest <nl> } <nl> <nl> @ Test <nl> + public void testIndexRedistribution ( ) throws IOException <nl> + { <nl> + Map < String , Pair < String , Integer > > part1 = new HashMap < String , Pair < String , Integer > > ( ) <nl> + { { <nl> + put ( " key01 " , Pair . create ( " a " , 33 ) ) ; <nl> + put ( " key02 " , Pair . create ( " a " , 41 ) ) ; <nl> + } } ; <nl> + <nl> + Map < String , Pair < String , Integer > > part2 = new HashMap < String , Pair < String , Integer > > ( ) <nl> + { { <nl> + put ( " key03 " , Pair . create ( " a " , 22 ) ) ; <nl> + put ( " key04 " , Pair . create ( " a " , 45 ) ) ; <nl> + } } ; <nl> + <nl> + Map < String , Pair < String , Integer > > part3 = new HashMap < String , Pair < String , Integer > > ( ) <nl> + { { <nl> + put ( " key05 " , Pair . create ( " a " , 32 ) ) ; <nl> + put ( " key06 " , Pair . create ( " a " , 38 ) ) ; <nl> + } } ; <nl> + <nl> + Map < String , Pair < String , Integer > > part4 = new HashMap < String , Pair < String , Integer > > ( ) <nl> + { { <nl> + put ( " key07 " , Pair . create ( " a " , 36 ) ) ; <nl> + put ( " key08 " , Pair . create ( " a " , 36 ) ) ; <nl> + } } ; <nl> + <nl> + Map < String , Pair < String , Integer > > part5 = new HashMap < String , Pair < String , Integer > > ( ) <nl> + { { <nl> + put ( " key09 " , Pair . create ( " a " , 21 ) ) ; <nl> + put ( " key10 " , Pair . create ( " a " , 35 ) ) ; <nl> + } } ; <nl> + <nl> + ColumnFamilyStore store = loadData ( part1 , 1000 , true ) ; <nl> + loadData ( part2 , true ) ; <nl> + loadData ( part3 , true ) ; <nl> + <nl> + final ByteBuffer firstName = UTF8Type . instance . decompose ( " first _ name " ) ; <nl> + <nl> + Set < String > rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; <nl> + Assert . assertEquals ( rows . toString ( ) , 6 , rows . size ( ) ) ; <nl> + <nl> + loadData ( part4 , true ) ; <nl> + rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; <nl> + Assert . assertEquals ( rows . toString ( ) , 8 , rows . size ( ) ) ; <nl> + <nl> + loadData ( part5 , true ) ; <nl> + <nl> + int minIndexInterval = store . metadata . params . minIndexInterval ; <nl> + try <nl> + { <nl> + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 2 ) ; <nl> + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 4 ) ; <nl> + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 8 ) ; <nl> + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 16 ) ; <nl> + } finally <nl> + { <nl> + store . metadata . minIndexInterval ( minIndexInterval ) ; <nl> + } <nl> + } <nl> + <nl> + private void redistributeSummaries ( int expected , ColumnFamilyStore store , ByteBuffer firstName , int minIndexInterval ) throws IOException <nl> + { <nl> + store . metadata . minIndexInterval ( minIndexInterval ) ; <nl> + IndexSummaryManager . instance . redistributeSummaries ( ) ; <nl> + store . forceBlockingFlush ( ) ; <nl> + <nl> + Set < String > rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; <nl> + Assert . assertEquals ( rows . toString ( ) , expected , rows . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testTruncate ( ) <nl> { <nl> Map < String , Pair < String , Integer > > part1 = new HashMap < String , Pair < String , Integer > > ( )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0e4346b . . d70b381 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 11 . 3 
 + * Fix New SASI view creation during Index Redistribution ( CASSANDRA - 14055 ) 
 * Remove string formatting lines from BufferPool hot path ( CASSANDRA - 14416 ) 
 * Update metrics to 3 . 1 . 5 ( CASSANDRA - 12924 ) 
 * Detect OpenJDK jvm type and architecture ( CASSANDRA - 12793 ) 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / view / View . java b / src / java / org / apache / cassandra / index / sasi / conf / view / View . java 
 index 25f32d9 . . b0afc5b 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / view / View . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / view / View . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . index . sasi . conf . view ; 
 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 + import java . util . stream . Collectors ; 
 
 import org . apache . cassandra . index . sasi . SSTableIndex ; 
 import org . apache . cassandra . index . sasi . conf . ColumnIndex ; 
 @ @ - 59 , 10 + 60 , 15 @ @ public class View implements Iterable < SSTableIndex > 
 : new RangeTermTree . Builder ( index . getMode ( ) . mode , validator ) ; 
 
 List < Interval < Key , SSTableIndex > > keyIntervals = new ArrayList < > ( ) ; 
 - for ( SSTableIndex sstableIndex : Iterables . concat ( currentView , newIndexes ) ) 
 + / / Ensure oldSSTables and newIndexes are disjoint ( in index redistribution case the intersection can be non - empty ) . 
 + / / also favor newIndexes over currentView in case an SSTable has been re - opened ( also occurs during redistribution ) 
 + / / See CASSANDRA - 14055 
 + Collection < SSTableReader > toRemove = new HashSet < > ( oldSSTables ) ; 
 + toRemove . removeAll ( newIndexes . stream ( ) . map ( SSTableIndex : : getSSTable ) . collect ( Collectors . toSet ( ) ) ) ; 
 + for ( SSTableIndex sstableIndex : Iterables . concat ( newIndexes , currentView ) ) 
 { 
 SSTableReader sstable = sstableIndex . getSSTable ( ) ; 
 - if ( oldSSTables . contains ( sstable ) | | sstable . isMarkedCompacted ( ) | | newView . containsKey ( sstable . descriptor ) ) 
 + if ( toRemove . contains ( sstable ) | | sstable . isMarkedCompacted ( ) | | newView . containsKey ( sstable . descriptor ) ) 
 { 
 sstableIndex . release ( ) ; 
 continue ; 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 index 1b2f97d . . a57af61 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 @ @ - 18 , 6 + 18 , 7 @ @ 
 package org . apache . cassandra . index . sasi ; 
 
 import java . io . FileWriter ; 
 + import java . io . IOException ; 
 import java . io . Writer ; 
 import java . nio . ByteBuffer ; 
 import java . nio . file . FileSystems ; 
 @ @ - 60 , 6 + 61 , 7 @ @ import org . apache . cassandra . index . sasi . exceptions . TimeQuotaExceededException ; 
 import org . apache . cassandra . index . sasi . memory . IndexMemtable ; 
 import org . apache . cassandra . index . sasi . plan . QueryController ; 
 import org . apache . cassandra . index . sasi . plan . QueryPlan ; 
 + import org . apache . cassandra . io . sstable . IndexSummaryManager ; 
 import org . apache . cassandra . io . sstable . SSTable ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 import org . apache . cassandra . schema . KeyspaceMetadata ; 
 @ @ - 898 , 6 + 900 , 77 @ @ public class SASIIndexTest 
 } 
 
 @ Test 
 + public void testIndexRedistribution ( ) throws IOException 
 + { 
 + Map < String , Pair < String , Integer > > part1 = new HashMap < String , Pair < String , Integer > > ( ) 
 + { { 
 + put ( " key01 " , Pair . create ( " a " , 33 ) ) ; 
 + put ( " key02 " , Pair . create ( " a " , 41 ) ) ; 
 + } } ; 
 + 
 + Map < String , Pair < String , Integer > > part2 = new HashMap < String , Pair < String , Integer > > ( ) 
 + { { 
 + put ( " key03 " , Pair . create ( " a " , 22 ) ) ; 
 + put ( " key04 " , Pair . create ( " a " , 45 ) ) ; 
 + } } ; 
 + 
 + Map < String , Pair < String , Integer > > part3 = new HashMap < String , Pair < String , Integer > > ( ) 
 + { { 
 + put ( " key05 " , Pair . create ( " a " , 32 ) ) ; 
 + put ( " key06 " , Pair . create ( " a " , 38 ) ) ; 
 + } } ; 
 + 
 + Map < String , Pair < String , Integer > > part4 = new HashMap < String , Pair < String , Integer > > ( ) 
 + { { 
 + put ( " key07 " , Pair . create ( " a " , 36 ) ) ; 
 + put ( " key08 " , Pair . create ( " a " , 36 ) ) ; 
 + } } ; 
 + 
 + Map < String , Pair < String , Integer > > part5 = new HashMap < String , Pair < String , Integer > > ( ) 
 + { { 
 + put ( " key09 " , Pair . create ( " a " , 21 ) ) ; 
 + put ( " key10 " , Pair . create ( " a " , 35 ) ) ; 
 + } } ; 
 + 
 + ColumnFamilyStore store = loadData ( part1 , 1000 , true ) ; 
 + loadData ( part2 , true ) ; 
 + loadData ( part3 , true ) ; 
 + 
 + final ByteBuffer firstName = UTF8Type . instance . decompose ( " first _ name " ) ; 
 + 
 + Set < String > rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; 
 + Assert . assertEquals ( rows . toString ( ) , 6 , rows . size ( ) ) ; 
 + 
 + loadData ( part4 , true ) ; 
 + rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; 
 + Assert . assertEquals ( rows . toString ( ) , 8 , rows . size ( ) ) ; 
 + 
 + loadData ( part5 , true ) ; 
 + 
 + int minIndexInterval = store . metadata . params . minIndexInterval ; 
 + try 
 + { 
 + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 2 ) ; 
 + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 4 ) ; 
 + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 8 ) ; 
 + redistributeSummaries ( 10 , store , firstName , minIndexInterval * 16 ) ; 
 + } finally 
 + { 
 + store . metadata . minIndexInterval ( minIndexInterval ) ; 
 + } 
 + } 
 + 
 + private void redistributeSummaries ( int expected , ColumnFamilyStore store , ByteBuffer firstName , int minIndexInterval ) throws IOException 
 + { 
 + store . metadata . minIndexInterval ( minIndexInterval ) ; 
 + IndexSummaryManager . instance . redistributeSummaries ( ) ; 
 + store . forceBlockingFlush ( ) ; 
 + 
 + Set < String > rows = getIndexed ( store , 100 , buildExpression ( firstName , Operator . LIKE _ CONTAINS , UTF8Type . instance . decompose ( " a " ) ) ) ; 
 + Assert . assertEquals ( rows . toString ( ) , expected , rows . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 public void testTruncate ( ) 
 { 
 Map < String , Pair < String , Integer > > part1 = new HashMap < String , Pair < String , Integer > > ( )

NEAREST DIFF:
ELIMINATEDSENTENCE
