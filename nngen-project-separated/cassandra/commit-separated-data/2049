BLEU SCORE: 0.07545383788761362

TEST MSG: Emit metrics for CAS
GENERATED MSG: add read support for CL . SERIAL

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> index 3dc269f . . a3838a0 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> @ @ - 93 , 6 + 93 , 12 @ @ public class ColumnFamilyMetrics <nl> public final ColumnFamilyHistogram tombstoneScannedHistogram ; <nl> / * * Live cells scanned in queries on this CF * / <nl> public final ColumnFamilyHistogram liveScannedHistogram ; <nl> + / * * CAS Prepare metrics * / <nl> + public final LatencyMetrics casPrepare ; <nl> + / * * CAS Propose metrics * / <nl> + public final LatencyMetrics casPropose ; <nl> + / * * CAS Commit metrics * / <nl> + public final LatencyMetrics casCommit ; <nl> <nl> public final Timer coordinatorReadLatency ; <nl> public final Timer coordinatorScanLatency ; <nl> @ @ - 444 , 6 + 450 , 9 @ @ public class ColumnFamilyMetrics <nl> liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram ) ; <nl> coordinatorReadLatency = Metrics . newTimer ( factory . createMetricName ( " CoordinatorReadLatency " ) , TimeUnit . MICROSECONDS , TimeUnit . SECONDS ) ; <nl> coordinatorScanLatency = Metrics . newTimer ( factory . createMetricName ( " CoordinatorScanLatency " ) , TimeUnit . MICROSECONDS , TimeUnit . SECONDS ) ; <nl> + casPrepare = new LatencyMetrics ( factory , " CasPrepare " , cfs . keyspace . metric . casPrepare ) ; <nl> + casPropose = new LatencyMetrics ( factory , " CasPropose " , cfs . keyspace . metric . casPropose ) ; <nl> + casCommit = new LatencyMetrics ( factory , " CasCommit " , cfs . keyspace . metric . casCommit ) ; <nl> } <nl> <nl> public void updateSSTableIterated ( int count ) <nl> diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> index 7dcf9d5 . . 7a768b8 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> @ @ - 62 , 6 + 62 , 12 @ @ public class KeyspaceMetrics <nl> public final Histogram tombstoneScannedHistogram ; <nl> / * * Live cells scanned in queries on this Keyspace * / <nl> public final Histogram liveScannedHistogram ; <nl> + / * * CAS Prepare metric * / <nl> + public final LatencyMetrics casPrepare ; <nl> + / * * CAS Propose metrics * / <nl> + public final LatencyMetrics casPropose ; <nl> + / * * CAS Commit metrics * / <nl> + public final LatencyMetrics casCommit ; <nl> <nl> private final MetricNameFactory factory ; <nl> private Keyspace keyspace ; <nl> @ @ - 151 , 6 + 157 , 10 @ @ public class KeyspaceMetrics <nl> liveScannedHistogram = Metrics . newHistogram ( factory . createMetricName ( " LiveScannedHistogram " ) , true ) ; <nl> / / add manually since histograms do not use createKeyspaceGauge method <nl> allMetrics . addAll ( Lists . newArrayList ( " SSTablesPerReadHistogram " , " TombstoneScannedHistogram " , " LiveScannedHistogram " ) ) ; <nl> + <nl> + casPrepare = new LatencyMetrics ( factory , " CasPrepare " ) ; <nl> + casPropose = new LatencyMetrics ( factory , " CasPropose " ) ; <nl> + casCommit = new LatencyMetrics ( factory , " CasCommit " ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 904d602 . . d8b6619 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import com . google . common . base . Predicate ; <nl> import com . google . common . cache . CacheLoader ; <nl> import com . google . common . collect . * ; <nl> import com . google . common . util . concurrent . Uninterruptibles ; <nl> + import org . apache . cassandra . metrics . * ; <nl> import org . apache . commons . lang3 . StringUtils ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 55 , 9 + 56 , 6 @ @ import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . IEndpointSnitch ; <nl> import org . apache . cassandra . locator . LocalStrategy ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> - import org . apache . cassandra . metrics . ClientRequestMetrics ; <nl> - import org . apache . cassandra . metrics . ReadRepairMetrics ; <nl> - import org . apache . cassandra . metrics . StorageMetrics ; <nl> import org . apache . cassandra . net . * ; <nl> import org . apache . cassandra . service . paxos . * ; <nl> import org . apache . cassandra . sink . SinkManager ; <nl> @ @ - 90 , 6 + 88 , 8 @ @ public class StorageProxy implements StorageProxyMBean <nl> private static final ClientRequestMetrics readMetrics = new ClientRequestMetrics ( " Read " ) ; <nl> private static final ClientRequestMetrics rangeMetrics = new ClientRequestMetrics ( " RangeSlice " ) ; <nl> private static final ClientRequestMetrics writeMetrics = new ClientRequestMetrics ( " Write " ) ; <nl> + private static final CASClientRequestMetrics casWriteMetrics = new CASClientRequestMetrics ( " CASWrite " ) ; <nl> + private static final CASClientRequestMetrics casReadMetrics = new CASClientRequestMetrics ( " CASRead " ) ; <nl> <nl> private StorageProxy ( ) { } <nl> <nl> @ @ - 203 , 62 + 203 , 88 @ @ public class StorageProxy implements StorageProxyMBean <nl> ConsistencyLevel consistencyForCommit ) <nl> throws UnavailableException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException <nl> { <nl> - consistencyForPaxos . validateForCas ( ) ; <nl> - consistencyForCommit . validateForCasCommit ( keyspaceName ) ; <nl> - <nl> - CFMetaData metadata = Schema . instance . getCFMetaData ( keyspaceName , cfName ) ; <nl> - <nl> long start = System . nanoTime ( ) ; <nl> - long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; <nl> - while ( System . nanoTime ( ) - start < timeout ) <nl> + int contentions = 0 ; <nl> + try <nl> { <nl> - / / for simplicity , we ' ll do a single liveness check at the start of each attempt <nl> - Pair < List < InetAddress > , Integer > p = getPaxosParticipants ( keyspaceName , key , consistencyForPaxos ) ; <nl> - List < InetAddress > liveEndpoints = p . left ; <nl> - int requiredParticipants = p . right ; <nl> + consistencyForPaxos . validateForCas ( ) ; <nl> + consistencyForCommit . validateForCasCommit ( keyspaceName ) ; <nl> <nl> - UUID ballot = beginAndRepairPaxos ( start , key , metadata , liveEndpoints , requiredParticipants , consistencyForPaxos , consistencyForCommit ) ; <nl> + CFMetaData metadata = Schema . instance . getCFMetaData ( keyspaceName , cfName ) ; <nl> <nl> - / / read the current values and check they validate the conditions <nl> - Tracing . trace ( " Reading existing values for CAS precondition " ) ; <nl> - long timestamp = System . currentTimeMillis ( ) ; <nl> - ReadCommand readCommand = ReadCommand . create ( keyspaceName , key , cfName , timestamp , conditions . readFilter ( ) ) ; <nl> - List < Row > rows = read ( Arrays . asList ( readCommand ) , consistencyForPaxos = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ) ; <nl> - ColumnFamily current = rows . get ( 0 ) . cf ; <nl> - if ( ! conditions . appliesTo ( current ) ) <nl> + long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; <nl> + while ( System . nanoTime ( ) - start < timeout ) <nl> { <nl> - Tracing . trace ( " CAS precondition { } does not match current values { } " , conditions , current ) ; <nl> - / / We should not return null as this means success <nl> - return current = = null ? EmptyColumns . factory . create ( metadata ) : current ; <nl> - } <nl> + / / for simplicity , we ' ll do a single liveness check at the start of each attempt <nl> + Pair < List < InetAddress > , Integer > p = getPaxosParticipants ( keyspaceName , key , consistencyForPaxos ) ; <nl> + List < InetAddress > liveEndpoints = p . left ; <nl> + int requiredParticipants = p . right ; <nl> <nl> - / / finish the paxos round w / the desired updates <nl> - / / TODO turn null updates into delete ? <nl> - <nl> - / / Apply triggers to cas updates . A consideration here is that <nl> - / / triggers emit RowMutations , and so a given trigger implementation <nl> - / / may generate mutations for partitions other than the one this <nl> - / / paxos round is scoped for . In this case , TriggerExecutor will <nl> - / / validate that the generated mutations are targetted at the same <nl> - / / partition as the initial updates and reject ( via an <nl> - / / InvalidRequestException ) any which aren ' t . <nl> - updates = TriggerExecutor . instance . execute ( key , updates ) ; <nl> - <nl> - Commit proposal = Commit . newProposal ( key , ballot , updates ) ; <nl> - Tracing . trace ( " CAS precondition is met ; proposing client - requested updates for { } " , ballot ) ; <nl> - if ( proposePaxos ( proposal , liveEndpoints , requiredParticipants , true , consistencyForPaxos ) ) <nl> - { <nl> - commitPaxos ( proposal , consistencyForCommit ) ; <nl> - Tracing . trace ( " CAS successful " ) ; <nl> - return null ; <nl> + final Pair < UUID , Integer > pair = beginAndRepairPaxos ( start , key , metadata , liveEndpoints , requiredParticipants , consistencyForPaxos , consistencyForCommit , true ) ; <nl> + final UUID ballot = pair . left ; <nl> + contentions + = pair . right ; <nl> + <nl> + / / read the current values and check they validate the conditions <nl> + Tracing . trace ( " Reading existing values for CAS precondition " ) ; <nl> + long timestamp = System . currentTimeMillis ( ) ; <nl> + ReadCommand readCommand = ReadCommand . create ( keyspaceName , key , cfName , timestamp , conditions . readFilter ( ) ) ; <nl> + List < Row > rows = read ( Arrays . asList ( readCommand ) , consistencyForPaxos = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ) ; <nl> + ColumnFamily current = rows . get ( 0 ) . cf ; <nl> + if ( ! conditions . appliesTo ( current ) ) <nl> + { <nl> + Tracing . trace ( " CAS precondition { } does not match current values { } " , conditions , current ) ; <nl> + / / We should not return null as this means success <nl> + casWriteMetrics . conditionNotMet . inc ( ) ; <nl> + return current = = null ? EmptyColumns . factory . create ( metadata ) : current ; <nl> + } <nl> + <nl> + / / finish the paxos round w / the desired updates <nl> + / / TODO turn null updates into delete ? <nl> + <nl> + / / Apply triggers to cas updates . A consideration here is that <nl> + / / triggers emit RowMutations , and so a given trigger implementation <nl> + / / may generate mutations for partitions other than the one this <nl> + / / paxos round is scoped for . In this case , TriggerExecutor will <nl> + / / validate that the generated mutations are targetted at the same <nl> + / / partition as the initial updates and reject ( via an <nl> + / / InvalidRequestException ) any which aren ' t . <nl> + updates = TriggerExecutor . instance . execute ( key , updates ) ; <nl> + <nl> + Commit proposal = Commit . newProposal ( key , ballot , updates ) ; <nl> + Tracing . trace ( " CAS precondition is met ; proposing client - requested updates for { } " , ballot ) ; <nl> + if ( proposePaxos ( proposal , liveEndpoints , requiredParticipants , true , consistencyForPaxos ) ) <nl> + { <nl> + commitPaxos ( proposal , consistencyForCommit ) ; <nl> + Tracing . trace ( " CAS successful " ) ; <nl> + return null ; <nl> + } <nl> + <nl> + Tracing . trace ( " Paxos proposal not accepted ( pre - empted by a higher ballot ) " ) ; <nl> + contentions + + ; <nl> + Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; <nl> + / / continue to retry <nl> } <nl> <nl> - Tracing . trace ( " Paxos proposal not accepted ( pre - empted by a higher ballot ) " ) ; <nl> - Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; <nl> - / / continue to retry <nl> + throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( keyspaceName ) ) ) ; <nl> + } <nl> + catch ( WriteTimeoutException | ReadTimeoutException e ) <nl> + { <nl> + casWriteMetrics . timeouts . mark ( ) ; <nl> + throw e ; <nl> + } <nl> + catch ( UnavailableException e ) <nl> + { <nl> + casWriteMetrics . unavailables . mark ( ) ; <nl> + throw e ; <nl> + } <nl> + finally <nl> + { <nl> + if ( contentions > 0 ) <nl> + casWriteMetrics . contention . update ( contentions ) ; <nl> + <nl> + casWriteMetrics . addNano ( System . nanoTime ( ) - start ) ; <nl> } <nl> <nl> - throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( keyspaceName ) ) ) ; <nl> } <nl> <nl> private static Predicate < InetAddress > sameDCPredicateFor ( final String dc ) <nl> @ @ - 299 , 12 + 325 , 13 @ @ public class StorageProxy implements StorageProxyMBean <nl> * @ return the Paxos ballot promised by the replicas if no in - progress requests were seen and a quorum of <nl> * nodes have seen the mostRecentCommit . Otherwise , return null . <nl> * / <nl> - private static UUID beginAndRepairPaxos ( long start , ByteBuffer key , CFMetaData metadata , List < InetAddress > liveEndpoints , int requiredParticipants , ConsistencyLevel consistencyForPaxos , ConsistencyLevel consistencyForCommit ) <nl> + private static Pair < UUID , Integer > beginAndRepairPaxos ( long start , ByteBuffer key , CFMetaData metadata , List < InetAddress > liveEndpoints , int requiredParticipants , ConsistencyLevel consistencyForPaxos , ConsistencyLevel consistencyForCommit , final boolean isWrite ) <nl> throws WriteTimeoutException <nl> { <nl> long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; <nl> <nl> PrepareCallback summary = null ; <nl> + int contentions = 0 ; <nl> while ( System . nanoTime ( ) - start < timeout ) <nl> { <nl> long ballotMillis = summary = = null <nl> @ @ - 319 , 6 + 346 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> if ( ! summary . promised ) <nl> { <nl> Tracing . trace ( " Some replicas have already promised a higher ballot than ours ; aborting " ) ; <nl> + contentions + + ; <nl> / / sleep a random amount to give the other proposer a chance to finish <nl> Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; <nl> continue ; <nl> @ @ - 332 , 6 + 360 , 10 @ @ public class StorageProxy implements StorageProxyMBean <nl> if ( ! inProgress . update . isEmpty ( ) & & inProgress . isAfter ( mostRecent ) ) <nl> { <nl> Tracing . trace ( " Finishing incomplete paxos round { } " , inProgress ) ; <nl> + if ( isWrite ) <nl> + casWriteMetrics . unfinishedCommit . inc ( ) ; <nl> + else <nl> + casReadMetrics . unfinishedCommit . inc ( ) ; <nl> Commit refreshedInProgress = Commit . newProposal ( inProgress . key , ballot , inProgress . update ) ; <nl> if ( proposePaxos ( refreshedInProgress , liveEndpoints , requiredParticipants , false , consistencyForPaxos ) ) <nl> { <nl> @ @ - 341 , 6 + 373 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> Tracing . trace ( " Some replicas have already promised a higher ballot than ours ; aborting " ) ; <nl> / / sleep a random amount to give the other proposer a chance to finish <nl> + contentions + + ; <nl> Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; <nl> } <nl> continue ; <nl> @ @ - 362 , 7 + 395 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> continue ; <nl> } <nl> <nl> - return ballot ; <nl> + return Pair . create ( ballot , contentions ) ; <nl> } <nl> <nl> throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( metadata . ksName ) ) ) ; <nl> @ @ - 1151 , 7 + 1184 , 9 @ @ public class StorageProxy implements StorageProxyMBean <nl> final ConsistencyLevel consistencyForCommitOrFetch = consistency _ level = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ; <nl> try <nl> { <nl> - beginAndRepairPaxos ( start , command . key , metadata , liveEndpoints , requiredParticipants , consistency _ level , consistencyForCommitOrFetch ) ; <nl> + final Pair < UUID , Integer > pair = beginAndRepairPaxos ( start , command . key , metadata , liveEndpoints , requiredParticipants , consistency _ level , consistencyForCommitOrFetch , false ) ; <nl> + if ( pair . right > 0 ) <nl> + casReadMetrics . contention . update ( pair . right ) ; <nl> } <nl> catch ( WriteTimeoutException e ) <nl> { <nl> @ @ - 1169 , 18 + 1204 , 24 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> readMetrics . unavailables . mark ( ) ; <nl> ClientRequestMetrics . readUnavailables . inc ( ) ; <nl> + if ( consistency _ level . isSerialConsistency ( ) ) <nl> + casReadMetrics . unavailables . mark ( ) ; <nl> throw e ; <nl> } <nl> catch ( ReadTimeoutException e ) <nl> { <nl> readMetrics . timeouts . mark ( ) ; <nl> ClientRequestMetrics . readTimeouts . inc ( ) ; <nl> + if ( consistency _ level . isSerialConsistency ( ) ) <nl> + casReadMetrics . timeouts . mark ( ) ; <nl> throw e ; <nl> } <nl> finally <nl> { <nl> long latency = System . nanoTime ( ) - start ; <nl> readMetrics . addNano ( latency ) ; <nl> + if ( consistency _ level . isSerialConsistency ( ) ) <nl> + casReadMetrics . addNano ( latency ) ; <nl> / / TODO avoid giving every command the same latency number . Can fix this in CASSADRA - 5329 <nl> for ( ReadCommand command : commands ) <nl> Keyspace . open ( command . ksName ) . getColumnFamilyStore ( command . cfName ) . metric . coordinatorReadLatency . update ( latency , TimeUnit . NANOSECONDS ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / paxos / PaxosState . java b / src / java / org / apache / cassandra / service / paxos / PaxosState . java <nl> index ff0b02c . . 0196122 100644 <nl> - - - a / src / java / org / apache / cassandra / service / paxos / PaxosState . java <nl> + + + b / src / java / org / apache / cassandra / service / paxos / PaxosState . java <nl> @ @ - 69 , 55 + 69 , 79 @ @ public class PaxosState <nl> <nl> public static PrepareResponse prepare ( Commit toPrepare ) <nl> { <nl> - synchronized ( lockFor ( toPrepare . key ) ) <nl> + long start = System . nanoTime ( ) ; <nl> + try <nl> { <nl> - PaxosState state = SystemKeyspace . loadPaxosState ( toPrepare . key , toPrepare . update . metadata ( ) ) ; <nl> - if ( toPrepare . isAfter ( state . promised ) ) <nl> + synchronized ( lockFor ( toPrepare . key ) ) <nl> { <nl> - Tracing . trace ( " Promising ballot { } " , toPrepare . ballot ) ; <nl> - SystemKeyspace . savePaxosPromise ( toPrepare ) ; <nl> - return new PrepareResponse ( true , state . accepted , state . mostRecentCommit ) ; <nl> - } <nl> - else <nl> - { <nl> - Tracing . trace ( " Promise rejected ; { } is not sufficiently newer than { } " , toPrepare , state . promised ) ; <nl> - / / return the currently promised ballot ( not the last accepted one ) so the coordinator can make sure it uses newer ballot next time ( # 5667 ) <nl> - return new PrepareResponse ( false , state . promised , state . mostRecentCommit ) ; <nl> + PaxosState state = SystemKeyspace . loadPaxosState ( toPrepare . key , toPrepare . update . metadata ( ) ) ; <nl> + if ( toPrepare . isAfter ( state . promised ) ) <nl> + { <nl> + Tracing . trace ( " Promising ballot { } " , toPrepare . ballot ) ; <nl> + SystemKeyspace . savePaxosPromise ( toPrepare ) ; <nl> + return new PrepareResponse ( true , state . accepted , state . mostRecentCommit ) ; <nl> + } <nl> + else <nl> + { <nl> + Tracing . trace ( " Promise rejected ; { } is not sufficiently newer than { } " , toPrepare , state . promised ) ; <nl> + / / return the currently promised ballot ( not the last accepted one ) so the coordinator can make sure it uses newer ballot next time
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 8bfbcd5 . . e187841 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 197 , 7 + 197 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> * @ return true if the operation succeeds in updating the row <nl> * / <nl> public static boolean cas ( String table , String cfName , ByteBuffer key , ColumnFamily expected , ColumnFamily updates ) <nl> - throws UnavailableException , IOException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException <nl> + throws UnavailableException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException <nl> { <nl> CFMetaData metadata = Schema . instance . getCFMetaData ( table , cfName ) ; <nl>

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 index 3dc269f . . a3838a0 100644 
 - - - a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 @ @ - 93 , 6 + 93 , 12 @ @ public class ColumnFamilyMetrics 
 public final ColumnFamilyHistogram tombstoneScannedHistogram ; 
 / * * Live cells scanned in queries on this CF * / 
 public final ColumnFamilyHistogram liveScannedHistogram ; 
 + / * * CAS Prepare metrics * / 
 + public final LatencyMetrics casPrepare ; 
 + / * * CAS Propose metrics * / 
 + public final LatencyMetrics casPropose ; 
 + / * * CAS Commit metrics * / 
 + public final LatencyMetrics casCommit ; 
 
 public final Timer coordinatorReadLatency ; 
 public final Timer coordinatorScanLatency ; 
 @ @ - 444 , 6 + 450 , 9 @ @ public class ColumnFamilyMetrics 
 liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram ) ; 
 coordinatorReadLatency = Metrics . newTimer ( factory . createMetricName ( " CoordinatorReadLatency " ) , TimeUnit . MICROSECONDS , TimeUnit . SECONDS ) ; 
 coordinatorScanLatency = Metrics . newTimer ( factory . createMetricName ( " CoordinatorScanLatency " ) , TimeUnit . MICROSECONDS , TimeUnit . SECONDS ) ; 
 + casPrepare = new LatencyMetrics ( factory , " CasPrepare " , cfs . keyspace . metric . casPrepare ) ; 
 + casPropose = new LatencyMetrics ( factory , " CasPropose " , cfs . keyspace . metric . casPropose ) ; 
 + casCommit = new LatencyMetrics ( factory , " CasCommit " , cfs . keyspace . metric . casCommit ) ; 
 } 
 
 public void updateSSTableIterated ( int count ) 
 diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 index 7dcf9d5 . . 7a768b8 100644 
 - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 @ @ - 62 , 6 + 62 , 12 @ @ public class KeyspaceMetrics 
 public final Histogram tombstoneScannedHistogram ; 
 / * * Live cells scanned in queries on this Keyspace * / 
 public final Histogram liveScannedHistogram ; 
 + / * * CAS Prepare metric * / 
 + public final LatencyMetrics casPrepare ; 
 + / * * CAS Propose metrics * / 
 + public final LatencyMetrics casPropose ; 
 + / * * CAS Commit metrics * / 
 + public final LatencyMetrics casCommit ; 
 
 private final MetricNameFactory factory ; 
 private Keyspace keyspace ; 
 @ @ - 151 , 6 + 157 , 10 @ @ public class KeyspaceMetrics 
 liveScannedHistogram = Metrics . newHistogram ( factory . createMetricName ( " LiveScannedHistogram " ) , true ) ; 
 / / add manually since histograms do not use createKeyspaceGauge method 
 allMetrics . addAll ( Lists . newArrayList ( " SSTablesPerReadHistogram " , " TombstoneScannedHistogram " , " LiveScannedHistogram " ) ) ; 
 + 
 + casPrepare = new LatencyMetrics ( factory , " CasPrepare " ) ; 
 + casPropose = new LatencyMetrics ( factory , " CasPropose " ) ; 
 + casCommit = new LatencyMetrics ( factory , " CasCommit " ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 904d602 . . d8b6619 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import com . google . common . base . Predicate ; 
 import com . google . common . cache . CacheLoader ; 
 import com . google . common . collect . * ; 
 import com . google . common . util . concurrent . Uninterruptibles ; 
 + import org . apache . cassandra . metrics . * ; 
 import org . apache . commons . lang3 . StringUtils ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 55 , 9 + 56 , 6 @ @ import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . IEndpointSnitch ; 
 import org . apache . cassandra . locator . LocalStrategy ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 - import org . apache . cassandra . metrics . ClientRequestMetrics ; 
 - import org . apache . cassandra . metrics . ReadRepairMetrics ; 
 - import org . apache . cassandra . metrics . StorageMetrics ; 
 import org . apache . cassandra . net . * ; 
 import org . apache . cassandra . service . paxos . * ; 
 import org . apache . cassandra . sink . SinkManager ; 
 @ @ - 90 , 6 + 88 , 8 @ @ public class StorageProxy implements StorageProxyMBean 
 private static final ClientRequestMetrics readMetrics = new ClientRequestMetrics ( " Read " ) ; 
 private static final ClientRequestMetrics rangeMetrics = new ClientRequestMetrics ( " RangeSlice " ) ; 
 private static final ClientRequestMetrics writeMetrics = new ClientRequestMetrics ( " Write " ) ; 
 + private static final CASClientRequestMetrics casWriteMetrics = new CASClientRequestMetrics ( " CASWrite " ) ; 
 + private static final CASClientRequestMetrics casReadMetrics = new CASClientRequestMetrics ( " CASRead " ) ; 
 
 private StorageProxy ( ) { } 
 
 @ @ - 203 , 62 + 203 , 88 @ @ public class StorageProxy implements StorageProxyMBean 
 ConsistencyLevel consistencyForCommit ) 
 throws UnavailableException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException 
 { 
 - consistencyForPaxos . validateForCas ( ) ; 
 - consistencyForCommit . validateForCasCommit ( keyspaceName ) ; 
 - 
 - CFMetaData metadata = Schema . instance . getCFMetaData ( keyspaceName , cfName ) ; 
 - 
 long start = System . nanoTime ( ) ; 
 - long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; 
 - while ( System . nanoTime ( ) - start < timeout ) 
 + int contentions = 0 ; 
 + try 
 { 
 - / / for simplicity , we ' ll do a single liveness check at the start of each attempt 
 - Pair < List < InetAddress > , Integer > p = getPaxosParticipants ( keyspaceName , key , consistencyForPaxos ) ; 
 - List < InetAddress > liveEndpoints = p . left ; 
 - int requiredParticipants = p . right ; 
 + consistencyForPaxos . validateForCas ( ) ; 
 + consistencyForCommit . validateForCasCommit ( keyspaceName ) ; 
 
 - UUID ballot = beginAndRepairPaxos ( start , key , metadata , liveEndpoints , requiredParticipants , consistencyForPaxos , consistencyForCommit ) ; 
 + CFMetaData metadata = Schema . instance . getCFMetaData ( keyspaceName , cfName ) ; 
 
 - / / read the current values and check they validate the conditions 
 - Tracing . trace ( " Reading existing values for CAS precondition " ) ; 
 - long timestamp = System . currentTimeMillis ( ) ; 
 - ReadCommand readCommand = ReadCommand . create ( keyspaceName , key , cfName , timestamp , conditions . readFilter ( ) ) ; 
 - List < Row > rows = read ( Arrays . asList ( readCommand ) , consistencyForPaxos = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ) ; 
 - ColumnFamily current = rows . get ( 0 ) . cf ; 
 - if ( ! conditions . appliesTo ( current ) ) 
 + long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; 
 + while ( System . nanoTime ( ) - start < timeout ) 
 { 
 - Tracing . trace ( " CAS precondition { } does not match current values { } " , conditions , current ) ; 
 - / / We should not return null as this means success 
 - return current = = null ? EmptyColumns . factory . create ( metadata ) : current ; 
 - } 
 + / / for simplicity , we ' ll do a single liveness check at the start of each attempt 
 + Pair < List < InetAddress > , Integer > p = getPaxosParticipants ( keyspaceName , key , consistencyForPaxos ) ; 
 + List < InetAddress > liveEndpoints = p . left ; 
 + int requiredParticipants = p . right ; 
 
 - / / finish the paxos round w / the desired updates 
 - / / TODO turn null updates into delete ? 
 - 
 - / / Apply triggers to cas updates . A consideration here is that 
 - / / triggers emit RowMutations , and so a given trigger implementation 
 - / / may generate mutations for partitions other than the one this 
 - / / paxos round is scoped for . In this case , TriggerExecutor will 
 - / / validate that the generated mutations are targetted at the same 
 - / / partition as the initial updates and reject ( via an 
 - / / InvalidRequestException ) any which aren ' t . 
 - updates = TriggerExecutor . instance . execute ( key , updates ) ; 
 - 
 - Commit proposal = Commit . newProposal ( key , ballot , updates ) ; 
 - Tracing . trace ( " CAS precondition is met ; proposing client - requested updates for { } " , ballot ) ; 
 - if ( proposePaxos ( proposal , liveEndpoints , requiredParticipants , true , consistencyForPaxos ) ) 
 - { 
 - commitPaxos ( proposal , consistencyForCommit ) ; 
 - Tracing . trace ( " CAS successful " ) ; 
 - return null ; 
 + final Pair < UUID , Integer > pair = beginAndRepairPaxos ( start , key , metadata , liveEndpoints , requiredParticipants , consistencyForPaxos , consistencyForCommit , true ) ; 
 + final UUID ballot = pair . left ; 
 + contentions + = pair . right ; 
 + 
 + / / read the current values and check they validate the conditions 
 + Tracing . trace ( " Reading existing values for CAS precondition " ) ; 
 + long timestamp = System . currentTimeMillis ( ) ; 
 + ReadCommand readCommand = ReadCommand . create ( keyspaceName , key , cfName , timestamp , conditions . readFilter ( ) ) ; 
 + List < Row > rows = read ( Arrays . asList ( readCommand ) , consistencyForPaxos = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ) ; 
 + ColumnFamily current = rows . get ( 0 ) . cf ; 
 + if ( ! conditions . appliesTo ( current ) ) 
 + { 
 + Tracing . trace ( " CAS precondition { } does not match current values { } " , conditions , current ) ; 
 + / / We should not return null as this means success 
 + casWriteMetrics . conditionNotMet . inc ( ) ; 
 + return current = = null ? EmptyColumns . factory . create ( metadata ) : current ; 
 + } 
 + 
 + / / finish the paxos round w / the desired updates 
 + / / TODO turn null updates into delete ? 
 + 
 + / / Apply triggers to cas updates . A consideration here is that 
 + / / triggers emit RowMutations , and so a given trigger implementation 
 + / / may generate mutations for partitions other than the one this 
 + / / paxos round is scoped for . In this case , TriggerExecutor will 
 + / / validate that the generated mutations are targetted at the same 
 + / / partition as the initial updates and reject ( via an 
 + / / InvalidRequestException ) any which aren ' t . 
 + updates = TriggerExecutor . instance . execute ( key , updates ) ; 
 + 
 + Commit proposal = Commit . newProposal ( key , ballot , updates ) ; 
 + Tracing . trace ( " CAS precondition is met ; proposing client - requested updates for { } " , ballot ) ; 
 + if ( proposePaxos ( proposal , liveEndpoints , requiredParticipants , true , consistencyForPaxos ) ) 
 + { 
 + commitPaxos ( proposal , consistencyForCommit ) ; 
 + Tracing . trace ( " CAS successful " ) ; 
 + return null ; 
 + } 
 + 
 + Tracing . trace ( " Paxos proposal not accepted ( pre - empted by a higher ballot ) " ) ; 
 + contentions + + ; 
 + Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; 
 + / / continue to retry 
 } 
 
 - Tracing . trace ( " Paxos proposal not accepted ( pre - empted by a higher ballot ) " ) ; 
 - Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; 
 - / / continue to retry 
 + throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( keyspaceName ) ) ) ; 
 + } 
 + catch ( WriteTimeoutException | ReadTimeoutException e ) 
 + { 
 + casWriteMetrics . timeouts . mark ( ) ; 
 + throw e ; 
 + } 
 + catch ( UnavailableException e ) 
 + { 
 + casWriteMetrics . unavailables . mark ( ) ; 
 + throw e ; 
 + } 
 + finally 
 + { 
 + if ( contentions > 0 ) 
 + casWriteMetrics . contention . update ( contentions ) ; 
 + 
 + casWriteMetrics . addNano ( System . nanoTime ( ) - start ) ; 
 } 
 
 - throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( keyspaceName ) ) ) ; 
 } 
 
 private static Predicate < InetAddress > sameDCPredicateFor ( final String dc ) 
 @ @ - 299 , 12 + 325 , 13 @ @ public class StorageProxy implements StorageProxyMBean 
 * @ return the Paxos ballot promised by the replicas if no in - progress requests were seen and a quorum of 
 * nodes have seen the mostRecentCommit . Otherwise , return null . 
 * / 
 - private static UUID beginAndRepairPaxos ( long start , ByteBuffer key , CFMetaData metadata , List < InetAddress > liveEndpoints , int requiredParticipants , ConsistencyLevel consistencyForPaxos , ConsistencyLevel consistencyForCommit ) 
 + private static Pair < UUID , Integer > beginAndRepairPaxos ( long start , ByteBuffer key , CFMetaData metadata , List < InetAddress > liveEndpoints , int requiredParticipants , ConsistencyLevel consistencyForPaxos , ConsistencyLevel consistencyForCommit , final boolean isWrite ) 
 throws WriteTimeoutException 
 { 
 long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; 
 
 PrepareCallback summary = null ; 
 + int contentions = 0 ; 
 while ( System . nanoTime ( ) - start < timeout ) 
 { 
 long ballotMillis = summary = = null 
 @ @ - 319 , 6 + 346 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 if ( ! summary . promised ) 
 { 
 Tracing . trace ( " Some replicas have already promised a higher ballot than ours ; aborting " ) ; 
 + contentions + + ; 
 / / sleep a random amount to give the other proposer a chance to finish 
 Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; 
 continue ; 
 @ @ - 332 , 6 + 360 , 10 @ @ public class StorageProxy implements StorageProxyMBean 
 if ( ! inProgress . update . isEmpty ( ) & & inProgress . isAfter ( mostRecent ) ) 
 { 
 Tracing . trace ( " Finishing incomplete paxos round { } " , inProgress ) ; 
 + if ( isWrite ) 
 + casWriteMetrics . unfinishedCommit . inc ( ) ; 
 + else 
 + casReadMetrics . unfinishedCommit . inc ( ) ; 
 Commit refreshedInProgress = Commit . newProposal ( inProgress . key , ballot , inProgress . update ) ; 
 if ( proposePaxos ( refreshedInProgress , liveEndpoints , requiredParticipants , false , consistencyForPaxos ) ) 
 { 
 @ @ - 341 , 6 + 373 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 Tracing . trace ( " Some replicas have already promised a higher ballot than ours ; aborting " ) ; 
 / / sleep a random amount to give the other proposer a chance to finish 
 + contentions + + ; 
 Uninterruptibles . sleepUninterruptibly ( FBUtilities . threadLocalRandom ( ) . nextInt ( 100 ) , TimeUnit . MILLISECONDS ) ; 
 } 
 continue ; 
 @ @ - 362 , 7 + 395 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 continue ; 
 } 
 
 - return ballot ; 
 + return Pair . create ( ballot , contentions ) ; 
 } 
 
 throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , 0 , consistencyForPaxos . blockFor ( Keyspace . open ( metadata . ksName ) ) ) ; 
 @ @ - 1151 , 7 + 1184 , 9 @ @ public class StorageProxy implements StorageProxyMBean 
 final ConsistencyLevel consistencyForCommitOrFetch = consistency _ level = = ConsistencyLevel . LOCAL _ SERIAL ? ConsistencyLevel . LOCAL _ QUORUM : ConsistencyLevel . QUORUM ; 
 try 
 { 
 - beginAndRepairPaxos ( start , command . key , metadata , liveEndpoints , requiredParticipants , consistency _ level , consistencyForCommitOrFetch ) ; 
 + final Pair < UUID , Integer > pair = beginAndRepairPaxos ( start , command . key , metadata , liveEndpoints , requiredParticipants , consistency _ level , consistencyForCommitOrFetch , false ) ; 
 + if ( pair . right > 0 ) 
 + casReadMetrics . contention . update ( pair . right ) ; 
 } 
 catch ( WriteTimeoutException e ) 
 { 
 @ @ - 1169 , 18 + 1204 , 24 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 readMetrics . unavailables . mark ( ) ; 
 ClientRequestMetrics . readUnavailables . inc ( ) ; 
 + if ( consistency _ level . isSerialConsistency ( ) ) 
 + casReadMetrics . unavailables . mark ( ) ; 
 throw e ; 
 } 
 catch ( ReadTimeoutException e ) 
 { 
 readMetrics . timeouts . mark ( ) ; 
 ClientRequestMetrics . readTimeouts . inc ( ) ; 
 + if ( consistency _ level . isSerialConsistency ( ) ) 
 + casReadMetrics . timeouts . mark ( ) ; 
 throw e ; 
 } 
 finally 
 { 
 long latency = System . nanoTime ( ) - start ; 
 readMetrics . addNano ( latency ) ; 
 + if ( consistency _ level . isSerialConsistency ( ) ) 
 + casReadMetrics . addNano ( latency ) ; 
 / / TODO avoid giving every command the same latency number . Can fix this in CASSADRA - 5329 
 for ( ReadCommand command : commands ) 
 Keyspace . open ( command . ksName ) . getColumnFamilyStore ( command . cfName ) . metric . coordinatorReadLatency . update ( latency , TimeUnit . NANOSECONDS ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / paxos / PaxosState . java b / src / java / org / apache / cassandra / service / paxos / PaxosState . java 
 index ff0b02c . . 0196122 100644 
 - - - a / src / java / org / apache / cassandra / service / paxos / PaxosState . java 
 + + + b / src / java / org / apache / cassandra / service / paxos / PaxosState . java 
 @ @ - 69 , 55 + 69 , 79 @ @ public class PaxosState 
 
 public static PrepareResponse prepare ( Commit toPrepare ) 
 { 
 - synchronized ( lockFor ( toPrepare . key ) ) 
 + long start = System . nanoTime ( ) ; 
 + try 
 { 
 - PaxosState state = SystemKeyspace . loadPaxosState ( toPrepare . key , toPrepare . update . metadata ( ) ) ; 
 - if ( toPrepare . isAfter ( state . promised ) ) 
 + synchronized ( lockFor ( toPrepare . key ) ) 
 { 
 - Tracing . trace ( " Promising ballot { } " , toPrepare . ballot ) ; 
 - SystemKeyspace . savePaxosPromise ( toPrepare ) ; 
 - return new PrepareResponse ( true , state . accepted , state . mostRecentCommit ) ; 
 - } 
 - else 
 - { 
 - Tracing . trace ( " Promise rejected ; { } is not sufficiently newer than { } " , toPrepare , state . promised ) ; 
 - / / return the currently promised ballot ( not the last accepted one ) so the coordinator can make sure it uses newer ballot next time ( # 5667 ) 
 - return new PrepareResponse ( false , state . promised , state . mostRecentCommit ) ; 
 + PaxosState state = SystemKeyspace . loadPaxosState ( toPrepare . key , toPrepare . update . metadata ( ) ) ; 
 + if ( toPrepare . isAfter ( state . promised ) ) 
 + { 
 + Tracing . trace ( " Promising ballot { } " , toPrepare . ballot ) ; 
 + SystemKeyspace . savePaxosPromise ( toPrepare ) ; 
 + return new PrepareResponse ( true , state . accepted , state . mostRecentCommit ) ; 
 + } 
 + else 
 + { 
 + Tracing . trace ( " Promise rejected ; { } is not sufficiently newer than { } " , toPrepare , state . promised ) ; 
 + / / return the currently promised ballot ( not the last accepted one ) so the coordinator can make sure it uses newer ballot next time

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 8bfbcd5 . . e187841 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 197 , 7 + 197 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 * @ return true if the operation succeeds in updating the row 
 * / 
 public static boolean cas ( String table , String cfName , ByteBuffer key , ColumnFamily expected , ColumnFamily updates ) 
 - throws UnavailableException , IOException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException 
 + throws UnavailableException , IsBootstrappingException , ReadTimeoutException , WriteTimeoutException , InvalidRequestException 
 { 
 CFMetaData metadata = Schema . instance . getCFMetaData ( table , cfName ) ; 

