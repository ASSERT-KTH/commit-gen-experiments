BLEU SCORE: 0.05341087579952926

TEST MSG: Fix merkle tree depth calculation
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 998849e . . 97bc70a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 9 <nl> + * Fix merkle tree depth calculation ( CASSANDRA - 12580 ) <nl> * Make Collections deserialization more robust ( CASSANDRA - 12618 ) <nl> <nl> <nl> @ @ - 36 , 7 + 37 , 6 @ @ <nl> * Don ' t write shadowed range tombstone ( CASSANDRA - 12030 ) <nl> Merged from 2 . 1 : <nl> * Add system property to set the max number of native transport requests in queue ( CASSANDRA - 11363 ) <nl> - * Fix queries with empty ByteBuffer values in clustering column restrictions ( CASSANDRA - 12127 ) <nl> * Disable passing control to post - flush after flush failure to prevent data loss ( CASSANDRA - 11828 ) <nl> * Allow STCS - in - L0 compactions to reduce scope with LCS ( CASSANDRA - 12040 ) <nl> * cannot use cql since upgrading python to 2 . 7 . 11 + ( CASSANDRA - 11850 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index cf82498 . . 78fa23c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 1112 , 8 + 1112 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> numPartitions + = sstable . estimatedKeysForRanges ( singleton ( validator . desc . range ) ) ; <nl> } <nl> - / / determine tree depth from number of partitions , but cap at 20 to prevent large tree . <nl> - int depth = numPartitions > 0 ? ( int ) Math . min ( Math . floor ( Math . log ( numPartitions ) ) , 20 ) : 0 ; <nl> + / / determine tree depth from number of partitions , but cap at 20 to prevent large tree ( CASSANDRA - 5263 ) <nl> + int depth = numPartitions > 0 ? ( int ) Math . min ( Math . ceil ( Math . log ( numPartitions ) / Math . log ( 2 ) ) , 20 ) : 0 ; <nl> MerkleTree tree = new MerkleTree ( cfs . partitioner , validator . desc . range , MerkleTree . RECOMMENDED _ DEPTH , ( int ) Math . pow ( 2 , depth ) ) ; <nl> <nl> long start = System . nanoTime ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / repair / Validator . java b / src / java / org / apache / cassandra / repair / Validator . java <nl> index 4db1cfb . . 8dbb4cf 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / Validator . java <nl> + + + b / src / java / org / apache / cassandra / repair / Validator . java <nl> @ @ - 54 , 6 + 54 , 7 @ @ public class Validator implements Runnable <nl> public final RepairJobDesc desc ; <nl> public final InetAddress initiator ; <nl> public final int gcBefore ; <nl> + private final boolean evenTreeDistribution ; <nl> <nl> / / null when all rows with the min token have been consumed <nl> private long validated ; <nl> @ @ - 67 , 19 + 68 , 25 @ @ public class Validator implements Runnable <nl> <nl> public Validator ( RepairJobDesc desc , InetAddress initiator , int gcBefore ) <nl> { <nl> + this ( desc , initiator , gcBefore , false ) ; <nl> + } <nl> + <nl> + public Validator ( RepairJobDesc desc , InetAddress initiator , int gcBefore , boolean evenTreeDistribution ) <nl> + { <nl> this . desc = desc ; <nl> this . initiator = initiator ; <nl> this . gcBefore = gcBefore ; <nl> validated = 0 ; <nl> range = null ; <nl> ranges = null ; <nl> + this . evenTreeDistribution = evenTreeDistribution ; <nl> } <nl> <nl> public void prepare ( ColumnFamilyStore cfs , MerkleTree tree ) <nl> { <nl> this . tree = tree ; <nl> <nl> - if ( ! tree . partitioner ( ) . preservesOrder ( ) ) <nl> + if ( ! tree . partitioner ( ) . preservesOrder ( ) | | evenTreeDistribution ) <nl> { <nl> / / You can ' t beat an even tree distribution for md5 <nl> tree . init ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / MerkleTree . java b / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> index 4fec62d . . 1e0f505 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> + + + b / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> @ @ - 516 , 6 + 516 , 16 @ @ public class MerkleTree implements Serializable <nl> return histbuild . buildWithStdevRangesAroundMean ( ) ; <nl> } <nl> <nl> + public long rowCount ( ) <nl> + { <nl> + long count = 0 ; <nl> + for ( TreeRange range : new TreeRangeIterator ( this ) ) <nl> + { <nl> + count + = range . hashable . rowsInRange ; <nl> + } <nl> + return count ; <nl> + } <nl> + <nl> @ Override <nl> public String toString ( ) <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> index 8ff3022 . . 471f8cf 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> @ @ - 125 , 7 + 125 , 7 @ @ public class CompactionsTest <nl> return store ; <nl> } <nl> <nl> - private long populate ( String ks , String cf , int startRowKey , int endRowKey , int ttl ) <nl> + public static long populate ( String ks , String cf , int startRowKey , int endRowKey , int ttl ) <nl> { <nl> long timestamp = System . currentTimeMillis ( ) ; <nl> for ( int i = startRowKey ; i < = endRowKey ; i + + ) <nl> diff - - git a / test / unit / org / apache / cassandra / repair / ValidatorTest . java b / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> index a9f18f5 . . 61ab3da 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / ValidatorTest . java <nl> @ @ - 20 , 8 + 20 , 16 @ @ package org . apache . cassandra . repair ; <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> import java . security . MessageDigest ; <nl> + import java . util . Collections ; <nl> import java . util . UUID ; <nl> + import java . util . concurrent . TimeUnit ; <nl> <nl> + import com . google . common . util . concurrent . ListenableFuture ; <nl> + import com . google . common . util . concurrent . SettableFuture ; <nl> + <nl> + import org . apache . cassandra . db . compaction . CompactionManager ; <nl> + import org . apache . cassandra . db . compaction . CompactionsTest ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . io . util . SequentialWriter ; <nl> import org . junit . After ; <nl> import org . junit . BeforeClass ; <nl> @ @ - 46 , 15 + 54 , 20 @ @ import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . net . IMessageSink ; <nl> import org . apache . cassandra . repair . messages . RepairMessage ; <nl> import org . apache . cassandra . repair . messages . ValidationComplete ; <nl> + import org . apache . cassandra . service . ActiveRepairService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . MerkleTree ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> import org . apache . cassandra . utils . concurrent . SimpleCondition ; <nl> <nl> import static org . junit . Assert . * ; <nl> <nl> public class ValidatorTest <nl> { <nl> + private static final long TEST _ TIMEOUT = 60 ; / / seconds <nl> + <nl> private static final String keyspace = " ValidatorTest " ; <nl> private static final String columnFamily = " Standard1 " ; <nl> private final IPartitioner partitioner = StorageService . getPartitioner ( ) ; <nl> @ @ - 81 , 35 + 94 , 7 @ @ public class ValidatorTest <nl> Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; <nl> final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , range ) ; <nl> <nl> - final SimpleCondition lock = new SimpleCondition ( ) ; <nl> - MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) <nl> - { <nl> - @ SuppressWarnings ( " unchecked " ) <nl> - public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) <nl> - { <nl> - try <nl> - { <nl> - if ( message . verb = = MessagingService . Verb . REPAIR _ MESSAGE ) <nl> - { <nl> - RepairMessage m = ( RepairMessage ) message . payload ; <nl> - assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; <nl> - assertEquals ( desc , m . desc ) ; <nl> - assertTrue ( ( ( ValidationComplete ) m ) . success ) ; <nl> - assertNotNull ( ( ( ValidationComplete ) m ) . tree ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock . signalAll ( ) ; <nl> - } <nl> - return false ; <nl> - } <nl> - <nl> - public boolean allowIncomingMessage ( MessageIn message , int id ) <nl> - { <nl> - return false ; <nl> - } <nl> - } ) ; <nl> + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; <nl> <nl> InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> <nl> @ @ - 131 , 8 + 116 , 13 @ @ public class ValidatorTest <nl> Token min = tree . partitioner ( ) . getMinimumToken ( ) ; <nl> assertNotNull ( tree . hash ( new Range < > ( min , min ) ) ) ; <nl> <nl> - if ( ! lock . isSignaled ( ) ) <nl> - lock . await ( ) ; <nl> + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; <nl> + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; <nl> + RepairMessage m = ( RepairMessage ) message . payload ; <nl> + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; <nl> + assertEquals ( desc , m . desc ) ; <nl> + assertTrue ( ( ( ValidationComplete ) m ) . success ) ; <nl> + assertNotNull ( ( ( ValidationComplete ) m ) . tree ) ; <nl> } <nl> <nl> private static class CompactedRowStub extends AbstractCompactedRow <nl> @ @ - 163 , 27 + 153 , 91 @ @ public class ValidatorTest <nl> Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; <nl> final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , range ) ; <nl> <nl> - final SimpleCondition lock = new SimpleCondition ( ) ; <nl> + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; <nl> + <nl> + InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> + <nl> + Validator validator = new Validator ( desc , remote , 0 ) ; <nl> + validator . fail ( ) ; <nl> + <nl> + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; <nl> + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; <nl> + RepairMessage m = ( RepairMessage ) message . payload ; <nl> + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; <nl> + assertEquals ( desc , m . desc ) ; <nl> + assertFalse ( ( ( ValidationComplete ) m ) . success ) ; <nl> + assertNull ( ( ( ValidationComplete ) m ) . tree ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void simpleValidationTest128 ( ) throws Exception <nl> + { <nl> + simpleValidationTest ( 128 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void simpleValidationTest1500 ( ) throws Exception <nl> + { <nl> + simpleValidationTest ( 1500 ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test for CASSANDRA - 5263 <nl> + * 1 . Create N rows <nl> + * 2 . Run validation compaction <nl> + * 3 . Expect merkle tree with size 2 ^ ( log2 ( n ) ) <nl> + * / <nl> + public void simpleValidationTest ( int n ) throws Exception <nl> + { <nl> + Keyspace ks = Keyspace . open ( keyspace ) ; <nl> + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( columnFamily ) ; <nl> + cfs . clearUnsafe ( ) ; <nl> + <nl> + / / disable compaction while flushing <nl> + cfs . disableAutoCompaction ( ) ; <nl> + <nl> + CompactionsTest . populate ( keyspace , columnFamily , 0 , n , 0 ) ; / / ttl = 3s <nl> + <nl> + cfs . forceBlockingFlush ( ) ; <nl> + assertEquals ( 1 , cfs . getSSTables ( ) . size ( ) ) ; <nl> + <nl> + / / wait enough to force single compaction <nl> + TimeUnit . SECONDS . sleep ( 5 ) ; <nl> + <nl> + SSTableReader sstable = cfs . getSSTables ( ) . iterator ( ) . next ( ) ; <nl> + UUID repairSessionId = UUIDGen . getTimeUUID ( ) ; <nl> + final RepairJobDesc desc = new RepairJobDesc ( repairSessionId , UUIDGen . getTimeUUID ( ) , cfs . keyspace . getName ( ) , <nl> + cfs . getColumnFamilyName ( ) , new Range < Token > ( sstable . first . getToken ( ) , <nl> + sstable . last . getToken ( ) ) ) ; <nl> + <nl> + ActiveRepairService . instance . registerParentRepairSession ( repairSessionId , FBUtilities . getBroadcastAddress ( ) , <nl> + Collections . singletonList ( cfs ) , Collections . singleton ( desc . range ) , <nl> + false , false ) ; <nl> + <nl> + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; <nl> + Validator validator = new Validator ( desc , FBUtilities . getBroadcastAddress ( ) , 0 , true ) ; <nl> + CompactionManager . instance . submitValidation ( cfs , validator ) ; <nl> + <nl> + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; <nl> + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; <nl> + RepairMessage m = ( RepairMessage ) message . payload ; <nl> + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; <nl> + assertEquals ( desc , m . desc ) ; <nl> + assertTrue ( ( ( ValidationComplete ) m ) . success ) ; <nl> + MerkleTree tree = ( ( ValidationComplete ) m ) . tree ; <nl> + <nl> + assertEquals ( Math . pow ( 2 , Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) , tree . size ( ) , 0 . 0 ) ; <nl> + assertEquals ( tree . rowCount ( ) , n ) ; <nl> + } <nl> + <nl> + private ListenableFuture < MessageOut > registerOutgoingMessageSink ( ) <nl> + { <nl> + final SettableFuture < MessageOut > future = SettableFuture . create ( ) ; <nl> MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) <nl> { <nl> - @ SuppressWarnings ( " unchecked " ) <nl> public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) <nl> { <nl> - try <nl> - { <nl> - if ( message . verb = = MessagingService . Verb . REPAIR _ MESSAGE ) <nl> - { <nl> - RepairMessage m = ( RepairMessage ) message . payload ; <nl> - assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; <nl> - assertEquals ( desc , m . desc ) ; <nl> - assertFalse ( ( ( ValidationComplete ) m ) . success ) ; <nl> - assertNull ( ( ( ValidationComplete ) m ) . tree ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock . signalAll ( ) ; <nl> - } <nl> + future . set ( message ) ; <nl> return false ; <nl> } <nl> <nl> @ @ - 192 , 13 + 246 , 6 @ @ public class ValidatorTest <nl> return false ; <nl> } <nl> } ) ; <nl> - <nl> - InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> - <nl> - Validator validator = new Validator ( desc , remote , 0 ) ; <nl> - validator . fail ( ) ; <nl> - <nl> - if ( ! lock . isSignaled ( ) ) <nl> - lock . await ( ) ; <nl> + return future ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 998849e . . 97bc70a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 9 
 + * Fix merkle tree depth calculation ( CASSANDRA - 12580 ) 
 * Make Collections deserialization more robust ( CASSANDRA - 12618 ) 
 
 
 @ @ - 36 , 7 + 37 , 6 @ @ 
 * Don ' t write shadowed range tombstone ( CASSANDRA - 12030 ) 
 Merged from 2 . 1 : 
 * Add system property to set the max number of native transport requests in queue ( CASSANDRA - 11363 ) 
 - * Fix queries with empty ByteBuffer values in clustering column restrictions ( CASSANDRA - 12127 ) 
 * Disable passing control to post - flush after flush failure to prevent data loss ( CASSANDRA - 11828 ) 
 * Allow STCS - in - L0 compactions to reduce scope with LCS ( CASSANDRA - 12040 ) 
 * cannot use cql since upgrading python to 2 . 7 . 11 + ( CASSANDRA - 11850 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index cf82498 . . 78fa23c 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 1112 , 8 + 1112 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 numPartitions + = sstable . estimatedKeysForRanges ( singleton ( validator . desc . range ) ) ; 
 } 
 - / / determine tree depth from number of partitions , but cap at 20 to prevent large tree . 
 - int depth = numPartitions > 0 ? ( int ) Math . min ( Math . floor ( Math . log ( numPartitions ) ) , 20 ) : 0 ; 
 + / / determine tree depth from number of partitions , but cap at 20 to prevent large tree ( CASSANDRA - 5263 ) 
 + int depth = numPartitions > 0 ? ( int ) Math . min ( Math . ceil ( Math . log ( numPartitions ) / Math . log ( 2 ) ) , 20 ) : 0 ; 
 MerkleTree tree = new MerkleTree ( cfs . partitioner , validator . desc . range , MerkleTree . RECOMMENDED _ DEPTH , ( int ) Math . pow ( 2 , depth ) ) ; 
 
 long start = System . nanoTime ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / repair / Validator . java b / src / java / org / apache / cassandra / repair / Validator . java 
 index 4db1cfb . . 8dbb4cf 100644 
 - - - a / src / java / org / apache / cassandra / repair / Validator . java 
 + + + b / src / java / org / apache / cassandra / repair / Validator . java 
 @ @ - 54 , 6 + 54 , 7 @ @ public class Validator implements Runnable 
 public final RepairJobDesc desc ; 
 public final InetAddress initiator ; 
 public final int gcBefore ; 
 + private final boolean evenTreeDistribution ; 
 
 / / null when all rows with the min token have been consumed 
 private long validated ; 
 @ @ - 67 , 19 + 68 , 25 @ @ public class Validator implements Runnable 
 
 public Validator ( RepairJobDesc desc , InetAddress initiator , int gcBefore ) 
 { 
 + this ( desc , initiator , gcBefore , false ) ; 
 + } 
 + 
 + public Validator ( RepairJobDesc desc , InetAddress initiator , int gcBefore , boolean evenTreeDistribution ) 
 + { 
 this . desc = desc ; 
 this . initiator = initiator ; 
 this . gcBefore = gcBefore ; 
 validated = 0 ; 
 range = null ; 
 ranges = null ; 
 + this . evenTreeDistribution = evenTreeDistribution ; 
 } 
 
 public void prepare ( ColumnFamilyStore cfs , MerkleTree tree ) 
 { 
 this . tree = tree ; 
 
 - if ( ! tree . partitioner ( ) . preservesOrder ( ) ) 
 + if ( ! tree . partitioner ( ) . preservesOrder ( ) | | evenTreeDistribution ) 
 { 
 / / You can ' t beat an even tree distribution for md5 
 tree . init ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / MerkleTree . java b / src / java / org / apache / cassandra / utils / MerkleTree . java 
 index 4fec62d . . 1e0f505 100644 
 - - - a / src / java / org / apache / cassandra / utils / MerkleTree . java 
 + + + b / src / java / org / apache / cassandra / utils / MerkleTree . java 
 @ @ - 516 , 6 + 516 , 16 @ @ public class MerkleTree implements Serializable 
 return histbuild . buildWithStdevRangesAroundMean ( ) ; 
 } 
 
 + public long rowCount ( ) 
 + { 
 + long count = 0 ; 
 + for ( TreeRange range : new TreeRangeIterator ( this ) ) 
 + { 
 + count + = range . hashable . rowsInRange ; 
 + } 
 + return count ; 
 + } 
 + 
 @ Override 
 public String toString ( ) 
 { 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 index 8ff3022 . . 471f8cf 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 @ @ - 125 , 7 + 125 , 7 @ @ public class CompactionsTest 
 return store ; 
 } 
 
 - private long populate ( String ks , String cf , int startRowKey , int endRowKey , int ttl ) 
 + public static long populate ( String ks , String cf , int startRowKey , int endRowKey , int ttl ) 
 { 
 long timestamp = System . currentTimeMillis ( ) ; 
 for ( int i = startRowKey ; i < = endRowKey ; i + + ) 
 diff - - git a / test / unit / org / apache / cassandra / repair / ValidatorTest . java b / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 index a9f18f5 . . 61ab3da 100644 
 - - - a / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / ValidatorTest . java 
 @ @ - 20 , 8 + 20 , 16 @ @ package org . apache . cassandra . repair ; 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 import java . security . MessageDigest ; 
 + import java . util . Collections ; 
 import java . util . UUID ; 
 + import java . util . concurrent . TimeUnit ; 
 
 + import com . google . common . util . concurrent . ListenableFuture ; 
 + import com . google . common . util . concurrent . SettableFuture ; 
 + 
 + import org . apache . cassandra . db . compaction . CompactionManager ; 
 + import org . apache . cassandra . db . compaction . CompactionsTest ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . io . util . SequentialWriter ; 
 import org . junit . After ; 
 import org . junit . BeforeClass ; 
 @ @ - 46 , 15 + 54 , 20 @ @ import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . net . IMessageSink ; 
 import org . apache . cassandra . repair . messages . RepairMessage ; 
 import org . apache . cassandra . repair . messages . ValidationComplete ; 
 + import org . apache . cassandra . service . ActiveRepairService ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . MerkleTree ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 import org . apache . cassandra . utils . concurrent . SimpleCondition ; 
 
 import static org . junit . Assert . * ; 
 
 public class ValidatorTest 
 { 
 + private static final long TEST _ TIMEOUT = 60 ; / / seconds 
 + 
 private static final String keyspace = " ValidatorTest " ; 
 private static final String columnFamily = " Standard1 " ; 
 private final IPartitioner partitioner = StorageService . getPartitioner ( ) ; 
 @ @ - 81 , 35 + 94 , 7 @ @ public class ValidatorTest 
 Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; 
 final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , range ) ; 
 
 - final SimpleCondition lock = new SimpleCondition ( ) ; 
 - MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) 
 - { 
 - @ SuppressWarnings ( " unchecked " ) 
 - public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) 
 - { 
 - try 
 - { 
 - if ( message . verb = = MessagingService . Verb . REPAIR _ MESSAGE ) 
 - { 
 - RepairMessage m = ( RepairMessage ) message . payload ; 
 - assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; 
 - assertEquals ( desc , m . desc ) ; 
 - assertTrue ( ( ( ValidationComplete ) m ) . success ) ; 
 - assertNotNull ( ( ( ValidationComplete ) m ) . tree ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock . signalAll ( ) ; 
 - } 
 - return false ; 
 - } 
 - 
 - public boolean allowIncomingMessage ( MessageIn message , int id ) 
 - { 
 - return false ; 
 - } 
 - } ) ; 
 + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; 
 
 InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 
 @ @ - 131 , 8 + 116 , 13 @ @ public class ValidatorTest 
 Token min = tree . partitioner ( ) . getMinimumToken ( ) ; 
 assertNotNull ( tree . hash ( new Range < > ( min , min ) ) ) ; 
 
 - if ( ! lock . isSignaled ( ) ) 
 - lock . await ( ) ; 
 + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; 
 + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; 
 + RepairMessage m = ( RepairMessage ) message . payload ; 
 + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; 
 + assertEquals ( desc , m . desc ) ; 
 + assertTrue ( ( ( ValidationComplete ) m ) . success ) ; 
 + assertNotNull ( ( ( ValidationComplete ) m ) . tree ) ; 
 } 
 
 private static class CompactedRowStub extends AbstractCompactedRow 
 @ @ - 163 , 27 + 153 , 91 @ @ public class ValidatorTest 
 Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; 
 final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , range ) ; 
 
 - final SimpleCondition lock = new SimpleCondition ( ) ; 
 + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; 
 + 
 + InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 + 
 + Validator validator = new Validator ( desc , remote , 0 ) ; 
 + validator . fail ( ) ; 
 + 
 + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; 
 + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; 
 + RepairMessage m = ( RepairMessage ) message . payload ; 
 + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; 
 + assertEquals ( desc , m . desc ) ; 
 + assertFalse ( ( ( ValidationComplete ) m ) . success ) ; 
 + assertNull ( ( ( ValidationComplete ) m ) . tree ) ; 
 + } 
 + 
 + @ Test 
 + public void simpleValidationTest128 ( ) throws Exception 
 + { 
 + simpleValidationTest ( 128 ) ; 
 + } 
 + 
 + @ Test 
 + public void simpleValidationTest1500 ( ) throws Exception 
 + { 
 + simpleValidationTest ( 1500 ) ; 
 + } 
 + 
 + / * * 
 + * Test for CASSANDRA - 5263 
 + * 1 . Create N rows 
 + * 2 . Run validation compaction 
 + * 3 . Expect merkle tree with size 2 ^ ( log2 ( n ) ) 
 + * / 
 + public void simpleValidationTest ( int n ) throws Exception 
 + { 
 + Keyspace ks = Keyspace . open ( keyspace ) ; 
 + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( columnFamily ) ; 
 + cfs . clearUnsafe ( ) ; 
 + 
 + / / disable compaction while flushing 
 + cfs . disableAutoCompaction ( ) ; 
 + 
 + CompactionsTest . populate ( keyspace , columnFamily , 0 , n , 0 ) ; / / ttl = 3s 
 + 
 + cfs . forceBlockingFlush ( ) ; 
 + assertEquals ( 1 , cfs . getSSTables ( ) . size ( ) ) ; 
 + 
 + / / wait enough to force single compaction 
 + TimeUnit . SECONDS . sleep ( 5 ) ; 
 + 
 + SSTableReader sstable = cfs . getSSTables ( ) . iterator ( ) . next ( ) ; 
 + UUID repairSessionId = UUIDGen . getTimeUUID ( ) ; 
 + final RepairJobDesc desc = new RepairJobDesc ( repairSessionId , UUIDGen . getTimeUUID ( ) , cfs . keyspace . getName ( ) , 
 + cfs . getColumnFamilyName ( ) , new Range < Token > ( sstable . first . getToken ( ) , 
 + sstable . last . getToken ( ) ) ) ; 
 + 
 + ActiveRepairService . instance . registerParentRepairSession ( repairSessionId , FBUtilities . getBroadcastAddress ( ) , 
 + Collections . singletonList ( cfs ) , Collections . singleton ( desc . range ) , 
 + false , false ) ; 
 + 
 + final ListenableFuture < MessageOut > outgoingMessageSink = registerOutgoingMessageSink ( ) ; 
 + Validator validator = new Validator ( desc , FBUtilities . getBroadcastAddress ( ) , 0 , true ) ; 
 + CompactionManager . instance . submitValidation ( cfs , validator ) ; 
 + 
 + MessageOut message = outgoingMessageSink . get ( TEST _ TIMEOUT , TimeUnit . SECONDS ) ; 
 + assertEquals ( MessagingService . Verb . REPAIR _ MESSAGE , message . verb ) ; 
 + RepairMessage m = ( RepairMessage ) message . payload ; 
 + assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; 
 + assertEquals ( desc , m . desc ) ; 
 + assertTrue ( ( ( ValidationComplete ) m ) . success ) ; 
 + MerkleTree tree = ( ( ValidationComplete ) m ) . tree ; 
 + 
 + assertEquals ( Math . pow ( 2 , Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) , tree . size ( ) , 0 . 0 ) ; 
 + assertEquals ( tree . rowCount ( ) , n ) ; 
 + } 
 + 
 + private ListenableFuture < MessageOut > registerOutgoingMessageSink ( ) 
 + { 
 + final SettableFuture < MessageOut > future = SettableFuture . create ( ) ; 
 MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) 
 { 
 - @ SuppressWarnings ( " unchecked " ) 
 public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) 
 { 
 - try 
 - { 
 - if ( message . verb = = MessagingService . Verb . REPAIR _ MESSAGE ) 
 - { 
 - RepairMessage m = ( RepairMessage ) message . payload ; 
 - assertEquals ( RepairMessage . Type . VALIDATION _ COMPLETE , m . messageType ) ; 
 - assertEquals ( desc , m . desc ) ; 
 - assertFalse ( ( ( ValidationComplete ) m ) . success ) ; 
 - assertNull ( ( ( ValidationComplete ) m ) . tree ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock . signalAll ( ) ; 
 - } 
 + future . set ( message ) ; 
 return false ; 
 } 
 
 @ @ - 192 , 13 + 246 , 6 @ @ public class ValidatorTest 
 return false ; 
 } 
 } ) ; 
 - 
 - InetAddress remote = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 - 
 - Validator validator = new Validator ( desc , remote , 0 ) ; 
 - validator . fail ( ) ; 
 - 
 - if ( ! lock . isSignaled ( ) ) 
 - lock . await ( ) ; 
 + return future ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
