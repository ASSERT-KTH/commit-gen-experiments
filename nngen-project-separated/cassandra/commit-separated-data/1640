BLEU SCORE: 0.06413885305524152

TEST MSG: fix stress to not use thrift unless requested
GENERATED MSG: update stress tool to be able to use CQL3

TEST DIFF (one line): diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> index 30a842a . . 272f3c7 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> @ @ - 243 , 14 + 243 , 21 @ @ public class StressProfile implements Serializable <nl> try <nl> { <nl> JavaDriverClient jclient = settings . getJavaDriverClient ( ) ; <nl> - ThriftClient tclient = settings . getThriftClient ( ) ; <nl> + ThriftClient tclient = null ; <nl> + <nl> + if ( settings . mode . api ! = ConnectionAPI . JAVA _ DRIVER _ NATIVE ) <nl> + tclient = settings . getThriftClient ( ) ; <nl> + <nl> Map < String , PreparedStatement > stmts = new HashMap < > ( ) ; <nl> Map < String , Integer > tids = new HashMap < > ( ) ; <nl> Map < String , SchemaQuery . ArgSelect > args = new HashMap < > ( ) ; <nl> for ( Map . Entry < String , StressYaml . QueryDef > e : queries . entrySet ( ) ) <nl> { <nl> stmts . put ( e . getKey ( ) . toLowerCase ( ) , jclient . prepare ( e . getValue ( ) . cql ) ) ; <nl> - tids . put ( e . getKey ( ) . toLowerCase ( ) , tclient . prepare _ cql3 _ query ( e . getValue ( ) . cql , Compression . NONE ) ) ; <nl> + <nl> + if ( tclient ! = null ) <nl> + tids . put ( e . getKey ( ) . toLowerCase ( ) , tclient . prepare _ cql3 _ query ( e . getValue ( ) . cql , Compression . NONE ) ) ; <nl> + <nl> args . put ( e . getKey ( ) . toLowerCase ( ) , e . getValue ( ) . fields = = null <nl> ? SchemaQuery . ArgSelect . MULTIROW <nl> : SchemaQuery . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; <nl> @ @ - 373 , 14 + 380 , 19 @ @ public class StressProfile implements Serializable <nl> <nl> JavaDriverClient client = settings . getJavaDriverClient ( ) ; <nl> String query = sb . toString ( ) ; <nl> - try <nl> - { <nl> - thriftInsertId = settings . getThriftClient ( ) . prepare _ cql3 _ query ( query , Compression . NONE ) ; <nl> - } <nl> - catch ( TException e ) <nl> + <nl> + if ( settings . mode . api ! = ConnectionAPI . JAVA _ DRIVER _ NATIVE ) <nl> { <nl> - throw new RuntimeException ( e ) ; <nl> + try <nl> + { <nl> + thriftInsertId = settings . getThriftClient ( ) . prepare _ cql3 _ query ( query , Compression . NONE ) ; <nl> + } <nl> + catch ( TException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> } <nl> + <nl> insertStatement = client . prepare ( query ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 896b8cc . . 95a8b18 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 5 @ @ <nl> 1 . 2 - beta1 <nl> - * add atomic _ batch _ mutate ( CASSANDRA - 4542 ) <nl> + * add atomic _ batch _ mutate ( CASSANDRA - 4542 , - 4635 ) <nl> * increase default max _ hint _ window _ in _ ms to 3h ( CASSANDRA - 4632 ) <nl> * include message initiation time to replicas so they can more <nl> accurately drop timed - out requests ( CASSANDRA - 2858 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 9ee684c . . 4e29fc7 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 194 , 7 + 194 , 6 @ @ public final class CFMetaData <nl> <nl> public static final CFMetaData BatchlogCF = compile ( 16 , " CREATE TABLE " + SystemTable . BATCHLOG _ CF + " ( " <nl> + " id uuid PRIMARY KEY , " <nl> - + " coordinator inet , " <nl> + " written _ at timestamp , " <nl> + " data blob " <nl> + " ) WITH COMMENT = ' uncommited batches ' AND gc _ grace _ seconds = 0 " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / BatchlogManager . java b / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> index 2ae9361 . . ded1ca4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> + + + b / src / java / org / apache / cassandra / db / BatchlogManager . java <nl> @ @ - 23 , 6 + 23 , 8 @ @ import java . net . InetAddress ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> + import java . util . concurrent . atomic . AtomicLong ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> @ @ - 32 , 17 + 34 , 16 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . filter . IFilter ; <nl> import org . apache . cassandra . db . filter . NamesQueryFilter ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> - import org . apache . cassandra . db . marshal . InetAddressType ; <nl> import org . apache . cassandra . db . marshal . LongType ; <nl> import org . apache . cassandra . db . marshal . UTF8Type ; <nl> import org . apache . cassandra . db . marshal . UUIDType ; <nl> import org . apache . cassandra . dht . AbstractBounds ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> - import org . apache . cassandra . gms . FailureDetector ; <nl> import org . apache . cassandra . io . util . FastByteArrayOutputStream ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> @ @ - 54 , 17 + 55 , 18 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> { <nl> private static final String MBEAN _ NAME = " org . apache . cassandra . db : type = BatchlogManager " ; <nl> private static final int VERSION = MessagingService . VERSION _ 12 ; <nl> - private static final long TIMEOUT = 2 * DatabaseDescriptor . getRpcTimeout ( ) ; <nl> + private static final long TIMEOUT = 2 * DatabaseDescriptor . getWriteRpcTimeout ( ) ; <nl> <nl> - private static final ByteBuffer COORDINATOR = columnName ( " coordinator " ) ; <nl> private static final ByteBuffer WRITTEN _ AT = columnName ( " written _ at " ) ; <nl> private static final ByteBuffer DATA = columnName ( " data " ) ; <nl> - private static final SortedSet < ByteBuffer > META = ImmutableSortedSet . of ( COORDINATOR , WRITTEN _ AT ) ; <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( BatchlogManager . class ) ; <nl> <nl> public static final BatchlogManager instance = new BatchlogManager ( ) ; <nl> <nl> + private final AtomicLong totalBatchesReplayed = new AtomicLong ( ) ; <nl> + private final AtomicBoolean isReplaying = new AtomicBoolean ( ) ; <nl> + <nl> public void start ( ) <nl> { <nl> MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> @ @ - 90 , 15 + 92 , 43 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> TimeUnit . MILLISECONDS ) ; <nl> } <nl> <nl> + public int countAllBatches ( ) <nl> + { <nl> + int count = 0 ; <nl> + <nl> + for ( Row row : getRangeSlice ( new NamesQueryFilter ( ImmutableSortedSet . < ByteBuffer > of ( ) ) ) ) <nl> + { <nl> + if ( row . cf ! = null & & ! row . cf . isMarkedForDelete ( ) ) <nl> + count + + ; <nl> + } <nl> + <nl> + return count ; <nl> + } <nl> + <nl> + public long getTotalBatchesReplayed ( ) <nl> + { <nl> + return totalBatchesReplayed . longValue ( ) ; <nl> + } <nl> + <nl> + public void forceBatchlogReplay ( ) <nl> + { <nl> + Runnable runnable = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + replayAllFailedBatches ( ) ; <nl> + } <nl> + } ; <nl> + StorageService . optionalTasks . execute ( runnable ) ; <nl> + } <nl> + <nl> public static RowMutation getBatchlogMutationFor ( Collection < RowMutation > mutations , UUID uuid ) <nl> { <nl> long timestamp = FBUtilities . timestampMicros ( ) ; <nl> - ByteBuffer coordinator = InetAddressType . instance . decompose ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> ByteBuffer writtenAt = LongType . instance . decompose ( timestamp / 1000 ) ; <nl> ByteBuffer data = serializeRowMutations ( mutations ) ; <nl> <nl> ColumnFamily cf = ColumnFamily . create ( CFMetaData . BatchlogCF ) ; <nl> - cf . addColumn ( new Column ( COORDINATOR , coordinator , timestamp ) ) ; <nl> cf . addColumn ( new Column ( WRITTEN _ AT , writtenAt , timestamp ) ) ; <nl> cf . addColumn ( new Column ( DATA , data , timestamp ) ) ; <nl> RowMutation rm = new RowMutation ( Table . SYSTEM _ KS , UUIDType . instance . decompose ( uuid ) ) ; <nl> @ @ - 126 , 55 + 156 , 38 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> return ByteBuffer . wrap ( bos . toByteArray ( ) ) ; <nl> } <nl> <nl> - private static void replayAllFailedBatches ( ) <nl> + private void replayAllFailedBatches ( ) <nl> { <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Started replayAllFailedBatches " ) ; <nl> - <nl> - ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; <nl> - <nl> - if ( store . isEmpty ( ) ) <nl> + if ( ! isReplaying . compareAndSet ( false , true ) ) <nl> return ; <nl> <nl> - IPartitioner partitioner = StorageService . getPartitioner ( ) ; <nl> - RowPosition minPosition = partitioner . getMinimumToken ( ) . minKeyBound ( ) ; <nl> - AbstractBounds < RowPosition > range = new Range < RowPosition > ( minPosition , minPosition , partitioner ) ; <nl> - <nl> - List < Row > rows = store . getRangeSlice ( null , range , Integer . MAX _ VALUE , new NamesQueryFilter ( META ) , null ) ; <nl> - <nl> - for ( Row row : rows ) <nl> + try <nl> { <nl> - if ( row . cf . isMarkedForDelete ( ) ) <nl> - continue ; <nl> - <nl> - IColumn coordinatorColumn = row . cf . getColumn ( COORDINATOR ) ; <nl> - IColumn writtenAtColumn = row . cf . getColumn ( WRITTEN _ AT ) ; <nl> + logger . debug ( " Started replayAllFailedBatches " ) ; <nl> <nl> - if ( coordinatorColumn = = null | | writtenAtColumn = = null ) <nl> + for ( Row row : getRangeSlice ( new NamesQueryFilter ( WRITTEN _ AT ) ) ) <nl> { <nl> - replayBatch ( row . key ) ; <nl> - continue ; <nl> - } <nl> + if ( row . cf = = null | | row . cf . isMarkedForDelete ( ) ) <nl> + continue ; <nl> <nl> - InetAddress coordinator = InetAddressType . instance . compose ( coordinatorColumn . value ( ) ) ; <nl> - long writtenAt = LongType . instance . compose ( writtenAtColumn . value ( ) ) ; <nl> - / / if the batch is new and its coordinator is alive - give it a chance to complete naturally . <nl> - if ( System . currentTimeMillis ( ) < writtenAt + TIMEOUT & & FailureDetector . instance . isAlive ( coordinator ) ) <nl> - continue ; <nl> - <nl> - replayBatch ( row . key ) ; <nl> + IColumn writtenAt = row . cf . getColumn ( WRITTEN _ AT ) ; <nl> + if ( writtenAt = = null | | System . currentTimeMillis ( ) > LongType . instance . compose ( writtenAt . value ( ) ) + TIMEOUT ) <nl> + replayBatch ( row . key ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + isReplaying . set ( false ) ; <nl> } <nl> <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Finished replayAllFailedBatches " ) ; <nl> + logger . debug ( " Finished replayAllFailedBatches " ) ; <nl> } <nl> <nl> - private static void replayBatch ( DecoratedKey key ) <nl> + private void replayBatch ( DecoratedKey key ) <nl> { <nl> UUID uuid = UUIDType . instance . compose ( key . key ) ; <nl> <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Replaying batch { } " , uuid ) ; <nl> + logger . debug ( " Replaying batch { } " , uuid ) ; <nl> <nl> ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; <nl> QueryFilter filter = QueryFilter . getNamesFilter ( key , new QueryPath ( SystemTable . BATCHLOG _ CF ) , DATA ) ; <nl> @ @ - 195 , 6 + 208 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> } <nl> <nl> deleteBatch ( key ) ; <nl> + totalBatchesReplayed . incrementAndGet ( ) ; <nl> } <nl> <nl> private static void writeHintsForSerializedMutations ( ByteBuffer data ) throws IOException <nl> @ @ - 228 , 4 + 242 , 13 @ @ public class BatchlogManager implements BatchlogManagerMBean <nl> ByteBuffer raw = UTF8Type . instance . decompose ( name ) ; <nl> return CFMetaData . BatchlogCF . getCfDef ( ) . getColumnNameBuilder ( ) . add ( raw ) . build ( ) ; <nl> } <nl> + <nl> + private static List < Row > getRangeSlice ( IFilter columnFilter ) <nl> + { <nl> + ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; <nl> + IPartitioner partitioner = StorageService . getPartitioner ( ) ; <nl> + RowPosition minPosition = partitioner . getMinimumToken ( ) . minKeyBound ( ) ; <nl> + AbstractBounds < RowPosition > range = new Range < RowPosition > ( minPosition , minPosition , partitioner ) ; <nl> + return store . getRangeSlice ( null , range , Integer . MAX _ VALUE , columnFilter , null ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java b / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java <nl> index 0322b21 . . 2e60ba4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java <nl> + + + b / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java <nl> @ @ - 19 , 4 + 19 , 20 @ @ package org . apache . cassandra . db ; <nl> <nl> public interface BatchlogManagerMBean <nl> { <nl> + / * * <nl> + * Counts all batches currently in the batchlog . <nl> + * <nl> + * @ return total batch count <nl> + * / <nl> + public int countAllBatches ( ) ; <nl> + <nl> + / * * <nl> + * @ return total count of batches replayed since node start <nl> + * / <nl> + public long getTotalBatchesReplayed ( ) ; <nl> + <nl> + / * * <nl> + * Forces batchlog replay . Returns immediately if replay is already in progress . <nl> + * / <nl> + public void forceBatchlogReplay ( ) ; <nl> }

TEST DIFF:
diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 index 30a842a . . 272f3c7 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 @ @ - 243 , 14 + 243 , 21 @ @ public class StressProfile implements Serializable 
 try 
 { 
 JavaDriverClient jclient = settings . getJavaDriverClient ( ) ; 
 - ThriftClient tclient = settings . getThriftClient ( ) ; 
 + ThriftClient tclient = null ; 
 + 
 + if ( settings . mode . api ! = ConnectionAPI . JAVA _ DRIVER _ NATIVE ) 
 + tclient = settings . getThriftClient ( ) ; 
 + 
 Map < String , PreparedStatement > stmts = new HashMap < > ( ) ; 
 Map < String , Integer > tids = new HashMap < > ( ) ; 
 Map < String , SchemaQuery . ArgSelect > args = new HashMap < > ( ) ; 
 for ( Map . Entry < String , StressYaml . QueryDef > e : queries . entrySet ( ) ) 
 { 
 stmts . put ( e . getKey ( ) . toLowerCase ( ) , jclient . prepare ( e . getValue ( ) . cql ) ) ; 
 - tids . put ( e . getKey ( ) . toLowerCase ( ) , tclient . prepare _ cql3 _ query ( e . getValue ( ) . cql , Compression . NONE ) ) ; 
 + 
 + if ( tclient ! = null ) 
 + tids . put ( e . getKey ( ) . toLowerCase ( ) , tclient . prepare _ cql3 _ query ( e . getValue ( ) . cql , Compression . NONE ) ) ; 
 + 
 args . put ( e . getKey ( ) . toLowerCase ( ) , e . getValue ( ) . fields = = null 
 ? SchemaQuery . ArgSelect . MULTIROW 
 : SchemaQuery . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; 
 @ @ - 373 , 14 + 380 , 19 @ @ public class StressProfile implements Serializable 
 
 JavaDriverClient client = settings . getJavaDriverClient ( ) ; 
 String query = sb . toString ( ) ; 
 - try 
 - { 
 - thriftInsertId = settings . getThriftClient ( ) . prepare _ cql3 _ query ( query , Compression . NONE ) ; 
 - } 
 - catch ( TException e ) 
 + 
 + if ( settings . mode . api ! = ConnectionAPI . JAVA _ DRIVER _ NATIVE ) 
 { 
 - throw new RuntimeException ( e ) ; 
 + try 
 + { 
 + thriftInsertId = settings . getThriftClient ( ) . prepare _ cql3 _ query ( query , Compression . NONE ) ; 
 + } 
 + catch ( TException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 } 
 + 
 insertStatement = client . prepare ( query ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 896b8cc . . 95a8b18 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 5 @ @ 
 1 . 2 - beta1 
 - * add atomic _ batch _ mutate ( CASSANDRA - 4542 ) 
 + * add atomic _ batch _ mutate ( CASSANDRA - 4542 , - 4635 ) 
 * increase default max _ hint _ window _ in _ ms to 3h ( CASSANDRA - 4632 ) 
 * include message initiation time to replicas so they can more 
 accurately drop timed - out requests ( CASSANDRA - 2858 ) 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 9ee684c . . 4e29fc7 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 194 , 7 + 194 , 6 @ @ public final class CFMetaData 
 
 public static final CFMetaData BatchlogCF = compile ( 16 , " CREATE TABLE " + SystemTable . BATCHLOG _ CF + " ( " 
 + " id uuid PRIMARY KEY , " 
 - + " coordinator inet , " 
 + " written _ at timestamp , " 
 + " data blob " 
 + " ) WITH COMMENT = ' uncommited batches ' AND gc _ grace _ seconds = 0 " ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / BatchlogManager . java b / src / java / org / apache / cassandra / db / BatchlogManager . java 
 index 2ae9361 . . ded1ca4 100644 
 - - - a / src / java / org / apache / cassandra / db / BatchlogManager . java 
 + + + b / src / java / org / apache / cassandra / db / BatchlogManager . java 
 @ @ - 23 , 6 + 23 , 8 @ @ import java . net . InetAddress ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 + import java . util . concurrent . atomic . AtomicLong ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 @ @ - 32 , 17 + 34 , 16 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . filter . IFilter ; 
 import org . apache . cassandra . db . filter . NamesQueryFilter ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 - import org . apache . cassandra . db . marshal . InetAddressType ; 
 import org . apache . cassandra . db . marshal . LongType ; 
 import org . apache . cassandra . db . marshal . UTF8Type ; 
 import org . apache . cassandra . db . marshal . UUIDType ; 
 import org . apache . cassandra . dht . AbstractBounds ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Range ; 
 - import org . apache . cassandra . gms . FailureDetector ; 
 import org . apache . cassandra . io . util . FastByteArrayOutputStream ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . service . StorageProxy ; 
 @ @ - 54 , 17 + 55 , 18 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 { 
 private static final String MBEAN _ NAME = " org . apache . cassandra . db : type = BatchlogManager " ; 
 private static final int VERSION = MessagingService . VERSION _ 12 ; 
 - private static final long TIMEOUT = 2 * DatabaseDescriptor . getRpcTimeout ( ) ; 
 + private static final long TIMEOUT = 2 * DatabaseDescriptor . getWriteRpcTimeout ( ) ; 
 
 - private static final ByteBuffer COORDINATOR = columnName ( " coordinator " ) ; 
 private static final ByteBuffer WRITTEN _ AT = columnName ( " written _ at " ) ; 
 private static final ByteBuffer DATA = columnName ( " data " ) ; 
 - private static final SortedSet < ByteBuffer > META = ImmutableSortedSet . of ( COORDINATOR , WRITTEN _ AT ) ; 
 
 private static final Logger logger = LoggerFactory . getLogger ( BatchlogManager . class ) ; 
 
 public static final BatchlogManager instance = new BatchlogManager ( ) ; 
 
 + private final AtomicLong totalBatchesReplayed = new AtomicLong ( ) ; 
 + private final AtomicBoolean isReplaying = new AtomicBoolean ( ) ; 
 + 
 public void start ( ) 
 { 
 MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; 
 @ @ - 90 , 15 + 92 , 43 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 TimeUnit . MILLISECONDS ) ; 
 } 
 
 + public int countAllBatches ( ) 
 + { 
 + int count = 0 ; 
 + 
 + for ( Row row : getRangeSlice ( new NamesQueryFilter ( ImmutableSortedSet . < ByteBuffer > of ( ) ) ) ) 
 + { 
 + if ( row . cf ! = null & & ! row . cf . isMarkedForDelete ( ) ) 
 + count + + ; 
 + } 
 + 
 + return count ; 
 + } 
 + 
 + public long getTotalBatchesReplayed ( ) 
 + { 
 + return totalBatchesReplayed . longValue ( ) ; 
 + } 
 + 
 + public void forceBatchlogReplay ( ) 
 + { 
 + Runnable runnable = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + replayAllFailedBatches ( ) ; 
 + } 
 + } ; 
 + StorageService . optionalTasks . execute ( runnable ) ; 
 + } 
 + 
 public static RowMutation getBatchlogMutationFor ( Collection < RowMutation > mutations , UUID uuid ) 
 { 
 long timestamp = FBUtilities . timestampMicros ( ) ; 
 - ByteBuffer coordinator = InetAddressType . instance . decompose ( FBUtilities . getBroadcastAddress ( ) ) ; 
 ByteBuffer writtenAt = LongType . instance . decompose ( timestamp / 1000 ) ; 
 ByteBuffer data = serializeRowMutations ( mutations ) ; 
 
 ColumnFamily cf = ColumnFamily . create ( CFMetaData . BatchlogCF ) ; 
 - cf . addColumn ( new Column ( COORDINATOR , coordinator , timestamp ) ) ; 
 cf . addColumn ( new Column ( WRITTEN _ AT , writtenAt , timestamp ) ) ; 
 cf . addColumn ( new Column ( DATA , data , timestamp ) ) ; 
 RowMutation rm = new RowMutation ( Table . SYSTEM _ KS , UUIDType . instance . decompose ( uuid ) ) ; 
 @ @ - 126 , 55 + 156 , 38 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 return ByteBuffer . wrap ( bos . toByteArray ( ) ) ; 
 } 
 
 - private static void replayAllFailedBatches ( ) 
 + private void replayAllFailedBatches ( ) 
 { 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Started replayAllFailedBatches " ) ; 
 - 
 - ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; 
 - 
 - if ( store . isEmpty ( ) ) 
 + if ( ! isReplaying . compareAndSet ( false , true ) ) 
 return ; 
 
 - IPartitioner partitioner = StorageService . getPartitioner ( ) ; 
 - RowPosition minPosition = partitioner . getMinimumToken ( ) . minKeyBound ( ) ; 
 - AbstractBounds < RowPosition > range = new Range < RowPosition > ( minPosition , minPosition , partitioner ) ; 
 - 
 - List < Row > rows = store . getRangeSlice ( null , range , Integer . MAX _ VALUE , new NamesQueryFilter ( META ) , null ) ; 
 - 
 - for ( Row row : rows ) 
 + try 
 { 
 - if ( row . cf . isMarkedForDelete ( ) ) 
 - continue ; 
 - 
 - IColumn coordinatorColumn = row . cf . getColumn ( COORDINATOR ) ; 
 - IColumn writtenAtColumn = row . cf . getColumn ( WRITTEN _ AT ) ; 
 + logger . debug ( " Started replayAllFailedBatches " ) ; 
 
 - if ( coordinatorColumn = = null | | writtenAtColumn = = null ) 
 + for ( Row row : getRangeSlice ( new NamesQueryFilter ( WRITTEN _ AT ) ) ) 
 { 
 - replayBatch ( row . key ) ; 
 - continue ; 
 - } 
 + if ( row . cf = = null | | row . cf . isMarkedForDelete ( ) ) 
 + continue ; 
 
 - InetAddress coordinator = InetAddressType . instance . compose ( coordinatorColumn . value ( ) ) ; 
 - long writtenAt = LongType . instance . compose ( writtenAtColumn . value ( ) ) ; 
 - / / if the batch is new and its coordinator is alive - give it a chance to complete naturally . 
 - if ( System . currentTimeMillis ( ) < writtenAt + TIMEOUT & & FailureDetector . instance . isAlive ( coordinator ) ) 
 - continue ; 
 - 
 - replayBatch ( row . key ) ; 
 + IColumn writtenAt = row . cf . getColumn ( WRITTEN _ AT ) ; 
 + if ( writtenAt = = null | | System . currentTimeMillis ( ) > LongType . instance . compose ( writtenAt . value ( ) ) + TIMEOUT ) 
 + replayBatch ( row . key ) ; 
 + } 
 + } 
 + finally 
 + { 
 + isReplaying . set ( false ) ; 
 } 
 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Finished replayAllFailedBatches " ) ; 
 + logger . debug ( " Finished replayAllFailedBatches " ) ; 
 } 
 
 - private static void replayBatch ( DecoratedKey key ) 
 + private void replayBatch ( DecoratedKey key ) 
 { 
 UUID uuid = UUIDType . instance . compose ( key . key ) ; 
 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Replaying batch { } " , uuid ) ; 
 + logger . debug ( " Replaying batch { } " , uuid ) ; 
 
 ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; 
 QueryFilter filter = QueryFilter . getNamesFilter ( key , new QueryPath ( SystemTable . BATCHLOG _ CF ) , DATA ) ; 
 @ @ - 195 , 6 + 208 , 7 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 } 
 
 deleteBatch ( key ) ; 
 + totalBatchesReplayed . incrementAndGet ( ) ; 
 } 
 
 private static void writeHintsForSerializedMutations ( ByteBuffer data ) throws IOException 
 @ @ - 228 , 4 + 242 , 13 @ @ public class BatchlogManager implements BatchlogManagerMBean 
 ByteBuffer raw = UTF8Type . instance . decompose ( name ) ; 
 return CFMetaData . BatchlogCF . getCfDef ( ) . getColumnNameBuilder ( ) . add ( raw ) . build ( ) ; 
 } 
 + 
 + private static List < Row > getRangeSlice ( IFilter columnFilter ) 
 + { 
 + ColumnFamilyStore store = Table . open ( Table . SYSTEM _ KS ) . getColumnFamilyStore ( SystemTable . BATCHLOG _ CF ) ; 
 + IPartitioner partitioner = StorageService . getPartitioner ( ) ; 
 + RowPosition minPosition = partitioner . getMinimumToken ( ) . minKeyBound ( ) ; 
 + AbstractBounds < RowPosition > range = new Range < RowPosition > ( minPosition , minPosition , partitioner ) ; 
 + return store . getRangeSlice ( null , range , Integer . MAX _ VALUE , columnFilter , null ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java b / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java 
 index 0322b21 . . 2e60ba4 100644 
 - - - a / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java 
 + + + b / src / java / org / apache / cassandra / db / BatchlogManagerMBean . java 
 @ @ - 19 , 4 + 19 , 20 @ @ package org . apache . cassandra . db ; 
 
 public interface BatchlogManagerMBean 
 { 
 + / * * 
 + * Counts all batches currently in the batchlog . 
 + * 
 + * @ return total batch count 
 + * / 
 + public int countAllBatches ( ) ; 
 + 
 + / * * 
 + * @ return total count of batches replayed since node start 
 + * / 
 + public long getTotalBatchesReplayed ( ) ; 
 + 
 + / * * 
 + * Forces batchlog replay . Returns immediately if replay is already in progress . 
 + * / 
 + public void forceBatchlogReplay ( ) ; 
 }
