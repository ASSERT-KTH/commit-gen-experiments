BLEU SCORE: 0.015542791893293221

TEST MSG: Allow LWT operation on static column with only partition keys
GENERATED MSG: Fix AssertionError while flushing memtable due to materialized views incorrectly inserting empty rows

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ebcc90c . . 7d70902 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 15 <nl> + * Allow LWT operation on static column with only partition keys ( CASSANDRA - 10532 ) <nl> * Create interval tree over canonical sstables to avoid missing sstables during streaming ( CASSANDRA - 11886 ) <nl> * cqlsh COPY FROM : shutdown parent cluster after forking , to avoid corrupting SSL connections ( CASSANDRA - 11749 ) <nl> * Updated cqlsh Python driver to fix DESCRIBE problem for legacy tables ( CASSANDRA - 11055 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> index 33c61e7 . . d8fa467 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> @ @ - 50 , 15 + 50 , 6 @ @ public class DeleteStatement extends ModificationStatement <nl> { <nl> List < Operation > deletions = getOperations ( ) ; <nl> <nl> - if ( prefix . size ( ) < cfm . clusteringColumns ( ) . size ( ) & & ! deletions . isEmpty ( ) ) <nl> - { <nl> - / / In general , we can ' t delete specific columns if not all clustering columns have been specified . <nl> - / / However , if we delete only static colums , it ' s fine since we won ' t really use the prefix anyway . <nl> - for ( Operation deletion : deletions ) <nl> - if ( ! deletion . column . isStatic ( ) ) <nl> - throw new InvalidRequestException ( String . format ( " Primary key column ' % s ' must be specified in order to delete column ' % s ' " , getFirstEmptyKey ( ) . name , deletion . column . name ) ) ; <nl> - } <nl> - <nl> if ( deletions . isEmpty ( ) ) <nl> { <nl> / / We delete the slice selected by the prefix . <nl> @ @ - 88 , 19 + 79 , 39 @ @ public class DeleteStatement extends ModificationStatement <nl> <nl> protected void validateWhereClauseForConditions ( ) throws InvalidRequestException <nl> { <nl> - Iterator < ColumnDefinition > iterator = Iterators . concat ( cfm . partitionKeyColumns ( ) . iterator ( ) , cfm . clusteringColumns ( ) . iterator ( ) ) ; <nl> + boolean onlyHasConditionsOnStaticColumns = hasStaticConditions ( ) & & ! hasRegularConditions ( ) ; <nl> + <nl> + / / In general , we can ' t delete specific columns if not all clustering columns have been specified . <nl> + / / However , if we delete only static colums , it ' s fine since we won ' t really use the prefix anyway . <nl> + Iterator < ColumnDefinition > iterator = appliesOnlyToStaticColumns ( ) <nl> + ? cfm . partitionKeyColumns ( ) . iterator ( ) <nl> + : Iterators . concat ( cfm . partitionKeyColumns ( ) . iterator ( ) , cfm . clusteringColumns ( ) . iterator ( ) ) ; <nl> while ( iterator . hasNext ( ) ) <nl> { <nl> ColumnDefinition def = iterator . next ( ) ; <nl> Restriction restriction = processedKeys . get ( def . name ) ; <nl> if ( restriction = = null | | ! ( restriction . isEQ ( ) | | restriction . isIN ( ) ) ) <nl> { <nl> + if ( onlyHasConditionsOnStaticColumns ) <nl> + { <nl> + for ( Operation oper : getOperations ( ) ) <nl> + { <nl> + if ( ! oper . column . isStatic ( ) ) <nl> + { <nl> + throw new InvalidRequestException ( String . format ( " Primary key column ' % s ' must be specified in order to delete column ' % s ' " , <nl> + def . name , <nl> + oper . column . name ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> throw new InvalidRequestException ( <nl> - String . format ( " DELETE statements must restrict all PRIMARY KEY columns with equality relations in order " + <nl> - " to use IF conditions , but column ' % s ' is not restricted " , def . name ) ) ; <nl> + String . format ( " DELETE statements must restrict all % s KEY columns with equality relations in order " + <nl> + " to use IF conditions % s , but column ' % s ' is not restricted " , <nl> + onlyHasConditionsOnStaticColumns ? " PARTITION " : " PRIMARY " , <nl> + onlyHasConditionsOnStaticColumns ? " on static columns " : " " , def . name ) ) ; <nl> } <nl> } <nl> - <nl> } <nl> <nl> public static class Parsed extends ModificationStatement . Parsed <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index 75a3b40 . . a9f65e1 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 211 , 6 + 211 , 16 @ @ public abstract class ModificationStatement implements CQLStatement <nl> return ifExists ; <nl> } <nl> <nl> + public boolean hasStaticConditions ( ) <nl> + { <nl> + return staticConditions ! = null & & ! staticConditions . isEmpty ( ) ; <nl> + } <nl> + <nl> + public boolean hasRegularConditions ( ) <nl> + { <nl> + return columnConditions ! = null & & ! columnConditions . isEmpty ( ) ; <nl> + } <nl> + <nl> private void addKeyValues ( ColumnDefinition def , Restriction values ) throws InvalidRequestException <nl> { <nl> if ( def . kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) <nl> @ @ - 364 , 7 + 374 , 7 @ @ public abstract class ModificationStatement implements CQLStatement <nl> * Checks that the modification only apply to static columns . <nl> * @ return < code > true < / code > if the modification only apply to static columns , < code > false < / code > otherwise . <nl> * / <nl> - private boolean appliesOnlyToStaticColumns ( ) <nl> + protected boolean appliesOnlyToStaticColumns ( ) <nl> { <nl> return setsStaticColumns & & ! appliesToRegularColumns ( ) ; <nl> } <nl> @ @ - 373 , 7 + 383 , 7 @ @ public abstract class ModificationStatement implements CQLStatement <nl> * Checks that the modification apply to regular columns . <nl> * @ return < code > true < / code > if the modification apply to regular columns , < code > false < / code > otherwise . <nl> * / <nl> - private boolean appliesToRegularColumns ( ) <nl> + protected boolean appliesToRegularColumns ( ) <nl> { <nl> / / If we have regular operations , this applies to regular columns . <nl> / / Otherwise , if the statement is a DELETE and columnOperations is empty , this means we have no operations , <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> index e94011b . . 05ba09d 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> @ @ - 311 , 6 + 311 , 119 @ @ public class InsertUpdateIfConditionTest extends CQLTester <nl> } <nl> <nl> / * * <nl> + * Test CASSANDRA - 10532 <nl> + * / <nl> + @ Test <nl> + public void testStaticColumnsCasDelete ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( pk int , ck int , static _ col int static , value int , PRIMARY KEY ( pk , ck ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 1 , 2 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 3 , 4 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 5 , 6 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 7 , 8 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 2 , 1 , 2 ) ; <nl> + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; <nl> + <nl> + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 2 ) , row ( false , 1 ) ) ; <nl> + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 1 ) , row ( true ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , null , 2 ) , <nl> + row ( 1 , 3 , null , 4 ) , <nl> + row ( 1 , 5 , null , 6 ) , <nl> + row ( 1 , 7 , null , 8 ) ) ; <nl> + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " DELETE statements must restrict all PARTITION KEY columns with equality relations in order " + <nl> + " to use IF conditions on static columns , but column ' pk ' is not restricted " , <nl> + " DELETE static _ col FROM % s WHERE ck = ? IF static _ col = ? " , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid restriction on clustering column ck since the DELETE statement modifies only static columns " , <nl> + " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF static _ col = ? " , 1 , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " Primary key column ' ck ' must be specified in order to delete column ' value ' " , <nl> + " DELETE static _ col , value FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 1 ) ; <nl> + <nl> + / / Same query but with an invalid condition <nl> + assertInvalidMessage ( " Primary key column ' ck ' must be specified in order to delete column ' value ' " , <nl> + " DELETE static _ col , value FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 2 ) ; <nl> + <nl> + / / DELETE of an underspecified PRIMARY KEY should not succeed if static is not only restriction <nl> + assertInvalidMessage ( " DELETE statements must restrict all PRIMARY KEY columns with equality relations in order " + <nl> + " to use IF conditions , but column ' ck ' is not restricted " , <nl> + " DELETE static _ col FROM % s WHERE pk = ? IF value = ? AND static _ col = ? " , 1 , 2 , 1 ) ; <nl> + <nl> + assertRows ( execute ( " DELETE value FROM % s WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 2 , 2 ) , row ( false , 2 , 1 ) ) ; <nl> + assertRows ( execute ( " DELETE value FROM % s WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 2 , 1 ) , row ( true ) ) ; <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , 1 , null ) , <nl> + row ( 1 , 3 , 1 , 4 ) , <nl> + row ( 1 , 5 , 1 , 6 ) , <nl> + row ( 1 , 7 , 1 , 8 ) ) ; <nl> + <nl> + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF value = ? " , 1 , 5 , 10 ) , row ( false , 6 ) ) ; <nl> + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF value = ? " , 1 , 5 , 6 ) , row ( true ) ) ; <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , null , null ) , <nl> + row ( 1 , 3 , null , 4 ) , <nl> + row ( 1 , 5 , null , 6 ) , <nl> + row ( 1 , 7 , null , 8 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testStaticColumnsCasUpdate ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( pk int , ck int , static _ col int static , value int , PRIMARY KEY ( pk , ck ) ) " ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 1 , 2 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 3 , 4 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 5 , 6 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 7 , 8 ) ; <nl> + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 2 , 1 , 2 ) ; <nl> + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; <nl> + <nl> + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 2 ) , row ( false , 1 ) ) ; <nl> + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? IF static _ col = ? " , 2 , 1 , 1 ) , row ( true ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , 2 , 2 ) , <nl> + row ( 1 , 3 , 2 , 4 ) , <nl> + row ( 1 , 5 , 2 , 6 ) , <nl> + row ( 1 , 7 , 2 , 8 ) ) ; <nl> + <nl> + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part pk " , <nl> + " UPDATE % s SET static _ col = ? WHERE ck = ? IF static _ col = ? " , 3 , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid restriction on clustering column ck since the UPDATE statement modifies only static columns " , <nl> + " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF static _ col = ? " , 3 , 1 , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , <nl> + " UPDATE % s SET static _ col = ? , value = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 1 , 2 ) ; <nl> + <nl> + / / Same query but with an invalid condition <nl> + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , <nl> + " UPDATE % s SET static _ col = ? , value = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 1 , 1 ) ; <nl> + <nl> + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , <nl> + " UPDATE % s SET static _ col = ? WHERE pk = ? IF value = ? AND static _ col = ? " , 3 , 1 , 4 , 2 ) ; <nl> + <nl> + assertRows ( execute ( " UPDATE % s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 3 , 1 , 1 , 3 , 2 ) , row ( false , 2 , 2 ) ) ; <nl> + assertRows ( execute ( " UPDATE % s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 1 , 2 , 2 ) , row ( true ) ) ; <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , 2 , 1 ) , <nl> + row ( 1 , 3 , 2 , 4 ) , <nl> + row ( 1 , 5 , 2 , 6 ) , <nl> + row ( 1 , 7 , 2 , 8 ) ) ; <nl> + <nl> + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF value = ? " , 3 , 1 , 1 , 2 ) , row ( false , 1 ) ) ; <nl> + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF value = ? " , 1 , 1 , 1 , 1 ) , row ( true ) ) ; <nl> + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , <nl> + row ( 1 , 1 , 1 , 1 ) , <nl> + row ( 1 , 3 , 1 , 4 ) , <nl> + row ( 1 , 5 , 1 , 6 ) , <nl> + row ( 1 , 7 , 1 , 8 ) ) ; <nl> + } <nl> + <nl> + / * * <nl> * Migrated from cql _ tests . py : TestCQL . bug _ 6069 _ test ( ) <nl> * / <nl> @ Test
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ebcc90c . . 7d70902 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 15 
 + * Allow LWT operation on static column with only partition keys ( CASSANDRA - 10532 ) 
 * Create interval tree over canonical sstables to avoid missing sstables during streaming ( CASSANDRA - 11886 ) 
 * cqlsh COPY FROM : shutdown parent cluster after forking , to avoid corrupting SSL connections ( CASSANDRA - 11749 ) 
 * Updated cqlsh Python driver to fix DESCRIBE problem for legacy tables ( CASSANDRA - 11055 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 index 33c61e7 . . d8fa467 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 @ @ - 50 , 15 + 50 , 6 @ @ public class DeleteStatement extends ModificationStatement 
 { 
 List < Operation > deletions = getOperations ( ) ; 
 
 - if ( prefix . size ( ) < cfm . clusteringColumns ( ) . size ( ) & & ! deletions . isEmpty ( ) ) 
 - { 
 - / / In general , we can ' t delete specific columns if not all clustering columns have been specified . 
 - / / However , if we delete only static colums , it ' s fine since we won ' t really use the prefix anyway . 
 - for ( Operation deletion : deletions ) 
 - if ( ! deletion . column . isStatic ( ) ) 
 - throw new InvalidRequestException ( String . format ( " Primary key column ' % s ' must be specified in order to delete column ' % s ' " , getFirstEmptyKey ( ) . name , deletion . column . name ) ) ; 
 - } 
 - 
 if ( deletions . isEmpty ( ) ) 
 { 
 / / We delete the slice selected by the prefix . 
 @ @ - 88 , 19 + 79 , 39 @ @ public class DeleteStatement extends ModificationStatement 
 
 protected void validateWhereClauseForConditions ( ) throws InvalidRequestException 
 { 
 - Iterator < ColumnDefinition > iterator = Iterators . concat ( cfm . partitionKeyColumns ( ) . iterator ( ) , cfm . clusteringColumns ( ) . iterator ( ) ) ; 
 + boolean onlyHasConditionsOnStaticColumns = hasStaticConditions ( ) & & ! hasRegularConditions ( ) ; 
 + 
 + / / In general , we can ' t delete specific columns if not all clustering columns have been specified . 
 + / / However , if we delete only static colums , it ' s fine since we won ' t really use the prefix anyway . 
 + Iterator < ColumnDefinition > iterator = appliesOnlyToStaticColumns ( ) 
 + ? cfm . partitionKeyColumns ( ) . iterator ( ) 
 + : Iterators . concat ( cfm . partitionKeyColumns ( ) . iterator ( ) , cfm . clusteringColumns ( ) . iterator ( ) ) ; 
 while ( iterator . hasNext ( ) ) 
 { 
 ColumnDefinition def = iterator . next ( ) ; 
 Restriction restriction = processedKeys . get ( def . name ) ; 
 if ( restriction = = null | | ! ( restriction . isEQ ( ) | | restriction . isIN ( ) ) ) 
 { 
 + if ( onlyHasConditionsOnStaticColumns ) 
 + { 
 + for ( Operation oper : getOperations ( ) ) 
 + { 
 + if ( ! oper . column . isStatic ( ) ) 
 + { 
 + throw new InvalidRequestException ( String . format ( " Primary key column ' % s ' must be specified in order to delete column ' % s ' " , 
 + def . name , 
 + oper . column . name ) ) ; 
 + } 
 + } 
 + } 
 + 
 throw new InvalidRequestException ( 
 - String . format ( " DELETE statements must restrict all PRIMARY KEY columns with equality relations in order " + 
 - " to use IF conditions , but column ' % s ' is not restricted " , def . name ) ) ; 
 + String . format ( " DELETE statements must restrict all % s KEY columns with equality relations in order " + 
 + " to use IF conditions % s , but column ' % s ' is not restricted " , 
 + onlyHasConditionsOnStaticColumns ? " PARTITION " : " PRIMARY " , 
 + onlyHasConditionsOnStaticColumns ? " on static columns " : " " , def . name ) ) ; 
 } 
 } 
 - 
 } 
 
 public static class Parsed extends ModificationStatement . Parsed 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index 75a3b40 . . a9f65e1 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 211 , 6 + 211 , 16 @ @ public abstract class ModificationStatement implements CQLStatement 
 return ifExists ; 
 } 
 
 + public boolean hasStaticConditions ( ) 
 + { 
 + return staticConditions ! = null & & ! staticConditions . isEmpty ( ) ; 
 + } 
 + 
 + public boolean hasRegularConditions ( ) 
 + { 
 + return columnConditions ! = null & & ! columnConditions . isEmpty ( ) ; 
 + } 
 + 
 private void addKeyValues ( ColumnDefinition def , Restriction values ) throws InvalidRequestException 
 { 
 if ( def . kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) 
 @ @ - 364 , 7 + 374 , 7 @ @ public abstract class ModificationStatement implements CQLStatement 
 * Checks that the modification only apply to static columns . 
 * @ return < code > true < / code > if the modification only apply to static columns , < code > false < / code > otherwise . 
 * / 
 - private boolean appliesOnlyToStaticColumns ( ) 
 + protected boolean appliesOnlyToStaticColumns ( ) 
 { 
 return setsStaticColumns & & ! appliesToRegularColumns ( ) ; 
 } 
 @ @ - 373 , 7 + 383 , 7 @ @ public abstract class ModificationStatement implements CQLStatement 
 * Checks that the modification apply to regular columns . 
 * @ return < code > true < / code > if the modification apply to regular columns , < code > false < / code > otherwise . 
 * / 
 - private boolean appliesToRegularColumns ( ) 
 + protected boolean appliesToRegularColumns ( ) 
 { 
 / / If we have regular operations , this applies to regular columns . 
 / / Otherwise , if the statement is a DELETE and columnOperations is empty , this means we have no operations , 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 index e94011b . . 05ba09d 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 @ @ - 311 , 6 + 311 , 119 @ @ public class InsertUpdateIfConditionTest extends CQLTester 
 } 
 
 / * * 
 + * Test CASSANDRA - 10532 
 + * / 
 + @ Test 
 + public void testStaticColumnsCasDelete ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( pk int , ck int , static _ col int static , value int , PRIMARY KEY ( pk , ck ) ) " ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 1 , 2 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 3 , 4 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 5 , 6 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 7 , 8 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 2 , 1 , 2 ) ; 
 + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; 
 + 
 + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 2 ) , row ( false , 1 ) ) ; 
 + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 1 ) , row ( true ) ) ; 
 + 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , null , 2 ) , 
 + row ( 1 , 3 , null , 4 ) , 
 + row ( 1 , 5 , null , 6 ) , 
 + row ( 1 , 7 , null , 8 ) ) ; 
 + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " DELETE statements must restrict all PARTITION KEY columns with equality relations in order " + 
 + " to use IF conditions on static columns , but column ' pk ' is not restricted " , 
 + " DELETE static _ col FROM % s WHERE ck = ? IF static _ col = ? " , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " Invalid restriction on clustering column ck since the DELETE statement modifies only static columns " , 
 + " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF static _ col = ? " , 1 , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " Primary key column ' ck ' must be specified in order to delete column ' value ' " , 
 + " DELETE static _ col , value FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 1 ) ; 
 + 
 + / / Same query but with an invalid condition 
 + assertInvalidMessage ( " Primary key column ' ck ' must be specified in order to delete column ' value ' " , 
 + " DELETE static _ col , value FROM % s WHERE pk = ? IF static _ col = ? " , 1 , 2 ) ; 
 + 
 + / / DELETE of an underspecified PRIMARY KEY should not succeed if static is not only restriction 
 + assertInvalidMessage ( " DELETE statements must restrict all PRIMARY KEY columns with equality relations in order " + 
 + " to use IF conditions , but column ' ck ' is not restricted " , 
 + " DELETE static _ col FROM % s WHERE pk = ? IF value = ? AND static _ col = ? " , 1 , 2 , 1 ) ; 
 + 
 + assertRows ( execute ( " DELETE value FROM % s WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 2 , 2 ) , row ( false , 2 , 1 ) ) ; 
 + assertRows ( execute ( " DELETE value FROM % s WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 2 , 1 ) , row ( true ) ) ; 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , 1 , null ) , 
 + row ( 1 , 3 , 1 , 4 ) , 
 + row ( 1 , 5 , 1 , 6 ) , 
 + row ( 1 , 7 , 1 , 8 ) ) ; 
 + 
 + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF value = ? " , 1 , 5 , 10 ) , row ( false , 6 ) ) ; 
 + assertRows ( execute ( " DELETE static _ col FROM % s WHERE pk = ? AND ck = ? IF value = ? " , 1 , 5 , 6 ) , row ( true ) ) ; 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , null , null ) , 
 + row ( 1 , 3 , null , 4 ) , 
 + row ( 1 , 5 , null , 6 ) , 
 + row ( 1 , 7 , null , 8 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testStaticColumnsCasUpdate ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( pk int , ck int , static _ col int static , value int , PRIMARY KEY ( pk , ck ) ) " ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 1 , 2 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 3 , 4 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 5 , 6 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 1 , 7 , 8 ) ; 
 + execute ( " INSERT INTO % s ( pk , ck , value ) VALUES ( ? , ? , ? ) " , 2 , 1 , 2 ) ; 
 + execute ( " INSERT INTO % s ( pk , static _ col ) VALUES ( ? , ? ) " , 1 , 1 ) ; 
 + 
 + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 2 ) , row ( false , 1 ) ) ; 
 + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? IF static _ col = ? " , 2 , 1 , 1 ) , row ( true ) ) ; 
 + 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , 2 , 2 ) , 
 + row ( 1 , 3 , 2 , 4 ) , 
 + row ( 1 , 5 , 2 , 6 ) , 
 + row ( 1 , 7 , 2 , 8 ) ) ; 
 + 
 + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part pk " , 
 + " UPDATE % s SET static _ col = ? WHERE ck = ? IF static _ col = ? " , 3 , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " Invalid restriction on clustering column ck since the UPDATE statement modifies only static columns " , 
 + " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF static _ col = ? " , 3 , 1 , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , 
 + " UPDATE % s SET static _ col = ? , value = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 1 , 2 ) ; 
 + 
 + / / Same query but with an invalid condition 
 + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , 
 + " UPDATE % s SET static _ col = ? , value = ? WHERE pk = ? IF static _ col = ? " , 3 , 1 , 1 , 1 ) ; 
 + 
 + assertInvalidMessage ( " Missing mandatory PRIMARY KEY part ck " , 
 + " UPDATE % s SET static _ col = ? WHERE pk = ? IF value = ? AND static _ col = ? " , 3 , 1 , 4 , 2 ) ; 
 + 
 + assertRows ( execute ( " UPDATE % s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 3 , 1 , 1 , 3 , 2 ) , row ( false , 2 , 2 ) ) ; 
 + assertRows ( execute ( " UPDATE % s SET value = ? WHERE pk = ? AND ck = ? IF value = ? AND static _ col = ? " , 1 , 1 , 1 , 2 , 2 ) , row ( true ) ) ; 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , 2 , 1 ) , 
 + row ( 1 , 3 , 2 , 4 ) , 
 + row ( 1 , 5 , 2 , 6 ) , 
 + row ( 1 , 7 , 2 , 8 ) ) ; 
 + 
 + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF value = ? " , 3 , 1 , 1 , 2 ) , row ( false , 1 ) ) ; 
 + assertRows ( execute ( " UPDATE % s SET static _ col = ? WHERE pk = ? AND ck = ? IF value = ? " , 1 , 1 , 1 , 1 ) , row ( true ) ) ; 
 + assertRows ( execute ( " SELECT pk , ck , static _ col , value FROM % s WHERE pk = 1 " ) , 
 + row ( 1 , 1 , 1 , 1 ) , 
 + row ( 1 , 3 , 1 , 4 ) , 
 + row ( 1 , 5 , 1 , 6 ) , 
 + row ( 1 , 7 , 1 , 8 ) ) ; 
 + } 
 + 
 + / * * 
 * Migrated from cql _ tests . py : TestCQL . bug _ 6069 _ test ( ) 
 * / 
 @ Test

NEAREST DIFF:
ELIMINATEDSENTENCE
