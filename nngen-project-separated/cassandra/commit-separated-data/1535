BLEU SCORE: 0.1152159099228654

TEST MSG: Update cqlsh for UDFs
GENERATED MSG: User types support for cqlsh .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 16fe569 . . c0480d7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 <nl> + * Update cqlsh for UDFs ( CASSANDRA - 7556 ) <nl> * Change Windows kernel default timer resolution ( CASSANDRA - 9634 ) <nl> * Deprected sstable2json and json2sstable ( CASSANDRA - 9618 ) <nl> * Allow native functions in user - defined aggregates ( CASSANDRA - 9542 ) <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index b2a729c . . a556a92 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 265 , 7 + 265 , 11 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' <nl> ; <nl> <nl> < describeCommand > : : = ( " DESCRIBE " | " DESC " ) <nl> - ( " KEYSPACES " <nl> + ( " FUNCTIONS " ksname = < keyspaceName > ? <nl> + | " FUNCTION " udf = < anyFunctionName > <nl> + | " AGGREGATES " ksname = < keyspaceName > ? <nl> + | " AGGREGATE " uda = < userAggregateName > <nl> + | " KEYSPACES " <nl> | " KEYSPACE " ksname = < keyspaceName > ? <nl> | ( " COLUMNFAMILY " | " TABLE " ) cf = < columnFamilyName > <nl> | ( " COLUMNFAMILIES " | " TABLES " ) <nl> @ @ - 437 , 6 + 441 , 12 @ @ class VersionNotSupported ( Exception ) : <nl> class UserTypeNotFound ( Exception ) : <nl> pass <nl> <nl> + class FunctionNotFound ( Exception ) : <nl> + pass <nl> + <nl> + class AggregateNotFound ( Exception ) : <nl> + pass <nl> + <nl> <nl> class DecodeError ( Exception ) : <nl> verb = ' decode ' <nl> @ @ - 784 , 6 + 794 , 18 @ @ class Shell ( cmd . Cmd ) : <nl> return [ ( field _ name , field _ type . cql _ parameterized _ type ( ) ) <nl> for field _ name , field _ type in zip ( user _ type . field _ names , user _ type . field _ types ) ] <nl> <nl> + def get _ userfunction _ names ( self , ksname = None ) : <nl> + if ksname is None : <nl> + ksname = self . current _ keyspace <nl> + <nl> + return map ( lambda f : f . name , self . get _ keyspace _ meta ( ksname ) . functions . values ( ) ) <nl> + <nl> + def get _ useraggregate _ names ( self , ksname = None ) : <nl> + if ksname is None : <nl> + ksname = self . current _ keyspace <nl> + <nl> + return map ( lambda f : f . name , self . get _ keyspace _ meta ( ksname ) . aggregates . values ( ) ) <nl> + <nl> def get _ cluster _ name ( self ) : <nl> return self . conn . metadata . cluster _ name <nl> <nl> @ @ - 1284 , 6 + 1306 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> def describe _ columnfamily ( self , ksname , cfname ) : <nl> if ksname is None : <nl> ksname = self . current _ keyspace <nl> + if ksname is None : <nl> + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) <nl> print <nl> self . print _ recreate _ columnfamily ( ksname , cfname , sys . stdout ) <nl> print <nl> @ @ - 1301 , 6 + 1325 , 60 @ @ class Shell ( cmd . Cmd ) : <nl> cmd . Cmd . columnize ( self , protect _ names ( self . get _ columnfamily _ names ( ksname ) ) ) <nl> print <nl> <nl> + def describe _ functions ( self , ksname = None ) : <nl> + print <nl> + if ksname is None : <nl> + for ksmeta in self . get _ keyspaces ( ) : <nl> + name = protect _ name ( ksmeta . name ) <nl> + print ' Keyspace % s ' % ( name , ) <nl> + print ' - - - - - - - - - % s ' % ( ' - ' * len ( name ) ) <nl> + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . functions . keys ( ) ) ) <nl> + print <nl> + else : <nl> + ksmeta = self . get _ keyspace _ meta ( ksname ) <nl> + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . functions . keys ( ) ) ) <nl> + print <nl> + <nl> + def describe _ function ( self , ksname , functionname ) : <nl> + if ksname is None : <nl> + ksname = self . current _ keyspace <nl> + if ksname is None : <nl> + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) <nl> + print <nl> + ksmeta = self . get _ keyspace _ meta ( ksname ) <nl> + functions = filter ( lambda f : f . name = = functionname , ksmeta . functions . values ( ) ) <nl> + if len ( functions ) = = 0 : <nl> + raise FunctionNotFound ( " User defined function % r not found " % functionname ) <nl> + print " \ n \ n " . join ( func . as _ cql _ query ( formatted = True ) for func in functions ) <nl> + print <nl> + <nl> + def describe _ aggregates ( self , ksname = None ) : <nl> + print <nl> + if ksname is None : <nl> + for ksmeta in self . get _ keyspaces ( ) : <nl> + name = protect _ name ( ksmeta . name ) <nl> + print ' Keyspace % s ' % ( name , ) <nl> + print ' - - - - - - - - - % s ' % ( ' - ' * len ( name ) ) <nl> + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . aggregates . keys ( ) ) ) <nl> + print <nl> + else : <nl> + ksmeta = self . get _ keyspace _ meta ( ksname ) <nl> + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . aggregates . keys ( ) ) ) <nl> + print <nl> + <nl> + def describe _ aggregate ( self , ksname , aggregatename ) : <nl> + if ksname is None : <nl> + ksname = self . current _ keyspace <nl> + if ksname is None : <nl> + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) <nl> + print <nl> + ksmeta = self . get _ keyspace _ meta ( ksname ) <nl> + aggregates = filter ( lambda f : f . name = = aggregatename , ksmeta . aggregates . values ( ) ) <nl> + if len ( aggregates ) = = 0 : <nl> + raise FunctionNotFound ( " User defined aggregate % r not found " % aggregatename ) <nl> + print " \ n \ n " . join ( aggr . as _ cql _ query ( formatted = True ) for aggr in aggregates ) <nl> + print <nl> + <nl> def describe _ usertypes ( self , ksname ) : <nl> print <nl> if ksname is None : <nl> @ @ - 1318 , 6 + 1396 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> def describe _ usertype ( self , ksname , typename ) : <nl> if ksname is None : <nl> ksname = self . current _ keyspace <nl> + if ksname is None : <nl> + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) <nl> print <nl> ksmeta = self . get _ keyspace _ meta ( ksname ) <nl> try : <nl> @ @ - 1395 , 11 + 1475 , 41 @ @ class Shell ( cmd . Cmd ) : <nl> Output CQL commands that could be used to recreate the entire ( non - system ) schema . <nl> Works as though " DESCRIBE KEYSPACE k " was invoked for each non - system keyspace <nl> k . Use DESCRIBE FULL SCHEMA to include the system keyspaces . <nl> + <nl> + DESCRIBE FUNCTIONS < keyspace > <nl> + <nl> + Output the names of all user defined functions in the given keyspace . <nl> + <nl> + DESCRIBE FUNCTION [ < keyspace > . ] < function > <nl> + <nl> + Describe the given user defined function . <nl> + <nl> + DESCRIBE AGGREGATES < keyspace > <nl> + <nl> + Output the names of all user defined aggregates in the given keyspace . <nl> + <nl> + DESCRIBE AGGREGATE [ < keyspace > . ] < aggregate > <nl> + <nl> + Describe the given user defined aggregate . <nl> " " " <nl> what = parsed . matched [ 1 ] [ 1 ] . lower ( ) <nl> - if what = = ' keyspaces ' : <nl> + if what = = ' functions ' : <nl> + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + self . describe _ functions ( ksname ) <nl> + elif what = = ' function ' : <nl> + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + functionname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' udfname ' ) ) <nl> + self . describe _ function ( ksname , functionname ) <nl> + elif what = = ' aggregates ' : <nl> + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + self . describe _ aggregates ( ksname ) <nl> + elif what = = ' aggregate ' : <nl> + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + aggregatename = self . cql _ unprotect _ name ( parsed . get _ binding ( ' udaname ' ) ) <nl> + self . describe _ aggregate ( ksname , aggregatename ) <nl> + elif what = = ' keyspaces ' : <nl> self . describe _ keyspaces ( ) <nl> - if what = = ' keyspace ' : <nl> + elif what = = ' keyspace ' : <nl> ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) <nl> if not ksname : <nl> ksname = self . current _ keyspace <nl> diff - - git a / lib / cassandra - driver - 2 . 6 . 0c1 . zip b / lib / cassandra - driver - 2 . 6 . 0c1 . zip <nl> new file mode 100644 <nl> index 0000000 . . 0e77468 <nl> Binary files / dev / null and b / lib / cassandra - driver - 2 . 6 . 0c1 . zip differ <nl> diff - - git a / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip b / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip <nl> deleted file mode 100644 <nl> index ce21a7a . . 0000000 <nl> Binary files a / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip and / dev / null differ <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index ae66a4e . . 75b2871 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 209 , 10 + 209 , 20 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> < mapLiteral > : : = " { " < term > " : " < term > ( " , " < term > " : " < term > ) * " } " <nl> ; <nl> <nl> - < userFunctionName > : : = < identifier > ( " . " < identifier > ) ? <nl> - ; <nl> + < anyFunctionName > : : = ( ksname = < cfOrKsName > dot = " . " ) ? udfname = < cfOrKsName > ; <nl> + <nl> + < userFunctionName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? udfname = < cfOrKsName > ; <nl> + <nl> + < refUserFunctionName > : : = udfname = < cfOrKsName > ; <nl> <nl> - < functionName > : : = < userFunctionName > <nl> + < userAggregateName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? udaname = < cfOrKsName > ; <nl> + <nl> + < functionAggregateName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? functionname = < cfOrKsName > ; <nl> + <nl> + < aggregateName > : : = < userAggregateName > <nl> + ; <nl> + <nl> + < functionName > : : = < functionAggregateName > <nl> | " TOKEN " <nl> ; <nl> <nl> @ @ - 645 , 6 + 655 , 69 @ @ syntax _ rules + = r ' ' ' <nl> ; <nl> ' ' ' <nl> <nl> + <nl> + <nl> + def udf _ name _ completer ( ctxt , cass ) : <nl> + ks = ctxt . get _ binding ( ' ksname ' , None ) <nl> + if ks is not None : <nl> + ks = dequote _ name ( ks ) <nl> + try : <nl> + udfnames = cass . get _ userfunction _ names ( ks ) <nl> + except Exception : <nl> + if ks is None : <nl> + return ( ) <nl> + raise <nl> + return map ( maybe _ escape _ name , udfnames ) <nl> + <nl> + <nl> + def uda _ name _ completer ( ctxt , cass ) : <nl> + ks = ctxt . get _ binding ( ' ksname ' , None ) <nl> + if ks is not None : <nl> + ks = dequote _ name ( ks ) <nl> + try : <nl> + udanames = cass . get _ useraggregate _ names ( ks ) <nl> + except Exception : <nl> + if ks is None : <nl> + return ( ) <nl> + raise <nl> + return map ( maybe _ escape _ name , udanames ) <nl> + <nl> + <nl> + def udf _ uda _ name _ completer ( ctxt , cass ) : <nl> + ks = ctxt . get _ binding ( ' ksname ' , None ) <nl> + if ks is not None : <nl> + ks = dequote _ name ( ks ) <nl> + try : <nl> + functionnames = cass . get _ userfunction _ names ( ks ) + cass . get _ useraggregate _ names ( ks ) <nl> + except Exception : <nl> + if ks is None : <nl> + return ( ) <nl> + raise <nl> + return map ( maybe _ escape _ name , functionnames ) <nl> + <nl> + <nl> + def ref _ udf _ name _ completer ( ctxt , cass ) : <nl> + try : <nl> + udanames = cass . get _ userfunction _ names ( None ) <nl> + except Exception : <nl> + return ( ) <nl> + return map ( maybe _ escape _ name , udanames ) <nl> + <nl> + <nl> + completer _ for ( ' functionAggregateName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) <nl> + completer _ for ( ' functionAggregateName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) <nl> + completer _ for ( ' functionAggregateName ' , ' functionname ' ) ( udf _ uda _ name _ completer ) <nl> + completer _ for ( ' anyFunctionName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) <nl> + completer _ for ( ' anyFunctionName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) <nl> + completer _ for ( ' anyFunctionName ' , ' udfname ' ) ( udf _ name _ completer ) <nl> + completer _ for ( ' userFunctionName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) <nl> + completer _ for ( ' userFunctionName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) <nl> + completer _ for ( ' userFunctionName ' , ' udfname ' ) ( udf _ name _ completer ) <nl> + completer _ for ( ' refUserFunctionName ' , ' udfname ' ) ( ref _ udf _ name _ completer ) <nl> + completer _ for ( ' userAggregateName ' , ' ksname ' ) ( cf _ ks _ dot _ completer ) <nl> + completer _ for ( ' userAggregateName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) <nl> + completer _ for ( ' userAggregateName ' , ' udaname ' ) ( uda _ name _ completer ) <nl> + <nl> @ completer _ for ( ' orderByClause ' , ' ordercol ' ) <nl> def select _ order _ column _ completer ( ctxt , cass ) : <nl> prev _ order _ cols = ctxt . get _ binding ( ' ordercol ' , ( ) ) <nl> @ @ - 1034 , 13 + 1107 , 13 @ @ syntax _ rules + = r ' ' ' <nl> <nl> < createAggregateStatement > : : = " CREATE " ( " OR " " REPLACE " ) ? " AGGREGATE " <nl> ( " IF " " NOT " " EXISTS " ) ? <nl> - < userFunctionName > <nl> + < userAggregateName > <nl> ( " ( " <nl> ( < storageType > ( " , " < storageType > ) * ) ? <nl> " ) " ) ? <nl> - " SFUNC " < identifier > <nl> + " SFUNC " < refUserFunctionName > <nl> " STYPE " < storageType > <nl> - ( " FINALFUNC " < identifier > ) ? <nl> + ( " FINALFUNC " < refUserFunctionName > ) ? <nl> ( " INITCOND " < term > ) ? <nl> ; <nl> <nl> @ @ - 1078 , 7 + 1151 , 7 @ @ syntax _ rules + = r ' ' ' <nl> < dropFunctionStatement > : : = " DROP " " FUNCTION " ( " IF " " EXISTS " ) ? < userFunctionName > <nl> ; <nl> <nl> - < dropAggregateStatement > : : = " DROP " " AGGREGATE " ( " IF " " EXISTS " ) ? < userFunctionName > <nl> + < dropAggregateStatement > : : = " DROP " " AGGREGATE " ( " IF " " EXISTS " ) ? < userAggregateName > <nl> ; <nl> <nl> ' ' ' <nl> @ @ - 1246 , 7 + 1319 , 11 @ @ syntax _ rules + = r ' ' ' <nl> ; <nl> <nl> < functionResource > : : = ( " ALL " " FUNCTIONS " ( " IN KEYSPACE " < keyspaceName > ) ? ) <nl> - | ( " FUNCTION " < userFunctionName > ) <nl> + | ( " FUNCTION " < functionAggregateName > <nl> + ( " ( " ( newcol = < cident > < storageType > <nl> + ( " , " [ newcolname ] = < cident > < storageType > ) * ) ? <nl> + " ) " ) <nl> + ) <nl> ; <nl> ' ' ' <nl> <nl> diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py <nl> index b38b235 . . 860a582 100644 <nl> - - - a / pylib / cqlshlib / helptopics . py <nl> + + + b / pylib / cqlshlib / helptopics . py <nl> @ @ - 183 , 6 + 183 , 8 @ @ class CQLHelpTopics ( object ) : <nl> HELP DROP _ KEYSPACE ; <nl> HELP DROP _ TABLE ; <nl> HELP DROP _ INDEX ; <nl> + HELP DROP _ FUNCTION ; <nl> + HELP DROP _ AGGREGATE ; <nl> " " " <nl> <nl> def help _ drop _ keyspace ( self ) : <nl> @ @ - 211 , 6 + 213 , 37 @ @ class CQLHelpTopics ( object ) : <nl> A DROP INDEX statement is used to drop an existing secondary index . <nl> " " " <nl> <nl> + def help _ drop _ function ( self ) : <nl> + print " " " <nl> + DROP FUNCTION ( IF EXISTS ) ? <nl> + ( < keyspace > ' . ' ) ? < function - name > <nl> + ( ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' ) ? <nl> + <nl> + DROP FUNCTION statement removes a function created using CREATE FUNCTION . <nl> + You must specify the argument types ( signature ) of the function to drop if there <nl> + are multiple functions with the same name but a different signature <nl> + ( overloaded functions ) . <nl> + <nl> + DROP FUNCTION with the optional IF EXISTS keywords drops a function if it exists . <nl> + " " " <nl> + <nl> + def help _ drop _ aggregate ( self ) : <nl> + print " " " <nl> + DROP AGGREGATE ( IF EXISTS ) ? <nl> + ( < keyspace > ' . ' ) ? < aggregate - name > <nl> + ( ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' ) ? <nl> + <nl> + The DROP AGGREGATE statement removes an aggregate created using CREATE AGGREGATE . <nl> + You must specify the argument types of the aggregate to drop if there are multiple <nl> + aggregates with the same name but a different signature ( overloaded aggregates ) . <nl> + <nl> + DROP AGGREGATE with the optional IF EXISTS keywords drops an aggregate if it exists , <nl> + and does nothing if a function with the signature does not exist . <nl> + <nl> + Signatures for user - defined aggregates follow the same rules as for <nl> + user - defined functions . <nl> + " " " <nl> + <nl> def help _ truncate ( self ) : <nl> print " " " <nl> TRUNCATE < tablename > ; <nl> @ @ - 227 , 6 + 260 , 8 @ @ class CQLHelpTopics ( object ) : <nl> HELP CREATE _ KEYSPACE ; <nl> HELP CREATE _ TABLE ; <nl> HELP CREATE _ INDEX ; <nl> + HELP CREATE _ FUNCTION ; <nl> + HELP CREATE _ AGGREGATE ; <nl> " " " <nl> <nl> def help _ use ( self ) : <nl> @ @ - 243 , 6 + 278 , 96 @ @ class CQLHelpTopics ( object ) : <nl> number , it can be quoted using double quotes . <nl> " " " <nl> <nl> + def help _ create _ aggregate ( self ) : <nl> + print " " " <nl> + CREATE ( OR REPLACE ) ? AGGREGATE ( IF NOT EXISTS ) ? <nl> + ( < keyspace > ' . ' ) ? < aggregate - name > <nl> + ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' <nl> + SFUNC ( < keyspace > ' . ' ) ? < state - functionname > <nl> + STYPE < state - type > <nl> + ( FINALFUNC ( < keyspace > ' . ' ) ? < final - functionname > ) ? <nl> + ( INITCOND < init - cond > ) ? <nl> + <nl> + CREATE AGGREGATE creates or replaces a user - defined aggregate . <nl> + <nl> + CREATE AGGREGATE with the optional OR REPLACE keywords either creates an aggregate <nl> + or replaces an existing one with the same signature . A CREATE AGGREGATE without <nl> + OR REPLACE fails if an aggregate with the same signature already exists . <nl> + <nl> + CREATE AGGREGATE with the optional IF NOT EXISTS keywords either creates an aggregate <nl> + if it does not already exist . <nl> + <nl> + OR REPLACE and IF NOT EXIST cannot be used together . <nl> + <nl> + Aggregates belong to a keyspace . If no keyspace is specified in < aggregate - name > , the <nl> + current keyspace is used ( i . e . the keyspace specified using the USE statement ) . It is <nl> + not possible to create a user - defined aggregate in one of the system keyspaces . <nl> + <nl> + Signatures for user - defined aggregates follow the same rules as for <nl> + user - defined functions . <nl> + <nl> + STYPE defines the type of the state value and must be specified . <nl> + <nl> + The optional INITCOND defines the initial state value for the aggregate . It defaults <nl> + to null . A non - null INITCOND must be specified for state functions that are declared <nl> + with RETURNS NULL ON NULL INPUT . <nl> + <nl> + SFUNC references an existing function to be used as the state modifying function . The <nl> + type of first argument of the state function must match STYPE . The remaining argument <nl> + types of the state function must match the argument types of the aggregate function . <nl> + State is not updated for state functions declared with RETURNS NULL ON NULL INPUT and <nl> + called with null . <nl> + <nl> + The optional FINALFUNC is called just before the aggregate result is returned . It must <nl> + take only one argument with type STYPE . The return type of the FINALFUNC may be a <nl> + different type . A final function declared with RETURNS NULL ON NULL INPUT means that <nl> + the aggregate ' s return value will be null , if the last state is null . <nl> + <nl> + If no FINALFUNC is defined , the overall return type of the aggregate function is STYPE . <nl> + If a FINALFUNC is defined , it is the return type of that function . <nl> + " " " <nl> + <nl> + def help _ create _ function ( self ) : <nl> + print " " " <nl> + CREATE ( OR REPLACE ) ? FUNCTION ( IF NOT EXISTS ) ? <nl> + ( < keyspace > ' . ' ) ? < function - name > <nl> + ' ( ' < arg - name > < arg - type > ( ' , ' < arg - name > < arg - type > ) * ' ) ' <nl> + ( CALLED | RETURNS NULL ) ON NULL INPUT <nl> + RETURNS < type > <nl> + LANGUAGE < language > <nl> + AS < body > <nl> + <nl> + CREATE FUNCTION creates or replaces a user - defined function . <nl> + <nl> + Signatures are used to distinguish individual functions . The signature consists of : <nl> + <nl> + The fully qualified function name - i . e keyspace plus function - name <nl> + The concatenated list of all argument types <nl> + <nl> + Note that keyspace names , function names and argument types are subject to the default <nl> + naming conventions and case - sensitivity rules . <nl> + <nl> + CREATE FUNCTION with the optional OR REPLACE keywords either creates a function or <nl> + replaces an existing one with the same signature . A CREATE FUNCTION without OR REPLACE <nl> + fails if a function with the same signature already exists . <nl> + <nl> + Behavior on invocation with null values must be defined for each function . There are <nl> + two options : <nl> + <nl> + RETURNS NULL ON NULL INPUT declares that the function will always return null if any <nl> + of the input arguments is null . CALLED ON NULL INPUT declares that the function will <nl> + always be executed . <nl> + <nl> + If the optional IF NOT EXISTS keywords are used , the function will only be created if <nl> + another function with the same signature does not exist . <nl> + <nl> + OR REPLACE and IF NOT EXIST cannot be used together . <nl> + <nl> + Functions belong to a keyspace . If no keyspace is specified in < function - name > , the <nl> + current keyspace is used ( i . e . the keyspace specified using the USE statement ) . <nl> + It is not possible to create a user - defined function in one of the system keyspaces . <nl> + " " " <nl> + <nl> def help _ create _ table ( self ) : <nl> print " " " <nl> CREATE TABLE < cfname > ( < colname > < type > PRIMARY KEY [ , <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index d49dbd3 . . 094b72e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 171 , 6 + 171 , 8 @ @ options { <nl> <nl> public Set < Permission > filterPermissions ( Set < Permission > permissions , IResource resource ) <nl> { <nl> + if ( resource = = null ) <nl> + return Collections . emptySet ( ) ; <nl> Set < Permission > filtered = new HashSet < > ( permissions ) ; <nl> filtered . retainAll ( resource . applicablePermissions ( ) ) ; <nl> if ( filtered . isEmpty ( ) )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 16fe569 . . c0480d7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 
 + * Update cqlsh for UDFs ( CASSANDRA - 7556 ) 
 * Change Windows kernel default timer resolution ( CASSANDRA - 9634 ) 
 * Deprected sstable2json and json2sstable ( CASSANDRA - 9618 ) 
 * Allow native functions in user - defined aggregates ( CASSANDRA - 9542 ) 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index b2a729c . . a556a92 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 265 , 7 + 265 , 11 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' 
 ; 
 
 < describeCommand > : : = ( " DESCRIBE " | " DESC " ) 
 - ( " KEYSPACES " 
 + ( " FUNCTIONS " ksname = < keyspaceName > ? 
 + | " FUNCTION " udf = < anyFunctionName > 
 + | " AGGREGATES " ksname = < keyspaceName > ? 
 + | " AGGREGATE " uda = < userAggregateName > 
 + | " KEYSPACES " 
 | " KEYSPACE " ksname = < keyspaceName > ? 
 | ( " COLUMNFAMILY " | " TABLE " ) cf = < columnFamilyName > 
 | ( " COLUMNFAMILIES " | " TABLES " ) 
 @ @ - 437 , 6 + 441 , 12 @ @ class VersionNotSupported ( Exception ) : 
 class UserTypeNotFound ( Exception ) : 
 pass 
 
 + class FunctionNotFound ( Exception ) : 
 + pass 
 + 
 + class AggregateNotFound ( Exception ) : 
 + pass 
 + 
 
 class DecodeError ( Exception ) : 
 verb = ' decode ' 
 @ @ - 784 , 6 + 794 , 18 @ @ class Shell ( cmd . Cmd ) : 
 return [ ( field _ name , field _ type . cql _ parameterized _ type ( ) ) 
 for field _ name , field _ type in zip ( user _ type . field _ names , user _ type . field _ types ) ] 
 
 + def get _ userfunction _ names ( self , ksname = None ) : 
 + if ksname is None : 
 + ksname = self . current _ keyspace 
 + 
 + return map ( lambda f : f . name , self . get _ keyspace _ meta ( ksname ) . functions . values ( ) ) 
 + 
 + def get _ useraggregate _ names ( self , ksname = None ) : 
 + if ksname is None : 
 + ksname = self . current _ keyspace 
 + 
 + return map ( lambda f : f . name , self . get _ keyspace _ meta ( ksname ) . aggregates . values ( ) ) 
 + 
 def get _ cluster _ name ( self ) : 
 return self . conn . metadata . cluster _ name 
 
 @ @ - 1284 , 6 + 1306 , 8 @ @ class Shell ( cmd . Cmd ) : 
 def describe _ columnfamily ( self , ksname , cfname ) : 
 if ksname is None : 
 ksname = self . current _ keyspace 
 + if ksname is None : 
 + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) 
 print 
 self . print _ recreate _ columnfamily ( ksname , cfname , sys . stdout ) 
 print 
 @ @ - 1301 , 6 + 1325 , 60 @ @ class Shell ( cmd . Cmd ) : 
 cmd . Cmd . columnize ( self , protect _ names ( self . get _ columnfamily _ names ( ksname ) ) ) 
 print 
 
 + def describe _ functions ( self , ksname = None ) : 
 + print 
 + if ksname is None : 
 + for ksmeta in self . get _ keyspaces ( ) : 
 + name = protect _ name ( ksmeta . name ) 
 + print ' Keyspace % s ' % ( name , ) 
 + print ' - - - - - - - - - % s ' % ( ' - ' * len ( name ) ) 
 + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . functions . keys ( ) ) ) 
 + print 
 + else : 
 + ksmeta = self . get _ keyspace _ meta ( ksname ) 
 + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . functions . keys ( ) ) ) 
 + print 
 + 
 + def describe _ function ( self , ksname , functionname ) : 
 + if ksname is None : 
 + ksname = self . current _ keyspace 
 + if ksname is None : 
 + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) 
 + print 
 + ksmeta = self . get _ keyspace _ meta ( ksname ) 
 + functions = filter ( lambda f : f . name = = functionname , ksmeta . functions . values ( ) ) 
 + if len ( functions ) = = 0 : 
 + raise FunctionNotFound ( " User defined function % r not found " % functionname ) 
 + print " \ n \ n " . join ( func . as _ cql _ query ( formatted = True ) for func in functions ) 
 + print 
 + 
 + def describe _ aggregates ( self , ksname = None ) : 
 + print 
 + if ksname is None : 
 + for ksmeta in self . get _ keyspaces ( ) : 
 + name = protect _ name ( ksmeta . name ) 
 + print ' Keyspace % s ' % ( name , ) 
 + print ' - - - - - - - - - % s ' % ( ' - ' * len ( name ) ) 
 + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . aggregates . keys ( ) ) ) 
 + print 
 + else : 
 + ksmeta = self . get _ keyspace _ meta ( ksname ) 
 + cmd . Cmd . columnize ( self , protect _ names ( ksmeta . aggregates . keys ( ) ) ) 
 + print 
 + 
 + def describe _ aggregate ( self , ksname , aggregatename ) : 
 + if ksname is None : 
 + ksname = self . current _ keyspace 
 + if ksname is None : 
 + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) 
 + print 
 + ksmeta = self . get _ keyspace _ meta ( ksname ) 
 + aggregates = filter ( lambda f : f . name = = aggregatename , ksmeta . aggregates . values ( ) ) 
 + if len ( aggregates ) = = 0 : 
 + raise FunctionNotFound ( " User defined aggregate % r not found " % aggregatename ) 
 + print " \ n \ n " . join ( aggr . as _ cql _ query ( formatted = True ) for aggr in aggregates ) 
 + print 
 + 
 def describe _ usertypes ( self , ksname ) : 
 print 
 if ksname is None : 
 @ @ - 1318 , 6 + 1396 , 8 @ @ class Shell ( cmd . Cmd ) : 
 def describe _ usertype ( self , ksname , typename ) : 
 if ksname is None : 
 ksname = self . current _ keyspace 
 + if ksname is None : 
 + raise NoKeyspaceError ( " No keyspace specified and no current keyspace " ) 
 print 
 ksmeta = self . get _ keyspace _ meta ( ksname ) 
 try : 
 @ @ - 1395 , 11 + 1475 , 41 @ @ class Shell ( cmd . Cmd ) : 
 Output CQL commands that could be used to recreate the entire ( non - system ) schema . 
 Works as though " DESCRIBE KEYSPACE k " was invoked for each non - system keyspace 
 k . Use DESCRIBE FULL SCHEMA to include the system keyspaces . 
 + 
 + DESCRIBE FUNCTIONS < keyspace > 
 + 
 + Output the names of all user defined functions in the given keyspace . 
 + 
 + DESCRIBE FUNCTION [ < keyspace > . ] < function > 
 + 
 + Describe the given user defined function . 
 + 
 + DESCRIBE AGGREGATES < keyspace > 
 + 
 + Output the names of all user defined aggregates in the given keyspace . 
 + 
 + DESCRIBE AGGREGATE [ < keyspace > . ] < aggregate > 
 + 
 + Describe the given user defined aggregate . 
 " " " 
 what = parsed . matched [ 1 ] [ 1 ] . lower ( ) 
 - if what = = ' keyspaces ' : 
 + if what = = ' functions ' : 
 + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + self . describe _ functions ( ksname ) 
 + elif what = = ' function ' : 
 + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + functionname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' udfname ' ) ) 
 + self . describe _ function ( ksname , functionname ) 
 + elif what = = ' aggregates ' : 
 + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + self . describe _ aggregates ( ksname ) 
 + elif what = = ' aggregate ' : 
 + ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + aggregatename = self . cql _ unprotect _ name ( parsed . get _ binding ( ' udaname ' ) ) 
 + self . describe _ aggregate ( ksname , aggregatename ) 
 + elif what = = ' keyspaces ' : 
 self . describe _ keyspaces ( ) 
 - if what = = ' keyspace ' : 
 + elif what = = ' keyspace ' : 
 ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) 
 if not ksname : 
 ksname = self . current _ keyspace 
 diff - - git a / lib / cassandra - driver - 2 . 6 . 0c1 . zip b / lib / cassandra - driver - 2 . 6 . 0c1 . zip 
 new file mode 100644 
 index 0000000 . . 0e77468 
 Binary files / dev / null and b / lib / cassandra - driver - 2 . 6 . 0c1 . zip differ 
 diff - - git a / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip b / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip 
 deleted file mode 100644 
 index ce21a7a . . 0000000 
 Binary files a / lib / cassandra - driver - internal - only - 2 . 5 . 1 . post0 - 074650b . zip and / dev / null differ 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index ae66a4e . . 75b2871 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 209 , 10 + 209 , 20 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 < mapLiteral > : : = " { " < term > " : " < term > ( " , " < term > " : " < term > ) * " } " 
 ; 
 
 - < userFunctionName > : : = < identifier > ( " . " < identifier > ) ? 
 - ; 
 + < anyFunctionName > : : = ( ksname = < cfOrKsName > dot = " . " ) ? udfname = < cfOrKsName > ; 
 + 
 + < userFunctionName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? udfname = < cfOrKsName > ; 
 + 
 + < refUserFunctionName > : : = udfname = < cfOrKsName > ; 
 
 - < functionName > : : = < userFunctionName > 
 + < userAggregateName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? udaname = < cfOrKsName > ; 
 + 
 + < functionAggregateName > : : = ( ksname = < nonSystemKeyspaceName > dot = " . " ) ? functionname = < cfOrKsName > ; 
 + 
 + < aggregateName > : : = < userAggregateName > 
 + ; 
 + 
 + < functionName > : : = < functionAggregateName > 
 | " TOKEN " 
 ; 
 
 @ @ - 645 , 6 + 655 , 69 @ @ syntax _ rules + = r ' ' ' 
 ; 
 ' ' ' 
 
 + 
 + 
 + def udf _ name _ completer ( ctxt , cass ) : 
 + ks = ctxt . get _ binding ( ' ksname ' , None ) 
 + if ks is not None : 
 + ks = dequote _ name ( ks ) 
 + try : 
 + udfnames = cass . get _ userfunction _ names ( ks ) 
 + except Exception : 
 + if ks is None : 
 + return ( ) 
 + raise 
 + return map ( maybe _ escape _ name , udfnames ) 
 + 
 + 
 + def uda _ name _ completer ( ctxt , cass ) : 
 + ks = ctxt . get _ binding ( ' ksname ' , None ) 
 + if ks is not None : 
 + ks = dequote _ name ( ks ) 
 + try : 
 + udanames = cass . get _ useraggregate _ names ( ks ) 
 + except Exception : 
 + if ks is None : 
 + return ( ) 
 + raise 
 + return map ( maybe _ escape _ name , udanames ) 
 + 
 + 
 + def udf _ uda _ name _ completer ( ctxt , cass ) : 
 + ks = ctxt . get _ binding ( ' ksname ' , None ) 
 + if ks is not None : 
 + ks = dequote _ name ( ks ) 
 + try : 
 + functionnames = cass . get _ userfunction _ names ( ks ) + cass . get _ useraggregate _ names ( ks ) 
 + except Exception : 
 + if ks is None : 
 + return ( ) 
 + raise 
 + return map ( maybe _ escape _ name , functionnames ) 
 + 
 + 
 + def ref _ udf _ name _ completer ( ctxt , cass ) : 
 + try : 
 + udanames = cass . get _ userfunction _ names ( None ) 
 + except Exception : 
 + return ( ) 
 + return map ( maybe _ escape _ name , udanames ) 
 + 
 + 
 + completer _ for ( ' functionAggregateName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) 
 + completer _ for ( ' functionAggregateName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) 
 + completer _ for ( ' functionAggregateName ' , ' functionname ' ) ( udf _ uda _ name _ completer ) 
 + completer _ for ( ' anyFunctionName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) 
 + completer _ for ( ' anyFunctionName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) 
 + completer _ for ( ' anyFunctionName ' , ' udfname ' ) ( udf _ name _ completer ) 
 + completer _ for ( ' userFunctionName ' , ' ksname ' ) ( cf _ ks _ name _ completer ) 
 + completer _ for ( ' userFunctionName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) 
 + completer _ for ( ' userFunctionName ' , ' udfname ' ) ( udf _ name _ completer ) 
 + completer _ for ( ' refUserFunctionName ' , ' udfname ' ) ( ref _ udf _ name _ completer ) 
 + completer _ for ( ' userAggregateName ' , ' ksname ' ) ( cf _ ks _ dot _ completer ) 
 + completer _ for ( ' userAggregateName ' , ' dot ' ) ( cf _ ks _ dot _ completer ) 
 + completer _ for ( ' userAggregateName ' , ' udaname ' ) ( uda _ name _ completer ) 
 + 
 @ completer _ for ( ' orderByClause ' , ' ordercol ' ) 
 def select _ order _ column _ completer ( ctxt , cass ) : 
 prev _ order _ cols = ctxt . get _ binding ( ' ordercol ' , ( ) ) 
 @ @ - 1034 , 13 + 1107 , 13 @ @ syntax _ rules + = r ' ' ' 
 
 < createAggregateStatement > : : = " CREATE " ( " OR " " REPLACE " ) ? " AGGREGATE " 
 ( " IF " " NOT " " EXISTS " ) ? 
 - < userFunctionName > 
 + < userAggregateName > 
 ( " ( " 
 ( < storageType > ( " , " < storageType > ) * ) ? 
 " ) " ) ? 
 - " SFUNC " < identifier > 
 + " SFUNC " < refUserFunctionName > 
 " STYPE " < storageType > 
 - ( " FINALFUNC " < identifier > ) ? 
 + ( " FINALFUNC " < refUserFunctionName > ) ? 
 ( " INITCOND " < term > ) ? 
 ; 
 
 @ @ - 1078 , 7 + 1151 , 7 @ @ syntax _ rules + = r ' ' ' 
 < dropFunctionStatement > : : = " DROP " " FUNCTION " ( " IF " " EXISTS " ) ? < userFunctionName > 
 ; 
 
 - < dropAggregateStatement > : : = " DROP " " AGGREGATE " ( " IF " " EXISTS " ) ? < userFunctionName > 
 + < dropAggregateStatement > : : = " DROP " " AGGREGATE " ( " IF " " EXISTS " ) ? < userAggregateName > 
 ; 
 
 ' ' ' 
 @ @ - 1246 , 7 + 1319 , 11 @ @ syntax _ rules + = r ' ' ' 
 ; 
 
 < functionResource > : : = ( " ALL " " FUNCTIONS " ( " IN KEYSPACE " < keyspaceName > ) ? ) 
 - | ( " FUNCTION " < userFunctionName > ) 
 + | ( " FUNCTION " < functionAggregateName > 
 + ( " ( " ( newcol = < cident > < storageType > 
 + ( " , " [ newcolname ] = < cident > < storageType > ) * ) ? 
 + " ) " ) 
 + ) 
 ; 
 ' ' ' 
 
 diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py 
 index b38b235 . . 860a582 100644 
 - - - a / pylib / cqlshlib / helptopics . py 
 + + + b / pylib / cqlshlib / helptopics . py 
 @ @ - 183 , 6 + 183 , 8 @ @ class CQLHelpTopics ( object ) : 
 HELP DROP _ KEYSPACE ; 
 HELP DROP _ TABLE ; 
 HELP DROP _ INDEX ; 
 + HELP DROP _ FUNCTION ; 
 + HELP DROP _ AGGREGATE ; 
 " " " 
 
 def help _ drop _ keyspace ( self ) : 
 @ @ - 211 , 6 + 213 , 37 @ @ class CQLHelpTopics ( object ) : 
 A DROP INDEX statement is used to drop an existing secondary index . 
 " " " 
 
 + def help _ drop _ function ( self ) : 
 + print " " " 
 + DROP FUNCTION ( IF EXISTS ) ? 
 + ( < keyspace > ' . ' ) ? < function - name > 
 + ( ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' ) ? 
 + 
 + DROP FUNCTION statement removes a function created using CREATE FUNCTION . 
 + You must specify the argument types ( signature ) of the function to drop if there 
 + are multiple functions with the same name but a different signature 
 + ( overloaded functions ) . 
 + 
 + DROP FUNCTION with the optional IF EXISTS keywords drops a function if it exists . 
 + " " " 
 + 
 + def help _ drop _ aggregate ( self ) : 
 + print " " " 
 + DROP AGGREGATE ( IF EXISTS ) ? 
 + ( < keyspace > ' . ' ) ? < aggregate - name > 
 + ( ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' ) ? 
 + 
 + The DROP AGGREGATE statement removes an aggregate created using CREATE AGGREGATE . 
 + You must specify the argument types of the aggregate to drop if there are multiple 
 + aggregates with the same name but a different signature ( overloaded aggregates ) . 
 + 
 + DROP AGGREGATE with the optional IF EXISTS keywords drops an aggregate if it exists , 
 + and does nothing if a function with the signature does not exist . 
 + 
 + Signatures for user - defined aggregates follow the same rules as for 
 + user - defined functions . 
 + " " " 
 + 
 def help _ truncate ( self ) : 
 print " " " 
 TRUNCATE < tablename > ; 
 @ @ - 227 , 6 + 260 , 8 @ @ class CQLHelpTopics ( object ) : 
 HELP CREATE _ KEYSPACE ; 
 HELP CREATE _ TABLE ; 
 HELP CREATE _ INDEX ; 
 + HELP CREATE _ FUNCTION ; 
 + HELP CREATE _ AGGREGATE ; 
 " " " 
 
 def help _ use ( self ) : 
 @ @ - 243 , 6 + 278 , 96 @ @ class CQLHelpTopics ( object ) : 
 number , it can be quoted using double quotes . 
 " " " 
 
 + def help _ create _ aggregate ( self ) : 
 + print " " " 
 + CREATE ( OR REPLACE ) ? AGGREGATE ( IF NOT EXISTS ) ? 
 + ( < keyspace > ' . ' ) ? < aggregate - name > 
 + ' ( ' < arg - type > ( ' , ' < arg - type > ) * ' ) ' 
 + SFUNC ( < keyspace > ' . ' ) ? < state - functionname > 
 + STYPE < state - type > 
 + ( FINALFUNC ( < keyspace > ' . ' ) ? < final - functionname > ) ? 
 + ( INITCOND < init - cond > ) ? 
 + 
 + CREATE AGGREGATE creates or replaces a user - defined aggregate . 
 + 
 + CREATE AGGREGATE with the optional OR REPLACE keywords either creates an aggregate 
 + or replaces an existing one with the same signature . A CREATE AGGREGATE without 
 + OR REPLACE fails if an aggregate with the same signature already exists . 
 + 
 + CREATE AGGREGATE with the optional IF NOT EXISTS keywords either creates an aggregate 
 + if it does not already exist . 
 + 
 + OR REPLACE and IF NOT EXIST cannot be used together . 
 + 
 + Aggregates belong to a keyspace . If no keyspace is specified in < aggregate - name > , the 
 + current keyspace is used ( i . e . the keyspace specified using the USE statement ) . It is 
 + not possible to create a user - defined aggregate in one of the system keyspaces . 
 + 
 + Signatures for user - defined aggregates follow the same rules as for 
 + user - defined functions . 
 + 
 + STYPE defines the type of the state value and must be specified . 
 + 
 + The optional INITCOND defines the initial state value for the aggregate . It defaults 
 + to null . A non - null INITCOND must be specified for state functions that are declared 
 + with RETURNS NULL ON NULL INPUT . 
 + 
 + SFUNC references an existing function to be used as the state modifying function . The 
 + type of first argument of the state function must match STYPE . The remaining argument 
 + types of the state function must match the argument types of the aggregate function . 
 + State is not updated for state functions declared with RETURNS NULL ON NULL INPUT and 
 + called with null . 
 + 
 + The optional FINALFUNC is called just before the aggregate result is returned . It must 
 + take only one argument with type STYPE . The return type of the FINALFUNC may be a 
 + different type . A final function declared with RETURNS NULL ON NULL INPUT means that 
 + the aggregate ' s return value will be null , if the last state is null . 
 + 
 + If no FINALFUNC is defined , the overall return type of the aggregate function is STYPE . 
 + If a FINALFUNC is defined , it is the return type of that function . 
 + " " " 
 + 
 + def help _ create _ function ( self ) : 
 + print " " " 
 + CREATE ( OR REPLACE ) ? FUNCTION ( IF NOT EXISTS ) ? 
 + ( < keyspace > ' . ' ) ? < function - name > 
 + ' ( ' < arg - name > < arg - type > ( ' , ' < arg - name > < arg - type > ) * ' ) ' 
 + ( CALLED | RETURNS NULL ) ON NULL INPUT 
 + RETURNS < type > 
 + LANGUAGE < language > 
 + AS < body > 
 + 
 + CREATE FUNCTION creates or replaces a user - defined function . 
 + 
 + Signatures are used to distinguish individual functions . The signature consists of : 
 + 
 + The fully qualified function name - i . e keyspace plus function - name 
 + The concatenated list of all argument types 
 + 
 + Note that keyspace names , function names and argument types are subject to the default 
 + naming conventions and case - sensitivity rules . 
 + 
 + CREATE FUNCTION with the optional OR REPLACE keywords either creates a function or 
 + replaces an existing one with the same signature . A CREATE FUNCTION without OR REPLACE 
 + fails if a function with the same signature already exists . 
 + 
 + Behavior on invocation with null values must be defined for each function . There are 
 + two options : 
 + 
 + RETURNS NULL ON NULL INPUT declares that the function will always return null if any 
 + of the input arguments is null . CALLED ON NULL INPUT declares that the function will 
 + always be executed . 
 + 
 + If the optional IF NOT EXISTS keywords are used , the function will only be created if 
 + another function with the same signature does not exist . 
 + 
 + OR REPLACE and IF NOT EXIST cannot be used together . 
 + 
 + Functions belong to a keyspace . If no keyspace is specified in < function - name > , the 
 + current keyspace is used ( i . e . the keyspace specified using the USE statement ) . 
 + It is not possible to create a user - defined function in one of the system keyspaces . 
 + " " " 
 + 
 def help _ create _ table ( self ) : 
 print " " " 
 CREATE TABLE < cfname > ( < colname > < type > PRIMARY KEY [ , 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index d49dbd3 . . 094b72e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 171 , 6 + 171 , 8 @ @ options { 
 
 public Set < Permission > filterPermissions ( Set < Permission > permissions , IResource resource ) 
 { 
 + if ( resource = = null ) 
 + return Collections . emptySet ( ) ; 
 Set < Permission > filtered = new HashSet < > ( permissions ) ; 
 filtered . retainAll ( resource . applicablePermissions ( ) ) ; 
 if ( filtered . isEmpty ( ) )

NEAREST DIFF:
ELIMINATEDSENTENCE
