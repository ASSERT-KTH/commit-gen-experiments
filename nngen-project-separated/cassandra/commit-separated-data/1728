BLEU SCORE: 0.01509869171115925

TEST MSG: Introduce NoSpamLogger
GENERATED MSG: replace tcp writes w / blocking i / o

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / NoSpamLogger . java b / src / java / org / apache / cassandra / utils / NoSpamLogger . java <nl> new file mode 100644 <nl> index 0000000 . . 9f5d5ce <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / NoSpamLogger . java <nl> @ @ - 0 , 0 + 1 , 238 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicLong ; <nl> + <nl> + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> + import org . slf4j . Logger ; <nl> + <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + <nl> + / * * <nl> + * Logging that limits each log statement to firing based on time since the statement last fired . <nl> + * <nl> + * Every logger has a unique timer per statement . Minimum time between logging is set for each statement <nl> + * the first time it is used and a subsequent attempt to request that statement with a different minimum time will <nl> + * result in the original time being used . No warning is provided if there is a mismatch . <nl> + * <nl> + * If the statement is cached and used to log directly then only a volatile read will be required in the common case . <nl> + * If the Logger is cached then there is a single concurrent hash map lookup + the volatile read . <nl> + * If neither the logger nor the statement is cached then it is two concurrent hash map lookups + the volatile read . <nl> + * <nl> + * / <nl> + public class NoSpamLogger <nl> + { <nl> + / * * <nl> + * Levels for programmatically specifying the severity of a log statement <nl> + * / <nl> + public enum Level <nl> + { <nl> + INFO , WARN , ERROR ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + static interface Clock <nl> + { <nl> + long nanoTime ( ) ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + static Clock CLOCK = new Clock ( ) <nl> + { <nl> + public long nanoTime ( ) <nl> + { <nl> + return System . nanoTime ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + public class NoSpamLogStatement extends AtomicLong <nl> + { <nl> + private static final long serialVersionUID = 1L ; <nl> + <nl> + private final String statement ; <nl> + private final long minIntervalNanos ; <nl> + <nl> + public NoSpamLogStatement ( String statement , long minIntervalNanos ) <nl> + { <nl> + this . statement = statement ; <nl> + this . minIntervalNanos = minIntervalNanos ; <nl> + } <nl> + <nl> + private boolean shouldLog ( long nowNanos ) <nl> + { <nl> + long expected = get ( ) ; <nl> + return nowNanos - expected > = minIntervalNanos & & compareAndSet ( expected , nowNanos ) ; <nl> + } <nl> + <nl> + public void log ( Level l , long nowNanos , Object . . . objects ) <nl> + { <nl> + if ( ! shouldLog ( nowNanos ) ) return ; <nl> + <nl> + switch ( l ) <nl> + { <nl> + case INFO : <nl> + wrapped . info ( statement , objects ) ; <nl> + break ; <nl> + case WARN : <nl> + wrapped . warn ( statement , objects ) ; <nl> + break ; <nl> + case ERROR : <nl> + wrapped . error ( statement , objects ) ; <nl> + break ; <nl> + default : <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void info ( long nowNanos , Object . . . objects ) <nl> + { <nl> + log ( Level . INFO , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void info ( Object . . . objects ) <nl> + { <nl> + info ( CLOCK . nanoTime ( ) , objects ) ; <nl> + } <nl> + <nl> + public void warn ( long nowNanos , Object . . . objects ) <nl> + { <nl> + log ( Level . WARN , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void warn ( String s , Object . . . objects ) <nl> + { <nl> + warn ( CLOCK . nanoTime ( ) , s , objects ) ; <nl> + } <nl> + <nl> + public void error ( long nowNanos , Object . . . objects ) <nl> + { <nl> + log ( Level . ERROR , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void error ( Object . . . objects ) <nl> + { <nl> + error ( CLOCK . nanoTime ( ) , objects ) ; <nl> + } <nl> + } <nl> + <nl> + private static final NonBlockingHashMap < Logger , NoSpamLogger > wrappedLoggers = new NonBlockingHashMap < > ( ) ; <nl> + <nl> + @ VisibleForTesting <nl> + static void clearWrappedLoggersForTest ( ) <nl> + { <nl> + wrappedLoggers . clear ( ) ; <nl> + } <nl> + <nl> + public static NoSpamLogger getLogger ( Logger logger , long minInterval , TimeUnit unit ) <nl> + { <nl> + NoSpamLogger wrapped = wrappedLoggers . get ( logger ) ; <nl> + if ( wrapped = = null ) <nl> + { <nl> + wrapped = new NoSpamLogger ( logger , minInterval , unit ) ; <nl> + NoSpamLogger temp = wrappedLoggers . putIfAbsent ( logger , wrapped ) ; <nl> + if ( temp ! = null ) <nl> + wrapped = temp ; <nl> + } <nl> + return wrapped ; <nl> + } <nl> + <nl> + public static void log ( Logger logger , Level level , long minInterval , TimeUnit unit , String message , Object . . . objects ) <nl> + { <nl> + log ( logger , level , minInterval , unit , CLOCK . nanoTime ( ) , message , objects ) ; <nl> + } <nl> + <nl> + public static void log ( Logger logger , Level level , long minInterval , TimeUnit unit , long nowNanos , String message , Object . . . objects ) <nl> + { <nl> + NoSpamLogger wrapped = getLogger ( logger , minInterval , unit ) ; <nl> + NoSpamLogStatement statement = wrapped . getStatement ( message ) ; <nl> + statement . log ( level , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public static NoSpamLogStatement getStatement ( Logger logger , String message , long minInterval , TimeUnit unit ) { <nl> + NoSpamLogger wrapped = getLogger ( logger , minInterval , unit ) ; <nl> + return wrapped . getStatement ( message ) ; <nl> + } <nl> + <nl> + private final Logger wrapped ; <nl> + private final long minIntervalNanos ; <nl> + private final NonBlockingHashMap < String , NoSpamLogStatement > lastMessage = new NonBlockingHashMap < > ( ) ; <nl> + <nl> + private NoSpamLogger ( Logger wrapped , long minInterval , TimeUnit timeUnit ) <nl> + { <nl> + this . wrapped = wrapped ; <nl> + minIntervalNanos = timeUnit . toNanos ( minInterval ) ; <nl> + } <nl> + <nl> + public void info ( long nowNanos , String s , Object . . . objects ) <nl> + { <nl> + log ( Level . INFO , s , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void info ( String s , Object . . . objects ) <nl> + { <nl> + info ( CLOCK . nanoTime ( ) , s , objects ) ; <nl> + } <nl> + <nl> + public void warn ( long nowNanos , String s , Object . . . objects ) <nl> + { <nl> + log ( Level . WARN , s , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void warn ( String s , Object . . . objects ) <nl> + { <nl> + warn ( CLOCK . nanoTime ( ) , s , objects ) ; <nl> + } <nl> + <nl> + public void error ( long nowNanos , String s , Object . . . objects ) <nl> + { <nl> + log ( Level . ERROR , s , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public void error ( String s , Object . . . objects ) <nl> + { <nl> + error ( CLOCK . nanoTime ( ) , s , objects ) ; <nl> + } <nl> + <nl> + public void log ( Level l , String s , long nowNanos , Object . . . objects ) { <nl> + getStatement ( s , minIntervalNanos ) . log ( l , nowNanos , objects ) ; <nl> + } <nl> + <nl> + public NoSpamLogStatement getStatement ( String s ) <nl> + { <nl> + return getStatement ( s , minIntervalNanos ) ; <nl> + } <nl> + <nl> + public NoSpamLogStatement getStatement ( String s , long minInterval , TimeUnit unit ) { <nl> + return getStatement ( s , unit . toNanos ( minInterval ) ) ; <nl> + } <nl> + <nl> + public NoSpamLogStatement getStatement ( String s , long minIntervalNanos ) <nl> + { <nl> + NoSpamLogStatement statement = lastMessage . get ( s ) ; <nl> + if ( statement = = null ) <nl> + { <nl> + statement = new NoSpamLogStatement ( s , minIntervalNanos ) ; <nl> + NoSpamLogStatement temp = lastMessage . putIfAbsent ( s , statement ) ; <nl> + if ( temp ! = null ) <nl> + statement = temp ; <nl> + } <nl> + return statement ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java b / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 3ad7ab8 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java <nl> @ @ - 0 , 0 + 1 , 174 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import org . apache . cassandra . utils . NoSpamLogger . Level ; <nl> + import org . apache . cassandra . utils . NoSpamLogger . NoSpamLogStatement ; <nl> + import org . junit . Before ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . helpers . SubstituteLogger ; <nl> + <nl> + <nl> + public class NoSpamLoggerTest <nl> + { <nl> + Map < Level , List < Pair < String , Object [ ] > > > logged = new HashMap < > ( ) ; <nl> + <nl> + Logger mock = new SubstituteLogger ( null ) <nl> + { <nl> + <nl> + @ Override <nl> + public void info ( String statement , Object . . . args ) <nl> + { <nl> + logged . get ( Level . INFO ) . add ( Pair . create ( statement , args ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void warn ( String statement , Object . . . args ) <nl> + { <nl> + logged . get ( Level . WARN ) . add ( Pair . create ( statement , args ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void error ( String statement , Object . . . args ) <nl> + { <nl> + logged . get ( Level . ERROR ) . add ( Pair . create ( statement , args ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) <nl> + { <nl> + return 42 ; / / It ' s a valid hash code <nl> + } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object o ) <nl> + { <nl> + return this = = o ; <nl> + } <nl> + } ; <nl> + <nl> + <nl> + static long now ; <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) throws Exception <nl> + { <nl> + NoSpamLogger . CLOCK = new NoSpamLogger . Clock ( ) <nl> + { <nl> + @ Override <nl> + public long nanoTime ( ) <nl> + { <nl> + return now ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + @ Before <nl> + public void setUp ( ) throws Exception <nl> + { <nl> + logged . put ( Level . INFO , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; <nl> + logged . put ( Level . WARN , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; <nl> + logged . put ( Level . ERROR , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoSpamLogger ( ) throws Exception <nl> + { <nl> + testLevel ( Level . INFO ) ; <nl> + testLevel ( Level . WARN ) ; <nl> + testLevel ( Level . ERROR ) ; <nl> + } <nl> + <nl> + private void testLevel ( Level l ) throws Exception <nl> + { <nl> + setUp ( ) ; <nl> + now = 5 ; <nl> + NoSpamLogger . clearWrappedLoggersForTest ( ) ; <nl> + <nl> + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; <nl> + <nl> + assertEquals ( 1 , logged . get ( l ) . size ( ) ) ; <nl> + <nl> + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; <nl> + <nl> + assertEquals ( 1 , logged . get ( l ) . size ( ) ) ; <nl> + <nl> + now + = 5 ; <nl> + <nl> + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; <nl> + <nl> + assertEquals ( 2 , logged . get ( l ) . size ( ) ) ; <nl> + } <nl> + <nl> + private void assertLoggedSizes ( int info , int warn , int error ) <nl> + { <nl> + assertEquals ( info , logged . get ( Level . INFO ) . size ( ) ) ; <nl> + assertEquals ( warn , logged . get ( Level . WARN ) . size ( ) ) ; <nl> + assertEquals ( error , logged . get ( Level . ERROR ) . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoSpamLoggerDirect ( ) throws Exception <nl> + { <nl> + now = 5 ; <nl> + NoSpamLogger logger = NoSpamLogger . getLogger ( mock , 5 , TimeUnit . NANOSECONDS ) ; <nl> + <nl> + logger . info ( " swizzle { } " , " a " ) ; <nl> + logger . info ( " swizzle { } " , " a " ) ; <nl> + logger . warn ( " swizzle { } " , " a " ) ; <nl> + logger . error ( " swizzle { } " , " a " ) ; <nl> + <nl> + assertLoggedSizes ( 1 , 0 , 0 ) ; <nl> + <nl> + NoSpamLogStatement statement = logger . getStatement ( " swizzle2 { } " , 10 , TimeUnit . NANOSECONDS ) ; <nl> + statement . warn ( " a " ) ; <nl> + / / now is 5 so it won ' t log <nl> + assertLoggedSizes ( 1 , 0 , 0 ) ; <nl> + <nl> + now = 10 ; <nl> + statement . warn ( " a " ) ; <nl> + assertLoggedSizes ( 1 , 1 , 0 ) ; <nl> + <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoSpamLoggerStatementDirect ( ) throws Exception <nl> + { <nl> + NoSpamLogger . NoSpamLogStatement statement = NoSpamLogger . getStatement ( mock , " swizzle { } " , 5 , TimeUnit . NANOSECONDS ) ; <nl> + <nl> + now = 5 ; <nl> + <nl> + statement . info ( " swizzle { } " , " a " ) ; <nl> + statement . info ( " swizzle { } " , " a " ) ; <nl> + statement . warn ( " swizzle { } " , " a " ) ; <nl> + statement . error ( " swizzle { } " , " a " ) ; <nl> + <nl> + assertLoggedSizes ( 1 , 0 , 0 ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> index 724e9ae . . 34619da 100644 <nl> - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> @ @ - 44 , 6 + 44 , 8 @ @ class FileStreamTask implements Runnable <nl> <nl> public void run ( ) <nl> { <nl> + / * <nl> + TODO <nl> TcpConnection connection = null ; <nl> try <nl> { <nl> @ @ - 61 , 6 + 63 , 6 @ @ class FileStreamTask implements Runnable <nl> } <nl> throw new RuntimeException ( e ) ; <nl> } <nl> + * / <nl> } <nl> - <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 96bad3c . . 11afaae 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 68 , 7 + 68 , 7 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> / * Thread pool to handle messaging write activities * / <nl> private static ExecutorService streamExecutor _ ; <nl> <nl> - private static NonBlockingHashMap < String , TcpConnectionManager > connectionManagers _ = new NonBlockingHashMap < String , TcpConnectionManager > ( ) ; <nl> + private static NonBlockingHashMap < String , OutboundTcpConnectionPool > connectionManagers _ = new NonBlockingHashMap < String , OutboundTcpConnectionPool > ( ) ; <nl> <nl> private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; <nl> <nl> @ @ - 186 , 19 + 186 , 19 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> } <nl> } <nl> <nl> - public static TcpConnectionManager getConnectionPool ( InetAddress from , InetAddress to ) <nl> + public static OutboundTcpConnectionPool getConnectionPool ( InetAddress from , InetAddress to ) <nl> { <nl> String key = from + " : " + to ; <nl> - TcpConnectionManager cp = connectionManagers _ . get ( key ) ; <nl> + OutboundTcpConnectionPool cp = connectionManagers _ . get ( key ) ; <nl> if ( cp = = null ) <nl> { <nl> - connectionManagers _ . putIfAbsent ( key , new TcpConnectionManager ( from , to ) ) ; <nl> + connectionManagers _ . putIfAbsent ( key , new OutboundTcpConnectionPool ( from , to ) ) ; <nl> cp = connectionManagers _ . get ( key ) ; <nl> } <nl> return cp ; <nl> } <nl> <nl> - public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException <nl> + public static OutboundTcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) <nl> { <nl> return getConnectionPool ( from , to ) . getConnection ( msg ) ; <nl> } <nl> @ @ - 331 , 20 + 331 , 9 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> assert data . length > 0 ; <nl> ByteBuffer buffer = packIt ( data , false , false ) ; <nl> <nl> - TcpConnection connection = null ; <nl> - try <nl> - { <nl> - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> - connection . write ( buffer ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - if ( connection ! = null ) <nl> - { <nl> - connection . errorClose ( ) ; <nl> - } <nl> - logger _ . error ( " unexpected error writing " + message , e ) ; <nl> - } <nl> + OutboundTcpConnection connection = null ; <nl> + connection = getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> + connection . write ( buffer ) ; <nl> } <nl> <nl> public IAsyncResult sendRR ( Message message , InetAddress to ) <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> new file mode 100644 <nl> index 0000000 . . f2ace82 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> @ @ - 0 , 0 + 1 , 97 @ @ <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . DataOutputStream ; <nl> + import java . io . IOError ; <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + import java . net . Socket ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . concurrent . BlockingQueue ; <nl> + import java . util . concurrent . LinkedBlockingQueue ; <nl> + <nl> + import org . apache . log4j . Logger ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class OutboundTcpConnection <nl> + { <nl> + private static Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; <nl> + <nl> + public BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; <nl> + public DataOutputStream output ; <nl> + public Socket socket ; <nl> + <nl> + / / TODO localEp is ignored , get rid of it <nl> + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , InetAddress localEp , final InetAddress remoteEp ) <nl> + { <nl> + try <nl> + { <nl> + socket = new Socket ( remoteEp , DatabaseDescriptor . getStoragePort ( ) ) ; <nl> + socket . setTcpNoDelay ( true ) ; <nl> + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> + new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( socket ! = null ) <nl> + { <nl> + ByteBuffer bb ; <nl> + try <nl> + { <nl> + bb = queue . take ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + try <nl> + { <nl> + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; <nl> + if ( queue . peek ( ) = = null ) <nl> + { <nl> + output . flush ( ) ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger . info ( " error writing to " + remoteEp ) ; <nl> + pool . reset ( ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } , " WRITE - " + remoteEp ) . start ( ) ; <nl> + } <nl> + <nl> + public void write ( ByteBuffer buffer ) <nl> + { <nl> + try <nl> + { <nl> + queue . put ( buffer ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public void closeSocket ( ) <nl> + { <nl> + try <nl> + { <nl> + socket . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " error closing socket " , e ) ; <nl> + } <nl> + socket = null ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java <nl> new file mode 100644 <nl> index 0000000 . . 8ad66ca <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java <nl> @ @ - 0 , 0 + 1 , 72 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> + <nl> + class OutboundTcpConnectionPool <nl> + { <nl> + private InetAddress localEp _ ; <nl> + private InetAddress remoteEp _ ; <nl> + private OutboundTcpConnection cmdCon ; <nl> + private OutboundTcpConnection ackCon ; <nl> + <nl> + / / TODO localEp is ignored , get rid of it <nl> + OutboundTcpConnectionPool ( InetAddress localEp , InetAddress remoteEp ) <nl> + { <nl> + localEp _ = localEp ; <nl> + remoteEp _ = remoteEp ; <nl> + } <nl> + <nl> + private OutboundTcpConnection newCon ( ) <nl> + { <nl> + return new OutboundTcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> + } <nl> + <nl> + / * * <nl> + * returns the appropriate connection based on message type . <nl> + * / <nl> + synchronized OutboundTcpConnection getConnection ( Message msg ) <nl> + { <nl> + if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) <nl> + { <nl> + if ( ackCon = = null ) <nl> + ackCon = newCon ( ) ; <nl> + return ackCon ; <nl> + } <nl> + else <nl> + { <nl> + if ( cmdCon = = null ) <nl> + cmdCon = newCon ( ) ; <nl> + return cmdCon ; <nl> + } <nl> + } <nl> + <nl> + synchronized void reset ( ) <nl> + { <nl> + for ( OutboundTcpConnection con : new OutboundTcpConnection [ ] { cmdCon , ackCon } ) <nl> + if ( con ! = null ) <nl> + con . closeSocket ( ) ; <nl> + cmdCon = null ; <nl> + ackCon = null ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> deleted file mode 100644 <nl> index 01003d1 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnection . java <nl> + + + / dev / null <nl> @ @ - 1 , 378 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . * ; <nl> - import java . nio . ByteBuffer ; <nl> - import java . nio . channels . FileChannel ; <nl> - import java . nio . channels . SelectionKey ; <nl> - import java . nio . channels . SocketChannel ; <nl> - import java . util . * ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> - import java . util . concurrent . locks . Condition ; <nl> - import java . util . concurrent . locks . Lock ; <nl> - import java . util . concurrent . locks . ReentrantLock ; <nl> - import java . net . InetAddress ; <nl> - import java . net . InetSocketAddress ; <nl> - <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> - { <nl> - / / logging and profiling . <nl> - private static Logger logger _ = Logger . getLogger ( TcpConnection . class ) ; <nl> - private SocketChannel socketChannel _ ; <nl> - private SelectionKey key _ ; <nl> - private TcpConnectionManager pool _ ; <nl> - private boolean isIncoming _ = false ; <nl> - private Queue < ByteBuffer > pendingWrites _ = new ConcurrentLinkedQueue < ByteBuffer > ( ) ; <nl> - private InetAddress localEp _ ; <nl> - private InetAddress remoteEp _ ; <nl> - <nl> - / * <nl> - * Added for streaming support . We need the boolean <nl> - * to indicate that this connection is used for <nl> - * streaming . The Condition and the Lock are used <nl> - * to signal the stream ( ) that it can continue <nl> - * streaming when the socket becomes writable . <nl> - * / <nl> - private boolean bStream _ = false ; <nl> - private Lock lock _ ; <nl> - private Condition condition _ ; <nl> - <nl> - private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException <nl> - { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . socket ( ) . bind ( new InetSocketAddress ( from , 0 ) ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - <nl> - localEp _ = from ; <nl> - remoteEp _ = to ; <nl> - <nl> - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; <nl> - } <nl> - else <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> - } <nl> - <nl> - if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) <nl> - throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; <nl> - <nl> - if ( pool ! = null ) <nl> - pool _ = pool ; <nl> - if ( streaming ) <nl> - { <nl> - bStream _ = true ; <nl> - lock _ = new ReentrantLock ( ) ; <nl> - condition _ = lock _ . newCondition ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / used from getConnection - outgoing <nl> - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - this ( from , to , pool , false ) ; <nl> - } <nl> - <nl> - / * <nl> - * Used for streaming purposes has no pooling semantics . <nl> - * / <nl> - TcpConnection ( InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - this ( from , to , null , true ) ; <nl> - } <nl> - <nl> - public InetAddress getEndPoint ( ) <nl> - { <nl> - return remoteEp _ ; <nl> - } <nl> - <nl> - public SocketChannel getSocketChannel ( ) <nl> - { <nl> - return socketChannel _ ; <nl> - } <nl> - <nl> - public synchronized void write ( ByteBuffer buffer ) throws IOException <nl> - { <nl> - if ( ! pendingWrites _ . isEmpty ( ) | | ! socketChannel _ . isConnected ( ) ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - return ; <nl> - } <nl> - <nl> - socketChannel _ . write ( buffer ) ; <nl> - <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - <nl> - public void stream ( File file , long startPosition , long endPosition ) throws IOException , InterruptedException <nl> - { <nl> - if ( ! bStream _ ) <nl> - throw new IllegalStateException ( " Cannot stream since we are not set up to stream data . " ) ; <nl> - <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - / * transfer 64MB in each attempt * / <nl> - int limit = 64 * 1024 * 1024 ; <nl> - long total = endPosition - startPosition ; <nl> - / * keeps track of total number of bytes transferred * / <nl> - long bytesWritten = 0L ; <nl> - RandomAccessFile raf = new RandomAccessFile ( file , " r " ) ; <nl> - FileChannel fc = raf . getChannel ( ) ; <nl> - <nl> - / * <nl> - * If the connection is not yet established then wait for <nl> - * the timeout period of 2 seconds . Attempt to reconnect 3 times and then <nl> - * bail with an IOException . <nl> - * / <nl> - long waitTime = 2 ; <nl> - int retry = 0 ; <nl> - while ( ! socketChannel _ . isConnected ( ) ) <nl> - { <nl> - if ( retry = = 3 ) <nl> - throw new IOException ( " Unable to connect to " + remoteEp _ + " after " + retry + " attempts . " ) ; <nl> - condition _ . await ( waitTime , TimeUnit . SECONDS ) ; <nl> - + + retry ; <nl> - } <nl> - <nl> - while ( bytesWritten < total ) <nl> - { <nl> - if ( startPosition = = 0 ) <nl> - { <nl> - ByteBuffer buffer = MessagingService . constructStreamHeader ( false , true ) ; <nl> - socketChannel _ . write ( buffer ) ; <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - condition _ . await ( ) ; <nl> - } <nl> - } <nl> - <nl> - long bytesTransferred ; <nl> - try <nl> - { <nl> - / * returns the number of bytes transferred from file to the socket * / <nl> - bytesTransferred = fc . transferTo ( startPosition , limit , socketChannel _ ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - / / at least jdk1 . 6 . 0 on Linux seems to throw IOException <nl> - / / when the socket is full . ( Bug fixed for 1 . 7 : http : / / bugs . sun . com / view _ bug . do ? bug _ id = 5103988 ) <nl> - / / For now look for a specific string in for the message for the exception . <nl> - if ( ! e . getMessage ( ) . startsWith ( " Resource temporarily unavailable " ) ) <nl> - throw e ; <nl> - Thread . sleep ( 10 ) ; <nl> - continue ; <nl> - } <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Bytes transferred " + bytesTransferred ) ; <nl> - bytesWritten + = bytesTransferred ; <nl> - startPosition + = bytesTransferred ; <nl> - / * <nl> - * If the number of bytes transferred is less than intended <nl> - * then we need to wait till socket becomes writeable again . <nl> - * / <nl> - if ( bytesTransferred < limit & & bytesWritten ! = total ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - condition _ . await ( ) ; <nl> - } <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - private void resumeStreaming ( ) <nl> - { <nl> - / * if not in streaming mode do nothing * / <nl> - if ( ! bStream _ ) <nl> - return ; <nl> - <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - condition _ . signal ( ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - public boolean isConnected ( ) <nl> - { <nl> - return socketChannel _ . isConnected ( ) ; <nl> - } <nl> - <nl> - public boolean equals ( Object o ) <nl> - { <nl> - if ( ! ( o instanceof TcpConnection ) ) <nl> - return false ; <nl> - <nl> - TcpConnection rhs = ( TcpConnection ) o ; <nl> - return localEp _ . equals ( rhs . localEp _ ) & & remoteEp _ . equals ( rhs . remoteEp _ ) ; <nl> - } <nl> - <nl> - public int hashCode ( ) <nl> - { <nl> - return ( localEp _ + " : " + remoteEp _ ) . hashCode ( ) ; <nl> - } <nl> - <nl> - public String toString ( ) <nl> - { <nl> - return socketChannel _ . toString ( ) ; <nl> - } <nl> - <nl> - void closeSocket ( ) <nl> - { <nl> - if ( pendingWrites _ . size ( ) > 0 ) <nl> - logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; <nl> - cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - } <nl> - <nl> - void errorClose ( ) <nl> - { <nl> - logger _ . info ( " Closing errored connection " + socketChannel _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - if ( pool _ ! = null ) <nl> - pool _ . reset ( ) ; <nl> - } <nl> - <nl> - private void cancel ( SelectionKey key ) <nl> - { <nl> - if ( key ! = null ) <nl> - { <nl> - key . cancel ( ) ; <nl> - try <nl> - { <nl> - key . channel ( ) . close ( ) ; <nl> - } <nl> - catch ( IOException e ) { } <nl> - } <nl> - } <nl> - <nl> - / / called in the selector thread <nl> - public void connect ( SelectionKey key ) <nl> - { <nl> - turnOffInterestOps ( key , SelectionKey . OP _ CONNECT ) ; <nl> - try <nl> - { <nl> - if ( socketChannel _ . finishConnect ( ) ) <nl> - { <nl> - turnOnInterestOps ( key , SelectionKey . OP _ READ ) ; <nl> - <nl> - synchronized ( this ) <nl> - { <nl> - / / this will flush the pending <nl> - if ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - resumeStreaming ( ) ; <nl> - } <nl> - else <nl> - { <nl> - logger _ . error ( " Closing connection because socket channel could not finishConnect . " ) ; ; <nl> - errorClose ( ) ; <nl> - } <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - logger _ . error ( " Encountered IOException on connection : " + socketChannel _ , e ) ; <nl> - errorClose ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / called in the selector thread <nl> - public void write ( SelectionKey key ) <nl> - { <nl> - turnOffInterestOps ( key , SelectionKey . OP _ WRITE ) ; <nl> - doPendingWrites ( ) ; <nl> - / * <nl> - * This is executed only if we are in streaming mode . <nl> - * Idea is that we read a chunk of data from a source <nl> - * and wait to read the next from the source until we <nl> - * are siganlled to do so from here . <nl> - * / <nl> - resumeStreaming ( ) ; <nl> - } <nl> - <nl> - public void doPendingWrites ( ) <nl> - { <nl> - synchronized ( this ) <nl> - { <nl> - try <nl> - { <nl> - while ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - ByteBuffer buffer = pendingWrites _ . peek ( ) ; <nl> - socketChannel _ . write ( buffer ) ; <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - break ; <nl> - } <nl> - pendingWrites _ . remove ( ) ; <nl> - } <nl> - <nl> - } <nl> - catch ( IOException ex ) <nl> - { <nl> - logger _ . error ( ex ) ; <nl> - / / This is to fix the wierd Linux bug with NIO . <nl> - errorClose ( ) ; <nl> - } <nl> - finally <nl> - { <nl> - if ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> - public int compareTo ( Object o ) <nl> - { <nl> - if ( o instanceof TcpConnection ) <nl> - { <nl> - return pendingWrites _ . size ( ) - ( ( TcpConnection ) o ) . pendingWrites _ . size ( ) ; <nl> - } <nl> - <nl> - throw new IllegalArgumentException ( ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> deleted file mode 100644 <nl> index 8cdfef2 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> + + + / dev / null <nl> @ @ - 1 , 72 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . IOException ; <nl> - import java . net . InetAddress ; <nl> - <nl> - import org . apache . cassandra . concurrent . StageManager ; <nl> - <nl> - class TcpConnectionManager <nl> - { <nl> - private InetAddress localEp _ ; <nl> - private InetAddress remoteEp _ ; <nl> - private TcpConnection cmdCon ; <nl> - private TcpConnection ackCon ; <nl> - <nl> - TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) <nl> - { <nl> - localEp _ = localEp ; <nl> - remoteEp _ = remoteEp ; <nl> - } <nl> - <nl> - private TcpConnection newCon ( ) throws IOException <nl> - { <nl> - TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - return con ; <nl> - } <nl> - <nl> - / * * <nl> - * returns the appropriate connection based on message type . <nl> - * / <nl> - synchronized TcpConnection getConnection ( Message msg ) throws IOException <nl> - { <nl> - if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) <nl> - { <nl> - if ( ackCon = = null ) <nl> - ackCon = newCon ( ) ; <nl> - return ackCon ; <nl> - } <nl> - else <nl> - { <nl> - if ( cmdCon = = null ) <nl> - cmdCon = newCon ( ) ; <nl> - return cmdCon ; <nl> - } <nl> - } <nl> - <nl> - synchronized void reset ( ) <nl> - { <nl> - for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) <nl> - if ( con ! = null ) <nl> - con . closeSocket ( ) ; <nl> - cmdCon = null ; <nl> - ackCon = null ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / NoSpamLogger . java b / src / java / org / apache / cassandra / utils / NoSpamLogger . java 
 new file mode 100644 
 index 0000000 . . 9f5d5ce 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / NoSpamLogger . java 
 @ @ - 0 , 0 + 1 , 238 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicLong ; 
 + 
 + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 + import org . slf4j . Logger ; 
 + 
 + import com . google . common . annotations . VisibleForTesting ; 
 + 
 + / * * 
 + * Logging that limits each log statement to firing based on time since the statement last fired . 
 + * 
 + * Every logger has a unique timer per statement . Minimum time between logging is set for each statement 
 + * the first time it is used and a subsequent attempt to request that statement with a different minimum time will 
 + * result in the original time being used . No warning is provided if there is a mismatch . 
 + * 
 + * If the statement is cached and used to log directly then only a volatile read will be required in the common case . 
 + * If the Logger is cached then there is a single concurrent hash map lookup + the volatile read . 
 + * If neither the logger nor the statement is cached then it is two concurrent hash map lookups + the volatile read . 
 + * 
 + * / 
 + public class NoSpamLogger 
 + { 
 + / * * 
 + * Levels for programmatically specifying the severity of a log statement 
 + * / 
 + public enum Level 
 + { 
 + INFO , WARN , ERROR ; 
 + } 
 + 
 + @ VisibleForTesting 
 + static interface Clock 
 + { 
 + long nanoTime ( ) ; 
 + } 
 + 
 + @ VisibleForTesting 
 + static Clock CLOCK = new Clock ( ) 
 + { 
 + public long nanoTime ( ) 
 + { 
 + return System . nanoTime ( ) ; 
 + } 
 + } ; 
 + 
 + public class NoSpamLogStatement extends AtomicLong 
 + { 
 + private static final long serialVersionUID = 1L ; 
 + 
 + private final String statement ; 
 + private final long minIntervalNanos ; 
 + 
 + public NoSpamLogStatement ( String statement , long minIntervalNanos ) 
 + { 
 + this . statement = statement ; 
 + this . minIntervalNanos = minIntervalNanos ; 
 + } 
 + 
 + private boolean shouldLog ( long nowNanos ) 
 + { 
 + long expected = get ( ) ; 
 + return nowNanos - expected > = minIntervalNanos & & compareAndSet ( expected , nowNanos ) ; 
 + } 
 + 
 + public void log ( Level l , long nowNanos , Object . . . objects ) 
 + { 
 + if ( ! shouldLog ( nowNanos ) ) return ; 
 + 
 + switch ( l ) 
 + { 
 + case INFO : 
 + wrapped . info ( statement , objects ) ; 
 + break ; 
 + case WARN : 
 + wrapped . warn ( statement , objects ) ; 
 + break ; 
 + case ERROR : 
 + wrapped . error ( statement , objects ) ; 
 + break ; 
 + default : 
 + throw new AssertionError ( ) ; 
 + } 
 + } 
 + 
 + public void info ( long nowNanos , Object . . . objects ) 
 + { 
 + log ( Level . INFO , nowNanos , objects ) ; 
 + } 
 + 
 + public void info ( Object . . . objects ) 
 + { 
 + info ( CLOCK . nanoTime ( ) , objects ) ; 
 + } 
 + 
 + public void warn ( long nowNanos , Object . . . objects ) 
 + { 
 + log ( Level . WARN , nowNanos , objects ) ; 
 + } 
 + 
 + public void warn ( String s , Object . . . objects ) 
 + { 
 + warn ( CLOCK . nanoTime ( ) , s , objects ) ; 
 + } 
 + 
 + public void error ( long nowNanos , Object . . . objects ) 
 + { 
 + log ( Level . ERROR , nowNanos , objects ) ; 
 + } 
 + 
 + public void error ( Object . . . objects ) 
 + { 
 + error ( CLOCK . nanoTime ( ) , objects ) ; 
 + } 
 + } 
 + 
 + private static final NonBlockingHashMap < Logger , NoSpamLogger > wrappedLoggers = new NonBlockingHashMap < > ( ) ; 
 + 
 + @ VisibleForTesting 
 + static void clearWrappedLoggersForTest ( ) 
 + { 
 + wrappedLoggers . clear ( ) ; 
 + } 
 + 
 + public static NoSpamLogger getLogger ( Logger logger , long minInterval , TimeUnit unit ) 
 + { 
 + NoSpamLogger wrapped = wrappedLoggers . get ( logger ) ; 
 + if ( wrapped = = null ) 
 + { 
 + wrapped = new NoSpamLogger ( logger , minInterval , unit ) ; 
 + NoSpamLogger temp = wrappedLoggers . putIfAbsent ( logger , wrapped ) ; 
 + if ( temp ! = null ) 
 + wrapped = temp ; 
 + } 
 + return wrapped ; 
 + } 
 + 
 + public static void log ( Logger logger , Level level , long minInterval , TimeUnit unit , String message , Object . . . objects ) 
 + { 
 + log ( logger , level , minInterval , unit , CLOCK . nanoTime ( ) , message , objects ) ; 
 + } 
 + 
 + public static void log ( Logger logger , Level level , long minInterval , TimeUnit unit , long nowNanos , String message , Object . . . objects ) 
 + { 
 + NoSpamLogger wrapped = getLogger ( logger , minInterval , unit ) ; 
 + NoSpamLogStatement statement = wrapped . getStatement ( message ) ; 
 + statement . log ( level , nowNanos , objects ) ; 
 + } 
 + 
 + public static NoSpamLogStatement getStatement ( Logger logger , String message , long minInterval , TimeUnit unit ) { 
 + NoSpamLogger wrapped = getLogger ( logger , minInterval , unit ) ; 
 + return wrapped . getStatement ( message ) ; 
 + } 
 + 
 + private final Logger wrapped ; 
 + private final long minIntervalNanos ; 
 + private final NonBlockingHashMap < String , NoSpamLogStatement > lastMessage = new NonBlockingHashMap < > ( ) ; 
 + 
 + private NoSpamLogger ( Logger wrapped , long minInterval , TimeUnit timeUnit ) 
 + { 
 + this . wrapped = wrapped ; 
 + minIntervalNanos = timeUnit . toNanos ( minInterval ) ; 
 + } 
 + 
 + public void info ( long nowNanos , String s , Object . . . objects ) 
 + { 
 + log ( Level . INFO , s , nowNanos , objects ) ; 
 + } 
 + 
 + public void info ( String s , Object . . . objects ) 
 + { 
 + info ( CLOCK . nanoTime ( ) , s , objects ) ; 
 + } 
 + 
 + public void warn ( long nowNanos , String s , Object . . . objects ) 
 + { 
 + log ( Level . WARN , s , nowNanos , objects ) ; 
 + } 
 + 
 + public void warn ( String s , Object . . . objects ) 
 + { 
 + warn ( CLOCK . nanoTime ( ) , s , objects ) ; 
 + } 
 + 
 + public void error ( long nowNanos , String s , Object . . . objects ) 
 + { 
 + log ( Level . ERROR , s , nowNanos , objects ) ; 
 + } 
 + 
 + public void error ( String s , Object . . . objects ) 
 + { 
 + error ( CLOCK . nanoTime ( ) , s , objects ) ; 
 + } 
 + 
 + public void log ( Level l , String s , long nowNanos , Object . . . objects ) { 
 + getStatement ( s , minIntervalNanos ) . log ( l , nowNanos , objects ) ; 
 + } 
 + 
 + public NoSpamLogStatement getStatement ( String s ) 
 + { 
 + return getStatement ( s , minIntervalNanos ) ; 
 + } 
 + 
 + public NoSpamLogStatement getStatement ( String s , long minInterval , TimeUnit unit ) { 
 + return getStatement ( s , unit . toNanos ( minInterval ) ) ; 
 + } 
 + 
 + public NoSpamLogStatement getStatement ( String s , long minIntervalNanos ) 
 + { 
 + NoSpamLogStatement statement = lastMessage . get ( s ) ; 
 + if ( statement = = null ) 
 + { 
 + statement = new NoSpamLogStatement ( s , minIntervalNanos ) ; 
 + NoSpamLogStatement temp = lastMessage . putIfAbsent ( s , statement ) ; 
 + if ( temp ! = null ) 
 + statement = temp ; 
 + } 
 + return statement ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java b / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java 
 new file mode 100644 
 index 0000000 . . 3ad7ab8 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / utils / NoSpamLoggerTest . java 
 @ @ - 0 , 0 + 1 , 174 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import org . apache . cassandra . utils . NoSpamLogger . Level ; 
 + import org . apache . cassandra . utils . NoSpamLogger . NoSpamLogStatement ; 
 + import org . junit . Before ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . helpers . SubstituteLogger ; 
 + 
 + 
 + public class NoSpamLoggerTest 
 + { 
 + Map < Level , List < Pair < String , Object [ ] > > > logged = new HashMap < > ( ) ; 
 + 
 + Logger mock = new SubstituteLogger ( null ) 
 + { 
 + 
 + @ Override 
 + public void info ( String statement , Object . . . args ) 
 + { 
 + logged . get ( Level . INFO ) . add ( Pair . create ( statement , args ) ) ; 
 + } 
 + 
 + @ Override 
 + public void warn ( String statement , Object . . . args ) 
 + { 
 + logged . get ( Level . WARN ) . add ( Pair . create ( statement , args ) ) ; 
 + } 
 + 
 + @ Override 
 + public void error ( String statement , Object . . . args ) 
 + { 
 + logged . get ( Level . ERROR ) . add ( Pair . create ( statement , args ) ) ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) 
 + { 
 + return 42 ; / / It ' s a valid hash code 
 + } 
 + 
 + @ Override 
 + public boolean equals ( Object o ) 
 + { 
 + return this = = o ; 
 + } 
 + } ; 
 + 
 + 
 + static long now ; 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) throws Exception 
 + { 
 + NoSpamLogger . CLOCK = new NoSpamLogger . Clock ( ) 
 + { 
 + @ Override 
 + public long nanoTime ( ) 
 + { 
 + return now ; 
 + } 
 + } ; 
 + } 
 + 
 + @ Before 
 + public void setUp ( ) throws Exception 
 + { 
 + logged . put ( Level . INFO , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; 
 + logged . put ( Level . WARN , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; 
 + logged . put ( Level . ERROR , new ArrayList < Pair < String , Object [ ] > > ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testNoSpamLogger ( ) throws Exception 
 + { 
 + testLevel ( Level . INFO ) ; 
 + testLevel ( Level . WARN ) ; 
 + testLevel ( Level . ERROR ) ; 
 + } 
 + 
 + private void testLevel ( Level l ) throws Exception 
 + { 
 + setUp ( ) ; 
 + now = 5 ; 
 + NoSpamLogger . clearWrappedLoggersForTest ( ) ; 
 + 
 + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; 
 + 
 + assertEquals ( 1 , logged . get ( l ) . size ( ) ) ; 
 + 
 + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; 
 + 
 + assertEquals ( 1 , logged . get ( l ) . size ( ) ) ; 
 + 
 + now + = 5 ; 
 + 
 + NoSpamLogger . log ( mock , l , 5 , TimeUnit . NANOSECONDS , " swizzle { } " , " a " ) ; 
 + 
 + assertEquals ( 2 , logged . get ( l ) . size ( ) ) ; 
 + } 
 + 
 + private void assertLoggedSizes ( int info , int warn , int error ) 
 + { 
 + assertEquals ( info , logged . get ( Level . INFO ) . size ( ) ) ; 
 + assertEquals ( warn , logged . get ( Level . WARN ) . size ( ) ) ; 
 + assertEquals ( error , logged . get ( Level . ERROR ) . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testNoSpamLoggerDirect ( ) throws Exception 
 + { 
 + now = 5 ; 
 + NoSpamLogger logger = NoSpamLogger . getLogger ( mock , 5 , TimeUnit . NANOSECONDS ) ; 
 + 
 + logger . info ( " swizzle { } " , " a " ) ; 
 + logger . info ( " swizzle { } " , " a " ) ; 
 + logger . warn ( " swizzle { } " , " a " ) ; 
 + logger . error ( " swizzle { } " , " a " ) ; 
 + 
 + assertLoggedSizes ( 1 , 0 , 0 ) ; 
 + 
 + NoSpamLogStatement statement = logger . getStatement ( " swizzle2 { } " , 10 , TimeUnit . NANOSECONDS ) ; 
 + statement . warn ( " a " ) ; 
 + / / now is 5 so it won ' t log 
 + assertLoggedSizes ( 1 , 0 , 0 ) ; 
 + 
 + now = 10 ; 
 + statement . warn ( " a " ) ; 
 + assertLoggedSizes ( 1 , 1 , 0 ) ; 
 + 
 + } 
 + 
 + @ Test 
 + public void testNoSpamLoggerStatementDirect ( ) throws Exception 
 + { 
 + NoSpamLogger . NoSpamLogStatement statement = NoSpamLogger . getStatement ( mock , " swizzle { } " , 5 , TimeUnit . NANOSECONDS ) ; 
 + 
 + now = 5 ; 
 + 
 + statement . info ( " swizzle { } " , " a " ) ; 
 + statement . info ( " swizzle { } " , " a " ) ; 
 + statement . warn ( " swizzle { } " , " a " ) ; 
 + statement . error ( " swizzle { } " , " a " ) ; 
 + 
 + assertLoggedSizes ( 1 , 0 , 0 ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 index 724e9ae . . 34619da 100644 
 - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java 
 + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 @ @ - 44 , 6 + 44 , 8 @ @ class FileStreamTask implements Runnable 
 
 public void run ( ) 
 { 
 + / * 
 + TODO 
 TcpConnection connection = null ; 
 try 
 { 
 @ @ - 61 , 6 + 63 , 6 @ @ class FileStreamTask implements Runnable 
 } 
 throw new RuntimeException ( e ) ; 
 } 
 + * / 
 } 
 - 
 } 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 96bad3c . . 11afaae 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 68 , 7 + 68 , 7 @ @ public class MessagingService implements IFailureDetectionEventListener 
 / * Thread pool to handle messaging write activities * / 
 private static ExecutorService streamExecutor _ ; 
 
 - private static NonBlockingHashMap < String , TcpConnectionManager > connectionManagers _ = new NonBlockingHashMap < String , TcpConnectionManager > ( ) ; 
 + private static NonBlockingHashMap < String , OutboundTcpConnectionPool > connectionManagers _ = new NonBlockingHashMap < String , OutboundTcpConnectionPool > ( ) ; 
 
 private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; 
 
 @ @ - 186 , 19 + 186 , 19 @ @ public class MessagingService implements IFailureDetectionEventListener 
 } 
 } 
 
 - public static TcpConnectionManager getConnectionPool ( InetAddress from , InetAddress to ) 
 + public static OutboundTcpConnectionPool getConnectionPool ( InetAddress from , InetAddress to ) 
 { 
 String key = from + " : " + to ; 
 - TcpConnectionManager cp = connectionManagers _ . get ( key ) ; 
 + OutboundTcpConnectionPool cp = connectionManagers _ . get ( key ) ; 
 if ( cp = = null ) 
 { 
 - connectionManagers _ . putIfAbsent ( key , new TcpConnectionManager ( from , to ) ) ; 
 + connectionManagers _ . putIfAbsent ( key , new OutboundTcpConnectionPool ( from , to ) ) ; 
 cp = connectionManagers _ . get ( key ) ; 
 } 
 return cp ; 
 } 
 
 - public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException 
 + public static OutboundTcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) 
 { 
 return getConnectionPool ( from , to ) . getConnection ( msg ) ; 
 } 
 @ @ - 331 , 20 + 331 , 9 @ @ public class MessagingService implements IFailureDetectionEventListener 
 assert data . length > 0 ; 
 ByteBuffer buffer = packIt ( data , false , false ) ; 
 
 - TcpConnection connection = null ; 
 - try 
 - { 
 - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 - connection . write ( buffer ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - if ( connection ! = null ) 
 - { 
 - connection . errorClose ( ) ; 
 - } 
 - logger _ . error ( " unexpected error writing " + message , e ) ; 
 - } 
 + OutboundTcpConnection connection = null ; 
 + connection = getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 + connection . write ( buffer ) ; 
 } 
 
 public IAsyncResult sendRR ( Message message , InetAddress to ) 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 new file mode 100644 
 index 0000000 . . f2ace82 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 @ @ - 0 , 0 + 1 , 97 @ @ 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . DataOutputStream ; 
 + import java . io . IOError ; 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + import java . net . Socket ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . concurrent . BlockingQueue ; 
 + import java . util . concurrent . LinkedBlockingQueue ; 
 + 
 + import org . apache . log4j . Logger ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class OutboundTcpConnection 
 + { 
 + private static Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; 
 + 
 + public BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; 
 + public DataOutputStream output ; 
 + public Socket socket ; 
 + 
 + / / TODO localEp is ignored , get rid of it 
 + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , InetAddress localEp , final InetAddress remoteEp ) 
 + { 
 + try 
 + { 
 + socket = new Socket ( remoteEp , DatabaseDescriptor . getStoragePort ( ) ) ; 
 + socket . setTcpNoDelay ( true ) ; 
 + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 + new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( socket ! = null ) 
 + { 
 + ByteBuffer bb ; 
 + try 
 + { 
 + bb = queue . take ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + try 
 + { 
 + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; 
 + if ( queue . peek ( ) = = null ) 
 + { 
 + output . flush ( ) ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger . info ( " error writing to " + remoteEp ) ; 
 + pool . reset ( ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } , " WRITE - " + remoteEp ) . start ( ) ; 
 + } 
 + 
 + public void write ( ByteBuffer buffer ) 
 + { 
 + try 
 + { 
 + queue . put ( buffer ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + } 
 + 
 + public void closeSocket ( ) 
 + { 
 + try 
 + { 
 + socket . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " error closing socket " , e ) ; 
 + } 
 + socket = null ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java 
 new file mode 100644 
 index 0000000 . . 8ad66ca 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java 
 @ @ - 0 , 0 + 1 , 72 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + 
 + import org . apache . cassandra . concurrent . StageManager ; 
 + 
 + class OutboundTcpConnectionPool 
 + { 
 + private InetAddress localEp _ ; 
 + private InetAddress remoteEp _ ; 
 + private OutboundTcpConnection cmdCon ; 
 + private OutboundTcpConnection ackCon ; 
 + 
 + / / TODO localEp is ignored , get rid of it 
 + OutboundTcpConnectionPool ( InetAddress localEp , InetAddress remoteEp ) 
 + { 
 + localEp _ = localEp ; 
 + remoteEp _ = remoteEp ; 
 + } 
 + 
 + private OutboundTcpConnection newCon ( ) 
 + { 
 + return new OutboundTcpConnection ( this , localEp _ , remoteEp _ ) ; 
 + } 
 + 
 + / * * 
 + * returns the appropriate connection based on message type . 
 + * / 
 + synchronized OutboundTcpConnection getConnection ( Message msg ) 
 + { 
 + if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) 
 + { 
 + if ( ackCon = = null ) 
 + ackCon = newCon ( ) ; 
 + return ackCon ; 
 + } 
 + else 
 + { 
 + if ( cmdCon = = null ) 
 + cmdCon = newCon ( ) ; 
 + return cmdCon ; 
 + } 
 + } 
 + 
 + synchronized void reset ( ) 
 + { 
 + for ( OutboundTcpConnection con : new OutboundTcpConnection [ ] { cmdCon , ackCon } ) 
 + if ( con ! = null ) 
 + con . closeSocket ( ) ; 
 + cmdCon = null ; 
 + ackCon = null ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java 
 deleted file mode 100644 
 index 01003d1 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / TcpConnection . java 
 + + + / dev / null 
 @ @ - 1 , 378 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . * ; 
 - import java . nio . ByteBuffer ; 
 - import java . nio . channels . FileChannel ; 
 - import java . nio . channels . SelectionKey ; 
 - import java . nio . channels . SocketChannel ; 
 - import java . util . * ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 - import java . util . concurrent . locks . Condition ; 
 - import java . util . concurrent . locks . Lock ; 
 - import java . util . concurrent . locks . ReentrantLock ; 
 - import java . net . InetAddress ; 
 - import java . net . InetSocketAddress ; 
 - 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - 
 - import org . apache . log4j . Logger ; 
 - 
 - public class TcpConnection extends SelectionKeyHandler implements Comparable 
 - { 
 - / / logging and profiling . 
 - private static Logger logger _ = Logger . getLogger ( TcpConnection . class ) ; 
 - private SocketChannel socketChannel _ ; 
 - private SelectionKey key _ ; 
 - private TcpConnectionManager pool _ ; 
 - private boolean isIncoming _ = false ; 
 - private Queue < ByteBuffer > pendingWrites _ = new ConcurrentLinkedQueue < ByteBuffer > ( ) ; 
 - private InetAddress localEp _ ; 
 - private InetAddress remoteEp _ ; 
 - 
 - / * 
 - * Added for streaming support . We need the boolean 
 - * to indicate that this connection is used for 
 - * streaming . The Condition and the Lock are used 
 - * to signal the stream ( ) that it can continue 
 - * streaming when the socket becomes writable . 
 - * / 
 - private boolean bStream _ = false ; 
 - private Lock lock _ ; 
 - private Condition condition _ ; 
 - 
 - private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException 
 - { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . socket ( ) . bind ( new InetSocketAddress ( from , 0 ) ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - 
 - localEp _ = from ; 
 - remoteEp _ = to ; 
 - 
 - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; 
 - } 
 - else 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 - } 
 - 
 - if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) 
 - throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; 
 - 
 - if ( pool ! = null ) 
 - pool _ = pool ; 
 - if ( streaming ) 
 - { 
 - bStream _ = true ; 
 - lock _ = new ReentrantLock ( ) ; 
 - condition _ = lock _ . newCondition ( ) ; 
 - } 
 - } 
 - 
 - / / used from getConnection - outgoing 
 - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 - { 
 - this ( from , to , pool , false ) ; 
 - } 
 - 
 - / * 
 - * Used for streaming purposes has no pooling semantics . 
 - * / 
 - TcpConnection ( InetAddress from , InetAddress to ) throws IOException 
 - { 
 - this ( from , to , null , true ) ; 
 - } 
 - 
 - public InetAddress getEndPoint ( ) 
 - { 
 - return remoteEp _ ; 
 - } 
 - 
 - public SocketChannel getSocketChannel ( ) 
 - { 
 - return socketChannel _ ; 
 - } 
 - 
 - public synchronized void write ( ByteBuffer buffer ) throws IOException 
 - { 
 - if ( ! pendingWrites _ . isEmpty ( ) | | ! socketChannel _ . isConnected ( ) ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - return ; 
 - } 
 - 
 - socketChannel _ . write ( buffer ) ; 
 - 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - 
 - public void stream ( File file , long startPosition , long endPosition ) throws IOException , InterruptedException 
 - { 
 - if ( ! bStream _ ) 
 - throw new IllegalStateException ( " Cannot stream since we are not set up to stream data . " ) ; 
 - 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - / * transfer 64MB in each attempt * / 
 - int limit = 64 * 1024 * 1024 ; 
 - long total = endPosition - startPosition ; 
 - / * keeps track of total number of bytes transferred * / 
 - long bytesWritten = 0L ; 
 - RandomAccessFile raf = new RandomAccessFile ( file , " r " ) ; 
 - FileChannel fc = raf . getChannel ( ) ; 
 - 
 - / * 
 - * If the connection is not yet established then wait for 
 - * the timeout period of 2 seconds . Attempt to reconnect 3 times and then 
 - * bail with an IOException . 
 - * / 
 - long waitTime = 2 ; 
 - int retry = 0 ; 
 - while ( ! socketChannel _ . isConnected ( ) ) 
 - { 
 - if ( retry = = 3 ) 
 - throw new IOException ( " Unable to connect to " + remoteEp _ + " after " + retry + " attempts . " ) ; 
 - condition _ . await ( waitTime , TimeUnit . SECONDS ) ; 
 - + + retry ; 
 - } 
 - 
 - while ( bytesWritten < total ) 
 - { 
 - if ( startPosition = = 0 ) 
 - { 
 - ByteBuffer buffer = MessagingService . constructStreamHeader ( false , true ) ; 
 - socketChannel _ . write ( buffer ) ; 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - condition _ . await ( ) ; 
 - } 
 - } 
 - 
 - long bytesTransferred ; 
 - try 
 - { 
 - / * returns the number of bytes transferred from file to the socket * / 
 - bytesTransferred = fc . transferTo ( startPosition , limit , socketChannel _ ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - / / at least jdk1 . 6 . 0 on Linux seems to throw IOException 
 - / / when the socket is full . ( Bug fixed for 1 . 7 : http : / / bugs . sun . com / view _ bug . do ? bug _ id = 5103988 ) 
 - / / For now look for a specific string in for the message for the exception . 
 - if ( ! e . getMessage ( ) . startsWith ( " Resource temporarily unavailable " ) ) 
 - throw e ; 
 - Thread . sleep ( 10 ) ; 
 - continue ; 
 - } 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Bytes transferred " + bytesTransferred ) ; 
 - bytesWritten + = bytesTransferred ; 
 - startPosition + = bytesTransferred ; 
 - / * 
 - * If the number of bytes transferred is less than intended 
 - * then we need to wait till socket becomes writeable again . 
 - * / 
 - if ( bytesTransferred < limit & & bytesWritten ! = total ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - condition _ . await ( ) ; 
 - } 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - private void resumeStreaming ( ) 
 - { 
 - / * if not in streaming mode do nothing * / 
 - if ( ! bStream _ ) 
 - return ; 
 - 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - condition _ . signal ( ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - public boolean isConnected ( ) 
 - { 
 - return socketChannel _ . isConnected ( ) ; 
 - } 
 - 
 - public boolean equals ( Object o ) 
 - { 
 - if ( ! ( o instanceof TcpConnection ) ) 
 - return false ; 
 - 
 - TcpConnection rhs = ( TcpConnection ) o ; 
 - return localEp _ . equals ( rhs . localEp _ ) & & remoteEp _ . equals ( rhs . remoteEp _ ) ; 
 - } 
 - 
 - public int hashCode ( ) 
 - { 
 - return ( localEp _ + " : " + remoteEp _ ) . hashCode ( ) ; 
 - } 
 - 
 - public String toString ( ) 
 - { 
 - return socketChannel _ . toString ( ) ; 
 - } 
 - 
 - void closeSocket ( ) 
 - { 
 - if ( pendingWrites _ . size ( ) > 0 ) 
 - logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; 
 - cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - } 
 - 
 - void errorClose ( ) 
 - { 
 - logger _ . info ( " Closing errored connection " + socketChannel _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - if ( pool _ ! = null ) 
 - pool _ . reset ( ) ; 
 - } 
 - 
 - private void cancel ( SelectionKey key ) 
 - { 
 - if ( key ! = null ) 
 - { 
 - key . cancel ( ) ; 
 - try 
 - { 
 - key . channel ( ) . close ( ) ; 
 - } 
 - catch ( IOException e ) { } 
 - } 
 - } 
 - 
 - / / called in the selector thread 
 - public void connect ( SelectionKey key ) 
 - { 
 - turnOffInterestOps ( key , SelectionKey . OP _ CONNECT ) ; 
 - try 
 - { 
 - if ( socketChannel _ . finishConnect ( ) ) 
 - { 
 - turnOnInterestOps ( key , SelectionKey . OP _ READ ) ; 
 - 
 - synchronized ( this ) 
 - { 
 - / / this will flush the pending 
 - if ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - resumeStreaming ( ) ; 
 - } 
 - else 
 - { 
 - logger _ . error ( " Closing connection because socket channel could not finishConnect . " ) ; ; 
 - errorClose ( ) ; 
 - } 
 - } 
 - catch ( IOException e ) 
 - { 
 - logger _ . error ( " Encountered IOException on connection : " + socketChannel _ , e ) ; 
 - errorClose ( ) ; 
 - } 
 - } 
 - 
 - / / called in the selector thread 
 - public void write ( SelectionKey key ) 
 - { 
 - turnOffInterestOps ( key , SelectionKey . OP _ WRITE ) ; 
 - doPendingWrites ( ) ; 
 - / * 
 - * This is executed only if we are in streaming mode . 
 - * Idea is that we read a chunk of data from a source 
 - * and wait to read the next from the source until we 
 - * are siganlled to do so from here . 
 - * / 
 - resumeStreaming ( ) ; 
 - } 
 - 
 - public void doPendingWrites ( ) 
 - { 
 - synchronized ( this ) 
 - { 
 - try 
 - { 
 - while ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - ByteBuffer buffer = pendingWrites _ . peek ( ) ; 
 - socketChannel _ . write ( buffer ) ; 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - break ; 
 - } 
 - pendingWrites _ . remove ( ) ; 
 - } 
 - 
 - } 
 - catch ( IOException ex ) 
 - { 
 - logger _ . error ( ex ) ; 
 - / / This is to fix the wierd Linux bug with NIO . 
 - errorClose ( ) ; 
 - } 
 - finally 
 - { 
 - if ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - } 
 - } 
 - 
 - public int compareTo ( Object o ) 
 - { 
 - if ( o instanceof TcpConnection ) 
 - { 
 - return pendingWrites _ . size ( ) - ( ( TcpConnection ) o ) . pendingWrites _ . size ( ) ; 
 - } 
 - 
 - throw new IllegalArgumentException ( ) ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 deleted file mode 100644 
 index 8cdfef2 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 + + + / dev / null 
 @ @ - 1 , 72 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . IOException ; 
 - import java . net . InetAddress ; 
 - 
 - import org . apache . cassandra . concurrent . StageManager ; 
 - 
 - class TcpConnectionManager 
 - { 
 - private InetAddress localEp _ ; 
 - private InetAddress remoteEp _ ; 
 - private TcpConnection cmdCon ; 
 - private TcpConnection ackCon ; 
 - 
 - TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) 
 - { 
 - localEp _ = localEp ; 
 - remoteEp _ = remoteEp ; 
 - } 
 - 
 - private TcpConnection newCon ( ) throws IOException 
 - { 
 - TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - return con ; 
 - } 
 - 
 - / * * 
 - * returns the appropriate connection based on message type . 
 - * / 
 - synchronized TcpConnection getConnection ( Message msg ) throws IOException 
 - { 
 - if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) 
 - { 
 - if ( ackCon = = null ) 
 - ackCon = newCon ( ) ; 
 - return ackCon ; 
 - } 
 - else 
 - { 
 - if ( cmdCon = = null ) 
 - cmdCon = newCon ( ) ; 
 - return cmdCon ; 
 - } 
 - } 
 - 
 - synchronized void reset ( ) 
 - { 
 - for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) 
 - if ( con ! = null ) 
 - con . closeSocket ( ) ; 
 - cmdCon = null ; 
 - ackCon = null ; 
 - } 
 - }
