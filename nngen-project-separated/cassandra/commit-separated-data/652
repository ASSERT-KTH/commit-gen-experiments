BLEU SCORE: 0.010738456044579523

TEST MSG: Handle composite prefixes with final EOC = 0 as in 2 . x and refactor LegacyLayout . decodeBound
GENERATED MSG: Fix legacy non - compound range tombstone serialization

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 459d591 . . f0ec3e3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Handle composite prefixes with final EOC = 0 as in 2 . x and refactor LegacyLayout . decodeBound ( CASSANDRA - 12423 ) <nl> * Fix paging for 2 . x to 3 . x upgrades ( CASSANDRA - 11195 ) <nl> * select _ distinct _ with _ deletions _ test failing on non - vnode environments ( CASSANDRA - 11126 ) <nl> * Stack Overflow returned to queries while upgrading ( CASSANDRA - 12527 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index 65f9d3f . . c8e7536 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 186 , 41 + 186 , 49 @ @ public abstract class LegacyLayout <nl> if ( ! bound . hasRemaining ( ) ) <nl> return isStart ? LegacyBound . BOTTOM : LegacyBound . TOP ; <nl> <nl> - List < CompositeType . CompositeComponent > components = metadata . isCompound ( ) <nl> - ? CompositeType . deconstruct ( bound ) <nl> - : Collections . singletonList ( new CompositeType . CompositeComponent ( bound , ( byte ) 0 ) ) ; <nl> - <nl> - / / Either it ' s a prefix of the clustering , or it ' s the bound of a collection range tombstone ( and thus has <nl> - / / the collection column name ) <nl> - assert components . size ( ) < = metadata . comparator . size ( ) | | ( ! metadata . isCompactTable ( ) & & components . size ( ) = = metadata . comparator . size ( ) + 1 ) ; <nl> - <nl> - List < CompositeType . CompositeComponent > prefix = components . size ( ) < = metadata . comparator . size ( ) <nl> - ? components <nl> - : components . subList ( 0 , metadata . comparator . size ( ) ) ; <nl> - Slice . Bound . Kind boundKind ; <nl> + if ( ! metadata . isCompound ( ) ) <nl> + { <nl> + / / The non compound case is a lot easier , in that there is no EOC nor collection to worry about , so dealing <nl> + / / with that first . <nl> + return new LegacyBound ( isStart ? Slice . Bound . inclusiveStartOf ( bound ) : Slice . Bound . inclusiveEndOf ( bound ) , false , null ) ; <nl> + } <nl> + <nl> + int clusteringSize = metadata . comparator . size ( ) ; <nl> + <nl> + List < ByteBuffer > components = CompositeType . splitName ( bound ) ; <nl> + byte eoc = CompositeType . lastEOC ( bound ) ; <nl> + <nl> + / / There can be more components than the clustering size only in the case this is the bound of a collection <nl> + / / range tombstone . In which case , there is exactly one more component , and that component is the name of the <nl> + / / collection being selected / deleted . <nl> + assert components . size ( ) < = clusteringSize | | ( ! metadata . isCompactTable ( ) & & components . size ( ) = = clusteringSize + 1 ) ; <nl> + <nl> + ColumnDefinition collectionName = null ; <nl> + if ( components . size ( ) > clusteringSize ) <nl> + collectionName = metadata . getColumnDefinition ( components . remove ( clusteringSize ) ) ; <nl> + <nl> + boolean isInclusive ; <nl> if ( isStart ) <nl> { <nl> - if ( components . get ( components . size ( ) - 1 ) . eoc > 0 ) <nl> - boundKind = Slice . Bound . Kind . EXCL _ START _ BOUND ; <nl> - else <nl> - boundKind = Slice . Bound . Kind . INCL _ START _ BOUND ; <nl> + isInclusive = eoc < = 0 ; <nl> } <nl> else <nl> { <nl> - if ( components . get ( components . size ( ) - 1 ) . eoc < 0 ) <nl> - boundKind = Slice . Bound . Kind . EXCL _ END _ BOUND ; <nl> - else <nl> - boundKind = Slice . Bound . Kind . INCL _ END _ BOUND ; <nl> - } <nl> + isInclusive = eoc > = 0 ; <nl> <nl> - ByteBuffer [ ] prefixValues = new ByteBuffer [ prefix . size ( ) ] ; <nl> - for ( int i = 0 ; i < prefix . size ( ) ; i + + ) <nl> - prefixValues [ i ] = prefix . get ( i ) . value ; <nl> - Slice . Bound sb = Slice . Bound . create ( boundKind , prefixValues ) ; <nl> + / / for an end bound , if we only have a prefix of all the components and the final EOC is zero , <nl> + / / then it should only match up to the prefix but no further , that is , it is an inclusive bound <nl> + / / of the exact prefix but an exclusive bound of anything beyond it , so adding an empty <nl> + / / composite value ensures this behavior , see CASSANDRA - 12423 for more details <nl> + if ( eoc = = 0 & & components . size ( ) < clusteringSize ) <nl> + { <nl> + components . add ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) ; <nl> + isInclusive = false ; <nl> + } <nl> + } <nl> <nl> - ColumnDefinition collectionName = components . size ( ) = = metadata . comparator . size ( ) + 1 <nl> - ? metadata . getColumnDefinition ( components . get ( metadata . comparator . size ( ) ) . value ) <nl> - : null ; <nl> + Slice . Bound . Kind boundKind = Slice . Bound . boundKind ( isStart , isInclusive ) ; <nl> + Slice . Bound sb = Slice . Bound . create ( boundKind , components . toArray ( new ByteBuffer [ components . size ( ) ] ) ) ; <nl> return new LegacyBound ( sb , metadata . isCompound ( ) & & CompositeType . isStaticName ( bound ) , collectionName ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / CompositeType . java b / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> index d005fd7 . . 52d6d39 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> @ @ - 227 , 32 + 227 , 6 @ @ public class CompositeType extends AbstractCompositeType <nl> return null ; <nl> } <nl> <nl> - public static class CompositeComponent <nl> - { <nl> - public ByteBuffer value ; <nl> - public byte eoc ; <nl> - <nl> - public CompositeComponent ( ByteBuffer value , byte eoc ) <nl> - { <nl> - this . value = value ; <nl> - this . eoc = eoc ; <nl> - } <nl> - } <nl> - <nl> - public static List < CompositeComponent > deconstruct ( ByteBuffer bytes ) <nl> - { <nl> - List < CompositeComponent > list = new ArrayList < > ( ) ; <nl> - ByteBuffer bb = bytes . duplicate ( ) ; <nl> - readStatic ( bb ) ; <nl> - while ( bb . remaining ( ) > 0 ) <nl> - { <nl> - ByteBuffer value = ByteBufferUtil . readBytesWithShortLength ( bb ) ; <nl> - byte eoc = bb . get ( ) ; <nl> - list . add ( new CompositeComponent ( value , eoc ) ) ; <nl> - } <nl> - return list ; <nl> - } <nl> - <nl> / / Extract CQL3 column name from the full column name . <nl> public ByteBuffer extractLastComponent ( ByteBuffer bb ) <nl> {
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 459d591 . . f0ec3e3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Handle composite prefixes with final EOC = 0 as in 2 . x and refactor LegacyLayout . decodeBound ( CASSANDRA - 12423 ) 
 * Fix paging for 2 . x to 3 . x upgrades ( CASSANDRA - 11195 ) 
 * select _ distinct _ with _ deletions _ test failing on non - vnode environments ( CASSANDRA - 11126 ) 
 * Stack Overflow returned to queries while upgrading ( CASSANDRA - 12527 ) 
 diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index 65f9d3f . . c8e7536 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 186 , 41 + 186 , 49 @ @ public abstract class LegacyLayout 
 if ( ! bound . hasRemaining ( ) ) 
 return isStart ? LegacyBound . BOTTOM : LegacyBound . TOP ; 
 
 - List < CompositeType . CompositeComponent > components = metadata . isCompound ( ) 
 - ? CompositeType . deconstruct ( bound ) 
 - : Collections . singletonList ( new CompositeType . CompositeComponent ( bound , ( byte ) 0 ) ) ; 
 - 
 - / / Either it ' s a prefix of the clustering , or it ' s the bound of a collection range tombstone ( and thus has 
 - / / the collection column name ) 
 - assert components . size ( ) < = metadata . comparator . size ( ) | | ( ! metadata . isCompactTable ( ) & & components . size ( ) = = metadata . comparator . size ( ) + 1 ) ; 
 - 
 - List < CompositeType . CompositeComponent > prefix = components . size ( ) < = metadata . comparator . size ( ) 
 - ? components 
 - : components . subList ( 0 , metadata . comparator . size ( ) ) ; 
 - Slice . Bound . Kind boundKind ; 
 + if ( ! metadata . isCompound ( ) ) 
 + { 
 + / / The non compound case is a lot easier , in that there is no EOC nor collection to worry about , so dealing 
 + / / with that first . 
 + return new LegacyBound ( isStart ? Slice . Bound . inclusiveStartOf ( bound ) : Slice . Bound . inclusiveEndOf ( bound ) , false , null ) ; 
 + } 
 + 
 + int clusteringSize = metadata . comparator . size ( ) ; 
 + 
 + List < ByteBuffer > components = CompositeType . splitName ( bound ) ; 
 + byte eoc = CompositeType . lastEOC ( bound ) ; 
 + 
 + / / There can be more components than the clustering size only in the case this is the bound of a collection 
 + / / range tombstone . In which case , there is exactly one more component , and that component is the name of the 
 + / / collection being selected / deleted . 
 + assert components . size ( ) < = clusteringSize | | ( ! metadata . isCompactTable ( ) & & components . size ( ) = = clusteringSize + 1 ) ; 
 + 
 + ColumnDefinition collectionName = null ; 
 + if ( components . size ( ) > clusteringSize ) 
 + collectionName = metadata . getColumnDefinition ( components . remove ( clusteringSize ) ) ; 
 + 
 + boolean isInclusive ; 
 if ( isStart ) 
 { 
 - if ( components . get ( components . size ( ) - 1 ) . eoc > 0 ) 
 - boundKind = Slice . Bound . Kind . EXCL _ START _ BOUND ; 
 - else 
 - boundKind = Slice . Bound . Kind . INCL _ START _ BOUND ; 
 + isInclusive = eoc < = 0 ; 
 } 
 else 
 { 
 - if ( components . get ( components . size ( ) - 1 ) . eoc < 0 ) 
 - boundKind = Slice . Bound . Kind . EXCL _ END _ BOUND ; 
 - else 
 - boundKind = Slice . Bound . Kind . INCL _ END _ BOUND ; 
 - } 
 + isInclusive = eoc > = 0 ; 
 
 - ByteBuffer [ ] prefixValues = new ByteBuffer [ prefix . size ( ) ] ; 
 - for ( int i = 0 ; i < prefix . size ( ) ; i + + ) 
 - prefixValues [ i ] = prefix . get ( i ) . value ; 
 - Slice . Bound sb = Slice . Bound . create ( boundKind , prefixValues ) ; 
 + / / for an end bound , if we only have a prefix of all the components and the final EOC is zero , 
 + / / then it should only match up to the prefix but no further , that is , it is an inclusive bound 
 + / / of the exact prefix but an exclusive bound of anything beyond it , so adding an empty 
 + / / composite value ensures this behavior , see CASSANDRA - 12423 for more details 
 + if ( eoc = = 0 & & components . size ( ) < clusteringSize ) 
 + { 
 + components . add ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) ; 
 + isInclusive = false ; 
 + } 
 + } 
 
 - ColumnDefinition collectionName = components . size ( ) = = metadata . comparator . size ( ) + 1 
 - ? metadata . getColumnDefinition ( components . get ( metadata . comparator . size ( ) ) . value ) 
 - : null ; 
 + Slice . Bound . Kind boundKind = Slice . Bound . boundKind ( isStart , isInclusive ) ; 
 + Slice . Bound sb = Slice . Bound . create ( boundKind , components . toArray ( new ByteBuffer [ components . size ( ) ] ) ) ; 
 return new LegacyBound ( sb , metadata . isCompound ( ) & & CompositeType . isStaticName ( bound ) , collectionName ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / CompositeType . java b / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 index d005fd7 . . 52d6d39 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 @ @ - 227 , 32 + 227 , 6 @ @ public class CompositeType extends AbstractCompositeType 
 return null ; 
 } 
 
 - public static class CompositeComponent 
 - { 
 - public ByteBuffer value ; 
 - public byte eoc ; 
 - 
 - public CompositeComponent ( ByteBuffer value , byte eoc ) 
 - { 
 - this . value = value ; 
 - this . eoc = eoc ; 
 - } 
 - } 
 - 
 - public static List < CompositeComponent > deconstruct ( ByteBuffer bytes ) 
 - { 
 - List < CompositeComponent > list = new ArrayList < > ( ) ; 
 - ByteBuffer bb = bytes . duplicate ( ) ; 
 - readStatic ( bb ) ; 
 - while ( bb . remaining ( ) > 0 ) 
 - { 
 - ByteBuffer value = ByteBufferUtil . readBytesWithShortLength ( bb ) ; 
 - byte eoc = bb . get ( ) ; 
 - list . add ( new CompositeComponent ( value , eoc ) ) ; 
 - } 
 - return list ; 
 - } 
 - 
 / / Extract CQL3 column name from the full column name . 
 public ByteBuffer extractLastComponent ( ByteBuffer bb ) 
 {

NEAREST DIFF:
ELIMINATEDSENTENCE
