BLEU SCORE: 0.013967653161805973

TEST MSG: Add optional startup delay to wait until peers are ready
GENERATED MSG: Dynamic snitch to adaptively avoid reading from slow nodes . Patch by brandonwilliams ; reviewed by jbellis for CASSANDRA - 981

TEST DIFF (one line): diff - - git a / . circleci / config . yml b / . circleci / config . yml <nl> index f881b70 . . 13bc11d 100644 <nl> - - - a / . circleci / config . yml <nl> + + + b / . circleci / config . yml <nl> @ @ - 58 , 16 + 58 , 16 @ @ with _ dtest _ jobs _ only : & with _ dtest _ jobs _ only <nl> - build <nl> # Set env _ settings , env _ vars , and workflows / build _ and _ run _ tests based on environment <nl> env _ settings : & env _ settings <nl> - < < : * default _ env _ settings <nl> - # < < : * high _ capacity _ env _ settings <nl> + # < < : * default _ env _ settings <nl> + < < : * high _ capacity _ env _ settings <nl> env _ vars : & env _ vars <nl> - < < : * resource _ constrained _ env _ vars <nl> - # < < : * high _ capacity _ env _ vars <nl> + # < < : * resource _ constrained _ env _ vars <nl> + < < : * high _ capacity _ env _ vars <nl> workflows : <nl> version : 2 <nl> - build _ and _ run _ tests : * default _ jobs <nl> + # build _ and _ run _ tests : * default _ jobs <nl> # build _ and _ run _ tests : * with _ dtest _ jobs _ only <nl> - # build _ and _ run _ tests : * with _ dtest _ jobs <nl> + build _ and _ run _ tests : * with _ dtest _ jobs <nl> docker _ image : & docker _ image kjellman / cassandra - test : 0 . 4 . 3 <nl> version : 2 <nl> jobs : <nl> diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 40b18ae . . 9e7a599 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add optional startup delay to wait until peers are ready ( CASSANDRA - 13993 ) <nl> * Add a few options to nodetool verify ( CASSANDRA - 14201 ) <nl> * CVE - 2017 - 5929 Security vulnerability and redefine default log rotation policy ( CASSANDRA - 14183 ) <nl> * Use JVM default SSL validation algorithm instead of custom default ( CASSANDRA - 13259 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 875751b . . ad91a9b 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 373 , 6 + 373 , 11 @ @ public class Config <nl> <nl> public String full _ query _ log _ dir = null ; <nl> <nl> + / / parameters to adjust how much to delay startup until a certain amount of the cluster is connect to and marked alive <nl> + public int block _ for _ peers _ percentage = 70 ; <nl> + public int block _ for _ peers _ timeout _ in _ secs = 10 ; <nl> + <nl> + <nl> / * * <nl> * @ deprecated migrate to { @ link DatabaseDescriptor # isClientInitialized ( ) } <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index ccb0a30 . . 2e772c5 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 2522 , 4 + 2522 , 14 @ @ public class DatabaseDescriptor <nl> { <nl> return conf . full _ query _ log _ dir ; <nl> } <nl> + <nl> + public static int getBlockForPeersPercentage ( ) <nl> + { <nl> + return conf . block _ for _ peers _ percentage ; <nl> + } <nl> + <nl> + public static int getBlockForPeersTimeoutInSeconds ( ) <nl> + { <nl> + return conf . block _ for _ peers _ timeout _ in _ secs ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessageOut . java b / src / java / org / apache / cassandra / net / MessageOut . java <nl> index 7d3c0af . . 236a770 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessageOut . java <nl> + + + b / src / java / org / apache / cassandra / net / MessageOut . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 97 , 6 + 98 , 11 @ @ public class MessageOut < T > <nl> public final List < Object > parameters ; <nl> <nl> / * * <nl> + * Allows sender to explicitly state which connection type the message should be sent on . <nl> + * / <nl> + public final ConnectionType connectionType ; <nl> + <nl> + / * * <nl> * Memoization of the serialized size of the just the payload . <nl> * / <nl> private int payloadSerializedSize = - 1 ; <nl> @ @ - 122 , 24 + 128 , 33 @ @ public class MessageOut < T > <nl> this ( verb , <nl> payload , <nl> serializer , <nl> - isTracing ( ) <nl> - ? Tracing . instance . getTraceHeaders ( ) <nl> - : ImmutableList . of ( ) ) ; <nl> + isTracing ( ) ? Tracing . instance . getTraceHeaders ( ) : ImmutableList . of ( ) , <nl> + null ) ; <nl> + } <nl> + <nl> + public MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , ConnectionType connectionType ) <nl> + { <nl> + this ( verb , <nl> + payload , <nl> + serializer , <nl> + isTracing ( ) ? Tracing . instance . getTraceHeaders ( ) : ImmutableList . of ( ) , <nl> + connectionType ) ; <nl> } <nl> <nl> - private MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters ) <nl> + private MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters , ConnectionType connectionType ) <nl> { <nl> - this ( FBUtilities . getBroadcastAddressAndPort ( ) , verb , payload , serializer , parameters ) ; <nl> + this ( FBUtilities . getBroadcastAddressAndPort ( ) , verb , payload , serializer , parameters , connectionType ) ; <nl> } <nl> <nl> @ VisibleForTesting <nl> - public MessageOut ( InetAddressAndPort from , MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters ) <nl> + public MessageOut ( InetAddressAndPort from , MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters , ConnectionType connectionType ) <nl> { <nl> this . from = from ; <nl> this . verb = verb ; <nl> this . payload = payload ; <nl> this . serializer = serializer ; <nl> this . parameters = parameters ; <nl> + this . connectionType = connectionType ; <nl> } <nl> <nl> public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) <nl> @ @ - 148 , 7 + 163 , 7 @ @ public class MessageOut < T > <nl> newParameters . addAll ( parameters ) ; <nl> newParameters . add ( type ) ; <nl> newParameters . add ( value ) ; <nl> - return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; <nl> + return new MessageOut < T > ( verb , payload , serializer , newParameters , connectionType ) ; <nl> } <nl> <nl> public Stage getStage ( ) <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 8fdb395 . . 573cf7d 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 35 , 7 + 35 , 6 @ @ import java . util . concurrent . ConcurrentMap ; <nl> import java . util . concurrent . CopyOnWriteArraySet ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> - <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> @ @ - 255 , 7 + 254 , 10 @ @ public final class MessagingService implements MessagingServiceMBean <nl> return DatabaseDescriptor . getRangeRpcTimeout ( ) ; <nl> } <nl> } , <nl> - / / remember to add new verbs at the end , since we serialize by ordinal <nl> + PING ( ) , <nl> + <nl> + / / add new verbs after the existing verbs , but * before * the UNUSED verbs , since we serialize by ordinal . <nl> + / / UNUSED verbs serve as padding for backwards compatability where a previous version needs to validate a verb from the future . <nl> UNUSED _ 1 , <nl> UNUSED _ 2 , <nl> UNUSED _ 3 , <nl> @ @ - 263 , 7 + 265 , 7 @ @ public final class MessagingService implements MessagingServiceMBean <nl> UNUSED _ 5 , <nl> ; <nl> <nl> - private int id ; <nl> + private final int id ; <nl> Verb ( ) <nl> { <nl> id = ordinal ( ) ; <nl> @ @ - 291 , 7 + 293 , 11 @ @ public final class MessagingService implements MessagingServiceMBean <nl> static <nl> { <nl> for ( Verb v : values ( ) ) <nl> + { <nl> + if ( idToVerbMap . containsKey ( v . getId ( ) ) ) <nl> + throw new IllegalArgumentException ( " cannot have two verbs that map to the same id : " + v + " and " + v . getId ( ) ) ; <nl> idToVerbMap . put ( v . getId ( ) , v ) ; <nl> + } <nl> } <nl> <nl> public static Verb fromId ( int id ) <nl> @ @ - 347 , 6 + 353 , 8 @ @ public final class MessagingService implements MessagingServiceMBean <nl> put ( Verb . UNUSED _ 1 , Stage . INTERNAL _ RESPONSE ) ; <nl> put ( Verb . UNUSED _ 2 , Stage . INTERNAL _ RESPONSE ) ; <nl> put ( Verb . UNUSED _ 3 , Stage . INTERNAL _ RESPONSE ) ; <nl> + <nl> + put ( Verb . PING , Stage . READ ) ; <nl> } } ; <nl> <nl> / * * <nl> @ @ - 385 , 6 + 393 , 8 @ @ public final class MessagingService implements MessagingServiceMBean <nl> put ( Verb . HINT , HintMessage . serializer ) ; <nl> put ( Verb . BATCH _ STORE , Batch . serializer ) ; <nl> put ( Verb . BATCH _ REMOVE , UUIDSerializer . serializer ) ; <nl> + <nl> + put ( Verb . PING , PingMessage . serializer ) ; <nl> } } ; <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / net / PingMessage . java b / src / java / org / apache / cassandra / net / PingMessage . java <nl> new file mode 100644 <nl> index 0000000 . . 4a19f22 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / PingMessage . java <nl> @ @ - 0 , 0 + 1 , 82 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . IOException ; <nl> + <nl> + import org . apache . cassandra . hints . HintResponse ; <nl> + import org . apache . cassandra . io . IVersionedSerializer ; <nl> + import org . apache . cassandra . io . util . DataInputPlus ; <nl> + import org . apache . cassandra . io . util . DataOutputPlus ; <nl> + import org . apache . cassandra . net . async . OutboundConnectionIdentifier ; <nl> + import org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; <nl> + <nl> + / * * <nl> + * Conceptually the same as { @ link org . apache . cassandra . gms . EchoMessage } , but indicates to the recipient which <nl> + * { @ link ConnectionType } should be used for the response . <nl> + * / <nl> + public class PingMessage <nl> + { <nl> + public static IVersionedSerializer < PingMessage > serializer = new PingMessageSerializer ( ) ; <nl> + <nl> + public static final PingMessage smallChannelMessage = new PingMessage ( ConnectionType . SMALL _ MESSAGE ) ; <nl> + public static final PingMessage largeChannelMessage = new PingMessage ( ConnectionType . LARGE _ MESSAGE ) ; <nl> + public static final PingMessage gossipChannelMessage = new PingMessage ( ConnectionType . GOSSIP ) ; <nl> + <nl> + public final ConnectionType connectionType ; <nl> + <nl> + public PingMessage ( ConnectionType connectionType ) <nl> + { <nl> + this . connectionType = connectionType ; <nl> + } <nl> + <nl> + public static class PingMessageSerializer implements IVersionedSerializer < PingMessage > <nl> + { <nl> + public void serialize ( PingMessage t , DataOutputPlus out , int version ) throws IOException <nl> + { <nl> + out . writeByte ( t . connectionType . getId ( ) ) ; <nl> + } <nl> + <nl> + public PingMessage deserialize ( DataInputPlus in , int version ) throws IOException <nl> + { <nl> + ConnectionType connectionType = ConnectionType . fromId ( in . readByte ( ) ) ; <nl> + <nl> + / / if we ever create a new connection type , then during a rolling upgrade , the old nodes won ' t know about <nl> + / / the new connection type ( as it won ' t recognize the id ) , so just default to the small message type . <nl> + if ( connectionType = = null ) <nl> + connectionType = ConnectionType . SMALL _ MESSAGE ; <nl> + <nl> + switch ( connectionType ) <nl> + { <nl> + case LARGE _ MESSAGE : <nl> + return largeChannelMessage ; <nl> + case GOSSIP : <nl> + return gossipChannelMessage ; <nl> + case SMALL _ MESSAGE : <nl> + default : <nl> + return smallChannelMessage ; <nl> + } <nl> + } <nl> + <nl> + public long serializedSize ( PingMessage t , int version ) <nl> + { <nl> + return 1 ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / PingVerbHandler . java b / src / java / org / apache / cassandra / net / PingVerbHandler . java <nl> new file mode 100644 <nl> index 0000000 . . d959b91 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / PingVerbHandler . java <nl> @ @ - 0 , 0 + 1 , 31 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + public class PingVerbHandler implements IVerbHandler < PingMessage > <nl> + { <nl> + @ Override <nl> + public void doVerb ( MessageIn < PingMessage > message , int id ) <nl> + { <nl> + MessageOut < PongMessage > msg = new MessageOut < > ( MessagingService . Verb . REQUEST _ RESPONSE , PongMessage . instance , <nl> + PongMessage . serializer , <nl> + message . payload . connectionType ) ; <nl> + MessagingService . instance ( ) . sendReply ( msg , id , message . from ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / PongMessage . java b / src / java / org / apache / cassandra / net / PongMessage . java <nl> new file mode 100644 <nl> index 0000000 . . bb89cdf <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / PongMessage . java <nl> @ @ - 0 , 0 + 1 , 50 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . IOException ; <nl> + <nl> + import org . apache . cassandra . io . IVersionedSerializer ; <nl> + import org . apache . cassandra . io . util . DataInputPlus ; <nl> + import org . apache . cassandra . io . util . DataOutputPlus ; <nl> + <nl> + public class PongMessage <nl> + { <nl> + public static final PongMessage instance = new PongMessage ( ) ; <nl> + public static IVersionedSerializer < PongMessage > serializer = new PongMessage . PongMessageSerializer ( ) ; <nl> + <nl> + private PongMessage ( ) <nl> + { } <nl> + <nl> + public static class PongMessageSerializer implements IVersionedSerializer < PongMessage > <nl> + { <nl> + public void serialize ( PongMessage t , DataOutputPlus out , int version ) throws IOException <nl> + { } <nl> + <nl> + public PongMessage deserialize ( DataInputPlus in , int version ) throws IOException <nl> + { <nl> + return instance ; <nl> + } <nl> + <nl> + public long serializedSize ( PongMessage t , int version ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java b / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java <nl> new file mode 100644 <nl> index 0000000 . . f22ab48 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java <nl> @ @ - 0 , 0 + 1 , 171 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . util . Set ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . function . Predicate ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . util . concurrent . Uninterruptibles ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . net . async . OutboundConnectionIdentifier ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import static org . apache . cassandra . net . MessagingService . Verb . PING ; <nl> + <nl> + public class StartupClusterConnectivityChecker <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( StartupClusterConnectivityChecker . class ) ; <nl> + <nl> + enum State { CONTINUE , FINISH _ SUCCESS , FINISH _ TIMEOUT } <nl> + <nl> + private final int targetPercent ; <nl> + private final int timeoutSecs ; <nl> + private final Predicate < InetAddressAndPort > gossipStatus ; <nl> + <nl> + public StartupClusterConnectivityChecker ( int targetPercent , int timeoutSecs , Predicate < InetAddressAndPort > gossipStatus ) <nl> + { <nl> + if ( targetPercent < 0 ) <nl> + { <nl> + targetPercent = 0 ; <nl> + } <nl> + else if ( targetPercent > 100 ) <nl> + { <nl> + targetPercent = 100 ; <nl> + } <nl> + this . targetPercent = targetPercent ; <nl> + <nl> + if ( timeoutSecs < 0 ) <nl> + { <nl> + timeoutSecs = 1 ; <nl> + } <nl> + else if ( timeoutSecs > 100 ) <nl> + { <nl> + logger . warn ( " setting the block - for - peers timeout ( in seconds ) to { } might be a bit excessive , but using it nonetheless " , timeoutSecs ) ; <nl> + } <nl> + this . timeoutSecs = timeoutSecs ; <nl> + <nl> + this . gossipStatus = gossipStatus ; <nl> + } <nl> + <nl> + public void execute ( Set < InetAddressAndPort > peers ) <nl> + { <nl> + if ( peers = = null | | targetPercent = = 0 ) <nl> + return ; <nl> + <nl> + / / remove current node from the set <nl> + peers = peers . stream ( ) <nl> + . filter ( peer - > ! peer . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) <nl> + . collect ( Collectors . toSet ( ) ) ; <nl> + <nl> + / / don ' t block if there ' s no other nodes in the cluster ( or we don ' t know about them ) <nl> + if ( peers . size ( ) < = 0 ) <nl> + return ; <nl> + <nl> + logger . info ( " choosing to block until { } % of peers are marked alive and connections are established ; max time to wait = { } seconds " , <nl> + targetPercent , timeoutSecs ) ; <nl> + <nl> + / / first , send out a ping message to open up the non - gossip connections <nl> + final AtomicInteger connectedCount = sendPingMessages ( peers ) ; <nl> + <nl> + final long startNanos = System . nanoTime ( ) ; <nl> + final long expirationNanos = startNanos + TimeUnit . SECONDS . toNanos ( timeoutSecs ) ; <nl> + int completedRounds = 0 ; <nl> + while ( checkStatus ( peers , connectedCount , startNanos , expirationNanos < System . nanoTime ( ) , completedRounds ) = = State . CONTINUE ) <nl> + { <nl> + completedRounds + + ; <nl> + Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . MICROSECONDS ) ; <nl> + } <nl> + } <nl> + <nl> + State checkStatus ( Set < InetAddressAndPort > peers , AtomicInteger connectedCount , final long startNanos , boolean beyondExpiration , final int completedRounds ) <nl> + { <nl> + long currentAlive = peers . stream ( ) . filter ( gossipStatus ) . count ( ) ; <nl> + float currentAlivePercent = ( ( float ) currentAlive / ( float ) peers . size ( ) ) * 100 ; <nl> + <nl> + / / assume two connections to remote host that we care to track here ( small msg & large msg ) <nl> + final int totalConnectionsSize = peers . size ( ) * 2 ; <nl> + final int connectionsCount = connectedCount . get ( ) ; <nl> + float currentConnectedPercent = ( ( float ) connectionsCount / ( float ) totalConnectionsSize ) * 100 ; <nl> + <nl> + if ( currentAlivePercent > = targetPercent & & currentConnectedPercent > = targetPercent ) <nl> + { <nl> + logger . info ( " after { } milliseconds , found { } % ( { } / { } ) of peers as marked alive , " + <nl> + " and { } % ( { } / { } ) of peers as connected , " + <nl> + " both of which are above the desired threshold of { } % " , <nl> + TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - startNanos ) , <nl> + currentAlivePercent , currentAlive , peers . size ( ) , <nl> + currentConnectedPercent , connectionsCount , totalConnectionsSize , <nl> + targetPercent ) ; <nl> + return State . FINISH _ SUCCESS ; <nl> + } <nl> + <nl> + / / perform at least two rounds of checking , else this is kinda useless ( and the operator set the aliveTimeoutSecs too low ) <nl> + if ( completedRounds > = 2 & & beyondExpiration ) <nl> + { <nl> + logger . info ( " after { } milliseconds , found { } % ( { } / { } ) of peers as marked alive , " + <nl> + " and { } % ( { } / { } ) of peers as connected , " + <nl> + " one or both of which is below the desired threshold of { } % " , <nl> + TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - startNanos ) , <nl> + currentAlivePercent , currentAlive , peers . size ( ) , <nl> + currentConnectedPercent , connectionsCount , totalConnectionsSize , <nl> + targetPercent ) ; <nl> + return State . FINISH _ TIMEOUT ; <nl> + } <nl> + return State . CONTINUE ; <nl> + } <nl> + <nl> + / * * <nl> + * Sends a " connection warmup " message to each peer in the collection , on every { @ link OutboundConnectionIdentifier . ConnectionType } <nl> + * used for internode messaging . <nl> + * / <nl> + private AtomicInteger sendPingMessages ( Set < InetAddressAndPort > peers ) <nl> + { <nl> + AtomicInteger connectedCount = new AtomicInteger ( 0 ) ; <nl> + IAsyncCallback responseHandler = new IAsyncCallback ( ) <nl> + { <nl> + @ Override <nl> + public boolean isLatencyForSnitch ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public void response ( MessageIn msg ) <nl> + { <nl> + connectedCount . incrementAndGet ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + MessageOut < PingMessage > smallChannelMessageOut = new MessageOut < > ( PING , PingMessage . smallChannelMessage , PingMessage . serializer ) ; <nl> + MessageOut < PingMessage > largeChannelMessageOut = new MessageOut < > ( PING , PingMessage . largeChannelMessage , PingMessage . serializer ) ; <nl> + for ( InetAddressAndPort peer : peers ) <nl> + { <nl> + MessagingService . instance ( ) . sendRR ( smallChannelMessageOut , peer , responseHandler ) ; <nl> + MessagingService . instance ( ) . sendRR ( largeChannelMessageOut , peer , responseHandler ) ; <nl> + } <nl> + <nl> + return connectedCount ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java b / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java <nl> index f3cb554 . . e309065 100644 <nl> - - - a / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java <nl> + + + b / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java <nl> @ @ - 18 , 9 + 18 , 8 @ @ <nl> <nl> package org . apache . cassandra . net . async ; <nl> <nl> - import java . net . InetAddress ; <nl> - import java . net . InetSocketAddress ; <nl> - <nl> + import com . carrotsearch . hppc . IntObjectMap ; <nl> + import com . carrotsearch . hppc . IntObjectOpenHashMap ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> <nl> / * * <nl> @ @ - 32 , 9 + 31 , 34 @ @ import org . apache . cassandra . locator . InetAddressAndPort ; <nl> * / <nl> public class OutboundConnectionIdentifier <nl> { <nl> - enum ConnectionType <nl> + public enum ConnectionType <nl> { <nl> - GOSSIP , LARGE _ MESSAGE , SMALL _ MESSAGE , STREAM <nl> + GOSSIP ( 0 ) , LARGE _ MESSAGE ( 1 ) , SMALL _ MESSAGE ( 2 ) , STREAM ( 3 ) ; <nl> + <nl> + private final int id ; <nl> + <nl> + ConnectionType ( int id ) <nl> + { <nl> + this . id = id ; <nl> + } <nl> + <nl> + public int getId ( ) <nl> + { <nl> + return id ; <nl> + } <nl> + <nl> + private static final IntObjectMap < ConnectionType > idMap = new IntObjectOpenHashMap < > ( values ( ) . length ) ; <nl> + static <nl> + { <nl> + for ( ConnectionType type : values ( ) ) <nl> + idMap . put ( type . id , type ) ; <nl> + } <nl> + <nl> + public static ConnectionType fromId ( int id ) <nl> + { <nl> + return idMap . get ( id ) ; <nl> + } <nl> + <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java b / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java <nl> index 28775ef . . 064131b 100644 <nl> - - - a / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java <nl> @ @ - 479 , 7 + 479 , 7 @ @ public class OutboundMessagingConnection <nl> { <nl> case SUCCESS : <nl> assert result . channelWriter ! = null ; <nl> - logger . debug ( " successfully connected to { } , conmpress = { } , coalescing = { } " , connectionId , <nl> + logger . debug ( " successfully connected to { } , compress = { } , coalescing = { } " , connectionId , <nl> shouldCompressConnection ( connectionId . local ( ) , connectionId . remote ( ) ) , <nl> coalescingStrategy . isPresent ( ) ? coalescingStrategy . get ( ) : CoalescingStrategies . Strategy . DISABLED ) ; <nl> if ( state . get ( ) = = State . CLOSED ) <nl> diff - - git a / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java b / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java <nl> index c701229 . . 14650a7 100644 <nl> - - - a / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java <nl> + + + b / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java <nl> @ @ - 18 , 7 + 18 , 6 @ @ <nl> <nl> package org . apache . cassandra . net . async ; <nl> <nl> - import java . net . InetSocketAddress ; <nl> import java . util . Optional ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> @ @ - 101 , 14 + 100 , 21 @ @ public class OutboundMessagingPool <nl> @ VisibleForTesting <nl> public OutboundMessagingConnection getConnection ( MessageOut msg ) <nl> { <nl> - / / optimize for the common path ( the small message channel ) <nl> - if ( Stage . GOSSIP ! = msg . getStage ( ) ) <nl> + if ( msg . connectionType = = null ) <nl> { <nl> - return msg . serializedSize ( smallMessageChannel . getTargetVersion ( ) ) < LARGE _ MESSAGE _ THRESHOLD <nl> - ? smallMessageChannel <nl> - : largeMessageChannel ; <nl> + / / optimize for the common path ( the small message channel ) <nl> + if ( Stage . GOSSIP ! = msg . getStage ( ) ) <nl> + { <nl> + return msg . serializedSize ( smallMessageChannel . getTargetVersion ( ) ) < LARGE _ MESSAGE _ THRESHOLD <nl> + ? smallMessageChannel <nl> + : largeMessageChannel ; <nl> + } <nl> + return gossipChannel ; <nl> + } <nl> + else <nl> + { <nl> + return getConnection ( msg . connectionType ) ; <nl> } <nl> - return gossipChannel ; <nl> } <nl> <nl> / * * <nl> @ @ - 138 , 20 + 144 , 17 @ @ public class OutboundMessagingPool <nl> smallMessageChannel . close ( softClose ) ; <nl> } <nl> <nl> - / * * <nl> - * For testing purposes only . <nl> - * / <nl> @ VisibleForTesting <nl> - OutboundMessagingConnection getConnection ( ConnectionType connectionType ) <nl> + final OutboundMessagingConnection getConnection ( ConnectionType connectionType ) <nl> { <nl> switch ( connectionType ) <nl> { <nl> - case GOSSIP : <nl> - return gossipChannel ; <nl> - case LARGE _ MESSAGE : <nl> - return largeMessageChannel ; <nl> case SMALL _ MESSAGE : <nl> return smallMessageChannel ; <nl> + case LARGE _ MESSAGE : <nl> + return largeMessageChannel ; <nl> + case GOSSIP : <nl> + return gossipChannel ; <nl> default : <nl> throw new IllegalArgumentException ( " unsupported connection type : " + connectionType ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 130f3fd . . 295a33b 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 25 , 7 + 25 , 10 @ @ import java . net . InetAddress ; <nl> import java . net . URL ; <nl> import java . net . UnknownHostException ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . concurrent . TimeUnit ; <nl> + import java . util . stream . Collectors ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> import javax . management . StandardMBean ; <nl> @ @ - 47 , 6 + 50 , 7 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . net . StartupClusterConnectivityChecker ; <nl> import org . apache . cassandra . schema . TableMetadata ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . schema . Schema ; <nl> @ @ - 491 , 6 + 495 , 12 @ @ public class CassandraDaemon <nl> * / <nl> public void start ( ) <nl> { <nl> + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( DatabaseDescriptor . getBlockForPeersPercentage ( ) , <nl> + DatabaseDescriptor . getBlockForPeersTimeoutInSeconds ( ) , <nl> + Gossiper . instance : : isAlive ) ; <nl> + Set < InetAddressAndPort > peers = Gossiper . instance . getEndpointStates ( ) . stream ( ) . map ( Map . Entry : : getKey ) . collect ( Collectors . toSet ( ) ) ; <nl> + connectivityChecker . execute ( peers ) ; <nl> + <nl> String nativeFlag = System . getProperty ( " cassandra . start _ native _ transport " ) ; <nl> if ( ( nativeFlag ! = null & & Boolean . parseBoolean ( nativeFlag ) ) | | ( nativeFlag = = null & & DatabaseDescriptor . startNativeTransport ( ) ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / EchoVerbHandler . java b / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> index d0c435e . . 1cc52e9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / EchoVerbHandler . java <nl> @ @ - 26 , 16 + 26 , 20 @ @ import org . apache . cassandra . net . IVerbHandler ; <nl> import org . apache . cassandra . net . MessageIn ; <nl> import org . apache . cassandra . net . MessageOut ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> + <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import static org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; <nl> + <nl> public class EchoVerbHandler implements IVerbHandler < EchoMessage > <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( EchoVerbHandler . class ) ; <nl> <nl> public void doVerb ( MessageIn < EchoMessage > message , int id ) <nl> { <nl> - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , EchoMessage . serializer ) ; <nl> + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , <nl> + EchoMessage . serializer , ConnectionType . GOSSIP ) ; <nl> logger . trace ( " Sending a EchoMessage reply { } " , message . from ) ; <nl> MessagingService . instance ( ) . sendReply ( echoMessage , id , message . from ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index d465431 . . 51b77a6 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 92 , 6 + 92 , 7 @ @ import org . apache . cassandra . schema . SchemaVersionVerbHandler ; <nl> import org . apache . cassandra . schema . TableMetadata ; <nl> import org . apache . cassandra . schema . TableMetadataRef ; <nl> import org . apache . cassandra . schema . ViewMetadata ; <nl> + import org . apache . cassandra . repair . RepairMessageVerbHandler ; <nl> import org . apache . cassandra . service . paxos . CommitVerbHandler ; <nl> import org . apache . cassandra . service . paxos . PrepareVerbHandler ; <nl> import org . apache . cassandra . service . paxos . ProposeVerbHandler ; <nl> @ @ - 301 , 6 + 302 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BATCH _ STORE , new BatchStoreVerbHandler ( ) ) ; <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BATCH _ REMOVE , new BatchRemoveVerbHandler ( ) ) ; <nl> + <nl> + MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . PING , new PingVerbHandler ( ) ) ; <nl> } <nl> <nl> public void registerDaemon ( CassandraDaemon daemon ) <nl> diff - - git a / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java b / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 12f54c6 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java <nl> @ @ - 0 , 0 + 1 , 129 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . net . UnknownHostException ; <nl> + import java . util . HashSet ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . function . Predicate ; <nl> + <nl> + import com . google . common . net . InetAddresses ; <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + <nl> + public class StartupClusterConnectivityCheckerTest <nl> + { <nl> + @ Test <nl> + public void testConnectivity _ SimpleHappyPath ( ) throws UnknownHostException <nl> + { <nl> + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; <nl> + int count = 10 ; <nl> + Set < InetAddressAndPort > peers = createNodes ( count ) ; <nl> + Assert . assertEquals ( StartupClusterConnectivityChecker . State . FINISH _ SUCCESS , <nl> + connectivityChecker . checkStatus ( peers , new AtomicInteger ( count * 2 ) , System . nanoTime ( ) , false , 0 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConnectivity _ SimpleContinue ( ) throws UnknownHostException <nl> + { <nl> + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; <nl> + int count = 10 ; <nl> + Set < InetAddressAndPort > peers = createNodes ( count ) ; <nl> + Assert . assertEquals ( StartupClusterConnectivityChecker . State . CONTINUE , <nl> + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , false , 0 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConnectivity _ Timeout ( ) throws UnknownHostException <nl> + { <nl> + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; <nl> + int count = 10 ; <nl> + Set < InetAddressAndPort > peers = createNodes ( count ) ; <nl> + Assert . assertEquals ( StartupClusterConnectivityChecker . State . CONTINUE , <nl> + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , false , 4 ) ) ; <nl> + Assert . assertEquals ( StartupClusterConnectivityChecker . State . FINISH _ TIMEOUT , <nl> + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , true , 5 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConnectivity _ SimpleUpdating ( ) throws UnknownHostException <nl> + { <nl> + UpdatablePredicate predicate = new UpdatablePredicate ( ) ; <nl> + final int count = 100 ; <nl> + final int thresholdPercentage = 70 ; <nl> + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( thresholdPercentage , 10 , predicate ) ; <nl> + Set < InetAddressAndPort > peers = createNodes ( count ) ; <nl> + <nl> + AtomicInteger connectedCount = new AtomicInteger ( ) ; <nl> + <nl> + for ( int i = 0 ; i < count ; i + + ) <nl> + { <nl> + predicate . reset ( i ) ; <nl> + connectedCount . set ( i * 2 ) ; <nl> + StartupClusterConnectivityChecker . State expectedState = i < thresholdPercentage ? <nl> + StartupClusterConnectivityChecker . State . CONTINUE : <nl> + StartupClusterConnectivityChecker . State . FINISH _ SUCCESS ; <nl> + Assert . assertEquals ( " failed on iteration " + i , <nl> + expectedState , connectivityChecker . checkStatus ( peers , connectedCount , System . nanoTime ( ) , false , i ) ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * returns true until index = threshold , then returns false . <nl> + * / <nl> + private class UpdatablePredicate implements Predicate < InetAddressAndPort > <nl> + { <nl> + int index ; <nl> + int threshold ; <nl> + <nl> + void reset ( int threshold ) <nl> + { <nl> + index = 0 ; <nl> + this . threshold = threshold ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean test ( InetAddressAndPort inetAddressAndPort ) <nl> + { <nl> + index + + ; <nl> + return index < = threshold ; <nl> + } <nl> + } <nl> + <nl> + private static Set < InetAddressAndPort > createNodes ( int count ) throws UnknownHostException <nl> + { <nl> + Set < InetAddressAndPort > nodes = new HashSet < > ( ) ; <nl> + <nl> + if ( count < 1 ) <nl> + Assert . fail ( " need at least * one * node in the set ! " ) ; <nl> + <nl> + InetAddressAndPort node = InetAddressAndPort . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + nodes . add ( node ) ; <nl> + for ( int i = 1 ; i < count ; i + + ) <nl> + { <nl> + node = InetAddressAndPort . getByAddress ( InetAddresses . increment ( node . address ) ) ; <nl> + nodes . add ( node ) ; <nl> + } <nl> + return nodes ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / service / RemoveTest . java b / test / unit / org / apache / cassandra / service / RemoveTest . java <nl> index 6714a83 . . 0d39322 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / RemoveTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / RemoveTest . java <nl> @ @ - 161 , 7 + 161 , 7 @ @ public class RemoveTest <nl> <nl> for ( InetAddressAndPort host : hosts ) <nl> { <nl> - MessageOut msg = new MessageOut ( host , MessagingService . Verb . REPLICATION _ FINISHED , null , null , Collections . < Object > emptyList ( ) ) ; <nl> + MessageOut msg = new MessageOut ( host , MessagingService . Verb . REPLICATION _ FINISHED , null , null , Collections . < Object > emptyList ( ) , null ) ; <nl> MessagingService . instance ( ) . sendRR ( msg , FBUtilities . getBroadcastAddressAndPort ( ) ) ; <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 30f85a4 . . 11499a6 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler <nl> # the request scheduling . The current supported option is " keyspace " <nl> request _ scheduler _ id : keyspace <nl> <nl> + # dynamic _ snitch - - This boolean controls whether the above snitch is <nl> + # wrapped with a dynamic snitch , which will monitor read latencies <nl> + # and avoid reading from hosts that have slowed ( due to compaction , <nl> + # for instance ) <nl> + dynamic _ snitch : false <nl> + <nl> # A ColumnFamily is the Cassandra concept closest to a relational table . <nl> # <nl> # Keyspaces are separate groups of ColumnFamilies . Except in very <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 2a5478e . . 315c9a4 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 71 , 6 + 71 , 7 @ @ public class Config { <nl> public Integer commitlog _ sync _ period _ in _ ms ; <nl> <nl> public String endpoint _ snitch ; <nl> + public Boolean dynamic _ snitch = false ; <nl> <nl> public String request _ scheduler ; <nl> public RequestSchedulerId request _ scheduler _ id ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 0947af0 . . b5f9302 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; <nl> import java . net . UnknownHostException ; <nl> import java . util . * ; <nl> <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor <nl> throw ( ConfigurationException ) e . getCause ( ) ; <nl> throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; <nl> } <nl> - return snitch ; <nl> + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; <nl> } <nl> <nl> - public static void loadSchemas ( ) throws IOException <nl> + public static void loadSchemas ( ) throws IOException <nl> { <nl> / / we can load tables from local storage if a version is set in the system table and that acutally maps to <nl> / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> index 4892281 . . 2ef4980 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . net . InetAddress ; <nl> import java . util . Collection ; <nl> + import java . util . Comparator ; <nl> import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> <nl> @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch <nl> <nl> public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> index acb1d16 . . c40f995 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch <nl> { <nl> public int compare ( InetAddress a1 , InetAddress a2 ) <nl> { <nl> - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> - return - 1 ; <nl> - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> - return 1 ; <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } ; <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> <nl> - String addressRack = getRack ( address ) ; <nl> - String a1Rack = getRack ( a1 ) ; <nl> - String a2Rack = getRack ( a2 ) ; <nl> - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> - return - 1 ; <nl> - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> - return 1 ; <nl> + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> + return - 1 ; <nl> + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> + return 1 ; <nl> <nl> - String addressDatacenter = getDatacenter ( address ) ; <nl> - String a1Datacenter = getDatacenter ( a1 ) ; <nl> - String a2Datacenter = getDatacenter ( a2 ) ; <nl> - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> - return - 1 ; <nl> - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> - return 1 ; <nl> + String addressRack = getRack ( address ) ; <nl> + String a1Rack = getRack ( a1 ) ; <nl> + String a2Rack = getRack ( a2 ) ; <nl> + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> + return - 1 ; <nl> + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> + return 1 ; <nl> <nl> - return 0 ; <nl> - } <nl> - } ) ; <nl> - return addresses ; <nl> + String addressDatacenter = getDatacenter ( address ) ; <nl> + String a1Datacenter = getDatacenter ( a1 ) ; <nl> + String a2Datacenter = getDatacenter ( a2 ) ; <nl> + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> + return - 1 ; <nl> + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> + return 1 ; <nl> + <nl> + return 0 ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> new file mode 100644 <nl> index 0000000 . . cb2f03b <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> @ @ - 0 , 0 + 1 , 238 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . * ; <nl> + import java . util . concurrent . LinkedBlockingDeque ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import java . lang . management . ManagementFactory ; <nl> + import javax . management . MBeanServer ; <nl> + import javax . management . ObjectName ; <nl> + <nl> + import org . apache . cassandra . net . IVerbHandler ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . ResponseVerbHandler ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . utils . AbstractStatsDeque ; <nl> + import org . apache . cassandra . locator . IEndpointSnitch ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + import org . apache . cassandra . locator . AbstractEndpointSnitch ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + / * * <nl> + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector <nl> + * / <nl> + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean <nl> + { <nl> + private static int UPDATES _ PER _ INTERVAL = 100 ; <nl> + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; <nl> + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; <nl> + private static int WINDOW _ SIZE = 100 ; <nl> + private boolean registered = false ; <nl> + <nl> + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; <nl> + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; <nl> + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; <nl> + public IEndpointSnitch subsnitch ; <nl> + <nl> + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) <nl> + { <nl> + subsnitch = snitch ; <nl> + TimerTask update = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + updateScores ( ) ; <nl> + } <nl> + } ; <nl> + TimerTask reset = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try <nl> + / / to read from it , which would cause its score to never change <nl> + reset ( ) ; <nl> + } <nl> + } ; <nl> + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; <nl> + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; <nl> + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; <nl> + <nl> + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> + try <nl> + { <nl> + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getRack ( endpoint ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getDatacenter ( endpoint ) ; <nl> + } <nl> + <nl> + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> + { <nl> + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; <nl> + sortByProximity ( address , list ) ; <nl> + return list ; <nl> + } <nl> + <nl> + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) <nl> + { <nl> + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself <nl> + Collections . sort ( addresses , new Comparator < InetAddress > ( ) <nl> + { <nl> + public int compare ( InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + Double scored1 = scores . get ( a1 ) ; <nl> + Double scored2 = scores . get ( a2 ) ; <nl> + <nl> + if ( scored1 = = null | | scored2 = = null ) <nl> + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; <nl> + if ( scored1 . equals ( scored2 ) ) <nl> + return 0 ; <nl> + if ( scored1 < scored2 ) <nl> + return 1 ; <nl> + else <nl> + return - 1 ; <nl> + } <nl> + <nl> + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap <nl> + { <nl> + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) <nl> + return ; <nl> + AdaptiveLatencyTracker tracker = windows . get ( host ) ; <nl> + if ( tracker = = null ) <nl> + { <nl> + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; <nl> + tracker = windows . putIfAbsent ( host , alt ) ; <nl> + if ( tracker = = null ) <nl> + tracker = alt ; <nl> + } <nl> + tracker . add ( latency ) ; <nl> + intervalupdates . getAndIncrement ( ) ; <nl> + } <nl> + <nl> + private void updateScores ( ) / / this is expensive <nl> + { <nl> + if ( ! registered ) <nl> + { <nl> + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; <nl> + if ( handler ! = null ) <nl> + { <nl> + handler . register ( this ) ; <nl> + registered = true ; <nl> + } <nl> + <nl> + } <nl> + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) <nl> + { <nl> + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; <nl> + } <nl> + intervalupdates . set ( 0 ) ; <nl> + } <nl> + <nl> + private void reset ( ) <nl> + { <nl> + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) <nl> + { <nl> + tracker . clear ( ) ; <nl> + } <nl> + } <nl> + <nl> + public Map < InetAddress , Double > getScores ( ) <nl> + { <nl> + return scores ; <nl> + } <nl> + } <nl> + <nl> + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / <nl> + class AdaptiveLatencyTracker extends AbstractStatsDeque <nl> + { <nl> + private LinkedBlockingDeque latencies ; <nl> + private final int size ; <nl> + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter <nl> + <nl> + AdaptiveLatencyTracker ( int size ) <nl> + { <nl> + this . size = size ; <nl> + latencies = new LinkedBlockingDeque ( size ) ; <nl> + } <nl> + <nl> + public void add ( double i ) <nl> + { <nl> + latencies . offer ( i ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + latencies . clear ( ) ; <nl> + } <nl> + <nl> + public Iterator < Double > iterator ( ) <nl> + { <nl> + return latencies . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return latencies . size ( ) ; <nl> + } <nl> + <nl> + double p ( double t ) <nl> + { <nl> + double mean = mean ( ) ; <nl> + double exponent = ( - 1 ) * ( t ) / mean ; <nl> + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; <nl> + } <nl> + <nl> + double score ( ) <nl> + { <nl> + double log = 0d ; <nl> + if ( latencies . size ( ) > 0 ) <nl> + { <nl> + double probability = p ( SENTINEL _ COMPARE ) ; <nl> + log = ( - 1 ) * Math . log10 ( probability ) ; <nl> + } <nl> + return log ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> new file mode 100644 <nl> index 0000000 . . 26c5799 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> @ @ - 0 , 0 + 1 , 27 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Map ; <nl> + <nl> + public interface DynamicEndpointSnitchMBean { <nl> + public Map < InetAddress , Double > getScores ( ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> index ca451c0 . . 091c4c2 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; <nl> public interface IEndpointSnitch <nl> { <nl> / * * <nl> + * returns a String repesenting the rack this endpoint belongs to <nl> + * / <nl> + public String getRack ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> + * returns a String representing the datacenter this endpoint belongs to <nl> + * / <nl> + public String getDatacenter ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> * returns a new < tt > List < / tt > sorted by proximity to the given endpoint <nl> * / <nl> public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch <nl> * @ param subscriber the subscriber to notify <nl> * / <nl> public void register ( AbstractReplicationStrategy subscriber ) ; <nl> + <nl> + / * * <nl> + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would <nl> + * / <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> new file mode 100644 <nl> index 0000000 . . 0d97e84 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + <nl> + public interface ILatencyPublisher <nl> + { <nl> + public void register ( ILatencySubscriber subcriber ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> new file mode 100644 <nl> index 0000000 . . 6cfcf33 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + <nl> + public interface ILatencySubscriber <nl> + { <nl> + public void receiveTiming ( InetAddress address , Double latency ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> index c2fd8b5 . . dd8fb68 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> + import org . apache . commons . lang . NotImplementedException ; <nl> + <nl> / * * <nl> * A simple endpoint snitch implementation does not sort addresses by <nl> * proximity . <nl> * / <nl> public class SimpleSnitch extends AbstractEndpointSnitch <nl> { <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> { <nl> return new ArrayList < InetAddress > ( addresses ) ; <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 474d7c2 . . efd2545 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> return taskCompletionMap _ . remove ( key ) ; <nl> } <nl> <nl> + public static long getRegisteredCallbackAge ( String key ) <nl> + { <nl> + return callbackMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> + public static long getAsyncResultAge ( String key ) <nl> + { <nl> + return taskCompletionMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> public static ExecutorService getDeserializationExecutor ( ) <nl> { <nl> return messageDeserializerExecutor _ ; <nl> diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> index 020d187 . . cde87b2 100644 <nl> - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> @ @ - 18 , 21 + 18 , 30 @ @ <nl> <nl> package org . apache . cassandra . net ; <nl> <nl> + <nl> + import java . util . * ; <nl> + import java . net . InetAddress ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> <nl> - public class ResponseVerbHandler implements IVerbHandler <nl> + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher <nl> { <nl> private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; <nl> - <nl> + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; <nl> + <nl> + <nl> public void doVerb ( Message message ) <nl> { <nl> String messageId = message . getMessageId ( ) ; <nl> IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; <nl> + double age = 0 ; <nl> if ( cb ! = null ) <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; <nl> cb . response ( message ) ; <nl> } <nl> else <nl> @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; <nl> ar . result ( message ) ; <nl> } <nl> } <nl> + notifySubscribers ( message . getFrom ( ) , age ) ; <nl> + } <nl> + <nl> + private void notifySubscribers ( InetAddress host , double latency ) <nl> + { <nl> + for ( ILatencySubscriber subscriber : subscribers ) <nl> + { <nl> + subscriber . receiveTiming ( host , latency ) ; <nl> + } <nl> + } <nl> + <nl> + public void register ( ILatencySubscriber subscriber ) <nl> + { <nl> + subscribers . add ( subscriber ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> index dfaadf7 . . aa2c7ec 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > <nl> return result ; <nl> } <nl> <nl> + public long getAge ( K key ) <nl> + { <nl> + long age = 0 ; <nl> + CacheableObject < V > co = cache . get ( key ) ; <nl> + if ( co ! = null ) <nl> + { <nl> + age = co . age ; <nl> + } <nl> + return age ; <nl> + } <nl> + <nl> public int size ( ) <nl> { <nl> return cache . size ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> new file mode 100644 <nl> index 0000000 . . 62904b4 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> @ @ - 0 , 0 + 1 , 109 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . ArrayList ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> + import org . apache . cassandra . locator . SimpleSnitch ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class DynamicEndpointSnitchTest <nl> + { <nl> + @ Test <nl> + public void testSnitch ( ) throws UnknownHostException , InterruptedException <nl> + { <nl> + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; <nl> + InetAddress self = FBUtilities . getLocalAddress ( ) ; <nl> + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; <nl> + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; <nl> + <nl> + / / first , make all hosts equal <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + <nl> + Thread . sleep ( 1500 ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host1 a little worse <nl> + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host2 a little worse <nl> + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host3 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host3 the worst <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + / / make host3 equal to the others <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / . circleci / config . yml b / . circleci / config . yml 
 index f881b70 . . 13bc11d 100644 
 - - - a / . circleci / config . yml 
 + + + b / . circleci / config . yml 
 @ @ - 58 , 16 + 58 , 16 @ @ with _ dtest _ jobs _ only : & with _ dtest _ jobs _ only 
 - build 
 # Set env _ settings , env _ vars , and workflows / build _ and _ run _ tests based on environment 
 env _ settings : & env _ settings 
 - < < : * default _ env _ settings 
 - # < < : * high _ capacity _ env _ settings 
 + # < < : * default _ env _ settings 
 + < < : * high _ capacity _ env _ settings 
 env _ vars : & env _ vars 
 - < < : * resource _ constrained _ env _ vars 
 - # < < : * high _ capacity _ env _ vars 
 + # < < : * resource _ constrained _ env _ vars 
 + < < : * high _ capacity _ env _ vars 
 workflows : 
 version : 2 
 - build _ and _ run _ tests : * default _ jobs 
 + # build _ and _ run _ tests : * default _ jobs 
 # build _ and _ run _ tests : * with _ dtest _ jobs _ only 
 - # build _ and _ run _ tests : * with _ dtest _ jobs 
 + build _ and _ run _ tests : * with _ dtest _ jobs 
 docker _ image : & docker _ image kjellman / cassandra - test : 0 . 4 . 3 
 version : 2 
 jobs : 
 diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 40b18ae . . 9e7a599 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add optional startup delay to wait until peers are ready ( CASSANDRA - 13993 ) 
 * Add a few options to nodetool verify ( CASSANDRA - 14201 ) 
 * CVE - 2017 - 5929 Security vulnerability and redefine default log rotation policy ( CASSANDRA - 14183 ) 
 * Use JVM default SSL validation algorithm instead of custom default ( CASSANDRA - 13259 ) 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 875751b . . ad91a9b 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 373 , 6 + 373 , 11 @ @ public class Config 
 
 public String full _ query _ log _ dir = null ; 
 
 + / / parameters to adjust how much to delay startup until a certain amount of the cluster is connect to and marked alive 
 + public int block _ for _ peers _ percentage = 70 ; 
 + public int block _ for _ peers _ timeout _ in _ secs = 10 ; 
 + 
 + 
 / * * 
 * @ deprecated migrate to { @ link DatabaseDescriptor # isClientInitialized ( ) } 
 * / 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index ccb0a30 . . 2e772c5 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 2522 , 4 + 2522 , 14 @ @ public class DatabaseDescriptor 
 { 
 return conf . full _ query _ log _ dir ; 
 } 
 + 
 + public static int getBlockForPeersPercentage ( ) 
 + { 
 + return conf . block _ for _ peers _ percentage ; 
 + } 
 + 
 + public static int getBlockForPeersTimeoutInSeconds ( ) 
 + { 
 + return conf . block _ for _ peers _ timeout _ in _ secs ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / net / MessageOut . java b / src / java / org / apache / cassandra / net / MessageOut . java 
 index 7d3c0af . . 236a770 100644 
 - - - a / src / java / org / apache / cassandra / net / MessageOut . java 
 + + + b / src / java / org / apache / cassandra / net / MessageOut . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; 
 import org . apache . cassandra . tracing . Tracing ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 97 , 6 + 98 , 11 @ @ public class MessageOut < T > 
 public final List < Object > parameters ; 
 
 / * * 
 + * Allows sender to explicitly state which connection type the message should be sent on . 
 + * / 
 + public final ConnectionType connectionType ; 
 + 
 + / * * 
 * Memoization of the serialized size of the just the payload . 
 * / 
 private int payloadSerializedSize = - 1 ; 
 @ @ - 122 , 24 + 128 , 33 @ @ public class MessageOut < T > 
 this ( verb , 
 payload , 
 serializer , 
 - isTracing ( ) 
 - ? Tracing . instance . getTraceHeaders ( ) 
 - : ImmutableList . of ( ) ) ; 
 + isTracing ( ) ? Tracing . instance . getTraceHeaders ( ) : ImmutableList . of ( ) , 
 + null ) ; 
 + } 
 + 
 + public MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , ConnectionType connectionType ) 
 + { 
 + this ( verb , 
 + payload , 
 + serializer , 
 + isTracing ( ) ? Tracing . instance . getTraceHeaders ( ) : ImmutableList . of ( ) , 
 + connectionType ) ; 
 } 
 
 - private MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters ) 
 + private MessageOut ( MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters , ConnectionType connectionType ) 
 { 
 - this ( FBUtilities . getBroadcastAddressAndPort ( ) , verb , payload , serializer , parameters ) ; 
 + this ( FBUtilities . getBroadcastAddressAndPort ( ) , verb , payload , serializer , parameters , connectionType ) ; 
 } 
 
 @ VisibleForTesting 
 - public MessageOut ( InetAddressAndPort from , MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters ) 
 + public MessageOut ( InetAddressAndPort from , MessagingService . Verb verb , T payload , IVersionedSerializer < T > serializer , List < Object > parameters , ConnectionType connectionType ) 
 { 
 this . from = from ; 
 this . verb = verb ; 
 this . payload = payload ; 
 this . serializer = serializer ; 
 this . parameters = parameters ; 
 + this . connectionType = connectionType ; 
 } 
 
 public < VT > MessageOut < T > withParameter ( ParameterType type , VT value ) 
 @ @ - 148 , 7 + 163 , 7 @ @ public class MessageOut < T > 
 newParameters . addAll ( parameters ) ; 
 newParameters . add ( type ) ; 
 newParameters . add ( value ) ; 
 - return new MessageOut < T > ( verb , payload , serializer , newParameters ) ; 
 + return new MessageOut < T > ( verb , payload , serializer , newParameters , connectionType ) ; 
 } 
 
 public Stage getStage ( ) 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 8fdb395 . . 573cf7d 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 35 , 7 + 35 , 6 @ @ import java . util . concurrent . ConcurrentMap ; 
 import java . util . concurrent . CopyOnWriteArraySet ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 - 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 @ @ - 255 , 7 + 254 , 10 @ @ public final class MessagingService implements MessagingServiceMBean 
 return DatabaseDescriptor . getRangeRpcTimeout ( ) ; 
 } 
 } , 
 - / / remember to add new verbs at the end , since we serialize by ordinal 
 + PING ( ) , 
 + 
 + / / add new verbs after the existing verbs , but * before * the UNUSED verbs , since we serialize by ordinal . 
 + / / UNUSED verbs serve as padding for backwards compatability where a previous version needs to validate a verb from the future . 
 UNUSED _ 1 , 
 UNUSED _ 2 , 
 UNUSED _ 3 , 
 @ @ - 263 , 7 + 265 , 7 @ @ public final class MessagingService implements MessagingServiceMBean 
 UNUSED _ 5 , 
 ; 
 
 - private int id ; 
 + private final int id ; 
 Verb ( ) 
 { 
 id = ordinal ( ) ; 
 @ @ - 291 , 7 + 293 , 11 @ @ public final class MessagingService implements MessagingServiceMBean 
 static 
 { 
 for ( Verb v : values ( ) ) 
 + { 
 + if ( idToVerbMap . containsKey ( v . getId ( ) ) ) 
 + throw new IllegalArgumentException ( " cannot have two verbs that map to the same id : " + v + " and " + v . getId ( ) ) ; 
 idToVerbMap . put ( v . getId ( ) , v ) ; 
 + } 
 } 
 
 public static Verb fromId ( int id ) 
 @ @ - 347 , 6 + 353 , 8 @ @ public final class MessagingService implements MessagingServiceMBean 
 put ( Verb . UNUSED _ 1 , Stage . INTERNAL _ RESPONSE ) ; 
 put ( Verb . UNUSED _ 2 , Stage . INTERNAL _ RESPONSE ) ; 
 put ( Verb . UNUSED _ 3 , Stage . INTERNAL _ RESPONSE ) ; 
 + 
 + put ( Verb . PING , Stage . READ ) ; 
 } } ; 
 
 / * * 
 @ @ - 385 , 6 + 393 , 8 @ @ public final class MessagingService implements MessagingServiceMBean 
 put ( Verb . HINT , HintMessage . serializer ) ; 
 put ( Verb . BATCH _ STORE , Batch . serializer ) ; 
 put ( Verb . BATCH _ REMOVE , UUIDSerializer . serializer ) ; 
 + 
 + put ( Verb . PING , PingMessage . serializer ) ; 
 } } ; 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / net / PingMessage . java b / src / java / org / apache / cassandra / net / PingMessage . java 
 new file mode 100644 
 index 0000000 . . 4a19f22 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / PingMessage . java 
 @ @ - 0 , 0 + 1 , 82 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . IOException ; 
 + 
 + import org . apache . cassandra . hints . HintResponse ; 
 + import org . apache . cassandra . io . IVersionedSerializer ; 
 + import org . apache . cassandra . io . util . DataInputPlus ; 
 + import org . apache . cassandra . io . util . DataOutputPlus ; 
 + import org . apache . cassandra . net . async . OutboundConnectionIdentifier ; 
 + import org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; 
 + 
 + / * * 
 + * Conceptually the same as { @ link org . apache . cassandra . gms . EchoMessage } , but indicates to the recipient which 
 + * { @ link ConnectionType } should be used for the response . 
 + * / 
 + public class PingMessage 
 + { 
 + public static IVersionedSerializer < PingMessage > serializer = new PingMessageSerializer ( ) ; 
 + 
 + public static final PingMessage smallChannelMessage = new PingMessage ( ConnectionType . SMALL _ MESSAGE ) ; 
 + public static final PingMessage largeChannelMessage = new PingMessage ( ConnectionType . LARGE _ MESSAGE ) ; 
 + public static final PingMessage gossipChannelMessage = new PingMessage ( ConnectionType . GOSSIP ) ; 
 + 
 + public final ConnectionType connectionType ; 
 + 
 + public PingMessage ( ConnectionType connectionType ) 
 + { 
 + this . connectionType = connectionType ; 
 + } 
 + 
 + public static class PingMessageSerializer implements IVersionedSerializer < PingMessage > 
 + { 
 + public void serialize ( PingMessage t , DataOutputPlus out , int version ) throws IOException 
 + { 
 + out . writeByte ( t . connectionType . getId ( ) ) ; 
 + } 
 + 
 + public PingMessage deserialize ( DataInputPlus in , int version ) throws IOException 
 + { 
 + ConnectionType connectionType = ConnectionType . fromId ( in . readByte ( ) ) ; 
 + 
 + / / if we ever create a new connection type , then during a rolling upgrade , the old nodes won ' t know about 
 + / / the new connection type ( as it won ' t recognize the id ) , so just default to the small message type . 
 + if ( connectionType = = null ) 
 + connectionType = ConnectionType . SMALL _ MESSAGE ; 
 + 
 + switch ( connectionType ) 
 + { 
 + case LARGE _ MESSAGE : 
 + return largeChannelMessage ; 
 + case GOSSIP : 
 + return gossipChannelMessage ; 
 + case SMALL _ MESSAGE : 
 + default : 
 + return smallChannelMessage ; 
 + } 
 + } 
 + 
 + public long serializedSize ( PingMessage t , int version ) 
 + { 
 + return 1 ; 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / PingVerbHandler . java b / src / java / org / apache / cassandra / net / PingVerbHandler . java 
 new file mode 100644 
 index 0000000 . . d959b91 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / PingVerbHandler . java 
 @ @ - 0 , 0 + 1 , 31 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + public class PingVerbHandler implements IVerbHandler < PingMessage > 
 + { 
 + @ Override 
 + public void doVerb ( MessageIn < PingMessage > message , int id ) 
 + { 
 + MessageOut < PongMessage > msg = new MessageOut < > ( MessagingService . Verb . REQUEST _ RESPONSE , PongMessage . instance , 
 + PongMessage . serializer , 
 + message . payload . connectionType ) ; 
 + MessagingService . instance ( ) . sendReply ( msg , id , message . from ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / PongMessage . java b / src / java / org / apache / cassandra / net / PongMessage . java 
 new file mode 100644 
 index 0000000 . . bb89cdf 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / PongMessage . java 
 @ @ - 0 , 0 + 1 , 50 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . IOException ; 
 + 
 + import org . apache . cassandra . io . IVersionedSerializer ; 
 + import org . apache . cassandra . io . util . DataInputPlus ; 
 + import org . apache . cassandra . io . util . DataOutputPlus ; 
 + 
 + public class PongMessage 
 + { 
 + public static final PongMessage instance = new PongMessage ( ) ; 
 + public static IVersionedSerializer < PongMessage > serializer = new PongMessage . PongMessageSerializer ( ) ; 
 + 
 + private PongMessage ( ) 
 + { } 
 + 
 + public static class PongMessageSerializer implements IVersionedSerializer < PongMessage > 
 + { 
 + public void serialize ( PongMessage t , DataOutputPlus out , int version ) throws IOException 
 + { } 
 + 
 + public PongMessage deserialize ( DataInputPlus in , int version ) throws IOException 
 + { 
 + return instance ; 
 + } 
 + 
 + public long serializedSize ( PongMessage t , int version ) 
 + { 
 + return 0 ; 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java b / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java 
 new file mode 100644 
 index 0000000 . . f22ab48 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / StartupClusterConnectivityChecker . java 
 @ @ - 0 , 0 + 1 , 171 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . util . Set ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . function . Predicate ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . util . concurrent . Uninterruptibles ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . net . async . OutboundConnectionIdentifier ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import static org . apache . cassandra . net . MessagingService . Verb . PING ; 
 + 
 + public class StartupClusterConnectivityChecker 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( StartupClusterConnectivityChecker . class ) ; 
 + 
 + enum State { CONTINUE , FINISH _ SUCCESS , FINISH _ TIMEOUT } 
 + 
 + private final int targetPercent ; 
 + private final int timeoutSecs ; 
 + private final Predicate < InetAddressAndPort > gossipStatus ; 
 + 
 + public StartupClusterConnectivityChecker ( int targetPercent , int timeoutSecs , Predicate < InetAddressAndPort > gossipStatus ) 
 + { 
 + if ( targetPercent < 0 ) 
 + { 
 + targetPercent = 0 ; 
 + } 
 + else if ( targetPercent > 100 ) 
 + { 
 + targetPercent = 100 ; 
 + } 
 + this . targetPercent = targetPercent ; 
 + 
 + if ( timeoutSecs < 0 ) 
 + { 
 + timeoutSecs = 1 ; 
 + } 
 + else if ( timeoutSecs > 100 ) 
 + { 
 + logger . warn ( " setting the block - for - peers timeout ( in seconds ) to { } might be a bit excessive , but using it nonetheless " , timeoutSecs ) ; 
 + } 
 + this . timeoutSecs = timeoutSecs ; 
 + 
 + this . gossipStatus = gossipStatus ; 
 + } 
 + 
 + public void execute ( Set < InetAddressAndPort > peers ) 
 + { 
 + if ( peers = = null | | targetPercent = = 0 ) 
 + return ; 
 + 
 + / / remove current node from the set 
 + peers = peers . stream ( ) 
 + . filter ( peer - > ! peer . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) 
 + . collect ( Collectors . toSet ( ) ) ; 
 + 
 + / / don ' t block if there ' s no other nodes in the cluster ( or we don ' t know about them ) 
 + if ( peers . size ( ) < = 0 ) 
 + return ; 
 + 
 + logger . info ( " choosing to block until { } % of peers are marked alive and connections are established ; max time to wait = { } seconds " , 
 + targetPercent , timeoutSecs ) ; 
 + 
 + / / first , send out a ping message to open up the non - gossip connections 
 + final AtomicInteger connectedCount = sendPingMessages ( peers ) ; 
 + 
 + final long startNanos = System . nanoTime ( ) ; 
 + final long expirationNanos = startNanos + TimeUnit . SECONDS . toNanos ( timeoutSecs ) ; 
 + int completedRounds = 0 ; 
 + while ( checkStatus ( peers , connectedCount , startNanos , expirationNanos < System . nanoTime ( ) , completedRounds ) = = State . CONTINUE ) 
 + { 
 + completedRounds + + ; 
 + Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . MICROSECONDS ) ; 
 + } 
 + } 
 + 
 + State checkStatus ( Set < InetAddressAndPort > peers , AtomicInteger connectedCount , final long startNanos , boolean beyondExpiration , final int completedRounds ) 
 + { 
 + long currentAlive = peers . stream ( ) . filter ( gossipStatus ) . count ( ) ; 
 + float currentAlivePercent = ( ( float ) currentAlive / ( float ) peers . size ( ) ) * 100 ; 
 + 
 + / / assume two connections to remote host that we care to track here ( small msg & large msg ) 
 + final int totalConnectionsSize = peers . size ( ) * 2 ; 
 + final int connectionsCount = connectedCount . get ( ) ; 
 + float currentConnectedPercent = ( ( float ) connectionsCount / ( float ) totalConnectionsSize ) * 100 ; 
 + 
 + if ( currentAlivePercent > = targetPercent & & currentConnectedPercent > = targetPercent ) 
 + { 
 + logger . info ( " after { } milliseconds , found { } % ( { } / { } ) of peers as marked alive , " + 
 + " and { } % ( { } / { } ) of peers as connected , " + 
 + " both of which are above the desired threshold of { } % " , 
 + TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - startNanos ) , 
 + currentAlivePercent , currentAlive , peers . size ( ) , 
 + currentConnectedPercent , connectionsCount , totalConnectionsSize , 
 + targetPercent ) ; 
 + return State . FINISH _ SUCCESS ; 
 + } 
 + 
 + / / perform at least two rounds of checking , else this is kinda useless ( and the operator set the aliveTimeoutSecs too low ) 
 + if ( completedRounds > = 2 & & beyondExpiration ) 
 + { 
 + logger . info ( " after { } milliseconds , found { } % ( { } / { } ) of peers as marked alive , " + 
 + " and { } % ( { } / { } ) of peers as connected , " + 
 + " one or both of which is below the desired threshold of { } % " , 
 + TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - startNanos ) , 
 + currentAlivePercent , currentAlive , peers . size ( ) , 
 + currentConnectedPercent , connectionsCount , totalConnectionsSize , 
 + targetPercent ) ; 
 + return State . FINISH _ TIMEOUT ; 
 + } 
 + return State . CONTINUE ; 
 + } 
 + 
 + / * * 
 + * Sends a " connection warmup " message to each peer in the collection , on every { @ link OutboundConnectionIdentifier . ConnectionType } 
 + * used for internode messaging . 
 + * / 
 + private AtomicInteger sendPingMessages ( Set < InetAddressAndPort > peers ) 
 + { 
 + AtomicInteger connectedCount = new AtomicInteger ( 0 ) ; 
 + IAsyncCallback responseHandler = new IAsyncCallback ( ) 
 + { 
 + @ Override 
 + public boolean isLatencyForSnitch ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public void response ( MessageIn msg ) 
 + { 
 + connectedCount . incrementAndGet ( ) ; 
 + } 
 + } ; 
 + 
 + MessageOut < PingMessage > smallChannelMessageOut = new MessageOut < > ( PING , PingMessage . smallChannelMessage , PingMessage . serializer ) ; 
 + MessageOut < PingMessage > largeChannelMessageOut = new MessageOut < > ( PING , PingMessage . largeChannelMessage , PingMessage . serializer ) ; 
 + for ( InetAddressAndPort peer : peers ) 
 + { 
 + MessagingService . instance ( ) . sendRR ( smallChannelMessageOut , peer , responseHandler ) ; 
 + MessagingService . instance ( ) . sendRR ( largeChannelMessageOut , peer , responseHandler ) ; 
 + } 
 + 
 + return connectedCount ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java b / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java 
 index f3cb554 . . e309065 100644 
 - - - a / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java 
 + + + b / src / java / org / apache / cassandra / net / async / OutboundConnectionIdentifier . java 
 @ @ - 18 , 9 + 18 , 8 @ @ 
 
 package org . apache . cassandra . net . async ; 
 
 - import java . net . InetAddress ; 
 - import java . net . InetSocketAddress ; 
 - 
 + import com . carrotsearch . hppc . IntObjectMap ; 
 + import com . carrotsearch . hppc . IntObjectOpenHashMap ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 
 / * * 
 @ @ - 32 , 9 + 31 , 34 @ @ import org . apache . cassandra . locator . InetAddressAndPort ; 
 * / 
 public class OutboundConnectionIdentifier 
 { 
 - enum ConnectionType 
 + public enum ConnectionType 
 { 
 - GOSSIP , LARGE _ MESSAGE , SMALL _ MESSAGE , STREAM 
 + GOSSIP ( 0 ) , LARGE _ MESSAGE ( 1 ) , SMALL _ MESSAGE ( 2 ) , STREAM ( 3 ) ; 
 + 
 + private final int id ; 
 + 
 + ConnectionType ( int id ) 
 + { 
 + this . id = id ; 
 + } 
 + 
 + public int getId ( ) 
 + { 
 + return id ; 
 + } 
 + 
 + private static final IntObjectMap < ConnectionType > idMap = new IntObjectOpenHashMap < > ( values ( ) . length ) ; 
 + static 
 + { 
 + for ( ConnectionType type : values ( ) ) 
 + idMap . put ( type . id , type ) ; 
 + } 
 + 
 + public static ConnectionType fromId ( int id ) 
 + { 
 + return idMap . get ( id ) ; 
 + } 
 + 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java b / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java 
 index 28775ef . . 064131b 100644 
 - - - a / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java 
 + + + b / src / java / org / apache / cassandra / net / async / OutboundMessagingConnection . java 
 @ @ - 479 , 7 + 479 , 7 @ @ public class OutboundMessagingConnection 
 { 
 case SUCCESS : 
 assert result . channelWriter ! = null ; 
 - logger . debug ( " successfully connected to { } , conmpress = { } , coalescing = { } " , connectionId , 
 + logger . debug ( " successfully connected to { } , compress = { } , coalescing = { } " , connectionId , 
 shouldCompressConnection ( connectionId . local ( ) , connectionId . remote ( ) ) , 
 coalescingStrategy . isPresent ( ) ? coalescingStrategy . get ( ) : CoalescingStrategies . Strategy . DISABLED ) ; 
 if ( state . get ( ) = = State . CLOSED ) 
 diff - - git a / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java b / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java 
 index c701229 . . 14650a7 100644 
 - - - a / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java 
 + + + b / src / java / org / apache / cassandra / net / async / OutboundMessagingPool . java 
 @ @ - 18 , 7 + 18 , 6 @ @ 
 
 package org . apache . cassandra . net . async ; 
 
 - import java . net . InetSocketAddress ; 
 import java . util . Optional ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 @ @ - 101 , 14 + 100 , 21 @ @ public class OutboundMessagingPool 
 @ VisibleForTesting 
 public OutboundMessagingConnection getConnection ( MessageOut msg ) 
 { 
 - / / optimize for the common path ( the small message channel ) 
 - if ( Stage . GOSSIP ! = msg . getStage ( ) ) 
 + if ( msg . connectionType = = null ) 
 { 
 - return msg . serializedSize ( smallMessageChannel . getTargetVersion ( ) ) < LARGE _ MESSAGE _ THRESHOLD 
 - ? smallMessageChannel 
 - : largeMessageChannel ; 
 + / / optimize for the common path ( the small message channel ) 
 + if ( Stage . GOSSIP ! = msg . getStage ( ) ) 
 + { 
 + return msg . serializedSize ( smallMessageChannel . getTargetVersion ( ) ) < LARGE _ MESSAGE _ THRESHOLD 
 + ? smallMessageChannel 
 + : largeMessageChannel ; 
 + } 
 + return gossipChannel ; 
 + } 
 + else 
 + { 
 + return getConnection ( msg . connectionType ) ; 
 } 
 - return gossipChannel ; 
 } 
 
 / * * 
 @ @ - 138 , 20 + 144 , 17 @ @ public class OutboundMessagingPool 
 smallMessageChannel . close ( softClose ) ; 
 } 
 
 - / * * 
 - * For testing purposes only . 
 - * / 
 @ VisibleForTesting 
 - OutboundMessagingConnection getConnection ( ConnectionType connectionType ) 
 + final OutboundMessagingConnection getConnection ( ConnectionType connectionType ) 
 { 
 switch ( connectionType ) 
 { 
 - case GOSSIP : 
 - return gossipChannel ; 
 - case LARGE _ MESSAGE : 
 - return largeMessageChannel ; 
 case SMALL _ MESSAGE : 
 return smallMessageChannel ; 
 + case LARGE _ MESSAGE : 
 + return largeMessageChannel ; 
 + case GOSSIP : 
 + return gossipChannel ; 
 default : 
 throw new IllegalArgumentException ( " unsupported connection type : " + connectionType ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 130f3fd . . 295a33b 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 25 , 7 + 25 , 10 @ @ import java . net . InetAddress ; 
 import java . net . URL ; 
 import java . net . UnknownHostException ; 
 import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . concurrent . TimeUnit ; 
 + import java . util . stream . Collectors ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 import javax . management . StandardMBean ; 
 @ @ - 47 , 6 + 50 , 7 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . net . StartupClusterConnectivityChecker ; 
 import org . apache . cassandra . schema . TableMetadata ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . schema . Schema ; 
 @ @ - 491 , 6 + 495 , 12 @ @ public class CassandraDaemon 
 * / 
 public void start ( ) 
 { 
 + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( DatabaseDescriptor . getBlockForPeersPercentage ( ) , 
 + DatabaseDescriptor . getBlockForPeersTimeoutInSeconds ( ) , 
 + Gossiper . instance : : isAlive ) ; 
 + Set < InetAddressAndPort > peers = Gossiper . instance . getEndpointStates ( ) . stream ( ) . map ( Map . Entry : : getKey ) . collect ( Collectors . toSet ( ) ) ; 
 + connectivityChecker . execute ( peers ) ; 
 + 
 String nativeFlag = System . getProperty ( " cassandra . start _ native _ transport " ) ; 
 if ( ( nativeFlag ! = null & & Boolean . parseBoolean ( nativeFlag ) ) | | ( nativeFlag = = null & & DatabaseDescriptor . startNativeTransport ( ) ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / EchoVerbHandler . java b / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 index d0c435e . . 1cc52e9 100644 
 - - - a / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / service / EchoVerbHandler . java 
 @ @ - 26 , 16 + 26 , 20 @ @ import org . apache . cassandra . net . IVerbHandler ; 
 import org . apache . cassandra . net . MessageIn ; 
 import org . apache . cassandra . net . MessageOut ; 
 import org . apache . cassandra . net . MessagingService ; 
 + 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import static org . apache . cassandra . net . async . OutboundConnectionIdentifier . ConnectionType ; 
 + 
 public class EchoVerbHandler implements IVerbHandler < EchoMessage > 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( EchoVerbHandler . class ) ; 
 
 public void doVerb ( MessageIn < EchoMessage > message , int id ) 
 { 
 - MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , EchoMessage . serializer ) ; 
 + MessageOut < EchoMessage > echoMessage = new MessageOut < EchoMessage > ( MessagingService . Verb . REQUEST _ RESPONSE , EchoMessage . instance , 
 + EchoMessage . serializer , ConnectionType . GOSSIP ) ; 
 logger . trace ( " Sending a EchoMessage reply { } " , message . from ) ; 
 MessagingService . instance ( ) . sendReply ( echoMessage , id , message . from ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index d465431 . . 51b77a6 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 92 , 6 + 92 , 7 @ @ import org . apache . cassandra . schema . SchemaVersionVerbHandler ; 
 import org . apache . cassandra . schema . TableMetadata ; 
 import org . apache . cassandra . schema . TableMetadataRef ; 
 import org . apache . cassandra . schema . ViewMetadata ; 
 + import org . apache . cassandra . repair . RepairMessageVerbHandler ; 
 import org . apache . cassandra . service . paxos . CommitVerbHandler ; 
 import org . apache . cassandra . service . paxos . PrepareVerbHandler ; 
 import org . apache . cassandra . service . paxos . ProposeVerbHandler ; 
 @ @ - 301 , 6 + 302 , 8 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BATCH _ STORE , new BatchStoreVerbHandler ( ) ) ; 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BATCH _ REMOVE , new BatchRemoveVerbHandler ( ) ) ; 
 + 
 + MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . PING , new PingVerbHandler ( ) ) ; 
 } 
 
 public void registerDaemon ( CassandraDaemon daemon ) 
 diff - - git a / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java b / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java 
 new file mode 100644 
 index 0000000 . . 12f54c6 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / net / StartupClusterConnectivityCheckerTest . java 
 @ @ - 0 , 0 + 1 , 129 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . net . UnknownHostException ; 
 + import java . util . HashSet ; 
 + import java . util . Set ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . function . Predicate ; 
 + 
 + import com . google . common . net . InetAddresses ; 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + 
 + public class StartupClusterConnectivityCheckerTest 
 + { 
 + @ Test 
 + public void testConnectivity _ SimpleHappyPath ( ) throws UnknownHostException 
 + { 
 + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; 
 + int count = 10 ; 
 + Set < InetAddressAndPort > peers = createNodes ( count ) ; 
 + Assert . assertEquals ( StartupClusterConnectivityChecker . State . FINISH _ SUCCESS , 
 + connectivityChecker . checkStatus ( peers , new AtomicInteger ( count * 2 ) , System . nanoTime ( ) , false , 0 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testConnectivity _ SimpleContinue ( ) throws UnknownHostException 
 + { 
 + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; 
 + int count = 10 ; 
 + Set < InetAddressAndPort > peers = createNodes ( count ) ; 
 + Assert . assertEquals ( StartupClusterConnectivityChecker . State . CONTINUE , 
 + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , false , 0 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testConnectivity _ Timeout ( ) throws UnknownHostException 
 + { 
 + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( 70 , 10 , addr - > true ) ; 
 + int count = 10 ; 
 + Set < InetAddressAndPort > peers = createNodes ( count ) ; 
 + Assert . assertEquals ( StartupClusterConnectivityChecker . State . CONTINUE , 
 + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , false , 4 ) ) ; 
 + Assert . assertEquals ( StartupClusterConnectivityChecker . State . FINISH _ TIMEOUT , 
 + connectivityChecker . checkStatus ( peers , new AtomicInteger ( 0 ) , System . nanoTime ( ) , true , 5 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testConnectivity _ SimpleUpdating ( ) throws UnknownHostException 
 + { 
 + UpdatablePredicate predicate = new UpdatablePredicate ( ) ; 
 + final int count = 100 ; 
 + final int thresholdPercentage = 70 ; 
 + StartupClusterConnectivityChecker connectivityChecker = new StartupClusterConnectivityChecker ( thresholdPercentage , 10 , predicate ) ; 
 + Set < InetAddressAndPort > peers = createNodes ( count ) ; 
 + 
 + AtomicInteger connectedCount = new AtomicInteger ( ) ; 
 + 
 + for ( int i = 0 ; i < count ; i + + ) 
 + { 
 + predicate . reset ( i ) ; 
 + connectedCount . set ( i * 2 ) ; 
 + StartupClusterConnectivityChecker . State expectedState = i < thresholdPercentage ? 
 + StartupClusterConnectivityChecker . State . CONTINUE : 
 + StartupClusterConnectivityChecker . State . FINISH _ SUCCESS ; 
 + Assert . assertEquals ( " failed on iteration " + i , 
 + expectedState , connectivityChecker . checkStatus ( peers , connectedCount , System . nanoTime ( ) , false , i ) ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * returns true until index = threshold , then returns false . 
 + * / 
 + private class UpdatablePredicate implements Predicate < InetAddressAndPort > 
 + { 
 + int index ; 
 + int threshold ; 
 + 
 + void reset ( int threshold ) 
 + { 
 + index = 0 ; 
 + this . threshold = threshold ; 
 + } 
 + 
 + @ Override 
 + public boolean test ( InetAddressAndPort inetAddressAndPort ) 
 + { 
 + index + + ; 
 + return index < = threshold ; 
 + } 
 + } 
 + 
 + private static Set < InetAddressAndPort > createNodes ( int count ) throws UnknownHostException 
 + { 
 + Set < InetAddressAndPort > nodes = new HashSet < > ( ) ; 
 + 
 + if ( count < 1 ) 
 + Assert . fail ( " need at least * one * node in the set ! " ) ; 
 + 
 + InetAddressAndPort node = InetAddressAndPort . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + nodes . add ( node ) ; 
 + for ( int i = 1 ; i < count ; i + + ) 
 + { 
 + node = InetAddressAndPort . getByAddress ( InetAddresses . increment ( node . address ) ) ; 
 + nodes . add ( node ) ; 
 + } 
 + return nodes ; 
 + } 
 + 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / service / RemoveTest . java b / test / unit / org / apache / cassandra / service / RemoveTest . java 
 index 6714a83 . . 0d39322 100644 
 - - - a / test / unit / org / apache / cassandra / service / RemoveTest . java 
 + + + b / test / unit / org / apache / cassandra / service / RemoveTest . java 
 @ @ - 161 , 7 + 161 , 7 @ @ public class RemoveTest 
 
 for ( InetAddressAndPort host : hosts ) 
 { 
 - MessageOut msg = new MessageOut ( host , MessagingService . Verb . REPLICATION _ FINISHED , null , null , Collections . < Object > emptyList ( ) ) ; 
 + MessageOut msg = new MessageOut ( host , MessagingService . Verb . REPLICATION _ FINISHED , null , null , Collections . < Object > emptyList ( ) , null ) ; 
 MessagingService . instance ( ) . sendRR ( msg , FBUtilities . getBroadcastAddressAndPort ( ) ) ; 
 } 


NEAREST DIFF:
diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 30f85a4 . . 11499a6 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler 
 # the request scheduling . The current supported option is " keyspace " 
 request _ scheduler _ id : keyspace 
 
 + # dynamic _ snitch - - This boolean controls whether the above snitch is 
 + # wrapped with a dynamic snitch , which will monitor read latencies 
 + # and avoid reading from hosts that have slowed ( due to compaction , 
 + # for instance ) 
 + dynamic _ snitch : false 
 + 
 # A ColumnFamily is the Cassandra concept closest to a relational table . 
 # 
 # Keyspaces are separate groups of ColumnFamilies . Except in very 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 2a5478e . . 315c9a4 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 71 , 6 + 71 , 7 @ @ public class Config { 
 public Integer commitlog _ sync _ period _ in _ ms ; 
 
 public String endpoint _ snitch ; 
 + public Boolean dynamic _ snitch = false ; 
 
 public String request _ scheduler ; 
 public RequestSchedulerId request _ scheduler _ id ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 0947af0 . . b5f9302 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; 
 import java . net . UnknownHostException ; 
 import java . util . * ; 
 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor 
 throw ( ConfigurationException ) e . getCause ( ) ; 
 throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; 
 } 
 - return snitch ; 
 + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; 
 } 
 
 - public static void loadSchemas ( ) throws IOException 
 + public static void loadSchemas ( ) throws IOException 
 { 
 / / we can load tables from local storage if a version is set in the system table and that acutally maps to 
 / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 index 4892281 . . 2ef4980 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; 
 
 import java . net . InetAddress ; 
 import java . util . Collection ; 
 + import java . util . Comparator ; 
 import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 
 @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch 
 
 public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 index acb1d16 . . c40f995 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch 
 { 
 public int compare ( InetAddress a1 , InetAddress a2 ) 
 { 
 - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 - return - 1 ; 
 - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 - return 1 ; 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } ; 
 + } ) ; 
 + return addresses ; 
 + } 
 
 - String addressRack = getRack ( address ) ; 
 - String a1Rack = getRack ( a1 ) ; 
 - String a2Rack = getRack ( a2 ) ; 
 - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 - return - 1 ; 
 - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 - return 1 ; 
 + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) 
 + { 
 + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 + return - 1 ; 
 + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 + return 1 ; 
 
 - String addressDatacenter = getDatacenter ( address ) ; 
 - String a1Datacenter = getDatacenter ( a1 ) ; 
 - String a2Datacenter = getDatacenter ( a2 ) ; 
 - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 - return - 1 ; 
 - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 - return 1 ; 
 + String addressRack = getRack ( address ) ; 
 + String a1Rack = getRack ( a1 ) ; 
 + String a2Rack = getRack ( a2 ) ; 
 + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 + return - 1 ; 
 + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 + return 1 ; 
 
 - return 0 ; 
 - } 
 - } ) ; 
 - return addresses ; 
 + String addressDatacenter = getDatacenter ( address ) ; 
 + String a1Datacenter = getDatacenter ( a1 ) ; 
 + String a2Datacenter = getDatacenter ( a2 ) ; 
 + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 + return - 1 ; 
 + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 + return 1 ; 
 + 
 + return 0 ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 new file mode 100644 
 index 0000000 . . cb2f03b 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 @ @ - 0 , 0 + 1 , 238 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . * ; 
 + import java . util . concurrent . LinkedBlockingDeque ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import java . lang . management . ManagementFactory ; 
 + import javax . management . MBeanServer ; 
 + import javax . management . ObjectName ; 
 + 
 + import org . apache . cassandra . net . IVerbHandler ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . ResponseVerbHandler ; 
 + import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . utils . AbstractStatsDeque ; 
 + import org . apache . cassandra . locator . IEndpointSnitch ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + import org . apache . cassandra . locator . AbstractEndpointSnitch ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + / * * 
 + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector 
 + * / 
 + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean 
 + { 
 + private static int UPDATES _ PER _ INTERVAL = 100 ; 
 + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; 
 + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; 
 + private static int WINDOW _ SIZE = 100 ; 
 + private boolean registered = false ; 
 + 
 + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; 
 + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; 
 + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; 
 + public IEndpointSnitch subsnitch ; 
 + 
 + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) 
 + { 
 + subsnitch = snitch ; 
 + TimerTask update = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + updateScores ( ) ; 
 + } 
 + } ; 
 + TimerTask reset = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try 
 + / / to read from it , which would cause its score to never change 
 + reset ( ) ; 
 + } 
 + } ; 
 + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; 
 + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; 
 + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; 
 + 
 + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; 
 + try 
 + { 
 + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getRack ( endpoint ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getDatacenter ( endpoint ) ; 
 + } 
 + 
 + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 + { 
 + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; 
 + sortByProximity ( address , list ) ; 
 + return list ; 
 + } 
 + 
 + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) 
 + { 
 + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself 
 + Collections . sort ( addresses , new Comparator < InetAddress > ( ) 
 + { 
 + public int compare ( InetAddress a1 , InetAddress a2 ) 
 + { 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } 
 + } ) ; 
 + return addresses ; 
 + } 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + Double scored1 = scores . get ( a1 ) ; 
 + Double scored2 = scores . get ( a2 ) ; 
 + 
 + if ( scored1 = = null | | scored2 = = null ) 
 + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; 
 + if ( scored1 . equals ( scored2 ) ) 
 + return 0 ; 
 + if ( scored1 < scored2 ) 
 + return 1 ; 
 + else 
 + return - 1 ; 
 + } 
 + 
 + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap 
 + { 
 + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) 
 + return ; 
 + AdaptiveLatencyTracker tracker = windows . get ( host ) ; 
 + if ( tracker = = null ) 
 + { 
 + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; 
 + tracker = windows . putIfAbsent ( host , alt ) ; 
 + if ( tracker = = null ) 
 + tracker = alt ; 
 + } 
 + tracker . add ( latency ) ; 
 + intervalupdates . getAndIncrement ( ) ; 
 + } 
 + 
 + private void updateScores ( ) / / this is expensive 
 + { 
 + if ( ! registered ) 
 + { 
 + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; 
 + if ( handler ! = null ) 
 + { 
 + handler . register ( this ) ; 
 + registered = true ; 
 + } 
 + 
 + } 
 + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) 
 + { 
 + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; 
 + } 
 + intervalupdates . set ( 0 ) ; 
 + } 
 + 
 + private void reset ( ) 
 + { 
 + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) 
 + { 
 + tracker . clear ( ) ; 
 + } 
 + } 
 + 
 + public Map < InetAddress , Double > getScores ( ) 
 + { 
 + return scores ; 
 + } 
 + } 
 + 
 + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / 
 + class AdaptiveLatencyTracker extends AbstractStatsDeque 
 + { 
 + private LinkedBlockingDeque latencies ; 
 + private final int size ; 
 + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter 
 + 
 + AdaptiveLatencyTracker ( int size ) 
 + { 
 + this . size = size ; 
 + latencies = new LinkedBlockingDeque ( size ) ; 
 + } 
 + 
 + public void add ( double i ) 
 + { 
 + latencies . offer ( i ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + latencies . clear ( ) ; 
 + } 
 + 
 + public Iterator < Double > iterator ( ) 
 + { 
 + return latencies . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return latencies . size ( ) ; 
 + } 
 + 
 + double p ( double t ) 
 + { 
 + double mean = mean ( ) ; 
 + double exponent = ( - 1 ) * ( t ) / mean ; 
 + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; 
 + } 
 + 
 + double score ( ) 
 + { 
 + double log = 0d ; 
 + if ( latencies . size ( ) > 0 ) 
 + { 
 + double probability = p ( SENTINEL _ COMPARE ) ; 
 + log = ( - 1 ) * Math . log10 ( probability ) ; 
 + } 
 + return log ; 
 + } 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 new file mode 100644 
 index 0000000 . . 26c5799 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Map ; 
 + 
 + public interface DynamicEndpointSnitchMBean { 
 + public Map < InetAddress , Double > getScores ( ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 index ca451c0 . . 091c4c2 100644 
 - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; 
 public interface IEndpointSnitch 
 { 
 / * * 
 + * returns a String repesenting the rack this endpoint belongs to 
 + * / 
 + public String getRack ( InetAddress endpoint ) ; 
 + 
 + / * * 
 + * returns a String representing the datacenter this endpoint belongs to 
 + * / 
 + public String getDatacenter ( InetAddress endpoint ) ; 
 + 
 + / * * 
 * returns a new < tt > List < / tt > sorted by proximity to the given endpoint 
 * / 
 public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch 
 * @ param subscriber the subscriber to notify 
 * / 
 public void register ( AbstractReplicationStrategy subscriber ) ; 
 + 
 + / * * 
 + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would 
 + * / 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 new file mode 100644 
 index 0000000 . . 0d97e84 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + 
 + public interface ILatencyPublisher 
 + { 
 + public void register ( ILatencySubscriber subcriber ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 new file mode 100644 
 index 0000000 . . 6cfcf33 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + 
 + public interface ILatencySubscriber 
 + { 
 + public void receiveTiming ( InetAddress address , Double latency ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 index c2fd8b5 . . dd8fb68 100644 
 - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 
 + import org . apache . commons . lang . NotImplementedException ; 
 + 
 / * * 
 * A simple endpoint snitch implementation does not sort addresses by 
 * proximity . 
 * / 
 public class SimpleSnitch extends AbstractEndpointSnitch 
 { 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 { 
 return new ArrayList < InetAddress > ( addresses ) ; 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 474d7c2 . . efd2545 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener 
 return taskCompletionMap _ . remove ( key ) ; 
 } 
 
 + public static long getRegisteredCallbackAge ( String key ) 
 + { 
 + return callbackMap _ . getAge ( key ) ; 
 + } 
 + 
 + public static long getAsyncResultAge ( String key ) 
 + { 
 + return taskCompletionMap _ . getAge ( key ) ; 
 + } 
 + 
 public static ExecutorService getDeserializationExecutor ( ) 
 { 
 return messageDeserializerExecutor _ ; 
 diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 index 020d187 . . cde87b2 100644 
 - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 @ @ - 18 , 21 + 18 , 30 @ @ 
 
 package org . apache . cassandra . net ; 
 
 + 
 + import java . util . * ; 
 + import java . net . InetAddress ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 
 - public class ResponseVerbHandler implements IVerbHandler 
 + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher 
 { 
 private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; 
 - 
 + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; 
 + 
 + 
 public void doVerb ( Message message ) 
 { 
 String messageId = message . getMessageId ( ) ; 
 IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; 
 + double age = 0 ; 
 if ( cb ! = null ) 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; 
 cb . response ( message ) ; 
 } 
 else 
 @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; 
 ar . result ( message ) ; 
 } 
 } 
 + notifySubscribers ( message . getFrom ( ) , age ) ; 
 + } 
 + 
 + private void notifySubscribers ( InetAddress host , double latency ) 
 + { 
 + for ( ILatencySubscriber subscriber : subscribers ) 
 + { 
 + subscriber . receiveTiming ( host , latency ) ; 
 + } 
 + } 
 + 
 + public void register ( ILatencySubscriber subscriber ) 
 + { 
 + subscribers . add ( subscriber ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 index dfaadf7 . . aa2c7ec 100644 
 - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > 
 return result ; 
 } 
 
 + public long getAge ( K key ) 
 + { 
 + long age = 0 ; 
 + CacheableObject < V > co = cache . get ( key ) ; 
 + if ( co ! = null ) 
 + { 
 + age = co . age ; 
 + } 
 + return age ; 
 + } 
 + 
 public int size ( ) 
 { 
 return cache . size ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 new file mode 100644 
 index 0000000 . . 62904b4 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . ArrayList ; 
 + 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . * ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 + import org . apache . cassandra . locator . SimpleSnitch ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class DynamicEndpointSnitchTest 
 + { 
 + @ Test 
 + public void testSnitch ( ) throws UnknownHostException , InterruptedException 
 + { 
 + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; 
 + InetAddress self = FBUtilities . getLocalAddress ( ) ; 
 + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; 
 + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; 
 + 
 + / / first , make all hosts equal 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + 
 + Thread . sleep ( 1500 ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host1 a little worse 
 + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host2 a little worse 
 + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host3 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host3 the worst 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + order . add ( host3 ) ; 
 + 
 + / / make host3 equal to the others 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + } 
 + }
