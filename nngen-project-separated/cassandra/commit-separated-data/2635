BLEU SCORE: 0.11598118436136108

TEST MSG: Improve PerRowSecondaryIndex performance
GENERATED MSG: simplify Map / Set usage

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 86d4e6f . . 862ea3e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 15 , 6 + 15 , 7 @ @ <nl> * Read message id as string from earlier versions ( CASSANDRA - 6840 ) <nl> * Properly use the Paxos consistency for ( non - protocol ) batch ( CASSANDRA - 6837 ) <nl> * Add paranoid disk failure option ( CASSANDRA - 6646 ) <nl> + * Improve PerRowSecondaryIndex performance ( CASSANDRA - 6876 ) <nl> Merged from 1 . 2 : <nl> * add extra SSL cipher suites ( CASSANDRA - 6613 ) <nl> * fix nodetool getsstables for blob PK ( CASSANDRA - 6803 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Keyspace . java b / src / java / org / apache / cassandra / db / Keyspace . java <nl> index 36789e2 . . f5369f9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Keyspace . java <nl> + + + b / src / java / org / apache / cassandra / db / Keyspace . java <nl> @ @ - 389 , 7 + 389 , 7 @ @ public class Keyspace <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Indexing row { } " , cfs . metadata . getKeyValidator ( ) . getString ( key . key ) ) ; <nl> <nl> - Collection < SecondaryIndex > indexes = cfs . indexManager . getIndexesByNames ( idxNames ) ; <nl> + Set < SecondaryIndex > indexes = cfs . indexManager . getIndexesByNames ( idxNames ) ; <nl> <nl> switchLock . readLock ( ) . lock ( ) ; <nl> try <nl> diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> index 7bfed33 . . 5e49966 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java <nl> @ @ - 60 , 15 + 60 , 18 @ @ public class SecondaryIndexManager <nl> * / <nl> private final ConcurrentNavigableMap < ByteBuffer , SecondaryIndex > indexesByColumn ; <nl> <nl> - <nl> / * * <nl> * Keeps a single instance of a SecondaryIndex for many columns when the index type <nl> * has isRowLevelIndex ( ) = = true <nl> * <nl> * This allows updates to happen to an entire row at once <nl> * / <nl> - private final Map < Class < ? extends SecondaryIndex > , SecondaryIndex > rowLevelIndexMap ; <nl> + private final ConcurrentMap < Class < ? extends SecondaryIndex > , SecondaryIndex > rowLevelIndexMap ; <nl> <nl> + / * * <nl> + * Keeps all secondary index instances , either per - column or per - row <nl> + * / <nl> + private final Set < SecondaryIndex > allIndexes ; <nl> <nl> / * * <nl> * The underlying column family containing the source data for these indexes <nl> @ @ - 78 , 7 + 81 , 8 @ @ public class SecondaryIndexManager <nl> public SecondaryIndexManager ( ColumnFamilyStore baseCfs ) <nl> { <nl> indexesByColumn = new ConcurrentSkipListMap < > ( ) ; <nl> - rowLevelIndexMap = new HashMap < > ( ) ; <nl> + rowLevelIndexMap = new ConcurrentHashMap < > ( ) ; <nl> + allIndexes = Collections . newSetFromMap ( new ConcurrentHashMap < SecondaryIndex , Boolean > ( ) ) ; <nl> <nl> this . baseCfs = baseCfs ; <nl> } <nl> @ @ - 104 , 16 + 108 , 14 @ @ public class SecondaryIndexManager <nl> if ( cdef . getIndexType ( ) ! = null & & ! indexedColumnNames . contains ( cdef . name ) ) <nl> addIndexedColumn ( cdef ) ; <nl> <nl> - Set < SecondaryIndex > reloadedIndexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> - if ( reloadedIndexes . add ( index ) ) <nl> - index . reload ( ) ; <nl> + for ( SecondaryIndex index : allIndexes ) <nl> + index . reload ( ) ; <nl> } <nl> <nl> public Set < String > allIndexesNames ( ) <nl> { <nl> - Set < String > names = new HashSet < > ( indexesByColumn . size ( ) ) ; <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + Set < String > names = new HashSet < > ( allIndexes . size ( ) ) ; <nl> + for ( SecondaryIndex index : allIndexes ) <nl> names . add ( index . getIndexName ( ) ) ; <nl> return names ; <nl> } <nl> @ @ - 144 , 24 + 146 , 33 @ @ public class SecondaryIndexManager <nl> logger . info ( " Index build of " + idxNames + " complete " ) ; <nl> } <nl> <nl> - public boolean indexes ( ByteBuffer name , Collection < SecondaryIndex > indexes ) <nl> + public boolean indexes ( ByteBuffer name , Set < SecondaryIndex > indexes ) <nl> { <nl> - return ! indexFor ( name , indexes ) . isEmpty ( ) ; <nl> + boolean matching = false ; <nl> + for ( SecondaryIndex index : indexes ) <nl> + { <nl> + if ( index . indexes ( name ) ) <nl> + { <nl> + matching = true ; <nl> + break ; <nl> + } <nl> + } <nl> + return matching ; <nl> } <nl> <nl> - public List < SecondaryIndex > indexFor ( ByteBuffer name , Collection < SecondaryIndex > indexes ) <nl> + public Set < SecondaryIndex > indexFor ( ByteBuffer name , Set < SecondaryIndex > indexes ) <nl> { <nl> - List < SecondaryIndex > matching = null ; <nl> + Set < SecondaryIndex > matching = null ; <nl> for ( SecondaryIndex index : indexes ) <nl> { <nl> if ( index . indexes ( name ) ) <nl> { <nl> if ( matching = = null ) <nl> - matching = new ArrayList < > ( ) ; <nl> + matching = new HashSet < > ( ) ; <nl> matching . add ( index ) ; <nl> } <nl> } <nl> - return matching = = null ? Collections . < SecondaryIndex > emptyList ( ) : matching ; <nl> + return matching = = null ? Collections . < SecondaryIndex > emptySet ( ) : matching ; <nl> } <nl> <nl> public boolean indexes ( Column column ) <nl> @ @ - 171 , 12 + 182 , 12 @ @ public class SecondaryIndexManager <nl> <nl> public boolean indexes ( ByteBuffer name ) <nl> { <nl> - return indexes ( name , indexesByColumn . values ( ) ) ; <nl> + return indexes ( name , allIndexes ) ; <nl> } <nl> <nl> - public List < SecondaryIndex > indexFor ( ByteBuffer name ) <nl> + public Set < SecondaryIndex > indexFor ( ByteBuffer name ) <nl> { <nl> - return indexFor ( name , indexesByColumn . values ( ) ) ; <nl> + return indexFor ( name , allIndexes ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 221 , 6 + 232 , 9 @ @ public class SecondaryIndexManager <nl> rowLevelIndexMap . remove ( index . getClass ( ) ) ; <nl> } <nl> <nl> + / / Remove from all indexes set : <nl> + allIndexes . remove ( index ) ; <nl> + <nl> index . removeIndex ( column ) ; <nl> SystemKeyspace . setIndexRemoved ( baseCfs . metadata . ksName , index . getNameForSystemKeyspace ( column ) ) ; <nl> } <nl> @ @ - 281 , 6 + 295 , 9 @ @ public class SecondaryIndexManager <nl> / / until the index is actually built before using in queries . <nl> indexesByColumn . put ( cdef . name , index ) ; <nl> <nl> + / / Add to all indexes set : <nl> + allIndexes . add ( index ) ; <nl> + <nl> / / if we ' re just linking in the index to indexedColumns on an <nl> / / already - built index post - restart , we ' re done <nl> if ( index . isIndexBuilt ( cdef . name ) ) <nl> @ @ - 304 , 7 + 321 , 7 @ @ public class SecondaryIndexManager <nl> * / <nl> public void invalidate ( ) <nl> { <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + for ( SecondaryIndex index : allIndexes ) <nl> index . invalidate ( ) ; <nl> } <nl> <nl> @ @ - 313 , 7 + 330 , 7 @ @ public class SecondaryIndexManager <nl> * / <nl> public void flushIndexesBlocking ( ) <nl> { <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + for ( SecondaryIndex index : allIndexes ) <nl> index . forceBlockingFlush ( ) ; <nl> } <nl> <nl> @ @ - 338 , 11 + 355 , 11 @ @ public class SecondaryIndexManager <nl> / * * <nl> * @ return all CFS from indexes which use a backing CFS internally ( KEYS ) <nl> * / <nl> - public Collection < ColumnFamilyStore > getIndexesBackedByCfs ( ) <nl> + public Set < ColumnFamilyStore > getIndexesBackedByCfs ( ) <nl> { <nl> - ArrayList < ColumnFamilyStore > cfsList = new ArrayList < > ( ) ; <nl> + Set < ColumnFamilyStore > cfsList = new HashSet < > ( ) ; <nl> <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + for ( SecondaryIndex index : allIndexes ) <nl> { <nl> ColumnFamilyStore cfs = index . getIndexCfs ( ) ; <nl> if ( cfs ! = null ) <nl> @ @ - 355 , 11 + 372 , 11 @ @ public class SecondaryIndexManager <nl> / * * <nl> * @ return all indexes which do * not * use a backing CFS internally <nl> * / <nl> - public Collection < SecondaryIndex > getIndexesNotBackedByCfs ( ) <nl> + public Set < SecondaryIndex > getIndexesNotBackedByCfs ( ) <nl> { <nl> / / we use identity map because per row indexes use same instance across many columns <nl> Set < SecondaryIndex > indexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + for ( SecondaryIndex index : allIndexes ) <nl> if ( index . getIndexCfs ( ) = = null ) <nl> indexes . add ( index ) ; <nl> return indexes ; <nl> @ @ - 368 , 12 + 385 , 9 @ @ public class SecondaryIndexManager <nl> / * * <nl> * @ return all of the secondary indexes without distinction to the ( non - ) backed by secondary ColumnFamilyStore . <nl> * / <nl> - public Collection < SecondaryIndex > getIndexes ( ) <nl> + public Set < SecondaryIndex > getIndexes ( ) <nl> { <nl> - / / we use identity map because per row indexes use same instance across many columns <nl> - Set < SecondaryIndex > indexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; <nl> - indexes . addAll ( indexesByColumn . values ( ) ) ; <nl> - return indexes ; <nl> + return allIndexes ; <nl> } <nl> <nl> / * * <nl> @ @ - 406 , 7 + 420 , 7 @ @ public class SecondaryIndexManager <nl> / / Update entire row only once per row level index <nl> Set < Class < ? extends SecondaryIndex > > appliedRowLevelIndexes = null ; <nl> <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + for ( SecondaryIndex index : allIndexes ) <nl> { <nl> if ( index instanceof PerRowSecondaryIndex ) <nl> { <nl> @ @ - 538 , 10 + 552 , 10 @ @ public class SecondaryIndexManager <nl> return indexSearchers . get ( 0 ) . search ( filter ) ; <nl> } <nl> <nl> - public Collection < SecondaryIndex > getIndexesByNames ( Set < String > idxNames ) <nl> + public Set < SecondaryIndex > getIndexesByNames ( Set < String > idxNames ) <nl> { <nl> - List < SecondaryIndex > result = new ArrayList < > ( ) ; <nl> - for ( SecondaryIndex index : indexesByColumn . values ( ) ) <nl> + Set < SecondaryIndex > result = new HashSet < > ( ) ; <nl> + for ( SecondaryIndex index : allIndexes ) <nl> if ( idxNames . contains ( index . getIndexName ( ) ) ) <nl> result . add ( index ) ; <nl> return result ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index dfb77d6 . . 2ea901f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 3 + 1 , 7 @ @ <nl> + 1 . 1 . 5 <nl> + * Log ( info ) schema changes ( CASSANDRA - 4547 ) <nl> + <nl> + <nl> 1 . 1 . 4 <nl> * fix offline scrub to catch > = out of order rows ( CASSANDRA - 4411 ) <nl> * fix cassandra - env . sh on RHEL and other non - dash - based systems <nl> diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> index eedb20d . . 1d4401a 100644 <nl> - - - a / src / java / org / apache / cassandra / service / MigrationManager . java <nl> + + + b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> @ @ - 123 , 6 + 123 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> if ( Schema . instance . getTableDefinition ( ksm . name ) ! = null ) <nl> throw new ConfigurationException ( String . format ( " Cannot add already existing keyspace ' % s ' . " , ksm . name ) ) ; <nl> <nl> + logger . info ( String . format ( " Create new Keyspace : % s " , ksm ) ) ; <nl> announce ( ksm . toSchema ( FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> @ @ - 136 , 6 + 137 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> else if ( ksm . cfMetaData ( ) . containsKey ( cfm . cfName ) ) <nl> throw new ConfigurationException ( String . format ( " Cannot add already existing column family ' % s ' to keyspace ' % s ' . " , cfm . cfName , cfm . ksName ) ) ; <nl> <nl> + logger . info ( String . format ( " Create new ColumnFamily : % s " , cfm ) ) ; <nl> announce ( cfm . toSchema ( FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> @ @ - 147 , 6 + 149 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> if ( oldKsm = = null ) <nl> throw new ConfigurationException ( String . format ( " Cannot update non existing keyspace ' % s ' . " , ksm . name ) ) ; <nl> <nl> + logger . info ( String . format ( " Update Keyspace ' % s ' From % s To % s " , ksm . name , oldKsm , ksm ) ) ; <nl> announce ( oldKsm . toSchemaUpdate ( ksm , FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> @ @ - 158 , 6 + 161 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> if ( oldCfm = = null ) <nl> throw new ConfigurationException ( String . format ( " Cannot update non existing column family ' % s ' in keyspace ' % s ' . " , cfm . cfName , cfm . ksName ) ) ; <nl> <nl> + logger . info ( String . format ( " Update ColumnFamily ' % s / % s ' From % s To % s " , cfm . ksName , cfm . cfName , oldCfm , cfm ) ) ; <nl> announce ( oldCfm . toSchemaUpdate ( cfm , FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> @ @ - 167 , 6 + 171 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> if ( oldKsm = = null ) <nl> throw new ConfigurationException ( String . format ( " Cannot drop non existing keyspace ' % s ' . " , ksName ) ) ; <nl> <nl> + logger . info ( String . format ( " Drop Keyspace ' % s ' " , oldKsm . name ) ) ; <nl> announce ( oldKsm . dropFromSchema ( FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> @ @ - 176 , 6 + 181 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> if ( oldCfm = = null ) <nl> throw new ConfigurationException ( String . format ( " Cannot drop non existing column family ' % s ' in keyspace ' % s ' . " , cfName , ksName ) ) ; <nl> <nl> + logger . info ( String . format ( " Drop ColumnFamily ' % s / % s ' " , oldCfm . ksName , oldCfm . cfName ) ) ; <nl> announce ( oldCfm . dropFromSchema ( FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 86d4e6f . . 862ea3e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 15 , 6 + 15 , 7 @ @ 
 * Read message id as string from earlier versions ( CASSANDRA - 6840 ) 
 * Properly use the Paxos consistency for ( non - protocol ) batch ( CASSANDRA - 6837 ) 
 * Add paranoid disk failure option ( CASSANDRA - 6646 ) 
 + * Improve PerRowSecondaryIndex performance ( CASSANDRA - 6876 ) 
 Merged from 1 . 2 : 
 * add extra SSL cipher suites ( CASSANDRA - 6613 ) 
 * fix nodetool getsstables for blob PK ( CASSANDRA - 6803 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Keyspace . java b / src / java / org / apache / cassandra / db / Keyspace . java 
 index 36789e2 . . f5369f9 100644 
 - - - a / src / java / org / apache / cassandra / db / Keyspace . java 
 + + + b / src / java / org / apache / cassandra / db / Keyspace . java 
 @ @ - 389 , 7 + 389 , 7 @ @ public class Keyspace 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Indexing row { } " , cfs . metadata . getKeyValidator ( ) . getString ( key . key ) ) ; 
 
 - Collection < SecondaryIndex > indexes = cfs . indexManager . getIndexesByNames ( idxNames ) ; 
 + Set < SecondaryIndex > indexes = cfs . indexManager . getIndexesByNames ( idxNames ) ; 
 
 switchLock . readLock ( ) . lock ( ) ; 
 try 
 diff - - git a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 index 7bfed33 . . 5e49966 100644 
 - - - a / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / db / index / SecondaryIndexManager . java 
 @ @ - 60 , 15 + 60 , 18 @ @ public class SecondaryIndexManager 
 * / 
 private final ConcurrentNavigableMap < ByteBuffer , SecondaryIndex > indexesByColumn ; 
 
 - 
 / * * 
 * Keeps a single instance of a SecondaryIndex for many columns when the index type 
 * has isRowLevelIndex ( ) = = true 
 * 
 * This allows updates to happen to an entire row at once 
 * / 
 - private final Map < Class < ? extends SecondaryIndex > , SecondaryIndex > rowLevelIndexMap ; 
 + private final ConcurrentMap < Class < ? extends SecondaryIndex > , SecondaryIndex > rowLevelIndexMap ; 
 
 + / * * 
 + * Keeps all secondary index instances , either per - column or per - row 
 + * / 
 + private final Set < SecondaryIndex > allIndexes ; 
 
 / * * 
 * The underlying column family containing the source data for these indexes 
 @ @ - 78 , 7 + 81 , 8 @ @ public class SecondaryIndexManager 
 public SecondaryIndexManager ( ColumnFamilyStore baseCfs ) 
 { 
 indexesByColumn = new ConcurrentSkipListMap < > ( ) ; 
 - rowLevelIndexMap = new HashMap < > ( ) ; 
 + rowLevelIndexMap = new ConcurrentHashMap < > ( ) ; 
 + allIndexes = Collections . newSetFromMap ( new ConcurrentHashMap < SecondaryIndex , Boolean > ( ) ) ; 
 
 this . baseCfs = baseCfs ; 
 } 
 @ @ - 104 , 16 + 108 , 14 @ @ public class SecondaryIndexManager 
 if ( cdef . getIndexType ( ) ! = null & & ! indexedColumnNames . contains ( cdef . name ) ) 
 addIndexedColumn ( cdef ) ; 
 
 - Set < SecondaryIndex > reloadedIndexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 - if ( reloadedIndexes . add ( index ) ) 
 - index . reload ( ) ; 
 + for ( SecondaryIndex index : allIndexes ) 
 + index . reload ( ) ; 
 } 
 
 public Set < String > allIndexesNames ( ) 
 { 
 - Set < String > names = new HashSet < > ( indexesByColumn . size ( ) ) ; 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + Set < String > names = new HashSet < > ( allIndexes . size ( ) ) ; 
 + for ( SecondaryIndex index : allIndexes ) 
 names . add ( index . getIndexName ( ) ) ; 
 return names ; 
 } 
 @ @ - 144 , 24 + 146 , 33 @ @ public class SecondaryIndexManager 
 logger . info ( " Index build of " + idxNames + " complete " ) ; 
 } 
 
 - public boolean indexes ( ByteBuffer name , Collection < SecondaryIndex > indexes ) 
 + public boolean indexes ( ByteBuffer name , Set < SecondaryIndex > indexes ) 
 { 
 - return ! indexFor ( name , indexes ) . isEmpty ( ) ; 
 + boolean matching = false ; 
 + for ( SecondaryIndex index : indexes ) 
 + { 
 + if ( index . indexes ( name ) ) 
 + { 
 + matching = true ; 
 + break ; 
 + } 
 + } 
 + return matching ; 
 } 
 
 - public List < SecondaryIndex > indexFor ( ByteBuffer name , Collection < SecondaryIndex > indexes ) 
 + public Set < SecondaryIndex > indexFor ( ByteBuffer name , Set < SecondaryIndex > indexes ) 
 { 
 - List < SecondaryIndex > matching = null ; 
 + Set < SecondaryIndex > matching = null ; 
 for ( SecondaryIndex index : indexes ) 
 { 
 if ( index . indexes ( name ) ) 
 { 
 if ( matching = = null ) 
 - matching = new ArrayList < > ( ) ; 
 + matching = new HashSet < > ( ) ; 
 matching . add ( index ) ; 
 } 
 } 
 - return matching = = null ? Collections . < SecondaryIndex > emptyList ( ) : matching ; 
 + return matching = = null ? Collections . < SecondaryIndex > emptySet ( ) : matching ; 
 } 
 
 public boolean indexes ( Column column ) 
 @ @ - 171 , 12 + 182 , 12 @ @ public class SecondaryIndexManager 
 
 public boolean indexes ( ByteBuffer name ) 
 { 
 - return indexes ( name , indexesByColumn . values ( ) ) ; 
 + return indexes ( name , allIndexes ) ; 
 } 
 
 - public List < SecondaryIndex > indexFor ( ByteBuffer name ) 
 + public Set < SecondaryIndex > indexFor ( ByteBuffer name ) 
 { 
 - return indexFor ( name , indexesByColumn . values ( ) ) ; 
 + return indexFor ( name , allIndexes ) ; 
 } 
 
 / * * 
 @ @ - 221 , 6 + 232 , 9 @ @ public class SecondaryIndexManager 
 rowLevelIndexMap . remove ( index . getClass ( ) ) ; 
 } 
 
 + / / Remove from all indexes set : 
 + allIndexes . remove ( index ) ; 
 + 
 index . removeIndex ( column ) ; 
 SystemKeyspace . setIndexRemoved ( baseCfs . metadata . ksName , index . getNameForSystemKeyspace ( column ) ) ; 
 } 
 @ @ - 281 , 6 + 295 , 9 @ @ public class SecondaryIndexManager 
 / / until the index is actually built before using in queries . 
 indexesByColumn . put ( cdef . name , index ) ; 
 
 + / / Add to all indexes set : 
 + allIndexes . add ( index ) ; 
 + 
 / / if we ' re just linking in the index to indexedColumns on an 
 / / already - built index post - restart , we ' re done 
 if ( index . isIndexBuilt ( cdef . name ) ) 
 @ @ - 304 , 7 + 321 , 7 @ @ public class SecondaryIndexManager 
 * / 
 public void invalidate ( ) 
 { 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + for ( SecondaryIndex index : allIndexes ) 
 index . invalidate ( ) ; 
 } 
 
 @ @ - 313 , 7 + 330 , 7 @ @ public class SecondaryIndexManager 
 * / 
 public void flushIndexesBlocking ( ) 
 { 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + for ( SecondaryIndex index : allIndexes ) 
 index . forceBlockingFlush ( ) ; 
 } 
 
 @ @ - 338 , 11 + 355 , 11 @ @ public class SecondaryIndexManager 
 / * * 
 * @ return all CFS from indexes which use a backing CFS internally ( KEYS ) 
 * / 
 - public Collection < ColumnFamilyStore > getIndexesBackedByCfs ( ) 
 + public Set < ColumnFamilyStore > getIndexesBackedByCfs ( ) 
 { 
 - ArrayList < ColumnFamilyStore > cfsList = new ArrayList < > ( ) ; 
 + Set < ColumnFamilyStore > cfsList = new HashSet < > ( ) ; 
 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + for ( SecondaryIndex index : allIndexes ) 
 { 
 ColumnFamilyStore cfs = index . getIndexCfs ( ) ; 
 if ( cfs ! = null ) 
 @ @ - 355 , 11 + 372 , 11 @ @ public class SecondaryIndexManager 
 / * * 
 * @ return all indexes which do * not * use a backing CFS internally 
 * / 
 - public Collection < SecondaryIndex > getIndexesNotBackedByCfs ( ) 
 + public Set < SecondaryIndex > getIndexesNotBackedByCfs ( ) 
 { 
 / / we use identity map because per row indexes use same instance across many columns 
 Set < SecondaryIndex > indexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + for ( SecondaryIndex index : allIndexes ) 
 if ( index . getIndexCfs ( ) = = null ) 
 indexes . add ( index ) ; 
 return indexes ; 
 @ @ - 368 , 12 + 385 , 9 @ @ public class SecondaryIndexManager 
 / * * 
 * @ return all of the secondary indexes without distinction to the ( non - ) backed by secondary ColumnFamilyStore . 
 * / 
 - public Collection < SecondaryIndex > getIndexes ( ) 
 + public Set < SecondaryIndex > getIndexes ( ) 
 { 
 - / / we use identity map because per row indexes use same instance across many columns 
 - Set < SecondaryIndex > indexes = Collections . newSetFromMap ( new IdentityHashMap < SecondaryIndex , Boolean > ( ) ) ; 
 - indexes . addAll ( indexesByColumn . values ( ) ) ; 
 - return indexes ; 
 + return allIndexes ; 
 } 
 
 / * * 
 @ @ - 406 , 7 + 420 , 7 @ @ public class SecondaryIndexManager 
 / / Update entire row only once per row level index 
 Set < Class < ? extends SecondaryIndex > > appliedRowLevelIndexes = null ; 
 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + for ( SecondaryIndex index : allIndexes ) 
 { 
 if ( index instanceof PerRowSecondaryIndex ) 
 { 
 @ @ - 538 , 10 + 552 , 10 @ @ public class SecondaryIndexManager 
 return indexSearchers . get ( 0 ) . search ( filter ) ; 
 } 
 
 - public Collection < SecondaryIndex > getIndexesByNames ( Set < String > idxNames ) 
 + public Set < SecondaryIndex > getIndexesByNames ( Set < String > idxNames ) 
 { 
 - List < SecondaryIndex > result = new ArrayList < > ( ) ; 
 - for ( SecondaryIndex index : indexesByColumn . values ( ) ) 
 + Set < SecondaryIndex > result = new HashSet < > ( ) ; 
 + for ( SecondaryIndex index : allIndexes ) 
 if ( idxNames . contains ( index . getIndexName ( ) ) ) 
 result . add ( index ) ; 
 return result ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index dfb77d6 . . 2ea901f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 3 + 1 , 7 @ @ 
 + 1 . 1 . 5 
 + * Log ( info ) schema changes ( CASSANDRA - 4547 ) 
 + 
 + 
 1 . 1 . 4 
 * fix offline scrub to catch > = out of order rows ( CASSANDRA - 4411 ) 
 * fix cassandra - env . sh on RHEL and other non - dash - based systems 
 diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java 
 index eedb20d . . 1d4401a 100644 
 - - - a / src / java / org / apache / cassandra / service / MigrationManager . java 
 + + + b / src / java / org / apache / cassandra / service / MigrationManager . java 
 @ @ - 123 , 6 + 123 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 if ( Schema . instance . getTableDefinition ( ksm . name ) ! = null ) 
 throw new ConfigurationException ( String . format ( " Cannot add already existing keyspace ' % s ' . " , ksm . name ) ) ; 
 
 + logger . info ( String . format ( " Create new Keyspace : % s " , ksm ) ) ; 
 announce ( ksm . toSchema ( FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 @ @ - 136 , 6 + 137 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 else if ( ksm . cfMetaData ( ) . containsKey ( cfm . cfName ) ) 
 throw new ConfigurationException ( String . format ( " Cannot add already existing column family ' % s ' to keyspace ' % s ' . " , cfm . cfName , cfm . ksName ) ) ; 
 
 + logger . info ( String . format ( " Create new ColumnFamily : % s " , cfm ) ) ; 
 announce ( cfm . toSchema ( FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 @ @ - 147 , 6 + 149 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 if ( oldKsm = = null ) 
 throw new ConfigurationException ( String . format ( " Cannot update non existing keyspace ' % s ' . " , ksm . name ) ) ; 
 
 + logger . info ( String . format ( " Update Keyspace ' % s ' From % s To % s " , ksm . name , oldKsm , ksm ) ) ; 
 announce ( oldKsm . toSchemaUpdate ( ksm , FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 @ @ - 158 , 6 + 161 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 if ( oldCfm = = null ) 
 throw new ConfigurationException ( String . format ( " Cannot update non existing column family ' % s ' in keyspace ' % s ' . " , cfm . cfName , cfm . ksName ) ) ; 
 
 + logger . info ( String . format ( " Update ColumnFamily ' % s / % s ' From % s To % s " , cfm . ksName , cfm . cfName , oldCfm , cfm ) ) ; 
 announce ( oldCfm . toSchemaUpdate ( cfm , FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 @ @ - 167 , 6 + 171 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 if ( oldKsm = = null ) 
 throw new ConfigurationException ( String . format ( " Cannot drop non existing keyspace ' % s ' . " , ksName ) ) ; 
 
 + logger . info ( String . format ( " Drop Keyspace ' % s ' " , oldKsm . name ) ) ; 
 announce ( oldKsm . dropFromSchema ( FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 @ @ - 176 , 6 + 181 , 7 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 if ( oldCfm = = null ) 
 throw new ConfigurationException ( String . format ( " Cannot drop non existing column family ' % s ' in keyspace ' % s ' . " , cfName , ksName ) ) ; 
 
 + logger . info ( String . format ( " Drop ColumnFamily ' % s / % s ' " , oldCfm . ksName , oldCfm . cfName ) ) ; 
 announce ( oldCfm . dropFromSchema ( FBUtilities . timestampMicros ( ) ) ) ; 
 } 

