BLEU SCORE: 0.0037960378087611287

TEST MSG: Use new token allocation for non bootstrap case as well .
GENERATED MSG: get token on bootstrap that gives us half of the keys from the most heavily - loaded node . ( the " splits " approach should also be useful for # 342 ; adding it to Thrift is trivial )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9ed66fd . . cacb7cd 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 6 @ @ <nl> 3 . 12 <nl> - * Avoid byte - array copy when key cache is disabled ( CASANDRA - 13084 ) <nl> + * Use new token allocation for non bootstrap case as well ( CASSANDRA - 13080 ) <nl> + * Avoid byte - array copy when key cache is disabled ( CASSANDRA - 13084 ) <nl> * More fixes to the TokenAllocator ( CASSANDRA - 12990 ) <nl> * Require forceful decommission if number of nodes is less than replication factor ( CASSANDRA - 12510 ) <nl> * Allow IN restrictions on column families with collections ( CASSANDRA - 12654 ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 392dbf2 . . 1e00f48 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 33 , 12 + 33 , 15 @ @ import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . dht . tokenallocator . TokenAllocation ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . gms . FailureDetector ; <nl> + import org . apache . cassandra . gms . Gossiper ; <nl> import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . streaming . * ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . progress . ProgressEvent ; <nl> import org . apache . cassandra . utils . progress . ProgressEventNotifierSupport ; <nl> import org . apache . cassandra . utils . progress . ProgressEventType ; <nl> @ @ - 155 , 7 + 158 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport <nl> * otherwise , if allocationKeyspace is specified use the token allocation algorithm to generate suitable tokens <nl> * else choose num _ tokens tokens at random <nl> * / <nl> - public static Collection < Token > getBootstrapTokens ( final TokenMetadata metadata , InetAddress address ) throws ConfigurationException <nl> + public static Collection < Token > getBootstrapTokens ( final TokenMetadata metadata , InetAddress address , int schemaWaitDelay ) throws ConfigurationException <nl> { <nl> String allocationKeyspace = DatabaseDescriptor . getAllocateTokensForKeyspace ( ) ; <nl> Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; <nl> @ @ - 171 , 7 + 174 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport <nl> throw new ConfigurationException ( " num _ tokens must be > = 1 " ) ; <nl> <nl> if ( allocationKeyspace ! = null ) <nl> - return allocateTokens ( metadata , address , allocationKeyspace , numTokens ) ; <nl> + return allocateTokens ( metadata , address , allocationKeyspace , numTokens , schemaWaitDelay ) ; <nl> <nl> if ( numTokens = = 1 ) <nl> logger . warn ( " Picking random token for a single vnode . You should probably add more vnodes and / or use the automatic token allocation mechanism . " ) ; <nl> @ @ - 182 , 7 + 185 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport <nl> private static Collection < Token > getSpecifiedTokens ( final TokenMetadata metadata , <nl> Collection < String > initialTokens ) <nl> { <nl> - logger . trace ( " tokens manually specified as { } " , initialTokens ) ; <nl> + logger . info ( " tokens manually specified as { } " , initialTokens ) ; <nl> List < Token > tokens = new ArrayList < > ( initialTokens . size ( ) ) ; <nl> for ( String tokenString : initialTokens ) <nl> { <nl> @ @ - 197 , 8 + 200 , 13 @ @ public class BootStrapper extends ProgressEventNotifierSupport <nl> static Collection < Token > allocateTokens ( final TokenMetadata metadata , <nl> InetAddress address , <nl> String allocationKeyspace , <nl> - int numTokens ) <nl> + int numTokens , <nl> + int schemaWaitDelay ) <nl> { <nl> + StorageService . instance . waitForSchema ( schemaWaitDelay ) ; <nl> + if ( ! FBUtilities . getBroadcastAddress ( ) . equals ( InetAddress . getLoopbackAddress ( ) ) ) <nl> + Gossiper . waitToSettle ( ) ; <nl> + <nl> Keyspace ks = Keyspace . open ( allocationKeyspace ) ; <nl> if ( ks = = null ) <nl> throw new ConfigurationException ( " Problem opening token allocation keyspace " + allocationKeyspace ) ; <nl> @ @ - 216 , 6 + 224 , 8 @ @ public class BootStrapper extends ProgressEventNotifierSupport <nl> if ( metadata . getEndpoint ( token ) = = null ) <nl> tokens . add ( token ) ; <nl> } <nl> + <nl> + logger . info ( " Generated random tokens . tokens are { } " , tokens ) ; <nl> return tokens ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java b / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java <nl> index 15d7868 . . 9c50613 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java <nl> + + + b / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java <nl> @ @ - 53 , 9 + 53 , 6 @ @ public class TokenAllocation <nl> final InetAddress endpoint , <nl> int numTokens ) <nl> { <nl> - if ( ! FBUtilities . getBroadcastAddress ( ) . equals ( InetAddress . getLoopbackAddress ( ) ) ) <nl> - Gossiper . waitToSettle ( ) ; <nl> - <nl> TokenMetadata tokenMetadataCopy = tokenMetadata . cloneOnlyTokenMap ( ) ; <nl> StrategyAdapter strategy = getStrategy ( tokenMetadataCopy , rs , endpoint ) ; <nl> Collection < Token > tokens = create ( tokenMetadata , strategy ) . addUnit ( endpoint , numTokens ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 3fc7d54 . . a1b15ce 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 748 , 7 + 748 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> private boolean shouldBootstrap ( ) <nl> { <nl> - return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! isSeed ( ) ; <nl> + } <nl> + <nl> + public static boolean isSeed ( ) <nl> + { <nl> + return DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> <nl> private void prepareToJoin ( ) throws ConfigurationException <nl> @ @ - 831 , 6 + 836 , 29 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> } <nl> <nl> + public void waitForSchema ( int delay ) <nl> + { <nl> + / / first sleep the delay to make sure we see all our peers <nl> + for ( int i = 0 ; i < delay ; i + = 1000 ) <nl> + { <nl> + / / if we see schema , we can proceed to the next check directly <nl> + if ( ! Schema . instance . getVersion ( ) . equals ( SchemaConstants . emptyVersion ) ) <nl> + { <nl> + logger . debug ( " got schema : { } " , Schema . instance . getVersion ( ) ) ; <nl> + break ; <nl> + } <nl> + Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; <nl> + } <nl> + / / if our schema hasn ' t matched yet , wait until it has <nl> + / / we do this by waiting for all in - flight migration requests and responses to complete <nl> + / / ( post CASSANDRA - 1391 we don ' t expect this to be necessary very often , but it doesn ' t hurt to be careful ) <nl> + if ( ! MigrationManager . isReadyForBootstrap ( ) ) <nl> + { <nl> + setMode ( Mode . JOINING , " waiting for schema information to complete " , true ) ; <nl> + MigrationManager . waitUntilReadyForBootstrap ( ) ; <nl> + } <nl> + } <nl> + <nl> private void joinTokenRing ( int delay ) throws ConfigurationException <nl> { <nl> joined = true ; <nl> @ @ - 867 , 25 + 895 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> else <nl> SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . IN _ PROGRESS ) ; <nl> setMode ( Mode . JOINING , " waiting for ring information " , true ) ; <nl> - / / first sleep the delay to make sure we see all our peers <nl> - for ( int i = 0 ; i < delay ; i + = 1000 ) <nl> - { <nl> - / / if we see schema , we can proceed to the next check directly <nl> - if ( ! Schema . instance . getVersion ( ) . equals ( SchemaConstants . emptyVersion ) ) <nl> - { <nl> - logger . debug ( " got schema : { } " , Schema . instance . getVersion ( ) ) ; <nl> - break ; <nl> - } <nl> - Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; <nl> - } <nl> - / / if our schema hasn ' t matched yet , wait until it has <nl> - / / we do this by waiting for all in - flight migration requests and responses to complete <nl> - / / ( post CASSANDRA - 1391 we don ' t expect this to be necessary very often , but it doesn ' t hurt to be careful ) <nl> - if ( ! MigrationManager . isReadyForBootstrap ( ) ) <nl> - { <nl> - setMode ( Mode . JOINING , " waiting for schema information to complete " , true ) ; <nl> - MigrationManager . waitUntilReadyForBootstrap ( ) ; <nl> - } <nl> + waitForSchema ( delay ) ; <nl> setMode ( Mode . JOINING , " schema complete , ready to bootstrap " , true ) ; <nl> setMode ( Mode . JOINING , " waiting for pending range calculation " , true ) ; <nl> PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; <nl> @ @ - 912 , 7 + 922 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> throw new UnsupportedOperationException ( s ) ; <nl> } <nl> setMode ( Mode . JOINING , " getting bootstrap token " , true ) ; <nl> - bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) ) ; <nl> + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) , delay ) ; <nl> } <nl> else <nl> { <nl> @ @ - 968 , 22 + 978 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> bootstrapTokens = SystemKeyspace . getSavedTokens ( ) ; <nl> if ( bootstrapTokens . isEmpty ( ) ) <nl> { <nl> - Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; <nl> - if ( initialTokens . size ( ) < 1 ) <nl> - { <nl> - bootstrapTokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; <nl> - if ( DatabaseDescriptor . getNumTokens ( ) = = 1 ) <nl> - logger . warn ( " Generated random token { } . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " , bootstrapTokens ) ; <nl> - else <nl> - logger . info ( " Generated random tokens . tokens are { } " , bootstrapTokens ) ; <nl> - } <nl> - else <nl> - { <nl> - bootstrapTokens = new ArrayList < > ( initialTokens . size ( ) ) ; <nl> - for ( String token : initialTokens ) <nl> - bootstrapTokens . add ( getTokenFactory ( ) . fromString ( token ) ) ; <nl> - logger . info ( " Saved tokens not found . Using configuration value : { } " , bootstrapTokens ) ; <nl> - } <nl> + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) , delay ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> index 3af52e5 . . ed15a70 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> @ @ - 224 , 7 + 224 , 7 @ @ public class BootStrapperTest <nl> private void allocateTokensForNode ( int vn , String ks , TokenMetadata tm , InetAddress addr ) <nl> { <nl> SummaryStatistics os = TokenAllocation . replicatedOwnershipStats ( tm . cloneOnlyTokenMap ( ) , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ; <nl> - Collection < Token > tokens = BootStrapper . allocateTokens ( tm , addr , ks , vn ) ; <nl> + Collection < Token > tokens = BootStrapper . allocateTokens ( tm , addr , ks , vn , 0 ) ; <nl> assertEquals ( vn , tokens . size ( ) ) ; <nl> tm . updateNormalTokens ( tokens , addr ) ; <nl> SummaryStatistics ns = TokenAllocation . replicatedOwnershipStats ( tm . cloneOnlyTokenMap ( ) , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0ce9ee6 . . 8dfd1f8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 725 , 10 + 725 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> void doCleanup ( SSTableReader sstable ) throws IOException <nl> { <nl> assert sstable ! = null ; <nl> - List < Range > myRanges ; <nl> - Map < EndPoint , List < Range > > endPointtoRangeMap = StorageService . instance ( ) . constructEndPointToRangesMap ( ) ; <nl> - myRanges = endPointtoRangeMap . get ( StorageService . getLocalStorageEndPoint ( ) ) ; <nl> - List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , myRanges , null ) ; <nl> + List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , StorageService . instance ( ) . getLocalRanges ( ) , null ) ; <nl> if ( ! sstables . isEmpty ( ) ) <nl> { <nl> assert sstables . size ( ) = = 1 ; <nl> @ @ - 764 , 7 + 761 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> long startTime = System . currentTimeMillis ( ) ; <nl> long totalkeysWritten = 0 ; <nl> <nl> - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ; <nl> + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) ( SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; <nl> <nl> @ @ - 844 , 7 + 841 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> long startTime = System . currentTimeMillis ( ) ; <nl> long totalkeysWritten = 0 ; <nl> <nl> - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) ) ; <nl> + / / TODO the int cast here is potentially buggy <nl> + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) SSTableReader . getApproximateKeyCount ( sstables ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / DecoratedKey . java b / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> index 1b9af39 . . b2a72da 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> + + + b / src / java / org / apache / cassandra / db / DecoratedKey . java <nl> @ @ - 24 , 7 + 24 , 7 @ @ import org . apache . cassandra . dht . Token ; <nl> * Represents a decorated key , handy for certain operations <nl> * where just working with strings gets slow . <nl> * / <nl> - public class DecoratedKey < T extends Token > <nl> + public class DecoratedKey < T extends Token > implements Comparable < DecoratedKey > <nl> { <nl> public final T token ; <nl> public final String key ; <nl> @ @ - 32 , 6 + 32 , 7 @ @ public class DecoratedKey < T extends Token > <nl> public DecoratedKey ( T token , String key ) <nl> { <nl> super ( ) ; <nl> + assert key ! = null ; <nl> this . token = token ; <nl> this . key = key ; <nl> } <nl> @ @ - 55 , 20 + 56 , 22 @ @ public class DecoratedKey < T extends Token > <nl> return false ; <nl> if ( getClass ( ) ! = obj . getClass ( ) ) <nl> return false ; <nl> + <nl> DecoratedKey other = ( DecoratedKey ) obj ; <nl> - if ( key = = null ) <nl> - { <nl> - if ( other . key ! = null ) <nl> - return false ; <nl> - } else if ( ! key . equals ( other . key ) ) <nl> - return false ; <nl> + / / either both should be of a class where all tokens are null , or neither <nl> + assert ( token = = null ) = = ( other . token = = null ) ; <nl> if ( token = = null ) <nl> - { <nl> - if ( other . token ! = null ) <nl> - return false ; <nl> - } else if ( ! token . equals ( other . token ) ) <nl> - return false ; <nl> - return true ; <nl> + return key . equals ( other . key ) ; <nl> + return token . equals ( other . token ) & & key . equals ( other . key ) ; <nl> + } <nl> + <nl> + public int compareTo ( DecoratedKey other ) <nl> + { <nl> + assert ( token = = null ) = = ( other . token = = null ) ; <nl> + if ( token = = null ) <nl> + return key . compareTo ( other . key ) ; <nl> + int i = token . compareTo ( other . token ) ; <nl> + return i = = 0 ? key . compareTo ( other . key ) : i ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index b61991e . . 5503a8f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 492 , 7 + 492 , 7 @ @ public class Table <nl> } <nl> <nl> / * <nl> - * Get the list of all SSTables on disk . Not safe unless you aquire the CFS readlocks ! <nl> + * Get the list of all SSTables on disk . <nl> * / <nl> public List < SSTableReader > getAllSSTablesOnDisk ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 35cab21 . . 9402048 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 41 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . LogUtil ; <nl> * / <nl> public class BootStrapper implements Runnable <nl> { <nl> + public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms <nl> + <nl> private static Logger logger _ = Logger . getLogger ( BootStrapper . class ) ; <nl> - private static final long INITIAL _ DELAY = 60 * 1000 ; / / ms <nl> + <nl> / * endpoints that need to be bootstrapped * / <nl> protected EndPoint [ ] targets _ = new EndPoint [ 0 ] ; <nl> / * tokens of the nodes being bootstrapped . * / <nl> @ @ - 60 , 10 + 62 , 6 @ @ public class BootStrapper implements Runnable <nl> { <nl> try <nl> { <nl> - / * Initial delay waiting for this node to get a stable endpoint map * / <nl> - Thread . sleep ( INITIAL _ DELAY ) ; <nl> - / * Clone again now so we include all discovered nodes in our calculations * / <nl> - tokenMetadata _ = StorageService . instance ( ) . getTokenMetadata ( ) ; <nl> / / Mark as not bootstrapping to calculate ranges correctly <nl> for ( int i = 0 ; i < targets _ . length ; i + + ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTableReader . java b / src / java / org / apache / cassandra / io / SSTableReader . java <nl> index 1954732 . . c498a7e 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTableReader . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . log4j . Logger ; <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . utils . BloomFilter ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> @ @ - 86 , 9 + 87 , 14 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > <nl> return INDEX _ INTERVAL ; <nl> } <nl> <nl> - public static int getApproximateKeyCount ( Iterable < SSTableReader > sstables ) <nl> + public static long getApproximateKeyCount ( ) <nl> { <nl> - int count = 0 ; <nl> + return getApproximateKeyCount ( openedFiles . values ( ) ) ; <nl> + } <nl> + <nl> + public static long getApproximateKeyCount ( Iterable < SSTableReader > sstables ) <nl> + { <nl> + long count = 0 ; <nl> <nl> for ( SSTableReader sstable : sstables ) <nl> { <nl> @ @ - 101 , 6 + 107 , 30 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > <nl> return count ; <nl> } <nl> <nl> + / * * <nl> + * Get all indexed keys in any SSTable for our primary range <nl> + * TODO add option to include keys from one or more other ranges <nl> + * / <nl> + public static List < DecoratedKey > getIndexedDecoratedKeys ( ) <nl> + { <nl> + Range range = StorageService . instance ( ) . getLocalPrimaryRange ( ) ; <nl> + List < DecoratedKey > indexedKeys = new ArrayList < DecoratedKey > ( ) ; <nl> + <nl> + for ( SSTableReader sstable : openedFiles . values ( ) ) <nl> + { <nl> + for ( KeyPosition kp : sstable . getIndexPositions ( ) ) <nl> + { <nl> + if ( range . contains ( kp . key . token ) ) <nl> + { <nl> + indexedKeys . add ( kp . key ) ; <nl> + } <nl> + } <nl> + } <nl> + Collections . sort ( indexedKeys ) ; <nl> + <nl> + return indexedKeys ; <nl> + } <nl> + <nl> public static SSTableReader open ( String dataFileName ) throws IOException <nl> { <nl> return open ( dataFileName , StorageService . getPartitioner ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTableWriter . java b / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> index 41f3de1 . . 1340d2c 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTableWriter . java <nl> @ @ - 46 , 12 + 46 , 12 @ @ public class SSTableWriter extends SSTable <nl> private DecoratedKey lastWrittenKey ; <nl> private BloomFilter bf ; <nl> <nl> - public SSTableWriter ( String filename , int keyCount , IPartitioner partitioner ) throws IOException <nl> + public SSTableWriter ( String filename , long keyCount , IPartitioner partitioner ) throws IOException <nl> { <nl> super ( filename , partitioner ) ; <nl> dataFile = new BufferedRandomAccessFile ( path , " rw " , ( int ) ( DatabaseDescriptor . getFlushDataBufferSizeInMB ( ) * 1024 * 1024 ) ) ; <nl> indexFile = new BufferedRandomAccessFile ( indexFilename ( ) , " rw " , ( int ) ( DatabaseDescriptor . getFlushIndexBufferSizeInMB ( ) * 1024 * 1024 ) ) ; <nl> - bf = new BloomFilter ( keyCount , 15 ) ; <nl> + bf = new BloomFilter ( ( int ) keyCount , 15 ) ; / / TODO fix long - > int cast <nl> } <nl> <nl> private long beforeAppend ( DecoratedKey decoratedKey ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index c685711 . . 6758b2f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 77 , 8 + 77 , 7 @ @ public class CassandraDaemon <nl> } ) ; <nl> <nl> / / initialize stuff <nl> - Set < String > tables = DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ; <nl> - for ( String table : tables ) <nl> + for ( String table : DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ) <nl> { <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " opening keyspace " + table ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> index 1228525 . . 8b6a607 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraServer . java <nl> @ @ - 525 , 10 + 525 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> { <nl> return DatabaseDescriptor . getTables ( ) ; <nl> } <nl> - else <nl> - { <nl> - return new ArrayList < String > ( ) ; <nl> - } <nl> + return Collections . emptyList ( ) ; <nl> } <nl> <nl> public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 7a7c1cd . . 5a4e5e3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . service ; <nl> <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> + import java . io . UnsupportedEncodingException ; <nl> import java . lang . management . ManagementFactory ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> @ @ - 27 , 8 + 28 , 7 @ @ import java . util . * ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . LinkedBlockingQueue ; <nl> import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . locks . Lock ; <nl> - import java . util . concurrent . locks . ReentrantLock ; <nl> + import java . util . concurrent . locks . Condition ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> @ @ - 43 , 8 + 43 , 18 @ @ import org . apache . cassandra . net . io . StreamContextManager ; <nl> import org . apache . cassandra . tools . MembershipCleanerVerbHandler ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . SimpleCondition ; <nl> + import org . apache . cassandra . io . SSTableReader ; <nl> + import org . apache . thrift . protocol . TBinaryProtocol ; <nl> + import org . apache . thrift . transport . TSocket ; <nl> + import org . apache . thrift . transport . TTransport ; <nl> + import org . apache . thrift . transport . TTransportException ; <nl> + import org . apache . thrift . TException ; <nl> + <nl> import org . apache . log4j . Logger ; <nl> import org . apache . log4j . Level ; <nl> + import org . apache . commons . lang . ArrayUtils ; <nl> <nl> / * <nl> * This abstraction contains the token / identifier of this node <nl> @ @ - 77 , 6 + 87 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> public final static String mbrshipCleanerVerbHandler _ = " MBRSHIP - CLEANER - VERB - HANDLER " ; <nl> public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; <nl> public final static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; <nl> + public final static String bootstrapTokenVerbHandler _ = " SPLITS - VERB - HANDLER " ; <nl> <nl> private static StorageService instance _ ; <nl> private static EndPoint tcpAddr _ ; <nl> @ @ - 97 , 6 + 108 , 16 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> return partitioner _ ; <nl> } <nl> <nl> + public List < Range > getLocalRanges ( ) <nl> + { <nl> + return getRangesForEndPoint ( getLocalStorageEndPoint ( ) ) ; <nl> + } <nl> + <nl> + public Range getLocalPrimaryRange ( ) <nl> + { <nl> + return getPrimaryRangeForEndPoint ( getLocalStorageEndPoint ( ) ) ; <nl> + } <nl> + <nl> static <nl> { <nl> partitioner _ = DatabaseDescriptor . getPartitioner ( ) ; <nl> @ @ - 254 , 6 + 275 , 24 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . mbrshipCleanerVerbHandler _ , new MembershipCleanerVerbHandler ( ) ) ; <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bsMetadataVerbHandler _ , new BootstrapMetadataVerbHandler ( ) ) ; <nl> MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . rangeVerbHandler _ , new RangeVerbHandler ( ) ) ; <nl> + MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bootstrapTokenVerbHandler _ , new IVerbHandler ( ) <nl> + { <nl> + public void doVerb ( Message message ) <nl> + { <nl> + List < String > tokens = getSplits ( 2 ) ; <nl> + assert tokens . size ( ) = = 3 : tokens . size ( ) ; <nl> + Message response ; <nl> + try <nl> + { <nl> + response = message . getReply ( getLocalStorageEndPoint ( ) , tokens . get ( 1 ) . getBytes ( " UTF - 8 " ) ) ; <nl> + } <nl> + catch ( UnsupportedEncodingException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; <nl> + } <nl> + } ) ; <nl> <nl> / * register the stage for the mutations * / <nl> consistencyManager _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getConsistencyThreads ( ) , <nl> @ @ - 309 , 12 + 348 , 56 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Gossiper . instance ( ) . addApplicationState ( StorageService . nodeId _ , state ) ; <nl> if ( isBootstrapMode ) <nl> { <nl> - logger _ . info ( " Starting in bootstrap mode " ) ; <nl> + logger _ . info ( " Starting in bootstrap mode ( first , sleeping to get load information ) " ) ; <nl> + / / wait for node information to be available . if the rest of the cluster just came up , <nl> + / / this could be up to threshold _ ms ( currently 5 minutes ) . <nl> + try <nl> + { <nl> + while ( storageLoadBalancer _ . getLoadInfo ( ) . isEmpty ( ) ) <nl> + { <nl> + Thread . sleep ( 100 ) ; <nl> + } <nl> + / / one more sleep in case there are some stragglers <nl> + Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + <nl> + / / if initialtoken was specified , use that . otherwise , pick a token to assume half the load of the most - loaded node . <nl> + if ( DatabaseDescriptor . getInitialToken ( ) = = null ) <nl> + { <nl> + double maxLoad = 0 ; <nl> + EndPoint maxEndpoint = null ; <nl> + for ( Map . Entry < EndPoint , Double > entry : storageLoadBalancer _ . getLoadInfo ( ) . entrySet ( ) ) <nl> + { <nl> + if ( maxEndpoint = = null | | entry . getValue ( ) > maxLoad ) <nl> + { <nl> + maxEndpoint = entry . getKey ( ) ; <nl> + maxLoad = entry . getValue ( ) ; <nl> + } <nl> + } <nl> + if ( ! maxEndpoint . equals ( getLocalStorageEndPoint ( ) ) ) <nl> + { <nl> + Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; <nl> + logger _ . info ( " Setting token to " + t + " to assume load from " + maxEndpoint . getHost ( ) ) ; <nl> + updateToken ( t ) ; <nl> + } <nl> + } <nl> doBootstrap ( StorageService . getLocalStorageEndPoint ( ) ) ; <nl> Gossiper . instance ( ) . addApplicationState ( BOOTSTRAP _ MODE , new ApplicationState ( " " ) ) ; <nl> } <nl> } <nl> - <nl> + <nl> + private Token < ? > getBootstrapTokenFrom ( EndPoint maxEndpoint ) <nl> + { <nl> + Message message = new Message ( getLocalStorageEndPoint ( ) , " " , bootstrapTokenVerbHandler _ , ArrayUtils . EMPTY _ BYTE _ ARRAY ) ; <nl> + BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; <nl> + MessagingService . getMessagingInstance ( ) . sendRR ( message , maxEndpoint , btc ) ; <nl> + return btc . getToken ( ) ; <nl> + } <nl> + <nl> public boolean isBootstrapMode ( ) <nl> { <nl> return isBootstrapMode ; <nl> @ @ - 1058 , 4 + 1141 , 68 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Logger . getLogger ( classQualifier ) . setLevel ( level ) ; <nl> logger _ . info ( " set log level to " + level + " for classes under ' " + classQualifier + " ' ( if the level doesn ' t look like ' " + rawLevel + " ' then log4j couldn ' t parse ' " + rawLevel + " ' ) " ) ; <nl> } <nl> + <nl> + / * * <nl> + * @ param splits : number of ranges to break into . Minimum 2 . <nl> + * @ return list of Tokens ( _ not _ keys ! ) breaking up the data this node is responsible for into ` splits ` pieces . <nl> + * There will be 1 more token than splits requested . So for splits of 2 , tokens T1 T2 T3 will be returned , <nl> + * where ( T1 , T2 ] is the first range and ( T2 , T3 ] is the second . The first token will always be the left <nl> + * Token of this node ' s primary range , and the last will always be the Right token of that range . <nl> + * / <nl> + public List < String > getSplits ( int splits ) <nl> + { <nl> + assert splits > 1 ; <nl> + / / we use the actual Range token for the first and last brackets of the splits to ensure correctness <nl> + / / ( we ' re only operating on 1 / 128 of the keys remember ) <nl> + Range range = getLocalPrimaryRange ( ) ; <nl> + List < String > tokens = new ArrayList < String > ( ) ; <nl> + tokens . add ( range . left ( ) . toString ( ) ) ; <nl> + <nl> + List < DecoratedKey > decoratedKeys = SSTableReader . getIndexedDecoratedKeys ( ) ; <nl> + for ( int i = 1 ; i < splits ; i + + ) <nl> + { <nl> + int index = i * ( decoratedKeys . size ( ) / splits ) ; <nl> + tokens . add ( decoratedKeys . get ( index ) . token . toString ( ) ) ; <nl> + } <nl> + <nl> + tokens . add ( range . right ( ) . toString ( ) ) ; <nl> + return tokens ; <nl> + } <nl> + <nl> + class BootstrapTokenCallback implements IAsyncCallback <nl> + { <nl> + private volatile Token < ? > token ; <nl> + private final Condition condition = new SimpleCondition ( ) ; <nl> + <nl> + public Token < ? > getToken ( ) <nl> + { <nl> + try <nl> + { <nl> + condition . await ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + return token ; <nl> + } <nl> + <nl> + public void response ( Message msg ) <nl> + { <nl> + try <nl> + { <nl> + token = partitioner _ . getTokenFactory ( ) . fromString ( new String ( msg . getMessageBody ( ) , " UTF - 8 " ) ) ; <nl> + } <nl> + catch ( UnsupportedEncodingException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + condition . signalAll ( ) ; <nl> + } <nl> + <nl> + public void attachContext ( Object o ) <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9ed66fd . . cacb7cd 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 6 @ @ 
 3 . 12 
 - * Avoid byte - array copy when key cache is disabled ( CASANDRA - 13084 ) 
 + * Use new token allocation for non bootstrap case as well ( CASSANDRA - 13080 ) 
 + * Avoid byte - array copy when key cache is disabled ( CASSANDRA - 13084 ) 
 * More fixes to the TokenAllocator ( CASSANDRA - 12990 ) 
 * Require forceful decommission if number of nodes is less than replication factor ( CASSANDRA - 12510 ) 
 * Allow IN restrictions on column families with collections ( CASSANDRA - 12654 ) 
 diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 392dbf2 . . 1e00f48 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 33 , 12 + 33 , 15 @ @ import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . dht . tokenallocator . TokenAllocation ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . gms . FailureDetector ; 
 + import org . apache . cassandra . gms . Gossiper ; 
 import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 + import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . streaming . * ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . progress . ProgressEvent ; 
 import org . apache . cassandra . utils . progress . ProgressEventNotifierSupport ; 
 import org . apache . cassandra . utils . progress . ProgressEventType ; 
 @ @ - 155 , 7 + 158 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport 
 * otherwise , if allocationKeyspace is specified use the token allocation algorithm to generate suitable tokens 
 * else choose num _ tokens tokens at random 
 * / 
 - public static Collection < Token > getBootstrapTokens ( final TokenMetadata metadata , InetAddress address ) throws ConfigurationException 
 + public static Collection < Token > getBootstrapTokens ( final TokenMetadata metadata , InetAddress address , int schemaWaitDelay ) throws ConfigurationException 
 { 
 String allocationKeyspace = DatabaseDescriptor . getAllocateTokensForKeyspace ( ) ; 
 Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; 
 @ @ - 171 , 7 + 174 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport 
 throw new ConfigurationException ( " num _ tokens must be > = 1 " ) ; 
 
 if ( allocationKeyspace ! = null ) 
 - return allocateTokens ( metadata , address , allocationKeyspace , numTokens ) ; 
 + return allocateTokens ( metadata , address , allocationKeyspace , numTokens , schemaWaitDelay ) ; 
 
 if ( numTokens = = 1 ) 
 logger . warn ( " Picking random token for a single vnode . You should probably add more vnodes and / or use the automatic token allocation mechanism . " ) ; 
 @ @ - 182 , 7 + 185 , 7 @ @ public class BootStrapper extends ProgressEventNotifierSupport 
 private static Collection < Token > getSpecifiedTokens ( final TokenMetadata metadata , 
 Collection < String > initialTokens ) 
 { 
 - logger . trace ( " tokens manually specified as { } " , initialTokens ) ; 
 + logger . info ( " tokens manually specified as { } " , initialTokens ) ; 
 List < Token > tokens = new ArrayList < > ( initialTokens . size ( ) ) ; 
 for ( String tokenString : initialTokens ) 
 { 
 @ @ - 197 , 8 + 200 , 13 @ @ public class BootStrapper extends ProgressEventNotifierSupport 
 static Collection < Token > allocateTokens ( final TokenMetadata metadata , 
 InetAddress address , 
 String allocationKeyspace , 
 - int numTokens ) 
 + int numTokens , 
 + int schemaWaitDelay ) 
 { 
 + StorageService . instance . waitForSchema ( schemaWaitDelay ) ; 
 + if ( ! FBUtilities . getBroadcastAddress ( ) . equals ( InetAddress . getLoopbackAddress ( ) ) ) 
 + Gossiper . waitToSettle ( ) ; 
 + 
 Keyspace ks = Keyspace . open ( allocationKeyspace ) ; 
 if ( ks = = null ) 
 throw new ConfigurationException ( " Problem opening token allocation keyspace " + allocationKeyspace ) ; 
 @ @ - 216 , 6 + 224 , 8 @ @ public class BootStrapper extends ProgressEventNotifierSupport 
 if ( metadata . getEndpoint ( token ) = = null ) 
 tokens . add ( token ) ; 
 } 
 + 
 + logger . info ( " Generated random tokens . tokens are { } " , tokens ) ; 
 return tokens ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java b / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java 
 index 15d7868 . . 9c50613 100644 
 - - - a / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java 
 + + + b / src / java / org / apache / cassandra / dht / tokenallocator / TokenAllocation . java 
 @ @ - 53 , 9 + 53 , 6 @ @ public class TokenAllocation 
 final InetAddress endpoint , 
 int numTokens ) 
 { 
 - if ( ! FBUtilities . getBroadcastAddress ( ) . equals ( InetAddress . getLoopbackAddress ( ) ) ) 
 - Gossiper . waitToSettle ( ) ; 
 - 
 TokenMetadata tokenMetadataCopy = tokenMetadata . cloneOnlyTokenMap ( ) ; 
 StrategyAdapter strategy = getStrategy ( tokenMetadataCopy , rs , endpoint ) ; 
 Collection < Token > tokens = create ( tokenMetadata , strategy ) . addUnit ( endpoint , numTokens ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 3fc7d54 . . a1b15ce 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 748 , 7 + 748 , 12 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 private boolean shouldBootstrap ( ) 
 { 
 - return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + return DatabaseDescriptor . isAutoBootstrap ( ) & & ! SystemKeyspace . bootstrapComplete ( ) & & ! isSeed ( ) ; 
 + } 
 + 
 + public static boolean isSeed ( ) 
 + { 
 + return DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 
 private void prepareToJoin ( ) throws ConfigurationException 
 @ @ - 831 , 6 + 836 , 29 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 } 
 
 + public void waitForSchema ( int delay ) 
 + { 
 + / / first sleep the delay to make sure we see all our peers 
 + for ( int i = 0 ; i < delay ; i + = 1000 ) 
 + { 
 + / / if we see schema , we can proceed to the next check directly 
 + if ( ! Schema . instance . getVersion ( ) . equals ( SchemaConstants . emptyVersion ) ) 
 + { 
 + logger . debug ( " got schema : { } " , Schema . instance . getVersion ( ) ) ; 
 + break ; 
 + } 
 + Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; 
 + } 
 + / / if our schema hasn ' t matched yet , wait until it has 
 + / / we do this by waiting for all in - flight migration requests and responses to complete 
 + / / ( post CASSANDRA - 1391 we don ' t expect this to be necessary very often , but it doesn ' t hurt to be careful ) 
 + if ( ! MigrationManager . isReadyForBootstrap ( ) ) 
 + { 
 + setMode ( Mode . JOINING , " waiting for schema information to complete " , true ) ; 
 + MigrationManager . waitUntilReadyForBootstrap ( ) ; 
 + } 
 + } 
 + 
 private void joinTokenRing ( int delay ) throws ConfigurationException 
 { 
 joined = true ; 
 @ @ - 867 , 25 + 895 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 else 
 SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . IN _ PROGRESS ) ; 
 setMode ( Mode . JOINING , " waiting for ring information " , true ) ; 
 - / / first sleep the delay to make sure we see all our peers 
 - for ( int i = 0 ; i < delay ; i + = 1000 ) 
 - { 
 - / / if we see schema , we can proceed to the next check directly 
 - if ( ! Schema . instance . getVersion ( ) . equals ( SchemaConstants . emptyVersion ) ) 
 - { 
 - logger . debug ( " got schema : { } " , Schema . instance . getVersion ( ) ) ; 
 - break ; 
 - } 
 - Uninterruptibles . sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; 
 - } 
 - / / if our schema hasn ' t matched yet , wait until it has 
 - / / we do this by waiting for all in - flight migration requests and responses to complete 
 - / / ( post CASSANDRA - 1391 we don ' t expect this to be necessary very often , but it doesn ' t hurt to be careful ) 
 - if ( ! MigrationManager . isReadyForBootstrap ( ) ) 
 - { 
 - setMode ( Mode . JOINING , " waiting for schema information to complete " , true ) ; 
 - MigrationManager . waitUntilReadyForBootstrap ( ) ; 
 - } 
 + waitForSchema ( delay ) ; 
 setMode ( Mode . JOINING , " schema complete , ready to bootstrap " , true ) ; 
 setMode ( Mode . JOINING , " waiting for pending range calculation " , true ) ; 
 PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; 
 @ @ - 912 , 7 + 922 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 throw new UnsupportedOperationException ( s ) ; 
 } 
 setMode ( Mode . JOINING , " getting bootstrap token " , true ) ; 
 - bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) ) ; 
 + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) , delay ) ; 
 } 
 else 
 { 
 @ @ - 968 , 22 + 978 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 bootstrapTokens = SystemKeyspace . getSavedTokens ( ) ; 
 if ( bootstrapTokens . isEmpty ( ) ) 
 { 
 - Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; 
 - if ( initialTokens . size ( ) < 1 ) 
 - { 
 - bootstrapTokens = BootStrapper . getRandomTokens ( tokenMetadata , DatabaseDescriptor . getNumTokens ( ) ) ; 
 - if ( DatabaseDescriptor . getNumTokens ( ) = = 1 ) 
 - logger . warn ( " Generated random token { } . Random tokens will result in an unbalanced ring ; see http : / / wiki . apache . org / cassandra / Operations " , bootstrapTokens ) ; 
 - else 
 - logger . info ( " Generated random tokens . tokens are { } " , bootstrapTokens ) ; 
 - } 
 - else 
 - { 
 - bootstrapTokens = new ArrayList < > ( initialTokens . size ( ) ) ; 
 - for ( String token : initialTokens ) 
 - bootstrapTokens . add ( getTokenFactory ( ) . fromString ( token ) ) ; 
 - logger . info ( " Saved tokens not found . Using configuration value : { } " , bootstrapTokens ) ; 
 - } 
 + bootstrapTokens = BootStrapper . getBootstrapTokens ( tokenMetadata , FBUtilities . getBroadcastAddress ( ) , delay ) ; 
 } 
 else 
 { 
 diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 index 3af52e5 . . ed15a70 100644 
 - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 @ @ - 224 , 7 + 224 , 7 @ @ public class BootStrapperTest 
 private void allocateTokensForNode ( int vn , String ks , TokenMetadata tm , InetAddress addr ) 
 { 
 SummaryStatistics os = TokenAllocation . replicatedOwnershipStats ( tm . cloneOnlyTokenMap ( ) , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ; 
 - Collection < Token > tokens = BootStrapper . allocateTokens ( tm , addr , ks , vn ) ; 
 + Collection < Token > tokens = BootStrapper . allocateTokens ( tm , addr , ks , vn , 0 ) ; 
 assertEquals ( vn , tokens . size ( ) ) ; 
 tm . updateNormalTokens ( tokens , addr ) ; 
 SummaryStatistics ns = TokenAllocation . replicatedOwnershipStats ( tm . cloneOnlyTokenMap ( ) , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0ce9ee6 . . 8dfd1f8 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 725 , 10 + 725 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 void doCleanup ( SSTableReader sstable ) throws IOException 
 { 
 assert sstable ! = null ; 
 - List < Range > myRanges ; 
 - Map < EndPoint , List < Range > > endPointtoRangeMap = StorageService . instance ( ) . constructEndPointToRangesMap ( ) ; 
 - myRanges = endPointtoRangeMap . get ( StorageService . getLocalStorageEndPoint ( ) ) ; 
 - List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , myRanges , null ) ; 
 + List < SSTableReader > sstables = doFileAntiCompaction ( Arrays . asList ( sstable ) , StorageService . instance ( ) . getLocalRanges ( ) , null ) ; 
 if ( ! sstables . isEmpty ( ) ) 
 { 
 assert sstables . size ( ) = = 1 ; 
 @ @ - 764 , 7 + 761 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 long startTime = System . currentTimeMillis ( ) ; 
 long totalkeysWritten = 0 ; 
 
 - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ; 
 + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) ( SSTableReader . getApproximateKeyCount ( sstables ) / 2 ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; 
 
 @ @ - 844 , 7 + 841 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 long startTime = System . currentTimeMillis ( ) ; 
 long totalkeysWritten = 0 ; 
 
 - int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , SSTableReader . getApproximateKeyCount ( sstables ) ) ; 
 + / / TODO the int cast here is potentially buggy 
 + int expectedBloomFilterSize = Math . max ( SSTableReader . indexInterval ( ) , ( int ) SSTableReader . getApproximateKeyCount ( sstables ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Expected bloom filter size : " + expectedBloomFilterSize ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / DecoratedKey . java b / src / java / org / apache / cassandra / db / DecoratedKey . java 
 index 1b9af39 . . b2a72da 100644 
 - - - a / src / java / org / apache / cassandra / db / DecoratedKey . java 
 + + + b / src / java / org / apache / cassandra / db / DecoratedKey . java 
 @ @ - 24 , 7 + 24 , 7 @ @ import org . apache . cassandra . dht . Token ; 
 * Represents a decorated key , handy for certain operations 
 * where just working with strings gets slow . 
 * / 
 - public class DecoratedKey < T extends Token > 
 + public class DecoratedKey < T extends Token > implements Comparable < DecoratedKey > 
 { 
 public final T token ; 
 public final String key ; 
 @ @ - 32 , 6 + 32 , 7 @ @ public class DecoratedKey < T extends Token > 
 public DecoratedKey ( T token , String key ) 
 { 
 super ( ) ; 
 + assert key ! = null ; 
 this . token = token ; 
 this . key = key ; 
 } 
 @ @ - 55 , 20 + 56 , 22 @ @ public class DecoratedKey < T extends Token > 
 return false ; 
 if ( getClass ( ) ! = obj . getClass ( ) ) 
 return false ; 
 + 
 DecoratedKey other = ( DecoratedKey ) obj ; 
 - if ( key = = null ) 
 - { 
 - if ( other . key ! = null ) 
 - return false ; 
 - } else if ( ! key . equals ( other . key ) ) 
 - return false ; 
 + / / either both should be of a class where all tokens are null , or neither 
 + assert ( token = = null ) = = ( other . token = = null ) ; 
 if ( token = = null ) 
 - { 
 - if ( other . token ! = null ) 
 - return false ; 
 - } else if ( ! token . equals ( other . token ) ) 
 - return false ; 
 - return true ; 
 + return key . equals ( other . key ) ; 
 + return token . equals ( other . token ) & & key . equals ( other . key ) ; 
 + } 
 + 
 + public int compareTo ( DecoratedKey other ) 
 + { 
 + assert ( token = = null ) = = ( other . token = = null ) ; 
 + if ( token = = null ) 
 + return key . compareTo ( other . key ) ; 
 + int i = token . compareTo ( other . token ) ; 
 + return i = = 0 ? key . compareTo ( other . key ) : i ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index b61991e . . 5503a8f 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 492 , 7 + 492 , 7 @ @ public class Table 
 } 
 
 / * 
 - * Get the list of all SSTables on disk . Not safe unless you aquire the CFS readlocks ! 
 + * Get the list of all SSTables on disk . 
 * / 
 public List < SSTableReader > getAllSSTablesOnDisk ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 35cab21 . . 9402048 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 41 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . LogUtil ; 
 * / 
 public class BootStrapper implements Runnable 
 { 
 + public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms 
 + 
 private static Logger logger _ = Logger . getLogger ( BootStrapper . class ) ; 
 - private static final long INITIAL _ DELAY = 60 * 1000 ; / / ms 
 + 
 / * endpoints that need to be bootstrapped * / 
 protected EndPoint [ ] targets _ = new EndPoint [ 0 ] ; 
 / * tokens of the nodes being bootstrapped . * / 
 @ @ - 60 , 10 + 62 , 6 @ @ public class BootStrapper implements Runnable 
 { 
 try 
 { 
 - / * Initial delay waiting for this node to get a stable endpoint map * / 
 - Thread . sleep ( INITIAL _ DELAY ) ; 
 - / * Clone again now so we include all discovered nodes in our calculations * / 
 - tokenMetadata _ = StorageService . instance ( ) . getTokenMetadata ( ) ; 
 / / Mark as not bootstrapping to calculate ranges correctly 
 for ( int i = 0 ; i < targets _ . length ; i + + ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / SSTableReader . java b / src / java / org / apache / cassandra / io / SSTableReader . java 
 index 1954732 . . c498a7e 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / SSTableReader . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . log4j . Logger ; 
 import org . apache . commons . lang . StringUtils ; 
 
 import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . utils . BloomFilter ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 @ @ - 86 , 9 + 87 , 14 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > 
 return INDEX _ INTERVAL ; 
 } 
 
 - public static int getApproximateKeyCount ( Iterable < SSTableReader > sstables ) 
 + public static long getApproximateKeyCount ( ) 
 { 
 - int count = 0 ; 
 + return getApproximateKeyCount ( openedFiles . values ( ) ) ; 
 + } 
 + 
 + public static long getApproximateKeyCount ( Iterable < SSTableReader > sstables ) 
 + { 
 + long count = 0 ; 
 
 for ( SSTableReader sstable : sstables ) 
 { 
 @ @ - 101 , 6 + 107 , 30 @ @ public class SSTableReader extends SSTable implements Comparable < SSTableReader > 
 return count ; 
 } 
 
 + / * * 
 + * Get all indexed keys in any SSTable for our primary range 
 + * TODO add option to include keys from one or more other ranges 
 + * / 
 + public static List < DecoratedKey > getIndexedDecoratedKeys ( ) 
 + { 
 + Range range = StorageService . instance ( ) . getLocalPrimaryRange ( ) ; 
 + List < DecoratedKey > indexedKeys = new ArrayList < DecoratedKey > ( ) ; 
 + 
 + for ( SSTableReader sstable : openedFiles . values ( ) ) 
 + { 
 + for ( KeyPosition kp : sstable . getIndexPositions ( ) ) 
 + { 
 + if ( range . contains ( kp . key . token ) ) 
 + { 
 + indexedKeys . add ( kp . key ) ; 
 + } 
 + } 
 + } 
 + Collections . sort ( indexedKeys ) ; 
 + 
 + return indexedKeys ; 
 + } 
 + 
 public static SSTableReader open ( String dataFileName ) throws IOException 
 { 
 return open ( dataFileName , StorageService . getPartitioner ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / SSTableWriter . java b / src / java / org / apache / cassandra / io / SSTableWriter . java 
 index 41f3de1 . . 1340d2c 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / SSTableWriter . java 
 @ @ - 46 , 12 + 46 , 12 @ @ public class SSTableWriter extends SSTable 
 private DecoratedKey lastWrittenKey ; 
 private BloomFilter bf ; 
 
 - public SSTableWriter ( String filename , int keyCount , IPartitioner partitioner ) throws IOException 
 + public SSTableWriter ( String filename , long keyCount , IPartitioner partitioner ) throws IOException 
 { 
 super ( filename , partitioner ) ; 
 dataFile = new BufferedRandomAccessFile ( path , " rw " , ( int ) ( DatabaseDescriptor . getFlushDataBufferSizeInMB ( ) * 1024 * 1024 ) ) ; 
 indexFile = new BufferedRandomAccessFile ( indexFilename ( ) , " rw " , ( int ) ( DatabaseDescriptor . getFlushIndexBufferSizeInMB ( ) * 1024 * 1024 ) ) ; 
 - bf = new BloomFilter ( keyCount , 15 ) ; 
 + bf = new BloomFilter ( ( int ) keyCount , 15 ) ; / / TODO fix long - > int cast 
 } 
 
 private long beforeAppend ( DecoratedKey decoratedKey ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index c685711 . . 6758b2f 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 77 , 8 + 77 , 7 @ @ public class CassandraDaemon 
 } ) ; 
 
 / / initialize stuff 
 - Set < String > tables = DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ; 
 - for ( String table : tables ) 
 + for ( String table : DatabaseDescriptor . getTableToColumnFamilyMap ( ) . keySet ( ) ) 
 { 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " opening keyspace " + table ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraServer . java b / src / java / org / apache / cassandra / service / CassandraServer . java 
 index 1228525 . . 8b6a607 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraServer . java 
 @ @ - 525 , 10 + 525 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 { 
 return DatabaseDescriptor . getTables ( ) ; 
 } 
 - else 
 - { 
 - return new ArrayList < String > ( ) ; 
 - } 
 + return Collections . emptyList ( ) ; 
 } 
 
 public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 7a7c1cd . . 5a4e5e3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . service ; 
 
 import java . io . File ; 
 import java . io . IOException ; 
 + import java . io . UnsupportedEncodingException ; 
 import java . lang . management . ManagementFactory ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 @ @ - 27 , 8 + 28 , 7 @ @ import java . util . * ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . LinkedBlockingQueue ; 
 import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . locks . Lock ; 
 - import java . util . concurrent . locks . ReentrantLock ; 
 + import java . util . concurrent . locks . Condition ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 @ @ - 43 , 8 + 43 , 18 @ @ import org . apache . cassandra . net . io . StreamContextManager ; 
 import org . apache . cassandra . tools . MembershipCleanerVerbHandler ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . SimpleCondition ; 
 + import org . apache . cassandra . io . SSTableReader ; 
 + import org . apache . thrift . protocol . TBinaryProtocol ; 
 + import org . apache . thrift . transport . TSocket ; 
 + import org . apache . thrift . transport . TTransport ; 
 + import org . apache . thrift . transport . TTransportException ; 
 + import org . apache . thrift . TException ; 
 + 
 import org . apache . log4j . Logger ; 
 import org . apache . log4j . Level ; 
 + import org . apache . commons . lang . ArrayUtils ; 
 
 / * 
 * This abstraction contains the token / identifier of this node 
 @ @ - 77 , 6 + 87 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 public final static String mbrshipCleanerVerbHandler _ = " MBRSHIP - CLEANER - VERB - HANDLER " ; 
 public final static String bsMetadataVerbHandler _ = " BS - METADATA - VERB - HANDLER " ; 
 public final static String rangeVerbHandler _ = " RANGE - VERB - HANDLER " ; 
 + public final static String bootstrapTokenVerbHandler _ = " SPLITS - VERB - HANDLER " ; 
 
 private static StorageService instance _ ; 
 private static EndPoint tcpAddr _ ; 
 @ @ - 97 , 6 + 108 , 16 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 return partitioner _ ; 
 } 
 
 + public List < Range > getLocalRanges ( ) 
 + { 
 + return getRangesForEndPoint ( getLocalStorageEndPoint ( ) ) ; 
 + } 
 + 
 + public Range getLocalPrimaryRange ( ) 
 + { 
 + return getPrimaryRangeForEndPoint ( getLocalStorageEndPoint ( ) ) ; 
 + } 
 + 
 static 
 { 
 partitioner _ = DatabaseDescriptor . getPartitioner ( ) ; 
 @ @ - 254 , 6 + 275 , 24 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . mbrshipCleanerVerbHandler _ , new MembershipCleanerVerbHandler ( ) ) ; 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bsMetadataVerbHandler _ , new BootstrapMetadataVerbHandler ( ) ) ; 
 MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . rangeVerbHandler _ , new RangeVerbHandler ( ) ) ; 
 + MessagingService . getMessagingInstance ( ) . registerVerbHandlers ( StorageService . bootstrapTokenVerbHandler _ , new IVerbHandler ( ) 
 + { 
 + public void doVerb ( Message message ) 
 + { 
 + List < String > tokens = getSplits ( 2 ) ; 
 + assert tokens . size ( ) = = 3 : tokens . size ( ) ; 
 + Message response ; 
 + try 
 + { 
 + response = message . getReply ( getLocalStorageEndPoint ( ) , tokens . get ( 1 ) . getBytes ( " UTF - 8 " ) ) ; 
 + } 
 + catch ( UnsupportedEncodingException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + MessagingService . getMessagingInstance ( ) . sendOneWay ( response , message . getFrom ( ) ) ; 
 + } 
 + } ) ; 
 
 / * register the stage for the mutations * / 
 consistencyManager _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getConsistencyThreads ( ) , 
 @ @ - 309 , 12 + 348 , 56 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Gossiper . instance ( ) . addApplicationState ( StorageService . nodeId _ , state ) ; 
 if ( isBootstrapMode ) 
 { 
 - logger _ . info ( " Starting in bootstrap mode " ) ; 
 + logger _ . info ( " Starting in bootstrap mode ( first , sleeping to get load information ) " ) ; 
 + / / wait for node information to be available . if the rest of the cluster just came up , 
 + / / this could be up to threshold _ ms ( currently 5 minutes ) . 
 + try 
 + { 
 + while ( storageLoadBalancer _ . getLoadInfo ( ) . isEmpty ( ) ) 
 + { 
 + Thread . sleep ( 100 ) ; 
 + } 
 + / / one more sleep in case there are some stragglers 
 + Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + 
 + / / if initialtoken was specified , use that . otherwise , pick a token to assume half the load of the most - loaded node . 
 + if ( DatabaseDescriptor . getInitialToken ( ) = = null ) 
 + { 
 + double maxLoad = 0 ; 
 + EndPoint maxEndpoint = null ; 
 + for ( Map . Entry < EndPoint , Double > entry : storageLoadBalancer _ . getLoadInfo ( ) . entrySet ( ) ) 
 + { 
 + if ( maxEndpoint = = null | | entry . getValue ( ) > maxLoad ) 
 + { 
 + maxEndpoint = entry . getKey ( ) ; 
 + maxLoad = entry . getValue ( ) ; 
 + } 
 + } 
 + if ( ! maxEndpoint . equals ( getLocalStorageEndPoint ( ) ) ) 
 + { 
 + Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; 
 + logger _ . info ( " Setting token to " + t + " to assume load from " + maxEndpoint . getHost ( ) ) ; 
 + updateToken ( t ) ; 
 + } 
 + } 
 doBootstrap ( StorageService . getLocalStorageEndPoint ( ) ) ; 
 Gossiper . instance ( ) . addApplicationState ( BOOTSTRAP _ MODE , new ApplicationState ( " " ) ) ; 
 } 
 } 
 - 
 + 
 + private Token < ? > getBootstrapTokenFrom ( EndPoint maxEndpoint ) 
 + { 
 + Message message = new Message ( getLocalStorageEndPoint ( ) , " " , bootstrapTokenVerbHandler _ , ArrayUtils . EMPTY _ BYTE _ ARRAY ) ; 
 + BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; 
 + MessagingService . getMessagingInstance ( ) . sendRR ( message , maxEndpoint , btc ) ; 
 + return btc . getToken ( ) ; 
 + } 
 + 
 public boolean isBootstrapMode ( ) 
 { 
 return isBootstrapMode ; 
 @ @ - 1058 , 4 + 1141 , 68 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Logger . getLogger ( classQualifier ) . setLevel ( level ) ; 
 logger _ . info ( " set log level to " + level + " for classes under ' " + classQualifier + " ' ( if the level doesn ' t look like ' " + rawLevel + " ' then log4j couldn ' t parse ' " + rawLevel + " ' ) " ) ; 
 } 
 + 
 + / * * 
 + * @ param splits : number of ranges to break into . Minimum 2 . 
 + * @ return list of Tokens ( _ not _ keys ! ) breaking up the data this node is responsible for into ` splits ` pieces . 
 + * There will be 1 more token than splits requested . So for splits of 2 , tokens T1 T2 T3 will be returned , 
 + * where ( T1 , T2 ] is the first range and ( T2 , T3 ] is the second . The first token will always be the left 
 + * Token of this node ' s primary range , and the last will always be the Right token of that range . 
 + * / 
 + public List < String > getSplits ( int splits ) 
 + { 
 + assert splits > 1 ; 
 + / / we use the actual Range token for the first and last brackets of the splits to ensure correctness 
 + / / ( we ' re only operating on 1 / 128 of the keys remember ) 
 + Range range = getLocalPrimaryRange ( ) ; 
 + List < String > tokens = new ArrayList < String > ( ) ; 
 + tokens . add ( range . left ( ) . toString ( ) ) ; 
 + 
 + List < DecoratedKey > decoratedKeys = SSTableReader . getIndexedDecoratedKeys ( ) ; 
 + for ( int i = 1 ; i < splits ; i + + ) 
 + { 
 + int index = i * ( decoratedKeys . size ( ) / splits ) ; 
 + tokens . add ( decoratedKeys . get ( index ) . token . toString ( ) ) ; 
 + } 
 + 
 + tokens . add ( range . right ( ) . toString ( ) ) ; 
 + return tokens ; 
 + } 
 + 
 + class BootstrapTokenCallback implements IAsyncCallback 
 + { 
 + private volatile Token < ? > token ; 
 + private final Condition condition = new SimpleCondition ( ) ; 
 + 
 + public Token < ? > getToken ( ) 
 + { 
 + try 
 + { 
 + condition . await ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + return token ; 
 + } 
 + 
 + public void response ( Message msg ) 
 + { 
 + try 
 + { 
 + token = partitioner _ . getTokenFactory ( ) . fromString ( new String ( msg . getMessageBody ( ) , " UTF - 8 " ) ) ; 
 + } 
 + catch ( UnsupportedEncodingException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + condition . signalAll ( ) ; 
 + } 
 + 
 + public void attachContext ( Object o ) 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + } 
 }
