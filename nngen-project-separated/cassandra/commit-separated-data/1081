BLEU SCORE: 0.008058772966335387

TEST MSG: Fix bad merge
GENERATED MSG: MV timestamp should be the maximum of the values , not the minimum

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / view / TemporalRow . java b / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> index 8898857 . . 8ee310d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> + + + b / src / java / org / apache / cassandra / db / view / TemporalRow . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . Comparator ; <nl> import java . util . HashMap ; <nl> import java . util . Iterator ; <nl> import java . util . List ; <nl> @ @ - 279 , 9 + 280 , 7 @ @ public class TemporalRow <nl> this . nowInSec = nowInSec ; <nl> <nl> LivenessInfo liveness = row . primaryKeyLivenessInfo ( ) ; <nl> - this . viewClusteringLocalDeletionTime = minValueIfSet ( viewClusteringLocalDeletionTime , row . deletion ( ) . time ( ) . localDeletionTime ( ) , NO _ DELETION _ TIME ) ; <nl> - this . viewClusteringTimestamp = minValueIfSet ( viewClusteringTimestamp , liveness . timestamp ( ) , NO _ TIMESTAMP ) ; <nl> - this . viewClusteringTtl = minValueIfSet ( viewClusteringTtl , liveness . ttl ( ) , NO _ TTL ) ; <nl> + updateLiveness ( liveness . ttl ( ) , liveness . timestamp ( ) , row . deletion ( ) . time ( ) . localDeletionTime ( ) ) ; <nl> <nl> List < ColumnDefinition > clusteringDefs = baseCfs . metadata . clusteringColumns ( ) ; <nl> clusteringColumns = new HashMap < > ( ) ; <nl> @ @ - 295 , 6 + 294 , 31 @ @ public class TemporalRow <nl> } <nl> } <nl> <nl> + / * <nl> + * PK ts : 5 , ttl : 1 , deletion : 2 <nl> + * Col ts : 4 , ttl : 2 , deletion : 3 <nl> + * <nl> + * TTL use min , since it expires at the lowest time which we are expiring . If we have the above values , we <nl> + * would want to return 1 , since the base row expires in 1 second . <nl> + * <nl> + * Timestamp uses max , as this is the time that the row has been written to the view . See CASSANDRA - 10910 . <nl> + * <nl> + * Local Deletion Time should use max , as this deletion will cover all previous values written . <nl> + * / <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + private void updateLiveness ( int ttl , long timestamp , int localDeletionTime ) <nl> + { <nl> + / / We are returning whichever is higher from valueIfSet <nl> + / / Natural order will return the max : 1 . compareTo ( 2 ) < 0 , so 2 is returned <nl> + / / Reverse order will return the min : 1 . compareTo ( 2 ) > 0 , so 1 is returned <nl> + final Comparator max = Comparator . naturalOrder ( ) ; <nl> + final Comparator min = Comparator . reverseOrder ( ) ; <nl> + <nl> + this . viewClusteringTtl = valueIfSet ( viewClusteringTtl , ttl , NO _ TTL , min ) ; <nl> + this . viewClusteringTimestamp = valueIfSet ( viewClusteringTimestamp , timestamp , NO _ TIMESTAMP , max ) ; <nl> + this . viewClusteringLocalDeletionTime = valueIfSet ( viewClusteringLocalDeletionTime , localDeletionTime , NO _ DELETION _ TIME , max ) ; <nl> + } <nl> + <nl> @ Override <nl> public String toString ( ) <nl> { <nl> @ @ - 351 , 30 + 375 , 33 @ @ public class TemporalRow <nl> / / If this column is part of the view ' s primary keys <nl> if ( viewPrimaryKey . contains ( identifier ) ) <nl> { <nl> - this . viewClusteringTtl = minValueIfSet ( this . viewClusteringTtl , ttl , NO _ TTL ) ; <nl> - this . viewClusteringTimestamp = minValueIfSet ( this . viewClusteringTimestamp , timestamp , NO _ TIMESTAMP ) ; <nl> - this . viewClusteringLocalDeletionTime = minValueIfSet ( this . viewClusteringLocalDeletionTime , localDeletionTime , NO _ DELETION _ TIME ) ; <nl> + updateLiveness ( ttl , timestamp , localDeletionTime ) ; <nl> } <nl> <nl> innerMap . get ( cellPath ) . setVersion ( new TemporalCell ( value , timestamp , ttl , localDeletionTime , isNew ) ) ; <nl> } <nl> <nl> - private static int minValueIfSet ( int existing , int update , int defaultValue ) <nl> - { <nl> - if ( existing = = defaultValue ) <nl> - return update ; <nl> - if ( update = = defaultValue ) <nl> - return existing ; <nl> - return Math . min ( existing , update ) ; <nl> - } <nl> - <nl> - private static long minValueIfSet ( long existing , long update , long defaultValue ) <nl> + / * * <nl> + * @ return <nl> + * < ul > <nl> + * < li > <nl> + * If both existing and update are defaultValue , return defaultValue <nl> + * < / li > <nl> + * < li > <nl> + * If only one of existing or existing are defaultValue , return the one which is not <nl> + * < / li > <nl> + * < li > <nl> + * If both existing and update are not defaultValue , compare using comparator and return the higher one . <nl> + * < / li > <nl> + * < / ul > <nl> + * / <nl> + private static < T > T valueIfSet ( T existing , T update , T defaultValue , Comparator < T > comparator ) <nl> { <nl> - if ( existing = = defaultValue ) <nl> + if ( existing . equals ( defaultValue ) ) <nl> return update ; <nl> - if ( update = = defaultValue ) <nl> + if ( update . equals ( defaultValue ) ) <nl> return existing ; <nl> - return Math . min ( existing , update ) ; <nl> + return comparator . compare ( existing , update ) > 0 ? existing : update ; <nl> } <nl> <nl> public int viewClusteringTtl ( ) <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / ViewTest . java b / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> index 8ae21df . . 2e3cf5f 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / ViewTest . java <nl> @ @ - 275 , 6 + 275 , 36 @ @ public class ViewTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> + public void testRegularColumnTimestampUpdates ( ) throws Throwable <nl> + { <nl> + / / Regression test for CASSANDRA - 10910 <nl> + <nl> + createTable ( " CREATE TABLE % s ( " + <nl> + " k int PRIMARY KEY , " + <nl> + " c int , " + <nl> + " val int ) " ) ; <nl> + <nl> + execute ( " USE " + keyspace ( ) ) ; <nl> + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; <nl> + <nl> + createView ( " mv _ rctstest " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY ( k , c ) " ) ; <nl> + <nl> + updateView ( " UPDATE % s SET c = ? , val = ? WHERE k = ? " , 0 , 0 , 0 ) ; <nl> + updateView ( " UPDATE % s SET val = ? WHERE k = ? " , 1 , 0 ) ; <nl> + updateView ( " UPDATE % s SET c = ? WHERE k = ? " , 1 , 0 ) ; <nl> + assertRows ( execute ( " SELECT c , k , val FROM mv _ rctstest " ) , row ( 1 , 0 , 1 ) ) ; <nl> + <nl> + updateView ( " TRUNCATE % s " ) ; <nl> + <nl> + updateView ( " UPDATE % s USING TIMESTAMP 1 SET c = ? , val = ? WHERE k = ? " , 0 , 0 , 0 ) ; <nl> + updateView ( " UPDATE % s USING TIMESTAMP 3 SET c = ? WHERE k = ? " , 1 , 0 ) ; <nl> + updateView ( " UPDATE % s USING TIMESTAMP 2 SET val = ? WHERE k = ? " , 1 , 0 ) ; <nl> + updateView ( " UPDATE % s USING TIMESTAMP 4 SET c = ? WHERE k = ? " , 2 , 0 ) ; <nl> + updateView ( " UPDATE % s USING TIMESTAMP 3 SET val = ? WHERE k = ? " , 2 , 0 ) ; <nl> + assertRows ( execute ( " SELECT c , k , val FROM mv _ rctstest " ) , row ( 2 , 0 , 2 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testCountersTable ( ) throws Throwable <nl> { <nl> createTable ( " CREATE TABLE % s ( " +
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / view / TemporalRow . java b / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 index 8898857 . . 8ee310d 100644 
 - - - a / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 + + + b / src / java / org / apache / cassandra / db / view / TemporalRow . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . Comparator ; 
 import java . util . HashMap ; 
 import java . util . Iterator ; 
 import java . util . List ; 
 @ @ - 279 , 9 + 280 , 7 @ @ public class TemporalRow 
 this . nowInSec = nowInSec ; 
 
 LivenessInfo liveness = row . primaryKeyLivenessInfo ( ) ; 
 - this . viewClusteringLocalDeletionTime = minValueIfSet ( viewClusteringLocalDeletionTime , row . deletion ( ) . time ( ) . localDeletionTime ( ) , NO _ DELETION _ TIME ) ; 
 - this . viewClusteringTimestamp = minValueIfSet ( viewClusteringTimestamp , liveness . timestamp ( ) , NO _ TIMESTAMP ) ; 
 - this . viewClusteringTtl = minValueIfSet ( viewClusteringTtl , liveness . ttl ( ) , NO _ TTL ) ; 
 + updateLiveness ( liveness . ttl ( ) , liveness . timestamp ( ) , row . deletion ( ) . time ( ) . localDeletionTime ( ) ) ; 
 
 List < ColumnDefinition > clusteringDefs = baseCfs . metadata . clusteringColumns ( ) ; 
 clusteringColumns = new HashMap < > ( ) ; 
 @ @ - 295 , 6 + 294 , 31 @ @ public class TemporalRow 
 } 
 } 
 
 + / * 
 + * PK ts : 5 , ttl : 1 , deletion : 2 
 + * Col ts : 4 , ttl : 2 , deletion : 3 
 + * 
 + * TTL use min , since it expires at the lowest time which we are expiring . If we have the above values , we 
 + * would want to return 1 , since the base row expires in 1 second . 
 + * 
 + * Timestamp uses max , as this is the time that the row has been written to the view . See CASSANDRA - 10910 . 
 + * 
 + * Local Deletion Time should use max , as this deletion will cover all previous values written . 
 + * / 
 + @ SuppressWarnings ( " unchecked " ) 
 + private void updateLiveness ( int ttl , long timestamp , int localDeletionTime ) 
 + { 
 + / / We are returning whichever is higher from valueIfSet 
 + / / Natural order will return the max : 1 . compareTo ( 2 ) < 0 , so 2 is returned 
 + / / Reverse order will return the min : 1 . compareTo ( 2 ) > 0 , so 1 is returned 
 + final Comparator max = Comparator . naturalOrder ( ) ; 
 + final Comparator min = Comparator . reverseOrder ( ) ; 
 + 
 + this . viewClusteringTtl = valueIfSet ( viewClusteringTtl , ttl , NO _ TTL , min ) ; 
 + this . viewClusteringTimestamp = valueIfSet ( viewClusteringTimestamp , timestamp , NO _ TIMESTAMP , max ) ; 
 + this . viewClusteringLocalDeletionTime = valueIfSet ( viewClusteringLocalDeletionTime , localDeletionTime , NO _ DELETION _ TIME , max ) ; 
 + } 
 + 
 @ Override 
 public String toString ( ) 
 { 
 @ @ - 351 , 30 + 375 , 33 @ @ public class TemporalRow 
 / / If this column is part of the view ' s primary keys 
 if ( viewPrimaryKey . contains ( identifier ) ) 
 { 
 - this . viewClusteringTtl = minValueIfSet ( this . viewClusteringTtl , ttl , NO _ TTL ) ; 
 - this . viewClusteringTimestamp = minValueIfSet ( this . viewClusteringTimestamp , timestamp , NO _ TIMESTAMP ) ; 
 - this . viewClusteringLocalDeletionTime = minValueIfSet ( this . viewClusteringLocalDeletionTime , localDeletionTime , NO _ DELETION _ TIME ) ; 
 + updateLiveness ( ttl , timestamp , localDeletionTime ) ; 
 } 
 
 innerMap . get ( cellPath ) . setVersion ( new TemporalCell ( value , timestamp , ttl , localDeletionTime , isNew ) ) ; 
 } 
 
 - private static int minValueIfSet ( int existing , int update , int defaultValue ) 
 - { 
 - if ( existing = = defaultValue ) 
 - return update ; 
 - if ( update = = defaultValue ) 
 - return existing ; 
 - return Math . min ( existing , update ) ; 
 - } 
 - 
 - private static long minValueIfSet ( long existing , long update , long defaultValue ) 
 + / * * 
 + * @ return 
 + * < ul > 
 + * < li > 
 + * If both existing and update are defaultValue , return defaultValue 
 + * < / li > 
 + * < li > 
 + * If only one of existing or existing are defaultValue , return the one which is not 
 + * < / li > 
 + * < li > 
 + * If both existing and update are not defaultValue , compare using comparator and return the higher one . 
 + * < / li > 
 + * < / ul > 
 + * / 
 + private static < T > T valueIfSet ( T existing , T update , T defaultValue , Comparator < T > comparator ) 
 { 
 - if ( existing = = defaultValue ) 
 + if ( existing . equals ( defaultValue ) ) 
 return update ; 
 - if ( update = = defaultValue ) 
 + if ( update . equals ( defaultValue ) ) 
 return existing ; 
 - return Math . min ( existing , update ) ; 
 + return comparator . compare ( existing , update ) > 0 ? existing : update ; 
 } 
 
 public int viewClusteringTtl ( ) 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / ViewTest . java b / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 index 8ae21df . . 2e3cf5f 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / ViewTest . java 
 @ @ - 275 , 6 + 275 , 36 @ @ public class ViewTest extends CQLTester 
 } 
 
 @ Test 
 + public void testRegularColumnTimestampUpdates ( ) throws Throwable 
 + { 
 + / / Regression test for CASSANDRA - 10910 
 + 
 + createTable ( " CREATE TABLE % s ( " + 
 + " k int PRIMARY KEY , " + 
 + " c int , " + 
 + " val int ) " ) ; 
 + 
 + execute ( " USE " + keyspace ( ) ) ; 
 + executeNet ( protocolVersion , " USE " + keyspace ( ) ) ; 
 + 
 + createView ( " mv _ rctstest " , " CREATE MATERIALIZED VIEW % s AS SELECT * FROM % % s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY ( k , c ) " ) ; 
 + 
 + updateView ( " UPDATE % s SET c = ? , val = ? WHERE k = ? " , 0 , 0 , 0 ) ; 
 + updateView ( " UPDATE % s SET val = ? WHERE k = ? " , 1 , 0 ) ; 
 + updateView ( " UPDATE % s SET c = ? WHERE k = ? " , 1 , 0 ) ; 
 + assertRows ( execute ( " SELECT c , k , val FROM mv _ rctstest " ) , row ( 1 , 0 , 1 ) ) ; 
 + 
 + updateView ( " TRUNCATE % s " ) ; 
 + 
 + updateView ( " UPDATE % s USING TIMESTAMP 1 SET c = ? , val = ? WHERE k = ? " , 0 , 0 , 0 ) ; 
 + updateView ( " UPDATE % s USING TIMESTAMP 3 SET c = ? WHERE k = ? " , 1 , 0 ) ; 
 + updateView ( " UPDATE % s USING TIMESTAMP 2 SET val = ? WHERE k = ? " , 1 , 0 ) ; 
 + updateView ( " UPDATE % s USING TIMESTAMP 4 SET c = ? WHERE k = ? " , 2 , 0 ) ; 
 + updateView ( " UPDATE % s USING TIMESTAMP 3 SET val = ? WHERE k = ? " , 2 , 0 ) ; 
 + assertRows ( execute ( " SELECT c , k , val FROM mv _ rctstest " ) , row ( 2 , 0 , 2 ) ) ; 
 + } 
 + 
 + @ Test 
 public void testCountersTable ( ) throws Throwable 
 { 
 createTable ( " CREATE TABLE % s ( " +

NEAREST DIFF:
ELIMINATEDSENTENCE
