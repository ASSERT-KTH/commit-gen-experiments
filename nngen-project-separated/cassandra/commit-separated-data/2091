BLEU SCORE: 0.035802380724744266

TEST MSG: merge from 2 . 0
GENERATED MSG: Archive any commitlog segments present at startup

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9881a94 . . 3c217e2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 50 , 6 + 50 , 7 @ @ <nl> * Make repair - pr work with - local ( CASSANDRA - 7450 ) <nl> * Fix error in sstableloader with - cph > 1 ( CASSANDRA - 8007 ) <nl> Merged from 2 . 0 : <nl> + * Archive any commitlog segments present at startup ( CASSANDRA - 6904 ) <nl> * CrcCheckChance should adjust based on live CFMetadata not <nl> sstable metadata ( CASSANDRA - 7978 ) <nl> * token ( ) should only accept columns in the partitioning <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index d2a5fa7 . . d38c4ed 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 90 , 9 + 90 , 7 @ @ public class CommitLog implements CommitLogMBean <nl> * / <nl> public int recover ( ) throws IOException <nl> { <nl> - archiver . maybeRestoreArchive ( ) ; <nl> - <nl> - File [ ] files = new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( new FilenameFilter ( ) <nl> + FilenameFilter unmanagedFilesFilter = new FilenameFilter ( ) <nl> { <nl> public boolean accept ( File dir , String name ) <nl> { <nl> @ @ - 101 , 8 + 99 , 19 @ @ public class CommitLog implements CommitLogMBean <nl> / / ahead and allow writes before recover ( ) , and just skip active segments when we do . <nl> return CommitLogDescriptor . isValid ( name ) & & ! instance . allocator . manages ( name ) ; <nl> } <nl> - } ) ; <nl> + } ; <nl> + <nl> + / / submit all existing files in the commit log dir for archiving prior to recovery - CASSANDRA - 6904 <nl> + for ( File file : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ) <nl> + { <nl> + archiver . maybeArchive ( file . getPath ( ) , file . getName ( ) ) ; <nl> + archiver . maybeWaitForArchiving ( file . getName ( ) ) ; <nl> + } <nl> + <nl> + assert archiver . archivePending . isEmpty ( ) : " Not all commit log archive tasks were completed before restore " ; <nl> + archiver . maybeRestoreArchive ( ) ; <nl> <nl> + File [ ] files = new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ; <nl> int replayed = 0 ; <nl> if ( files . length = = 0 ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java <nl> index 2795cae . . c385f75 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java <nl> @ @ - 120 , 6 + 120 , 28 @ @ public class CommitLogArchiver <nl> } ) ) ; <nl> } <nl> <nl> + / * * <nl> + * Differs from the above because it can be used on any file , rather than only <nl> + * managed commit log segments ( and thus cannot call waitForFinalSync ) . <nl> + * <nl> + * Used to archive files present in the commit log directory at startup ( CASSANDRA - 6904 ) <nl> + * / <nl> + public void maybeArchive ( final String path , final String name ) <nl> + { <nl> + if ( Strings . isNullOrEmpty ( archiveCommand ) ) <nl> + return ; <nl> + <nl> + archivePending . put ( name , executor . submit ( new WrappedRunnable ( ) <nl> + { <nl> + protected void runMayThrow ( ) throws IOException <nl> + { <nl> + String command = archiveCommand . replace ( " % name " , name ) ; <nl> + command = command . replace ( " % path " , path ) ; <nl> + exec ( command ) ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + <nl> public boolean maybeWaitForArchiving ( String name ) <nl> { <nl> Future < ? > f = archivePending . remove ( name ) ; <nl> @ @ - 179 , 7 + 201 , 11 @ @ public class CommitLogArchiver <nl> <nl> File toFile = new File ( DatabaseDescriptor . getCommitLogLocation ( ) , descriptor . fileName ( ) ) ; <nl> if ( toFile . exists ( ) ) <nl> - throw new IllegalStateException ( " Trying to restore archive " + fromFile . getPath ( ) + " , but the same segment already exists in the restore location : " + toFile . getPath ( ) ) ; <nl> + { <nl> + logger . debug ( " Skipping restore of archive { } as the segment already exists in the restore location { } " , <nl> + fromFile . getPath ( ) , toFile . getPath ( ) ) ; <nl> + continue ; <nl> + } <nl> <nl> String command = restoreCommand . replace ( " % from " , fromFile . getPath ( ) ) ; <nl> command = command . replace ( " % to " , toFile . getPath ( ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9881a94 . . 3c217e2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 50 , 6 + 50 , 7 @ @ 
 * Make repair - pr work with - local ( CASSANDRA - 7450 ) 
 * Fix error in sstableloader with - cph > 1 ( CASSANDRA - 8007 ) 
 Merged from 2 . 0 : 
 + * Archive any commitlog segments present at startup ( CASSANDRA - 6904 ) 
 * CrcCheckChance should adjust based on live CFMetadata not 
 sstable metadata ( CASSANDRA - 7978 ) 
 * token ( ) should only accept columns in the partitioning 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index d2a5fa7 . . d38c4ed 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 90 , 9 + 90 , 7 @ @ public class CommitLog implements CommitLogMBean 
 * / 
 public int recover ( ) throws IOException 
 { 
 - archiver . maybeRestoreArchive ( ) ; 
 - 
 - File [ ] files = new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( new FilenameFilter ( ) 
 + FilenameFilter unmanagedFilesFilter = new FilenameFilter ( ) 
 { 
 public boolean accept ( File dir , String name ) 
 { 
 @ @ - 101 , 8 + 99 , 19 @ @ public class CommitLog implements CommitLogMBean 
 / / ahead and allow writes before recover ( ) , and just skip active segments when we do . 
 return CommitLogDescriptor . isValid ( name ) & & ! instance . allocator . manages ( name ) ; 
 } 
 - } ) ; 
 + } ; 
 + 
 + / / submit all existing files in the commit log dir for archiving prior to recovery - CASSANDRA - 6904 
 + for ( File file : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ) 
 + { 
 + archiver . maybeArchive ( file . getPath ( ) , file . getName ( ) ) ; 
 + archiver . maybeWaitForArchiving ( file . getName ( ) ) ; 
 + } 
 + 
 + assert archiver . archivePending . isEmpty ( ) : " Not all commit log archive tasks were completed before restore " ; 
 + archiver . maybeRestoreArchive ( ) ; 
 
 + File [ ] files = new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( unmanagedFilesFilter ) ; 
 int replayed = 0 ; 
 if ( files . length = = 0 ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java 
 index 2795cae . . c385f75 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogArchiver . java 
 @ @ - 120 , 6 + 120 , 28 @ @ public class CommitLogArchiver 
 } ) ) ; 
 } 
 
 + / * * 
 + * Differs from the above because it can be used on any file , rather than only 
 + * managed commit log segments ( and thus cannot call waitForFinalSync ) . 
 + * 
 + * Used to archive files present in the commit log directory at startup ( CASSANDRA - 6904 ) 
 + * / 
 + public void maybeArchive ( final String path , final String name ) 
 + { 
 + if ( Strings . isNullOrEmpty ( archiveCommand ) ) 
 + return ; 
 + 
 + archivePending . put ( name , executor . submit ( new WrappedRunnable ( ) 
 + { 
 + protected void runMayThrow ( ) throws IOException 
 + { 
 + String command = archiveCommand . replace ( " % name " , name ) ; 
 + command = command . replace ( " % path " , path ) ; 
 + exec ( command ) ; 
 + } 
 + } ) ) ; 
 + } 
 + 
 public boolean maybeWaitForArchiving ( String name ) 
 { 
 Future < ? > f = archivePending . remove ( name ) ; 
 @ @ - 179 , 7 + 201 , 11 @ @ public class CommitLogArchiver 
 
 File toFile = new File ( DatabaseDescriptor . getCommitLogLocation ( ) , descriptor . fileName ( ) ) ; 
 if ( toFile . exists ( ) ) 
 - throw new IllegalStateException ( " Trying to restore archive " + fromFile . getPath ( ) + " , but the same segment already exists in the restore location : " + toFile . getPath ( ) ) ; 
 + { 
 + logger . debug ( " Skipping restore of archive { } as the segment already exists in the restore location { } " , 
 + fromFile . getPath ( ) , toFile . getPath ( ) ) ; 
 + continue ; 
 + } 
 
 String command = restoreCommand . replace ( " % from " , fromFile . getPath ( ) ) ; 
 command = command . replace ( " % to " , toFile . getPath ( ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
