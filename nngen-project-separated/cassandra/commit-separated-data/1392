BLEU SCORE: 0.015761706576336954

TEST MSG: Add the removal of ' index _ interval ' to the NEWS file
GENERATED MSG: add http : / / wiki . apache . org / cassandra / FAQ # cli _ keys to 0 . 8 Upgrading section

TEST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index 26fe902 . . 3ba7efa 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 64 , 6 + 64 , 9 @ @ Upgrading <nl> be done by setting the new option ` enabled ` to ` false ` . <nl> - Only map syntax is now allowed for caching options . ALL / NONE / KEYS _ ONLY / ROWS _ ONLY syntax <nl> has been deprecated since 2 . 1 . 0 and is being removed in 3 . 0 . 0 . <nl> + - The ' index _ interval ' option for ' CREATE TABLE ' statements , which has been deprecated <nl> + since 2 . 0 and replaced with the ' min _ index _ interval ' and ' max _ index _ interval ' options , <nl> + has now been removed . <nl> - Batchlog entries are now stored in a new table - system . batches . <nl> The old one has been deprecated . <nl> - JMX methods set / getCompactionStrategyClass have been removed , use
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4eb0642 . . 8ca363d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 39 , 6 + 39 , 7 @ @ <nl> and string representations in CLI ( CASSANDRA - 3075 ) <nl> * always hint counters ( CASSANDRA - 3099 ) <nl> * fix log4j initialization in EmbeddedCassandraService ( CASSANDRA - 2857 ) <nl> + * fix corner cases in Range . differenceToFetch ( CASSANDRA - 3084 ) <nl> <nl> <nl> 0 . 8 . 4 <nl> diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java <nl> index fe5f45b . . 6161a29 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Range . java <nl> + + + b / src / java / org / apache / cassandra / dht / Range . java <nl> @ @ - 261 , 6 + 261 , 24 @ @ public class Range extends AbstractBounds implements Comparable < Range > , Serializ <nl> } <nl> <nl> / * * <nl> + * Subtracts a portion of this range . <nl> + * @ param contained The range to subtract from this . It must be totally <nl> + * contained by this range . <nl> + * @ return An ArrayList of the Ranges left after subtracting contained <nl> + * from this . <nl> + * / <nl> + private ArrayList < Range > subtractContained ( Range contained ) <nl> + { <nl> + ArrayList < Range > difference = new ArrayList < Range > ( ) ; <nl> + <nl> + if ( ! left . equals ( contained . left ) ) <nl> + difference . add ( new Range ( left , contained . left ) ) ; <nl> + if ( ! right . equals ( contained . right ) ) <nl> + difference . add ( new Range ( contained . right , right ) ) ; <nl> + return difference ; <nl> + } <nl> + <nl> + / * * <nl> * Calculate set of the difference ranges of given two ranges <nl> * ( as current ( A , B ] and rhs is ( C , D ] ) <nl> * which node will need to fetch when moving to a given new token <nl> @ @ - 270 , 33 + 288 , 35 @ @ public class Range extends AbstractBounds implements Comparable < Range > , Serializ <nl> * / <nl> public Set < Range > differenceToFetch ( Range rhs ) <nl> { <nl> - Set < Range > difference = new HashSet < Range > ( ) ; <nl> - <nl> - int comparisonAC = Range . compare ( left , rhs . left ) ; <nl> - <nl> - if ( comparisonAC = = 0 ) / / ( A , B ] & ( A , C ] <nl> + Set < Range > result ; <nl> + Set < Range > intersectionSet = this . intersectionWith ( rhs ) ; <nl> + if ( intersectionSet . isEmpty ( ) ) <nl> { <nl> - if ( Range . compare ( right , rhs . right ) < 0 ) / / B < C <nl> - { <nl> - difference . add ( new Range ( right , rhs . right ) ) ; <nl> - } <nl> + result = new HashSet < Range > ( ) ; <nl> + result . add ( rhs ) ; <nl> } <nl> - else if ( comparisonAC > 0 ) / / ( A , B ] & ( C , D ] where C < A ( A > C ) <nl> + else <nl> { <nl> - difference . add ( new Range ( rhs . left , left ) ) ; / / first interval will be ( C , A ] <nl> - <nl> - if ( Range . compare ( rhs . right , right ) > 0 ) / / D > B <nl> + Range [ ] intersections = new Range [ intersectionSet . size ( ) ] ; <nl> + intersectionSet . toArray ( intersections ) ; <nl> + if ( intersections . length = = 1 ) <nl> { <nl> - difference . add ( new Range ( rhs . right , right ) ) ; / / ( D , B ] <nl> + result = new HashSet < Range > ( rhs . subtractContained ( intersections [ 0 ] ) ) ; <nl> + } <nl> + else <nl> + { <nl> + / / intersections . length must be 2 <nl> + Range first = intersections [ 0 ] ; <nl> + Range second = intersections [ 1 ] ; <nl> + ArrayList < Range > temp = rhs . subtractContained ( first ) ; <nl> + <nl> + / / Because there are two intersections , subtracting only one of them <nl> + / / will yield a single Range . <nl> + Range single = temp . get ( 0 ) ; <nl> + result = new HashSet < Range > ( single . subtractContained ( second ) ) ; <nl> } <nl> } <nl> - else / / ( A , B ] & ( C , D ] where C > A ( mean that comparisonAC < 0 ) <nl> - { <nl> - Token newLeft = ( Range . compare ( rhs . left , right ) > 0 ) ? rhs . left : right ; / / C > B ? ( C , D ] : ( B , D ] <nl> - difference . add ( new Range ( newLeft , rhs . right ) ) ; <nl> - } <nl> - <nl> - return difference ; <nl> + return result ; <nl> } <nl> <nl> public static boolean isTokenInRanges ( Token token , Iterable < Range > ranges ) <nl> diff - - git a / test / unit / org / apache / cassandra / dht / RangeTest . java b / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> index a961b8d . . 5506f54 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / RangeTest . java <nl> @ @ - 19 , 12 + 19 , 10 @ @ <nl> package org . apache . cassandra . dht ; <nl> <nl> import java . nio . ByteBuffer ; <nl> - import java . util . Arrays ; <nl> - import java . util . List ; <nl> + import java . util . HashSet ; <nl> import java . util . Set ; <nl> <nl> import org . apache . commons . lang . StringUtils ; <nl> - <nl> import org . junit . Test ; <nl> <nl> public class RangeTest <nl> @ @ - 314 , 4 + 312 , 151 @ @ public class RangeTest <nl> assert Range . compare ( t5 , t4 ) = = 1 ; <nl> assert Range . compare ( t1 , t4 ) = = 0 ; <nl> } <nl> + <nl> + private Range makeRange ( String token1 , String token2 ) <nl> + { <nl> + return new Range ( new BigIntegerToken ( token1 ) , new BigIntegerToken ( token2 ) ) ; <nl> + } <nl> + <nl> + private Set < Range > makeRanges ( String [ ] [ ] tokenPairs ) <nl> + { <nl> + Set < Range > ranges = new HashSet < Range > ( ) ; <nl> + for ( int i = 0 ; i < tokenPairs . length ; + + i ) <nl> + ranges . add ( makeRange ( tokenPairs [ i ] [ 0 ] , tokenPairs [ i ] [ 1 ] ) ) ; <nl> + return ranges ; <nl> + } <nl> + <nl> + private void checkDifference ( Range oldRange , String [ ] [ ] newTokens , String [ ] [ ] expected ) <nl> + { <nl> + Set < Range > ranges = makeRanges ( newTokens ) ; <nl> + for ( Range newRange : ranges ) <nl> + { <nl> + Set < Range > diff = oldRange . differenceToFetch ( newRange ) ; <nl> + assert diff . equals ( makeRanges ( expected ) ) : " \ n " + <nl> + " Old range : " + oldRange . toString ( ) + " \ n " + <nl> + " New range : " + newRange . toString ( ) + " \ n " + <nl> + " Difference : ( result ) " + diff . toString ( ) + " ! = " + makeRanges ( expected ) + " ( expected ) " ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testDifferenceToFetchNoWrap ( ) <nl> + { <nl> + Range oldRange = makeRange ( " 10 " , " 40 " ) ; <nl> + <nl> + / / New range is entirely contained <nl> + String [ ] [ ] newTokens1 = { { " 20 " , " 30 " } , { " 10 " , " 20 " } , { " 10 " , " 40 " } , { " 20 " , " 40 " } } ; <nl> + String [ ] [ ] expected1 = { } ; <nl> + checkDifference ( oldRange , newTokens1 , expected1 ) ; <nl> + <nl> + / / Right half of the new range is needed <nl> + String [ ] [ ] newTokens2 = { { " 10 " , " 50 " } , { " 20 " , " 50 " } , { " 40 " , " 50 " } } ; <nl> + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens2 , expected2 ) ; <nl> + <nl> + / / Left half of the new range is needed <nl> + String [ ] [ ] newTokens3 = { { " 0 " , " 10 " } , { " 0 " , " 20 " } , { " 0 " , " 40 " } } ; <nl> + String [ ] [ ] expected3 = { { " 0 " , " 10 " } } ; <nl> + checkDifference ( oldRange , newTokens3 , expected3 ) ; <nl> + <nl> + / / Parts on both ends of the new range are needed <nl> + String [ ] [ ] newTokens4 = { { " 0 " , " 50 " } } ; <nl> + String [ ] [ ] expected4 = { { " 0 " , " 10 " } , { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens4 , expected4 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testDifferenceToFetchBothWrap ( ) <nl> + { <nl> + Range oldRange = makeRange ( " 1010 " , " 40 " ) ; <nl> + <nl> + / / New range is entirely contained <nl> + String [ ] [ ] newTokens1 = { { " 1020 " , " 30 " } , { " 1010 " , " 20 " } , { " 1010 " , " 40 " } , { " 1020 " , " 40 " } } ; <nl> + String [ ] [ ] expected1 = { } ; <nl> + checkDifference ( oldRange , newTokens1 , expected1 ) ; <nl> + <nl> + / / Right half of the new range is needed <nl> + String [ ] [ ] newTokens2 = { { " 1010 " , " 50 " } , { " 1020 " , " 50 " } , { " 1040 " , " 50 " } } ; <nl> + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens2 , expected2 ) ; <nl> + <nl> + / / Left half of the new range is needed <nl> + String [ ] [ ] newTokens3 = { { " 1000 " , " 10 " } , { " 1000 " , " 20 " } , { " 1000 " , " 40 " } } ; <nl> + String [ ] [ ] expected3 = { { " 1000 " , " 1010 " } } ; <nl> + checkDifference ( oldRange , newTokens3 , expected3 ) ; <nl> + <nl> + / / Parts on both ends of the new range are needed <nl> + String [ ] [ ] newTokens4 = { { " 1000 " , " 50 " } } ; <nl> + String [ ] [ ] expected4 = { { " 1000 " , " 1010 " } , { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens4 , expected4 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testDifferenceToFetchOldWraps ( ) <nl> + { <nl> + Range oldRange = makeRange ( " 1010 " , " 40 " ) ; <nl> + <nl> + / / New range is entirely contained <nl> + String [ ] [ ] newTokens1 = { { " 0 " , " 30 " } , { " 0 " , " 40 " } , { " 10 " , " 40 " } } ; <nl> + String [ ] [ ] expected1 = { } ; <nl> + checkDifference ( oldRange , newTokens1 , expected1 ) ; <nl> + <nl> + / / Right half of the new range is needed <nl> + String [ ] [ ] newTokens2 = { { " 0 " , " 50 " } , { " 10 " , " 50 " } , { " 40 " , " 50 " } } ; <nl> + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens2 , expected2 ) ; <nl> + <nl> + / / Whole range is needed <nl> + String [ ] [ ] newTokens3 = { { " 50 " , " 90 " } } ; <nl> + String [ ] [ ] expected3 = { { " 50 " , " 90 " } } ; <nl> + checkDifference ( oldRange , newTokens3 , expected3 ) ; <nl> + <nl> + / / Both ends of the new range overlaps the old range <nl> + String [ ] [ ] newTokens4 = { { " 10 " , " 1010 " } , { " 40 " , " 1010 " } , { " 10 " , " 1030 " } , { " 40 " , " 1030 " } } ; <nl> + String [ ] [ ] expected4 = { { " 40 " , " 1010 " } } ; <nl> + checkDifference ( oldRange , newTokens4 , expected4 ) ; <nl> + <nl> + / / Only RHS of the new range overlaps the old range <nl> + String [ ] [ ] newTokens5 = { { " 60 " , " 1010 " } , { " 60 " , " 1030 " } } ; <nl> + String [ ] [ ] expected5 = { { " 60 " , " 1010 " } } ; <nl> + checkDifference ( oldRange , newTokens5 , expected5 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testDifferenceToFetchNewWraps ( ) <nl> + { <nl> + Range oldRange = makeRange ( " 0 " , " 40 " ) ; <nl> + <nl> + / / Only the LHS of the new range is needed <nl> + String [ ] [ ] newTokens1 = { { " 1010 " , " 0 " } , { " 1010 " , " 10 " } , { " 1010 " , " 40 " } } ; <nl> + String [ ] [ ] expected1 = { { " 1010 " , " 0 " } } ; <nl> + checkDifference ( oldRange , newTokens1 , expected1 ) ; <nl> + <nl> + / / Both ends of the new range are needed <nl> + String [ ] [ ] newTokens2 = { { " 1010 " , " 50 " } } ; <nl> + String [ ] [ ] expected2 = { { " 1010 " , " 0 " } , { " 40 " , " 50 " } } ; <nl> + checkDifference ( oldRange , newTokens2 , expected2 ) ; <nl> + <nl> + oldRange = makeRange ( " 20 " , " 40 " ) ; <nl> + <nl> + / / Whole new range is needed <nl> + String [ ] [ ] newTokens3 = { { " 1010 " , " 0 " } } ; <nl> + String [ ] [ ] expected3 = { { " 1010 " , " 0 " } } ; <nl> + checkDifference ( oldRange , newTokens3 , expected3 ) ; <nl> + <nl> + / / Whole new range is needed ( matching endpoints ) <nl> + String [ ] [ ] newTokens4 = { { " 1010 " , " 20 " } } ; <nl> + String [ ] [ ] expected4 = { { " 1010 " , " 20 " } } ; <nl> + checkDifference ( oldRange , newTokens4 , expected4 ) ; <nl> + <nl> + / / Only RHS of new range is needed <nl> + String [ ] [ ] newTokens5 = { { " 30 " , " 0 " } , { " 40 " , " 0 " } } ; <nl> + String [ ] [ ] expected5 = { { " 40 " , " 0 " } } ; <nl> + checkDifference ( oldRange , newTokens5 , expected5 ) ; <nl> + <nl> + / / Only RHS of new range is needed ( matching endpoints ) <nl> + String [ ] [ ] newTokens6 = { { " 30 " , " 20 " } , { " 40 " , " 20 " } } ; <nl> + String [ ] [ ] expected6 = { { " 40 " , " 20 " } } ; <nl> + checkDifference ( oldRange , newTokens6 , expected6 ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index 26fe902 . . 3ba7efa 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 64 , 6 + 64 , 9 @ @ Upgrading 
 be done by setting the new option ` enabled ` to ` false ` . 
 - Only map syntax is now allowed for caching options . ALL / NONE / KEYS _ ONLY / ROWS _ ONLY syntax 
 has been deprecated since 2 . 1 . 0 and is being removed in 3 . 0 . 0 . 
 + - The ' index _ interval ' option for ' CREATE TABLE ' statements , which has been deprecated 
 + since 2 . 0 and replaced with the ' min _ index _ interval ' and ' max _ index _ interval ' options , 
 + has now been removed . 
 - Batchlog entries are now stored in a new table - system . batches . 
 The old one has been deprecated . 
 - JMX methods set / getCompactionStrategyClass have been removed , use

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4eb0642 . . 8ca363d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 39 , 6 + 39 , 7 @ @ 
 and string representations in CLI ( CASSANDRA - 3075 ) 
 * always hint counters ( CASSANDRA - 3099 ) 
 * fix log4j initialization in EmbeddedCassandraService ( CASSANDRA - 2857 ) 
 + * fix corner cases in Range . differenceToFetch ( CASSANDRA - 3084 ) 
 
 
 0 . 8 . 4 
 diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java 
 index fe5f45b . . 6161a29 100644 
 - - - a / src / java / org / apache / cassandra / dht / Range . java 
 + + + b / src / java / org / apache / cassandra / dht / Range . java 
 @ @ - 261 , 6 + 261 , 24 @ @ public class Range extends AbstractBounds implements Comparable < Range > , Serializ 
 } 
 
 / * * 
 + * Subtracts a portion of this range . 
 + * @ param contained The range to subtract from this . It must be totally 
 + * contained by this range . 
 + * @ return An ArrayList of the Ranges left after subtracting contained 
 + * from this . 
 + * / 
 + private ArrayList < Range > subtractContained ( Range contained ) 
 + { 
 + ArrayList < Range > difference = new ArrayList < Range > ( ) ; 
 + 
 + if ( ! left . equals ( contained . left ) ) 
 + difference . add ( new Range ( left , contained . left ) ) ; 
 + if ( ! right . equals ( contained . right ) ) 
 + difference . add ( new Range ( contained . right , right ) ) ; 
 + return difference ; 
 + } 
 + 
 + / * * 
 * Calculate set of the difference ranges of given two ranges 
 * ( as current ( A , B ] and rhs is ( C , D ] ) 
 * which node will need to fetch when moving to a given new token 
 @ @ - 270 , 33 + 288 , 35 @ @ public class Range extends AbstractBounds implements Comparable < Range > , Serializ 
 * / 
 public Set < Range > differenceToFetch ( Range rhs ) 
 { 
 - Set < Range > difference = new HashSet < Range > ( ) ; 
 - 
 - int comparisonAC = Range . compare ( left , rhs . left ) ; 
 - 
 - if ( comparisonAC = = 0 ) / / ( A , B ] & ( A , C ] 
 + Set < Range > result ; 
 + Set < Range > intersectionSet = this . intersectionWith ( rhs ) ; 
 + if ( intersectionSet . isEmpty ( ) ) 
 { 
 - if ( Range . compare ( right , rhs . right ) < 0 ) / / B < C 
 - { 
 - difference . add ( new Range ( right , rhs . right ) ) ; 
 - } 
 + result = new HashSet < Range > ( ) ; 
 + result . add ( rhs ) ; 
 } 
 - else if ( comparisonAC > 0 ) / / ( A , B ] & ( C , D ] where C < A ( A > C ) 
 + else 
 { 
 - difference . add ( new Range ( rhs . left , left ) ) ; / / first interval will be ( C , A ] 
 - 
 - if ( Range . compare ( rhs . right , right ) > 0 ) / / D > B 
 + Range [ ] intersections = new Range [ intersectionSet . size ( ) ] ; 
 + intersectionSet . toArray ( intersections ) ; 
 + if ( intersections . length = = 1 ) 
 { 
 - difference . add ( new Range ( rhs . right , right ) ) ; / / ( D , B ] 
 + result = new HashSet < Range > ( rhs . subtractContained ( intersections [ 0 ] ) ) ; 
 + } 
 + else 
 + { 
 + / / intersections . length must be 2 
 + Range first = intersections [ 0 ] ; 
 + Range second = intersections [ 1 ] ; 
 + ArrayList < Range > temp = rhs . subtractContained ( first ) ; 
 + 
 + / / Because there are two intersections , subtracting only one of them 
 + / / will yield a single Range . 
 + Range single = temp . get ( 0 ) ; 
 + result = new HashSet < Range > ( single . subtractContained ( second ) ) ; 
 } 
 } 
 - else / / ( A , B ] & ( C , D ] where C > A ( mean that comparisonAC < 0 ) 
 - { 
 - Token newLeft = ( Range . compare ( rhs . left , right ) > 0 ) ? rhs . left : right ; / / C > B ? ( C , D ] : ( B , D ] 
 - difference . add ( new Range ( newLeft , rhs . right ) ) ; 
 - } 
 - 
 - return difference ; 
 + return result ; 
 } 
 
 public static boolean isTokenInRanges ( Token token , Iterable < Range > ranges ) 
 diff - - git a / test / unit / org / apache / cassandra / dht / RangeTest . java b / test / unit / org / apache / cassandra / dht / RangeTest . java 
 index a961b8d . . 5506f54 100644 
 - - - a / test / unit / org / apache / cassandra / dht / RangeTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / RangeTest . java 
 @ @ - 19 , 12 + 19 , 10 @ @ 
 package org . apache . cassandra . dht ; 
 
 import java . nio . ByteBuffer ; 
 - import java . util . Arrays ; 
 - import java . util . List ; 
 + import java . util . HashSet ; 
 import java . util . Set ; 
 
 import org . apache . commons . lang . StringUtils ; 
 - 
 import org . junit . Test ; 
 
 public class RangeTest 
 @ @ - 314 , 4 + 312 , 151 @ @ public class RangeTest 
 assert Range . compare ( t5 , t4 ) = = 1 ; 
 assert Range . compare ( t1 , t4 ) = = 0 ; 
 } 
 + 
 + private Range makeRange ( String token1 , String token2 ) 
 + { 
 + return new Range ( new BigIntegerToken ( token1 ) , new BigIntegerToken ( token2 ) ) ; 
 + } 
 + 
 + private Set < Range > makeRanges ( String [ ] [ ] tokenPairs ) 
 + { 
 + Set < Range > ranges = new HashSet < Range > ( ) ; 
 + for ( int i = 0 ; i < tokenPairs . length ; + + i ) 
 + ranges . add ( makeRange ( tokenPairs [ i ] [ 0 ] , tokenPairs [ i ] [ 1 ] ) ) ; 
 + return ranges ; 
 + } 
 + 
 + private void checkDifference ( Range oldRange , String [ ] [ ] newTokens , String [ ] [ ] expected ) 
 + { 
 + Set < Range > ranges = makeRanges ( newTokens ) ; 
 + for ( Range newRange : ranges ) 
 + { 
 + Set < Range > diff = oldRange . differenceToFetch ( newRange ) ; 
 + assert diff . equals ( makeRanges ( expected ) ) : " \ n " + 
 + " Old range : " + oldRange . toString ( ) + " \ n " + 
 + " New range : " + newRange . toString ( ) + " \ n " + 
 + " Difference : ( result ) " + diff . toString ( ) + " ! = " + makeRanges ( expected ) + " ( expected ) " ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testDifferenceToFetchNoWrap ( ) 
 + { 
 + Range oldRange = makeRange ( " 10 " , " 40 " ) ; 
 + 
 + / / New range is entirely contained 
 + String [ ] [ ] newTokens1 = { { " 20 " , " 30 " } , { " 10 " , " 20 " } , { " 10 " , " 40 " } , { " 20 " , " 40 " } } ; 
 + String [ ] [ ] expected1 = { } ; 
 + checkDifference ( oldRange , newTokens1 , expected1 ) ; 
 + 
 + / / Right half of the new range is needed 
 + String [ ] [ ] newTokens2 = { { " 10 " , " 50 " } , { " 20 " , " 50 " } , { " 40 " , " 50 " } } ; 
 + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens2 , expected2 ) ; 
 + 
 + / / Left half of the new range is needed 
 + String [ ] [ ] newTokens3 = { { " 0 " , " 10 " } , { " 0 " , " 20 " } , { " 0 " , " 40 " } } ; 
 + String [ ] [ ] expected3 = { { " 0 " , " 10 " } } ; 
 + checkDifference ( oldRange , newTokens3 , expected3 ) ; 
 + 
 + / / Parts on both ends of the new range are needed 
 + String [ ] [ ] newTokens4 = { { " 0 " , " 50 " } } ; 
 + String [ ] [ ] expected4 = { { " 0 " , " 10 " } , { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens4 , expected4 ) ; 
 + } 
 + 
 + @ Test 
 + public void testDifferenceToFetchBothWrap ( ) 
 + { 
 + Range oldRange = makeRange ( " 1010 " , " 40 " ) ; 
 + 
 + / / New range is entirely contained 
 + String [ ] [ ] newTokens1 = { { " 1020 " , " 30 " } , { " 1010 " , " 20 " } , { " 1010 " , " 40 " } , { " 1020 " , " 40 " } } ; 
 + String [ ] [ ] expected1 = { } ; 
 + checkDifference ( oldRange , newTokens1 , expected1 ) ; 
 + 
 + / / Right half of the new range is needed 
 + String [ ] [ ] newTokens2 = { { " 1010 " , " 50 " } , { " 1020 " , " 50 " } , { " 1040 " , " 50 " } } ; 
 + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens2 , expected2 ) ; 
 + 
 + / / Left half of the new range is needed 
 + String [ ] [ ] newTokens3 = { { " 1000 " , " 10 " } , { " 1000 " , " 20 " } , { " 1000 " , " 40 " } } ; 
 + String [ ] [ ] expected3 = { { " 1000 " , " 1010 " } } ; 
 + checkDifference ( oldRange , newTokens3 , expected3 ) ; 
 + 
 + / / Parts on both ends of the new range are needed 
 + String [ ] [ ] newTokens4 = { { " 1000 " , " 50 " } } ; 
 + String [ ] [ ] expected4 = { { " 1000 " , " 1010 " } , { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens4 , expected4 ) ; 
 + } 
 + 
 + @ Test 
 + public void testDifferenceToFetchOldWraps ( ) 
 + { 
 + Range oldRange = makeRange ( " 1010 " , " 40 " ) ; 
 + 
 + / / New range is entirely contained 
 + String [ ] [ ] newTokens1 = { { " 0 " , " 30 " } , { " 0 " , " 40 " } , { " 10 " , " 40 " } } ; 
 + String [ ] [ ] expected1 = { } ; 
 + checkDifference ( oldRange , newTokens1 , expected1 ) ; 
 + 
 + / / Right half of the new range is needed 
 + String [ ] [ ] newTokens2 = { { " 0 " , " 50 " } , { " 10 " , " 50 " } , { " 40 " , " 50 " } } ; 
 + String [ ] [ ] expected2 = { { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens2 , expected2 ) ; 
 + 
 + / / Whole range is needed 
 + String [ ] [ ] newTokens3 = { { " 50 " , " 90 " } } ; 
 + String [ ] [ ] expected3 = { { " 50 " , " 90 " } } ; 
 + checkDifference ( oldRange , newTokens3 , expected3 ) ; 
 + 
 + / / Both ends of the new range overlaps the old range 
 + String [ ] [ ] newTokens4 = { { " 10 " , " 1010 " } , { " 40 " , " 1010 " } , { " 10 " , " 1030 " } , { " 40 " , " 1030 " } } ; 
 + String [ ] [ ] expected4 = { { " 40 " , " 1010 " } } ; 
 + checkDifference ( oldRange , newTokens4 , expected4 ) ; 
 + 
 + / / Only RHS of the new range overlaps the old range 
 + String [ ] [ ] newTokens5 = { { " 60 " , " 1010 " } , { " 60 " , " 1030 " } } ; 
 + String [ ] [ ] expected5 = { { " 60 " , " 1010 " } } ; 
 + checkDifference ( oldRange , newTokens5 , expected5 ) ; 
 + } 
 + 
 + @ Test 
 + public void testDifferenceToFetchNewWraps ( ) 
 + { 
 + Range oldRange = makeRange ( " 0 " , " 40 " ) ; 
 + 
 + / / Only the LHS of the new range is needed 
 + String [ ] [ ] newTokens1 = { { " 1010 " , " 0 " } , { " 1010 " , " 10 " } , { " 1010 " , " 40 " } } ; 
 + String [ ] [ ] expected1 = { { " 1010 " , " 0 " } } ; 
 + checkDifference ( oldRange , newTokens1 , expected1 ) ; 
 + 
 + / / Both ends of the new range are needed 
 + String [ ] [ ] newTokens2 = { { " 1010 " , " 50 " } } ; 
 + String [ ] [ ] expected2 = { { " 1010 " , " 0 " } , { " 40 " , " 50 " } } ; 
 + checkDifference ( oldRange , newTokens2 , expected2 ) ; 
 + 
 + oldRange = makeRange ( " 20 " , " 40 " ) ; 
 + 
 + / / Whole new range is needed 
 + String [ ] [ ] newTokens3 = { { " 1010 " , " 0 " } } ; 
 + String [ ] [ ] expected3 = { { " 1010 " , " 0 " } } ; 
 + checkDifference ( oldRange , newTokens3 , expected3 ) ; 
 + 
 + / / Whole new range is needed ( matching endpoints ) 
 + String [ ] [ ] newTokens4 = { { " 1010 " , " 20 " } } ; 
 + String [ ] [ ] expected4 = { { " 1010 " , " 20 " } } ; 
 + checkDifference ( oldRange , newTokens4 , expected4 ) ; 
 + 
 + / / Only RHS of new range is needed 
 + String [ ] [ ] newTokens5 = { { " 30 " , " 0 " } , { " 40 " , " 0 " } } ; 
 + String [ ] [ ] expected5 = { { " 40 " , " 0 " } } ; 
 + checkDifference ( oldRange , newTokens5 , expected5 ) ; 
 + 
 + / / Only RHS of new range is needed ( matching endpoints ) 
 + String [ ] [ ] newTokens6 = { { " 30 " , " 20 " } , { " 40 " , " 20 " } } ; 
 + String [ ] [ ] expected6 = { { " 40 " , " 20 " } } ; 
 + checkDifference ( oldRange , newTokens6 , expected6 ) ; 
 + } 
 }
