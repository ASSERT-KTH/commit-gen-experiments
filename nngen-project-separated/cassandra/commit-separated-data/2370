BLEU SCORE: 0.027611988917697356

TEST MSG: don ' t mask class ' template parameter
GENERATED MSG: Fixup for 6271

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / btree / Path . java b / src / java / org / apache / cassandra / utils / btree / Path . java <nl> index db6d64e . . b1b0e03 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / Path . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / Path . java <nl> @ @ - 94 , 9 + 94 , 9 @ @ public class Path < V > <nl> * @ param target the key to search for <nl> * @ param mode the type of search to perform <nl> * @ param forwards if the path should be setup for forward or backward iteration <nl> - * @ param < V > <nl> + * @ param < K > <nl> * / <nl> - < V > boolean find ( Comparator < V > comparator , Object target , Op mode , boolean forwards ) <nl> + < K > boolean find ( Comparator < K > comparator , Object target , Op mode , boolean forwards ) <nl> { <nl> / / TODO : should not require parameter ' forwards ' - consider modifying index to represent both <nl> / / child and key position , as opposed to just key position ( which necessitates a different value depending <nl> @ @ - 321 , 7 + 321 , 7 @ @ public class Path < V > <nl> return currentNode ( ) [ currentIndex ( ) ] ; <nl> } <nl> <nl> - int compareTo ( Path that , boolean forwards ) <nl> + int compareTo ( Path < V > that , boolean forwards ) <nl> { <nl> int d = Math . min ( this . depth , that . depth ) ; <nl> for ( int i = 0 ; i < = d ; i + + )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / btree / Path . java b / src / java / org / apache / cassandra / utils / btree / Path . java 
 index db6d64e . . b1b0e03 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / Path . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / Path . java 
 @ @ - 94 , 9 + 94 , 9 @ @ public class Path < V > 
 * @ param target the key to search for 
 * @ param mode the type of search to perform 
 * @ param forwards if the path should be setup for forward or backward iteration 
 - * @ param < V > 
 + * @ param < K > 
 * / 
 - < V > boolean find ( Comparator < V > comparator , Object target , Op mode , boolean forwards ) 
 + < K > boolean find ( Comparator < K > comparator , Object target , Op mode , boolean forwards ) 
 { 
 / / TODO : should not require parameter ' forwards ' - consider modifying index to represent both 
 / / child and key position , as opposed to just key position ( which necessitates a different value depending 
 @ @ - 321 , 7 + 321 , 7 @ @ public class Path < V > 
 return currentNode ( ) [ currentIndex ( ) ] ; 
 } 
 
 - int compareTo ( Path that , boolean forwards ) 
 + int compareTo ( Path < V > that , boolean forwards ) 
 { 
 int d = Math . min ( this . depth , that . depth ) ; 
 for ( int i = 0 ; i < = d ; i + + )

NEAREST DIFF:
ELIMINATEDSENTENCE
