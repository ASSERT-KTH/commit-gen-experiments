BLEU SCORE: 0.03283637368030199

TEST MSG: Fix descending iteration past end of BTreeSearchIterator
GENERATED MSG: merge from 0 . 6

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d95d833 . . 2c0cde2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 0 - rc1 <nl> + * Fix descending iteration past end of BTreeSearchIterator ( CASSANDRA - 10301 ) <nl> * Transfer hints to a different node on decommission ( CASSANDRA - 10198 ) <nl> * Check partition keys for CAS operations during stmt validation ( CASSANDRA - 10338 ) <nl> * Add custom query expressions to SELECT ( CASSANDRA - 10217 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java <nl> index 6d023d2 . . ec16a8e 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java <nl> @ @ - 102 , 9 + 102 , 8 @ @ public class BTreeSearchIterator < K , V > extends TreeCursor < K > implements IndexedS <nl> return null ; <nl> <nl> int state = this . state ; <nl> - int index = seekTo ( target , forwards , ( state & ( ON _ ITEM | BEFORE _ FIRST ) ) ! = 0 ) ; <nl> - boolean found = index > = 0 ; <nl> - if ( ! found ) index = - 1 - index ; <nl> + boolean found = seekTo ( target , forwards , ( state & ( ON _ ITEM | BEFORE _ FIRST ) ) ! = 0 ) ; <nl> + int index = cur . globalIndex ( ) ; <nl> <nl> V next = null ; <nl> if ( state = = BEFORE _ FIRST & & compareToFirst ( index ) < 0 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / TreeCursor . java b / src / java / org / apache / cassandra / utils / btree / TreeCursor . java <nl> index 164b83f . . 5e55698 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / TreeCursor . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / TreeCursor . java <nl> @ @ - 93 , 9 + 93 , 9 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> / * * <nl> * seeks from the current position , forwards or backwards , for the provided key <nl> * while the direction could be inferred ( or ignored ) , it is required so that ( e . g . ) we do not infinitely loop on bad inputs <nl> - * if there is no such key , it moves to the key that would naturally proceed it ( i . e . it behaves as ceil when ascending ; floor when descending ) <nl> + * if there is no such key , it moves to the key that would naturally follow / succeed it ( i . e . it behaves as ceil when ascending ; floor when descending ) <nl> * / <nl> - int seekTo ( K key , boolean forwards , boolean skipOne ) <nl> + boolean seekTo ( K key , boolean forwards , boolean skipOne ) <nl> { <nl> NodeCursor < K > cur = this . cur ; <nl> <nl> @ @ - 114 , 7 + 114 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> { <nl> / / we moved out of the tree ; return out - of - bounds <nl> this . cur = root ( ) ; <nl> - return forwards ? - 1 - size ( rootNode ( ) ) : - 1 ; <nl> + return false ; <nl> } <nl> <nl> if ( tryOne ) <nl> @ @ - 128 , 9 + 128 , 8 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> if ( forwards ? cmp > = 0 : cmp < = 0 ) <nl> { <nl> / / we ' ve either matched , or excluded the value from being present <nl> - int index = cur . globalIndex ( ) ; <nl> this . cur = cur ; <nl> - return cmp = = 0 ? index : - 1 - index ; <nl> + return cmp = = 0 ; <nl> } <nl> } <nl> <nl> @ @ - 151 , 7 + 150 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> if ( cmpbound = = 0 ) / / it was an exact match , so terminate here <nl> { <nl> this . cur = cur ; <nl> - return cur . globalBranchIndex ( ) ; <nl> + return true ; <nl> } <nl> } <nl> <nl> @ @ - 168 , 8 + 167 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> <nl> this . cur = cur ; <nl> assert ! cur . inChild ; <nl> - int index = cur . globalIndex ( ) ; <nl> - return match ? index : - 1 - index ; <nl> + return match ; <nl> } <nl> <nl> / * * <nl> @ @ - 189 , 7 + 187 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > <nl> <nl> / * * <nl> * move out of a leaf node that is currently out of ( its own ) bounds <nl> - * @ return null if we ' re now out - of - bounds of the whole true <nl> + * @ return null if we ' re now out - of - bounds of the whole tree <nl> * / <nl> private < K > NodeCursor < K > moveOutOfLeaf ( boolean forwards , NodeCursor < K > cur , NodeCursor < K > ifFail ) <nl> { <nl> diff - - git a / test / burn / org / apache / cassandra / utils / LongBTreeTest . java b / test / burn / org / apache / cassandra / utils / LongBTreeTest . java <nl> index 0e8c467 . . 5044290 100644 <nl> - - - a / test / burn / org / apache / cassandra / utils / LongBTreeTest . java <nl> + + + b / test / burn / org / apache / cassandra / utils / LongBTreeTest . java <nl> @ @ - 569 , 12 + 569 , 12 @ @ public class LongBTreeTest <nl> boolean useFake = mixInNotPresentItems & & rnd . nextBoolean ( ) ; <nl> final float fakeRatio = rnd . nextFloat ( ) ; <nl> List < Integer > results = new ArrayList < > ( ) ; <nl> - Long fakeLb = null , fakeUb = null ; <nl> + Long fakeLb = ( long ) Integer . MIN _ VALUE , fakeUb = null ; <nl> + Integer max = null ; <nl> for ( Integer v : canonical ) <nl> { <nl> if ( ! useFake <nl> - | | fakeLb = = null <nl> - | | ( fakeUb = = null ? v - 1 : fakeUb ) < = fakeLb + 1 <nl> + | | ( fakeUb = = null ? v - 1 : fakeUb ) < = fakeLb + 1 <nl> | | rnd . nextFloat ( ) < fakeRatio ) <nl> { <nl> / / if we cannot safely construct a fake value , or our randomizer says not to , we emit the next real value <nl> @ @ - 593 , 7 + 593 , 10 @ @ public class LongBTreeTest <nl> results . add ( ( int ) mid ) ; <nl> fakeLb = mid ; <nl> } <nl> + max = v ; <nl> } <nl> + if ( useFake & & max ! = null & & max < Integer . MAX _ VALUE ) <nl> + results . add ( max + 1 ) ; <nl> final float useChance = rnd . nextFloat ( ) ; <nl> return Lists . newArrayList ( filter ( results , ( x ) - > rnd . nextFloat ( ) < useChance ) ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8d9e2ea . . c97b17f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 7 + 1 , 10 @ @ <nl> dev <nl> * sstable versioning ( CASSANDRA - 389 ) <nl> <nl> - 0 . 6 . 0 - dev <nl> + 0 . 6 . 0 - RC1 <nl> + * fix compaction bucketing bug ( CASSANDRA - 814 ) <nl> + <nl> + 0 . 6 . 0 - beta1 / beta2 <nl> * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) <nl> * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) <nl> * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) <nl> @ @ - 42 , 7 + 45 , 9 @ @ dev <nl> * allow larger numbers of keys ( > 140M ) in a sstable bloom filter <nl> ( CASSANDRA - 790 ) <nl> * include jvm argument improvements from CASSANDRA - 504 in debian package <nl> - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * change streaming chunk size to 32MB to accomodate Windows XP limitations <nl> + ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) <nl> <nl> <nl> 0 . 5 . 0 final <nl> diff - - git a / build . xml b / build . xml <nl> index ea79876 . . 54ef12d 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 314 , 6 + 314 , 7 @ @ <nl> < include name = " * * " / > <nl> < exclude name = " build / * * " / > <nl> < exclude name = " src / gen - java / * * " / > <nl> + < exclude name = " interface / avro / * * " / > <nl> < / tarfileset > <nl> < / tar > <nl> < / target > <nl> diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> index fbd5ebb . . 1b5b6b1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return 0 ; <nl> } <nl> logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; <nl> - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> <nl> for ( List < SSTableReader > sstables : buckets ) <nl> @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> / * <nl> * Group files of similar size into buckets . <nl> * / <nl> - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) <nl> + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) <nl> { <nl> Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; <nl> for ( SSTableReader sstable : files ) <nl> @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> / / remove and re - add because adding changes the hash <nl> buckets . remove ( bucket ) ; <nl> - averageSize = ( averageSize + size ) / 2 ; <nl> + long totalSize = bucket . size ( ) * averageSize ; <nl> + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; <nl> bucket . add ( sstable ) ; <nl> buckets . put ( bucket , averageSize ) ; <nl> bFound = true ; <nl> @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> public void run ( ) <nl> { <nl> logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; <nl> - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> } <nl> } ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d95d833 . . 2c0cde2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 0 - rc1 
 + * Fix descending iteration past end of BTreeSearchIterator ( CASSANDRA - 10301 ) 
 * Transfer hints to a different node on decommission ( CASSANDRA - 10198 ) 
 * Check partition keys for CAS operations during stmt validation ( CASSANDRA - 10338 ) 
 * Add custom query expressions to SELECT ( CASSANDRA - 10217 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java 
 index 6d023d2 . . ec16a8e 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSearchIterator . java 
 @ @ - 102 , 9 + 102 , 8 @ @ public class BTreeSearchIterator < K , V > extends TreeCursor < K > implements IndexedS 
 return null ; 
 
 int state = this . state ; 
 - int index = seekTo ( target , forwards , ( state & ( ON _ ITEM | BEFORE _ FIRST ) ) ! = 0 ) ; 
 - boolean found = index > = 0 ; 
 - if ( ! found ) index = - 1 - index ; 
 + boolean found = seekTo ( target , forwards , ( state & ( ON _ ITEM | BEFORE _ FIRST ) ) ! = 0 ) ; 
 + int index = cur . globalIndex ( ) ; 
 
 V next = null ; 
 if ( state = = BEFORE _ FIRST & & compareToFirst ( index ) < 0 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / TreeCursor . java b / src / java / org / apache / cassandra / utils / btree / TreeCursor . java 
 index 164b83f . . 5e55698 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / TreeCursor . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / TreeCursor . java 
 @ @ - 93 , 9 + 93 , 9 @ @ class TreeCursor < K > extends NodeCursor < K > 
 / * * 
 * seeks from the current position , forwards or backwards , for the provided key 
 * while the direction could be inferred ( or ignored ) , it is required so that ( e . g . ) we do not infinitely loop on bad inputs 
 - * if there is no such key , it moves to the key that would naturally proceed it ( i . e . it behaves as ceil when ascending ; floor when descending ) 
 + * if there is no such key , it moves to the key that would naturally follow / succeed it ( i . e . it behaves as ceil when ascending ; floor when descending ) 
 * / 
 - int seekTo ( K key , boolean forwards , boolean skipOne ) 
 + boolean seekTo ( K key , boolean forwards , boolean skipOne ) 
 { 
 NodeCursor < K > cur = this . cur ; 
 
 @ @ - 114 , 7 + 114 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > 
 { 
 / / we moved out of the tree ; return out - of - bounds 
 this . cur = root ( ) ; 
 - return forwards ? - 1 - size ( rootNode ( ) ) : - 1 ; 
 + return false ; 
 } 
 
 if ( tryOne ) 
 @ @ - 128 , 9 + 128 , 8 @ @ class TreeCursor < K > extends NodeCursor < K > 
 if ( forwards ? cmp > = 0 : cmp < = 0 ) 
 { 
 / / we ' ve either matched , or excluded the value from being present 
 - int index = cur . globalIndex ( ) ; 
 this . cur = cur ; 
 - return cmp = = 0 ? index : - 1 - index ; 
 + return cmp = = 0 ; 
 } 
 } 
 
 @ @ - 151 , 7 + 150 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > 
 if ( cmpbound = = 0 ) / / it was an exact match , so terminate here 
 { 
 this . cur = cur ; 
 - return cur . globalBranchIndex ( ) ; 
 + return true ; 
 } 
 } 
 
 @ @ - 168 , 8 + 167 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > 
 
 this . cur = cur ; 
 assert ! cur . inChild ; 
 - int index = cur . globalIndex ( ) ; 
 - return match ? index : - 1 - index ; 
 + return match ; 
 } 
 
 / * * 
 @ @ - 189 , 7 + 187 , 7 @ @ class TreeCursor < K > extends NodeCursor < K > 
 
 / * * 
 * move out of a leaf node that is currently out of ( its own ) bounds 
 - * @ return null if we ' re now out - of - bounds of the whole true 
 + * @ return null if we ' re now out - of - bounds of the whole tree 
 * / 
 private < K > NodeCursor < K > moveOutOfLeaf ( boolean forwards , NodeCursor < K > cur , NodeCursor < K > ifFail ) 
 { 
 diff - - git a / test / burn / org / apache / cassandra / utils / LongBTreeTest . java b / test / burn / org / apache / cassandra / utils / LongBTreeTest . java 
 index 0e8c467 . . 5044290 100644 
 - - - a / test / burn / org / apache / cassandra / utils / LongBTreeTest . java 
 + + + b / test / burn / org / apache / cassandra / utils / LongBTreeTest . java 
 @ @ - 569 , 12 + 569 , 12 @ @ public class LongBTreeTest 
 boolean useFake = mixInNotPresentItems & & rnd . nextBoolean ( ) ; 
 final float fakeRatio = rnd . nextFloat ( ) ; 
 List < Integer > results = new ArrayList < > ( ) ; 
 - Long fakeLb = null , fakeUb = null ; 
 + Long fakeLb = ( long ) Integer . MIN _ VALUE , fakeUb = null ; 
 + Integer max = null ; 
 for ( Integer v : canonical ) 
 { 
 if ( ! useFake 
 - | | fakeLb = = null 
 - | | ( fakeUb = = null ? v - 1 : fakeUb ) < = fakeLb + 1 
 + | | ( fakeUb = = null ? v - 1 : fakeUb ) < = fakeLb + 1 
 | | rnd . nextFloat ( ) < fakeRatio ) 
 { 
 / / if we cannot safely construct a fake value , or our randomizer says not to , we emit the next real value 
 @ @ - 593 , 7 + 593 , 10 @ @ public class LongBTreeTest 
 results . add ( ( int ) mid ) ; 
 fakeLb = mid ; 
 } 
 + max = v ; 
 } 
 + if ( useFake & & max ! = null & & max < Integer . MAX _ VALUE ) 
 + results . add ( max + 1 ) ; 
 final float useChance = rnd . nextFloat ( ) ; 
 return Lists . newArrayList ( filter ( results , ( x ) - > rnd . nextFloat ( ) < useChance ) ) ; 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8d9e2ea . . c97b17f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 7 + 1 , 10 @ @ 
 dev 
 * sstable versioning ( CASSANDRA - 389 ) 
 
 - 0 . 6 . 0 - dev 
 + 0 . 6 . 0 - RC1 
 + * fix compaction bucketing bug ( CASSANDRA - 814 ) 
 + 
 + 0 . 6 . 0 - beta1 / beta2 
 * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) 
 * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) 
 * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) 
 @ @ - 42 , 7 + 45 , 9 @ @ dev 
 * allow larger numbers of keys ( > 140M ) in a sstable bloom filter 
 ( CASSANDRA - 790 ) 
 * include jvm argument improvements from CASSANDRA - 504 in debian package 
 - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) 
 + * change streaming chunk size to 32MB to accomodate Windows XP limitations 
 + ( was 64MB ) ( CASSANDRA - 795 ) 
 + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) 
 
 
 0 . 5 . 0 final 
 diff - - git a / build . xml b / build . xml 
 index ea79876 . . 54ef12d 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 314 , 6 + 314 , 7 @ @ 
 < include name = " * * " / > 
 < exclude name = " build / * * " / > 
 < exclude name = " src / gen - java / * * " / > 
 + < exclude name = " interface / avro / * * " / > 
 < / tarfileset > 
 < / tar > 
 < / target > 
 diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java 
 index fbd5ebb . . 1b5b6b1 100644 
 - - - a / src / java / org / apache / cassandra / db / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / CompactionManager . java 
 @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return 0 ; 
 } 
 logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; 
 - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 
 for ( List < SSTableReader > sstables : buckets ) 
 @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 / * 
 * Group files of similar size into buckets . 
 * / 
 - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) 
 + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) 
 { 
 Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; 
 for ( SSTableReader sstable : files ) 
 @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 / / remove and re - add because adding changes the hash 
 buckets . remove ( bucket ) ; 
 - averageSize = ( averageSize + size ) / 2 ; 
 + long totalSize = bucket . size ( ) * averageSize ; 
 + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; 
 bucket . add ( sstable ) ; 
 buckets . put ( bucket , averageSize ) ; 
 bFound = true ; 
 @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 public void run ( ) 
 { 
 logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; 
 - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 } 
 } ;
