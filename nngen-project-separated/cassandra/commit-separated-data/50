BLEU SCORE: 0.020980574531482755

TEST MSG: In BufferPool , make allocating thread receive a Chunk .
GENERATED MSG: Prevent direct memory OOM on buffer pool allocations

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6d04416 . . f145a06 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * BufferPool : allocating thread for new chunks should acquire directly ( CASSANDRA - 14832 ) <nl> * Send correct messaging version in internode messaging handshake ' s third message ( CASSANDRA - 14896 ) <nl> * Make Read and Write Latency columns consistent for proxyhistograms and tablehistograms ( CASSANDRA - 11939 ) <nl> * Make protocol checksum type option case insensitive ( CASSANDRA - 14716 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / memory / BufferPool . java b / src / java / org / apache / cassandra / utils / memory / BufferPool . java <nl> index c8ad078 . . a67f520 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / memory / BufferPool . java <nl> + + + b / src / java / org / apache / cassandra / utils / memory / BufferPool . java <nl> @ @ - 241 , 23 + 241 , 23 @ @ public class BufferPool <nl> / * * Return a chunk , the caller will take owership of the parent chunk . * / <nl> public Chunk get ( ) <nl> { <nl> - while ( true ) <nl> - { <nl> - Chunk chunk = chunks . poll ( ) ; <nl> - if ( chunk ! = null ) <nl> - return chunk ; <nl> + Chunk chunk = chunks . poll ( ) ; <nl> + if ( chunk ! = null ) <nl> + return chunk ; <nl> <nl> - if ( ! allocateMoreChunks ( ) ) <nl> - / / give it one last attempt , in case someone else allocated before us <nl> - return chunks . poll ( ) ; <nl> - } <nl> + chunk = allocateMoreChunks ( ) ; <nl> + if ( chunk ! = null ) <nl> + return chunk ; <nl> + <nl> + / / another thread may have just allocated last macro chunk , so make one final attempt before returning null <nl> + return chunks . poll ( ) ; <nl> } <nl> <nl> / * * <nl> * This method might be called by multiple threads and that ' s fine if we add more <nl> * than one chunk at the same time as long as we don ' t exceed the MEMORY _ USAGE _ THRESHOLD . <nl> * / <nl> - private boolean allocateMoreChunks ( ) <nl> + private Chunk allocateMoreChunks ( ) <nl> { <nl> while ( true ) <nl> { <nl> @ @ - 266 , 7 + 266 , 7 @ @ public class BufferPool <nl> { <nl> noSpamLogger . info ( " Maximum memory usage reached ( { } ) , cannot allocate chunk of { } " , <nl> MEMORY _ USAGE _ THRESHOLD , MACRO _ CHUNK _ SIZE ) ; <nl> - return false ; <nl> + return null ; <nl> } <nl> if ( memoryUsage . compareAndSet ( cur , cur + MACRO _ CHUNK _ SIZE ) ) <nl> break ; <nl> @ @ - 284 , 20 + 284 , 23 @ @ public class BufferPool <nl> " Attempting to continue ; buffers will be allocated in on - heap memory which can degrade performance . " + <nl> " Make sure direct memory size ( - XX : MaxDirectMemorySize ) is large enough to accommodate off - heap memtables and caches . " , <nl> MACRO _ CHUNK _ SIZE , sizeInBytes ( ) , oom . toString ( ) ) ; <nl> - return false ; <nl> + return null ; <nl> } <nl> <nl> chunk . acquire ( null ) ; <nl> macroChunks . add ( chunk ) ; <nl> - for ( int i = 0 ; i < MACRO _ CHUNK _ SIZE ; i + = CHUNK _ SIZE ) <nl> + <nl> + final Chunk callerChunk = new Chunk ( chunk . get ( CHUNK _ SIZE ) ) ; <nl> + if ( DEBUG ) <nl> + debug . register ( callerChunk ) ; <nl> + for ( int i = CHUNK _ SIZE ; i < MACRO _ CHUNK _ SIZE ; i + = CHUNK _ SIZE ) <nl> { <nl> Chunk add = new Chunk ( chunk . get ( CHUNK _ SIZE ) ) ; <nl> chunks . add ( add ) ; <nl> if ( DEBUG ) <nl> debug . register ( add ) ; <nl> } <nl> - <nl> - return true ; <nl> + return callerChunk ; <nl> } <nl> <nl> public void recycle ( Chunk chunk )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6d04416 . . f145a06 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * BufferPool : allocating thread for new chunks should acquire directly ( CASSANDRA - 14832 ) 
 * Send correct messaging version in internode messaging handshake ' s third message ( CASSANDRA - 14896 ) 
 * Make Read and Write Latency columns consistent for proxyhistograms and tablehistograms ( CASSANDRA - 11939 ) 
 * Make protocol checksum type option case insensitive ( CASSANDRA - 14716 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / memory / BufferPool . java b / src / java / org / apache / cassandra / utils / memory / BufferPool . java 
 index c8ad078 . . a67f520 100644 
 - - - a / src / java / org / apache / cassandra / utils / memory / BufferPool . java 
 + + + b / src / java / org / apache / cassandra / utils / memory / BufferPool . java 
 @ @ - 241 , 23 + 241 , 23 @ @ public class BufferPool 
 / * * Return a chunk , the caller will take owership of the parent chunk . * / 
 public Chunk get ( ) 
 { 
 - while ( true ) 
 - { 
 - Chunk chunk = chunks . poll ( ) ; 
 - if ( chunk ! = null ) 
 - return chunk ; 
 + Chunk chunk = chunks . poll ( ) ; 
 + if ( chunk ! = null ) 
 + return chunk ; 
 
 - if ( ! allocateMoreChunks ( ) ) 
 - / / give it one last attempt , in case someone else allocated before us 
 - return chunks . poll ( ) ; 
 - } 
 + chunk = allocateMoreChunks ( ) ; 
 + if ( chunk ! = null ) 
 + return chunk ; 
 + 
 + / / another thread may have just allocated last macro chunk , so make one final attempt before returning null 
 + return chunks . poll ( ) ; 
 } 
 
 / * * 
 * This method might be called by multiple threads and that ' s fine if we add more 
 * than one chunk at the same time as long as we don ' t exceed the MEMORY _ USAGE _ THRESHOLD . 
 * / 
 - private boolean allocateMoreChunks ( ) 
 + private Chunk allocateMoreChunks ( ) 
 { 
 while ( true ) 
 { 
 @ @ - 266 , 7 + 266 , 7 @ @ public class BufferPool 
 { 
 noSpamLogger . info ( " Maximum memory usage reached ( { } ) , cannot allocate chunk of { } " , 
 MEMORY _ USAGE _ THRESHOLD , MACRO _ CHUNK _ SIZE ) ; 
 - return false ; 
 + return null ; 
 } 
 if ( memoryUsage . compareAndSet ( cur , cur + MACRO _ CHUNK _ SIZE ) ) 
 break ; 
 @ @ - 284 , 20 + 284 , 23 @ @ public class BufferPool 
 " Attempting to continue ; buffers will be allocated in on - heap memory which can degrade performance . " + 
 " Make sure direct memory size ( - XX : MaxDirectMemorySize ) is large enough to accommodate off - heap memtables and caches . " , 
 MACRO _ CHUNK _ SIZE , sizeInBytes ( ) , oom . toString ( ) ) ; 
 - return false ; 
 + return null ; 
 } 
 
 chunk . acquire ( null ) ; 
 macroChunks . add ( chunk ) ; 
 - for ( int i = 0 ; i < MACRO _ CHUNK _ SIZE ; i + = CHUNK _ SIZE ) 
 + 
 + final Chunk callerChunk = new Chunk ( chunk . get ( CHUNK _ SIZE ) ) ; 
 + if ( DEBUG ) 
 + debug . register ( callerChunk ) ; 
 + for ( int i = CHUNK _ SIZE ; i < MACRO _ CHUNK _ SIZE ; i + = CHUNK _ SIZE ) 
 { 
 Chunk add = new Chunk ( chunk . get ( CHUNK _ SIZE ) ) ; 
 chunks . add ( add ) ; 
 if ( DEBUG ) 
 debug . register ( add ) ; 
 } 
 - 
 - return true ; 
 + return callerChunk ; 
 } 
 
 public void recycle ( Chunk chunk )

NEAREST DIFF:
ELIMINATEDSENTENCE
