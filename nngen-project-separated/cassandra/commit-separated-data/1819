BLEU SCORE: 1.0

TEST MSG: Remove cold _ reads _ to _ omit from STCS
GENERATED MSG: Remove cold _ reads _ to _ omit from STCS

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 748acf8 . . 4992d85 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 4 <nl> + * Remove cold _ reads _ to _ omit from STCS ( CASSANDRA - 8860 ) <nl> * Make EstimatedHistogram # percentile ( ) use ceil instead of floor ( CASSANDRA - 8883 ) <nl> * Fix top partitions reporting wrong cardinality ( CASSANDRA - 8834 ) <nl> * Fix rare NPE in KeyCacheSerializer ( CASSANDRA - 8067 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 602770c . . 06013b8 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 13 , 6 + 13 , 14 @ @ restore snapshots created with the previous major version using the <nl> ' sstableloader ' tool . You can upgrade the file format of your snapshots <nl> using the provided ' sstableupgrade ' tool . <nl> <nl> + 2 . 1 . 4 <nl> + = = = = = <nl> + Upgrading <nl> + - - - - - - - - - <nl> + - The option to omit cold sstables with size tiered compaction has been <nl> + removed - it is almost always better to use date tiered compaction for <nl> + workloads that have cold data . <nl> + <nl> 2 . 1 . 3 <nl> = = = = = <nl> <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index f089cd7 . . 88f042e 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 468 , 7 + 468 , 6 @ @ def cf _ prop _ val _ mapkey _ completer ( ctxt , cass ) : <nl> opts . add ( ' min _ threshold ' ) <nl> opts . add ( ' bucket _ high ' ) <nl> opts . add ( ' bucket _ low ' ) <nl> - opts . add ( ' cold _ reads _ to _ omit ' ) <nl> elif csc = = ' LeveledCompactionStrategy ' : <nl> opts . add ( ' sstable _ size _ in _ mb ' ) <nl> elif csc = = ' DateTieredCompactionStrategy ' : <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> index 08102c1 . . 19abd9c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> @ @ - 82 , 7 + 82 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> int maxThreshold = cfs . getMaximumCompactionThreshold ( ) ; <nl> <nl> Iterable < SSTableReader > candidates = filterSuspectSSTables ( Sets . intersection ( cfs . getUncompactingSSTables ( ) , sstables ) ) ; <nl> - candidates = filterColdSSTables ( Lists . newArrayList ( candidates ) , options . coldReadsToOmit , cfs . getMinimumCompactionThreshold ( ) ) ; <nl> <nl> List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( candidates ) , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; <nl> logger . debug ( " Compaction buckets are { } " , buckets ) ; <nl> @ @ - 106 , 141 + 105 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> return Collections . singletonList ( sstablesWithTombstones . get ( 0 ) ) ; <nl> } <nl> <nl> - / * * <nl> - * Removes as many cold sstables as possible while retaining at least 1 - coldReadsToOmit of the total reads / sec <nl> - * across all sstables <nl> - * @ param sstables all sstables to consider <nl> - * @ param coldReadsToOmit the proportion of total reads / sec that will be omitted ( 0 = omit nothing , 1 = omit everything ) <nl> - * @ param minThreshold min compaction threshold <nl> - * @ return a list of sstables with the coldest sstables excluded until the reads they represent reaches coldReadsToOmit <nl> - * / <nl> - @ VisibleForTesting <nl> - static List < SSTableReader > filterColdSSTables ( List < SSTableReader > sstables , double coldReadsToOmit , int minThreshold ) <nl> - { <nl> - if ( coldReadsToOmit = = 0 . 0 ) <nl> - return sstables ; <nl> - <nl> - / / Sort the sstables by hotness ( coldest - first ) . We first build a map because the hotness may change during the sort . <nl> - final Map < SSTableReader , Double > hotnessSnapshot = getHotnessMap ( sstables ) ; <nl> - Collections . sort ( sstables , new Comparator < SSTableReader > ( ) <nl> - { <nl> - public int compare ( SSTableReader o1 , SSTableReader o2 ) <nl> - { <nl> - int comparison = Double . compare ( hotnessSnapshot . get ( o1 ) , hotnessSnapshot . get ( o2 ) ) ; <nl> - if ( comparison ! = 0 ) <nl> - return comparison ; <nl> - <nl> - / / break ties with size on disk ( mainly for system tables and cold tables ) <nl> - comparison = Long . compare ( o1 . bytesOnDisk ( ) , o2 . bytesOnDisk ( ) ) ; <nl> - if ( comparison ! = 0 ) <nl> - return comparison ; <nl> - <nl> - / / if there ' s still a tie , use generation , which is guaranteed to be unique . this ensures that <nl> - / / our filtering is deterministic , which can be useful when debugging . <nl> - return o1 . descriptor . generation - o2 . descriptor . generation ; <nl> - } <nl> - } ) ; <nl> - <nl> - / / calculate the total reads / sec across all sstables <nl> - double totalReads = 0 . 0 ; <nl> - for ( SSTableReader sstr : sstables ) <nl> - if ( sstr . getReadMeter ( ) ! = null ) <nl> - totalReads + = sstr . getReadMeter ( ) . twoHourRate ( ) ; <nl> - <nl> - / / if this is a system table with no read meters or we don ' t have any read rates yet , just return them all <nl> - if ( totalReads = = 0 . 0 ) <nl> - return sstables ; <nl> - <nl> - / / iteratively ignore the coldest sstables until ignoring one more would put us over the coldReadsToOmit threshold <nl> - double maxColdReads = coldReadsToOmit * totalReads ; <nl> - <nl> - double totalColdReads = 0 . 0 ; <nl> - int cutoffIndex = 0 ; <nl> - while ( cutoffIndex < sstables . size ( ) ) <nl> - { <nl> - SSTableReader sstable = sstables . get ( cutoffIndex ) ; <nl> - if ( sstable . getReadMeter ( ) = = null ) <nl> - { <nl> - throw new AssertionError ( " If you ' re seeing this exception , please attach your logs to CASSANDRA - 8238 to help us debug . " + sstable ) ; <nl> - } <nl> - double reads = sstable . getReadMeter ( ) . twoHourRate ( ) ; <nl> - if ( totalColdReads + reads > maxColdReads ) <nl> - break ; <nl> - <nl> - totalColdReads + = reads ; <nl> - cutoffIndex + + ; <nl> - } <nl> - List < SSTableReader > hotSSTables = new ArrayList < > ( sstables . subList ( cutoffIndex , sstables . size ( ) ) ) ; <nl> - List < SSTableReader > coldSSTables = sstables . subList ( 0 , cutoffIndex ) ; <nl> - logger . debug ( " hotSSTables = { } , coldSSTables = { } " , hotSSTables . size ( ) , coldSSTables . size ( ) ) ; <nl> - if ( hotSSTables . size ( ) > = minThreshold ) <nl> - return hotSSTables ; <nl> - if ( coldSSTables . size ( ) < minThreshold ) <nl> - return Collections . emptyList ( ) ; <nl> - <nl> - Map < SSTableReader , Set < SSTableReader > > overlapMap = new HashMap < > ( ) ; <nl> - for ( int i = 0 ; i < coldSSTables . size ( ) ; i + + ) <nl> - { <nl> - SSTableReader sstable = coldSSTables . get ( i ) ; <nl> - Set < SSTableReader > overlaps = new HashSet < > ( ) ; <nl> - for ( int j = 0 ; j < coldSSTables . size ( ) ; j + + ) <nl> - { <nl> - SSTableReader innerSSTable = coldSSTables . get ( j ) ; <nl> - if ( ColumnNameHelper . overlaps ( sstable . getSSTableMetadata ( ) . minColumnNames , <nl> - sstable . getSSTableMetadata ( ) . maxColumnNames , <nl> - innerSSTable . getSSTableMetadata ( ) . minColumnNames , <nl> - innerSSTable . getSSTableMetadata ( ) . maxColumnNames , <nl> - sstable . metadata . comparator ) ) <nl> - { <nl> - overlaps . add ( innerSSTable ) ; <nl> - } <nl> - } <nl> - overlapMap . put ( sstable , overlaps ) ; <nl> - } <nl> - List < Set < SSTableReader > > overlapChains = new ArrayList < > ( ) ; <nl> - for ( SSTableReader sstable : overlapMap . keySet ( ) ) <nl> - overlapChains . add ( createOverlapChain ( sstable , overlapMap ) ) ; <nl> - <nl> - Collections . sort ( overlapChains , new Comparator < Set < SSTableReader > > ( ) <nl> - { <nl> - @ Override <nl> - public int compare ( Set < SSTableReader > o1 , Set < SSTableReader > o2 ) <nl> - { <nl> - return Longs . compare ( SSTableReader . getTotalBytes ( o2 ) , SSTableReader . getTotalBytes ( o1 ) ) ; <nl> - } <nl> - } ) ; <nl> - for ( Set < SSTableReader > overlapping : overlapChains ) <nl> - { <nl> - / / if we are expecting to only keep 70 % of the keys after a compaction , run a compaction on these cold sstables : <nl> - if ( SSTableReader . estimateCompactionGain ( overlapping ) < 0 . 7 ) <nl> - return new ArrayList < > ( overlapping ) ; <nl> - } <nl> - return Collections . emptyList ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * returns a set with all overlapping sstables starting with s . <nl> - * if we have 3 sstables , a , b , c where a overlaps with b , but not c and b overlaps with c , all sstables would be returned . <nl> - * <nl> - * m contains an sstable - > all overlapping mapping <nl> - * / <nl> - private static Set < SSTableReader > createOverlapChain ( SSTableReader s , Map < SSTableReader , Set < SSTableReader > > m ) <nl> - { <nl> - Deque < SSTableReader > sstables = new ArrayDeque < > ( ) ; <nl> - Set < SSTableReader > overlapChain = new HashSet < > ( ) ; <nl> - sstables . push ( s ) ; <nl> - while ( ! sstables . isEmpty ( ) ) <nl> - { <nl> - SSTableReader sstable = sstables . pop ( ) ; <nl> - if ( overlapChain . add ( sstable ) ) <nl> - { <nl> - if ( m . containsKey ( sstable ) ) <nl> - sstables . addAll ( m . get ( sstable ) ) ; <nl> - } <nl> - } <nl> - return overlapChain ; <nl> - } <nl> - <nl> <nl> / * * <nl> * @ param buckets list of buckets from which to return the most interesting , where " interesting " is the total hotness for reads <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java <nl> index 84e7d61 . . 911bb9f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java <nl> @ @ - 26 , 16 + 26 , 13 @ @ public final class SizeTieredCompactionStrategyOptions <nl> protected static final long DEFAULT _ MIN _ SSTABLE _ SIZE = 50L * 1024L * 1024L ; <nl> protected static final double DEFAULT _ BUCKET _ LOW = 0 . 5 ; <nl> protected static final double DEFAULT _ BUCKET _ HIGH = 1 . 5 ; <nl> - protected static final double DEFAULT _ COLD _ READS _ TO _ OMIT = 0 . 05 ; <nl> protected static final String MIN _ SSTABLE _ SIZE _ KEY = " min _ sstable _ size " ; <nl> protected static final String BUCKET _ LOW _ KEY = " bucket _ low " ; <nl> protected static final String BUCKET _ HIGH _ KEY = " bucket _ high " ; <nl> - protected static final String COLD _ READS _ TO _ OMIT _ KEY = " cold _ reads _ to _ omit " ; <nl> <nl> protected long minSSTableSize ; <nl> protected double bucketLow ; <nl> protected double bucketHigh ; <nl> - protected double coldReadsToOmit ; <nl> <nl> public SizeTieredCompactionStrategyOptions ( Map < String , String > options ) <nl> { <nl> @ @ - 45 , 8 + 42 , 6 @ @ public final class SizeTieredCompactionStrategyOptions <nl> bucketLow = optionValue = = null ? DEFAULT _ BUCKET _ LOW : Double . parseDouble ( optionValue ) ; <nl> optionValue = options . get ( BUCKET _ HIGH _ KEY ) ; <nl> bucketHigh = optionValue = = null ? DEFAULT _ BUCKET _ HIGH : Double . parseDouble ( optionValue ) ; <nl> - optionValue = options . get ( COLD _ READS _ TO _ OMIT _ KEY ) ; <nl> - coldReadsToOmit = optionValue = = null ? DEFAULT _ COLD _ READS _ TO _ OMIT : Double . parseDouble ( optionValue ) ; <nl> } <nl> <nl> public SizeTieredCompactionStrategyOptions ( ) <nl> @ @ - 54 , 7 + 49 , 6 @ @ public final class SizeTieredCompactionStrategyOptions <nl> minSSTableSize = DEFAULT _ MIN _ SSTABLE _ SIZE ; <nl> bucketLow = DEFAULT _ BUCKET _ LOW ; <nl> bucketHigh = DEFAULT _ BUCKET _ HIGH ; <nl> - coldReadsToOmit = DEFAULT _ COLD _ READS _ TO _ OMIT ; <nl> } <nl> <nl> private static double parseDouble ( Map < String , String > options , String key , double defaultValue ) throws ConfigurationException <nl> @ @ - 94 , 17 + 88 , 9 @ @ public final class SizeTieredCompactionStrategyOptions <nl> BUCKET _ HIGH _ KEY , bucketHigh , BUCKET _ LOW _ KEY , bucketLow ) ) ; <nl> } <nl> <nl> - double maxColdReadsRatio = parseDouble ( options , COLD _ READS _ TO _ OMIT _ KEY , DEFAULT _ COLD _ READS _ TO _ OMIT ) ; <nl> - if ( maxColdReadsRatio < 0 . 0 | | maxColdReadsRatio > 1 . 0 ) <nl> - { <nl> - throw new ConfigurationException ( String . format ( " % s value ( % s ) should be between between 0 . 0 and 1 . 0 " , <nl> - COLD _ READS _ TO _ OMIT _ KEY , optionValue ) ) ; <nl> - } <nl> - <nl> uncheckedOptions . remove ( MIN _ SSTABLE _ SIZE _ KEY ) ; <nl> uncheckedOptions . remove ( BUCKET _ LOW _ KEY ) ; <nl> uncheckedOptions . remove ( BUCKET _ HIGH _ KEY ) ; <nl> - uncheckedOptions . remove ( COLD _ READS _ TO _ OMIT _ KEY ) ; <nl> <nl> return uncheckedOptions ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java <nl> index 87b284e . . 1591f03 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java <nl> @ @ - 33 , 7 + 33 , 6 @ @ import org . apache . cassandra . utils . Pair ; <nl> import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . getBuckets ; <nl> import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . mostInterestingBucket ; <nl> import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . trimToThresholdWithHotness ; <nl> - import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . filterColdSSTables ; <nl> import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . validateOptions ; <nl> <nl> import static org . junit . Assert . * ; <nl> @ @ - 45 , 7 + 44 , 6 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader <nl> public void testOptionsValidation ( ) throws ConfigurationException <nl> { <nl> Map < String , String > options = new HashMap < > ( ) ; <nl> - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 0 . 35 " ) ; <nl> options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ LOW _ KEY , " 0 . 5 " ) ; <nl> options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ HIGH _ KEY , " 1 . 5 " ) ; <nl> options . put ( SizeTieredCompactionStrategyOptions . MIN _ SSTABLE _ SIZE _ KEY , " 10000 " ) ; <nl> @ @ - 54 , 25 + 52 , 6 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader <nl> <nl> try <nl> { <nl> - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " - 0 . 5 " ) ; <nl> - validateOptions ( options ) ; <nl> - fail ( String . format ( " Negative % s should be rejected " , SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY ) ) ; <nl> - } <nl> - catch ( ConfigurationException e ) { } <nl> - <nl> - try <nl> - { <nl> - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 10 . 0 " ) ; <nl> - validateOptions ( options ) ; <nl> - fail ( String . format ( " % s > 1 . 0 should be rejected " , SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY ) ) ; <nl> - } <nl> - catch ( ConfigurationException e ) <nl> - { <nl> - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 0 . 25 " ) ; <nl> - } <nl> - <nl> - try <nl> - { <nl> options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ LOW _ KEY , " 1000 . 0 " ) ; <nl> validateOptions ( options ) ; <nl> fail ( " bucket _ low greater than bucket _ high should be rejected " ) ; <nl> @ @ - 186 , 73 + 165 , 4 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader <nl> assertEquals ( String . format ( " bucket hotness ( % f ) should be close to % f " , bucket . right , expectedBucketHotness ) , <nl> expectedBucketHotness , bucket . right , 1 . 0 ) ; <nl> } <nl> - <nl> - @ Test <nl> - public void testFilterColdSSTables ( ) throws Exception <nl> - { <nl> - String ksname = " Keyspace1 " ; <nl> - String cfname = " Standard1 " ; <nl> - Keyspace keyspace = Keyspace . open ( ksname ) ; <nl> - ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; <nl> - cfs . truncateBlocking ( ) ; <nl> - cfs . disableAutoCompaction ( ) ; <nl> - <nl> - ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; <nl> - <nl> - / / create 10 sstables <nl> - int numSSTables = 10 ; <nl> - for ( int r = 0 ; r < numSSTables ; r + + ) <nl> - { <nl> - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; <nl> - Mutation rm = new Mutation ( ksname , key . getKey ( ) ) ; <nl> - rm . add ( cfname , Util . cellname ( " column " ) , value , 0 ) ; <nl> - rm . apply ( ) ; <nl> - cfs . forceBlockingFlush ( ) ; <nl> - } <nl> - cfs . forceBlockingFlush ( ) ; <nl> - <nl> - List < SSTableReader > filtered ; <nl> - List < SSTableReader > sstrs = new ArrayList < > ( cfs . getSSTables ( ) ) ; <nl> - <nl> - for ( SSTableReader sstr : sstrs ) <nl> - sstr . overrideReadMeter ( null ) ; <nl> - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; <nl> - assertEquals ( " when there are no read meters , no sstables should be filtered " , sstrs . size ( ) , filtered . size ( ) ) ; <nl> - <nl> - for ( SSTableReader sstr : sstrs ) <nl> - sstr . overrideReadMeter ( new RestorableMeter ( 0 . 0 , 0 . 0 ) ) ; <nl> - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; <nl> - assertEquals ( " when all read meters are zero , no sstables should be filtered " , sstrs . size ( ) , filtered . size ( ) ) ; <nl> - <nl> - / / leave all read rates at 0 besides one <nl> - sstrs . get ( 0 ) . overrideReadMeter ( new RestorableMeter ( 1000 . 0 , 1000 . 0 ) ) ; <nl> - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; <nl> - assertEquals ( " there should only be one hot sstable " , 1 , filtered . size ( ) ) ; <nl> - assertEquals ( 1000 . 0 , filtered . get ( 0 ) . getReadMeter ( ) . twoHourRate ( ) , 0 . 5 ) ; <nl> - <nl> - / / the total read rate is 100 , and we ' ll set a threshold of 2 . 5 % , so two of the sstables with read <nl> - / / rate 1 . 0 should be ignored , but not the third <nl> - for ( SSTableReader sstr : sstrs ) <nl> - sstr . overrideReadMeter ( new RestorableMeter ( 0 . 0 , 0 . 0 ) ) ; <nl> - sstrs . get ( 0 ) . overrideReadMeter ( new RestorableMeter ( 97 . 0 , 97 . 0 ) ) ; <nl> - sstrs . get ( 1 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; <nl> - sstrs . get ( 2 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; <nl> - sstrs . get ( 3 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; <nl> - <nl> - filtered = filterColdSSTables ( sstrs , 0 . 025 , 0 ) ; <nl> - assertEquals ( 2 , filtered . size ( ) ) ; <nl> - assertEquals ( 98 . 0 , filtered . get ( 0 ) . getReadMeter ( ) . twoHourRate ( ) + filtered . get ( 1 ) . getReadMeter ( ) . twoHourRate ( ) , 0 . 5 ) ; <nl> - <nl> - / / make sure a threshold of 0 . 0 doesn ' t result in any sstables being filtered <nl> - for ( SSTableReader sstr : sstrs ) <nl> - sstr . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; <nl> - filtered = filterColdSSTables ( sstrs , 0 . 0 , 0 ) ; <nl> - assertEquals ( sstrs . size ( ) , filtered . size ( ) ) ; <nl> - <nl> - / / just for fun , set a threshold where all sstables are considered cold <nl> - for ( SSTableReader sstr : sstrs ) <nl> - sstr . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; <nl> - filtered = filterColdSSTables ( sstrs , 1 . 0 , 0 ) ; <nl> - assertTrue ( filtered . isEmpty ( ) ) ; <nl> - } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 748acf8 . . 4992d85 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 4 
 + * Remove cold _ reads _ to _ omit from STCS ( CASSANDRA - 8860 ) 
 * Make EstimatedHistogram # percentile ( ) use ceil instead of floor ( CASSANDRA - 8883 ) 
 * Fix top partitions reporting wrong cardinality ( CASSANDRA - 8834 ) 
 * Fix rare NPE in KeyCacheSerializer ( CASSANDRA - 8067 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 602770c . . 06013b8 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 13 , 6 + 13 , 14 @ @ restore snapshots created with the previous major version using the 
 ' sstableloader ' tool . You can upgrade the file format of your snapshots 
 using the provided ' sstableupgrade ' tool . 
 
 + 2 . 1 . 4 
 + = = = = = 
 + Upgrading 
 + - - - - - - - - - 
 + - The option to omit cold sstables with size tiered compaction has been 
 + removed - it is almost always better to use date tiered compaction for 
 + workloads that have cold data . 
 + 
 2 . 1 . 3 
 = = = = = 
 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index f089cd7 . . 88f042e 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 468 , 7 + 468 , 6 @ @ def cf _ prop _ val _ mapkey _ completer ( ctxt , cass ) : 
 opts . add ( ' min _ threshold ' ) 
 opts . add ( ' bucket _ high ' ) 
 opts . add ( ' bucket _ low ' ) 
 - opts . add ( ' cold _ reads _ to _ omit ' ) 
 elif csc = = ' LeveledCompactionStrategy ' : 
 opts . add ( ' sstable _ size _ in _ mb ' ) 
 elif csc = = ' DateTieredCompactionStrategy ' : 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 index 08102c1 . . 19abd9c 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 @ @ - 82 , 7 + 82 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 int maxThreshold = cfs . getMaximumCompactionThreshold ( ) ; 
 
 Iterable < SSTableReader > candidates = filterSuspectSSTables ( Sets . intersection ( cfs . getUncompactingSSTables ( ) , sstables ) ) ; 
 - candidates = filterColdSSTables ( Lists . newArrayList ( candidates ) , options . coldReadsToOmit , cfs . getMinimumCompactionThreshold ( ) ) ; 
 
 List < List < SSTableReader > > buckets = getBuckets ( createSSTableAndLengthPairs ( candidates ) , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; 
 logger . debug ( " Compaction buckets are { } " , buckets ) ; 
 @ @ - 106 , 141 + 105 , 6 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 return Collections . singletonList ( sstablesWithTombstones . get ( 0 ) ) ; 
 } 
 
 - / * * 
 - * Removes as many cold sstables as possible while retaining at least 1 - coldReadsToOmit of the total reads / sec 
 - * across all sstables 
 - * @ param sstables all sstables to consider 
 - * @ param coldReadsToOmit the proportion of total reads / sec that will be omitted ( 0 = omit nothing , 1 = omit everything ) 
 - * @ param minThreshold min compaction threshold 
 - * @ return a list of sstables with the coldest sstables excluded until the reads they represent reaches coldReadsToOmit 
 - * / 
 - @ VisibleForTesting 
 - static List < SSTableReader > filterColdSSTables ( List < SSTableReader > sstables , double coldReadsToOmit , int minThreshold ) 
 - { 
 - if ( coldReadsToOmit = = 0 . 0 ) 
 - return sstables ; 
 - 
 - / / Sort the sstables by hotness ( coldest - first ) . We first build a map because the hotness may change during the sort . 
 - final Map < SSTableReader , Double > hotnessSnapshot = getHotnessMap ( sstables ) ; 
 - Collections . sort ( sstables , new Comparator < SSTableReader > ( ) 
 - { 
 - public int compare ( SSTableReader o1 , SSTableReader o2 ) 
 - { 
 - int comparison = Double . compare ( hotnessSnapshot . get ( o1 ) , hotnessSnapshot . get ( o2 ) ) ; 
 - if ( comparison ! = 0 ) 
 - return comparison ; 
 - 
 - / / break ties with size on disk ( mainly for system tables and cold tables ) 
 - comparison = Long . compare ( o1 . bytesOnDisk ( ) , o2 . bytesOnDisk ( ) ) ; 
 - if ( comparison ! = 0 ) 
 - return comparison ; 
 - 
 - / / if there ' s still a tie , use generation , which is guaranteed to be unique . this ensures that 
 - / / our filtering is deterministic , which can be useful when debugging . 
 - return o1 . descriptor . generation - o2 . descriptor . generation ; 
 - } 
 - } ) ; 
 - 
 - / / calculate the total reads / sec across all sstables 
 - double totalReads = 0 . 0 ; 
 - for ( SSTableReader sstr : sstables ) 
 - if ( sstr . getReadMeter ( ) ! = null ) 
 - totalReads + = sstr . getReadMeter ( ) . twoHourRate ( ) ; 
 - 
 - / / if this is a system table with no read meters or we don ' t have any read rates yet , just return them all 
 - if ( totalReads = = 0 . 0 ) 
 - return sstables ; 
 - 
 - / / iteratively ignore the coldest sstables until ignoring one more would put us over the coldReadsToOmit threshold 
 - double maxColdReads = coldReadsToOmit * totalReads ; 
 - 
 - double totalColdReads = 0 . 0 ; 
 - int cutoffIndex = 0 ; 
 - while ( cutoffIndex < sstables . size ( ) ) 
 - { 
 - SSTableReader sstable = sstables . get ( cutoffIndex ) ; 
 - if ( sstable . getReadMeter ( ) = = null ) 
 - { 
 - throw new AssertionError ( " If you ' re seeing this exception , please attach your logs to CASSANDRA - 8238 to help us debug . " + sstable ) ; 
 - } 
 - double reads = sstable . getReadMeter ( ) . twoHourRate ( ) ; 
 - if ( totalColdReads + reads > maxColdReads ) 
 - break ; 
 - 
 - totalColdReads + = reads ; 
 - cutoffIndex + + ; 
 - } 
 - List < SSTableReader > hotSSTables = new ArrayList < > ( sstables . subList ( cutoffIndex , sstables . size ( ) ) ) ; 
 - List < SSTableReader > coldSSTables = sstables . subList ( 0 , cutoffIndex ) ; 
 - logger . debug ( " hotSSTables = { } , coldSSTables = { } " , hotSSTables . size ( ) , coldSSTables . size ( ) ) ; 
 - if ( hotSSTables . size ( ) > = minThreshold ) 
 - return hotSSTables ; 
 - if ( coldSSTables . size ( ) < minThreshold ) 
 - return Collections . emptyList ( ) ; 
 - 
 - Map < SSTableReader , Set < SSTableReader > > overlapMap = new HashMap < > ( ) ; 
 - for ( int i = 0 ; i < coldSSTables . size ( ) ; i + + ) 
 - { 
 - SSTableReader sstable = coldSSTables . get ( i ) ; 
 - Set < SSTableReader > overlaps = new HashSet < > ( ) ; 
 - for ( int j = 0 ; j < coldSSTables . size ( ) ; j + + ) 
 - { 
 - SSTableReader innerSSTable = coldSSTables . get ( j ) ; 
 - if ( ColumnNameHelper . overlaps ( sstable . getSSTableMetadata ( ) . minColumnNames , 
 - sstable . getSSTableMetadata ( ) . maxColumnNames , 
 - innerSSTable . getSSTableMetadata ( ) . minColumnNames , 
 - innerSSTable . getSSTableMetadata ( ) . maxColumnNames , 
 - sstable . metadata . comparator ) ) 
 - { 
 - overlaps . add ( innerSSTable ) ; 
 - } 
 - } 
 - overlapMap . put ( sstable , overlaps ) ; 
 - } 
 - List < Set < SSTableReader > > overlapChains = new ArrayList < > ( ) ; 
 - for ( SSTableReader sstable : overlapMap . keySet ( ) ) 
 - overlapChains . add ( createOverlapChain ( sstable , overlapMap ) ) ; 
 - 
 - Collections . sort ( overlapChains , new Comparator < Set < SSTableReader > > ( ) 
 - { 
 - @ Override 
 - public int compare ( Set < SSTableReader > o1 , Set < SSTableReader > o2 ) 
 - { 
 - return Longs . compare ( SSTableReader . getTotalBytes ( o2 ) , SSTableReader . getTotalBytes ( o1 ) ) ; 
 - } 
 - } ) ; 
 - for ( Set < SSTableReader > overlapping : overlapChains ) 
 - { 
 - / / if we are expecting to only keep 70 % of the keys after a compaction , run a compaction on these cold sstables : 
 - if ( SSTableReader . estimateCompactionGain ( overlapping ) < 0 . 7 ) 
 - return new ArrayList < > ( overlapping ) ; 
 - } 
 - return Collections . emptyList ( ) ; 
 - } 
 - 
 - / * * 
 - * returns a set with all overlapping sstables starting with s . 
 - * if we have 3 sstables , a , b , c where a overlaps with b , but not c and b overlaps with c , all sstables would be returned . 
 - * 
 - * m contains an sstable - > all overlapping mapping 
 - * / 
 - private static Set < SSTableReader > createOverlapChain ( SSTableReader s , Map < SSTableReader , Set < SSTableReader > > m ) 
 - { 
 - Deque < SSTableReader > sstables = new ArrayDeque < > ( ) ; 
 - Set < SSTableReader > overlapChain = new HashSet < > ( ) ; 
 - sstables . push ( s ) ; 
 - while ( ! sstables . isEmpty ( ) ) 
 - { 
 - SSTableReader sstable = sstables . pop ( ) ; 
 - if ( overlapChain . add ( sstable ) ) 
 - { 
 - if ( m . containsKey ( sstable ) ) 
 - sstables . addAll ( m . get ( sstable ) ) ; 
 - } 
 - } 
 - return overlapChain ; 
 - } 
 - 
 
 / * * 
 * @ param buckets list of buckets from which to return the most interesting , where " interesting " is the total hotness for reads 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java 
 index 84e7d61 . . 911bb9f 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyOptions . java 
 @ @ - 26 , 16 + 26 , 13 @ @ public final class SizeTieredCompactionStrategyOptions 
 protected static final long DEFAULT _ MIN _ SSTABLE _ SIZE = 50L * 1024L * 1024L ; 
 protected static final double DEFAULT _ BUCKET _ LOW = 0 . 5 ; 
 protected static final double DEFAULT _ BUCKET _ HIGH = 1 . 5 ; 
 - protected static final double DEFAULT _ COLD _ READS _ TO _ OMIT = 0 . 05 ; 
 protected static final String MIN _ SSTABLE _ SIZE _ KEY = " min _ sstable _ size " ; 
 protected static final String BUCKET _ LOW _ KEY = " bucket _ low " ; 
 protected static final String BUCKET _ HIGH _ KEY = " bucket _ high " ; 
 - protected static final String COLD _ READS _ TO _ OMIT _ KEY = " cold _ reads _ to _ omit " ; 
 
 protected long minSSTableSize ; 
 protected double bucketLow ; 
 protected double bucketHigh ; 
 - protected double coldReadsToOmit ; 
 
 public SizeTieredCompactionStrategyOptions ( Map < String , String > options ) 
 { 
 @ @ - 45 , 8 + 42 , 6 @ @ public final class SizeTieredCompactionStrategyOptions 
 bucketLow = optionValue = = null ? DEFAULT _ BUCKET _ LOW : Double . parseDouble ( optionValue ) ; 
 optionValue = options . get ( BUCKET _ HIGH _ KEY ) ; 
 bucketHigh = optionValue = = null ? DEFAULT _ BUCKET _ HIGH : Double . parseDouble ( optionValue ) ; 
 - optionValue = options . get ( COLD _ READS _ TO _ OMIT _ KEY ) ; 
 - coldReadsToOmit = optionValue = = null ? DEFAULT _ COLD _ READS _ TO _ OMIT : Double . parseDouble ( optionValue ) ; 
 } 
 
 public SizeTieredCompactionStrategyOptions ( ) 
 @ @ - 54 , 7 + 49 , 6 @ @ public final class SizeTieredCompactionStrategyOptions 
 minSSTableSize = DEFAULT _ MIN _ SSTABLE _ SIZE ; 
 bucketLow = DEFAULT _ BUCKET _ LOW ; 
 bucketHigh = DEFAULT _ BUCKET _ HIGH ; 
 - coldReadsToOmit = DEFAULT _ COLD _ READS _ TO _ OMIT ; 
 } 
 
 private static double parseDouble ( Map < String , String > options , String key , double defaultValue ) throws ConfigurationException 
 @ @ - 94 , 17 + 88 , 9 @ @ public final class SizeTieredCompactionStrategyOptions 
 BUCKET _ HIGH _ KEY , bucketHigh , BUCKET _ LOW _ KEY , bucketLow ) ) ; 
 } 
 
 - double maxColdReadsRatio = parseDouble ( options , COLD _ READS _ TO _ OMIT _ KEY , DEFAULT _ COLD _ READS _ TO _ OMIT ) ; 
 - if ( maxColdReadsRatio < 0 . 0 | | maxColdReadsRatio > 1 . 0 ) 
 - { 
 - throw new ConfigurationException ( String . format ( " % s value ( % s ) should be between between 0 . 0 and 1 . 0 " , 
 - COLD _ READS _ TO _ OMIT _ KEY , optionValue ) ) ; 
 - } 
 - 
 uncheckedOptions . remove ( MIN _ SSTABLE _ SIZE _ KEY ) ; 
 uncheckedOptions . remove ( BUCKET _ LOW _ KEY ) ; 
 uncheckedOptions . remove ( BUCKET _ HIGH _ KEY ) ; 
 - uncheckedOptions . remove ( COLD _ READS _ TO _ OMIT _ KEY ) ; 
 
 return uncheckedOptions ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java 
 index 87b284e . . 1591f03 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategyTest . java 
 @ @ - 33 , 7 + 33 , 6 @ @ import org . apache . cassandra . utils . Pair ; 
 import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . getBuckets ; 
 import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . mostInterestingBucket ; 
 import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . trimToThresholdWithHotness ; 
 - import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . filterColdSSTables ; 
 import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . validateOptions ; 
 
 import static org . junit . Assert . * ; 
 @ @ - 45 , 7 + 44 , 6 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader 
 public void testOptionsValidation ( ) throws ConfigurationException 
 { 
 Map < String , String > options = new HashMap < > ( ) ; 
 - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 0 . 35 " ) ; 
 options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ LOW _ KEY , " 0 . 5 " ) ; 
 options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ HIGH _ KEY , " 1 . 5 " ) ; 
 options . put ( SizeTieredCompactionStrategyOptions . MIN _ SSTABLE _ SIZE _ KEY , " 10000 " ) ; 
 @ @ - 54 , 25 + 52 , 6 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader 
 
 try 
 { 
 - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " - 0 . 5 " ) ; 
 - validateOptions ( options ) ; 
 - fail ( String . format ( " Negative % s should be rejected " , SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY ) ) ; 
 - } 
 - catch ( ConfigurationException e ) { } 
 - 
 - try 
 - { 
 - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 10 . 0 " ) ; 
 - validateOptions ( options ) ; 
 - fail ( String . format ( " % s > 1 . 0 should be rejected " , SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY ) ) ; 
 - } 
 - catch ( ConfigurationException e ) 
 - { 
 - options . put ( SizeTieredCompactionStrategyOptions . COLD _ READS _ TO _ OMIT _ KEY , " 0 . 25 " ) ; 
 - } 
 - 
 - try 
 - { 
 options . put ( SizeTieredCompactionStrategyOptions . BUCKET _ LOW _ KEY , " 1000 . 0 " ) ; 
 validateOptions ( options ) ; 
 fail ( " bucket _ low greater than bucket _ high should be rejected " ) ; 
 @ @ - 186 , 73 + 165 , 4 @ @ public class SizeTieredCompactionStrategyTest extends SchemaLoader 
 assertEquals ( String . format ( " bucket hotness ( % f ) should be close to % f " , bucket . right , expectedBucketHotness ) , 
 expectedBucketHotness , bucket . right , 1 . 0 ) ; 
 } 
 - 
 - @ Test 
 - public void testFilterColdSSTables ( ) throws Exception 
 - { 
 - String ksname = " Keyspace1 " ; 
 - String cfname = " Standard1 " ; 
 - Keyspace keyspace = Keyspace . open ( ksname ) ; 
 - ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; 
 - cfs . truncateBlocking ( ) ; 
 - cfs . disableAutoCompaction ( ) ; 
 - 
 - ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 ] ) ; 
 - 
 - / / create 10 sstables 
 - int numSSTables = 10 ; 
 - for ( int r = 0 ; r < numSSTables ; r + + ) 
 - { 
 - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; 
 - Mutation rm = new Mutation ( ksname , key . getKey ( ) ) ; 
 - rm . add ( cfname , Util . cellname ( " column " ) , value , 0 ) ; 
 - rm . apply ( ) ; 
 - cfs . forceBlockingFlush ( ) ; 
 - } 
 - cfs . forceBlockingFlush ( ) ; 
 - 
 - List < SSTableReader > filtered ; 
 - List < SSTableReader > sstrs = new ArrayList < > ( cfs . getSSTables ( ) ) ; 
 - 
 - for ( SSTableReader sstr : sstrs ) 
 - sstr . overrideReadMeter ( null ) ; 
 - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; 
 - assertEquals ( " when there are no read meters , no sstables should be filtered " , sstrs . size ( ) , filtered . size ( ) ) ; 
 - 
 - for ( SSTableReader sstr : sstrs ) 
 - sstr . overrideReadMeter ( new RestorableMeter ( 0 . 0 , 0 . 0 ) ) ; 
 - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; 
 - assertEquals ( " when all read meters are zero , no sstables should be filtered " , sstrs . size ( ) , filtered . size ( ) ) ; 
 - 
 - / / leave all read rates at 0 besides one 
 - sstrs . get ( 0 ) . overrideReadMeter ( new RestorableMeter ( 1000 . 0 , 1000 . 0 ) ) ; 
 - filtered = filterColdSSTables ( sstrs , 0 . 05 , 0 ) ; 
 - assertEquals ( " there should only be one hot sstable " , 1 , filtered . size ( ) ) ; 
 - assertEquals ( 1000 . 0 , filtered . get ( 0 ) . getReadMeter ( ) . twoHourRate ( ) , 0 . 5 ) ; 
 - 
 - / / the total read rate is 100 , and we ' ll set a threshold of 2 . 5 % , so two of the sstables with read 
 - / / rate 1 . 0 should be ignored , but not the third 
 - for ( SSTableReader sstr : sstrs ) 
 - sstr . overrideReadMeter ( new RestorableMeter ( 0 . 0 , 0 . 0 ) ) ; 
 - sstrs . get ( 0 ) . overrideReadMeter ( new RestorableMeter ( 97 . 0 , 97 . 0 ) ) ; 
 - sstrs . get ( 1 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; 
 - sstrs . get ( 2 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; 
 - sstrs . get ( 3 ) . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; 
 - 
 - filtered = filterColdSSTables ( sstrs , 0 . 025 , 0 ) ; 
 - assertEquals ( 2 , filtered . size ( ) ) ; 
 - assertEquals ( 98 . 0 , filtered . get ( 0 ) . getReadMeter ( ) . twoHourRate ( ) + filtered . get ( 1 ) . getReadMeter ( ) . twoHourRate ( ) , 0 . 5 ) ; 
 - 
 - / / make sure a threshold of 0 . 0 doesn ' t result in any sstables being filtered 
 - for ( SSTableReader sstr : sstrs ) 
 - sstr . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; 
 - filtered = filterColdSSTables ( sstrs , 0 . 0 , 0 ) ; 
 - assertEquals ( sstrs . size ( ) , filtered . size ( ) ) ; 
 - 
 - / / just for fun , set a threshold where all sstables are considered cold 
 - for ( SSTableReader sstr : sstrs ) 
 - sstr . overrideReadMeter ( new RestorableMeter ( 1 . 0 , 1 . 0 ) ) ; 
 - filtered = filterColdSSTables ( sstrs , 1 . 0 , 0 ) ; 
 - assertTrue ( filtered . isEmpty ( ) ) ; 
 - } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
