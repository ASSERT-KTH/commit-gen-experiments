BLEU SCORE: 0.005136630090540242

TEST MSG: Stop inheriting liveRatio and liveRatioComputedAt from previous memtables
GENERATED MSG: support multiple flush threads safely . automatically use up to avaiable core count threads for flushing . pause updates when too many unflushed memtables are generated .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c8f7591 . . 2b2930e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 10 <nl> + * Stop inheriting liveRatio and liveRatioComputedAt from previous <nl> + memtables ( CASSANDRA - 7796 ) <nl> * Throw EOFException if we run out of chunks in compressed datafile <nl> ( CASSANDRA - 7664 ) <nl> * Throw InvalidRequestException when queries contain relations on entire <nl> diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java <nl> index 088255e . . 05ee13e 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DataTracker . java <nl> + + + b / src / java / org / apache / cassandra / db / DataTracker . java <nl> @ @ - 109 , 7 + 109 , 7 @ @ public class DataTracker <nl> public Memtable switchMemtable ( ) <nl> { <nl> / / atomically change the current memtable <nl> - Memtable newMemtable = new Memtable ( cfstore , view . get ( ) . memtable ) ; <nl> + Memtable newMemtable = new Memtable ( cfstore ) ; <nl> Memtable toFlushMemtable ; <nl> View currentView , newView ; <nl> do <nl> @ @ - 132 , 7 + 132 , 7 @ @ public class DataTracker <nl> { <nl> assert ! cfstore . keyspace . metadata . durableWrites ; <nl> <nl> - Memtable newMemtable = new Memtable ( cfstore , view . get ( ) . memtable ) ; <nl> + Memtable newMemtable = new Memtable ( cfstore ) ; <nl> View currentView , newView ; <nl> do <nl> { <nl> @ @ - 323 , 7 + 323 , 7 @ @ public class DataTracker <nl> / * * ( Re ) initializes the tracker , purging all references . * / <nl> void init ( ) <nl> { <nl> - view . set ( new View ( new Memtable ( cfstore , null ) , <nl> + view . set ( new View ( new Memtable ( cfstore ) , <nl> Collections . < Memtable > emptySet ( ) , <nl> Collections . < SSTableReader > emptySet ( ) , <nl> Collections . < SSTableReader > emptySet ( ) , <nl> diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java <nl> index 20adeb7 . . f9a6719 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / java / org / apache / cassandra / db / Memtable . java <nl> @ @ - 120 , 20 + 120 , 12 @ @ public class Memtable <nl> / / memtable was created with the new or old comparator . <nl> public final AbstractType initialComparator ; <nl> <nl> - public Memtable ( ColumnFamilyStore cfs , Memtable previous ) <nl> + public Memtable ( ColumnFamilyStore cfs ) <nl> { <nl> this . cfs = cfs ; <nl> this . initialComparator = cfs . metadata . comparator ; <nl> this . cfs . scheduleFlush ( ) ; <nl> <nl> - / / Inherit liveRatio and liveRatioCompareAt from the previous memtable , if available , <nl> - / / to minimise recalculation frequency as much as possible . <nl> - if ( previous ! = null ) <nl> - { <nl> - liveRatio = previous . liveRatio ; <nl> - liveRatioComputedAt . set ( previous . liveRatioComputedAt . get ( ) / 4 ) ; <nl> - } <nl> - <nl> Callable < Set < Object > > provider = new Callable < Set < Object > > ( ) <nl> { <nl> public Set < Object > call ( ) throws Exception <nl> @ @ - 175 , 12 + 167 , 12 @ @ public class Memtable <nl> <nl> public void maybeUpdateLiveRatio ( ) <nl> { <nl> - / / recompute liveRatio , if we have doubled the number of ops since last calculated <nl> + / / recompute liveRatio , if we have increased the number of ops 10x since last calculated <nl> while ( true ) <nl> { <nl> long last = liveRatioComputedAt . get ( ) ; <nl> long operations = currentOperations . get ( ) ; <nl> - if ( operations < = 2L * last ) <nl> + if ( operations < = 10L * last ) <nl> break ; <nl> if ( liveRatioComputedAt . compareAndSet ( last , operations ) ) <nl> {
NEAREST DIFF (one line): diff - - git a / conf / storage - conf . xml b / conf / storage - conf . xml <nl> index 9a19da5 . . a23385d 100644 <nl> - - - a / conf / storage - conf . xml <nl> + + + b / conf / storage - conf . xml <nl> @ @ - 299 , 12 + 299 , 9 @ @ <nl> < GCGraceSeconds > 864000 < / GCGraceSeconds > <nl> <nl> < ! - - <nl> - ~ Number of threads to run when flushing memtables to disk . Set this to <nl> - ~ the number of disks you physically have in your machine allocated for DataDirectory * 2 . <nl> - ~ If you are planning to use the Binary Memtable , its recommended to increase the max threads <nl> - ~ to maintain a higher quality of service while under load when normal memtables are flushing to disk . <nl> + ~ The threshold size in megabytes the binary memtable must grow to , <nl> + ~ before it ' s submitted for flushing to disk . <nl> - - > <nl> - < FlushMinThreads > 1 < / FlushMinThreads > <nl> - < FlushMaxThreads > 1 < / FlushMaxThreads > <nl> + < BinaryMemtableSizeInMB > 256 < / BinaryMemtableSizeInMB > <nl> <nl> < / Storage > <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 2af44bb . . c376a42 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 74 , 8 + 74 , 7 @ @ public class DatabaseDescriptor <nl> private static int slicedReadBufferSizeInKB _ = 64 ; <nl> private static List < String > tables _ = new ArrayList < String > ( ) ; <nl> private static Set < String > applicationColumnFamilies _ = new HashSet < String > ( ) ; <nl> - private static int flushMinThreads _ = 1 ; <nl> - private static int flushMaxThreads _ = 1 ; <nl> + private static int bmtThreshold _ = 256 ; <nl> <nl> / / Default descriptive names for introspection . The user can override <nl> / / these choices in the config file . These are not case sensitive . <nl> @ @ - 272 , 16 + 271 , 10 @ @ public class DatabaseDescriptor <nl> slicedReadBufferSizeInKB _ = Integer . parseInt ( rawSlicedBuffer ) ; <nl> } <nl> <nl> - String rawflushMinThreads = xmlUtils . getNodeValue ( " / Storage / FlushMinThreads " ) ; <nl> - if ( rawflushMinThreads ! = null ) <nl> + String bmtThreshold = xmlUtils . getNodeValue ( " / Storage / BinaryMemtableSizeInMB " ) ; <nl> + if ( bmtThreshold ! = null ) <nl> { <nl> - flushMinThreads _ = Integer . parseInt ( rawflushMinThreads ) ; <nl> - } <nl> - <nl> - String rawflushMaxThreads = xmlUtils . getNodeValue ( " / Storage / FlushMaxThreads " ) ; <nl> - if ( rawflushMaxThreads ! = null ) <nl> - { <nl> - flushMaxThreads _ = Integer . parseInt ( rawflushMaxThreads ) ; <nl> + bmtThreshold _ = Integer . parseInt ( bmtThreshold ) ; <nl> } <nl> <nl> / * TCP port on which the storage system listens * / <nl> @ @ - 995 , 14 + 988 , 8 @ @ public class DatabaseDescriptor <nl> return slicedReadBufferSizeInKB _ ; <nl> } <nl> <nl> - public static int getFlushMinThreads ( ) <nl> + public static int getBMTThreshold ( ) <nl> { <nl> - return flushMinThreads _ ; <nl> + return bmtThreshold _ ; <nl> } <nl> - <nl> - public static int getFlushMaxThreads ( ) <nl> - { <nl> - return flushMaxThreads _ ; <nl> - } <nl> - <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index ba79f0b . . 636b2a9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 28 , 7 + 28 , 6 @ @ import java . util . * ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . concurrent . atomic . AtomicReference ; <nl> - import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> <nl> import org . apache . log4j . Logger ; <nl> <nl> @ @ - 55 , 8 + 54 , 14 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> private static Logger logger _ = Logger . getLogger ( ColumnFamilyStore . class ) ; <nl> <nl> private static NonBlockingHashMap < String , Set < Memtable > > memtablesPendingFlush = new NonBlockingHashMap < String , Set < Memtable > > ( ) ; <nl> - private static ExecutorService flusher _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getFlushMinThreads ( ) , DatabaseDescriptor . getFlushMaxThreads ( ) , Integer . MAX _ VALUE , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , new ThreadFactoryImpl ( " MEMTABLE - FLUSHER - POOL " ) ) ; <nl> - <nl> + private static DebuggableThreadPoolExecutor flusher _ = new DebuggableThreadPoolExecutor ( 1 , <nl> + Runtime . getRuntime ( ) . availableProcessors ( ) , <nl> + Integer . MAX _ VALUE , <nl> + TimeUnit . SECONDS , <nl> + new LinkedBlockingQueue < Runnable > ( 2 * Runtime . getRuntime ( ) . availableProcessors ( ) ) , <nl> + new ThreadFactoryImpl ( " MEMTABLE - FLUSHER - POOL " ) ) ; <nl> + private static ExecutorService commitLogUpdater _ = new DebuggableThreadPoolExecutor ( " MEMTABLE - POST - FLUSHER " ) ; <nl> + <nl> private final String table _ ; <nl> public final String columnFamily _ ; <nl> private final boolean isSuper _ ; <nl> @ @ - 317 , 9 + 322 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> columnFamily _ , SSTable . TEMPFILE _ MARKER , fileIndexGenerator _ . incrementAndGet ( ) ) ; <nl> } <nl> <nl> - void switchMemtable ( Memtable oldMemtable ) <nl> + Future < ? > switchMemtable ( Memtable oldMemtable ) throws IOException <nl> { <nl> - CommitLog . CommitLogContext ctx = null ; <nl> / * * <nl> * If we can get the writelock , that means no new updates can come in and <nl> * all ongoing updates to memtables have completed . We can get the tail <nl> @ @ - 330 , 34 + 334 , 43 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> Table . flusherLock _ . writeLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - try <nl> - { <nl> - ctx = CommitLog . open ( ) . getContext ( ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> + final CommitLog . CommitLogContext ctx = CommitLog . open ( ) . getContext ( ) ; <nl> <nl> if ( oldMemtable . isFrozen ( ) ) <nl> { <nl> - return ; <nl> + return null ; <nl> } <nl> logger _ . info ( columnFamily _ + " has reached its threshold ; switching in a fresh Memtable " ) ; <nl> oldMemtable . freeze ( ) ; <nl> getMemtablesPendingFlushNotNull ( columnFamily _ ) . add ( oldMemtable ) ; / / it ' s ok for the MT to briefly be both active and pendingFlush <nl> - submitFlush ( oldMemtable , ctx ) ; <nl> + final Future < ? > future = submitFlush ( oldMemtable , ctx ) ; <nl> memtable _ = new Memtable ( table _ , columnFamily _ ) ; <nl> - <nl> - if ( memtableSwitchCount = = Integer . MAX _ VALUE ) <nl> + / / a second executor that makes sure the onMemtableFlushes get called in the right order , <nl> + / / while keeping the wait - for - flush ( future . get ) out of anything latency - sensitive . <nl> + return commitLogUpdater _ . submit ( new Runnable ( ) <nl> { <nl> - memtableSwitchCount = 0 ; <nl> - } <nl> - memtableSwitchCount + + ; <nl> + public void run ( ) <nl> + { <nl> + try <nl> + { <nl> + future . get ( ) ; <nl> + onMemtableFlush ( ctx ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> } <nl> finally <nl> { <nl> Table . flusherLock _ . writeLock ( ) . unlock ( ) ; <nl> + if ( memtableSwitchCount = = Integer . MAX _ VALUE ) <nl> + { <nl> + memtableSwitchCount = 0 ; <nl> + } <nl> + memtableSwitchCount + + ; <nl> } <nl> } <nl> <nl> @ @ - 367 , 27 + 380 , 20 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> binaryMemtable _ . get ( ) . put ( key , buffer ) ; <nl> } <nl> <nl> - public void forceFlush ( ) <nl> + public Future < ? > forceFlush ( ) throws IOException <nl> { <nl> if ( memtable _ . isClean ( ) ) <nl> - return ; <nl> + return null ; <nl> <nl> - switchMemtable ( memtable _ ) ; <nl> + return switchMemtable ( memtable _ ) ; <nl> } <nl> <nl> void forceBlockingFlush ( ) throws IOException , ExecutionException , InterruptedException <nl> { <nl> Memtable oldMemtable = getMemtableThreadSafe ( ) ; <nl> - forceFlush ( ) ; <nl> - / / block for flush to finish by adding a no - op action to the flush executorservice <nl> - / / and waiting for that to finish . ( this works since flush ES is single - threaded . ) <nl> - Future f = flusher _ . submit ( new Runnable ( ) <nl> - { <nl> - public void run ( ) <nl> - { <nl> - } <nl> - } ) ; <nl> - f . get ( ) ; <nl> + Future < ? > future = forceFlush ( ) ; <nl> + if ( future ! = null ) <nl> + future . get ( ) ; <nl> / * this assert is not threadsafe - - the memtable could have been clean when forceFlush <nl> checked it , but dirty now thanks to another thread . But as long as we are only <nl> calling this from single - threaded test code it is useful to have as a sanity check . * / <nl> @ @ - 882 , 10 + 888 , 10 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> / * Submit memtables to be flushed to disk * / <nl> - private static void submitFlush ( final Memtable memtable , final CommitLog . CommitLogContext cLogCtx ) <nl> + private static Future < ? > submitFlush ( final Memtable memtable , final CommitLog . CommitLogContext cLogCtx ) <nl> { <nl> logger _ . info ( " Enqueuing flush of " + memtable ) ; <nl> - flusher _ . submit ( new Runnable ( ) <nl> + return flusher _ . submit ( new Runnable ( ) <nl> { <nl> public void run ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> index b50fc1f . . ecd53ea 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java <nl> @ @ - 18 , 6 + 18 , 9 @ @ <nl> <nl> package org . apache . cassandra . db ; <nl> <nl> + import java . util . concurrent . Future ; <nl> + import java . io . IOException ; <nl> + <nl> / * * <nl> * The MBean interface for ColumnFamilyStore <nl> * / <nl> @ @ - 54 , 7 + 57 , 7 @ @ public interface ColumnFamilyStoreMBean <nl> / * * <nl> * Triggers an immediate memtable flush . <nl> * / <nl> - public void forceFlush ( ) ; <nl> + public Future < ? > forceFlush ( ) throws IOException ; <nl> <nl> / * * <nl> * @ return the number of read operations on this column family in the last minute <nl> diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java <nl> index b9eeb6b . . 2ccaa1c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / java / org / apache / cassandra / db / Memtable . java <nl> @ @ - 219 , 7 + 219 , 6 @ @ public class Memtable implements Comparable < Memtable > <nl> } <nl> } <nl> SSTableReader ssTable = writer . closeAndOpenReader ( ) ; <nl> - cfStore . onMemtableFlush ( cLogCtx ) ; <nl> cfStore . addSSTable ( ssTable ) ; <nl> buffer . close ( ) ; <nl> isFlushed _ = true ; <nl> diff - - git a / src / java / org / apache / cassandra / db / PeriodicFlushManager . java b / src / java / org / apache / cassandra / db / PeriodicFlushManager . java <nl> index e633e24 . . 4a471ea 100644 <nl> - - - a / src / java / org / apache / cassandra / db / PeriodicFlushManager . java <nl> + + + b / src / java / org / apache / cassandra / db / PeriodicFlushManager . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . util . concurrent . ScheduledExecutorService ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . locks . Lock ; <nl> import java . util . concurrent . locks . ReentrantLock ; <nl> + import java . io . IOException ; <nl> <nl> import org . apache . log4j . Logger ; <nl> <nl> @ @ - 62 , 7 + 63 , 14 @ @ class PeriodicFlushManager <nl> { <nl> public void run ( ) <nl> { <nl> - columnFamilyStore . forceFlush ( ) ; <nl> + try <nl> + { <nl> + columnFamilyStore . forceFlush ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> } <nl> } ; <nl> flusher _ . scheduleWithFixedDelay ( runnable , flushPeriodInMinutes , flushPeriodInMinutes , TimeUnit . MINUTES ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c8f7591 . . 2b2930e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 10 
 + * Stop inheriting liveRatio and liveRatioComputedAt from previous 
 + memtables ( CASSANDRA - 7796 ) 
 * Throw EOFException if we run out of chunks in compressed datafile 
 ( CASSANDRA - 7664 ) 
 * Throw InvalidRequestException when queries contain relations on entire 
 diff - - git a / src / java / org / apache / cassandra / db / DataTracker . java b / src / java / org / apache / cassandra / db / DataTracker . java 
 index 088255e . . 05ee13e 100644 
 - - - a / src / java / org / apache / cassandra / db / DataTracker . java 
 + + + b / src / java / org / apache / cassandra / db / DataTracker . java 
 @ @ - 109 , 7 + 109 , 7 @ @ public class DataTracker 
 public Memtable switchMemtable ( ) 
 { 
 / / atomically change the current memtable 
 - Memtable newMemtable = new Memtable ( cfstore , view . get ( ) . memtable ) ; 
 + Memtable newMemtable = new Memtable ( cfstore ) ; 
 Memtable toFlushMemtable ; 
 View currentView , newView ; 
 do 
 @ @ - 132 , 7 + 132 , 7 @ @ public class DataTracker 
 { 
 assert ! cfstore . keyspace . metadata . durableWrites ; 
 
 - Memtable newMemtable = new Memtable ( cfstore , view . get ( ) . memtable ) ; 
 + Memtable newMemtable = new Memtable ( cfstore ) ; 
 View currentView , newView ; 
 do 
 { 
 @ @ - 323 , 7 + 323 , 7 @ @ public class DataTracker 
 / * * ( Re ) initializes the tracker , purging all references . * / 
 void init ( ) 
 { 
 - view . set ( new View ( new Memtable ( cfstore , null ) , 
 + view . set ( new View ( new Memtable ( cfstore ) , 
 Collections . < Memtable > emptySet ( ) , 
 Collections . < SSTableReader > emptySet ( ) , 
 Collections . < SSTableReader > emptySet ( ) , 
 diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java 
 index 20adeb7 . . f9a6719 100644 
 - - - a / src / java / org / apache / cassandra / db / Memtable . java 
 + + + b / src / java / org / apache / cassandra / db / Memtable . java 
 @ @ - 120 , 20 + 120 , 12 @ @ public class Memtable 
 / / memtable was created with the new or old comparator . 
 public final AbstractType initialComparator ; 
 
 - public Memtable ( ColumnFamilyStore cfs , Memtable previous ) 
 + public Memtable ( ColumnFamilyStore cfs ) 
 { 
 this . cfs = cfs ; 
 this . initialComparator = cfs . metadata . comparator ; 
 this . cfs . scheduleFlush ( ) ; 
 
 - / / Inherit liveRatio and liveRatioCompareAt from the previous memtable , if available , 
 - / / to minimise recalculation frequency as much as possible . 
 - if ( previous ! = null ) 
 - { 
 - liveRatio = previous . liveRatio ; 
 - liveRatioComputedAt . set ( previous . liveRatioComputedAt . get ( ) / 4 ) ; 
 - } 
 - 
 Callable < Set < Object > > provider = new Callable < Set < Object > > ( ) 
 { 
 public Set < Object > call ( ) throws Exception 
 @ @ - 175 , 12 + 167 , 12 @ @ public class Memtable 
 
 public void maybeUpdateLiveRatio ( ) 
 { 
 - / / recompute liveRatio , if we have doubled the number of ops since last calculated 
 + / / recompute liveRatio , if we have increased the number of ops 10x since last calculated 
 while ( true ) 
 { 
 long last = liveRatioComputedAt . get ( ) ; 
 long operations = currentOperations . get ( ) ; 
 - if ( operations < = 2L * last ) 
 + if ( operations < = 10L * last ) 
 break ; 
 if ( liveRatioComputedAt . compareAndSet ( last , operations ) ) 
 {

NEAREST DIFF:
diff - - git a / conf / storage - conf . xml b / conf / storage - conf . xml 
 index 9a19da5 . . a23385d 100644 
 - - - a / conf / storage - conf . xml 
 + + + b / conf / storage - conf . xml 
 @ @ - 299 , 12 + 299 , 9 @ @ 
 < GCGraceSeconds > 864000 < / GCGraceSeconds > 
 
 < ! - - 
 - ~ Number of threads to run when flushing memtables to disk . Set this to 
 - ~ the number of disks you physically have in your machine allocated for DataDirectory * 2 . 
 - ~ If you are planning to use the Binary Memtable , its recommended to increase the max threads 
 - ~ to maintain a higher quality of service while under load when normal memtables are flushing to disk . 
 + ~ The threshold size in megabytes the binary memtable must grow to , 
 + ~ before it ' s submitted for flushing to disk . 
 - - > 
 - < FlushMinThreads > 1 < / FlushMinThreads > 
 - < FlushMaxThreads > 1 < / FlushMaxThreads > 
 + < BinaryMemtableSizeInMB > 256 < / BinaryMemtableSizeInMB > 
 
 < / Storage > 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 2af44bb . . c376a42 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 74 , 8 + 74 , 7 @ @ public class DatabaseDescriptor 
 private static int slicedReadBufferSizeInKB _ = 64 ; 
 private static List < String > tables _ = new ArrayList < String > ( ) ; 
 private static Set < String > applicationColumnFamilies _ = new HashSet < String > ( ) ; 
 - private static int flushMinThreads _ = 1 ; 
 - private static int flushMaxThreads _ = 1 ; 
 + private static int bmtThreshold _ = 256 ; 
 
 / / Default descriptive names for introspection . The user can override 
 / / these choices in the config file . These are not case sensitive . 
 @ @ - 272 , 16 + 271 , 10 @ @ public class DatabaseDescriptor 
 slicedReadBufferSizeInKB _ = Integer . parseInt ( rawSlicedBuffer ) ; 
 } 
 
 - String rawflushMinThreads = xmlUtils . getNodeValue ( " / Storage / FlushMinThreads " ) ; 
 - if ( rawflushMinThreads ! = null ) 
 + String bmtThreshold = xmlUtils . getNodeValue ( " / Storage / BinaryMemtableSizeInMB " ) ; 
 + if ( bmtThreshold ! = null ) 
 { 
 - flushMinThreads _ = Integer . parseInt ( rawflushMinThreads ) ; 
 - } 
 - 
 - String rawflushMaxThreads = xmlUtils . getNodeValue ( " / Storage / FlushMaxThreads " ) ; 
 - if ( rawflushMaxThreads ! = null ) 
 - { 
 - flushMaxThreads _ = Integer . parseInt ( rawflushMaxThreads ) ; 
 + bmtThreshold _ = Integer . parseInt ( bmtThreshold ) ; 
 } 
 
 / * TCP port on which the storage system listens * / 
 @ @ - 995 , 14 + 988 , 8 @ @ public class DatabaseDescriptor 
 return slicedReadBufferSizeInKB _ ; 
 } 
 
 - public static int getFlushMinThreads ( ) 
 + public static int getBMTThreshold ( ) 
 { 
 - return flushMinThreads _ ; 
 + return bmtThreshold _ ; 
 } 
 - 
 - public static int getFlushMaxThreads ( ) 
 - { 
 - return flushMaxThreads _ ; 
 - } 
 - 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index ba79f0b . . 636b2a9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 28 , 7 + 28 , 6 @ @ import java . util . * ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . concurrent . atomic . AtomicReference ; 
 - import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 
 import org . apache . log4j . Logger ; 
 
 @ @ - 55 , 8 + 54 , 14 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 private static Logger logger _ = Logger . getLogger ( ColumnFamilyStore . class ) ; 
 
 private static NonBlockingHashMap < String , Set < Memtable > > memtablesPendingFlush = new NonBlockingHashMap < String , Set < Memtable > > ( ) ; 
 - private static ExecutorService flusher _ = new DebuggableThreadPoolExecutor ( DatabaseDescriptor . getFlushMinThreads ( ) , DatabaseDescriptor . getFlushMaxThreads ( ) , Integer . MAX _ VALUE , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , new ThreadFactoryImpl ( " MEMTABLE - FLUSHER - POOL " ) ) ; 
 - 
 + private static DebuggableThreadPoolExecutor flusher _ = new DebuggableThreadPoolExecutor ( 1 , 
 + Runtime . getRuntime ( ) . availableProcessors ( ) , 
 + Integer . MAX _ VALUE , 
 + TimeUnit . SECONDS , 
 + new LinkedBlockingQueue < Runnable > ( 2 * Runtime . getRuntime ( ) . availableProcessors ( ) ) , 
 + new ThreadFactoryImpl ( " MEMTABLE - FLUSHER - POOL " ) ) ; 
 + private static ExecutorService commitLogUpdater _ = new DebuggableThreadPoolExecutor ( " MEMTABLE - POST - FLUSHER " ) ; 
 + 
 private final String table _ ; 
 public final String columnFamily _ ; 
 private final boolean isSuper _ ; 
 @ @ - 317 , 9 + 322 , 8 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 columnFamily _ , SSTable . TEMPFILE _ MARKER , fileIndexGenerator _ . incrementAndGet ( ) ) ; 
 } 
 
 - void switchMemtable ( Memtable oldMemtable ) 
 + Future < ? > switchMemtable ( Memtable oldMemtable ) throws IOException 
 { 
 - CommitLog . CommitLogContext ctx = null ; 
 / * * 
 * If we can get the writelock , that means no new updates can come in and 
 * all ongoing updates to memtables have completed . We can get the tail 
 @ @ - 330 , 34 + 334 , 43 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 Table . flusherLock _ . writeLock ( ) . lock ( ) ; 
 try 
 { 
 - try 
 - { 
 - ctx = CommitLog . open ( ) . getContext ( ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 + final CommitLog . CommitLogContext ctx = CommitLog . open ( ) . getContext ( ) ; 
 
 if ( oldMemtable . isFrozen ( ) ) 
 { 
 - return ; 
 + return null ; 
 } 
 logger _ . info ( columnFamily _ + " has reached its threshold ; switching in a fresh Memtable " ) ; 
 oldMemtable . freeze ( ) ; 
 getMemtablesPendingFlushNotNull ( columnFamily _ ) . add ( oldMemtable ) ; / / it ' s ok for the MT to briefly be both active and pendingFlush 
 - submitFlush ( oldMemtable , ctx ) ; 
 + final Future < ? > future = submitFlush ( oldMemtable , ctx ) ; 
 memtable _ = new Memtable ( table _ , columnFamily _ ) ; 
 - 
 - if ( memtableSwitchCount = = Integer . MAX _ VALUE ) 
 + / / a second executor that makes sure the onMemtableFlushes get called in the right order , 
 + / / while keeping the wait - for - flush ( future . get ) out of anything latency - sensitive . 
 + return commitLogUpdater _ . submit ( new Runnable ( ) 
 { 
 - memtableSwitchCount = 0 ; 
 - } 
 - memtableSwitchCount + + ; 
 + public void run ( ) 
 + { 
 + try 
 + { 
 + future . get ( ) ; 
 + onMemtableFlush ( ctx ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } ) ; 
 } 
 finally 
 { 
 Table . flusherLock _ . writeLock ( ) . unlock ( ) ; 
 + if ( memtableSwitchCount = = Integer . MAX _ VALUE ) 
 + { 
 + memtableSwitchCount = 0 ; 
 + } 
 + memtableSwitchCount + + ; 
 } 
 } 
 
 @ @ - 367 , 27 + 380 , 20 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 binaryMemtable _ . get ( ) . put ( key , buffer ) ; 
 } 
 
 - public void forceFlush ( ) 
 + public Future < ? > forceFlush ( ) throws IOException 
 { 
 if ( memtable _ . isClean ( ) ) 
 - return ; 
 + return null ; 
 
 - switchMemtable ( memtable _ ) ; 
 + return switchMemtable ( memtable _ ) ; 
 } 
 
 void forceBlockingFlush ( ) throws IOException , ExecutionException , InterruptedException 
 { 
 Memtable oldMemtable = getMemtableThreadSafe ( ) ; 
 - forceFlush ( ) ; 
 - / / block for flush to finish by adding a no - op action to the flush executorservice 
 - / / and waiting for that to finish . ( this works since flush ES is single - threaded . ) 
 - Future f = flusher _ . submit ( new Runnable ( ) 
 - { 
 - public void run ( ) 
 - { 
 - } 
 - } ) ; 
 - f . get ( ) ; 
 + Future < ? > future = forceFlush ( ) ; 
 + if ( future ! = null ) 
 + future . get ( ) ; 
 / * this assert is not threadsafe - - the memtable could have been clean when forceFlush 
 checked it , but dirty now thanks to another thread . But as long as we are only 
 calling this from single - threaded test code it is useful to have as a sanity check . * / 
 @ @ - 882 , 10 + 888 , 10 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 / * Submit memtables to be flushed to disk * / 
 - private static void submitFlush ( final Memtable memtable , final CommitLog . CommitLogContext cLogCtx ) 
 + private static Future < ? > submitFlush ( final Memtable memtable , final CommitLog . CommitLogContext cLogCtx ) 
 { 
 logger _ . info ( " Enqueuing flush of " + memtable ) ; 
 - flusher _ . submit ( new Runnable ( ) 
 + return flusher _ . submit ( new Runnable ( ) 
 { 
 public void run ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 index b50fc1f . . ecd53ea 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStoreMBean . java 
 @ @ - 18 , 6 + 18 , 9 @ @ 
 
 package org . apache . cassandra . db ; 
 
 + import java . util . concurrent . Future ; 
 + import java . io . IOException ; 
 + 
 / * * 
 * The MBean interface for ColumnFamilyStore 
 * / 
 @ @ - 54 , 7 + 57 , 7 @ @ public interface ColumnFamilyStoreMBean 
 / * * 
 * Triggers an immediate memtable flush . 
 * / 
 - public void forceFlush ( ) ; 
 + public Future < ? > forceFlush ( ) throws IOException ; 
 
 / * * 
 * @ return the number of read operations on this column family in the last minute 
 diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java 
 index b9eeb6b . . 2ccaa1c 100644 
 - - - a / src / java / org / apache / cassandra / db / Memtable . java 
 + + + b / src / java / org / apache / cassandra / db / Memtable . java 
 @ @ - 219 , 7 + 219 , 6 @ @ public class Memtable implements Comparable < Memtable > 
 } 
 } 
 SSTableReader ssTable = writer . closeAndOpenReader ( ) ; 
 - cfStore . onMemtableFlush ( cLogCtx ) ; 
 cfStore . addSSTable ( ssTable ) ; 
 buffer . close ( ) ; 
 isFlushed _ = true ; 
 diff - - git a / src / java / org / apache / cassandra / db / PeriodicFlushManager . java b / src / java / org / apache / cassandra / db / PeriodicFlushManager . java 
 index e633e24 . . 4a471ea 100644 
 - - - a / src / java / org / apache / cassandra / db / PeriodicFlushManager . java 
 + + + b / src / java / org / apache / cassandra / db / PeriodicFlushManager . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . util . concurrent . ScheduledExecutorService ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . locks . Lock ; 
 import java . util . concurrent . locks . ReentrantLock ; 
 + import java . io . IOException ; 
 
 import org . apache . log4j . Logger ; 
 
 @ @ - 62 , 7 + 63 , 14 @ @ class PeriodicFlushManager 
 { 
 public void run ( ) 
 { 
 - columnFamilyStore . forceFlush ( ) ; 
 + try 
 + { 
 + columnFamilyStore . forceFlush ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 } 
 } ; 
 flusher _ . scheduleWithFixedDelay ( runnable , flushPeriodInMinutes , flushPeriodInMinutes , TimeUnit . MINUTES ) ;
