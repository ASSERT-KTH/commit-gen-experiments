BLEU SCORE: 0.024675789207681903

TEST MSG: Fix consolidating racks violating the RF contract
GENERATED MSG: update TokenMetadata in support of many tokens per node

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d4cc15f . . 3c47427 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 17 <nl> + * Fix consolidating racks violating the RF contract ( CASSANDRA - 10238 ) <nl> * Disallow decommission when node is in drained state ( CASSANDRA - 8741 ) <nl> * Backport CASSANDRA - 8013 to 2 . 0 ( CASSANDRA - 10144 ) <nl> * Make getFullyExpiredSSTables less expensive ( CASSANDRA - 9882 ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> index 4f822c6 . . 745eeb8 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> @ @ - 69 , 6 + 69 , 7 @ @ public class PropertyFileSnitch extends AbstractNetworkTopologySnitch <nl> protected void runMayThrow ( ) throws ConfigurationException <nl> { <nl> reloadConfiguration ( ) ; <nl> + StorageService . instance . updateTopology ( ) ; <nl> } <nl> } ; <nl> ResourceWatcher . watch ( SNITCH _ PROPERTIES _ FILENAME , runnable , 60 * 1000 ) ; <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index a673c94 . . b1b25e8 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 78 , 14 + 78 , 14 @ @ public class TokenMetadata <nl> / / Finally , note that recording the tokens of joining nodes in bootstrapTokens also <nl> / / means we can detect and reject the addition of multiple nodes at the same token <nl> / / before one becomes part of the ring . <nl> - private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < Token , InetAddress > ( ) ; <nl> + private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < > ( ) ; <nl> / / ( don ' t need to record Token here since it ' s still part of tokenToEndpointMap until it ' s done leaving ) <nl> - private final Set < InetAddress > leavingEndpoints = new HashSet < InetAddress > ( ) ; <nl> + private final Set < InetAddress > leavingEndpoints = new HashSet < > ( ) ; <nl> / / this is a cache of the calculation from { tokenToEndpointMap , bootstrapTokens , leavingEndpoints } <nl> - private final ConcurrentMap < String , Multimap < Range < Token > , InetAddress > > pendingRanges = new ConcurrentHashMap < String , Multimap < Range < Token > , InetAddress > > ( ) ; <nl> + private final ConcurrentMap < String , Multimap < Range < Token > , InetAddress > > pendingRanges = new ConcurrentHashMap < > ( ) ; <nl> <nl> / / nodes which are migrating to the new tokens in the ring <nl> - private final Set < Pair < Token , InetAddress > > movingEndpoints = new HashSet < Pair < Token , InetAddress > > ( ) ; <nl> + private final Set < Pair < Token , InetAddress > > movingEndpoints = new HashSet < > ( ) ; <nl> <nl> / * Use this lock for manipulating the token map * / <nl> private final ReadWriteLock lock = new ReentrantReadWriteLock ( true ) ; <nl> @ @ - 121 , 7 + 121 , 7 @ @ public class TokenMetadata <nl> <nl> private ArrayList < Token > sortTokens ( ) <nl> { <nl> - return new ArrayList < Token > ( tokenToEndpointMap . keySet ( ) ) ; <nl> + return new ArrayList < > ( tokenToEndpointMap . keySet ( ) ) ; <nl> } <nl> <nl> / * * @ return the number of nodes bootstrapping into source ' s primary range * / <nl> @ @ - 165 , 8 + 165 , 6 @ @ public class TokenMetadata <nl> * <nl> * Prefer this whenever there are multiple pairs to update , as each update ( whether a single or multiple ) <nl> * is expensive ( CASSANDRA - 3831 ) . <nl> - * <nl> - * @ param endpointTokens <nl> * / <nl> public void updateNormalTokens ( Multimap < InetAddress , Token > endpointTokens ) <nl> { <nl> @ @ - 213 , 9 + 211 , 6 @ @ public class TokenMetadata <nl> / * * <nl> * Store an end - point to host ID mapping . Each ID must be unique , and <nl> * cannot be changed after the fact . <nl> - * <nl> - * @ param hostId <nl> - * @ param endpoint <nl> * / <nl> public void updateHostId ( UUID hostId , InetAddress endpoint ) <nl> { <nl> @ @ - 284 , 7 + 279 , 7 @ @ public class TokenMetadata <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - Map < InetAddress , UUID > readMap = new HashMap < InetAddress , UUID > ( ) ; <nl> + Map < InetAddress , UUID > readMap = new HashMap < > ( ) ; <nl> readMap . putAll ( endpointToHostIdMap ) ; <nl> return readMap ; <nl> } <nl> @ @ - 407 , 6 + 402 , 43 @ @ public class TokenMetadata <nl> } <nl> <nl> / * * <nl> + * This is called when the snitch properties for this endpoint are updated , see CASSANDRA - 10238 . <nl> + * / <nl> + public void updateTopology ( InetAddress endpoint ) <nl> + { <nl> + assert endpoint ! = null ; <nl> + <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + logger . info ( " Updating topology for { } " , endpoint ) ; <nl> + topology . updateEndpoint ( endpoint ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * This is called when the snitch properties for many endpoints are updated , it will update <nl> + * the topology mappings of any endpoints whose snitch has changed , see CASSANDRA - 10238 . <nl> + * / <nl> + public void updateTopology ( ) <nl> + { <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + logger . info ( " Updating topology for all endpoints that have changed " ) ; <nl> + topology . updateEndpoints ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * Remove pair of token / address from moving endpoints <nl> * @ param endpoint address of the moving node <nl> * / <nl> @ @ - 442 , 7 + 474 , 7 @ @ public class TokenMetadata <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - return new ArrayList < Token > ( tokenToEndpointMap . inverse ( ) . get ( endpoint ) ) ; <nl> + return new ArrayList < > ( tokenToEndpointMap . inverse ( ) . get ( endpoint ) ) ; <nl> } <nl> finally <nl> { <nl> @ @ - 508 , 7 + 540 , 7 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> - private final AtomicReference < TokenMetadata > cachedTokenMap = new AtomicReference < TokenMetadata > ( ) ; <nl> + private final AtomicReference < TokenMetadata > cachedTokenMap = new AtomicReference < > ( ) ; <nl> <nl> / * * <nl> * Create a copy of TokenMetadata with only tokenToEndpointMap . That is , pending ranges , <nl> @ @ - 519 , 7 + 551 , 7 @ @ public class TokenMetadata <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - return new TokenMetadata ( SortedBiMultiValMap . < Token , InetAddress > create ( tokenToEndpointMap , null , inetaddressCmp ) , <nl> + return new TokenMetadata ( SortedBiMultiValMap . create ( tokenToEndpointMap , null , inetaddressCmp ) , <nl> HashBiMap . create ( endpointToHostIdMap ) , <nl> new Topology ( topology ) ) ; <nl> } <nl> @ @ - 622 , 9 + 654 , 9 @ @ public class TokenMetadata <nl> <nl> public Collection < Range < Token > > getPrimaryRangesFor ( Collection < Token > tokens ) <nl> { <nl> - Collection < Range < Token > > ranges = new ArrayList < Range < Token > > ( tokens . size ( ) ) ; <nl> + Collection < Range < Token > > ranges = new ArrayList < > ( tokens . size ( ) ) ; <nl> for ( Token right : tokens ) <nl> - ranges . add ( new Range < Token > ( getPredecessor ( right ) , right ) ) ; <nl> + ranges . add ( new Range < > ( getPredecessor ( right ) , right ) ) ; <nl> return ranges ; <nl> } <nl> <nl> @ @ - 660 , 7 + 692 , 7 @ @ public class TokenMetadata <nl> <nl> public List < Range < Token > > getPendingRanges ( String keyspaceName , InetAddress endpoint ) <nl> { <nl> - List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; <nl> + List < Range < Token > > ranges = new ArrayList < > ( ) ; <nl> for ( Map . Entry < Range < Token > , InetAddress > entry : getPendingRangesMM ( keyspaceName ) . entries ( ) ) <nl> { <nl> if ( entry . getValue ( ) . equals ( endpoint ) ) <nl> @ @ - 845 , 7 + 877 , 7 @ @ public class TokenMetadata <nl> for ( InetAddress ep : eps ) <nl> { <nl> sb . append ( ep ) ; <nl> - sb . append ( " : " ) ; <nl> + sb . append ( ' : ' ) ; <nl> sb . append ( tokenToEndpointMap . inverse ( ) . get ( ep ) ) ; <nl> sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> } <nl> @ @ - 857 , 7 + 889 , 7 @ @ public class TokenMetadata <nl> sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) <nl> { <nl> - sb . append ( entry . getValue ( ) ) . append ( " : " ) . append ( entry . getKey ( ) ) ; <nl> + sb . append ( entry . getValue ( ) ) . append ( ' : ' ) . append ( entry . getKey ( ) ) ; <nl> sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> } <nl> } <nl> @ @ - 896 , 7 + 928 , 7 @ @ public class TokenMetadata <nl> { <nl> for ( Map . Entry < Range < Token > , InetAddress > rmap : entry . getValue ( ) . entries ( ) ) <nl> { <nl> - sb . append ( rmap . getValue ( ) ) . append ( " : " ) . append ( rmap . getKey ( ) ) ; <nl> + sb . append ( rmap . getValue ( ) ) . append ( ' : ' ) . append ( rmap . getKey ( ) ) ; <nl> sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> } <nl> } <nl> @ @ - 910 , 7 + 942 , 7 @ @ public class TokenMetadata <nl> if ( ranges . isEmpty ( ) ) <nl> return Collections . emptyList ( ) ; <nl> <nl> - Set < InetAddress > endpoints = new HashSet < InetAddress > ( ) ; <nl> + Set < InetAddress > endpoints = new HashSet < > ( ) ; <nl> for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : ranges . entrySet ( ) ) <nl> { <nl> if ( entry . getKey ( ) . contains ( token ) ) <nl> @ @ - 954 , 7 + 986 , 7 @ @ public class TokenMetadata <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - Map < Token , InetAddress > map = new HashMap < Token , InetAddress > ( tokenToEndpointMap . size ( ) + bootstrapTokens . size ( ) ) ; <nl> + Map < Token , InetAddress > map = new HashMap < > ( tokenToEndpointMap . size ( ) + bootstrapTokens . size ( ) ) ; <nl> map . putAll ( tokenToEndpointMap ) ; <nl> map . putAll ( bootstrapTokens ) ; <nl> return map ; <nl> @ @ - 1001 , 14 + 1033 , 14 @ @ public class TokenMetadata <nl> / * * reverse - lookup map for endpoint to current known dc / rack assignment * / <nl> private final Map < InetAddress , Pair < String , String > > currentLocations ; <nl> <nl> - protected Topology ( ) <nl> + Topology ( ) <nl> { <nl> dcEndpoints = HashMultimap . create ( ) ; <nl> - dcRacks = new HashMap < String , Multimap < String , InetAddress > > ( ) ; <nl> - currentLocations = new HashMap < InetAddress , Pair < String , String > > ( ) ; <nl> + dcRacks = new HashMap < > ( ) ; <nl> + currentLocations = new HashMap < > ( ) ; <nl> } <nl> <nl> - protected void clear ( ) <nl> + void clear ( ) <nl> { <nl> dcEndpoints . clear ( ) ; <nl> dcRacks . clear ( ) ; <nl> @ @ - 1018 , 19 + 1050 , 19 @ @ public class TokenMetadata <nl> / * * <nl> * construct deep - copy of other <nl> * / <nl> - protected Topology ( Topology other ) <nl> + Topology ( Topology other ) <nl> { <nl> dcEndpoints = HashMultimap . create ( other . dcEndpoints ) ; <nl> - dcRacks = new HashMap < String , Multimap < String , InetAddress > > ( ) ; <nl> + dcRacks = new HashMap < > ( ) ; <nl> for ( String dc : other . dcRacks . keySet ( ) ) <nl> dcRacks . put ( dc , HashMultimap . create ( other . dcRacks . get ( dc ) ) ) ; <nl> - currentLocations = new HashMap < InetAddress , Pair < String , String > > ( other . currentLocations ) ; <nl> + currentLocations = new HashMap < > ( other . currentLocations ) ; <nl> } <nl> <nl> / * * <nl> * Stores current DC / rack assignment for ep <nl> * / <nl> - protected void addEndpoint ( InetAddress ep ) <nl> + void addEndpoint ( InetAddress ep ) <nl> { <nl> IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; <nl> String dc = snitch . getDatacenter ( ep ) ; <nl> @ @ - 1040 , 10 + 1072 , 14 @ @ public class TokenMetadata <nl> { <nl> if ( current . left . equals ( dc ) & & current . right . equals ( rack ) ) <nl> return ; <nl> - dcRacks . get ( current . left ) . remove ( current . right , ep ) ; <nl> - dcEndpoints . remove ( current . left , ep ) ; <nl> + doRemoveEndpoint ( ep , current ) ; <nl> } <nl> <nl> + doAddEndpoint ( ep , dc , rack ) ; <nl> + } <nl> + <nl> + private void doAddEndpoint ( InetAddress ep , String dc , String rack ) <nl> + { <nl> dcEndpoints . put ( dc , ep ) ; <nl> <nl> if ( ! dcRacks . containsKey ( dc ) ) <nl> @ @ - 1056 , 13 + 1092 , 49 @ @ public class TokenMetadata <nl> / * * <nl> * Removes current DC / rack assignment for ep <nl> * / <nl> - protected void removeEndpoint ( InetAddress ep ) <nl> + void removeEndpoint ( InetAddress ep ) <nl> { <nl> if ( ! currentLocations . containsKey ( ep ) ) <nl> return ; <nl> - Pair < String , String > current = currentLocations . remove ( ep ) ; <nl> - dcEndpoints . remove ( current . left , ep ) ; <nl> + <nl> + doRemoveEndpoint ( ep , currentLocations . remove ( ep ) ) ; <nl> + } <nl> + <nl> + private void doRemoveEndpoint ( InetAddress ep , Pair < String , String > current ) <nl> + { <nl> dcRacks . get ( current . left ) . remove ( current . right , ep ) ; <nl> + dcEndpoints . remove ( current . left , ep ) ; <nl> + } <nl> + <nl> + void updateEndpoint ( InetAddress ep ) <nl> + { <nl> + IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; <nl> + if ( snitch = = null | | ! currentLocations . containsKey ( ep ) ) <nl> + return ; <nl> + <nl> + updateEndpoint ( ep , snitch ) ; <nl> + } <nl> + <nl> + void updateEndpoints ( ) <nl> + { <nl> + IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; <nl> + if ( snitch = = null ) <nl> + return ; <nl> + <nl> + for ( InetAddress ep : currentLocations . keySet ( ) ) <nl> + updateEndpoint ( ep , snitch ) ; <nl> + } <nl> + <nl> + private void updateEndpoint ( InetAddress ep , IEndpointSnitch snitch ) <nl> + { <nl> + Pair < String , String > current = currentLocations . get ( ep ) ; <nl> + String dc = snitch . getDatacenter ( ep ) ; <nl> + String rack = snitch . getRack ( ep ) ; <nl> + if ( dc . equals ( current . left ) & & rack . equals ( current . right ) ) <nl> + return ; <nl> + <nl> + doRemoveEndpoint ( ep , current ) ; <nl> + doAddEndpoint ( ep , dc , rack ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java b / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java <nl> index 3237979 . . e6691c4 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java <nl> @ @ - 120 , 6 + 120 , 7 @ @ public class YamlFileNetworkTopologySnitch <nl> protected void runMayThrow ( ) throws ConfigurationException <nl> { <nl> loadTopologyConfiguration ( ) ; <nl> + StorageService . instance . updateTopology ( ) ; <nl> } <nl> } ; <nl> ResourceWatcher . watch ( topologyConfigFilename , runnable , <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 5ac4980 . . c5f159e 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 1378 , 9 + 1378 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> SystemKeyspace . updatePeerInfo ( endpoint , " release _ version " , quote ( value . value ) ) ; <nl> break ; <nl> case DC : <nl> + updateTopology ( endpoint ) ; <nl> SystemKeyspace . updatePeerInfo ( endpoint , " data _ center " , quote ( value . value ) ) ; <nl> break ; <nl> case RACK : <nl> + updateTopology ( endpoint ) ; <nl> SystemKeyspace . updatePeerInfo ( endpoint , " rack " , quote ( value . value ) ) ; <nl> break ; <nl> case RPC _ ADDRESS : <nl> @ @ - 1398 , 6 + 1400 , 20 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> } <nl> <nl> + public void updateTopology ( InetAddress endpoint ) <nl> + { <nl> + if ( getTokenMetadata ( ) . isMember ( endpoint ) ) <nl> + { <nl> + getTokenMetadata ( ) . updateTopology ( endpoint ) ; <nl> + } <nl> + } <nl> + <nl> + public void updateTopology ( ) <nl> + { <nl> + getTokenMetadata ( ) . updateTopology ( ) ; <nl> + <nl> + } <nl> + <nl> private void updatePeerInfo ( InetAddress endpoint ) <nl> { <nl> EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java b / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java <nl> index 95118dc . . fc8095d 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java <nl> @ @ - 19 , 19 + 19 , 27 @ @ <nl> package org . apache . cassandra . locator ; <nl> <nl> import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> import java . util . ArrayList ; <nl> + import java . util . Map ; <nl> + <nl> import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . Multimap ; <nl> <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> + <nl> + import static junit . framework . Assert . assertNotNull ; <nl> import static org . junit . Assert . assertEquals ; <nl> <nl> import static org . apache . cassandra . Util . token ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> <nl> import org . apache . cassandra . OrderedJUnit4ClassRunner ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . dht . Token ; <nl> - import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . service . StorageService ; <nl> <nl> @ RunWith ( OrderedJUnit4ClassRunner . class ) <nl> @ @ - 50 , 9 + 58 , 9 @ @ public class TokenMetadataTest <nl> tmd . updateNormalToken ( token ( SIX ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; <nl> } <nl> <nl> - private void testRingIterator ( ArrayList < Token > ring , String start , boolean includeMin , String . . . expected ) <nl> + private static void testRingIterator ( ArrayList < Token > ring , String start , boolean includeMin , String . . . expected ) <nl> { <nl> - ArrayList < Token > actual = new ArrayList < Token > ( ) ; <nl> + ArrayList < Token > actual = new ArrayList < > ( ) ; <nl> Iterators . addAll ( actual , TokenMetadata . ringIterator ( ring , token ( start ) , includeMin ) ) ; <nl> assertEquals ( actual . toString ( ) , expected . length , actual . size ( ) ) ; <nl> for ( int i = 0 ; i < expected . length ; i + + ) <nl> @ @ - 84 , 4 + 92 , 199 @ @ public class TokenMetadataTest <nl> { <nl> testRingIterator ( new ArrayList < Token > ( ) , " 2 " , false ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testTopologyUpdate _ RackConsolidation ( ) throws UnknownHostException <nl> + { <nl> + final InetAddress first = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + final InetAddress second = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; <nl> + final String DATA _ CENTER = " datacenter1 " ; <nl> + final String RACK1 = " rack1 " ; <nl> + final String RACK2 = " rack2 " ; <nl> + <nl> + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) <nl> + { <nl> + @ Override <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return endpoint . equals ( first ) ? RACK1 : RACK2 ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return DATA _ CENTER ; <nl> + } <nl> + <nl> + @ Override <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } ) ; <nl> + <nl> + tmd . updateNormalToken ( token ( ONE ) , first ) ; <nl> + tmd . updateNormalToken ( token ( SIX ) , second ) ; <nl> + <nl> + TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; <nl> + assertNotNull ( tokenMetadata ) ; <nl> + <nl> + TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; <nl> + assertNotNull ( topology ) ; <nl> + <nl> + Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; <nl> + assertNotNull ( allEndpoints ) ; <nl> + assertTrue ( allEndpoints . size ( ) = = 2 ) ; <nl> + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; <nl> + <nl> + Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; <nl> + assertNotNull ( racks ) ; <nl> + assertTrue ( racks . size ( ) = = 1 ) ; <nl> + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK2 ) . contains ( second ) ) ; <nl> + <nl> + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) <nl> + { <nl> + @ Override <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return RACK1 ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return DATA _ CENTER ; <nl> + } <nl> + <nl> + @ Override <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } ) ; <nl> + <nl> + tokenMetadata . updateTopology ( first ) ; <nl> + tokenMetadata . updateTopology ( second ) ; <nl> + <nl> + allEndpoints = topology . getDatacenterEndpoints ( ) ; <nl> + assertNotNull ( allEndpoints ) ; <nl> + assertTrue ( allEndpoints . size ( ) = = 2 ) ; <nl> + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; <nl> + <nl> + racks = topology . getDatacenterRacks ( ) ; <nl> + assertNotNull ( racks ) ; <nl> + assertTrue ( racks . size ( ) = = 1 ) ; <nl> + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; <nl> + assertFalse ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( second ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTopologyUpdate _ RackExpansion ( ) throws UnknownHostException <nl> + { <nl> + final InetAddress first = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + final InetAddress second = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; <nl> + final String DATA _ CENTER = " datacenter1 " ; <nl> + final String RACK1 = " rack1 " ; <nl> + final String RACK2 = " rack2 " ; <nl> + <nl> + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) <nl> + { <nl> + @ Override <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return RACK1 ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return DATA _ CENTER ; <nl> + } <nl> + <nl> + @ Override <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } ) ; <nl> + <nl> + tmd . updateNormalToken ( token ( ONE ) , first ) ; <nl> + tmd . updateNormalToken ( token ( SIX ) , second ) ; <nl> + <nl> + TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; <nl> + assertNotNull ( tokenMetadata ) ; <nl> + <nl> + TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; <nl> + assertNotNull ( topology ) ; <nl> + <nl> + Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; <nl> + assertNotNull ( allEndpoints ) ; <nl> + assertTrue ( allEndpoints . size ( ) = = 2 ) ; <nl> + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; <nl> + <nl> + Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; <nl> + assertNotNull ( racks ) ; <nl> + assertTrue ( racks . size ( ) = = 1 ) ; <nl> + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; <nl> + assertFalse ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( second ) ) ; <nl> + <nl> + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) <nl> + { <nl> + @ Override <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return endpoint . equals ( first ) ? RACK1 : RACK2 ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return DATA _ CENTER ; <nl> + } <nl> + <nl> + @ Override <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + } ) ; <nl> + <nl> + tokenMetadata . updateTopology ( ) ; <nl> + <nl> + allEndpoints = topology . getDatacenterEndpoints ( ) ; <nl> + assertNotNull ( allEndpoints ) ; <nl> + assertTrue ( allEndpoints . size ( ) = = 2 ) ; <nl> + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; <nl> + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; <nl> + <nl> + racks = topology . getDatacenterRacks ( ) ; <nl> + assertNotNull ( racks ) ; <nl> + assertTrue ( racks . size ( ) = = 1 ) ; <nl> + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; <nl> + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK2 ) . contains ( second ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / BiMultiValMap . java b / src / java / org / apache / cassandra / utils / BiMultiValMap . java <nl> new file mode 100644 <nl> index 0000000 . . 992d9cf <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / BiMultiValMap . java <nl> @ @ - 0 , 0 + 1 , 124 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Collection ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + <nl> + import com . google . common . collect . HashMultimap ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . collect . Multimaps ; <nl> + <nl> + / * * <nl> + * <nl> + * A variant of BiMap which does not enforce uniqueness of values . This means the inverse <nl> + * is a Multimap . <nl> + * <nl> + * @ param < K > <nl> + * @ param < V > <nl> + * / <nl> + public class BiMultiValMap < K , V > implements Map < K , V > <nl> + { <nl> + protected final Map < K , V > forwardMap ; <nl> + protected final Multimap < V , K > reverseMap ; <nl> + <nl> + public BiMultiValMap ( ) <nl> + { <nl> + this . forwardMap = new HashMap < K , V > ( ) ; <nl> + this . reverseMap = HashMultimap . < V , K > create ( ) ; <nl> + } <nl> + <nl> + protected BiMultiValMap ( Map < K , V > forwardMap , Multimap < V , K > reverseMap ) <nl> + { <nl> + this . forwardMap = forwardMap ; <nl> + this . reverseMap = reverseMap ; <nl> + } <nl> + <nl> + public BiMultiValMap ( BiMultiValMap < K , V > map ) <nl> + { <nl> + this ( ) ; <nl> + forwardMap . putAll ( map ) ; <nl> + reverseMap . putAll ( map . inverse ( ) ) ; <nl> + } <nl> + <nl> + public Multimap < V , K > inverse ( ) <nl> + { <nl> + return Multimaps . unmodifiableMultimap ( reverseMap ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + forwardMap . clear ( ) ; <nl> + reverseMap . clear ( ) ; <nl> + } <nl> + <nl> + public boolean containsKey ( Object key ) <nl> + { <nl> + return forwardMap . containsKey ( key ) ; <nl> + } <nl> + <nl> + public boolean containsValue ( Object value ) <nl> + { <nl> + return reverseMap . containsKey ( value ) ; <nl> + } <nl> + <nl> + public Set < Map . Entry < K , V > > entrySet ( ) <nl> + { <nl> + return forwardMap . entrySet ( ) ; <nl> + } <nl> + <nl> + public V get ( Object key ) <nl> + { <nl> + return forwardMap . get ( key ) ; <nl> + } <nl> + <nl> + public boolean isEmpty ( ) <nl> + { <nl> + return forwardMap . isEmpty ( ) ; <nl> + } <nl> + <nl> + public Set < K > keySet ( ) <nl> + { <nl> + return forwardMap . keySet ( ) ; <nl> + } <nl> + <nl> + public V put ( K key , V value ) <nl> + { <nl> + V oldVal = forwardMap . put ( key , value ) ; <nl> + if ( oldVal ! = null ) <nl> + reverseMap . remove ( oldVal , key ) ; <nl> + reverseMap . put ( value , key ) ; <nl> + return oldVal ; <nl> + } <nl> + <nl> + public void putAll ( Map < ? extends K , ? extends V > m ) <nl> + { <nl> + for ( Map . Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) <nl> + put ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + } <nl> + <nl> + public V remove ( Object key ) <nl> + { <nl> + V oldVal = forwardMap . remove ( key ) ; <nl> + reverseMap . remove ( oldVal , key ) ; <nl> + return oldVal ; <nl> + } <nl> + <nl> + public Collection < K > removeValue ( V value ) <nl> + { <nl> + Collection < K > keys = reverseMap . removeAll ( value ) ; <nl> + for ( K key : keys ) <nl> + forwardMap . remove ( key ) ; <nl> + return keys ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return forwardMap . size ( ) ; <nl> + } <nl> + <nl> + public Collection < V > values ( ) <nl> + { <nl> + return reverseMap . keys ( ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java b / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java <nl> new file mode 100644 <nl> index 0000000 . . 7ba5e37 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java <nl> @ @ - 0 , 0 + 1 , 58 @ @ <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Comparator ; <nl> + import java . util . SortedMap ; <nl> + import java . util . TreeMap ; <nl> + <nl> + import com . google . common . collect . SortedSetMultimap ; <nl> + import com . google . common . collect . TreeMultimap ; <nl> + <nl> + public class SortedBiMultiValMap < K , V > extends BiMultiValMap < K , V > <nl> + { <nl> + protected SortedBiMultiValMap ( SortedMap < K , V > forwardMap , SortedSetMultimap < V , K > reverseMap ) <nl> + { <nl> + super ( forwardMap , reverseMap ) ; <nl> + } <nl> + <nl> + public static < K extends Comparable < K > , V extends Comparable < V > > SortedBiMultiValMap < K , V > create ( ) <nl> + { <nl> + return new SortedBiMultiValMap < K , V > ( new TreeMap < K , V > ( ) , TreeMultimap . < V , K > create ( ) ) ; <nl> + } <nl> + <nl> + public static < K , V > SortedBiMultiValMap < K , V > create ( Comparator < K > keyComparator , Comparator < V > valueComparator ) <nl> + { <nl> + if ( keyComparator = = null ) <nl> + keyComparator = defaultComparator ( ) ; <nl> + if ( valueComparator = = null ) <nl> + valueComparator = defaultComparator ( ) ; <nl> + return new SortedBiMultiValMap < K , V > ( new TreeMap < K , V > ( keyComparator ) , TreeMultimap . < V , K > create ( valueComparator , keyComparator ) ) ; <nl> + } <nl> + <nl> + public static < K extends Comparable < K > , V extends Comparable < V > > SortedBiMultiValMap < K , V > create ( BiMultiValMap < K , V > map ) <nl> + { <nl> + SortedBiMultiValMap < K , V > newMap = SortedBiMultiValMap . < K , V > create ( ) ; <nl> + newMap . forwardMap . putAll ( map ) ; <nl> + newMap . reverseMap . putAll ( map . inverse ( ) ) ; <nl> + return newMap ; <nl> + } <nl> + <nl> + public static < K , V > SortedBiMultiValMap < K , V > create ( BiMultiValMap < K , V > map , Comparator < K > keyComparator , Comparator < V > valueComparator ) <nl> + { <nl> + SortedBiMultiValMap < K , V > newMap = create ( keyComparator , valueComparator ) ; <nl> + newMap . forwardMap . putAll ( map ) ; <nl> + newMap . reverseMap . putAll ( map . inverse ( ) ) ; <nl> + return newMap ; <nl> + } <nl> + <nl> + private static < T > Comparator < T > defaultComparator ( ) <nl> + { <nl> + return new Comparator < T > ( ) <nl> + { <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + public int compare ( T o1 , T o2 ) <nl> + { <nl> + return ( ( Comparable < T > ) o1 ) . compareTo ( o2 ) ; <nl> + } <nl> + } ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d4cc15f . . 3c47427 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 17 
 + * Fix consolidating racks violating the RF contract ( CASSANDRA - 10238 ) 
 * Disallow decommission when node is in drained state ( CASSANDRA - 8741 ) 
 * Backport CASSANDRA - 8013 to 2 . 0 ( CASSANDRA - 10144 ) 
 * Make getFullyExpiredSSTables less expensive ( CASSANDRA - 9882 ) 
 diff - - git a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 index 4f822c6 . . 745eeb8 100644 
 - - - a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 @ @ - 69 , 6 + 69 , 7 @ @ public class PropertyFileSnitch extends AbstractNetworkTopologySnitch 
 protected void runMayThrow ( ) throws ConfigurationException 
 { 
 reloadConfiguration ( ) ; 
 + StorageService . instance . updateTopology ( ) ; 
 } 
 } ; 
 ResourceWatcher . watch ( SNITCH _ PROPERTIES _ FILENAME , runnable , 60 * 1000 ) ; 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index a673c94 . . b1b25e8 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 78 , 14 + 78 , 14 @ @ public class TokenMetadata 
 / / Finally , note that recording the tokens of joining nodes in bootstrapTokens also 
 / / means we can detect and reject the addition of multiple nodes at the same token 
 / / before one becomes part of the ring . 
 - private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < Token , InetAddress > ( ) ; 
 + private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < > ( ) ; 
 / / ( don ' t need to record Token here since it ' s still part of tokenToEndpointMap until it ' s done leaving ) 
 - private final Set < InetAddress > leavingEndpoints = new HashSet < InetAddress > ( ) ; 
 + private final Set < InetAddress > leavingEndpoints = new HashSet < > ( ) ; 
 / / this is a cache of the calculation from { tokenToEndpointMap , bootstrapTokens , leavingEndpoints } 
 - private final ConcurrentMap < String , Multimap < Range < Token > , InetAddress > > pendingRanges = new ConcurrentHashMap < String , Multimap < Range < Token > , InetAddress > > ( ) ; 
 + private final ConcurrentMap < String , Multimap < Range < Token > , InetAddress > > pendingRanges = new ConcurrentHashMap < > ( ) ; 
 
 / / nodes which are migrating to the new tokens in the ring 
 - private final Set < Pair < Token , InetAddress > > movingEndpoints = new HashSet < Pair < Token , InetAddress > > ( ) ; 
 + private final Set < Pair < Token , InetAddress > > movingEndpoints = new HashSet < > ( ) ; 
 
 / * Use this lock for manipulating the token map * / 
 private final ReadWriteLock lock = new ReentrantReadWriteLock ( true ) ; 
 @ @ - 121 , 7 + 121 , 7 @ @ public class TokenMetadata 
 
 private ArrayList < Token > sortTokens ( ) 
 { 
 - return new ArrayList < Token > ( tokenToEndpointMap . keySet ( ) ) ; 
 + return new ArrayList < > ( tokenToEndpointMap . keySet ( ) ) ; 
 } 
 
 / * * @ return the number of nodes bootstrapping into source ' s primary range * / 
 @ @ - 165 , 8 + 165 , 6 @ @ public class TokenMetadata 
 * 
 * Prefer this whenever there are multiple pairs to update , as each update ( whether a single or multiple ) 
 * is expensive ( CASSANDRA - 3831 ) . 
 - * 
 - * @ param endpointTokens 
 * / 
 public void updateNormalTokens ( Multimap < InetAddress , Token > endpointTokens ) 
 { 
 @ @ - 213 , 9 + 211 , 6 @ @ public class TokenMetadata 
 / * * 
 * Store an end - point to host ID mapping . Each ID must be unique , and 
 * cannot be changed after the fact . 
 - * 
 - * @ param hostId 
 - * @ param endpoint 
 * / 
 public void updateHostId ( UUID hostId , InetAddress endpoint ) 
 { 
 @ @ - 284 , 7 + 279 , 7 @ @ public class TokenMetadata 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - Map < InetAddress , UUID > readMap = new HashMap < InetAddress , UUID > ( ) ; 
 + Map < InetAddress , UUID > readMap = new HashMap < > ( ) ; 
 readMap . putAll ( endpointToHostIdMap ) ; 
 return readMap ; 
 } 
 @ @ - 407 , 6 + 402 , 43 @ @ public class TokenMetadata 
 } 
 
 / * * 
 + * This is called when the snitch properties for this endpoint are updated , see CASSANDRA - 10238 . 
 + * / 
 + public void updateTopology ( InetAddress endpoint ) 
 + { 
 + assert endpoint ! = null ; 
 + 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + logger . info ( " Updating topology for { } " , endpoint ) ; 
 + topology . updateEndpoint ( endpoint ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * This is called when the snitch properties for many endpoints are updated , it will update 
 + * the topology mappings of any endpoints whose snitch has changed , see CASSANDRA - 10238 . 
 + * / 
 + public void updateTopology ( ) 
 + { 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + logger . info ( " Updating topology for all endpoints that have changed " ) ; 
 + topology . updateEndpoints ( ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 * Remove pair of token / address from moving endpoints 
 * @ param endpoint address of the moving node 
 * / 
 @ @ - 442 , 7 + 474 , 7 @ @ public class TokenMetadata 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - return new ArrayList < Token > ( tokenToEndpointMap . inverse ( ) . get ( endpoint ) ) ; 
 + return new ArrayList < > ( tokenToEndpointMap . inverse ( ) . get ( endpoint ) ) ; 
 } 
 finally 
 { 
 @ @ - 508 , 7 + 540 , 7 @ @ public class TokenMetadata 
 } 
 } 
 
 - private final AtomicReference < TokenMetadata > cachedTokenMap = new AtomicReference < TokenMetadata > ( ) ; 
 + private final AtomicReference < TokenMetadata > cachedTokenMap = new AtomicReference < > ( ) ; 
 
 / * * 
 * Create a copy of TokenMetadata with only tokenToEndpointMap . That is , pending ranges , 
 @ @ - 519 , 7 + 551 , 7 @ @ public class TokenMetadata 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - return new TokenMetadata ( SortedBiMultiValMap . < Token , InetAddress > create ( tokenToEndpointMap , null , inetaddressCmp ) , 
 + return new TokenMetadata ( SortedBiMultiValMap . create ( tokenToEndpointMap , null , inetaddressCmp ) , 
 HashBiMap . create ( endpointToHostIdMap ) , 
 new Topology ( topology ) ) ; 
 } 
 @ @ - 622 , 9 + 654 , 9 @ @ public class TokenMetadata 
 
 public Collection < Range < Token > > getPrimaryRangesFor ( Collection < Token > tokens ) 
 { 
 - Collection < Range < Token > > ranges = new ArrayList < Range < Token > > ( tokens . size ( ) ) ; 
 + Collection < Range < Token > > ranges = new ArrayList < > ( tokens . size ( ) ) ; 
 for ( Token right : tokens ) 
 - ranges . add ( new Range < Token > ( getPredecessor ( right ) , right ) ) ; 
 + ranges . add ( new Range < > ( getPredecessor ( right ) , right ) ) ; 
 return ranges ; 
 } 
 
 @ @ - 660 , 7 + 692 , 7 @ @ public class TokenMetadata 
 
 public List < Range < Token > > getPendingRanges ( String keyspaceName , InetAddress endpoint ) 
 { 
 - List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; 
 + List < Range < Token > > ranges = new ArrayList < > ( ) ; 
 for ( Map . Entry < Range < Token > , InetAddress > entry : getPendingRangesMM ( keyspaceName ) . entries ( ) ) 
 { 
 if ( entry . getValue ( ) . equals ( endpoint ) ) 
 @ @ - 845 , 7 + 877 , 7 @ @ public class TokenMetadata 
 for ( InetAddress ep : eps ) 
 { 
 sb . append ( ep ) ; 
 - sb . append ( " : " ) ; 
 + sb . append ( ' : ' ) ; 
 sb . append ( tokenToEndpointMap . inverse ( ) . get ( ep ) ) ; 
 sb . append ( System . getProperty ( " line . separator " ) ) ; 
 } 
 @ @ - 857 , 7 + 889 , 7 @ @ public class TokenMetadata 
 sb . append ( System . getProperty ( " line . separator " ) ) ; 
 for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) 
 { 
 - sb . append ( entry . getValue ( ) ) . append ( " : " ) . append ( entry . getKey ( ) ) ; 
 + sb . append ( entry . getValue ( ) ) . append ( ' : ' ) . append ( entry . getKey ( ) ) ; 
 sb . append ( System . getProperty ( " line . separator " ) ) ; 
 } 
 } 
 @ @ - 896 , 7 + 928 , 7 @ @ public class TokenMetadata 
 { 
 for ( Map . Entry < Range < Token > , InetAddress > rmap : entry . getValue ( ) . entries ( ) ) 
 { 
 - sb . append ( rmap . getValue ( ) ) . append ( " : " ) . append ( rmap . getKey ( ) ) ; 
 + sb . append ( rmap . getValue ( ) ) . append ( ' : ' ) . append ( rmap . getKey ( ) ) ; 
 sb . append ( System . getProperty ( " line . separator " ) ) ; 
 } 
 } 
 @ @ - 910 , 7 + 942 , 7 @ @ public class TokenMetadata 
 if ( ranges . isEmpty ( ) ) 
 return Collections . emptyList ( ) ; 
 
 - Set < InetAddress > endpoints = new HashSet < InetAddress > ( ) ; 
 + Set < InetAddress > endpoints = new HashSet < > ( ) ; 
 for ( Map . Entry < Range < Token > , Collection < InetAddress > > entry : ranges . entrySet ( ) ) 
 { 
 if ( entry . getKey ( ) . contains ( token ) ) 
 @ @ - 954 , 7 + 986 , 7 @ @ public class TokenMetadata 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - Map < Token , InetAddress > map = new HashMap < Token , InetAddress > ( tokenToEndpointMap . size ( ) + bootstrapTokens . size ( ) ) ; 
 + Map < Token , InetAddress > map = new HashMap < > ( tokenToEndpointMap . size ( ) + bootstrapTokens . size ( ) ) ; 
 map . putAll ( tokenToEndpointMap ) ; 
 map . putAll ( bootstrapTokens ) ; 
 return map ; 
 @ @ - 1001 , 14 + 1033 , 14 @ @ public class TokenMetadata 
 / * * reverse - lookup map for endpoint to current known dc / rack assignment * / 
 private final Map < InetAddress , Pair < String , String > > currentLocations ; 
 
 - protected Topology ( ) 
 + Topology ( ) 
 { 
 dcEndpoints = HashMultimap . create ( ) ; 
 - dcRacks = new HashMap < String , Multimap < String , InetAddress > > ( ) ; 
 - currentLocations = new HashMap < InetAddress , Pair < String , String > > ( ) ; 
 + dcRacks = new HashMap < > ( ) ; 
 + currentLocations = new HashMap < > ( ) ; 
 } 
 
 - protected void clear ( ) 
 + void clear ( ) 
 { 
 dcEndpoints . clear ( ) ; 
 dcRacks . clear ( ) ; 
 @ @ - 1018 , 19 + 1050 , 19 @ @ public class TokenMetadata 
 / * * 
 * construct deep - copy of other 
 * / 
 - protected Topology ( Topology other ) 
 + Topology ( Topology other ) 
 { 
 dcEndpoints = HashMultimap . create ( other . dcEndpoints ) ; 
 - dcRacks = new HashMap < String , Multimap < String , InetAddress > > ( ) ; 
 + dcRacks = new HashMap < > ( ) ; 
 for ( String dc : other . dcRacks . keySet ( ) ) 
 dcRacks . put ( dc , HashMultimap . create ( other . dcRacks . get ( dc ) ) ) ; 
 - currentLocations = new HashMap < InetAddress , Pair < String , String > > ( other . currentLocations ) ; 
 + currentLocations = new HashMap < > ( other . currentLocations ) ; 
 } 
 
 / * * 
 * Stores current DC / rack assignment for ep 
 * / 
 - protected void addEndpoint ( InetAddress ep ) 
 + void addEndpoint ( InetAddress ep ) 
 { 
 IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; 
 String dc = snitch . getDatacenter ( ep ) ; 
 @ @ - 1040 , 10 + 1072 , 14 @ @ public class TokenMetadata 
 { 
 if ( current . left . equals ( dc ) & & current . right . equals ( rack ) ) 
 return ; 
 - dcRacks . get ( current . left ) . remove ( current . right , ep ) ; 
 - dcEndpoints . remove ( current . left , ep ) ; 
 + doRemoveEndpoint ( ep , current ) ; 
 } 
 
 + doAddEndpoint ( ep , dc , rack ) ; 
 + } 
 + 
 + private void doAddEndpoint ( InetAddress ep , String dc , String rack ) 
 + { 
 dcEndpoints . put ( dc , ep ) ; 
 
 if ( ! dcRacks . containsKey ( dc ) ) 
 @ @ - 1056 , 13 + 1092 , 49 @ @ public class TokenMetadata 
 / * * 
 * Removes current DC / rack assignment for ep 
 * / 
 - protected void removeEndpoint ( InetAddress ep ) 
 + void removeEndpoint ( InetAddress ep ) 
 { 
 if ( ! currentLocations . containsKey ( ep ) ) 
 return ; 
 - Pair < String , String > current = currentLocations . remove ( ep ) ; 
 - dcEndpoints . remove ( current . left , ep ) ; 
 + 
 + doRemoveEndpoint ( ep , currentLocations . remove ( ep ) ) ; 
 + } 
 + 
 + private void doRemoveEndpoint ( InetAddress ep , Pair < String , String > current ) 
 + { 
 dcRacks . get ( current . left ) . remove ( current . right , ep ) ; 
 + dcEndpoints . remove ( current . left , ep ) ; 
 + } 
 + 
 + void updateEndpoint ( InetAddress ep ) 
 + { 
 + IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; 
 + if ( snitch = = null | | ! currentLocations . containsKey ( ep ) ) 
 + return ; 
 + 
 + updateEndpoint ( ep , snitch ) ; 
 + } 
 + 
 + void updateEndpoints ( ) 
 + { 
 + IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; 
 + if ( snitch = = null ) 
 + return ; 
 + 
 + for ( InetAddress ep : currentLocations . keySet ( ) ) 
 + updateEndpoint ( ep , snitch ) ; 
 + } 
 + 
 + private void updateEndpoint ( InetAddress ep , IEndpointSnitch snitch ) 
 + { 
 + Pair < String , String > current = currentLocations . get ( ep ) ; 
 + String dc = snitch . getDatacenter ( ep ) ; 
 + String rack = snitch . getRack ( ep ) ; 
 + if ( dc . equals ( current . left ) & & rack . equals ( current . right ) ) 
 + return ; 
 + 
 + doRemoveEndpoint ( ep , current ) ; 
 + doAddEndpoint ( ep , dc , rack ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java b / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java 
 index 3237979 . . e6691c4 100644 
 - - - a / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / YamlFileNetworkTopologySnitch . java 
 @ @ - 120 , 6 + 120 , 7 @ @ public class YamlFileNetworkTopologySnitch 
 protected void runMayThrow ( ) throws ConfigurationException 
 { 
 loadTopologyConfiguration ( ) ; 
 + StorageService . instance . updateTopology ( ) ; 
 } 
 } ; 
 ResourceWatcher . watch ( topologyConfigFilename , runnable , 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 5ac4980 . . c5f159e 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 1378 , 9 + 1378 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 SystemKeyspace . updatePeerInfo ( endpoint , " release _ version " , quote ( value . value ) ) ; 
 break ; 
 case DC : 
 + updateTopology ( endpoint ) ; 
 SystemKeyspace . updatePeerInfo ( endpoint , " data _ center " , quote ( value . value ) ) ; 
 break ; 
 case RACK : 
 + updateTopology ( endpoint ) ; 
 SystemKeyspace . updatePeerInfo ( endpoint , " rack " , quote ( value . value ) ) ; 
 break ; 
 case RPC _ ADDRESS : 
 @ @ - 1398 , 6 + 1400 , 20 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 } 
 
 + public void updateTopology ( InetAddress endpoint ) 
 + { 
 + if ( getTokenMetadata ( ) . isMember ( endpoint ) ) 
 + { 
 + getTokenMetadata ( ) . updateTopology ( endpoint ) ; 
 + } 
 + } 
 + 
 + public void updateTopology ( ) 
 + { 
 + getTokenMetadata ( ) . updateTopology ( ) ; 
 + 
 + } 
 + 
 private void updatePeerInfo ( InetAddress endpoint ) 
 { 
 EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java b / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java 
 index 95118dc . . fc8095d 100644 
 - - - a / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / TokenMetadataTest . java 
 @ @ - 19 , 19 + 19 , 27 @ @ 
 package org . apache . cassandra . locator ; 
 
 import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 import java . util . ArrayList ; 
 + import java . util . Map ; 
 + 
 import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . Multimap ; 
 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 + 
 + import static junit . framework . Assert . assertNotNull ; 
 import static org . junit . Assert . assertEquals ; 
 
 import static org . apache . cassandra . Util . token ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 
 import org . apache . cassandra . OrderedJUnit4ClassRunner ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . dht . Token ; 
 - import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . service . StorageService ; 
 
 @ RunWith ( OrderedJUnit4ClassRunner . class ) 
 @ @ - 50 , 9 + 58 , 9 @ @ public class TokenMetadataTest 
 tmd . updateNormalToken ( token ( SIX ) , InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ) ; 
 } 
 
 - private void testRingIterator ( ArrayList < Token > ring , String start , boolean includeMin , String . . . expected ) 
 + private static void testRingIterator ( ArrayList < Token > ring , String start , boolean includeMin , String . . . expected ) 
 { 
 - ArrayList < Token > actual = new ArrayList < Token > ( ) ; 
 + ArrayList < Token > actual = new ArrayList < > ( ) ; 
 Iterators . addAll ( actual , TokenMetadata . ringIterator ( ring , token ( start ) , includeMin ) ) ; 
 assertEquals ( actual . toString ( ) , expected . length , actual . size ( ) ) ; 
 for ( int i = 0 ; i < expected . length ; i + + ) 
 @ @ - 84 , 4 + 92 , 199 @ @ public class TokenMetadataTest 
 { 
 testRingIterator ( new ArrayList < Token > ( ) , " 2 " , false ) ; 
 } 
 + 
 + @ Test 
 + public void testTopologyUpdate _ RackConsolidation ( ) throws UnknownHostException 
 + { 
 + final InetAddress first = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + final InetAddress second = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; 
 + final String DATA _ CENTER = " datacenter1 " ; 
 + final String RACK1 = " rack1 " ; 
 + final String RACK2 = " rack2 " ; 
 + 
 + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) 
 + { 
 + @ Override 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return endpoint . equals ( first ) ? RACK1 : RACK2 ; 
 + } 
 + 
 + @ Override 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return DATA _ CENTER ; 
 + } 
 + 
 + @ Override 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return 0 ; 
 + } 
 + } ) ; 
 + 
 + tmd . updateNormalToken ( token ( ONE ) , first ) ; 
 + tmd . updateNormalToken ( token ( SIX ) , second ) ; 
 + 
 + TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; 
 + assertNotNull ( tokenMetadata ) ; 
 + 
 + TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; 
 + assertNotNull ( topology ) ; 
 + 
 + Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; 
 + assertNotNull ( allEndpoints ) ; 
 + assertTrue ( allEndpoints . size ( ) = = 2 ) ; 
 + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; 
 + 
 + Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; 
 + assertNotNull ( racks ) ; 
 + assertTrue ( racks . size ( ) = = 1 ) ; 
 + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK2 ) . contains ( second ) ) ; 
 + 
 + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) 
 + { 
 + @ Override 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return RACK1 ; 
 + } 
 + 
 + @ Override 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return DATA _ CENTER ; 
 + } 
 + 
 + @ Override 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return 0 ; 
 + } 
 + } ) ; 
 + 
 + tokenMetadata . updateTopology ( first ) ; 
 + tokenMetadata . updateTopology ( second ) ; 
 + 
 + allEndpoints = topology . getDatacenterEndpoints ( ) ; 
 + assertNotNull ( allEndpoints ) ; 
 + assertTrue ( allEndpoints . size ( ) = = 2 ) ; 
 + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; 
 + 
 + racks = topology . getDatacenterRacks ( ) ; 
 + assertNotNull ( racks ) ; 
 + assertTrue ( racks . size ( ) = = 1 ) ; 
 + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; 
 + assertFalse ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( second ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testTopologyUpdate _ RackExpansion ( ) throws UnknownHostException 
 + { 
 + final InetAddress first = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + final InetAddress second = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; 
 + final String DATA _ CENTER = " datacenter1 " ; 
 + final String RACK1 = " rack1 " ; 
 + final String RACK2 = " rack2 " ; 
 + 
 + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) 
 + { 
 + @ Override 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return RACK1 ; 
 + } 
 + 
 + @ Override 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return DATA _ CENTER ; 
 + } 
 + 
 + @ Override 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return 0 ; 
 + } 
 + } ) ; 
 + 
 + tmd . updateNormalToken ( token ( ONE ) , first ) ; 
 + tmd . updateNormalToken ( token ( SIX ) , second ) ; 
 + 
 + TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; 
 + assertNotNull ( tokenMetadata ) ; 
 + 
 + TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; 
 + assertNotNull ( topology ) ; 
 + 
 + Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; 
 + assertNotNull ( allEndpoints ) ; 
 + assertTrue ( allEndpoints . size ( ) = = 2 ) ; 
 + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; 
 + 
 + Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; 
 + assertNotNull ( racks ) ; 
 + assertTrue ( racks . size ( ) = = 1 ) ; 
 + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; 
 + assertFalse ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( second ) ) ; 
 + 
 + DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) 
 + { 
 + @ Override 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return endpoint . equals ( first ) ? RACK1 : RACK2 ; 
 + } 
 + 
 + @ Override 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return DATA _ CENTER ; 
 + } 
 + 
 + @ Override 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return 0 ; 
 + } 
 + } ) ; 
 + 
 + tokenMetadata . updateTopology ( ) ; 
 + 
 + allEndpoints = topology . getDatacenterEndpoints ( ) ; 
 + assertNotNull ( allEndpoints ) ; 
 + assertTrue ( allEndpoints . size ( ) = = 2 ) ; 
 + assertTrue ( allEndpoints . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( first ) ) ; 
 + assertTrue ( allEndpoints . get ( DATA _ CENTER ) . contains ( second ) ) ; 
 + 
 + racks = topology . getDatacenterRacks ( ) ; 
 + assertNotNull ( racks ) ; 
 + assertTrue ( racks . size ( ) = = 1 ) ; 
 + assertTrue ( racks . containsKey ( DATA _ CENTER ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . size ( ) = = 2 ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK1 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . containsKey ( RACK2 ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK1 ) . contains ( first ) ) ; 
 + assertTrue ( racks . get ( DATA _ CENTER ) . get ( RACK2 ) . contains ( second ) ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / BiMultiValMap . java b / src / java / org / apache / cassandra / utils / BiMultiValMap . java 
 new file mode 100644 
 index 0000000 . . 992d9cf 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / BiMultiValMap . java 
 @ @ - 0 , 0 + 1 , 124 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Collection ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + 
 + import com . google . common . collect . HashMultimap ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . collect . Multimaps ; 
 + 
 + / * * 
 + * 
 + * A variant of BiMap which does not enforce uniqueness of values . This means the inverse 
 + * is a Multimap . 
 + * 
 + * @ param < K > 
 + * @ param < V > 
 + * / 
 + public class BiMultiValMap < K , V > implements Map < K , V > 
 + { 
 + protected final Map < K , V > forwardMap ; 
 + protected final Multimap < V , K > reverseMap ; 
 + 
 + public BiMultiValMap ( ) 
 + { 
 + this . forwardMap = new HashMap < K , V > ( ) ; 
 + this . reverseMap = HashMultimap . < V , K > create ( ) ; 
 + } 
 + 
 + protected BiMultiValMap ( Map < K , V > forwardMap , Multimap < V , K > reverseMap ) 
 + { 
 + this . forwardMap = forwardMap ; 
 + this . reverseMap = reverseMap ; 
 + } 
 + 
 + public BiMultiValMap ( BiMultiValMap < K , V > map ) 
 + { 
 + this ( ) ; 
 + forwardMap . putAll ( map ) ; 
 + reverseMap . putAll ( map . inverse ( ) ) ; 
 + } 
 + 
 + public Multimap < V , K > inverse ( ) 
 + { 
 + return Multimaps . unmodifiableMultimap ( reverseMap ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + forwardMap . clear ( ) ; 
 + reverseMap . clear ( ) ; 
 + } 
 + 
 + public boolean containsKey ( Object key ) 
 + { 
 + return forwardMap . containsKey ( key ) ; 
 + } 
 + 
 + public boolean containsValue ( Object value ) 
 + { 
 + return reverseMap . containsKey ( value ) ; 
 + } 
 + 
 + public Set < Map . Entry < K , V > > entrySet ( ) 
 + { 
 + return forwardMap . entrySet ( ) ; 
 + } 
 + 
 + public V get ( Object key ) 
 + { 
 + return forwardMap . get ( key ) ; 
 + } 
 + 
 + public boolean isEmpty ( ) 
 + { 
 + return forwardMap . isEmpty ( ) ; 
 + } 
 + 
 + public Set < K > keySet ( ) 
 + { 
 + return forwardMap . keySet ( ) ; 
 + } 
 + 
 + public V put ( K key , V value ) 
 + { 
 + V oldVal = forwardMap . put ( key , value ) ; 
 + if ( oldVal ! = null ) 
 + reverseMap . remove ( oldVal , key ) ; 
 + reverseMap . put ( value , key ) ; 
 + return oldVal ; 
 + } 
 + 
 + public void putAll ( Map < ? extends K , ? extends V > m ) 
 + { 
 + for ( Map . Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) 
 + put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + } 
 + 
 + public V remove ( Object key ) 
 + { 
 + V oldVal = forwardMap . remove ( key ) ; 
 + reverseMap . remove ( oldVal , key ) ; 
 + return oldVal ; 
 + } 
 + 
 + public Collection < K > removeValue ( V value ) 
 + { 
 + Collection < K > keys = reverseMap . removeAll ( value ) ; 
 + for ( K key : keys ) 
 + forwardMap . remove ( key ) ; 
 + return keys ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return forwardMap . size ( ) ; 
 + } 
 + 
 + public Collection < V > values ( ) 
 + { 
 + return reverseMap . keys ( ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java b / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java 
 new file mode 100644 
 index 0000000 . . 7ba5e37 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / SortedBiMultiValMap . java 
 @ @ - 0 , 0 + 1 , 58 @ @ 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Comparator ; 
 + import java . util . SortedMap ; 
 + import java . util . TreeMap ; 
 + 
 + import com . google . common . collect . SortedSetMultimap ; 
 + import com . google . common . collect . TreeMultimap ; 
 + 
 + public class SortedBiMultiValMap < K , V > extends BiMultiValMap < K , V > 
 + { 
 + protected SortedBiMultiValMap ( SortedMap < K , V > forwardMap , SortedSetMultimap < V , K > reverseMap ) 
 + { 
 + super ( forwardMap , reverseMap ) ; 
 + } 
 + 
 + public static < K extends Comparable < K > , V extends Comparable < V > > SortedBiMultiValMap < K , V > create ( ) 
 + { 
 + return new SortedBiMultiValMap < K , V > ( new TreeMap < K , V > ( ) , TreeMultimap . < V , K > create ( ) ) ; 
 + } 
 + 
 + public static < K , V > SortedBiMultiValMap < K , V > create ( Comparator < K > keyComparator , Comparator < V > valueComparator ) 
 + { 
 + if ( keyComparator = = null ) 
 + keyComparator = defaultComparator ( ) ; 
 + if ( valueComparator = = null ) 
 + valueComparator = defaultComparator ( ) ; 
 + return new SortedBiMultiValMap < K , V > ( new TreeMap < K , V > ( keyComparator ) , TreeMultimap . < V , K > create ( valueComparator , keyComparator ) ) ; 
 + } 
 + 
 + public static < K extends Comparable < K > , V extends Comparable < V > > SortedBiMultiValMap < K , V > create ( BiMultiValMap < K , V > map ) 
 + { 
 + SortedBiMultiValMap < K , V > newMap = SortedBiMultiValMap . < K , V > create ( ) ; 
 + newMap . forwardMap . putAll ( map ) ; 
 + newMap . reverseMap . putAll ( map . inverse ( ) ) ; 
 + return newMap ; 
 + } 
 + 
 + public static < K , V > SortedBiMultiValMap < K , V > create ( BiMultiValMap < K , V > map , Comparator < K > keyComparator , Comparator < V > valueComparator ) 
 + { 
 + SortedBiMultiValMap < K , V > newMap = create ( keyComparator , valueComparator ) ; 
 + newMap . forwardMap . putAll ( map ) ; 
 + newMap . reverseMap . putAll ( map . inverse ( ) ) ; 
 + return newMap ; 
 + } 
 + 
 + private static < T > Comparator < T > defaultComparator ( ) 
 + { 
 + return new Comparator < T > ( ) 
 + { 
 + @ SuppressWarnings ( " unchecked " ) 
 + public int compare ( T o1 , T o2 ) 
 + { 
 + return ( ( Comparable < T > ) o1 ) . compareTo ( o2 ) ; 
 + } 
 + } ; 
 + } 
 + }
