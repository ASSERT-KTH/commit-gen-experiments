BLEU SCORE: 0.02383853510228548

TEST MSG: Fix error when doing reverse queries with static columns
GENERATED MSG: merge from 0 . 7

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 23be338 . . 3553e4a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 10 , 6 + 10 , 7 @ @ <nl> ( CASSANDRA - 7455 ) <nl> * Add inter _ dc _ stream _ throughput _ outbound _ megabits _ per _ sec ( CASSANDRA - 6596 ) <nl> * Add option to disable STCS in L0 ( CASSANDRA - 6621 ) <nl> + * Fix error when doing reversed queries with static columns ( CASSANDRA - 7490 ) <nl> Merged from 1 . 2 : <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 98bd99a . . 523302f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 472 , 10 + 472 , 17 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> if ( slice . isAlwaysEmpty ( cfDef . cfm . comparator , isReversed ) ) <nl> return staticSlice = = null ? null : sliceFilter ( staticSlice , limit , toGroup ) ; <nl> <nl> - return staticSlice = = null <nl> - ? sliceFilter ( slice , limit , toGroup ) <nl> - : ( slice . includes ( cfDef . cfm . comparator , staticSlice . finish ) ? sliceFilter ( new ColumnSlice ( staticSlice . start , slice . finish ) , limit , toGroup ) <nl> - : sliceFilter ( new ColumnSlice [ ] { staticSlice , slice } , limit , toGroup ) ) ; <nl> + if ( staticSlice = = null ) <nl> + return sliceFilter ( slice , limit , toGroup ) ; <nl> + <nl> + if ( isReversed ) <nl> + return slice . includes ( cfDef . cfm . comparator . reverseComparator , staticSlice . start ) <nl> + ? sliceFilter ( new ColumnSlice ( slice . start , staticSlice . finish ) , limit , toGroup ) <nl> + : sliceFilter ( new ColumnSlice [ ] { slice , staticSlice } , limit , toGroup ) ; <nl> + else <nl> + return slice . includes ( cfDef . cfm . comparator , staticSlice . finish ) <nl> + ? sliceFilter ( new ColumnSlice ( staticSlice . start , slice . finish ) , limit , toGroup ) <nl> + : sliceFilter ( new ColumnSlice [ ] { staticSlice , slice } , limit , toGroup ) ; <nl> } <nl> <nl> List < ColumnSlice > l = new ArrayList < ColumnSlice > ( startBounds . size ( ) ) ; <nl> @ @ - 497 , 7 + 504 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> ColumnSlice [ ] slices ; <nl> if ( isReversed ) <nl> { <nl> - if ( l . get ( l . size ( ) - 1 ) . includes ( cfDef . cfm . comparator , staticSlice . start ) ) <nl> + if ( l . get ( l . size ( ) - 1 ) . includes ( cfDef . cfm . comparator . reverseComparator , staticSlice . start ) ) <nl> { <nl> slices = l . toArray ( new ColumnSlice [ l . size ( ) ] ) ; <nl> slices [ slices . length - 1 ] = new ColumnSlice ( slices [ slices . length - 1 ] . start , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java b / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java <nl> new file mode 100644 <nl> index 0000000 . . a21ebdc <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java <nl> @ @ - 0 , 0 + 1 , 357 @ @ <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . exceptions . RequestExecutionException ; <nl> + import org . apache . cassandra . exceptions . RequestValidationException ; <nl> + import org . apache . cassandra . exceptions . SyntaxException ; <nl> + import org . apache . cassandra . gms . Gossiper ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> + import org . apache . cassandra . service . QueryState ; <nl> + import org . apache . cassandra . transport . messages . ResultMessage ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . MD5Digest ; <nl> + import org . junit . AfterClass ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> + <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . process ; <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static com . google . common . collect . Lists . newArrayList ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + / * * <nl> + * Test column ranges and ordering with static column in table <nl> + * / <nl> + public class SliceQueryFilterWithStaticColumnsPresentTest <nl> + { <nl> + static ClientState clientState ; <nl> + static String keyspace = " static _ column _ slice _ test " ; <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) throws Throwable <nl> + { <nl> + SchemaLoader . loadSchema ( ) ; <nl> + executeSchemaChange ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; <nl> + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . single _ clustering ( p text , c text , v text , s text static , PRIMARY KEY ( p , c ) ) ; " ) ; <nl> + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . single _ clustering _ reversed ( p text , c text , v text , s text static , PRIMARY KEY ( p , c ) ) WITH CLUSTERING ORDER BY ( c DESC ) ; " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering ( p , c , v , s ) values ( ' p1 ' , ' k1 ' , ' v1 ' , ' sv1 ' ) " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering ( p , c , v ) values ( ' p1 ' , ' k2 ' , ' v2 ' ) " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering ( p , s ) values ( ' p2 ' , ' sv2 ' ) " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , c , v , s ) values ( ' p1 ' , ' k1 ' , ' v1 ' , ' sv1 ' ) " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , c , v ) values ( ' p1 ' , ' k2 ' , ' v2 ' ) " ) ; <nl> + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , s ) values ( ' p2 ' , ' sv2 ' ) " ) ; <nl> + clientState = ClientState . forInternalCalls ( ) ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void stopGossiper ( ) <nl> + { <nl> + Gossiper . instance . stop ( ) ; <nl> + } <nl> + <nl> + private static void executeSchemaChange ( String query ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + process ( String . format ( query , keyspace ) , ConsistencyLevel . ONE ) ; <nl> + } catch ( RuntimeException exc ) <nl> + { <nl> + throw exc . getCause ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static UntypedResultSet execute ( String query ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + return processInternal ( String . format ( query , keyspace ) ) ; <nl> + } catch ( RuntimeException exc ) <nl> + { <nl> + if ( exc . getCause ( ) ! = null ) <nl> + throw exc . getCause ( ) ; <nl> + throw exc ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoClusteringColumnDefaultOrdering ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoClusteringColumnAscending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNoClusteringColumnDescending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSingleRelationDefaultOrdering ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSingleRelationAscending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c ASC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSingleRelationDescending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c DESC " ) ; <nl> + assertEquals ( 0 , results . size ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInDefaultOrdering ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInAscending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c ASC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testInDescending ( ) throws Throwable <nl> + { <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + <nl> + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c DESC " ) ; <nl> + assertEquals ( 2 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; <nl> + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; <nl> + } <nl> + <nl> + private static void checkRow ( int rowIndex , UntypedResultSet results , String . . . expectedValues ) <nl> + { <nl> + List < UntypedResultSet . Row > rows = newArrayList ( results . iterator ( ) ) ; <nl> + UntypedResultSet . Row row = rows . get ( rowIndex ) ; <nl> + Iterator < ColumnSpecification > columns = row . getColumns ( ) . iterator ( ) ; <nl> + for ( String expected : expectedValues ) <nl> + { <nl> + String columnName = columns . next ( ) . name . toString ( ) ; <nl> + String actual = row . has ( columnName ) ? row . getString ( columnName ) : null ; <nl> + assertEquals ( String . format ( " Expected value % s for column % s in row % d , but got % s " , actual , columnName , rowIndex , expected ) , <nl> + expected , actual ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index eec904a . . 982454c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 59 , 6 + 59 , 8 @ @ <nl> the old ones ( CASSANDRA - 1644 ) <nl> * upgrade to Thrift 0 . 5 ( CASSANDRA - 1367 ) <nl> * renamed CL . DCQUORUM to LOCAL _ QUORUM and DCQUORUMSYNC to EACH _ QUORUM <nl> + * cli truncate support ( CASSANDRA - 1653 ) <nl> + * update GC settings in cassandra . bat ( CASSANDRA - 1636 ) <nl> <nl> <nl> 0 . 7 - beta2 <nl> diff - - git a / src / java / org / apache / cassandra / cli / Cli . g b / src / java / org / apache / cassandra / cli / Cli . g <nl> index e59c608 . . a9229ee 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / Cli . g <nl> + + + b / src / java / org / apache / cassandra / cli / Cli . g <nl> @ @ - 55 , 6 + 55 , 7 @ @ tokens { <nl> NODE _ UPDATE _ KEYSPACE ; <nl> NODE _ UPDATE _ COLUMN _ FAMILY ; <nl> NODE _ LIST ; <nl> + NODE _ TRUNCATE ; <nl> <nl> / / Internal Nodes . <nl> NODE _ COLUMN _ ACCESS ; <nl> @ @ - 123 , 6 + 124 , 7 @ @ statement <nl> | setStatement <nl> | showStatement <nl> | listStatement <nl> + | truncateStatement <nl> | - > ^ ( NODE _ NO _ OP ) <nl> ; <nl> <nl> @ @ - 174 , 6 + 176 , 8 @ @ helpStatement <nl> - > ^ ( NODE _ HELP NODE _ THRIFT _ COUNT ) <nl> | K _ HELP K _ LIST <nl> - > ^ ( NODE _ HELP NODE _ LIST ) <nl> + | K _ HELP K _ TRUNCATE <nl> + - > ^ ( NODE _ HELP NODE _ TRUNCATE ) <nl> | K _ HELP <nl> - > ^ ( NODE _ HELP ) <nl> | ' ? ' <nl> @ @ - 231 , 6 + 235 , 11 @ @ listStatement <nl> - > ^ ( NODE _ LIST columnFamily keyRangeExpr ? ^ ( NODE _ LIMIT $ limit ) ? ) <nl> ; <nl> <nl> + truncateStatement <nl> + : K _ TRUNCATE columnFamily <nl> + - > ^ ( NODE _ TRUNCATE columnFamily ) <nl> + ; <nl> + <nl> showClusterName <nl> : K _ SHOW K _ CLUSTER K _ NAME <nl> - > ^ ( NODE _ SHOW _ CLUSTER _ NAME ) <nl> @ @ - 430 , 6 + 439 , 7 @ @ K _ AND : ' AND ' ; <nl> K _ UPDATE : ' UPDATE ' ; <nl> K _ LIST : ' LIST ' ; <nl> K _ LIMIT : ' LIMIT ' ; <nl> + K _ TRUNCATE : ' TRUNCATE ' ; <nl> <nl> / / private syntactic rules <nl> fragment <nl> diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java <nl> index b6ace98 . . b63105a 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliClient . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliClient . java <nl> @ @ - 171 , 6 + 171 , 9 @ @ public class CliClient extends CliUserHelp <nl> case CliParser . NODE _ LIST : <nl> executeList ( tree ) ; <nl> break ; <nl> + case CliParser . NODE _ TRUNCATE : <nl> + executeTruncate ( tree . getChild ( 0 ) . getText ( ) ) ; <nl> + break ; <nl> case CliParser . NODE _ NO _ OP : <nl> / / comment lines come here ; they are treated as no ops . <nl> break ; <nl> @ @ - 943 , 6 + 946 , 30 @ @ public class CliClient extends CliUserHelp <nl> printSliceList ( columnFamilyDef , keySlices ) ; <nl> } <nl> <nl> + / / TRUNCATE < columnFamily > <nl> + private void executeTruncate ( String columnFamily ) <nl> + { <nl> + if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> + return ; <nl> + <nl> + / / getting CfDef , it will fail if there is no such column family in current keySpace . <nl> + CfDef cfDef = getCfDef ( columnFamily ) ; <nl> + <nl> + try <nl> + { <nl> + thriftClient . truncate ( cfDef . getName ( ) ) ; <nl> + sessionState . out . println ( columnFamily + " truncated . " ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + throw new RuntimeException ( e . getWhy ( ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> / / SHOW API VERSION <nl> private void executeShowVersion ( ) throws TException <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cli / CliCompleter . java b / src / java / org / apache / cassandra / cli / CliCompleter . java <nl> index f541fe5 . . b033d8f 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliCompleter . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliCompleter . java <nl> @ @ - 55 , 12 + 55 , 16 @ @ public class CliCompleter extends SimpleCompletor <nl> " help set " , <nl> " help del " , <nl> " help count " , <nl> + " help list " , <nl> + " help truncate " <nl> } ; <nl> private static String [ ] keyspaceCommands = { <nl> " get " , <nl> " set " , <nl> " count " , <nl> - " del " <nl> + " del " , <nl> + " list " , <nl> + " truncate " <nl> } ; <nl> <nl> public CliCompleter ( ) <nl> diff - - git a / src / java / org / apache / cassandra / cli / CliUserHelp . java b / src / java / org / apache / cassandra / cli / CliUserHelp . java <nl> index 7c512e2 . . db6a779 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliUserHelp . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliUserHelp . java <nl> @ @ - 281 , 6 + 281 , 13 @ @ public class CliUserHelp { <nl> state . out . println ( " list Users [ j : ] limit 40 " ) ; <nl> break ; <nl> <nl> + case CliParser . NODE _ TRUNCATE : <nl> + state . out . println ( " truncate < column _ family > " ) ; <nl> + state . out . println ( " Truncate specified column family . \ n " ) ; <nl> + state . out . println ( " example : " ) ; <nl> + state . out . println ( " truncate Category " ) ; <nl> + break ; <nl> + <nl> default : <nl> state . out . println ( " ? " ) ; <nl> break ; <nl> @ @ - 324 , 7 + 331 , 8 @ @ public class CliUserHelp { <nl> state . out . println ( " del < cf > [ ' < key > ' ] [ ' < super > ' ] [ ' < col > ' ] Delete sub column . " ) ; <nl> state . out . println ( " count < cf > [ ' < key > ' ] Count columns in record . " ) ; <nl> state . out . println ( " count < cf > [ ' < key > ' ] [ ' < super > ' ] Count columns in a super column . " ) ; <nl> - state . out . println ( " list < cf > List all rows in the column family . " ) ; <nl> + state . out . println ( " truncate < column _ family > Truncate specified column family . " ) ; <nl> + state . out . println ( " list < cf > List all rows in the column family . " ) ; <nl> state . out . println ( " list < cf > [ < startKey > : ] " ) ; <nl> state . out . println ( " List rows in the column family beginning with < startKey > . " ) ; <nl> state . out . println ( " list < cf > [ < startKey > : < endKey > ] " ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cli / CliTest . java b / test / unit / org / apache / cassandra / cli / CliTest . java <nl> index 24a3de0 . . eddcafd 100644 <nl> - - - a / test / unit / org / apache / cassandra / cli / CliTest . java <nl> + + + b / test / unit / org / apache / cassandra / cli / CliTest . java <nl> @ @ - 52 , 6 + 52 , 7 @ @ public class CliTest extends TestCase <nl> " list CF3 [ h : ] " , <nl> " list CF3 limit 10 " , <nl> " list CF3 [ h : g ] limit 10 " , <nl> + " truncate CF1 " , <nl> " update keyspace TestKeySpace with placement _ strategy = ' org . apache . cassandra . locator . LocalStrategy ' " , <nl> " update keyspace TestKeySpace with replication _ factor = 1 and strategy _ options = [ { DC1 : 3 , DC2 : 4 , DC5 : 1 } ] " <nl> } ; <nl> @ @ - 101 , 6 + 102 , 10 @ @ public class CliTest extends TestCase <nl> assertTrue ( result . startsWith ( " = > ( column = " ) ) ; <nl> } <nl> } <nl> + else if ( statement . startsWith ( " truncate " ) ) <nl> + { <nl> + assertTrue ( result . contains ( " truncated . " ) ) ; <nl> + } <nl> <nl> outStream . reset ( ) ; / / reset stream so we have only output from next statement all the time <nl> errStream . reset ( ) ; / / no errors to the end user .

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 23be338 . . 3553e4a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 10 , 6 + 10 , 7 @ @ 
 ( CASSANDRA - 7455 ) 
 * Add inter _ dc _ stream _ throughput _ outbound _ megabits _ per _ sec ( CASSANDRA - 6596 ) 
 * Add option to disable STCS in L0 ( CASSANDRA - 6621 ) 
 + * Fix error when doing reversed queries with static columns ( CASSANDRA - 7490 ) 
 Merged from 1 . 2 : 
 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 98bd99a . . 523302f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 472 , 10 + 472 , 17 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 if ( slice . isAlwaysEmpty ( cfDef . cfm . comparator , isReversed ) ) 
 return staticSlice = = null ? null : sliceFilter ( staticSlice , limit , toGroup ) ; 
 
 - return staticSlice = = null 
 - ? sliceFilter ( slice , limit , toGroup ) 
 - : ( slice . includes ( cfDef . cfm . comparator , staticSlice . finish ) ? sliceFilter ( new ColumnSlice ( staticSlice . start , slice . finish ) , limit , toGroup ) 
 - : sliceFilter ( new ColumnSlice [ ] { staticSlice , slice } , limit , toGroup ) ) ; 
 + if ( staticSlice = = null ) 
 + return sliceFilter ( slice , limit , toGroup ) ; 
 + 
 + if ( isReversed ) 
 + return slice . includes ( cfDef . cfm . comparator . reverseComparator , staticSlice . start ) 
 + ? sliceFilter ( new ColumnSlice ( slice . start , staticSlice . finish ) , limit , toGroup ) 
 + : sliceFilter ( new ColumnSlice [ ] { slice , staticSlice } , limit , toGroup ) ; 
 + else 
 + return slice . includes ( cfDef . cfm . comparator , staticSlice . finish ) 
 + ? sliceFilter ( new ColumnSlice ( staticSlice . start , slice . finish ) , limit , toGroup ) 
 + : sliceFilter ( new ColumnSlice [ ] { staticSlice , slice } , limit , toGroup ) ; 
 } 
 
 List < ColumnSlice > l = new ArrayList < ColumnSlice > ( startBounds . size ( ) ) ; 
 @ @ - 497 , 7 + 504 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 ColumnSlice [ ] slices ; 
 if ( isReversed ) 
 { 
 - if ( l . get ( l . size ( ) - 1 ) . includes ( cfDef . cfm . comparator , staticSlice . start ) ) 
 + if ( l . get ( l . size ( ) - 1 ) . includes ( cfDef . cfm . comparator . reverseComparator , staticSlice . start ) ) 
 { 
 slices = l . toArray ( new ColumnSlice [ l . size ( ) ] ) ; 
 slices [ slices . length - 1 ] = new ColumnSlice ( slices [ slices . length - 1 ] . start , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java b / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java 
 new file mode 100644 
 index 0000000 . . a21ebdc 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / SliceQueryFilterWithStaticColumnsPresentTest . java 
 @ @ - 0 , 0 + 1 , 357 @ @ 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . marshal . * ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . exceptions . RequestExecutionException ; 
 + import org . apache . cassandra . exceptions . RequestValidationException ; 
 + import org . apache . cassandra . exceptions . SyntaxException ; 
 + import org . apache . cassandra . gms . Gossiper ; 
 + import org . apache . cassandra . service . ClientState ; 
 + import org . apache . cassandra . service . QueryState ; 
 + import org . apache . cassandra . transport . messages . ResultMessage ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . MD5Digest ; 
 + import org . junit . AfterClass ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 + 
 + import static org . apache . cassandra . cql3 . QueryProcessor . process ; 
 + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; 
 + import static org . junit . Assert . assertTrue ; 
 + import static org . junit . Assert . assertEquals ; 
 + import static com . google . common . collect . Lists . newArrayList ; 
 + import static org . junit . Assert . fail ; 
 + 
 + / * * 
 + * Test column ranges and ordering with static column in table 
 + * / 
 + public class SliceQueryFilterWithStaticColumnsPresentTest 
 + { 
 + static ClientState clientState ; 
 + static String keyspace = " static _ column _ slice _ test " ; 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) throws Throwable 
 + { 
 + SchemaLoader . loadSchema ( ) ; 
 + executeSchemaChange ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; 
 + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . single _ clustering ( p text , c text , v text , s text static , PRIMARY KEY ( p , c ) ) ; " ) ; 
 + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . single _ clustering _ reversed ( p text , c text , v text , s text static , PRIMARY KEY ( p , c ) ) WITH CLUSTERING ORDER BY ( c DESC ) ; " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering ( p , c , v , s ) values ( ' p1 ' , ' k1 ' , ' v1 ' , ' sv1 ' ) " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering ( p , c , v ) values ( ' p1 ' , ' k2 ' , ' v2 ' ) " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering ( p , s ) values ( ' p2 ' , ' sv2 ' ) " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , c , v , s ) values ( ' p1 ' , ' k1 ' , ' v1 ' , ' sv1 ' ) " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , c , v ) values ( ' p1 ' , ' k2 ' , ' v2 ' ) " ) ; 
 + execute ( " INSERT INTO % s . single _ clustering _ reversed ( p , s ) values ( ' p2 ' , ' sv2 ' ) " ) ; 
 + clientState = ClientState . forInternalCalls ( ) ; 
 + } 
 + 
 + @ AfterClass 
 + public static void stopGossiper ( ) 
 + { 
 + Gossiper . instance . stop ( ) ; 
 + } 
 + 
 + private static void executeSchemaChange ( String query ) throws Throwable 
 + { 
 + try 
 + { 
 + process ( String . format ( query , keyspace ) , ConsistencyLevel . ONE ) ; 
 + } catch ( RuntimeException exc ) 
 + { 
 + throw exc . getCause ( ) ; 
 + } 
 + } 
 + 
 + private static UntypedResultSet execute ( String query ) throws Throwable 
 + { 
 + try 
 + { 
 + return processInternal ( String . format ( query , keyspace ) ) ; 
 + } catch ( RuntimeException exc ) 
 + { 
 + if ( exc . getCause ( ) ! = null ) 
 + throw exc . getCause ( ) ; 
 + throw exc ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testNoClusteringColumnDefaultOrdering ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + } 
 + 
 + @ Test 
 + public void testNoClusteringColumnAscending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + } 
 + 
 + @ Test 
 + public void testNoClusteringColumnDescending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p2 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p2 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p2 " , null , " sv2 " , null ) ; 
 + } 
 + 
 + @ Test 
 + public void testSingleRelationDefaultOrdering ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSingleRelationAscending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c ASC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSingleRelationDescending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k2 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c > = ' k3 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k1 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c < = ' k0 ' ORDER BY c DESC " ) ; 
 + assertEquals ( 0 , results . size ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testInDefaultOrdering ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + } 
 + 
 + @ Test 
 + public void testInAscending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c ASC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + } 
 + 
 + @ Test 
 + public void testInDescending ( ) throws Throwable 
 + { 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . single _ clustering WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + 
 + results = execute ( " SELECT * FROM % s . single _ clustering _ reversed WHERE p = ' p1 ' AND c IN ( ' k1 ' , ' k2 ' ) ORDER BY c DESC " ) ; 
 + assertEquals ( 2 , results . size ( ) ) ; 
 + checkRow ( 0 , results , " p1 " , " k2 " , " sv1 " , " v2 " ) ; 
 + checkRow ( 1 , results , " p1 " , " k1 " , " sv1 " , " v1 " ) ; 
 + } 
 + 
 + private static void checkRow ( int rowIndex , UntypedResultSet results , String . . . expectedValues ) 
 + { 
 + List < UntypedResultSet . Row > rows = newArrayList ( results . iterator ( ) ) ; 
 + UntypedResultSet . Row row = rows . get ( rowIndex ) ; 
 + Iterator < ColumnSpecification > columns = row . getColumns ( ) . iterator ( ) ; 
 + for ( String expected : expectedValues ) 
 + { 
 + String columnName = columns . next ( ) . name . toString ( ) ; 
 + String actual = row . has ( columnName ) ? row . getString ( columnName ) : null ; 
 + assertEquals ( String . format ( " Expected value % s for column % s in row % d , but got % s " , actual , columnName , rowIndex , expected ) , 
 + expected , actual ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index eec904a . . 982454c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 59 , 6 + 59 , 8 @ @ 
 the old ones ( CASSANDRA - 1644 ) 
 * upgrade to Thrift 0 . 5 ( CASSANDRA - 1367 ) 
 * renamed CL . DCQUORUM to LOCAL _ QUORUM and DCQUORUMSYNC to EACH _ QUORUM 
 + * cli truncate support ( CASSANDRA - 1653 ) 
 + * update GC settings in cassandra . bat ( CASSANDRA - 1636 ) 
 
 
 0 . 7 - beta2 
 diff - - git a / src / java / org / apache / cassandra / cli / Cli . g b / src / java / org / apache / cassandra / cli / Cli . g 
 index e59c608 . . a9229ee 100644 
 - - - a / src / java / org / apache / cassandra / cli / Cli . g 
 + + + b / src / java / org / apache / cassandra / cli / Cli . g 
 @ @ - 55 , 6 + 55 , 7 @ @ tokens { 
 NODE _ UPDATE _ KEYSPACE ; 
 NODE _ UPDATE _ COLUMN _ FAMILY ; 
 NODE _ LIST ; 
 + NODE _ TRUNCATE ; 
 
 / / Internal Nodes . 
 NODE _ COLUMN _ ACCESS ; 
 @ @ - 123 , 6 + 124 , 7 @ @ statement 
 | setStatement 
 | showStatement 
 | listStatement 
 + | truncateStatement 
 | - > ^ ( NODE _ NO _ OP ) 
 ; 
 
 @ @ - 174 , 6 + 176 , 8 @ @ helpStatement 
 - > ^ ( NODE _ HELP NODE _ THRIFT _ COUNT ) 
 | K _ HELP K _ LIST 
 - > ^ ( NODE _ HELP NODE _ LIST ) 
 + | K _ HELP K _ TRUNCATE 
 + - > ^ ( NODE _ HELP NODE _ TRUNCATE ) 
 | K _ HELP 
 - > ^ ( NODE _ HELP ) 
 | ' ? ' 
 @ @ - 231 , 6 + 235 , 11 @ @ listStatement 
 - > ^ ( NODE _ LIST columnFamily keyRangeExpr ? ^ ( NODE _ LIMIT $ limit ) ? ) 
 ; 
 
 + truncateStatement 
 + : K _ TRUNCATE columnFamily 
 + - > ^ ( NODE _ TRUNCATE columnFamily ) 
 + ; 
 + 
 showClusterName 
 : K _ SHOW K _ CLUSTER K _ NAME 
 - > ^ ( NODE _ SHOW _ CLUSTER _ NAME ) 
 @ @ - 430 , 6 + 439 , 7 @ @ K _ AND : ' AND ' ; 
 K _ UPDATE : ' UPDATE ' ; 
 K _ LIST : ' LIST ' ; 
 K _ LIMIT : ' LIMIT ' ; 
 + K _ TRUNCATE : ' TRUNCATE ' ; 
 
 / / private syntactic rules 
 fragment 
 diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java 
 index b6ace98 . . b63105a 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliClient . java 
 + + + b / src / java / org / apache / cassandra / cli / CliClient . java 
 @ @ - 171 , 6 + 171 , 9 @ @ public class CliClient extends CliUserHelp 
 case CliParser . NODE _ LIST : 
 executeList ( tree ) ; 
 break ; 
 + case CliParser . NODE _ TRUNCATE : 
 + executeTruncate ( tree . getChild ( 0 ) . getText ( ) ) ; 
 + break ; 
 case CliParser . NODE _ NO _ OP : 
 / / comment lines come here ; they are treated as no ops . 
 break ; 
 @ @ - 943 , 6 + 946 , 30 @ @ public class CliClient extends CliUserHelp 
 printSliceList ( columnFamilyDef , keySlices ) ; 
 } 
 
 + / / TRUNCATE < columnFamily > 
 + private void executeTruncate ( String columnFamily ) 
 + { 
 + if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 + return ; 
 + 
 + / / getting CfDef , it will fail if there is no such column family in current keySpace . 
 + CfDef cfDef = getCfDef ( columnFamily ) ; 
 + 
 + try 
 + { 
 + thriftClient . truncate ( cfDef . getName ( ) ) ; 
 + sessionState . out . println ( columnFamily + " truncated . " ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + throw new RuntimeException ( e . getWhy ( ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( e . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 / / SHOW API VERSION 
 private void executeShowVersion ( ) throws TException 
 { 
 diff - - git a / src / java / org / apache / cassandra / cli / CliCompleter . java b / src / java / org / apache / cassandra / cli / CliCompleter . java 
 index f541fe5 . . b033d8f 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliCompleter . java 
 + + + b / src / java / org / apache / cassandra / cli / CliCompleter . java 
 @ @ - 55 , 12 + 55 , 16 @ @ public class CliCompleter extends SimpleCompletor 
 " help set " , 
 " help del " , 
 " help count " , 
 + " help list " , 
 + " help truncate " 
 } ; 
 private static String [ ] keyspaceCommands = { 
 " get " , 
 " set " , 
 " count " , 
 - " del " 
 + " del " , 
 + " list " , 
 + " truncate " 
 } ; 
 
 public CliCompleter ( ) 
 diff - - git a / src / java / org / apache / cassandra / cli / CliUserHelp . java b / src / java / org / apache / cassandra / cli / CliUserHelp . java 
 index 7c512e2 . . db6a779 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliUserHelp . java 
 + + + b / src / java / org / apache / cassandra / cli / CliUserHelp . java 
 @ @ - 281 , 6 + 281 , 13 @ @ public class CliUserHelp { 
 state . out . println ( " list Users [ j : ] limit 40 " ) ; 
 break ; 
 
 + case CliParser . NODE _ TRUNCATE : 
 + state . out . println ( " truncate < column _ family > " ) ; 
 + state . out . println ( " Truncate specified column family . \ n " ) ; 
 + state . out . println ( " example : " ) ; 
 + state . out . println ( " truncate Category " ) ; 
 + break ; 
 + 
 default : 
 state . out . println ( " ? " ) ; 
 break ; 
 @ @ - 324 , 7 + 331 , 8 @ @ public class CliUserHelp { 
 state . out . println ( " del < cf > [ ' < key > ' ] [ ' < super > ' ] [ ' < col > ' ] Delete sub column . " ) ; 
 state . out . println ( " count < cf > [ ' < key > ' ] Count columns in record . " ) ; 
 state . out . println ( " count < cf > [ ' < key > ' ] [ ' < super > ' ] Count columns in a super column . " ) ; 
 - state . out . println ( " list < cf > List all rows in the column family . " ) ; 
 + state . out . println ( " truncate < column _ family > Truncate specified column family . " ) ; 
 + state . out . println ( " list < cf > List all rows in the column family . " ) ; 
 state . out . println ( " list < cf > [ < startKey > : ] " ) ; 
 state . out . println ( " List rows in the column family beginning with < startKey > . " ) ; 
 state . out . println ( " list < cf > [ < startKey > : < endKey > ] " ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cli / CliTest . java b / test / unit / org / apache / cassandra / cli / CliTest . java 
 index 24a3de0 . . eddcafd 100644 
 - - - a / test / unit / org / apache / cassandra / cli / CliTest . java 
 + + + b / test / unit / org / apache / cassandra / cli / CliTest . java 
 @ @ - 52 , 6 + 52 , 7 @ @ public class CliTest extends TestCase 
 " list CF3 [ h : ] " , 
 " list CF3 limit 10 " , 
 " list CF3 [ h : g ] limit 10 " , 
 + " truncate CF1 " , 
 " update keyspace TestKeySpace with placement _ strategy = ' org . apache . cassandra . locator . LocalStrategy ' " , 
 " update keyspace TestKeySpace with replication _ factor = 1 and strategy _ options = [ { DC1 : 3 , DC2 : 4 , DC5 : 1 } ] " 
 } ; 
 @ @ - 101 , 6 + 102 , 10 @ @ public class CliTest extends TestCase 
 assertTrue ( result . startsWith ( " = > ( column = " ) ) ; 
 } 
 } 
 + else if ( statement . startsWith ( " truncate " ) ) 
 + { 
 + assertTrue ( result . contains ( " truncated . " ) ) ; 
 + } 
 
 outStream . reset ( ) ; / / reset stream so we have only output from next statement all the time 
 errStream . reset ( ) ; / / no errors to the end user .
