BLEU SCORE: 0.041961149062965476

TEST MSG: Fix handling of range tombstones and add test for merging
GENERATED MSG: add PBSPredictor consistency modeler

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ClusteringComparator . java b / src / java / org / apache / cassandra / db / ClusteringComparator . java <nl> index b0e8e5c . . 8b01d6f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ClusteringComparator . java <nl> + + + b / src / java / org / apache / cassandra / db / ClusteringComparator . java <nl> @ @ - 162 , 7 + 162 , 7 @ @ public class ClusteringComparator implements Comparator < Clusterable > <nl> if ( s1 = = s2 ) <nl> return ClusteringPrefix . Kind . compare ( c1 . kind ( ) , c2 . kind ( ) ) ; <nl> <nl> - return s1 < s2 ? c1 . kind ( ) . prefixComparisonResult : - c2 . kind ( ) . prefixComparisonResult ; <nl> + return s1 < s2 ? c1 . kind ( ) . comparedToClustering : - c2 . kind ( ) . comparedToClustering ; <nl> } <nl> <nl> public int compare ( Clustering c1 , Clustering c2 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ClusteringPrefix . java b / src / java / org / apache / cassandra / db / ClusteringPrefix . java <nl> index 36d91e7 . . 3bc7ff8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ClusteringPrefix . java <nl> + + + b / src / java / org / apache / cassandra / db / ClusteringPrefix . java <nl> @ @ - 56 , 26 + 56 , 27 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab <nl> { <nl> / / WARNING : the ordering of that enum matters because we use ordinal ( ) in the serialization <nl> <nl> - EXCL _ END _ BOUND ( 0 , - 1 ) , <nl> - INCL _ START _ BOUND ( 1 , - 1 ) , <nl> - EXCL _ END _ INCL _ START _ BOUNDARY ( 1 , - 1 ) , <nl> - STATIC _ CLUSTERING ( 2 , - 1 ) , <nl> - CLUSTERING ( 3 , 0 ) , <nl> - INCL _ END _ EXCL _ START _ BOUNDARY ( 4 , - 1 ) , <nl> - INCL _ END _ BOUND ( 4 , 1 ) , <nl> - EXCL _ START _ BOUND ( 5 , 1 ) ; <nl> + EXCL _ END _ BOUND ( 0 , - 1 ) , <nl> + INCL _ START _ BOUND ( 0 , - 1 ) , <nl> + EXCL _ END _ INCL _ START _ BOUNDARY ( 0 , - 1 ) , <nl> + STATIC _ CLUSTERING ( 1 , - 1 ) , <nl> + CLUSTERING ( 2 , 0 ) , <nl> + INCL _ END _ EXCL _ START _ BOUNDARY ( 3 , 1 ) , <nl> + INCL _ END _ BOUND ( 3 , 1 ) , <nl> + EXCL _ START _ BOUND ( 3 , 1 ) ; <nl> <nl> private final int comparison ; <nl> <nl> - / / If clusterable c1 has this Kind and is a strict prefix of clusterable c2 , then this <nl> - / / is the result of compare ( c1 , c2 ) . Basically , this is the same as comparing the kind of c1 to <nl> - / / CLUSTERING . <nl> - public final int prefixComparisonResult ; <nl> + / * * <nl> + * Return the comparison of this kind to CLUSTERING . <nl> + * For bounds / boundaries , this basically tells us if we sort before or after our clustering values . <nl> + * / <nl> + public final int comparedToClustering ; <nl> <nl> - private Kind ( int comparison , int prefixComparisonResult ) <nl> + private Kind ( int comparison , int comparedToClustering ) <nl> { <nl> this . comparison = comparison ; <nl> - this . prefixComparisonResult = prefixComparisonResult ; <nl> + this . comparedToClustering = comparedToClustering ; <nl> } <nl> <nl> / * * <nl> @ @ - 441 , 7 + 442 , 7 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab <nl> for ( int i = 0 ; i < bound . size ( ) ; i + + ) <nl> { <nl> if ( ! hasComponent ( i ) ) <nl> - return nextKind . prefixComparisonResult ; <nl> + return nextKind . comparedToClustering ; <nl> <nl> int cmp = comparator . compareComponent ( i , nextValues [ i ] , bound . get ( i ) ) ; <nl> if ( cmp ! = 0 ) <nl> @ @ - 452 , 7 + 453 , 7 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab <nl> return nextKind . compareTo ( bound . kind ( ) ) ; <nl> <nl> / / We know that we ' ll have exited already if nextSize < bound . size <nl> - return - bound . kind ( ) . prefixComparisonResult ; <nl> + return - bound . kind ( ) . comparedToClustering ; <nl> } <nl> <nl> private boolean hasComponent ( int i ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / db / RangeTombstone . java b / src / java / org / apache / cassandra / db / RangeTombstone . java <nl> index de21950 . . df60933 100644 <nl> - - - a / src / java / org / apache / cassandra / db / RangeTombstone . java <nl> + + + b / src / java / org / apache / cassandra / db / RangeTombstone . java <nl> @ @ - 71 , 6 + 71 , 11 @ @ public class RangeTombstone <nl> return deletion ; <nl> } <nl> <nl> + public String toString ( ClusteringComparator comparator ) <nl> + { <nl> + return slice . toString ( comparator ) + " @ " + deletion ; <nl> + } <nl> + <nl> @ Override <nl> public boolean equals ( Object other ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / RangeTombstoneList . java b / src / java / org / apache / cassandra / db / RangeTombstoneList . java <nl> index c377d10 . . 64f0978 100644 <nl> - - - a / src / java / org / apache / cassandra / db / RangeTombstoneList . java <nl> + + + b / src / java / org / apache / cassandra / db / RangeTombstoneList . java <nl> @ @ - 34 , 6 + 34 , 7 @ @ import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . utils . ObjectSizes ; <nl> import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> / * * <nl> * Data structure holding the range tombstones of a ColumnFamily . <nl> @ @ - 163 , 7 + 164 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable <nl> int c = comparator . compare ( ends [ size - 1 ] , start ) ; <nl> <nl> / / Fast path if we add in sorted order <nl> - if ( c < 0 ) <nl> + if ( c < = 0 ) <nl> { <nl> addInternal ( size , start , end , markedAt , delTime ) ; <nl> } <nl> @ @ - 171 , 7 + 172 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable <nl> { <nl> / / Note : insertFrom expect i to be the insertion point in term of interval ends <nl> int pos = Arrays . binarySearch ( ends , 0 , size , start , comparator ) ; <nl> - insertFrom ( ( pos > = 0 ? pos : - pos - 1 ) , start , end , markedAt , delTime ) ; <nl> + insertFrom ( ( pos > = 0 ? pos + 1 : - pos - 1 ) , start , end , markedAt , delTime ) ; <nl> } <nl> boundaryHeapSize + = start . unsharedHeapSize ( ) + end . unsharedHeapSize ( ) ; <nl> } <nl> @ @ - 504 , 12 + 505 , 14 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable <nl> <nl> / * <nl> * Inserts a new element starting at index i . This method assumes that : <nl> - * ends [ i - 1 ] < start < ends [ i ] <nl> - * ( note that we cannot have start = = end since both will at least have a different bound " kind " ) <nl> + * ends [ i - 1 ] < = start < ends [ i ] <nl> + * ( note that start can be equal to ends [ i - 1 ] in the case where we have a boundary , i . e . for instance <nl> + * ends [ i - 1 ] is the exclusive end of X and start is the inclusive start of X ) . <nl> * <nl> * A RangeTombstoneList is a list of range [ s _ 0 , e _ 0 ] . . . [ s _ n , e _ n ] such that : <nl> - * - s _ i < = e _ i <nl> - * - e _ i < s _ i + 1 <nl> + * - s _ i is a start bound and e _ i is a end bound <nl> + * - s _ i < e _ i <nl> + * - e _ i < = s _ i + 1 <nl> * Basically , range are non overlapping and in order . <nl> * / <nl> private void insertFrom ( int i , Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) <nl> @ @ - 517 , 7 + 520 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable <nl> while ( i < size ) <nl> { <nl> assert start . isStart ( ) & & end . isEnd ( ) ; <nl> - assert i = = 0 | | comparator . compare ( ends [ i - 1 ] , start ) < 0 ; <nl> + assert i = = 0 | | comparator . compare ( ends [ i - 1 ] , start ) < = 0 ; <nl> assert comparator . compare ( start , ends [ i ] ) < 0 ; <nl> <nl> if ( Slice . isEmpty ( comparator , start , end ) ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> index b5ac19b . . 8b52b0b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> @ @ - 114 , 6 + 114 , 20 @ @ public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker <nl> return deletion ; <nl> } <nl> <nl> + public boolean openIsInclusive ( boolean reversed ) <nl> + { <nl> + if ( ! isOpen ( reversed ) ) <nl> + throw new IllegalStateException ( ) ; <nl> + return bound . isInclusive ( ) ; <nl> + } <nl> + <nl> + public boolean closeIsInclusive ( boolean reversed ) <nl> + { <nl> + if ( isOpen ( reversed ) ) <nl> + throw new IllegalStateException ( ) ; <nl> + return bound . isInclusive ( ) ; <nl> + } <nl> + <nl> public void copyTo ( RangeTombstoneMarker . Writer writer ) <nl> { <nl> copyBoundTo ( writer ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> index 1140d40 . . f17515d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> @ @ - 87 , 6 + 87 , 16 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker <nl> return reversed ? endDeletion : startDeletion ; <nl> } <nl> <nl> + public boolean openIsInclusive ( boolean reversed ) <nl> + { <nl> + return ( bound . kind ( ) = = ClusteringPrefix . Kind . EXCL _ END _ INCL _ START _ BOUNDARY ) ^ reversed ; <nl> + } <nl> + <nl> + public boolean closeIsInclusive ( boolean reversed ) <nl> + { <nl> + return ( bound . kind ( ) = = ClusteringPrefix . Kind . INCL _ END _ EXCL _ START _ BOUNDARY ) ^ reversed ; <nl> + } <nl> + <nl> public boolean isOpen ( boolean reversed ) <nl> { <nl> / / A boundary always open one side <nl> @ @ - 99 , 21 + 109 , 9 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker <nl> return true ; <nl> } <nl> <nl> - public static boolean isBoundary ( ClusteringComparator comparator , Slice . Bound close , Slice . Bound open ) <nl> - { <nl> - if ( ! comparator . isOnSameClustering ( close , open ) ) <nl> - return false ; <nl> - <nl> - / / If both bound are exclusive , then it ' s not a boundary , otherwise it is one . <nl> - / / Note that most code should never call this with 2 inclusive bound : this would mean we had <nl> - / / 2 RTs that were overlapping and RangeTombstoneList don ' t create that . However , old <nl> - / / code was generating that so supporting this case helps dealing with backward compatibility . <nl> - return close . isInclusive ( ) | | open . isInclusive ( ) ; <nl> - } <nl> - <nl> - / / Please note that isBoundary * must * have been called ( and returned true ) before this is called . <nl> public static RangeTombstoneBoundaryMarker makeBoundary ( boolean reversed , Slice . Bound close , Slice . Bound open , DeletionTime closeDeletion , DeletionTime openDeletion ) <nl> { <nl> + assert RangeTombstone . Bound . Kind . compare ( close . kind ( ) , open . kind ( ) ) = = 0 : " Both bound don ' t form a boundary " ; <nl> boolean isExclusiveClose = close . isExclusive ( ) | | ( close . isInclusive ( ) & & open . isInclusive ( ) & & openDeletion . supersedes ( closeDeletion ) ) ; <nl> return isExclusiveClose <nl> ? exclusiveCloseInclusiveOpen ( reversed , close . getRawValues ( ) , closeDeletion , openDeletion ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java <nl> index 1a506d5 . . 380e6b0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java <nl> @ @ - 41 , 6 + 41 , 8 @ @ public interface RangeTombstoneMarker extends Unfiltered <nl> public boolean isClose ( boolean reversed ) ; <nl> public DeletionTime openDeletionTime ( boolean reversed ) ; <nl> public DeletionTime closeDeletionTime ( boolean reversed ) ; <nl> + public boolean openIsInclusive ( boolean reversed ) ; <nl> + public boolean closeIsInclusive ( boolean reversed ) ; <nl> <nl> public interface Writer extends Slice . Bound . Writer <nl> { <nl> @ @ - 121 , 33 + 123 , 6 @ @ public interface RangeTombstoneMarker extends Unfiltered <nl> * / <nl> public static class Merger <nl> { <nl> - / / Boundaries sorts like the bound that have their equivalent " inclusive " part and that ' s the main action we <nl> - / / care about as far as merging goes . So MergedKind just group those as the same case , and tell us whether <nl> - / / we ' re dealing with an open or a close ( based on whether we ' re dealing with reversed iterators or not ) . <nl> - / / Really this enum is just a convenience for merging . <nl> - private enum MergedKind <nl> - { <nl> - INCL _ OPEN , EXCL _ CLOSE , EXCL _ OPEN , INCL _ CLOSE ; <nl> - <nl> - public static MergedKind forBound ( RangeTombstone . Bound bound , boolean reversed ) <nl> - { <nl> - switch ( bound . kind ( ) ) <nl> - { <nl> - case INCL _ START _ BOUND : <nl> - case EXCL _ END _ INCL _ START _ BOUNDARY : <nl> - return reversed ? INCL _ CLOSE : INCL _ OPEN ; <nl> - case EXCL _ END _ BOUND : <nl> - return reversed ? EXCL _ OPEN : EXCL _ CLOSE ; <nl> - case EXCL _ START _ BOUND : <nl> - return reversed ? EXCL _ CLOSE : EXCL _ OPEN ; <nl> - case INCL _ END _ EXCL _ START _ BOUNDARY : <nl> - case INCL _ END _ BOUND : <nl> - return reversed ? INCL _ OPEN : INCL _ CLOSE ; <nl> - } <nl> - throw new AssertionError ( ) ; <nl> - } <nl> - } <nl> - <nl> private final CFMetaData metadata ; <nl> private final UnfilteredRowIterators . MergeListener listener ; <nl> private final DeletionTime partitionDeletion ; <nl> @ @ - 202 , 33 + 177 , 29 @ @ public interface RangeTombstoneMarker extends Unfiltered <nl> if ( previousDeletionTimeInMerged . equals ( newDeletionTimeInMerged ) ) <nl> return null ; <nl> <nl> - ByteBuffer [ ] values = bound . getRawValues ( ) ; <nl> + boolean isBeforeClustering = bound . kind ( ) . comparedToClustering < 0 ; <nl> + if ( reversed ) <nl> + isBeforeClustering = ! isBeforeClustering ; <nl> <nl> + ByteBuffer [ ] values = bound . getRawValues ( ) ; <nl> RangeTombstoneMarker merged ; <nl> - switch ( MergedKind . forBound ( bound , reversed ) ) <nl> + if ( previousDeletionTimeInMerged . isLive ( ) ) <nl> + { <nl> + merged = isBeforeClustering <nl> + ? RangeTombstoneBoundMarker . inclusiveOpen ( reversed , values , newDeletionTimeInMerged ) <nl> + : RangeTombstoneBoundMarker . exclusiveOpen ( reversed , values , newDeletionTimeInMerged ) ; <nl> + } <nl> + else if ( newDeletionTimeInMerged . isLive ( ) ) <nl> + { <nl> + merged = isBeforeClustering <nl> + ? RangeTombstoneBoundMarker . exclusiveClose ( reversed , values , previousDeletionTimeInMerged ) <nl> + : RangeTombstoneBoundMarker . inclusiveClose ( reversed , values , previousDeletionTimeInMerged ) ; <nl> + } <nl> + else <nl> { <nl> - case INCL _ OPEN : <nl> - merged = previousDeletionTimeInMerged . isLive ( ) <nl> - ? RangeTombstoneBoundMarker . inclusiveOpen ( reversed , values , newDeletionTimeInMerged ) <nl> - : RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; <nl> - break ; <nl> - case EXCL _ CLOSE : <nl> - merged = newDeletionTimeInMerged . isLive ( ) <nl> - ? RangeTombstoneBoundMarker . exclusiveClose ( reversed , values , previousDeletionTimeInMerged ) <nl> - : RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; <nl> - break ; <nl> - case EXCL _ OPEN : <nl> - merged = previousDeletionTimeInMerged . isLive ( ) <nl> - ? RangeTombstoneBoundMarker . exclusiveOpen ( reversed , values , newDeletionTimeInMerged ) <nl> - : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; <nl> - break ; <nl> - case INCL _ CLOSE : <nl> - merged = newDeletionTimeInMerged . isLive ( ) <nl> - ? RangeTombstoneBoundMarker . inclusiveClose ( reversed , values , previousDeletionTimeInMerged ) <nl> - : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; <nl> - break ; <nl> - default : <nl> - throw new AssertionError ( ) ; <nl> + merged = isBeforeClustering <nl> + ? RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) <nl> + : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; <nl> } <nl> <nl> if ( listener ! = null ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java b / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java <nl> index 51383a2 . . f923329 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java <nl> @ @ - 27 , 7 + 27 , 6 @ @ import org . apache . cassandra . db . * ; <nl> <nl> public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltered > implements PeekingIterator < Unfiltered > <nl> { <nl> - private final ClusteringComparator clusteringComparator ; <nl> private final Comparator < Clusterable > comparator ; <nl> private final boolean reversed ; <nl> <nl> @ @ - 42 , 7 + 41 , 6 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere <nl> <nl> public RowAndTombstoneMergeIterator ( ClusteringComparator comparator , boolean reversed ) <nl> { <nl> - this . clusteringComparator = comparator ; <nl> this . comparator = reversed ? comparator . reversed ( ) : comparator ; <nl> this . reversed = reversed ; <nl> } <nl> @ @ - 87 , 7 + 85 , 8 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere <nl> { <nl> RangeTombstone rt = nextTombstone ; <nl> nextTombstone = tombstoneIter . hasNext ( ) ? tombstoneIter . next ( ) : null ; <nl> - if ( nextTombstone ! = null & & RangeTombstoneBoundaryMarker . isBoundary ( clusteringComparator , rt . deletedSlice ( ) . close ( reversed ) , nextTombstone . deletedSlice ( ) . open ( reversed ) ) ) <nl> + / / An end and a start makes a boundary if they sort similarly <nl> + if ( nextTombstone ! = null & & RangeTombstone . Bound . Kind . compare ( rt . deletedSlice ( ) . close ( reversed ) . kind ( ) , nextTombstone . deletedSlice ( ) . open ( reversed ) . kind ( ) ) = = 0 ) <nl> { <nl> next = RangeTombstoneBoundaryMarker . makeBoundary ( reversed , <nl> rt . deletedSlice ( ) . close ( reversed ) , <nl> @ @ - 113 , 7 + 112 , 7 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere <nl> { <nl> RangeTombstone rt = nextTombstone ; <nl> nextTombstone = tombstoneIter . hasNext ( ) ? tombstoneIter . next ( ) : null ; <nl> - if ( nextTombstone ! = null & & RangeTombstoneBoundaryMarker . isBoundary ( clusteringComparator , rt . deletedSlice ( ) . close ( reversed ) , nextTombstone . deletedSlice ( ) . open ( reversed ) ) ) <nl> + if ( nextTombstone ! = null & & RangeTombstone . Bound . Kind . compare ( rt . deletedSlice ( ) . close ( reversed ) . kind ( ) , nextTombstone . deletedSlice ( ) . open ( reversed ) . kind ( ) ) = = 0 ) <nl> { <nl> next = RangeTombstoneBoundaryMarker . makeBoundary ( reversed , <nl> rt . deletedSlice ( ) . close ( reversed ) , <nl> diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java <nl> index 73b91ea . . 8a697f4 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java <nl> @ @ - 26 , 12 + 26 , 12 @ @ import static org . junit . Assert . * ; <nl> <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . db . * ; <nl> - import org . apache . cassandra . db . marshal . IntegerType ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> public class RangeTombstoneListTest <nl> { <nl> - private static final ClusteringComparator cmp = new ClusteringComparator ( IntegerType . instance ) ; <nl> + private static final ClusteringComparator cmp = new ClusteringComparator ( Int32Type . instance ) ; <nl> <nl> @ Test <nl> public void sortedAdditionTest ( ) <nl> @ @ - 263 , 19 + 263 , 35 @ @ public class RangeTombstoneListTest <nl> <nl> int prevStart = - 1 ; <nl> int prevEnd = 0 ; <nl> + boolean prevStartInclusive = false ; <nl> + boolean prevEndInclusive = false ; <nl> for ( int i = 0 ; i < size ; i + + ) <nl> { <nl> int nextStart = prevEnd + rand . nextInt ( maxItDistance ) ; <nl> int nextEnd = nextStart + rand . nextInt ( maxItSize ) ; <nl> <nl> - / / We can have an interval [ x , x ] , but not 2 consecutives ones for the same x <nl> - if ( nextEnd = = nextStart & & prevEnd = = prevStart & & prevEnd = = nextStart ) <nl> - nextEnd + = 1 + rand . nextInt ( maxItDistance ) ; <nl> + boolean startInclusive = rand . nextBoolean ( ) ; <nl> + boolean endInclusive = rand . nextBoolean ( ) ; <nl> <nl> - l . add ( rt ( nextStart , nextEnd , rand . nextInt ( maxMarkedAt ) ) ) ; <nl> + / / Now make sure we create meaningful ranges <nl> + <nl> + if ( prevEnd = = nextStart ) <nl> + startInclusive = ! prevEndInclusive ; <nl> + <nl> + if ( nextStart = = nextEnd ) <nl> + { <nl> + if ( startInclusive ) <nl> + endInclusive = true ; <nl> + else <nl> + nextEnd + = 1 ; <nl> + } <nl> + <nl> + l . add ( rt ( nextStart , startInclusive , nextEnd , endInclusive , rand . nextInt ( maxMarkedAt ) ) ) ; <nl> <nl> prevStart = nextStart ; <nl> prevEnd = nextEnd ; <nl> + prevStartInclusive = startInclusive ; <nl> + prevEndInclusive = endInclusive ; <nl> } <nl> return l ; <nl> } <nl> @ @ - 339 , 7 + 355 , 7 @ @ public class RangeTombstoneListTest <nl> Slice curr = iter . next ( ) . deletedSlice ( ) ; <nl> <nl> assertFalse ( " Invalid empty slice " + curr . toString ( cmp ) , curr . isEmpty ( cmp ) ) ; <nl> - assertTrue ( " Slice not in order or overlapping : " + prev . toString ( cmp ) + curr . toString ( cmp ) , cmp . compare ( prev . end ( ) , curr . start ( ) ) < 0 ) ; <nl> + assertTrue ( " Slice not in order or overlapping : " + prev . toString ( cmp ) + curr . toString ( cmp ) , cmp . compare ( prev . end ( ) , curr . start ( ) ) < = 0 ) ; <nl> } <nl> } <nl> <nl> @ @ - 377 , 6 + 393 , 11 @ @ public class RangeTombstoneListTest <nl> return rt ( start , end , tstamp , 0 ) ; <nl> } <nl> <nl> + private static RangeTombstone rt ( int start , boolean startInclusive , int end , boolean endInclusive , long tstamp ) <nl> + { <nl> + return new RangeTombstone ( Slice . make ( Slice . Bound . create ( cmp , true , startInclusive , start ) , Slice . Bound . create ( cmp , false , endInclusive , end ) ) , new SimpleDeletionTime ( tstamp , 0 ) ) ; <nl> + } <nl> + <nl> private static RangeTombstone rt ( int start , int end , long tstamp , int delTime ) <nl> { <nl> return new RangeTombstone ( Slice . make ( Slice . Bound . inclusiveStartOf ( bb ( start ) ) , Slice . Bound . inclusiveEndOf ( bb ( end ) ) ) , new SimpleDeletionTime ( tstamp , delTime ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java b / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java <nl> new file mode 100644 <nl> index 0000000 . . a607dca <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java <nl> @ @ - 0 , 0 + 1 , 679 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . db . rows ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> + import java . util . function . Function ; <nl> + import java . util . regex . Matcher ; <nl> + import java . util . regex . Pattern ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import com . google . common . collect . Iterators ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . Slice . Bound ; <nl> + import org . apache . cassandra . db . marshal . AsciiType ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . rows . Unfiltered . Kind ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> + <nl> + public class UnfilteredRowIteratorsMergeTest <nl> + { <nl> + static DecoratedKey partitionKey = Util . dk ( " key " ) ; <nl> + static DeletionTime partitionLevelDeletion = DeletionTime . LIVE ; <nl> + static CFMetaData metadata = CFMetaData . Builder . create ( " UnfilteredRowIteratorsMergeTest " , " Test " ) . <nl> + addPartitionKey ( " key " , AsciiType . instance ) . <nl> + addClusteringColumn ( " clustering " , Int32Type . instance ) . <nl> + addRegularColumn ( " data " , Int32Type . instance ) . <nl> + build ( ) ; <nl> + static Comparator < Clusterable > comparator = new ClusteringComparator ( Int32Type . instance ) ; <nl> + static int nowInSec = FBUtilities . nowInSeconds ( ) ; <nl> + <nl> + static final int RANGE = 3000 ; <nl> + static final int DEL _ RANGE = 100 ; <nl> + static final int ITERATORS = 15 ; <nl> + static final int ITEMS = 300 ; <nl> + <nl> + boolean reversed ; <nl> + <nl> + public UnfilteredRowIteratorsMergeTest ( ) <nl> + { <nl> + } <nl> + <nl> + @ Test <nl> + public void testTombstoneMerge ( ) <nl> + { <nl> + testTombstoneMerge ( false , false ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTombstoneMergeReversed ( ) <nl> + { <nl> + testTombstoneMerge ( true , false ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTombstoneMergeIterative ( ) <nl> + { <nl> + testTombstoneMerge ( false , true ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTombstoneMergeReversedIterative ( ) <nl> + { <nl> + testTombstoneMerge ( true , true ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testDuplicateRangeCase ( ) <nl> + { <nl> + testForInput ( " 67 < = [ 98 ] [ 98 ] < = 67 " , <nl> + " 66 < = [ 11 ] [ 11 ] < 71 " , <nl> + " 66 < [ 13 ] [ 13 ] < 67 " ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unused " ) <nl> + public void testTombstoneMerge ( boolean reversed , boolean iterations ) <nl> + { <nl> + for ( int seed = 1 ; seed < = 100 ; + + seed ) <nl> + { <nl> + this . reversed = reversed ; <nl> + if ( ITEMS < = 20 ) <nl> + System . out . println ( " \ nSeed " + seed ) ; <nl> + <nl> + Random r = new Random ( seed ) ; <nl> + List < Function < Integer , Integer > > timeGenerators = ImmutableList . of ( <nl> + x - > - 1 , <nl> + x - > DEL _ RANGE , <nl> + x - > r . nextInt ( DEL _ RANGE ) <nl> + ) ; <nl> + List < List < Unfiltered > > sources = new ArrayList < > ( ITERATORS ) ; <nl> + if ( ITEMS < = 20 ) <nl> + System . out . println ( " Merging " ) ; <nl> + for ( int i = 0 ; i < ITERATORS ; + + i ) <nl> + sources . add ( generateSource ( r , timeGenerators . get ( r . nextInt ( timeGenerators . size ( ) ) ) ) ) ; <nl> + List < Unfiltered > merged = merge ( sources , iterations ) ; <nl> + <nl> + if ( ITEMS < = 20 ) <nl> + System . out . println ( " results in " ) ; <nl> + if ( ITEMS < = 20 ) <nl> + dumpList ( merged ) ; <nl> + verifyEquivalent ( sources , merged ) ; <nl> + verifyValid ( merged ) ; <nl> + if ( reversed ) <nl> + { <nl> + Collections . reverse ( merged ) ; <nl> + this . reversed = false ; <nl> + verifyValid ( merged ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private List < Unfiltered > merge ( List < List < Unfiltered > > sources , boolean iterations ) <nl> + { <nl> + List < UnfilteredRowIterator > us = sources . stream ( ) . map ( l - > new Source ( l . iterator ( ) ) ) . collect ( Collectors . toList ( ) ) ; <nl> + List < Unfiltered > merged = new ArrayList < > ( ) ; <nl> + Iterators . addAll ( merged , safeIterator ( mergeIterators ( us , iterations ) ) ) ; <nl> + return merged ; <nl> + } <nl> + <nl> + public UnfilteredRowIterator mergeIterators ( List < UnfilteredRowIterator > us , boolean iterations ) <nl> + { <nl> + int now = FBUtilities . nowInSeconds ( ) ; <nl> + if ( iterations ) <nl> + { <nl> + UnfilteredRowIterator mi = us . get ( 0 ) ; <nl> + int i ; <nl> + for ( i = 1 ; i + 2 < = ITERATORS ; i + = 2 ) <nl> + mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) , us . get ( i + 1 ) ) , now ) ; <nl> + if ( i + 1 < = ITERATORS ) <nl> + mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) ) , now ) ; <nl> + return mi ; <nl> + } <nl> + else <nl> + { <nl> + return UnfilteredRowIterators . merge ( us , now ) ; <nl> + } <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unused " ) <nl> + private List < Unfiltered > generateSource ( Random r , Function < Integer , Integer > timeGenerator ) <nl> + { <nl> + int [ ] positions = new int [ ITEMS + 1 ] ; <nl> + for ( int i = 0 ; i < ITEMS ; + + i ) <nl> + positions [ i ] = r . nextInt ( RANGE ) ; <nl> + positions [ ITEMS ] = RANGE ; <nl> + Arrays . sort ( positions ) ; <nl> + <nl> + List < Unfiltered > content = new ArrayList < > ( ITEMS ) ; <nl> + int prev = - 1 ; <nl> + for ( int i = 0 ; i < ITEMS ; + + i ) <nl> + { <nl> + int pos = positions [ i ] ; <nl> + int sz = positions [ i + 1 ] - pos ; <nl> + if ( sz = = 0 & & pos = = prev ) <nl> + / / Filter out more than two of the same position . <nl> + continue ; <nl> + if ( r . nextBoolean ( ) | | pos = = prev ) <nl> + { <nl> + int span ; <nl> + boolean includesStart ; <nl> + boolean includesEnd ; <nl> + if ( pos > prev ) <nl> + { <nl> + span = r . nextInt ( sz + 1 ) ; <nl> + includesStart = span > 0 ? r . nextBoolean ( ) : true ; <nl> + includesEnd = span > 0 ? r . nextBoolean ( ) : true ; <nl> + } <nl> + else <nl> + { <nl> + span = 1 + r . nextInt ( sz ) ; <nl> + includesStart = false ; <nl> + includesEnd = r . nextBoolean ( ) ; <nl> + } <nl> + int deltime = r . nextInt ( DEL _ RANGE ) ; <nl> + DeletionTime dt = new SimpleDeletionTime ( deltime , deltime ) ; <nl> + content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos , true , includesStart ) , dt ) ) ; <nl> + content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos + span , false , includesEnd ) , dt ) ) ; <nl> + prev = pos + span - ( includesEnd ? 0 : 1 ) ; <nl> + } <nl> + else <nl> + { <nl> + content . add ( emptyRowAt ( pos , timeGenerator ) ) ; <nl> + prev = pos ; <nl> + } <nl> + } <nl> + <nl> + attachBoundaries ( content ) ; <nl> + if ( reversed ) <nl> + { <nl> + Collections . reverse ( content ) ; <nl> + } <nl> + verifyValid ( content ) ; <nl> + if ( ITEMS < = 20 ) <nl> + dumpList ( content ) ; <nl> + return content ; <nl> + } <nl> + <nl> + static void attachBoundaries ( List < Unfiltered > content ) <nl> + { <nl> + int di = 0 ; <nl> + RangeTombstoneMarker prev = null ; <nl> + for ( int si = 0 ; si < content . size ( ) ; + + si ) <nl> + { <nl> + Unfiltered currUnfiltered = content . get ( si ) ; <nl> + RangeTombstoneMarker curr = currUnfiltered . kind ( ) = = Kind . RANGE _ TOMBSTONE _ MARKER ? <nl> + ( RangeTombstoneMarker ) currUnfiltered : <nl> + null ; <nl> + if ( prev ! = null & & curr ! = null & & prev . isClose ( false ) & & curr . isOpen ( false ) & & prev . clustering ( ) . invert ( ) . equals ( curr . clustering ( ) ) ) <nl> + { <nl> + / / Join . Prefer not to use merger to check its correctness . <nl> + RangeTombstone . Bound b = prev . clustering ( ) ; <nl> + b = b . withNewKind ( b . isInclusive ( ) ? RangeTombstone . Bound . Kind . INCL _ END _ EXCL _ START _ BOUNDARY : RangeTombstone . Bound . Kind . EXCL _ END _ INCL _ START _ BOUNDARY ) ; <nl> + prev = new RangeTombstoneBoundaryMarker ( b , prev . closeDeletionTime ( false ) , curr . openDeletionTime ( false ) ) ; <nl> + currUnfiltered = prev ; <nl> + - - di ; <nl> + } <nl> + content . set ( di + + , currUnfiltered ) ; <nl> + prev = curr ; <nl> + } <nl> + for ( int pos = content . size ( ) - 1 ; pos > = di ; - - pos ) <nl> + content . remove ( pos ) ; <nl> + } <nl> + <nl> + void verifyValid ( List < Unfiltered > list ) <nl> + { <nl> + int reversedAsMultiplier = reversed ? - 1 : 1 ; <nl> + try { <nl> + RangeTombstoneMarker prev = null ; <nl> + Unfiltered prevUnfiltered = null ; <nl> + for ( Unfiltered unfiltered : list ) <nl> + { <nl> + Assert . assertTrue ( " Order violation prev " + str ( prevUnfiltered ) + " curr " + str ( unfiltered ) , <nl> + prevUnfiltered = = null | | comparator . compare ( prevUnfiltered , unfiltered ) * reversedAsMultiplier < 0 ) ; <nl> + prevUnfiltered = unfiltered ; <nl> + <nl> + if ( unfiltered . kind ( ) = = Kind . RANGE _ TOMBSTONE _ MARKER ) <nl> + { <nl> + RangeTombstoneMarker curr = ( RangeTombstoneMarker ) unfiltered ; <nl> + if ( prev ! = null ) <nl> + { <nl> + if ( curr . isClose ( reversed ) ) <nl> + { <nl> + Assert . assertTrue ( str ( unfiltered ) + " follows another close marker " + str ( prev ) , prev . isOpen ( reversed ) ) ; <nl> + Assert . assertEquals ( " Deletion time mismatch for open " + str ( prev ) + " and close " + str ( unfiltered ) , <nl> + prev . openDeletionTime ( reversed ) , <nl> + curr . closeDeletionTime ( reversed ) ) ; <nl> + } <nl> + else <nl> + Assert . assertFalse ( str ( curr ) + " follows another open marker " + str ( prev ) , prev . isOpen ( reversed ) ) ; <nl> + } <nl> + <nl> + prev = curr ; <nl> + } <nl> + } <nl> + Assert . assertFalse ( " Cannot end in open marker " + str ( prev ) , prev ! = null & & prev . isOpen ( reversed ) ) ; <nl> + <nl> + } catch ( AssertionError e ) { <nl> + System . out . println ( e ) ; <nl> + dumpList ( list ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> + <nl> + void verifyEquivalent ( List < List < Unfiltered > > sources , List < Unfiltered > merged ) <nl> + { <nl> + try <nl> + { <nl> + for ( int i = 0 ; i < RANGE ; + + i ) <nl> + { <nl> + Clusterable c = clusteringFor ( i ) ; <nl> + DeletionTime dt = DeletionTime . LIVE ; <nl> + for ( List < Unfiltered > source : sources ) <nl> + { <nl> + dt = deletionFor ( c , source , dt ) ; <nl> + } <nl> + Assert . assertEquals ( " Deletion time mismatch for position " + str ( c ) , dt , deletionFor ( c , merged ) ) ; <nl> + if ( dt = = DeletionTime . LIVE ) <nl> + { <nl> + Optional < Unfiltered > sourceOpt = sources . stream ( ) . map ( source - > rowFor ( c , source ) ) . filter ( x - > x ! = null ) . findAny ( ) ; <nl> + Unfiltered mergedRow = rowFor ( c , merged ) ; <nl> + Assert . assertEquals ( " Content mismatch for position " + str ( c ) , str ( sourceOpt . orElse ( null ) ) , str ( mergedRow ) ) ; <nl> + } <nl> + } <nl> + } <nl> + catch ( AssertionError e ) <nl> + { <nl> + System . out . println ( e ) ; <nl> + for ( List < Unfiltered > list : sources ) <nl> + dumpList ( list ) ; <nl> + System . out . println ( " merged " ) ; <nl> + dumpList ( merged ) ; <nl> + throw e ; <nl> + } <nl> + } <nl> + <nl> + private Unfiltered rowFor ( Clusterable pointer , List < Unfiltered > list ) <nl> + { <nl> + int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; <nl> + return index > = 0 ? list . get ( index ) : null ; <nl> + } <nl> + <nl> + DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list ) <nl> + { <nl> + return deletionFor ( pointer , list , DeletionTime . LIVE ) ; <nl> + } <nl> + <nl> + DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list , DeletionTime def ) <nl> + { <nl> + if ( list . isEmpty ( ) ) <nl> + return def ; <nl> + <nl> + int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; <nl> + if ( index < 0 ) <nl> + index = - 1 - index ; <nl> + else <nl> + { <nl> + Row row = ( Row ) list . get ( index ) ; <nl> + if ( row . deletion ( ) ! = null & & row . deletion ( ) . supersedes ( def ) ) <nl> + def = row . deletion ( ) ; <nl> + } <nl> + <nl> + if ( index > = list . size ( ) ) <nl> + return def ; <nl> + <nl> + while ( - - index > = 0 ) <nl> + { <nl> + Unfiltered unfiltered = list . get ( index ) ; <nl> + if ( unfiltered . kind ( ) = = Kind . ROW ) <nl> + continue ; <nl> + RangeTombstoneMarker lower = ( RangeTombstoneMarker ) unfiltered ; <nl> + if ( ! lower . isOpen ( reversed ) ) <nl> + return def ; <nl> + return lower . openDeletionTime ( reversed ) . supersedes ( def ) ? lower . openDeletionTime ( reversed ) : def ; <nl> + } <nl> + return def ; <nl> + } <nl> + <nl> + private static Bound boundFor ( int pos , boolean start , boolean inclusive ) <nl> + { <nl> + return Bound . create ( Bound . boundKind ( start , inclusive ) , new ByteBuffer [ ] { Int32Type . instance . decompose ( pos ) } ) ; <nl> + } <nl> + <nl> + private static SimpleClustering clusteringFor ( int i ) <nl> + { <nl> + return new SimpleClustering ( Int32Type . instance . decompose ( i ) ) ; <nl> + } <nl> + <nl> + static Row emptyRowAt ( int pos , Function < Integer , Integer > timeGenerator ) <nl> + { <nl> + final Clustering clustering = clusteringFor ( pos ) ; <nl> + final LivenessInfo live = SimpleLivenessInfo . forUpdate ( timeGenerator . apply ( pos ) , 0 , nowInSec , metadata ) ; <nl> + return emptyRowAt ( clustering , live , DeletionTime . LIVE ) ; <nl> + } <nl> + <nl> + public static class TestCell extends AbstractCell <nl> + { <nl> + private final ColumnDefinition column ; <nl> + private final ByteBuffer value ; <nl> + private final LivenessInfo info ; <nl> + <nl> + public TestCell ( ColumnDefinition column , ByteBuffer value , LivenessInfo info ) <nl> + { <nl> + this . column = column ; <nl> + this . value = value ; <nl> + this . info = info . takeAlias ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public ColumnDefinition column ( ) <nl> + { <nl> + return column ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isCounterCell ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public ByteBuffer value ( ) <nl> + { <nl> + return value ; <nl> + } <nl> + <nl> + @ Override <nl> + public LivenessInfo livenessInfo ( ) <nl> + { <nl> + return info ; <nl> + } <nl> + <nl> + @ Override <nl> + public CellPath path ( ) <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> + static Row emptyRowAt ( final Clustering clustering , final LivenessInfo live , final DeletionTime deletion ) <nl> + { <nl> + final ColumnDefinition columnDef = metadata . getColumnDefinition ( new ColumnIdentifier ( " data " , true ) ) ; <nl> + final Cell cell = new TestCell ( columnDef , clustering . get ( 0 ) , live ) ; <nl> + <nl> + return new AbstractRow ( ) <nl> + { <nl> + @ Override <nl> + public Columns columns ( ) <nl> + { <nl> + return Columns . of ( columnDef ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public LivenessInfo primaryKeyLivenessInfo ( ) <nl> + { <nl> + return live ; <nl> + } <nl> + <nl> + @ Override <nl> + public DeletionTime deletion ( ) <nl> + { <nl> + return deletion ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isEmpty ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasComplexDeletion ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public Clustering clustering ( ) <nl> + { <nl> + return clustering ; <nl> + } <nl> + <nl> + @ Override <nl> + public Cell getCell ( ColumnDefinition c ) <nl> + { <nl> + return c = = columnDef ? cell : null ; <nl> + } <nl> + <nl> + @ Override <nl> + public Cell getCell ( ColumnDefinition c , CellPath path ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < Cell > getCells ( ColumnDefinition c ) <nl> + { <nl> + return Iterators . singletonIterator ( cell ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public DeletionTime getDeletion ( ColumnDefinition c ) <nl> + { <nl> + return DeletionTime . LIVE ; <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < Cell > iterator ( ) <nl> + { <nl> + return Iterators . < Cell > emptyIterator ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public SearchIterator < ColumnDefinition , ColumnData > searchIterator ( ) <nl> + { <nl> + return new SearchIterator < ColumnDefinition , ColumnData > ( ) <nl> + { <nl> + @ Override <nl> + public boolean hasNext ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + @ Override <nl> + public ColumnData next ( ColumnDefinition column ) <nl> + { <nl> + return null ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + @ Override <nl> + public Kind kind ( ) <nl> + { <nl> + return Unfiltered . Kind . ROW ; <nl> + } <nl> + <nl> + @ Override <nl> + public Row takeAlias ( ) <nl> + { <nl> + return this ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return Int32Type . instance . getString ( clustering . get ( 0 ) ) ; <nl> + } <nl> + } ; <nl> + <nl> + } <nl> + <nl> + private void dumpList ( List < Unfiltered > list ) <nl> + { <nl> + for ( Unfiltered u : list ) <nl> + System . out . print ( str ( u ) + " " ) ; <nl> + System . out . println ( ) ; <nl> + } <nl> + <nl> + private String str ( Clusterable curr ) <nl> + { <nl> + if ( curr = = null ) <nl> + return " null " ; <nl> + String val = Int32Type . instance . getString ( curr . clustering ( ) . get ( 0 ) ) ; <nl> + if ( curr instanceof RangeTombstoneMarker ) <nl> + { <nl> + RangeTombstoneMarker marker = ( RangeTombstoneMarker ) curr ; <nl> + if ( marker . isClose ( reversed ) ) <nl> + val = " [ " + marker . closeDeletionTime ( reversed ) . markedForDeleteAt ( ) + " ] " + ( marker . closeIsInclusive ( reversed ) ? " < = " : " < " ) + val ; <nl> + if ( marker . isOpen ( reversed ) ) <nl> + val = val + ( marker . openIsInclusive ( reversed ) ? " < = " : " < " ) + " [ " + marker . openDeletionTime ( reversed ) . markedForDeleteAt ( ) + " ] " ; <nl> + } <nl> + return val ; <nl> + } <nl> + <nl> + class Source extends AbstractUnfilteredRowIterator implements UnfilteredRowIterator <nl> + { <nl> + Iterator < Unfiltered > content ; <nl> + <nl> + protected Source ( Iterator < Unfiltered > content ) <nl> + { <nl> + super ( UnfilteredRowIteratorsMergeTest . metadata , <nl> + UnfilteredRowIteratorsMergeTest . partitionKey , <nl> + UnfilteredRowIteratorsMergeTest . partitionLevelDeletion , <nl> + UnfilteredRowIteratorsMergeTest . metadata . partitionColumns ( ) , <nl> + null , <nl> + reversed , <nl> + RowStats . NO _ STATS ) ; <nl> + this . content = content ; <nl> + } <nl> + <nl> + @ Override <nl> + protected Unfiltered computeNext ( ) <nl> + { <nl> + return content . hasNext ( ) ? content . next ( ) : endOfData ( ) ; <nl> + } <nl> + } <nl> + <nl> + static RangeTombstoneMarker safeMarker ( RangeTombstoneMarker marker ) <nl> + { <nl> + RangeTombstoneMarker . Builder writer = new RangeTombstoneMarker . Builder ( 1 ) ; <nl> + marker . copyTo ( writer ) ; <nl> + return writer . build ( ) ; <nl> + } <nl> + <nl> + private static Row safeRow ( Row row ) <nl> + { <nl> + return emptyRowAt ( new SimpleClustering ( row . clustering ( ) . get ( 0 ) ) , row . primaryKeyLivenessInfo ( ) , row . deletion ( ) ) ; <nl> + } <nl> + <nl> + public static UnfilteredRowIterator safeIterator ( UnfilteredRowIterator iterator ) <nl> + { <nl> + return new WrappingUnfilteredRowIterator ( iterator ) <nl> + { <nl> + @ Override <nl> + public Unfiltered next ( ) <nl> + { <nl> + Unfiltered next = super . next ( ) ; <nl> + return next . kind ( ) = = Unfiltered . Kind . ROW <nl> + ? safeRow ( ( Row ) next ) <nl> + : safeMarker ( ( RangeTombstoneMarker ) next ) ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + public void testForInput ( String . . . inputs ) <nl> + { <nl> + List < List < Unfiltered > > sources = new ArrayList < > ( ) ; <nl> + for ( String input : inputs ) <nl> + { <nl> + List < Unfiltered > source = parse ( input ) ; <nl> + attachBoundaries ( source ) ; <nl> + dumpList ( source ) ; <nl> + verifyValid ( source ) ; <nl> + sources . add ( source ) ; <nl> + } <nl> + <nl> + List < Unfiltered > merged = merge ( sources , false ) ; <nl> + System . out . println ( " Merge to : " ) ; <nl> + dumpList ( merged ) ; <nl> + verifyEquivalent ( sources , merged ) ; <nl> + verifyValid ( merged ) ; <nl> + System . out . println ( ) ; <nl> + } <nl> + <nl> + List < Unfiltered > parse ( String input ) <nl> + { <nl> + String [ ] split = input . split ( " " ) ; <nl> + Pattern open = Pattern . compile ( " ( \ \ d + ) < ( = ) ? \ \ [ ( \ \ d + ) \ \ ] " ) ; <nl> + Pattern close = Pattern . compile ( " \ \ [ ( \ \ d + ) \ \ ] < ( = ) ? ( \ \ d + ) " ) ; <nl> + Pattern row = Pattern . compile ( " ( \ \ d + ) ( \ \ [ ( \ \ d + ) \ \ ] ) ? " ) ; <nl> + List < Unfiltered > out = new ArrayList < > ( split . length ) ; <nl> + for ( String s : split ) <nl> + { <nl> + Matcher m = open . matcher ( s ) ; <nl> + if ( m . matches ( ) ) <nl> + { <nl> + out . add ( openMarker ( Integer . parseInt ( m . group ( 1 ) ) , Integer . parseInt ( m . group ( 3 ) ) , m . group ( 2 ) ! = null ) ) ; <nl> + continue ; <nl> + } <nl> + m = close . matcher ( s ) ; <nl> + if ( m . matches ( ) ) <nl> + { <nl> + out . add ( closeMarker ( Integer . parseInt ( m . group ( 3 ) ) , Integer . parseInt ( m . group ( 1 ) ) , m . group ( 2 ) ! = null ) ) ; <nl> + continue ; <nl> + } <nl> + m = row . matcher ( s ) ; <nl> + if ( m . matches ( ) ) <nl> + { <nl> + int live = m . group ( 3 ) ! = null ? Integer . parseInt ( m . group ( 3 ) ) : DEL _ RANGE ; <nl> + out . add ( emptyRowAt ( Integer . parseInt ( m . group ( 1 ) ) , x - > live ) ) ; <nl> + continue ; <nl> + } <nl> + Assert . fail ( " Can ' t parse " + s ) ; <nl> + } <nl> + return out ; <nl> + } <nl> + <nl> + private RangeTombstoneMarker openMarker ( int pos , int delTime , boolean inclusive ) <nl> + { <nl> + return marker ( pos , delTime , true , inclusive ) ; <nl> + } <nl> + <nl> + private RangeTombstoneMarker closeMarker ( int pos , int delTime , boolean inclusive ) <nl> + { <nl> + return marker ( pos , delTime , false , inclusive ) ; <nl> + } <nl> + <nl> + private RangeTombstoneMarker marker ( int pos , int delTime , boolean isStart , boolean inclusive ) <nl> + { <nl> + return new RangeTombstoneBoundMarker ( Bound . create ( Bound . boundKind ( isStart , inclusive ) , <nl> + new ByteBuffer [ ] { clusteringFor ( pos ) . get ( 0 ) } ) , <nl> + new SimpleDeletionTime ( delTime , delTime ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e48fbfd . . f598aa2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * fix error when using ORDER BY with extended selections ( CASSANDRA - 4689 ) <nl> * ( CQL3 ) Fix validation for IN queries for non - PK cols ( CASSANDRA - 4709 ) <nl> * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) <nl> + * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) <nl> Merged from 1 . 0 : <nl> * Switch from NBHM to CHM in MessagingService ' s callback map , which <nl> prevents OOM in long - running instances ( CASSANDRA - 4708 ) <nl> diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java <nl> index d0fb543 . . b32b0f7 100644 <nl> - - - a / src / java / org / apache / cassandra / cli / CliClient . java <nl> + + + b / src / java / org / apache / cassandra / cli / CliClient . java <nl> @ @ - 461 , 7 + 461 , 7 @ @ public class CliClient <nl> throws InvalidRequestException , UnavailableException , TimedOutException , TException , IllegalAccessException , NotFoundException , InstantiationException , NoSuchFieldException <nl> { <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> ColumnParent parent = new ColumnParent ( columnFamily ) ; <nl> if ( superColumnName ! = null ) <nl> parent . setSuper _ column ( superColumnName ) ; <nl> @ @ - 565 , 7 + 565 , 7 @ @ public class CliClient <nl> { <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> Tree columnFamilySpec = statement . getChild ( 0 ) ; <nl> String columnFamily = CliCompiler . getColumnFamily ( columnFamilySpec , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> ByteBuffer key = getKeyAsBytes ( columnFamily , columnFamilySpec . getChild ( 1 ) ) ; <nl> @ @ - 734 , 7 + 734 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> <nl> IndexClause clause = new IndexClause ( ) ; <nl> String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> @ @ - 828 , 7 + 828 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> / / ^ ( NODE _ COLUMN _ ACCESS < cf > < key > < column > ) <nl> Tree columnFamilySpec = statement . getChild ( 0 ) ; <nl> Tree keyTree = columnFamilySpec . getChild ( 1 ) ; / / could be a function or regular text <nl> @ @ - 1323 , 7 + 1323 , 7 @ @ public class CliClient <nl> if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) <nl> return ; <nl> <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> + long startTime = System . nanoTime ( ) ; <nl> <nl> / / extract column family <nl> String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; <nl> @ @ - 2968 , 9 + 2968 , 25 @ @ public class CliClient <nl> return false ; <nl> } <nl> <nl> + / * * <nl> + * Print elapsed time . Print 2 fraction digits if eta is under 10 ms . <nl> + * @ param startTime starting time in nanoseconds <nl> + * / <nl> private void elapsedTime ( long startTime ) <nl> { <nl> - sessionState . out . println ( " Elapsed time : " + ( System . currentTimeMillis ( ) - startTime ) + " msec ( s ) . " ) ; <nl> + / * * time elapsed in nanoseconds * / <nl> + long eta = System . nanoTime ( ) - startTime ; <nl> + <nl> + sessionState . out . print ( " Elapsed time : " ) ; <nl> + if ( eta < 10000000 ) <nl> + { <nl> + sessionState . out . print ( Math . round ( eta / 10000 . 0 ) / 100 . 0 ) ; <nl> + } <nl> + else <nl> + { <nl> + sessionState . out . print ( Math . round ( eta / 1000000 . 0 ) ) ; <nl> + } <nl> + sessionState . out . println ( " msec ( s ) . " ) ; <nl> } <nl> <nl> class CfAssumptions

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ClusteringComparator . java b / src / java / org / apache / cassandra / db / ClusteringComparator . java 
 index b0e8e5c . . 8b01d6f 100644 
 - - - a / src / java / org / apache / cassandra / db / ClusteringComparator . java 
 + + + b / src / java / org / apache / cassandra / db / ClusteringComparator . java 
 @ @ - 162 , 7 + 162 , 7 @ @ public class ClusteringComparator implements Comparator < Clusterable > 
 if ( s1 = = s2 ) 
 return ClusteringPrefix . Kind . compare ( c1 . kind ( ) , c2 . kind ( ) ) ; 
 
 - return s1 < s2 ? c1 . kind ( ) . prefixComparisonResult : - c2 . kind ( ) . prefixComparisonResult ; 
 + return s1 < s2 ? c1 . kind ( ) . comparedToClustering : - c2 . kind ( ) . comparedToClustering ; 
 } 
 
 public int compare ( Clustering c1 , Clustering c2 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ClusteringPrefix . java b / src / java / org / apache / cassandra / db / ClusteringPrefix . java 
 index 36d91e7 . . 3bc7ff8 100644 
 - - - a / src / java / org / apache / cassandra / db / ClusteringPrefix . java 
 + + + b / src / java / org / apache / cassandra / db / ClusteringPrefix . java 
 @ @ - 56 , 26 + 56 , 27 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab 
 { 
 / / WARNING : the ordering of that enum matters because we use ordinal ( ) in the serialization 
 
 - EXCL _ END _ BOUND ( 0 , - 1 ) , 
 - INCL _ START _ BOUND ( 1 , - 1 ) , 
 - EXCL _ END _ INCL _ START _ BOUNDARY ( 1 , - 1 ) , 
 - STATIC _ CLUSTERING ( 2 , - 1 ) , 
 - CLUSTERING ( 3 , 0 ) , 
 - INCL _ END _ EXCL _ START _ BOUNDARY ( 4 , - 1 ) , 
 - INCL _ END _ BOUND ( 4 , 1 ) , 
 - EXCL _ START _ BOUND ( 5 , 1 ) ; 
 + EXCL _ END _ BOUND ( 0 , - 1 ) , 
 + INCL _ START _ BOUND ( 0 , - 1 ) , 
 + EXCL _ END _ INCL _ START _ BOUNDARY ( 0 , - 1 ) , 
 + STATIC _ CLUSTERING ( 1 , - 1 ) , 
 + CLUSTERING ( 2 , 0 ) , 
 + INCL _ END _ EXCL _ START _ BOUNDARY ( 3 , 1 ) , 
 + INCL _ END _ BOUND ( 3 , 1 ) , 
 + EXCL _ START _ BOUND ( 3 , 1 ) ; 
 
 private final int comparison ; 
 
 - / / If clusterable c1 has this Kind and is a strict prefix of clusterable c2 , then this 
 - / / is the result of compare ( c1 , c2 ) . Basically , this is the same as comparing the kind of c1 to 
 - / / CLUSTERING . 
 - public final int prefixComparisonResult ; 
 + / * * 
 + * Return the comparison of this kind to CLUSTERING . 
 + * For bounds / boundaries , this basically tells us if we sort before or after our clustering values . 
 + * / 
 + public final int comparedToClustering ; 
 
 - private Kind ( int comparison , int prefixComparisonResult ) 
 + private Kind ( int comparison , int comparedToClustering ) 
 { 
 this . comparison = comparison ; 
 - this . prefixComparisonResult = prefixComparisonResult ; 
 + this . comparedToClustering = comparedToClustering ; 
 } 
 
 / * * 
 @ @ - 441 , 7 + 442 , 7 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab 
 for ( int i = 0 ; i < bound . size ( ) ; i + + ) 
 { 
 if ( ! hasComponent ( i ) ) 
 - return nextKind . prefixComparisonResult ; 
 + return nextKind . comparedToClustering ; 
 
 int cmp = comparator . compareComponent ( i , nextValues [ i ] , bound . get ( i ) ) ; 
 if ( cmp ! = 0 ) 
 @ @ - 452 , 7 + 453 , 7 @ @ public interface ClusteringPrefix extends Aliasable < ClusteringPrefix > , IMeasurab 
 return nextKind . compareTo ( bound . kind ( ) ) ; 
 
 / / We know that we ' ll have exited already if nextSize < bound . size 
 - return - bound . kind ( ) . prefixComparisonResult ; 
 + return - bound . kind ( ) . comparedToClustering ; 
 } 
 
 private boolean hasComponent ( int i ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / db / RangeTombstone . java b / src / java / org / apache / cassandra / db / RangeTombstone . java 
 index de21950 . . df60933 100644 
 - - - a / src / java / org / apache / cassandra / db / RangeTombstone . java 
 + + + b / src / java / org / apache / cassandra / db / RangeTombstone . java 
 @ @ - 71 , 6 + 71 , 11 @ @ public class RangeTombstone 
 return deletion ; 
 } 
 
 + public String toString ( ClusteringComparator comparator ) 
 + { 
 + return slice . toString ( comparator ) + " @ " + deletion ; 
 + } 
 + 
 @ Override 
 public boolean equals ( Object other ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / RangeTombstoneList . java b / src / java / org / apache / cassandra / db / RangeTombstoneList . java 
 index c377d10 . . 64f0978 100644 
 - - - a / src / java / org / apache / cassandra / db / RangeTombstoneList . java 
 + + + b / src / java / org / apache / cassandra / db / RangeTombstoneList . java 
 @ @ - 34 , 6 + 34 , 7 @ @ import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . utils . ObjectSizes ; 
 import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 / * * 
 * Data structure holding the range tombstones of a ColumnFamily . 
 @ @ - 163 , 7 + 164 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable 
 int c = comparator . compare ( ends [ size - 1 ] , start ) ; 
 
 / / Fast path if we add in sorted order 
 - if ( c < 0 ) 
 + if ( c < = 0 ) 
 { 
 addInternal ( size , start , end , markedAt , delTime ) ; 
 } 
 @ @ - 171 , 7 + 172 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable 
 { 
 / / Note : insertFrom expect i to be the insertion point in term of interval ends 
 int pos = Arrays . binarySearch ( ends , 0 , size , start , comparator ) ; 
 - insertFrom ( ( pos > = 0 ? pos : - pos - 1 ) , start , end , markedAt , delTime ) ; 
 + insertFrom ( ( pos > = 0 ? pos + 1 : - pos - 1 ) , start , end , markedAt , delTime ) ; 
 } 
 boundaryHeapSize + = start . unsharedHeapSize ( ) + end . unsharedHeapSize ( ) ; 
 } 
 @ @ - 504 , 12 + 505 , 14 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable 
 
 / * 
 * Inserts a new element starting at index i . This method assumes that : 
 - * ends [ i - 1 ] < start < ends [ i ] 
 - * ( note that we cannot have start = = end since both will at least have a different bound " kind " ) 
 + * ends [ i - 1 ] < = start < ends [ i ] 
 + * ( note that start can be equal to ends [ i - 1 ] in the case where we have a boundary , i . e . for instance 
 + * ends [ i - 1 ] is the exclusive end of X and start is the inclusive start of X ) . 
 * 
 * A RangeTombstoneList is a list of range [ s _ 0 , e _ 0 ] . . . [ s _ n , e _ n ] such that : 
 - * - s _ i < = e _ i 
 - * - e _ i < s _ i + 1 
 + * - s _ i is a start bound and e _ i is a end bound 
 + * - s _ i < e _ i 
 + * - e _ i < = s _ i + 1 
 * Basically , range are non overlapping and in order . 
 * / 
 private void insertFrom ( int i , Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) 
 @ @ - 517 , 7 + 520 , 7 @ @ public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurable 
 while ( i < size ) 
 { 
 assert start . isStart ( ) & & end . isEnd ( ) ; 
 - assert i = = 0 | | comparator . compare ( ends [ i - 1 ] , start ) < 0 ; 
 + assert i = = 0 | | comparator . compare ( ends [ i - 1 ] , start ) < = 0 ; 
 assert comparator . compare ( start , ends [ i ] ) < 0 ; 
 
 if ( Slice . isEmpty ( comparator , start , end ) ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 index b5ac19b . . 8b52b0b 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 @ @ - 114 , 6 + 114 , 20 @ @ public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker 
 return deletion ; 
 } 
 
 + public boolean openIsInclusive ( boolean reversed ) 
 + { 
 + if ( ! isOpen ( reversed ) ) 
 + throw new IllegalStateException ( ) ; 
 + return bound . isInclusive ( ) ; 
 + } 
 + 
 + public boolean closeIsInclusive ( boolean reversed ) 
 + { 
 + if ( isOpen ( reversed ) ) 
 + throw new IllegalStateException ( ) ; 
 + return bound . isInclusive ( ) ; 
 + } 
 + 
 public void copyTo ( RangeTombstoneMarker . Writer writer ) 
 { 
 copyBoundTo ( writer ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 index 1140d40 . . f17515d 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 @ @ - 87 , 6 + 87 , 16 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker 
 return reversed ? endDeletion : startDeletion ; 
 } 
 
 + public boolean openIsInclusive ( boolean reversed ) 
 + { 
 + return ( bound . kind ( ) = = ClusteringPrefix . Kind . EXCL _ END _ INCL _ START _ BOUNDARY ) ^ reversed ; 
 + } 
 + 
 + public boolean closeIsInclusive ( boolean reversed ) 
 + { 
 + return ( bound . kind ( ) = = ClusteringPrefix . Kind . INCL _ END _ EXCL _ START _ BOUNDARY ) ^ reversed ; 
 + } 
 + 
 public boolean isOpen ( boolean reversed ) 
 { 
 / / A boundary always open one side 
 @ @ - 99 , 21 + 109 , 9 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker 
 return true ; 
 } 
 
 - public static boolean isBoundary ( ClusteringComparator comparator , Slice . Bound close , Slice . Bound open ) 
 - { 
 - if ( ! comparator . isOnSameClustering ( close , open ) ) 
 - return false ; 
 - 
 - / / If both bound are exclusive , then it ' s not a boundary , otherwise it is one . 
 - / / Note that most code should never call this with 2 inclusive bound : this would mean we had 
 - / / 2 RTs that were overlapping and RangeTombstoneList don ' t create that . However , old 
 - / / code was generating that so supporting this case helps dealing with backward compatibility . 
 - return close . isInclusive ( ) | | open . isInclusive ( ) ; 
 - } 
 - 
 - / / Please note that isBoundary * must * have been called ( and returned true ) before this is called . 
 public static RangeTombstoneBoundaryMarker makeBoundary ( boolean reversed , Slice . Bound close , Slice . Bound open , DeletionTime closeDeletion , DeletionTime openDeletion ) 
 { 
 + assert RangeTombstone . Bound . Kind . compare ( close . kind ( ) , open . kind ( ) ) = = 0 : " Both bound don ' t form a boundary " ; 
 boolean isExclusiveClose = close . isExclusive ( ) | | ( close . isInclusive ( ) & & open . isInclusive ( ) & & openDeletion . supersedes ( closeDeletion ) ) ; 
 return isExclusiveClose 
 ? exclusiveCloseInclusiveOpen ( reversed , close . getRawValues ( ) , closeDeletion , openDeletion ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java 
 index 1a506d5 . . 380e6b0 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneMarker . java 
 @ @ - 41 , 6 + 41 , 8 @ @ public interface RangeTombstoneMarker extends Unfiltered 
 public boolean isClose ( boolean reversed ) ; 
 public DeletionTime openDeletionTime ( boolean reversed ) ; 
 public DeletionTime closeDeletionTime ( boolean reversed ) ; 
 + public boolean openIsInclusive ( boolean reversed ) ; 
 + public boolean closeIsInclusive ( boolean reversed ) ; 
 
 public interface Writer extends Slice . Bound . Writer 
 { 
 @ @ - 121 , 33 + 123 , 6 @ @ public interface RangeTombstoneMarker extends Unfiltered 
 * / 
 public static class Merger 
 { 
 - / / Boundaries sorts like the bound that have their equivalent " inclusive " part and that ' s the main action we 
 - / / care about as far as merging goes . So MergedKind just group those as the same case , and tell us whether 
 - / / we ' re dealing with an open or a close ( based on whether we ' re dealing with reversed iterators or not ) . 
 - / / Really this enum is just a convenience for merging . 
 - private enum MergedKind 
 - { 
 - INCL _ OPEN , EXCL _ CLOSE , EXCL _ OPEN , INCL _ CLOSE ; 
 - 
 - public static MergedKind forBound ( RangeTombstone . Bound bound , boolean reversed ) 
 - { 
 - switch ( bound . kind ( ) ) 
 - { 
 - case INCL _ START _ BOUND : 
 - case EXCL _ END _ INCL _ START _ BOUNDARY : 
 - return reversed ? INCL _ CLOSE : INCL _ OPEN ; 
 - case EXCL _ END _ BOUND : 
 - return reversed ? EXCL _ OPEN : EXCL _ CLOSE ; 
 - case EXCL _ START _ BOUND : 
 - return reversed ? EXCL _ CLOSE : EXCL _ OPEN ; 
 - case INCL _ END _ EXCL _ START _ BOUNDARY : 
 - case INCL _ END _ BOUND : 
 - return reversed ? INCL _ OPEN : INCL _ CLOSE ; 
 - } 
 - throw new AssertionError ( ) ; 
 - } 
 - } 
 - 
 private final CFMetaData metadata ; 
 private final UnfilteredRowIterators . MergeListener listener ; 
 private final DeletionTime partitionDeletion ; 
 @ @ - 202 , 33 + 177 , 29 @ @ public interface RangeTombstoneMarker extends Unfiltered 
 if ( previousDeletionTimeInMerged . equals ( newDeletionTimeInMerged ) ) 
 return null ; 
 
 - ByteBuffer [ ] values = bound . getRawValues ( ) ; 
 + boolean isBeforeClustering = bound . kind ( ) . comparedToClustering < 0 ; 
 + if ( reversed ) 
 + isBeforeClustering = ! isBeforeClustering ; 
 
 + ByteBuffer [ ] values = bound . getRawValues ( ) ; 
 RangeTombstoneMarker merged ; 
 - switch ( MergedKind . forBound ( bound , reversed ) ) 
 + if ( previousDeletionTimeInMerged . isLive ( ) ) 
 + { 
 + merged = isBeforeClustering 
 + ? RangeTombstoneBoundMarker . inclusiveOpen ( reversed , values , newDeletionTimeInMerged ) 
 + : RangeTombstoneBoundMarker . exclusiveOpen ( reversed , values , newDeletionTimeInMerged ) ; 
 + } 
 + else if ( newDeletionTimeInMerged . isLive ( ) ) 
 + { 
 + merged = isBeforeClustering 
 + ? RangeTombstoneBoundMarker . exclusiveClose ( reversed , values , previousDeletionTimeInMerged ) 
 + : RangeTombstoneBoundMarker . inclusiveClose ( reversed , values , previousDeletionTimeInMerged ) ; 
 + } 
 + else 
 { 
 - case INCL _ OPEN : 
 - merged = previousDeletionTimeInMerged . isLive ( ) 
 - ? RangeTombstoneBoundMarker . inclusiveOpen ( reversed , values , newDeletionTimeInMerged ) 
 - : RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; 
 - break ; 
 - case EXCL _ CLOSE : 
 - merged = newDeletionTimeInMerged . isLive ( ) 
 - ? RangeTombstoneBoundMarker . exclusiveClose ( reversed , values , previousDeletionTimeInMerged ) 
 - : RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; 
 - break ; 
 - case EXCL _ OPEN : 
 - merged = previousDeletionTimeInMerged . isLive ( ) 
 - ? RangeTombstoneBoundMarker . exclusiveOpen ( reversed , values , newDeletionTimeInMerged ) 
 - : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; 
 - break ; 
 - case INCL _ CLOSE : 
 - merged = newDeletionTimeInMerged . isLive ( ) 
 - ? RangeTombstoneBoundMarker . inclusiveClose ( reversed , values , previousDeletionTimeInMerged ) 
 - : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; 
 - break ; 
 - default : 
 - throw new AssertionError ( ) ; 
 + merged = isBeforeClustering 
 + ? RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) 
 + : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; 
 } 
 
 if ( listener ! = null ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java b / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java 
 index 51383a2 . . f923329 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RowAndTombstoneMergeIterator . java 
 @ @ - 27 , 7 + 27 , 6 @ @ import org . apache . cassandra . db . * ; 
 
 public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltered > implements PeekingIterator < Unfiltered > 
 { 
 - private final ClusteringComparator clusteringComparator ; 
 private final Comparator < Clusterable > comparator ; 
 private final boolean reversed ; 
 
 @ @ - 42 , 7 + 41 , 6 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere 
 
 public RowAndTombstoneMergeIterator ( ClusteringComparator comparator , boolean reversed ) 
 { 
 - this . clusteringComparator = comparator ; 
 this . comparator = reversed ? comparator . reversed ( ) : comparator ; 
 this . reversed = reversed ; 
 } 
 @ @ - 87 , 7 + 85 , 8 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere 
 { 
 RangeTombstone rt = nextTombstone ; 
 nextTombstone = tombstoneIter . hasNext ( ) ? tombstoneIter . next ( ) : null ; 
 - if ( nextTombstone ! = null & & RangeTombstoneBoundaryMarker . isBoundary ( clusteringComparator , rt . deletedSlice ( ) . close ( reversed ) , nextTombstone . deletedSlice ( ) . open ( reversed ) ) ) 
 + / / An end and a start makes a boundary if they sort similarly 
 + if ( nextTombstone ! = null & & RangeTombstone . Bound . Kind . compare ( rt . deletedSlice ( ) . close ( reversed ) . kind ( ) , nextTombstone . deletedSlice ( ) . open ( reversed ) . kind ( ) ) = = 0 ) 
 { 
 next = RangeTombstoneBoundaryMarker . makeBoundary ( reversed , 
 rt . deletedSlice ( ) . close ( reversed ) , 
 @ @ - 113 , 7 + 112 , 7 @ @ public class RowAndTombstoneMergeIterator extends UnmodifiableIterator < Unfiltere 
 { 
 RangeTombstone rt = nextTombstone ; 
 nextTombstone = tombstoneIter . hasNext ( ) ? tombstoneIter . next ( ) : null ; 
 - if ( nextTombstone ! = null & & RangeTombstoneBoundaryMarker . isBoundary ( clusteringComparator , rt . deletedSlice ( ) . close ( reversed ) , nextTombstone . deletedSlice ( ) . open ( reversed ) ) ) 
 + if ( nextTombstone ! = null & & RangeTombstone . Bound . Kind . compare ( rt . deletedSlice ( ) . close ( reversed ) . kind ( ) , nextTombstone . deletedSlice ( ) . open ( reversed ) . kind ( ) ) = = 0 ) 
 { 
 next = RangeTombstoneBoundaryMarker . makeBoundary ( reversed , 
 rt . deletedSlice ( ) . close ( reversed ) , 
 diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java 
 index 73b91ea . . 8a697f4 100644 
 - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneListTest . java 
 @ @ - 26 , 12 + 26 , 12 @ @ import static org . junit . Assert . * ; 
 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . db . * ; 
 - import org . apache . cassandra . db . marshal . IntegerType ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 public class RangeTombstoneListTest 
 { 
 - private static final ClusteringComparator cmp = new ClusteringComparator ( IntegerType . instance ) ; 
 + private static final ClusteringComparator cmp = new ClusteringComparator ( Int32Type . instance ) ; 
 
 @ Test 
 public void sortedAdditionTest ( ) 
 @ @ - 263 , 19 + 263 , 35 @ @ public class RangeTombstoneListTest 
 
 int prevStart = - 1 ; 
 int prevEnd = 0 ; 
 + boolean prevStartInclusive = false ; 
 + boolean prevEndInclusive = false ; 
 for ( int i = 0 ; i < size ; i + + ) 
 { 
 int nextStart = prevEnd + rand . nextInt ( maxItDistance ) ; 
 int nextEnd = nextStart + rand . nextInt ( maxItSize ) ; 
 
 - / / We can have an interval [ x , x ] , but not 2 consecutives ones for the same x 
 - if ( nextEnd = = nextStart & & prevEnd = = prevStart & & prevEnd = = nextStart ) 
 - nextEnd + = 1 + rand . nextInt ( maxItDistance ) ; 
 + boolean startInclusive = rand . nextBoolean ( ) ; 
 + boolean endInclusive = rand . nextBoolean ( ) ; 
 
 - l . add ( rt ( nextStart , nextEnd , rand . nextInt ( maxMarkedAt ) ) ) ; 
 + / / Now make sure we create meaningful ranges 
 + 
 + if ( prevEnd = = nextStart ) 
 + startInclusive = ! prevEndInclusive ; 
 + 
 + if ( nextStart = = nextEnd ) 
 + { 
 + if ( startInclusive ) 
 + endInclusive = true ; 
 + else 
 + nextEnd + = 1 ; 
 + } 
 + 
 + l . add ( rt ( nextStart , startInclusive , nextEnd , endInclusive , rand . nextInt ( maxMarkedAt ) ) ) ; 
 
 prevStart = nextStart ; 
 prevEnd = nextEnd ; 
 + prevStartInclusive = startInclusive ; 
 + prevEndInclusive = endInclusive ; 
 } 
 return l ; 
 } 
 @ @ - 339 , 7 + 355 , 7 @ @ public class RangeTombstoneListTest 
 Slice curr = iter . next ( ) . deletedSlice ( ) ; 
 
 assertFalse ( " Invalid empty slice " + curr . toString ( cmp ) , curr . isEmpty ( cmp ) ) ; 
 - assertTrue ( " Slice not in order or overlapping : " + prev . toString ( cmp ) + curr . toString ( cmp ) , cmp . compare ( prev . end ( ) , curr . start ( ) ) < 0 ) ; 
 + assertTrue ( " Slice not in order or overlapping : " + prev . toString ( cmp ) + curr . toString ( cmp ) , cmp . compare ( prev . end ( ) , curr . start ( ) ) < = 0 ) ; 
 } 
 } 
 
 @ @ - 377 , 6 + 393 , 11 @ @ public class RangeTombstoneListTest 
 return rt ( start , end , tstamp , 0 ) ; 
 } 
 
 + private static RangeTombstone rt ( int start , boolean startInclusive , int end , boolean endInclusive , long tstamp ) 
 + { 
 + return new RangeTombstone ( Slice . make ( Slice . Bound . create ( cmp , true , startInclusive , start ) , Slice . Bound . create ( cmp , false , endInclusive , end ) ) , new SimpleDeletionTime ( tstamp , 0 ) ) ; 
 + } 
 + 
 private static RangeTombstone rt ( int start , int end , long tstamp , int delTime ) 
 { 
 return new RangeTombstone ( Slice . make ( Slice . Bound . inclusiveStartOf ( bb ( start ) ) , Slice . Bound . inclusiveEndOf ( bb ( end ) ) ) , new SimpleDeletionTime ( tstamp , delTime ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java b / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java 
 new file mode 100644 
 index 0000000 . . a607dca 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / rows / UnfilteredRowIteratorsMergeTest . java 
 @ @ - 0 , 0 + 1 , 679 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . db . rows ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 + import java . util . function . Function ; 
 + import java . util . regex . Matcher ; 
 + import java . util . regex . Pattern ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import com . google . common . collect . Iterators ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . Slice . Bound ; 
 + import org . apache . cassandra . db . marshal . AsciiType ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . rows . Unfiltered . Kind ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 + 
 + public class UnfilteredRowIteratorsMergeTest 
 + { 
 + static DecoratedKey partitionKey = Util . dk ( " key " ) ; 
 + static DeletionTime partitionLevelDeletion = DeletionTime . LIVE ; 
 + static CFMetaData metadata = CFMetaData . Builder . create ( " UnfilteredRowIteratorsMergeTest " , " Test " ) . 
 + addPartitionKey ( " key " , AsciiType . instance ) . 
 + addClusteringColumn ( " clustering " , Int32Type . instance ) . 
 + addRegularColumn ( " data " , Int32Type . instance ) . 
 + build ( ) ; 
 + static Comparator < Clusterable > comparator = new ClusteringComparator ( Int32Type . instance ) ; 
 + static int nowInSec = FBUtilities . nowInSeconds ( ) ; 
 + 
 + static final int RANGE = 3000 ; 
 + static final int DEL _ RANGE = 100 ; 
 + static final int ITERATORS = 15 ; 
 + static final int ITEMS = 300 ; 
 + 
 + boolean reversed ; 
 + 
 + public UnfilteredRowIteratorsMergeTest ( ) 
 + { 
 + } 
 + 
 + @ Test 
 + public void testTombstoneMerge ( ) 
 + { 
 + testTombstoneMerge ( false , false ) ; 
 + } 
 + 
 + @ Test 
 + public void testTombstoneMergeReversed ( ) 
 + { 
 + testTombstoneMerge ( true , false ) ; 
 + } 
 + 
 + @ Test 
 + public void testTombstoneMergeIterative ( ) 
 + { 
 + testTombstoneMerge ( false , true ) ; 
 + } 
 + 
 + @ Test 
 + public void testTombstoneMergeReversedIterative ( ) 
 + { 
 + testTombstoneMerge ( true , true ) ; 
 + } 
 + 
 + @ Test 
 + public void testDuplicateRangeCase ( ) 
 + { 
 + testForInput ( " 67 < = [ 98 ] [ 98 ] < = 67 " , 
 + " 66 < = [ 11 ] [ 11 ] < 71 " , 
 + " 66 < [ 13 ] [ 13 ] < 67 " ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unused " ) 
 + public void testTombstoneMerge ( boolean reversed , boolean iterations ) 
 + { 
 + for ( int seed = 1 ; seed < = 100 ; + + seed ) 
 + { 
 + this . reversed = reversed ; 
 + if ( ITEMS < = 20 ) 
 + System . out . println ( " \ nSeed " + seed ) ; 
 + 
 + Random r = new Random ( seed ) ; 
 + List < Function < Integer , Integer > > timeGenerators = ImmutableList . of ( 
 + x - > - 1 , 
 + x - > DEL _ RANGE , 
 + x - > r . nextInt ( DEL _ RANGE ) 
 + ) ; 
 + List < List < Unfiltered > > sources = new ArrayList < > ( ITERATORS ) ; 
 + if ( ITEMS < = 20 ) 
 + System . out . println ( " Merging " ) ; 
 + for ( int i = 0 ; i < ITERATORS ; + + i ) 
 + sources . add ( generateSource ( r , timeGenerators . get ( r . nextInt ( timeGenerators . size ( ) ) ) ) ) ; 
 + List < Unfiltered > merged = merge ( sources , iterations ) ; 
 + 
 + if ( ITEMS < = 20 ) 
 + System . out . println ( " results in " ) ; 
 + if ( ITEMS < = 20 ) 
 + dumpList ( merged ) ; 
 + verifyEquivalent ( sources , merged ) ; 
 + verifyValid ( merged ) ; 
 + if ( reversed ) 
 + { 
 + Collections . reverse ( merged ) ; 
 + this . reversed = false ; 
 + verifyValid ( merged ) ; 
 + } 
 + } 
 + } 
 + 
 + private List < Unfiltered > merge ( List < List < Unfiltered > > sources , boolean iterations ) 
 + { 
 + List < UnfilteredRowIterator > us = sources . stream ( ) . map ( l - > new Source ( l . iterator ( ) ) ) . collect ( Collectors . toList ( ) ) ; 
 + List < Unfiltered > merged = new ArrayList < > ( ) ; 
 + Iterators . addAll ( merged , safeIterator ( mergeIterators ( us , iterations ) ) ) ; 
 + return merged ; 
 + } 
 + 
 + public UnfilteredRowIterator mergeIterators ( List < UnfilteredRowIterator > us , boolean iterations ) 
 + { 
 + int now = FBUtilities . nowInSeconds ( ) ; 
 + if ( iterations ) 
 + { 
 + UnfilteredRowIterator mi = us . get ( 0 ) ; 
 + int i ; 
 + for ( i = 1 ; i + 2 < = ITERATORS ; i + = 2 ) 
 + mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) , us . get ( i + 1 ) ) , now ) ; 
 + if ( i + 1 < = ITERATORS ) 
 + mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) ) , now ) ; 
 + return mi ; 
 + } 
 + else 
 + { 
 + return UnfilteredRowIterators . merge ( us , now ) ; 
 + } 
 + } 
 + 
 + @ SuppressWarnings ( " unused " ) 
 + private List < Unfiltered > generateSource ( Random r , Function < Integer , Integer > timeGenerator ) 
 + { 
 + int [ ] positions = new int [ ITEMS + 1 ] ; 
 + for ( int i = 0 ; i < ITEMS ; + + i ) 
 + positions [ i ] = r . nextInt ( RANGE ) ; 
 + positions [ ITEMS ] = RANGE ; 
 + Arrays . sort ( positions ) ; 
 + 
 + List < Unfiltered > content = new ArrayList < > ( ITEMS ) ; 
 + int prev = - 1 ; 
 + for ( int i = 0 ; i < ITEMS ; + + i ) 
 + { 
 + int pos = positions [ i ] ; 
 + int sz = positions [ i + 1 ] - pos ; 
 + if ( sz = = 0 & & pos = = prev ) 
 + / / Filter out more than two of the same position . 
 + continue ; 
 + if ( r . nextBoolean ( ) | | pos = = prev ) 
 + { 
 + int span ; 
 + boolean includesStart ; 
 + boolean includesEnd ; 
 + if ( pos > prev ) 
 + { 
 + span = r . nextInt ( sz + 1 ) ; 
 + includesStart = span > 0 ? r . nextBoolean ( ) : true ; 
 + includesEnd = span > 0 ? r . nextBoolean ( ) : true ; 
 + } 
 + else 
 + { 
 + span = 1 + r . nextInt ( sz ) ; 
 + includesStart = false ; 
 + includesEnd = r . nextBoolean ( ) ; 
 + } 
 + int deltime = r . nextInt ( DEL _ RANGE ) ; 
 + DeletionTime dt = new SimpleDeletionTime ( deltime , deltime ) ; 
 + content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos , true , includesStart ) , dt ) ) ; 
 + content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos + span , false , includesEnd ) , dt ) ) ; 
 + prev = pos + span - ( includesEnd ? 0 : 1 ) ; 
 + } 
 + else 
 + { 
 + content . add ( emptyRowAt ( pos , timeGenerator ) ) ; 
 + prev = pos ; 
 + } 
 + } 
 + 
 + attachBoundaries ( content ) ; 
 + if ( reversed ) 
 + { 
 + Collections . reverse ( content ) ; 
 + } 
 + verifyValid ( content ) ; 
 + if ( ITEMS < = 20 ) 
 + dumpList ( content ) ; 
 + return content ; 
 + } 
 + 
 + static void attachBoundaries ( List < Unfiltered > content ) 
 + { 
 + int di = 0 ; 
 + RangeTombstoneMarker prev = null ; 
 + for ( int si = 0 ; si < content . size ( ) ; + + si ) 
 + { 
 + Unfiltered currUnfiltered = content . get ( si ) ; 
 + RangeTombstoneMarker curr = currUnfiltered . kind ( ) = = Kind . RANGE _ TOMBSTONE _ MARKER ? 
 + ( RangeTombstoneMarker ) currUnfiltered : 
 + null ; 
 + if ( prev ! = null & & curr ! = null & & prev . isClose ( false ) & & curr . isOpen ( false ) & & prev . clustering ( ) . invert ( ) . equals ( curr . clustering ( ) ) ) 
 + { 
 + / / Join . Prefer not to use merger to check its correctness . 
 + RangeTombstone . Bound b = prev . clustering ( ) ; 
 + b = b . withNewKind ( b . isInclusive ( ) ? RangeTombstone . Bound . Kind . INCL _ END _ EXCL _ START _ BOUNDARY : RangeTombstone . Bound . Kind . EXCL _ END _ INCL _ START _ BOUNDARY ) ; 
 + prev = new RangeTombstoneBoundaryMarker ( b , prev . closeDeletionTime ( false ) , curr . openDeletionTime ( false ) ) ; 
 + currUnfiltered = prev ; 
 + - - di ; 
 + } 
 + content . set ( di + + , currUnfiltered ) ; 
 + prev = curr ; 
 + } 
 + for ( int pos = content . size ( ) - 1 ; pos > = di ; - - pos ) 
 + content . remove ( pos ) ; 
 + } 
 + 
 + void verifyValid ( List < Unfiltered > list ) 
 + { 
 + int reversedAsMultiplier = reversed ? - 1 : 1 ; 
 + try { 
 + RangeTombstoneMarker prev = null ; 
 + Unfiltered prevUnfiltered = null ; 
 + for ( Unfiltered unfiltered : list ) 
 + { 
 + Assert . assertTrue ( " Order violation prev " + str ( prevUnfiltered ) + " curr " + str ( unfiltered ) , 
 + prevUnfiltered = = null | | comparator . compare ( prevUnfiltered , unfiltered ) * reversedAsMultiplier < 0 ) ; 
 + prevUnfiltered = unfiltered ; 
 + 
 + if ( unfiltered . kind ( ) = = Kind . RANGE _ TOMBSTONE _ MARKER ) 
 + { 
 + RangeTombstoneMarker curr = ( RangeTombstoneMarker ) unfiltered ; 
 + if ( prev ! = null ) 
 + { 
 + if ( curr . isClose ( reversed ) ) 
 + { 
 + Assert . assertTrue ( str ( unfiltered ) + " follows another close marker " + str ( prev ) , prev . isOpen ( reversed ) ) ; 
 + Assert . assertEquals ( " Deletion time mismatch for open " + str ( prev ) + " and close " + str ( unfiltered ) , 
 + prev . openDeletionTime ( reversed ) , 
 + curr . closeDeletionTime ( reversed ) ) ; 
 + } 
 + else 
 + Assert . assertFalse ( str ( curr ) + " follows another open marker " + str ( prev ) , prev . isOpen ( reversed ) ) ; 
 + } 
 + 
 + prev = curr ; 
 + } 
 + } 
 + Assert . assertFalse ( " Cannot end in open marker " + str ( prev ) , prev ! = null & & prev . isOpen ( reversed ) ) ; 
 + 
 + } catch ( AssertionError e ) { 
 + System . out . println ( e ) ; 
 + dumpList ( list ) ; 
 + throw e ; 
 + } 
 + } 
 + 
 + void verifyEquivalent ( List < List < Unfiltered > > sources , List < Unfiltered > merged ) 
 + { 
 + try 
 + { 
 + for ( int i = 0 ; i < RANGE ; + + i ) 
 + { 
 + Clusterable c = clusteringFor ( i ) ; 
 + DeletionTime dt = DeletionTime . LIVE ; 
 + for ( List < Unfiltered > source : sources ) 
 + { 
 + dt = deletionFor ( c , source , dt ) ; 
 + } 
 + Assert . assertEquals ( " Deletion time mismatch for position " + str ( c ) , dt , deletionFor ( c , merged ) ) ; 
 + if ( dt = = DeletionTime . LIVE ) 
 + { 
 + Optional < Unfiltered > sourceOpt = sources . stream ( ) . map ( source - > rowFor ( c , source ) ) . filter ( x - > x ! = null ) . findAny ( ) ; 
 + Unfiltered mergedRow = rowFor ( c , merged ) ; 
 + Assert . assertEquals ( " Content mismatch for position " + str ( c ) , str ( sourceOpt . orElse ( null ) ) , str ( mergedRow ) ) ; 
 + } 
 + } 
 + } 
 + catch ( AssertionError e ) 
 + { 
 + System . out . println ( e ) ; 
 + for ( List < Unfiltered > list : sources ) 
 + dumpList ( list ) ; 
 + System . out . println ( " merged " ) ; 
 + dumpList ( merged ) ; 
 + throw e ; 
 + } 
 + } 
 + 
 + private Unfiltered rowFor ( Clusterable pointer , List < Unfiltered > list ) 
 + { 
 + int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; 
 + return index > = 0 ? list . get ( index ) : null ; 
 + } 
 + 
 + DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list ) 
 + { 
 + return deletionFor ( pointer , list , DeletionTime . LIVE ) ; 
 + } 
 + 
 + DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list , DeletionTime def ) 
 + { 
 + if ( list . isEmpty ( ) ) 
 + return def ; 
 + 
 + int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; 
 + if ( index < 0 ) 
 + index = - 1 - index ; 
 + else 
 + { 
 + Row row = ( Row ) list . get ( index ) ; 
 + if ( row . deletion ( ) ! = null & & row . deletion ( ) . supersedes ( def ) ) 
 + def = row . deletion ( ) ; 
 + } 
 + 
 + if ( index > = list . size ( ) ) 
 + return def ; 
 + 
 + while ( - - index > = 0 ) 
 + { 
 + Unfiltered unfiltered = list . get ( index ) ; 
 + if ( unfiltered . kind ( ) = = Kind . ROW ) 
 + continue ; 
 + RangeTombstoneMarker lower = ( RangeTombstoneMarker ) unfiltered ; 
 + if ( ! lower . isOpen ( reversed ) ) 
 + return def ; 
 + return lower . openDeletionTime ( reversed ) . supersedes ( def ) ? lower . openDeletionTime ( reversed ) : def ; 
 + } 
 + return def ; 
 + } 
 + 
 + private static Bound boundFor ( int pos , boolean start , boolean inclusive ) 
 + { 
 + return Bound . create ( Bound . boundKind ( start , inclusive ) , new ByteBuffer [ ] { Int32Type . instance . decompose ( pos ) } ) ; 
 + } 
 + 
 + private static SimpleClustering clusteringFor ( int i ) 
 + { 
 + return new SimpleClustering ( Int32Type . instance . decompose ( i ) ) ; 
 + } 
 + 
 + static Row emptyRowAt ( int pos , Function < Integer , Integer > timeGenerator ) 
 + { 
 + final Clustering clustering = clusteringFor ( pos ) ; 
 + final LivenessInfo live = SimpleLivenessInfo . forUpdate ( timeGenerator . apply ( pos ) , 0 , nowInSec , metadata ) ; 
 + return emptyRowAt ( clustering , live , DeletionTime . LIVE ) ; 
 + } 
 + 
 + public static class TestCell extends AbstractCell 
 + { 
 + private final ColumnDefinition column ; 
 + private final ByteBuffer value ; 
 + private final LivenessInfo info ; 
 + 
 + public TestCell ( ColumnDefinition column , ByteBuffer value , LivenessInfo info ) 
 + { 
 + this . column = column ; 
 + this . value = value ; 
 + this . info = info . takeAlias ( ) ; 
 + } 
 + 
 + @ Override 
 + public ColumnDefinition column ( ) 
 + { 
 + return column ; 
 + } 
 + 
 + @ Override 
 + public boolean isCounterCell ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public ByteBuffer value ( ) 
 + { 
 + return value ; 
 + } 
 + 
 + @ Override 
 + public LivenessInfo livenessInfo ( ) 
 + { 
 + return info ; 
 + } 
 + 
 + @ Override 
 + public CellPath path ( ) 
 + { 
 + return null ; 
 + } 
 + } 
 + 
 + static Row emptyRowAt ( final Clustering clustering , final LivenessInfo live , final DeletionTime deletion ) 
 + { 
 + final ColumnDefinition columnDef = metadata . getColumnDefinition ( new ColumnIdentifier ( " data " , true ) ) ; 
 + final Cell cell = new TestCell ( columnDef , clustering . get ( 0 ) , live ) ; 
 + 
 + return new AbstractRow ( ) 
 + { 
 + @ Override 
 + public Columns columns ( ) 
 + { 
 + return Columns . of ( columnDef ) ; 
 + } 
 + 
 + @ Override 
 + public LivenessInfo primaryKeyLivenessInfo ( ) 
 + { 
 + return live ; 
 + } 
 + 
 + @ Override 
 + public DeletionTime deletion ( ) 
 + { 
 + return deletion ; 
 + } 
 + 
 + @ Override 
 + public boolean isEmpty ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public boolean hasComplexDeletion ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public Clustering clustering ( ) 
 + { 
 + return clustering ; 
 + } 
 + 
 + @ Override 
 + public Cell getCell ( ColumnDefinition c ) 
 + { 
 + return c = = columnDef ? cell : null ; 
 + } 
 + 
 + @ Override 
 + public Cell getCell ( ColumnDefinition c , CellPath path ) 
 + { 
 + return null ; 
 + } 
 + 
 + @ Override 
 + public Iterator < Cell > getCells ( ColumnDefinition c ) 
 + { 
 + return Iterators . singletonIterator ( cell ) ; 
 + } 
 + 
 + @ Override 
 + public DeletionTime getDeletion ( ColumnDefinition c ) 
 + { 
 + return DeletionTime . LIVE ; 
 + } 
 + 
 + @ Override 
 + public Iterator < Cell > iterator ( ) 
 + { 
 + return Iterators . < Cell > emptyIterator ( ) ; 
 + } 
 + 
 + @ Override 
 + public SearchIterator < ColumnDefinition , ColumnData > searchIterator ( ) 
 + { 
 + return new SearchIterator < ColumnDefinition , ColumnData > ( ) 
 + { 
 + @ Override 
 + public boolean hasNext ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + @ Override 
 + public ColumnData next ( ColumnDefinition column ) 
 + { 
 + return null ; 
 + } 
 + } ; 
 + } 
 + 
 + @ Override 
 + public Kind kind ( ) 
 + { 
 + return Unfiltered . Kind . ROW ; 
 + } 
 + 
 + @ Override 
 + public Row takeAlias ( ) 
 + { 
 + return this ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return Int32Type . instance . getString ( clustering . get ( 0 ) ) ; 
 + } 
 + } ; 
 + 
 + } 
 + 
 + private void dumpList ( List < Unfiltered > list ) 
 + { 
 + for ( Unfiltered u : list ) 
 + System . out . print ( str ( u ) + " " ) ; 
 + System . out . println ( ) ; 
 + } 
 + 
 + private String str ( Clusterable curr ) 
 + { 
 + if ( curr = = null ) 
 + return " null " ; 
 + String val = Int32Type . instance . getString ( curr . clustering ( ) . get ( 0 ) ) ; 
 + if ( curr instanceof RangeTombstoneMarker ) 
 + { 
 + RangeTombstoneMarker marker = ( RangeTombstoneMarker ) curr ; 
 + if ( marker . isClose ( reversed ) ) 
 + val = " [ " + marker . closeDeletionTime ( reversed ) . markedForDeleteAt ( ) + " ] " + ( marker . closeIsInclusive ( reversed ) ? " < = " : " < " ) + val ; 
 + if ( marker . isOpen ( reversed ) ) 
 + val = val + ( marker . openIsInclusive ( reversed ) ? " < = " : " < " ) + " [ " + marker . openDeletionTime ( reversed ) . markedForDeleteAt ( ) + " ] " ; 
 + } 
 + return val ; 
 + } 
 + 
 + class Source extends AbstractUnfilteredRowIterator implements UnfilteredRowIterator 
 + { 
 + Iterator < Unfiltered > content ; 
 + 
 + protected Source ( Iterator < Unfiltered > content ) 
 + { 
 + super ( UnfilteredRowIteratorsMergeTest . metadata , 
 + UnfilteredRowIteratorsMergeTest . partitionKey , 
 + UnfilteredRowIteratorsMergeTest . partitionLevelDeletion , 
 + UnfilteredRowIteratorsMergeTest . metadata . partitionColumns ( ) , 
 + null , 
 + reversed , 
 + RowStats . NO _ STATS ) ; 
 + this . content = content ; 
 + } 
 + 
 + @ Override 
 + protected Unfiltered computeNext ( ) 
 + { 
 + return content . hasNext ( ) ? content . next ( ) : endOfData ( ) ; 
 + } 
 + } 
 + 
 + static RangeTombstoneMarker safeMarker ( RangeTombstoneMarker marker ) 
 + { 
 + RangeTombstoneMarker . Builder writer = new RangeTombstoneMarker . Builder ( 1 ) ; 
 + marker . copyTo ( writer ) ; 
 + return writer . build ( ) ; 
 + } 
 + 
 + private static Row safeRow ( Row row ) 
 + { 
 + return emptyRowAt ( new SimpleClustering ( row . clustering ( ) . get ( 0 ) ) , row . primaryKeyLivenessInfo ( ) , row . deletion ( ) ) ; 
 + } 
 + 
 + public static UnfilteredRowIterator safeIterator ( UnfilteredRowIterator iterator ) 
 + { 
 + return new WrappingUnfilteredRowIterator ( iterator ) 
 + { 
 + @ Override 
 + public Unfiltered next ( ) 
 + { 
 + Unfiltered next = super . next ( ) ; 
 + return next . kind ( ) = = Unfiltered . Kind . ROW 
 + ? safeRow ( ( Row ) next ) 
 + : safeMarker ( ( RangeTombstoneMarker ) next ) ; 
 + } 
 + } ; 
 + } 
 + 
 + public void testForInput ( String . . . inputs ) 
 + { 
 + List < List < Unfiltered > > sources = new ArrayList < > ( ) ; 
 + for ( String input : inputs ) 
 + { 
 + List < Unfiltered > source = parse ( input ) ; 
 + attachBoundaries ( source ) ; 
 + dumpList ( source ) ; 
 + verifyValid ( source ) ; 
 + sources . add ( source ) ; 
 + } 
 + 
 + List < Unfiltered > merged = merge ( sources , false ) ; 
 + System . out . println ( " Merge to : " ) ; 
 + dumpList ( merged ) ; 
 + verifyEquivalent ( sources , merged ) ; 
 + verifyValid ( merged ) ; 
 + System . out . println ( ) ; 
 + } 
 + 
 + List < Unfiltered > parse ( String input ) 
 + { 
 + String [ ] split = input . split ( " " ) ; 
 + Pattern open = Pattern . compile ( " ( \ \ d + ) < ( = ) ? \ \ [ ( \ \ d + ) \ \ ] " ) ; 
 + Pattern close = Pattern . compile ( " \ \ [ ( \ \ d + ) \ \ ] < ( = ) ? ( \ \ d + ) " ) ; 
 + Pattern row = Pattern . compile ( " ( \ \ d + ) ( \ \ [ ( \ \ d + ) \ \ ] ) ? " ) ; 
 + List < Unfiltered > out = new ArrayList < > ( split . length ) ; 
 + for ( String s : split ) 
 + { 
 + Matcher m = open . matcher ( s ) ; 
 + if ( m . matches ( ) ) 
 + { 
 + out . add ( openMarker ( Integer . parseInt ( m . group ( 1 ) ) , Integer . parseInt ( m . group ( 3 ) ) , m . group ( 2 ) ! = null ) ) ; 
 + continue ; 
 + } 
 + m = close . matcher ( s ) ; 
 + if ( m . matches ( ) ) 
 + { 
 + out . add ( closeMarker ( Integer . parseInt ( m . group ( 3 ) ) , Integer . parseInt ( m . group ( 1 ) ) , m . group ( 2 ) ! = null ) ) ; 
 + continue ; 
 + } 
 + m = row . matcher ( s ) ; 
 + if ( m . matches ( ) ) 
 + { 
 + int live = m . group ( 3 ) ! = null ? Integer . parseInt ( m . group ( 3 ) ) : DEL _ RANGE ; 
 + out . add ( emptyRowAt ( Integer . parseInt ( m . group ( 1 ) ) , x - > live ) ) ; 
 + continue ; 
 + } 
 + Assert . fail ( " Can ' t parse " + s ) ; 
 + } 
 + return out ; 
 + } 
 + 
 + private RangeTombstoneMarker openMarker ( int pos , int delTime , boolean inclusive ) 
 + { 
 + return marker ( pos , delTime , true , inclusive ) ; 
 + } 
 + 
 + private RangeTombstoneMarker closeMarker ( int pos , int delTime , boolean inclusive ) 
 + { 
 + return marker ( pos , delTime , false , inclusive ) ; 
 + } 
 + 
 + private RangeTombstoneMarker marker ( int pos , int delTime , boolean isStart , boolean inclusive ) 
 + { 
 + return new RangeTombstoneBoundMarker ( Bound . create ( Bound . boundKind ( isStart , inclusive ) , 
 + new ByteBuffer [ ] { clusteringFor ( pos ) . get ( 0 ) } ) , 
 + new SimpleDeletionTime ( delTime , delTime ) ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e48fbfd . . f598aa2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * fix error when using ORDER BY with extended selections ( CASSANDRA - 4689 ) 
 * ( CQL3 ) Fix validation for IN queries for non - PK cols ( CASSANDRA - 4709 ) 
 * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) 
 + * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) 
 Merged from 1 . 0 : 
 * Switch from NBHM to CHM in MessagingService ' s callback map , which 
 prevents OOM in long - running instances ( CASSANDRA - 4708 ) 
 diff - - git a / src / java / org / apache / cassandra / cli / CliClient . java b / src / java / org / apache / cassandra / cli / CliClient . java 
 index d0fb543 . . b32b0f7 100644 
 - - - a / src / java / org / apache / cassandra / cli / CliClient . java 
 + + + b / src / java / org / apache / cassandra / cli / CliClient . java 
 @ @ - 461 , 7 + 461 , 7 @ @ public class CliClient 
 throws InvalidRequestException , UnavailableException , TimedOutException , TException , IllegalAccessException , NotFoundException , InstantiationException , NoSuchFieldException 
 { 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 ColumnParent parent = new ColumnParent ( columnFamily ) ; 
 if ( superColumnName ! = null ) 
 parent . setSuper _ column ( superColumnName ) ; 
 @ @ - 565 , 7 + 565 , 7 @ @ public class CliClient 
 { 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 Tree columnFamilySpec = statement . getChild ( 0 ) ; 
 String columnFamily = CliCompiler . getColumnFamily ( columnFamilySpec , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 ByteBuffer key = getKeyAsBytes ( columnFamily , columnFamilySpec . getChild ( 1 ) ) ; 
 @ @ - 734 , 7 + 734 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 
 IndexClause clause = new IndexClause ( ) ; 
 String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 @ @ - 828 , 7 + 828 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 / / ^ ( NODE _ COLUMN _ ACCESS < cf > < key > < column > ) 
 Tree columnFamilySpec = statement . getChild ( 0 ) ; 
 Tree keyTree = columnFamilySpec . getChild ( 1 ) ; / / could be a function or regular text 
 @ @ - 1323 , 7 + 1323 , 7 @ @ public class CliClient 
 if ( ! CliMain . isConnected ( ) | | ! hasKeySpace ( ) ) 
 return ; 
 
 - long startTime = System . currentTimeMillis ( ) ; 
 + long startTime = System . nanoTime ( ) ; 
 
 / / extract column family 
 String columnFamily = CliCompiler . getColumnFamily ( statement , keyspacesMap . get ( keySpace ) . cf _ defs ) ; 
 @ @ - 2968 , 9 + 2968 , 25 @ @ public class CliClient 
 return false ; 
 } 
 
 + / * * 
 + * Print elapsed time . Print 2 fraction digits if eta is under 10 ms . 
 + * @ param startTime starting time in nanoseconds 
 + * / 
 private void elapsedTime ( long startTime ) 
 { 
 - sessionState . out . println ( " Elapsed time : " + ( System . currentTimeMillis ( ) - startTime ) + " msec ( s ) . " ) ; 
 + / * * time elapsed in nanoseconds * / 
 + long eta = System . nanoTime ( ) - startTime ; 
 + 
 + sessionState . out . print ( " Elapsed time : " ) ; 
 + if ( eta < 10000000 ) 
 + { 
 + sessionState . out . print ( Math . round ( eta / 10000 . 0 ) / 100 . 0 ) ; 
 + } 
 + else 
 + { 
 + sessionState . out . print ( Math . round ( eta / 1000000 . 0 ) ) ; 
 + } 
 + sessionState . out . println ( " msec ( s ) . " ) ; 
 } 
 
 class CfAssumptions
