BLEU SCORE: 1.0

TEST MSG: Fix schema concurrency exceptions
GENERATED MSG: Fix schema concurrency exceptions

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2b8dea8 . . 4c4be3b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 7 <nl> + * Fix schema concurrency exceptions ( CASSANDRA - 6841 ) <nl> * Fix leaking validator FH in StreamWriter ( CASSANDRA - 6832 ) <nl> * Fix saving triggers to schema ( CASSANDRA - 6789 ) <nl> * Fix trigger mutations when base mutation list is immutable ( CASSANDRA - 6790 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java <nl> index d822704 . . 0907177 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Schema . java <nl> + + + b / src / java / org / apache / cassandra / config / Schema . java <nl> @ @ - 23 , 7 + 23 , 9 @ @ import java . security . MessageDigest ; <nl> import java . security . NoSuchAlgorithmException ; <nl> import java . util . * ; <nl> <nl> - import com . google . common . collect . * ; <nl> + import com . google . common . collect . ImmutableList ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> + import com . google . common . collect . Sets ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 32 , 7 + 34 , 7 @ @ import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . service . MigrationManager ; <nl> - import org . apache . cassandra . tracing . Tracing ; <nl> + import org . apache . cassandra . utils . ConcurrentBiMap ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . Pair ; <nl> import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> @ @ - 58 , 7 + 60 , 7 @ @ public class Schema <nl> private final Map < String , Keyspace > keyspaceInstances = new NonBlockingHashMap < String , Keyspace > ( ) ; <nl> <nl> / * metadata map for faster ColumnFamily lookup * / <nl> - private final BiMap < Pair < String , String > , UUID > cfIdMap = HashBiMap . create ( ) ; <nl> + private final ConcurrentBiMap < Pair < String , String > , UUID > cfIdMap = new ConcurrentBiMap < > ( ) ; <nl> <nl> private volatile UUID version ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> index 575e3c3 . . 3009a63 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> @ @ - 304 , 7 + 304 , 7 @ @ public class CommitLogAllocator <nl> { <nl> CommitLogSegment oldestSegment = activeSegments . peek ( ) ; <nl> <nl> - if ( oldestSegment ! = null ) <nl> + if ( oldestSegment ! = null & & oldestSegment ! = CommitLog . instance . activeSegment ) <nl> { <nl> for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index 25658ed . . 5b8bcfa 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 25 , 10 + 25 , 13 @ @ import java . io . RandomAccessFile ; <nl> import java . nio . ByteBuffer ; <nl> import java . nio . MappedByteBuffer ; <nl> import java . nio . channels . FileChannel ; <nl> + import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . Comparator ; <nl> import java . util . HashMap ; <nl> + import java . util . Map ; <nl> import java . util . UUID ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . zip . Checksum ; <nl> <nl> @ @ - 63 , 7 + 66 , 7 @ @ public class CommitLogSegment <nl> static final int ENTRY _ OVERHEAD _ SIZE = 4 + 8 + 8 ; <nl> <nl> / / cache which cf is dirty in this segment to avoid having to lookup all ReplayPositions to decide if we can delete this segment <nl> - private final HashMap < UUID , Integer > cfLastWrite = new HashMap < UUID , Integer > ( ) ; <nl> + private final Map < UUID , Integer > cfLastWrite = new HashMap < > ( ) ; <nl> <nl> public final long id ; <nl> <nl> @ @ - 355 , 7 + 358 , 7 @ @ public class CommitLogSegment <nl> * @ param cfId the column family ID that is now clean <nl> * @ param context the optional clean offset <nl> * / <nl> - public void markClean ( UUID cfId , ReplayPosition context ) <nl> + public synchronized void markClean ( UUID cfId , ReplayPosition context ) <nl> { <nl> Integer lastWritten = cfLastWrite . get ( cfId ) ; <nl> <nl> @ @ - 368 , 15 + 371 , 15 @ @ public class CommitLogSegment <nl> / * * <nl> * @ return a collection of dirty CFIDs for this segment file . <nl> * / <nl> - public Collection < UUID > getDirtyCFIDs ( ) <nl> + public synchronized Collection < UUID > getDirtyCFIDs ( ) <nl> { <nl> - return cfLastWrite . keySet ( ) ; <nl> + return new ArrayList < > ( cfLastWrite . keySet ( ) ) ; <nl> } <nl> <nl> / * * <nl> * @ return true if this segment is unused and safe to recycle or delete <nl> * / <nl> - public boolean isUnused ( ) <nl> + public synchronized boolean isUnused ( ) <nl> { <nl> return cfLastWrite . isEmpty ( ) ; <nl> } <nl> @ @ - 396 , 7 + 399 , 7 @ @ public class CommitLogSegment <nl> public String dirtyString ( ) <nl> { <nl> StringBuilder sb = new StringBuilder ( ) ; <nl> - for ( UUID cfId : cfLastWrite . keySet ( ) ) <nl> + for ( UUID cfId : getDirtyCFIDs ( ) ) <nl> { <nl> CFMetaData m = Schema . instance . getCFMetaData ( cfId ) ; <nl> sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) . append ( " ) , " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java b / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java <nl> new file mode 100644 <nl> index 0000000 . . b4dfa2e <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java <nl> @ @ - 0 , 0 + 1 , 131 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . Collection ; <nl> + import java . util . Collections ; <nl> + import java . util . Map ; <nl> + import java . util . Objects ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + <nl> + / * * <nl> + * <nl> + * A variant of BiMap that permits concurrent access , and expects uniqueness of values in both domain and range . <nl> + * We synchronize on _ modifications only _ , and use ConcurrentHashMap so that readers can lookup safely . This does mean there <nl> + * could be races to lookup the inverse , but we aren ' t too worried about that . <nl> + * <nl> + * @ param < K > <nl> + * @ param < V > <nl> + * / <nl> + public class ConcurrentBiMap < K , V > implements Map < K , V > <nl> + { <nl> + protected final Map < K , V > forwardMap ; <nl> + protected final Map < V , K > reverseMap ; <nl> + <nl> + public ConcurrentBiMap ( ) <nl> + { <nl> + this ( new ConcurrentHashMap < K , V > ( 16 , 0 . 5f , 1 ) , new ConcurrentHashMap < V , K > ( 16 , 0 . 5f , 1 ) ) ; <nl> + } <nl> + <nl> + protected ConcurrentBiMap ( Map < K , V > forwardMap , Map < V , K > reverseMap ) <nl> + { <nl> + this . forwardMap = forwardMap ; <nl> + this . reverseMap = reverseMap ; <nl> + } <nl> + <nl> + public Map < V , K > inverse ( ) <nl> + { <nl> + return Collections . unmodifiableMap ( reverseMap ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + forwardMap . clear ( ) ; <nl> + reverseMap . clear ( ) ; <nl> + } <nl> + <nl> + public boolean containsKey ( Object key ) <nl> + { <nl> + return forwardMap . containsKey ( key ) ; <nl> + } <nl> + <nl> + public boolean containsValue ( Object value ) <nl> + { <nl> + return reverseMap . containsKey ( value ) ; <nl> + } <nl> + <nl> + public Set < Entry < K , V > > entrySet ( ) <nl> + { <nl> + return forwardMap . entrySet ( ) ; <nl> + } <nl> + <nl> + public V get ( Object key ) <nl> + { <nl> + return forwardMap . get ( key ) ; <nl> + } <nl> + <nl> + public boolean isEmpty ( ) <nl> + { <nl> + return forwardMap . isEmpty ( ) ; <nl> + } <nl> + <nl> + public Set < K > keySet ( ) <nl> + { <nl> + return forwardMap . keySet ( ) ; <nl> + } <nl> + <nl> + public synchronized V put ( K key , V value ) <nl> + { <nl> + K oldKey = reverseMap . get ( value ) ; <nl> + if ( oldKey ! = null & & ! key . equals ( oldKey ) ) <nl> + throw new IllegalArgumentException ( value + " is already bound in reverseMap to " + oldKey ) ; <nl> + V oldVal = forwardMap . put ( key , value ) ; <nl> + if ( oldVal ! = null & & ! Objects . equals ( reverseMap . remove ( oldVal ) , key ) ) <nl> + throw new IllegalStateException ( ) ; / / for the prior mapping to be correct , we MUST get back the key from the reverseMap <nl> + reverseMap . put ( value , key ) ; <nl> + return oldVal ; <nl> + } <nl> + <nl> + public synchronized void putAll ( Map < ? extends K , ? extends V > m ) <nl> + { <nl> + for ( Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) <nl> + put ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + } <nl> + <nl> + public synchronized V remove ( Object key ) <nl> + { <nl> + V oldVal = forwardMap . remove ( key ) ; <nl> + if ( oldVal = = null ) <nl> + return null ; <nl> + Object oldKey = reverseMap . remove ( oldVal ) ; <nl> + if ( oldKey = = null | | ! oldKey . equals ( key ) ) <nl> + throw new IllegalStateException ( ) ; / / for the prior mapping to be correct , we MUST get back the key from the reverseMap <nl> + return oldVal ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return forwardMap . size ( ) ; <nl> + } <nl> + <nl> + public Collection < V > values ( ) <nl> + { <nl> + return reverseMap . keySet ( ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2b8dea8 . . 4c4be3b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 7 
 + * Fix schema concurrency exceptions ( CASSANDRA - 6841 ) 
 * Fix leaking validator FH in StreamWriter ( CASSANDRA - 6832 ) 
 * Fix saving triggers to schema ( CASSANDRA - 6789 ) 
 * Fix trigger mutations when base mutation list is immutable ( CASSANDRA - 6790 ) 
 diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java 
 index d822704 . . 0907177 100644 
 - - - a / src / java / org / apache / cassandra / config / Schema . java 
 + + + b / src / java / org / apache / cassandra / config / Schema . java 
 @ @ - 23 , 7 + 23 , 9 @ @ import java . security . MessageDigest ; 
 import java . security . NoSuchAlgorithmException ; 
 import java . util . * ; 
 
 - import com . google . common . collect . * ; 
 + import com . google . common . collect . ImmutableList ; 
 + import com . google . common . collect . ImmutableSet ; 
 + import com . google . common . collect . Sets ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 32 , 7 + 34 , 7 @ @ import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . service . MigrationManager ; 
 - import org . apache . cassandra . tracing . Tracing ; 
 + import org . apache . cassandra . utils . ConcurrentBiMap ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . Pair ; 
 import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 @ @ - 58 , 7 + 60 , 7 @ @ public class Schema 
 private final Map < String , Keyspace > keyspaceInstances = new NonBlockingHashMap < String , Keyspace > ( ) ; 
 
 / * metadata map for faster ColumnFamily lookup * / 
 - private final BiMap < Pair < String , String > , UUID > cfIdMap = HashBiMap . create ( ) ; 
 + private final ConcurrentBiMap < Pair < String , String > , UUID > cfIdMap = new ConcurrentBiMap < > ( ) ; 
 
 private volatile UUID version ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 index 575e3c3 . . 3009a63 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 @ @ - 304 , 7 + 304 , 7 @ @ public class CommitLogAllocator 
 { 
 CommitLogSegment oldestSegment = activeSegments . peek ( ) ; 
 
 - if ( oldestSegment ! = null ) 
 + if ( oldestSegment ! = null & & oldestSegment ! = CommitLog . instance . activeSegment ) 
 { 
 for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index 25658ed . . 5b8bcfa 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 25 , 10 + 25 , 13 @ @ import java . io . RandomAccessFile ; 
 import java . nio . ByteBuffer ; 
 import java . nio . MappedByteBuffer ; 
 import java . nio . channels . FileChannel ; 
 + import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . Comparator ; 
 import java . util . HashMap ; 
 + import java . util . Map ; 
 import java . util . UUID ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . zip . Checksum ; 
 
 @ @ - 63 , 7 + 66 , 7 @ @ public class CommitLogSegment 
 static final int ENTRY _ OVERHEAD _ SIZE = 4 + 8 + 8 ; 
 
 / / cache which cf is dirty in this segment to avoid having to lookup all ReplayPositions to decide if we can delete this segment 
 - private final HashMap < UUID , Integer > cfLastWrite = new HashMap < UUID , Integer > ( ) ; 
 + private final Map < UUID , Integer > cfLastWrite = new HashMap < > ( ) ; 
 
 public final long id ; 
 
 @ @ - 355 , 7 + 358 , 7 @ @ public class CommitLogSegment 
 * @ param cfId the column family ID that is now clean 
 * @ param context the optional clean offset 
 * / 
 - public void markClean ( UUID cfId , ReplayPosition context ) 
 + public synchronized void markClean ( UUID cfId , ReplayPosition context ) 
 { 
 Integer lastWritten = cfLastWrite . get ( cfId ) ; 
 
 @ @ - 368 , 15 + 371 , 15 @ @ public class CommitLogSegment 
 / * * 
 * @ return a collection of dirty CFIDs for this segment file . 
 * / 
 - public Collection < UUID > getDirtyCFIDs ( ) 
 + public synchronized Collection < UUID > getDirtyCFIDs ( ) 
 { 
 - return cfLastWrite . keySet ( ) ; 
 + return new ArrayList < > ( cfLastWrite . keySet ( ) ) ; 
 } 
 
 / * * 
 * @ return true if this segment is unused and safe to recycle or delete 
 * / 
 - public boolean isUnused ( ) 
 + public synchronized boolean isUnused ( ) 
 { 
 return cfLastWrite . isEmpty ( ) ; 
 } 
 @ @ - 396 , 7 + 399 , 7 @ @ public class CommitLogSegment 
 public String dirtyString ( ) 
 { 
 StringBuilder sb = new StringBuilder ( ) ; 
 - for ( UUID cfId : cfLastWrite . keySet ( ) ) 
 + for ( UUID cfId : getDirtyCFIDs ( ) ) 
 { 
 CFMetaData m = Schema . instance . getCFMetaData ( cfId ) ; 
 sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) . append ( " ) , " ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java b / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java 
 new file mode 100644 
 index 0000000 . . b4dfa2e 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / ConcurrentBiMap . java 
 @ @ - 0 , 0 + 1 , 131 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . Collection ; 
 + import java . util . Collections ; 
 + import java . util . Map ; 
 + import java . util . Objects ; 
 + import java . util . Set ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + 
 + / * * 
 + * 
 + * A variant of BiMap that permits concurrent access , and expects uniqueness of values in both domain and range . 
 + * We synchronize on _ modifications only _ , and use ConcurrentHashMap so that readers can lookup safely . This does mean there 
 + * could be races to lookup the inverse , but we aren ' t too worried about that . 
 + * 
 + * @ param < K > 
 + * @ param < V > 
 + * / 
 + public class ConcurrentBiMap < K , V > implements Map < K , V > 
 + { 
 + protected final Map < K , V > forwardMap ; 
 + protected final Map < V , K > reverseMap ; 
 + 
 + public ConcurrentBiMap ( ) 
 + { 
 + this ( new ConcurrentHashMap < K , V > ( 16 , 0 . 5f , 1 ) , new ConcurrentHashMap < V , K > ( 16 , 0 . 5f , 1 ) ) ; 
 + } 
 + 
 + protected ConcurrentBiMap ( Map < K , V > forwardMap , Map < V , K > reverseMap ) 
 + { 
 + this . forwardMap = forwardMap ; 
 + this . reverseMap = reverseMap ; 
 + } 
 + 
 + public Map < V , K > inverse ( ) 
 + { 
 + return Collections . unmodifiableMap ( reverseMap ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + forwardMap . clear ( ) ; 
 + reverseMap . clear ( ) ; 
 + } 
 + 
 + public boolean containsKey ( Object key ) 
 + { 
 + return forwardMap . containsKey ( key ) ; 
 + } 
 + 
 + public boolean containsValue ( Object value ) 
 + { 
 + return reverseMap . containsKey ( value ) ; 
 + } 
 + 
 + public Set < Entry < K , V > > entrySet ( ) 
 + { 
 + return forwardMap . entrySet ( ) ; 
 + } 
 + 
 + public V get ( Object key ) 
 + { 
 + return forwardMap . get ( key ) ; 
 + } 
 + 
 + public boolean isEmpty ( ) 
 + { 
 + return forwardMap . isEmpty ( ) ; 
 + } 
 + 
 + public Set < K > keySet ( ) 
 + { 
 + return forwardMap . keySet ( ) ; 
 + } 
 + 
 + public synchronized V put ( K key , V value ) 
 + { 
 + K oldKey = reverseMap . get ( value ) ; 
 + if ( oldKey ! = null & & ! key . equals ( oldKey ) ) 
 + throw new IllegalArgumentException ( value + " is already bound in reverseMap to " + oldKey ) ; 
 + V oldVal = forwardMap . put ( key , value ) ; 
 + if ( oldVal ! = null & & ! Objects . equals ( reverseMap . remove ( oldVal ) , key ) ) 
 + throw new IllegalStateException ( ) ; / / for the prior mapping to be correct , we MUST get back the key from the reverseMap 
 + reverseMap . put ( value , key ) ; 
 + return oldVal ; 
 + } 
 + 
 + public synchronized void putAll ( Map < ? extends K , ? extends V > m ) 
 + { 
 + for ( Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) 
 + put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + } 
 + 
 + public synchronized V remove ( Object key ) 
 + { 
 + V oldVal = forwardMap . remove ( key ) ; 
 + if ( oldVal = = null ) 
 + return null ; 
 + Object oldKey = reverseMap . remove ( oldVal ) ; 
 + if ( oldKey = = null | | ! oldKey . equals ( key ) ) 
 + throw new IllegalStateException ( ) ; / / for the prior mapping to be correct , we MUST get back the key from the reverseMap 
 + return oldVal ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return forwardMap . size ( ) ; 
 + } 
 + 
 + public Collection < V > values ( ) 
 + { 
 + return reverseMap . keySet ( ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
