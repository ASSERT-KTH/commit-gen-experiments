BLEU SCORE: 0.037477767366779206

TEST MSG: Fix paging for 2 . x to 3 . x upgrades
GENERATED MSG: Apply Thrift ordering to legacy remote response where needed

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 798496a . . 459d591 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Fix paging for 2 . x to 3 . x upgrades ( CASSANDRA - 11195 ) <nl> * select _ distinct _ with _ deletions _ test failing on non - vnode environments ( CASSANDRA - 11126 ) <nl> * Stack Overflow returned to queries while upgrading ( CASSANDRA - 12527 ) <nl> * Fix legacy regex for temporary files from 2 . 2 ( CASSANDRA - 12565 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> index c1762f1 . . 70c770d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> @ @ - 1016 , 7 + 1016 , 7 @ @ public abstract class ReadCommand implements ReadQuery <nl> / / slice filter ' s stop . <nl> DataRange . Paging pagingRange = ( DataRange . Paging ) rangeCommand . dataRange ( ) ; <nl> Clustering lastReturned = pagingRange . getLastReturned ( ) ; <nl> - Slice . Bound newStart = Slice . Bound . exclusiveStartOf ( lastReturned ) ; <nl> + Slice . Bound newStart = Slice . Bound . inclusiveStartOf ( lastReturned ) ; <nl> Slice lastSlice = filter . requestedSlices ( ) . get ( filter . requestedSlices ( ) . size ( ) - 1 ) ; <nl> ByteBufferUtil . writeWithShortLength ( LegacyLayout . encodeBound ( metadata , newStart , true ) , out ) ; <nl> ByteBufferUtil . writeWithShortLength ( LegacyLayout . encodeClustering ( metadata , lastSlice . end ( ) . clustering ( ) ) , out ) ; <nl> @ @ - 1025 , 10 + 1025 , 8 @ @ public abstract class ReadCommand implements ReadQuery <nl> <nl> / / command - level limit <nl> / / Pre - 3 . 0 we would always request one more row than we actually needed and the command - level " start " would <nl> - / / be the last - returned cell name , so the response would always include it . When dealing with compound comparators , <nl> - / / we can pass an exclusive start and use the normal limit . However , when dealing with non - compound comparators , <nl> - / / pre - 3 . 0 nodes cannot perform exclusive slices , so we need to request one extra row . <nl> - int maxResults = rangeCommand . limits ( ) . count ( ) + ( metadata . isCompound ( ) ? 0 : 1 ) ; <nl> + / / be the last - returned cell name , so the response would always include it . <nl> + int maxResults = rangeCommand . limits ( ) . count ( ) + 1 ; <nl> out . writeInt ( maxResults ) ; <nl> <nl> / / countCQL3Rows <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> index 2304cb4 . . 12f0b15 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadResponse . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> @ @ - 280 , 13 + 280 , 10 @ @ public abstract class ReadResponse <nl> <nl> ClusteringIndexFilter filter = command . clusteringIndexFilter ( partition . partitionKey ( ) ) ; <nl> <nl> - / / Pre - 3 . 0 , we didn ' t have a way to express exclusivity for non - composite comparators , so all slices were <nl> - / / inclusive on both ends . If we have exclusive slice ends , we need to filter the results here . <nl> - UnfilteredRowIterator iterator ; <nl> - if ( ! command . metadata ( ) . isCompound ( ) ) <nl> - iterator = filter . filter ( partition . sliceableUnfilteredIterator ( command . columnFilter ( ) , filter . isReversed ( ) ) ) ; <nl> - else <nl> - iterator = partition . unfilteredIterator ( command . columnFilter ( ) , Slices . ALL , filter . isReversed ( ) ) ; <nl> + / / Pre - 3 . 0 we would always request one more row than we actually needed and the command - level " start " would <nl> + / / be the last - returned cell name , so the response would always include it . By consequence , we need to filter <nl> + / / the results here . <nl> + UnfilteredRowIterator iterator = filter . filter ( partition . sliceableUnfilteredIterator ( command . columnFilter ( ) , filter . isReversed ( ) ) ) ; <nl> <nl> / / Wrap results with a ThriftResultMerger only if they ' re intended for the thrift command . <nl> if ( command . isForThrift ( ) )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 798496a . . 459d591 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Fix paging for 2 . x to 3 . x upgrades ( CASSANDRA - 11195 ) 
 * select _ distinct _ with _ deletions _ test failing on non - vnode environments ( CASSANDRA - 11126 ) 
 * Stack Overflow returned to queries while upgrading ( CASSANDRA - 12527 ) 
 * Fix legacy regex for temporary files from 2 . 2 ( CASSANDRA - 12565 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java 
 index c1762f1 . . 70c770d 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / ReadCommand . java 
 @ @ - 1016 , 7 + 1016 , 7 @ @ public abstract class ReadCommand implements ReadQuery 
 / / slice filter ' s stop . 
 DataRange . Paging pagingRange = ( DataRange . Paging ) rangeCommand . dataRange ( ) ; 
 Clustering lastReturned = pagingRange . getLastReturned ( ) ; 
 - Slice . Bound newStart = Slice . Bound . exclusiveStartOf ( lastReturned ) ; 
 + Slice . Bound newStart = Slice . Bound . inclusiveStartOf ( lastReturned ) ; 
 Slice lastSlice = filter . requestedSlices ( ) . get ( filter . requestedSlices ( ) . size ( ) - 1 ) ; 
 ByteBufferUtil . writeWithShortLength ( LegacyLayout . encodeBound ( metadata , newStart , true ) , out ) ; 
 ByteBufferUtil . writeWithShortLength ( LegacyLayout . encodeClustering ( metadata , lastSlice . end ( ) . clustering ( ) ) , out ) ; 
 @ @ - 1025 , 10 + 1025 , 8 @ @ public abstract class ReadCommand implements ReadQuery 
 
 / / command - level limit 
 / / Pre - 3 . 0 we would always request one more row than we actually needed and the command - level " start " would 
 - / / be the last - returned cell name , so the response would always include it . When dealing with compound comparators , 
 - / / we can pass an exclusive start and use the normal limit . However , when dealing with non - compound comparators , 
 - / / pre - 3 . 0 nodes cannot perform exclusive slices , so we need to request one extra row . 
 - int maxResults = rangeCommand . limits ( ) . count ( ) + ( metadata . isCompound ( ) ? 0 : 1 ) ; 
 + / / be the last - returned cell name , so the response would always include it . 
 + int maxResults = rangeCommand . limits ( ) . count ( ) + 1 ; 
 out . writeInt ( maxResults ) ; 
 
 / / countCQL3Rows 
 diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java 
 index 2304cb4 . . 12f0b15 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadResponse . java 
 + + + b / src / java / org / apache / cassandra / db / ReadResponse . java 
 @ @ - 280 , 13 + 280 , 10 @ @ public abstract class ReadResponse 
 
 ClusteringIndexFilter filter = command . clusteringIndexFilter ( partition . partitionKey ( ) ) ; 
 
 - / / Pre - 3 . 0 , we didn ' t have a way to express exclusivity for non - composite comparators , so all slices were 
 - / / inclusive on both ends . If we have exclusive slice ends , we need to filter the results here . 
 - UnfilteredRowIterator iterator ; 
 - if ( ! command . metadata ( ) . isCompound ( ) ) 
 - iterator = filter . filter ( partition . sliceableUnfilteredIterator ( command . columnFilter ( ) , filter . isReversed ( ) ) ) ; 
 - else 
 - iterator = partition . unfilteredIterator ( command . columnFilter ( ) , Slices . ALL , filter . isReversed ( ) ) ; 
 + / / Pre - 3 . 0 we would always request one more row than we actually needed and the command - level " start " would 
 + / / be the last - returned cell name , so the response would always include it . By consequence , we need to filter 
 + / / the results here . 
 + UnfilteredRowIterator iterator = filter . filter ( partition . sliceableUnfilteredIterator ( command . columnFilter ( ) , filter . isReversed ( ) ) ) ; 
 
 / / Wrap results with a ThriftResultMerger only if they ' re intended for the thrift command . 
 if ( command . isForThrift ( ) )

NEAREST DIFF:
ELIMINATEDSENTENCE
