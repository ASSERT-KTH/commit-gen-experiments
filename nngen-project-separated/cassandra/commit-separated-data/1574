BLEU SCORE: 0.018543295278285157

TEST MSG: Switch SSTableDeletingTask . failingTasks to a ConcurrentLinkedQueue
GENERATED MSG: fix race between reference - counted cleanup and scrub in DefsTest

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> index cc837ba . . 13bfd6d 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java <nl> @ @ - 19 , 8 + 19 , 9 @ @ package org . apache . cassandra . io . sstable ; <nl> <nl> import java . io . File ; <nl> import java . util . Collections ; <nl> + import java . util . Queue ; <nl> import java . util . Set ; <nl> - import java . util . concurrent . CopyOnWriteArraySet ; <nl> + import java . util . concurrent . ConcurrentLinkedQueue ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> @ @ - 42 , 7 + 43 , 7 @ @ public class SSTableDeletingTask implements Runnable <nl> / / and delete will fail ( on Windows ) until it is ( we only force the unmapping on SUN VMs ) . <nl> / / Additionally , we need to make sure to delete the data file first , so on restart the others <nl> / / will be recognized as GCable . <nl> - private static final Set < SSTableDeletingTask > failedTasks = new CopyOnWriteArraySet < > ( ) ; <nl> + private static final Queue < SSTableDeletingTask > failedTasks = new ConcurrentLinkedQueue < > ( ) ; <nl> private static final Blocker blocker = new Blocker ( ) ; <nl> <nl> private final SSTableReader referent ; <nl> @ @ - 119 , 11 + 120 , 9 @ @ public class SSTableDeletingTask implements Runnable <nl> * / <nl> public static void rescheduleFailedTasks ( ) <nl> { <nl> - for ( SSTableDeletingTask task : failedTasks ) <nl> - { <nl> - failedTasks . remove ( task ) ; <nl> + SSTableDeletingTask task ; <nl> + while ( null ! = ( task = failedTasks . poll ( ) ) ) <nl> task . schedule ( ) ; <nl> - } <nl> } <nl> <nl> / * * for tests * /
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java b / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java <nl> index 9489e36 . . 69c18ac 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java <nl> @ @ - 130 , 15 + 130 , 15 @ @ public class ColumnFamilySerializer implements ICompactSerializer3 < ColumnFamily > <nl> <nl> public void deserializeColumns ( DataInput dis , ColumnFamily cf , boolean intern , boolean fromRemote ) throws IOException <nl> { <nl> - int size = dis . readInt ( ) ; <nl> - deserializeColumns ( dis , cf , size , intern , fromRemote ) ; <nl> + int count = dis . readInt ( ) ; <nl> + deserializeColumns ( dis , cf , count , intern , fromRemote ) ; <nl> } <nl> <nl> / * column count is already read from DataInput * / <nl> - public void deserializeColumns ( DataInput dis , ColumnFamily cf , int size , boolean intern , boolean fromRemote ) throws IOException <nl> + public void deserializeColumns ( DataInput dis , ColumnFamily cf , int count , boolean intern , boolean fromRemote ) throws IOException <nl> { <nl> ColumnFamilyStore interner = intern ? Table . open ( CFMetaData . getCF ( cf . id ( ) ) . left ) . getColumnFamilyStore ( cf . id ( ) ) : null ; <nl> - for ( int i = 0 ; i < size ; + + i ) <nl> + for ( int i = 0 ; i < count ; + + i ) <nl> { <nl> IColumn column = cf . getColumnSerializer ( ) . deserialize ( dis , interner , fromRemote , ( int ) ( System . currentTimeMillis ( ) / 1000 ) ) ; <nl> cf . addColumn ( column ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 index cc837ba . . 13bfd6d 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableDeletingTask . java 
 @ @ - 19 , 8 + 19 , 9 @ @ package org . apache . cassandra . io . sstable ; 
 
 import java . io . File ; 
 import java . util . Collections ; 
 + import java . util . Queue ; 
 import java . util . Set ; 
 - import java . util . concurrent . CopyOnWriteArraySet ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 import java . util . concurrent . TimeUnit ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 @ @ - 42 , 7 + 43 , 7 @ @ public class SSTableDeletingTask implements Runnable 
 / / and delete will fail ( on Windows ) until it is ( we only force the unmapping on SUN VMs ) . 
 / / Additionally , we need to make sure to delete the data file first , so on restart the others 
 / / will be recognized as GCable . 
 - private static final Set < SSTableDeletingTask > failedTasks = new CopyOnWriteArraySet < > ( ) ; 
 + private static final Queue < SSTableDeletingTask > failedTasks = new ConcurrentLinkedQueue < > ( ) ; 
 private static final Blocker blocker = new Blocker ( ) ; 
 
 private final SSTableReader referent ; 
 @ @ - 119 , 11 + 120 , 9 @ @ public class SSTableDeletingTask implements Runnable 
 * / 
 public static void rescheduleFailedTasks ( ) 
 { 
 - for ( SSTableDeletingTask task : failedTasks ) 
 - { 
 - failedTasks . remove ( task ) ; 
 + SSTableDeletingTask task ; 
 + while ( null ! = ( task = failedTasks . poll ( ) ) ) 
 task . schedule ( ) ; 
 - } 
 } 
 
 / * * for tests * /

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java b / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java 
 index 9489e36 . . 69c18ac 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilySerializer . java 
 @ @ - 130 , 15 + 130 , 15 @ @ public class ColumnFamilySerializer implements ICompactSerializer3 < ColumnFamily > 
 
 public void deserializeColumns ( DataInput dis , ColumnFamily cf , boolean intern , boolean fromRemote ) throws IOException 
 { 
 - int size = dis . readInt ( ) ; 
 - deserializeColumns ( dis , cf , size , intern , fromRemote ) ; 
 + int count = dis . readInt ( ) ; 
 + deserializeColumns ( dis , cf , count , intern , fromRemote ) ; 
 } 
 
 / * column count is already read from DataInput * / 
 - public void deserializeColumns ( DataInput dis , ColumnFamily cf , int size , boolean intern , boolean fromRemote ) throws IOException 
 + public void deserializeColumns ( DataInput dis , ColumnFamily cf , int count , boolean intern , boolean fromRemote ) throws IOException 
 { 
 ColumnFamilyStore interner = intern ? Table . open ( CFMetaData . getCF ( cf . id ( ) ) . left ) . getColumnFamilyStore ( cf . id ( ) ) : null ; 
 - for ( int i = 0 ; i < size ; + + i ) 
 + for ( int i = 0 ; i < count ; + + i ) 
 { 
 IColumn column = cf . getColumnSerializer ( ) . deserialize ( dis , interner , fromRemote , ( int ) ( System . currentTimeMillis ( ) / 1000 ) ) ; 
 cf . addColumn ( column ) ;
