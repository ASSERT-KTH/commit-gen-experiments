BLEU SCORE: 0.01562359895249748

TEST MSG: Catch errors when the JVM pulls the rug out from GCInspector
GENERATED MSG: work around native memory leak in com . sun . management . GarbageCollectorMXBean

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d339309 . . d4b11d1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 10 <nl> + * Catch errors when the JVM pulls the rug out from GCInspector ( CASSANDRA - 5345 ) <nl> * ( Windows ) force range - based repair to non - sequential mode ( CASSANDRA - 7541 ) <nl> * Fix range merging when DES scores are zero ( CASSANDRA - 7535 ) <nl> * Warn when SSL certificates have expired ( CASSANDRA - 7528 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java <nl> index 9961bf9 . . f03ec01 100644 <nl> - - - a / src / java / org / apache / cassandra / service / GCInspector . java <nl> + + + b / src / java / org / apache / cassandra / service / GCInspector . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ import java . lang . management . GarbageCollectorMXBean ; <nl> import java . lang . management . ManagementFactory ; <nl> import java . lang . management . MemoryMXBean ; <nl> import java . lang . management . MemoryUsage ; <nl> + import java . lang . reflect . UndeclaredThrowableException ; <nl> import java . util . ArrayList ; <nl> import java . util . HashMap ; <nl> import java . util . List ; <nl> @ @ - 49 , 8 + 50 , 28 @ @ public class GCInspector <nl> final List < GarbageCollectorMXBean > beans = new ArrayList < GarbageCollectorMXBean > ( ) ; <nl> final MemoryMXBean membean = ManagementFactory . getMemoryMXBean ( ) ; <nl> <nl> - public GCInspector ( ) <nl> + public void start ( ) <nl> { <nl> + buildMXBeanList ( ) ; <nl> + <nl> + / / don ' t bother starting a thread that will do nothing . <nl> + if ( beans . isEmpty ( ) ) <nl> + return ; <nl> + <nl> + Runnable t = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + logGCResults ( ) ; <nl> + } <nl> + } ; <nl> + StorageService . scheduledTasks . scheduleWithFixedDelay ( t , INTERVAL _ IN _ MS , INTERVAL _ IN _ MS , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + <nl> + private void buildMXBeanList ( ) <nl> + { <nl> + beans . clear ( ) ; <nl> + <nl> MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> try <nl> { <nl> @ @ - 67 , 62 + 88 , 67 @ @ public class GCInspector <nl> } <nl> } <nl> <nl> - public void start ( ) <nl> + private void logGCResults ( ) <nl> { <nl> - / / don ' t bother starting a thread that will do nothing . <nl> - if ( beans . size ( ) = = 0 ) <nl> - return ; <nl> - Runnable t = new Runnable ( ) <nl> + boolean gcChanged = false ; <nl> + try <nl> { <nl> - public void run ( ) <nl> + for ( GarbageCollectorMXBean gc : beans ) <nl> { <nl> - logGCResults ( ) ; <nl> + if ( ! gc . isValid ( ) ) <nl> + { <nl> + gcChanged = true ; <nl> + continue ; <nl> + } <nl> + <nl> + Long previousTotal = gctimes . get ( gc . getName ( ) ) ; <nl> + Long total = gc . getCollectionTime ( ) ; <nl> + if ( previousTotal = = null ) <nl> + previousTotal = 0L ; <nl> + if ( previousTotal . equals ( total ) ) <nl> + continue ; <nl> + gctimes . put ( gc . getName ( ) , total ) ; <nl> + Long duration = total - previousTotal ; / / may be zero for a really fast collection <nl> + <nl> + Long previousCount = gccounts . get ( gc . getName ( ) ) ; <nl> + Long count = gc . getCollectionCount ( ) ; <nl> + <nl> + if ( previousCount = = null ) <nl> + previousCount = 0L ; <nl> + if ( count . equals ( previousCount ) ) <nl> + continue ; <nl> + <nl> + gccounts . put ( gc . getName ( ) , count ) ; <nl> + <nl> + MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; <nl> + long memoryUsed = mu . getUsed ( ) ; <nl> + long memoryMax = mu . getMax ( ) ; <nl> + <nl> + String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , <nl> + gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; <nl> + long durationPerCollection = duration / ( count - previousCount ) ; <nl> + if ( durationPerCollection > MIN _ DURATION ) <nl> + logger . info ( st ) ; <nl> + else if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( st ) ; <nl> + <nl> + if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) <nl> + StatusLogger . log ( ) ; <nl> + <nl> + / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure <nl> + if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) <nl> + SSTableDeletingTask . rescheduleFailedTasks ( ) ; <nl> } <nl> - } ; <nl> - StorageService . scheduledTasks . scheduleWithFixedDelay ( t , INTERVAL _ IN _ MS , INTERVAL _ IN _ MS , TimeUnit . MILLISECONDS ) ; <nl> - } <nl> - <nl> - private void logGCResults ( ) <nl> - { <nl> - for ( GarbageCollectorMXBean gc : beans ) <nl> + } <nl> + catch ( UndeclaredThrowableException e ) <nl> { <nl> - Long previousTotal = gctimes . get ( gc . getName ( ) ) ; <nl> - Long total = gc . getCollectionTime ( ) ; <nl> - if ( previousTotal = = null ) <nl> - previousTotal = 0L ; <nl> - if ( previousTotal . equals ( total ) ) <nl> - continue ; <nl> - gctimes . put ( gc . getName ( ) , total ) ; <nl> - Long duration = total - previousTotal ; / / may be zero for a really fast collection <nl> - <nl> - Long previousCount = gccounts . get ( gc . getName ( ) ) ; <nl> - Long count = gc . getCollectionCount ( ) ; <nl> - <nl> - if ( previousCount = = null ) <nl> - previousCount = 0L ; <nl> - if ( count . equals ( previousCount ) ) <nl> - continue ; <nl> - <nl> - gccounts . put ( gc . getName ( ) , count ) ; <nl> - <nl> - MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; <nl> - long memoryUsed = mu . getUsed ( ) ; <nl> - long memoryMax = mu . getMax ( ) ; <nl> - <nl> - String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , <nl> - gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; <nl> - long durationPerCollection = duration / ( count - previousCount ) ; <nl> - if ( durationPerCollection > MIN _ DURATION ) <nl> - logger . info ( st ) ; <nl> - else if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( st ) ; <nl> - <nl> - if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) <nl> - StatusLogger . log ( ) ; <nl> - <nl> - / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure <nl> - if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) <nl> - SSTableDeletingTask . rescheduleFailedTasks ( ) ; <nl> + / / valid - ness may have changed out from under us , even though we check for it explicitly . <nl> + / / if so , gc . getName ( ) will throw UTE when reflection runs into InstanceNotFoundException . <nl> + / / See CASSANDRA - 5345 <nl> + gcChanged = true ; <nl> } <nl> + <nl> + if ( gcChanged ) <nl> + buildMXBeanList ( ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6a4416c . . 3d7e747 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 45 , 6 + 45 , 10 @ @ <nl> in a commitlog segment ( CASSANDRA - 3021 ) <nl> * fix cassandra . bat when CASSANDRA _ HOME contains spaces ( CASSANDRA - 2952 ) <nl> * fix to SSTableSimpleUnsortedWriter bufferSize calculation ( CASSANDRA - 3027 ) <nl> + * make cleanup and normal compaction able to skip empty rows <nl> + ( rows containing nothing but expired tombstones ) ( CASSANDRA - 3039 ) <nl> + * work around native memory leak in com . sun . management . GarbageCollectorMXBean <nl> + ( CASSANDRA - 2868 ) <nl> <nl> <nl> 0 . 8 . 4 <nl> diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g <nl> index b884fc5 . . 85a2088 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql / Cql . g <nl> @ @ - 207 , 7 + 207 , 6 @ @ whereClause returns [ WhereClause clause ] <nl> insertStatement returns [ UpdateStatement expr ] <nl> : { <nl> Attributes attrs = new Attributes ( ) ; <nl> - Map < Term , Term > columns = new HashMap < Term , Term > ( ) ; <nl> <nl> List < Term > columnNames = new ArrayList < Term > ( ) ; <nl> List < Term > columnValues = new ArrayList < Term > ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 94e3467 . . c029312 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 199 , 6 + 199 , 7 @ @ public class CommitLog implements CommitLogMBean <nl> } <nl> final ReplayPosition globalPosition = Ordering . from ( ReplayPosition . comparator ) . min ( cfPositions . values ( ) ) ; <nl> <nl> + Checksum checksum = new CRC32 ( ) ; <nl> for ( final File file : clogs ) <nl> { <nl> final long segment = CommitLogSegment . idFromFilename ( file . getName ( ) ) ; <nl> @ @ - 237 , 7 + 238 , 6 @ @ public class CommitLog implements CommitLogMBean <nl> logger . debug ( " Reading mutation at " + reader . getFilePointer ( ) ) ; <nl> <nl> long claimedCRC32 ; <nl> - Checksum checksum = new CRC32 ( ) ; <nl> int serializedSize ; <nl> try <nl> { <nl> @ @ - 250 , 6 + 250 , 7 @ @ public class CommitLog implements CommitLogMBean <nl> if ( serializedSize < 10 ) <nl> break ; <nl> long claimedSizeChecksum = reader . readLong ( ) ; <nl> + checksum . reset ( ) ; <nl> checksum . update ( serializedSize ) ; <nl> if ( checksum . getValue ( ) ! = claimedSizeChecksum ) <nl> break ; / / entry wasn ' t synced correctly / fully . that ' s ok . <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 3abf443 . . 3d8a258 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 700 , 8 + 700 , 11 @ @ public class CompactionManager implements CompactionManagerMBean <nl> SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; <nl> if ( Range . isTokenInRanges ( row . getKey ( ) . token , ranges ) ) <nl> { <nl> + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; <nl> + if ( compactedRow . isEmpty ( ) ) <nl> + continue ; <nl> writer = maybeCreateWriter ( cfs , compactionFileLocation , expectedBloomFilterSize , writer , Collections . singletonList ( sstable ) ) ; <nl> - writer . append ( controller . getCompactedRow ( row ) ) ; <nl> + writer . append ( compactedRow ) ; <nl> totalkeysWritten + + ; <nl> } <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> index 8fc7aff . . 6401af4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> @ @ - 152 , 6 + 152 , 9 @ @ public class CompactionTask extends AbstractCompactionTask <nl> while ( nni . hasNext ( ) ) <nl> { <nl> AbstractCompactedRow row = nni . next ( ) ; <nl> + if ( row . isEmpty ( ) ) <nl> + continue ; <nl> + <nl> long position = writer . append ( row ) ; <nl> totalkeysWritten + + ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java <nl> index 3a08eef . . d66eb94 100644 <nl> - - - a / src / java / org / apache / cassandra / service / GCInspector . java <nl> + + + b / src / java / org / apache / cassandra / service / GCInspector . java <nl> @ @ - 20 , 11 + 20 , 13 @ @ package org . apache . cassandra . service ; <nl> * <nl> * / <nl> <nl> + import java . lang . management . GarbageCollectorMXBean ; <nl> import java . lang . management . ManagementFactory ; <nl> + import java . lang . management . MemoryMXBean ; <nl> import java . lang . management . MemoryUsage ; <nl> - import java . lang . reflect . InvocationTargetException ; <nl> - import java . lang . reflect . Method ; <nl> - import java . util . * ; <nl> + import java . util . ArrayList ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> import java . util . concurrent . TimeUnit ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> @ @ - 46 , 32 + 48 , 22 @ @ public class GCInspector <nl> public static final GCInspector instance = new GCInspector ( ) ; <nl> <nl> private HashMap < String , Long > gctimes = new HashMap < String , Long > ( ) ; <nl> + private HashMap < String , Long > gccounts = new HashMap < String , Long > ( ) ; <nl> + <nl> + List < GarbageCollectorMXBean > beans = new ArrayList < GarbageCollectorMXBean > ( ) ; <nl> + MemoryMXBean membean = ManagementFactory . getMemoryMXBean ( ) ; <nl> <nl> - List < Object > beans = new ArrayList < Object > ( ) ; / / these are instances of com . sun . management . GarbageCollectorMXBean <nl> private volatile boolean cacheSizesReduced ; <nl> <nl> public GCInspector ( ) <nl> { <nl> - / / we only want this class to do its thing on sun jdks , or when the sun classes are present . <nl> - Class gcBeanClass = null ; <nl> - try <nl> - { <nl> - gcBeanClass = Class . forName ( " com . sun . management . GarbageCollectorMXBean " ) ; <nl> - Class . forName ( " com . sun . management . GcInfo " ) ; <nl> - } <nl> - catch ( ClassNotFoundException ex ) <nl> - { <nl> - / / this happens when using a non - sun jdk . <nl> - logger . warn ( " Cannot load sun GC monitoring classes . GCInspector is disabled . " ) ; <nl> - } <nl> - <nl> MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> try <nl> { <nl> ObjectName gcName = new ObjectName ( ManagementFactory . GARBAGE _ COLLECTOR _ MXBEAN _ DOMAIN _ TYPE + " , * " ) ; <nl> for ( ObjectName name : server . queryNames ( gcName , null ) ) <nl> { <nl> - Object gc = ManagementFactory . newPlatformMXBeanProxy ( server , name . getCanonicalName ( ) , gcBeanClass ) ; <nl> + GarbageCollectorMXBean gc = ManagementFactory . newPlatformMXBeanProxy ( server , name . getCanonicalName ( ) , GarbageCollectorMXBean . class ) ; <nl> beans . add ( gc ) ; <nl> } <nl> } <nl> @ @ - 98 , 43 + 90 , 42 @ @ public class GCInspector <nl> <nl> private void logGCResults ( ) <nl> { <nl> - for ( Object gc : beans ) <nl> + for ( GarbageCollectorMXBean gc : beans ) <nl> { <nl> - SunGcWrapper gcw = new SunGcWrapper ( gc ) ; <nl> - if ( gcw . isLastGcInfoNull ( ) ) <nl> + Long previousTotal = gctimes . get ( gc . getName ( ) ) ; <nl> + Long total = gc . getCollectionTime ( ) ; <nl> + if ( previousTotal = = null ) <nl> + previousTotal = 0L ; <nl> + if ( previousTotal . equals ( total ) ) <nl> continue ; <nl> - <nl> - Long previous = gctimes . get ( gcw . getName ( ) ) ; <nl> - if ( previous ! = null & & previous . longValue ( ) = = gcw . getCollectionTime ( ) . longValue ( ) ) <nl> - continue ; <nl> - gctimes . put ( gcw . getName ( ) , gcw . getCollectionTime ( ) ) ; <nl> - <nl> - long previousMemoryUsed = 0 ; <nl> - long memoryUsed = 0 ; <nl> - long memoryMax = 0 ; <nl> - for ( Map . Entry < String , MemoryUsage > entry : gcw . getMemoryUsageBeforeGc ( ) . entrySet ( ) ) <nl> - { <nl> - previousMemoryUsed + = entry . getValue ( ) . getUsed ( ) ; <nl> - } <nl> - for ( Map . Entry < String , MemoryUsage > entry : gcw . getMemoryUsageAfterGc ( ) . entrySet ( ) ) <nl> - { <nl> - MemoryUsage mu = entry . getValue ( ) ; <nl> - memoryUsed + = mu . getUsed ( ) ; <nl> - memoryMax + = mu . getMax ( ) ; <nl> - } <nl> - <nl> - String st = String . format ( " GC for % s : % s ms , % s reclaimed leaving % s used ; max is % s " , <nl> - gcw . getName ( ) , gcw . getDuration ( ) , previousMemoryUsed - memoryUsed , memoryUsed , memoryMax ) ; <nl> - if ( gcw . getDuration ( ) > MIN _ DURATION ) <nl> + gctimes . put ( gc . getName ( ) , total ) ; <nl> + Long duration = total - previousTotal ; <nl> + assert duration > 0 ; <nl> + <nl> + Long previousCount = gccounts . get ( gc . getName ( ) ) ; <nl> + Long count = gc . getCollectionCount ( ) ; <nl> + if ( previousCount = = null ) <nl> + previousCount = 0L ; <nl> + gccounts . put ( gc . getName ( ) , count ) ; <nl> + assert count > previousCount ; <nl> + <nl> + MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; <nl> + long memoryUsed = mu . getUsed ( ) ; <nl> + long memoryMax = mu . getMax ( ) ; <nl> + <nl> + String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , <nl> + gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; <nl> + long durationPerCollection = duration / ( count - previousCount ) ; <nl> + if ( durationPerCollection > MIN _ DURATION ) <nl> logger . info ( st ) ; <nl> else if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( st ) ; <nl> <nl> - if ( gcw . getDuration ( ) > MIN _ DURATION _ TPSTATS ) <nl> + if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) <nl> StatusLogger . log ( ) ; <nl> <nl> / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure <nl> - if ( gcw . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) <nl> + if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) <nl> { <nl> SSTableDeletingTask . rescheduleFailedTasks ( ) ; <nl> <nl> @ @ - 155 , 82 + 146 , 4 @ @ public class GCInspector <nl> } <nl> } <nl> } <nl> - <nl> - / / wrapper for sun class . this enables other jdks to compile this class . <nl> - private static final class SunGcWrapper <nl> - { <nl> - <nl> - private Map < String , MemoryUsage > usageBeforeGc = null ; <nl> - private Map < String , MemoryUsage > usageAfterGc = null ; <nl> - private String name ; <nl> - private Long collectionTime ; <nl> - private Long duration ; <nl> - <nl> - SunGcWrapper ( Object gcMxBean ) <nl> - { <nl> - / / if we ' ve gotten this far , we ' ve already verified that the right classes are in the CP . Now we just <nl> - / / need to check for boneheadedness . <nl> - / / grab everything we need here so that we don ' t have to deal with try / catch everywhere . <nl> - try <nl> - { <nl> - assert Class . forName ( " com . sun . management . GarbageCollectorMXBean " ) . isAssignableFrom ( gcMxBean . getClass ( ) ) ; <nl> - Method getGcInfo = gcMxBean . getClass ( ) . getDeclaredMethod ( " getLastGcInfo " ) ; <nl> - Object lastGcInfo = getGcInfo . invoke ( gcMxBean ) ; <nl> - if ( lastGcInfo ! = null ) <nl> - { <nl> - usageBeforeGc = ( Map < String , MemoryUsage > ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getMemoryUsageBeforeGc " ) . invoke ( lastGcInfo ) ; <nl> - usageAfterGc = ( Map < String , MemoryUsage > ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getMemoryUsageAfterGc " ) . invoke ( lastGcInfo ) ; <nl> - duration = ( Long ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getDuration " ) . invoke ( lastGcInfo ) ; <nl> - name = ( String ) gcMxBean . getClass ( ) . getDeclaredMethod ( " getName " ) . invoke ( gcMxBean ) ; <nl> - collectionTime = ( Long ) gcMxBean . getClass ( ) . getDeclaredMethod ( " getCollectionTime " ) . invoke ( gcMxBean ) ; <nl> - } <nl> - } <nl> - catch ( ClassNotFoundException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - catch ( NoSuchMethodException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - catch ( IllegalAccessException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - catch ( InvocationTargetException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - } <nl> - <nl> - String getName ( ) <nl> - { <nl> - return name ; <nl> - } <nl> - <nl> - Long getCollectionTime ( ) <nl> - { <nl> - return collectionTime ; <nl> - } <nl> - <nl> - Long getDuration ( ) <nl> - { <nl> - return duration ; <nl> - } <nl> - <nl> - Map < String , MemoryUsage > getMemoryUsageAfterGc ( ) <nl> - { <nl> - return usageAfterGc ; <nl> - } <nl> - <nl> - Map < String , MemoryUsage > getMemoryUsageBeforeGc ( ) <nl> - { <nl> - return usageBeforeGc ; <nl> - } <nl> - <nl> - boolean isLastGcInfoNull ( ) <nl> - { <nl> - return usageBeforeGc = = null ; <nl> - } <nl> - } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d339309 . . d4b11d1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 10 
 + * Catch errors when the JVM pulls the rug out from GCInspector ( CASSANDRA - 5345 ) 
 * ( Windows ) force range - based repair to non - sequential mode ( CASSANDRA - 7541 ) 
 * Fix range merging when DES scores are zero ( CASSANDRA - 7535 ) 
 * Warn when SSL certificates have expired ( CASSANDRA - 7528 ) 
 diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java 
 index 9961bf9 . . f03ec01 100644 
 - - - a / src / java / org / apache / cassandra / service / GCInspector . java 
 + + + b / src / java / org / apache / cassandra / service / GCInspector . java 
 @ @ - 21 , 6 + 21 , 7 @ @ import java . lang . management . GarbageCollectorMXBean ; 
 import java . lang . management . ManagementFactory ; 
 import java . lang . management . MemoryMXBean ; 
 import java . lang . management . MemoryUsage ; 
 + import java . lang . reflect . UndeclaredThrowableException ; 
 import java . util . ArrayList ; 
 import java . util . HashMap ; 
 import java . util . List ; 
 @ @ - 49 , 8 + 50 , 28 @ @ public class GCInspector 
 final List < GarbageCollectorMXBean > beans = new ArrayList < GarbageCollectorMXBean > ( ) ; 
 final MemoryMXBean membean = ManagementFactory . getMemoryMXBean ( ) ; 
 
 - public GCInspector ( ) 
 + public void start ( ) 
 { 
 + buildMXBeanList ( ) ; 
 + 
 + / / don ' t bother starting a thread that will do nothing . 
 + if ( beans . isEmpty ( ) ) 
 + return ; 
 + 
 + Runnable t = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + logGCResults ( ) ; 
 + } 
 + } ; 
 + StorageService . scheduledTasks . scheduleWithFixedDelay ( t , INTERVAL _ IN _ MS , INTERVAL _ IN _ MS , TimeUnit . MILLISECONDS ) ; 
 + } 
 + 
 + private void buildMXBeanList ( ) 
 + { 
 + beans . clear ( ) ; 
 + 
 MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; 
 try 
 { 
 @ @ - 67 , 62 + 88 , 67 @ @ public class GCInspector 
 } 
 } 
 
 - public void start ( ) 
 + private void logGCResults ( ) 
 { 
 - / / don ' t bother starting a thread that will do nothing . 
 - if ( beans . size ( ) = = 0 ) 
 - return ; 
 - Runnable t = new Runnable ( ) 
 + boolean gcChanged = false ; 
 + try 
 { 
 - public void run ( ) 
 + for ( GarbageCollectorMXBean gc : beans ) 
 { 
 - logGCResults ( ) ; 
 + if ( ! gc . isValid ( ) ) 
 + { 
 + gcChanged = true ; 
 + continue ; 
 + } 
 + 
 + Long previousTotal = gctimes . get ( gc . getName ( ) ) ; 
 + Long total = gc . getCollectionTime ( ) ; 
 + if ( previousTotal = = null ) 
 + previousTotal = 0L ; 
 + if ( previousTotal . equals ( total ) ) 
 + continue ; 
 + gctimes . put ( gc . getName ( ) , total ) ; 
 + Long duration = total - previousTotal ; / / may be zero for a really fast collection 
 + 
 + Long previousCount = gccounts . get ( gc . getName ( ) ) ; 
 + Long count = gc . getCollectionCount ( ) ; 
 + 
 + if ( previousCount = = null ) 
 + previousCount = 0L ; 
 + if ( count . equals ( previousCount ) ) 
 + continue ; 
 + 
 + gccounts . put ( gc . getName ( ) , count ) ; 
 + 
 + MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; 
 + long memoryUsed = mu . getUsed ( ) ; 
 + long memoryMax = mu . getMax ( ) ; 
 + 
 + String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , 
 + gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; 
 + long durationPerCollection = duration / ( count - previousCount ) ; 
 + if ( durationPerCollection > MIN _ DURATION ) 
 + logger . info ( st ) ; 
 + else if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( st ) ; 
 + 
 + if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) 
 + StatusLogger . log ( ) ; 
 + 
 + / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure 
 + if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) 
 + SSTableDeletingTask . rescheduleFailedTasks ( ) ; 
 } 
 - } ; 
 - StorageService . scheduledTasks . scheduleWithFixedDelay ( t , INTERVAL _ IN _ MS , INTERVAL _ IN _ MS , TimeUnit . MILLISECONDS ) ; 
 - } 
 - 
 - private void logGCResults ( ) 
 - { 
 - for ( GarbageCollectorMXBean gc : beans ) 
 + } 
 + catch ( UndeclaredThrowableException e ) 
 { 
 - Long previousTotal = gctimes . get ( gc . getName ( ) ) ; 
 - Long total = gc . getCollectionTime ( ) ; 
 - if ( previousTotal = = null ) 
 - previousTotal = 0L ; 
 - if ( previousTotal . equals ( total ) ) 
 - continue ; 
 - gctimes . put ( gc . getName ( ) , total ) ; 
 - Long duration = total - previousTotal ; / / may be zero for a really fast collection 
 - 
 - Long previousCount = gccounts . get ( gc . getName ( ) ) ; 
 - Long count = gc . getCollectionCount ( ) ; 
 - 
 - if ( previousCount = = null ) 
 - previousCount = 0L ; 
 - if ( count . equals ( previousCount ) ) 
 - continue ; 
 - 
 - gccounts . put ( gc . getName ( ) , count ) ; 
 - 
 - MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; 
 - long memoryUsed = mu . getUsed ( ) ; 
 - long memoryMax = mu . getMax ( ) ; 
 - 
 - String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , 
 - gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; 
 - long durationPerCollection = duration / ( count - previousCount ) ; 
 - if ( durationPerCollection > MIN _ DURATION ) 
 - logger . info ( st ) ; 
 - else if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( st ) ; 
 - 
 - if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) 
 - StatusLogger . log ( ) ; 
 - 
 - / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure 
 - if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) 
 - SSTableDeletingTask . rescheduleFailedTasks ( ) ; 
 + / / valid - ness may have changed out from under us , even though we check for it explicitly . 
 + / / if so , gc . getName ( ) will throw UTE when reflection runs into InstanceNotFoundException . 
 + / / See CASSANDRA - 5345 
 + gcChanged = true ; 
 } 
 + 
 + if ( gcChanged ) 
 + buildMXBeanList ( ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6a4416c . . 3d7e747 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 45 , 6 + 45 , 10 @ @ 
 in a commitlog segment ( CASSANDRA - 3021 ) 
 * fix cassandra . bat when CASSANDRA _ HOME contains spaces ( CASSANDRA - 2952 ) 
 * fix to SSTableSimpleUnsortedWriter bufferSize calculation ( CASSANDRA - 3027 ) 
 + * make cleanup and normal compaction able to skip empty rows 
 + ( rows containing nothing but expired tombstones ) ( CASSANDRA - 3039 ) 
 + * work around native memory leak in com . sun . management . GarbageCollectorMXBean 
 + ( CASSANDRA - 2868 ) 
 
 
 0 . 8 . 4 
 diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g 
 index b884fc5 . . 85a2088 100644 
 - - - a / src / java / org / apache / cassandra / cql / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql / Cql . g 
 @ @ - 207 , 7 + 207 , 6 @ @ whereClause returns [ WhereClause clause ] 
 insertStatement returns [ UpdateStatement expr ] 
 : { 
 Attributes attrs = new Attributes ( ) ; 
 - Map < Term , Term > columns = new HashMap < Term , Term > ( ) ; 
 
 List < Term > columnNames = new ArrayList < Term > ( ) ; 
 List < Term > columnValues = new ArrayList < Term > ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 94e3467 . . c029312 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 199 , 6 + 199 , 7 @ @ public class CommitLog implements CommitLogMBean 
 } 
 final ReplayPosition globalPosition = Ordering . from ( ReplayPosition . comparator ) . min ( cfPositions . values ( ) ) ; 
 
 + Checksum checksum = new CRC32 ( ) ; 
 for ( final File file : clogs ) 
 { 
 final long segment = CommitLogSegment . idFromFilename ( file . getName ( ) ) ; 
 @ @ - 237 , 7 + 238 , 6 @ @ public class CommitLog implements CommitLogMBean 
 logger . debug ( " Reading mutation at " + reader . getFilePointer ( ) ) ; 
 
 long claimedCRC32 ; 
 - Checksum checksum = new CRC32 ( ) ; 
 int serializedSize ; 
 try 
 { 
 @ @ - 250 , 6 + 250 , 7 @ @ public class CommitLog implements CommitLogMBean 
 if ( serializedSize < 10 ) 
 break ; 
 long claimedSizeChecksum = reader . readLong ( ) ; 
 + checksum . reset ( ) ; 
 checksum . update ( serializedSize ) ; 
 if ( checksum . getValue ( ) ! = claimedSizeChecksum ) 
 break ; / / entry wasn ' t synced correctly / fully . that ' s ok . 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 3abf443 . . 3d8a258 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 700 , 8 + 700 , 11 @ @ public class CompactionManager implements CompactionManagerMBean 
 SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; 
 if ( Range . isTokenInRanges ( row . getKey ( ) . token , ranges ) ) 
 { 
 + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; 
 + if ( compactedRow . isEmpty ( ) ) 
 + continue ; 
 writer = maybeCreateWriter ( cfs , compactionFileLocation , expectedBloomFilterSize , writer , Collections . singletonList ( sstable ) ) ; 
 - writer . append ( controller . getCompactedRow ( row ) ) ; 
 + writer . append ( compactedRow ) ; 
 totalkeysWritten + + ; 
 } 
 else 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 index 8fc7aff . . 6401af4 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 @ @ - 152 , 6 + 152 , 9 @ @ public class CompactionTask extends AbstractCompactionTask 
 while ( nni . hasNext ( ) ) 
 { 
 AbstractCompactedRow row = nni . next ( ) ; 
 + if ( row . isEmpty ( ) ) 
 + continue ; 
 + 
 long position = writer . append ( row ) ; 
 totalkeysWritten + + ; 
 
 diff - - git a / src / java / org / apache / cassandra / service / GCInspector . java b / src / java / org / apache / cassandra / service / GCInspector . java 
 index 3a08eef . . d66eb94 100644 
 - - - a / src / java / org / apache / cassandra / service / GCInspector . java 
 + + + b / src / java / org / apache / cassandra / service / GCInspector . java 
 @ @ - 20 , 11 + 20 , 13 @ @ package org . apache . cassandra . service ; 
 * 
 * / 
 
 + import java . lang . management . GarbageCollectorMXBean ; 
 import java . lang . management . ManagementFactory ; 
 + import java . lang . management . MemoryMXBean ; 
 import java . lang . management . MemoryUsage ; 
 - import java . lang . reflect . InvocationTargetException ; 
 - import java . lang . reflect . Method ; 
 - import java . util . * ; 
 + import java . util . ArrayList ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 import java . util . concurrent . TimeUnit ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 @ @ - 46 , 32 + 48 , 22 @ @ public class GCInspector 
 public static final GCInspector instance = new GCInspector ( ) ; 
 
 private HashMap < String , Long > gctimes = new HashMap < String , Long > ( ) ; 
 + private HashMap < String , Long > gccounts = new HashMap < String , Long > ( ) ; 
 + 
 + List < GarbageCollectorMXBean > beans = new ArrayList < GarbageCollectorMXBean > ( ) ; 
 + MemoryMXBean membean = ManagementFactory . getMemoryMXBean ( ) ; 
 
 - List < Object > beans = new ArrayList < Object > ( ) ; / / these are instances of com . sun . management . GarbageCollectorMXBean 
 private volatile boolean cacheSizesReduced ; 
 
 public GCInspector ( ) 
 { 
 - / / we only want this class to do its thing on sun jdks , or when the sun classes are present . 
 - Class gcBeanClass = null ; 
 - try 
 - { 
 - gcBeanClass = Class . forName ( " com . sun . management . GarbageCollectorMXBean " ) ; 
 - Class . forName ( " com . sun . management . GcInfo " ) ; 
 - } 
 - catch ( ClassNotFoundException ex ) 
 - { 
 - / / this happens when using a non - sun jdk . 
 - logger . warn ( " Cannot load sun GC monitoring classes . GCInspector is disabled . " ) ; 
 - } 
 - 
 MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; 
 try 
 { 
 ObjectName gcName = new ObjectName ( ManagementFactory . GARBAGE _ COLLECTOR _ MXBEAN _ DOMAIN _ TYPE + " , * " ) ; 
 for ( ObjectName name : server . queryNames ( gcName , null ) ) 
 { 
 - Object gc = ManagementFactory . newPlatformMXBeanProxy ( server , name . getCanonicalName ( ) , gcBeanClass ) ; 
 + GarbageCollectorMXBean gc = ManagementFactory . newPlatformMXBeanProxy ( server , name . getCanonicalName ( ) , GarbageCollectorMXBean . class ) ; 
 beans . add ( gc ) ; 
 } 
 } 
 @ @ - 98 , 43 + 90 , 42 @ @ public class GCInspector 
 
 private void logGCResults ( ) 
 { 
 - for ( Object gc : beans ) 
 + for ( GarbageCollectorMXBean gc : beans ) 
 { 
 - SunGcWrapper gcw = new SunGcWrapper ( gc ) ; 
 - if ( gcw . isLastGcInfoNull ( ) ) 
 + Long previousTotal = gctimes . get ( gc . getName ( ) ) ; 
 + Long total = gc . getCollectionTime ( ) ; 
 + if ( previousTotal = = null ) 
 + previousTotal = 0L ; 
 + if ( previousTotal . equals ( total ) ) 
 continue ; 
 - 
 - Long previous = gctimes . get ( gcw . getName ( ) ) ; 
 - if ( previous ! = null & & previous . longValue ( ) = = gcw . getCollectionTime ( ) . longValue ( ) ) 
 - continue ; 
 - gctimes . put ( gcw . getName ( ) , gcw . getCollectionTime ( ) ) ; 
 - 
 - long previousMemoryUsed = 0 ; 
 - long memoryUsed = 0 ; 
 - long memoryMax = 0 ; 
 - for ( Map . Entry < String , MemoryUsage > entry : gcw . getMemoryUsageBeforeGc ( ) . entrySet ( ) ) 
 - { 
 - previousMemoryUsed + = entry . getValue ( ) . getUsed ( ) ; 
 - } 
 - for ( Map . Entry < String , MemoryUsage > entry : gcw . getMemoryUsageAfterGc ( ) . entrySet ( ) ) 
 - { 
 - MemoryUsage mu = entry . getValue ( ) ; 
 - memoryUsed + = mu . getUsed ( ) ; 
 - memoryMax + = mu . getMax ( ) ; 
 - } 
 - 
 - String st = String . format ( " GC for % s : % s ms , % s reclaimed leaving % s used ; max is % s " , 
 - gcw . getName ( ) , gcw . getDuration ( ) , previousMemoryUsed - memoryUsed , memoryUsed , memoryMax ) ; 
 - if ( gcw . getDuration ( ) > MIN _ DURATION ) 
 + gctimes . put ( gc . getName ( ) , total ) ; 
 + Long duration = total - previousTotal ; 
 + assert duration > 0 ; 
 + 
 + Long previousCount = gccounts . get ( gc . getName ( ) ) ; 
 + Long count = gc . getCollectionCount ( ) ; 
 + if ( previousCount = = null ) 
 + previousCount = 0L ; 
 + gccounts . put ( gc . getName ( ) , count ) ; 
 + assert count > previousCount ; 
 + 
 + MemoryUsage mu = membean . getHeapMemoryUsage ( ) ; 
 + long memoryUsed = mu . getUsed ( ) ; 
 + long memoryMax = mu . getMax ( ) ; 
 + 
 + String st = String . format ( " GC for % s : % s ms for % s collections , % s used ; max is % s " , 
 + gc . getName ( ) , duration , count - previousCount , memoryUsed , memoryMax ) ; 
 + long durationPerCollection = duration / ( count - previousCount ) ; 
 + if ( durationPerCollection > MIN _ DURATION ) 
 logger . info ( st ) ; 
 else if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( st ) ; 
 
 - if ( gcw . getDuration ( ) > MIN _ DURATION _ TPSTATS ) 
 + if ( durationPerCollection > MIN _ DURATION _ TPSTATS ) 
 StatusLogger . log ( ) ; 
 
 / / if we just finished a full collection and we ' re still using a lot of memory , try to reduce the pressure 
 - if ( gcw . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) 
 + if ( gc . getName ( ) . equals ( " ConcurrentMarkSweep " ) ) 
 { 
 SSTableDeletingTask . rescheduleFailedTasks ( ) ; 
 
 @ @ - 155 , 82 + 146 , 4 @ @ public class GCInspector 
 } 
 } 
 } 
 - 
 - / / wrapper for sun class . this enables other jdks to compile this class . 
 - private static final class SunGcWrapper 
 - { 
 - 
 - private Map < String , MemoryUsage > usageBeforeGc = null ; 
 - private Map < String , MemoryUsage > usageAfterGc = null ; 
 - private String name ; 
 - private Long collectionTime ; 
 - private Long duration ; 
 - 
 - SunGcWrapper ( Object gcMxBean ) 
 - { 
 - / / if we ' ve gotten this far , we ' ve already verified that the right classes are in the CP . Now we just 
 - / / need to check for boneheadedness . 
 - / / grab everything we need here so that we don ' t have to deal with try / catch everywhere . 
 - try 
 - { 
 - assert Class . forName ( " com . sun . management . GarbageCollectorMXBean " ) . isAssignableFrom ( gcMxBean . getClass ( ) ) ; 
 - Method getGcInfo = gcMxBean . getClass ( ) . getDeclaredMethod ( " getLastGcInfo " ) ; 
 - Object lastGcInfo = getGcInfo . invoke ( gcMxBean ) ; 
 - if ( lastGcInfo ! = null ) 
 - { 
 - usageBeforeGc = ( Map < String , MemoryUsage > ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getMemoryUsageBeforeGc " ) . invoke ( lastGcInfo ) ; 
 - usageAfterGc = ( Map < String , MemoryUsage > ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getMemoryUsageAfterGc " ) . invoke ( lastGcInfo ) ; 
 - duration = ( Long ) lastGcInfo . getClass ( ) . getDeclaredMethod ( " getDuration " ) . invoke ( lastGcInfo ) ; 
 - name = ( String ) gcMxBean . getClass ( ) . getDeclaredMethod ( " getName " ) . invoke ( gcMxBean ) ; 
 - collectionTime = ( Long ) gcMxBean . getClass ( ) . getDeclaredMethod ( " getCollectionTime " ) . invoke ( gcMxBean ) ; 
 - } 
 - } 
 - catch ( ClassNotFoundException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - catch ( NoSuchMethodException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - catch ( IllegalAccessException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - catch ( InvocationTargetException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - } 
 - 
 - String getName ( ) 
 - { 
 - return name ; 
 - } 
 - 
 - Long getCollectionTime ( ) 
 - { 
 - return collectionTime ; 
 - } 
 - 
 - Long getDuration ( ) 
 - { 
 - return duration ; 
 - } 
 - 
 - Map < String , MemoryUsage > getMemoryUsageAfterGc ( ) 
 - { 
 - return usageAfterGc ; 
 - } 
 - 
 - Map < String , MemoryUsage > getMemoryUsageBeforeGc ( ) 
 - { 
 - return usageBeforeGc ; 
 - } 
 - 
 - boolean isLastGcInfoNull ( ) 
 - { 
 - return usageBeforeGc = = null ; 
 - } 
 - } 
 }
