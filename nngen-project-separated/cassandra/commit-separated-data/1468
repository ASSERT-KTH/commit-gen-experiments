BLEU SCORE: 0.08116697886877475

TEST MSG: Ninja fixup for KeyspaceTest . testGetSliceFromLarge
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java b / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java <nl> index 4a35e80 . . fe8d1f0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java <nl> @ @ - 417 , 7 + 417 , 7 @ @ abstract class AbstractSSTableIterator implements SliceableUnfilteredRowIterator <nl> private final List < IndexHelper . IndexInfo > indexes ; <nl> private final boolean reversed ; <nl> <nl> - private int currentIndexIdx = - 1 ; <nl> + private int currentIndexIdx ; <nl> <nl> / / Marks the beginning of the block corresponding to currentIndexIdx . <nl> private FileMark mark ; <nl> @ @ - 469 , 16 + 469 , 22 @ @ abstract class AbstractSSTableIterator implements SliceableUnfilteredRowIterator <nl> return indexes . get ( currentIndexIdx ) ; <nl> } <nl> <nl> - / / Finds the index of the first block containing the provided bound , starting at the current index . <nl> + / / Finds the index of the first block containing the provided bound , starting at the provided index . <nl> / / Will be - 1 if the bound is before any block , and blocksCount ( ) if it is after every block . <nl> - public int findBlockIndex ( Slice . Bound bound ) <nl> + public int findBlockIndex ( Slice . Bound bound , int fromIdx ) <nl> { <nl> if ( bound = = Slice . Bound . BOTTOM ) <nl> return - 1 ; <nl> if ( bound = = Slice . Bound . TOP ) <nl> return blocksCount ( ) ; <nl> <nl> - return IndexHelper . indexFor ( bound , indexes , comparator , reversed , currentIndexIdx ) ; <nl> + return IndexHelper . indexFor ( bound , indexes , comparator , reversed , fromIdx ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return String . format ( " IndexState ( indexSize = % d , currentBlock = % d , reversed = % b ) " , indexes . size ( ) , currentIndexIdx , reversed ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java <nl> index 64d33dc . . e985c18 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java <nl> @ @ - 217 , 28 + 217 , 41 @ @ public class SSTableIterator extends AbstractSSTableIterator <nl> } <nl> <nl> / / Find the first index block we ' ll need to read for the slice . <nl> - int startIdx = indexState . findBlockIndex ( slice . start ( ) ) ; <nl> + int startIdx = indexState . findBlockIndex ( slice . start ( ) , indexState . currentBlockIdx ( ) ) ; <nl> if ( startIdx > = indexState . blocksCount ( ) ) <nl> { <nl> sliceDone = true ; <nl> return ; <nl> } <nl> <nl> + / / Find the last index block we ' ll need to read for the slice . <nl> + lastBlockIdx = indexState . findBlockIndex ( slice . end ( ) , startIdx ) ; <nl> + <nl> + / / If the slice end is before the very first block , we have nothing for that slice <nl> + if ( lastBlockIdx < 0 ) <nl> + { <nl> + assert startIdx < 0 ; <nl> + sliceDone = true ; <nl> + return ; <nl> + } <nl> + <nl> + / / If we start before the very first block , just read from the first one . <nl> + if ( startIdx < 0 ) <nl> + startIdx = 0 ; <nl> + <nl> / / If that ' s the last block we were reading , we ' re already where we want to be . Otherwise , <nl> / / seek to that first block <nl> if ( startIdx ! = indexState . currentBlockIdx ( ) ) <nl> indexState . setToBlock ( startIdx ) ; <nl> <nl> - / / Find the last index block we ' ll need to read for the slice . <nl> - lastBlockIdx = indexState . findBlockIndex ( slice . end ( ) ) ; <nl> - <nl> / / The index search is based on the last name of the index blocks , so at that point we have that : <nl> / / 1 ) indexes [ currentIdx - 1 ] . lastName < slice . start < = indexes [ currentIdx ] . lastName <nl> / / 2 ) indexes [ lastBlockIdx - 1 ] . lastName < slice . end < = indexes [ lastBlockIdx ] . lastName <nl> / / so if currentIdx = = lastBlockIdx and slice . end < indexes [ currentIdx ] . firstName , we ' re guaranteed that the <nl> / / whole slice is between the previous block end and this block start , and thus has no corresponding <nl> / / data . One exception is if the previous block ends with an openMarker as it will cover our slice <nl> - / / and we need to return it . <nl> + / / and we need to return it ( we also don ' t skip the slice for the old format because we didn ' t have the openMarker <nl> + / / info in that case and can ' t rely on this optimization ) . <nl> if ( indexState . currentBlockIdx ( ) = = lastBlockIdx <nl> & & metadata ( ) . comparator . compare ( slice . end ( ) , indexState . currentIndex ( ) . firstName ) < 0 <nl> & & openMarker = = null <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java <nl> index e15d330 . . 4082874 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java <nl> @ @ - 213 , 9 + 213 , 8 @ @ public class SSTableReversedIterator extends AbstractSSTableIterator <nl> <nl> protected void init ( ) throws IOException <nl> { <nl> - / / If this is called , it means we ' re calling hasNext ( ) before any call to setForSlice . Which means <nl> - / / we ' re reading everything from the end . So just set us up on the last block . <nl> - indexState . setToBlock ( indexState . blocksCount ( ) - 1 ) ; <nl> + / / This is actually a no - op , because if we call hasNext without having called setForSlice , then ReverseReader . hasNextInternal <nl> + / / will call setForSlice ( Slice . ALL ) which does the right thing . <nl> } <nl> <nl> @ Override <nl> @ @ - 232 , 21 + 231 , 32 @ @ public class SSTableReversedIterator extends AbstractSSTableIterator <nl> } <nl> <nl> / / Find the first index block we ' ll need to read for the slice . <nl> - int startIdx = indexState . findBlockIndex ( slice . end ( ) ) ; <nl> + int startIdx = indexState . findBlockIndex ( slice . end ( ) , indexState . currentBlockIdx ( ) ) ; <nl> if ( startIdx < 0 ) <nl> { <nl> iterator = Collections . emptyIterator ( ) ; <nl> return ; <nl> } <nl> <nl> - boolean isCurrentBlock = startIdx = = indexState . currentBlockIdx ( ) ; <nl> - if ( ! isCurrentBlock ) <nl> - indexState . setToBlock ( startIdx ) ; <nl> + lastBlockIdx = indexState . findBlockIndex ( slice . start ( ) , startIdx ) ; <nl> <nl> - lastBlockIdx = indexState . findBlockIndex ( slice . start ( ) ) ; <nl> + / / If the last block to look ( in reverse order ) is after the very last block , we have nothing for that slice <nl> + if ( lastBlockIdx > = indexState . blocksCount ( ) ) <nl> + { <nl> + assert startIdx > = indexState . blocksCount ( ) ; <nl> + iterator = Collections . emptyIterator ( ) ; <nl> + return ; <nl> + } <nl> <nl> - if ( ! isCurrentBlock ) <nl> + / / If we start ( in reverse order ) after the very last block , just read from the last one . <nl> + if ( startIdx > = indexState . blocksCount ( ) ) <nl> + startIdx = indexState . blocksCount ( ) - 1 ; <nl> + <nl> + if ( startIdx ! = indexState . currentBlockIdx ( ) ) <nl> + { <nl> + indexState . setToBlock ( startIdx ) ; <nl> readCurrentBlock ( true ) ; <nl> + } <nl> <nl> setIterator ( slice ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java b / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java 
 index 4a35e80 . . fe8d1f0 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / AbstractSSTableIterator . java 
 @ @ - 417 , 7 + 417 , 7 @ @ abstract class AbstractSSTableIterator implements SliceableUnfilteredRowIterator 
 private final List < IndexHelper . IndexInfo > indexes ; 
 private final boolean reversed ; 
 
 - private int currentIndexIdx = - 1 ; 
 + private int currentIndexIdx ; 
 
 / / Marks the beginning of the block corresponding to currentIndexIdx . 
 private FileMark mark ; 
 @ @ - 469 , 16 + 469 , 22 @ @ abstract class AbstractSSTableIterator implements SliceableUnfilteredRowIterator 
 return indexes . get ( currentIndexIdx ) ; 
 } 
 
 - / / Finds the index of the first block containing the provided bound , starting at the current index . 
 + / / Finds the index of the first block containing the provided bound , starting at the provided index . 
 / / Will be - 1 if the bound is before any block , and blocksCount ( ) if it is after every block . 
 - public int findBlockIndex ( Slice . Bound bound ) 
 + public int findBlockIndex ( Slice . Bound bound , int fromIdx ) 
 { 
 if ( bound = = Slice . Bound . BOTTOM ) 
 return - 1 ; 
 if ( bound = = Slice . Bound . TOP ) 
 return blocksCount ( ) ; 
 
 - return IndexHelper . indexFor ( bound , indexes , comparator , reversed , currentIndexIdx ) ; 
 + return IndexHelper . indexFor ( bound , indexes , comparator , reversed , fromIdx ) ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return String . format ( " IndexState ( indexSize = % d , currentBlock = % d , reversed = % b ) " , indexes . size ( ) , currentIndexIdx , reversed ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java 
 index 64d33dc . . e985c18 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableIterator . java 
 @ @ - 217 , 28 + 217 , 41 @ @ public class SSTableIterator extends AbstractSSTableIterator 
 } 
 
 / / Find the first index block we ' ll need to read for the slice . 
 - int startIdx = indexState . findBlockIndex ( slice . start ( ) ) ; 
 + int startIdx = indexState . findBlockIndex ( slice . start ( ) , indexState . currentBlockIdx ( ) ) ; 
 if ( startIdx > = indexState . blocksCount ( ) ) 
 { 
 sliceDone = true ; 
 return ; 
 } 
 
 + / / Find the last index block we ' ll need to read for the slice . 
 + lastBlockIdx = indexState . findBlockIndex ( slice . end ( ) , startIdx ) ; 
 + 
 + / / If the slice end is before the very first block , we have nothing for that slice 
 + if ( lastBlockIdx < 0 ) 
 + { 
 + assert startIdx < 0 ; 
 + sliceDone = true ; 
 + return ; 
 + } 
 + 
 + / / If we start before the very first block , just read from the first one . 
 + if ( startIdx < 0 ) 
 + startIdx = 0 ; 
 + 
 / / If that ' s the last block we were reading , we ' re already where we want to be . Otherwise , 
 / / seek to that first block 
 if ( startIdx ! = indexState . currentBlockIdx ( ) ) 
 indexState . setToBlock ( startIdx ) ; 
 
 - / / Find the last index block we ' ll need to read for the slice . 
 - lastBlockIdx = indexState . findBlockIndex ( slice . end ( ) ) ; 
 - 
 / / The index search is based on the last name of the index blocks , so at that point we have that : 
 / / 1 ) indexes [ currentIdx - 1 ] . lastName < slice . start < = indexes [ currentIdx ] . lastName 
 / / 2 ) indexes [ lastBlockIdx - 1 ] . lastName < slice . end < = indexes [ lastBlockIdx ] . lastName 
 / / so if currentIdx = = lastBlockIdx and slice . end < indexes [ currentIdx ] . firstName , we ' re guaranteed that the 
 / / whole slice is between the previous block end and this block start , and thus has no corresponding 
 / / data . One exception is if the previous block ends with an openMarker as it will cover our slice 
 - / / and we need to return it . 
 + / / and we need to return it ( we also don ' t skip the slice for the old format because we didn ' t have the openMarker 
 + / / info in that case and can ' t rely on this optimization ) . 
 if ( indexState . currentBlockIdx ( ) = = lastBlockIdx 
 & & metadata ( ) . comparator . compare ( slice . end ( ) , indexState . currentIndex ( ) . firstName ) < 0 
 & & openMarker = = null 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java b / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java 
 index e15d330 . . 4082874 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / SSTableReversedIterator . java 
 @ @ - 213 , 9 + 213 , 8 @ @ public class SSTableReversedIterator extends AbstractSSTableIterator 
 
 protected void init ( ) throws IOException 
 { 
 - / / If this is called , it means we ' re calling hasNext ( ) before any call to setForSlice . Which means 
 - / / we ' re reading everything from the end . So just set us up on the last block . 
 - indexState . setToBlock ( indexState . blocksCount ( ) - 1 ) ; 
 + / / This is actually a no - op , because if we call hasNext without having called setForSlice , then ReverseReader . hasNextInternal 
 + / / will call setForSlice ( Slice . ALL ) which does the right thing . 
 } 
 
 @ Override 
 @ @ - 232 , 21 + 231 , 32 @ @ public class SSTableReversedIterator extends AbstractSSTableIterator 
 } 
 
 / / Find the first index block we ' ll need to read for the slice . 
 - int startIdx = indexState . findBlockIndex ( slice . end ( ) ) ; 
 + int startIdx = indexState . findBlockIndex ( slice . end ( ) , indexState . currentBlockIdx ( ) ) ; 
 if ( startIdx < 0 ) 
 { 
 iterator = Collections . emptyIterator ( ) ; 
 return ; 
 } 
 
 - boolean isCurrentBlock = startIdx = = indexState . currentBlockIdx ( ) ; 
 - if ( ! isCurrentBlock ) 
 - indexState . setToBlock ( startIdx ) ; 
 + lastBlockIdx = indexState . findBlockIndex ( slice . start ( ) , startIdx ) ; 
 
 - lastBlockIdx = indexState . findBlockIndex ( slice . start ( ) ) ; 
 + / / If the last block to look ( in reverse order ) is after the very last block , we have nothing for that slice 
 + if ( lastBlockIdx > = indexState . blocksCount ( ) ) 
 + { 
 + assert startIdx > = indexState . blocksCount ( ) ; 
 + iterator = Collections . emptyIterator ( ) ; 
 + return ; 
 + } 
 
 - if ( ! isCurrentBlock ) 
 + / / If we start ( in reverse order ) after the very last block , just read from the last one . 
 + if ( startIdx > = indexState . blocksCount ( ) ) 
 + startIdx = indexState . blocksCount ( ) - 1 ; 
 + 
 + if ( startIdx ! = indexState . currentBlockIdx ( ) ) 
 + { 
 + indexState . setToBlock ( startIdx ) ; 
 readCurrentBlock ( true ) ; 
 + } 
 
 setIterator ( slice ) ; 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
