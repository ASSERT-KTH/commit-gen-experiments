BLEU SCORE: 1.0

TEST MSG: include missing files
GENERATED MSG: include missing files

TEST DIFF (one line): diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java b / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java <nl> new file mode 100644 <nl> index 0000000 . . ab89d07 <nl> - - - / dev / null <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java <nl> @ @ - 0 , 0 + 1 , 139 @ @ <nl> + package org . apache . cassandra . stress . util ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . Map ; <nl> + import java . util . TreeMap ; <nl> + <nl> + public class TimingIntervals <nl> + { <nl> + final Map < String , TimingInterval > intervals ; <nl> + TimingIntervals ( Iterable < String > opTypes ) <nl> + { <nl> + long now = System . nanoTime ( ) ; <nl> + intervals = new TreeMap < > ( ) ; <nl> + for ( String opType : opTypes ) <nl> + intervals . put ( opType , new TimingInterval ( now ) ) ; <nl> + } <nl> + <nl> + TimingIntervals ( Map < String , TimingInterval > intervals ) <nl> + { <nl> + this . intervals = intervals ; <nl> + } <nl> + <nl> + public TimingIntervals merge ( TimingIntervals with , int maxSamples , long start ) <nl> + { <nl> + assert intervals . size ( ) = = with . intervals . size ( ) ; <nl> + TreeMap < String , TimingInterval > ret = new TreeMap < > ( ) ; <nl> + <nl> + for ( String opType : intervals . keySet ( ) ) <nl> + { <nl> + assert with . intervals . containsKey ( opType ) ; <nl> + ret . put ( opType , TimingInterval . merge ( Arrays . asList ( intervals . get ( opType ) , with . intervals . get ( opType ) ) , maxSamples , start ) ) ; <nl> + } <nl> + <nl> + return new TimingIntervals ( ret ) ; <nl> + } <nl> + <nl> + public TimingInterval get ( String opType ) <nl> + { <nl> + return intervals . get ( opType ) ; <nl> + } <nl> + <nl> + public TimingInterval combine ( int maxSamples ) <nl> + { <nl> + long start = Long . MAX _ VALUE ; <nl> + for ( TimingInterval ti : intervals . values ( ) ) <nl> + start = Math . min ( start , ti . startNanos ( ) ) ; <nl> + <nl> + return TimingInterval . merge ( intervals . values ( ) , maxSamples , start ) ; <nl> + } <nl> + <nl> + public String str ( TimingInterval . TimingParameter value ) <nl> + { <nl> + return str ( value , Float . NaN ) ; <nl> + } <nl> + <nl> + public String str ( TimingInterval . TimingParameter value , float rank ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( " [ " ) ; <nl> + <nl> + for ( Map . Entry < String , TimingInterval > entry : intervals . entrySet ( ) ) <nl> + { <nl> + sb . append ( entry . getKey ( ) ) ; <nl> + sb . append ( " : " ) ; <nl> + sb . append ( entry . getValue ( ) . getStringValue ( value , rank ) ) ; <nl> + sb . append ( " , " ) ; <nl> + } <nl> + <nl> + sb . setLength ( sb . length ( ) - 2 ) ; <nl> + sb . append ( " ] " ) ; <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> + public String opRates ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . OPRATE ) ; <nl> + } <nl> + public String partitionRates ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . PARTITIONRATE ) ; <nl> + } <nl> + public String rowRates ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . ROWRATE ) ; <nl> + } <nl> + public String meanLatencies ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . MEANLATENCY ) ; <nl> + } <nl> + public String maxLatencies ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . MAXLATENCY ) ; <nl> + } <nl> + public String medianLatencies ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . MEDIANLATENCY ) ; <nl> + } <nl> + public String rankLatencies ( float rank ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . MEDIANLATENCY , rank ) ; <nl> + } <nl> + public String errorCounts ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . ERRORCOUNT ) ; <nl> + } <nl> + public String partitionCounts ( ) <nl> + { <nl> + return str ( TimingInterval . TimingParameter . PARTITIONCOUNT ) ; <nl> + } <nl> + <nl> + public long opRate ( ) <nl> + { <nl> + long v = 0 ; <nl> + for ( TimingInterval interval : intervals . values ( ) ) <nl> + v + = interval . opRate ( ) ; <nl> + return v ; <nl> + } <nl> + <nl> + public long startNanos ( ) <nl> + { <nl> + long start = Long . MAX _ VALUE ; <nl> + for ( TimingInterval interval : intervals . values ( ) ) <nl> + start = Math . min ( start , interval . startNanos ( ) ) ; <nl> + return start ; <nl> + } <nl> + <nl> + public long endNanos ( ) <nl> + { <nl> + long end = Long . MIN _ VALUE ; <nl> + for ( TimingInterval interval : intervals . values ( ) ) <nl> + end = Math . max ( end , interval . startNanos ( ) ) ; <nl> + return end ; <nl> + } <nl> + <nl> + public Map < String , TimingInterval > intervals ( ) <nl> + { <nl> + return intervals ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java b / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java 
 new file mode 100644 
 index 0000000 . . ab89d07 
 - - - / dev / null 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / TimingIntervals . java 
 @ @ - 0 , 0 + 1 , 139 @ @ 
 + package org . apache . cassandra . stress . util ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . Map ; 
 + import java . util . TreeMap ; 
 + 
 + public class TimingIntervals 
 + { 
 + final Map < String , TimingInterval > intervals ; 
 + TimingIntervals ( Iterable < String > opTypes ) 
 + { 
 + long now = System . nanoTime ( ) ; 
 + intervals = new TreeMap < > ( ) ; 
 + for ( String opType : opTypes ) 
 + intervals . put ( opType , new TimingInterval ( now ) ) ; 
 + } 
 + 
 + TimingIntervals ( Map < String , TimingInterval > intervals ) 
 + { 
 + this . intervals = intervals ; 
 + } 
 + 
 + public TimingIntervals merge ( TimingIntervals with , int maxSamples , long start ) 
 + { 
 + assert intervals . size ( ) = = with . intervals . size ( ) ; 
 + TreeMap < String , TimingInterval > ret = new TreeMap < > ( ) ; 
 + 
 + for ( String opType : intervals . keySet ( ) ) 
 + { 
 + assert with . intervals . containsKey ( opType ) ; 
 + ret . put ( opType , TimingInterval . merge ( Arrays . asList ( intervals . get ( opType ) , with . intervals . get ( opType ) ) , maxSamples , start ) ) ; 
 + } 
 + 
 + return new TimingIntervals ( ret ) ; 
 + } 
 + 
 + public TimingInterval get ( String opType ) 
 + { 
 + return intervals . get ( opType ) ; 
 + } 
 + 
 + public TimingInterval combine ( int maxSamples ) 
 + { 
 + long start = Long . MAX _ VALUE ; 
 + for ( TimingInterval ti : intervals . values ( ) ) 
 + start = Math . min ( start , ti . startNanos ( ) ) ; 
 + 
 + return TimingInterval . merge ( intervals . values ( ) , maxSamples , start ) ; 
 + } 
 + 
 + public String str ( TimingInterval . TimingParameter value ) 
 + { 
 + return str ( value , Float . NaN ) ; 
 + } 
 + 
 + public String str ( TimingInterval . TimingParameter value , float rank ) 
 + { 
 + StringBuilder sb = new StringBuilder ( " [ " ) ; 
 + 
 + for ( Map . Entry < String , TimingInterval > entry : intervals . entrySet ( ) ) 
 + { 
 + sb . append ( entry . getKey ( ) ) ; 
 + sb . append ( " : " ) ; 
 + sb . append ( entry . getValue ( ) . getStringValue ( value , rank ) ) ; 
 + sb . append ( " , " ) ; 
 + } 
 + 
 + sb . setLength ( sb . length ( ) - 2 ) ; 
 + sb . append ( " ] " ) ; 
 + 
 + return sb . toString ( ) ; 
 + } 
 + 
 + public String opRates ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . OPRATE ) ; 
 + } 
 + public String partitionRates ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . PARTITIONRATE ) ; 
 + } 
 + public String rowRates ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . ROWRATE ) ; 
 + } 
 + public String meanLatencies ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . MEANLATENCY ) ; 
 + } 
 + public String maxLatencies ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . MAXLATENCY ) ; 
 + } 
 + public String medianLatencies ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . MEDIANLATENCY ) ; 
 + } 
 + public String rankLatencies ( float rank ) 
 + { 
 + return str ( TimingInterval . TimingParameter . MEDIANLATENCY , rank ) ; 
 + } 
 + public String errorCounts ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . ERRORCOUNT ) ; 
 + } 
 + public String partitionCounts ( ) 
 + { 
 + return str ( TimingInterval . TimingParameter . PARTITIONCOUNT ) ; 
 + } 
 + 
 + public long opRate ( ) 
 + { 
 + long v = 0 ; 
 + for ( TimingInterval interval : intervals . values ( ) ) 
 + v + = interval . opRate ( ) ; 
 + return v ; 
 + } 
 + 
 + public long startNanos ( ) 
 + { 
 + long start = Long . MAX _ VALUE ; 
 + for ( TimingInterval interval : intervals . values ( ) ) 
 + start = Math . min ( start , interval . startNanos ( ) ) ; 
 + return start ; 
 + } 
 + 
 + public long endNanos ( ) 
 + { 
 + long end = Long . MIN _ VALUE ; 
 + for ( TimingInterval interval : intervals . values ( ) ) 
 + end = Math . max ( end , interval . startNanos ( ) ) ; 
 + return end ; 
 + } 
 + 
 + public Map < String , TimingInterval > intervals ( ) 
 + { 
 + return intervals ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
