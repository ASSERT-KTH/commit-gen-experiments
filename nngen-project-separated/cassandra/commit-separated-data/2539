BLEU SCORE: 0.014929831413909562

TEST MSG: Fix CFMetaData # getColumnDefinitionFromColumnName ( )
GENERATED MSG: fix potential use of free ' d native memory interface / SerializingCache

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 69e9d37 . . b3470bf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * Require nodetool rebuild _ index to specify index names ( CASSANDRA - 7038 ) <nl> * Ensure that batchlog and hint timeouts do not produce hints ( CASSANDRA - 7058 ) <nl> * Don ' t shut MessagingService down when replacing a node ( CASSANDRA - 6476 ) <nl> + * Always clean up references in SerializingCache ( CASSANDRA - 6994 ) <nl> <nl> <nl> 1 . 2 . 16 <nl> diff - - git a / src / java / org / apache / cassandra / cache / SerializingCache . java b / src / java / org / apache / cassandra / cache / SerializingCache . java <nl> index c7430d2 . . 58da56b 100644 <nl> - - - a / src / java / org / apache / cassandra / cache / SerializingCache . java <nl> + + + b / src / java / org / apache / cassandra / cache / SerializingCache . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . cache ; <nl> import java . io . IOException ; <nl> import java . util . Set ; <nl> <nl> + import com . google . common . base . Throwables ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 92 , 7 + 93 , 7 @ @ public class SerializingCache < K , V > implements ICache < K , V > <nl> } <nl> catch ( IOException e ) <nl> { <nl> - logger . debug ( " Cannot fetch in memory data , we will failback to read from disk " , e ) ; <nl> + logger . debug ( " Cannot fetch in memory data , we will fallback to read from disk " , e ) ; <nl> return null ; <nl> } <nl> } <nl> @ @ - 119 , 6 + 120 , 7 @ @ public class SerializingCache < K , V > implements ICache < K , V > <nl> } <nl> catch ( IOException e ) <nl> { <nl> + freeableMemory . unreference ( ) ; <nl> throw new RuntimeException ( e ) ; <nl> } <nl> return freeableMemory ; <nl> @ @ - 177 , 7 + 179 , 17 @ @ public class SerializingCache < K , V > implements ICache < K , V > <nl> if ( mem = = null ) <nl> return ; / / out of memory . never mind . <nl> <nl> - RefCountedMemory old = map . put ( key , mem ) ; <nl> + RefCountedMemory old ; <nl> + try <nl> + { <nl> + old = map . put ( key , mem ) ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + mem . unreference ( ) ; <nl> + throw Throwables . propagate ( t ) ; <nl> + } <nl> + <nl> if ( old ! = null ) <nl> old . unreference ( ) ; <nl> } <nl> @ @ - 188 , 7 + 200 , 17 @ @ public class SerializingCache < K , V > implements ICache < K , V > <nl> if ( mem = = null ) <nl> return false ; / / out of memory . never mind . <nl> <nl> - RefCountedMemory old = map . putIfAbsent ( key , mem ) ; <nl> + RefCountedMemory old ; <nl> + try <nl> + { <nl> + old = map . putIfAbsent ( key , mem ) ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + mem . unreference ( ) ; <nl> + throw Throwables . propagate ( t ) ; <nl> + } <nl> + <nl> if ( old ! = null ) <nl> / / the new value was not put , we ' ve uselessly allocated some memory , free it <nl> mem . unreference ( ) ; <nl> @ @ - 202 , 24 + 224 , 32 @ @ public class SerializingCache < K , V > implements ICache < K , V > <nl> if ( old = = null ) <nl> return false ; <nl> <nl> + V oldValue ; <nl> + / / reference old guy before de - serializing <nl> + if ( ! old . reference ( ) ) <nl> + return false ; / / we have already freed hence noop . <nl> + <nl> + oldValue = deserialize ( old ) ; <nl> + old . unreference ( ) ; <nl> + <nl> + if ( ! oldValue . equals ( oldToReplace ) ) <nl> + return false ; <nl> + <nl> / / see if the old value matches the one we want to replace <nl> RefCountedMemory mem = serialize ( value ) ; <nl> if ( mem = = null ) <nl> return false ; / / out of memory . never mind . <nl> <nl> - V oldValue ; <nl> - / / reference old guy before de - serializing <nl> - if ( ! old . reference ( ) ) <nl> - return false ; / / we have already freed hence noop . <nl> + boolean success ; <nl> try <nl> { <nl> - oldValue = deserialize ( old ) ; <nl> + success = map . replace ( key , old , mem ) ; <nl> } <nl> - finally <nl> + catch ( Throwable t ) <nl> { <nl> - old . unreference ( ) ; <nl> + mem . unreference ( ) ; <nl> + throw Throwables . propagate ( t ) ; <nl> } <nl> - boolean success = oldValue . equals ( oldToReplace ) & & map . replace ( key , old , mem ) ; <nl> <nl> if ( success ) <nl> old . unreference ( ) ; / / so it will be eventually be cleaned
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index b8eefed . . dc59662 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 981 , 6 + 981 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener <nl> EndpointState epState = endpointStateMap . get ( FBUtilities . getLocalAddress ( ) ) ; <nl> assert epState ! = null ; <nl> epState . addApplicationState ( state , value ) ; <nl> + doNotifications ( FBUtilities . getLocalAddress ( ) , state , value ) ; <nl> } <nl> <nl> public void stop ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 4701cfc . . 78ad474 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 1913 , 7 + 1913 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> <nl> / / ring ranges and endpoints associated with them <nl> / / this used to determine what nodes should we ping about range data <nl> - Multimap < Range , InetAddress > rangeAddresses = strategy . getRangeAddresses ( tokenMetaClone ) ; <nl> + Multimap < Range , InetAddress > rangeAddresses = strategy . getRangeAddresses ( tokenMetadata _ ) ; <nl> <nl> / / calculated parts of the ranges to request / stream from / to nodes in the ring <nl> Pair < Set < Range > , Set < Range > > rangesPerTable = calculateStreamAndFetchRanges ( currentRanges , updatedRanges ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 69e9d37 . . b3470bf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * Require nodetool rebuild _ index to specify index names ( CASSANDRA - 7038 ) 
 * Ensure that batchlog and hint timeouts do not produce hints ( CASSANDRA - 7058 ) 
 * Don ' t shut MessagingService down when replacing a node ( CASSANDRA - 6476 ) 
 + * Always clean up references in SerializingCache ( CASSANDRA - 6994 ) 
 
 
 1 . 2 . 16 
 diff - - git a / src / java / org / apache / cassandra / cache / SerializingCache . java b / src / java / org / apache / cassandra / cache / SerializingCache . java 
 index c7430d2 . . 58da56b 100644 
 - - - a / src / java / org / apache / cassandra / cache / SerializingCache . java 
 + + + b / src / java / org / apache / cassandra / cache / SerializingCache . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . cache ; 
 import java . io . IOException ; 
 import java . util . Set ; 
 
 + import com . google . common . base . Throwables ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 92 , 7 + 93 , 7 @ @ public class SerializingCache < K , V > implements ICache < K , V > 
 } 
 catch ( IOException e ) 
 { 
 - logger . debug ( " Cannot fetch in memory data , we will failback to read from disk " , e ) ; 
 + logger . debug ( " Cannot fetch in memory data , we will fallback to read from disk " , e ) ; 
 return null ; 
 } 
 } 
 @ @ - 119 , 6 + 120 , 7 @ @ public class SerializingCache < K , V > implements ICache < K , V > 
 } 
 catch ( IOException e ) 
 { 
 + freeableMemory . unreference ( ) ; 
 throw new RuntimeException ( e ) ; 
 } 
 return freeableMemory ; 
 @ @ - 177 , 7 + 179 , 17 @ @ public class SerializingCache < K , V > implements ICache < K , V > 
 if ( mem = = null ) 
 return ; / / out of memory . never mind . 
 
 - RefCountedMemory old = map . put ( key , mem ) ; 
 + RefCountedMemory old ; 
 + try 
 + { 
 + old = map . put ( key , mem ) ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + mem . unreference ( ) ; 
 + throw Throwables . propagate ( t ) ; 
 + } 
 + 
 if ( old ! = null ) 
 old . unreference ( ) ; 
 } 
 @ @ - 188 , 7 + 200 , 17 @ @ public class SerializingCache < K , V > implements ICache < K , V > 
 if ( mem = = null ) 
 return false ; / / out of memory . never mind . 
 
 - RefCountedMemory old = map . putIfAbsent ( key , mem ) ; 
 + RefCountedMemory old ; 
 + try 
 + { 
 + old = map . putIfAbsent ( key , mem ) ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + mem . unreference ( ) ; 
 + throw Throwables . propagate ( t ) ; 
 + } 
 + 
 if ( old ! = null ) 
 / / the new value was not put , we ' ve uselessly allocated some memory , free it 
 mem . unreference ( ) ; 
 @ @ - 202 , 24 + 224 , 32 @ @ public class SerializingCache < K , V > implements ICache < K , V > 
 if ( old = = null ) 
 return false ; 
 
 + V oldValue ; 
 + / / reference old guy before de - serializing 
 + if ( ! old . reference ( ) ) 
 + return false ; / / we have already freed hence noop . 
 + 
 + oldValue = deserialize ( old ) ; 
 + old . unreference ( ) ; 
 + 
 + if ( ! oldValue . equals ( oldToReplace ) ) 
 + return false ; 
 + 
 / / see if the old value matches the one we want to replace 
 RefCountedMemory mem = serialize ( value ) ; 
 if ( mem = = null ) 
 return false ; / / out of memory . never mind . 
 
 - V oldValue ; 
 - / / reference old guy before de - serializing 
 - if ( ! old . reference ( ) ) 
 - return false ; / / we have already freed hence noop . 
 + boolean success ; 
 try 
 { 
 - oldValue = deserialize ( old ) ; 
 + success = map . replace ( key , old , mem ) ; 
 } 
 - finally 
 + catch ( Throwable t ) 
 { 
 - old . unreference ( ) ; 
 + mem . unreference ( ) ; 
 + throw Throwables . propagate ( t ) ; 
 } 
 - boolean success = oldValue . equals ( oldToReplace ) & & map . replace ( key , old , mem ) ; 
 
 if ( success ) 
 old . unreference ( ) ; / / so it will be eventually be cleaned

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index b8eefed . . dc59662 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 981 , 6 + 981 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener 
 EndpointState epState = endpointStateMap . get ( FBUtilities . getLocalAddress ( ) ) ; 
 assert epState ! = null ; 
 epState . addApplicationState ( state , value ) ; 
 + doNotifications ( FBUtilities . getLocalAddress ( ) , state , value ) ; 
 } 
 
 public void stop ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 4701cfc . . 78ad474 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 1913 , 7 + 1913 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 
 / / ring ranges and endpoints associated with them 
 / / this used to determine what nodes should we ping about range data 
 - Multimap < Range , InetAddress > rangeAddresses = strategy . getRangeAddresses ( tokenMetaClone ) ; 
 + Multimap < Range , InetAddress > rangeAddresses = strategy . getRangeAddresses ( tokenMetadata _ ) ; 
 
 / / calculated parts of the ranges to request / stream from / to nodes in the ring 
 Pair < Set < Range > , Set < Range > > rangesPerTable = calculateStreamAndFetchRanges ( currentRanges , updatedRanges ) ;
