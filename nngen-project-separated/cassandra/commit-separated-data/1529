BLEU SCORE: 0.04873498938813619

TEST MSG: Fix generate - eclipse - files ant target
GENERATED MSG: exclude * - sources . jar from the classpath

TEST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index 2723b4d . . 2eb2d89 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 1904 , 9 + 1904 , 6 @ @ <nl> 	 < fileset dir = " build / lib / jars " > <nl> 	 < include name = " * * / * . jar " / > <nl> 	 < / fileset > <nl> - 	 < fileset dir = " tools / lib " > <nl> - 	 < include name = " * * / * . jar " / > <nl> - 	 < / fileset > <nl> 	 < / path > <nl> 	 < property name = " eclipse - project - libs " refid = " eclipse - project - libs - path " / > <nl> 	 < script language = " javascript " classpathref = " cassandra . classpath " > < ! [ CDATA [
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index 542b6d6 . . 7ca0000 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 476 , 54 + 476 , 56 @ @ public abstract class ModificationStatement implements CQLStatement <nl> <nl> ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; <nl> <nl> - if ( stmt . isCounter ( ) ) <nl> - throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; <nl> - <nl> - if ( ifNotExists ) <nl> - { <nl> - / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . <nl> - / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . <nl> - assert conditions . isEmpty ( ) ; <nl> - stmt . setIfNotExistCondition ( ) ; <nl> - } <nl> - else <nl> + if ( stmt . hasConditions ( ) ) <nl> { <nl> - for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) <nl> - { <nl> - CFDefinition . Name name = cfDef . get ( entry . left ) ; <nl> - if ( name = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; <nl> - <nl> - / * <nl> - * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists <nl> - * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for <nl> - * now , we just refuse lists , which also save use from having to bother about the read that some <nl> - * list operation involve . <nl> - * / <nl> - if ( name . type instanceof ListType ) <nl> - throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; <nl> + if ( stmt . isCounter ( ) ) <nl> + throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; <nl> <nl> - Operation condition = entry . right . prepare ( name ) ; <nl> - assert ! condition . requiresRead ( ) ; <nl> + if ( attrs . timestamp ! = null ) <nl> + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> <nl> - condition . collectMarkerSpecification ( boundNames ) ; <nl> - <nl> - switch ( name . kind ) <nl> + if ( ifNotExists ) <nl> + { <nl> + / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . <nl> + / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . <nl> + assert conditions . isEmpty ( ) ; <nl> + stmt . setIfNotExistCondition ( ) ; <nl> + } <nl> + else <nl> + { <nl> + for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) <nl> { <nl> - case KEY _ ALIAS : <nl> - case COLUMN _ ALIAS : <nl> - throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; <nl> - case VALUE _ ALIAS : <nl> - case COLUMN _ METADATA : <nl> - stmt . addCondition ( condition ) ; <nl> - break ; <nl> + CFDefinition . Name name = cfDef . get ( entry . left ) ; <nl> + if ( name = = null ) <nl> + throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; <nl> + <nl> + / * <nl> + * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists <nl> + * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for <nl> + * now , we just refuse lists , which also save use from having to bother about the read that some <nl> + * list operation involve . <nl> + * / <nl> + if ( name . type instanceof ListType ) <nl> + throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; <nl> + <nl> + Operation condition = entry . right . prepare ( name ) ; <nl> + assert ! condition . requiresRead ( ) ; <nl> + <nl> + condition . collectMarkerSpecification ( boundNames ) ; <nl> + <nl> + switch ( name . kind ) <nl> + { <nl> + case KEY _ ALIAS : <nl> + case COLUMN _ ALIAS : <nl> + throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; <nl> + case VALUE _ ALIAS : <nl> + case COLUMN _ METADATA : <nl> + stmt . addCondition ( condition ) ; <nl> + break ; <nl> + } <nl> } <nl> } <nl> } <nl> - <nl> - if ( stmt . hasConditions ( ) & & attrs . timestamp ! = null ) <nl> - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> - <nl> return stmt ; <nl> } <nl>

TEST DIFF:
diff - - git a / build . xml b / build . xml 
 index 2723b4d . . 2eb2d89 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 1904 , 9 + 1904 , 6 @ @ 
 	 < fileset dir = " build / lib / jars " > 
 	 < include name = " * * / * . jar " / > 
 	 < / fileset > 
 - 	 < fileset dir = " tools / lib " > 
 - 	 < include name = " * * / * . jar " / > 
 - 	 < / fileset > 
 	 < / path > 
 	 < property name = " eclipse - project - libs " refid = " eclipse - project - libs - path " / > 
 	 < script language = " javascript " classpathref = " cassandra . classpath " > < ! [ CDATA [

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index 542b6d6 . . 7ca0000 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 476 , 54 + 476 , 56 @ @ public abstract class ModificationStatement implements CQLStatement 
 
 ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; 
 
 - if ( stmt . isCounter ( ) ) 
 - throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; 
 - 
 - if ( ifNotExists ) 
 - { 
 - / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . 
 - / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . 
 - assert conditions . isEmpty ( ) ; 
 - stmt . setIfNotExistCondition ( ) ; 
 - } 
 - else 
 + if ( stmt . hasConditions ( ) ) 
 { 
 - for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) 
 - { 
 - CFDefinition . Name name = cfDef . get ( entry . left ) ; 
 - if ( name = = null ) 
 - throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; 
 - 
 - / * 
 - * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists 
 - * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for 
 - * now , we just refuse lists , which also save use from having to bother about the read that some 
 - * list operation involve . 
 - * / 
 - if ( name . type instanceof ListType ) 
 - throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; 
 + if ( stmt . isCounter ( ) ) 
 + throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; 
 
 - Operation condition = entry . right . prepare ( name ) ; 
 - assert ! condition . requiresRead ( ) ; 
 + if ( attrs . timestamp ! = null ) 
 + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 
 - condition . collectMarkerSpecification ( boundNames ) ; 
 - 
 - switch ( name . kind ) 
 + if ( ifNotExists ) 
 + { 
 + / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . 
 + / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . 
 + assert conditions . isEmpty ( ) ; 
 + stmt . setIfNotExistCondition ( ) ; 
 + } 
 + else 
 + { 
 + for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) 
 { 
 - case KEY _ ALIAS : 
 - case COLUMN _ ALIAS : 
 - throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; 
 - case VALUE _ ALIAS : 
 - case COLUMN _ METADATA : 
 - stmt . addCondition ( condition ) ; 
 - break ; 
 + CFDefinition . Name name = cfDef . get ( entry . left ) ; 
 + if ( name = = null ) 
 + throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; 
 + 
 + / * 
 + * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists 
 + * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for 
 + * now , we just refuse lists , which also save use from having to bother about the read that some 
 + * list operation involve . 
 + * / 
 + if ( name . type instanceof ListType ) 
 + throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; 
 + 
 + Operation condition = entry . right . prepare ( name ) ; 
 + assert ! condition . requiresRead ( ) ; 
 + 
 + condition . collectMarkerSpecification ( boundNames ) ; 
 + 
 + switch ( name . kind ) 
 + { 
 + case KEY _ ALIAS : 
 + case COLUMN _ ALIAS : 
 + throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; 
 + case VALUE _ ALIAS : 
 + case COLUMN _ METADATA : 
 + stmt . addCondition ( condition ) ; 
 + break ; 
 + } 
 } 
 } 
 } 
 - 
 - if ( stmt . hasConditions ( ) & & attrs . timestamp ! = null ) 
 - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 - 
 return stmt ; 
 } 

