BLEU SCORE: 0.040583489434387374

TEST MSG: 10585 - 2 . 2 patch
GENERATED MSG: Cleanup and document EstimatedHistogram

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 5325c8a . . 7e0fbcb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1654 , 7 + 1654 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> metric . rowCacheHit . inc ( ) ; <nl> Tracing . trace ( " Row cache hit " ) ; <nl> - return filterColumnFamily ( cachedCf , filter ) ; <nl> + ColumnFamily result = filterColumnFamily ( cachedCf , filter ) ; <nl> + metric . updateSSTableIterated ( 0 ) ; <nl> + return result ; <nl> } <nl> <nl> metric . rowCacheHitOutOfRange . inc ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java b / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java <nl> index e6f2b81 . . 4e64cff 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java <nl> @ @ - 34 , 7 + 34 , 7 @ @ public class CASClientRequestMetrics extends ClientRequestMetrics <nl> <nl> public CASClientRequestMetrics ( String scope ) { <nl> super ( scope ) ; <nl> - contention = Metrics . histogram ( factory . createMetricName ( " ContentionHistogram " ) ) ; <nl> + contention = Metrics . histogram ( factory . createMetricName ( " ContentionHistogram " ) , false ) ; <nl> conditionNotMet = Metrics . counter ( factory . createMetricName ( " ConditionNotMet " ) ) ; <nl> unfinishedCommit = Metrics . counter ( factory . createMetricName ( " UnfinishedCommit " ) ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java b / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java <nl> index 26b9c07 . . 6fdb2ff 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java <nl> + + + b / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java <nl> @ @ - 58 , 9 + 58 , 9 @ @ public class CassandraMetricsRegistry extends MetricRegistry <nl> return meter ; <nl> } <nl> <nl> - public Histogram histogram ( MetricName name ) <nl> + public Histogram histogram ( MetricName name , boolean considerZeroes ) <nl> { <nl> - Histogram histogram = register ( name , new ClearableHistogram ( new EstimatedHistogramReservoir ( ) ) ) ; <nl> + Histogram histogram = register ( name , new ClearableHistogram ( new EstimatedHistogramReservoir ( considerZeroes ) ) ) ; <nl> registerMBean ( histogram , name . getMBeanName ( ) ) ; <nl> <nl> return histogram ; <nl> @ @ - 68 , 7 + 68 , 7 @ @ public class CassandraMetricsRegistry extends MetricRegistry <nl> <nl> public Timer timer ( MetricName name ) <nl> { <nl> - Timer timer = register ( name , new Timer ( new EstimatedHistogramReservoir ( ) ) ) ; <nl> + Timer timer = register ( name , new Timer ( new EstimatedHistogramReservoir ( false ) ) ) ; <nl> registerMBean ( timer , name . getMBeanName ( ) ) ; <nl> <nl> return timer ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> index 4ab4446 . . 40ed2e4 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java <nl> @ @ - 306 , 7 + 306 , 7 @ @ public class ColumnFamilyMetrics <nl> } ) ; <nl> } <nl> } ) ; <nl> - sstablesPerReadHistogram = createColumnFamilyHistogram ( " SSTablesPerReadHistogram " , cfs . keyspace . metric . sstablesPerReadHistogram ) ; <nl> + sstablesPerReadHistogram = createColumnFamilyHistogram ( " SSTablesPerReadHistogram " , cfs . keyspace . metric . sstablesPerReadHistogram , true ) ; <nl> compressionRatio = createColumnFamilyGauge ( " CompressionRatio " , new Gauge < Double > ( ) <nl> { <nl> public Double getValue ( ) <nl> @ @ - 596 , 12 + 596 , 12 @ @ public class ColumnFamilyMetrics <nl> return Math . max ( requests , 1 ) ; / / to avoid NaN . <nl> } <nl> } ) ; <nl> - tombstoneScannedHistogram = createColumnFamilyHistogram ( " TombstoneScannedHistogram " , cfs . keyspace . metric . tombstoneScannedHistogram ) ; <nl> - liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram ) ; <nl> - colUpdateTimeDeltaHistogram = createColumnFamilyHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram ) ; <nl> + tombstoneScannedHistogram = createColumnFamilyHistogram ( " TombstoneScannedHistogram " , cfs . keyspace . metric . tombstoneScannedHistogram , false ) ; <nl> + liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram , false ) ; <nl> + colUpdateTimeDeltaHistogram = createColumnFamilyHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram , false ) ; <nl> coordinatorReadLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorReadLatency " ) ) ; <nl> coordinatorScanLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorScanLatency " ) ) ; <nl> - waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) ) ; <nl> + waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , false ) ; <nl> <nl> trueSnapshotsSize = createColumnFamilyGauge ( " SnapshotsSize " , new Gauge < Long > ( ) <nl> { <nl> @ @ - 710 , 11 + 710 , 11 @ @ public class ColumnFamilyMetrics <nl> * Create a histogram - like interface that will register both a CF , keyspace and global level <nl> * histogram and forward any updates to both <nl> * / <nl> - protected ColumnFamilyHistogram createColumnFamilyHistogram ( String name , Histogram keyspaceHistogram ) <nl> + protected ColumnFamilyHistogram createColumnFamilyHistogram ( String name , Histogram keyspaceHistogram , boolean considerZeroes ) <nl> { <nl> - Histogram cfHistogram = Metrics . histogram ( factory . createMetricName ( name ) ) ; <nl> + Histogram cfHistogram = Metrics . histogram ( factory . createMetricName ( name ) , considerZeroes ) ; <nl> register ( name , cfHistogram ) ; <nl> - return new ColumnFamilyHistogram ( cfHistogram , keyspaceHistogram , Metrics . histogram ( globalNameFactory . createMetricName ( name ) ) ) ; <nl> + return new ColumnFamilyHistogram ( cfHistogram , keyspaceHistogram , Metrics . histogram ( globalNameFactory . createMetricName ( name ) , considerZeroes ) ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java b / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java <nl> index 3051711 . . 3658f3a 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java <nl> + + + b / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java <nl> @ @ - 34 , 14 + 34 , 14 @ @ public class EstimatedHistogramReservoir implements Reservoir <nl> EstimatedHistogram histogram ; <nl> <nl> / / Default to > 4 hours of in nanoseconds of buckets <nl> - public EstimatedHistogramReservoir ( ) <nl> + public EstimatedHistogramReservoir ( boolean considerZeroes ) <nl> { <nl> - this ( 164 ) ; <nl> + this ( 164 , considerZeroes ) ; <nl> } <nl> <nl> - public EstimatedHistogramReservoir ( int numBuckets ) <nl> + public EstimatedHistogramReservoir ( int numBuckets , boolean considerZeroes ) <nl> { <nl> - histogram = new EstimatedHistogram ( numBuckets ) ; <nl> + histogram = new EstimatedHistogram ( numBuckets , considerZeroes ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 100 , 7 + 100 , 7 @ @ public class EstimatedHistogramReservoir implements Reservoir <nl> @ Override <nl> public double getMean ( ) <nl> { <nl> - return histogram . mean ( ) ; <nl> + return histogram . rawMean ( ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> index e9ce49c . . 369f323 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> @ @ - 221 , 10 + 221 , 10 @ @ public class KeyspaceMetrics <nl> writeLatency = new LatencyMetrics ( factory , " Write " ) ; <nl> rangeLatency = new LatencyMetrics ( factory , " Range " ) ; <nl> / / create histograms for ColumnFamilyMetrics to replicate updates to <nl> - sstablesPerReadHistogram = Metrics . histogram ( factory . createMetricName ( " SSTablesPerReadHistogram " ) ) ; <nl> - tombstoneScannedHistogram = Metrics . histogram ( factory . createMetricName ( " TombstoneScannedHistogram " ) ) ; <nl> - liveScannedHistogram = Metrics . histogram ( factory . createMetricName ( " LiveScannedHistogram " ) ) ; <nl> - colUpdateTimeDeltaHistogram = Metrics . histogram ( factory . createMetricName ( " ColUpdateTimeDeltaHistogram " ) ) ; <nl> + sstablesPerReadHistogram = Metrics . histogram ( factory . createMetricName ( " SSTablesPerReadHistogram " ) , true ) ; <nl> + tombstoneScannedHistogram = Metrics . histogram ( factory . createMetricName ( " TombstoneScannedHistogram " ) , false ) ; <nl> + liveScannedHistogram = Metrics . histogram ( factory . createMetricName ( " LiveScannedHistogram " ) , false ) ; <nl> + colUpdateTimeDeltaHistogram = Metrics . histogram ( factory . createMetricName ( " ColUpdateTimeDeltaHistogram " ) , false ) ; <nl> / / add manually since histograms do not use createKeyspaceGauge method <nl> allMetrics . addAll ( Lists . newArrayList ( " SSTablesPerReadHistogram " , " TombstoneScannedHistogram " , " LiveScannedHistogram " ) ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> index 93d142a . . 6c929df 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> + + + b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java <nl> @ @ - 57 , 7 + 57 , 12 @ @ public class EstimatedHistogram <nl> <nl> public EstimatedHistogram ( int bucketCount ) <nl> { <nl> - bucketOffsets = newOffsets ( bucketCount ) ; <nl> + this ( bucketCount , false ) ; <nl> + } <nl> + <nl> + public EstimatedHistogram ( int bucketCount , boolean considerZeroes ) <nl> + { <nl> + bucketOffsets = newOffsets ( bucketCount , considerZeroes ) ; <nl> buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; <nl> } <nl> <nl> @ @ - 68 , 12 + 73 , 15 @ @ public class EstimatedHistogram <nl> buckets = new AtomicLongArray ( bucketData ) ; <nl> } <nl> <nl> - private static long [ ] newOffsets ( int size ) <nl> + private static long [ ] newOffsets ( int size , boolean considerZeroes ) <nl> { <nl> - long [ ] result = new long [ size ] ; <nl> + long [ ] result = new long [ size + ( considerZeroes ? 1 : 0 ) ] ; <nl> + int i = 0 ; <nl> + if ( considerZeroes ) <nl> + result [ i + + ] = 0 ; <nl> long last = 1 ; <nl> - result [ 0 ] = last ; <nl> - for ( int i = 1 ; i < size ; i + + ) <nl> + result [ i + + ] = last ; <nl> + for ( ; i < result . length ; i + + ) <nl> { <nl> long next = Math . round ( last * 1 . 2 ) ; <nl> if ( next = = last ) <nl> @ @ - 193 , 11 + 201 , 20 @ @ public class EstimatedHistogram <nl> } <nl> <nl> / * * <nl> - * @ return the mean histogram value ( average of bucket offsets , weighted by count ) <nl> + * @ return the ceil of mean histogram value ( average of bucket offsets , weighted by count ) <nl> * @ throws IllegalStateException if any values were greater than the largest bucket threshold <nl> * / <nl> public long mean ( ) <nl> { <nl> + return ( long ) Math . ceil ( rawMean ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ return the mean histogram value ( average of bucket offsets , weighted by count ) <nl> + * @ throws IllegalStateException if any values were greater than the largest bucket threshold <nl> + * / <nl> + public double rawMean ( ) <nl> + { <nl> int lastBucket = buckets . length ( ) - 1 ; <nl> if ( buckets . get ( lastBucket ) > 0 ) <nl> throw new IllegalStateException ( " Unable to compute ceiling for max when histogram overflowed " ) ; <nl> @ @ - 211 , 7 + 228 , 7 @ @ public class EstimatedHistogram <nl> sum + = bCount * bucketOffsets [ i ] ; <nl> } <nl> <nl> - return ( long ) Math . ceil ( ( double ) sum / elements ) ; <nl> + return ( double ) sum / elements ; <nl> } <nl> <nl> / * * <nl> diff - - git a / test / unit / org / apache / cassandra / db / RowCacheTest . java b / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> index 9fb322b . . 0c0396c 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> @ @ - 46 , 10 + 46 , 12 @ @ import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . locator . SimpleStrategy ; <nl> + import org . apache . cassandra . metrics . ClearableHistogram ; <nl> import org . apache . cassandra . service . CacheService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> <nl> public class RowCacheTest <nl> { <nl> @ @ - 339 , 6 + 341 , 54 @ @ public class RowCacheTest <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testSSTablesPerReadHistogramWhenRowCache ( ) <nl> + { <nl> + CompactionManager . instance . disableAutoCompaction ( ) ; <nl> + <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE _ CACHED ) ; <nl> + ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( CF _ CACHED ) ; <nl> + <nl> + / / empty the row cache <nl> + CacheService . instance . invalidateRowCache ( ) ; <nl> + <nl> + / / set global row cache size to 1 MB <nl> + CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; <nl> + <nl> + / / inserting 100 rows into both column families <nl> + SchemaLoader . insertData ( KEYSPACE _ CACHED , CF _ CACHED , 0 , 100 ) ; <nl> + <nl> + / / force flush for confidence that SSTables exists <nl> + cachedStore . forceBlockingFlush ( ) ; <nl> + <nl> + ( ( ClearableHistogram ) cachedStore . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; <nl> + <nl> + for ( int i = 0 ; i < 100 ; i + + ) <nl> + { <nl> + DecoratedKey key = Util . dk ( " key " + i ) ; <nl> + <nl> + cachedStore . getColumnFamily ( key , Composites . EMPTY , Composites . EMPTY , false , 1 , System . currentTimeMillis ( ) ) ; <nl> + <nl> + long count _ before = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; <nl> + cachedStore . getColumnFamily ( key , Composites . EMPTY , Composites . EMPTY , false , 1 , System . currentTimeMillis ( ) ) ; <nl> + <nl> + / / check that SSTablePerReadHistogram has been updated by zero , <nl> + / / so count has been increased and in a 1 / 2 of requests there were zero read SSTables <nl> + long count _ after = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; <nl> + double belowMedian = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getValue ( 0 . 49D ) ; <nl> + double mean _ after = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMean ( ) ; <nl> + assertEquals ( " SSTablePerReadHistogram should be updated even key found in row cache " , count _ before + 1 , count _ after ) ; <nl> + assertTrue ( " In half of requests we have not touched SSTables , " + <nl> + " so 49 percentile ( " + belowMedian + " ) must be strongly less than 0 . 9 " , belowMedian < 0 . 9D ) ; <nl> + assertTrue ( " In half of requests we have not touched SSTables , " + <nl> + " so mean value ( " + mean _ after + " ) must be strongly less than 1 , but greater than 0 " , mean _ after < 0 . 999D & & mean _ after > 0 . 001D ) ; <nl> + } <nl> + <nl> + assertEquals ( " Min value of SSTablesPerRead should be zero " , 0 , cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMin ( ) ) ; <nl> + <nl> + CacheService . instance . setRowCacheCapacityInMB ( 0 ) ; <nl> + } <nl> + <nl> public void rowCacheLoad ( int totalKeys , int keysToSave , int offset ) throws Exception <nl> { <nl> CompactionManager . instance . disableAutoCompaction ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> index eebaa25 . . b0e0e4f 100644 <nl> - - - a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> + + + b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java <nl> @ @ - 28 , 12 + 28 , 23 @ @ public class EstimatedHistogramTest <nl> @ Test <nl> public void testSimple ( ) <nl> { <nl> - / / 0 and 1 map to the same , first bucket <nl> - EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> - histogram . add ( 0 ) ; <nl> - assertEquals ( 1 , histogram . get ( 0 ) ) ; <nl> - histogram . add ( 1 ) ; <nl> - assertEquals ( 2 , histogram . get ( 0 ) ) ; <nl> + { <nl> + / / 0 and 1 map to the same , first bucket <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> + histogram . add ( 0 ) ; <nl> + assertEquals ( 1 , histogram . get ( 0 ) ) ; <nl> + histogram . add ( 1 ) ; <nl> + assertEquals ( 2 , histogram . get ( 0 ) ) ; <nl> + } <nl> + { <nl> + / / 0 and 1 map to different buckets <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; <nl> + histogram . add ( 0 ) ; <nl> + assertEquals ( 1 , histogram . get ( 0 ) ) ; <nl> + histogram . add ( 1 ) ; <nl> + assertEquals ( 1 , histogram . get ( 0 ) ) ; <nl> + assertEquals ( 1 , histogram . get ( 1 ) ) ; <nl> + } <nl> } <nl> <nl> @ Test <nl> @ @ - 55 , 6 + 66 , 33 @ @ public class EstimatedHistogramTest <nl> } <nl> <nl> @ Test <nl> + public void testMean ( ) <nl> + { <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> + for ( int i = 0 ; i < 40 ; i + + ) <nl> + histogram . add ( 0 ) ; <nl> + for ( int i = 0 ; i < 20 ; i + + ) <nl> + histogram . add ( 1 ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + histogram . add ( 2 ) ; <nl> + assertEquals ( 70 , histogram . count ( ) ) ; <nl> + assertEquals ( 2 , histogram . mean ( ) ) ; <nl> + } <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; <nl> + for ( int i = 0 ; i < 40 ; i + + ) <nl> + histogram . add ( 0 ) ; <nl> + for ( int i = 0 ; i < 20 ; i + + ) <nl> + histogram . add ( 1 ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + histogram . add ( 2 ) ; <nl> + assertEquals ( 70 , histogram . count ( ) ) ; <nl> + assertEquals ( 1 , histogram . mean ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> public void testFindingCorrectBuckets ( ) <nl> { <nl> EstimatedHistogram histogram = new EstimatedHistogram ( ) ; <nl> @ @ - 119 , 5 + 157 , 14 @ @ public class EstimatedHistogramTest <nl> assertEquals ( 17 , histogram . percentile ( 0 . 60 ) ) ; <nl> assertEquals ( 20 , histogram . percentile ( 0 . 80 ) ) ; <nl> } <nl> + { <nl> + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; <nl> + histogram . add ( 0 ) ; <nl> + histogram . add ( 0 ) ; <nl> + histogram . add ( 1 ) ; <nl> + <nl> + assertEquals ( 0 , histogram . percentile ( 0 . 5 ) ) ; <nl> + assertEquals ( 1 , histogram . percentile ( 0 . 99 ) ) ; <nl> + } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e268270 . . 42f86f7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 18 , 7 + 18 , 7 @ @ <nl> * add nodetool scrub ( CASSANDRA - 2217 ) <nl> * fix sstable2json large - row pagination ( CASSANDRA - 2188 ) <nl> * fix EOFing on requests for the last bytes in a file ( CASSANDRA - 2213 ) <nl> - * fix BRAF performance when seeking to EOF ( CASSANDRA - 2218 ) <nl> + * fix BufferedRandomAccessFile bugs ( CASSANDRA - 2218 , - 2241 ) <nl> * check for memtable flush _ after _ mins exceeded every 10s ( CASSANDRA - 2183 ) <nl> * fix cache saving on Windows ( CASSANDRA - 2207 ) <nl> * add validateSchemaAgreement call + synchronization to schema <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 82d8320 . . 3d5ad19 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 172 , 7 + 172 , 7 @ @ public class CommitLog <nl> <nl> for ( File file : clogs ) <nl> { <nl> - int bufferSize = ( int ) Math . min ( file . length ( ) , 32 * 1024 * 1024 ) ; <nl> + int bufferSize = ( int ) Math . min ( Math . max ( file . length ( ) , 1 ) , 32 * 1024 * 1024 ) ; <nl> BufferedRandomAccessFile reader = new BufferedRandomAccessFile ( new File ( file . getAbsolutePath ( ) ) , " r " , bufferSize , true ) ; <nl> <nl> try <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / Descriptor . java b / src / java / org / apache / cassandra / io / sstable / Descriptor . java <nl> index effeb82 . . 08d3b00 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / Descriptor . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / Descriptor . java <nl> @ @ - 76 , 8 + 76 , 8 @ @ public class Descriptor <nl> hasStringsInBloomFilter = version . compareTo ( " c " ) < 0 ; <nl> hasIntRowSize = version . compareTo ( " d " ) < 0 ; <nl> hasEncodedKeys = version . compareTo ( " e " ) < 0 ; <nl> - isLatestVersion = version . compareTo ( CURRENT _ VERSION ) = = 0 ; <nl> usesOldBloomFilter = version . compareTo ( " f " ) < 0 ; <nl> + isLatestVersion = version . compareTo ( CURRENT _ VERSION ) = = 0 ; <nl> } <nl> <nl> public String filenameFor ( Component component ) <nl> diff - - git a / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java b / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java <nl> index 8059c2a . . 073ad72 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java <nl> + + + b / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java <nl> @ @ - 47 , 16 + 47 , 16 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> public static final int DEFAULT _ BUFFER _ SIZE = 65535 ; <nl> <nl> / / isDirty - true if this . buffer contains any un - synced bytes <nl> - / / hitEOF - true if buffer capacity is less then it ' s maximal size <nl> - private boolean isDirty , syncNeeded , hitEOF = false ; <nl> + private boolean isDirty , syncNeeded ; <nl> <nl> / / buffer which will cache file blocks <nl> - private ByteBuffer buffer ; <nl> + private byte [ ] buffer ; <nl> <nl> / / ` current ` as current position in file <nl> / / ` bufferOffset ` is the offset of the beginning of the buffer <nl> - / / ` bufferEnd ` is ` bufferOffset ` + count of bytes read from file , i . e . the lowest position we can ' t read from the buffer <nl> - private long bufferOffset , bufferEnd , current = 0 ; <nl> + / / ` validBufferBytes ` is the number of bytes in the buffer that are actually valid ; this will be LESS than buffer capacity if buffer is not full ! <nl> + private long bufferOffset , current = 0 ; <nl> + private int validBufferBytes = 0 ; <nl> <nl> / / constant , used for caching purpose , - 1 if file is open in " rw " mode <nl> / / otherwise this will hold cached file length <nl> @ @ - 118 , 11 + 118 , 11 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> / / allocating required size of the buffer <nl> if ( bufferSize < = 0 ) <nl> throw new IllegalArgumentException ( " bufferSize must be positive " ) ; <nl> - buffer = ByteBuffer . allocate ( bufferSize ) ; <nl> + buffer = new byte [ bufferSize ] ; <nl> + reBuffer ( ) ; <nl> <nl> / / if in read - only mode , caching file size <nl> fileLength = ( mode . equals ( " r " ) ) ? this . channel . size ( ) : - 1 ; <nl> - bufferEnd = reBuffer ( ) ; / / bufferBottom equals to the bytes read <nl> fd = CLibrary . getfd ( this . getFD ( ) ) ; <nl> } <nl> <nl> @ @ - 155 , 9 + 155 , 7 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> if ( channel . position ( ) ! = bufferOffset ) <nl> channel . position ( bufferOffset ) ; <nl> <nl> - int lengthToWrite = ( int ) ( bufferEnd - bufferOffset ) ; <nl> - <nl> - super . write ( buffer . array ( ) , 0 , lengthToWrite ) ; <nl> + super . write ( buffer , 0 , validBufferBytes ) ; <nl> <nl> if ( skipCache ) <nl> { <nl> @ @ - 167 , 7 + 165 , 7 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> / / so we continue to clear pages we don ' t need from the first <nl> / / offset we see <nl> / / periodically we update this starting offset <nl> - bytesSinceCacheFlush + = lengthToWrite ; <nl> + bytesSinceCacheFlush + = validBufferBytes ; <nl> <nl> if ( bufferOffset < minBufferOffset ) <nl> minBufferOffset = bufferOffset ; <nl> @ @ - 185 , 66 + 183 , 53 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> } <nl> } <nl> <nl> - private long reBuffer ( ) throws IOException <nl> + private void reBuffer ( ) throws IOException <nl> { <nl> flush ( ) ; / / synchronizing buffer and file on disk <nl> - buffer . clear ( ) ; <nl> - bufferOffset = current ; <nl> <nl> + bufferOffset = current ; <nl> if ( bufferOffset > = channel . size ( ) ) <nl> { <nl> - buffer . rewind ( ) ; <nl> - bufferEnd = bufferOffset ; <nl> - hitEOF = true ; <nl> - <nl> - return 0 ; <nl> + validBufferBytes = 0 ; <nl> + return ; <nl> } <nl> <nl> if ( bufferOffset < minBufferOffset ) <nl> minBufferOffset = bufferOffset ; <nl> <nl> channel . position ( bufferOffset ) ; / / setting channel position <nl> - long bytesRead = channel . read ( buffer ) ; / / reading from that position <nl> - <nl> - hitEOF = ( bytesRead < buffer . capacity ( ) ) ; / / buffer is not fully loaded with <nl> - / / data <nl> - bufferEnd = bufferOffset + bytesRead ; <nl> - <nl> - buffer . rewind ( ) ; <nl> - <nl> - bytesSinceCacheFlush + = bytesRead ; <nl> + int read = 0 ; <nl> + while ( read < buffer . length ) <nl> + { <nl> + int n = super . read ( buffer , read , buffer . length - read ) ; <nl> + if ( n < 0 ) <nl> + break ; <nl> + read + = n ; <nl> + } <nl> + validBufferBytes = read ; <nl> <nl> + bytesSinceCacheFlush + = read ; <nl> if ( skipCache & & bytesSinceCacheFlush > = MAX _ BYTES _ IN _ PAGE _ CACHE ) <nl> { <nl> CLibrary . trySkipCache ( this . fd , ( int ) minBufferOffset , 0 ) ; <nl> bytesSinceCacheFlush = 0 ; <nl> minBufferOffset = Long . MAX _ VALUE ; <nl> } <nl> - <nl> - return bytesRead ; <nl> } <nl> <nl> @ Override <nl> - / / - 1 will be returned if EOF is reached , RandomAccessFile is responsible <nl> - / / for <nl> - / / throwing EOFException <nl> + / / - 1 will be returned if there is nothing to read ; higher - level methods like readInt <nl> + / / or readFully ( from RandomAccessFile ) will throw EOFException but this should not <nl> public int read ( ) throws IOException <nl> { <nl> if ( isEOF ( ) ) <nl> return - 1 ; / / required by RandomAccessFile <nl> <nl> - if ( current < bufferOffset | | current > = bufferEnd ) <nl> - { <nl> + if ( current > = bufferOffset + buffer . length ) <nl> reBuffer ( ) ; <nl> + assert current > = bufferOffset & & current < bufferOffset + validBufferBytes ; <nl> <nl> - if ( current = = bufferEnd & & hitEOF ) <nl> - return - 1 ; / / required by RandomAccessFile <nl> - } <nl> - <nl> - byte result = buffer . get ( ) ; <nl> - current + + ; <nl> - <nl> - return ( ( int ) result ) & 0xFF ; <nl> + return ( ( int ) buffer [ ( int ) ( current + + - bufferOffset ) ] ) & 0xFF ; <nl> } <nl> <nl> @ Override <nl> @ @ - 254 , 40 + 239 , 25 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> } <nl> <nl> @ Override <nl> - / / - 1 will be returned if EOF is reached ; higher - level methods like readInt <nl> + / / - 1 will be returned if there is nothing to read ; higher - level methods like readInt <nl> / / or readFully ( from RandomAccessFile ) will throw EOFException but this should not <nl> public int read ( byte [ ] buff , int offset , int length ) throws IOException <nl> { <nl> - int bytesCount = 0 ; <nl> - <nl> - while ( length > 0 ) <nl> - { <nl> - int bytesRead = readAtMost ( buff , offset , length ) ; <nl> - if ( bytesRead = = - 1 ) <nl> - return - 1 ; / / EOF <nl> - <nl> - offset + = bytesRead ; <nl> - length - = bytesRead ; <nl> - bytesCount + = bytesRead ; <nl> - } <nl> - <nl> - return bytesCount ; <nl> - } <nl> + if ( length = = 0 ) <nl> + return 0 ; <nl> <nl> - private int readAtMost ( byte [ ] buff , int offset , int length ) throws IOException <nl> - { <nl> - if ( length > bufferEnd & & hitEOF ) <nl> + if ( isEOF ( ) ) <nl> return - 1 ; <nl> <nl> - final int left = buffer . capacity ( ) - buffer . position ( ) ; <nl> - if ( current < bufferOffset | | left < length ) <nl> + if ( current > = bufferOffset + buffer . length ) <nl> reBuffer ( ) ; <nl> + assert current > = bufferOffset & & current < bufferOffset + validBufferBytes ; <nl> <nl> - length = Math . min ( length , buffer . capacity ( ) - buffer . position ( ) ) ; <nl> - buffer . get ( buff , offset , length ) ; <nl> - current + = length ; <nl> + int toCopy = Math . min ( length , validBufferBytes - ( int ) ( current - bufferOffset ) ) ; <nl> + System . arraycopy ( buffer , ( int ) ( current - bufferOffset ) , buff , offset , toCopy ) ; <nl> + current + = toCopy ; <nl> <nl> - return length ; <nl> + return toCopy ; <nl> } <nl> <nl> public ByteBuffer readBytes ( int length ) throws IOException <nl> @ @ - 300 , 12 + 270 , 12 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> return ByteBuffer . wrap ( buff ) ; <nl> } <nl> <nl> + private final byte [ ] singleByteBuffer = new byte [ 1 ] ; / / so we can use the write ( byte [ ] ) path w / o tons of new byte [ ] allocations <nl> @ Override <nl> public void write ( int val ) throws IOException <nl> { <nl> - byte [ ] b = new byte [ 1 ] ; <nl> - b [ 0 ] = ( byte ) val ; <nl> - this . write ( b , 0 , b . length ) ; <nl> + singleByteBuffer [ 0 ] = ( byte ) val ; <nl> + this . write ( singleByteBuffer , 0 , 1 ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 334 , 21 + 304 , 18 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> * / <nl> private int writeAtMost ( byte [ ] buff , int offset , int length ) throws IOException <nl> { <nl> - final int left = buffer . capacity ( ) - buffer . position ( ) ; <nl> - if ( current < bufferOffset | | left < length ) <nl> + if ( current > = bufferOffset + buffer . length ) <nl> reBuffer ( ) ; <nl> + assert current < bufferOffset + buffer . length ; <nl> <nl> - / / logic is the following : we need to add bytes to the end of the buffer <nl> - / / starting from current buffer position and return this length <nl> - length = Math . min ( length , buffer . capacity ( ) - buffer . position ( ) ) ; <nl> - <nl> - buffer . put ( buff , offset , length ) ; <nl> - current + = length ; <nl> + int positionWithinBuffer = ( int ) ( current - bufferOffset ) ; <nl> + int toCopy = Math . min ( length , buffer . length - positionWithinBuffer ) ; <nl> + System . arraycopy ( buff , offset , buffer , positionWithinBuffer , toCopy ) ; <nl> + current + = toCopy ; <nl> + validBufferBytes = Math . max ( validBufferBytes , positionWithinBuffer + toCopy ) ; <nl> + assert current < = bufferOffset + buffer . length ; <nl> <nl> - if ( current > bufferEnd ) <nl> - bufferEnd = current ; <nl> - <nl> - return length ; <nl> + return toCopy ; <nl> } <nl> <nl> @ Override <nl> @ @ - 356 , 13 + 323 , 8 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> { <nl> current = newPosition ; <nl> <nl> - if ( newPosition > = bufferEnd | | newPosition < bufferOffset ) <nl> - { <nl> + if ( newPosition > = bufferOffset + validBufferBytes | | newPosition < bufferOffset ) <nl> reBuffer ( ) ; / / this will set bufferEnd for us <nl> - } <nl> - <nl> - final int delta = ( int ) ( newPosition - bufferOffset ) ; <nl> - buffer . position ( delta ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 382 , 12 + 344 , 12 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> <nl> public long length ( ) throws IOException <nl> { <nl> - return ( fileLength = = - 1 ) ? Math . max ( current , channel . size ( ) ) : fileLength ; <nl> + return ( fileLength = = - 1 ) ? Math . max ( Math . max ( current , channel . size ( ) ) , bufferOffset + validBufferBytes ) : fileLength ; <nl> } <nl> <nl> public long getFilePointer ( ) <nl> { <nl> - return bufferOffset + buffer . position ( ) ; <nl> + return current ; <nl> } <nl> <nl> public String getPath ( ) <nl> @ @ - 395 , 6 + 357 , 9 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa <nl> return filePath ; <nl> } <nl> <nl> + / * * <nl> + * @ return true if there is no more data to read <nl> + * / <nl> public boolean isEOF ( ) throws IOException <nl> { <nl> return getFilePointer ( ) = = length ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java b / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java <nl> new file mode 100644 <nl> index 0000000 . . 62fc998 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java <nl> @ @ - 0 , 0 + 1 , 16 @ @ <nl> + package org . apache . cassandra . io . sstable ; <nl> + <nl> + import java . io . File ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + public class DescriptorTest <nl> + { <nl> + @ Test <nl> + public void testLegacy ( ) <nl> + { <nl> + Descriptor descriptor = Descriptor . fromFilename ( new File ( " Keyspace1 " ) , " userActionUtilsKey - 9 - Data . db " ) . left ; <nl> + assert descriptor . version . equals ( Descriptor . LEGACY _ VERSION ) ; <nl> + assert descriptor . usesOldBloomFilter ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> index 606ba09 . . 2116a7e 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . io . File ; <nl> import java . io . FileOutputStream ; <nl> import java . io . IOException ; <nl> import java . util . Arrays ; <nl> + import java . util . concurrent . Callable ; <nl> <nl> import org . junit . Test ; <nl> <nl> @ @ - 98 , 37 + 99 , 69 @ @ public class BufferedRandomAccessFileTest <nl> rw . write ( 42 ) ; <nl> } <nl> <nl> - protected void expectException ( int size , int offset , int len , BufferedRandomAccessFile braf ) <nl> + @ Test <nl> + public void testNotEOF ( ) throws IOException <nl> + { <nl> + assertEquals ( 1 , new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 1 ] ) , " rw " ) . read ( new byte [ 2 ] ) ) ; <nl> + } <nl> + <nl> + <nl> + protected void expectEOF ( Callable < ? > callable ) <nl> { <nl> boolean threw = false ; <nl> try <nl> { <nl> - braf . readFully ( new byte [ size ] , offset , len ) ; <nl> + callable . call ( ) ; <nl> } <nl> - catch ( Throwable t ) <nl> + catch ( Exception e ) <nl> { <nl> - assert t . getClass ( ) . equals ( EOFException . class ) : t . getClass ( ) . getName ( ) + " is not " + EOFException . class . getName ( ) ; <nl> + assert e . getClass ( ) . equals ( EOFException . class ) : e . getClass ( ) . getName ( ) + " is not " + EOFException . class . getName ( ) ; <nl> threw = true ; <nl> } <nl> assert threw : EOFException . class . getName ( ) + " not received " ; <nl> } <nl> <nl> @ Test <nl> - public void testEOF ( ) throws Exception <nl> + public void testEOF ( ) throws IOException <nl> { <nl> for ( String mode : Arrays . asList ( " r " , " rw " ) ) / / read , read + write <nl> { <nl> - for ( int buf : Arrays . asList ( 8 , 16 , 32 , 0 ) ) / / smaller , equal , bigger , zero <nl> + for ( int bufferSize : Arrays . asList ( 1 , 2 , 3 , 5 , 8 , 64 ) ) / / smaller , equal , bigger buffer sizes <nl> { <nl> - for ( int off : Arrays . asList ( 0 , 8 ) ) <nl> + final byte [ ] target = new byte [ 32 ] ; <nl> + <nl> + / / single too - large read <nl> + for ( final int offset : Arrays . asList ( 0 , 8 ) ) <nl> { <nl> - expectException ( 32 , off , 17 , new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , buf ) ) ; <nl> + final BufferedRandomAccessFile file = new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , bufferSize ) ; <nl> + expectEOF ( new Callable < Object > ( ) <nl> + { <nl> + public Object call ( ) throws IOException <nl> + { <nl> + file . readFully ( target , offset , 17 ) ; <nl> + return null ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + / / first read is ok but eventually EOFs <nl> + for ( final int n : Arrays . asList ( 1 , 2 , 4 , 8 ) ) <nl> + { <nl> + final BufferedRandomAccessFile file = new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , bufferSize ) ; <nl> + expectEOF ( new Callable < Object > ( ) <nl> + { <nl> + public Object call ( ) throws IOException <nl> + { <nl> + while ( true ) <nl> + file . readFully ( target , 0 , n ) ; <nl> + } <nl> + } ) ; <nl> } <nl> } <nl> } <nl> } <nl> <nl> - protected File writeTemporaryFile ( byte [ ] data ) throws Exception <nl> + protected File writeTemporaryFile ( byte [ ] data ) throws IOException <nl> { <nl> File f = File . createTempFile ( " BRAFTestFile " , null ) ; <nl> f . deleteOnExit ( ) ; <nl> @ @ - 172 , 12 + 205 , 12 @ @ public class BufferedRandomAccessFileTest <nl> <nl> BufferedRandomAccessFile rw = new BufferedRandomAccessFile ( tmpFile . getPath ( ) , " rw " ) ; <nl> rw . write ( new byte [ ] { 1 } ) ; <nl> - <nl> rw . seek ( 0 ) ; <nl> + <nl> / / test read of buffered - but - not - yet - written data <nl> byte [ ] buffer = new byte [ 1 ] ; <nl> - assert rw . read ( buffer ) = = 1 ; <nl> - assert buffer [ 0 ] = = 1 ; <nl> + assertEquals ( 1 , rw . read ( buffer ) ) ; <nl> + assertEquals ( 1 , buffer [ 0 ] ) ; <nl> rw . close ( ) ; <nl> <nl> / / test read of not - yet - buffered data

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 5325c8a . . 7e0fbcb 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1654 , 7 + 1654 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 metric . rowCacheHit . inc ( ) ; 
 Tracing . trace ( " Row cache hit " ) ; 
 - return filterColumnFamily ( cachedCf , filter ) ; 
 + ColumnFamily result = filterColumnFamily ( cachedCf , filter ) ; 
 + metric . updateSSTableIterated ( 0 ) ; 
 + return result ; 
 } 
 
 metric . rowCacheHitOutOfRange . inc ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java b / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java 
 index e6f2b81 . . 4e64cff 100644 
 - - - a / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / CASClientRequestMetrics . java 
 @ @ - 34 , 7 + 34 , 7 @ @ public class CASClientRequestMetrics extends ClientRequestMetrics 
 
 public CASClientRequestMetrics ( String scope ) { 
 super ( scope ) ; 
 - contention = Metrics . histogram ( factory . createMetricName ( " ContentionHistogram " ) ) ; 
 + contention = Metrics . histogram ( factory . createMetricName ( " ContentionHistogram " ) , false ) ; 
 conditionNotMet = Metrics . counter ( factory . createMetricName ( " ConditionNotMet " ) ) ; 
 unfinishedCommit = Metrics . counter ( factory . createMetricName ( " UnfinishedCommit " ) ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java b / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java 
 index 26b9c07 . . 6fdb2ff 100644 
 - - - a / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java 
 + + + b / src / java / org / apache / cassandra / metrics / CassandraMetricsRegistry . java 
 @ @ - 58 , 9 + 58 , 9 @ @ public class CassandraMetricsRegistry extends MetricRegistry 
 return meter ; 
 } 
 
 - public Histogram histogram ( MetricName name ) 
 + public Histogram histogram ( MetricName name , boolean considerZeroes ) 
 { 
 - Histogram histogram = register ( name , new ClearableHistogram ( new EstimatedHistogramReservoir ( ) ) ) ; 
 + Histogram histogram = register ( name , new ClearableHistogram ( new EstimatedHistogramReservoir ( considerZeroes ) ) ) ; 
 registerMBean ( histogram , name . getMBeanName ( ) ) ; 
 
 return histogram ; 
 @ @ - 68 , 7 + 68 , 7 @ @ public class CassandraMetricsRegistry extends MetricRegistry 
 
 public Timer timer ( MetricName name ) 
 { 
 - Timer timer = register ( name , new Timer ( new EstimatedHistogramReservoir ( ) ) ) ; 
 + Timer timer = register ( name , new Timer ( new EstimatedHistogramReservoir ( false ) ) ) ; 
 registerMBean ( timer , name . getMBeanName ( ) ) ; 
 
 return timer ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 index 4ab4446 . . 40ed2e4 100644 
 - - - a / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / ColumnFamilyMetrics . java 
 @ @ - 306 , 7 + 306 , 7 @ @ public class ColumnFamilyMetrics 
 } ) ; 
 } 
 } ) ; 
 - sstablesPerReadHistogram = createColumnFamilyHistogram ( " SSTablesPerReadHistogram " , cfs . keyspace . metric . sstablesPerReadHistogram ) ; 
 + sstablesPerReadHistogram = createColumnFamilyHistogram ( " SSTablesPerReadHistogram " , cfs . keyspace . metric . sstablesPerReadHistogram , true ) ; 
 compressionRatio = createColumnFamilyGauge ( " CompressionRatio " , new Gauge < Double > ( ) 
 { 
 public Double getValue ( ) 
 @ @ - 596 , 12 + 596 , 12 @ @ public class ColumnFamilyMetrics 
 return Math . max ( requests , 1 ) ; / / to avoid NaN . 
 } 
 } ) ; 
 - tombstoneScannedHistogram = createColumnFamilyHistogram ( " TombstoneScannedHistogram " , cfs . keyspace . metric . tombstoneScannedHistogram ) ; 
 - liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram ) ; 
 - colUpdateTimeDeltaHistogram = createColumnFamilyHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram ) ; 
 + tombstoneScannedHistogram = createColumnFamilyHistogram ( " TombstoneScannedHistogram " , cfs . keyspace . metric . tombstoneScannedHistogram , false ) ; 
 + liveScannedHistogram = createColumnFamilyHistogram ( " LiveScannedHistogram " , cfs . keyspace . metric . liveScannedHistogram , false ) ; 
 + colUpdateTimeDeltaHistogram = createColumnFamilyHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram , false ) ; 
 coordinatorReadLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorReadLatency " ) ) ; 
 coordinatorScanLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorScanLatency " ) ) ; 
 - waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) ) ; 
 + waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , false ) ; 
 
 trueSnapshotsSize = createColumnFamilyGauge ( " SnapshotsSize " , new Gauge < Long > ( ) 
 { 
 @ @ - 710 , 11 + 710 , 11 @ @ public class ColumnFamilyMetrics 
 * Create a histogram - like interface that will register both a CF , keyspace and global level 
 * histogram and forward any updates to both 
 * / 
 - protected ColumnFamilyHistogram createColumnFamilyHistogram ( String name , Histogram keyspaceHistogram ) 
 + protected ColumnFamilyHistogram createColumnFamilyHistogram ( String name , Histogram keyspaceHistogram , boolean considerZeroes ) 
 { 
 - Histogram cfHistogram = Metrics . histogram ( factory . createMetricName ( name ) ) ; 
 + Histogram cfHistogram = Metrics . histogram ( factory . createMetricName ( name ) , considerZeroes ) ; 
 register ( name , cfHistogram ) ; 
 - return new ColumnFamilyHistogram ( cfHistogram , keyspaceHistogram , Metrics . histogram ( globalNameFactory . createMetricName ( name ) ) ) ; 
 + return new ColumnFamilyHistogram ( cfHistogram , keyspaceHistogram , Metrics . histogram ( globalNameFactory . createMetricName ( name ) , considerZeroes ) ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java b / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java 
 index 3051711 . . 3658f3a 100644 
 - - - a / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java 
 + + + b / src / java / org / apache / cassandra / metrics / EstimatedHistogramReservoir . java 
 @ @ - 34 , 14 + 34 , 14 @ @ public class EstimatedHistogramReservoir implements Reservoir 
 EstimatedHistogram histogram ; 
 
 / / Default to > 4 hours of in nanoseconds of buckets 
 - public EstimatedHistogramReservoir ( ) 
 + public EstimatedHistogramReservoir ( boolean considerZeroes ) 
 { 
 - this ( 164 ) ; 
 + this ( 164 , considerZeroes ) ; 
 } 
 
 - public EstimatedHistogramReservoir ( int numBuckets ) 
 + public EstimatedHistogramReservoir ( int numBuckets , boolean considerZeroes ) 
 { 
 - histogram = new EstimatedHistogram ( numBuckets ) ; 
 + histogram = new EstimatedHistogram ( numBuckets , considerZeroes ) ; 
 } 
 
 @ Override 
 @ @ - 100 , 7 + 100 , 7 @ @ public class EstimatedHistogramReservoir implements Reservoir 
 @ Override 
 public double getMean ( ) 
 { 
 - return histogram . mean ( ) ; 
 + return histogram . rawMean ( ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 index e9ce49c . . 369f323 100644 
 - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 @ @ - 221 , 10 + 221 , 10 @ @ public class KeyspaceMetrics 
 writeLatency = new LatencyMetrics ( factory , " Write " ) ; 
 rangeLatency = new LatencyMetrics ( factory , " Range " ) ; 
 / / create histograms for ColumnFamilyMetrics to replicate updates to 
 - sstablesPerReadHistogram = Metrics . histogram ( factory . createMetricName ( " SSTablesPerReadHistogram " ) ) ; 
 - tombstoneScannedHistogram = Metrics . histogram ( factory . createMetricName ( " TombstoneScannedHistogram " ) ) ; 
 - liveScannedHistogram = Metrics . histogram ( factory . createMetricName ( " LiveScannedHistogram " ) ) ; 
 - colUpdateTimeDeltaHistogram = Metrics . histogram ( factory . createMetricName ( " ColUpdateTimeDeltaHistogram " ) ) ; 
 + sstablesPerReadHistogram = Metrics . histogram ( factory . createMetricName ( " SSTablesPerReadHistogram " ) , true ) ; 
 + tombstoneScannedHistogram = Metrics . histogram ( factory . createMetricName ( " TombstoneScannedHistogram " ) , false ) ; 
 + liveScannedHistogram = Metrics . histogram ( factory . createMetricName ( " LiveScannedHistogram " ) , false ) ; 
 + colUpdateTimeDeltaHistogram = Metrics . histogram ( factory . createMetricName ( " ColUpdateTimeDeltaHistogram " ) , false ) ; 
 / / add manually since histograms do not use createKeyspaceGauge method 
 allMetrics . addAll ( Lists . newArrayList ( " SSTablesPerReadHistogram " , " TombstoneScannedHistogram " , " LiveScannedHistogram " ) ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 index 93d142a . . 6c929df 100644 
 - - - a / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 + + + b / src / java / org / apache / cassandra / utils / EstimatedHistogram . java 
 @ @ - 57 , 7 + 57 , 12 @ @ public class EstimatedHistogram 
 
 public EstimatedHistogram ( int bucketCount ) 
 { 
 - bucketOffsets = newOffsets ( bucketCount ) ; 
 + this ( bucketCount , false ) ; 
 + } 
 + 
 + public EstimatedHistogram ( int bucketCount , boolean considerZeroes ) 
 + { 
 + bucketOffsets = newOffsets ( bucketCount , considerZeroes ) ; 
 buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; 
 } 
 
 @ @ - 68 , 12 + 73 , 15 @ @ public class EstimatedHistogram 
 buckets = new AtomicLongArray ( bucketData ) ; 
 } 
 
 - private static long [ ] newOffsets ( int size ) 
 + private static long [ ] newOffsets ( int size , boolean considerZeroes ) 
 { 
 - long [ ] result = new long [ size ] ; 
 + long [ ] result = new long [ size + ( considerZeroes ? 1 : 0 ) ] ; 
 + int i = 0 ; 
 + if ( considerZeroes ) 
 + result [ i + + ] = 0 ; 
 long last = 1 ; 
 - result [ 0 ] = last ; 
 - for ( int i = 1 ; i < size ; i + + ) 
 + result [ i + + ] = last ; 
 + for ( ; i < result . length ; i + + ) 
 { 
 long next = Math . round ( last * 1 . 2 ) ; 
 if ( next = = last ) 
 @ @ - 193 , 11 + 201 , 20 @ @ public class EstimatedHistogram 
 } 
 
 / * * 
 - * @ return the mean histogram value ( average of bucket offsets , weighted by count ) 
 + * @ return the ceil of mean histogram value ( average of bucket offsets , weighted by count ) 
 * @ throws IllegalStateException if any values were greater than the largest bucket threshold 
 * / 
 public long mean ( ) 
 { 
 + return ( long ) Math . ceil ( rawMean ( ) ) ; 
 + } 
 + 
 + / * * 
 + * @ return the mean histogram value ( average of bucket offsets , weighted by count ) 
 + * @ throws IllegalStateException if any values were greater than the largest bucket threshold 
 + * / 
 + public double rawMean ( ) 
 + { 
 int lastBucket = buckets . length ( ) - 1 ; 
 if ( buckets . get ( lastBucket ) > 0 ) 
 throw new IllegalStateException ( " Unable to compute ceiling for max when histogram overflowed " ) ; 
 @ @ - 211 , 7 + 228 , 7 @ @ public class EstimatedHistogram 
 sum + = bCount * bucketOffsets [ i ] ; 
 } 
 
 - return ( long ) Math . ceil ( ( double ) sum / elements ) ; 
 + return ( double ) sum / elements ; 
 } 
 
 / * * 
 diff - - git a / test / unit / org / apache / cassandra / db / RowCacheTest . java b / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 index 9fb322b . . 0c0396c 100644 
 - - - a / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 @ @ - 46 , 10 + 46 , 12 @ @ import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . locator . SimpleStrategy ; 
 + import org . apache . cassandra . metrics . ClearableHistogram ; 
 import org . apache . cassandra . service . CacheService ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 
 public class RowCacheTest 
 { 
 @ @ - 339 , 6 + 341 , 54 @ @ public class RowCacheTest 
 } 
 } 
 
 + @ Test 
 + public void testSSTablesPerReadHistogramWhenRowCache ( ) 
 + { 
 + CompactionManager . instance . disableAutoCompaction ( ) ; 
 + 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE _ CACHED ) ; 
 + ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( CF _ CACHED ) ; 
 + 
 + / / empty the row cache 
 + CacheService . instance . invalidateRowCache ( ) ; 
 + 
 + / / set global row cache size to 1 MB 
 + CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; 
 + 
 + / / inserting 100 rows into both column families 
 + SchemaLoader . insertData ( KEYSPACE _ CACHED , CF _ CACHED , 0 , 100 ) ; 
 + 
 + / / force flush for confidence that SSTables exists 
 + cachedStore . forceBlockingFlush ( ) ; 
 + 
 + ( ( ClearableHistogram ) cachedStore . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; 
 + 
 + for ( int i = 0 ; i < 100 ; i + + ) 
 + { 
 + DecoratedKey key = Util . dk ( " key " + i ) ; 
 + 
 + cachedStore . getColumnFamily ( key , Composites . EMPTY , Composites . EMPTY , false , 1 , System . currentTimeMillis ( ) ) ; 
 + 
 + long count _ before = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; 
 + cachedStore . getColumnFamily ( key , Composites . EMPTY , Composites . EMPTY , false , 1 , System . currentTimeMillis ( ) ) ; 
 + 
 + / / check that SSTablePerReadHistogram has been updated by zero , 
 + / / so count has been increased and in a 1 / 2 of requests there were zero read SSTables 
 + long count _ after = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; 
 + double belowMedian = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getValue ( 0 . 49D ) ; 
 + double mean _ after = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMean ( ) ; 
 + assertEquals ( " SSTablePerReadHistogram should be updated even key found in row cache " , count _ before + 1 , count _ after ) ; 
 + assertTrue ( " In half of requests we have not touched SSTables , " + 
 + " so 49 percentile ( " + belowMedian + " ) must be strongly less than 0 . 9 " , belowMedian < 0 . 9D ) ; 
 + assertTrue ( " In half of requests we have not touched SSTables , " + 
 + " so mean value ( " + mean _ after + " ) must be strongly less than 1 , but greater than 0 " , mean _ after < 0 . 999D & & mean _ after > 0 . 001D ) ; 
 + } 
 + 
 + assertEquals ( " Min value of SSTablesPerRead should be zero " , 0 , cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMin ( ) ) ; 
 + 
 + CacheService . instance . setRowCacheCapacityInMB ( 0 ) ; 
 + } 
 + 
 public void rowCacheLoad ( int totalKeys , int keysToSave , int offset ) throws Exception 
 { 
 CompactionManager . instance . disableAutoCompaction ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 index eebaa25 . . b0e0e4f 100644 
 - - - a / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 + + + b / test / unit / org / apache / cassandra / utils / EstimatedHistogramTest . java 
 @ @ - 28 , 12 + 28 , 23 @ @ public class EstimatedHistogramTest 
 @ Test 
 public void testSimple ( ) 
 { 
 - / / 0 and 1 map to the same , first bucket 
 - EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 - histogram . add ( 0 ) ; 
 - assertEquals ( 1 , histogram . get ( 0 ) ) ; 
 - histogram . add ( 1 ) ; 
 - assertEquals ( 2 , histogram . get ( 0 ) ) ; 
 + { 
 + / / 0 and 1 map to the same , first bucket 
 + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 + histogram . add ( 0 ) ; 
 + assertEquals ( 1 , histogram . get ( 0 ) ) ; 
 + histogram . add ( 1 ) ; 
 + assertEquals ( 2 , histogram . get ( 0 ) ) ; 
 + } 
 + { 
 + / / 0 and 1 map to different buckets 
 + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; 
 + histogram . add ( 0 ) ; 
 + assertEquals ( 1 , histogram . get ( 0 ) ) ; 
 + histogram . add ( 1 ) ; 
 + assertEquals ( 1 , histogram . get ( 0 ) ) ; 
 + assertEquals ( 1 , histogram . get ( 1 ) ) ; 
 + } 
 } 
 
 @ Test 
 @ @ - 55 , 6 + 66 , 33 @ @ public class EstimatedHistogramTest 
 } 
 
 @ Test 
 + public void testMean ( ) 
 + { 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 + for ( int i = 0 ; i < 40 ; i + + ) 
 + histogram . add ( 0 ) ; 
 + for ( int i = 0 ; i < 20 ; i + + ) 
 + histogram . add ( 1 ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + histogram . add ( 2 ) ; 
 + assertEquals ( 70 , histogram . count ( ) ) ; 
 + assertEquals ( 2 , histogram . mean ( ) ) ; 
 + } 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; 
 + for ( int i = 0 ; i < 40 ; i + + ) 
 + histogram . add ( 0 ) ; 
 + for ( int i = 0 ; i < 20 ; i + + ) 
 + histogram . add ( 1 ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + histogram . add ( 2 ) ; 
 + assertEquals ( 70 , histogram . count ( ) ) ; 
 + assertEquals ( 1 , histogram . mean ( ) ) ; 
 + } 
 + } 
 + 
 + @ Test 
 public void testFindingCorrectBuckets ( ) 
 { 
 EstimatedHistogram histogram = new EstimatedHistogram ( ) ; 
 @ @ - 119 , 5 + 157 , 14 @ @ public class EstimatedHistogramTest 
 assertEquals ( 17 , histogram . percentile ( 0 . 60 ) ) ; 
 assertEquals ( 20 , histogram . percentile ( 0 . 80 ) ) ; 
 } 
 + { 
 + EstimatedHistogram histogram = new EstimatedHistogram ( 90 , true ) ; 
 + histogram . add ( 0 ) ; 
 + histogram . add ( 0 ) ; 
 + histogram . add ( 1 ) ; 
 + 
 + assertEquals ( 0 , histogram . percentile ( 0 . 5 ) ) ; 
 + assertEquals ( 1 , histogram . percentile ( 0 . 99 ) ) ; 
 + } 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e268270 . . 42f86f7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 18 , 7 + 18 , 7 @ @ 
 * add nodetool scrub ( CASSANDRA - 2217 ) 
 * fix sstable2json large - row pagination ( CASSANDRA - 2188 ) 
 * fix EOFing on requests for the last bytes in a file ( CASSANDRA - 2213 ) 
 - * fix BRAF performance when seeking to EOF ( CASSANDRA - 2218 ) 
 + * fix BufferedRandomAccessFile bugs ( CASSANDRA - 2218 , - 2241 ) 
 * check for memtable flush _ after _ mins exceeded every 10s ( CASSANDRA - 2183 ) 
 * fix cache saving on Windows ( CASSANDRA - 2207 ) 
 * add validateSchemaAgreement call + synchronization to schema 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 82d8320 . . 3d5ad19 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 172 , 7 + 172 , 7 @ @ public class CommitLog 
 
 for ( File file : clogs ) 
 { 
 - int bufferSize = ( int ) Math . min ( file . length ( ) , 32 * 1024 * 1024 ) ; 
 + int bufferSize = ( int ) Math . min ( Math . max ( file . length ( ) , 1 ) , 32 * 1024 * 1024 ) ; 
 BufferedRandomAccessFile reader = new BufferedRandomAccessFile ( new File ( file . getAbsolutePath ( ) ) , " r " , bufferSize , true ) ; 
 
 try 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / Descriptor . java b / src / java / org / apache / cassandra / io / sstable / Descriptor . java 
 index effeb82 . . 08d3b00 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / Descriptor . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / Descriptor . java 
 @ @ - 76 , 8 + 76 , 8 @ @ public class Descriptor 
 hasStringsInBloomFilter = version . compareTo ( " c " ) < 0 ; 
 hasIntRowSize = version . compareTo ( " d " ) < 0 ; 
 hasEncodedKeys = version . compareTo ( " e " ) < 0 ; 
 - isLatestVersion = version . compareTo ( CURRENT _ VERSION ) = = 0 ; 
 usesOldBloomFilter = version . compareTo ( " f " ) < 0 ; 
 + isLatestVersion = version . compareTo ( CURRENT _ VERSION ) = = 0 ; 
 } 
 
 public String filenameFor ( Component component ) 
 diff - - git a / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java b / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java 
 index 8059c2a . . 073ad72 100644 
 - - - a / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java 
 + + + b / src / java / org / apache / cassandra / io / util / BufferedRandomAccessFile . java 
 @ @ - 47 , 16 + 47 , 16 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 public static final int DEFAULT _ BUFFER _ SIZE = 65535 ; 
 
 / / isDirty - true if this . buffer contains any un - synced bytes 
 - / / hitEOF - true if buffer capacity is less then it ' s maximal size 
 - private boolean isDirty , syncNeeded , hitEOF = false ; 
 + private boolean isDirty , syncNeeded ; 
 
 / / buffer which will cache file blocks 
 - private ByteBuffer buffer ; 
 + private byte [ ] buffer ; 
 
 / / ` current ` as current position in file 
 / / ` bufferOffset ` is the offset of the beginning of the buffer 
 - / / ` bufferEnd ` is ` bufferOffset ` + count of bytes read from file , i . e . the lowest position we can ' t read from the buffer 
 - private long bufferOffset , bufferEnd , current = 0 ; 
 + / / ` validBufferBytes ` is the number of bytes in the buffer that are actually valid ; this will be LESS than buffer capacity if buffer is not full ! 
 + private long bufferOffset , current = 0 ; 
 + private int validBufferBytes = 0 ; 
 
 / / constant , used for caching purpose , - 1 if file is open in " rw " mode 
 / / otherwise this will hold cached file length 
 @ @ - 118 , 11 + 118 , 11 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 / / allocating required size of the buffer 
 if ( bufferSize < = 0 ) 
 throw new IllegalArgumentException ( " bufferSize must be positive " ) ; 
 - buffer = ByteBuffer . allocate ( bufferSize ) ; 
 + buffer = new byte [ bufferSize ] ; 
 + reBuffer ( ) ; 
 
 / / if in read - only mode , caching file size 
 fileLength = ( mode . equals ( " r " ) ) ? this . channel . size ( ) : - 1 ; 
 - bufferEnd = reBuffer ( ) ; / / bufferBottom equals to the bytes read 
 fd = CLibrary . getfd ( this . getFD ( ) ) ; 
 } 
 
 @ @ - 155 , 9 + 155 , 7 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 if ( channel . position ( ) ! = bufferOffset ) 
 channel . position ( bufferOffset ) ; 
 
 - int lengthToWrite = ( int ) ( bufferEnd - bufferOffset ) ; 
 - 
 - super . write ( buffer . array ( ) , 0 , lengthToWrite ) ; 
 + super . write ( buffer , 0 , validBufferBytes ) ; 
 
 if ( skipCache ) 
 { 
 @ @ - 167 , 7 + 165 , 7 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 / / so we continue to clear pages we don ' t need from the first 
 / / offset we see 
 / / periodically we update this starting offset 
 - bytesSinceCacheFlush + = lengthToWrite ; 
 + bytesSinceCacheFlush + = validBufferBytes ; 
 
 if ( bufferOffset < minBufferOffset ) 
 minBufferOffset = bufferOffset ; 
 @ @ - 185 , 66 + 183 , 53 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 } 
 } 
 
 - private long reBuffer ( ) throws IOException 
 + private void reBuffer ( ) throws IOException 
 { 
 flush ( ) ; / / synchronizing buffer and file on disk 
 - buffer . clear ( ) ; 
 - bufferOffset = current ; 
 
 + bufferOffset = current ; 
 if ( bufferOffset > = channel . size ( ) ) 
 { 
 - buffer . rewind ( ) ; 
 - bufferEnd = bufferOffset ; 
 - hitEOF = true ; 
 - 
 - return 0 ; 
 + validBufferBytes = 0 ; 
 + return ; 
 } 
 
 if ( bufferOffset < minBufferOffset ) 
 minBufferOffset = bufferOffset ; 
 
 channel . position ( bufferOffset ) ; / / setting channel position 
 - long bytesRead = channel . read ( buffer ) ; / / reading from that position 
 - 
 - hitEOF = ( bytesRead < buffer . capacity ( ) ) ; / / buffer is not fully loaded with 
 - / / data 
 - bufferEnd = bufferOffset + bytesRead ; 
 - 
 - buffer . rewind ( ) ; 
 - 
 - bytesSinceCacheFlush + = bytesRead ; 
 + int read = 0 ; 
 + while ( read < buffer . length ) 
 + { 
 + int n = super . read ( buffer , read , buffer . length - read ) ; 
 + if ( n < 0 ) 
 + break ; 
 + read + = n ; 
 + } 
 + validBufferBytes = read ; 
 
 + bytesSinceCacheFlush + = read ; 
 if ( skipCache & & bytesSinceCacheFlush > = MAX _ BYTES _ IN _ PAGE _ CACHE ) 
 { 
 CLibrary . trySkipCache ( this . fd , ( int ) minBufferOffset , 0 ) ; 
 bytesSinceCacheFlush = 0 ; 
 minBufferOffset = Long . MAX _ VALUE ; 
 } 
 - 
 - return bytesRead ; 
 } 
 
 @ Override 
 - / / - 1 will be returned if EOF is reached , RandomAccessFile is responsible 
 - / / for 
 - / / throwing EOFException 
 + / / - 1 will be returned if there is nothing to read ; higher - level methods like readInt 
 + / / or readFully ( from RandomAccessFile ) will throw EOFException but this should not 
 public int read ( ) throws IOException 
 { 
 if ( isEOF ( ) ) 
 return - 1 ; / / required by RandomAccessFile 
 
 - if ( current < bufferOffset | | current > = bufferEnd ) 
 - { 
 + if ( current > = bufferOffset + buffer . length ) 
 reBuffer ( ) ; 
 + assert current > = bufferOffset & & current < bufferOffset + validBufferBytes ; 
 
 - if ( current = = bufferEnd & & hitEOF ) 
 - return - 1 ; / / required by RandomAccessFile 
 - } 
 - 
 - byte result = buffer . get ( ) ; 
 - current + + ; 
 - 
 - return ( ( int ) result ) & 0xFF ; 
 + return ( ( int ) buffer [ ( int ) ( current + + - bufferOffset ) ] ) & 0xFF ; 
 } 
 
 @ Override 
 @ @ - 254 , 40 + 239 , 25 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 } 
 
 @ Override 
 - / / - 1 will be returned if EOF is reached ; higher - level methods like readInt 
 + / / - 1 will be returned if there is nothing to read ; higher - level methods like readInt 
 / / or readFully ( from RandomAccessFile ) will throw EOFException but this should not 
 public int read ( byte [ ] buff , int offset , int length ) throws IOException 
 { 
 - int bytesCount = 0 ; 
 - 
 - while ( length > 0 ) 
 - { 
 - int bytesRead = readAtMost ( buff , offset , length ) ; 
 - if ( bytesRead = = - 1 ) 
 - return - 1 ; / / EOF 
 - 
 - offset + = bytesRead ; 
 - length - = bytesRead ; 
 - bytesCount + = bytesRead ; 
 - } 
 - 
 - return bytesCount ; 
 - } 
 + if ( length = = 0 ) 
 + return 0 ; 
 
 - private int readAtMost ( byte [ ] buff , int offset , int length ) throws IOException 
 - { 
 - if ( length > bufferEnd & & hitEOF ) 
 + if ( isEOF ( ) ) 
 return - 1 ; 
 
 - final int left = buffer . capacity ( ) - buffer . position ( ) ; 
 - if ( current < bufferOffset | | left < length ) 
 + if ( current > = bufferOffset + buffer . length ) 
 reBuffer ( ) ; 
 + assert current > = bufferOffset & & current < bufferOffset + validBufferBytes ; 
 
 - length = Math . min ( length , buffer . capacity ( ) - buffer . position ( ) ) ; 
 - buffer . get ( buff , offset , length ) ; 
 - current + = length ; 
 + int toCopy = Math . min ( length , validBufferBytes - ( int ) ( current - bufferOffset ) ) ; 
 + System . arraycopy ( buffer , ( int ) ( current - bufferOffset ) , buff , offset , toCopy ) ; 
 + current + = toCopy ; 
 
 - return length ; 
 + return toCopy ; 
 } 
 
 public ByteBuffer readBytes ( int length ) throws IOException 
 @ @ - 300 , 12 + 270 , 12 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 return ByteBuffer . wrap ( buff ) ; 
 } 
 
 + private final byte [ ] singleByteBuffer = new byte [ 1 ] ; / / so we can use the write ( byte [ ] ) path w / o tons of new byte [ ] allocations 
 @ Override 
 public void write ( int val ) throws IOException 
 { 
 - byte [ ] b = new byte [ 1 ] ; 
 - b [ 0 ] = ( byte ) val ; 
 - this . write ( b , 0 , b . length ) ; 
 + singleByteBuffer [ 0 ] = ( byte ) val ; 
 + this . write ( singleByteBuffer , 0 , 1 ) ; 
 } 
 
 @ Override 
 @ @ - 334 , 21 + 304 , 18 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 * / 
 private int writeAtMost ( byte [ ] buff , int offset , int length ) throws IOException 
 { 
 - final int left = buffer . capacity ( ) - buffer . position ( ) ; 
 - if ( current < bufferOffset | | left < length ) 
 + if ( current > = bufferOffset + buffer . length ) 
 reBuffer ( ) ; 
 + assert current < bufferOffset + buffer . length ; 
 
 - / / logic is the following : we need to add bytes to the end of the buffer 
 - / / starting from current buffer position and return this length 
 - length = Math . min ( length , buffer . capacity ( ) - buffer . position ( ) ) ; 
 - 
 - buffer . put ( buff , offset , length ) ; 
 - current + = length ; 
 + int positionWithinBuffer = ( int ) ( current - bufferOffset ) ; 
 + int toCopy = Math . min ( length , buffer . length - positionWithinBuffer ) ; 
 + System . arraycopy ( buff , offset , buffer , positionWithinBuffer , toCopy ) ; 
 + current + = toCopy ; 
 + validBufferBytes = Math . max ( validBufferBytes , positionWithinBuffer + toCopy ) ; 
 + assert current < = bufferOffset + buffer . length ; 
 
 - if ( current > bufferEnd ) 
 - bufferEnd = current ; 
 - 
 - return length ; 
 + return toCopy ; 
 } 
 
 @ Override 
 @ @ - 356 , 13 + 323 , 8 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 { 
 current = newPosition ; 
 
 - if ( newPosition > = bufferEnd | | newPosition < bufferOffset ) 
 - { 
 + if ( newPosition > = bufferOffset + validBufferBytes | | newPosition < bufferOffset ) 
 reBuffer ( ) ; / / this will set bufferEnd for us 
 - } 
 - 
 - final int delta = ( int ) ( newPosition - bufferOffset ) ; 
 - buffer . position ( delta ) ; 
 } 
 
 @ Override 
 @ @ - 382 , 12 + 344 , 12 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 
 public long length ( ) throws IOException 
 { 
 - return ( fileLength = = - 1 ) ? Math . max ( current , channel . size ( ) ) : fileLength ; 
 + return ( fileLength = = - 1 ) ? Math . max ( Math . max ( current , channel . size ( ) ) , bufferOffset + validBufferBytes ) : fileLength ; 
 } 
 
 public long getFilePointer ( ) 
 { 
 - return bufferOffset + buffer . position ( ) ; 
 + return current ; 
 } 
 
 public String getPath ( ) 
 @ @ - 395 , 6 + 357 , 9 @ @ public class BufferedRandomAccessFile extends RandomAccessFile implements FileDa 
 return filePath ; 
 } 
 
 + / * * 
 + * @ return true if there is no more data to read 
 + * / 
 public boolean isEOF ( ) throws IOException 
 { 
 return getFilePointer ( ) = = length ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java b / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java 
 new file mode 100644 
 index 0000000 . . 62fc998 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / io / sstable / DescriptorTest . java 
 @ @ - 0 , 0 + 1 , 16 @ @ 
 + package org . apache . cassandra . io . sstable ; 
 + 
 + import java . io . File ; 
 + 
 + import org . junit . Test ; 
 + 
 + public class DescriptorTest 
 + { 
 + @ Test 
 + public void testLegacy ( ) 
 + { 
 + Descriptor descriptor = Descriptor . fromFilename ( new File ( " Keyspace1 " ) , " userActionUtilsKey - 9 - Data . db " ) . left ; 
 + assert descriptor . version . equals ( Descriptor . LEGACY _ VERSION ) ; 
 + assert descriptor . usesOldBloomFilter ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 index 606ba09 . . 2116a7e 100644 
 - - - a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 + + + b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . io . File ; 
 import java . io . FileOutputStream ; 
 import java . io . IOException ; 
 import java . util . Arrays ; 
 + import java . util . concurrent . Callable ; 
 
 import org . junit . Test ; 
 
 @ @ - 98 , 37 + 99 , 69 @ @ public class BufferedRandomAccessFileTest 
 rw . write ( 42 ) ; 
 } 
 
 - protected void expectException ( int size , int offset , int len , BufferedRandomAccessFile braf ) 
 + @ Test 
 + public void testNotEOF ( ) throws IOException 
 + { 
 + assertEquals ( 1 , new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 1 ] ) , " rw " ) . read ( new byte [ 2 ] ) ) ; 
 + } 
 + 
 + 
 + protected void expectEOF ( Callable < ? > callable ) 
 { 
 boolean threw = false ; 
 try 
 { 
 - braf . readFully ( new byte [ size ] , offset , len ) ; 
 + callable . call ( ) ; 
 } 
 - catch ( Throwable t ) 
 + catch ( Exception e ) 
 { 
 - assert t . getClass ( ) . equals ( EOFException . class ) : t . getClass ( ) . getName ( ) + " is not " + EOFException . class . getName ( ) ; 
 + assert e . getClass ( ) . equals ( EOFException . class ) : e . getClass ( ) . getName ( ) + " is not " + EOFException . class . getName ( ) ; 
 threw = true ; 
 } 
 assert threw : EOFException . class . getName ( ) + " not received " ; 
 } 
 
 @ Test 
 - public void testEOF ( ) throws Exception 
 + public void testEOF ( ) throws IOException 
 { 
 for ( String mode : Arrays . asList ( " r " , " rw " ) ) / / read , read + write 
 { 
 - for ( int buf : Arrays . asList ( 8 , 16 , 32 , 0 ) ) / / smaller , equal , bigger , zero 
 + for ( int bufferSize : Arrays . asList ( 1 , 2 , 3 , 5 , 8 , 64 ) ) / / smaller , equal , bigger buffer sizes 
 { 
 - for ( int off : Arrays . asList ( 0 , 8 ) ) 
 + final byte [ ] target = new byte [ 32 ] ; 
 + 
 + / / single too - large read 
 + for ( final int offset : Arrays . asList ( 0 , 8 ) ) 
 { 
 - expectException ( 32 , off , 17 , new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , buf ) ) ; 
 + final BufferedRandomAccessFile file = new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , bufferSize ) ; 
 + expectEOF ( new Callable < Object > ( ) 
 + { 
 + public Object call ( ) throws IOException 
 + { 
 + file . readFully ( target , offset , 17 ) ; 
 + return null ; 
 + } 
 + } ) ; 
 + } 
 + 
 + / / first read is ok but eventually EOFs 
 + for ( final int n : Arrays . asList ( 1 , 2 , 4 , 8 ) ) 
 + { 
 + final BufferedRandomAccessFile file = new BufferedRandomAccessFile ( writeTemporaryFile ( new byte [ 16 ] ) , mode , bufferSize ) ; 
 + expectEOF ( new Callable < Object > ( ) 
 + { 
 + public Object call ( ) throws IOException 
 + { 
 + while ( true ) 
 + file . readFully ( target , 0 , n ) ; 
 + } 
 + } ) ; 
 } 
 } 
 } 
 } 
 
 - protected File writeTemporaryFile ( byte [ ] data ) throws Exception 
 + protected File writeTemporaryFile ( byte [ ] data ) throws IOException 
 { 
 File f = File . createTempFile ( " BRAFTestFile " , null ) ; 
 f . deleteOnExit ( ) ; 
 @ @ - 172 , 12 + 205 , 12 @ @ public class BufferedRandomAccessFileTest 
 
 BufferedRandomAccessFile rw = new BufferedRandomAccessFile ( tmpFile . getPath ( ) , " rw " ) ; 
 rw . write ( new byte [ ] { 1 } ) ; 
 - 
 rw . seek ( 0 ) ; 
 + 
 / / test read of buffered - but - not - yet - written data 
 byte [ ] buffer = new byte [ 1 ] ; 
 - assert rw . read ( buffer ) = = 1 ; 
 - assert buffer [ 0 ] = = 1 ; 
 + assertEquals ( 1 , rw . read ( buffer ) ) ; 
 + assertEquals ( 1 , buffer [ 0 ] ) ; 
 rw . close ( ) ; 
 
 / / test read of not - yet - buffered data
