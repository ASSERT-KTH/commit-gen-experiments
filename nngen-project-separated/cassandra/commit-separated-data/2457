BLEU SCORE: 0.06220117374063391

TEST MSG: Validate method for CollectionType
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3a9eb2b . . 4efaa46 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 15 , 6 + 15 , 7 @ @ <nl> * Make batchlog replay asynchronous ( CASSANDRA - 6134 ) <nl> * remove unused classes ( CASSANDRA - 7197 ) <nl> * Limit user types to the keyspace they are defined in ( CASSANDRA - 6643 ) <nl> + * Add validate method to CollectionType ( CASSANDRA - 7208 ) <nl> Merged from 2 . 0 : <nl> * ( Hadoop ) support authentication in CqlRecordReader ( CASSANDRA - 7221 ) <nl> * ( Hadoop ) Close java driver Cluster in CQLRR . close ( CASSANDRA - 7228 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / CollectionType . java b / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> index 7f75a5f . . b1d8da1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> @ @ - 85 , 11 + 85 , 6 @ @ public abstract class CollectionType < T > extends AbstractType < T > <nl> } <nl> } <nl> <nl> - public void validate ( ByteBuffer bytes ) <nl> - { <nl> - valueComparator ( ) . validate ( bytes ) ; <nl> - } <nl> - <nl> @ Override <nl> public boolean isCompatibleWith ( AbstractType < ? > previous ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> index 5452a96 . . 7cddb12 100644 <nl> - - - a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> + + + b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java <nl> @ @ - 25 , 15 + 25 , 11 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> public abstract class CollectionSerializer < T > implements TypeSerializer < T > <nl> { <nl> - public void validate ( ByteBuffer bytes ) throws MarshalException <nl> - { <nl> - / / The collection is not currently being properly validated . <nl> - } <nl> - <nl> protected abstract List < ByteBuffer > serializeValues ( T value ) ; <nl> protected abstract int getElementCount ( T value ) ; <nl> <nl> public abstract T deserializeForNativeProtocol ( ByteBuffer buffer , int version ) ; <nl> + public abstract void validateForNativeProtocol ( ByteBuffer buffer , int version ) ; <nl> <nl> public ByteBuffer serialize ( T value ) <nl> { <nl> @ @ - 52 , 6 + 48 , 12 @ @ public abstract class CollectionSerializer < T > implements TypeSerializer < T > <nl> return deserializeForNativeProtocol ( bytes , 3 ) ; <nl> } <nl> <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + { <nl> + / / Same thing than above <nl> + validateForNativeProtocol ( bytes , 3 ) ; <nl> + } <nl> + <nl> public static ByteBuffer pack ( List < ByteBuffer > buffers , int elements , int version ) <nl> { <nl> int size = 0 ; <nl> diff - - git a / src / java / org / apache / cassandra / serializers / ListSerializer . java b / src / java / org / apache / cassandra / serializers / ListSerializer . java <nl> index e662341 . . b64c012 100644 <nl> - - - a / src / java / org / apache / cassandra / serializers / ListSerializer . java <nl> + + + b / src / java / org / apache / cassandra / serializers / ListSerializer . java <nl> @ @ - 60 , 6 + 60 , 21 @ @ public class ListSerializer < T > extends CollectionSerializer < List < T > > <nl> return value . size ( ) ; <nl> } <nl> <nl> + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) <nl> + { <nl> + try <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + int n = readCollectionSize ( input , version ) ; <nl> + for ( int i = 0 ; i < n ; i + + ) <nl> + elements . validate ( readValue ( input , version ) ) ; <nl> + } <nl> + catch ( BufferUnderflowException e ) <nl> + { <nl> + throw new MarshalException ( " Not enough bytes to read a list " ) ; <nl> + } <nl> + } <nl> + <nl> public List < T > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) <nl> { <nl> try <nl> diff - - git a / src / java / org / apache / cassandra / serializers / MapSerializer . java b / src / java / org / apache / cassandra / serializers / MapSerializer . java <nl> index 5d349dd . . 34e7c05 100644 <nl> - - - a / src / java / org / apache / cassandra / serializers / MapSerializer . java <nl> + + + b / src / java / org / apache / cassandra / serializers / MapSerializer . java <nl> @ @ - 67 , 6 + 67 , 24 @ @ public class MapSerializer < K , V > extends CollectionSerializer < Map < K , V > > <nl> return value . size ( ) ; <nl> } <nl> <nl> + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) <nl> + { <nl> + try <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + int n = readCollectionSize ( input , version ) ; <nl> + for ( int i = 0 ; i < n ; i + + ) <nl> + { <nl> + keys . validate ( readValue ( input , version ) ) ; <nl> + values . validate ( readValue ( input , version ) ) ; <nl> + } <nl> + } <nl> + catch ( BufferUnderflowException e ) <nl> + { <nl> + throw new MarshalException ( " Not enough bytes to read a set " ) ; <nl> + } <nl> + } <nl> + <nl> public Map < K , V > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) <nl> { <nl> try <nl> diff - - git a / src / java / org / apache / cassandra / serializers / SetSerializer . java b / src / java / org / apache / cassandra / serializers / SetSerializer . java <nl> index 812dd68 . . 136b4e0 100644 <nl> - - - a / src / java / org / apache / cassandra / serializers / SetSerializer . java <nl> + + + b / src / java / org / apache / cassandra / serializers / SetSerializer . java <nl> @ @ - 60 , 6 + 60 , 21 @ @ public class SetSerializer < T > extends CollectionSerializer < Set < T > > <nl> return value . size ( ) ; <nl> } <nl> <nl> + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) <nl> + { <nl> + try <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + int n = readCollectionSize ( input , version ) ; <nl> + for ( int i = 0 ; i < n ; i + + ) <nl> + elements . validate ( readValue ( input , version ) ) ; <nl> + } <nl> + catch ( BufferUnderflowException e ) <nl> + { <nl> + throw new MarshalException ( " Not enough bytes to read a set " ) ; <nl> + } <nl> + } <nl> + <nl> public Set < T > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) <nl> { <nl> try <nl> diff - - git a / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java <nl> index c51d304 . . 18156c3 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ <nl> package org . apache . cassandra . db . marshal ; <nl> <nl> import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> <nl> import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . ImmutableMap ; <nl> @ @ - 25 , 8 + 26 , 10 @ @ import com . google . common . collect . ImmutableSet ; <nl> <nl> import org . junit . Test ; <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . fail ; <nl> <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . serializers . * ; <nl> <nl> public class CollectionTypeTest <nl> { <nl> @ @ - 112 , 4 + 115 , 94 @ @ public class CollectionTypeTest <nl> } <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void listSerDerTest ( ) <nl> + { <nl> + ListSerializer < String > sls = ListType . getInstance ( UTF8Type . instance ) . getSerializer ( ) ; <nl> + ListSerializer < Integer > ils = ListType . getInstance ( Int32Type . instance ) . getSerializer ( ) ; <nl> + <nl> + List < String > sl = Arrays . asList ( " Foo " , " Bar " ) ; <nl> + List < Integer > il = Arrays . asList ( 3 , 1 , 5 ) ; <nl> + <nl> + ByteBuffer sb = sls . serialize ( sl ) ; <nl> + ByteBuffer ib = ils . serialize ( il ) ; <nl> + <nl> + assertEquals ( sls . deserialize ( sb ) , sl ) ; <nl> + assertEquals ( ils . deserialize ( ib ) , il ) ; <nl> + <nl> + sls . validate ( sb ) ; <nl> + ils . validate ( ib ) ; <nl> + <nl> + / / string list with integer list type <nl> + assertInvalid ( ils , sb ) ; <nl> + / / non list value <nl> + assertInvalid ( sls , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void setSerDerTest ( ) <nl> + { <nl> + SetSerializer < String > sss = SetType . getInstance ( UTF8Type . instance ) . getSerializer ( ) ; <nl> + SetSerializer < Integer > iss = SetType . getInstance ( Int32Type . instance ) . getSerializer ( ) ; <nl> + <nl> + Set < String > ss = new HashSet ( ) { { add ( " Foo " ) ; add ( " Bar " ) ; } } ; <nl> + Set < Integer > is = new HashSet ( ) { { add ( 3 ) ; add ( 1 ) ; add ( 5 ) ; } } ; <nl> + <nl> + ByteBuffer sb = sss . serialize ( ss ) ; <nl> + ByteBuffer ib = iss . serialize ( is ) ; <nl> + <nl> + assertEquals ( sss . deserialize ( sb ) , ss ) ; <nl> + assertEquals ( iss . deserialize ( ib ) , is ) ; <nl> + <nl> + sss . validate ( sb ) ; <nl> + iss . validate ( ib ) ; <nl> + <nl> + / / string set with integer set type <nl> + assertInvalid ( iss , sb ) ; <nl> + / / non set value <nl> + assertInvalid ( sss , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void setMapDerTest ( ) <nl> + { <nl> + MapSerializer < String , String > sms = MapType . getInstance ( UTF8Type . instance , UTF8Type . instance ) . getSerializer ( ) ; <nl> + MapSerializer < Integer , Integer > ims = MapType . getInstance ( Int32Type . instance , Int32Type . instance ) . getSerializer ( ) ; <nl> + <nl> + Map < String , String > sm = new HashMap ( ) { { put ( " Foo " , " xxx " ) ; put ( " Bar " , " yyy " ) ; } } ; <nl> + Map < Integer , Integer > im = new HashMap ( ) { { put ( 3 , 0 ) ; put ( 1 , 8 ) ; put ( 5 , 2 ) ; } } ; <nl> + <nl> + ByteBuffer sb = sms . serialize ( sm ) ; <nl> + ByteBuffer ib = ims . serialize ( im ) ; <nl> + <nl> + assertEquals ( sms . deserialize ( sb ) , sm ) ; <nl> + assertEquals ( ims . deserialize ( ib ) , im ) ; <nl> + <nl> + sms . validate ( sb ) ; <nl> + ims . validate ( ib ) ; <nl> + <nl> + / / string map with integer map type <nl> + assertInvalid ( ims , sb ) ; <nl> + / / non map value <nl> + assertInvalid ( sms , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; <nl> + <nl> + MapSerializer < Integer , String > sims = MapType . getInstance ( Int32Type . instance , UTF8Type . instance ) . getSerializer ( ) ; <nl> + MapSerializer < String , Integer > isms = MapType . getInstance ( UTF8Type . instance , Int32Type . instance ) . getSerializer ( ) ; <nl> + <nl> + / / only key are invalid <nl> + assertInvalid ( isms , sb ) ; <nl> + / / only values are invalid <nl> + assertInvalid ( sims , sb ) ; <nl> + } <nl> + <nl> + private void assertInvalid ( TypeSerializer < ? > type , ByteBuffer value ) <nl> + { <nl> + try { <nl> + type . validate ( value ) ; <nl> + fail ( " Value " + ByteBufferUtil . bytesToHex ( value ) + " shouldn ' t be valid for type " + type ) ; <nl> + } catch ( MarshalException e ) { <nl> + / / ok , that ' s what we want <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3a9eb2b . . 4efaa46 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 15 , 6 + 15 , 7 @ @ 
 * Make batchlog replay asynchronous ( CASSANDRA - 6134 ) 
 * remove unused classes ( CASSANDRA - 7197 ) 
 * Limit user types to the keyspace they are defined in ( CASSANDRA - 6643 ) 
 + * Add validate method to CollectionType ( CASSANDRA - 7208 ) 
 Merged from 2 . 0 : 
 * ( Hadoop ) support authentication in CqlRecordReader ( CASSANDRA - 7221 ) 
 * ( Hadoop ) Close java driver Cluster in CQLRR . close ( CASSANDRA - 7228 ) 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / CollectionType . java b / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 index 7f75a5f . . b1d8da1 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 @ @ - 85 , 11 + 85 , 6 @ @ public abstract class CollectionType < T > extends AbstractType < T > 
 } 
 } 
 
 - public void validate ( ByteBuffer bytes ) 
 - { 
 - valueComparator ( ) . validate ( bytes ) ; 
 - } 
 - 
 @ Override 
 public boolean isCompatibleWith ( AbstractType < ? > previous ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 index 5452a96 . . 7cddb12 100644 
 - - - a / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 + + + b / src / java / org / apache / cassandra / serializers / CollectionSerializer . java 
 @ @ - 25 , 15 + 25 , 11 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 public abstract class CollectionSerializer < T > implements TypeSerializer < T > 
 { 
 - public void validate ( ByteBuffer bytes ) throws MarshalException 
 - { 
 - / / The collection is not currently being properly validated . 
 - } 
 - 
 protected abstract List < ByteBuffer > serializeValues ( T value ) ; 
 protected abstract int getElementCount ( T value ) ; 
 
 public abstract T deserializeForNativeProtocol ( ByteBuffer buffer , int version ) ; 
 + public abstract void validateForNativeProtocol ( ByteBuffer buffer , int version ) ; 
 
 public ByteBuffer serialize ( T value ) 
 { 
 @ @ - 52 , 6 + 48 , 12 @ @ public abstract class CollectionSerializer < T > implements TypeSerializer < T > 
 return deserializeForNativeProtocol ( bytes , 3 ) ; 
 } 
 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 + { 
 + / / Same thing than above 
 + validateForNativeProtocol ( bytes , 3 ) ; 
 + } 
 + 
 public static ByteBuffer pack ( List < ByteBuffer > buffers , int elements , int version ) 
 { 
 int size = 0 ; 
 diff - - git a / src / java / org / apache / cassandra / serializers / ListSerializer . java b / src / java / org / apache / cassandra / serializers / ListSerializer . java 
 index e662341 . . b64c012 100644 
 - - - a / src / java / org / apache / cassandra / serializers / ListSerializer . java 
 + + + b / src / java / org / apache / cassandra / serializers / ListSerializer . java 
 @ @ - 60 , 6 + 60 , 21 @ @ public class ListSerializer < T > extends CollectionSerializer < List < T > > 
 return value . size ( ) ; 
 } 
 
 + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) 
 + { 
 + try 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + int n = readCollectionSize ( input , version ) ; 
 + for ( int i = 0 ; i < n ; i + + ) 
 + elements . validate ( readValue ( input , version ) ) ; 
 + } 
 + catch ( BufferUnderflowException e ) 
 + { 
 + throw new MarshalException ( " Not enough bytes to read a list " ) ; 
 + } 
 + } 
 + 
 public List < T > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) 
 { 
 try 
 diff - - git a / src / java / org / apache / cassandra / serializers / MapSerializer . java b / src / java / org / apache / cassandra / serializers / MapSerializer . java 
 index 5d349dd . . 34e7c05 100644 
 - - - a / src / java / org / apache / cassandra / serializers / MapSerializer . java 
 + + + b / src / java / org / apache / cassandra / serializers / MapSerializer . java 
 @ @ - 67 , 6 + 67 , 24 @ @ public class MapSerializer < K , V > extends CollectionSerializer < Map < K , V > > 
 return value . size ( ) ; 
 } 
 
 + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) 
 + { 
 + try 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + int n = readCollectionSize ( input , version ) ; 
 + for ( int i = 0 ; i < n ; i + + ) 
 + { 
 + keys . validate ( readValue ( input , version ) ) ; 
 + values . validate ( readValue ( input , version ) ) ; 
 + } 
 + } 
 + catch ( BufferUnderflowException e ) 
 + { 
 + throw new MarshalException ( " Not enough bytes to read a set " ) ; 
 + } 
 + } 
 + 
 public Map < K , V > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) 
 { 
 try 
 diff - - git a / src / java / org / apache / cassandra / serializers / SetSerializer . java b / src / java / org / apache / cassandra / serializers / SetSerializer . java 
 index 812dd68 . . 136b4e0 100644 
 - - - a / src / java / org / apache / cassandra / serializers / SetSerializer . java 
 + + + b / src / java / org / apache / cassandra / serializers / SetSerializer . java 
 @ @ - 60 , 6 + 60 , 21 @ @ public class SetSerializer < T > extends CollectionSerializer < Set < T > > 
 return value . size ( ) ; 
 } 
 
 + public void validateForNativeProtocol ( ByteBuffer bytes , int version ) 
 + { 
 + try 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + int n = readCollectionSize ( input , version ) ; 
 + for ( int i = 0 ; i < n ; i + + ) 
 + elements . validate ( readValue ( input , version ) ) ; 
 + } 
 + catch ( BufferUnderflowException e ) 
 + { 
 + throw new MarshalException ( " Not enough bytes to read a set " ) ; 
 + } 
 + } 
 + 
 public Set < T > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) 
 { 
 try 
 diff - - git a / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java 
 index c51d304 . . 18156c3 100644 
 - - - a / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java 
 + + + b / test / unit / org / apache / cassandra / db / marshal / CollectionTypeTest . java 
 @ @ - 18 , 6 + 18 , 7 @ @ 
 package org . apache . cassandra . db . marshal ; 
 
 import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 
 import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . ImmutableMap ; 
 @ @ - 25 , 8 + 26 , 10 @ @ import com . google . common . collect . ImmutableSet ; 
 
 import org . junit . Test ; 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . fail ; 
 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . serializers . * ; 
 
 public class CollectionTypeTest 
 { 
 @ @ - 112 , 4 + 115 , 94 @ @ public class CollectionTypeTest 
 } 
 } 
 } 
 + 
 + @ Test 
 + public void listSerDerTest ( ) 
 + { 
 + ListSerializer < String > sls = ListType . getInstance ( UTF8Type . instance ) . getSerializer ( ) ; 
 + ListSerializer < Integer > ils = ListType . getInstance ( Int32Type . instance ) . getSerializer ( ) ; 
 + 
 + List < String > sl = Arrays . asList ( " Foo " , " Bar " ) ; 
 + List < Integer > il = Arrays . asList ( 3 , 1 , 5 ) ; 
 + 
 + ByteBuffer sb = sls . serialize ( sl ) ; 
 + ByteBuffer ib = ils . serialize ( il ) ; 
 + 
 + assertEquals ( sls . deserialize ( sb ) , sl ) ; 
 + assertEquals ( ils . deserialize ( ib ) , il ) ; 
 + 
 + sls . validate ( sb ) ; 
 + ils . validate ( ib ) ; 
 + 
 + / / string list with integer list type 
 + assertInvalid ( ils , sb ) ; 
 + / / non list value 
 + assertInvalid ( sls , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void setSerDerTest ( ) 
 + { 
 + SetSerializer < String > sss = SetType . getInstance ( UTF8Type . instance ) . getSerializer ( ) ; 
 + SetSerializer < Integer > iss = SetType . getInstance ( Int32Type . instance ) . getSerializer ( ) ; 
 + 
 + Set < String > ss = new HashSet ( ) { { add ( " Foo " ) ; add ( " Bar " ) ; } } ; 
 + Set < Integer > is = new HashSet ( ) { { add ( 3 ) ; add ( 1 ) ; add ( 5 ) ; } } ; 
 + 
 + ByteBuffer sb = sss . serialize ( ss ) ; 
 + ByteBuffer ib = iss . serialize ( is ) ; 
 + 
 + assertEquals ( sss . deserialize ( sb ) , ss ) ; 
 + assertEquals ( iss . deserialize ( ib ) , is ) ; 
 + 
 + sss . validate ( sb ) ; 
 + iss . validate ( ib ) ; 
 + 
 + / / string set with integer set type 
 + assertInvalid ( iss , sb ) ; 
 + / / non set value 
 + assertInvalid ( sss , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void setMapDerTest ( ) 
 + { 
 + MapSerializer < String , String > sms = MapType . getInstance ( UTF8Type . instance , UTF8Type . instance ) . getSerializer ( ) ; 
 + MapSerializer < Integer , Integer > ims = MapType . getInstance ( Int32Type . instance , Int32Type . instance ) . getSerializer ( ) ; 
 + 
 + Map < String , String > sm = new HashMap ( ) { { put ( " Foo " , " xxx " ) ; put ( " Bar " , " yyy " ) ; } } ; 
 + Map < Integer , Integer > im = new HashMap ( ) { { put ( 3 , 0 ) ; put ( 1 , 8 ) ; put ( 5 , 2 ) ; } } ; 
 + 
 + ByteBuffer sb = sms . serialize ( sm ) ; 
 + ByteBuffer ib = ims . serialize ( im ) ; 
 + 
 + assertEquals ( sms . deserialize ( sb ) , sm ) ; 
 + assertEquals ( ims . deserialize ( ib ) , im ) ; 
 + 
 + sms . validate ( sb ) ; 
 + ims . validate ( ib ) ; 
 + 
 + / / string map with integer map type 
 + assertInvalid ( ims , sb ) ; 
 + / / non map value 
 + assertInvalid ( sms , UTF8Type . instance . getSerializer ( ) . serialize ( " foo " ) ) ; 
 + 
 + MapSerializer < Integer , String > sims = MapType . getInstance ( Int32Type . instance , UTF8Type . instance ) . getSerializer ( ) ; 
 + MapSerializer < String , Integer > isms = MapType . getInstance ( UTF8Type . instance , Int32Type . instance ) . getSerializer ( ) ; 
 + 
 + / / only key are invalid 
 + assertInvalid ( isms , sb ) ; 
 + / / only values are invalid 
 + assertInvalid ( sims , sb ) ; 
 + } 
 + 
 + private void assertInvalid ( TypeSerializer < ? > type , ByteBuffer value ) 
 + { 
 + try { 
 + type . validate ( value ) ; 
 + fail ( " Value " + ByteBufferUtil . bytesToHex ( value ) + " shouldn ' t be valid for type " + type ) ; 
 + } catch ( MarshalException e ) { 
 + / / ok , that ' s what we want 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
