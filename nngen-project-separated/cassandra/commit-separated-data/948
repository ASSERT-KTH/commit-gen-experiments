BLEU SCORE: 0.04767707020457096

TEST MSG: Dont mark sstables as repairing with sub range repairs
GENERATED MSG: Avoid leaking references during parallel repairs

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6e43496 . . e7aa321 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 6 <nl> + * Dont mark sstables as repairing with sub range repairs ( CASSANDRA - 11451 ) <nl> * Fix use of NullUpdater for 2i during compaction ( CASSANDRA - 11450 ) <nl> * Notify when sstables change after cancelling compaction ( CASSANDRA - 11373 ) <nl> * cqlsh : COPY FROM should check that explicit column names are valid ( CASSANDRA - 11333 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index ca02747 . . 675d3cc 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 1176 , 12 + 1176 , 15 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> - Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , validator . desc . parentSessionId ) ; <nl> - <nl> - if ( ! Sets . intersection ( currentlyRepairing , sstablesToValidate ) . isEmpty ( ) ) <nl> + if ( prs . isGlobal ) <nl> { <nl> - logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> - throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> + Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , validator . desc . parentSessionId ) ; <nl> + <nl> + if ( ! Sets . intersection ( currentlyRepairing , sstablesToValidate ) . isEmpty ( ) ) <nl> + { <nl> + logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> + throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> + } <nl> } <nl> <nl> sstables = Refs . tryRef ( sstablesToValidate ) ; <nl> @ @ - 1191 , 8 + 1194 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> throw new RuntimeException ( " Could not reference sstables " ) ; <nl> } <nl> } <nl> - <nl> - prs . addSSTables ( cfs . metadata . cfId , sstablesToValidate ) ; <nl> + if ( prs . isGlobal ) <nl> + prs . addSSTables ( cfs . metadata . cfId , sstablesToValidate ) ; <nl> <nl> return sstables ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> index b8f8b65 . . 8a0706a 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> @ @ - 108 , 16 + 108 , 18 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > <nl> new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( Collections . singleton ( repairingRange ) ) ; <nl> } <nl> } , true ) ; / / ephemeral snapshot , if repair fails , it will be cleaned next startup <nl> - <nl> - Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; <nl> - if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) <nl> + if ( ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . isGlobal ) <nl> { <nl> - / / clear snapshot that we just created <nl> - cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; <nl> - logErrorAndSendFailureResponse ( " Cannot start multiple repair sessions over the same sstables " , message . from , id ) ; <nl> - return ; <nl> + Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; <nl> + if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) <nl> + { <nl> + / / clear snapshot that we just created <nl> + cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; <nl> + logErrorAndSendFailureResponse ( " Cannot start multiple repair sessions over the same sstables " , message . from , id ) ; <nl> + return ; <nl> + } <nl> + ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; <nl> } <nl> - ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; <nl> logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ; <nl> MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) , id , message . from ) ; <nl> break ; <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index 9ac1186 . . 39be051 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 426 , 7 + 426 , 7 @ @ public class ActiveRepairService <nl> private final Map < UUID , Set < SSTableReader > > sstableMap = new HashMap < > ( ) ; <nl> private final long repairedAt ; <nl> public final boolean isIncremental ; <nl> - private final boolean isGlobal ; <nl> + public final boolean isGlobal ; <nl> <nl> public ParentRepairSession ( List < ColumnFamilyStore > columnFamilyStores , Collection < Range < Token > > ranges , boolean isIncremental , boolean isGlobal , long repairedAt ) <nl> {
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6e43496 . . e7aa321 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 6 
 + * Dont mark sstables as repairing with sub range repairs ( CASSANDRA - 11451 ) 
 * Fix use of NullUpdater for 2i during compaction ( CASSANDRA - 11450 ) 
 * Notify when sstables change after cancelling compaction ( CASSANDRA - 11373 ) 
 * cqlsh : COPY FROM should check that explicit column names are valid ( CASSANDRA - 11333 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index ca02747 . . 675d3cc 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 1176 , 12 + 1176 , 15 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 - Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , validator . desc . parentSessionId ) ; 
 - 
 - if ( ! Sets . intersection ( currentlyRepairing , sstablesToValidate ) . isEmpty ( ) ) 
 + if ( prs . isGlobal ) 
 { 
 - logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 - throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 + Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , validator . desc . parentSessionId ) ; 
 + 
 + if ( ! Sets . intersection ( currentlyRepairing , sstablesToValidate ) . isEmpty ( ) ) 
 + { 
 + logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 + throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 + } 
 } 
 
 sstables = Refs . tryRef ( sstablesToValidate ) ; 
 @ @ - 1191 , 8 + 1194 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 throw new RuntimeException ( " Could not reference sstables " ) ; 
 } 
 } 
 - 
 - prs . addSSTables ( cfs . metadata . cfId , sstablesToValidate ) ; 
 + if ( prs . isGlobal ) 
 + prs . addSSTables ( cfs . metadata . cfId , sstablesToValidate ) ; 
 
 return sstables ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 index b8f8b65 . . 8a0706a 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 @ @ - 108 , 16 + 108 , 18 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > 
 new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( Collections . singleton ( repairingRange ) ) ; 
 } 
 } , true ) ; / / ephemeral snapshot , if repair fails , it will be cleaned next startup 
 - 
 - Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; 
 - if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) 
 + if ( ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . isGlobal ) 
 { 
 - / / clear snapshot that we just created 
 - cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; 
 - logErrorAndSendFailureResponse ( " Cannot start multiple repair sessions over the same sstables " , message . from , id ) ; 
 - return ; 
 + Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; 
 + if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) 
 + { 
 + / / clear snapshot that we just created 
 + cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; 
 + logErrorAndSendFailureResponse ( " Cannot start multiple repair sessions over the same sstables " , message . from , id ) ; 
 + return ; 
 + } 
 + ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; 
 } 
 - ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; 
 logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ; 
 MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) , id , message . from ) ; 
 break ; 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index 9ac1186 . . 39be051 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 426 , 7 + 426 , 7 @ @ public class ActiveRepairService 
 private final Map < UUID , Set < SSTableReader > > sstableMap = new HashMap < > ( ) ; 
 private final long repairedAt ; 
 public final boolean isIncremental ; 
 - private final boolean isGlobal ; 
 + public final boolean isGlobal ; 
 
 public ParentRepairSession ( List < ColumnFamilyStore > columnFamilyStores , Collection < Range < Token > > ranges , boolean isIncremental , boolean isGlobal , long repairedAt ) 
 {

NEAREST DIFF:
ELIMINATEDSENTENCE
