BLEU SCORE: 0.0114347838903095

TEST MSG: SSL Cert Hot Reloading should check for sanity of the new keystore / truststore before loading it
GENERATED MSG: Correct and clarify SSLFactory . getSslContext method and call sites

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e8d4598 . . 89c558a8 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * SSL Cert Hot Reloading should check for sanity of the new keystore / truststore before loading it ( CASSANDRA - 14991 ) <nl> * Avoid leaking threads when failing anticompactions and rate limit anticompactions ( CASSANDRA - 15002 ) <nl> * Validate token ( ) arguments early instead of throwing NPE at execution ( CASSANDRA - 14989 ) <nl> * Add a new tool to dump audit logs ( CASSANDRA - 14885 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 5feaea3 . . 9b7a6e5 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 902 , 7 + 902 , 13 @ @ public class DatabaseDescriptor <nl> <nl> public static void applySslContextHotReload ( ) <nl> { <nl> - SSLFactory . initHotReloading ( conf . server _ encryption _ options , conf . client _ encryption _ options , false ) ; <nl> + try <nl> + { <nl> + SSLFactory . initHotReloading ( conf . server _ encryption _ options , conf . client _ encryption _ options , false ) ; <nl> + } catch ( IOException e ) <nl> + { <nl> + throw new ConfigurationException ( " Failed to initialize SSL hot reloading " , e ) ; <nl> + } <nl> } <nl> <nl> public static void applySeedProvider ( ) <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index f5c064e . . f72cd61 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 56 , 6 + 56 , 7 @ @ import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> import org . apache . cassandra . concurrent . Stage ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . EncryptionOptions ; <nl> import org . apache . cassandra . config . EncryptionOptions . ServerEncryptionOptions ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> @ @ - 1716 , 8 + 1717 , 11 @ @ public final class MessagingService implements MessagingServiceMBean <nl> } <nl> <nl> @ Override <nl> - public void reloadSslCertificates ( ) <nl> + public void reloadSslCertificates ( ) throws IOException <nl> { <nl> - SSLFactory . checkCertFilesForHotReloading ( ) ; <nl> + final ServerEncryptionOptions serverOpts = DatabaseDescriptor . getInternodeMessagingEncyptionOptions ( ) ; <nl> + final EncryptionOptions clientOpts = DatabaseDescriptor . getNativeProtocolEncryptionOptions ( ) ; <nl> + SSLFactory . validateSslCerts ( serverOpts , clientOpts ) ; <nl> + SSLFactory . checkCertFilesForHotReloading ( serverOpts , clientOpts ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingServiceMBean . java b / src / java / org / apache / cassandra / net / MessagingServiceMBean . java <nl> index 6adb891 . . 732a5ed 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingServiceMBean . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . net ; <nl> <nl> <nl> <nl> + import java . io . IOException ; <nl> import java . net . UnknownHostException ; <nl> import java . util . Map ; <nl> <nl> @ @ - 130 , 5 + 131 , 5 @ @ public interface MessagingServiceMBean <nl> <nl> public int getVersion ( String address ) throws UnknownHostException ; <nl> <nl> - void reloadSslCertificates ( ) ; <nl> + void reloadSslCertificates ( ) throws IOException ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / net / async / NettyFactory . java b / src / java / org / apache / cassandra / net / async / NettyFactory . java <nl> index 81de5d8 . . 3752927 100644 <nl> - - - a / src / java / org / apache / cassandra / net / async / NettyFactory . java <nl> + + + b / src / java / org / apache / cassandra / net / async / NettyFactory . java <nl> @ @ - 292 , 7 + 292 , 7 @ @ public final class NettyFactory <nl> } <nl> else <nl> { <nl> - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . SERVER ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . SocketType . SERVER ) ; <nl> InetSocketAddress peer = encryptionOptions . require _ endpoint _ verification ? channel . remoteAddress ( ) : null ; <nl> SslHandler sslHandler = newSslHandler ( channel , sslContext , peer ) ; <nl> logger . trace ( " creating inbound netty SslContext : context = { } , engine = { } " , sslContext . getClass ( ) . getName ( ) , sslHandler . engine ( ) . getClass ( ) . getName ( ) ) ; <nl> @ @ - 369 , 7 + 369 , 7 @ @ public final class NettyFactory <nl> / / order of handlers : ssl - > logger - > handshakeHandler <nl> if ( params . encryptionOptions ! = null ) <nl> { <nl> - SslContext sslContext = SSLFactory . getSslContext ( params . encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . CLIENT ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( params . encryptionOptions , true , SSLFactory . SocketType . CLIENT ) ; <nl> / / for some reason channel . remoteAddress ( ) will return null <nl> InetAddressAndPort address = params . connectionId . remote ( ) ; <nl> InetSocketAddress peer = params . encryptionOptions . require _ endpoint _ verification ? new InetSocketAddress ( address . address , address . port ) : null ; <nl> diff - - git a / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java b / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java <nl> index d57518c . . 3b4f794 100644 <nl> - - - a / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java <nl> + + + b / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java <nl> @ @ - 51 , 7 + 51 , 7 @ @ public class OptionalSslHandler extends ByteToMessageDecoder <nl> if ( SslHandler . isEncrypted ( in ) ) <nl> { <nl> / / Connection uses SSL / TLS , replace the detection handler with a SslHandler and so use encryption . <nl> - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . SERVER ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . SocketType . SERVER ) ; <nl> Channel channel = ctx . channel ( ) ; <nl> InetSocketAddress peer = encryptionOptions . require _ endpoint _ verification ? ( InetSocketAddress ) channel . remoteAddress ( ) : null ; <nl> SslHandler sslHandler = NettyFactory . newSslHandler ( channel , sslContext , peer ) ; <nl> diff - - git a / src / java / org / apache / cassandra / security / SSLFactory . java b / src / java / org / apache / cassandra / security / SSLFactory . java <nl> index d64dded . . 700142d 100644 <nl> - - - a / src / java / org / apache / cassandra / security / SSLFactory . java <nl> + + + b / src / java / org / apache / cassandra / security / SSLFactory . java <nl> @ @ - 56 , 6 + 56 , 7 @ @ import io . netty . handler . ssl . SslProvider ; <nl> import io . netty . handler . ssl . SupportedCipherSuiteFilter ; <nl> import io . netty . util . ReferenceCountUtil ; <nl> import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . EncryptionOptions ; <nl> <nl> / * * <nl> @ @ - 71 , 15 + 72 , 6 @ @ public final class SSLFactory <nl> private static final Logger logger = LoggerFactory . getLogger ( SSLFactory . class ) ; <nl> <nl> / * * <nl> - * Indicator if a connection is shared with a client application ( { @ link ConnectionType # NATIVE _ TRANSPORT } ) <nl> - * or another cassandra node ( { @ link ConnectionType # INTERNODE _ MESSAGING } ) . <nl> - * / <nl> - public enum ConnectionType <nl> - { <nl> - NATIVE _ TRANSPORT , INTERNODE _ MESSAGING <nl> - } <nl> - <nl> - / * * <nl> * Indicates if the process holds the inbound / listening end of the socket ( { @ link SocketType # SERVER } ) ) , or the <nl> * outbound side ( { @ link SocketType # CLIENT } ) . <nl> * / <nl> @ @ - 229 , 27 + 221 , 28 @ @ public final class SSLFactory <nl> / * * <nl> * get a netty { @ link SslContext } instance <nl> * / <nl> - public static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , <nl> + public static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , <nl> SocketType socketType ) throws IOException <nl> { <nl> - return getSslContext ( options , buildTruststore , connectionType , socketType , OpenSsl . isAvailable ( ) ) ; <nl> + return getSslContext ( options , buildTruststore , socketType , OpenSsl . isAvailable ( ) ) ; <nl> } <nl> <nl> / * * <nl> * Get a netty { @ link SslContext } instance . <nl> * / <nl> @ VisibleForTesting <nl> - static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , <nl> + static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , <nl> SocketType socketType , boolean useOpenSsl ) throws IOException <nl> { <nl> - CacheKey key = new CacheKey ( options , connectionType , socketType ) ; <nl> + CacheKey key = new CacheKey ( options , socketType ) ; <nl> SslContext sslContext ; <nl> <nl> sslContext = cachedSslContexts . get ( key ) ; <nl> if ( sslContext ! = null ) <nl> return sslContext ; <nl> <nl> - sslContext = createNettySslContext ( options , buildTruststore , connectionType , socketType , useOpenSsl ) ; <nl> + sslContext = createNettySslContext ( options , buildTruststore , socketType , useOpenSsl ) ; <nl> + <nl> SslContext previous = cachedSslContexts . putIfAbsent ( key , sslContext ) ; <nl> if ( previous = = null ) <nl> return sslContext ; <nl> @ @ - 261 , 7 + 254 , 7 @ @ public final class SSLFactory <nl> / * * <nl> * Create a Netty { @ link SslContext } <nl> * / <nl> - static SslContext createNettySslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , <nl> + static SslContext createNettySslContext ( EncryptionOptions options , boolean buildTruststore , <nl> SocketType socketType , boolean useOpenSsl ) throws IOException <nl> { <nl> / * <nl> @ @ - 303 , 7 + 296 , 8 @ @ public final class SSLFactory <nl> * @ throws IllegalStateException if { @ link # initHotReloading ( EncryptionOptions . ServerEncryptionOptions , EncryptionOptions , boolean ) } <nl> * is not called first <nl> * / <nl> - public static void checkCertFilesForHotReloading ( ) <nl> + public static void checkCertFilesForHotReloading ( EncryptionOptions . ServerEncryptionOptions serverOpts , <nl> + EncryptionOptions clientOpts ) <nl> { <nl> if ( ! isHotReloadingInitialized ) <nl> throw new IllegalStateException ( " Hot reloading functionality has not been initialized . " ) ; <nl> @ @ - 313 , 61 + 307 , 104 @ @ public final class SSLFactory <nl> if ( hotReloadableFiles . stream ( ) . anyMatch ( HotReloadableFile : : shouldReload ) ) <nl> { <nl> logger . info ( " SSL certificates have been updated . Reseting the ssl contexts for new connections . " ) ; <nl> - cachedSslContexts . clear ( ) ; <nl> + try <nl> + { <nl> + validateSslCerts ( serverOpts , clientOpts ) ; <nl> + cachedSslContexts . clear ( ) ; <nl> + } catch ( Exception e ) <nl> + { <nl> + logger . error ( " Failed to hot reload the SSL Certificates ! Please check the certificate files . " , e ) ; <nl> + } <nl> } <nl> } <nl> <nl> / * * <nl> * Determines whether to hot reload certificates and schedules a periodic task for it . <nl> * <nl> - * @ param serverEncryptionOptions <nl> - * @ param clientEncryptionOptions <nl> + * @ param serverOpts Server encryption options ( Internode ) <nl> + * @ param clientOpts Client encryption options ( Native Protocol ) <nl> * / <nl> - public static synchronized void initHotReloading ( EncryptionOptions . ServerEncryptionOptions serverEncryptionOptions , <nl> - EncryptionOptions clientEncryptionOptions , <nl> - boolean force ) <nl> + public static synchronized void initHotReloading ( EncryptionOptions . ServerEncryptionOptions serverOpts , <nl> + EncryptionOptions clientOpts , <nl> + boolean force ) throws IOException <nl> { <nl> if ( isHotReloadingInitialized & & ! force ) <nl> return ; <nl> <nl> logger . debug ( " Initializing hot reloading SSLContext " ) ; <nl> <nl> + validateSslCerts ( serverOpts , clientOpts ) ; <nl> + <nl> List < HotReloadableFile > fileList = new ArrayList < > ( ) ; <nl> <nl> - if ( serverEncryptionOptions . enabled ) <nl> + if ( serverOpts ! = null & & serverOpts . enabled ) <nl> { <nl> - fileList . add ( new HotReloadableFile ( serverEncryptionOptions . keystore ) ) ; <nl> - fileList . add ( new HotReloadableFile ( serverEncryptionOptions . truststore ) ) ; <nl> + fileList . add ( new HotReloadableFile ( serverOpts . keystore ) ) ; <nl> + fileList . add ( new HotReloadableFile ( serverOpts . truststore ) ) ; <nl> } <nl> <nl> - if ( clientEncryptionOptions . enabled ) <nl> + if ( clientOpts ! = null & & clientOpts . enabled ) <nl> { <nl> - fileList . add ( new HotReloadableFile ( clientEncryptionOptions . keystore ) ) ; <nl> - fileList . add ( new HotReloadableFile ( clientEncryptionOptions . truststore ) ) ; <nl> + fileList . add ( new HotReloadableFile ( clientOpts . keystore ) ) ; <nl> + fileList . add ( new HotReloadableFile ( clientOpts . truststore ) ) ; <nl> } <nl> <nl> hotReloadableFiles = ImmutableList . copyOf ( fileList ) ; <nl> <nl> if ( ! isHotReloadingInitialized ) <nl> { <nl> - ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( SSLFactory : : checkCertFilesForHotReloading , <nl> - DEFAULT _ HOT _ RELOAD _ INITIAL _ DELAY _ SEC , <nl> - DEFAULT _ HOT _ RELOAD _ PERIOD _ SEC , TimeUnit . SECONDS ) ; <nl> + ScheduledExecutors . scheduledTasks <nl> + . scheduleWithFixedDelay ( ( ) - > checkCertFilesForHotReloading ( <nl> + DatabaseDescriptor . getInternodeMessagingEncyptionOptions ( ) , <nl> + DatabaseDescriptor . getNativeProtocolEncryptionOptions ( ) ) , <nl> + DEFAULT _ HOT _ RELOAD _ INITIAL _ DELAY _ SEC , <nl> + DEFAULT _ HOT _ RELOAD _ PERIOD _ SEC , TimeUnit . SECONDS ) ; <nl> } <nl> <nl> isHotReloadingInitialized = true ; <nl> } <nl> <nl> + <nl> + / * * <nl> + * Sanity checks all certificates to ensure we can actually load them <nl> + * / <nl> + public static void validateSslCerts ( EncryptionOptions . ServerEncryptionOptions serverOpts , EncryptionOptions clientOpts ) throws IOException <nl> + { <nl> + try <nl> + { <nl> + / / Ensure we ' re able to create both server & client SslContexts <nl> + if ( serverOpts ! = null & & serverOpts . enabled ) <nl> + { <nl> + createNettySslContext ( serverOpts , true , SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; <nl> + createNettySslContext ( serverOpts , true , SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> + } <nl> + } catch ( Exception e ) <nl> + { <nl> + throw new IOException ( " Failed to create SSL context using server _ encryption _ options ! " , e ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / Ensure we ' re able to create both server & client SslContexts <nl> + if ( clientOpts ! = null & & clientOpts . enabled ) <nl> + { <nl> + createNettySslContext ( clientOpts , clientOpts . require _ client _ auth , SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; <nl> + createNettySslContext ( clientOpts , clientOpts . require _ client _ auth , SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> + } <nl> + } catch ( Exception e ) <nl> + { <nl> + throw new IOException ( " Failed to create SSL context using client _ encryption _ options ! " , e ) ; <nl> + } <nl> + } <nl> + <nl> static class CacheKey <nl> { <nl> private final EncryptionOptions encryptionOptions ; <nl> - private final ConnectionType connectionType ; <nl> private final SocketType socketType ; <nl> <nl> - public CacheKey ( EncryptionOptions encryptionOptions , ConnectionType connectionType , SocketType socketType ) <nl> + public CacheKey ( EncryptionOptions encryptionOptions , SocketType socketType ) <nl> { <nl> this . encryptionOptions = encryptionOptions ; <nl> - this . connectionType = connectionType ; <nl> this . socketType = socketType ; <nl> } <nl> <nl> @ @ - 376 , 15 + 413 , 13 @ @ public final class SSLFactory <nl> if ( this = = o ) return true ; <nl> if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; <nl> CacheKey cacheKey = ( CacheKey ) o ; <nl> - return ( connectionType = = cacheKey . connectionType & & <nl> - socketType = = cacheKey . socketType & & <nl> + return ( socketType = = cacheKey . socketType & & <nl> Objects . equals ( encryptionOptions , cacheKey . encryptionOptions ) ) ; <nl> } <nl> <nl> public int hashCode ( ) <nl> { <nl> int result = 0 ; <nl> - result + = 31 * connectionType . hashCode ( ) ; <nl> result + = 31 * socketType . hashCode ( ) ; <nl> result + = 31 * encryptionOptions . hashCode ( ) ; <nl> return result ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index 197dd50 . . a2bff26 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 1746 , 7 + 1746 , 7 @ @ public class NodeProbe implements AutoCloseable <nl> return arsProxy ; <nl> } <nl> <nl> - public void reloadSslCerts ( ) <nl> + public void reloadSslCerts ( ) throws IOException <nl> { <nl> msProxy . reloadSslCertificates ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java b / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java <nl> index f38b8c0 . . a572648 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java <nl> + + + b / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . tools ; <nl> <nl> + import java . io . IOException ; <nl> + <nl> import io . airlift . airline . Command ; <nl> <nl> @ Command ( name = " reloadssl " , description = " Signals Cassandra to reload SSL certificates " ) <nl> @ @ - 25 , 6 + 27 , 13 @ @ public class ReloadSslCertificates extends NodeTool . NodeToolCmd <nl> @ Override <nl> public void execute ( NodeProbe probe ) <nl> { <nl> - probe . reloadSslCerts ( ) ; <nl> + try <nl> + { <nl> + probe . reloadSslCerts ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( " Failed to reload SSL certificates . Please check the SSL certificates " , e ) ; <nl> + } <nl> } <nl> - } <nl> \ No newline at end of file <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java <nl> index 67532ac . . 056a4a0 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Server . java <nl> + + + b / src / java / org / apache / cassandra / transport / Server . java <nl> @ @ - 406 , 8 + 406 , 7 @ @ public class Server implements CassandraDaemon . Server <nl> <nl> protected final SslHandler createSslHandler ( ByteBufAllocator allocator ) throws IOException <nl> { <nl> - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , <nl> - SSLFactory . ConnectionType . NATIVE _ TRANSPORT , SSLFactory . SocketType . SERVER ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , SSLFactory . SocketType . SERVER ) ; <nl> return sslContext . newHandler ( allocator ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> index 1334448 . . 0db9136 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> @ @ - 293 , 7 + 293 , 7 @ @ public class SimpleClient implements Closeable <nl> { <nl> super . initChannel ( channel ) ; <nl> SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , <nl> - SSLFactory . ConnectionType . NATIVE _ TRANSPORT , SSLFactory . SocketType . CLIENT ) ; <nl> + SSLFactory . SocketType . CLIENT ) ; <nl> channel . pipeline ( ) . addFirst ( " ssl " , sslContext . newHandler ( channel . alloc ( ) ) ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / security / SSLFactoryTest . java b / test / unit / org / apache / cassandra / security / SSLFactoryTest . java <nl> index 19e88de . . b253c59 100644 <nl> - - - a / test / unit / org / apache / cassandra / security / SSLFactoryTest . java <nl> + + + b / test / unit / org / apache / cassandra / security / SSLFactoryTest . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import java . security . cert . CertificateException ; <nl> import java . util . Arrays ; <nl> import javax . net . ssl . TrustManagerFactory ; <nl> <nl> + import org . apache . commons . io . FileUtils ; <nl> import org . junit . Assert ; <nl> import org . junit . Before ; <nl> import org . junit . Test ; <nl> @ @ - 95 , 8 + 96 , 7 @ @ public class SSLFactoryTest <nl> } <nl> <nl> EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; <nl> - SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> - SSLFactory . SocketType . CLIENT , true ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , true ) ; <nl> Assert . assertNotNull ( sslContext ) ; <nl> Assert . assertTrue ( sslContext instanceof OpenSslContext ) ; <nl> } <nl> @ @ - 105 , 8 + 105 , 7 @ @ public class SSLFactoryTest <nl> public void getSslContext _ JdkSsl ( ) throws IOException <nl> { <nl> EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; <nl> - SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> - SSLFactory . SocketType . CLIENT , false ) ; <nl> + SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , false ) ; <nl> Assert . assertNotNull ( sslContext ) ; <nl> Assert . assertTrue ( sslContext instanceof JdkSslContext ) ; <nl> Assert . assertEquals ( Arrays . asList ( encryptionOptions . cipher _ suites ) , sslContext . cipherSuites ( ) ) ; <nl> @ @ - 175 , 17 + 174 , 17 @ @ public class SSLFactoryTest <nl> <nl> SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; <nl> <nl> - SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> File keystoreFile = new File ( options . keystore ) ; <nl> <nl> - SSLFactory . checkCertFilesForHotReloading ( ) ; <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; <nl> Thread . sleep ( 5000 ) ; <nl> - keystoreFile . setLastModified ( System . currentTimeMillis ( ) ) ; <nl> + FileUtils . touch ( keystoreFile ) ; <nl> <nl> - SSLFactory . checkCertFilesForHotReloading ( ) ; <nl> - SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; <nl> + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> <nl> Assert . assertNotSame ( oldCtx , newCtx ) ; <nl> } <nl> @ @ - 199 , 6 + 198 , 94 @ @ public class SSLFactoryTest <nl> } <nl> } <nl> <nl> + @ Test ( expected = IOException . class ) <nl> + public void testSslFactorySslInit _ BadPassword _ ThrowsException ( ) throws IOException <nl> + { <nl> + EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; <nl> + options . keystore _ password = " bad password " ; <nl> + options . enabled = true ; <nl> + <nl> + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSslFactoryHotReload _ BadPassword _ DoesNotClearExistingSslContext ( ) throws IOException , <nl> + InterruptedException <nl> + { <nl> + try <nl> + { <nl> + addKeystoreOptions ( encryptionOptions ) ; <nl> + <nl> + EncryptionOptions options = new ServerEncryptionOptions ( encryptionOptions ) ; <nl> + options . enabled = true ; <nl> + <nl> + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; <nl> + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> + File keystoreFile = new File ( options . keystore ) ; <nl> + <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; <nl> + Thread . sleep ( 5000 ) ; <nl> + FileUtils . touch ( keystoreFile ) ; <nl> + <nl> + options . keystore _ password = " bad password " ; <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; <nl> + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> + <nl> + Assert . assertSame ( oldCtx , newCtx ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw e ; <nl> + } <nl> + finally <nl> + { <nl> + DatabaseDescriptor . loadConfig ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testSslFactoryHotReload _ CorruptOrNonExistentFile _ DoesNotClearExistingSslContext ( ) throws IOException , <nl> + InterruptedException <nl> + { <nl> + try <nl> + { <nl> + addKeystoreOptions ( encryptionOptions ) ; <nl> + <nl> + File testKeystoreFile = new File ( encryptionOptions . keystore + " . test " ) ; <nl> + FileUtils . copyFile ( new File ( encryptionOptions . keystore ) , testKeystoreFile ) ; <nl> + encryptionOptions . keystore = testKeystoreFile . getPath ( ) ; <nl> + <nl> + EncryptionOptions options = new ServerEncryptionOptions ( encryptionOptions ) ; <nl> + options . enabled = true ; <nl> + <nl> + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; <nl> + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; <nl> + Thread . sleep ( 5000 ) ; <nl> + <nl> + FileUtils . touch ( testKeystoreFile ) ; <nl> + FileUtils . forceDelete ( testKeystoreFile ) ; <nl> + <nl> + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; <nl> + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl <nl> + . isAvailable ( ) ) ; <nl> + <nl> + Assert . assertSame ( oldCtx , newCtx ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw e ; <nl> + } <nl> + finally <nl> + { <nl> + DatabaseDescriptor . loadConfig ( ) ; <nl> + FileUtils . deleteQuietly ( new File ( encryptionOptions . keystore + " . test " ) ) ; <nl> + } <nl> + } <nl> + <nl> @ Test <nl> public void getSslContext _ ParamChanges ( ) throws IOException <nl> { <nl> @ @ - 206 , 15 + 293 , 15 @ @ public class SSLFactoryTest <nl> options . enabled = true ; <nl> options . cipher _ suites = new String [ ] { " TLS _ ECDHE _ ECDSA _ WITH _ AES _ 128 _ GCM _ SHA256 " } ; <nl> <nl> - SslContext ctx1 = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> + SslContext ctx1 = SSLFactory . getSslContext ( options , true , <nl> + SSLFactory . SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; <nl> <nl> - Assert . assertTrue ( ctx1 . isClient ( ) ) ; <nl> + Assert . assertTrue ( ctx1 . isServer ( ) ) ; <nl> Assert . assertArrayEquals ( ctx1 . cipherSuites ( ) . toArray ( ) , options . cipher _ suites ) ; <nl> <nl> options . cipher _ suites = new String [ ] { " TLS _ ECDHE _ RSA _ WITH _ AES _ 128 _ GCM _ SHA256 " } ; <nl> <nl> - SslContext ctx2 = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , <nl> + SslContext ctx2 = SSLFactory . getSslContext ( options , true , <nl> SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; <nl> <nl> Assert . assertTrue ( ctx2 . isClient ( ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e8d4598 . . 89c558a8 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * SSL Cert Hot Reloading should check for sanity of the new keystore / truststore before loading it ( CASSANDRA - 14991 ) 
 * Avoid leaking threads when failing anticompactions and rate limit anticompactions ( CASSANDRA - 15002 ) 
 * Validate token ( ) arguments early instead of throwing NPE at execution ( CASSANDRA - 14989 ) 
 * Add a new tool to dump audit logs ( CASSANDRA - 14885 ) 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 5feaea3 . . 9b7a6e5 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 902 , 7 + 902 , 13 @ @ public class DatabaseDescriptor 
 
 public static void applySslContextHotReload ( ) 
 { 
 - SSLFactory . initHotReloading ( conf . server _ encryption _ options , conf . client _ encryption _ options , false ) ; 
 + try 
 + { 
 + SSLFactory . initHotReloading ( conf . server _ encryption _ options , conf . client _ encryption _ options , false ) ; 
 + } catch ( IOException e ) 
 + { 
 + throw new ConfigurationException ( " Failed to initialize SSL hot reloading " , e ) ; 
 + } 
 } 
 
 public static void applySeedProvider ( ) 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index f5c064e . . f72cd61 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 56 , 6 + 56 , 7 @ @ import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 import org . apache . cassandra . concurrent . Stage ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . EncryptionOptions ; 
 import org . apache . cassandra . config . EncryptionOptions . ServerEncryptionOptions ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 @ @ - 1716 , 8 + 1717 , 11 @ @ public final class MessagingService implements MessagingServiceMBean 
 } 
 
 @ Override 
 - public void reloadSslCertificates ( ) 
 + public void reloadSslCertificates ( ) throws IOException 
 { 
 - SSLFactory . checkCertFilesForHotReloading ( ) ; 
 + final ServerEncryptionOptions serverOpts = DatabaseDescriptor . getInternodeMessagingEncyptionOptions ( ) ; 
 + final EncryptionOptions clientOpts = DatabaseDescriptor . getNativeProtocolEncryptionOptions ( ) ; 
 + SSLFactory . validateSslCerts ( serverOpts , clientOpts ) ; 
 + SSLFactory . checkCertFilesForHotReloading ( serverOpts , clientOpts ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingServiceMBean . java b / src / java / org / apache / cassandra / net / MessagingServiceMBean . java 
 index 6adb891 . . 732a5ed 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingServiceMBean . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . net ; 
 
 
 
 + import java . io . IOException ; 
 import java . net . UnknownHostException ; 
 import java . util . Map ; 
 
 @ @ - 130 , 5 + 131 , 5 @ @ public interface MessagingServiceMBean 
 
 public int getVersion ( String address ) throws UnknownHostException ; 
 
 - void reloadSslCertificates ( ) ; 
 + void reloadSslCertificates ( ) throws IOException ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / net / async / NettyFactory . java b / src / java / org / apache / cassandra / net / async / NettyFactory . java 
 index 81de5d8 . . 3752927 100644 
 - - - a / src / java / org / apache / cassandra / net / async / NettyFactory . java 
 + + + b / src / java / org / apache / cassandra / net / async / NettyFactory . java 
 @ @ - 292 , 7 + 292 , 7 @ @ public final class NettyFactory 
 } 
 else 
 { 
 - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . SERVER ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . SocketType . SERVER ) ; 
 InetSocketAddress peer = encryptionOptions . require _ endpoint _ verification ? channel . remoteAddress ( ) : null ; 
 SslHandler sslHandler = newSslHandler ( channel , sslContext , peer ) ; 
 logger . trace ( " creating inbound netty SslContext : context = { } , engine = { } " , sslContext . getClass ( ) . getName ( ) , sslHandler . engine ( ) . getClass ( ) . getName ( ) ) ; 
 @ @ - 369 , 7 + 369 , 7 @ @ public final class NettyFactory 
 / / order of handlers : ssl - > logger - > handshakeHandler 
 if ( params . encryptionOptions ! = null ) 
 { 
 - SslContext sslContext = SSLFactory . getSslContext ( params . encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . CLIENT ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( params . encryptionOptions , true , SSLFactory . SocketType . CLIENT ) ; 
 / / for some reason channel . remoteAddress ( ) will return null 
 InetAddressAndPort address = params . connectionId . remote ( ) ; 
 InetSocketAddress peer = params . encryptionOptions . require _ endpoint _ verification ? new InetSocketAddress ( address . address , address . port ) : null ; 
 diff - - git a / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java b / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java 
 index d57518c . . 3b4f794 100644 
 - - - a / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java 
 + + + b / src / java / org / apache / cassandra / net / async / OptionalSslHandler . java 
 @ @ - 51 , 7 + 51 , 7 @ @ public class OptionalSslHandler extends ByteToMessageDecoder 
 if ( SslHandler . isEncrypted ( in ) ) 
 { 
 / / Connection uses SSL / TLS , replace the detection handler with a SslHandler and so use encryption . 
 - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . ConnectionType . INTERNODE _ MESSAGING , SSLFactory . SocketType . SERVER ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , true , SSLFactory . SocketType . SERVER ) ; 
 Channel channel = ctx . channel ( ) ; 
 InetSocketAddress peer = encryptionOptions . require _ endpoint _ verification ? ( InetSocketAddress ) channel . remoteAddress ( ) : null ; 
 SslHandler sslHandler = NettyFactory . newSslHandler ( channel , sslContext , peer ) ; 
 diff - - git a / src / java / org / apache / cassandra / security / SSLFactory . java b / src / java / org / apache / cassandra / security / SSLFactory . java 
 index d64dded . . 700142d 100644 
 - - - a / src / java / org / apache / cassandra / security / SSLFactory . java 
 + + + b / src / java / org / apache / cassandra / security / SSLFactory . java 
 @ @ - 56 , 6 + 56 , 7 @ @ import io . netty . handler . ssl . SslProvider ; 
 import io . netty . handler . ssl . SupportedCipherSuiteFilter ; 
 import io . netty . util . ReferenceCountUtil ; 
 import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . EncryptionOptions ; 
 
 / * * 
 @ @ - 71 , 15 + 72 , 6 @ @ public final class SSLFactory 
 private static final Logger logger = LoggerFactory . getLogger ( SSLFactory . class ) ; 
 
 / * * 
 - * Indicator if a connection is shared with a client application ( { @ link ConnectionType # NATIVE _ TRANSPORT } ) 
 - * or another cassandra node ( { @ link ConnectionType # INTERNODE _ MESSAGING } ) . 
 - * / 
 - public enum ConnectionType 
 - { 
 - NATIVE _ TRANSPORT , INTERNODE _ MESSAGING 
 - } 
 - 
 - / * * 
 * Indicates if the process holds the inbound / listening end of the socket ( { @ link SocketType # SERVER } ) ) , or the 
 * outbound side ( { @ link SocketType # CLIENT } ) . 
 * / 
 @ @ - 229 , 27 + 221 , 28 @ @ public final class SSLFactory 
 / * * 
 * get a netty { @ link SslContext } instance 
 * / 
 - public static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , 
 + public static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , 
 SocketType socketType ) throws IOException 
 { 
 - return getSslContext ( options , buildTruststore , connectionType , socketType , OpenSsl . isAvailable ( ) ) ; 
 + return getSslContext ( options , buildTruststore , socketType , OpenSsl . isAvailable ( ) ) ; 
 } 
 
 / * * 
 * Get a netty { @ link SslContext } instance . 
 * / 
 @ VisibleForTesting 
 - static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , 
 + static SslContext getSslContext ( EncryptionOptions options , boolean buildTruststore , 
 SocketType socketType , boolean useOpenSsl ) throws IOException 
 { 
 - CacheKey key = new CacheKey ( options , connectionType , socketType ) ; 
 + CacheKey key = new CacheKey ( options , socketType ) ; 
 SslContext sslContext ; 
 
 sslContext = cachedSslContexts . get ( key ) ; 
 if ( sslContext ! = null ) 
 return sslContext ; 
 
 - sslContext = createNettySslContext ( options , buildTruststore , connectionType , socketType , useOpenSsl ) ; 
 + sslContext = createNettySslContext ( options , buildTruststore , socketType , useOpenSsl ) ; 
 + 
 SslContext previous = cachedSslContexts . putIfAbsent ( key , sslContext ) ; 
 if ( previous = = null ) 
 return sslContext ; 
 @ @ - 261 , 7 + 254 , 7 @ @ public final class SSLFactory 
 / * * 
 * Create a Netty { @ link SslContext } 
 * / 
 - static SslContext createNettySslContext ( EncryptionOptions options , boolean buildTruststore , ConnectionType connectionType , 
 + static SslContext createNettySslContext ( EncryptionOptions options , boolean buildTruststore , 
 SocketType socketType , boolean useOpenSsl ) throws IOException 
 { 
 / * 
 @ @ - 303 , 7 + 296 , 8 @ @ public final class SSLFactory 
 * @ throws IllegalStateException if { @ link # initHotReloading ( EncryptionOptions . ServerEncryptionOptions , EncryptionOptions , boolean ) } 
 * is not called first 
 * / 
 - public static void checkCertFilesForHotReloading ( ) 
 + public static void checkCertFilesForHotReloading ( EncryptionOptions . ServerEncryptionOptions serverOpts , 
 + EncryptionOptions clientOpts ) 
 { 
 if ( ! isHotReloadingInitialized ) 
 throw new IllegalStateException ( " Hot reloading functionality has not been initialized . " ) ; 
 @ @ - 313 , 61 + 307 , 104 @ @ public final class SSLFactory 
 if ( hotReloadableFiles . stream ( ) . anyMatch ( HotReloadableFile : : shouldReload ) ) 
 { 
 logger . info ( " SSL certificates have been updated . Reseting the ssl contexts for new connections . " ) ; 
 - cachedSslContexts . clear ( ) ; 
 + try 
 + { 
 + validateSslCerts ( serverOpts , clientOpts ) ; 
 + cachedSslContexts . clear ( ) ; 
 + } catch ( Exception e ) 
 + { 
 + logger . error ( " Failed to hot reload the SSL Certificates ! Please check the certificate files . " , e ) ; 
 + } 
 } 
 } 
 
 / * * 
 * Determines whether to hot reload certificates and schedules a periodic task for it . 
 * 
 - * @ param serverEncryptionOptions 
 - * @ param clientEncryptionOptions 
 + * @ param serverOpts Server encryption options ( Internode ) 
 + * @ param clientOpts Client encryption options ( Native Protocol ) 
 * / 
 - public static synchronized void initHotReloading ( EncryptionOptions . ServerEncryptionOptions serverEncryptionOptions , 
 - EncryptionOptions clientEncryptionOptions , 
 - boolean force ) 
 + public static synchronized void initHotReloading ( EncryptionOptions . ServerEncryptionOptions serverOpts , 
 + EncryptionOptions clientOpts , 
 + boolean force ) throws IOException 
 { 
 if ( isHotReloadingInitialized & & ! force ) 
 return ; 
 
 logger . debug ( " Initializing hot reloading SSLContext " ) ; 
 
 + validateSslCerts ( serverOpts , clientOpts ) ; 
 + 
 List < HotReloadableFile > fileList = new ArrayList < > ( ) ; 
 
 - if ( serverEncryptionOptions . enabled ) 
 + if ( serverOpts ! = null & & serverOpts . enabled ) 
 { 
 - fileList . add ( new HotReloadableFile ( serverEncryptionOptions . keystore ) ) ; 
 - fileList . add ( new HotReloadableFile ( serverEncryptionOptions . truststore ) ) ; 
 + fileList . add ( new HotReloadableFile ( serverOpts . keystore ) ) ; 
 + fileList . add ( new HotReloadableFile ( serverOpts . truststore ) ) ; 
 } 
 
 - if ( clientEncryptionOptions . enabled ) 
 + if ( clientOpts ! = null & & clientOpts . enabled ) 
 { 
 - fileList . add ( new HotReloadableFile ( clientEncryptionOptions . keystore ) ) ; 
 - fileList . add ( new HotReloadableFile ( clientEncryptionOptions . truststore ) ) ; 
 + fileList . add ( new HotReloadableFile ( clientOpts . keystore ) ) ; 
 + fileList . add ( new HotReloadableFile ( clientOpts . truststore ) ) ; 
 } 
 
 hotReloadableFiles = ImmutableList . copyOf ( fileList ) ; 
 
 if ( ! isHotReloadingInitialized ) 
 { 
 - ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( SSLFactory : : checkCertFilesForHotReloading , 
 - DEFAULT _ HOT _ RELOAD _ INITIAL _ DELAY _ SEC , 
 - DEFAULT _ HOT _ RELOAD _ PERIOD _ SEC , TimeUnit . SECONDS ) ; 
 + ScheduledExecutors . scheduledTasks 
 + . scheduleWithFixedDelay ( ( ) - > checkCertFilesForHotReloading ( 
 + DatabaseDescriptor . getInternodeMessagingEncyptionOptions ( ) , 
 + DatabaseDescriptor . getNativeProtocolEncryptionOptions ( ) ) , 
 + DEFAULT _ HOT _ RELOAD _ INITIAL _ DELAY _ SEC , 
 + DEFAULT _ HOT _ RELOAD _ PERIOD _ SEC , TimeUnit . SECONDS ) ; 
 } 
 
 isHotReloadingInitialized = true ; 
 } 
 
 + 
 + / * * 
 + * Sanity checks all certificates to ensure we can actually load them 
 + * / 
 + public static void validateSslCerts ( EncryptionOptions . ServerEncryptionOptions serverOpts , EncryptionOptions clientOpts ) throws IOException 
 + { 
 + try 
 + { 
 + / / Ensure we ' re able to create both server & client SslContexts 
 + if ( serverOpts ! = null & & serverOpts . enabled ) 
 + { 
 + createNettySslContext ( serverOpts , true , SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; 
 + createNettySslContext ( serverOpts , true , SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 + } 
 + } catch ( Exception e ) 
 + { 
 + throw new IOException ( " Failed to create SSL context using server _ encryption _ options ! " , e ) ; 
 + } 
 + 
 + try 
 + { 
 + / / Ensure we ' re able to create both server & client SslContexts 
 + if ( clientOpts ! = null & & clientOpts . enabled ) 
 + { 
 + createNettySslContext ( clientOpts , clientOpts . require _ client _ auth , SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; 
 + createNettySslContext ( clientOpts , clientOpts . require _ client _ auth , SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 + } 
 + } catch ( Exception e ) 
 + { 
 + throw new IOException ( " Failed to create SSL context using client _ encryption _ options ! " , e ) ; 
 + } 
 + } 
 + 
 static class CacheKey 
 { 
 private final EncryptionOptions encryptionOptions ; 
 - private final ConnectionType connectionType ; 
 private final SocketType socketType ; 
 
 - public CacheKey ( EncryptionOptions encryptionOptions , ConnectionType connectionType , SocketType socketType ) 
 + public CacheKey ( EncryptionOptions encryptionOptions , SocketType socketType ) 
 { 
 this . encryptionOptions = encryptionOptions ; 
 - this . connectionType = connectionType ; 
 this . socketType = socketType ; 
 } 
 
 @ @ - 376 , 15 + 413 , 13 @ @ public final class SSLFactory 
 if ( this = = o ) return true ; 
 if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; 
 CacheKey cacheKey = ( CacheKey ) o ; 
 - return ( connectionType = = cacheKey . connectionType & & 
 - socketType = = cacheKey . socketType & & 
 + return ( socketType = = cacheKey . socketType & & 
 Objects . equals ( encryptionOptions , cacheKey . encryptionOptions ) ) ; 
 } 
 
 public int hashCode ( ) 
 { 
 int result = 0 ; 
 - result + = 31 * connectionType . hashCode ( ) ; 
 result + = 31 * socketType . hashCode ( ) ; 
 result + = 31 * encryptionOptions . hashCode ( ) ; 
 return result ; 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index 197dd50 . . a2bff26 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 1746 , 7 + 1746 , 7 @ @ public class NodeProbe implements AutoCloseable 
 return arsProxy ; 
 } 
 
 - public void reloadSslCerts ( ) 
 + public void reloadSslCerts ( ) throws IOException 
 { 
 msProxy . reloadSslCertificates ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java b / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java 
 index f38b8c0 . . a572648 100644 
 - - - a / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java 
 + + + b / src / java / org / apache / cassandra / tools / ReloadSslCertificates . java 
 @ @ - 17 , 6 + 17 , 8 @ @ 
 * / 
 package org . apache . cassandra . tools ; 
 
 + import java . io . IOException ; 
 + 
 import io . airlift . airline . Command ; 
 
 @ Command ( name = " reloadssl " , description = " Signals Cassandra to reload SSL certificates " ) 
 @ @ - 25 , 6 + 27 , 13 @ @ public class ReloadSslCertificates extends NodeTool . NodeToolCmd 
 @ Override 
 public void execute ( NodeProbe probe ) 
 { 
 - probe . reloadSslCerts ( ) ; 
 + try 
 + { 
 + probe . reloadSslCerts ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( " Failed to reload SSL certificates . Please check the SSL certificates " , e ) ; 
 + } 
 } 
 - } 
 \ No newline at end of file 
 + } 
 diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java 
 index 67532ac . . 056a4a0 100644 
 - - - a / src / java / org / apache / cassandra / transport / Server . java 
 + + + b / src / java / org / apache / cassandra / transport / Server . java 
 @ @ - 406 , 8 + 406 , 7 @ @ public class Server implements CassandraDaemon . Server 
 
 protected final SslHandler createSslHandler ( ByteBufAllocator allocator ) throws IOException 
 { 
 - SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , 
 - SSLFactory . ConnectionType . NATIVE _ TRANSPORT , SSLFactory . SocketType . SERVER ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , SSLFactory . SocketType . SERVER ) ; 
 return sslContext . newHandler ( allocator ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 index 1334448 . . 0db9136 100644 
 - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java 
 + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 @ @ - 293 , 7 + 293 , 7 @ @ public class SimpleClient implements Closeable 
 { 
 super . initChannel ( channel ) ; 
 SslContext sslContext = SSLFactory . getSslContext ( encryptionOptions , encryptionOptions . require _ client _ auth , 
 - SSLFactory . ConnectionType . NATIVE _ TRANSPORT , SSLFactory . SocketType . CLIENT ) ; 
 + SSLFactory . SocketType . CLIENT ) ; 
 channel . pipeline ( ) . addFirst ( " ssl " , sslContext . newHandler ( channel . alloc ( ) ) ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / security / SSLFactoryTest . java b / test / unit / org / apache / cassandra / security / SSLFactoryTest . java 
 index 19e88de . . b253c59 100644 
 - - - a / test / unit / org / apache / cassandra / security / SSLFactoryTest . java 
 + + + b / test / unit / org / apache / cassandra / security / SSLFactoryTest . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import java . security . cert . CertificateException ; 
 import java . util . Arrays ; 
 import javax . net . ssl . TrustManagerFactory ; 
 
 + import org . apache . commons . io . FileUtils ; 
 import org . junit . Assert ; 
 import org . junit . Before ; 
 import org . junit . Test ; 
 @ @ - 95 , 8 + 96 , 7 @ @ public class SSLFactoryTest 
 } 
 
 EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; 
 - SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 - SSLFactory . SocketType . CLIENT , true ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , true ) ; 
 Assert . assertNotNull ( sslContext ) ; 
 Assert . assertTrue ( sslContext instanceof OpenSslContext ) ; 
 } 
 @ @ - 105 , 8 + 105 , 7 @ @ public class SSLFactoryTest 
 public void getSslContext _ JdkSsl ( ) throws IOException 
 { 
 EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; 
 - SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 - SSLFactory . SocketType . CLIENT , false ) ; 
 + SslContext sslContext = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , false ) ; 
 Assert . assertNotNull ( sslContext ) ; 
 Assert . assertTrue ( sslContext instanceof JdkSslContext ) ; 
 Assert . assertEquals ( Arrays . asList ( encryptionOptions . cipher _ suites ) , sslContext . cipherSuites ( ) ) ; 
 @ @ - 175 , 17 + 174 , 17 @ @ public class SSLFactoryTest 
 
 SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; 
 
 - SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 File keystoreFile = new File ( options . keystore ) ; 
 
 - SSLFactory . checkCertFilesForHotReloading ( ) ; 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; 
 Thread . sleep ( 5000 ) ; 
 - keystoreFile . setLastModified ( System . currentTimeMillis ( ) ) ; 
 + FileUtils . touch ( keystoreFile ) ; 
 
 - SSLFactory . checkCertFilesForHotReloading ( ) ; 
 - SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; 
 + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 
 Assert . assertNotSame ( oldCtx , newCtx ) ; 
 } 
 @ @ - 199 , 6 + 198 , 94 @ @ public class SSLFactoryTest 
 } 
 } 
 
 + @ Test ( expected = IOException . class ) 
 + public void testSslFactorySslInit _ BadPassword _ ThrowsException ( ) throws IOException 
 + { 
 + EncryptionOptions options = addKeystoreOptions ( encryptionOptions ) ; 
 + options . keystore _ password = " bad password " ; 
 + options . enabled = true ; 
 + 
 + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; 
 + } 
 + 
 + @ Test 
 + public void testSslFactoryHotReload _ BadPassword _ DoesNotClearExistingSslContext ( ) throws IOException , 
 + InterruptedException 
 + { 
 + try 
 + { 
 + addKeystoreOptions ( encryptionOptions ) ; 
 + 
 + EncryptionOptions options = new ServerEncryptionOptions ( encryptionOptions ) ; 
 + options . enabled = true ; 
 + 
 + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; 
 + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 + File keystoreFile = new File ( options . keystore ) ; 
 + 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; 
 + Thread . sleep ( 5000 ) ; 
 + FileUtils . touch ( keystoreFile ) ; 
 + 
 + options . keystore _ password = " bad password " ; 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; 
 + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 + 
 + Assert . assertSame ( oldCtx , newCtx ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw e ; 
 + } 
 + finally 
 + { 
 + DatabaseDescriptor . loadConfig ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testSslFactoryHotReload _ CorruptOrNonExistentFile _ DoesNotClearExistingSslContext ( ) throws IOException , 
 + InterruptedException 
 + { 
 + try 
 + { 
 + addKeystoreOptions ( encryptionOptions ) ; 
 + 
 + File testKeystoreFile = new File ( encryptionOptions . keystore + " . test " ) ; 
 + FileUtils . copyFile ( new File ( encryptionOptions . keystore ) , testKeystoreFile ) ; 
 + encryptionOptions . keystore = testKeystoreFile . getPath ( ) ; 
 + 
 + EncryptionOptions options = new ServerEncryptionOptions ( encryptionOptions ) ; 
 + options . enabled = true ; 
 + 
 + SSLFactory . initHotReloading ( ( ServerEncryptionOptions ) options , options , true ) ; 
 + SslContext oldCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; 
 + Thread . sleep ( 5000 ) ; 
 + 
 + FileUtils . touch ( testKeystoreFile ) ; 
 + FileUtils . forceDelete ( testKeystoreFile ) ; 
 + 
 + SSLFactory . checkCertFilesForHotReloading ( ( ServerEncryptionOptions ) options , options ) ; ; 
 + SslContext newCtx = SSLFactory . getSslContext ( options , true , SSLFactory . SocketType . CLIENT , OpenSsl 
 + . isAvailable ( ) ) ; 
 + 
 + Assert . assertSame ( oldCtx , newCtx ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw e ; 
 + } 
 + finally 
 + { 
 + DatabaseDescriptor . loadConfig ( ) ; 
 + FileUtils . deleteQuietly ( new File ( encryptionOptions . keystore + " . test " ) ) ; 
 + } 
 + } 
 + 
 @ Test 
 public void getSslContext _ ParamChanges ( ) throws IOException 
 { 
 @ @ - 206 , 15 + 293 , 15 @ @ public class SSLFactoryTest 
 options . enabled = true ; 
 options . cipher _ suites = new String [ ] { " TLS _ ECDHE _ ECDSA _ WITH _ AES _ 128 _ GCM _ SHA256 " } ; 
 
 - SslContext ctx1 = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 - SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 + SslContext ctx1 = SSLFactory . getSslContext ( options , true , 
 + SSLFactory . SocketType . SERVER , OpenSsl . isAvailable ( ) ) ; 
 
 - Assert . assertTrue ( ctx1 . isClient ( ) ) ; 
 + Assert . assertTrue ( ctx1 . isServer ( ) ) ; 
 Assert . assertArrayEquals ( ctx1 . cipherSuites ( ) . toArray ( ) , options . cipher _ suites ) ; 
 
 options . cipher _ suites = new String [ ] { " TLS _ ECDHE _ RSA _ WITH _ AES _ 128 _ GCM _ SHA256 " } ; 
 
 - SslContext ctx2 = SSLFactory . getSslContext ( options , true , SSLFactory . ConnectionType . NATIVE _ TRANSPORT , 
 + SslContext ctx2 = SSLFactory . getSslContext ( options , true , 
 SSLFactory . SocketType . CLIENT , OpenSsl . isAvailable ( ) ) ; 
 
 Assert . assertTrue ( ctx2 . isClient ( ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
