BLEU SCORE: 0.04767707020457096

TEST MSG: Fix race condition in StreamTransferTask that could lead to
GENERATED MSG: Fix SSTable not released if stream session fails

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 987c227 . . cf4a115 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 10 <nl> + * Fix race condition in StreamTransferTask that could lead to <nl> + infinite loops and premature sstable deletion ( CASSANDRA - 7704 ) <nl> * ( cqlsh ) Wait up to 10 sec for a tracing session ( CASSANDRA - 7222 ) <nl> * Fix NPE in FileCacheService . sizeInBytes ( CASSANDRA - 7756 ) <nl> * ( cqlsh ) cqlsh should automatically disable tracing when selecting <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> index a543d01 . . 629c6bb 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> @ @ - 19 , 8 + 19 , 12 @ @ package org . apache . cassandra . streaming ; <nl> <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> + import java . util . concurrent . ScheduledFuture ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> + import io . netty . util . concurrent . * ; <nl> + import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 30 , 13 + 34 , 13 @ @ import org . apache . cassandra . utils . Pair ; <nl> * / <nl> public class StreamTransferTask extends StreamTask <nl> { <nl> - private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; <nl> + private static final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( " StreamingTransferTaskTimeouts " ) ) ; <nl> <nl> private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; <nl> + private boolean aborted = false ; <nl> <nl> - private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; <nl> - <nl> - private final Map < Integer , ScheduledFuture > timeoutTasks = new ConcurrentHashMap < > ( ) ; <nl> + private final Map < Integer , OutgoingFileMessage > files = new HashMap < > ( ) ; <nl> + private final Map < Integer , ScheduledFuture > timeoutTasks = new HashMap < > ( ) ; <nl> <nl> private long totalSize ; <nl> <nl> @ @ - 45 , 7 + 49 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> super ( session , cfId ) ; <nl> } <nl> <nl> - public void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections ) <nl> + public synchronized void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections ) <nl> { <nl> assert sstable ! = null & & cfId . equals ( sstable . metadata . cfId ) ; <nl> OutgoingFileMessage message = new OutgoingFileMessage ( sstable , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections ) ; <nl> @ @ - 58 , 31 + 62 , 42 @ @ public class StreamTransferTask extends StreamTask <nl> * <nl> * @ param sequenceNumber sequence number of file <nl> * / <nl> - public synchronized void complete ( int sequenceNumber ) <nl> + public void complete ( int sequenceNumber ) <nl> { <nl> - OutgoingFileMessage file = files . remove ( sequenceNumber ) ; <nl> - if ( file ! = null ) <nl> + boolean signalComplete ; <nl> + synchronized ( this ) <nl> { <nl> - file . sstable . releaseReference ( ) ; <nl> - / / all file sent , notify session this task is complete . <nl> - if ( files . isEmpty ( ) ) <nl> - { <nl> - timeoutExecutor . shutdownNow ( ) ; <nl> - session . taskCompleted ( this ) ; <nl> - } <nl> + ScheduledFuture timeout = timeoutTasks . remove ( sequenceNumber ) ; <nl> + if ( timeout ! = null ) <nl> + timeout . cancel ( false ) ; <nl> + <nl> + OutgoingFileMessage file = files . remove ( sequenceNumber ) ; <nl> + if ( file ! = null ) <nl> + file . sstable . releaseReference ( ) ; <nl> + <nl> + signalComplete = files . isEmpty ( ) ; <nl> } <nl> + <nl> + / / all file sent , notify session this task is complete . <nl> + if ( signalComplete ) <nl> + session . taskCompleted ( this ) ; <nl> } <nl> <nl> - public void abort ( ) <nl> + public synchronized void abort ( ) <nl> { <nl> + if ( aborted ) <nl> + return ; <nl> + aborted = true ; <nl> + <nl> + for ( ScheduledFuture future : timeoutTasks . values ( ) ) <nl> + future . cancel ( false ) ; <nl> + timeoutTasks . clear ( ) ; <nl> + <nl> for ( OutgoingFileMessage file : files . values ( ) ) <nl> - { <nl> file . sstable . releaseReference ( ) ; <nl> - } <nl> - timeoutExecutor . shutdownNow ( ) ; <nl> } <nl> <nl> - public int getTotalNumberOfFiles ( ) <nl> + public synchronized int getTotalNumberOfFiles ( ) <nl> { <nl> return files . size ( ) ; <nl> } <nl> @ @ - 92 , 17 + 107 , 17 @ @ public class StreamTransferTask extends StreamTask <nl> return totalSize ; <nl> } <nl> <nl> - public Collection < OutgoingFileMessage > getFileMessages ( ) <nl> + public synchronized Collection < OutgoingFileMessage > getFileMessages ( ) <nl> { <nl> / / We may race between queuing all those messages and the completion of the completion of <nl> - / / the first ones . So copy the values to avoid a ConcurrentModificationException <nl> + / / the first ones . So copy tthe values to avoid a ConcurrentModificationException <nl> return new ArrayList < > ( files . values ( ) ) ; <nl> } <nl> <nl> public synchronized OutgoingFileMessage createMessageForRetry ( int sequenceNumber ) <nl> { <nl> / / remove previous time out task to be rescheduled later <nl> - ScheduledFuture future = timeoutTasks . get ( sequenceNumber ) ; <nl> + ScheduledFuture future = timeoutTasks . remove ( sequenceNumber ) ; <nl> if ( future ! = null ) <nl> future . cancel ( false ) ; <nl> return files . get ( sequenceNumber ) ; <nl> @ @ - 120 , 18 + 135 , 24 @ @ public class StreamTransferTask extends StreamTask <nl> * / <nl> public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) <nl> { <nl> - if ( timeoutExecutor . isShutdown ( ) ) <nl> + if ( ! files . containsKey ( sequenceNumber ) ) <nl> return null ; <nl> <nl> ScheduledFuture future = timeoutExecutor . schedule ( new Runnable ( ) <nl> { <nl> public void run ( ) <nl> { <nl> - StreamTransferTask . this . complete ( sequenceNumber ) ; <nl> - timeoutTasks . remove ( sequenceNumber ) ; <nl> + synchronized ( StreamTransferTask . this ) <nl> + { <nl> + / / remove so we don ' t cancel ourselves <nl> + timeoutTasks . remove ( sequenceNumber ) ; <nl> + StreamTransferTask . this . complete ( sequenceNumber ) ; <nl> + } <nl> } <nl> } , time , unit ) ; <nl> - timeoutTasks . put ( sequenceNumber , future ) ; <nl> + <nl> + ScheduledFuture prev = timeoutTasks . put ( sequenceNumber , future ) ; <nl> + assert prev = = null ; <nl> return future ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> index ce0f9d0 . . cc41a8b 100644 <nl> - - - a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> + + + b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> @ @ - 19 , 11 + 19 , 14 @ @ package org . apache . cassandra . streaming ; <nl> <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> + import java . util . concurrent . CancellationException ; <nl> + import java . util . concurrent . Future ; <nl> import java . util . concurrent . ScheduledFuture ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> import org . junit . Test ; <nl> <nl> + import junit . framework . Assert ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> @ @ - 43 , 7 + 46 , 7 @ @ public class StreamTransferTaskTest extends SchemaLoader <nl> String ks = " Keyspace1 " ; <nl> String cf = " Standard1 " ; <nl> <nl> - StreamSession session = new StreamSession ( FBUtilities . getBroadcastAddress ( ) , null ) ; <nl> + StreamSession session = new StreamSession ( FBUtilities . getBroadcastAddress ( ) , null , 0 ) ; <nl> ColumnFamilyStore cfs = Keyspace . open ( ks ) . getColumnFamilyStore ( cf ) ; <nl> <nl> / / create two sstables <nl> @ @ - 59 , 19 + 62 , 25 @ @ public class StreamTransferTaskTest extends SchemaLoader <nl> { <nl> List < Range < Token > > ranges = new ArrayList < > ( ) ; <nl> ranges . add ( new Range < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ) ; <nl> - task . addTransferFile ( sstable , 1 , sstable . getPositionsForRanges ( ranges ) ) ; <nl> + task . addTransferFile ( sstable , 1 , sstable . getPositionsForRanges ( ranges ) , 0 ) ; <nl> } <nl> assertEquals ( 2 , task . getTotalNumberOfFiles ( ) ) ; <nl> <nl> / / if file sending completes before timeout then the task should be canceled . <nl> - ScheduledFuture f = task . scheduleTimeout ( 0 , 1 , TimeUnit . SECONDS ) ; <nl> - task . complete ( 0 ) ; <nl> - / / timeout task may run after complete but it is noop <nl> + Future f = task . scheduleTimeout ( 0 , 0 , TimeUnit . NANOSECONDS ) ; <nl> f . get ( ) ; <nl> <nl> / / when timeout runs on second file , task should be completed <nl> f = task . scheduleTimeout ( 1 , 1 , TimeUnit . MILLISECONDS ) ; <nl> - f . get ( ) ; <nl> + task . complete ( 1 ) ; <nl> + try <nl> + { <nl> + f . get ( ) ; <nl> + Assert . assertTrue ( false ) ; <nl> + } <nl> + catch ( CancellationException ex ) <nl> + { <nl> + } <nl> assertEquals ( StreamSession . State . WAIT _ COMPLETE , session . state ( ) ) ; <nl> <nl> / / when all streaming are done , time out task should not be scheduled .
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 987c227 . . cf4a115 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 10 
 + * Fix race condition in StreamTransferTask that could lead to 
 + infinite loops and premature sstable deletion ( CASSANDRA - 7704 ) 
 * ( cqlsh ) Wait up to 10 sec for a tracing session ( CASSANDRA - 7222 ) 
 * Fix NPE in FileCacheService . sizeInBytes ( CASSANDRA - 7756 ) 
 * ( cqlsh ) cqlsh should automatically disable tracing when selecting 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 index a543d01 . . 629c6bb 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 @ @ - 19 , 8 + 19 , 12 @ @ package org . apache . cassandra . streaming ; 
 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 + import java . util . concurrent . ScheduledFuture ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 
 + import io . netty . util . concurrent . * ; 
 + import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 30 , 13 + 34 , 13 @ @ import org . apache . cassandra . utils . Pair ; 
 * / 
 public class StreamTransferTask extends StreamTask 
 { 
 - private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; 
 + private static final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( " StreamingTransferTaskTimeouts " ) ) ; 
 
 private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; 
 + private boolean aborted = false ; 
 
 - private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; 
 - 
 - private final Map < Integer , ScheduledFuture > timeoutTasks = new ConcurrentHashMap < > ( ) ; 
 + private final Map < Integer , OutgoingFileMessage > files = new HashMap < > ( ) ; 
 + private final Map < Integer , ScheduledFuture > timeoutTasks = new HashMap < > ( ) ; 
 
 private long totalSize ; 
 
 @ @ - 45 , 7 + 49 , 7 @ @ public class StreamTransferTask extends StreamTask 
 super ( session , cfId ) ; 
 } 
 
 - public void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections ) 
 + public synchronized void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections ) 
 { 
 assert sstable ! = null & & cfId . equals ( sstable . metadata . cfId ) ; 
 OutgoingFileMessage message = new OutgoingFileMessage ( sstable , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections ) ; 
 @ @ - 58 , 31 + 62 , 42 @ @ public class StreamTransferTask extends StreamTask 
 * 
 * @ param sequenceNumber sequence number of file 
 * / 
 - public synchronized void complete ( int sequenceNumber ) 
 + public void complete ( int sequenceNumber ) 
 { 
 - OutgoingFileMessage file = files . remove ( sequenceNumber ) ; 
 - if ( file ! = null ) 
 + boolean signalComplete ; 
 + synchronized ( this ) 
 { 
 - file . sstable . releaseReference ( ) ; 
 - / / all file sent , notify session this task is complete . 
 - if ( files . isEmpty ( ) ) 
 - { 
 - timeoutExecutor . shutdownNow ( ) ; 
 - session . taskCompleted ( this ) ; 
 - } 
 + ScheduledFuture timeout = timeoutTasks . remove ( sequenceNumber ) ; 
 + if ( timeout ! = null ) 
 + timeout . cancel ( false ) ; 
 + 
 + OutgoingFileMessage file = files . remove ( sequenceNumber ) ; 
 + if ( file ! = null ) 
 + file . sstable . releaseReference ( ) ; 
 + 
 + signalComplete = files . isEmpty ( ) ; 
 } 
 + 
 + / / all file sent , notify session this task is complete . 
 + if ( signalComplete ) 
 + session . taskCompleted ( this ) ; 
 } 
 
 - public void abort ( ) 
 + public synchronized void abort ( ) 
 { 
 + if ( aborted ) 
 + return ; 
 + aborted = true ; 
 + 
 + for ( ScheduledFuture future : timeoutTasks . values ( ) ) 
 + future . cancel ( false ) ; 
 + timeoutTasks . clear ( ) ; 
 + 
 for ( OutgoingFileMessage file : files . values ( ) ) 
 - { 
 file . sstable . releaseReference ( ) ; 
 - } 
 - timeoutExecutor . shutdownNow ( ) ; 
 } 
 
 - public int getTotalNumberOfFiles ( ) 
 + public synchronized int getTotalNumberOfFiles ( ) 
 { 
 return files . size ( ) ; 
 } 
 @ @ - 92 , 17 + 107 , 17 @ @ public class StreamTransferTask extends StreamTask 
 return totalSize ; 
 } 
 
 - public Collection < OutgoingFileMessage > getFileMessages ( ) 
 + public synchronized Collection < OutgoingFileMessage > getFileMessages ( ) 
 { 
 / / We may race between queuing all those messages and the completion of the completion of 
 - / / the first ones . So copy the values to avoid a ConcurrentModificationException 
 + / / the first ones . So copy tthe values to avoid a ConcurrentModificationException 
 return new ArrayList < > ( files . values ( ) ) ; 
 } 
 
 public synchronized OutgoingFileMessage createMessageForRetry ( int sequenceNumber ) 
 { 
 / / remove previous time out task to be rescheduled later 
 - ScheduledFuture future = timeoutTasks . get ( sequenceNumber ) ; 
 + ScheduledFuture future = timeoutTasks . remove ( sequenceNumber ) ; 
 if ( future ! = null ) 
 future . cancel ( false ) ; 
 return files . get ( sequenceNumber ) ; 
 @ @ - 120 , 18 + 135 , 24 @ @ public class StreamTransferTask extends StreamTask 
 * / 
 public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) 
 { 
 - if ( timeoutExecutor . isShutdown ( ) ) 
 + if ( ! files . containsKey ( sequenceNumber ) ) 
 return null ; 
 
 ScheduledFuture future = timeoutExecutor . schedule ( new Runnable ( ) 
 { 
 public void run ( ) 
 { 
 - StreamTransferTask . this . complete ( sequenceNumber ) ; 
 - timeoutTasks . remove ( sequenceNumber ) ; 
 + synchronized ( StreamTransferTask . this ) 
 + { 
 + / / remove so we don ' t cancel ourselves 
 + timeoutTasks . remove ( sequenceNumber ) ; 
 + StreamTransferTask . this . complete ( sequenceNumber ) ; 
 + } 
 } 
 } , time , unit ) ; 
 - timeoutTasks . put ( sequenceNumber , future ) ; 
 + 
 + ScheduledFuture prev = timeoutTasks . put ( sequenceNumber , future ) ; 
 + assert prev = = null ; 
 return future ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 index ce0f9d0 . . cc41a8b 100644 
 - - - a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 + + + b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 @ @ - 19 , 11 + 19 , 14 @ @ package org . apache . cassandra . streaming ; 
 
 import java . util . ArrayList ; 
 import java . util . List ; 
 + import java . util . concurrent . CancellationException ; 
 + import java . util . concurrent . Future ; 
 import java . util . concurrent . ScheduledFuture ; 
 import java . util . concurrent . TimeUnit ; 
 
 import org . junit . Test ; 
 
 + import junit . framework . Assert ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . Keyspace ; 
 @ @ - 43 , 7 + 46 , 7 @ @ public class StreamTransferTaskTest extends SchemaLoader 
 String ks = " Keyspace1 " ; 
 String cf = " Standard1 " ; 
 
 - StreamSession session = new StreamSession ( FBUtilities . getBroadcastAddress ( ) , null ) ; 
 + StreamSession session = new StreamSession ( FBUtilities . getBroadcastAddress ( ) , null , 0 ) ; 
 ColumnFamilyStore cfs = Keyspace . open ( ks ) . getColumnFamilyStore ( cf ) ; 
 
 / / create two sstables 
 @ @ - 59 , 19 + 62 , 25 @ @ public class StreamTransferTaskTest extends SchemaLoader 
 { 
 List < Range < Token > > ranges = new ArrayList < > ( ) ; 
 ranges . add ( new Range < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ) ; 
 - task . addTransferFile ( sstable , 1 , sstable . getPositionsForRanges ( ranges ) ) ; 
 + task . addTransferFile ( sstable , 1 , sstable . getPositionsForRanges ( ranges ) , 0 ) ; 
 } 
 assertEquals ( 2 , task . getTotalNumberOfFiles ( ) ) ; 
 
 / / if file sending completes before timeout then the task should be canceled . 
 - ScheduledFuture f = task . scheduleTimeout ( 0 , 1 , TimeUnit . SECONDS ) ; 
 - task . complete ( 0 ) ; 
 - / / timeout task may run after complete but it is noop 
 + Future f = task . scheduleTimeout ( 0 , 0 , TimeUnit . NANOSECONDS ) ; 
 f . get ( ) ; 
 
 / / when timeout runs on second file , task should be completed 
 f = task . scheduleTimeout ( 1 , 1 , TimeUnit . MILLISECONDS ) ; 
 - f . get ( ) ; 
 + task . complete ( 1 ) ; 
 + try 
 + { 
 + f . get ( ) ; 
 + Assert . assertTrue ( false ) ; 
 + } 
 + catch ( CancellationException ex ) 
 + { 
 + } 
 assertEquals ( StreamSession . State . WAIT _ COMPLETE , session . state ( ) ) ; 
 
 / / when all streaming are done , time out task should not be scheduled .

NEAREST DIFF:
ELIMINATEDSENTENCE
