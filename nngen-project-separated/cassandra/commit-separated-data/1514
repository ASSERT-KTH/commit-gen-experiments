BLEU SCORE: 0.05522397783539471

TEST MSG: remove StorageProxy . OPTIMIZE _ LOCAL _ REQUESTS
GENERATED MSG: remove redundant startTime

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 22831ca . . bf0c664 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 69 , 7 + 69 , 6 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> public static final String MBEAN _ NAME = " org . apache . cassandra . db : type = StorageProxy " ; <nl> private static final Logger logger = LoggerFactory . getLogger ( StorageProxy . class ) ; <nl> - static final boolean OPTIMIZE _ LOCAL _ REQUESTS = true ; / / set to false to test messagingservice path on single node <nl> <nl> public static final String UNREACHABLE = " UNREACHABLE " ; <nl> <nl> @ @ - 705 , 7 + 704 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> <nl> public static boolean canDoLocalRequest ( InetAddress replica ) <nl> { <nl> - return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ; <nl> + return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> <nl> <nl> @ @ - 1849 , 9 + 1848 , 6 @ @ public class StorageProxy implements StorageProxyMBean <nl> throws UnavailableException , ReadFailureException , ReadTimeoutException <nl> { <nl> Tracing . trace ( " Computing ranges to query " ) ; <nl> - long startTime = System . nanoTime ( ) ; <nl> - <nl> - List < FilteredPartition > partitions = new ArrayList < > ( ) ; <nl> <nl> Keyspace keyspace = Keyspace . open ( command . metadata ( ) . ksName ) ; <nl> RangeIterator ranges = new RangeIterator ( command , keyspace , consistencyLevel ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1b9634c . . 843bb53 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 3 , 8 + 3 , 9 @ @ <nl> * Fix serialization of the LEFT gossip value ( CASSANDRA - 5696 ) <nl> * Pig : support for cql3 tables ( CASSANDRA - 5234 ) <nl> * cqlsh : Don ' t show ' null ' in place of empty values ( CASSANDRA - 5675 ) <nl> - * Race condition in detecting version on a mixed 1 . 1 / 1 . 2 cluster <nl> + * Race condition in detecting version on a mixed 1 . 1 / 1 . 2 cluster <nl> ( CASSANDRA - 5692 ) <nl> + * Fix skipping range tombstones with reverse queries ( CASSANDRA - 5712 ) <nl> <nl> <nl> 1 . 2 . 6 <nl> diff - - git a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> index 4ca0ea5 . . 21eb48b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> + + + b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . cassandra . db . ColumnFamily ; <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> import org . apache . cassandra . db . DeletionInfo ; <nl> import org . apache . cassandra . db . OnDiskAtom ; <nl> + import org . apache . cassandra . db . RangeTombstone ; <nl> import org . apache . cassandra . db . RowIndexEntry ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> @ @ - 60 , 6 + 61 , 9 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA <nl> private final Deque < OnDiskAtom > blockColumns = new ArrayDeque < OnDiskAtom > ( ) ; <nl> private final AbstractType < ? > comparator ; <nl> <nl> + / / Holds range tombstone in reverse queries . See addColumn ( ) <nl> + private final Deque < OnDiskAtom > rangeTombstonesReversed ; <nl> + <nl> / * * <nl> * This slice reader assumes that slices are sorted correctly , e . g . that for forward lookup slices are in <nl> * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of <nl> @ @ - 74 , 6 + 78 , 7 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA <nl> this . reversed = reversed ; <nl> this . slices = slices ; <nl> this . comparator = sstable . metadata . comparator ; <nl> + this . rangeTombstonesReversed = reversed ? new ArrayDeque < OnDiskAtom > ( ) : null ; <nl> <nl> try <nl> { <nl> @ @ - 147 , 6 + 152 , 14 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA <nl> { <nl> while ( true ) <nl> { <nl> + if ( reversed ) <nl> + { <nl> + / / Return all tombstone for the block first ( see addColumn ( ) below ) <nl> + OnDiskAtom column = rangeTombstonesReversed . poll ( ) ; <nl> + if ( column ! = null ) <nl> + return column ; <nl> + } <nl> + <nl> OnDiskAtom column = blockColumns . poll ( ) ; <nl> if ( column = = null ) <nl> { <nl> @ @ - 169 , 9 + 182 , 22 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA <nl> protected void addColumn ( OnDiskAtom col ) <nl> { <nl> if ( reversed ) <nl> - blockColumns . addFirst ( col ) ; <nl> + { <nl> + / * <nl> + * We put range tomstone markers at the beginning of the range they delete . But for reversed queries , <nl> + * the caller still need to know about a RangeTombstone before it sees any column that it covers . <nl> + * To make that simple , we keep said tombstones separate and return them all before any column for <nl> + * a given block . <nl> + * / <nl> + if ( col instanceof RangeTombstone ) <nl> + rangeTombstonesReversed . addFirst ( col ) ; <nl> + else <nl> + blockColumns . addFirst ( col ) ; <nl> + } <nl> else <nl> + { <nl> blockColumns . addLast ( col ) ; <nl> + } <nl> } <nl> <nl> private abstract class BlockFetcher <nl> diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> index c531461 . . c2f8b83 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java <nl> @ @ - 154 , 6 + 154 , 38 @ @ public class RangeTombstoneTest extends SchemaLoader <nl> assert ! isLive ( cf , cf . getColumn ( b ( i ) ) ) : " Column " + i + " shouldn ' t be live " ; <nl> } <nl> <nl> + @ Test <nl> + public void reverseQueryTest ( ) throws Exception <nl> + { <nl> + Table table = Table . open ( KSNAME ) ; <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; <nl> + <nl> + / / Inserting data <nl> + String key = " k3 " ; <nl> + RowMutation rm ; <nl> + ColumnFamily cf ; <nl> + <nl> + rm = new RowMutation ( KSNAME , ByteBufferUtil . bytes ( key ) ) ; <nl> + add ( rm , 2 , 0 ) ; <nl> + rm . apply ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + rm = new RowMutation ( KSNAME , ByteBufferUtil . bytes ( key ) ) ; <nl> + / / Deletes everything but without being a row tombstone <nl> + delete ( rm . addOrGet ( CFNAME ) , 0 , 10 , 1 ) ; <nl> + add ( rm , 1 , 2 ) ; <nl> + rm . apply ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + / / Get the last value of the row <nl> + QueryPath path = new QueryPath ( CFNAME ) ; <nl> + cf = cfs . getColumnFamily ( QueryFilter . getSliceFilter ( dk ( key ) , path , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , true , 1 ) ) ; <nl> + <nl> + assert ! cf . isEmpty ( ) ; <nl> + int last = i ( cf . getSortedColumns ( ) . iterator ( ) . next ( ) . name ( ) ) ; <nl> + assert last = = 1 : " Last column should be column 1 since column 2 has been deleted " ; <nl> + } <nl> + <nl> private static boolean isLive ( ColumnFamily cf , IColumn c ) <nl> { <nl> return c ! = null & & ! c . isMarkedForDelete ( ) & & ! cf . deletionInfo ( ) . isDeleted ( c ) ; <nl> @ @ - 164 , 6 + 196 , 11 @ @ public class RangeTombstoneTest extends SchemaLoader <nl> return ByteBufferUtil . bytes ( i ) ; <nl> } <nl> <nl> + private static int i ( ByteBuffer i ) <nl> + { <nl> + return ByteBufferUtil . toInt ( i ) ; <nl> + } <nl> + <nl> private static void add ( RowMutation rm , int value , long timestamp ) <nl> { <nl> rm . add ( new QueryPath ( CFNAME , null , b ( value ) ) , b ( value ) , timestamp ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 22831ca . . bf0c664 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 69 , 7 + 69 , 6 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 public static final String MBEAN _ NAME = " org . apache . cassandra . db : type = StorageProxy " ; 
 private static final Logger logger = LoggerFactory . getLogger ( StorageProxy . class ) ; 
 - static final boolean OPTIMIZE _ LOCAL _ REQUESTS = true ; / / set to false to test messagingservice path on single node 
 
 public static final String UNREACHABLE = " UNREACHABLE " ; 
 
 @ @ - 705 , 7 + 704 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 
 public static boolean canDoLocalRequest ( InetAddress replica ) 
 { 
 - return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ; 
 + return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 
 
 @ @ - 1849 , 9 + 1848 , 6 @ @ public class StorageProxy implements StorageProxyMBean 
 throws UnavailableException , ReadFailureException , ReadTimeoutException 
 { 
 Tracing . trace ( " Computing ranges to query " ) ; 
 - long startTime = System . nanoTime ( ) ; 
 - 
 - List < FilteredPartition > partitions = new ArrayList < > ( ) ; 
 
 Keyspace keyspace = Keyspace . open ( command . metadata ( ) . ksName ) ; 
 RangeIterator ranges = new RangeIterator ( command , keyspace , consistencyLevel ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1b9634c . . 843bb53 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 3 , 8 + 3 , 9 @ @ 
 * Fix serialization of the LEFT gossip value ( CASSANDRA - 5696 ) 
 * Pig : support for cql3 tables ( CASSANDRA - 5234 ) 
 * cqlsh : Don ' t show ' null ' in place of empty values ( CASSANDRA - 5675 ) 
 - * Race condition in detecting version on a mixed 1 . 1 / 1 . 2 cluster 
 + * Race condition in detecting version on a mixed 1 . 1 / 1 . 2 cluster 
 ( CASSANDRA - 5692 ) 
 + * Fix skipping range tombstones with reverse queries ( CASSANDRA - 5712 ) 
 
 
 1 . 2 . 6 
 diff - - git a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 index 4ca0ea5 . . 21eb48b 100644 
 - - - a / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 + + + b / src / java / org / apache / cassandra / db / columniterator / IndexedSliceReader . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . cassandra . db . ColumnFamily ; 
 import org . apache . cassandra . db . DecoratedKey ; 
 import org . apache . cassandra . db . DeletionInfo ; 
 import org . apache . cassandra . db . OnDiskAtom ; 
 + import org . apache . cassandra . db . RangeTombstone ; 
 import org . apache . cassandra . db . RowIndexEntry ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 @ @ - 60 , 6 + 61 , 9 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA 
 private final Deque < OnDiskAtom > blockColumns = new ArrayDeque < OnDiskAtom > ( ) ; 
 private final AbstractType < ? > comparator ; 
 
 + / / Holds range tombstone in reverse queries . See addColumn ( ) 
 + private final Deque < OnDiskAtom > rangeTombstonesReversed ; 
 + 
 / * * 
 * This slice reader assumes that slices are sorted correctly , e . g . that for forward lookup slices are in 
 * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of 
 @ @ - 74 , 6 + 78 , 7 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA 
 this . reversed = reversed ; 
 this . slices = slices ; 
 this . comparator = sstable . metadata . comparator ; 
 + this . rangeTombstonesReversed = reversed ? new ArrayDeque < OnDiskAtom > ( ) : null ; 
 
 try 
 { 
 @ @ - 147 , 6 + 152 , 14 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA 
 { 
 while ( true ) 
 { 
 + if ( reversed ) 
 + { 
 + / / Return all tombstone for the block first ( see addColumn ( ) below ) 
 + OnDiskAtom column = rangeTombstonesReversed . poll ( ) ; 
 + if ( column ! = null ) 
 + return column ; 
 + } 
 + 
 OnDiskAtom column = blockColumns . poll ( ) ; 
 if ( column = = null ) 
 { 
 @ @ - 169 , 9 + 182 , 22 @ @ class IndexedSliceReader extends AbstractIterator < OnDiskAtom > implements OnDiskA 
 protected void addColumn ( OnDiskAtom col ) 
 { 
 if ( reversed ) 
 - blockColumns . addFirst ( col ) ; 
 + { 
 + / * 
 + * We put range tomstone markers at the beginning of the range they delete . But for reversed queries , 
 + * the caller still need to know about a RangeTombstone before it sees any column that it covers . 
 + * To make that simple , we keep said tombstones separate and return them all before any column for 
 + * a given block . 
 + * / 
 + if ( col instanceof RangeTombstone ) 
 + rangeTombstonesReversed . addFirst ( col ) ; 
 + else 
 + blockColumns . addFirst ( col ) ; 
 + } 
 else 
 + { 
 blockColumns . addLast ( col ) ; 
 + } 
 } 
 
 private abstract class BlockFetcher 
 diff - - git a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 index c531461 . . c2f8b83 100644 
 - - - a / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RangeTombstoneTest . java 
 @ @ - 154 , 6 + 154 , 38 @ @ public class RangeTombstoneTest extends SchemaLoader 
 assert ! isLive ( cf , cf . getColumn ( b ( i ) ) ) : " Column " + i + " shouldn ' t be live " ; 
 } 
 
 + @ Test 
 + public void reverseQueryTest ( ) throws Exception 
 + { 
 + Table table = Table . open ( KSNAME ) ; 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( CFNAME ) ; 
 + 
 + / / Inserting data 
 + String key = " k3 " ; 
 + RowMutation rm ; 
 + ColumnFamily cf ; 
 + 
 + rm = new RowMutation ( KSNAME , ByteBufferUtil . bytes ( key ) ) ; 
 + add ( rm , 2 , 0 ) ; 
 + rm . apply ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + rm = new RowMutation ( KSNAME , ByteBufferUtil . bytes ( key ) ) ; 
 + / / Deletes everything but without being a row tombstone 
 + delete ( rm . addOrGet ( CFNAME ) , 0 , 10 , 1 ) ; 
 + add ( rm , 1 , 2 ) ; 
 + rm . apply ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + / / Get the last value of the row 
 + QueryPath path = new QueryPath ( CFNAME ) ; 
 + cf = cfs . getColumnFamily ( QueryFilter . getSliceFilter ( dk ( key ) , path , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , true , 1 ) ) ; 
 + 
 + assert ! cf . isEmpty ( ) ; 
 + int last = i ( cf . getSortedColumns ( ) . iterator ( ) . next ( ) . name ( ) ) ; 
 + assert last = = 1 : " Last column should be column 1 since column 2 has been deleted " ; 
 + } 
 + 
 private static boolean isLive ( ColumnFamily cf , IColumn c ) 
 { 
 return c ! = null & & ! c . isMarkedForDelete ( ) & & ! cf . deletionInfo ( ) . isDeleted ( c ) ; 
 @ @ - 164 , 6 + 196 , 11 @ @ public class RangeTombstoneTest extends SchemaLoader 
 return ByteBufferUtil . bytes ( i ) ; 
 } 
 
 + private static int i ( ByteBuffer i ) 
 + { 
 + return ByteBufferUtil . toInt ( i ) ; 
 + } 
 + 
 private static void add ( RowMutation rm , int value , long timestamp ) 
 { 
 rm . add ( new QueryPath ( CFNAME , null , b ( value ) ) , b ( value ) , timestamp ) ;
