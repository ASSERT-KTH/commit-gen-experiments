BLEU SCORE: 0.044568827606990644

TEST MSG: Add - - resolve - ip option to ' nodetool ring '
GENERATED MSG: Add ability to list specific KS / CF combinations in nodetool cfstats

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 285efd1 . . 30e45c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * cqlsh : Accept and execute CQL statement ( s ) from command - line parameter ( CASSANDRA - 7172 ) <nl> * Fix IllegalStateException in CqlPagingRecordReader ( CASSANDRA - 7198 ) <nl> * Fix the InvertedIndex trigger example ( CASSANDRA - 7211 ) <nl> + * Add - - resolve - ip option to ' nodetool ring ' ( CASSANDRA - 7210 ) <nl> <nl> <nl> 2 . 0 . 8 <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index b79a037 . . 1af1ec8 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 250 , 7 + 250 , 7 @ @ public class NodeCmd <nl> * @ param outs <nl> * the stream to write to <nl> * / <nl> - public void printRing ( PrintStream outs , String keyspace ) <nl> + public void printRing ( PrintStream outs , String keyspace , boolean resolveIp ) <nl> { <nl> Map < String , String > tokensToEndpoints = probe . getTokenToEndpointMap ( ) ; <nl> LinkedHashMultimap < String , String > endpointsToTokens = LinkedHashMultimap . create ( ) ; <nl> @ @ - 285 , 7 + 285 , 7 @ @ public class NodeCmd <nl> try <nl> { <nl> outs . println ( ) ; <nl> - for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( false , tokensToEndpoints , ownerships ) . entrySet ( ) ) <nl> + for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( resolveIp , tokensToEndpoints , ownerships ) . entrySet ( ) ) <nl> printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; <nl> } <nl> catch ( UnknownHostException e ) <nl> @ @ - 362 , 7 + 362 , 7 @ @ public class NodeCmd <nl> ? loadMap . get ( endpoint ) <nl> : " ? " ; <nl> String owns = stat . owns ! = null ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( stat . owns ) : " ? " ; <nl> - outs . printf ( format , endpoint , rack , status , state , load , owns , stat . token ) ; <nl> + outs . printf ( format , stat . ipOrDns ( ) , rack , status , state , load , owns , stat . token ) ; <nl> } <nl> outs . println ( ) ; <nl> } <nl> @ @ - 1216 , 8 + 1216 , 9 @ @ public class NodeCmd <nl> switch ( command ) <nl> { <nl> case RING : <nl> - if ( arguments . length > 0 ) { nodeCmd . printRing ( System . out , arguments [ 0 ] ) ; } <nl> - else { nodeCmd . printRing ( System . out , null ) ; } ; <nl> + boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; <nl> + if ( arguments . length > 0 ) { nodeCmd . printRing ( System . out , arguments [ 0 ] , resolveIp ) ; } <nl> + else { nodeCmd . printRing ( System . out , null , resolveIp ) ; } ; <nl> break ; <nl> <nl> case INFO : nodeCmd . printInfo ( System . out , cmd ) ; break ; <nl> @ @ - 1257 , 7 + 1258 , 7 @ @ public class NodeCmd <nl> break ; <nl> <nl> case STATUS : <nl> - boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; <nl> + resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; <nl> if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] , resolveIp ) ; <nl> else nodeCmd . printClusterStatus ( System . out , null , resolveIp ) ; <nl> break ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2dbadc4 . . d6ecac1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 7 @ @ <nl> 1 . 2 . 12 <nl> * Add ability to list specific KS / CF combinations in nodetool cfstats ( CASSANDRA - 4191 ) <nl> + * Mark CF clean if a mutation raced the drop and got it marked dirty <nl> + <nl> <nl> 1 . 2 . 11 <nl> * Limit CQL prepared statement cache by size instead of count ( CASSANDRA - 6107 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> index 2855979 . . d62d7ca 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . Table ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> <nl> / * * <nl> @ @ - 296 , 19 + 297 , 30 @ @ public class CommitLogAllocator <nl> { <nl> for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) <nl> { <nl> - String keypace = Schema . instance . getCF ( dirtyCFId ) . left ; <nl> - final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; <nl> - / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , <nl> - / / which may already be held by a thread waiting for the CL executor ( via getContext ) , <nl> - / / causing deadlock <nl> - Runnable runnable = new Runnable ( ) <nl> + Pair < String , String > pair = Schema . instance . getCF ( dirtyCFId ) ; <nl> + if ( pair = = null ) <nl> { <nl> - public void run ( ) <nl> + / / even though we remove the schema entry before a final flush when dropping a CF , <nl> + / / it ' s still possible for a writer to race and finish his append after the flush . <nl> + logger . debug ( " Marking clean CF { } that doesn ' t exist anymore " , dirtyCFId ) ; <nl> + oldestSegment . markClean ( dirtyCFId , oldestSegment . getContext ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + String keypace = pair . left ; <nl> + final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; <nl> + / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , <nl> + / / which may already be held by a thread waiting for the CL executor ( via getContext ) , <nl> + / / causing deadlock <nl> + Runnable runnable = new Runnable ( ) <nl> { <nl> - cfs . forceFlush ( ) ; <nl> - } <nl> - } ; <nl> - StorageService . optionalTasks . execute ( runnable ) ; <nl> + public void run ( ) <nl> + { <nl> + cfs . forceFlush ( ) ; <nl> + } <nl> + } ; <nl> + StorageService . optionalTasks . execute ( runnable ) ; <nl> + } <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 285efd1 . . 30e45c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * cqlsh : Accept and execute CQL statement ( s ) from command - line parameter ( CASSANDRA - 7172 ) 
 * Fix IllegalStateException in CqlPagingRecordReader ( CASSANDRA - 7198 ) 
 * Fix the InvertedIndex trigger example ( CASSANDRA - 7211 ) 
 + * Add - - resolve - ip option to ' nodetool ring ' ( CASSANDRA - 7210 ) 
 
 
 2 . 0 . 8 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index b79a037 . . 1af1ec8 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 250 , 7 + 250 , 7 @ @ public class NodeCmd 
 * @ param outs 
 * the stream to write to 
 * / 
 - public void printRing ( PrintStream outs , String keyspace ) 
 + public void printRing ( PrintStream outs , String keyspace , boolean resolveIp ) 
 { 
 Map < String , String > tokensToEndpoints = probe . getTokenToEndpointMap ( ) ; 
 LinkedHashMultimap < String , String > endpointsToTokens = LinkedHashMultimap . create ( ) ; 
 @ @ - 285 , 7 + 285 , 7 @ @ public class NodeCmd 
 try 
 { 
 outs . println ( ) ; 
 - for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( false , tokensToEndpoints , ownerships ) . entrySet ( ) ) 
 + for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( resolveIp , tokensToEndpoints , ownerships ) . entrySet ( ) ) 
 printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; 
 } 
 catch ( UnknownHostException e ) 
 @ @ - 362 , 7 + 362 , 7 @ @ public class NodeCmd 
 ? loadMap . get ( endpoint ) 
 : " ? " ; 
 String owns = stat . owns ! = null ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( stat . owns ) : " ? " ; 
 - outs . printf ( format , endpoint , rack , status , state , load , owns , stat . token ) ; 
 + outs . printf ( format , stat . ipOrDns ( ) , rack , status , state , load , owns , stat . token ) ; 
 } 
 outs . println ( ) ; 
 } 
 @ @ - 1216 , 8 + 1216 , 9 @ @ public class NodeCmd 
 switch ( command ) 
 { 
 case RING : 
 - if ( arguments . length > 0 ) { nodeCmd . printRing ( System . out , arguments [ 0 ] ) ; } 
 - else { nodeCmd . printRing ( System . out , null ) ; } ; 
 + boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; 
 + if ( arguments . length > 0 ) { nodeCmd . printRing ( System . out , arguments [ 0 ] , resolveIp ) ; } 
 + else { nodeCmd . printRing ( System . out , null , resolveIp ) ; } ; 
 break ; 
 
 case INFO : nodeCmd . printInfo ( System . out , cmd ) ; break ; 
 @ @ - 1257 , 7 + 1258 , 7 @ @ public class NodeCmd 
 break ; 
 
 case STATUS : 
 - boolean resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; 
 + resolveIp = cmd . hasOption ( RESOLVE _ IP . left ) ; 
 if ( arguments . length > 0 ) nodeCmd . printClusterStatus ( System . out , arguments [ 0 ] , resolveIp ) ; 
 else nodeCmd . printClusterStatus ( System . out , null , resolveIp ) ; 
 break ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2dbadc4 . . d6ecac1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 1 . 2 . 12 
 * Add ability to list specific KS / CF combinations in nodetool cfstats ( CASSANDRA - 4191 ) 
 + * Mark CF clean if a mutation raced the drop and got it marked dirty 
 + 
 
 1 . 2 . 11 
 * Limit CQL prepared statement cache by size instead of count ( CASSANDRA - 6107 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 index 2855979 . . d62d7ca 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . Table ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . utils . Pair ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 
 / * * 
 @ @ - 296 , 19 + 297 , 30 @ @ public class CommitLogAllocator 
 { 
 for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) 
 { 
 - String keypace = Schema . instance . getCF ( dirtyCFId ) . left ; 
 - final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; 
 - / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , 
 - / / which may already be held by a thread waiting for the CL executor ( via getContext ) , 
 - / / causing deadlock 
 - Runnable runnable = new Runnable ( ) 
 + Pair < String , String > pair = Schema . instance . getCF ( dirtyCFId ) ; 
 + if ( pair = = null ) 
 { 
 - public void run ( ) 
 + / / even though we remove the schema entry before a final flush when dropping a CF , 
 + / / it ' s still possible for a writer to race and finish his append after the flush . 
 + logger . debug ( " Marking clean CF { } that doesn ' t exist anymore " , dirtyCFId ) ; 
 + oldestSegment . markClean ( dirtyCFId , oldestSegment . getContext ( ) ) ; 
 + } 
 + else 
 + { 
 + String keypace = pair . left ; 
 + final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; 
 + / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , 
 + / / which may already be held by a thread waiting for the CL executor ( via getContext ) , 
 + / / causing deadlock 
 + Runnable runnable = new Runnable ( ) 
 { 
 - cfs . forceFlush ( ) ; 
 - } 
 - } ; 
 - StorageService . optionalTasks . execute ( runnable ) ; 
 + public void run ( ) 
 + { 
 + cfs . forceFlush ( ) ; 
 + } 
 + } ; 
 + StorageService . optionalTasks . execute ( runnable ) ; 
 + } 
 } 
 } 
 }
