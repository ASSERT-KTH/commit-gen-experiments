BLEU SCORE: 1.0

TEST MSG: Track metrics at a keyspace level
GENERATED MSG: Track metrics at a keyspace level

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a2a978e . . 576355c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 16 , 7 + 16 , 7 @ @ <nl> * Fix infinite loop on exception while streaming ( CASSANDRA - 7330 ) <nl> * Reference sstables before populating key cache ( CASSANDRA - 7234 ) <nl> Merged from 1 . 2 : <nl> - 1 . 2 . 17 <nl> + * Tracke metrics at a keyspace level ( CASSANDRA - 6539 ) <nl> * Add replace _ address _ first _ boot flag to only replace if not bootstrapped ( CASSANDRA - 7356 ) <nl> * Enable keepalive for native protocol ( CASSANDRA - 7380 ) <nl> * Check internal addresses for seeds ( CASSANDRA - 6523 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Keyspace . java b / src / java / org / apache / cassandra / db / Keyspace . java <nl> index 714956a . . d92bea7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Keyspace . java <nl> + + + b / src / java / org / apache / cassandra / db / Keyspace . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . Iterables ; <nl> + import org . apache . cassandra . metrics . KeyspaceMetrics ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 62 , 6 + 63 , 8 @ @ public class Keyspace <nl> * / <nl> public static final ReentrantReadWriteLock switchLock = new ReentrantReadWriteLock ( ) ; <nl> <nl> + public final KeyspaceMetrics metric ; <nl> + <nl> / / It is possible to call Keyspace . open without a running daemon , so it makes sense to ensure <nl> / / proper directories here as well as in CassandraDaemon . <nl> static <nl> @ @ - 133 , 6 + 136 , 7 @ @ public class Keyspace <nl> { <nl> for ( ColumnFamilyStore cfs : t . getColumnFamilyStores ( ) ) <nl> t . unloadCf ( cfs ) ; <nl> + t . metric . release ( ) ; <nl> } <nl> return t ; <nl> } <nl> @ @ - 259 , 6 + 263 , 7 @ @ public class Keyspace <nl> metadata = Schema . instance . getKSMetaData ( keyspaceName ) ; <nl> assert metadata ! = null : " Unknown keyspace " + keyspaceName ; <nl> createReplicationStrategy ( metadata ) ; <nl> + metric = new KeyspaceMetrics ( this ) ; <nl> <nl> for ( CFMetaData cfm : new ArrayList < CFMetaData > ( metadata . cfMetaData ( ) . values ( ) ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . 4a0980f <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> @ @ - 0 , 0 + 1 , 202 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . * ; <nl> + import com . yammer . metrics . stats . Snapshot ; <nl> + <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + <nl> + / * * <nl> + * Metrics for { @ link ColumnFamilyStore } . <nl> + * / <nl> + public class KeyspaceMetrics <nl> + { <nl> + / * * Total amount of data stored in the memtable , including column related overhead . * / <nl> + public final Gauge < Long > memtableDataSize ; <nl> + / * * Total amount of data stored in the memtables ( 2i and pending flush memtables included ) . * / <nl> + public final Gauge < Long > allMemtablesDataSize ; <nl> + / * * Total number of columns present in the memtable . * / <nl> + public final Gauge < Long > memtableColumnsCount ; <nl> + / * * Number of times flush has resulted in the memtable being switched out . * / <nl> + public final Gauge < Long > memtableSwitchCount ; <nl> + / * * Estimated number of tasks pending for this column family * / <nl> + public final Gauge < Integer > pendingTasks ; <nl> + / * * Estimate of number of pending compactios for this CF * / <nl> + public final Gauge < Integer > pendingCompactions ; <nl> + / * * Disk space used by SSTables belonging to this CF * / <nl> + public final Gauge < Long > liveDiskSpaceUsed ; <nl> + / * * Total disk space used by SSTables belonging to this CF , including obsolete ones waiting to be GC ' d * / <nl> + public final Gauge < Long > totalDiskSpaceUsed ; <nl> + / * * Disk space used by bloom filter * / <nl> + public final Gauge < Long > bloomFilterDiskSpaceUsed ; <nl> + <nl> + private final MetricNameFactory factory ; <nl> + <nl> + / * * <nl> + * Creates metrics for given { @ link ColumnFamilyStore } . <nl> + * <nl> + * @ param ks Keyspace to measure metrics <nl> + * / <nl> + public KeyspaceMetrics ( final Keyspace ks ) <nl> + { <nl> + factory = new KeyspaceMetricNameFactory ( ks ) ; <nl> + <nl> + memtableColumnsCount = Metrics . newGauge ( factory . createMetricName ( " MemtableColumnsCount " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . memtableColumnsCount . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + memtableDataSize = Metrics . newGauge ( factory . createMetricName ( " MemtableDataSize " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . memtableDataSize . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + allMemtablesDataSize = Metrics . newGauge ( factory . createMetricName ( " AllMemtablesDataSize " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + total + = cf . metric . allMemtablesDataSize . value ( ) ; <nl> + } <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + memtableSwitchCount = Metrics . newGauge ( factory . createMetricName ( " MemtableSwitchCount " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + sum + = cf . metric . memtableSwitchCount . count ( ) ; <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + pendingCompactions = Metrics . newGauge ( factory . createMetricName ( " PendingCompactions " ) , new Gauge < Integer > ( ) <nl> + { <nl> + public Integer value ( ) <nl> + { <nl> + int sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . pendingCompactions . value ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + pendingTasks = Metrics . newGauge ( factory . createMetricName ( " PendingTasks " ) , new Gauge < Integer > ( ) <nl> + { <nl> + public Integer value ( ) <nl> + { <nl> + return Keyspace . switchLock . getQueueLength ( ) ; <nl> + } <nl> + } ) ; <nl> + liveDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " LiveDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . liveDiskSpaceUsed . count ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + totalDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " TotalDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long sum = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + { <nl> + sum + = cf . metric . totalDiskSpaceUsed . count ( ) ; <nl> + } <nl> + return sum ; <nl> + } <nl> + } ) ; <nl> + bloomFilterDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + long total = 0 ; <nl> + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) <nl> + total + = cf . metric . bloomFilterDiskSpaceUsed . value ( ) ; <nl> + return total ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Release all associated metrics . <nl> + * / <nl> + public void release ( ) <nl> + { <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " AllMemtablesDataSize " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableDataSize " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableSwitchCount " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " PendingTasks " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " LiveDiskSpaceUsed " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " TotalDiskSpaceUsed " ) ) ; <nl> + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) ) ; <nl> + } <nl> + <nl> + class KeyspaceMetricNameFactory implements MetricNameFactory <nl> + { <nl> + private final String keyspaceName ; <nl> + <nl> + KeyspaceMetricNameFactory ( Keyspace ks ) <nl> + { <nl> + this . keyspaceName = ks . getName ( ) ; <nl> + } <nl> + <nl> + public MetricName createMetricName ( String metricName ) <nl> + { <nl> + String groupName = ColumnFamilyMetrics . class . getPackage ( ) . getName ( ) ; <nl> + <nl> + StringBuilder mbeanName = new StringBuilder ( ) ; <nl> + mbeanName . append ( groupName ) . append ( " : " ) ; <nl> + mbeanName . append ( " type = Keyspace " ) ; <nl> + mbeanName . append ( " , keyspace = " ) . append ( keyspaceName ) ; <nl> + mbeanName . append ( " , name = " ) . append ( metricName ) ; <nl> + <nl> + return new MetricName ( groupName , " keyspace " , metricName , keyspaceName , mbeanName . toString ( ) ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a2a978e . . 576355c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 16 , 7 + 16 , 7 @ @ 
 * Fix infinite loop on exception while streaming ( CASSANDRA - 7330 ) 
 * Reference sstables before populating key cache ( CASSANDRA - 7234 ) 
 Merged from 1 . 2 : 
 - 1 . 2 . 17 
 + * Tracke metrics at a keyspace level ( CASSANDRA - 6539 ) 
 * Add replace _ address _ first _ boot flag to only replace if not bootstrapped ( CASSANDRA - 7356 ) 
 * Enable keepalive for native protocol ( CASSANDRA - 7380 ) 
 * Check internal addresses for seeds ( CASSANDRA - 6523 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Keyspace . java b / src / java / org / apache / cassandra / db / Keyspace . java 
 index 714956a . . d92bea7 100644 
 - - - a / src / java / org / apache / cassandra / db / Keyspace . java 
 + + + b / src / java / org / apache / cassandra / db / Keyspace . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 
 import com . google . common . base . Function ; 
 import com . google . common . collect . Iterables ; 
 + import org . apache . cassandra . metrics . KeyspaceMetrics ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 62 , 6 + 63 , 8 @ @ public class Keyspace 
 * / 
 public static final ReentrantReadWriteLock switchLock = new ReentrantReadWriteLock ( ) ; 
 
 + public final KeyspaceMetrics metric ; 
 + 
 / / It is possible to call Keyspace . open without a running daemon , so it makes sense to ensure 
 / / proper directories here as well as in CassandraDaemon . 
 static 
 @ @ - 133 , 6 + 136 , 7 @ @ public class Keyspace 
 { 
 for ( ColumnFamilyStore cfs : t . getColumnFamilyStores ( ) ) 
 t . unloadCf ( cfs ) ; 
 + t . metric . release ( ) ; 
 } 
 return t ; 
 } 
 @ @ - 259 , 6 + 263 , 7 @ @ public class Keyspace 
 metadata = Schema . instance . getKSMetaData ( keyspaceName ) ; 
 assert metadata ! = null : " Unknown keyspace " + keyspaceName ; 
 createReplicationStrategy ( metadata ) ; 
 + metric = new KeyspaceMetrics ( this ) ; 
 
 for ( CFMetaData cfm : new ArrayList < CFMetaData > ( metadata . cfMetaData ( ) . values ( ) ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 new file mode 100644 
 index 0000000 . . 4a0980f 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 @ @ - 0 , 0 + 1 , 202 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . * ; 
 + import com . yammer . metrics . stats . Snapshot ; 
 + 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + 
 + / * * 
 + * Metrics for { @ link ColumnFamilyStore } . 
 + * / 
 + public class KeyspaceMetrics 
 + { 
 + / * * Total amount of data stored in the memtable , including column related overhead . * / 
 + public final Gauge < Long > memtableDataSize ; 
 + / * * Total amount of data stored in the memtables ( 2i and pending flush memtables included ) . * / 
 + public final Gauge < Long > allMemtablesDataSize ; 
 + / * * Total number of columns present in the memtable . * / 
 + public final Gauge < Long > memtableColumnsCount ; 
 + / * * Number of times flush has resulted in the memtable being switched out . * / 
 + public final Gauge < Long > memtableSwitchCount ; 
 + / * * Estimated number of tasks pending for this column family * / 
 + public final Gauge < Integer > pendingTasks ; 
 + / * * Estimate of number of pending compactios for this CF * / 
 + public final Gauge < Integer > pendingCompactions ; 
 + / * * Disk space used by SSTables belonging to this CF * / 
 + public final Gauge < Long > liveDiskSpaceUsed ; 
 + / * * Total disk space used by SSTables belonging to this CF , including obsolete ones waiting to be GC ' d * / 
 + public final Gauge < Long > totalDiskSpaceUsed ; 
 + / * * Disk space used by bloom filter * / 
 + public final Gauge < Long > bloomFilterDiskSpaceUsed ; 
 + 
 + private final MetricNameFactory factory ; 
 + 
 + / * * 
 + * Creates metrics for given { @ link ColumnFamilyStore } . 
 + * 
 + * @ param ks Keyspace to measure metrics 
 + * / 
 + public KeyspaceMetrics ( final Keyspace ks ) 
 + { 
 + factory = new KeyspaceMetricNameFactory ( ks ) ; 
 + 
 + memtableColumnsCount = Metrics . newGauge ( factory . createMetricName ( " MemtableColumnsCount " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . memtableColumnsCount . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + memtableDataSize = Metrics . newGauge ( factory . createMetricName ( " MemtableDataSize " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . memtableDataSize . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + allMemtablesDataSize = Metrics . newGauge ( factory . createMetricName ( " AllMemtablesDataSize " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + total + = cf . metric . allMemtablesDataSize . value ( ) ; 
 + } 
 + return total ; 
 + } 
 + } ) ; 
 + memtableSwitchCount = Metrics . newGauge ( factory . createMetricName ( " MemtableSwitchCount " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + sum + = cf . metric . memtableSwitchCount . count ( ) ; 
 + return sum ; 
 + } 
 + } ) ; 
 + pendingCompactions = Metrics . newGauge ( factory . createMetricName ( " PendingCompactions " ) , new Gauge < Integer > ( ) 
 + { 
 + public Integer value ( ) 
 + { 
 + int sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . pendingCompactions . value ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + pendingTasks = Metrics . newGauge ( factory . createMetricName ( " PendingTasks " ) , new Gauge < Integer > ( ) 
 + { 
 + public Integer value ( ) 
 + { 
 + return Keyspace . switchLock . getQueueLength ( ) ; 
 + } 
 + } ) ; 
 + liveDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " LiveDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . liveDiskSpaceUsed . count ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + totalDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " TotalDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long sum = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + { 
 + sum + = cf . metric . totalDiskSpaceUsed . count ( ) ; 
 + } 
 + return sum ; 
 + } 
 + } ) ; 
 + bloomFilterDiskSpaceUsed = Metrics . newGauge ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + long total = 0 ; 
 + for ( ColumnFamilyStore cf : ks . getColumnFamilyStores ( ) ) 
 + total + = cf . metric . bloomFilterDiskSpaceUsed . value ( ) ; 
 + return total ; 
 + } 
 + } ) ; 
 + } 
 + 
 + / * * 
 + * Release all associated metrics . 
 + * / 
 + public void release ( ) 
 + { 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " AllMemtablesDataSize " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableDataSize " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " MemtableSwitchCount " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " PendingTasks " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " LiveDiskSpaceUsed " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " TotalDiskSpaceUsed " ) ) ; 
 + Metrics . defaultRegistry ( ) . removeMetric ( factory . createMetricName ( " BloomFilterDiskSpaceUsed " ) ) ; 
 + } 
 + 
 + class KeyspaceMetricNameFactory implements MetricNameFactory 
 + { 
 + private final String keyspaceName ; 
 + 
 + KeyspaceMetricNameFactory ( Keyspace ks ) 
 + { 
 + this . keyspaceName = ks . getName ( ) ; 
 + } 
 + 
 + public MetricName createMetricName ( String metricName ) 
 + { 
 + String groupName = ColumnFamilyMetrics . class . getPackage ( ) . getName ( ) ; 
 + 
 + StringBuilder mbeanName = new StringBuilder ( ) ; 
 + mbeanName . append ( groupName ) . append ( " : " ) ; 
 + mbeanName . append ( " type = Keyspace " ) ; 
 + mbeanName . append ( " , keyspace = " ) . append ( keyspaceName ) ; 
 + mbeanName . append ( " , name = " ) . append ( metricName ) ; 
 + 
 + return new MetricName ( groupName , " keyspace " , metricName , keyspaceName , mbeanName . toString ( ) ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
