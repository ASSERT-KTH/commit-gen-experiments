BLEU SCORE: 0.02383853510228548

TEST MSG: Make read " defrag " async to reclaim memtables
GENERATED MSG: revert # 2503

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 71a6642 . . b4cb6fb 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 3 <nl> + * Make read " defrag " async to reclaim memtables ( CASSANDRA - 8459 ) <nl> * Remove tmplink files for offline compactions ( CASSANDRA - 8321 ) <nl> * Reduce maxHintsInProgress ( CASSANDRA - 8415 ) <nl> * BTree updates may call provided update function twice ( CASSANDRA - 8018 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java <nl> index 1b22e70 . . 4efcd9c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CollationController . java <nl> + + + b / src / java / org / apache / cassandra / db / CollationController . java <nl> @ @ - 29 , 6 + 29 , 8 @ @ import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Iterators ; <nl> <nl> import net . nicoulaj . compilecommand . annotations . Inline ; <nl> + import org . apache . cassandra . concurrent . Stage ; <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> @ @ - 152 , 10 + 154 , 18 @ @ public class CollationController <nl> & & ! cfs . isAutoCompactionDisabled ( ) <nl> & & cfs . getCompactionStrategy ( ) . shouldDefragment ( ) ) <nl> { <nl> + / / ! ! WARNING ! ! if we stop copying our data to a heap - managed object , <nl> + / / we will need to track the lifetime of this mutation as well <nl> Tracing . trace ( " Defragmenting requested data " ) ; <nl> - Mutation mutation = new Mutation ( cfs . keyspace . getName ( ) , filter . key . getKey ( ) , returnCF . cloneMe ( ) ) ; <nl> - / / skipping commitlog and index updates is fine since we ' re just de - fragmenting existing data <nl> - Keyspace . open ( mutation . getKeyspaceName ( ) ) . apply ( mutation , false , false ) ; <nl> + final Mutation mutation = new Mutation ( cfs . keyspace . getName ( ) , filter . key . getKey ( ) , returnCF . cloneMe ( ) ) ; <nl> + StageManager . getStage ( Stage . MUTATION ) . execute ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / skipping commitlog and index updates is fine since we ' re just de - fragmenting existing data <nl> + Keyspace . open ( mutation . getKeyspaceName ( ) ) . apply ( mutation , false , false ) ; <nl> + } <nl> + } ) ; <nl> } <nl> <nl> / / Caller is responsible for final removeDeletedCF . This is important for cacheRow to work correctly :
NEAREST DIFF (one line): diff - - git a / pylib / cqlshlib / cqlhandling . py b / pylib / cqlshlib / cqlhandling . py <nl> index 769ea16 . . 2df8061 100644 <nl> - - - a / pylib / cqlshlib / cqlhandling . py <nl> + + + b / pylib / cqlshlib / cqlhandling . py <nl> @ @ - 189 , 7 + 189 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> < star > : : = " * " ; <nl> < range > : : = " . . " ; <nl> < endtoken > : : = " ; " ; <nl> - < op > : : = / [ = , ( ) . ] / ; <nl> + < op > : : = / [ - + = , ( ) . ] / ; <nl> < cmp > : : = / [ < > ] = ? / ; <nl> <nl> < unclosedString > : : = / ' ( [ ^ ' ] | ' ' ) * / ; <nl> @ @ - 267 , 7 + 267 , 7 @ @ syntax _ rules + = r ' ' ' <nl> < selectWhereClause > : : = < relation > ( " AND " < relation > ) * <nl> | keyname = < colname > " IN " " ( " < term > ( " , " < term > ) * " ) " <nl> ; <nl> - < relation > : : = [ rel _ lhs ] = < colname > ( " = " | " < " | " > " | " < = " | " > = " ) < term > <nl> + < relation > : : = [ rel _ lhs ] = < colname > ( " = " | " < " | " > " | " < = " | " > = " ) < colname > <nl> ; <nl> < whatToSelect > : : = colname = < colname > ( " , " colname = < colname > ) * <nl> | ( " FIRST " < integer > ) ? " REVERSED " ? ( rangestart = < colname > " . . " rangeend = < colname > <nl> @ @ - 358 , 8 + 358 , 8 @ @ syntax _ rules + = r ' ' ' <nl> " SET " < assignment > ( " , " < assignment > ) * <nl> " WHERE " < updateWhereClause > <nl> ; <nl> - < assignment > : : = updatecol = < colname > " = " update _ rhs = < term > <nl> - ( counterop = ( " + " | " - " ) < term > ) ? <nl> + < assignment > : : = updatecol = < colname > " = " update _ rhs = < colname > <nl> + ( counterop = ( " + " | " - " ? ) < integer > ) ? <nl> ; <nl> < updateWhereClause > : : = updatefiltercol = < colname > " = " < term > <nl> | updatefilterkey = < colname > filter _ in = " IN " " ( " < term > ( " , " < term > ) * " ) " <nl> diff - - git a / pylib / cqlshlib / pylexotron . py b / pylib / cqlshlib / pylexotron . py <nl> index 5be8080 . . fd769a6 100644 <nl> - - - a / pylib / cqlshlib / pylexotron . py <nl> + + + b / pylib / cqlshlib / pylexotron . py <nl> @ @ - 88 , 6 + 88 , 10 @ @ class ParseContext : <nl> return self . _ _ class _ _ ( self . ruleset , self . bindings , self . matched , <nl> self . remainder , newname ) <nl> <nl> + def _ _ repr _ _ ( self ) : <nl> + return ' < % s matched = % r remainder = % r prodname = % r > ' % ( self . _ _ class _ _ . _ _ name _ _ , self . matched , self . remainder , <nl> + self . productionname ) <nl> + <nl> class matcher : <nl> def _ _ init _ _ ( self , arg ) : <nl> self . arg = arg

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 71a6642 . . b4cb6fb 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 3 
 + * Make read " defrag " async to reclaim memtables ( CASSANDRA - 8459 ) 
 * Remove tmplink files for offline compactions ( CASSANDRA - 8321 ) 
 * Reduce maxHintsInProgress ( CASSANDRA - 8415 ) 
 * BTree updates may call provided update function twice ( CASSANDRA - 8018 ) 
 diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java 
 index 1b22e70 . . 4efcd9c 100644 
 - - - a / src / java / org / apache / cassandra / db / CollationController . java 
 + + + b / src / java / org / apache / cassandra / db / CollationController . java 
 @ @ - 29 , 6 + 29 , 8 @ @ import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Iterators ; 
 
 import net . nicoulaj . compilecommand . annotations . Inline ; 
 + import org . apache . cassandra . concurrent . Stage ; 
 + import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; 
 import org . apache . cassandra . db . composites . CellName ; 
 @ @ - 152 , 10 + 154 , 18 @ @ public class CollationController 
 & & ! cfs . isAutoCompactionDisabled ( ) 
 & & cfs . getCompactionStrategy ( ) . shouldDefragment ( ) ) 
 { 
 + / / ! ! WARNING ! ! if we stop copying our data to a heap - managed object , 
 + / / we will need to track the lifetime of this mutation as well 
 Tracing . trace ( " Defragmenting requested data " ) ; 
 - Mutation mutation = new Mutation ( cfs . keyspace . getName ( ) , filter . key . getKey ( ) , returnCF . cloneMe ( ) ) ; 
 - / / skipping commitlog and index updates is fine since we ' re just de - fragmenting existing data 
 - Keyspace . open ( mutation . getKeyspaceName ( ) ) . apply ( mutation , false , false ) ; 
 + final Mutation mutation = new Mutation ( cfs . keyspace . getName ( ) , filter . key . getKey ( ) , returnCF . cloneMe ( ) ) ; 
 + StageManager . getStage ( Stage . MUTATION ) . execute ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / skipping commitlog and index updates is fine since we ' re just de - fragmenting existing data 
 + Keyspace . open ( mutation . getKeyspaceName ( ) ) . apply ( mutation , false , false ) ; 
 + } 
 + } ) ; 
 } 
 
 / / Caller is responsible for final removeDeletedCF . This is important for cacheRow to work correctly :

NEAREST DIFF:
diff - - git a / pylib / cqlshlib / cqlhandling . py b / pylib / cqlshlib / cqlhandling . py 
 index 769ea16 . . 2df8061 100644 
 - - - a / pylib / cqlshlib / cqlhandling . py 
 + + + b / pylib / cqlshlib / cqlhandling . py 
 @ @ - 189 , 7 + 189 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 < star > : : = " * " ; 
 < range > : : = " . . " ; 
 < endtoken > : : = " ; " ; 
 - < op > : : = / [ = , ( ) . ] / ; 
 + < op > : : = / [ - + = , ( ) . ] / ; 
 < cmp > : : = / [ < > ] = ? / ; 
 
 < unclosedString > : : = / ' ( [ ^ ' ] | ' ' ) * / ; 
 @ @ - 267 , 7 + 267 , 7 @ @ syntax _ rules + = r ' ' ' 
 < selectWhereClause > : : = < relation > ( " AND " < relation > ) * 
 | keyname = < colname > " IN " " ( " < term > ( " , " < term > ) * " ) " 
 ; 
 - < relation > : : = [ rel _ lhs ] = < colname > ( " = " | " < " | " > " | " < = " | " > = " ) < term > 
 + < relation > : : = [ rel _ lhs ] = < colname > ( " = " | " < " | " > " | " < = " | " > = " ) < colname > 
 ; 
 < whatToSelect > : : = colname = < colname > ( " , " colname = < colname > ) * 
 | ( " FIRST " < integer > ) ? " REVERSED " ? ( rangestart = < colname > " . . " rangeend = < colname > 
 @ @ - 358 , 8 + 358 , 8 @ @ syntax _ rules + = r ' ' ' 
 " SET " < assignment > ( " , " < assignment > ) * 
 " WHERE " < updateWhereClause > 
 ; 
 - < assignment > : : = updatecol = < colname > " = " update _ rhs = < term > 
 - ( counterop = ( " + " | " - " ) < term > ) ? 
 + < assignment > : : = updatecol = < colname > " = " update _ rhs = < colname > 
 + ( counterop = ( " + " | " - " ? ) < integer > ) ? 
 ; 
 < updateWhereClause > : : = updatefiltercol = < colname > " = " < term > 
 | updatefilterkey = < colname > filter _ in = " IN " " ( " < term > ( " , " < term > ) * " ) " 
 diff - - git a / pylib / cqlshlib / pylexotron . py b / pylib / cqlshlib / pylexotron . py 
 index 5be8080 . . fd769a6 100644 
 - - - a / pylib / cqlshlib / pylexotron . py 
 + + + b / pylib / cqlshlib / pylexotron . py 
 @ @ - 88 , 6 + 88 , 10 @ @ class ParseContext : 
 return self . _ _ class _ _ ( self . ruleset , self . bindings , self . matched , 
 self . remainder , newname ) 
 
 + def _ _ repr _ _ ( self ) : 
 + return ' < % s matched = % r remainder = % r prodname = % r > ' % ( self . _ _ class _ _ . _ _ name _ _ , self . matched , self . remainder , 
 + self . productionname ) 
 + 
 class matcher : 
 def _ _ init _ _ ( self , arg ) : 
 self . arg = arg
