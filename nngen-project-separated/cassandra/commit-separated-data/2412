BLEU SCORE: 0.02383853510228548

TEST MSG: Don ' t fail streams on failure detector downs
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 333606a . . b5c2feb 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 6 + 1 , 7 @ @ <nl> 2 . 1 . 0 <nl> * Upgrade to Pig 0 . 12 . 1 ( CASSANDRA - 6556 ) <nl> * Make sure we clear out repair sessions from netstats ( CASSANDRA - 7329 ) <nl> + * Don ' t fail streams on failure detector downs ( CASSANDRA - 3569 ) <nl> Merged from 2 . 0 : <nl> * Fix NPE in StreamTransferTask . createMessageForRetry ( ) ( CASSANDRA - 7323 ) <nl> * Make StreamSession # closeSession ( ) idempotent ( CASSANDRA - 7262 ) <nl> diff - - git a / debian / cassandra - sysctl . conf b / debian / cassandra - sysctl . conf <nl> index 2173765 . . 443e83f 100644 <nl> - - - a / debian / cassandra - sysctl . conf <nl> + + + b / debian / cassandra - sysctl . conf <nl> @ @ - 1 + 1 , 2 @ @ <nl> vm . max _ map _ count = 1048575 <nl> + net . ipv4 . tcp _ keepalive _ time = 300 <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairJob . java b / src / java / org / apache / cassandra / repair / RepairJob . java <nl> index af00403 . . 8057ed5 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairJob . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairJob . java <nl> @ @ - 58 , 11 + 58 , 21 @ @ public class RepairJob <nl> / * Count down as sync completes * / <nl> private AtomicInteger waitForSync ; <nl> <nl> + private final IRepairJobEventListener listener ; <nl> + <nl> / * * <nl> * Create repair job to run on specific columnfamily <nl> * / <nl> - public RepairJob ( UUID parentSessionId , UUID sessionId , String keyspace , String columnFamily , Range < Token > range , boolean isSequential , ListeningExecutorService taskExecutor ) <nl> + public RepairJob ( IRepairJobEventListener listener , <nl> + UUID parentSessionId , <nl> + UUID sessionId , <nl> + String keyspace , <nl> + String columnFamily , <nl> + Range < Token > range , <nl> + boolean isSequential , <nl> + ListeningExecutorService taskExecutor ) <nl> { <nl> + this . listener = listener ; <nl> this . desc = new RepairJobDesc ( parentSessionId , sessionId , keyspace , columnFamily , range ) ; <nl> this . isSequential = isSequential ; <nl> this . taskExecutor = taskExecutor ; <nl> @ @ - 114 , 7 + 124 , 8 @ @ public class RepairJob <nl> public void onFailure ( Throwable throwable ) <nl> { <nl> / / TODO need to propagate error to RepairSession <nl> - logger . error ( " Error while snapshot " , throwable ) ; <nl> + logger . error ( " Error occurred during snapshot phase " , throwable ) ; <nl> + listener . failedSnapshot ( ) ; <nl> failed = true ; <nl> } <nl> } , taskExecutor ) ; <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairSession . java b / src / java / org / apache / cassandra / repair / RepairSession . java <nl> index 507dafa . . 346f3f4 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairSession . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairSession . java <nl> @ @ - 74 , 7 + 74 , 9 @ @ import org . apache . cassandra . utils . concurrent . SimpleCondition ; <nl> * Similarly , if a job is sequential , it will handle one Differencer at a time , but will handle <nl> * all of them in parallel otherwise . <nl> * / <nl> - public class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener <nl> + public class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , <nl> + IFailureDetectionEventListener , <nl> + IRepairJobEventListener <nl> { <nl> private static Logger logger = LoggerFactory . getLogger ( RepairSession . class ) ; <nl> <nl> @ @ - 89 , 9 + 91 , 11 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> <nl> private volatile Exception exception ; <nl> private final AtomicBoolean isFailed = new AtomicBoolean ( false ) ; <nl> + private final AtomicBoolean fdUnregistered = new AtomicBoolean ( false ) ; <nl> <nl> / / First , all RepairJobs are added to this queue , <nl> final Queue < RepairJob > jobs = new ConcurrentLinkedQueue < > ( ) ; <nl> + <nl> / / and after receiving all validation , the job is moved to <nl> / / this map , keyed by CF name . <nl> final Map < String , RepairJob > syncingJobs = new ConcurrentHashMap < > ( ) ; <nl> @ @ - 169 , 23 + 173 , 32 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> assert job . desc . equals ( desc ) ; <nl> if ( job . addTree ( endpoint , tree ) = = 0 ) <nl> { <nl> - logger . debug ( " All response received for { } / { } " , getId ( ) , desc . columnFamily ) ; <nl> + logger . debug ( " All responses received for { } / { } " , getId ( ) , desc . columnFamily ) ; <nl> if ( ! job . isFailed ( ) ) <nl> { <nl> syncingJobs . put ( job . desc . columnFamily , job ) ; <nl> job . submitDifferencers ( ) ; <nl> } <nl> <nl> - / / This job is complete , switching to next in line ( note that only <nl> - / / one thread will can ever do this ) <nl> + / / This job is complete , switching to next in line ( note that only one thread will ever do this ) <nl> jobs . poll ( ) ; <nl> RepairJob nextJob = jobs . peek ( ) ; <nl> if ( nextJob = = null ) <nl> + { <nl> + / / Unregister from FailureDetector once we ' ve completed synchronizing Merkle trees . <nl> + / / After this point , we rely on tcp _ keepalive for individual sockets to notify us when a connection is down . <nl> + / / See CASSANDRA - 3569 <nl> + if ( fdUnregistered . compareAndSet ( false , true ) ) <nl> + FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; <nl> + <nl> / / We are done with this repair session as far as differencing <nl> / / is considered . Just inform the session <nl> differencingDone . signalAll ( ) ; <nl> + } <nl> else <nl> + { <nl> nextJob . sendTreeRequests ( endpoints ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 271 , 7 + 284 , 7 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> / / Create and queue a RepairJob for each column family <nl> for ( String cfname : cfnames ) <nl> { <nl> - RepairJob job = new RepairJob ( parentRepairSession , id , keyspace , cfname , range , isSequential , taskExecutor ) ; <nl> + RepairJob job = new RepairJob ( this , parentRepairSession , id , keyspace , cfname , range , isSequential , taskExecutor ) ; <nl> jobs . offer ( job ) ; <nl> } <nl> logger . debug ( " Sending tree requests to endpoints { } " , endpoints ) ; <nl> @ @ - 299 , 7 + 312 , 13 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> { <nl> / / mark this session as terminated <nl> terminate ( ) ; <nl> + <nl> ActiveRepairService . instance . removeFromActiveSessions ( this ) ; <nl> + <nl> + / / If we ' ve reached here in an exception state without completing Merkle Tree sync , we ' ll still be registered <nl> + / / with the FailureDetector . <nl> + if ( fdUnregistered . compareAndSet ( false , true ) ) <nl> + FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; <nl> } <nl> } <nl> <nl> @ @ - 320 , 11 + 339 , 17 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan <nl> completed . signalAll ( ) ; <nl> } <nl> <nl> + public void failedSnapshot ( ) <nl> + { <nl> + exception = new IOException ( " Failed during snapshot creation . " ) ; <nl> + forceShutdown ( ) ; <nl> + } <nl> + <nl> void failedNode ( InetAddress remote ) <nl> { <nl> String errorMsg = String . format ( " Endpoint % s died " , remote ) ; <nl> exception = new IOException ( errorMsg ) ; <nl> - / / If a node failed , we stop everything ( though there could still be some activity in the background ) <nl> + / / If a node failed during Merkle creation , we stop everything ( though there could still be some activity in the background ) <nl> forceShutdown ( ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index b300547 . . 7f7325b 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 135 , 7 + 135 , 6 @ @ public class ActiveRepairService <nl> <nl> public void removeFromActiveSessions ( RepairSession session ) <nl> { <nl> - FailureDetector . instance . unregisterFailureDetectionEventListener ( session ) ; <nl> Gossiper . instance . unregister ( session ) ; <nl> sessions . remove ( session . getId ( ) ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> index 5484c83 . . 5716ae9 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> + + + b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java <nl> @ @ - 123 , 6 + 123 , 7 @ @ public class ConnectionHandler <nl> { <nl> Socket socket = OutboundTcpConnectionPool . newSocket ( peer ) ; <nl> socket . setSoTimeout ( DatabaseDescriptor . getStreamingSocketTimeout ( ) ) ; <nl> + socket . setKeepAlive ( true ) ; <nl> return socket ; <nl> } <nl> catch ( IOException e ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> index 411f969 . . 1afc07e 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java <nl> @ @ - 108 , 7 + 108 , 7 @ @ import org . apache . cassandra . utils . Pair ; <nl> * session is done is is closed ( closeSession ( ) ) . Otherwise , the node switch to the WAIT _ COMPLETE state and <nl> * send a CompleteMessage to the other side . <nl> * / <nl> - public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener <nl> + public class StreamSession implements IEndpointStateChangeSubscriber <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( StreamSession . class ) ; <nl> public final InetAddress peer ; <nl> @ @ - 181 , 10 + 181 , 6 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe <nl> public void init ( StreamResultFuture streamResult ) <nl> { <nl> this . streamResult = streamResult ; <nl> - <nl> - / / register to gossiper / FD to fail on node failure <nl> - Gossiper . instance . register ( this ) ; <nl> - FailureDetector . instance . registerFailureDetectionEventListener ( this ) ; <nl> } <nl> <nl> public void start ( ) <nl> @ @ - 358 , 8 + 354 , 6 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe <nl> / / incoming thread ( so we would deadlock ) . <nl> handler . close ( ) ; <nl> <nl> - Gossiper . instance . unregister ( this ) ; <nl> - FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; <nl> streamResult . handleSessionComplete ( this ) ; <nl> } <nl> } <nl> @ @ - 613 , 23 + 607 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe <nl> <nl> public void onRemove ( InetAddress endpoint ) <nl> { <nl> - convict ( endpoint , Double . MAX _ VALUE ) ; <nl> + closeSession ( State . FAILED ) ; <nl> } <nl> <nl> public void onRestart ( InetAddress endpoint , EndpointState epState ) <nl> { <nl> - convict ( endpoint , Double . MAX _ VALUE ) ; <nl> - } <nl> - <nl> - public void convict ( InetAddress endpoint , double phi ) <nl> - { <nl> - if ( ! endpoint . equals ( peer ) ) <nl> - return ; <nl> - <nl> - / / We want a higher confidence in the failure detection than usual because failing a streaming wrongly has a high cost . <nl> - if ( phi < 2 * DatabaseDescriptor . getPhiConvictThreshold ( ) ) <nl> - return ; <nl> - <nl> closeSession ( State . FAILED ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> index 2fe75fa . . 48a7d89 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . streaming ; <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> + import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; <nl> @ @ - 33 , 6 + 34 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; <nl> <nl> private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; <nl> + private AtomicBoolean aborted = new AtomicBoolean ( false ) ; <nl> <nl> private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; <nl> <nl> @ @ - 75 , 11 + 77 , 15 @ @ public class StreamTransferTask extends StreamTask <nl> <nl> public void abort ( ) <nl> { <nl> - for ( OutgoingFileMessage file : files . values ( ) ) <nl> + / / Prevent releasing reference multiple times <nl> + if ( aborted . compareAndSet ( false , true ) ) <nl> { <nl> - file . sstable . releaseReference ( ) ; <nl> + for ( OutgoingFileMessage file : files . values ( ) ) <nl> + { <nl> + file . sstable . releaseReference ( ) ; <nl> + } <nl> + timeoutExecutor . shutdownNow ( ) ; <nl> } <nl> - timeoutExecutor . shutdownNow ( ) ; <nl> } <nl> <nl> public int getTotalNumberOfFiles ( )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 333606a . . b5c2feb 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 6 + 1 , 7 @ @ 
 2 . 1 . 0 
 * Upgrade to Pig 0 . 12 . 1 ( CASSANDRA - 6556 ) 
 * Make sure we clear out repair sessions from netstats ( CASSANDRA - 7329 ) 
 + * Don ' t fail streams on failure detector downs ( CASSANDRA - 3569 ) 
 Merged from 2 . 0 : 
 * Fix NPE in StreamTransferTask . createMessageForRetry ( ) ( CASSANDRA - 7323 ) 
 * Make StreamSession # closeSession ( ) idempotent ( CASSANDRA - 7262 ) 
 diff - - git a / debian / cassandra - sysctl . conf b / debian / cassandra - sysctl . conf 
 index 2173765 . . 443e83f 100644 
 - - - a / debian / cassandra - sysctl . conf 
 + + + b / debian / cassandra - sysctl . conf 
 @ @ - 1 + 1 , 2 @ @ 
 vm . max _ map _ count = 1048575 
 + net . ipv4 . tcp _ keepalive _ time = 300 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairJob . java b / src / java / org / apache / cassandra / repair / RepairJob . java 
 index af00403 . . 8057ed5 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairJob . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairJob . java 
 @ @ - 58 , 11 + 58 , 21 @ @ public class RepairJob 
 / * Count down as sync completes * / 
 private AtomicInteger waitForSync ; 
 
 + private final IRepairJobEventListener listener ; 
 + 
 / * * 
 * Create repair job to run on specific columnfamily 
 * / 
 - public RepairJob ( UUID parentSessionId , UUID sessionId , String keyspace , String columnFamily , Range < Token > range , boolean isSequential , ListeningExecutorService taskExecutor ) 
 + public RepairJob ( IRepairJobEventListener listener , 
 + UUID parentSessionId , 
 + UUID sessionId , 
 + String keyspace , 
 + String columnFamily , 
 + Range < Token > range , 
 + boolean isSequential , 
 + ListeningExecutorService taskExecutor ) 
 { 
 + this . listener = listener ; 
 this . desc = new RepairJobDesc ( parentSessionId , sessionId , keyspace , columnFamily , range ) ; 
 this . isSequential = isSequential ; 
 this . taskExecutor = taskExecutor ; 
 @ @ - 114 , 7 + 124 , 8 @ @ public class RepairJob 
 public void onFailure ( Throwable throwable ) 
 { 
 / / TODO need to propagate error to RepairSession 
 - logger . error ( " Error while snapshot " , throwable ) ; 
 + logger . error ( " Error occurred during snapshot phase " , throwable ) ; 
 + listener . failedSnapshot ( ) ; 
 failed = true ; 
 } 
 } , taskExecutor ) ; 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairSession . java b / src / java / org / apache / cassandra / repair / RepairSession . java 
 index 507dafa . . 346f3f4 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairSession . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairSession . java 
 @ @ - 74 , 7 + 74 , 9 @ @ import org . apache . cassandra . utils . concurrent . SimpleCondition ; 
 * Similarly , if a job is sequential , it will handle one Differencer at a time , but will handle 
 * all of them in parallel otherwise . 
 * / 
 - public class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener 
 + public class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber , 
 + IFailureDetectionEventListener , 
 + IRepairJobEventListener 
 { 
 private static Logger logger = LoggerFactory . getLogger ( RepairSession . class ) ; 
 
 @ @ - 89 , 9 + 91 , 11 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 
 private volatile Exception exception ; 
 private final AtomicBoolean isFailed = new AtomicBoolean ( false ) ; 
 + private final AtomicBoolean fdUnregistered = new AtomicBoolean ( false ) ; 
 
 / / First , all RepairJobs are added to this queue , 
 final Queue < RepairJob > jobs = new ConcurrentLinkedQueue < > ( ) ; 
 + 
 / / and after receiving all validation , the job is moved to 
 / / this map , keyed by CF name . 
 final Map < String , RepairJob > syncingJobs = new ConcurrentHashMap < > ( ) ; 
 @ @ - 169 , 23 + 173 , 32 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 assert job . desc . equals ( desc ) ; 
 if ( job . addTree ( endpoint , tree ) = = 0 ) 
 { 
 - logger . debug ( " All response received for { } / { } " , getId ( ) , desc . columnFamily ) ; 
 + logger . debug ( " All responses received for { } / { } " , getId ( ) , desc . columnFamily ) ; 
 if ( ! job . isFailed ( ) ) 
 { 
 syncingJobs . put ( job . desc . columnFamily , job ) ; 
 job . submitDifferencers ( ) ; 
 } 
 
 - / / This job is complete , switching to next in line ( note that only 
 - / / one thread will can ever do this ) 
 + / / This job is complete , switching to next in line ( note that only one thread will ever do this ) 
 jobs . poll ( ) ; 
 RepairJob nextJob = jobs . peek ( ) ; 
 if ( nextJob = = null ) 
 + { 
 + / / Unregister from FailureDetector once we ' ve completed synchronizing Merkle trees . 
 + / / After this point , we rely on tcp _ keepalive for individual sockets to notify us when a connection is down . 
 + / / See CASSANDRA - 3569 
 + if ( fdUnregistered . compareAndSet ( false , true ) ) 
 + FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; 
 + 
 / / We are done with this repair session as far as differencing 
 / / is considered . Just inform the session 
 differencingDone . signalAll ( ) ; 
 + } 
 else 
 + { 
 nextJob . sendTreeRequests ( endpoints ) ; 
 + } 
 } 
 } 
 
 @ @ - 271 , 7 + 284 , 7 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 / / Create and queue a RepairJob for each column family 
 for ( String cfname : cfnames ) 
 { 
 - RepairJob job = new RepairJob ( parentRepairSession , id , keyspace , cfname , range , isSequential , taskExecutor ) ; 
 + RepairJob job = new RepairJob ( this , parentRepairSession , id , keyspace , cfname , range , isSequential , taskExecutor ) ; 
 jobs . offer ( job ) ; 
 } 
 logger . debug ( " Sending tree requests to endpoints { } " , endpoints ) ; 
 @ @ - 299 , 7 + 312 , 13 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 { 
 / / mark this session as terminated 
 terminate ( ) ; 
 + 
 ActiveRepairService . instance . removeFromActiveSessions ( this ) ; 
 + 
 + / / If we ' ve reached here in an exception state without completing Merkle Tree sync , we ' ll still be registered 
 + / / with the FailureDetector . 
 + if ( fdUnregistered . compareAndSet ( false , true ) ) 
 + FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; 
 } 
 } 
 
 @ @ - 320 , 11 + 339 , 17 @ @ public class RepairSession extends WrappedRunnable implements IEndpointStateChan 
 completed . signalAll ( ) ; 
 } 
 
 + public void failedSnapshot ( ) 
 + { 
 + exception = new IOException ( " Failed during snapshot creation . " ) ; 
 + forceShutdown ( ) ; 
 + } 
 + 
 void failedNode ( InetAddress remote ) 
 { 
 String errorMsg = String . format ( " Endpoint % s died " , remote ) ; 
 exception = new IOException ( errorMsg ) ; 
 - / / If a node failed , we stop everything ( though there could still be some activity in the background ) 
 + / / If a node failed during Merkle creation , we stop everything ( though there could still be some activity in the background ) 
 forceShutdown ( ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index b300547 . . 7f7325b 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 135 , 7 + 135 , 6 @ @ public class ActiveRepairService 
 
 public void removeFromActiveSessions ( RepairSession session ) 
 { 
 - FailureDetector . instance . unregisterFailureDetectionEventListener ( session ) ; 
 Gossiper . instance . unregister ( session ) ; 
 sessions . remove ( session . getId ( ) ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 index 5484c83 . . 5716ae9 100644 
 - - - a / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 + + + b / src / java / org / apache / cassandra / streaming / ConnectionHandler . java 
 @ @ - 123 , 6 + 123 , 7 @ @ public class ConnectionHandler 
 { 
 Socket socket = OutboundTcpConnectionPool . newSocket ( peer ) ; 
 socket . setSoTimeout ( DatabaseDescriptor . getStreamingSocketTimeout ( ) ) ; 
 + socket . setKeepAlive ( true ) ; 
 return socket ; 
 } 
 catch ( IOException e ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamSession . java b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 index 411f969 . . 1afc07e 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamSession . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamSession . java 
 @ @ - 108 , 7 + 108 , 7 @ @ import org . apache . cassandra . utils . Pair ; 
 * session is done is is closed ( closeSession ( ) ) . Otherwise , the node switch to the WAIT _ COMPLETE state and 
 * send a CompleteMessage to the other side . 
 * / 
 - public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener 
 + public class StreamSession implements IEndpointStateChangeSubscriber 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( StreamSession . class ) ; 
 public final InetAddress peer ; 
 @ @ - 181 , 10 + 181 , 6 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe 
 public void init ( StreamResultFuture streamResult ) 
 { 
 this . streamResult = streamResult ; 
 - 
 - / / register to gossiper / FD to fail on node failure 
 - Gossiper . instance . register ( this ) ; 
 - FailureDetector . instance . registerFailureDetectionEventListener ( this ) ; 
 } 
 
 public void start ( ) 
 @ @ - 358 , 8 + 354 , 6 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe 
 / / incoming thread ( so we would deadlock ) . 
 handler . close ( ) ; 
 
 - Gossiper . instance . unregister ( this ) ; 
 - FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; 
 streamResult . handleSessionComplete ( this ) ; 
 } 
 } 
 @ @ - 613 , 23 + 607 , 11 @ @ public class StreamSession implements IEndpointStateChangeSubscriber , IFailureDe 
 
 public void onRemove ( InetAddress endpoint ) 
 { 
 - convict ( endpoint , Double . MAX _ VALUE ) ; 
 + closeSession ( State . FAILED ) ; 
 } 
 
 public void onRestart ( InetAddress endpoint , EndpointState epState ) 
 { 
 - convict ( endpoint , Double . MAX _ VALUE ) ; 
 - } 
 - 
 - public void convict ( InetAddress endpoint , double phi ) 
 - { 
 - if ( ! endpoint . equals ( peer ) ) 
 - return ; 
 - 
 - / / We want a higher confidence in the failure detection than usual because failing a streaming wrongly has a high cost . 
 - if ( phi < 2 * DatabaseDescriptor . getPhiConvictThreshold ( ) ) 
 - return ; 
 - 
 closeSession ( State . FAILED ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 index 2fe75fa . . 48a7d89 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . streaming ; 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 + import java . util . concurrent . atomic . AtomicBoolean ; 
 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; 
 @ @ - 33 , 6 + 34 , 7 @ @ public class StreamTransferTask extends StreamTask 
 private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; 
 
 private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; 
 + private AtomicBoolean aborted = new AtomicBoolean ( false ) ; 
 
 private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; 
 
 @ @ - 75 , 11 + 77 , 15 @ @ public class StreamTransferTask extends StreamTask 
 
 public void abort ( ) 
 { 
 - for ( OutgoingFileMessage file : files . values ( ) ) 
 + / / Prevent releasing reference multiple times 
 + if ( aborted . compareAndSet ( false , true ) ) 
 { 
 - file . sstable . releaseReference ( ) ; 
 + for ( OutgoingFileMessage file : files . values ( ) ) 
 + { 
 + file . sstable . releaseReference ( ) ; 
 + } 
 + timeoutExecutor . shutdownNow ( ) ; 
 } 
 - timeoutExecutor . shutdownNow ( ) ; 
 } 
 
 public int getTotalNumberOfFiles ( )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
