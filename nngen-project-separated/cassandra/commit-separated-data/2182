BLEU SCORE: 0.027611988917697356

TEST MSG: cqlsh : Fix handling of CAS statement results
GENERATED MSG: colorize PK + clustering differently

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2320653 . . 11ec7ff 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 1 <nl> + * ( cqlsh ) Fix handling of CAS statement results ( CASSANDRA - 7671 ) <nl> * ( cqlsh ) COPY TO / FROM improvements ( CASSANDRA - 7405 ) <nl> * Support list index operations with conditions ( CASSANDRA - 7499 ) <nl> * Add max live / tombstoned cells to nodetool cfstats output ( CASSANDRA - 7731 ) <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 340566d . . b633e93 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 585 , 13 + 585 , 13 @ @ class Shell ( cmd . Cmd ) : <nl> self . decoding _ errors . append ( err ) <nl> return format _ value ( err , self . output _ codec . name , addcolor = self . color ) <nl> <nl> - def myformat _ colname ( self , name , cfMetaData = None ) : <nl> + def myformat _ colname ( self , name , table _ meta = None ) : <nl> column _ colors = COLUMN _ NAME _ COLORS . copy ( ) <nl> # check column role and color appropriately <nl> - if cfMetaData : <nl> - if name in [ col . name for col in cfMetaData . partition _ key ] : <nl> + if table _ meta : <nl> + if name in [ col . name for col in table _ meta . partition _ key ] : <nl> column _ colors . default _ factory = lambda : RED <nl> - elif name in [ col . name for col in cfMetaData . clustering _ key ] : <nl> + elif name in [ col . name for col in table _ meta . clustering _ key ] : <nl> column _ colors . default _ factory = lambda : CYAN <nl> return self . myformat _ value ( name , colormap = column _ colors ) <nl> <nl> @ @ - 913 , 6 + 913 , 12 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> return result <nl> <nl> + def parse _ for _ table _ meta ( self , query _ string ) : <nl> + parsed = cqlruleset . cql _ parse ( query _ string ) [ 1 ] <nl> + ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) <nl> + return self . get _ table _ meta ( ks , cf ) <nl> + <nl> def perform _ simple _ statement ( self , statement , with _ default _ limit = False ) : <nl> if not statement : <nl> return False <nl> @ @ - 930 , 25 + 936 , 21 @ @ class Shell ( cmd . Cmd ) : <nl> return False <nl> <nl> if statement . query _ string [ : 6 ] . lower ( ) = = ' select ' or statement . query _ string . lower ( ) . startswith ( " list " ) : <nl> - parsed = cqlruleset . cql _ parse ( statement . query _ string ) [ 1 ] <nl> - ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> - cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) <nl> - cfMetaData = self . get _ table _ meta ( ks , cf ) <nl> - self . print _ result ( rows , with _ default _ limit , cfMetaData ) <nl> + self . print _ result ( rows , with _ default _ limit , self . parse _ for _ table _ meta ( statement . query _ string ) ) <nl> elif rows : <nl> # CAS INSERT / UPDATE <nl> self . writeresult ( " " ) <nl> - self . print _ static _ result ( rows ) <nl> + self . print _ static _ result ( rows , self . parse _ for _ table _ meta ( statement . query _ string ) ) <nl> self . flush _ output ( ) <nl> return True <nl> <nl> - def print _ result ( self , rows , with _ default _ limit , cfMetaData ) : <nl> + def print _ result ( self , rows , with _ default _ limit , table _ meta ) : <nl> self . decoding _ errors = [ ] <nl> <nl> self . writeresult ( " " ) <nl> if rows : <nl> rows = list ( rows ) # this may be an iterator if the result is large enough to page <nl> - self . print _ static _ result ( rows , cfMetaData ) <nl> + self . print _ static _ result ( rows , table _ meta ) <nl> self . writeresult ( " ( % d rows ) " % len ( rows or [ ] ) ) <nl> <nl> if self . decoding _ errors : <nl> @ @ - 965 , 16 + 967 , 16 @ @ class Shell ( cmd . Cmd ) : <nl> % DEFAULT _ SELECT _ LIMIT , color = RED ) <nl> self . writeresult ( " " ) <nl> <nl> - def print _ static _ result ( self , rows , cfMetaData ) : <nl> + def print _ static _ result ( self , rows , table _ meta ) : <nl> if not rows : <nl> # print header only <nl> - colnames = cfMetaData . columns . keys ( ) # full header <nl> - formatted _ names = [ self . myformat _ colname ( name , cfMetaData ) for name in colnames ] <nl> + colnames = table _ meta . columns . keys ( ) # full header <nl> + formatted _ names = [ self . myformat _ colname ( name , table _ meta ) for name in colnames ] <nl> self . print _ formatted _ result ( formatted _ names , None ) <nl> return <nl> <nl> colnames = rows [ 0 ] . keys ( ) <nl> - formatted _ names = [ self . myformat _ colname ( name , cfMetaData ) for name in colnames ] <nl> + formatted _ names = [ self . myformat _ colname ( name , table _ meta ) for name in colnames ] <nl> formatted _ values = [ map ( self . myformat _ value , row . values ( ) ) for row in rows ] <nl> <nl> if self . expand _ enabled : <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 0888d64 . . e4ef67b 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 185 , 6 + 185 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> | < blobLiteral > <nl> | < collectionLiteral > <nl> | < functionName > < functionArguments > <nl> + | " NULL " <nl> ; <nl> <nl> < functionArguments > : : = " ( " ( < term > ( " , " < term > ) * ) ? " ) " <nl> @ @ - 673 , 6 + 674 , 7 @ @ syntax _ rules + = r ' ' ' <nl> ( " , " [ colname ] = < cident > ) * " ) " <nl> " VALUES " " ( " [ newval ] = < term > valcomma = " , " [ newval ] = < term > <nl> ( valcomma = " , " [ newval ] = < term > ) * valcomma = " ) " <nl> + ( " IF " " NOT " " EXISTS " ) ? <nl> ( " USING " [ insertopt ] = < usingOption > <nl> ( " AND " [ insertopt ] = < usingOption > ) * ) ? <nl> ; <nl> @ @ - 741 , 13 + 743 , 19 @ @ syntax _ rules + = r ' ' ' <nl> ( " AND " [ updateopt ] = < usingOption > ) * ) ? <nl> " SET " < assignment > ( " , " < assignment > ) * <nl> " WHERE " < whereClause > <nl> + ( " IF " < conditions > ) ? <nl> ; <nl> < assignment > : : = updatecol = < cident > <nl> - ( " = " update _ rhs = ( < value > | < cident > ) <nl> + ( " = " update _ rhs = ( < term > | < cident > ) <nl> ( counterop = ( " + " | " - " ) inc = < wholenumber > <nl> - | listadder = " + " listcol = < cident > ) <nl> + | listadder = " + " listcol = < cident > ) ? <nl> | indexbracket = " [ " < term > " ] " " = " < term > ) <nl> ; <nl> + < conditions > : : = < condition > ( " AND " < condition > ) * <nl> + ; <nl> + < condition > : : = < cident > ( " [ " < term > " ] " ) ? ( ( " = " | " < " | " > " | " < = " | " > = " | " ! = " ) < term > <nl> + | " IN " " ( " < term > ( " , " < term > ) * " ) " ) <nl> + ; <nl> ' ' ' <nl> <nl> @ completer _ for ( ' updateStatement ' , ' updateopt ' ) <nl> @ @ - 819 , 6 + 827 , 7 @ @ syntax _ rules + = r ' ' ' <nl> " FROM " cf = < columnFamilyName > <nl> ( " USING " [ delopt ] = < deleteOption > ) ? <nl> " WHERE " < whereClause > <nl> + ( " IF " ( " EXISTS " | < conditions > ) ) ? <nl> ; <nl> < deleteSelector > : : = delcol = < cident > ( memberbracket = " [ " memberselector = < term > " ] " ) ? <nl> ; <nl> diff - - git a / pylib / cqlshlib / pylexotron . py b / pylib / cqlshlib / pylexotron . py <nl> index ad283df . . b4ac36f 100644 <nl> - - - a / pylib / cqlshlib / pylexotron . py <nl> + + + b / pylib / cqlshlib / pylexotron . py <nl> @ @ - 14 , 7 + 14 , 6 @ @ <nl> # See the License for the specific language governing permissions and <nl> # limitations under the License . <nl> <nl> - from functools import partial <nl> import re <nl> from . saferscanner import SaferScanner <nl> <nl> @ @ - 24 , 6 + 23 , 9 @ @ class LexingError ( Exception ) : <nl> bad _ char = len ( rulestr ) - len ( unmatched ) <nl> linenum = rulestr [ : bad _ char ] . count ( ' \ n ' ) + 1 <nl> charnum = len ( rulestr [ : bad _ char ] . rsplit ( ' \ n ' , 1 ) [ - 1 ] ) + 1 <nl> + snippet _ start = max ( 0 , min ( len ( rulestr ) , bad _ char - 10 ) ) <nl> + snippet _ end = max ( 0 , min ( len ( rulestr ) , bad _ char + 10 ) ) <nl> + msg + = " ( Error at : ' . . . % s . . . ' ) " % ( rulestr [ snippet _ start : snippet _ end ] , ) <nl> raise cls ( linenum , charnum , msg ) <nl> <nl> def _ _ init _ _ ( self , linenum , charnum , msg = ' Lexing error ' ) :
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2320653 . . 11ec7ff 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 1 
 + * ( cqlsh ) Fix handling of CAS statement results ( CASSANDRA - 7671 ) 
 * ( cqlsh ) COPY TO / FROM improvements ( CASSANDRA - 7405 ) 
 * Support list index operations with conditions ( CASSANDRA - 7499 ) 
 * Add max live / tombstoned cells to nodetool cfstats output ( CASSANDRA - 7731 ) 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 340566d . . b633e93 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 585 , 13 + 585 , 13 @ @ class Shell ( cmd . Cmd ) : 
 self . decoding _ errors . append ( err ) 
 return format _ value ( err , self . output _ codec . name , addcolor = self . color ) 
 
 - def myformat _ colname ( self , name , cfMetaData = None ) : 
 + def myformat _ colname ( self , name , table _ meta = None ) : 
 column _ colors = COLUMN _ NAME _ COLORS . copy ( ) 
 # check column role and color appropriately 
 - if cfMetaData : 
 - if name in [ col . name for col in cfMetaData . partition _ key ] : 
 + if table _ meta : 
 + if name in [ col . name for col in table _ meta . partition _ key ] : 
 column _ colors . default _ factory = lambda : RED 
 - elif name in [ col . name for col in cfMetaData . clustering _ key ] : 
 + elif name in [ col . name for col in table _ meta . clustering _ key ] : 
 column _ colors . default _ factory = lambda : CYAN 
 return self . myformat _ value ( name , colormap = column _ colors ) 
 
 @ @ - 913 , 6 + 913 , 12 @ @ class Shell ( cmd . Cmd ) : 
 
 return result 
 
 + def parse _ for _ table _ meta ( self , query _ string ) : 
 + parsed = cqlruleset . cql _ parse ( query _ string ) [ 1 ] 
 + ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) 
 + return self . get _ table _ meta ( ks , cf ) 
 + 
 def perform _ simple _ statement ( self , statement , with _ default _ limit = False ) : 
 if not statement : 
 return False 
 @ @ - 930 , 25 + 936 , 21 @ @ class Shell ( cmd . Cmd ) : 
 return False 
 
 if statement . query _ string [ : 6 ] . lower ( ) = = ' select ' or statement . query _ string . lower ( ) . startswith ( " list " ) : 
 - parsed = cqlruleset . cql _ parse ( statement . query _ string ) [ 1 ] 
 - ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 - cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) 
 - cfMetaData = self . get _ table _ meta ( ks , cf ) 
 - self . print _ result ( rows , with _ default _ limit , cfMetaData ) 
 + self . print _ result ( rows , with _ default _ limit , self . parse _ for _ table _ meta ( statement . query _ string ) ) 
 elif rows : 
 # CAS INSERT / UPDATE 
 self . writeresult ( " " ) 
 - self . print _ static _ result ( rows ) 
 + self . print _ static _ result ( rows , self . parse _ for _ table _ meta ( statement . query _ string ) ) 
 self . flush _ output ( ) 
 return True 
 
 - def print _ result ( self , rows , with _ default _ limit , cfMetaData ) : 
 + def print _ result ( self , rows , with _ default _ limit , table _ meta ) : 
 self . decoding _ errors = [ ] 
 
 self . writeresult ( " " ) 
 if rows : 
 rows = list ( rows ) # this may be an iterator if the result is large enough to page 
 - self . print _ static _ result ( rows , cfMetaData ) 
 + self . print _ static _ result ( rows , table _ meta ) 
 self . writeresult ( " ( % d rows ) " % len ( rows or [ ] ) ) 
 
 if self . decoding _ errors : 
 @ @ - 965 , 16 + 967 , 16 @ @ class Shell ( cmd . Cmd ) : 
 % DEFAULT _ SELECT _ LIMIT , color = RED ) 
 self . writeresult ( " " ) 
 
 - def print _ static _ result ( self , rows , cfMetaData ) : 
 + def print _ static _ result ( self , rows , table _ meta ) : 
 if not rows : 
 # print header only 
 - colnames = cfMetaData . columns . keys ( ) # full header 
 - formatted _ names = [ self . myformat _ colname ( name , cfMetaData ) for name in colnames ] 
 + colnames = table _ meta . columns . keys ( ) # full header 
 + formatted _ names = [ self . myformat _ colname ( name , table _ meta ) for name in colnames ] 
 self . print _ formatted _ result ( formatted _ names , None ) 
 return 
 
 colnames = rows [ 0 ] . keys ( ) 
 - formatted _ names = [ self . myformat _ colname ( name , cfMetaData ) for name in colnames ] 
 + formatted _ names = [ self . myformat _ colname ( name , table _ meta ) for name in colnames ] 
 formatted _ values = [ map ( self . myformat _ value , row . values ( ) ) for row in rows ] 
 
 if self . expand _ enabled : 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 0888d64 . . e4ef67b 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 185 , 6 + 185 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 | < blobLiteral > 
 | < collectionLiteral > 
 | < functionName > < functionArguments > 
 + | " NULL " 
 ; 
 
 < functionArguments > : : = " ( " ( < term > ( " , " < term > ) * ) ? " ) " 
 @ @ - 673 , 6 + 674 , 7 @ @ syntax _ rules + = r ' ' ' 
 ( " , " [ colname ] = < cident > ) * " ) " 
 " VALUES " " ( " [ newval ] = < term > valcomma = " , " [ newval ] = < term > 
 ( valcomma = " , " [ newval ] = < term > ) * valcomma = " ) " 
 + ( " IF " " NOT " " EXISTS " ) ? 
 ( " USING " [ insertopt ] = < usingOption > 
 ( " AND " [ insertopt ] = < usingOption > ) * ) ? 
 ; 
 @ @ - 741 , 13 + 743 , 19 @ @ syntax _ rules + = r ' ' ' 
 ( " AND " [ updateopt ] = < usingOption > ) * ) ? 
 " SET " < assignment > ( " , " < assignment > ) * 
 " WHERE " < whereClause > 
 + ( " IF " < conditions > ) ? 
 ; 
 < assignment > : : = updatecol = < cident > 
 - ( " = " update _ rhs = ( < value > | < cident > ) 
 + ( " = " update _ rhs = ( < term > | < cident > ) 
 ( counterop = ( " + " | " - " ) inc = < wholenumber > 
 - | listadder = " + " listcol = < cident > ) 
 + | listadder = " + " listcol = < cident > ) ? 
 | indexbracket = " [ " < term > " ] " " = " < term > ) 
 ; 
 + < conditions > : : = < condition > ( " AND " < condition > ) * 
 + ; 
 + < condition > : : = < cident > ( " [ " < term > " ] " ) ? ( ( " = " | " < " | " > " | " < = " | " > = " | " ! = " ) < term > 
 + | " IN " " ( " < term > ( " , " < term > ) * " ) " ) 
 + ; 
 ' ' ' 
 
 @ completer _ for ( ' updateStatement ' , ' updateopt ' ) 
 @ @ - 819 , 6 + 827 , 7 @ @ syntax _ rules + = r ' ' ' 
 " FROM " cf = < columnFamilyName > 
 ( " USING " [ delopt ] = < deleteOption > ) ? 
 " WHERE " < whereClause > 
 + ( " IF " ( " EXISTS " | < conditions > ) ) ? 
 ; 
 < deleteSelector > : : = delcol = < cident > ( memberbracket = " [ " memberselector = < term > " ] " ) ? 
 ; 
 diff - - git a / pylib / cqlshlib / pylexotron . py b / pylib / cqlshlib / pylexotron . py 
 index ad283df . . b4ac36f 100644 
 - - - a / pylib / cqlshlib / pylexotron . py 
 + + + b / pylib / cqlshlib / pylexotron . py 
 @ @ - 14 , 7 + 14 , 6 @ @ 
 # See the License for the specific language governing permissions and 
 # limitations under the License . 
 
 - from functools import partial 
 import re 
 from . saferscanner import SaferScanner 
 
 @ @ - 24 , 6 + 23 , 9 @ @ class LexingError ( Exception ) : 
 bad _ char = len ( rulestr ) - len ( unmatched ) 
 linenum = rulestr [ : bad _ char ] . count ( ' \ n ' ) + 1 
 charnum = len ( rulestr [ : bad _ char ] . rsplit ( ' \ n ' , 1 ) [ - 1 ] ) + 1 
 + snippet _ start = max ( 0 , min ( len ( rulestr ) , bad _ char - 10 ) ) 
 + snippet _ end = max ( 0 , min ( len ( rulestr ) , bad _ char + 10 ) ) 
 + msg + = " ( Error at : ' . . . % s . . . ' ) " % ( rulestr [ snippet _ start : snippet _ end ] , ) 
 raise cls ( linenum , charnum , msg ) 
 
 def _ _ init _ _ ( self , linenum , charnum , msg = ' Lexing error ' ) :

NEAREST DIFF:
ELIMINATEDSENTENCE
