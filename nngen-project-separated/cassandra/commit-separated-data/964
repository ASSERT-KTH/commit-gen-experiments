BLEU SCORE: 0.06870976634467837

TEST MSG: Have keyspace stats in nodetool tablestats always include all tables
GENERATED MSG: Add ability to list specific KS / CF combinations in nodetool cfstats

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index bec51ab . . 15cceaa 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 6 <nl> + * Fix nodetool tablestats keyspace level metrics ( CASSANDRA - 11226 ) <nl> * Store repair options in parent _ repair _ history ( CASSANDRA - 11244 ) <nl> * Print current leveling in sstableofflinerelevel ( CASSANDRA - 9588 ) <nl> * Change repair message for keyspaces with RF 1 ( CASSANDRA - 11203 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableStats . java b / src / java / org / apache / cassandra / tools / nodetool / TableStats . java <nl> index 681af5b . . f082466 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / nodetool / TableStats . java <nl> + + + b / src / java / org / apache / cassandra / tools / nodetool / TableStats . java <nl> @ @ - 21 , 14 + 21 , 11 @ @ import io . airlift . command . Arguments ; <nl> import io . airlift . command . Command ; <nl> import io . airlift . command . Option ; <nl> <nl> - import java . util . ArrayList ; <nl> - import java . util . HashMap ; <nl> - import java . util . Iterator ; <nl> - import java . util . List ; <nl> - import java . util . Map ; <nl> - <nl> + import java . util . * ; <nl> import javax . management . InstanceNotFoundException ; <nl> <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + <nl> import org . apache . cassandra . db . ColumnFamilyStoreMBean ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . metrics . CassandraMetricsRegistry ; <nl> @ @ - 53 , 80 + 50 , 56 @ @ public class TableStats extends NodeToolCmd <nl> public void execute ( NodeProbe probe ) <nl> { <nl> TableStats . OptionFilter filter = new OptionFilter ( ignore , tableNames ) ; <nl> - Map < String , List < ColumnFamilyStoreMBean > > tableStoreMap = new HashMap < > ( ) ; <nl> + ArrayListMultimap < String , ColumnFamilyStoreMBean > selectedTableMbeans = ArrayListMultimap . create ( ) ; <nl> + Map < String , KeyspaceStats > keyspaceStats = new HashMap < > ( ) ; <nl> <nl> / / get a list of column family stores <nl> - Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tables = probe . getColumnFamilyStoreMBeanProxies ( ) ; <nl> + Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tableMBeans = probe . getColumnFamilyStoreMBeanProxies ( ) ; <nl> <nl> - while ( tables . hasNext ( ) ) <nl> + while ( tableMBeans . hasNext ( ) ) <nl> { <nl> - Map . Entry < String , ColumnFamilyStoreMBean > entry = tables . next ( ) ; <nl> + Map . Entry < String , ColumnFamilyStoreMBean > entry = tableMBeans . next ( ) ; <nl> String keyspaceName = entry . getKey ( ) ; <nl> ColumnFamilyStoreMBean tableProxy = entry . getValue ( ) ; <nl> <nl> - if ( ! tableStoreMap . containsKey ( keyspaceName ) & & filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) <nl> - { <nl> - List < ColumnFamilyStoreMBean > columnFamilies = new ArrayList < > ( ) ; <nl> - columnFamilies . add ( tableProxy ) ; <nl> - tableStoreMap . put ( keyspaceName , columnFamilies ) ; <nl> - } else if ( filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) <nl> + if ( filter . isKeyspaceIncluded ( keyspaceName ) ) <nl> { <nl> - tableStoreMap . get ( keyspaceName ) . add ( tableProxy ) ; <nl> + KeyspaceStats stats = keyspaceStats . get ( keyspaceName ) ; <nl> + if ( stats = = null ) <nl> + { <nl> + stats = new KeyspaceStats ( probe , keyspaceName ) ; <nl> + keyspaceStats . put ( keyspaceName , stats ) ; <nl> + } <nl> + stats . add ( tableProxy ) ; <nl> + <nl> + if ( filter . isTableIncluded ( keyspaceName , tableProxy . getTableName ( ) ) ) <nl> + selectedTableMbeans . put ( keyspaceName , tableProxy ) ; <nl> } <nl> } <nl> <nl> / / make sure all specified keyspace and tables exist <nl> filter . verifyKeyspaces ( probe . getKeyspaces ( ) ) ; <nl> - filter . verifyColumnFamilies ( ) ; <nl> + filter . verifyTables ( ) ; <nl> <nl> / / print out the table statistics <nl> - for ( Map . Entry < String , List < ColumnFamilyStoreMBean > > entry : tableStoreMap . entrySet ( ) ) <nl> + for ( Map . Entry < String , Collection < ColumnFamilyStoreMBean > > entry : selectedTableMbeans . asMap ( ) . entrySet ( ) ) <nl> { <nl> String keyspaceName = entry . getKey ( ) ; <nl> - List < ColumnFamilyStoreMBean > columnFamilies = entry . getValue ( ) ; <nl> - long keyspaceReadCount = 0 ; <nl> - long keyspaceWriteCount = 0 ; <nl> - int keyspacePendingFlushes = 0 ; <nl> - double keyspaceTotalReadTime = 0 . 0f ; <nl> - double keyspaceTotalWriteTime = 0 . 0f ; <nl> + Collection < ColumnFamilyStoreMBean > tables = entry . getValue ( ) ; <nl> <nl> System . out . println ( " Keyspace : " + keyspaceName ) ; <nl> - for ( ColumnFamilyStoreMBean table : columnFamilies ) <nl> - { <nl> - String tableName = table . getColumnFamilyName ( ) ; <nl> - long writeCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteLatency " ) ) . getCount ( ) ; <nl> - long readCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadLatency " ) ) . getCount ( ) ; <nl> - <nl> - if ( readCount > 0 ) <nl> - { <nl> - keyspaceReadCount + = readCount ; <nl> - keyspaceTotalReadTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadTotalLatency " ) ; <nl> - } <nl> - if ( writeCount > 0 ) <nl> - { <nl> - keyspaceWriteCount + = writeCount ; <nl> - keyspaceTotalWriteTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteTotalLatency " ) ; <nl> - } <nl> - keyspacePendingFlushes + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " PendingFlushes " ) ; <nl> - } <nl> - <nl> - double keyspaceReadLatency = keyspaceReadCount > 0 <nl> - ? keyspaceTotalReadTime / keyspaceReadCount / 1000 <nl> - : Double . NaN ; <nl> - double keyspaceWriteLatency = keyspaceWriteCount > 0 <nl> - ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000 <nl> - : Double . NaN ; <nl> + KeyspaceStats stats = keyspaceStats . get ( keyspaceName ) ; <nl> <nl> - System . out . println ( " \ tRead Count : " + keyspaceReadCount ) ; <nl> - System . out . println ( " \ tRead Latency : " + String . format ( " % s " , keyspaceReadLatency ) + " ms . " ) ; <nl> - System . out . println ( " \ tWrite Count : " + keyspaceWriteCount ) ; <nl> - System . out . println ( " \ tWrite Latency : " + String . format ( " % s " , keyspaceWriteLatency ) + " ms . " ) ; <nl> - System . out . println ( " \ tPending Flushes : " + keyspacePendingFlushes ) ; <nl> + System . out . println ( " \ tRead Count : " + stats . readCount ) ; <nl> + System . out . println ( " \ tRead Latency : " + String . format ( " % s " , stats . readLatency ( ) ) + " ms . " ) ; <nl> + System . out . println ( " \ tWrite Count : " + stats . writeCount ) ; <nl> + System . out . println ( " \ tWrite Latency : " + String . format ( " % s " , stats . writeLatency ( ) ) + " ms . " ) ; <nl> + System . out . println ( " \ tPending Flushes : " + stats . pendingFlushes ) ; <nl> <nl> / / print out column family statistics for this keyspace <nl> - for ( ColumnFamilyStoreMBean table : columnFamilies ) <nl> + for ( ColumnFamilyStoreMBean table : tables ) <nl> { <nl> - String tableName = table . getColumnFamilyName ( ) ; <nl> + String tableName = table . getTableName ( ) ; <nl> if ( tableName . contains ( " . " ) ) <nl> System . out . println ( " \ t \ tTable ( index ) : " + tableName ) ; <nl> else <nl> @ @ - 227 , 7 + 200 , 8 @ @ public class TableStats extends NodeToolCmd <nl> } <nl> } <nl> <nl> - private String format ( long bytes , boolean humanReadable ) { <nl> + private String format ( long bytes , boolean humanReadable ) <nl> + { <nl> return humanReadable ? FileUtils . stringifyFileSize ( bytes ) : Long . toString ( bytes ) ; <nl> } <nl> <nl> @ @ - 237 , 7 + 211 , 8 @ @ public class TableStats extends NodeToolCmd <nl> private static class OptionFilter <nl> { <nl> private Map < String , List < String > > filter = new HashMap < > ( ) ; <nl> - private Map < String , List < String > > verifier = new HashMap < > ( ) ; <nl> + private Map < String , List < String > > verifier = new HashMap < > ( ) ; / / Same as filter initially , but we remove tables every time we ' ve checked them for inclusion <nl> + / / in isTableIncluded ( ) so that we detect if those table requested don ' t exist ( verifyTables ( ) ) <nl> private List < String > filterList = new ArrayList < > ( ) ; <nl> private boolean ignoreMode ; <nl> <nl> @ @ - 255 , 24 + 230 , 17 @ @ public class TableStats extends NodeToolCmd <nl> { <nl> filter . put ( keyValues [ 0 ] , new ArrayList < String > ( ) ) ; <nl> verifier . put ( keyValues [ 0 ] , new ArrayList < String > ( ) ) ; <nl> + } <nl> <nl> - if ( keyValues . length = = 2 ) <nl> - { <nl> - filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> - verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> - } <nl> - } else <nl> + if ( keyValues . length = = 2 ) <nl> { <nl> - if ( keyValues . length = = 2 ) <nl> - { <nl> - filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> - verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> - } <nl> + filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> + verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; <nl> } <nl> } <nl> } <nl> <nl> - public boolean isColumnFamilyIncluded ( String keyspace , String columnFamily ) <nl> + public boolean isTableIncluded ( String keyspace , String table ) <nl> { <nl> / / supplying empty params list is treated as wanting to display all keyspaces and tables <nl> if ( filterList . isEmpty ( ) ) <nl> @ @ - 289 , 8 + 257 , 20 @ @ public class TableStats extends NodeToolCmd <nl> return ! ignoreMode ; <nl> <nl> / / keyspace exists , and it contains specific table <nl> - verifier . get ( keyspace ) . remove ( columnFamily ) ; <nl> - return ignoreMode ^ tables . contains ( columnFamily ) ; <nl> + verifier . get ( keyspace ) . remove ( table ) ; <nl> + return ignoreMode ^ tables . contains ( table ) ; <nl> + } <nl> + <nl> + public boolean isKeyspaceIncluded ( String keyspace ) <nl> + { <nl> + / / supplying empty params list is treated as wanting to display all keyspaces and tables <nl> + if ( filterList . isEmpty ( ) ) <nl> + return ! ignoreMode ; <nl> + <nl> + / / Note that if there is any table for the keyspace , we want to include the keyspace irregarding <nl> + / / of the ignoreMode , since the ignoreMode then apply to the table inside the keyspace but the <nl> + / / keyspace itself is not ignored <nl> + return filter . get ( keyspace ) ! = null | | ignoreMode ; <nl> } <nl> <nl> public void verifyKeyspaces ( List < String > keyspaces ) <nl> @ @ - 300 , 11 + 280 , 62 @ @ public class TableStats extends NodeToolCmd <nl> throw new IllegalArgumentException ( " Unknown keyspace : " + ks ) ; <nl> } <nl> <nl> - public void verifyColumnFamilies ( ) <nl> + public void verifyTables ( ) <nl> { <nl> for ( String ks : filter . keySet ( ) ) <nl> if ( verifier . get ( ks ) . size ( ) > 0 ) <nl> throw new IllegalArgumentException ( " Unknown tables : " + verifier . get ( ks ) + " in keyspace : " + ks ) ; <nl> } <nl> } <nl> + <nl> + private static class KeyspaceStats <nl> + { <nl> + private final NodeProbe probe ; <nl> + private final String keyspaceName ; <nl> + <nl> + public long readCount ; <nl> + public long writeCount ; <nl> + public int pendingFlushes ; <nl> + private double totalReadTime ; <nl> + private double totalWriteTime ; <nl> + <nl> + public KeyspaceStats ( NodeProbe probe , String keyspaceName ) <nl> + { <nl> + this . probe = probe ; <nl> + this . keyspaceName = keyspaceName ; <nl> + } <nl> + <nl> + public void add ( ColumnFamilyStoreMBean table ) <nl> + { <nl> + String tableName = table . getTableName ( ) ; <nl> + long tableWriteCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteLatency " ) ) . getCount ( ) ; <nl> + long tableReadCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadLatency " ) ) . getCount ( ) ; <nl> + <nl> + if ( tableReadCount > 0 ) <nl> + { <nl> + readCount + = tableReadCount ; <nl> + totalReadTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadTotalLatency " ) ; <nl> + } <nl> + if ( tableWriteCount > 0 ) <nl> + { <nl> + writeCount + = tableWriteCount ; <nl> + totalWriteTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteTotalLatency " ) ; <nl> + } <nl> + pendingFlushes + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " PendingFlushes " ) ; <nl> + } <nl> + <nl> + public double readLatency ( ) <nl> + { <nl> + return readCount > 0 <nl> + ? totalReadTime / readCount / 1000 <nl> + : Double . NaN ; <nl> + } <nl> + <nl> + public double writeLatency ( ) <nl> + { <nl> + return writeCount > 0 <nl> + ? totalWriteTime / writeCount / 1000 <nl> + : Double . NaN ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2dbadc4 . . d6ecac1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 7 @ @ <nl> 1 . 2 . 12 <nl> * Add ability to list specific KS / CF combinations in nodetool cfstats ( CASSANDRA - 4191 ) <nl> + * Mark CF clean if a mutation raced the drop and got it marked dirty <nl> + <nl> <nl> 1 . 2 . 11 <nl> * Limit CQL prepared statement cache by size instead of count ( CASSANDRA - 6107 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> index 2855979 . . d62d7ca 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java <nl> @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . Table ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> <nl> / * * <nl> @ @ - 296 , 19 + 297 , 30 @ @ public class CommitLogAllocator <nl> { <nl> for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) <nl> { <nl> - String keypace = Schema . instance . getCF ( dirtyCFId ) . left ; <nl> - final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; <nl> - / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , <nl> - / / which may already be held by a thread waiting for the CL executor ( via getContext ) , <nl> - / / causing deadlock <nl> - Runnable runnable = new Runnable ( ) <nl> + Pair < String , String > pair = Schema . instance . getCF ( dirtyCFId ) ; <nl> + if ( pair = = null ) <nl> { <nl> - public void run ( ) <nl> + / / even though we remove the schema entry before a final flush when dropping a CF , <nl> + / / it ' s still possible for a writer to race and finish his append after the flush . <nl> + logger . debug ( " Marking clean CF { } that doesn ' t exist anymore " , dirtyCFId ) ; <nl> + oldestSegment . markClean ( dirtyCFId , oldestSegment . getContext ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + String keypace = pair . left ; <nl> + final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; <nl> + / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , <nl> + / / which may already be held by a thread waiting for the CL executor ( via getContext ) , <nl> + / / causing deadlock <nl> + Runnable runnable = new Runnable ( ) <nl> { <nl> - cfs . forceFlush ( ) ; <nl> - } <nl> - } ; <nl> - StorageService . optionalTasks . execute ( runnable ) ; <nl> + public void run ( ) <nl> + { <nl> + cfs . forceFlush ( ) ; <nl> + } <nl> + } ; <nl> + StorageService . optionalTasks . execute ( runnable ) ; <nl> + } <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index bec51ab . . 15cceaa 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 6 
 + * Fix nodetool tablestats keyspace level metrics ( CASSANDRA - 11226 ) 
 * Store repair options in parent _ repair _ history ( CASSANDRA - 11244 ) 
 * Print current leveling in sstableofflinerelevel ( CASSANDRA - 9588 ) 
 * Change repair message for keyspaces with RF 1 ( CASSANDRA - 11203 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableStats . java b / src / java / org / apache / cassandra / tools / nodetool / TableStats . java 
 index 681af5b . . f082466 100644 
 - - - a / src / java / org / apache / cassandra / tools / nodetool / TableStats . java 
 + + + b / src / java / org / apache / cassandra / tools / nodetool / TableStats . java 
 @ @ - 21 , 14 + 21 , 11 @ @ import io . airlift . command . Arguments ; 
 import io . airlift . command . Command ; 
 import io . airlift . command . Option ; 
 
 - import java . util . ArrayList ; 
 - import java . util . HashMap ; 
 - import java . util . Iterator ; 
 - import java . util . List ; 
 - import java . util . Map ; 
 - 
 + import java . util . * ; 
 import javax . management . InstanceNotFoundException ; 
 
 + import com . google . common . collect . ArrayListMultimap ; 
 + 
 import org . apache . cassandra . db . ColumnFamilyStoreMBean ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . metrics . CassandraMetricsRegistry ; 
 @ @ - 53 , 80 + 50 , 56 @ @ public class TableStats extends NodeToolCmd 
 public void execute ( NodeProbe probe ) 
 { 
 TableStats . OptionFilter filter = new OptionFilter ( ignore , tableNames ) ; 
 - Map < String , List < ColumnFamilyStoreMBean > > tableStoreMap = new HashMap < > ( ) ; 
 + ArrayListMultimap < String , ColumnFamilyStoreMBean > selectedTableMbeans = ArrayListMultimap . create ( ) ; 
 + Map < String , KeyspaceStats > keyspaceStats = new HashMap < > ( ) ; 
 
 / / get a list of column family stores 
 - Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tables = probe . getColumnFamilyStoreMBeanProxies ( ) ; 
 + Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tableMBeans = probe . getColumnFamilyStoreMBeanProxies ( ) ; 
 
 - while ( tables . hasNext ( ) ) 
 + while ( tableMBeans . hasNext ( ) ) 
 { 
 - Map . Entry < String , ColumnFamilyStoreMBean > entry = tables . next ( ) ; 
 + Map . Entry < String , ColumnFamilyStoreMBean > entry = tableMBeans . next ( ) ; 
 String keyspaceName = entry . getKey ( ) ; 
 ColumnFamilyStoreMBean tableProxy = entry . getValue ( ) ; 
 
 - if ( ! tableStoreMap . containsKey ( keyspaceName ) & & filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) 
 - { 
 - List < ColumnFamilyStoreMBean > columnFamilies = new ArrayList < > ( ) ; 
 - columnFamilies . add ( tableProxy ) ; 
 - tableStoreMap . put ( keyspaceName , columnFamilies ) ; 
 - } else if ( filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) 
 + if ( filter . isKeyspaceIncluded ( keyspaceName ) ) 
 { 
 - tableStoreMap . get ( keyspaceName ) . add ( tableProxy ) ; 
 + KeyspaceStats stats = keyspaceStats . get ( keyspaceName ) ; 
 + if ( stats = = null ) 
 + { 
 + stats = new KeyspaceStats ( probe , keyspaceName ) ; 
 + keyspaceStats . put ( keyspaceName , stats ) ; 
 + } 
 + stats . add ( tableProxy ) ; 
 + 
 + if ( filter . isTableIncluded ( keyspaceName , tableProxy . getTableName ( ) ) ) 
 + selectedTableMbeans . put ( keyspaceName , tableProxy ) ; 
 } 
 } 
 
 / / make sure all specified keyspace and tables exist 
 filter . verifyKeyspaces ( probe . getKeyspaces ( ) ) ; 
 - filter . verifyColumnFamilies ( ) ; 
 + filter . verifyTables ( ) ; 
 
 / / print out the table statistics 
 - for ( Map . Entry < String , List < ColumnFamilyStoreMBean > > entry : tableStoreMap . entrySet ( ) ) 
 + for ( Map . Entry < String , Collection < ColumnFamilyStoreMBean > > entry : selectedTableMbeans . asMap ( ) . entrySet ( ) ) 
 { 
 String keyspaceName = entry . getKey ( ) ; 
 - List < ColumnFamilyStoreMBean > columnFamilies = entry . getValue ( ) ; 
 - long keyspaceReadCount = 0 ; 
 - long keyspaceWriteCount = 0 ; 
 - int keyspacePendingFlushes = 0 ; 
 - double keyspaceTotalReadTime = 0 . 0f ; 
 - double keyspaceTotalWriteTime = 0 . 0f ; 
 + Collection < ColumnFamilyStoreMBean > tables = entry . getValue ( ) ; 
 
 System . out . println ( " Keyspace : " + keyspaceName ) ; 
 - for ( ColumnFamilyStoreMBean table : columnFamilies ) 
 - { 
 - String tableName = table . getColumnFamilyName ( ) ; 
 - long writeCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteLatency " ) ) . getCount ( ) ; 
 - long readCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadLatency " ) ) . getCount ( ) ; 
 - 
 - if ( readCount > 0 ) 
 - { 
 - keyspaceReadCount + = readCount ; 
 - keyspaceTotalReadTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadTotalLatency " ) ; 
 - } 
 - if ( writeCount > 0 ) 
 - { 
 - keyspaceWriteCount + = writeCount ; 
 - keyspaceTotalWriteTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteTotalLatency " ) ; 
 - } 
 - keyspacePendingFlushes + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " PendingFlushes " ) ; 
 - } 
 - 
 - double keyspaceReadLatency = keyspaceReadCount > 0 
 - ? keyspaceTotalReadTime / keyspaceReadCount / 1000 
 - : Double . NaN ; 
 - double keyspaceWriteLatency = keyspaceWriteCount > 0 
 - ? keyspaceTotalWriteTime / keyspaceWriteCount / 1000 
 - : Double . NaN ; 
 + KeyspaceStats stats = keyspaceStats . get ( keyspaceName ) ; 
 
 - System . out . println ( " \ tRead Count : " + keyspaceReadCount ) ; 
 - System . out . println ( " \ tRead Latency : " + String . format ( " % s " , keyspaceReadLatency ) + " ms . " ) ; 
 - System . out . println ( " \ tWrite Count : " + keyspaceWriteCount ) ; 
 - System . out . println ( " \ tWrite Latency : " + String . format ( " % s " , keyspaceWriteLatency ) + " ms . " ) ; 
 - System . out . println ( " \ tPending Flushes : " + keyspacePendingFlushes ) ; 
 + System . out . println ( " \ tRead Count : " + stats . readCount ) ; 
 + System . out . println ( " \ tRead Latency : " + String . format ( " % s " , stats . readLatency ( ) ) + " ms . " ) ; 
 + System . out . println ( " \ tWrite Count : " + stats . writeCount ) ; 
 + System . out . println ( " \ tWrite Latency : " + String . format ( " % s " , stats . writeLatency ( ) ) + " ms . " ) ; 
 + System . out . println ( " \ tPending Flushes : " + stats . pendingFlushes ) ; 
 
 / / print out column family statistics for this keyspace 
 - for ( ColumnFamilyStoreMBean table : columnFamilies ) 
 + for ( ColumnFamilyStoreMBean table : tables ) 
 { 
 - String tableName = table . getColumnFamilyName ( ) ; 
 + String tableName = table . getTableName ( ) ; 
 if ( tableName . contains ( " . " ) ) 
 System . out . println ( " \ t \ tTable ( index ) : " + tableName ) ; 
 else 
 @ @ - 227 , 7 + 200 , 8 @ @ public class TableStats extends NodeToolCmd 
 } 
 } 
 
 - private String format ( long bytes , boolean humanReadable ) { 
 + private String format ( long bytes , boolean humanReadable ) 
 + { 
 return humanReadable ? FileUtils . stringifyFileSize ( bytes ) : Long . toString ( bytes ) ; 
 } 
 
 @ @ - 237 , 7 + 211 , 8 @ @ public class TableStats extends NodeToolCmd 
 private static class OptionFilter 
 { 
 private Map < String , List < String > > filter = new HashMap < > ( ) ; 
 - private Map < String , List < String > > verifier = new HashMap < > ( ) ; 
 + private Map < String , List < String > > verifier = new HashMap < > ( ) ; / / Same as filter initially , but we remove tables every time we ' ve checked them for inclusion 
 + / / in isTableIncluded ( ) so that we detect if those table requested don ' t exist ( verifyTables ( ) ) 
 private List < String > filterList = new ArrayList < > ( ) ; 
 private boolean ignoreMode ; 
 
 @ @ - 255 , 24 + 230 , 17 @ @ public class TableStats extends NodeToolCmd 
 { 
 filter . put ( keyValues [ 0 ] , new ArrayList < String > ( ) ) ; 
 verifier . put ( keyValues [ 0 ] , new ArrayList < String > ( ) ) ; 
 + } 
 
 - if ( keyValues . length = = 2 ) 
 - { 
 - filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 - verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 - } 
 - } else 
 + if ( keyValues . length = = 2 ) 
 { 
 - if ( keyValues . length = = 2 ) 
 - { 
 - filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 - verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 - } 
 + filter . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 + verifier . get ( keyValues [ 0 ] ) . add ( keyValues [ 1 ] ) ; 
 } 
 } 
 } 
 
 - public boolean isColumnFamilyIncluded ( String keyspace , String columnFamily ) 
 + public boolean isTableIncluded ( String keyspace , String table ) 
 { 
 / / supplying empty params list is treated as wanting to display all keyspaces and tables 
 if ( filterList . isEmpty ( ) ) 
 @ @ - 289 , 8 + 257 , 20 @ @ public class TableStats extends NodeToolCmd 
 return ! ignoreMode ; 
 
 / / keyspace exists , and it contains specific table 
 - verifier . get ( keyspace ) . remove ( columnFamily ) ; 
 - return ignoreMode ^ tables . contains ( columnFamily ) ; 
 + verifier . get ( keyspace ) . remove ( table ) ; 
 + return ignoreMode ^ tables . contains ( table ) ; 
 + } 
 + 
 + public boolean isKeyspaceIncluded ( String keyspace ) 
 + { 
 + / / supplying empty params list is treated as wanting to display all keyspaces and tables 
 + if ( filterList . isEmpty ( ) ) 
 + return ! ignoreMode ; 
 + 
 + / / Note that if there is any table for the keyspace , we want to include the keyspace irregarding 
 + / / of the ignoreMode , since the ignoreMode then apply to the table inside the keyspace but the 
 + / / keyspace itself is not ignored 
 + return filter . get ( keyspace ) ! = null | | ignoreMode ; 
 } 
 
 public void verifyKeyspaces ( List < String > keyspaces ) 
 @ @ - 300 , 11 + 280 , 62 @ @ public class TableStats extends NodeToolCmd 
 throw new IllegalArgumentException ( " Unknown keyspace : " + ks ) ; 
 } 
 
 - public void verifyColumnFamilies ( ) 
 + public void verifyTables ( ) 
 { 
 for ( String ks : filter . keySet ( ) ) 
 if ( verifier . get ( ks ) . size ( ) > 0 ) 
 throw new IllegalArgumentException ( " Unknown tables : " + verifier . get ( ks ) + " in keyspace : " + ks ) ; 
 } 
 } 
 + 
 + private static class KeyspaceStats 
 + { 
 + private final NodeProbe probe ; 
 + private final String keyspaceName ; 
 + 
 + public long readCount ; 
 + public long writeCount ; 
 + public int pendingFlushes ; 
 + private double totalReadTime ; 
 + private double totalWriteTime ; 
 + 
 + public KeyspaceStats ( NodeProbe probe , String keyspaceName ) 
 + { 
 + this . probe = probe ; 
 + this . keyspaceName = keyspaceName ; 
 + } 
 + 
 + public void add ( ColumnFamilyStoreMBean table ) 
 + { 
 + String tableName = table . getTableName ( ) ; 
 + long tableWriteCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteLatency " ) ) . getCount ( ) ; 
 + long tableReadCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadLatency " ) ) . getCount ( ) ; 
 + 
 + if ( tableReadCount > 0 ) 
 + { 
 + readCount + = tableReadCount ; 
 + totalReadTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " ReadTotalLatency " ) ; 
 + } 
 + if ( tableWriteCount > 0 ) 
 + { 
 + writeCount + = tableWriteCount ; 
 + totalWriteTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " WriteTotalLatency " ) ; 
 + } 
 + pendingFlushes + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , " PendingFlushes " ) ; 
 + } 
 + 
 + public double readLatency ( ) 
 + { 
 + return readCount > 0 
 + ? totalReadTime / readCount / 1000 
 + : Double . NaN ; 
 + } 
 + 
 + public double writeLatency ( ) 
 + { 
 + return writeCount > 0 
 + ? totalWriteTime / writeCount / 1000 
 + : Double . NaN ; 
 + } 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2dbadc4 . . d6ecac1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 7 @ @ 
 1 . 2 . 12 
 * Add ability to list specific KS / CF combinations in nodetool cfstats ( CASSANDRA - 4191 ) 
 + * Mark CF clean if a mutation raced the drop and got it marked dirty 
 + 
 
 1 . 2 . 11 
 * Limit CQL prepared statement cache by size instead of count ( CASSANDRA - 6107 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 index 2855979 . . d62d7ca 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogAllocator . java 
 @ @ - 39 , 6 + 39 , 7 @ @ import org . apache . cassandra . db . Table ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . utils . Pair ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 
 / * * 
 @ @ - 296 , 19 + 297 , 30 @ @ public class CommitLogAllocator 
 { 
 for ( UUID dirtyCFId : oldestSegment . getDirtyCFIDs ( ) ) 
 { 
 - String keypace = Schema . instance . getCF ( dirtyCFId ) . left ; 
 - final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; 
 - / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , 
 - / / which may already be held by a thread waiting for the CL executor ( via getContext ) , 
 - / / causing deadlock 
 - Runnable runnable = new Runnable ( ) 
 + Pair < String , String > pair = Schema . instance . getCF ( dirtyCFId ) ; 
 + if ( pair = = null ) 
 { 
 - public void run ( ) 
 + / / even though we remove the schema entry before a final flush when dropping a CF , 
 + / / it ' s still possible for a writer to race and finish his append after the flush . 
 + logger . debug ( " Marking clean CF { } that doesn ' t exist anymore " , dirtyCFId ) ; 
 + oldestSegment . markClean ( dirtyCFId , oldestSegment . getContext ( ) ) ; 
 + } 
 + else 
 + { 
 + String keypace = pair . left ; 
 + final ColumnFamilyStore cfs = Table . open ( keypace ) . getColumnFamilyStore ( dirtyCFId ) ; 
 + / / flush shouldn ' t run on the commitlog executor , since it acquires Table . switchLock , 
 + / / which may already be held by a thread waiting for the CL executor ( via getContext ) , 
 + / / causing deadlock 
 + Runnable runnable = new Runnable ( ) 
 { 
 - cfs . forceFlush ( ) ; 
 - } 
 - } ; 
 - StorageService . optionalTasks . execute ( runnable ) ; 
 + public void run ( ) 
 + { 
 + cfs . forceFlush ( ) ; 
 + } 
 + } ; 
 + StorageService . optionalTasks . execute ( runnable ) ; 
 + } 
 } 
 } 
 }
