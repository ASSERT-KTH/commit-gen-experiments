BLEU SCORE: 0.009055400496876965

TEST MSG: Prevent compaction strategies from looping indefinitely
GENERATED MSG: Track tombstone for LCS ; patch by yukim reviewed by jbellis for CASSANDRA - 4234

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fc18dc3 . . ce279f2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 11 . 2 <nl> + * Prevent compaction strategies from looping indefinitely ( CASSANDRA - 14079 ) <nl> * Cache disk boundaries ( CASSANDRA - 13215 ) <nl> * Add asm jar to build . xml for maven builds ( CASSANDRA - 11193 ) <nl> * Round buffer size to powers of 2 for the chunk cache ( CASSANDRA - 13897 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> index 729ddc0 . . bb9f4b9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java <nl> @ @ - 73 , 6 + 73 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> @ SuppressWarnings ( " resource " ) <nl> public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> + List < SSTableReader > previousCandidate = null ; <nl> while ( true ) <nl> { <nl> List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; <nl> @ @ - 80 , 9 + 81 , 20 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> if ( latestBucket . isEmpty ( ) ) <nl> return null ; <nl> <nl> + / / Already tried acquiring references without success . It means there is a race with <nl> + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager <nl> + if ( latestBucket . equals ( previousCandidate ) ) <nl> + { <nl> + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + <nl> + " unless it happens frequently , in which case it must be reported . Will retry later . " , <nl> + latestBucket ) ; <nl> + return null ; <nl> + } <nl> + <nl> LifecycleTransaction modifier = cfs . getTracker ( ) . tryModify ( latestBucket , OperationType . COMPACTION ) ; <nl> if ( modifier ! = null ) <nl> return new CompactionTask ( cfs , modifier , gcBefore ) ; <nl> + previousCandidate = latestBucket ; <nl> } <nl> } <nl> <nl> @ @ - 170 , 6 + 182 , 8 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> / / no need to convert to collection if had an Iterables . max ( ) , but not present in standard toolkit , and not worth adding <nl> List < SSTableReader > list = new ArrayList < > ( ) ; <nl> Iterables . addAll ( list , cfs . getSSTables ( SSTableSet . LIVE ) ) ; <nl> + if ( list . isEmpty ( ) ) <nl> + return 0 ; <nl> return Collections . max ( list , ( o1 , o2 ) - > Long . compare ( o1 . getMaxTimestamp ( ) , o2 . getMaxTimestamp ( ) ) ) <nl> . getMaxTimestamp ( ) ; <nl> } <nl> @ @ - 462 , 7 + 476 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy <nl> return uncheckedOptions ; <nl> } <nl> <nl> - public CompactionLogger . Strategy strategyLogger ( ) <nl> + public CompactionLogger . Strategy strategyLogger ( ) <nl> { <nl> return new CompactionLogger . Strategy ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> index f943b19 . . 43c81a4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java <nl> @ @ - 62 , 12 + 62 , 12 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> int configuredLevelFanoutSize = DEFAULT _ LEVEL _ FANOUT _ SIZE ; <nl> SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions ( options ) ; <nl> if ( options ! = null ) <nl> - { <nl> - if ( options . containsKey ( SSTABLE _ SIZE _ OPTION ) ) <nl> - { <nl> - configuredMaxSSTableSize = Integer . parseInt ( options . get ( SSTABLE _ SIZE _ OPTION ) ) ; <nl> + { <nl> + if ( options . containsKey ( SSTABLE _ SIZE _ OPTION ) ) <nl> + { <nl> + configuredMaxSSTableSize = Integer . parseInt ( options . get ( SSTABLE _ SIZE _ OPTION ) ) ; <nl> if ( ! tolerateSstableSize ) <nl> - { <nl> + { <nl> if ( configuredMaxSSTableSize > = 1000 ) <nl> logger . warn ( " Max sstable size of { } MB is configured for { } . { } ; having a unit of compaction this large is probably a bad idea " , <nl> configuredMaxSSTableSize , cfs . name , cfs . getColumnFamilyName ( ) ) ; <nl> @ @ - 113 , 6 + 113 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> @ SuppressWarnings ( " resource " ) / / transaction is closed by AbstractCompactionTask : : execute <nl> public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> + Collection < SSTableReader > previousCandidate = null ; <nl> while ( true ) <nl> { <nl> OperationType op ; <nl> @ @ - 136 , 6 + 137 , 16 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> op = OperationType . COMPACTION ; <nl> } <nl> <nl> + / / Already tried acquiring references without success . It means there is a race with <nl> + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager <nl> + if ( candidate . sstables . equals ( previousCandidate ) ) <nl> + { <nl> + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + <nl> + " unless it happens frequently , in which case it must be reported . Will retry later . " , <nl> + candidate . sstables ) ; <nl> + return null ; <nl> + } <nl> + <nl> LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( candidate . sstables , OperationType . COMPACTION ) ; <nl> if ( txn ! = null ) <nl> { <nl> @ @ - 143 , 6 + 154 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy <nl> newTask . setCompactionType ( op ) ; <nl> return newTask ; <nl> } <nl> + previousCandidate = candidate . sstables ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index 3d118de . . ceb3811 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 169 , 8 + 169 , 28 @ @ public class LeveledManifest <nl> { <nl> logger . error ( " Could not change sstable level - adding it at level 0 anyway , we will find it at restart . " , e ) ; <nl> } <nl> - generations [ 0 ] . add ( reader ) ; <nl> + if ( ! contains ( reader ) ) <nl> + { <nl> + generations [ 0 ] . add ( reader ) ; <nl> + } <nl> + else <nl> + { <nl> + / / An SSTable being added multiple times to this manifest indicates a programming error , but we don ' t <nl> + / / throw an AssertionError because this shouldn ' t break the compaction strategy . Instead we log it <nl> + / / together with a RuntimeException so the stack is print for troubleshooting if this ever happens . <nl> + logger . warn ( " SSTable { } is already present on leveled manifest and should not be re - added . " , reader , new RuntimeException ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private boolean contains ( SSTableReader reader ) <nl> + { <nl> + for ( int i = 0 ; i < generations . length ; i + + ) <nl> + { <nl> + if ( generations [ i ] . contains ( reader ) ) <nl> + return true ; <nl> } <nl> + return false ; <nl> } <nl> <nl> public synchronized void replace ( Collection < SSTableReader > removed , Collection < SSTableReader > added ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> index 8302a9b . . 0dd134a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java <nl> @ @ - 176 , 6 + 176 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> @ SuppressWarnings ( " resource " ) <nl> public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> + List < SSTableReader > previousCandidate = null ; <nl> while ( true ) <nl> { <nl> List < SSTableReader > hottestBucket = getNextBackgroundSSTables ( gcBefore ) ; <nl> @ @ - 183 , 9 + 184 , 20 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy <nl> if ( hottestBucket . isEmpty ( ) ) <nl> return null ; <nl> <nl> + / / Already tried acquiring references without success . It means there is a race with <nl> + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager <nl> + if ( hottestBucket . equals ( previousCandidate ) ) <nl> + { <nl> + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + <nl> + " unless it happens frequently , in which case it must be reported . Will retry later . " , <nl> + hottestBucket ) ; <nl> + return null ; <nl> + } <nl> + <nl> LifecycleTransaction transaction = cfs . getTracker ( ) . tryModify ( hottestBucket , OperationType . COMPACTION ) ; <nl> if ( transaction ! = null ) <nl> return new CompactionTask ( cfs , transaction , gcBefore ) ; <nl> + previousCandidate = hottestBucket ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> index 9532cc4 . . 38cef70 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java <nl> @ @ - 72 , 6 + 72 , 7 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy <nl> @ SuppressWarnings ( " resource " ) / / transaction is closed by AbstractCompactionTask : : execute <nl> public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) <nl> { <nl> + List < SSTableReader > previousCandidate = null ; <nl> while ( true ) <nl> { <nl> List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; <nl> @ @ - 79 , 9 + 80 , 20 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy <nl> if ( latestBucket . isEmpty ( ) ) <nl> return null ; <nl> <nl> + / / Already tried acquiring references without success . It means there is a race with <nl> + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager <nl> + if ( latestBucket . equals ( previousCandidate ) ) <nl> + { <nl> + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + <nl> + " unless it happens frequently , in which case it must be reported . Will retry later . " , <nl> + latestBucket ) ; <nl> + return null ; <nl> + } <nl> + <nl> LifecycleTransaction modifier = cfs . getTracker ( ) . tryModify ( latestBucket , OperationType . COMPACTION ) ; <nl> if ( modifier ! = null ) <nl> return new TimeWindowCompactionTask ( cfs , modifier , gcBefore , options . ignoreOverlaps ) ; <nl> + previousCandidate = latestBucket ; <nl> } <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java <nl> new file mode 100644 <nl> index 0000000 . . 481b394 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java <nl> @ @ - 0 , 0 + 1 , 144 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . db . compaction ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . RowUpdateBuilder ; <nl> + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . schema . CompactionParams ; <nl> + import org . apache . cassandra . schema . KeyspaceParams ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class AbstractCompactionStrategyTest <nl> + { <nl> + private static final String KEYSPACE1 = " Keyspace1 " ; <nl> + private static final String LCS _ TABLE = " LCS _ TABLE " ; <nl> + private static final String STCS _ TABLE = " STCS _ TABLE " ; <nl> + private static final String DTCS _ TABLE = " DTCS _ TABLE " ; <nl> + private static final String TWCS _ TABLE = " TWCS _ TABLE " ; <nl> + <nl> + @ BeforeClass <nl> + public static void loadData ( ) throws ConfigurationException <nl> + { <nl> + Map < String , String > stcsOptions = new HashMap < > ( ) ; <nl> + stcsOptions . put ( " tombstone _ compaction _ interval " , " 1 " ) ; <nl> + <nl> + SchemaLoader . prepareServer ( ) ; <nl> + SchemaLoader . createKeyspace ( KEYSPACE1 , <nl> + KeyspaceParams . simple ( 1 ) , <nl> + SchemaLoader . standardCFMD ( KEYSPACE1 , LCS _ TABLE ) <nl> + . compaction ( CompactionParams . lcs ( Collections . emptyMap ( ) ) ) , <nl> + SchemaLoader . standardCFMD ( KEYSPACE1 , STCS _ TABLE ) <nl> + . compaction ( CompactionParams . scts ( Collections . emptyMap ( ) ) ) , <nl> + SchemaLoader . standardCFMD ( KEYSPACE1 , DTCS _ TABLE ) <nl> + . compaction ( CompactionParams . create ( DateTieredCompactionStrategy . class , Collections . emptyMap ( ) ) ) , <nl> + SchemaLoader . standardCFMD ( KEYSPACE1 , TWCS _ TABLE ) <nl> + . compaction ( CompactionParams . create ( TimeWindowCompactionStrategy . class , Collections . emptyMap ( ) ) ) ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( LCS _ TABLE ) . disableAutoCompaction ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STCS _ TABLE ) . disableAutoCompaction ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( DTCS _ TABLE ) . disableAutoCompaction ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( TWCS _ TABLE ) . disableAutoCompaction ( ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void tearDown ( ) <nl> + { <nl> + <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( LCS _ TABLE ) . truncateBlocking ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STCS _ TABLE ) . truncateBlocking ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( DTCS _ TABLE ) . truncateBlocking ( ) ; <nl> + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( TWCS _ TABLE ) . truncateBlocking ( ) ; <nl> + } <nl> + <nl> + @ Test ( timeout = 30000 ) <nl> + public void testGetNextBackgroundTaskDoesNotBlockLCS ( ) <nl> + { <nl> + testGetNextBackgroundTaskDoesNotBlock ( LCS _ TABLE ) ; <nl> + } <nl> + <nl> + @ Test ( timeout = 30000 ) <nl> + public void testGetNextBackgroundTaskDoesNotBlockSTCS ( ) <nl> + { <nl> + testGetNextBackgroundTaskDoesNotBlock ( STCS _ TABLE ) ; <nl> + } <nl> + <nl> + @ Test ( timeout = 30000 ) <nl> + public void testGetNextBackgroundTaskDoesNotBlockDTCS ( ) <nl> + { <nl> + testGetNextBackgroundTaskDoesNotBlock ( DTCS _ TABLE ) ; <nl> + } <nl> + <nl> + @ Test ( timeout = 30000 ) <nl> + public void testGetNextBackgroundTaskDoesNotBlockTWCS ( ) <nl> + { <nl> + testGetNextBackgroundTaskDoesNotBlock ( TWCS _ TABLE ) ; <nl> + } <nl> + <nl> + public void testGetNextBackgroundTaskDoesNotBlock ( String table ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( table ) ; <nl> + AbstractCompactionStrategy strategy = cfs . getCompactionStrategyManager ( ) . getStrategies ( ) . get ( 1 ) . get ( 0 ) ; <nl> + <nl> + / / Add 4 sstables <nl> + for ( int i = 1 ; i < = 4 ; i + + ) <nl> + { <nl> + insertKeyAndFlush ( table , i ) ; <nl> + } <nl> + <nl> + / / Check they are returned on the next background task <nl> + try ( LifecycleTransaction txn = strategy . getNextBackgroundTask ( FBUtilities . nowInSeconds ( ) ) . transaction ) <nl> + { <nl> + Assert . assertEquals ( cfs . getLiveSSTables ( ) , txn . originals ( ) ) ; <nl> + } <nl> + <nl> + / / now remove sstables on the tracker , to simulate a concurrent transaction <nl> + cfs . getTracker ( ) . removeUnsafe ( cfs . getLiveSSTables ( ) ) ; <nl> + <nl> + / / verify the compaction strategy will return null <nl> + Assert . assertNull ( strategy . getNextBackgroundTask ( FBUtilities . nowInSeconds ( ) ) ) ; <nl> + } <nl> + <nl> + <nl> + private static void insertKeyAndFlush ( String table , int key ) <nl> + { <nl> + long timestamp = System . currentTimeMillis ( ) ; <nl> + DecoratedKey dk = Util . dk ( String . format ( " % 03d " , key ) ) ; <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( table ) ; <nl> + new RowUpdateBuilder ( cfs . metadata , timestamp , dk . getKey ( ) ) <nl> + . clustering ( String . valueOf ( key ) ) <nl> + . add ( " val " , " val " ) <nl> + . build ( ) <nl> + . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index afa1c54 . . f5f4ef6 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 65 , 7 + 65 , 7 @ @ public class Config <nl> public String listen _ address ; <nl> public String broadcast _ address ; <nl> <nl> - public Boolean start _ rpc = false ; <nl> + public Boolean start _ rpc = true ; <nl> public String rpc _ address ; <nl> public Integer rpc _ port = 9160 ; <nl> public String rpc _ server _ type = " sync " ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fc18dc3 . . ce279f2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 11 . 2 
 + * Prevent compaction strategies from looping indefinitely ( CASSANDRA - 14079 ) 
 * Cache disk boundaries ( CASSANDRA - 13215 ) 
 * Add asm jar to build . xml for maven builds ( CASSANDRA - 11193 ) 
 * Round buffer size to powers of 2 for the chunk cache ( CASSANDRA - 13897 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 index 729ddc0 . . bb9f4b9 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / DateTieredCompactionStrategy . java 
 @ @ - 73 , 6 + 73 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 @ SuppressWarnings ( " resource " ) 
 public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 + List < SSTableReader > previousCandidate = null ; 
 while ( true ) 
 { 
 List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; 
 @ @ - 80 , 9 + 81 , 20 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 if ( latestBucket . isEmpty ( ) ) 
 return null ; 
 
 + / / Already tried acquiring references without success . It means there is a race with 
 + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager 
 + if ( latestBucket . equals ( previousCandidate ) ) 
 + { 
 + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + 
 + " unless it happens frequently , in which case it must be reported . Will retry later . " , 
 + latestBucket ) ; 
 + return null ; 
 + } 
 + 
 LifecycleTransaction modifier = cfs . getTracker ( ) . tryModify ( latestBucket , OperationType . COMPACTION ) ; 
 if ( modifier ! = null ) 
 return new CompactionTask ( cfs , modifier , gcBefore ) ; 
 + previousCandidate = latestBucket ; 
 } 
 } 
 
 @ @ - 170 , 6 + 182 , 8 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 / / no need to convert to collection if had an Iterables . max ( ) , but not present in standard toolkit , and not worth adding 
 List < SSTableReader > list = new ArrayList < > ( ) ; 
 Iterables . addAll ( list , cfs . getSSTables ( SSTableSet . LIVE ) ) ; 
 + if ( list . isEmpty ( ) ) 
 + return 0 ; 
 return Collections . max ( list , ( o1 , o2 ) - > Long . compare ( o1 . getMaxTimestamp ( ) , o2 . getMaxTimestamp ( ) ) ) 
 . getMaxTimestamp ( ) ; 
 } 
 @ @ - 462 , 7 + 476 , 7 @ @ public class DateTieredCompactionStrategy extends AbstractCompactionStrategy 
 return uncheckedOptions ; 
 } 
 
 - public CompactionLogger . Strategy strategyLogger ( ) 
 + public CompactionLogger . Strategy strategyLogger ( ) 
 { 
 return new CompactionLogger . Strategy ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 index f943b19 . . 43c81a4 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledCompactionStrategy . java 
 @ @ - 62 , 12 + 62 , 12 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 int configuredLevelFanoutSize = DEFAULT _ LEVEL _ FANOUT _ SIZE ; 
 SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions ( options ) ; 
 if ( options ! = null ) 
 - { 
 - if ( options . containsKey ( SSTABLE _ SIZE _ OPTION ) ) 
 - { 
 - configuredMaxSSTableSize = Integer . parseInt ( options . get ( SSTABLE _ SIZE _ OPTION ) ) ; 
 + { 
 + if ( options . containsKey ( SSTABLE _ SIZE _ OPTION ) ) 
 + { 
 + configuredMaxSSTableSize = Integer . parseInt ( options . get ( SSTABLE _ SIZE _ OPTION ) ) ; 
 if ( ! tolerateSstableSize ) 
 - { 
 + { 
 if ( configuredMaxSSTableSize > = 1000 ) 
 logger . warn ( " Max sstable size of { } MB is configured for { } . { } ; having a unit of compaction this large is probably a bad idea " , 
 configuredMaxSSTableSize , cfs . name , cfs . getColumnFamilyName ( ) ) ; 
 @ @ - 113 , 6 + 113 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 @ SuppressWarnings ( " resource " ) / / transaction is closed by AbstractCompactionTask : : execute 
 public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 + Collection < SSTableReader > previousCandidate = null ; 
 while ( true ) 
 { 
 OperationType op ; 
 @ @ - 136 , 6 + 137 , 16 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 op = OperationType . COMPACTION ; 
 } 
 
 + / / Already tried acquiring references without success . It means there is a race with 
 + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager 
 + if ( candidate . sstables . equals ( previousCandidate ) ) 
 + { 
 + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + 
 + " unless it happens frequently , in which case it must be reported . Will retry later . " , 
 + candidate . sstables ) ; 
 + return null ; 
 + } 
 + 
 LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( candidate . sstables , OperationType . COMPACTION ) ; 
 if ( txn ! = null ) 
 { 
 @ @ - 143 , 6 + 154 , 7 @ @ public class LeveledCompactionStrategy extends AbstractCompactionStrategy 
 newTask . setCompactionType ( op ) ; 
 return newTask ; 
 } 
 + previousCandidate = candidate . sstables ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index 3d118de . . ceb3811 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 169 , 8 + 169 , 28 @ @ public class LeveledManifest 
 { 
 logger . error ( " Could not change sstable level - adding it at level 0 anyway , we will find it at restart . " , e ) ; 
 } 
 - generations [ 0 ] . add ( reader ) ; 
 + if ( ! contains ( reader ) ) 
 + { 
 + generations [ 0 ] . add ( reader ) ; 
 + } 
 + else 
 + { 
 + / / An SSTable being added multiple times to this manifest indicates a programming error , but we don ' t 
 + / / throw an AssertionError because this shouldn ' t break the compaction strategy . Instead we log it 
 + / / together with a RuntimeException so the stack is print for troubleshooting if this ever happens . 
 + logger . warn ( " SSTable { } is already present on leveled manifest and should not be re - added . " , reader , new RuntimeException ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + private boolean contains ( SSTableReader reader ) 
 + { 
 + for ( int i = 0 ; i < generations . length ; i + + ) 
 + { 
 + if ( generations [ i ] . contains ( reader ) ) 
 + return true ; 
 } 
 + return false ; 
 } 
 
 public synchronized void replace ( Collection < SSTableReader > removed , Collection < SSTableReader > added ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 index 8302a9b . . 0dd134a 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / SizeTieredCompactionStrategy . java 
 @ @ - 176 , 6 + 176 , 7 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 @ SuppressWarnings ( " resource " ) 
 public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 + List < SSTableReader > previousCandidate = null ; 
 while ( true ) 
 { 
 List < SSTableReader > hottestBucket = getNextBackgroundSSTables ( gcBefore ) ; 
 @ @ - 183 , 9 + 184 , 20 @ @ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy 
 if ( hottestBucket . isEmpty ( ) ) 
 return null ; 
 
 + / / Already tried acquiring references without success . It means there is a race with 
 + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager 
 + if ( hottestBucket . equals ( previousCandidate ) ) 
 + { 
 + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + 
 + " unless it happens frequently , in which case it must be reported . Will retry later . " , 
 + hottestBucket ) ; 
 + return null ; 
 + } 
 + 
 LifecycleTransaction transaction = cfs . getTracker ( ) . tryModify ( hottestBucket , OperationType . COMPACTION ) ; 
 if ( transaction ! = null ) 
 return new CompactionTask ( cfs , transaction , gcBefore ) ; 
 + previousCandidate = hottestBucket ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 index 9532cc4 . . 38cef70 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / TimeWindowCompactionStrategy . java 
 @ @ - 72 , 6 + 72 , 7 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy 
 @ SuppressWarnings ( " resource " ) / / transaction is closed by AbstractCompactionTask : : execute 
 public AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) 
 { 
 + List < SSTableReader > previousCandidate = null ; 
 while ( true ) 
 { 
 List < SSTableReader > latestBucket = getNextBackgroundSSTables ( gcBefore ) ; 
 @ @ - 79 , 9 + 80 , 20 @ @ public class TimeWindowCompactionStrategy extends AbstractCompactionStrategy 
 if ( latestBucket . isEmpty ( ) ) 
 return null ; 
 
 + / / Already tried acquiring references without success . It means there is a race with 
 + / / the tracker but candidate SSTables were not yet replaced in the compaction strategy manager 
 + if ( latestBucket . equals ( previousCandidate ) ) 
 + { 
 + logger . warn ( " Could not acquire references for compacting SSTables { } which is not a problem per se , " + 
 + " unless it happens frequently , in which case it must be reported . Will retry later . " , 
 + latestBucket ) ; 
 + return null ; 
 + } 
 + 
 LifecycleTransaction modifier = cfs . getTracker ( ) . tryModify ( latestBucket , OperationType . COMPACTION ) ; 
 if ( modifier ! = null ) 
 return new TimeWindowCompactionTask ( cfs , modifier , gcBefore , options . ignoreOverlaps ) ; 
 + previousCandidate = latestBucket ; 
 } 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java b / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java 
 new file mode 100644 
 index 0000000 . . 481b394 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / compaction / AbstractCompactionStrategyTest . java 
 @ @ - 0 , 0 + 1 , 144 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . db . compaction ; 
 + 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import org . junit . After ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . RowUpdateBuilder ; 
 + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . schema . CompactionParams ; 
 + import org . apache . cassandra . schema . KeyspaceParams ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class AbstractCompactionStrategyTest 
 + { 
 + private static final String KEYSPACE1 = " Keyspace1 " ; 
 + private static final String LCS _ TABLE = " LCS _ TABLE " ; 
 + private static final String STCS _ TABLE = " STCS _ TABLE " ; 
 + private static final String DTCS _ TABLE = " DTCS _ TABLE " ; 
 + private static final String TWCS _ TABLE = " TWCS _ TABLE " ; 
 + 
 + @ BeforeClass 
 + public static void loadData ( ) throws ConfigurationException 
 + { 
 + Map < String , String > stcsOptions = new HashMap < > ( ) ; 
 + stcsOptions . put ( " tombstone _ compaction _ interval " , " 1 " ) ; 
 + 
 + SchemaLoader . prepareServer ( ) ; 
 + SchemaLoader . createKeyspace ( KEYSPACE1 , 
 + KeyspaceParams . simple ( 1 ) , 
 + SchemaLoader . standardCFMD ( KEYSPACE1 , LCS _ TABLE ) 
 + . compaction ( CompactionParams . lcs ( Collections . emptyMap ( ) ) ) , 
 + SchemaLoader . standardCFMD ( KEYSPACE1 , STCS _ TABLE ) 
 + . compaction ( CompactionParams . scts ( Collections . emptyMap ( ) ) ) , 
 + SchemaLoader . standardCFMD ( KEYSPACE1 , DTCS _ TABLE ) 
 + . compaction ( CompactionParams . create ( DateTieredCompactionStrategy . class , Collections . emptyMap ( ) ) ) , 
 + SchemaLoader . standardCFMD ( KEYSPACE1 , TWCS _ TABLE ) 
 + . compaction ( CompactionParams . create ( TimeWindowCompactionStrategy . class , Collections . emptyMap ( ) ) ) ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( LCS _ TABLE ) . disableAutoCompaction ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STCS _ TABLE ) . disableAutoCompaction ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( DTCS _ TABLE ) . disableAutoCompaction ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( TWCS _ TABLE ) . disableAutoCompaction ( ) ; 
 + } 
 + 
 + @ After 
 + public void tearDown ( ) 
 + { 
 + 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( LCS _ TABLE ) . truncateBlocking ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STCS _ TABLE ) . truncateBlocking ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( DTCS _ TABLE ) . truncateBlocking ( ) ; 
 + Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( TWCS _ TABLE ) . truncateBlocking ( ) ; 
 + } 
 + 
 + @ Test ( timeout = 30000 ) 
 + public void testGetNextBackgroundTaskDoesNotBlockLCS ( ) 
 + { 
 + testGetNextBackgroundTaskDoesNotBlock ( LCS _ TABLE ) ; 
 + } 
 + 
 + @ Test ( timeout = 30000 ) 
 + public void testGetNextBackgroundTaskDoesNotBlockSTCS ( ) 
 + { 
 + testGetNextBackgroundTaskDoesNotBlock ( STCS _ TABLE ) ; 
 + } 
 + 
 + @ Test ( timeout = 30000 ) 
 + public void testGetNextBackgroundTaskDoesNotBlockDTCS ( ) 
 + { 
 + testGetNextBackgroundTaskDoesNotBlock ( DTCS _ TABLE ) ; 
 + } 
 + 
 + @ Test ( timeout = 30000 ) 
 + public void testGetNextBackgroundTaskDoesNotBlockTWCS ( ) 
 + { 
 + testGetNextBackgroundTaskDoesNotBlock ( TWCS _ TABLE ) ; 
 + } 
 + 
 + public void testGetNextBackgroundTaskDoesNotBlock ( String table ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( table ) ; 
 + AbstractCompactionStrategy strategy = cfs . getCompactionStrategyManager ( ) . getStrategies ( ) . get ( 1 ) . get ( 0 ) ; 
 + 
 + / / Add 4 sstables 
 + for ( int i = 1 ; i < = 4 ; i + + ) 
 + { 
 + insertKeyAndFlush ( table , i ) ; 
 + } 
 + 
 + / / Check they are returned on the next background task 
 + try ( LifecycleTransaction txn = strategy . getNextBackgroundTask ( FBUtilities . nowInSeconds ( ) ) . transaction ) 
 + { 
 + Assert . assertEquals ( cfs . getLiveSSTables ( ) , txn . originals ( ) ) ; 
 + } 
 + 
 + / / now remove sstables on the tracker , to simulate a concurrent transaction 
 + cfs . getTracker ( ) . removeUnsafe ( cfs . getLiveSSTables ( ) ) ; 
 + 
 + / / verify the compaction strategy will return null 
 + Assert . assertNull ( strategy . getNextBackgroundTask ( FBUtilities . nowInSeconds ( ) ) ) ; 
 + } 
 + 
 + 
 + private static void insertKeyAndFlush ( String table , int key ) 
 + { 
 + long timestamp = System . currentTimeMillis ( ) ; 
 + DecoratedKey dk = Util . dk ( String . format ( " % 03d " , key ) ) ; 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( table ) ; 
 + new RowUpdateBuilder ( cfs . metadata , timestamp , dk . getKey ( ) ) 
 + . clustering ( String . valueOf ( key ) ) 
 + . add ( " val " , " val " ) 
 + . build ( ) 
 + . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index afa1c54 . . f5f4ef6 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 65 , 7 + 65 , 7 @ @ public class Config 
 public String listen _ address ; 
 public String broadcast _ address ; 
 
 - public Boolean start _ rpc = false ; 
 + public Boolean start _ rpc = true ; 
 public String rpc _ address ; 
 public Integer rpc _ port = 9160 ; 
 public String rpc _ server _ type = " sync " ;
