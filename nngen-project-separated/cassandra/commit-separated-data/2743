BLEU SCORE: 0.05876350803261633

TEST MSG: ColumnFamily - related cleanups
GENERATED MSG: Optimize name - based queries to use ArrayBackedSortedColumns

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index b81e403 . . ba082e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 29 , 7 + 29 , 6 @ @ import org . apache . cassandra . db . composites . CellName ; <nl> import org . apache . cassandra . db . composites . CellNameType ; <nl> import org . apache . cassandra . db . composites . Composite ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> <nl> / * * <nl> * A ColumnFamily backed by an ArrayList . <nl> @ @ - 55 , 14 + 54 , 14 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> { <nl> super ( metadata ) ; <nl> this . reversed = reversed ; <nl> - this . cells = new ArrayList < Cell > ( ) ; <nl> + this . cells = new ArrayList < > ( ) ; <nl> } <nl> <nl> private ArrayBackedSortedColumns ( Collection < Cell > cells , CFMetaData metadata , boolean reversed ) <nl> { <nl> super ( metadata ) ; <nl> this . reversed = reversed ; <nl> - this . cells = new ArrayList < Cell > ( cells ) ; <nl> + this . cells = new ArrayList < > ( cells ) ; <nl> } <nl> <nl> public ColumnFamily . Factory getFactory ( ) <nl> @ @ - 91 , 7 + 90 , 7 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> return pos > = 0 ? cells . get ( pos ) : null ; <nl> } <nl> <nl> - public void addColumn ( Cell cell , AbstractAllocator allocator ) <nl> + public void addColumn ( Cell cell ) <nl> { <nl> if ( cells . isEmpty ( ) ) <nl> { <nl> @ @ - 109 , 13 + 108 , 13 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> else if ( c = = 0 ) <nl> { <nl> / / Resolve against last <nl> - resolveAgainst ( getColumnCount ( ) - 1 , cell , allocator ) ; <nl> + resolveAgainst ( getColumnCount ( ) - 1 , cell ) ; <nl> } <nl> else <nl> { <nl> int pos = binarySearch ( cell . name ( ) ) ; <nl> if ( pos > = 0 ) <nl> - resolveAgainst ( pos , cell , allocator ) ; <nl> + resolveAgainst ( pos , cell ) ; <nl> else <nl> cells . add ( - pos - 1 , cell ) ; <nl> } <nl> @ @ - 125 , 13 + 124 , 9 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> * Resolve against element at position i . <nl> * Assume that i is a valid position . <nl> * / <nl> - private void resolveAgainst ( int i , Cell cell , AbstractAllocator allocator ) <nl> + private void resolveAgainst ( int i , Cell cell ) <nl> { <nl> - Cell oldCell = cells . get ( i ) ; <nl> - <nl> - / / calculate reconciled col from old ( existing ) col and new col <nl> - Cell reconciledCell = cell . reconcile ( oldCell , allocator ) ; <nl> - cells . set ( i , reconciledCell ) ; <nl> + cells . set ( i , cell . reconcile ( cells . get ( i ) ) ) ; <nl> } <nl> <nl> private int binarySearch ( CellName name ) <nl> @ @ - 155 , 22 + 150 , 16 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> { <nl> mid = ( low + high ) > > 1 ; <nl> if ( ( result = comparator . compare ( name , cells . get ( mid ) . name ( ) ) ) > 0 ) <nl> - { <nl> low = mid + 1 ; <nl> - } <nl> else if ( result = = 0 ) <nl> - { <nl> return mid ; <nl> - } <nl> else <nl> - { <nl> high = mid - 1 ; <nl> - } <nl> } <nl> return - mid - ( result < 0 ? 1 : 2 ) ; <nl> } <nl> <nl> - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) <nl> + public void addAll ( ColumnFamily cm ) <nl> { <nl> delete ( cm . deletionInfo ( ) ) ; <nl> if ( cm . getColumnCount ( ) = = 0 ) <nl> @ @ - 193 , 42 + 182 , 28 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> } <nl> else if ( c > 0 ) <nl> { <nl> - cells . add ( transformation . apply ( otherCell ) ) ; <nl> + cells . add ( otherCell ) ; <nl> otherCell = other . hasNext ( ) ? other . next ( ) : null ; <nl> } <nl> else / / c = = 0 <nl> { <nl> cells . add ( copy [ idx ] ) ; <nl> - resolveAgainst ( getColumnCount ( ) - 1 , transformation . apply ( otherCell ) , allocator ) ; <nl> + resolveAgainst ( getColumnCount ( ) - 1 , otherCell ) ; <nl> idx + + ; <nl> otherCell = other . hasNext ( ) ? other . next ( ) : null ; <nl> } <nl> } <nl> + <nl> while ( idx < copy . length ) <nl> - { <nl> cells . add ( copy [ idx + + ] ) ; <nl> - } <nl> + <nl> while ( otherCell ! = null ) <nl> { <nl> - cells . add ( transformation . apply ( otherCell ) ) ; <nl> + cells . add ( otherCell ) ; <nl> otherCell = other . hasNext ( ) ? other . next ( ) : null ; <nl> } <nl> } <nl> <nl> - public boolean replace ( Cell oldCell , Cell newCell ) <nl> - { <nl> - if ( ! oldCell . name ( ) . equals ( newCell . name ( ) ) ) <nl> - throw new IllegalArgumentException ( ) ; <nl> - <nl> - int pos = binarySearch ( oldCell . name ( ) ) ; <nl> - if ( pos > = 0 ) <nl> - { <nl> - cells . set ( pos , newCell ) ; <nl> - } <nl> - <nl> - return pos > = 0 ; <nl> - } <nl> - <nl> public Collection < Cell > getSortedColumns ( ) <nl> { <nl> return reversed ? new ReverseSortedCollection ( ) : cells ; <nl> @ @ - 264 , 11 + 239 , 6 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> } ) ; <nl> } <nl> <nl> - public Iterator < Cell > iterator ( ) <nl> - { <nl> - return reversed ? Lists . reverse ( cells ) . iterator ( ) : cells . iterator ( ) ; <nl> - } <nl> - <nl> public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) <nl> { <nl> return new SlicesIterator ( cells , getComparator ( ) , slices , reversed ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> index c1c7b66 . . 5f56326 100644 <nl> - - - a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java <nl> @ @ - 34 , 7 + 34 , 6 @ @ import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> import org . apache . cassandra . db . composites . CellNameType ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . utils . ObjectSizes ; <nl> import org . apache . cassandra . utils . btree . BTree ; <nl> import org . apache . cassandra . utils . btree . BTreeSet ; <nl> @ @ - 93 , 11 + 92 , 6 @ @ public class AtomicBTreeColumns extends ColumnFamily <nl> this . ref = holder ; <nl> } <nl> <nl> - public CellNameType getComparator ( ) <nl> - { <nl> - return metadata . comparator ; <nl> - } <nl> - <nl> public Factory getFactory ( ) <nl> { <nl> return factory ; <nl> @ @ - 158 , 11 + 152 , 6 @ @ public class AtomicBTreeColumns extends ColumnFamily <nl> } <nl> } <nl> <nl> - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) <nl> - { <nl> - addAllWithSizeDelta ( cm , allocator , transformation , SecondaryIndexManager . nullUpdater , new Delta ( ) ) ; <nl> - } <nl> - <nl> / / the function we provide to the btree utilities to perform any column replacements <nl> private static final class ColumnUpdater implements UpdateFunction < Cell > <nl> { <nl> @ @ - 282 , 12 + 271 , 12 @ @ public class AtomicBTreeColumns extends ColumnFamily <nl> <nl> / / no particular reason not to implement these next methods , we just haven ' t needed them yet <nl> <nl> - public void addColumn ( Cell column , AbstractAllocator allocator ) <nl> + public void addColumn ( Cell column ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> <nl> - public boolean replace ( Cell oldColumn , Cell newColumn ) <nl> + public void addAll ( ColumnFamily cf ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java <nl> index 0ce2654 . . 3fd3e8b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CollationController . java <nl> + + + b / src / java / org / apache / cassandra / db / CollationController . java <nl> @ @ - 30 , 7 + 30 , 6 @ @ import org . apache . cassandra . db . marshal . CounterColumnType ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> <nl> public class CollationController <nl> { <nl> @ @ - 87 , 7 + 86 , 7 @ @ public class CollationController <nl> temp . addAtom ( iter . next ( ) ) ; <nl> } <nl> <nl> - container . addAll ( temp , HeapAllocator . instance ) ; <nl> + container . addAll ( temp ) ; <nl> temp . clear ( ) ; <nl> } <nl> <nl> @ @ - 129 , 7 + 128 , 7 @ @ public class CollationController <nl> temp . addAtom ( iter . next ( ) ) ; <nl> } <nl> <nl> - container . addAll ( temp , HeapAllocator . instance ) ; <nl> + container . addAll ( temp ) ; <nl> temp . clear ( ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 610e869 . . 2bf91bf 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 28 , 12 + 28 , 7 @ @ import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . UUID ; <nl> <nl> - import com . google . common . base . Function ; <nl> - import com . google . common . base . Functions ; <nl> import com . google . common . collect . ImmutableMap ; <nl> - <nl> - import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> import org . apache . commons . lang3 . builder . HashCodeBuilder ; <nl> <nl> import org . apache . cassandra . cache . IRowCacheEntry ; <nl> @ @ - 125 , 11 + 120 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> } <nl> } <nl> <nl> - public void addColumn ( Cell cell ) <nl> - { <nl> - addColumn ( cell , HeapAllocator . instance ) ; <nl> - } <nl> - <nl> public void addColumn ( CellName name , ByteBuffer value , long timestamp ) <nl> { <nl> addColumn ( name , value , timestamp , 0 ) ; <nl> @ @ - 210 , 7 + 200 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> * If a cell with the same name is already present in the map , it will <nl> * be replaced by the newly added cell . <nl> * / <nl> - public abstract void addColumn ( Cell cell , AbstractAllocator allocator ) ; <nl> + public abstract void addColumn ( Cell cell ) ; <nl> <nl> / * * <nl> * Adds all the columns of a given column map to this column map . <nl> @ @ - 221 , 14 + 211 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> * < / code > <nl> * but is potentially faster . <nl> * / <nl> - public abstract void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) ; <nl> - <nl> - / * * <nl> - * Replace oldCell if present by newCell . <nl> - * Returns true if oldCell was present and thus replaced . <nl> - * oldCell and newCell should have the same name . <nl> - * / <nl> - public abstract boolean replace ( Cell oldCell , Cell newCell ) ; <nl> + public abstract void addAll ( ColumnFamily cm ) ; <nl> <nl> / * * <nl> * Get a column given its name , returning null if the column is not <nl> @ @ - 294 , 11 + 277 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> delete ( columns . deletionInfo ( ) ) ; <nl> } <nl> <nl> - public void addAll ( ColumnFamily cf , AbstractAllocator allocator ) <nl> - { <nl> - addAll ( cf , allocator , Functions . < Cell > identity ( ) ) ; <nl> - } <nl> - <nl> / * <nl> * This function will calculate the difference between 2 column families . <nl> * The external input is assumed to be a superset of internal . <nl> @ @ - 381 , 7 + 359 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> public String toString ( ) <nl> { <nl> StringBuilder sb = new StringBuilder ( " ColumnFamily ( " ) ; <nl> - sb . append ( metadata = = null ? " < anonymous > " : metadata . cfName ) ; <nl> + sb . append ( metadata . cfName ) ; <nl> <nl> if ( isMarkedForDelete ( ) ) <nl> sb . append ( " - " ) . append ( deletionInfo ( ) ) . append ( " - " ) ; <nl> @ @ - 413 , 15 + 391 , 10 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> <nl> public void resolve ( ColumnFamily cf ) <nl> { <nl> - resolve ( cf , HeapAllocator . instance ) ; <nl> - } <nl> - <nl> - public void resolve ( ColumnFamily cf , AbstractAllocator allocator ) <nl> - { <nl> / / Row _ does _ allow null CF objects : ( seems a necessary evil for efficiency <nl> if ( cf = = null ) <nl> return ; <nl> - addAll ( cf , allocator ) ; <nl> + addAll ( cf ) ; <nl> } <nl> <nl> public ColumnStats getColumnStats ( ) <nl> @ @ - 485 , 21 + 458 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry <nl> return getReverseSortedColumns ( ) . iterator ( ) ; <nl> } <nl> <nl> - public boolean hasIrrelevantData ( int gcBefore ) <nl> - { <nl> - / / Do we have gcable deletion infos ? <nl> - if ( deletionInfo ( ) . hasPurgeableTombstones ( gcBefore ) ) <nl> - return true ; <nl> - <nl> - / / Do we have colums that are either deleted by the container or gcable tombstone ? <nl> - DeletionInfo . InOrderTester tester = inOrderDeletionTester ( ) ; <nl> - for ( Cell cell : this ) <nl> - if ( tester . isDeleted ( cell ) | | cell . hasIrrelevantData ( gcBefore ) ) <nl> - return true ; <nl> - <nl> - return false ; <nl> - } <nl> - <nl> public Map < CellName , ByteBuffer > asMap ( ) <nl> { <nl> ImmutableMap . Builder < CellName , ByteBuffer > builder = ImmutableMap . builder ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 961d126 . . 0b3f64e 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 33 , 13 + 33 , 6 @ @ import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . * ; <nl> import com . google . common . util . concurrent . * ; <nl> - import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> - import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> - import org . apache . cassandra . concurrent . StageManager ; <nl> - import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . db . filter . SliceQueryFilter ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> - <nl> import com . google . common . util . concurrent . Futures ; <nl> import com . google . common . util . concurrent . Striped ; <nl> import com . google . common . util . concurrent . Uninterruptibles ; <nl> @ @ - 48 , 19 + 41 , 22 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . cache . * ; <nl> import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; <nl> + import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . config . * ; <nl> import org . apache . cassandra . config . CFMetaData . SpeculativeRetry ; <nl> import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . db . commitlog . ReplayPosition ; <nl> import org . apache . cassandra . db . compaction . * ; <nl> - import org . apache . cassandra . db . filter . ExtendedFilter ; <nl> - import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> - import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> - import org . apache . cassandra . db . composites . Composites ; <nl> import org . apache . cassandra . db . composites . CellNameType ; <nl> import org . apache . cassandra . db . composites . Composite ; <nl> + import org . apache . cassandra . db . filter . ColumnSlice ; <nl> + import org . apache . cassandra . db . filter . ExtendedFilter ; <nl> + import org . apache . cassandra . db . filter . IDiskAtomFilter ; <nl> + import org . apache . cassandra . db . filter . QueryFilter ; <nl> + import org . apache . cassandra . db . filter . SliceQueryFilter ; <nl> import org . apache . cassandra . db . index . SecondaryIndex ; <nl> import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . dht . * ; <nl> @ @ - 74 , 13 + 70 , 12 @ @ import org . apache . cassandra . io . sstable . metadata . CompactionMetadata ; <nl> import org . apache . cassandra . io . sstable . metadata . MetadataType ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . metrics . ColumnFamilyMetrics ; <nl> - import org . apache . cassandra . service . ActiveRepairService ; <nl> import org . apache . cassandra . service . CacheService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> - <nl> import org . apache . cassandra . streaming . StreamLockfile ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> import org . apache . cassandra . utils . * ; <nl> + import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> <nl> import static org . apache . cassandra . config . CFMetaData . Caching ; <nl> <nl> @ @ - 2066 , 7 + 2061 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> ColumnFamily cf = filter . cfs . getColumnFamily ( new QueryFilter ( rawRow . key , name , extraFilter , filter . timestamp ) ) ; <nl> if ( cf ! = null ) <nl> - data . addAll ( cf , HeapAllocator . instance ) ; <nl> + data . addAll ( cf ) ; <nl> } <nl> <nl> removeDroppedColumns ( data ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / EmptyColumns . java b / src / java / org / apache / cassandra / db / EmptyColumns . java <nl> index 5021f39 . . fa6ea1b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / EmptyColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / EmptyColumns . java <nl> @ @ - 1 , 4 + 1 , 3 @ @ <nl> - package org . apache . cassandra . db ; <nl> / * <nl> * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> @ @ - 19 , 19 + 18 , 17 @ @ package org . apache . cassandra . db ; <nl> * under the License . <nl> * <nl> * / <nl> - <nl> + package org . apache . cassandra . db ; <nl> <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> import java . util . Iterator ; <nl> <nl> + import com . google . common . collect . Iterators ; <nl> + <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> - <nl> - import com . google . common . base . Function ; <nl> - import com . google . common . collect . Iterators ; <nl> <nl> public class EmptyColumns extends AbstractThreadUnsafeSortedColumns <nl> { <nl> @ @ - 63 , 17 + 60 , 12 @ @ public class EmptyColumns extends AbstractThreadUnsafeSortedColumns <nl> return factory ; <nl> } <nl> <nl> - public void addColumn ( Cell cell , AbstractAllocator allocator ) <nl> - { <nl> - throw new UnsupportedOperationException ( ) ; <nl> - } <nl> - <nl> - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) <nl> + public void addColumn ( Cell cell ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> <nl> - public boolean replace ( Cell oldCell , Cell newCell ) <nl> + public void addAll ( ColumnFamily cm ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 09c50fa . . dadb021 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 23 , 13 + 23 , 10 @ @ import java . util . SortedMap ; <nl> import java . util . SortedSet ; <nl> import java . util . TreeMap ; <nl> <nl> - import com . google . common . base . Function ; <nl> - <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . db . composites . CellName ; <nl> - import org . apache . cassandra . db . composites . CellNameType ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . utils . memory . AbstractAllocator ; <nl> + import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> <nl> public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> { <nl> @ @ - 44 , 11 + 41 , 6 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> } <nl> } ; <nl> <nl> - public CellNameType getComparator ( ) <nl> - { <nl> - return ( CellNameType ) map . comparator ( ) ; <nl> - } <nl> - <nl> private TreeMapBackedSortedColumns ( CFMetaData metadata ) <nl> { <nl> super ( metadata ) ; <nl> @ @ - 80 , 7 + 72 , 7 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> * If we find an old cell that has the same name <nl> * the ask it to resolve itself else add the new cell <nl> * / <nl> - public void addColumn ( Cell cell , AbstractAllocator allocator ) <nl> + public void addColumn ( Cell cell ) <nl> { <nl> CellName name = cell . name ( ) ; <nl> / / this is a slightly unusual way to structure this ; a more natural way is shown in ThreadSafeSortedColumns , <nl> @ @ - 92 , 40 + 84 , 17 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> return ; <nl> <nl> / / calculate reconciled col from old ( existing ) col and new col <nl> - map . put ( name , cell . reconcile ( oldCell , allocator ) ) ; <nl> + map . put ( name , cell . reconcile ( oldCell , HeapAllocator . instance ) ) ; <nl> } <nl> <nl> / * * <nl> * We need to go through each column in the column container and resolve it before adding <nl> * / <nl> - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) <nl> + public void addAll ( ColumnFamily cm ) <nl> { <nl> delete ( cm . deletionInfo ( ) ) ; <nl> for ( Cell cell : cm ) <nl> - addColumn ( transformation . apply ( cell ) , allocator ) ; <nl> - } <nl> - <nl> - public boolean replace ( Cell oldCell , Cell newCell ) <nl> - { <nl> - if ( ! oldCell . name ( ) . equals ( newCell . name ( ) ) ) <nl> - throw new IllegalArgumentException ( ) ; <nl> - <nl> - / / We are not supposed to put the newCell is either there was not <nl> - / / column or the column was not equal to oldCell ( to be coherent <nl> - / / with other implementation ) . We optimize for the common case where <nl> - / / oldCell do is present though . <nl> - Cell previous = map . put ( oldCell . name ( ) , newCell ) ; <nl> - if ( previous = = null ) <nl> - { <nl> - map . remove ( oldCell . name ( ) ) ; <nl> - return false ; <nl> - } <nl> - if ( ! previous . equals ( oldCell ) ) <nl> - { <nl> - map . put ( oldCell . name ( ) , previous ) ; <nl> - return false ; <nl> - } <nl> - return true ; <nl> + addColumn ( cell ) ; <nl> } <nl> <nl> public Cell getColumn ( CellName name ) <nl> @ @ - 159 , 11 + 128 , 6 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> return map . navigableKeySet ( ) ; <nl> } <nl> <nl> - public Iterator < Cell > iterator ( ) <nl> - { <nl> - return map . values ( ) . iterator ( ) ; <nl> - } <nl> - <nl> public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) <nl> { <nl> return new ColumnSlice . NavigableMapIterator ( map , slices ) ; <nl> @ @ - 173 , 5 + 137 , 4 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> { <nl> return new ColumnSlice . NavigableMapIterator ( map . descendingMap ( ) , slices ) ; <nl> } <nl> - <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java b / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java <nl> index d491c93 . . f08ba4d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java <nl> + + + b / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java <nl> @ @ - 24 , 8 + 24 , 6 @ @ import java . util . Iterator ; <nl> import java . util . List ; <nl> import java . util . Set ; <nl> <nl> - import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> - <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 40 , 7 + 38 , 7 @ @ import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . db . index . * ; <nl> import org . apache . cassandra . dht . AbstractBounds ; <nl> import org . apache . cassandra . dht . Range ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> + import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> <nl> public class KeysSearcher extends SecondaryIndexSearcher <nl> { <nl> @ @ - 182 , 7 + 180 , 7 @ @ public class KeysSearcher extends SecondaryIndexSearcher <nl> { <nl> ColumnFamily cf = baseCfs . getColumnFamily ( new QueryFilter ( dk , baseCfs . name , extraFilter , filter . timestamp ) ) ; <nl> if ( cf ! = null ) <nl> - data . addAll ( cf , HeapAllocator . instance ) ; <nl> + data . addAll ( cf ) ; <nl> } <nl> <nl> if ( ( ( KeysIndex ) index ) . isIndexEntryStale ( indexKey . key , data , filter . timestamp ) ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> index cd837c8 . . d98dab6 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java <nl> @ @ - 1 , 4 + 1 , 3 @ @ <nl> - package org . apache . cassandra . db ; <nl> / * <nl> * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> @ @ - 19 , 23 + 18 , 19 @ @ package org . apache . cassandra . db ; <nl> * under the License . <nl> * <nl> * / <nl> - <nl> + package org . apache . cassandra . db ; <nl> <nl> import java . util . * ; <nl> - <nl> import org . junit . Test ; <nl> <nl> import static org . junit . Assert . * ; <nl> <nl> - import com . google . common . base . Functions ; <nl> - <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . db . composites . * ; <nl> import org . apache . cassandra . db . filter . ColumnSlice ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> import org . apache . cassandra . db . marshal . Int32Type ; <nl> <nl> public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> @ @ - 59 , 7 + 54 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> int [ ] values = new int [ ] { 1 , 2 , 2 , 3 } ; <nl> <nl> for ( int i = 0 ; i < values . length ; + + i ) <nl> - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; <nl> <nl> Iterator < Cell > iter = map . iterator ( ) ; <nl> assertEquals ( " 1st column " , 1 , iter . next ( ) . name ( ) . toByteBuffer ( ) . getInt ( 0 ) ) ; <nl> @ @ - 84 , 12 + 79 , 12 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> int [ ] values2 = new int [ ] { 2 , 4 , 5 , 6 } ; <nl> <nl> for ( int i = 0 ; i < values1 . length ; + + i ) <nl> - map . addColumn ( new Cell ( type . makeCellName ( values1 [ reversed ? values1 . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map . addColumn ( new Cell ( type . makeCellName ( values1 [ reversed ? values1 . length - 1 - i : i ] ) ) ) ; <nl> <nl> for ( int i = 0 ; i < values2 . length ; + + i ) <nl> - map2 . addColumn ( new Cell ( type . makeCellName ( values2 [ reversed ? values2 . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map2 . addColumn ( new Cell ( type . makeCellName ( values2 [ reversed ? values2 . length - 1 - i : i ] ) ) ) ; <nl> <nl> - map2 . addAll ( map , HeapAllocator . instance , Functions . < Cell > identity ( ) ) ; <nl> + map2 . addAll ( map ) ; <nl> <nl> Iterator < Cell > iter = map2 . iterator ( ) ; <nl> assertEquals ( " 1st column " , 1 , iter . next ( ) . name ( ) . toByteBuffer ( ) . getInt ( 0 ) ) ; <nl> @ @ - 113 , 14 + 108 , 14 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> ColumnFamily map = ArrayBackedSortedColumns . factory . create ( metadata ( ) , reversed ) ; <nl> int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 } ; <nl> <nl> - List < Cell > sorted = new ArrayList < Cell > ( ) ; <nl> + List < Cell > sorted = new ArrayList < > ( ) ; <nl> for ( int v : values ) <nl> sorted . add ( new Cell ( type . makeCellName ( v ) ) ) ; <nl> - List < Cell > reverseSorted = new ArrayList < Cell > ( sorted ) ; <nl> + List < Cell > reverseSorted = new ArrayList < > ( sorted ) ; <nl> Collections . reverse ( reverseSorted ) ; <nl> <nl> for ( int i = 0 ; i < values . length ; + + i ) <nl> - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; <nl> <nl> assertSame ( sorted , map . getSortedColumns ( ) ) ; <nl> assertSame ( reverseSorted , map . getReverseSortedColumns ( ) ) ; <nl> @ @ - 141 , 7 + 136 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 } ; <nl> <nl> for ( int i = 0 ; i < values . length ; + + i ) <nl> - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; <nl> <nl> assertSame ( new int [ ] { 3 , 2 , 1 } , map . reverseIterator ( new ColumnSlice [ ] { new ColumnSlice ( type . make ( 3 ) , Composites . EMPTY ) } ) ) ; <nl> assertSame ( new int [ ] { 3 , 2 , 1 } , map . reverseIterator ( new ColumnSlice [ ] { new ColumnSlice ( type . make ( 4 ) , Composites . EMPTY ) } ) ) ; <nl> @ @ - 187 , 7 + 182 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader <nl> int [ ] values = new int [ ] { 1 , 2 , 2 , 3 } ; <nl> <nl> for ( int i = 0 ; i < values . length ; + + i ) <nl> - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; <nl> + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; <nl> <nl> Iterator < Cell > iter = map . getReverseSortedColumns ( ) . iterator ( ) ; <nl> assertTrue ( iter . hasNext ( ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java <nl> index cd79217 . . ae2a461 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java <nl> @ @ - 25 , 21 + 25 , 18 @ @ import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> - <nl> - import org . apache . cassandra . SchemaLoader ; <nl> import org . junit . Test ; <nl> <nl> + import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . io . sstable . ColumnStats ; <nl> import org . apache . cassandra . io . util . DataOutputBuffer ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> import static org . apache . cassandra . Util . column ; <nl> import static org . apache . cassandra . Util . cellname ; <nl> import static org . junit . Assert . assertEquals ; <nl> <nl> - import org . apache . cassandra . utils . ByteBufferUtil ; <nl> - import org . apache . cassandra . utils . memory . HeapAllocator ; <nl> - <nl> - <nl> public class ColumnFamilyTest extends SchemaLoader <nl> { <nl> static int version = MessagingService . current _ version ; <nl> @ @ - 68 , 7 + 65 , 7 @ @ public class ColumnFamilyTest extends SchemaLoader <nl> { <nl> ColumnFamily cf ; <nl> <nl> - TreeMap < String , String > map = new TreeMap < String , String > ( ) ; <nl> + TreeMap < String , String > map = new TreeMap < > ( ) ; <nl> for ( int i = 100 ; i < 1000 ; + + i ) <nl> { <nl> map . put ( Integer . toString ( i ) , " Avinash Lakshman is a good man : " + i ) ; <nl> @ @ - 134 , 8 + 131 , 8 @ @ public class ColumnFamilyTest extends SchemaLoader <nl> cf _ old . addColumn ( cellname ( " col2 " ) , val2 , 1 ) ; <nl> cf _ old . addColumn ( cellname ( " col3 " ) , val2 , 2 ) ; <nl> <nl> - cf _ result . addAll ( cf _ new , HeapAllocator . instance ) ; <nl> - cf _ result . addAll ( cf _ old , HeapAllocator . instance ) ; <nl> + cf _ result . addAll ( cf _ new ) ; <nl> + cf _ result . addAll ( cf _ old ) ; <nl> <nl> assert 3 = = cf _ result . getColumnCount ( ) : " Count is " + cf _ new . getColumnCount ( ) ; <nl> / / addcolumns will only add if timestamp > = old timestamp
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 115ee45 . . d73849c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 3 + 1 , 7 @ @ <nl> + 1 . 2 . 0 <nl> + * cqlsh : add DESCRIBE KEYSPACES command ( CASSANDRA - 5060 ) <nl> + <nl> + <nl> 1 . 2 - rc1 <nl> * rename rpc _ timeout settings to request _ timeout ( CASSANDRA - 5027 ) <nl> * add BF with 0 . 1 FP to LCS by default ( CASSANDRA - 5029 ) <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 611f6af . . f74dc42 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 211 , 7 + 211 , 8 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' <nl> ; <nl> <nl> < describeCommand > : : = ( " DESCRIBE " | " DESC " ) <nl> - ( " KEYSPACE " ksname = < keyspaceName > ? <nl> + ( " KEYSPACES " <nl> + | " KEYSPACE " ksname = < keyspaceName > ? <nl> | ( " COLUMNFAMILY " | " TABLE " ) cf = < columnFamilyName > <nl> | ( " COLUMNFAMILIES " | " TABLES " ) <nl> | " SCHEMA " <nl> @ @ - 1328 , 6 + 1329 , 11 @ @ class Shell ( cmd . Cmd ) : <nl> out . write ( ' CREATE INDEX % s ON % s ( % s ) ; \ n ' <nl> % ( col . index _ name , cfname , self . cql _ protect _ name ( col . name ) ) ) <nl> <nl> + def describe _ keyspaces ( self ) : <nl> + print <nl> + cmd . Cmd . columnize ( self , self . get _ keyspace _ names ( ) ) <nl> + print <nl> + <nl> def describe _ keyspace ( self , ksname ) : <nl> print <nl> self . print _ recreate _ keyspace ( self . get _ keyspace ( ksname ) , sys . stdout ) <nl> @ @ - 1381 , 6 + 1387 , 10 @ @ class Shell ( cmd . Cmd ) : <nl> Outputs information about the connected Cassandra cluster , or about <nl> the data stored on it . Use in one of the following ways : <nl> <nl> + DESCRIBE KEYSPACES <nl> + <nl> + Output the names of all keyspaces . <nl> + <nl> DESCRIBE KEYSPACE [ < keyspacename > ] <nl> <nl> Output CQL commands that could be used to recreate the given <nl> @ @ - 1416 , 6 + 1426 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> k . <nl> " " " <nl> what = parsed . matched [ 1 ] [ 1 ] . lower ( ) <nl> + if what = = ' keyspaces ' : <nl> + self . describe _ keyspaces ( ) <nl> if what = = ' keyspace ' : <nl> ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) <nl> if not ksname :

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index b81e403 . . ba082e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 29 , 7 + 29 , 6 @ @ import org . apache . cassandra . db . composites . CellName ; 
 import org . apache . cassandra . db . composites . CellNameType ; 
 import org . apache . cassandra . db . composites . Composite ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 
 / * * 
 * A ColumnFamily backed by an ArrayList . 
 @ @ - 55 , 14 + 54 , 14 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 { 
 super ( metadata ) ; 
 this . reversed = reversed ; 
 - this . cells = new ArrayList < Cell > ( ) ; 
 + this . cells = new ArrayList < > ( ) ; 
 } 
 
 private ArrayBackedSortedColumns ( Collection < Cell > cells , CFMetaData metadata , boolean reversed ) 
 { 
 super ( metadata ) ; 
 this . reversed = reversed ; 
 - this . cells = new ArrayList < Cell > ( cells ) ; 
 + this . cells = new ArrayList < > ( cells ) ; 
 } 
 
 public ColumnFamily . Factory getFactory ( ) 
 @ @ - 91 , 7 + 90 , 7 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 return pos > = 0 ? cells . get ( pos ) : null ; 
 } 
 
 - public void addColumn ( Cell cell , AbstractAllocator allocator ) 
 + public void addColumn ( Cell cell ) 
 { 
 if ( cells . isEmpty ( ) ) 
 { 
 @ @ - 109 , 13 + 108 , 13 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 else if ( c = = 0 ) 
 { 
 / / Resolve against last 
 - resolveAgainst ( getColumnCount ( ) - 1 , cell , allocator ) ; 
 + resolveAgainst ( getColumnCount ( ) - 1 , cell ) ; 
 } 
 else 
 { 
 int pos = binarySearch ( cell . name ( ) ) ; 
 if ( pos > = 0 ) 
 - resolveAgainst ( pos , cell , allocator ) ; 
 + resolveAgainst ( pos , cell ) ; 
 else 
 cells . add ( - pos - 1 , cell ) ; 
 } 
 @ @ - 125 , 13 + 124 , 9 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 * Resolve against element at position i . 
 * Assume that i is a valid position . 
 * / 
 - private void resolveAgainst ( int i , Cell cell , AbstractAllocator allocator ) 
 + private void resolveAgainst ( int i , Cell cell ) 
 { 
 - Cell oldCell = cells . get ( i ) ; 
 - 
 - / / calculate reconciled col from old ( existing ) col and new col 
 - Cell reconciledCell = cell . reconcile ( oldCell , allocator ) ; 
 - cells . set ( i , reconciledCell ) ; 
 + cells . set ( i , cell . reconcile ( cells . get ( i ) ) ) ; 
 } 
 
 private int binarySearch ( CellName name ) 
 @ @ - 155 , 22 + 150 , 16 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 { 
 mid = ( low + high ) > > 1 ; 
 if ( ( result = comparator . compare ( name , cells . get ( mid ) . name ( ) ) ) > 0 ) 
 - { 
 low = mid + 1 ; 
 - } 
 else if ( result = = 0 ) 
 - { 
 return mid ; 
 - } 
 else 
 - { 
 high = mid - 1 ; 
 - } 
 } 
 return - mid - ( result < 0 ? 1 : 2 ) ; 
 } 
 
 - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) 
 + public void addAll ( ColumnFamily cm ) 
 { 
 delete ( cm . deletionInfo ( ) ) ; 
 if ( cm . getColumnCount ( ) = = 0 ) 
 @ @ - 193 , 42 + 182 , 28 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 } 
 else if ( c > 0 ) 
 { 
 - cells . add ( transformation . apply ( otherCell ) ) ; 
 + cells . add ( otherCell ) ; 
 otherCell = other . hasNext ( ) ? other . next ( ) : null ; 
 } 
 else / / c = = 0 
 { 
 cells . add ( copy [ idx ] ) ; 
 - resolveAgainst ( getColumnCount ( ) - 1 , transformation . apply ( otherCell ) , allocator ) ; 
 + resolveAgainst ( getColumnCount ( ) - 1 , otherCell ) ; 
 idx + + ; 
 otherCell = other . hasNext ( ) ? other . next ( ) : null ; 
 } 
 } 
 + 
 while ( idx < copy . length ) 
 - { 
 cells . add ( copy [ idx + + ] ) ; 
 - } 
 + 
 while ( otherCell ! = null ) 
 { 
 - cells . add ( transformation . apply ( otherCell ) ) ; 
 + cells . add ( otherCell ) ; 
 otherCell = other . hasNext ( ) ? other . next ( ) : null ; 
 } 
 } 
 
 - public boolean replace ( Cell oldCell , Cell newCell ) 
 - { 
 - if ( ! oldCell . name ( ) . equals ( newCell . name ( ) ) ) 
 - throw new IllegalArgumentException ( ) ; 
 - 
 - int pos = binarySearch ( oldCell . name ( ) ) ; 
 - if ( pos > = 0 ) 
 - { 
 - cells . set ( pos , newCell ) ; 
 - } 
 - 
 - return pos > = 0 ; 
 - } 
 - 
 public Collection < Cell > getSortedColumns ( ) 
 { 
 return reversed ? new ReverseSortedCollection ( ) : cells ; 
 @ @ - 264 , 11 + 239 , 6 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 } ) ; 
 } 
 
 - public Iterator < Cell > iterator ( ) 
 - { 
 - return reversed ? Lists . reverse ( cells ) . iterator ( ) : cells . iterator ( ) ; 
 - } 
 - 
 public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) 
 { 
 return new SlicesIterator ( cells , getComparator ( ) , slices , reversed ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 index c1c7b66 . . 5f56326 100644 
 - - - a / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 + + + b / src / java / org / apache / cassandra / db / AtomicBTreeColumns . java 
 @ @ - 34 , 7 + 34 , 6 @ @ import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . db . composites . CellName ; 
 import org . apache . cassandra . db . composites . CellNameType ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . utils . ObjectSizes ; 
 import org . apache . cassandra . utils . btree . BTree ; 
 import org . apache . cassandra . utils . btree . BTreeSet ; 
 @ @ - 93 , 11 + 92 , 6 @ @ public class AtomicBTreeColumns extends ColumnFamily 
 this . ref = holder ; 
 } 
 
 - public CellNameType getComparator ( ) 
 - { 
 - return metadata . comparator ; 
 - } 
 - 
 public Factory getFactory ( ) 
 { 
 return factory ; 
 @ @ - 158 , 11 + 152 , 6 @ @ public class AtomicBTreeColumns extends ColumnFamily 
 } 
 } 
 
 - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) 
 - { 
 - addAllWithSizeDelta ( cm , allocator , transformation , SecondaryIndexManager . nullUpdater , new Delta ( ) ) ; 
 - } 
 - 
 / / the function we provide to the btree utilities to perform any column replacements 
 private static final class ColumnUpdater implements UpdateFunction < Cell > 
 { 
 @ @ - 282 , 12 + 271 , 12 @ @ public class AtomicBTreeColumns extends ColumnFamily 
 
 / / no particular reason not to implement these next methods , we just haven ' t needed them yet 
 
 - public void addColumn ( Cell column , AbstractAllocator allocator ) 
 + public void addColumn ( Cell column ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 
 - public boolean replace ( Cell oldColumn , Cell newColumn ) 
 + public void addAll ( ColumnFamily cf ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java 
 index 0ce2654 . . 3fd3e8b 100644 
 - - - a / src / java / org / apache / cassandra / db / CollationController . java 
 + + + b / src / java / org / apache / cassandra / db / CollationController . java 
 @ @ - 30 , 7 + 30 , 6 @ @ import org . apache . cassandra . db . marshal . CounterColumnType ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . tracing . Tracing ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 
 public class CollationController 
 { 
 @ @ - 87 , 7 + 86 , 7 @ @ public class CollationController 
 temp . addAtom ( iter . next ( ) ) ; 
 } 
 
 - container . addAll ( temp , HeapAllocator . instance ) ; 
 + container . addAll ( temp ) ; 
 temp . clear ( ) ; 
 } 
 
 @ @ - 129 , 7 + 128 , 7 @ @ public class CollationController 
 temp . addAtom ( iter . next ( ) ) ; 
 } 
 
 - container . addAll ( temp , HeapAllocator . instance ) ; 
 + container . addAll ( temp ) ; 
 temp . clear ( ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 610e869 . . 2bf91bf 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 28 , 12 + 28 , 7 @ @ import java . util . List ; 
 import java . util . Map ; 
 import java . util . UUID ; 
 
 - import com . google . common . base . Function ; 
 - import com . google . common . base . Functions ; 
 import com . google . common . collect . ImmutableMap ; 
 - 
 - import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 import org . apache . commons . lang3 . builder . HashCodeBuilder ; 
 
 import org . apache . cassandra . cache . IRowCacheEntry ; 
 @ @ - 125 , 11 + 120 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 } 
 } 
 
 - public void addColumn ( Cell cell ) 
 - { 
 - addColumn ( cell , HeapAllocator . instance ) ; 
 - } 
 - 
 public void addColumn ( CellName name , ByteBuffer value , long timestamp ) 
 { 
 addColumn ( name , value , timestamp , 0 ) ; 
 @ @ - 210 , 7 + 200 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 * If a cell with the same name is already present in the map , it will 
 * be replaced by the newly added cell . 
 * / 
 - public abstract void addColumn ( Cell cell , AbstractAllocator allocator ) ; 
 + public abstract void addColumn ( Cell cell ) ; 
 
 / * * 
 * Adds all the columns of a given column map to this column map . 
 @ @ - 221 , 14 + 211 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 * < / code > 
 * but is potentially faster . 
 * / 
 - public abstract void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) ; 
 - 
 - / * * 
 - * Replace oldCell if present by newCell . 
 - * Returns true if oldCell was present and thus replaced . 
 - * oldCell and newCell should have the same name . 
 - * / 
 - public abstract boolean replace ( Cell oldCell , Cell newCell ) ; 
 + public abstract void addAll ( ColumnFamily cm ) ; 
 
 / * * 
 * Get a column given its name , returning null if the column is not 
 @ @ - 294 , 11 + 277 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 delete ( columns . deletionInfo ( ) ) ; 
 } 
 
 - public void addAll ( ColumnFamily cf , AbstractAllocator allocator ) 
 - { 
 - addAll ( cf , allocator , Functions . < Cell > identity ( ) ) ; 
 - } 
 - 
 / * 
 * This function will calculate the difference between 2 column families . 
 * The external input is assumed to be a superset of internal . 
 @ @ - 381 , 7 + 359 , 7 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 public String toString ( ) 
 { 
 StringBuilder sb = new StringBuilder ( " ColumnFamily ( " ) ; 
 - sb . append ( metadata = = null ? " < anonymous > " : metadata . cfName ) ; 
 + sb . append ( metadata . cfName ) ; 
 
 if ( isMarkedForDelete ( ) ) 
 sb . append ( " - " ) . append ( deletionInfo ( ) ) . append ( " - " ) ; 
 @ @ - 413 , 15 + 391 , 10 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 
 public void resolve ( ColumnFamily cf ) 
 { 
 - resolve ( cf , HeapAllocator . instance ) ; 
 - } 
 - 
 - public void resolve ( ColumnFamily cf , AbstractAllocator allocator ) 
 - { 
 / / Row _ does _ allow null CF objects : ( seems a necessary evil for efficiency 
 if ( cf = = null ) 
 return ; 
 - addAll ( cf , allocator ) ; 
 + addAll ( cf ) ; 
 } 
 
 public ColumnStats getColumnStats ( ) 
 @ @ - 485 , 21 + 458 , 6 @ @ public abstract class ColumnFamily implements Iterable < Cell > , IRowCacheEntry 
 return getReverseSortedColumns ( ) . iterator ( ) ; 
 } 
 
 - public boolean hasIrrelevantData ( int gcBefore ) 
 - { 
 - / / Do we have gcable deletion infos ? 
 - if ( deletionInfo ( ) . hasPurgeableTombstones ( gcBefore ) ) 
 - return true ; 
 - 
 - / / Do we have colums that are either deleted by the container or gcable tombstone ? 
 - DeletionInfo . InOrderTester tester = inOrderDeletionTester ( ) ; 
 - for ( Cell cell : this ) 
 - if ( tester . isDeleted ( cell ) | | cell . hasIrrelevantData ( gcBefore ) ) 
 - return true ; 
 - 
 - return false ; 
 - } 
 - 
 public Map < CellName , ByteBuffer > asMap ( ) 
 { 
 ImmutableMap . Builder < CellName , ByteBuffer > builder = ImmutableMap . builder ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 961d126 . . 0b3f64e 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 33 , 13 + 33 , 6 @ @ import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . base . Function ; 
 import com . google . common . collect . * ; 
 import com . google . common . util . concurrent . * ; 
 - import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 - import org . apache . cassandra . utils . concurrent . OpOrder ; 
 - import org . apache . cassandra . concurrent . StageManager ; 
 - import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . db . filter . SliceQueryFilter ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 - 
 import com . google . common . util . concurrent . Futures ; 
 import com . google . common . util . concurrent . Striped ; 
 import com . google . common . util . concurrent . Uninterruptibles ; 
 @ @ - 48 , 19 + 41 , 22 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . cache . * ; 
 import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; 
 + import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 + import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . config . * ; 
 import org . apache . cassandra . config . CFMetaData . SpeculativeRetry ; 
 import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . db . commitlog . ReplayPosition ; 
 import org . apache . cassandra . db . compaction . * ; 
 - import org . apache . cassandra . db . filter . ExtendedFilter ; 
 - import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 - import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . db . composites . CellName ; 
 - import org . apache . cassandra . db . composites . Composites ; 
 import org . apache . cassandra . db . composites . CellNameType ; 
 import org . apache . cassandra . db . composites . Composite ; 
 + import org . apache . cassandra . db . filter . ColumnSlice ; 
 + import org . apache . cassandra . db . filter . ExtendedFilter ; 
 + import org . apache . cassandra . db . filter . IDiskAtomFilter ; 
 + import org . apache . cassandra . db . filter . QueryFilter ; 
 + import org . apache . cassandra . db . filter . SliceQueryFilter ; 
 import org . apache . cassandra . db . index . SecondaryIndex ; 
 import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . dht . * ; 
 @ @ - 74 , 13 + 70 , 12 @ @ import org . apache . cassandra . io . sstable . metadata . CompactionMetadata ; 
 import org . apache . cassandra . io . sstable . metadata . MetadataType ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . metrics . ColumnFamilyMetrics ; 
 - import org . apache . cassandra . service . ActiveRepairService ; 
 import org . apache . cassandra . service . CacheService ; 
 import org . apache . cassandra . service . StorageService ; 
 - 
 import org . apache . cassandra . streaming . StreamLockfile ; 
 import org . apache . cassandra . tracing . Tracing ; 
 import org . apache . cassandra . utils . * ; 
 + import org . apache . cassandra . utils . concurrent . OpOrder ; 
 
 import static org . apache . cassandra . config . CFMetaData . Caching ; 
 
 @ @ - 2066 , 7 + 2061 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 ColumnFamily cf = filter . cfs . getColumnFamily ( new QueryFilter ( rawRow . key , name , extraFilter , filter . timestamp ) ) ; 
 if ( cf ! = null ) 
 - data . addAll ( cf , HeapAllocator . instance ) ; 
 + data . addAll ( cf ) ; 
 } 
 
 removeDroppedColumns ( data ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / EmptyColumns . java b / src / java / org / apache / cassandra / db / EmptyColumns . java 
 index 5021f39 . . fa6ea1b 100644 
 - - - a / src / java / org / apache / cassandra / db / EmptyColumns . java 
 + + + b / src / java / org / apache / cassandra / db / EmptyColumns . java 
 @ @ - 1 , 4 + 1 , 3 @ @ 
 - package org . apache . cassandra . db ; 
 / * 
 * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 @ @ - 19 , 19 + 18 , 17 @ @ package org . apache . cassandra . db ; 
 * under the License . 
 * 
 * / 
 - 
 + package org . apache . cassandra . db ; 
 
 import java . util . Collection ; 
 import java . util . Collections ; 
 import java . util . Iterator ; 
 
 + import com . google . common . collect . Iterators ; 
 + 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . db . composites . CellName ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 - 
 - import com . google . common . base . Function ; 
 - import com . google . common . collect . Iterators ; 
 
 public class EmptyColumns extends AbstractThreadUnsafeSortedColumns 
 { 
 @ @ - 63 , 17 + 60 , 12 @ @ public class EmptyColumns extends AbstractThreadUnsafeSortedColumns 
 return factory ; 
 } 
 
 - public void addColumn ( Cell cell , AbstractAllocator allocator ) 
 - { 
 - throw new UnsupportedOperationException ( ) ; 
 - } 
 - 
 - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) 
 + public void addColumn ( Cell cell ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 
 - public boolean replace ( Cell oldCell , Cell newCell ) 
 + public void addAll ( ColumnFamily cm ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 09c50fa . . dadb021 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 23 , 13 + 23 , 10 @ @ import java . util . SortedMap ; 
 import java . util . SortedSet ; 
 import java . util . TreeMap ; 
 
 - import com . google . common . base . Function ; 
 - 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . db . composites . CellName ; 
 - import org . apache . cassandra . db . composites . CellNameType ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . utils . memory . AbstractAllocator ; 
 + import org . apache . cassandra . utils . memory . HeapAllocator ; 
 
 public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 { 
 @ @ - 44 , 11 + 41 , 6 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 } 
 } ; 
 
 - public CellNameType getComparator ( ) 
 - { 
 - return ( CellNameType ) map . comparator ( ) ; 
 - } 
 - 
 private TreeMapBackedSortedColumns ( CFMetaData metadata ) 
 { 
 super ( metadata ) ; 
 @ @ - 80 , 7 + 72 , 7 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 * If we find an old cell that has the same name 
 * the ask it to resolve itself else add the new cell 
 * / 
 - public void addColumn ( Cell cell , AbstractAllocator allocator ) 
 + public void addColumn ( Cell cell ) 
 { 
 CellName name = cell . name ( ) ; 
 / / this is a slightly unusual way to structure this ; a more natural way is shown in ThreadSafeSortedColumns , 
 @ @ - 92 , 40 + 84 , 17 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 return ; 
 
 / / calculate reconciled col from old ( existing ) col and new col 
 - map . put ( name , cell . reconcile ( oldCell , allocator ) ) ; 
 + map . put ( name , cell . reconcile ( oldCell , HeapAllocator . instance ) ) ; 
 } 
 
 / * * 
 * We need to go through each column in the column container and resolve it before adding 
 * / 
 - public void addAll ( ColumnFamily cm , AbstractAllocator allocator , Function < Cell , Cell > transformation ) 
 + public void addAll ( ColumnFamily cm ) 
 { 
 delete ( cm . deletionInfo ( ) ) ; 
 for ( Cell cell : cm ) 
 - addColumn ( transformation . apply ( cell ) , allocator ) ; 
 - } 
 - 
 - public boolean replace ( Cell oldCell , Cell newCell ) 
 - { 
 - if ( ! oldCell . name ( ) . equals ( newCell . name ( ) ) ) 
 - throw new IllegalArgumentException ( ) ; 
 - 
 - / / We are not supposed to put the newCell is either there was not 
 - / / column or the column was not equal to oldCell ( to be coherent 
 - / / with other implementation ) . We optimize for the common case where 
 - / / oldCell do is present though . 
 - Cell previous = map . put ( oldCell . name ( ) , newCell ) ; 
 - if ( previous = = null ) 
 - { 
 - map . remove ( oldCell . name ( ) ) ; 
 - return false ; 
 - } 
 - if ( ! previous . equals ( oldCell ) ) 
 - { 
 - map . put ( oldCell . name ( ) , previous ) ; 
 - return false ; 
 - } 
 - return true ; 
 + addColumn ( cell ) ; 
 } 
 
 public Cell getColumn ( CellName name ) 
 @ @ - 159 , 11 + 128 , 6 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 return map . navigableKeySet ( ) ; 
 } 
 
 - public Iterator < Cell > iterator ( ) 
 - { 
 - return map . values ( ) . iterator ( ) ; 
 - } 
 - 
 public Iterator < Cell > iterator ( ColumnSlice [ ] slices ) 
 { 
 return new ColumnSlice . NavigableMapIterator ( map , slices ) ; 
 @ @ - 173 , 5 + 137 , 4 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 { 
 return new ColumnSlice . NavigableMapIterator ( map . descendingMap ( ) , slices ) ; 
 } 
 - 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java b / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java 
 index d491c93 . . f08ba4d 100644 
 - - - a / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java 
 + + + b / src / java / org / apache / cassandra / db / index / keys / KeysSearcher . java 
 @ @ - 24 , 8 + 24 , 6 @ @ import java . util . Iterator ; 
 import java . util . List ; 
 import java . util . Set ; 
 
 - import org . apache . cassandra . utils . concurrent . OpOrder ; 
 - 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 40 , 7 + 38 , 7 @ @ import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . db . index . * ; 
 import org . apache . cassandra . dht . AbstractBounds ; 
 import org . apache . cassandra . dht . Range ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 + import org . apache . cassandra . utils . concurrent . OpOrder ; 
 
 public class KeysSearcher extends SecondaryIndexSearcher 
 { 
 @ @ - 182 , 7 + 180 , 7 @ @ public class KeysSearcher extends SecondaryIndexSearcher 
 { 
 ColumnFamily cf = baseCfs . getColumnFamily ( new QueryFilter ( dk , baseCfs . name , extraFilter , filter . timestamp ) ) ; 
 if ( cf ! = null ) 
 - data . addAll ( cf , HeapAllocator . instance ) ; 
 + data . addAll ( cf ) ; 
 } 
 
 if ( ( ( KeysIndex ) index ) . isIndexEntryStale ( indexKey . key , data , filter . timestamp ) ) 
 diff - - git a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 index cd837c8 . . d98dab6 100644 
 - - - a / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ArrayBackedSortedColumnsTest . java 
 @ @ - 1 , 4 + 1 , 3 @ @ 
 - package org . apache . cassandra . db ; 
 / * 
 * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 @ @ - 19 , 23 + 18 , 19 @ @ package org . apache . cassandra . db ; 
 * under the License . 
 * 
 * / 
 - 
 + package org . apache . cassandra . db ; 
 
 import java . util . * ; 
 - 
 import org . junit . Test ; 
 
 import static org . junit . Assert . * ; 
 
 - import com . google . common . base . Functions ; 
 - 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . db . composites . * ; 
 import org . apache . cassandra . db . filter . ColumnSlice ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 import org . apache . cassandra . db . marshal . Int32Type ; 
 
 public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 @ @ - 59 , 7 + 54 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 int [ ] values = new int [ ] { 1 , 2 , 2 , 3 } ; 
 
 for ( int i = 0 ; i < values . length ; + + i ) 
 - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; 
 
 Iterator < Cell > iter = map . iterator ( ) ; 
 assertEquals ( " 1st column " , 1 , iter . next ( ) . name ( ) . toByteBuffer ( ) . getInt ( 0 ) ) ; 
 @ @ - 84 , 12 + 79 , 12 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 int [ ] values2 = new int [ ] { 2 , 4 , 5 , 6 } ; 
 
 for ( int i = 0 ; i < values1 . length ; + + i ) 
 - map . addColumn ( new Cell ( type . makeCellName ( values1 [ reversed ? values1 . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map . addColumn ( new Cell ( type . makeCellName ( values1 [ reversed ? values1 . length - 1 - i : i ] ) ) ) ; 
 
 for ( int i = 0 ; i < values2 . length ; + + i ) 
 - map2 . addColumn ( new Cell ( type . makeCellName ( values2 [ reversed ? values2 . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map2 . addColumn ( new Cell ( type . makeCellName ( values2 [ reversed ? values2 . length - 1 - i : i ] ) ) ) ; 
 
 - map2 . addAll ( map , HeapAllocator . instance , Functions . < Cell > identity ( ) ) ; 
 + map2 . addAll ( map ) ; 
 
 Iterator < Cell > iter = map2 . iterator ( ) ; 
 assertEquals ( " 1st column " , 1 , iter . next ( ) . name ( ) . toByteBuffer ( ) . getInt ( 0 ) ) ; 
 @ @ - 113 , 14 + 108 , 14 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 ColumnFamily map = ArrayBackedSortedColumns . factory . create ( metadata ( ) , reversed ) ; 
 int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 } ; 
 
 - List < Cell > sorted = new ArrayList < Cell > ( ) ; 
 + List < Cell > sorted = new ArrayList < > ( ) ; 
 for ( int v : values ) 
 sorted . add ( new Cell ( type . makeCellName ( v ) ) ) ; 
 - List < Cell > reverseSorted = new ArrayList < Cell > ( sorted ) ; 
 + List < Cell > reverseSorted = new ArrayList < > ( sorted ) ; 
 Collections . reverse ( reverseSorted ) ; 
 
 for ( int i = 0 ; i < values . length ; + + i ) 
 - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; 
 
 assertSame ( sorted , map . getSortedColumns ( ) ) ; 
 assertSame ( reverseSorted , map . getReverseSortedColumns ( ) ) ; 
 @ @ - 141 , 7 + 136 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 int [ ] values = new int [ ] { 1 , 2 , 3 , 5 , 9 } ; 
 
 for ( int i = 0 ; i < values . length ; + + i ) 
 - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; 
 
 assertSame ( new int [ ] { 3 , 2 , 1 } , map . reverseIterator ( new ColumnSlice [ ] { new ColumnSlice ( type . make ( 3 ) , Composites . EMPTY ) } ) ) ; 
 assertSame ( new int [ ] { 3 , 2 , 1 } , map . reverseIterator ( new ColumnSlice [ ] { new ColumnSlice ( type . make ( 4 ) , Composites . EMPTY ) } ) ) ; 
 @ @ - 187 , 7 + 182 , 7 @ @ public class ArrayBackedSortedColumnsTest extends SchemaLoader 
 int [ ] values = new int [ ] { 1 , 2 , 2 , 3 } ; 
 
 for ( int i = 0 ; i < values . length ; + + i ) 
 - map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) , HeapAllocator . instance ) ; 
 + map . addColumn ( new Cell ( type . makeCellName ( values [ reversed ? values . length - 1 - i : i ] ) ) ) ; 
 
 Iterator < Cell > iter = map . getReverseSortedColumns ( ) . iterator ( ) ; 
 assertTrue ( iter . hasNext ( ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java 
 index cd79217 . . ae2a461 100644 
 - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyTest . java 
 @ @ - 25 , 21 + 25 , 18 @ @ import java . nio . ByteBuffer ; 
 import java . util . * ; 
 
 import com . google . common . collect . Iterables ; 
 - 
 - import org . apache . cassandra . SchemaLoader ; 
 import org . junit . Test ; 
 
 + import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . io . sstable . ColumnStats ; 
 import org . apache . cassandra . io . util . DataOutputBuffer ; 
 import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 import static org . apache . cassandra . Util . column ; 
 import static org . apache . cassandra . Util . cellname ; 
 import static org . junit . Assert . assertEquals ; 
 
 - import org . apache . cassandra . utils . ByteBufferUtil ; 
 - import org . apache . cassandra . utils . memory . HeapAllocator ; 
 - 
 - 
 public class ColumnFamilyTest extends SchemaLoader 
 { 
 static int version = MessagingService . current _ version ; 
 @ @ - 68 , 7 + 65 , 7 @ @ public class ColumnFamilyTest extends SchemaLoader 
 { 
 ColumnFamily cf ; 
 
 - TreeMap < String , String > map = new TreeMap < String , String > ( ) ; 
 + TreeMap < String , String > map = new TreeMap < > ( ) ; 
 for ( int i = 100 ; i < 1000 ; + + i ) 
 { 
 map . put ( Integer . toString ( i ) , " Avinash Lakshman is a good man : " + i ) ; 
 @ @ - 134 , 8 + 131 , 8 @ @ public class ColumnFamilyTest extends SchemaLoader 
 cf _ old . addColumn ( cellname ( " col2 " ) , val2 , 1 ) ; 
 cf _ old . addColumn ( cellname ( " col3 " ) , val2 , 2 ) ; 
 
 - cf _ result . addAll ( cf _ new , HeapAllocator . instance ) ; 
 - cf _ result . addAll ( cf _ old , HeapAllocator . instance ) ; 
 + cf _ result . addAll ( cf _ new ) ; 
 + cf _ result . addAll ( cf _ old ) ; 
 
 assert 3 = = cf _ result . getColumnCount ( ) : " Count is " + cf _ new . getColumnCount ( ) ; 
 / / addcolumns will only add if timestamp > = old timestamp

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 115ee45 . . d73849c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 3 + 1 , 7 @ @ 
 + 1 . 2 . 0 
 + * cqlsh : add DESCRIBE KEYSPACES command ( CASSANDRA - 5060 ) 
 + 
 + 
 1 . 2 - rc1 
 * rename rpc _ timeout settings to request _ timeout ( CASSANDRA - 5027 ) 
 * add BF with 0 . 1 FP to LCS by default ( CASSANDRA - 5029 ) 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 611f6af . . f74dc42 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 211 , 7 + 211 , 8 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' 
 ; 
 
 < describeCommand > : : = ( " DESCRIBE " | " DESC " ) 
 - ( " KEYSPACE " ksname = < keyspaceName > ? 
 + ( " KEYSPACES " 
 + | " KEYSPACE " ksname = < keyspaceName > ? 
 | ( " COLUMNFAMILY " | " TABLE " ) cf = < columnFamilyName > 
 | ( " COLUMNFAMILIES " | " TABLES " ) 
 | " SCHEMA " 
 @ @ - 1328 , 6 + 1329 , 11 @ @ class Shell ( cmd . Cmd ) : 
 out . write ( ' CREATE INDEX % s ON % s ( % s ) ; \ n ' 
 % ( col . index _ name , cfname , self . cql _ protect _ name ( col . name ) ) ) 
 
 + def describe _ keyspaces ( self ) : 
 + print 
 + cmd . Cmd . columnize ( self , self . get _ keyspace _ names ( ) ) 
 + print 
 + 
 def describe _ keyspace ( self , ksname ) : 
 print 
 self . print _ recreate _ keyspace ( self . get _ keyspace ( ksname ) , sys . stdout ) 
 @ @ - 1381 , 6 + 1387 , 10 @ @ class Shell ( cmd . Cmd ) : 
 Outputs information about the connected Cassandra cluster , or about 
 the data stored on it . Use in one of the following ways : 
 
 + DESCRIBE KEYSPACES 
 + 
 + Output the names of all keyspaces . 
 + 
 DESCRIBE KEYSPACE [ < keyspacename > ] 
 
 Output CQL commands that could be used to recreate the given 
 @ @ - 1416 , 6 + 1426 , 8 @ @ class Shell ( cmd . Cmd ) : 
 k . 
 " " " 
 what = parsed . matched [ 1 ] [ 1 ] . lower ( ) 
 + if what = = ' keyspaces ' : 
 + self . describe _ keyspaces ( ) 
 if what = = ' keyspace ' : 
 ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) 
 if not ksname :
