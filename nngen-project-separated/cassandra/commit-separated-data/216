BLEU SCORE: 0.040583489434387374

TEST MSG: Avoid exposing compaction strategy index externally
GENERATED MSG: acquire references on overlapped sstables

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5a1b891 . . 8a6b61a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 11 . 2 <nl> + * Avoid exposing compaction strategy index externally ( CASSANDRA - 14082 ) <nl> * Prevent continuous schema exchange between 3 . 0 and 3 . 11 nodes ( CASSANDRA - 14109 ) <nl> * Fix imbalanced disks when replacing node with same address with JBOD ( CASSANDRA - 14084 ) <nl> * Reload compaction strategies when disk boundaries are invalidated ( CASSANDRA - 13948 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 9cd18a9 . . e158982 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 520 , 7 + 520 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return AllSSTableOpStatus . ABORTED ; <nl> } <nl> <nl> - final List < PartitionPosition > diskBoundaries = cfs . getDiskBoundaries ( ) . positions ; <nl> + final DiskBoundaries diskBoundaries = cfs . getDiskBoundaries ( ) ; <nl> <nl> return parallelAllSSTableOperation ( cfs , new OneSSTableOperation ( ) <nl> { <nl> @ @ - 531 , 8 + 531 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> Set < SSTableReader > needsRelocation = originals . stream ( ) . filter ( s - > ! inCorrectLocation ( s ) ) . collect ( Collectors . toSet ( ) ) ; <nl> transaction . cancel ( Sets . difference ( originals , needsRelocation ) ) ; <nl> <nl> - Map < Integer , List < SSTableReader > > groupedByDisk = needsRelocation . stream ( ) . collect ( Collectors . groupingBy ( ( s ) - > <nl> - cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( s ) ) ) ; <nl> + Map < Integer , List < SSTableReader > > groupedByDisk = groupByDiskIndex ( needsRelocation ) ; <nl> <nl> int maxSize = 0 ; <nl> for ( List < SSTableReader > diskSSTables : groupedByDisk . values ( ) ) <nl> @ @ - 548 , 18 + 547 , 23 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return mixedSSTables ; <nl> } <nl> <nl> + public Map < Integer , List < SSTableReader > > groupByDiskIndex ( Set < SSTableReader > needsRelocation ) <nl> + { <nl> + return needsRelocation . stream ( ) . collect ( Collectors . groupingBy ( ( s ) - > diskBoundaries . getDiskIndex ( s ) ) ) ; <nl> + } <nl> + <nl> private boolean inCorrectLocation ( SSTableReader sstable ) <nl> { <nl> if ( ! cfs . getPartitioner ( ) . splitter ( ) . isPresent ( ) ) <nl> return true ; <nl> - int directoryIndex = cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( sstable ) ; <nl> - Directories . DataDirectory [ ] locations = cfs . getDirectories ( ) . getWriteableLocations ( ) ; <nl> <nl> - Directories . DataDirectory location = locations [ directoryIndex ] ; <nl> - PartitionPosition diskLast = diskBoundaries . get ( directoryIndex ) ; <nl> + int diskIndex = diskBoundaries . getDiskIndex ( sstable ) ; <nl> + File diskLocation = diskBoundaries . directories . get ( diskIndex ) . location ; <nl> + PartitionPosition diskLast = diskBoundaries . positions . get ( diskIndex ) ; <nl> + <nl> / / the location we get from directoryIndex is based on the first key in the sstable <nl> / / now we need to make sure the last key is less than the boundary as well : <nl> - return sstable . descriptor . directory . getAbsolutePath ( ) . startsWith ( location . location . getAbsolutePath ( ) ) & & sstable . last . compareTo ( diskLast ) < = 0 ; <nl> + return sstable . descriptor . directory . getAbsolutePath ( ) . startsWith ( diskLocation . getAbsolutePath ( ) ) & & sstable . last . compareTo ( diskLast ) < = 0 ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> index efaedc8 . . 39d253b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> @ @ - 271 , 12 + 271 , 6 @ @ public class CompactionStrategyManager implements INotificationConsumer <nl> * @ param sstable <nl> * @ return <nl> * / <nl> - public int getCompactionStrategyIndex ( SSTableReader sstable ) <nl> - { <nl> - maybeReloadDiskBoundaries ( ) ; <nl> - return compactionStrategyIndexFor ( sstable ) ; <nl> - } <nl> - <nl> @ VisibleForTesting <nl> protected int compactionStrategyIndexFor ( SSTableReader sstable ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / Scrubber . java b / src / java / org / apache / cassandra / db / compaction / Scrubber . java <nl> index c189c0b . . ed107d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / Scrubber . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / Scrubber . java <nl> @ @ - 99 , 8 + 99 , 8 @ @ public class Scrubber implements Closeable <nl> <nl> List < SSTableReader > toScrub = Collections . singletonList ( sstable ) ; <nl> <nl> - int locIndex = cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( sstable ) ; <nl> - this . destination = cfs . getDirectories ( ) . getLocationForDisk ( cfs . getDirectories ( ) . getWriteableLocations ( ) [ locIndex ] ) ; <nl> + <nl> + this . destination = cfs . getDirectories ( ) . getLocationForDisk ( cfs . getDiskBoundaries ( ) . getCorrectDiskForSSTable ( sstable ) ) ; <nl> this . isCommutative = cfs . metadata . isCounter ( ) ; <nl> <nl> boolean hasIndexFile = ( new File ( sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) . exists ( ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3b80885 . . f6769fe 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 1 . 2 - rc1 <nl> + * Fix rare race condition in getExpireTimeForEndpoint ( CASSANDRA - 4402 ) <nl> * acquire references to overlapping sstables during compaction so bloom filter <nl> doesn ' t get free ' d prematurely ( CASSANDRA - 4934 ) <nl> * Don ' t share slice query filter in CQL3 SelectStatement ( CASSANDRA - 4928 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index 85611de . . 18b7e4b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . ConcurrentMap ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> @ @ - 71 , 7 + 72 , 7 @ @ public class Table <nl> / * Table name . * / <nl> public final String name ; <nl> / * ColumnFamilyStore per column family * / <nl> - private final Map < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; <nl> + private final ConcurrentMap < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; <nl> private final Object [ ] indexLocks ; <nl> private volatile AbstractReplicationStrategy replicationStrategy ; <nl> <nl> @ @ - 319 , 19 + 320 , 25 @ @ public class Table <nl> * / <nl> public void initCf ( UUID cfId , String cfName , boolean loadSSTables ) <nl> { <nl> - if ( columnFamilyStores . containsKey ( cfId ) ) <nl> - { <nl> - / / this is the case when you reset local schema <nl> - / / just reload metadata <nl> - ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; <nl> - assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; <nl> + ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; <nl> <nl> - cfs . metadata . reload ( ) ; <nl> - cfs . reload ( ) ; <nl> + if ( cfs = = null ) <nl> + { <nl> + / / CFS being created for the first time , either on server startup or new CF being added . <nl> + / / We don ' t worry about races here ; startup is safe , and adding multiple idential CFs <nl> + / / simultaneously is a " don ' t do that " scenario . <nl> + ColumnFamilyStore oldCfs = columnFamilyStores . putIfAbsent ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; <nl> + / / CFS mbean instantiation will error out before we hit this , but in case that changes . . . <nl> + if ( oldCfs ! = null ) <nl> + throw new IllegalStateException ( " added multiple mappings for cf id " + cfId ) ; <nl> } <nl> else <nl> { <nl> - columnFamilyStores . put ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; <nl> + / / re - initializing an existing CF . This will happen if you cleared the schema <nl> + / / on this node and it ' s getting repopulated from the rest of the cluster . <nl> + assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; <nl> + cfs . metadata . reload ( ) ; <nl> + cfs . reload ( ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index e49a6b3 . . 5880210 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . * ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 90 , 7 + 91 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> private final Set < InetAddress > seeds = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; <nl> <nl> / * map where key is the endpoint and value is the state associated with the endpoint * / <nl> - final Map < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; <nl> + final ConcurrentMap < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; <nl> <nl> / * map where key is endpoint and value is timestamp when this endpoint was removed from <nl> * gossip . We will ignore any gossip regarding these endpoints for QUARANTINE _ DELAY time <nl> @ @ - 601 , 12 + 602 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> protected long getExpireTimeForEndpoint ( InetAddress endpoint ) <nl> { <nl> / * default expireTime is aVeryLongTime * / <nl> - long expireTime = computeExpireTime ( ) ; <nl> - if ( expireTimeEndpointMap . containsKey ( endpoint ) ) <nl> - { <nl> - expireTime = expireTimeEndpointMap . get ( endpoint ) ; <nl> - } <nl> - return expireTime ; <nl> + Long storedTime = expireTimeEndpointMap . get ( endpoint ) ; <nl> + return storedTime = = null ? computeExpireTime ( ) : storedTime ; <nl> } <nl> <nl> public EndpointState getEndpointStateForEndpoint ( InetAddress ep ) <nl> @ @ - 1031 , 17 + 1028 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> TimeUnit . MILLISECONDS ) ; <nl> } <nl> <nl> - / / initialize local HB state if needed . <nl> + / / initialize local HB state if needed , i . e . , if gossiper has never been started before . <nl> public void maybeInitializeLocalState ( int generationNbr ) <nl> { <nl> - EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - if ( localState = = null ) <nl> - { <nl> - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> - localState = new EndpointState ( hbState ) ; <nl> - localState . markAlive ( ) ; <nl> - endpointStateMap . put ( FBUtilities . getBroadcastAddress ( ) , localState ) ; <nl> - } <nl> + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> + EndpointState localState = new EndpointState ( hbState ) ; <nl> + localState . markAlive ( ) ; <nl> + endpointStateMap . putIfAbsent ( FBUtilities . getBroadcastAddress ( ) , localState ) ; <nl> } <nl> <nl> <nl> @ @ - 1093 , 27 + 1086 , 20 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> return ( scheduledGossipTask ! = null ) & & ( ! scheduledGossipTask . isCancelled ( ) ) ; <nl> } <nl> <nl> - / * * <nl> - * This should * only * be used for testing purposes . <nl> - * / <nl> - public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) { <nl> - / * initialize the heartbeat state for this localEndpoint * / <nl> - EndpointState localState = endpointStateMap . get ( addr ) ; <nl> - if ( localState = = null ) <nl> - { <nl> - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> - localState = new EndpointState ( hbState ) ; <nl> - localState . markAlive ( ) ; <nl> - endpointStateMap . put ( addr , localState ) ; <nl> - } <nl> + @ VisibleForTesting <nl> + public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) <nl> + { <nl> + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; <nl> + EndpointState localState = new EndpointState ( hbState ) ; <nl> + localState . markAlive ( ) ; <nl> + endpointStateMap . putIfAbsent ( addr , localState ) ; <nl> + <nl> / / always add the version state <nl> localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; <nl> localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; <nl> } <nl> <nl> - / * * <nl> - * This should * only * be used for testing purposes <nl> - * / <nl> + @ VisibleForTesting <nl> public void injectApplicationState ( InetAddress endpoint , ApplicationState state , VersionedValue value ) <nl> { <nl> EndpointState localState = endpointStateMap . get ( endpoint ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5a1b891 . . 8a6b61a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 11 . 2 
 + * Avoid exposing compaction strategy index externally ( CASSANDRA - 14082 ) 
 * Prevent continuous schema exchange between 3 . 0 and 3 . 11 nodes ( CASSANDRA - 14109 ) 
 * Fix imbalanced disks when replacing node with same address with JBOD ( CASSANDRA - 14084 ) 
 * Reload compaction strategies when disk boundaries are invalidated ( CASSANDRA - 13948 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 9cd18a9 . . e158982 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 520 , 7 + 520 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return AllSSTableOpStatus . ABORTED ; 
 } 
 
 - final List < PartitionPosition > diskBoundaries = cfs . getDiskBoundaries ( ) . positions ; 
 + final DiskBoundaries diskBoundaries = cfs . getDiskBoundaries ( ) ; 
 
 return parallelAllSSTableOperation ( cfs , new OneSSTableOperation ( ) 
 { 
 @ @ - 531 , 8 + 531 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 Set < SSTableReader > needsRelocation = originals . stream ( ) . filter ( s - > ! inCorrectLocation ( s ) ) . collect ( Collectors . toSet ( ) ) ; 
 transaction . cancel ( Sets . difference ( originals , needsRelocation ) ) ; 
 
 - Map < Integer , List < SSTableReader > > groupedByDisk = needsRelocation . stream ( ) . collect ( Collectors . groupingBy ( ( s ) - > 
 - cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( s ) ) ) ; 
 + Map < Integer , List < SSTableReader > > groupedByDisk = groupByDiskIndex ( needsRelocation ) ; 
 
 int maxSize = 0 ; 
 for ( List < SSTableReader > diskSSTables : groupedByDisk . values ( ) ) 
 @ @ - 548 , 18 + 547 , 23 @ @ public class CompactionManager implements CompactionManagerMBean 
 return mixedSSTables ; 
 } 
 
 + public Map < Integer , List < SSTableReader > > groupByDiskIndex ( Set < SSTableReader > needsRelocation ) 
 + { 
 + return needsRelocation . stream ( ) . collect ( Collectors . groupingBy ( ( s ) - > diskBoundaries . getDiskIndex ( s ) ) ) ; 
 + } 
 + 
 private boolean inCorrectLocation ( SSTableReader sstable ) 
 { 
 if ( ! cfs . getPartitioner ( ) . splitter ( ) . isPresent ( ) ) 
 return true ; 
 - int directoryIndex = cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( sstable ) ; 
 - Directories . DataDirectory [ ] locations = cfs . getDirectories ( ) . getWriteableLocations ( ) ; 
 
 - Directories . DataDirectory location = locations [ directoryIndex ] ; 
 - PartitionPosition diskLast = diskBoundaries . get ( directoryIndex ) ; 
 + int diskIndex = diskBoundaries . getDiskIndex ( sstable ) ; 
 + File diskLocation = diskBoundaries . directories . get ( diskIndex ) . location ; 
 + PartitionPosition diskLast = diskBoundaries . positions . get ( diskIndex ) ; 
 + 
 / / the location we get from directoryIndex is based on the first key in the sstable 
 / / now we need to make sure the last key is less than the boundary as well : 
 - return sstable . descriptor . directory . getAbsolutePath ( ) . startsWith ( location . location . getAbsolutePath ( ) ) & & sstable . last . compareTo ( diskLast ) < = 0 ; 
 + return sstable . descriptor . directory . getAbsolutePath ( ) . startsWith ( diskLocation . getAbsolutePath ( ) ) & & sstable . last . compareTo ( diskLast ) < = 0 ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 index efaedc8 . . 39d253b 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 @ @ - 271 , 12 + 271 , 6 @ @ public class CompactionStrategyManager implements INotificationConsumer 
 * @ param sstable 
 * @ return 
 * / 
 - public int getCompactionStrategyIndex ( SSTableReader sstable ) 
 - { 
 - maybeReloadDiskBoundaries ( ) ; 
 - return compactionStrategyIndexFor ( sstable ) ; 
 - } 
 - 
 @ VisibleForTesting 
 protected int compactionStrategyIndexFor ( SSTableReader sstable ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / Scrubber . java b / src / java / org / apache / cassandra / db / compaction / Scrubber . java 
 index c189c0b . . ed107d7 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / Scrubber . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / Scrubber . java 
 @ @ - 99 , 8 + 99 , 8 @ @ public class Scrubber implements Closeable 
 
 List < SSTableReader > toScrub = Collections . singletonList ( sstable ) ; 
 
 - int locIndex = cfs . getCompactionStrategyManager ( ) . getCompactionStrategyIndex ( sstable ) ; 
 - this . destination = cfs . getDirectories ( ) . getLocationForDisk ( cfs . getDirectories ( ) . getWriteableLocations ( ) [ locIndex ] ) ; 
 + 
 + this . destination = cfs . getDirectories ( ) . getLocationForDisk ( cfs . getDiskBoundaries ( ) . getCorrectDiskForSSTable ( sstable ) ) ; 
 this . isCommutative = cfs . metadata . isCounter ( ) ; 
 
 boolean hasIndexFile = ( new File ( sstable . descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ) . exists ( ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3b80885 . . f6769fe 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 1 . 2 - rc1 
 + * Fix rare race condition in getExpireTimeForEndpoint ( CASSANDRA - 4402 ) 
 * acquire references to overlapping sstables during compaction so bloom filter 
 doesn ' t get free ' d prematurely ( CASSANDRA - 4934 ) 
 * Don ' t share slice query filter in CQL3 SelectStatement ( CASSANDRA - 4928 ) 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index 85611de . . 18b7e4b 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . ConcurrentMap ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 @ @ - 71 , 7 + 72 , 7 @ @ public class Table 
 / * Table name . * / 
 public final String name ; 
 / * ColumnFamilyStore per column family * / 
 - private final Map < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; 
 + private final ConcurrentMap < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < UUID , ColumnFamilyStore > ( ) ; 
 private final Object [ ] indexLocks ; 
 private volatile AbstractReplicationStrategy replicationStrategy ; 
 
 @ @ - 319 , 19 + 320 , 25 @ @ public class Table 
 * / 
 public void initCf ( UUID cfId , String cfName , boolean loadSSTables ) 
 { 
 - if ( columnFamilyStores . containsKey ( cfId ) ) 
 - { 
 - / / this is the case when you reset local schema 
 - / / just reload metadata 
 - ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; 
 - assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; 
 + ColumnFamilyStore cfs = columnFamilyStores . get ( cfId ) ; 
 
 - cfs . metadata . reload ( ) ; 
 - cfs . reload ( ) ; 
 + if ( cfs = = null ) 
 + { 
 + / / CFS being created for the first time , either on server startup or new CF being added . 
 + / / We don ' t worry about races here ; startup is safe , and adding multiple idential CFs 
 + / / simultaneously is a " don ' t do that " scenario . 
 + ColumnFamilyStore oldCfs = columnFamilyStores . putIfAbsent ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; 
 + / / CFS mbean instantiation will error out before we hit this , but in case that changes . . . 
 + if ( oldCfs ! = null ) 
 + throw new IllegalStateException ( " added multiple mappings for cf id " + cfId ) ; 
 } 
 else 
 { 
 - columnFamilyStores . put ( cfId , ColumnFamilyStore . createColumnFamilyStore ( this , cfName , loadSSTables ) ) ; 
 + / / re - initializing an existing CF . This will happen if you cleared the schema 
 + / / on this node and it ' s getting repopulated from the rest of the cluster . 
 + assert cfs . getColumnFamilyName ( ) . equals ( cfName ) ; 
 + cfs . metadata . reload ( ) ; 
 + cfs . reload ( ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index e49a6b3 . . 5880210 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . * ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 + import com . google . common . annotations . VisibleForTesting ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 90 , 7 + 91 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 private final Set < InetAddress > seeds = new ConcurrentSkipListSet < InetAddress > ( inetcomparator ) ; 
 
 / * map where key is the endpoint and value is the state associated with the endpoint * / 
 - final Map < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; 
 + final ConcurrentMap < InetAddress , EndpointState > endpointStateMap = new ConcurrentHashMap < InetAddress , EndpointState > ( ) ; 
 
 / * map where key is endpoint and value is timestamp when this endpoint was removed from 
 * gossip . We will ignore any gossip regarding these endpoints for QUARANTINE _ DELAY time 
 @ @ - 601 , 12 + 602 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 protected long getExpireTimeForEndpoint ( InetAddress endpoint ) 
 { 
 / * default expireTime is aVeryLongTime * / 
 - long expireTime = computeExpireTime ( ) ; 
 - if ( expireTimeEndpointMap . containsKey ( endpoint ) ) 
 - { 
 - expireTime = expireTimeEndpointMap . get ( endpoint ) ; 
 - } 
 - return expireTime ; 
 + Long storedTime = expireTimeEndpointMap . get ( endpoint ) ; 
 + return storedTime = = null ? computeExpireTime ( ) : storedTime ; 
 } 
 
 public EndpointState getEndpointStateForEndpoint ( InetAddress ep ) 
 @ @ - 1031 , 17 + 1028 , 13 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 TimeUnit . MILLISECONDS ) ; 
 } 
 
 - / / initialize local HB state if needed . 
 + / / initialize local HB state if needed , i . e . , if gossiper has never been started before . 
 public void maybeInitializeLocalState ( int generationNbr ) 
 { 
 - EndpointState localState = endpointStateMap . get ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - if ( localState = = null ) 
 - { 
 - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 - localState = new EndpointState ( hbState ) ; 
 - localState . markAlive ( ) ; 
 - endpointStateMap . put ( FBUtilities . getBroadcastAddress ( ) , localState ) ; 
 - } 
 + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 + EndpointState localState = new EndpointState ( hbState ) ; 
 + localState . markAlive ( ) ; 
 + endpointStateMap . putIfAbsent ( FBUtilities . getBroadcastAddress ( ) , localState ) ; 
 } 
 
 
 @ @ - 1093 , 27 + 1086 , 20 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 return ( scheduledGossipTask ! = null ) & & ( ! scheduledGossipTask . isCancelled ( ) ) ; 
 } 
 
 - / * * 
 - * This should * only * be used for testing purposes . 
 - * / 
 - public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) { 
 - / * initialize the heartbeat state for this localEndpoint * / 
 - EndpointState localState = endpointStateMap . get ( addr ) ; 
 - if ( localState = = null ) 
 - { 
 - HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 - localState = new EndpointState ( hbState ) ; 
 - localState . markAlive ( ) ; 
 - endpointStateMap . put ( addr , localState ) ; 
 - } 
 + @ VisibleForTesting 
 + public void initializeNodeUnsafe ( InetAddress addr , UUID uuid , int generationNbr ) 
 + { 
 + HeartBeatState hbState = new HeartBeatState ( generationNbr ) ; 
 + EndpointState localState = new EndpointState ( hbState ) ; 
 + localState . markAlive ( ) ; 
 + endpointStateMap . putIfAbsent ( addr , localState ) ; 
 + 
 / / always add the version state 
 localState . addApplicationState ( ApplicationState . NET _ VERSION , StorageService . instance . valueFactory . networkVersion ( ) ) ; 
 localState . addApplicationState ( ApplicationState . HOST _ ID , StorageService . instance . valueFactory . hostId ( uuid ) ) ; 
 } 
 
 - / * * 
 - * This should * only * be used for testing purposes 
 - * / 
 + @ VisibleForTesting 
 public void injectApplicationState ( InetAddress endpoint , ApplicationState state , VersionedValue value ) 
 { 
 EndpointState localState = endpointStateMap . get ( endpoint ) ;
