BLEU SCORE: 0.03283637368030199

TEST MSG: Follow - up to CASSANDRA - 8143
GENERATED MSG: Fix CQLSSTableWriter throwing exception and spawning threads

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java <nl> index bcfac1b . . df4e984 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Schema . java <nl> + + + b / src / java / org / apache / cassandra / config / Schema . java <nl> @ @ - 91 , 8 + 91 , 11 @ @ public class Schema <nl> * / <nl> public Schema ( ) <nl> { <nl> - load ( SchemaKeyspace . metadata ( ) ) ; <nl> - load ( SystemKeyspace . metadata ( ) ) ; <nl> + if ( ! Config . isClientMode ( ) ) <nl> + { <nl> + load ( SchemaKeyspace . metadata ( ) ) ; <nl> + load ( SystemKeyspace . metadata ( ) ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 581 , 7 + 584 , 7 @ @ public class Schema <nl> Keyspace . clear ( ksm . name ) ; <nl> clearKeyspaceMetadata ( ksm ) ; <nl> <nl> - keyspace . writeOrder . awaitNewBarrier ( ) ; <nl> + Keyspace . writeOrder . awaitNewBarrier ( ) ; <nl> <nl> / / force a new segment in the CL <nl> CommitLog . instance . forceRecycleAllSegments ( droppedCfs ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java <nl> index 04cdc21 . . ebf28a4 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java <nl> @ @ - 370 , 6 + 370 , 12 @ @ public abstract class SSTableReader extends SSTable implements SelfRefCounted < SS <nl> return open ( descriptor , components , cfs . metadata , false , false ) ; / / do not track hotness <nl> } <nl> <nl> + / / use only for offline or " Standalone " operations <nl> + public static SSTableReader openNoValidation ( Descriptor descriptor , CFMetaData metadata ) throws IOException <nl> + { <nl> + return open ( descriptor , componentsFor ( descriptor ) , metadata , false , false ) ; / / do not track hotness <nl> + } <nl> + <nl> / * * <nl> * Open SSTable reader to be used in batch mode ( such as sstableloader ) . <nl> * <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java b / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java <nl> new file mode 100644 <nl> index 0000000 . . 661fcd5 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java <nl> @ @ - 0 , 0 + 1 , 135 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . io . sstable . format ; <nl> + <nl> + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; <nl> + <nl> + import java . io . File ; <nl> + import java . nio . ByteBuffer ; <nl> + <nl> + import com . google . common . util . concurrent . Runnables ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . Config ; <nl> + import org . apache . cassandra . db . filter . ColumnFilter ; <nl> + import org . apache . cassandra . db . marshal . BytesType ; <nl> + import org . apache . cassandra . db . rows . SliceableUnfilteredRowIterator ; <nl> + import org . apache . cassandra . dht . ByteOrderedPartitioner ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . io . sstable . Descriptor ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableFormat ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . io . sstable . format . Version ; <nl> + <nl> + / * * <nl> + * Tests backwards compatibility for SSTables <nl> + * / <nl> + public class ClientModeSSTableTest <nl> + { <nl> + public static final String LEGACY _ SSTABLE _ PROP = " legacy - sstable - root " ; <nl> + public static final String KSNAME = " Keyspace1 " ; <nl> + public static final String CFNAME = " Standard1 " ; <nl> + <nl> + public static File LEGACY _ SSTABLE _ ROOT ; <nl> + <nl> + static CFMetaData metadata ; <nl> + <nl> + @ BeforeClass <nl> + public static void defineSchema ( ) throws ConfigurationException <nl> + { <nl> + Config . setClientMode ( true ) ; <nl> + <nl> + metadata = CFMetaData . Builder . createDense ( KSNAME , CFNAME , false , false ) <nl> + . addPartitionKey ( " key " , BytesType . instance ) <nl> + . addClusteringColumn ( " column " , BytesType . instance ) <nl> + . addRegularColumn ( " value " , BytesType . instance ) <nl> + . withPartitioner ( ByteOrderedPartitioner . instance ) <nl> + . build ( ) ; <nl> + <nl> + String scp = System . getProperty ( LEGACY _ SSTABLE _ PROP ) ; <nl> + assert scp ! = null ; <nl> + LEGACY _ SSTABLE _ ROOT = new File ( scp ) . getAbsoluteFile ( ) ; <nl> + assert LEGACY _ SSTABLE _ ROOT . isDirectory ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Get a descriptor for the legacy sstable at the given version . <nl> + * / <nl> + protected Descriptor getDescriptor ( String ver ) <nl> + { <nl> + File directory = new File ( LEGACY _ SSTABLE _ ROOT + File . separator + ver + File . separator + KSNAME ) ; <nl> + return new Descriptor ( ver , directory , KSNAME , CFNAME , 0 , SSTableFormat . Type . LEGACY ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testVersions ( ) throws Throwable <nl> + { <nl> + boolean notSkipped = false ; <nl> + <nl> + for ( File version : LEGACY _ SSTABLE _ ROOT . listFiles ( ) ) <nl> + { <nl> + if ( ! new File ( LEGACY _ SSTABLE _ ROOT + File . separator + version . getName ( ) + File . separator + KSNAME ) . isDirectory ( ) ) <nl> + continue ; <nl> + if ( Version . validate ( version . getName ( ) ) & & SSTableFormat . Type . LEGACY . info . getVersion ( version . getName ( ) ) . isCompatible ( ) ) <nl> + { <nl> + notSkipped = true ; <nl> + testVersion ( version . getName ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + assert notSkipped ; <nl> + } <nl> + <nl> + public void testVersion ( String version ) throws Throwable <nl> + { <nl> + SSTableReader reader = null ; <nl> + try <nl> + { <nl> + reader = SSTableReader . openNoValidation ( getDescriptor ( version ) , metadata ) ; <nl> + <nl> + ByteBuffer key = bytes ( Integer . toString ( 100 ) ) ; <nl> + <nl> + try ( SliceableUnfilteredRowIterator iter = reader . iterator ( metadata . decorateKey ( key ) , ColumnFilter . selection ( metadata . partitionColumns ( ) ) , false , false ) ) <nl> + { <nl> + assert iter . next ( ) . clustering ( ) . get ( 0 ) . equals ( key ) ; <nl> + } <nl> + } <nl> + catch ( Throwable e ) <nl> + { <nl> + System . err . println ( " Failed to read " + version ) ; <nl> + throw e ; <nl> + } <nl> + finally <nl> + { <nl> + if ( reader ! = null ) <nl> + { <nl> + int globalTidyCount = SSTableReader . GlobalTidy . lookup . size ( ) ; <nl> + reader . selfRef ( ) . release ( ) ; <nl> + assert reader . selfRef ( ) . globalCount ( ) = = 0 ; <nl> + <nl> + / / await clean - up to complete if started . <nl> + ScheduledExecutors . nonPeriodicTasks . submit ( Runnables . doNothing ( ) ) . get ( ) ; <nl> + / / Ensure clean - up completed . <nl> + assert SSTableReader . GlobalTidy . lookup . size ( ) < globalTidyCount ; <nl> + } <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java 
 index bcfac1b . . df4e984 100644 
 - - - a / src / java / org / apache / cassandra / config / Schema . java 
 + + + b / src / java / org / apache / cassandra / config / Schema . java 
 @ @ - 91 , 8 + 91 , 11 @ @ public class Schema 
 * / 
 public Schema ( ) 
 { 
 - load ( SchemaKeyspace . metadata ( ) ) ; 
 - load ( SystemKeyspace . metadata ( ) ) ; 
 + if ( ! Config . isClientMode ( ) ) 
 + { 
 + load ( SchemaKeyspace . metadata ( ) ) ; 
 + load ( SystemKeyspace . metadata ( ) ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 581 , 7 + 584 , 7 @ @ public class Schema 
 Keyspace . clear ( ksm . name ) ; 
 clearKeyspaceMetadata ( ksm ) ; 
 
 - keyspace . writeOrder . awaitNewBarrier ( ) ; 
 + Keyspace . writeOrder . awaitNewBarrier ( ) ; 
 
 / / force a new segment in the CL 
 CommitLog . instance . forceRecycleAllSegments ( droppedCfs ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java 
 index 04cdc21 . . ebf28a4 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / format / SSTableReader . java 
 @ @ - 370 , 6 + 370 , 12 @ @ public abstract class SSTableReader extends SSTable implements SelfRefCounted < SS 
 return open ( descriptor , components , cfs . metadata , false , false ) ; / / do not track hotness 
 } 
 
 + / / use only for offline or " Standalone " operations 
 + public static SSTableReader openNoValidation ( Descriptor descriptor , CFMetaData metadata ) throws IOException 
 + { 
 + return open ( descriptor , componentsFor ( descriptor ) , metadata , false , false ) ; / / do not track hotness 
 + } 
 + 
 / * * 
 * Open SSTable reader to be used in batch mode ( such as sstableloader ) . 
 * 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java b / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java 
 new file mode 100644 
 index 0000000 . . 661fcd5 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / io / sstable / format / ClientModeSSTableTest . java 
 @ @ - 0 , 0 + 1 , 135 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . io . sstable . format ; 
 + 
 + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; 
 + 
 + import java . io . File ; 
 + import java . nio . ByteBuffer ; 
 + 
 + import com . google . common . util . concurrent . Runnables ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . Config ; 
 + import org . apache . cassandra . db . filter . ColumnFilter ; 
 + import org . apache . cassandra . db . marshal . BytesType ; 
 + import org . apache . cassandra . db . rows . SliceableUnfilteredRowIterator ; 
 + import org . apache . cassandra . dht . ByteOrderedPartitioner ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . io . sstable . Descriptor ; 
 + import org . apache . cassandra . io . sstable . format . SSTableFormat ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . io . sstable . format . Version ; 
 + 
 + / * * 
 + * Tests backwards compatibility for SSTables 
 + * / 
 + public class ClientModeSSTableTest 
 + { 
 + public static final String LEGACY _ SSTABLE _ PROP = " legacy - sstable - root " ; 
 + public static final String KSNAME = " Keyspace1 " ; 
 + public static final String CFNAME = " Standard1 " ; 
 + 
 + public static File LEGACY _ SSTABLE _ ROOT ; 
 + 
 + static CFMetaData metadata ; 
 + 
 + @ BeforeClass 
 + public static void defineSchema ( ) throws ConfigurationException 
 + { 
 + Config . setClientMode ( true ) ; 
 + 
 + metadata = CFMetaData . Builder . createDense ( KSNAME , CFNAME , false , false ) 
 + . addPartitionKey ( " key " , BytesType . instance ) 
 + . addClusteringColumn ( " column " , BytesType . instance ) 
 + . addRegularColumn ( " value " , BytesType . instance ) 
 + . withPartitioner ( ByteOrderedPartitioner . instance ) 
 + . build ( ) ; 
 + 
 + String scp = System . getProperty ( LEGACY _ SSTABLE _ PROP ) ; 
 + assert scp ! = null ; 
 + LEGACY _ SSTABLE _ ROOT = new File ( scp ) . getAbsoluteFile ( ) ; 
 + assert LEGACY _ SSTABLE _ ROOT . isDirectory ( ) ; 
 + } 
 + 
 + / * * 
 + * Get a descriptor for the legacy sstable at the given version . 
 + * / 
 + protected Descriptor getDescriptor ( String ver ) 
 + { 
 + File directory = new File ( LEGACY _ SSTABLE _ ROOT + File . separator + ver + File . separator + KSNAME ) ; 
 + return new Descriptor ( ver , directory , KSNAME , CFNAME , 0 , SSTableFormat . Type . LEGACY ) ; 
 + } 
 + 
 + @ Test 
 + public void testVersions ( ) throws Throwable 
 + { 
 + boolean notSkipped = false ; 
 + 
 + for ( File version : LEGACY _ SSTABLE _ ROOT . listFiles ( ) ) 
 + { 
 + if ( ! new File ( LEGACY _ SSTABLE _ ROOT + File . separator + version . getName ( ) + File . separator + KSNAME ) . isDirectory ( ) ) 
 + continue ; 
 + if ( Version . validate ( version . getName ( ) ) & & SSTableFormat . Type . LEGACY . info . getVersion ( version . getName ( ) ) . isCompatible ( ) ) 
 + { 
 + notSkipped = true ; 
 + testVersion ( version . getName ( ) ) ; 
 + } 
 + } 
 + 
 + assert notSkipped ; 
 + } 
 + 
 + public void testVersion ( String version ) throws Throwable 
 + { 
 + SSTableReader reader = null ; 
 + try 
 + { 
 + reader = SSTableReader . openNoValidation ( getDescriptor ( version ) , metadata ) ; 
 + 
 + ByteBuffer key = bytes ( Integer . toString ( 100 ) ) ; 
 + 
 + try ( SliceableUnfilteredRowIterator iter = reader . iterator ( metadata . decorateKey ( key ) , ColumnFilter . selection ( metadata . partitionColumns ( ) ) , false , false ) ) 
 + { 
 + assert iter . next ( ) . clustering ( ) . get ( 0 ) . equals ( key ) ; 
 + } 
 + } 
 + catch ( Throwable e ) 
 + { 
 + System . err . println ( " Failed to read " + version ) ; 
 + throw e ; 
 + } 
 + finally 
 + { 
 + if ( reader ! = null ) 
 + { 
 + int globalTidyCount = SSTableReader . GlobalTidy . lookup . size ( ) ; 
 + reader . selfRef ( ) . release ( ) ; 
 + assert reader . selfRef ( ) . globalCount ( ) = = 0 ; 
 + 
 + / / await clean - up to complete if started . 
 + ScheduledExecutors . nonPeriodicTasks . submit ( Runnables . doNothing ( ) ) . get ( ) ; 
 + / / Ensure clean - up completed . 
 + assert SSTableReader . GlobalTidy . lookup . size ( ) < globalTidyCount ; 
 + } 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
