BLEU SCORE: 0.040583489434387374

TEST MSG: Fix nested Tuples / UDTs validation
GENERATED MSG: Properly reject unknown UDT fields

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c966c92 . . 08c6e48 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 11 <nl> + * Fix nested Tuples / UDTs validation ( CASSANDRA - 13646 ) <nl> * Remove unused max _ value _ size _ in _ mb config setting from yaml ( CASSANDRA - 13625 <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / UserTypes . java b / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> index de3f545 . . 6766d07 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> @ @ - 91 , 7 + 91 , 7 @ @ public abstract class UserTypes <nl> private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException <nl> { <nl> if ( ! ( receiver . type instanceof UserType ) ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver , receiver . type . asCQL3Type ( ) ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; <nl> <nl> UserType ut = ( UserType ) receiver . type ; <nl> for ( int i = 0 ; i < ut . size ( ) ; i + + ) <nl> @ @ - 103 , 7 + 103 , 7 @ @ public abstract class UserTypes <nl> <nl> ColumnSpecification fieldSpec = fieldSpecOf ( receiver , i ) ; <nl> if ( ! value . testAssignment ( keyspace , fieldSpec ) . isAssignable ( ) ) <nl> - throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : field % s is not of type % s " , receiver , field , fieldSpec . type . asCQL3Type ( ) ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : field % s is not of type % s " , receiver . name , field , fieldSpec . type . asCQL3Type ( ) ) ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / TupleType . java b / src / java / org / apache / cassandra / db / marshal / TupleType . java <nl> index 0d08a52 . . bf7eae4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / TupleType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / TupleType . java <nl> @ @ - 39 , 11 + 39 , 23 @ @ public class TupleType extends AbstractType < ByteBuffer > <nl> { <nl> protected final List < AbstractType < ? > > types ; <nl> <nl> + private final TupleSerializer serializer ; <nl> + <nl> public TupleType ( List < AbstractType < ? > > types ) <nl> { <nl> for ( int i = 0 ; i < types . size ( ) ; i + + ) <nl> types . set ( i , types . get ( i ) . freeze ( ) ) ; <nl> this . types = types ; <nl> + this . serializer = new TupleSerializer ( fieldSerializers ( types ) ) ; <nl> + } <nl> + <nl> + private static List < TypeSerializer < ? > > fieldSerializers ( List < AbstractType < ? > > types ) <nl> + { <nl> + int size = types . size ( ) ; <nl> + List < TypeSerializer < ? > > serializers = new ArrayList < > ( size ) ; <nl> + for ( int i = 0 ; i < size ; i + + ) <nl> + serializers . add ( types . get ( i ) . getSerializer ( ) ) ; <nl> + return serializers ; <nl> } <nl> <nl> public static TupleType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException <nl> @ @ - 119 , 37 + 131 , 6 @ @ public class TupleType extends AbstractType < ByteBuffer > <nl> return 1 ; <nl> } <nl> <nl> - @ Override <nl> - public void validate ( ByteBuffer bytes ) throws MarshalException <nl> - { <nl> - ByteBuffer input = bytes . duplicate ( ) ; <nl> - for ( int i = 0 ; i < size ( ) ; i + + ) <nl> - { <nl> - / / we allow the input to have less fields than declared so as to support field addition . <nl> - if ( ! input . hasRemaining ( ) ) <nl> - return ; <nl> - <nl> - if ( input . remaining ( ) < 4 ) <nl> - throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth component " , i ) ) ; <nl> - <nl> - int size = input . getInt ( ) ; <nl> - <nl> - / / size < 0 means null value <nl> - if ( size < 0 ) <nl> - continue ; <nl> - <nl> - if ( input . remaining ( ) < size ) <nl> - throw new MarshalException ( String . format ( " Not enough bytes to read % dth component " , i ) ) ; <nl> - <nl> - ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> - types . get ( i ) . validate ( field ) ; <nl> - } <nl> - <nl> - / / We ' re allowed to get less fields than declared , but not more <nl> - if ( input . hasRemaining ( ) ) <nl> - throw new MarshalException ( " Invalid remaining data after end of tuple value " ) ; <nl> - } <nl> - <nl> / * * <nl> * Split a tuple value into its component values . <nl> * / <nl> @ @ - 297 , 7 + 278 , 7 @ @ public class TupleType extends AbstractType < ByteBuffer > <nl> <nl> public TypeSerializer < ByteBuffer > getSerializer ( ) <nl> { <nl> - return BytesSerializer . instance ; <nl> + return serializer ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / UserType . java b / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> index 187deeb . . 93059cd 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> @ @ - 28 , 6 + 28 , 8 @ @ import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . exceptions . SyntaxException ; <nl> import org . apache . cassandra . serializers . MarshalException ; <nl> + import org . apache . cassandra . serializers . TypeSerializer ; <nl> + import org . apache . cassandra . serializers . UserTypeSerializer ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> @ @ - 42 , 6 + 44 , 7 @ @ public class UserType extends TupleType <nl> public final ByteBuffer name ; <nl> private final List < ByteBuffer > fieldNames ; <nl> private final List < String > stringFieldNames ; <nl> + private final UserTypeSerializer serializer ; <nl> <nl> public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > fieldNames , List < AbstractType < ? > > fieldTypes ) <nl> { <nl> @ @ - 51 , 17 + 54 , 22 @ @ public class UserType extends TupleType <nl> this . name = name ; <nl> this . fieldNames = fieldNames ; <nl> this . stringFieldNames = new ArrayList < > ( fieldNames . size ( ) ) ; <nl> - for ( ByteBuffer fieldName : fieldNames ) <nl> + LinkedHashMap < String , TypeSerializer < ? > > fieldSerializers = new LinkedHashMap < > ( fieldTypes . size ( ) ) ; <nl> + for ( int i = 0 , m = fieldNames . size ( ) ; i < m ; i + + ) <nl> { <nl> + ByteBuffer fieldName = fieldNames . get ( i ) ; <nl> try <nl> { <nl> - stringFieldNames . add ( ByteBufferUtil . string ( fieldName , StandardCharsets . UTF _ 8 ) ) ; <nl> + String stringFieldName = ByteBufferUtil . string ( fieldName , StandardCharsets . UTF _ 8 ) ; <nl> + stringFieldNames . add ( stringFieldName ) ; <nl> + fieldSerializers . put ( stringFieldName , fieldTypes . get ( i ) . getSerializer ( ) ) ; <nl> } <nl> catch ( CharacterCodingException ex ) <nl> { <nl> throw new AssertionError ( " Got non - UTF8 field name for user - defined type : " + ByteBufferUtil . bytesToHex ( fieldName ) , ex ) ; <nl> } <nl> } <nl> + this . serializer = new UserTypeSerializer ( fieldSerializers ) ; <nl> } <nl> <nl> public static UserType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException <nl> @ @ - 109 , 38 + 117 , 6 @ @ public class UserType extends TupleType <nl> return UTF8Type . instance . compose ( name ) ; <nl> } <nl> <nl> - / / Note : the only reason we override this is to provide nicer error message , but since that ' s not that much code . . . <nl> - @ Override <nl> - public void validate ( ByteBuffer bytes ) throws MarshalException <nl> - { <nl> - ByteBuffer input = bytes . duplicate ( ) ; <nl> - for ( int i = 0 ; i < size ( ) ; i + + ) <nl> - { <nl> - / / we allow the input to have less fields than declared so as to support field addition . <nl> - if ( ! input . hasRemaining ( ) ) <nl> - return ; <nl> - <nl> - if ( input . remaining ( ) < 4 ) <nl> - throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , fieldNameAsString ( i ) ) ) ; <nl> - <nl> - int size = input . getInt ( ) ; <nl> - <nl> - / / size < 0 means null value <nl> - if ( size < 0 ) <nl> - continue ; <nl> - <nl> - if ( input . remaining ( ) < size ) <nl> - throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , fieldNameAsString ( i ) ) ) ; <nl> - <nl> - ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> - types . get ( i ) . validate ( field ) ; <nl> - } <nl> - <nl> - / / We ' re allowed to get less fields than declared , but not more <nl> - if ( input . hasRemaining ( ) ) <nl> - throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; <nl> - } <nl> - <nl> @ Override <nl> public Term fromJSONObject ( Object parsed ) throws MarshalException <nl> { <nl> @ @ - 243 , 4 + 219 , 10 @ @ public class UserType extends TupleType <nl> { <nl> return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , fieldNames , types ) ; <nl> } <nl> + <nl> + @ Override <nl> + public TypeSerializer < ByteBuffer > getSerializer ( ) <nl> + { <nl> + return serializer ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / serializers / TupleSerializer . java b / src / java / org / apache / cassandra / serializers / TupleSerializer . java <nl> new file mode 100644 <nl> index 0000000 . . 7cf71c6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / serializers / TupleSerializer . java <nl> @ @ - 0 , 0 + 1 , 66 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . serializers ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + public class TupleSerializer extends BytesSerializer <nl> + { <nl> + public final List < TypeSerializer < ? > > fields ; <nl> + <nl> + public TupleSerializer ( List < TypeSerializer < ? > > fields ) <nl> + { <nl> + this . fields = fields ; <nl> + } <nl> + <nl> + @ Override <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + for ( int i = 0 ; i < fields . size ( ) ; i + + ) <nl> + { <nl> + / / we allow the input to have less fields than declared so as to support field addition . <nl> + if ( ! input . hasRemaining ( ) ) <nl> + return ; <nl> + <nl> + if ( input . remaining ( ) < 4 ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth component " , i ) ) ; <nl> + <nl> + int size = input . getInt ( ) ; <nl> + <nl> + / / size < 0 means null value <nl> + if ( size < 0 ) <nl> + continue ; <nl> + <nl> + if ( input . remaining ( ) < size ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read % dth component " , i ) ) ; <nl> + <nl> + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> + fields . get ( i ) . validate ( field ) ; <nl> + } <nl> + <nl> + / / We ' re allowed to get less fields than declared , but not more <nl> + if ( input . hasRemaining ( ) ) <nl> + throw new MarshalException ( " Invalid remaining data after end of tuple value " ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java b / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java <nl> new file mode 100644 <nl> index 0000000 . . 472e39b <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java <nl> @ @ - 0 , 0 + 1 , 67 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . serializers ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . LinkedHashMap ; <nl> + import java . util . Map . Entry ; <nl> + <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + public class UserTypeSerializer extends BytesSerializer <nl> + { <nl> + public final LinkedHashMap < String , TypeSerializer < ? > > fields ; <nl> + <nl> + public UserTypeSerializer ( LinkedHashMap < String , TypeSerializer < ? > > fields ) <nl> + { <nl> + this . fields = fields ; <nl> + } <nl> + <nl> + @ Override <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + int i = 0 ; <nl> + for ( Entry < String , TypeSerializer < ? > > entry : fields . entrySet ( ) ) <nl> + { <nl> + / / we allow the input to have less fields than declared so as to support field addition . <nl> + if ( ! input . hasRemaining ( ) ) <nl> + return ; <nl> + <nl> + if ( input . remaining ( ) < 4 ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , entry . getKey ( ) ) ) ; <nl> + <nl> + int size = input . getInt ( ) ; <nl> + <nl> + / / size < 0 means null value <nl> + if ( size < 0 ) <nl> + continue ; <nl> + <nl> + if ( input . remaining ( ) < size ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , entry . getKey ( ) ) ) ; <nl> + <nl> + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> + entry . getValue ( ) . validate ( field ) ; <nl> + i + + ; <nl> + } <nl> + <nl> + / / We ' re allowed to get less fields than declared , but not more <nl> + if ( input . hasRemaining ( ) ) <nl> + throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java <nl> index 99d9695 . . 69d5a5c 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java <nl> @ @ - 748 , 4 + 748 , 40 @ @ public class CollectionsTest extends CQLTester <nl> execute ( " UPDATE % s SET s = s - ? , s = s + ? WHERE pk = ? " , set ( 3 ) , set ( 3 , 4 ) , 1 ) ; <nl> assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 " ) , row ( 1 , set ( 0 , 1 , 2 , 4 ) ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testInsertingCollectionsWithInvalidElements ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , s frozen < set < tuple < int , text , double > > > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , s ) VALUES ( 0 , ? ) " , <nl> + set ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid set literal for s : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , s ) VALUES ( 0 , { ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l frozen < list < tuple < int , text , double > > > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , l ) VALUES ( 0 , ? ) " , <nl> + list ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid list literal for l : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , l ) VALUES ( 0 , [ ( 1 , ' 1 ' , 1 . 0 , 1 ) ] ) " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m frozen < map < tuple < int , text , double > , int > > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , <nl> + map ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , 1 , tuple ( 2 , " 2 " , 2 . 0 , 2 ) , 2 ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid map literal for m : key ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , m ) VALUES ( 0 , { ( 1 , ' 1 ' , 1 . 0 , 1 ) : 1 } ) " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m frozen < map < int , tuple < int , text , double > > > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , <nl> + map ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) , 2 , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid map literal for m : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , m ) VALUES ( 0 , { 1 : ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java <nl> index 0783dd1 . . 3b4fb40 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java <nl> @ @ - 123 , 6 + 123 , 14 @ @ public class TupleTypeTest extends CQLTester <nl> <nl> assertInvalidMessage ( " Invalid tuple literal for t : too many elements . Type tuple < int , text , double > expects 3 but got 4 " , <nl> " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 2 , ' foo ' , 3 . 1 , ' bar ' ) ) " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t frozen < tuple < int , tuple < int , text , double > > > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , t ) VALUES ( 0 , ? ) " , <nl> + tuple ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid tuple literal for t : component 1 is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 1 , ( 1 , ' 1 ' , 1 . 0 , 1 ) ) ) " ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 137 , 7 + 145 , 7 @ @ public class TupleTypeTest extends CQLTester <nl> / / select using unset <nl> assertInvalidMessage ( " Invalid unset value for tuple field number 0 " , " SELECT * FROM % s WHERE k = ? and t = ( ? , ? , ? ) " , unset ( ) , unset ( ) , unset ( ) , unset ( ) ) ; <nl> } <nl> - 	 <nl> + <nl> / * * <nl> * Test the syntax introduced by # 4851 , <nl> * migrated from cql _ tests . py : TestCQL . tuple _ notation _ test ( ) <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java <nl> index 3803e5c . . 9bafe4a 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java <nl> @ @ - 53 , 6 + 53 , 15 @ @ public class UserTypesTest extends CQLTester <nl> " INSERT INTO % s ( pk , t ) VALUES ( ? , ? ) " , 1 , " test " ) ; <nl> assertInvalidMessage ( " Not enough bytes to read 0th field f " , <nl> " INSERT INTO % s ( pk , t ) VALUES ( ? , ? ) " , 1 , Long . MAX _ VALUE ) ; <nl> + <nl> + String type = createType ( " CREATE TYPE % s ( a int , b tuple < int , text , double > ) " ) ; <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t frozen < " + type + " > ) " ) ; <nl> + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , <nl> + " INSERT INTO % s ( k , t ) VALUES ( 0 , ? ) " , <nl> + userType ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) ) ) ; <nl> + <nl> + assertInvalidMessage ( " Invalid user type literal for t : field b is not of type tuple < int , text , double > " , <nl> + " INSERT INTO % s ( k , t ) VALUES ( 0 , { a : 1 , b : ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; <nl> } <nl> <nl> @ Test
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c966c92 . . 08c6e48 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 11 
 + * Fix nested Tuples / UDTs validation ( CASSANDRA - 13646 ) 
 * Remove unused max _ value _ size _ in _ mb config setting from yaml ( CASSANDRA - 13625 
 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / UserTypes . java b / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 index de3f545 . . 6766d07 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 + + + b / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 @ @ - 91 , 7 + 91 , 7 @ @ public abstract class UserTypes 
 private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException 
 { 
 if ( ! ( receiver . type instanceof UserType ) ) 
 - throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver , receiver . type . asCQL3Type ( ) ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; 
 
 UserType ut = ( UserType ) receiver . type ; 
 for ( int i = 0 ; i < ut . size ( ) ; i + + ) 
 @ @ - 103 , 7 + 103 , 7 @ @ public abstract class UserTypes 
 
 ColumnSpecification fieldSpec = fieldSpecOf ( receiver , i ) ; 
 if ( ! value . testAssignment ( keyspace , fieldSpec ) . isAssignable ( ) ) 
 - throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : field % s is not of type % s " , receiver , field , fieldSpec . type . asCQL3Type ( ) ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : field % s is not of type % s " , receiver . name , field , fieldSpec . type . asCQL3Type ( ) ) ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / TupleType . java b / src / java / org / apache / cassandra / db / marshal / TupleType . java 
 index 0d08a52 . . bf7eae4 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / TupleType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / TupleType . java 
 @ @ - 39 , 11 + 39 , 23 @ @ public class TupleType extends AbstractType < ByteBuffer > 
 { 
 protected final List < AbstractType < ? > > types ; 
 
 + private final TupleSerializer serializer ; 
 + 
 public TupleType ( List < AbstractType < ? > > types ) 
 { 
 for ( int i = 0 ; i < types . size ( ) ; i + + ) 
 types . set ( i , types . get ( i ) . freeze ( ) ) ; 
 this . types = types ; 
 + this . serializer = new TupleSerializer ( fieldSerializers ( types ) ) ; 
 + } 
 + 
 + private static List < TypeSerializer < ? > > fieldSerializers ( List < AbstractType < ? > > types ) 
 + { 
 + int size = types . size ( ) ; 
 + List < TypeSerializer < ? > > serializers = new ArrayList < > ( size ) ; 
 + for ( int i = 0 ; i < size ; i + + ) 
 + serializers . add ( types . get ( i ) . getSerializer ( ) ) ; 
 + return serializers ; 
 } 
 
 public static TupleType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException 
 @ @ - 119 , 37 + 131 , 6 @ @ public class TupleType extends AbstractType < ByteBuffer > 
 return 1 ; 
 } 
 
 - @ Override 
 - public void validate ( ByteBuffer bytes ) throws MarshalException 
 - { 
 - ByteBuffer input = bytes . duplicate ( ) ; 
 - for ( int i = 0 ; i < size ( ) ; i + + ) 
 - { 
 - / / we allow the input to have less fields than declared so as to support field addition . 
 - if ( ! input . hasRemaining ( ) ) 
 - return ; 
 - 
 - if ( input . remaining ( ) < 4 ) 
 - throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth component " , i ) ) ; 
 - 
 - int size = input . getInt ( ) ; 
 - 
 - / / size < 0 means null value 
 - if ( size < 0 ) 
 - continue ; 
 - 
 - if ( input . remaining ( ) < size ) 
 - throw new MarshalException ( String . format ( " Not enough bytes to read % dth component " , i ) ) ; 
 - 
 - ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 - types . get ( i ) . validate ( field ) ; 
 - } 
 - 
 - / / We ' re allowed to get less fields than declared , but not more 
 - if ( input . hasRemaining ( ) ) 
 - throw new MarshalException ( " Invalid remaining data after end of tuple value " ) ; 
 - } 
 - 
 / * * 
 * Split a tuple value into its component values . 
 * / 
 @ @ - 297 , 7 + 278 , 7 @ @ public class TupleType extends AbstractType < ByteBuffer > 
 
 public TypeSerializer < ByteBuffer > getSerializer ( ) 
 { 
 - return BytesSerializer . instance ; 
 + return serializer ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / UserType . java b / src / java / org / apache / cassandra / db / marshal / UserType . java 
 index 187deeb . . 93059cd 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / UserType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / UserType . java 
 @ @ - 28 , 6 + 28 , 8 @ @ import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . exceptions . SyntaxException ; 
 import org . apache . cassandra . serializers . MarshalException ; 
 + import org . apache . cassandra . serializers . TypeSerializer ; 
 + import org . apache . cassandra . serializers . UserTypeSerializer ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . Pair ; 
 
 @ @ - 42 , 6 + 44 , 7 @ @ public class UserType extends TupleType 
 public final ByteBuffer name ; 
 private final List < ByteBuffer > fieldNames ; 
 private final List < String > stringFieldNames ; 
 + private final UserTypeSerializer serializer ; 
 
 public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > fieldNames , List < AbstractType < ? > > fieldTypes ) 
 { 
 @ @ - 51 , 17 + 54 , 22 @ @ public class UserType extends TupleType 
 this . name = name ; 
 this . fieldNames = fieldNames ; 
 this . stringFieldNames = new ArrayList < > ( fieldNames . size ( ) ) ; 
 - for ( ByteBuffer fieldName : fieldNames ) 
 + LinkedHashMap < String , TypeSerializer < ? > > fieldSerializers = new LinkedHashMap < > ( fieldTypes . size ( ) ) ; 
 + for ( int i = 0 , m = fieldNames . size ( ) ; i < m ; i + + ) 
 { 
 + ByteBuffer fieldName = fieldNames . get ( i ) ; 
 try 
 { 
 - stringFieldNames . add ( ByteBufferUtil . string ( fieldName , StandardCharsets . UTF _ 8 ) ) ; 
 + String stringFieldName = ByteBufferUtil . string ( fieldName , StandardCharsets . UTF _ 8 ) ; 
 + stringFieldNames . add ( stringFieldName ) ; 
 + fieldSerializers . put ( stringFieldName , fieldTypes . get ( i ) . getSerializer ( ) ) ; 
 } 
 catch ( CharacterCodingException ex ) 
 { 
 throw new AssertionError ( " Got non - UTF8 field name for user - defined type : " + ByteBufferUtil . bytesToHex ( fieldName ) , ex ) ; 
 } 
 } 
 + this . serializer = new UserTypeSerializer ( fieldSerializers ) ; 
 } 
 
 public static UserType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException 
 @ @ - 109 , 38 + 117 , 6 @ @ public class UserType extends TupleType 
 return UTF8Type . instance . compose ( name ) ; 
 } 
 
 - / / Note : the only reason we override this is to provide nicer error message , but since that ' s not that much code . . . 
 - @ Override 
 - public void validate ( ByteBuffer bytes ) throws MarshalException 
 - { 
 - ByteBuffer input = bytes . duplicate ( ) ; 
 - for ( int i = 0 ; i < size ( ) ; i + + ) 
 - { 
 - / / we allow the input to have less fields than declared so as to support field addition . 
 - if ( ! input . hasRemaining ( ) ) 
 - return ; 
 - 
 - if ( input . remaining ( ) < 4 ) 
 - throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , fieldNameAsString ( i ) ) ) ; 
 - 
 - int size = input . getInt ( ) ; 
 - 
 - / / size < 0 means null value 
 - if ( size < 0 ) 
 - continue ; 
 - 
 - if ( input . remaining ( ) < size ) 
 - throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , fieldNameAsString ( i ) ) ) ; 
 - 
 - ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 - types . get ( i ) . validate ( field ) ; 
 - } 
 - 
 - / / We ' re allowed to get less fields than declared , but not more 
 - if ( input . hasRemaining ( ) ) 
 - throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; 
 - } 
 - 
 @ Override 
 public Term fromJSONObject ( Object parsed ) throws MarshalException 
 { 
 @ @ - 243 , 4 + 219 , 10 @ @ public class UserType extends TupleType 
 { 
 return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , fieldNames , types ) ; 
 } 
 + 
 + @ Override 
 + public TypeSerializer < ByteBuffer > getSerializer ( ) 
 + { 
 + return serializer ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / serializers / TupleSerializer . java b / src / java / org / apache / cassandra / serializers / TupleSerializer . java 
 new file mode 100644 
 index 0000000 . . 7cf71c6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / serializers / TupleSerializer . java 
 @ @ - 0 , 0 + 1 , 66 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . serializers ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + public class TupleSerializer extends BytesSerializer 
 + { 
 + public final List < TypeSerializer < ? > > fields ; 
 + 
 + public TupleSerializer ( List < TypeSerializer < ? > > fields ) 
 + { 
 + this . fields = fields ; 
 + } 
 + 
 + @ Override 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + for ( int i = 0 ; i < fields . size ( ) ; i + + ) 
 + { 
 + / / we allow the input to have less fields than declared so as to support field addition . 
 + if ( ! input . hasRemaining ( ) ) 
 + return ; 
 + 
 + if ( input . remaining ( ) < 4 ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth component " , i ) ) ; 
 + 
 + int size = input . getInt ( ) ; 
 + 
 + / / size < 0 means null value 
 + if ( size < 0 ) 
 + continue ; 
 + 
 + if ( input . remaining ( ) < size ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read % dth component " , i ) ) ; 
 + 
 + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 + fields . get ( i ) . validate ( field ) ; 
 + } 
 + 
 + / / We ' re allowed to get less fields than declared , but not more 
 + if ( input . hasRemaining ( ) ) 
 + throw new MarshalException ( " Invalid remaining data after end of tuple value " ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java b / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java 
 new file mode 100644 
 index 0000000 . . 472e39b 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / serializers / UserTypeSerializer . java 
 @ @ - 0 , 0 + 1 , 67 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . serializers ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . LinkedHashMap ; 
 + import java . util . Map . Entry ; 
 + 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + public class UserTypeSerializer extends BytesSerializer 
 + { 
 + public final LinkedHashMap < String , TypeSerializer < ? > > fields ; 
 + 
 + public UserTypeSerializer ( LinkedHashMap < String , TypeSerializer < ? > > fields ) 
 + { 
 + this . fields = fields ; 
 + } 
 + 
 + @ Override 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + int i = 0 ; 
 + for ( Entry < String , TypeSerializer < ? > > entry : fields . entrySet ( ) ) 
 + { 
 + / / we allow the input to have less fields than declared so as to support field addition . 
 + if ( ! input . hasRemaining ( ) ) 
 + return ; 
 + 
 + if ( input . remaining ( ) < 4 ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , entry . getKey ( ) ) ) ; 
 + 
 + int size = input . getInt ( ) ; 
 + 
 + / / size < 0 means null value 
 + if ( size < 0 ) 
 + continue ; 
 + 
 + if ( input . remaining ( ) < size ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , entry . getKey ( ) ) ) ; 
 + 
 + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 + entry . getValue ( ) . validate ( field ) ; 
 + i + + ; 
 + } 
 + 
 + / / We ' re allowed to get less fields than declared , but not more 
 + if ( input . hasRemaining ( ) ) 
 + throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java 
 index 99d9695 . . 69d5a5c 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / CollectionsTest . java 
 @ @ - 748 , 4 + 748 , 40 @ @ public class CollectionsTest extends CQLTester 
 execute ( " UPDATE % s SET s = s - ? , s = s + ? WHERE pk = ? " , set ( 3 ) , set ( 3 , 4 ) , 1 ) ; 
 assertRows ( execute ( " SELECT * FROM % s WHERE pk = 1 " ) , row ( 1 , set ( 0 , 1 , 2 , 4 ) ) ) ; 
 } 
 + 
 + @ Test 
 + public void testInsertingCollectionsWithInvalidElements ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , s frozen < set < tuple < int , text , double > > > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , s ) VALUES ( 0 , ? ) " , 
 + set ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid set literal for s : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , s ) VALUES ( 0 , { ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , l frozen < list < tuple < int , text , double > > > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , l ) VALUES ( 0 , ? ) " , 
 + list ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid list literal for l : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , l ) VALUES ( 0 , [ ( 1 , ' 1 ' , 1 . 0 , 1 ) ] ) " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m frozen < map < tuple < int , text , double > , int > > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , 
 + map ( tuple ( 1 , " 1 " , 1 . 0 , 1 ) , 1 , tuple ( 2 , " 2 " , 2 . 0 , 2 ) , 2 ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid map literal for m : key ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , m ) VALUES ( 0 , { ( 1 , ' 1 ' , 1 . 0 , 1 ) : 1 } ) " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , m frozen < map < int , tuple < int , text , double > > > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , m ) VALUES ( 0 , ? ) " , 
 + map ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) , 2 , tuple ( 2 , " 2 " , 2 . 0 , 2 ) ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid map literal for m : value ( 1 , ' 1 ' , 1 . 0 , 1 ) is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , m ) VALUES ( 0 , { 1 : ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java 
 index 0783dd1 . . 3b4fb40 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / TupleTypeTest . java 
 @ @ - 123 , 6 + 123 , 14 @ @ public class TupleTypeTest extends CQLTester 
 
 assertInvalidMessage ( " Invalid tuple literal for t : too many elements . Type tuple < int , text , double > expects 3 but got 4 " , 
 " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 2 , ' foo ' , 3 . 1 , ' bar ' ) ) " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t frozen < tuple < int , tuple < int , text , double > > > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , t ) VALUES ( 0 , ? ) " , 
 + tuple ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid tuple literal for t : component 1 is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , t ) VALUES ( 0 , ( 1 , ( 1 , ' 1 ' , 1 . 0 , 1 ) ) ) " ) ; 
 } 
 
 @ Test 
 @ @ - 137 , 7 + 145 , 7 @ @ public class TupleTypeTest extends CQLTester 
 / / select using unset 
 assertInvalidMessage ( " Invalid unset value for tuple field number 0 " , " SELECT * FROM % s WHERE k = ? and t = ( ? , ? , ? ) " , unset ( ) , unset ( ) , unset ( ) , unset ( ) ) ; 
 } 
 - 	 
 + 
 / * * 
 * Test the syntax introduced by # 4851 , 
 * migrated from cql _ tests . py : TestCQL . tuple _ notation _ test ( ) 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java 
 index 3803e5c . . 9bafe4a 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / UserTypesTest . java 
 @ @ - 53 , 6 + 53 , 15 @ @ public class UserTypesTest extends CQLTester 
 " INSERT INTO % s ( pk , t ) VALUES ( ? , ? ) " , 1 , " test " ) ; 
 assertInvalidMessage ( " Not enough bytes to read 0th field f " , 
 " INSERT INTO % s ( pk , t ) VALUES ( ? , ? ) " , 1 , Long . MAX _ VALUE ) ; 
 + 
 + String type = createType ( " CREATE TYPE % s ( a int , b tuple < int , text , double > ) " ) ; 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , t frozen < " + type + " > ) " ) ; 
 + assertInvalidMessage ( " Invalid remaining data after end of tuple value " , 
 + " INSERT INTO % s ( k , t ) VALUES ( 0 , ? ) " , 
 + userType ( 1 , tuple ( 1 , " 1 " , 1 . 0 , 1 ) ) ) ; 
 + 
 + assertInvalidMessage ( " Invalid user type literal for t : field b is not of type tuple < int , text , double > " , 
 + " INSERT INTO % s ( k , t ) VALUES ( 0 , { a : 1 , b : ( 1 , ' 1 ' , 1 . 0 , 1 ) } ) " ) ; 
 } 
 
 @ Test

NEAREST DIFF:
ELIMINATEDSENTENCE
