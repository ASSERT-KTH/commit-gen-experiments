BLEU SCORE: 1.0

TEST MSG: Fix race condition in StreamTransferTask that could lead to
GENERATED MSG: Fix race condition in StreamTransferTask that could lead to

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index dfed732 . . dac555b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 50 , 6 + 50 , 8 @ @ <nl> * Log failed host when preparing incremental repair ( CASSANDRA - 8228 ) <nl> * Force config client mode in CQLSSTableWriter ( CASSANDRA - 8281 ) <nl> Merged from 2 . 0 : <nl> + * Fix race condition in StreamTransferTask that could lead to <nl> + infinite loops and premature sstable deletion ( CASSANDRA - 7704 ) <nl> * Add an extra version check to MigrationTask ( CASSANDRA - 8462 ) <nl> * Ensure SSTableWriter cleans up properly after failure ( CASSANDRA - 8499 ) <nl> * Increase bf true positive count on key cache hit ( CASSANDRA - 8525 ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> index 48a7d89 . . b840ee5 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java <nl> @ @ - 19 , 9 + 19 , 10 @ @ package org . apache . cassandra . streaming ; <nl> <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> + import java . util . concurrent . ScheduledFuture ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> - import java . util . concurrent . atomic . AtomicBoolean ; <nl> <nl> + import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 31 , 14 + 32 , 13 @ @ import org . apache . cassandra . utils . Pair ; <nl> * / <nl> public class StreamTransferTask extends StreamTask <nl> { <nl> - private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; <nl> + private static final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( " StreamingTransferTaskTimeouts " ) ) ; <nl> <nl> private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; <nl> - private AtomicBoolean aborted = new AtomicBoolean ( false ) ; <nl> + private boolean aborted = false ; <nl> <nl> - private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; <nl> - <nl> - private final Map < Integer , ScheduledFuture > timeoutTasks = new ConcurrentHashMap < > ( ) ; <nl> + private final Map < Integer , OutgoingFileMessage > files = new HashMap < > ( ) ; <nl> + private final Map < Integer , ScheduledFuture > timeoutTasks = new HashMap < > ( ) ; <nl> <nl> private long totalSize ; <nl> <nl> @ @ - 47 , 7 + 47 , 7 @ @ public class StreamTransferTask extends StreamTask <nl> super ( session , cfId ) ; <nl> } <nl> <nl> - public void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections , long repairedAt ) <nl> + public synchronized void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections , long repairedAt ) <nl> { <nl> assert sstable ! = null & & cfId . equals ( sstable . metadata . cfId ) ; <nl> OutgoingFileMessage message = new OutgoingFileMessage ( sstable , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections , repairedAt ) ; <nl> @ @ - 60 , 35 + 60 , 42 @ @ public class StreamTransferTask extends StreamTask <nl> * <nl> * @ param sequenceNumber sequence number of file <nl> * / <nl> - public synchronized void complete ( int sequenceNumber ) <nl> + public void complete ( int sequenceNumber ) <nl> { <nl> - OutgoingFileMessage file = files . remove ( sequenceNumber ) ; <nl> - if ( file ! = null ) <nl> + boolean signalComplete ; <nl> + synchronized ( this ) <nl> { <nl> - file . sstable . releaseReference ( ) ; <nl> - / / all file sent , notify session this task is complete . <nl> - if ( files . isEmpty ( ) ) <nl> - { <nl> - timeoutExecutor . shutdownNow ( ) ; <nl> - session . taskCompleted ( this ) ; <nl> - } <nl> + ScheduledFuture timeout = timeoutTasks . remove ( sequenceNumber ) ; <nl> + if ( timeout ! = null ) <nl> + timeout . cancel ( false ) ; <nl> + <nl> + OutgoingFileMessage file = files . remove ( sequenceNumber ) ; <nl> + if ( file ! = null ) <nl> + file . sstable . releaseReference ( ) ; <nl> + <nl> + signalComplete = files . isEmpty ( ) ; <nl> } <nl> + <nl> + / / all file sent , notify session this task is complete . <nl> + if ( signalComplete ) <nl> + session . taskCompleted ( this ) ; <nl> } <nl> <nl> - public void abort ( ) <nl> + public synchronized void abort ( ) <nl> { <nl> - / / Prevent releasing reference multiple times <nl> - if ( aborted . compareAndSet ( false , true ) ) <nl> - { <nl> - for ( OutgoingFileMessage file : files . values ( ) ) <nl> - { <nl> - file . sstable . releaseReference ( ) ; <nl> - } <nl> - timeoutExecutor . shutdownNow ( ) ; <nl> - } <nl> + if ( aborted ) <nl> + return ; <nl> + aborted = true ; <nl> + <nl> + for ( ScheduledFuture future : timeoutTasks . values ( ) ) <nl> + future . cancel ( false ) ; <nl> + timeoutTasks . clear ( ) ; <nl> + <nl> + for ( OutgoingFileMessage file : files . values ( ) ) <nl> + file . sstable . releaseReference ( ) ; <nl> } <nl> <nl> - public int getTotalNumberOfFiles ( ) <nl> + public synchronized int getTotalNumberOfFiles ( ) <nl> { <nl> return files . size ( ) ; <nl> } <nl> @ @ - 98 , 17 + 105 , 17 @ @ public class StreamTransferTask extends StreamTask <nl> return totalSize ; <nl> } <nl> <nl> - public Collection < OutgoingFileMessage > getFileMessages ( ) <nl> + public synchronized Collection < OutgoingFileMessage > getFileMessages ( ) <nl> { <nl> / / We may race between queuing all those messages and the completion of the completion of <nl> - / / the first ones . So copy the values to avoid a ConcurrentModificationException <nl> + / / the first ones . So copy tthe values to avoid a ConcurrentModificationException <nl> return new ArrayList < > ( files . values ( ) ) ; <nl> } <nl> <nl> public synchronized OutgoingFileMessage createMessageForRetry ( int sequenceNumber ) <nl> { <nl> / / remove previous time out task to be rescheduled later <nl> - ScheduledFuture future = timeoutTasks . get ( sequenceNumber ) ; <nl> + ScheduledFuture future = timeoutTasks . remove ( sequenceNumber ) ; <nl> if ( future ! = null ) <nl> future . cancel ( false ) ; <nl> return files . get ( sequenceNumber ) ; <nl> @ @ - 126 , 18 + 133 , 24 @ @ public class StreamTransferTask extends StreamTask <nl> * / <nl> public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) <nl> { <nl> - if ( timeoutExecutor . isShutdown ( ) ) <nl> + if ( ! files . containsKey ( sequenceNumber ) ) <nl> return null ; <nl> <nl> ScheduledFuture future = timeoutExecutor . schedule ( new Runnable ( ) <nl> { <nl> public void run ( ) <nl> { <nl> - StreamTransferTask . this . complete ( sequenceNumber ) ; <nl> - timeoutTasks . remove ( sequenceNumber ) ; <nl> + synchronized ( StreamTransferTask . this ) <nl> + { <nl> + / / remove so we don ' t cancel ourselves <nl> + timeoutTasks . remove ( sequenceNumber ) ; <nl> + StreamTransferTask . this . complete ( sequenceNumber ) ; <nl> + } <nl> } <nl> } , time , unit ) ; <nl> - timeoutTasks . put ( sequenceNumber , future ) ; <nl> + <nl> + ScheduledFuture prev = timeoutTasks . put ( sequenceNumber , future ) ; <nl> + assert prev = = null ; <nl> return future ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> index 3e73b24 . . a528f10 100644 <nl> - - - a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> + + + b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java <nl> @ @ - 20 , 11 + 20 , 14 @ @ package org . apache . cassandra . streaming ; <nl> import java . net . InetAddress ; <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> + import java . util . concurrent . CancellationException ; <nl> + import java . util . concurrent . Future ; <nl> import java . util . concurrent . ScheduledFuture ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> import org . junit . Test ; <nl> <nl> + import junit . framework . Assert ; <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> @ @ - 66 , 14 + 69 , 20 @ @ public class StreamTransferTaskTest extends SchemaLoader <nl> assertEquals ( 2 , task . getTotalNumberOfFiles ( ) ) ; <nl> <nl> / / if file sending completes before timeout then the task should be canceled . <nl> - ScheduledFuture f = task . scheduleTimeout ( 0 , 1 , TimeUnit . SECONDS ) ; <nl> - task . complete ( 0 ) ; <nl> - / / timeout task may run after complete but it is noop <nl> + Future f = task . scheduleTimeout ( 0 , 0 , TimeUnit . NANOSECONDS ) ; <nl> f . get ( ) ; <nl> <nl> / / when timeout runs on second file , task should be completed <nl> f = task . scheduleTimeout ( 1 , 1 , TimeUnit . MILLISECONDS ) ; <nl> - f . get ( ) ; <nl> + task . complete ( 1 ) ; <nl> + try <nl> + { <nl> + f . get ( ) ; <nl> + Assert . assertTrue ( false ) ; <nl> + } <nl> + catch ( CancellationException ex ) <nl> + { <nl> + } <nl> assertEquals ( StreamSession . State . WAIT _ COMPLETE , session . state ( ) ) ; <nl> <nl> / / when all streaming are done , time out task should not be scheduled .
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index dfed732 . . dac555b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 50 , 6 + 50 , 8 @ @ 
 * Log failed host when preparing incremental repair ( CASSANDRA - 8228 ) 
 * Force config client mode in CQLSSTableWriter ( CASSANDRA - 8281 ) 
 Merged from 2 . 0 : 
 + * Fix race condition in StreamTransferTask that could lead to 
 + infinite loops and premature sstable deletion ( CASSANDRA - 7704 ) 
 * Add an extra version check to MigrationTask ( CASSANDRA - 8462 ) 
 * Ensure SSTableWriter cleans up properly after failure ( CASSANDRA - 8499 ) 
 * Increase bf true positive count on key cache hit ( CASSANDRA - 8525 ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 index 48a7d89 . . b840ee5 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamTransferTask . java 
 @ @ - 19 , 9 + 19 , 10 @ @ package org . apache . cassandra . streaming ; 
 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 + import java . util . concurrent . ScheduledFuture ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 - import java . util . concurrent . atomic . AtomicBoolean ; 
 
 + import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . streaming . messages . OutgoingFileMessage ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 31 , 14 + 32 , 13 @ @ import org . apache . cassandra . utils . Pair ; 
 * / 
 public class StreamTransferTask extends StreamTask 
 { 
 - private final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( ) ; 
 + private static final ScheduledExecutorService timeoutExecutor = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( " StreamingTransferTaskTimeouts " ) ) ; 
 
 private final AtomicInteger sequenceNumber = new AtomicInteger ( 0 ) ; 
 - private AtomicBoolean aborted = new AtomicBoolean ( false ) ; 
 + private boolean aborted = false ; 
 
 - private final Map < Integer , OutgoingFileMessage > files = new ConcurrentHashMap < > ( ) ; 
 - 
 - private final Map < Integer , ScheduledFuture > timeoutTasks = new ConcurrentHashMap < > ( ) ; 
 + private final Map < Integer , OutgoingFileMessage > files = new HashMap < > ( ) ; 
 + private final Map < Integer , ScheduledFuture > timeoutTasks = new HashMap < > ( ) ; 
 
 private long totalSize ; 
 
 @ @ - 47 , 7 + 47 , 7 @ @ public class StreamTransferTask extends StreamTask 
 super ( session , cfId ) ; 
 } 
 
 - public void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections , long repairedAt ) 
 + public synchronized void addTransferFile ( SSTableReader sstable , long estimatedKeys , List < Pair < Long , Long > > sections , long repairedAt ) 
 { 
 assert sstable ! = null & & cfId . equals ( sstable . metadata . cfId ) ; 
 OutgoingFileMessage message = new OutgoingFileMessage ( sstable , sequenceNumber . getAndIncrement ( ) , estimatedKeys , sections , repairedAt ) ; 
 @ @ - 60 , 35 + 60 , 42 @ @ public class StreamTransferTask extends StreamTask 
 * 
 * @ param sequenceNumber sequence number of file 
 * / 
 - public synchronized void complete ( int sequenceNumber ) 
 + public void complete ( int sequenceNumber ) 
 { 
 - OutgoingFileMessage file = files . remove ( sequenceNumber ) ; 
 - if ( file ! = null ) 
 + boolean signalComplete ; 
 + synchronized ( this ) 
 { 
 - file . sstable . releaseReference ( ) ; 
 - / / all file sent , notify session this task is complete . 
 - if ( files . isEmpty ( ) ) 
 - { 
 - timeoutExecutor . shutdownNow ( ) ; 
 - session . taskCompleted ( this ) ; 
 - } 
 + ScheduledFuture timeout = timeoutTasks . remove ( sequenceNumber ) ; 
 + if ( timeout ! = null ) 
 + timeout . cancel ( false ) ; 
 + 
 + OutgoingFileMessage file = files . remove ( sequenceNumber ) ; 
 + if ( file ! = null ) 
 + file . sstable . releaseReference ( ) ; 
 + 
 + signalComplete = files . isEmpty ( ) ; 
 } 
 + 
 + / / all file sent , notify session this task is complete . 
 + if ( signalComplete ) 
 + session . taskCompleted ( this ) ; 
 } 
 
 - public void abort ( ) 
 + public synchronized void abort ( ) 
 { 
 - / / Prevent releasing reference multiple times 
 - if ( aborted . compareAndSet ( false , true ) ) 
 - { 
 - for ( OutgoingFileMessage file : files . values ( ) ) 
 - { 
 - file . sstable . releaseReference ( ) ; 
 - } 
 - timeoutExecutor . shutdownNow ( ) ; 
 - } 
 + if ( aborted ) 
 + return ; 
 + aborted = true ; 
 + 
 + for ( ScheduledFuture future : timeoutTasks . values ( ) ) 
 + future . cancel ( false ) ; 
 + timeoutTasks . clear ( ) ; 
 + 
 + for ( OutgoingFileMessage file : files . values ( ) ) 
 + file . sstable . releaseReference ( ) ; 
 } 
 
 - public int getTotalNumberOfFiles ( ) 
 + public synchronized int getTotalNumberOfFiles ( ) 
 { 
 return files . size ( ) ; 
 } 
 @ @ - 98 , 17 + 105 , 17 @ @ public class StreamTransferTask extends StreamTask 
 return totalSize ; 
 } 
 
 - public Collection < OutgoingFileMessage > getFileMessages ( ) 
 + public synchronized Collection < OutgoingFileMessage > getFileMessages ( ) 
 { 
 / / We may race between queuing all those messages and the completion of the completion of 
 - / / the first ones . So copy the values to avoid a ConcurrentModificationException 
 + / / the first ones . So copy tthe values to avoid a ConcurrentModificationException 
 return new ArrayList < > ( files . values ( ) ) ; 
 } 
 
 public synchronized OutgoingFileMessage createMessageForRetry ( int sequenceNumber ) 
 { 
 / / remove previous time out task to be rescheduled later 
 - ScheduledFuture future = timeoutTasks . get ( sequenceNumber ) ; 
 + ScheduledFuture future = timeoutTasks . remove ( sequenceNumber ) ; 
 if ( future ! = null ) 
 future . cancel ( false ) ; 
 return files . get ( sequenceNumber ) ; 
 @ @ - 126 , 18 + 133 , 24 @ @ public class StreamTransferTask extends StreamTask 
 * / 
 public synchronized ScheduledFuture scheduleTimeout ( final int sequenceNumber , long time , TimeUnit unit ) 
 { 
 - if ( timeoutExecutor . isShutdown ( ) ) 
 + if ( ! files . containsKey ( sequenceNumber ) ) 
 return null ; 
 
 ScheduledFuture future = timeoutExecutor . schedule ( new Runnable ( ) 
 { 
 public void run ( ) 
 { 
 - StreamTransferTask . this . complete ( sequenceNumber ) ; 
 - timeoutTasks . remove ( sequenceNumber ) ; 
 + synchronized ( StreamTransferTask . this ) 
 + { 
 + / / remove so we don ' t cancel ourselves 
 + timeoutTasks . remove ( sequenceNumber ) ; 
 + StreamTransferTask . this . complete ( sequenceNumber ) ; 
 + } 
 } 
 } , time , unit ) ; 
 - timeoutTasks . put ( sequenceNumber , future ) ; 
 + 
 + ScheduledFuture prev = timeoutTasks . put ( sequenceNumber , future ) ; 
 + assert prev = = null ; 
 return future ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 index 3e73b24 . . a528f10 100644 
 - - - a / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 + + + b / test / unit / org / apache / cassandra / streaming / StreamTransferTaskTest . java 
 @ @ - 20 , 11 + 20 , 14 @ @ package org . apache . cassandra . streaming ; 
 import java . net . InetAddress ; 
 import java . util . ArrayList ; 
 import java . util . List ; 
 + import java . util . concurrent . CancellationException ; 
 + import java . util . concurrent . Future ; 
 import java . util . concurrent . ScheduledFuture ; 
 import java . util . concurrent . TimeUnit ; 
 
 import org . junit . Test ; 
 
 + import junit . framework . Assert ; 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . Keyspace ; 
 @ @ - 66 , 14 + 69 , 20 @ @ public class StreamTransferTaskTest extends SchemaLoader 
 assertEquals ( 2 , task . getTotalNumberOfFiles ( ) ) ; 
 
 / / if file sending completes before timeout then the task should be canceled . 
 - ScheduledFuture f = task . scheduleTimeout ( 0 , 1 , TimeUnit . SECONDS ) ; 
 - task . complete ( 0 ) ; 
 - / / timeout task may run after complete but it is noop 
 + Future f = task . scheduleTimeout ( 0 , 0 , TimeUnit . NANOSECONDS ) ; 
 f . get ( ) ; 
 
 / / when timeout runs on second file , task should be completed 
 f = task . scheduleTimeout ( 1 , 1 , TimeUnit . MILLISECONDS ) ; 
 - f . get ( ) ; 
 + task . complete ( 1 ) ; 
 + try 
 + { 
 + f . get ( ) ; 
 + Assert . assertTrue ( false ) ; 
 + } 
 + catch ( CancellationException ex ) 
 + { 
 + } 
 assertEquals ( StreamSession . State . WAIT _ COMPLETE , session . state ( ) ) ; 
 
 / / when all streaming are done , time out task should not be scheduled .

NEAREST DIFF:
ELIMINATEDSENTENCE
