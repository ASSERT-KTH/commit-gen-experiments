BLEU SCORE: 0.018738883683389617

TEST MSG: don ' t NPE shutting down , due to gossip failure
GENERATED MSG: Alter the wording of assassination end logging

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index f014ac0 . . c04a87d 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 1267 , 7 + 1267 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> <nl> public void stop ( ) <nl> { <nl> - scheduledGossipTask . cancel ( false ) ; <nl> + 	 if ( scheduledGossipTask ! = null ) <nl> + 	 	 scheduledGossipTask . cancel ( false ) ; <nl> logger . info ( " Announcing shutdown " ) ; <nl> Uninterruptibles . sleepUninterruptibly ( intervalInMillis * 2 , TimeUnit . MILLISECONDS ) ; <nl> MessageOut message = new MessageOut ( MessagingService . Verb . GOSSIP _ SHUTDOWN ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fb4f3f4 . . e4066ab 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 1 . 2 . 10 <nl> + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) <nl> * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) <nl> * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) <nl> * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 27ac09b . . 2916ed9 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 275 , 6 + 275 , 10 @ @ reduce _ cache _ capacity _ to : 0 . 6 <nl> concurrent _ reads : 32 <nl> concurrent _ writes : 32 <nl> <nl> + # Total memory to use for sstable - reading buffers . Defaults to <nl> + # the smaller of 1 / 4 of heap or 512MB . <nl> + # file _ cache _ size _ in _ mb : 512 <nl> + <nl> # Total memory to use for memtables . Cassandra will flush the largest <nl> # memtable when this much memory is used . <nl> # If omitted , Cassandra will set it to 1 / 3 of the heap . <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index a924a4c . . c5a4aa1 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 169 , 6 + 169 , 8 @ @ public class Config <nl> public String row _ cache _ provider = SerializingCacheProvider . class . getSimpleName ( ) ; <nl> public boolean populate _ io _ cache _ on _ flush = false ; <nl> <nl> + public Integer file _ cache _ size _ in _ mb ; <nl> + <nl> public boolean inter _ dc _ tcp _ nodelay = true ; <nl> <nl> public String memtable _ allocator = " SlabAllocator " ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 8e3cbe2 . . dbf0905 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 272 , 6 + 272 , 9 @ @ public class DatabaseDescriptor <nl> throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; <nl> } <nl> <nl> + if ( conf . file _ cache _ size _ in _ mb = = null ) <nl> + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; <nl> + <nl> if ( conf . memtable _ total _ space _ in _ mb = = null ) <nl> conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; <nl> if ( conf . memtable _ total _ space _ in _ mb < = 0 ) <nl> @ @ - 1209 , 6 + 1212 , 11 @ @ public class DatabaseDescriptor <nl> return conf . memtable _ flush _ queue _ size ; <nl> } <nl> <nl> + public static int getFileCacheSizeInMB ( ) <nl> + { <nl> + return conf . file _ cache _ size _ in _ mb ; <nl> + } <nl> + <nl> public static int getTotalMemtableSpaceInMB ( ) <nl> { <nl> / / should only be called if estimatesRealMemtableSize ( ) is true <nl> diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> index 4173d5a . . 892611c 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> @ @ - 17 , 13 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . io . util ; <nl> <nl> - import java . util . Queue ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> <nl> public abstract class PoolingSegmentedFile extends SegmentedFile <nl> { <nl> - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> - <nl> protected PoolingSegmentedFile ( String path , long length ) <nl> { <nl> super ( path , length ) ; <nl> @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public FileDataInput getSegment ( long position ) <nl> { <nl> - RandomAccessReader reader = pool . poll ( ) ; <nl> + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; <nl> + <nl> if ( reader = = null ) <nl> reader = createReader ( path ) ; <nl> + <nl> reader . seek ( position ) ; <nl> return reader ; <nl> } <nl> @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public void recycle ( RandomAccessReader reader ) <nl> { <nl> - pool . add ( reader ) ; <nl> + FileCacheService . instance . put ( reader ) ; <nl> } <nl> <nl> public void cleanup ( ) <nl> { <nl> - for ( RandomAccessReader reader : pool ) <nl> - reader . deallocate ( ) ; <nl> + FileCacheService . instance . invalidate ( path ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> index 3210372 . . 64c5cf7 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> @ @ - 186 , 6 + 186 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu <nl> return filePath ; <nl> } <nl> <nl> + public int getBufferSize ( ) <nl> + { <nl> + return buffer . length ; <nl> + } <nl> + <nl> public void reset ( ) <nl> { <nl> seek ( markedPointer ) ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . 9b21de6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> @ @ - 0 , 0 + 1 , 64 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . Gauge ; <nl> + import com . yammer . metrics . core . Meter ; <nl> + import com . yammer . metrics . core . MetricName ; <nl> + import com . yammer . metrics . util . RatioGauge ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> + <nl> + public class FileCacheMetrics <nl> + { <nl> + / * * Total number of hits * / <nl> + public final Meter hits ; <nl> + / * * Total number of requests * / <nl> + public final Meter requests ; <nl> + / * * hit rate * / <nl> + public final Gauge < Double > hitRate ; <nl> + / * * Total size of file cache , in bytes * / <nl> + public final Gauge < Long > size ; <nl> + <nl> + public FileCacheMetrics ( ) <nl> + { <nl> + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; <nl> + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; <nl> + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) <nl> + { <nl> + protected double getNumerator ( ) <nl> + { <nl> + return hits . count ( ) ; <nl> + } <nl> + <nl> + protected double getDenominator ( ) <nl> + { <nl> + return requests . count ( ) ; <nl> + } <nl> + } ) ; <nl> + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + return FileCacheService . instance . sizeInBytes ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> new file mode 100644 <nl> index 0000000 . . 9dd1b15 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> @ @ - 0 , 0 + 1 , 139 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . Queue ; <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . google . common . cache . Cache ; <nl> + import com . google . common . cache . CacheBuilder ; <nl> + import com . google . common . cache . RemovalListener ; <nl> + import com . google . common . cache . RemovalNotification ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . io . util . RandomAccessReader ; <nl> + import org . apache . cassandra . metrics . FileCacheMetrics ; <nl> + <nl> + public class FileCacheService <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; <nl> + <nl> + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; <nl> + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis <nl> + <nl> + public static FileCacheService instance = new FileCacheService ( ) ; <nl> + <nl> + private final Cache < String , Queue < RandomAccessReader > > cache ; <nl> + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; <nl> + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public Queue < RandomAccessReader > call ( ) throws Exception <nl> + { <nl> + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + protected FileCacheService ( ) <nl> + { <nl> + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) <nl> + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) <nl> + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) <nl> + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) <nl> + { <nl> + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; <nl> + <nl> + if ( cachedInstances = = null ) <nl> + return ; <nl> + <nl> + for ( RandomAccessReader reader : cachedInstances ) <nl> + reader . deallocate ( ) ; <nl> + } <nl> + } ) <nl> + . build ( ) ; <nl> + } <nl> + <nl> + public RandomAccessReader get ( String path ) <nl> + { <nl> + metrics . requests . mark ( ) ; <nl> + <nl> + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; <nl> + <nl> + if ( instances = = null ) <nl> + return null ; <nl> + <nl> + RandomAccessReader result = instances . poll ( ) ; <nl> + <nl> + if ( result ! = null ) <nl> + metrics . hits . mark ( ) ; <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + private Queue < RandomAccessReader > getCacheFor ( String path ) <nl> + { <nl> + try <nl> + { <nl> + return cache . get ( path , cacheForPathCreator ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + / / if something bad happened , let ' s just carry on and return null <nl> + / / as dysfunctional queue should not interrupt normal operation <nl> + logger . debug ( " Exception fetching cache " , e ) ; <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + public void put ( RandomAccessReader instance ) <nl> + { <nl> + / / This wouldn ' t be precise sometimes when CRAR is used because <nl> + / / there is a way for users to dynamically change the size of the buffer , <nl> + / / but we don ' t expect that to happen frequently in production . <nl> + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . <nl> + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; <nl> + <nl> + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) <nl> + instance . deallocate ( ) ; <nl> + else <nl> + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; <nl> + } <nl> + <nl> + public void invalidate ( String path ) <nl> + { <nl> + cache . invalidate ( path ) ; <nl> + } <nl> + <nl> + public long sizeInBytes ( ) <nl> + { <nl> + long n = 0 ; <nl> + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) <nl> + for ( RandomAccessReader reader : queue ) <nl> + n + = reader . getBufferSize ( ) ; <nl> + return n ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index f014ac0 . . c04a87d 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 1267 , 7 + 1267 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 
 public void stop ( ) 
 { 
 - scheduledGossipTask . cancel ( false ) ; 
 + 	 if ( scheduledGossipTask ! = null ) 
 + 	 	 scheduledGossipTask . cancel ( false ) ; 
 logger . info ( " Announcing shutdown " ) ; 
 Uninterruptibles . sleepUninterruptibly ( intervalInMillis * 2 , TimeUnit . MILLISECONDS ) ; 
 MessageOut message = new MessageOut ( MessagingService . Verb . GOSSIP _ SHUTDOWN ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fb4f3f4 . . e4066ab 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 1 . 2 . 10 
 + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) 
 * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) 
 * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) 
 * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 27ac09b . . 2916ed9 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 275 , 6 + 275 , 10 @ @ reduce _ cache _ capacity _ to : 0 . 6 
 concurrent _ reads : 32 
 concurrent _ writes : 32 
 
 + # Total memory to use for sstable - reading buffers . Defaults to 
 + # the smaller of 1 / 4 of heap or 512MB . 
 + # file _ cache _ size _ in _ mb : 512 
 + 
 # Total memory to use for memtables . Cassandra will flush the largest 
 # memtable when this much memory is used . 
 # If omitted , Cassandra will set it to 1 / 3 of the heap . 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index a924a4c . . c5a4aa1 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 169 , 6 + 169 , 8 @ @ public class Config 
 public String row _ cache _ provider = SerializingCacheProvider . class . getSimpleName ( ) ; 
 public boolean populate _ io _ cache _ on _ flush = false ; 
 
 + public Integer file _ cache _ size _ in _ mb ; 
 + 
 public boolean inter _ dc _ tcp _ nodelay = true ; 
 
 public String memtable _ allocator = " SlabAllocator " ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 8e3cbe2 . . dbf0905 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 272 , 6 + 272 , 9 @ @ public class DatabaseDescriptor 
 throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; 
 } 
 
 + if ( conf . file _ cache _ size _ in _ mb = = null ) 
 + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; 
 + 
 if ( conf . memtable _ total _ space _ in _ mb = = null ) 
 conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; 
 if ( conf . memtable _ total _ space _ in _ mb < = 0 ) 
 @ @ - 1209 , 6 + 1212 , 11 @ @ public class DatabaseDescriptor 
 return conf . memtable _ flush _ queue _ size ; 
 } 
 
 + public static int getFileCacheSizeInMB ( ) 
 + { 
 + return conf . file _ cache _ size _ in _ mb ; 
 + } 
 + 
 public static int getTotalMemtableSpaceInMB ( ) 
 { 
 / / should only be called if estimatesRealMemtableSize ( ) is true 
 diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 index 4173d5a . . 892611c 100644 
 - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 @ @ - 17 , 13 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . io . util ; 
 
 - import java . util . Queue ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 
 public abstract class PoolingSegmentedFile extends SegmentedFile 
 { 
 - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 - 
 protected PoolingSegmentedFile ( String path , long length ) 
 { 
 super ( path , length ) ; 
 @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public FileDataInput getSegment ( long position ) 
 { 
 - RandomAccessReader reader = pool . poll ( ) ; 
 + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; 
 + 
 if ( reader = = null ) 
 reader = createReader ( path ) ; 
 + 
 reader . seek ( position ) ; 
 return reader ; 
 } 
 @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public void recycle ( RandomAccessReader reader ) 
 { 
 - pool . add ( reader ) ; 
 + FileCacheService . instance . put ( reader ) ; 
 } 
 
 public void cleanup ( ) 
 { 
 - for ( RandomAccessReader reader : pool ) 
 - reader . deallocate ( ) ; 
 + FileCacheService . instance . invalidate ( path ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 index 3210372 . . 64c5cf7 100644 
 - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 @ @ - 186 , 6 + 186 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu 
 return filePath ; 
 } 
 
 + public int getBufferSize ( ) 
 + { 
 + return buffer . length ; 
 + } 
 + 
 public void reset ( ) 
 { 
 seek ( markedPointer ) ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 new file mode 100644 
 index 0000000 . . 9b21de6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 @ @ - 0 , 0 + 1 , 64 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . Gauge ; 
 + import com . yammer . metrics . core . Meter ; 
 + import com . yammer . metrics . core . MetricName ; 
 + import com . yammer . metrics . util . RatioGauge ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 + 
 + public class FileCacheMetrics 
 + { 
 + / * * Total number of hits * / 
 + public final Meter hits ; 
 + / * * Total number of requests * / 
 + public final Meter requests ; 
 + / * * hit rate * / 
 + public final Gauge < Double > hitRate ; 
 + / * * Total size of file cache , in bytes * / 
 + public final Gauge < Long > size ; 
 + 
 + public FileCacheMetrics ( ) 
 + { 
 + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; 
 + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; 
 + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) 
 + { 
 + protected double getNumerator ( ) 
 + { 
 + return hits . count ( ) ; 
 + } 
 + 
 + protected double getDenominator ( ) 
 + { 
 + return requests . count ( ) ; 
 + } 
 + } ) ; 
 + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + return FileCacheService . instance . sizeInBytes ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java 
 new file mode 100644 
 index 0000000 . . 9dd1b15 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / FileCacheService . java 
 @ @ - 0 , 0 + 1 , 139 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . Queue ; 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . google . common . cache . Cache ; 
 + import com . google . common . cache . CacheBuilder ; 
 + import com . google . common . cache . RemovalListener ; 
 + import com . google . common . cache . RemovalNotification ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . io . util . RandomAccessReader ; 
 + import org . apache . cassandra . metrics . FileCacheMetrics ; 
 + 
 + public class FileCacheService 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; 
 + 
 + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; 
 + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis 
 + 
 + public static FileCacheService instance = new FileCacheService ( ) ; 
 + 
 + private final Cache < String , Queue < RandomAccessReader > > cache ; 
 + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; 
 + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public Queue < RandomAccessReader > call ( ) throws Exception 
 + { 
 + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 + } 
 + } ; 
 + 
 + protected FileCacheService ( ) 
 + { 
 + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) 
 + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) 
 + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) 
 + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) 
 + { 
 + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; 
 + 
 + if ( cachedInstances = = null ) 
 + return ; 
 + 
 + for ( RandomAccessReader reader : cachedInstances ) 
 + reader . deallocate ( ) ; 
 + } 
 + } ) 
 + . build ( ) ; 
 + } 
 + 
 + public RandomAccessReader get ( String path ) 
 + { 
 + metrics . requests . mark ( ) ; 
 + 
 + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; 
 + 
 + if ( instances = = null ) 
 + return null ; 
 + 
 + RandomAccessReader result = instances . poll ( ) ; 
 + 
 + if ( result ! = null ) 
 + metrics . hits . mark ( ) ; 
 + 
 + return result ; 
 + } 
 + 
 + private Queue < RandomAccessReader > getCacheFor ( String path ) 
 + { 
 + try 
 + { 
 + return cache . get ( path , cacheForPathCreator ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + / / if something bad happened , let ' s just carry on and return null 
 + / / as dysfunctional queue should not interrupt normal operation 
 + logger . debug ( " Exception fetching cache " , e ) ; 
 + } 
 + 
 + return null ; 
 + } 
 + 
 + public void put ( RandomAccessReader instance ) 
 + { 
 + / / This wouldn ' t be precise sometimes when CRAR is used because 
 + / / there is a way for users to dynamically change the size of the buffer , 
 + / / but we don ' t expect that to happen frequently in production . 
 + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . 
 + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; 
 + 
 + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) 
 + instance . deallocate ( ) ; 
 + else 
 + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; 
 + } 
 + 
 + public void invalidate ( String path ) 
 + { 
 + cache . invalidate ( path ) ; 
 + } 
 + 
 + public long sizeInBytes ( ) 
 + { 
 + long n = 0 ; 
 + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) 
 + for ( RandomAccessReader reader : queue ) 
 + n + = reader . getBufferSize ( ) ; 
 + return n ; 
 + } 
 + }
