BLEU SCORE: 0.42888194248035344

TEST MSG: fix comment
GENERATED MSG: fix merge failure

TEST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / db / ScrubTest . java b / test / unit / org / apache / cassandra / db / ScrubTest . java <nl> index 220e2a4 . . 7dc7c5c 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ScrubTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ScrubTest . java <nl> @ @ - 187 , 7 + 187 , 7 @ @ public class ScrubTest extends SchemaLoader <nl> * The test also assumes an ordered partitioner . <nl> * <nl> ColumnFamily cf = ArrayBackedSortedColumns . factory . create ( cfs . metadata ) ; <nl> - cf . addColumn ( new Cell ( ByteBufferUtil . bytes ( " someName " ) , ByteBufferUtil . bytes ( " someValue " ) , 0L ) ) ; <nl> + cf . addColumn ( new BufferCell ( ByteBufferUtil . bytes ( " someName " ) , ByteBufferUtil . bytes ( " someValue " ) , 0L ) ) ; <nl> <nl> SSTableWriter writer = new SSTableWriter ( cfs . getTempSSTablePath ( new File ( System . getProperty ( " corrupt - sstable - root " ) ) ) , <nl> cfs . metadata . getIndexInterval ( ) ,
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2306887 . . 48b91da 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 <nl> + * removed PBSPredictor ( CASSANDRA - 5455 ) <nl> * CAS support ( CASSANDRA - 5062 , ) <nl> * Leveled compaction performs size - tiered compactions in L0 ( CASSANDRA - 5371 ) <nl> * Add yaml network topology snitch for mixed ec2 / other envs ( CASSANDRA - 5339 ) <nl> diff - - git a / build . xml b / build . xml <nl> index 86178c3 . . 8889794 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 1163 , 11 + 1163 , 6 @ @ <nl> < / testmacro > <nl> < / target > <nl> <nl> - < target name = " pbs - test " depends = " build - test " description = " Tests PBS predictor " > <nl> - < testmacro suitename = " unit " inputdir = " $ { test . unit . src } " <nl> - timeout = " 15000 " filter = " * * / PBSPredictorTest . java " / > <nl> - < / target > <nl> - <nl> < target name = " long - test " depends = " build - test " description = " Execute functional tests " > <nl> < testmacro suitename = " long " inputdir = " $ { test . long . src } " <nl> timeout = " $ { test . long . timeout } " > <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index d9688a9 . . c23f566 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 591 , 16 + 591 , 6 @ @ public final class MessagingService implements MessagingServiceMBean <nl> public int sendRR ( MessageOut message , InetAddress to , IAsyncCallback cb , long timeout ) <nl> { <nl> int id = addCallback ( cb , message , to , timeout ) ; <nl> - <nl> - if ( cb instanceof AbstractWriteResponseHandler ) <nl> - { <nl> - PBSPredictor . instance ( ) . startWriteOperation ( id ) ; <nl> - } <nl> - else if ( cb instanceof ReadCallback ) <nl> - { <nl> - PBSPredictor . instance ( ) . startReadOperation ( id ) ; <nl> - } <nl> - <nl> sendOneWay ( message , id , to ) ; <nl> return id ; <nl> } <nl> @ @ - 740 , 20 + 730 , 6 @ @ public final class MessagingService implements MessagingServiceMBean <nl> ExecutorService stage = StageManager . getStage ( message . getMessageType ( ) ) ; <nl> assert stage ! = null : " No stage for message type " + message . verb ; <nl> <nl> - if ( message . verb = = Verb . REQUEST _ RESPONSE & & PBSPredictor . instance ( ) . isLoggingEnabled ( ) ) <nl> - { <nl> - IAsyncCallback cb = MessagingService . instance ( ) . getRegisteredCallback ( id ) . callback ; <nl> - <nl> - if ( cb instanceof AbstractWriteResponseHandler ) <nl> - { <nl> - PBSPredictor . instance ( ) . logWriteResponse ( id , timestamp ) ; <nl> - } <nl> - else if ( cb instanceof ReadCallback ) <nl> - { <nl> - PBSPredictor . instance ( ) . logReadResponse ( id , timestamp ) ; <nl> - } <nl> - } <nl> - <nl> stage . execute ( runnable ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / PBSPredictionResult . java b / src / java / org / apache / cassandra / service / PBSPredictionResult . java <nl> deleted file mode 100644 <nl> index 92c5491 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / service / PBSPredictionResult . java <nl> + + + / dev / null <nl> @ @ - 1 , 127 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service ; <nl> - <nl> - import java . io . Serializable ; <nl> - <nl> - public class PBSPredictionResult implements Serializable <nl> - { <nl> - private int n ; <nl> - private int r ; <nl> - private int w ; <nl> - <nl> - private float timeSinceWrite ; <nl> - private int numberVersionsStale ; <nl> - <nl> - private float consistencyProbability ; <nl> - <nl> - private float averageReadLatency ; <nl> - private float averageWriteLatency ; <nl> - private long percentileReadLatencyValue ; <nl> - private float percentileReadLatencyPercentile ; <nl> - private long percentileWriteLatencyValue ; <nl> - private float percentileWriteLatencyPercentile ; <nl> - <nl> - public PBSPredictionResult ( int n , <nl> - int r , <nl> - int w , <nl> - float timeSinceWrite , <nl> - int numberVersionsStale , <nl> - float consistencyProbability , <nl> - float averageReadLatency , <nl> - float averageWriteLatency , <nl> - long percentileReadLatencyValue , <nl> - float percentileReadLatencyPercentile , <nl> - long percentileWriteLatencyValue , <nl> - float percentileWriteLatencyPercentile ) { <nl> - this . n = n ; <nl> - this . r = r ; <nl> - this . w = w ; <nl> - this . timeSinceWrite = timeSinceWrite ; <nl> - this . numberVersionsStale = numberVersionsStale ; <nl> - this . consistencyProbability = consistencyProbability ; <nl> - this . averageReadLatency = averageReadLatency ; <nl> - this . averageWriteLatency = averageWriteLatency ; <nl> - this . percentileReadLatencyValue = percentileReadLatencyValue ; <nl> - this . percentileReadLatencyPercentile = percentileReadLatencyPercentile ; <nl> - this . percentileWriteLatencyValue = percentileWriteLatencyValue ; <nl> - this . percentileWriteLatencyPercentile = percentileWriteLatencyPercentile ; <nl> - } <nl> - <nl> - public int getN ( ) <nl> - { <nl> - return n ; <nl> - } <nl> - <nl> - public int getR ( ) <nl> - { <nl> - return r ; <nl> - } <nl> - <nl> - public int getW ( ) <nl> - { <nl> - return w ; <nl> - } <nl> - <nl> - public float getTimeSinceWrite ( ) <nl> - { <nl> - return timeSinceWrite ; <nl> - } <nl> - <nl> - public int getNumberVersionsStale ( ) <nl> - { <nl> - return numberVersionsStale ; <nl> - } <nl> - <nl> - public float getConsistencyProbability ( ) <nl> - { <nl> - return consistencyProbability ; <nl> - } <nl> - <nl> - public float getAverageReadLatency ( ) <nl> - { <nl> - return averageReadLatency ; <nl> - } <nl> - <nl> - public float getAverageWriteLatency ( ) <nl> - { <nl> - return averageWriteLatency ; <nl> - } <nl> - <nl> - public long getPercentileReadLatencyValue ( ) <nl> - { <nl> - return percentileReadLatencyValue ; <nl> - } <nl> - <nl> - public float getPercentileReadLatencyPercentile ( ) <nl> - { <nl> - return percentileReadLatencyPercentile ; <nl> - } <nl> - <nl> - public long getPercentileWriteLatencyValue ( ) <nl> - { <nl> - return percentileWriteLatencyValue ; <nl> - } <nl> - <nl> - public float getPercentileWriteLatencyPercentile ( ) <nl> - { <nl> - return percentileWriteLatencyPercentile ; <nl> - } <nl> - } <nl> - <nl> diff - - git a / src / java / org / apache / cassandra / service / PBSPredictor . java b / src / java / org / apache / cassandra / service / PBSPredictor . java <nl> deleted file mode 100644 <nl> index 85ef304 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / service / PBSPredictor . java <nl> + + + / dev / null <nl> @ @ - 1 , 630 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service ; <nl> - <nl> - import java . lang . management . ManagementFactory ; <nl> - import java . util . * ; <nl> - import java . util . concurrent . ConcurrentHashMap ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> - import java . util . concurrent . LinkedBlockingQueue ; <nl> - import javax . management . MBeanServer ; <nl> - import javax . management . ObjectName ; <nl> - <nl> - import org . slf4j . Logger ; <nl> - import org . slf4j . LoggerFactory ; <nl> - <nl> - / * * <nl> - * Performs latency and consistency predictions as described in <nl> - * < a href = " http : / / arxiv . org / pdf / 1204 . 6082 . pdf " > <nl> - * " Probabilistically Bounded Staleness for Practical Partial Quorums " < / a > <nl> - * by Bailis et al . in VLDB 2012 . The predictions are of the form : <nl> - * < p / > <nl> - * < i > With ReplicationFactor < tt > N < / tt > , read consistency level of <nl> - * < tt > R < / tt > , and write consistency level < tt > W < / tt > , after <nl> - * < tt > t < / tt > seconds , < tt > p < / tt > % of reads will return a version <nl> - * within < tt > k < / tt > versions of the last written ; this should result <nl> - * in a latency of < tt > L < / tt > ms . < / i > <nl> - * < p / > <nl> - * < p / > <nl> - * These predictions should be used as a rough guideline for system <nl> - * operators . This interface is exposed through nodetool . <nl> - * < p / > <nl> - * < p / > <nl> - * The class accomplishes this by measuring latencies for reads and <nl> - * writes , then using Monte Carlo simulation to predict behavior under <nl> - * a given N , R , and W based on those latencies . <nl> - * < p / > <nl> - * < p / > <nl> - * We capture four distributions : <nl> - * < p / > <nl> - * < ul > <nl> - * < li > <nl> - * < tt > W < / tt > : time from when the coordinator sends a mutation to the time <nl> - * that a replica begins to serve the new value ( s ) <nl> - * < / li > <nl> - * < p / > <nl> - * < li > <nl> - * < tt > A < / tt > : time from when a replica accepting a mutation sends an <nl> - * acknowledgment to the time the coordinator hears of it <nl> - * < / li > <nl> - * < p / > <nl> - * < li > <nl> - * < tt > R < / tt > : time from when the coordinator sends a read request to the time <nl> - * that the replica performs the read <nl> - * < / li > <nl> - * < p / > <nl> - * < li > <nl> - * < tt > S < / tt > : time from when the replica sends a read response to the time <nl> - * when the coordinator receives it <nl> - * < / li > <nl> - * < / ul > <nl> - * < p / > <nl> - * < tt > A < / tt > and < tt > S < / tt > are mostly network - bound , while W and R <nl> - * depend on both the network and local processing time . <nl> - * < p / > <nl> - * < p / > <nl> - * < b > Caveats : < / b > <nl> - * Prediction is only as good as the latencies collected . Accurate <nl> - * prediction requires synchronizing clocks between replicas . We <nl> - * collect a running sample of latencies , but , if latencies change <nl> - * dramatically , predictions will be off . <nl> - * < p / > <nl> - * < p / > <nl> - * The predictions are conservative , or worst - case , meaning we may <nl> - * predict more staleness than in practice in the following ways : <nl> - * < ul > <nl> - * < li > <nl> - * We do not account for read repair . <nl> - * < / li > <nl> - * < li > <nl> - * We do not account for Merkle tree exchange . <nl> - * < / li > <nl> - * < li > <nl> - * Multi - version staleness is particularly conservative . <nl> - * < / li > <nl> - * < li > <nl> - * We simulate non - local reads and writes . We assume that the <nl> - * coordinating Cassandra node is not itself a replica for a given key . <nl> - * < / li > <nl> - * < / ul > <nl> - * < p / > <nl> - * < p / > <nl> - * The predictions are optimistic in the following ways : <nl> - * < ul > <nl> - * < li > <nl> - * We do not predict the impact of node failure . <nl> - * < / li > <nl> - * < li > <nl> - * We do not model hinted handoff . <nl> - * < / li > <nl> - * < / ul > <nl> - * <nl> - * @ see org . apache . cassandra . thrift . ConsistencyLevel <nl> - * @ see org . apache . cassandra . locator . AbstractReplicationStrategy <nl> - * / <nl> - <nl> - public class PBSPredictor implements PBSPredictorMBean <nl> - { <nl> - private static final Logger logger = LoggerFactory . getLogger ( PBSPredictor . class ) ; <nl> - <nl> - public static final String MBEAN _ NAME = " org . apache . cassandra . service : type = PBSPredictor " ; <nl> - private static final boolean DEFAULT _ DO _ LOG _ LATENCIES = false ; <nl> - private static final int DEFAULT _ MAX _ LOGGED _ LATENCIES = 10000 ; <nl> - private static final int DEFAULT _ NUMBER _ TRIALS _ PREDICTION = 10000 ; <nl> - <nl> - / * <nl> - * We record a fixed size set of WARS latencies for read and <nl> - * mutation operations . We store the order in which each <nl> - * operation arrived , and use an LRU policy to evict old <nl> - * messages . <nl> - * <nl> - * This information is stored as a mapping from messageIDs to <nl> - * latencies . <nl> - * / <nl> - <nl> - / * <nl> - * Helper class which minimizes the number of HashMaps we maintain . <nl> - * For a given messageId , this class maintains the startTime of the message , <nl> - * and a queue for send times and reply times . <nl> - * <nl> - * sendLats corresponds to W and R , while replyLats is used for A and S . <nl> - * / <nl> - private class MessageLatencyCollection <nl> - { <nl> - MessageLatencyCollection ( Long startTime ) <nl> - { <nl> - this . startTime = startTime ; <nl> - this . sendLats = new ConcurrentLinkedQueue < Long > ( ) ; <nl> - this . replyLats = new ConcurrentLinkedQueue < Long > ( ) ; <nl> - } <nl> - <nl> - void addSendLat ( Long sendLat ) <nl> - { <nl> - sendLats . add ( sendLat ) ; <nl> - } <nl> - <nl> - void addReplyLat ( Long replyLat ) <nl> - { <nl> - replyLats . add ( replyLat ) ; <nl> - } <nl> - <nl> - Collection < Long > getSendLats ( ) <nl> - { <nl> - return sendLats ; <nl> - } <nl> - <nl> - Collection < Long > getReplyLats ( ) <nl> - { <nl> - return replyLats ; <nl> - } <nl> - <nl> - Long getStartTime ( ) <nl> - { <nl> - return startTime ; <nl> - } <nl> - <nl> - Long startTime ; <nl> - Collection < Long > sendLats ; <nl> - Collection < Long > replyLats ; <nl> - } <nl> - <nl> - / / used for LRU replacement <nl> - private final Queue < Integer > writeMessageIds = new LinkedBlockingQueue < Integer > ( ) ; <nl> - private final Queue < Integer > readMessageIds = new LinkedBlockingQueue < Integer > ( ) ; <nl> - <nl> - private final Map < Integer , MessageLatencyCollection > messageIdToWriteLats = new ConcurrentHashMap < Integer , MessageLatencyCollection > ( ) ; <nl> - private final Map < Integer , MessageLatencyCollection > messageIdToReadLats = new ConcurrentHashMap < Integer , MessageLatencyCollection > ( ) ; <nl> - <nl> - private Random random ; <nl> - private boolean initialized = false ; <nl> - <nl> - private boolean logLatencies = DEFAULT _ DO _ LOG _ LATENCIES ; <nl> - private int maxLoggedLatencies = DEFAULT _ MAX _ LOGGED _ LATENCIES ; <nl> - private int numberTrialsPrediction = DEFAULT _ NUMBER _ TRIALS _ PREDICTION ; <nl> - <nl> - private static final PBSPredictor instance = new PBSPredictor ( ) ; <nl> - <nl> - public static PBSPredictor instance ( ) <nl> - { <nl> - return instance ; <nl> - } <nl> - <nl> - private PBSPredictor ( ) <nl> - { <nl> - init ( ) ; <nl> - } <nl> - <nl> - public void enableConsistencyPredictionLogging ( ) <nl> - { <nl> - logLatencies = true ; <nl> - } <nl> - <nl> - public void disableConsistencyPredictionLogging ( ) <nl> - { <nl> - logLatencies = false ; <nl> - } <nl> - <nl> - public boolean isLoggingEnabled ( ) <nl> - { <nl> - return logLatencies ; <nl> - } <nl> - <nl> - public void setMaxLoggedLatenciesForConsistencyPrediction ( int maxLogged ) <nl> - { <nl> - maxLoggedLatencies = maxLogged ; <nl> - } <nl> - <nl> - public void setNumberTrialsForConsistencyPrediction ( int numTrials ) <nl> - { <nl> - numberTrialsPrediction = numTrials ; <nl> - } <nl> - <nl> - public void init ( ) <nl> - { <nl> - if ( ! initialized ) <nl> - { <nl> - random = new Random ( ) ; <nl> - <nl> - MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> - try <nl> - { <nl> - mbs . registerMBean ( this , new ObjectName ( PBSPredictor . MBEAN _ NAME ) ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - initialized = true ; <nl> - } <nl> - } <nl> - <nl> - <nl> - / / used for random sampling from the latencies <nl> - private long getRandomElement ( List < Long > list ) <nl> - { <nl> - if ( list . size ( ) = = 0 ) <nl> - throw new RuntimeException ( " Not enough data for prediction " ) ; <nl> - return list . get ( random . nextInt ( list . size ( ) ) ) ; <nl> - } <nl> - <nl> - / / used for calculating the average latency of a read or write operation <nl> - / / given a set of simulated latencies <nl> - private float listAverage ( List < Long > list ) <nl> - { <nl> - long accum = 0 ; <nl> - for ( long value : list ) <nl> - accum + = value ; <nl> - return ( float ) accum / list . size ( ) ; <nl> - } <nl> - <nl> - / / calculate the percentile entry of a list <nl> - private long getPercentile ( List < Long > list , float percentile ) <nl> - { <nl> - Collections . sort ( list ) ; <nl> - return list . get ( ( int ) ( list . size ( ) * percentile ) ) ; <nl> - } <nl> - <nl> - / * <nl> - * For our trials , sample the latency for the ( replicaNumber ) th <nl> - * reply for one of WARS <nl> - * if replicaNumber > the number of replicas we have data for <nl> - * ( say we have data for ReplicationFactor 2 but ask for N = 3 ) <nl> - * then we randomly sample from all response times <nl> - * / <nl> - private long getRandomLatencySample ( Map < Integer , List < Long > > samples , int replicaNumber ) <nl> - { <nl> - if ( samples . containsKey ( replicaNumber ) ) <nl> - { <nl> - return getRandomElement ( samples . get ( replicaNumber ) ) ; <nl> - } <nl> - <nl> - return getRandomElement ( samples . get ( samples . keySet ( ) . toArray ( ) [ random . nextInt ( samples . keySet ( ) . size ( ) ) ] ) ) ; <nl> - } <nl> - <nl> - / * <nl> - * To perform the prediction , we randomly sample from the <nl> - * collected WARS latencies , simulating writes followed by reads <nl> - * exactly t milliseconds afterwards . We count the number of <nl> - * reordered reads and writes to calculate the probability of <nl> - * staleness along with recording operation latencies . <nl> - * / <nl> - <nl> - <nl> - public PBSPredictionResult doPrediction ( int n , <nl> - int r , <nl> - int w , <nl> - float timeSinceWrite , <nl> - int numberVersionsStale , <nl> - float percentileLatency ) <nl> - { <nl> - if ( r > n ) <nl> - throw new IllegalArgumentException ( " r must be less than n " ) ; <nl> - if ( r < 0 ) <nl> - throw new IllegalArgumentException ( " r must be positive " ) ; <nl> - if ( w > n ) <nl> - throw new IllegalArgumentException ( " w must be less than n " ) ; <nl> - if ( w < 0 ) <nl> - throw new IllegalArgumentException ( " w must be positive " ) ; <nl> - if ( percentileLatency < 0 | | percentileLatency > 1 ) <nl> - throw new IllegalArgumentException ( " percentileLatency must be between 0 and 1 inclusive " ) ; <nl> - if ( numberVersionsStale < 0 ) <nl> - throw new IllegalArgumentException ( " numberVersionsStale must be positive " ) ; <nl> - <nl> - if ( ! logLatencies ) <nl> - throw new IllegalStateException ( " Latency logging is not enabled " ) ; <nl> - <nl> - / / get a mapping of { replica number : latency } for each of WARS <nl> - Map < Integer , List < Long > > wLatencies = getOrderedWLatencies ( ) ; <nl> - Map < Integer , List < Long > > aLatencies = getOrderedALatencies ( ) ; <nl> - Map < Integer , List < Long > > rLatencies = getOrderedRLatencies ( ) ; <nl> - Map < Integer , List < Long > > sLatencies = getOrderedSLatencies ( ) ; <nl> - <nl> - if ( wLatencies . isEmpty ( ) | | aLatencies . isEmpty ( ) ) <nl> - throw new IllegalStateException ( " No write latencies have been recorded so far . Run some ( non - local ) inserts . " ) ; <nl> - <nl> - if ( rLatencies . isEmpty ( ) | | sLatencies . isEmpty ( ) ) <nl> - throw new IllegalStateException ( " No read latencies have been recorded so far . Run some ( non - local ) reads . " ) ; <nl> - <nl> - / / storage for simulated read and write latencies <nl> - ArrayList < Long > readLatencies = new ArrayList < Long > ( ) ; <nl> - ArrayList < Long > writeLatencies = new ArrayList < Long > ( ) ; <nl> - <nl> - long consistentReads = 0 ; <nl> - <nl> - / / storage for latencies for each replica for a given Monte Carlo trial <nl> - / / arr [ i ] will hold the ith replica ' s latency for one of WARS <nl> - ArrayList < Long > trialWLatencies = new ArrayList < Long > ( ) ; <nl> - ArrayList < Long > trialRLatencies = new ArrayList < Long > ( ) ; <nl> - <nl> - ArrayList < Long > replicaWriteLatencies = new ArrayList < Long > ( ) ; <nl> - ArrayList < Long > replicaReadLatencies = new ArrayList < Long > ( ) ; <nl> - <nl> - / / run repeated trials and observe staleness <nl> - for ( int i = 0 ; i < numberTrialsPrediction ; + + i ) <nl> - { <nl> - / / simulate sending a write to N replicas then sending a <nl> - / / read to N replicas and record the latencies by randomly <nl> - / / sampling from gathered latencies <nl> - for ( int replicaNo = 0 ; replicaNo < n ; + + replicaNo ) <nl> - { <nl> - long trialWLatency = getRandomLatencySample ( wLatencies , replicaNo ) ; <nl> - long trialALatency = getRandomLatencySample ( aLatencies , replicaNo ) ; <nl> - <nl> - trialWLatencies . add ( trialWLatency ) ; <nl> - <nl> - replicaWriteLatencies . add ( trialWLatency + trialALatency ) ; <nl> - } <nl> - <nl> - / / reads are only sent to R replicas - so pick R random read and <nl> - / / response latencies <nl> - for ( int replicaNo = 0 ; replicaNo < r ; + + replicaNo ) <nl> - { <nl> - long trialRLatency = getRandomLatencySample ( rLatencies , replicaNo ) ; <nl> - long trialSLatency = getRandomLatencySample ( sLatencies , replicaNo ) ; <nl> - <nl> - trialRLatencies . add ( trialRLatency ) ; <nl> - <nl> - replicaReadLatencies . add ( trialRLatency + trialSLatency ) ; <nl> - } <nl> - <nl> - / / the write latency for this trial is the time it takes <nl> - / / for the wth replica to respond ( W + A ) <nl> - Collections . sort ( replicaWriteLatencies ) ; <nl> - long writeLatency = replicaWriteLatencies . get ( w - 1 ) ; <nl> - writeLatencies . add ( writeLatency ) ; <nl> - <nl> - ArrayList < Long > sortedReplicaReadLatencies = new ArrayList < Long > ( replicaReadLatencies ) ; <nl> - Collections . sort ( sortedReplicaReadLatencies ) ; <nl> - <nl> - / / the read latency for this trial is the time it takes <nl> - / / for the rth replica to respond ( R + S ) <nl> - readLatencies . add ( sortedReplicaReadLatencies . get ( r - 1 ) ) ; <nl> - <nl> - / / were all of the read responses reordered ? <nl> - <nl> - / / for each of the first r messages ( the ones the <nl> - / / coordinator will pick from ) : <nl> - / / - - if the read message came in after this replica saw the <nl> - / / write , it will be consistent <nl> - / / - - each read request is sent at time <nl> - / / writeLatency + timeSinceWrite <nl> - <nl> - for ( int responseNumber = 0 ; responseNumber < r ; + + responseNumber ) <nl> - { <nl> - int replicaNumber = replicaReadLatencies . indexOf ( sortedReplicaReadLatencies . get ( responseNumber ) ) ; <nl> - <nl> - if ( writeLatency + timeSinceWrite + trialRLatencies . get ( replicaNumber ) > = <nl> - trialWLatencies . get ( replicaNumber ) ) <nl> - { <nl> - consistentReads + + ; <nl> - break ; <nl> - } <nl> - <nl> - / / tombstone this replica in the case that we have <nl> - / / duplicate read latencies <nl> - replicaReadLatencies . set ( replicaNumber , - 1L ) ; <nl> - } <nl> - <nl> - / / clear storage for the next trial <nl> - trialWLatencies . clear ( ) ; <nl> - trialRLatencies . clear ( ) ; <nl> - <nl> - replicaReadLatencies . clear ( ) ; <nl> - replicaWriteLatencies . clear ( ) ; <nl> - } <nl> - <nl> - float oneVersionConsistencyProbability = ( float ) consistentReads / numberTrialsPrediction ; <nl> - <nl> - / / to calculate multi - version staleness , we exponentiate the staleness probability by the number of versions <nl> - float consistencyProbability = ( float ) ( 1 - Math . pow ( ( double ) ( 1 - oneVersionConsistencyProbability ) , <nl> - numberVersionsStale ) ) ; <nl> - <nl> - float averageWriteLatency = listAverage ( writeLatencies ) ; <nl> - float averageReadLatency = listAverage ( readLatencies ) ; <nl> - <nl> - long percentileWriteLatency = getPercentile ( writeLatencies , percentileLatency ) ; <nl> - long percentileReadLatency = getPercentile ( readLatencies , percentileLatency ) ; <nl> - <nl> - return new PBSPredictionResult ( n , <nl> - r , <nl> - w , <nl> - timeSinceWrite , <nl> - numberVersionsStale , <nl> - consistencyProbability , <nl> - averageReadLatency , <nl> - averageWriteLatency , <nl> - percentileReadLatency , <nl> - percentileLatency , <nl> - percentileWriteLatency , <nl> - percentileLatency ) ; <nl> - } <nl> - <nl> - public void startWriteOperation ( int id ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - startWriteOperation ( id , System . currentTimeMillis ( ) ) ; <nl> - } <nl> - <nl> - public void startWriteOperation ( int id , long startTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - assert ( ! messageIdToWriteLats . containsKey ( id ) ) ; <nl> - <nl> - writeMessageIds . add ( id ) ; <nl> - <nl> - / / LRU replacement of latencies <nl> - / / the maximum number of entries is sloppy , but that ' s acceptable for our purposes <nl> - if ( writeMessageIds . size ( ) > maxLoggedLatencies ) <nl> - { <nl> - Integer toEvict = writeMessageIds . remove ( ) ; <nl> - messageIdToWriteLats . remove ( toEvict ) ; <nl> - } <nl> - <nl> - messageIdToWriteLats . put ( id , new MessageLatencyCollection ( startTime ) ) ; <nl> - } <nl> - <nl> - public void startReadOperation ( int id ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - startReadOperation ( id , System . currentTimeMillis ( ) ) ; <nl> - } <nl> - <nl> - public void startReadOperation ( int id , long startTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - assert ( ! messageIdToReadLats . containsKey ( id ) ) ; <nl> - readMessageIds . add ( id ) ; <nl> - <nl> - / / LRU replacement of latencies <nl> - / / the maximum number of entries is sloppy , but that ' s acceptable for our purposes <nl> - if ( readMessageIds . size ( ) > maxLoggedLatencies ) <nl> - { <nl> - Integer toEvict = readMessageIds . remove ( ) ; <nl> - messageIdToReadLats . remove ( toEvict ) ; <nl> - } <nl> - <nl> - messageIdToReadLats . put ( id , new MessageLatencyCollection ( startTime ) ) ; <nl> - } <nl> - <nl> - public void logWriteResponse ( int id , long constructionTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - logWriteResponse ( id , constructionTime , System . currentTimeMillis ( ) ) ; <nl> - } <nl> - <nl> - public void logWriteResponse ( int id , long responseCreationTime , long receivedTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - MessageLatencyCollection writeLatsCollection = messageIdToWriteLats . get ( id ) ; <nl> - if ( writeLatsCollection = = null ) <nl> - { <nl> - return ; <nl> - } <nl> - <nl> - Long startTime = writeLatsCollection . getStartTime ( ) ; <nl> - writeLatsCollection . addSendLat ( Math . max ( 0 , responseCreationTime - startTime ) ) ; <nl> - writeLatsCollection . addReplyLat ( Math . max ( 0 , receivedTime - responseCreationTime ) ) ; <nl> - } <nl> - <nl> - public void logReadResponse ( int id , long constructionTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - logReadResponse ( id , constructionTime , System . currentTimeMillis ( ) ) ; <nl> - } <nl> - <nl> - public void logReadResponse ( int id , long responseCreationTime , long receivedTime ) <nl> - { <nl> - if ( ! logLatencies ) <nl> - return ; <nl> - <nl> - MessageLatencyCollection readLatsCollection = messageIdToReadLats . get ( id ) ; <nl> - if ( readLatsCollection = = null ) <nl> - { <nl> - return ; <nl> - } <nl> - <nl> - Long startTime = readLatsCollection . getStartTime ( ) ; <nl> - readLatsCollection . addSendLat ( Math . max ( 0 , responseCreationTime - startTime ) ) ; <nl> - readLatsCollection . addReplyLat ( Math . max ( 0 , receivedTime - responseCreationTime ) ) ; <nl> - } <nl> - <nl> - Map < Integer , List < Long > > getOrderedWLatencies ( ) <nl> - { <nl> - Collection < Collection < Long > > allWLatencies = new ArrayList < Collection < Long > > ( ) ; <nl> - for ( MessageLatencyCollection wlc : messageIdToWriteLats . values ( ) ) <nl> - { <nl> - allWLatencies . add ( wlc . getSendLats ( ) ) ; <nl> - } <nl> - <nl> - return getOrderedLatencies ( allWLatencies ) ; <nl> - } <nl> - <nl> - Map < Integer , List < Long > > getOrderedALatencies ( ) <nl> - { <nl> - Collection < Collection < Long > > allALatencies = new ArrayList < Collection < Long > > ( ) ; <nl> - for ( MessageLatencyCollection wlc : messageIdToWriteLats . values ( ) ) <nl> - allALatencies . add ( wlc . getReplyLats ( ) ) ; <nl> - return getOrderedLatencies ( allALatencies ) ; <nl> - } <nl> - <nl> - Map < Integer , List < Long > > getOrderedRLatencies ( ) <nl> - { <nl> - Collection < Collection < Long > > allRLatencies = new ArrayList < Collection < Long > > ( ) ; <nl> - for ( MessageLatencyCollection rlc : messageIdToReadLats . values ( ) ) <nl> - { <nl> - allRLatencies . add ( rlc . getSendLats ( ) ) ; <nl> - } <nl> - return getOrderedLatencies ( allRLatencies ) ; <nl> - } <nl> - <nl> - Map < Integer , List < Long > > getOrderedSLatencies ( ) <nl> - { <nl> - Collection < Collection < Long > > allSLatencies = new ArrayList < Collection < Long > > ( ) ; <nl> - for ( MessageLatencyCollection rlc : messageIdToReadLats . values ( ) ) <nl> - allSLatencies . add ( rlc . getReplyLats ( ) ) ; <nl> - return getOrderedLatencies ( allSLatencies ) ; <nl> - } <nl> - <nl> - / / Return the collected latencies indexed by response number instead of by messageID <nl> - private Map < Integer , List < Long > > getOrderedLatencies ( Collection < Collection < Long > > latencyLists ) <nl> - { <nl> - Map < Integer , List < Long > > ret = new HashMap < Integer , List < Long > > ( ) ; <nl> - <nl> - / / N may vary <nl> - int maxResponses = 0 ; <nl> - <nl> - for ( Collection < Long > latencies : latencyLists ) <nl> - { <nl> - List < Long > sortedLatencies = new ArrayList < Long > ( latencies ) ; <nl> - Collections . sort ( sortedLatencies ) ; <nl> - <nl> - if ( sortedLatencies . size ( ) > maxResponses ) <nl> - { <nl> - for ( int i = maxResponses + 1 ; i < = sortedLatencies . size ( ) ; + + i ) <nl> - { <nl> - ret . put ( i , new Vector < Long > ( ) ) ; <nl> - } <nl> - <nl> - maxResponses = sortedLatencies . size ( ) ; <nl> - } <nl> - <nl> - / / indexing by 0 is awkward since we ' re talking about the ith response <nl> - for ( int i = 1 ; i < = sortedLatencies . size ( ) ; + + i ) <nl> - { <nl> - ret . get ( i ) . add ( sortedLatencies . get ( i - 1 ) ) ; <nl> - } <nl> - } <nl> - <nl> - return ret ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / service / PBSPredictorMBean . java b / src / java / org / apache / cassandra / service / PBSPredictorMBean . java <nl> deleted file mode 100644 <nl> index 1e2f31a . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / service / PBSPredictorMBean . java <nl> + + + / dev / null <nl> @ @ - 1 , 35 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service ; <nl> - <nl> - public interface PBSPredictorMBean <nl> - { <nl> - public PBSPredictionResult doPrediction ( int n , <nl> - int r , <nl> - int w , <nl> - float timeSinceWrite , <nl> - int numberVersionsStale , <nl> - float percentileLatency ) ; <nl> - <nl> - public void enableConsistencyPredictionLogging ( ) ; <nl> - public void disableConsistencyPredictionLogging ( ) ; <nl> - <nl> - public void setMaxLoggedLatenciesForConsistencyPrediction ( int maxLogged ) ; <nl> - public void setNumberTrialsForConsistencyPrediction ( int numTrials ) ; <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 855c69a . . c1acb44 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 473 , 8 + 473 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> throw new AssertionError ( e ) ; <nl> } <nl> <nl> - PBSPredictor . instance ( ) . init ( ) ; <nl> - <nl> if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . load _ ring _ state " , " true " ) ) ) <nl> { <nl> logger . info ( " Loading persisted ring state " ) ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 2140358 . . 6e52f69 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 47 , 8 + 47 , 6 @ @ import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; <nl> import org . apache . cassandra . net . MessagingServiceMBean ; <nl> import org . apache . cassandra . service . CacheServiceMBean ; <nl> - import org . apache . cassandra . service . PBSPredictionResult ; <nl> - import org . apache . cassandra . service . PBSPredictorMBean ; <nl> import org . apache . cassandra . service . StorageProxyMBean ; <nl> import org . apache . cassandra . utils . EstimatedHistogram ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 157 , 7 + 155 , 6 @ @ public class NodeCmd <nl> RANGEKEYSAMPLE , <nl> REBUILD _ INDEX , <nl> RESETLOCALSCHEMA , <nl> - PREDICTCONSISTENCY <nl> } <nl> <nl> <nl> @ @ - 925 , 48 + 922 , 6 @ @ public class NodeCmd <nl> outs . println ( probe . isThriftServerRunning ( ) ? " running " : " not running " ) ; <nl> } <nl> <nl> - public void predictConsistency ( Integer replicationFactor , <nl> - Integer timeAfterWrite , <nl> - Integer numVersions , <nl> - Float percentileLatency , <nl> - PrintStream output ) <nl> - { <nl> - PBSPredictorMBean predictorMBean = probe . getPBSPredictorMBean ( ) ; <nl> - <nl> - for ( int r = 1 ; r < = replicationFactor ; + + r ) { <nl> - for ( int w = 1 ; w < = replicationFactor ; + + w ) { <nl> - if ( w + r > replicationFactor + 1 ) <nl> - continue ; <nl> - <nl> - try { <nl> - PBSPredictionResult result = predictorMBean . doPrediction ( replicationFactor , <nl> - r , <nl> - w , <nl> - timeAfterWrite , <nl> - numVersions , <nl> - percentileLatency ) ; <nl> - <nl> - if ( r = = 1 & & w = = 1 ) { <nl> - output . printf ( " % dms after a given write , with maximum version staleness of k = % d % n " , timeAfterWrite , numVersions ) ; <nl> - } <nl> - <nl> - output . printf ( " N = % d , R = % d , W = % d % n " , replicationFactor , r , w ) ; <nl> - output . printf ( " Probability of consistent reads : % f % n " , result . getConsistencyProbability ( ) ) ; <nl> - output . printf ( " Average read latency : % fms ( % . 3fth % % ile % dms ) % n " , result . getAverageReadLatency ( ) , <nl> - result . getPercentileReadLatencyPercentile ( ) * 100 , <nl> - result . getPercentileReadLatencyValue ( ) ) ; <nl> - output . printf ( " Average write latency : % fms ( % . 3fth % % ile % dms ) % n % n " , result . getAverageWriteLatency ( ) , <nl> - result . getPercentileWriteLatencyPercentile ( ) * 100 , <nl> - result . getPercentileWriteLatencyValue ( ) ) ; <nl> - } catch ( Exception e ) { <nl> - System . out . println ( e . getMessage ( ) ) ; <nl> - e . printStackTrace ( ) ; <nl> - return ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> public static void main ( String [ ] args ) throws IOException , InterruptedException , ConfigurationException , ParseException <nl> { <nl> CommandLineParser parser = new PosixParser ( ) ; <nl> @ @ - 1244 , 20 + 1199 , 6 @ @ public class NodeCmd <nl> nodeCmd . printRangeKeySample ( System . out ) ; <nl> break ; <nl> <nl> - case PREDICTCONSISTENCY : <nl> - if ( arguments . length < 2 ) { badUse ( " Requires replication factor and time " ) ; } <nl> - int numVersions = 1 ; <nl> - if ( arguments . length = = 3 ) { numVersions = Integer . parseInt ( arguments [ 2 ] ) ; } <nl> - float percentileLatency = . 999f ; <nl> - if ( arguments . length = = 4 ) { percentileLatency = Float . parseFloat ( arguments [ 3 ] ) ; } <nl> - <nl> - nodeCmd . predictConsistency ( Integer . parseInt ( arguments [ 0 ] ) , <nl> - Integer . parseInt ( arguments [ 1 ] ) , <nl> - numVersions , <nl> - percentileLatency , <nl> - System . out ) ; <nl> - break ; <nl> - <nl> default : <nl> throw new RuntimeException ( " Unreachable code . " ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index fb941f5 . . 753a64c 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 77 , 7 + 77 , 6 @ @ public class NodeProbe <nl> public MessagingServiceMBean msProxy ; <nl> private FailureDetectorMBean fdProxy ; <nl> private CacheServiceMBean cacheService ; <nl> - private PBSPredictorMBean PBSPredictorProxy ; <nl> private StorageProxyMBean spProxy ; <nl> private HintedHandOffManagerMBean hhProxy ; <nl> private boolean failed ; <nl> @ @ - 149 , 8 + 148 , 6 @ @ public class NodeProbe <nl> { <nl> ObjectName name = new ObjectName ( ssObjName ) ; <nl> ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; <nl> - name = new ObjectName ( PBSPredictor . MBEAN _ NAME ) ; <nl> - PBSPredictorProxy = JMX . newMBeanProxy ( mbeanServerConn , name , PBSPredictorMBean . class ) ; <nl> name = new ObjectName ( MessagingService . MBEAN _ NAME ) ; <nl> msProxy = JMX . newMBeanProxy ( mbeanServerConn , name , MessagingServiceMBean . class ) ; <nl> name = new ObjectName ( StreamingService . MBEAN _ OBJECT _ NAME ) ; <nl> @ @ - 815 , 11 + 812 , 6 @ @ public class NodeProbe <nl> return ssProxy . describeRingJMX ( keyspaceName ) ; <nl> } <nl> <nl> - public PBSPredictorMBean getPBSPredictorMBean ( ) <nl> - { <nl> - return PBSPredictorProxy ; <nl> - } <nl> - <nl> public void rebuild ( String sourceDc ) <nl> { <nl> ssProxy . rebuild ( sourceDc ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / service / PBSPredictorTest . java b / test / unit / org / apache / cassandra / service / PBSPredictorTest . java <nl> deleted file mode 100644 <nl> index a0e2ef0 . . 0000000 <nl> - - - a / test / unit / org / apache / cassandra / service / PBSPredictorTest . java <nl> + + + / dev / null <nl> @ @ - 1 , 114 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , <nl> - * software distributed under the License is distributed on an <nl> - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> - * KIND , either express or implied . See the License for the <nl> - * specific language governing permissions and limitations <nl> - * under the License . <nl> - * / <nl> - package org . apache . cassandra . service ; <nl> - <nl> - import org . junit . Test ; <nl> - import static org . junit . Assert . * ; <nl> - <nl> - public class PBSPredictorTest <nl> - { <nl> - private static PBSPredictor predictor = PBSPredictor . instance ( ) ; <nl> - <nl> - private void createWriteResponse ( long W , long A , int id ) <nl> - { <nl> - predictor . startWriteOperation ( id , 0 ) ; <nl> - predictor . logWriteResponse ( id , W , W + A ) ; <nl> - } <nl> - <nl> - private void createReadResponse ( long R , long S , int id ) <nl> - { <nl> - predictor . startReadOperation ( id , 0 ) ; <nl> - predictor . logReadResponse ( id , R , R + S ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void testDoPrediction ( ) <nl> - { <nl> - try { <nl> - predictor . enableConsistencyPredictionLogging ( ) ; <nl> - predictor . init ( ) ; <nl> - <nl> - / * <nl> - Ensure accuracy given a set of basic latencies <nl> - Predictions here match a prior Python implementation <nl> - * / <nl> - <nl> - for ( int i = 0 ; i < 10 ; + + i ) <nl> - { <nl> - createWriteResponse ( 10 , 0 , 10 * i ) ; <nl> - createReadResponse ( 0 , 0 , 10 * i + 1 ) ; <nl> - } <nl> - <nl> - for ( int i = 0 ; i < 10 ; + + i ) <nl> - { <nl> - createWriteResponse ( 0 , 0 , 10 * i + 2 ) ; <nl> - } <nl> - <nl> - / / 10ms after write <nl> - PBSPredictionResult result = predictor . doPrediction ( 2 , 1 , 1 , 10 . 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( 1 , result . getConsistencyProbability ( ) , 0 ) ; <nl> - assertEquals ( 2 . 5 , result . getAverageWriteLatency ( ) , . 5 ) ; <nl> - <nl> - / / 0ms after write <nl> - result = predictor . doPrediction ( 2 , 1 , 1 , 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( . 75 , result . getConsistencyProbability ( ) , 0 . 05 ) ; <nl> - <nl> - / / k = 5 versions staleness <nl> - result = predictor . doPrediction ( 2 , 1 , 1 , 5 . 0f , 5 , 0 . 99f ) ; <nl> - assertEquals ( . 98 , result . getConsistencyProbability ( ) , 0 . 05 ) ; <nl> - assertEquals ( 2 . 5 , result . getAverageWriteLatency ( ) , . 5 ) ; <nl> - <nl> - for ( int i = 0 ; i < 10 ; + + i ) <nl> - { <nl> - createWriteResponse ( 20 , 0 , 10 * i + 3 ) ; <nl> - } <nl> - <nl> - / / 5ms after write <nl> - result = predictor . doPrediction ( 2 , 1 , 1 , 5 . 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( . 67 , result . getConsistencyProbability ( ) , . 05 ) ; <nl> - <nl> - / / N = 5 <nl> - result = predictor . doPrediction ( 5 , 1 , 1 , 5 . 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( . 42 , result . getConsistencyProbability ( ) , . 05 ) ; <nl> - assertEquals ( 1 . 33 , result . getAverageWriteLatency ( ) , . 5 ) ; <nl> - <nl> - for ( int i = 0 ; i < 10 ; + + i ) <nl> - { <nl> - createWriteResponse ( 100 , 100 , 10 * i + 4 ) ; <nl> - createReadResponse ( 100 , 100 , 10 * i + 5 ) ; <nl> - } <nl> - <nl> - result = predictor . doPrediction ( 2 , 1 , 1 , 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( . 860 , result . getConsistencyProbability ( ) , . 05 ) ; <nl> - assertEquals ( 26 . 5 , result . getAverageWriteLatency ( ) , 1 ) ; <nl> - assertEquals ( 100 . 33 , result . getAverageReadLatency ( ) , 4 ) ; <nl> - <nl> - result = predictor . doPrediction ( 2 , 2 , 1 , 0f , 1 , 0 . 99f ) ; <nl> - <nl> - assertEquals ( 1 , result . getConsistencyProbability ( ) , 0 ) ; <nl> - } catch ( Exception e ) { <nl> - fail ( e . getMessage ( ) ) ; <nl> - } <nl> - } <nl> - }

TEST DIFF:
diff - - git a / test / unit / org / apache / cassandra / db / ScrubTest . java b / test / unit / org / apache / cassandra / db / ScrubTest . java 
 index 220e2a4 . . 7dc7c5c 100644 
 - - - a / test / unit / org / apache / cassandra / db / ScrubTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ScrubTest . java 
 @ @ - 187 , 7 + 187 , 7 @ @ public class ScrubTest extends SchemaLoader 
 * The test also assumes an ordered partitioner . 
 * 
 ColumnFamily cf = ArrayBackedSortedColumns . factory . create ( cfs . metadata ) ; 
 - cf . addColumn ( new Cell ( ByteBufferUtil . bytes ( " someName " ) , ByteBufferUtil . bytes ( " someValue " ) , 0L ) ) ; 
 + cf . addColumn ( new BufferCell ( ByteBufferUtil . bytes ( " someName " ) , ByteBufferUtil . bytes ( " someValue " ) , 0L ) ) ; 
 
 SSTableWriter writer = new SSTableWriter ( cfs . getTempSSTablePath ( new File ( System . getProperty ( " corrupt - sstable - root " ) ) ) , 
 cfs . metadata . getIndexInterval ( ) ,

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2306887 . . 48b91da 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 
 + * removed PBSPredictor ( CASSANDRA - 5455 ) 
 * CAS support ( CASSANDRA - 5062 , ) 
 * Leveled compaction performs size - tiered compactions in L0 ( CASSANDRA - 5371 ) 
 * Add yaml network topology snitch for mixed ec2 / other envs ( CASSANDRA - 5339 ) 
 diff - - git a / build . xml b / build . xml 
 index 86178c3 . . 8889794 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 1163 , 11 + 1163 , 6 @ @ 
 < / testmacro > 
 < / target > 
 
 - < target name = " pbs - test " depends = " build - test " description = " Tests PBS predictor " > 
 - < testmacro suitename = " unit " inputdir = " $ { test . unit . src } " 
 - timeout = " 15000 " filter = " * * / PBSPredictorTest . java " / > 
 - < / target > 
 - 
 < target name = " long - test " depends = " build - test " description = " Execute functional tests " > 
 < testmacro suitename = " long " inputdir = " $ { test . long . src } " 
 timeout = " $ { test . long . timeout } " > 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index d9688a9 . . c23f566 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 591 , 16 + 591 , 6 @ @ public final class MessagingService implements MessagingServiceMBean 
 public int sendRR ( MessageOut message , InetAddress to , IAsyncCallback cb , long timeout ) 
 { 
 int id = addCallback ( cb , message , to , timeout ) ; 
 - 
 - if ( cb instanceof AbstractWriteResponseHandler ) 
 - { 
 - PBSPredictor . instance ( ) . startWriteOperation ( id ) ; 
 - } 
 - else if ( cb instanceof ReadCallback ) 
 - { 
 - PBSPredictor . instance ( ) . startReadOperation ( id ) ; 
 - } 
 - 
 sendOneWay ( message , id , to ) ; 
 return id ; 
 } 
 @ @ - 740 , 20 + 730 , 6 @ @ public final class MessagingService implements MessagingServiceMBean 
 ExecutorService stage = StageManager . getStage ( message . getMessageType ( ) ) ; 
 assert stage ! = null : " No stage for message type " + message . verb ; 
 
 - if ( message . verb = = Verb . REQUEST _ RESPONSE & & PBSPredictor . instance ( ) . isLoggingEnabled ( ) ) 
 - { 
 - IAsyncCallback cb = MessagingService . instance ( ) . getRegisteredCallback ( id ) . callback ; 
 - 
 - if ( cb instanceof AbstractWriteResponseHandler ) 
 - { 
 - PBSPredictor . instance ( ) . logWriteResponse ( id , timestamp ) ; 
 - } 
 - else if ( cb instanceof ReadCallback ) 
 - { 
 - PBSPredictor . instance ( ) . logReadResponse ( id , timestamp ) ; 
 - } 
 - } 
 - 
 stage . execute ( runnable ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / service / PBSPredictionResult . java b / src / java / org / apache / cassandra / service / PBSPredictionResult . java 
 deleted file mode 100644 
 index 92c5491 . . 0000000 
 - - - a / src / java / org / apache / cassandra / service / PBSPredictionResult . java 
 + + + / dev / null 
 @ @ - 1 , 127 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service ; 
 - 
 - import java . io . Serializable ; 
 - 
 - public class PBSPredictionResult implements Serializable 
 - { 
 - private int n ; 
 - private int r ; 
 - private int w ; 
 - 
 - private float timeSinceWrite ; 
 - private int numberVersionsStale ; 
 - 
 - private float consistencyProbability ; 
 - 
 - private float averageReadLatency ; 
 - private float averageWriteLatency ; 
 - private long percentileReadLatencyValue ; 
 - private float percentileReadLatencyPercentile ; 
 - private long percentileWriteLatencyValue ; 
 - private float percentileWriteLatencyPercentile ; 
 - 
 - public PBSPredictionResult ( int n , 
 - int r , 
 - int w , 
 - float timeSinceWrite , 
 - int numberVersionsStale , 
 - float consistencyProbability , 
 - float averageReadLatency , 
 - float averageWriteLatency , 
 - long percentileReadLatencyValue , 
 - float percentileReadLatencyPercentile , 
 - long percentileWriteLatencyValue , 
 - float percentileWriteLatencyPercentile ) { 
 - this . n = n ; 
 - this . r = r ; 
 - this . w = w ; 
 - this . timeSinceWrite = timeSinceWrite ; 
 - this . numberVersionsStale = numberVersionsStale ; 
 - this . consistencyProbability = consistencyProbability ; 
 - this . averageReadLatency = averageReadLatency ; 
 - this . averageWriteLatency = averageWriteLatency ; 
 - this . percentileReadLatencyValue = percentileReadLatencyValue ; 
 - this . percentileReadLatencyPercentile = percentileReadLatencyPercentile ; 
 - this . percentileWriteLatencyValue = percentileWriteLatencyValue ; 
 - this . percentileWriteLatencyPercentile = percentileWriteLatencyPercentile ; 
 - } 
 - 
 - public int getN ( ) 
 - { 
 - return n ; 
 - } 
 - 
 - public int getR ( ) 
 - { 
 - return r ; 
 - } 
 - 
 - public int getW ( ) 
 - { 
 - return w ; 
 - } 
 - 
 - public float getTimeSinceWrite ( ) 
 - { 
 - return timeSinceWrite ; 
 - } 
 - 
 - public int getNumberVersionsStale ( ) 
 - { 
 - return numberVersionsStale ; 
 - } 
 - 
 - public float getConsistencyProbability ( ) 
 - { 
 - return consistencyProbability ; 
 - } 
 - 
 - public float getAverageReadLatency ( ) 
 - { 
 - return averageReadLatency ; 
 - } 
 - 
 - public float getAverageWriteLatency ( ) 
 - { 
 - return averageWriteLatency ; 
 - } 
 - 
 - public long getPercentileReadLatencyValue ( ) 
 - { 
 - return percentileReadLatencyValue ; 
 - } 
 - 
 - public float getPercentileReadLatencyPercentile ( ) 
 - { 
 - return percentileReadLatencyPercentile ; 
 - } 
 - 
 - public long getPercentileWriteLatencyValue ( ) 
 - { 
 - return percentileWriteLatencyValue ; 
 - } 
 - 
 - public float getPercentileWriteLatencyPercentile ( ) 
 - { 
 - return percentileWriteLatencyPercentile ; 
 - } 
 - } 
 - 
 diff - - git a / src / java / org / apache / cassandra / service / PBSPredictor . java b / src / java / org / apache / cassandra / service / PBSPredictor . java 
 deleted file mode 100644 
 index 85ef304 . . 0000000 
 - - - a / src / java / org / apache / cassandra / service / PBSPredictor . java 
 + + + / dev / null 
 @ @ - 1 , 630 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service ; 
 - 
 - import java . lang . management . ManagementFactory ; 
 - import java . util . * ; 
 - import java . util . concurrent . ConcurrentHashMap ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 - import java . util . concurrent . LinkedBlockingQueue ; 
 - import javax . management . MBeanServer ; 
 - import javax . management . ObjectName ; 
 - 
 - import org . slf4j . Logger ; 
 - import org . slf4j . LoggerFactory ; 
 - 
 - / * * 
 - * Performs latency and consistency predictions as described in 
 - * < a href = " http : / / arxiv . org / pdf / 1204 . 6082 . pdf " > 
 - * " Probabilistically Bounded Staleness for Practical Partial Quorums " < / a > 
 - * by Bailis et al . in VLDB 2012 . The predictions are of the form : 
 - * < p / > 
 - * < i > With ReplicationFactor < tt > N < / tt > , read consistency level of 
 - * < tt > R < / tt > , and write consistency level < tt > W < / tt > , after 
 - * < tt > t < / tt > seconds , < tt > p < / tt > % of reads will return a version 
 - * within < tt > k < / tt > versions of the last written ; this should result 
 - * in a latency of < tt > L < / tt > ms . < / i > 
 - * < p / > 
 - * < p / > 
 - * These predictions should be used as a rough guideline for system 
 - * operators . This interface is exposed through nodetool . 
 - * < p / > 
 - * < p / > 
 - * The class accomplishes this by measuring latencies for reads and 
 - * writes , then using Monte Carlo simulation to predict behavior under 
 - * a given N , R , and W based on those latencies . 
 - * < p / > 
 - * < p / > 
 - * We capture four distributions : 
 - * < p / > 
 - * < ul > 
 - * < li > 
 - * < tt > W < / tt > : time from when the coordinator sends a mutation to the time 
 - * that a replica begins to serve the new value ( s ) 
 - * < / li > 
 - * < p / > 
 - * < li > 
 - * < tt > A < / tt > : time from when a replica accepting a mutation sends an 
 - * acknowledgment to the time the coordinator hears of it 
 - * < / li > 
 - * < p / > 
 - * < li > 
 - * < tt > R < / tt > : time from when the coordinator sends a read request to the time 
 - * that the replica performs the read 
 - * < / li > 
 - * < p / > 
 - * < li > 
 - * < tt > S < / tt > : time from when the replica sends a read response to the time 
 - * when the coordinator receives it 
 - * < / li > 
 - * < / ul > 
 - * < p / > 
 - * < tt > A < / tt > and < tt > S < / tt > are mostly network - bound , while W and R 
 - * depend on both the network and local processing time . 
 - * < p / > 
 - * < p / > 
 - * < b > Caveats : < / b > 
 - * Prediction is only as good as the latencies collected . Accurate 
 - * prediction requires synchronizing clocks between replicas . We 
 - * collect a running sample of latencies , but , if latencies change 
 - * dramatically , predictions will be off . 
 - * < p / > 
 - * < p / > 
 - * The predictions are conservative , or worst - case , meaning we may 
 - * predict more staleness than in practice in the following ways : 
 - * < ul > 
 - * < li > 
 - * We do not account for read repair . 
 - * < / li > 
 - * < li > 
 - * We do not account for Merkle tree exchange . 
 - * < / li > 
 - * < li > 
 - * Multi - version staleness is particularly conservative . 
 - * < / li > 
 - * < li > 
 - * We simulate non - local reads and writes . We assume that the 
 - * coordinating Cassandra node is not itself a replica for a given key . 
 - * < / li > 
 - * < / ul > 
 - * < p / > 
 - * < p / > 
 - * The predictions are optimistic in the following ways : 
 - * < ul > 
 - * < li > 
 - * We do not predict the impact of node failure . 
 - * < / li > 
 - * < li > 
 - * We do not model hinted handoff . 
 - * < / li > 
 - * < / ul > 
 - * 
 - * @ see org . apache . cassandra . thrift . ConsistencyLevel 
 - * @ see org . apache . cassandra . locator . AbstractReplicationStrategy 
 - * / 
 - 
 - public class PBSPredictor implements PBSPredictorMBean 
 - { 
 - private static final Logger logger = LoggerFactory . getLogger ( PBSPredictor . class ) ; 
 - 
 - public static final String MBEAN _ NAME = " org . apache . cassandra . service : type = PBSPredictor " ; 
 - private static final boolean DEFAULT _ DO _ LOG _ LATENCIES = false ; 
 - private static final int DEFAULT _ MAX _ LOGGED _ LATENCIES = 10000 ; 
 - private static final int DEFAULT _ NUMBER _ TRIALS _ PREDICTION = 10000 ; 
 - 
 - / * 
 - * We record a fixed size set of WARS latencies for read and 
 - * mutation operations . We store the order in which each 
 - * operation arrived , and use an LRU policy to evict old 
 - * messages . 
 - * 
 - * This information is stored as a mapping from messageIDs to 
 - * latencies . 
 - * / 
 - 
 - / * 
 - * Helper class which minimizes the number of HashMaps we maintain . 
 - * For a given messageId , this class maintains the startTime of the message , 
 - * and a queue for send times and reply times . 
 - * 
 - * sendLats corresponds to W and R , while replyLats is used for A and S . 
 - * / 
 - private class MessageLatencyCollection 
 - { 
 - MessageLatencyCollection ( Long startTime ) 
 - { 
 - this . startTime = startTime ; 
 - this . sendLats = new ConcurrentLinkedQueue < Long > ( ) ; 
 - this . replyLats = new ConcurrentLinkedQueue < Long > ( ) ; 
 - } 
 - 
 - void addSendLat ( Long sendLat ) 
 - { 
 - sendLats . add ( sendLat ) ; 
 - } 
 - 
 - void addReplyLat ( Long replyLat ) 
 - { 
 - replyLats . add ( replyLat ) ; 
 - } 
 - 
 - Collection < Long > getSendLats ( ) 
 - { 
 - return sendLats ; 
 - } 
 - 
 - Collection < Long > getReplyLats ( ) 
 - { 
 - return replyLats ; 
 - } 
 - 
 - Long getStartTime ( ) 
 - { 
 - return startTime ; 
 - } 
 - 
 - Long startTime ; 
 - Collection < Long > sendLats ; 
 - Collection < Long > replyLats ; 
 - } 
 - 
 - / / used for LRU replacement 
 - private final Queue < Integer > writeMessageIds = new LinkedBlockingQueue < Integer > ( ) ; 
 - private final Queue < Integer > readMessageIds = new LinkedBlockingQueue < Integer > ( ) ; 
 - 
 - private final Map < Integer , MessageLatencyCollection > messageIdToWriteLats = new ConcurrentHashMap < Integer , MessageLatencyCollection > ( ) ; 
 - private final Map < Integer , MessageLatencyCollection > messageIdToReadLats = new ConcurrentHashMap < Integer , MessageLatencyCollection > ( ) ; 
 - 
 - private Random random ; 
 - private boolean initialized = false ; 
 - 
 - private boolean logLatencies = DEFAULT _ DO _ LOG _ LATENCIES ; 
 - private int maxLoggedLatencies = DEFAULT _ MAX _ LOGGED _ LATENCIES ; 
 - private int numberTrialsPrediction = DEFAULT _ NUMBER _ TRIALS _ PREDICTION ; 
 - 
 - private static final PBSPredictor instance = new PBSPredictor ( ) ; 
 - 
 - public static PBSPredictor instance ( ) 
 - { 
 - return instance ; 
 - } 
 - 
 - private PBSPredictor ( ) 
 - { 
 - init ( ) ; 
 - } 
 - 
 - public void enableConsistencyPredictionLogging ( ) 
 - { 
 - logLatencies = true ; 
 - } 
 - 
 - public void disableConsistencyPredictionLogging ( ) 
 - { 
 - logLatencies = false ; 
 - } 
 - 
 - public boolean isLoggingEnabled ( ) 
 - { 
 - return logLatencies ; 
 - } 
 - 
 - public void setMaxLoggedLatenciesForConsistencyPrediction ( int maxLogged ) 
 - { 
 - maxLoggedLatencies = maxLogged ; 
 - } 
 - 
 - public void setNumberTrialsForConsistencyPrediction ( int numTrials ) 
 - { 
 - numberTrialsPrediction = numTrials ; 
 - } 
 - 
 - public void init ( ) 
 - { 
 - if ( ! initialized ) 
 - { 
 - random = new Random ( ) ; 
 - 
 - MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; 
 - try 
 - { 
 - mbs . registerMBean ( this , new ObjectName ( PBSPredictor . MBEAN _ NAME ) ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - initialized = true ; 
 - } 
 - } 
 - 
 - 
 - / / used for random sampling from the latencies 
 - private long getRandomElement ( List < Long > list ) 
 - { 
 - if ( list . size ( ) = = 0 ) 
 - throw new RuntimeException ( " Not enough data for prediction " ) ; 
 - return list . get ( random . nextInt ( list . size ( ) ) ) ; 
 - } 
 - 
 - / / used for calculating the average latency of a read or write operation 
 - / / given a set of simulated latencies 
 - private float listAverage ( List < Long > list ) 
 - { 
 - long accum = 0 ; 
 - for ( long value : list ) 
 - accum + = value ; 
 - return ( float ) accum / list . size ( ) ; 
 - } 
 - 
 - / / calculate the percentile entry of a list 
 - private long getPercentile ( List < Long > list , float percentile ) 
 - { 
 - Collections . sort ( list ) ; 
 - return list . get ( ( int ) ( list . size ( ) * percentile ) ) ; 
 - } 
 - 
 - / * 
 - * For our trials , sample the latency for the ( replicaNumber ) th 
 - * reply for one of WARS 
 - * if replicaNumber > the number of replicas we have data for 
 - * ( say we have data for ReplicationFactor 2 but ask for N = 3 ) 
 - * then we randomly sample from all response times 
 - * / 
 - private long getRandomLatencySample ( Map < Integer , List < Long > > samples , int replicaNumber ) 
 - { 
 - if ( samples . containsKey ( replicaNumber ) ) 
 - { 
 - return getRandomElement ( samples . get ( replicaNumber ) ) ; 
 - } 
 - 
 - return getRandomElement ( samples . get ( samples . keySet ( ) . toArray ( ) [ random . nextInt ( samples . keySet ( ) . size ( ) ) ] ) ) ; 
 - } 
 - 
 - / * 
 - * To perform the prediction , we randomly sample from the 
 - * collected WARS latencies , simulating writes followed by reads 
 - * exactly t milliseconds afterwards . We count the number of 
 - * reordered reads and writes to calculate the probability of 
 - * staleness along with recording operation latencies . 
 - * / 
 - 
 - 
 - public PBSPredictionResult doPrediction ( int n , 
 - int r , 
 - int w , 
 - float timeSinceWrite , 
 - int numberVersionsStale , 
 - float percentileLatency ) 
 - { 
 - if ( r > n ) 
 - throw new IllegalArgumentException ( " r must be less than n " ) ; 
 - if ( r < 0 ) 
 - throw new IllegalArgumentException ( " r must be positive " ) ; 
 - if ( w > n ) 
 - throw new IllegalArgumentException ( " w must be less than n " ) ; 
 - if ( w < 0 ) 
 - throw new IllegalArgumentException ( " w must be positive " ) ; 
 - if ( percentileLatency < 0 | | percentileLatency > 1 ) 
 - throw new IllegalArgumentException ( " percentileLatency must be between 0 and 1 inclusive " ) ; 
 - if ( numberVersionsStale < 0 ) 
 - throw new IllegalArgumentException ( " numberVersionsStale must be positive " ) ; 
 - 
 - if ( ! logLatencies ) 
 - throw new IllegalStateException ( " Latency logging is not enabled " ) ; 
 - 
 - / / get a mapping of { replica number : latency } for each of WARS 
 - Map < Integer , List < Long > > wLatencies = getOrderedWLatencies ( ) ; 
 - Map < Integer , List < Long > > aLatencies = getOrderedALatencies ( ) ; 
 - Map < Integer , List < Long > > rLatencies = getOrderedRLatencies ( ) ; 
 - Map < Integer , List < Long > > sLatencies = getOrderedSLatencies ( ) ; 
 - 
 - if ( wLatencies . isEmpty ( ) | | aLatencies . isEmpty ( ) ) 
 - throw new IllegalStateException ( " No write latencies have been recorded so far . Run some ( non - local ) inserts . " ) ; 
 - 
 - if ( rLatencies . isEmpty ( ) | | sLatencies . isEmpty ( ) ) 
 - throw new IllegalStateException ( " No read latencies have been recorded so far . Run some ( non - local ) reads . " ) ; 
 - 
 - / / storage for simulated read and write latencies 
 - ArrayList < Long > readLatencies = new ArrayList < Long > ( ) ; 
 - ArrayList < Long > writeLatencies = new ArrayList < Long > ( ) ; 
 - 
 - long consistentReads = 0 ; 
 - 
 - / / storage for latencies for each replica for a given Monte Carlo trial 
 - / / arr [ i ] will hold the ith replica ' s latency for one of WARS 
 - ArrayList < Long > trialWLatencies = new ArrayList < Long > ( ) ; 
 - ArrayList < Long > trialRLatencies = new ArrayList < Long > ( ) ; 
 - 
 - ArrayList < Long > replicaWriteLatencies = new ArrayList < Long > ( ) ; 
 - ArrayList < Long > replicaReadLatencies = new ArrayList < Long > ( ) ; 
 - 
 - / / run repeated trials and observe staleness 
 - for ( int i = 0 ; i < numberTrialsPrediction ; + + i ) 
 - { 
 - / / simulate sending a write to N replicas then sending a 
 - / / read to N replicas and record the latencies by randomly 
 - / / sampling from gathered latencies 
 - for ( int replicaNo = 0 ; replicaNo < n ; + + replicaNo ) 
 - { 
 - long trialWLatency = getRandomLatencySample ( wLatencies , replicaNo ) ; 
 - long trialALatency = getRandomLatencySample ( aLatencies , replicaNo ) ; 
 - 
 - trialWLatencies . add ( trialWLatency ) ; 
 - 
 - replicaWriteLatencies . add ( trialWLatency + trialALatency ) ; 
 - } 
 - 
 - / / reads are only sent to R replicas - so pick R random read and 
 - / / response latencies 
 - for ( int replicaNo = 0 ; replicaNo < r ; + + replicaNo ) 
 - { 
 - long trialRLatency = getRandomLatencySample ( rLatencies , replicaNo ) ; 
 - long trialSLatency = getRandomLatencySample ( sLatencies , replicaNo ) ; 
 - 
 - trialRLatencies . add ( trialRLatency ) ; 
 - 
 - replicaReadLatencies . add ( trialRLatency + trialSLatency ) ; 
 - } 
 - 
 - / / the write latency for this trial is the time it takes 
 - / / for the wth replica to respond ( W + A ) 
 - Collections . sort ( replicaWriteLatencies ) ; 
 - long writeLatency = replicaWriteLatencies . get ( w - 1 ) ; 
 - writeLatencies . add ( writeLatency ) ; 
 - 
 - ArrayList < Long > sortedReplicaReadLatencies = new ArrayList < Long > ( replicaReadLatencies ) ; 
 - Collections . sort ( sortedReplicaReadLatencies ) ; 
 - 
 - / / the read latency for this trial is the time it takes 
 - / / for the rth replica to respond ( R + S ) 
 - readLatencies . add ( sortedReplicaReadLatencies . get ( r - 1 ) ) ; 
 - 
 - / / were all of the read responses reordered ? 
 - 
 - / / for each of the first r messages ( the ones the 
 - / / coordinator will pick from ) : 
 - / / - - if the read message came in after this replica saw the 
 - / / write , it will be consistent 
 - / / - - each read request is sent at time 
 - / / writeLatency + timeSinceWrite 
 - 
 - for ( int responseNumber = 0 ; responseNumber < r ; + + responseNumber ) 
 - { 
 - int replicaNumber = replicaReadLatencies . indexOf ( sortedReplicaReadLatencies . get ( responseNumber ) ) ; 
 - 
 - if ( writeLatency + timeSinceWrite + trialRLatencies . get ( replicaNumber ) > = 
 - trialWLatencies . get ( replicaNumber ) ) 
 - { 
 - consistentReads + + ; 
 - break ; 
 - } 
 - 
 - / / tombstone this replica in the case that we have 
 - / / duplicate read latencies 
 - replicaReadLatencies . set ( replicaNumber , - 1L ) ; 
 - } 
 - 
 - / / clear storage for the next trial 
 - trialWLatencies . clear ( ) ; 
 - trialRLatencies . clear ( ) ; 
 - 
 - replicaReadLatencies . clear ( ) ; 
 - replicaWriteLatencies . clear ( ) ; 
 - } 
 - 
 - float oneVersionConsistencyProbability = ( float ) consistentReads / numberTrialsPrediction ; 
 - 
 - / / to calculate multi - version staleness , we exponentiate the staleness probability by the number of versions 
 - float consistencyProbability = ( float ) ( 1 - Math . pow ( ( double ) ( 1 - oneVersionConsistencyProbability ) , 
 - numberVersionsStale ) ) ; 
 - 
 - float averageWriteLatency = listAverage ( writeLatencies ) ; 
 - float averageReadLatency = listAverage ( readLatencies ) ; 
 - 
 - long percentileWriteLatency = getPercentile ( writeLatencies , percentileLatency ) ; 
 - long percentileReadLatency = getPercentile ( readLatencies , percentileLatency ) ; 
 - 
 - return new PBSPredictionResult ( n , 
 - r , 
 - w , 
 - timeSinceWrite , 
 - numberVersionsStale , 
 - consistencyProbability , 
 - averageReadLatency , 
 - averageWriteLatency , 
 - percentileReadLatency , 
 - percentileLatency , 
 - percentileWriteLatency , 
 - percentileLatency ) ; 
 - } 
 - 
 - public void startWriteOperation ( int id ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - startWriteOperation ( id , System . currentTimeMillis ( ) ) ; 
 - } 
 - 
 - public void startWriteOperation ( int id , long startTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - assert ( ! messageIdToWriteLats . containsKey ( id ) ) ; 
 - 
 - writeMessageIds . add ( id ) ; 
 - 
 - / / LRU replacement of latencies 
 - / / the maximum number of entries is sloppy , but that ' s acceptable for our purposes 
 - if ( writeMessageIds . size ( ) > maxLoggedLatencies ) 
 - { 
 - Integer toEvict = writeMessageIds . remove ( ) ; 
 - messageIdToWriteLats . remove ( toEvict ) ; 
 - } 
 - 
 - messageIdToWriteLats . put ( id , new MessageLatencyCollection ( startTime ) ) ; 
 - } 
 - 
 - public void startReadOperation ( int id ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - startReadOperation ( id , System . currentTimeMillis ( ) ) ; 
 - } 
 - 
 - public void startReadOperation ( int id , long startTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - assert ( ! messageIdToReadLats . containsKey ( id ) ) ; 
 - readMessageIds . add ( id ) ; 
 - 
 - / / LRU replacement of latencies 
 - / / the maximum number of entries is sloppy , but that ' s acceptable for our purposes 
 - if ( readMessageIds . size ( ) > maxLoggedLatencies ) 
 - { 
 - Integer toEvict = readMessageIds . remove ( ) ; 
 - messageIdToReadLats . remove ( toEvict ) ; 
 - } 
 - 
 - messageIdToReadLats . put ( id , new MessageLatencyCollection ( startTime ) ) ; 
 - } 
 - 
 - public void logWriteResponse ( int id , long constructionTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - logWriteResponse ( id , constructionTime , System . currentTimeMillis ( ) ) ; 
 - } 
 - 
 - public void logWriteResponse ( int id , long responseCreationTime , long receivedTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - MessageLatencyCollection writeLatsCollection = messageIdToWriteLats . get ( id ) ; 
 - if ( writeLatsCollection = = null ) 
 - { 
 - return ; 
 - } 
 - 
 - Long startTime = writeLatsCollection . getStartTime ( ) ; 
 - writeLatsCollection . addSendLat ( Math . max ( 0 , responseCreationTime - startTime ) ) ; 
 - writeLatsCollection . addReplyLat ( Math . max ( 0 , receivedTime - responseCreationTime ) ) ; 
 - } 
 - 
 - public void logReadResponse ( int id , long constructionTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - logReadResponse ( id , constructionTime , System . currentTimeMillis ( ) ) ; 
 - } 
 - 
 - public void logReadResponse ( int id , long responseCreationTime , long receivedTime ) 
 - { 
 - if ( ! logLatencies ) 
 - return ; 
 - 
 - MessageLatencyCollection readLatsCollection = messageIdToReadLats . get ( id ) ; 
 - if ( readLatsCollection = = null ) 
 - { 
 - return ; 
 - } 
 - 
 - Long startTime = readLatsCollection . getStartTime ( ) ; 
 - readLatsCollection . addSendLat ( Math . max ( 0 , responseCreationTime - startTime ) ) ; 
 - readLatsCollection . addReplyLat ( Math . max ( 0 , receivedTime - responseCreationTime ) ) ; 
 - } 
 - 
 - Map < Integer , List < Long > > getOrderedWLatencies ( ) 
 - { 
 - Collection < Collection < Long > > allWLatencies = new ArrayList < Collection < Long > > ( ) ; 
 - for ( MessageLatencyCollection wlc : messageIdToWriteLats . values ( ) ) 
 - { 
 - allWLatencies . add ( wlc . getSendLats ( ) ) ; 
 - } 
 - 
 - return getOrderedLatencies ( allWLatencies ) ; 
 - } 
 - 
 - Map < Integer , List < Long > > getOrderedALatencies ( ) 
 - { 
 - Collection < Collection < Long > > allALatencies = new ArrayList < Collection < Long > > ( ) ; 
 - for ( MessageLatencyCollection wlc : messageIdToWriteLats . values ( ) ) 
 - allALatencies . add ( wlc . getReplyLats ( ) ) ; 
 - return getOrderedLatencies ( allALatencies ) ; 
 - } 
 - 
 - Map < Integer , List < Long > > getOrderedRLatencies ( ) 
 - { 
 - Collection < Collection < Long > > allRLatencies = new ArrayList < Collection < Long > > ( ) ; 
 - for ( MessageLatencyCollection rlc : messageIdToReadLats . values ( ) ) 
 - { 
 - allRLatencies . add ( rlc . getSendLats ( ) ) ; 
 - } 
 - return getOrderedLatencies ( allRLatencies ) ; 
 - } 
 - 
 - Map < Integer , List < Long > > getOrderedSLatencies ( ) 
 - { 
 - Collection < Collection < Long > > allSLatencies = new ArrayList < Collection < Long > > ( ) ; 
 - for ( MessageLatencyCollection rlc : messageIdToReadLats . values ( ) ) 
 - allSLatencies . add ( rlc . getReplyLats ( ) ) ; 
 - return getOrderedLatencies ( allSLatencies ) ; 
 - } 
 - 
 - / / Return the collected latencies indexed by response number instead of by messageID 
 - private Map < Integer , List < Long > > getOrderedLatencies ( Collection < Collection < Long > > latencyLists ) 
 - { 
 - Map < Integer , List < Long > > ret = new HashMap < Integer , List < Long > > ( ) ; 
 - 
 - / / N may vary 
 - int maxResponses = 0 ; 
 - 
 - for ( Collection < Long > latencies : latencyLists ) 
 - { 
 - List < Long > sortedLatencies = new ArrayList < Long > ( latencies ) ; 
 - Collections . sort ( sortedLatencies ) ; 
 - 
 - if ( sortedLatencies . size ( ) > maxResponses ) 
 - { 
 - for ( int i = maxResponses + 1 ; i < = sortedLatencies . size ( ) ; + + i ) 
 - { 
 - ret . put ( i , new Vector < Long > ( ) ) ; 
 - } 
 - 
 - maxResponses = sortedLatencies . size ( ) ; 
 - } 
 - 
 - / / indexing by 0 is awkward since we ' re talking about the ith response 
 - for ( int i = 1 ; i < = sortedLatencies . size ( ) ; + + i ) 
 - { 
 - ret . get ( i ) . add ( sortedLatencies . get ( i - 1 ) ) ; 
 - } 
 - } 
 - 
 - return ret ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / service / PBSPredictorMBean . java b / src / java / org / apache / cassandra / service / PBSPredictorMBean . java 
 deleted file mode 100644 
 index 1e2f31a . . 0000000 
 - - - a / src / java / org / apache / cassandra / service / PBSPredictorMBean . java 
 + + + / dev / null 
 @ @ - 1 , 35 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service ; 
 - 
 - public interface PBSPredictorMBean 
 - { 
 - public PBSPredictionResult doPrediction ( int n , 
 - int r , 
 - int w , 
 - float timeSinceWrite , 
 - int numberVersionsStale , 
 - float percentileLatency ) ; 
 - 
 - public void enableConsistencyPredictionLogging ( ) ; 
 - public void disableConsistencyPredictionLogging ( ) ; 
 - 
 - public void setMaxLoggedLatenciesForConsistencyPrediction ( int maxLogged ) ; 
 - public void setNumberTrialsForConsistencyPrediction ( int numTrials ) ; 
 - } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 855c69a . . c1acb44 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 473 , 8 + 473 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 throw new AssertionError ( e ) ; 
 } 
 
 - PBSPredictor . instance ( ) . init ( ) ; 
 - 
 if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . load _ ring _ state " , " true " ) ) ) 
 { 
 logger . info ( " Loading persisted ring state " ) ; 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 2140358 . . 6e52f69 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 47 , 8 + 47 , 6 @ @ import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; 
 import org . apache . cassandra . net . MessagingServiceMBean ; 
 import org . apache . cassandra . service . CacheServiceMBean ; 
 - import org . apache . cassandra . service . PBSPredictionResult ; 
 - import org . apache . cassandra . service . PBSPredictorMBean ; 
 import org . apache . cassandra . service . StorageProxyMBean ; 
 import org . apache . cassandra . utils . EstimatedHistogram ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 157 , 7 + 155 , 6 @ @ public class NodeCmd 
 RANGEKEYSAMPLE , 
 REBUILD _ INDEX , 
 RESETLOCALSCHEMA , 
 - PREDICTCONSISTENCY 
 } 
 
 
 @ @ - 925 , 48 + 922 , 6 @ @ public class NodeCmd 
 outs . println ( probe . isThriftServerRunning ( ) ? " running " : " not running " ) ; 
 } 
 
 - public void predictConsistency ( Integer replicationFactor , 
 - Integer timeAfterWrite , 
 - Integer numVersions , 
 - Float percentileLatency , 
 - PrintStream output ) 
 - { 
 - PBSPredictorMBean predictorMBean = probe . getPBSPredictorMBean ( ) ; 
 - 
 - for ( int r = 1 ; r < = replicationFactor ; + + r ) { 
 - for ( int w = 1 ; w < = replicationFactor ; + + w ) { 
 - if ( w + r > replicationFactor + 1 ) 
 - continue ; 
 - 
 - try { 
 - PBSPredictionResult result = predictorMBean . doPrediction ( replicationFactor , 
 - r , 
 - w , 
 - timeAfterWrite , 
 - numVersions , 
 - percentileLatency ) ; 
 - 
 - if ( r = = 1 & & w = = 1 ) { 
 - output . printf ( " % dms after a given write , with maximum version staleness of k = % d % n " , timeAfterWrite , numVersions ) ; 
 - } 
 - 
 - output . printf ( " N = % d , R = % d , W = % d % n " , replicationFactor , r , w ) ; 
 - output . printf ( " Probability of consistent reads : % f % n " , result . getConsistencyProbability ( ) ) ; 
 - output . printf ( " Average read latency : % fms ( % . 3fth % % ile % dms ) % n " , result . getAverageReadLatency ( ) , 
 - result . getPercentileReadLatencyPercentile ( ) * 100 , 
 - result . getPercentileReadLatencyValue ( ) ) ; 
 - output . printf ( " Average write latency : % fms ( % . 3fth % % ile % dms ) % n % n " , result . getAverageWriteLatency ( ) , 
 - result . getPercentileWriteLatencyPercentile ( ) * 100 , 
 - result . getPercentileWriteLatencyValue ( ) ) ; 
 - } catch ( Exception e ) { 
 - System . out . println ( e . getMessage ( ) ) ; 
 - e . printStackTrace ( ) ; 
 - return ; 
 - } 
 - } 
 - } 
 - } 
 - 
 public static void main ( String [ ] args ) throws IOException , InterruptedException , ConfigurationException , ParseException 
 { 
 CommandLineParser parser = new PosixParser ( ) ; 
 @ @ - 1244 , 20 + 1199 , 6 @ @ public class NodeCmd 
 nodeCmd . printRangeKeySample ( System . out ) ; 
 break ; 
 
 - case PREDICTCONSISTENCY : 
 - if ( arguments . length < 2 ) { badUse ( " Requires replication factor and time " ) ; } 
 - int numVersions = 1 ; 
 - if ( arguments . length = = 3 ) { numVersions = Integer . parseInt ( arguments [ 2 ] ) ; } 
 - float percentileLatency = . 999f ; 
 - if ( arguments . length = = 4 ) { percentileLatency = Float . parseFloat ( arguments [ 3 ] ) ; } 
 - 
 - nodeCmd . predictConsistency ( Integer . parseInt ( arguments [ 0 ] ) , 
 - Integer . parseInt ( arguments [ 1 ] ) , 
 - numVersions , 
 - percentileLatency , 
 - System . out ) ; 
 - break ; 
 - 
 default : 
 throw new RuntimeException ( " Unreachable code . " ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index fb941f5 . . 753a64c 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 77 , 7 + 77 , 6 @ @ public class NodeProbe 
 public MessagingServiceMBean msProxy ; 
 private FailureDetectorMBean fdProxy ; 
 private CacheServiceMBean cacheService ; 
 - private PBSPredictorMBean PBSPredictorProxy ; 
 private StorageProxyMBean spProxy ; 
 private HintedHandOffManagerMBean hhProxy ; 
 private boolean failed ; 
 @ @ - 149 , 8 + 148 , 6 @ @ public class NodeProbe 
 { 
 ObjectName name = new ObjectName ( ssObjName ) ; 
 ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; 
 - name = new ObjectName ( PBSPredictor . MBEAN _ NAME ) ; 
 - PBSPredictorProxy = JMX . newMBeanProxy ( mbeanServerConn , name , PBSPredictorMBean . class ) ; 
 name = new ObjectName ( MessagingService . MBEAN _ NAME ) ; 
 msProxy = JMX . newMBeanProxy ( mbeanServerConn , name , MessagingServiceMBean . class ) ; 
 name = new ObjectName ( StreamingService . MBEAN _ OBJECT _ NAME ) ; 
 @ @ - 815 , 11 + 812 , 6 @ @ public class NodeProbe 
 return ssProxy . describeRingJMX ( keyspaceName ) ; 
 } 
 
 - public PBSPredictorMBean getPBSPredictorMBean ( ) 
 - { 
 - return PBSPredictorProxy ; 
 - } 
 - 
 public void rebuild ( String sourceDc ) 
 { 
 ssProxy . rebuild ( sourceDc ) ; 
 diff - - git a / test / unit / org / apache / cassandra / service / PBSPredictorTest . java b / test / unit / org / apache / cassandra / service / PBSPredictorTest . java 
 deleted file mode 100644 
 index a0e2ef0 . . 0000000 
 - - - a / test / unit / org / apache / cassandra / service / PBSPredictorTest . java 
 + + + / dev / null 
 @ @ - 1 , 114 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , 
 - * software distributed under the License is distributed on an 
 - * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 - * KIND , either express or implied . See the License for the 
 - * specific language governing permissions and limitations 
 - * under the License . 
 - * / 
 - package org . apache . cassandra . service ; 
 - 
 - import org . junit . Test ; 
 - import static org . junit . Assert . * ; 
 - 
 - public class PBSPredictorTest 
 - { 
 - private static PBSPredictor predictor = PBSPredictor . instance ( ) ; 
 - 
 - private void createWriteResponse ( long W , long A , int id ) 
 - { 
 - predictor . startWriteOperation ( id , 0 ) ; 
 - predictor . logWriteResponse ( id , W , W + A ) ; 
 - } 
 - 
 - private void createReadResponse ( long R , long S , int id ) 
 - { 
 - predictor . startReadOperation ( id , 0 ) ; 
 - predictor . logReadResponse ( id , R , R + S ) ; 
 - } 
 - 
 - @ Test 
 - public void testDoPrediction ( ) 
 - { 
 - try { 
 - predictor . enableConsistencyPredictionLogging ( ) ; 
 - predictor . init ( ) ; 
 - 
 - / * 
 - Ensure accuracy given a set of basic latencies 
 - Predictions here match a prior Python implementation 
 - * / 
 - 
 - for ( int i = 0 ; i < 10 ; + + i ) 
 - { 
 - createWriteResponse ( 10 , 0 , 10 * i ) ; 
 - createReadResponse ( 0 , 0 , 10 * i + 1 ) ; 
 - } 
 - 
 - for ( int i = 0 ; i < 10 ; + + i ) 
 - { 
 - createWriteResponse ( 0 , 0 , 10 * i + 2 ) ; 
 - } 
 - 
 - / / 10ms after write 
 - PBSPredictionResult result = predictor . doPrediction ( 2 , 1 , 1 , 10 . 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( 1 , result . getConsistencyProbability ( ) , 0 ) ; 
 - assertEquals ( 2 . 5 , result . getAverageWriteLatency ( ) , . 5 ) ; 
 - 
 - / / 0ms after write 
 - result = predictor . doPrediction ( 2 , 1 , 1 , 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( . 75 , result . getConsistencyProbability ( ) , 0 . 05 ) ; 
 - 
 - / / k = 5 versions staleness 
 - result = predictor . doPrediction ( 2 , 1 , 1 , 5 . 0f , 5 , 0 . 99f ) ; 
 - assertEquals ( . 98 , result . getConsistencyProbability ( ) , 0 . 05 ) ; 
 - assertEquals ( 2 . 5 , result . getAverageWriteLatency ( ) , . 5 ) ; 
 - 
 - for ( int i = 0 ; i < 10 ; + + i ) 
 - { 
 - createWriteResponse ( 20 , 0 , 10 * i + 3 ) ; 
 - } 
 - 
 - / / 5ms after write 
 - result = predictor . doPrediction ( 2 , 1 , 1 , 5 . 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( . 67 , result . getConsistencyProbability ( ) , . 05 ) ; 
 - 
 - / / N = 5 
 - result = predictor . doPrediction ( 5 , 1 , 1 , 5 . 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( . 42 , result . getConsistencyProbability ( ) , . 05 ) ; 
 - assertEquals ( 1 . 33 , result . getAverageWriteLatency ( ) , . 5 ) ; 
 - 
 - for ( int i = 0 ; i < 10 ; + + i ) 
 - { 
 - createWriteResponse ( 100 , 100 , 10 * i + 4 ) ; 
 - createReadResponse ( 100 , 100 , 10 * i + 5 ) ; 
 - } 
 - 
 - result = predictor . doPrediction ( 2 , 1 , 1 , 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( . 860 , result . getConsistencyProbability ( ) , . 05 ) ; 
 - assertEquals ( 26 . 5 , result . getAverageWriteLatency ( ) , 1 ) ; 
 - assertEquals ( 100 . 33 , result . getAverageReadLatency ( ) , 4 ) ; 
 - 
 - result = predictor . doPrediction ( 2 , 2 , 1 , 0f , 1 , 0 . 99f ) ; 
 - 
 - assertEquals ( 1 , result . getConsistencyProbability ( ) , 0 ) ; 
 - } catch ( Exception e ) { 
 - fail ( e . getMessage ( ) ) ; 
 - } 
 - } 
 - }
