BLEU SCORE: 1.0

TEST MSG: Handle short slice start / finishes of different lengths
GENERATED MSG: Handle short slice start / finishes of different lengths

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / marshal / CompositeType . java b / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> index 7f08219 . . 32fc432 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / CompositeType . java <nl> @ @ - 278 , 16 + 278 , 18 @ @ public class CompositeType extends AbstractCompositeType <nl> / / We could safely return true here , but there ' s a minor optimization : if the first component is restricted <nl> / / to a single value , we can check that the second component falls within the min / max for that component <nl> / / ( and repeat for all components ) . <nl> - for ( int i = 0 ; i < Math . min ( Math . min ( start . length , finish . length ) , minColumnNames . size ( ) ) ; i + + ) <nl> + for ( int i = 0 ; i < minColumnNames . size ( ) ; i + + ) <nl> { <nl> AbstractType < ? > t = types . get ( i ) ; <nl> + ByteBuffer s = i < start . length ? start [ i ] : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> + ByteBuffer f = i < finish . length ? finish [ i ] : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> <nl> / / we already know the first component falls within its min / max range ( otherwise we wouldn ' t get here ) <nl> - if ( i > 0 & & ! t . intersects ( minColumnNames . get ( i ) , maxColumnNames . get ( i ) , start [ i ] , finish [ i ] ) ) <nl> + if ( i > 0 & & ! t . intersects ( minColumnNames . get ( i ) , maxColumnNames . get ( i ) , s , f ) ) <nl> continue outer ; <nl> <nl> / / if this component isn ' t equal in the start and finish , we don ' t need to check any more <nl> - if ( t . compare ( start [ i ] , finish [ i ] ) ! = 0 ) <nl> + if ( i > = start . length | | i > = finish . length | | t . compare ( s , f ) ! = 0 ) <nl> break ; <nl> } <nl> return true ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java <nl> index 20cb5ef . . df6f5e1 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java <nl> @ @ - 458 , 6 + 458 , 10 @ @ public class CompositeTypeTest extends SchemaLoader <nl> filter = new SliceQueryFilter ( composite ( 1 , 2 ) , composite ( 1 , 3 ) , false , 1 ) ; <nl> assertFalse ( comparator . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 1 , 0 ) , filter ) ) ; <nl> <nl> + / / same case , but with missing start and end components and different lengths for start and end <nl> + filter = new SliceQueryFilter ( composite ( 1 , 2 ) , composite ( 1 ) , false , 1 ) ; <nl> + assertFalse ( comparator . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 1 , 0 ) , filter ) ) ; <nl> + <nl> <nl> / / same as the previous set of tests , but the second component is equal in the slice start and end <nl> filter = new SliceQueryFilter ( composite ( 1 , 2 , 0 ) , composite ( 1 , 2 , 0 ) , false , 1 ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / marshal / CompositeType . java b / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 index 7f08219 . . 32fc432 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / CompositeType . java 
 @ @ - 278 , 16 + 278 , 18 @ @ public class CompositeType extends AbstractCompositeType 
 / / We could safely return true here , but there ' s a minor optimization : if the first component is restricted 
 / / to a single value , we can check that the second component falls within the min / max for that component 
 / / ( and repeat for all components ) . 
 - for ( int i = 0 ; i < Math . min ( Math . min ( start . length , finish . length ) , minColumnNames . size ( ) ) ; i + + ) 
 + for ( int i = 0 ; i < minColumnNames . size ( ) ; i + + ) 
 { 
 AbstractType < ? > t = types . get ( i ) ; 
 + ByteBuffer s = i < start . length ? start [ i ] : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 + ByteBuffer f = i < finish . length ? finish [ i ] : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 
 / / we already know the first component falls within its min / max range ( otherwise we wouldn ' t get here ) 
 - if ( i > 0 & & ! t . intersects ( minColumnNames . get ( i ) , maxColumnNames . get ( i ) , start [ i ] , finish [ i ] ) ) 
 + if ( i > 0 & & ! t . intersects ( minColumnNames . get ( i ) , maxColumnNames . get ( i ) , s , f ) ) 
 continue outer ; 
 
 / / if this component isn ' t equal in the start and finish , we don ' t need to check any more 
 - if ( t . compare ( start [ i ] , finish [ i ] ) ! = 0 ) 
 + if ( i > = start . length | | i > = finish . length | | t . compare ( s , f ) ! = 0 ) 
 break ; 
 } 
 return true ; 
 diff - - git a / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java b / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java 
 index 20cb5ef . . df6f5e1 100644 
 - - - a / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java 
 + + + b / test / unit / org / apache / cassandra / db / marshal / CompositeTypeTest . java 
 @ @ - 458 , 6 + 458 , 10 @ @ public class CompositeTypeTest extends SchemaLoader 
 filter = new SliceQueryFilter ( composite ( 1 , 2 ) , composite ( 1 , 3 ) , false , 1 ) ; 
 assertFalse ( comparator . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 1 , 0 ) , filter ) ) ; 
 
 + / / same case , but with missing start and end components and different lengths for start and end 
 + filter = new SliceQueryFilter ( composite ( 1 , 2 ) , composite ( 1 ) , false , 1 ) ; 
 + assertFalse ( comparator . intersects ( columnNames ( 1 , 0 , 0 ) , columnNames ( 2 , 1 , 0 ) , filter ) ) ; 
 + 
 
 / / same as the previous set of tests , but the second component is equal in the slice start and end 
 filter = new SliceQueryFilter ( composite ( 1 , 2 , 0 ) , composite ( 1 , 2 , 0 ) , false , 1 ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
