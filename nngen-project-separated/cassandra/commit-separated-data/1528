BLEU SCORE: 0.020980574531482755

TEST MSG: Fix error msg when creating index on compact value columns
GENERATED MSG: Validate token ( ) args are in partition key order

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6e3a147 . . 80b4a8d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 17 <nl> + * Fix error message when attempting to create an index on a column <nl> + in a COMPACT STORAGE table with clustering columns ( CASSANDRA - 9527 ) <nl> * ' WITH WITH ' in alter keyspace statements causes NPE ( CASSANDRA - 9565 ) <nl> * Display min timestamp in sstablemetadata viewer ( CASSANDRA - 6767 ) <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> index 5710290 . . f2d698a 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> @ @ - 85 , 9 + 85 , 13 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> properties . validate ( ) ; <nl> <nl> / / TODO : we could lift that limitation <nl> - if ( ( cfm . getCfDef ( ) . isCompact | | ! cfm . getCfDef ( ) . isComposite ) & & cd . type ! = ColumnDefinition . Type . REGULAR ) <nl> + if ( ( cfm . getCfDef ( ) . isCompact | | ! cfm . getCfDef ( ) . isComposite ) <nl> + & & ( cd . type = = ColumnDefinition . Type . PARTITION _ KEY | | cd . type = = ColumnDefinition . Type . CLUSTERING _ KEY ) ) <nl> throw new InvalidRequestException ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " ) ; <nl> <nl> + if ( cd . type = = ColumnDefinition . Type . COMPACT _ VALUE ) <nl> + throw new InvalidRequestException ( " Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns " ) ; <nl> + <nl> / / It would be possible to support 2ndary index on static columns ( but not without modifications of at least ExtendedFilter and <nl> / / CompositesIndex ) and maybe we should , but that means a query like : <nl> / / SELECT * FROM foo WHERE static _ column = ' bar ' <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java b / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java <nl> new file mode 100644 <nl> index 0000000 . . a8bcf11 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java <nl> @ @ - 0 , 0 + 1 , 145 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + <nl> + import org . junit . AfterClass ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import static com . google . common . collect . Lists . newArrayList ; <nl> + <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . gms . Gossiper ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> + <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . process ; <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . fail ; <nl> + <nl> + public class CreateIndexTest <nl> + { <nl> + private static final String KEYSPACE = " create _ index _ test " ; <nl> + static ClientState clientState ; <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) throws Throwable <nl> + { <nl> + SchemaLoader . loadSchema ( ) ; <nl> + executeSchemaChange ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; <nl> + clientState = ClientState . forInternalCalls ( ) ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void stopGossiper ( ) <nl> + { <nl> + Gossiper . instance . stop ( ) ; <nl> + } <nl> + <nl> + private static void executeSchemaChange ( String query ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + process ( String . format ( query , KEYSPACE ) , ConsistencyLevel . ONE ) ; <nl> + } catch ( RuntimeException exc ) <nl> + { <nl> + throw exc . getCause ( ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreateIndexOnCompactTableWithClusteringColumns ( ) throws Throwable <nl> + { <nl> + executeSchemaChange ( " CREATE TABLE % s . compact _ table _ with _ clustering _ columns " <nl> + + " ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " <nl> + + " WITH COMPACT STORAGE ; " ) ; <nl> + <nl> + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , <nl> + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( a ) ; " ) ; <nl> + <nl> + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , <nl> + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( b ) ; " ) ; <nl> + <nl> + assertInvalid ( " Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns " , <nl> + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( c ) ; " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCreateIndexOnCompactTableWithoutClusteringColumns ( ) throws Throwable <nl> + { <nl> + executeSchemaChange ( " CREATE TABLE % s . compact _ table ( a int PRIMARY KEY , b int ) " <nl> + + " WITH COMPACT STORAGE ; " ) ; <nl> + <nl> + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , <nl> + " CREATE INDEX ON % s . compact _ table ( a ) ; " ) ; <nl> + <nl> + executeSchemaChange ( " CREATE INDEX ON % s . compact _ table ( b ) ; " ) ; <nl> + <nl> + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 1 , 1 ) ; " ) ; <nl> + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 2 , 4 ) ; " ) ; <nl> + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 3 , 6 ) ; " ) ; <nl> + <nl> + UntypedResultSet results = execute ( " SELECT * FROM % s . compact _ table WHERE b = 4 ; " ) ; <nl> + assertEquals ( 1 , results . size ( ) ) ; <nl> + checkRow ( 0 , results , 2 , 4 ) ; <nl> + } <nl> + <nl> + private static UntypedResultSet execute ( String query ) throws Throwable <nl> + { <nl> + try <nl> + { <nl> + return processInternal ( String . format ( query , KEYSPACE ) ) ; <nl> + } catch ( RuntimeException exc ) <nl> + { <nl> + if ( exc . getCause ( ) ! = null ) <nl> + throw exc . getCause ( ) ; <nl> + throw exc ; <nl> + } <nl> + } <nl> + <nl> + private static void checkRow ( int rowIndex , UntypedResultSet results , Integer . . . expectedValues ) <nl> + { <nl> + List < UntypedResultSet . Row > rows = newArrayList ( results . iterator ( ) ) ; <nl> + UntypedResultSet . Row row = rows . get ( rowIndex ) ; <nl> + Iterator < ColumnSpecification > columns = row . getColumns ( ) . iterator ( ) ; <nl> + for ( Integer expected : expectedValues ) <nl> + { <nl> + String columnName = columns . next ( ) . name . toString ( ) ; <nl> + int actual = row . getInt ( columnName ) ; <nl> + assertEquals ( String . format ( " Expected value % d for column % s in row % d , but got % s " , actual , columnName , rowIndex , expected ) , <nl> + ( long ) expected , actual ) ; <nl> + } <nl> + } <nl> + <nl> + private static void assertInvalid ( String msg , String stmt ) throws Throwable { <nl> + try <nl> + { <nl> + executeSchemaChange ( stmt ) ; <nl> + fail ( ) ; <nl> + } <nl> + catch ( InvalidRequestException e ) <nl> + { <nl> + assertEquals ( msg , e . getMessage ( ) ) ; <nl> + } <nl> + } }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6e3a147 . . 80b4a8d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 17 
 + * Fix error message when attempting to create an index on a column 
 + in a COMPACT STORAGE table with clustering columns ( CASSANDRA - 9527 ) 
 * ' WITH WITH ' in alter keyspace statements causes NPE ( CASSANDRA - 9565 ) 
 * Display min timestamp in sstablemetadata viewer ( CASSANDRA - 6767 ) 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 index 5710290 . . f2d698a 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 @ @ - 85 , 9 + 85 , 13 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 properties . validate ( ) ; 
 
 / / TODO : we could lift that limitation 
 - if ( ( cfm . getCfDef ( ) . isCompact | | ! cfm . getCfDef ( ) . isComposite ) & & cd . type ! = ColumnDefinition . Type . REGULAR ) 
 + if ( ( cfm . getCfDef ( ) . isCompact | | ! cfm . getCfDef ( ) . isComposite ) 
 + & & ( cd . type = = ColumnDefinition . Type . PARTITION _ KEY | | cd . type = = ColumnDefinition . Type . CLUSTERING _ KEY ) ) 
 throw new InvalidRequestException ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " ) ; 
 
 + if ( cd . type = = ColumnDefinition . Type . COMPACT _ VALUE ) 
 + throw new InvalidRequestException ( " Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns " ) ; 
 + 
 / / It would be possible to support 2ndary index on static columns ( but not without modifications of at least ExtendedFilter and 
 / / CompositesIndex ) and maybe we should , but that means a query like : 
 / / SELECT * FROM foo WHERE static _ column = ' bar ' 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java b / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java 
 new file mode 100644 
 index 0000000 . . a8bcf11 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / CreateIndexTest . java 
 @ @ - 0 , 0 + 1 , 145 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + 
 + import org . junit . AfterClass ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import static com . google . common . collect . Lists . newArrayList ; 
 + 
 + import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . gms . Gossiper ; 
 + import org . apache . cassandra . service . ClientState ; 
 + 
 + import static org . apache . cassandra . cql3 . QueryProcessor . process ; 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . fail ; 
 + 
 + public class CreateIndexTest 
 + { 
 + private static final String KEYSPACE = " create _ index _ test " ; 
 + static ClientState clientState ; 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) throws Throwable 
 + { 
 + SchemaLoader . loadSchema ( ) ; 
 + executeSchemaChange ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; 
 + clientState = ClientState . forInternalCalls ( ) ; 
 + } 
 + 
 + @ AfterClass 
 + public static void stopGossiper ( ) 
 + { 
 + Gossiper . instance . stop ( ) ; 
 + } 
 + 
 + private static void executeSchemaChange ( String query ) throws Throwable 
 + { 
 + try 
 + { 
 + process ( String . format ( query , KEYSPACE ) , ConsistencyLevel . ONE ) ; 
 + } catch ( RuntimeException exc ) 
 + { 
 + throw exc . getCause ( ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testCreateIndexOnCompactTableWithClusteringColumns ( ) throws Throwable 
 + { 
 + executeSchemaChange ( " CREATE TABLE % s . compact _ table _ with _ clustering _ columns " 
 + + " ( a int , b int , c int , PRIMARY KEY ( a , b ) ) " 
 + + " WITH COMPACT STORAGE ; " ) ; 
 + 
 + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , 
 + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( a ) ; " ) ; 
 + 
 + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , 
 + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( b ) ; " ) ; 
 + 
 + assertInvalid ( " Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns " , 
 + " CREATE INDEX ON % s . compact _ table _ with _ clustering _ columns ( c ) ; " ) ; 
 + } 
 + 
 + @ Test 
 + public void testCreateIndexOnCompactTableWithoutClusteringColumns ( ) throws Throwable 
 + { 
 + executeSchemaChange ( " CREATE TABLE % s . compact _ table ( a int PRIMARY KEY , b int ) " 
 + + " WITH COMPACT STORAGE ; " ) ; 
 + 
 + assertInvalid ( " Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables " , 
 + " CREATE INDEX ON % s . compact _ table ( a ) ; " ) ; 
 + 
 + executeSchemaChange ( " CREATE INDEX ON % s . compact _ table ( b ) ; " ) ; 
 + 
 + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 1 , 1 ) ; " ) ; 
 + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 2 , 4 ) ; " ) ; 
 + execute ( " INSERT INTO % s . compact _ table ( a , b ) VALUES ( 3 , 6 ) ; " ) ; 
 + 
 + UntypedResultSet results = execute ( " SELECT * FROM % s . compact _ table WHERE b = 4 ; " ) ; 
 + assertEquals ( 1 , results . size ( ) ) ; 
 + checkRow ( 0 , results , 2 , 4 ) ; 
 + } 
 + 
 + private static UntypedResultSet execute ( String query ) throws Throwable 
 + { 
 + try 
 + { 
 + return processInternal ( String . format ( query , KEYSPACE ) ) ; 
 + } catch ( RuntimeException exc ) 
 + { 
 + if ( exc . getCause ( ) ! = null ) 
 + throw exc . getCause ( ) ; 
 + throw exc ; 
 + } 
 + } 
 + 
 + private static void checkRow ( int rowIndex , UntypedResultSet results , Integer . . . expectedValues ) 
 + { 
 + List < UntypedResultSet . Row > rows = newArrayList ( results . iterator ( ) ) ; 
 + UntypedResultSet . Row row = rows . get ( rowIndex ) ; 
 + Iterator < ColumnSpecification > columns = row . getColumns ( ) . iterator ( ) ; 
 + for ( Integer expected : expectedValues ) 
 + { 
 + String columnName = columns . next ( ) . name . toString ( ) ; 
 + int actual = row . getInt ( columnName ) ; 
 + assertEquals ( String . format ( " Expected value % d for column % s in row % d , but got % s " , actual , columnName , rowIndex , expected ) , 
 + ( long ) expected , actual ) ; 
 + } 
 + } 
 + 
 + private static void assertInvalid ( String msg , String stmt ) throws Throwable { 
 + try 
 + { 
 + executeSchemaChange ( stmt ) ; 
 + fail ( ) ; 
 + } 
 + catch ( InvalidRequestException e ) 
 + { 
 + assertEquals ( msg , e . getMessage ( ) ) ; 
 + } 
 + } }

NEAREST DIFF:
ELIMINATEDSENTENCE
