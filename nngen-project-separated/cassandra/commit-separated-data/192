BLEU SCORE: 0.027611988917697356

TEST MSG: Better document in code InetAddressAndPort usage post 7544
GENERATED MSG: Support pluggable internode authentication

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c8eb6f0 . . d7f1f4e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Better document in code InetAddressAndPort usage post 7544 , incorporate port into UUIDGen node ( CASSANDRA - 14226 ) <nl> * Fix sstablemetadata date string for minLocalDeletionTime ( CASSANDRA - 14132 ) <nl> * Make it possible to change neverPurgeTombstones during runtime ( CASSANDRA - 14214 ) <nl> * Remove GossipDigestSynVerbHandler # doSort ( ) ( CASSANDRA - 14174 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 1db8217 . . 875751b 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 128 , 6 + 128 , 13 @ @ public class Config <nl> public boolean listen _ on _ broadcast _ address = false ; <nl> public String internode _ authenticator ; <nl> <nl> + / * <nl> + * RPC address and interface refer to the address / interface used for the native protocol used to communicate with <nl> + * clients . It ' s still called RPC in some places even though Thrift RPC is gone . If you see references to native <nl> + * address or native port it ' s derived from the RPC address configuration . <nl> + * <nl> + * native _ transport _ port is the port that is paired with RPC address to bind on . <nl> + * / <nl> public String rpc _ address ; <nl> public String rpc _ interface ; <nl> public boolean rpc _ interface _ prefer _ ipv6 = false ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 0714245 . . ccb0a30 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 1725 , 6 + 1725 , 12 @ @ public class DatabaseDescriptor <nl> broadcastAddress = broadcastAdd ; <nl> } <nl> <nl> + / * * <nl> + * This is the address used to bind for the native protocol to communicate with clients . Most usages in the code <nl> + * refer to it as native address although some places still call it RPC address . It ' s not thrift RPC anymore <nl> + * so native is more appropriate . The address alone is not enough to uniquely identify this instance because <nl> + * multiple instances might use the same interface with different ports . <nl> + * / <nl> public static InetAddress getRpcAddress ( ) <nl> { <nl> return rpcAddress ; <nl> @ @ - 1736 , 7 + 1742 , 12 @ @ public class DatabaseDescriptor <nl> } <nl> <nl> / * * <nl> - * May be null , please use { @ link FBUtilities # getBroadcastRpcAddress ( ) } instead . <nl> + * This is the address used to reach this instance for the native protocol to communicate with clients . Most usages in the code <nl> + * refer to it as native address although some places still call it RPC address . It ' s not thrift RPC anymore <nl> + * so native is more appropriate . The address alone is not enough to uniquely identify this instance because <nl> + * multiple instances might use the same interface with different ports . <nl> + * <nl> + * May be null , please use { @ link FBUtilities # getBroadcastNativeAddressAndPort ( ) } instead . <nl> * / <nl> public static InetAddress getBroadcastRpcAddress ( ) <nl> { <nl> @ @ - 1763 , 6 + 1774 , 10 @ @ public class DatabaseDescriptor <nl> return conf . start _ native _ transport ; <nl> } <nl> <nl> + / * * <nl> + * This is the port used with RPC address for the native protocol to communicate with clients . Now that thrift RPC <nl> + * is no longer in use there is no RPC port . <nl> + * / <nl> public static int getNativeTransportPort ( ) <nl> { <nl> return Integer . parseInt ( System . getProperty ( Config . PROPERTY _ PREFIX + " native _ transport _ port " , Integer . toString ( conf . native _ transport _ port ) ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> index 3ca8b89 . . 1565023 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> @ @ - 96 , 7 + 96 , 8 @ @ public class FBUtilities <nl> public static final int MAX _ UNSIGNED _ SHORT = 0xFFFF ; <nl> <nl> / * * <nl> - * Please use getJustBroadcastAddress instead . You need this only when you have to listen / connect . <nl> + * Please use getJustBroadcastAddress instead . You need this only when you have to listen / connect . It ' s also missing <nl> + * the port you should be using . 99 % of code doesn ' t want this . <nl> * / <nl> public static InetAddress getJustLocalAddress ( ) <nl> { <nl> @ @ - 114 , 6 + 115 , 10 @ @ public class FBUtilities <nl> return localInetAddress ; <nl> } <nl> <nl> + / * * <nl> + * The address and port to listen on for intra - cluster storage traffic ( not client ) . Use this to get the correct <nl> + * stuff to listen on for intra - cluster communication . <nl> + * / <nl> public static InetAddressAndPort getLocalAddressAndPort ( ) <nl> { <nl> if ( localInetAddressAndPort = = null ) <nl> @ @ - 123 , 6 + 128 , 10 @ @ public class FBUtilities <nl> return localInetAddressAndPort ; <nl> } <nl> <nl> + / * * <nl> + * Retrieve just the broadcast address but not the port . This is almost always the wrong thing to be using because <nl> + * it ' s ambiguous since you need the address and port to identify a node . You want getBroadcastAddressAndPort <nl> + * / <nl> public static InetAddress getJustBroadcastAddress ( ) <nl> { <nl> if ( broadcastInetAddress = = null ) <nl> @ @ - 132 , 6 + 141 , 11 @ @ public class FBUtilities <nl> return broadcastInetAddress ; <nl> } <nl> <nl> + / * * <nl> + * Get the broadcast address and port for intra - cluster storage traffic . This the address to advertise that uniquely <nl> + * identifies the node and is reachable from everywhere . This is the one you want unless you are trying to connect <nl> + * to the local address specifically . <nl> + * / <nl> public static InetAddressAndPort getBroadcastAddressAndPort ( ) <nl> { <nl> if ( broadcastInetAddressAndPort = = null ) <nl> @ @ - 150 , 6 + 164 , 10 @ @ public class FBUtilities <nl> broadcastInetAddressAndPort = InetAddressAndPort . getByAddress ( broadcastInetAddress ) ; <nl> } <nl> <nl> + / * * <nl> + * This returns the address that is bound to for the native protocol for communicating with clients . This is ambiguous <nl> + * because it doesn ' t include the port and it ' s almost always the wrong thing to be using you want getBroadcastNativeAddressAndPort <nl> + * / <nl> public static InetAddress getJustBroadcastNativeAddress ( ) <nl> { <nl> if ( broadcastNativeAddress = = null ) <nl> @ @ - 159 , 6 + 177 , 10 @ @ public class FBUtilities <nl> return broadcastNativeAddress ; <nl> } <nl> <nl> + / * * <nl> + * This returns the address that is bound to for the native protocol for communicating with clients . This is almost <nl> + * always what you need to identify a node and how to connect to it as a client . <nl> + * / <nl> public static InetAddressAndPort getBroadcastNativeAddressAndPort ( ) <nl> { <nl> if ( broadcastNativeAddressAndPort = = null ) <nl> @ @ - 167 , 25 + 189 , 6 @ @ public class FBUtilities <nl> return broadcastNativeAddressAndPort ; <nl> } <nl> <nl> - public static Collection < InetAddress > getAllLocalAddresses ( ) <nl> - { <nl> - Set < InetAddress > localAddresses = new HashSet < InetAddress > ( ) ; <nl> - try <nl> - { <nl> - Enumeration < NetworkInterface > nets = NetworkInterface . getNetworkInterfaces ( ) ; <nl> - if ( nets ! = null ) <nl> - { <nl> - while ( nets . hasMoreElements ( ) ) <nl> - localAddresses . addAll ( Collections . list ( nets . nextElement ( ) . getInetAddresses ( ) ) ) ; <nl> - } <nl> - } <nl> - catch ( SocketException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - return localAddresses ; <nl> - } <nl> - <nl> public static String getNetworkInterface ( InetAddress localAddress ) <nl> { <nl> try <nl> diff - - git a / src / java / org / apache / cassandra / utils / UUIDGen . java b / src / java / org / apache / cassandra / utils / UUIDGen . java <nl> index 19a0f83 . . 103042d 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / UUIDGen . java <nl> + + + b / src / java / org / apache / cassandra / utils / UUIDGen . java <nl> @ @ - 18 , 19 + 18 , 31 @ @ <nl> package org . apache . cassandra . utils ; <nl> <nl> import java . net . InetAddress ; <nl> + import java . net . NetworkInterface ; <nl> + import java . net . SocketException ; <nl> import java . nio . ByteBuffer ; <nl> import java . security . SecureRandom ; <nl> import java . util . Collection ; <nl> + import java . util . Collections ; <nl> + import java . util . Enumeration ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> import java . util . Random ; <nl> + import java . util . Set ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . atomic . AtomicLong ; <nl> import java . util . concurrent . TimeUnit ; <nl> + import java . util . function . Function ; <nl> + import java . util . stream . Collectors ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . hash . Hasher ; <nl> import com . google . common . hash . Hashing ; <nl> import com . google . common . primitives . Ints ; <nl> <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + <nl> / * * <nl> * The goods are here : www . ietf . org / rfc / rfc4122 . txt . <nl> * / <nl> @ @ - 361 , 7 + 373 , 7 @ @ public class UUIDGen <nl> * instanciation and the UUID generator is used in Stress for instance , <nl> * where we don ' t want to require the yaml . <nl> * / <nl> - Collection < InetAddress > localAddresses = FBUtilities . getAllLocalAddresses ( ) ; <nl> + Collection < InetAddressAndPort > localAddresses = getAllLocalAddresses ( ) ; <nl> if ( localAddresses . isEmpty ( ) ) <nl> throw new RuntimeException ( " Cannot generate the node component of the UUID because cannot retrieve any IP addresses . " ) ; <nl> <nl> @ @ - 377 , 12 + 389 , 15 @ @ public class UUIDGen <nl> return node | 0x0000010000000000L ; <nl> } <nl> <nl> - private static byte [ ] hash ( Collection < InetAddress > data ) <nl> + private static byte [ ] hash ( Collection < InetAddressAndPort > data ) <nl> { <nl> / / Identify the host . <nl> Hasher hasher = Hashing . md5 ( ) . newHasher ( ) ; <nl> - for ( InetAddress addr : data ) <nl> - hasher . putBytes ( addr . getAddress ( ) ) ; <nl> + for ( InetAddressAndPort addr : data ) <nl> + { <nl> + hasher . putBytes ( addr . addressBytes ) ; <nl> + hasher . putInt ( addr . port ) ; <nl> + } <nl> <nl> / / Identify the process on the load : we use both the PID and class loader hash . <nl> long pid = NativeLibrary . getProcessID ( ) ; <nl> @ @ - 396 , 6 + 411 , 41 @ @ public class UUIDGen <nl> <nl> return hasher . hash ( ) . asBytes ( ) ; <nl> } <nl> + <nl> + / * * <nl> + * Helper function used exclusively by UUIDGen to create <nl> + * * / <nl> + public static Collection < InetAddressAndPort > getAllLocalAddresses ( ) <nl> + { <nl> + Set < InetAddressAndPort > localAddresses = new HashSet < > ( ) ; <nl> + try <nl> + { <nl> + Enumeration < NetworkInterface > nets = NetworkInterface . getNetworkInterfaces ( ) ; <nl> + if ( nets ! = null ) <nl> + { <nl> + while ( nets . hasMoreElements ( ) ) <nl> + { <nl> + Function < InetAddress , InetAddressAndPort > converter = <nl> + address - > InetAddressAndPort . getByAddressOverrideDefaults ( address , 0 ) ; <nl> + List < InetAddressAndPort > addresses = <nl> + Collections . list ( nets . nextElement ( ) . getInetAddresses ( ) ) . stream ( ) . map ( converter ) . collect ( Collectors . toList ( ) ) ; <nl> + localAddresses . addAll ( addresses ) ; <nl> + } <nl> + } <nl> + } <nl> + catch ( SocketException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + if ( DatabaseDescriptor . isDaemonInitialized ( ) ) <nl> + { <nl> + localAddresses . add ( FBUtilities . getBroadcastAddressAndPort ( ) ) ; <nl> + localAddresses . add ( FBUtilities . getBroadcastNativeAddressAndPort ( ) ) ; <nl> + localAddresses . add ( FBUtilities . getLocalAddressAndPort ( ) ) ; <nl> + } <nl> + return localAddresses ; <nl> + } <nl> + <nl> } <nl> <nl> / / for the curious , here is how I generated START _ EPOCH
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 4f3e1e1 . . ed82e32 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 145 , 6 + 145 , 7 @ @ public class NodeCmd <nl> SETTRACEPROBABILITY , <nl> SNAPSHOT , <nl> STATUS , <nl> + STATUSBINARY , <nl> STATUSTHRIFT , <nl> STOP , <nl> TPSTATS , <nl> @ @ - 912 , 6 + 913 , 11 @ @ public class NodeCmd <nl> } <nl> } <nl> <nl> + private void printIsNativeTransportRunning ( PrintStream outs ) <nl> + { <nl> + outs . println ( probe . isNativeTransportRunning ( ) ? " running " : " not running " ) ; <nl> + } <nl> + <nl> private void printIsThriftServerRunning ( PrintStream outs ) <nl> { <nl> outs . println ( probe . isThriftServerRunning ( ) ? " running " : " not running " ) ; <nl> @ @ - 1052 , 6 + 1058 , 7 @ @ public class NodeCmd <nl> case COMPACTIONSTATS : nodeCmd . printCompactionStats ( System . out ) ; break ; <nl> case DISABLEBINARY : probe . stopNativeTransport ( ) ; break ; <nl> case ENABLEBINARY : probe . startNativeTransport ( ) ; break ; <nl> + case STATUSBINARY : nodeCmd . printIsNativeTransportRunning ( System . out ) ; break ; <nl> case DISABLEGOSSIP : probe . stopGossiping ( ) ; break ; <nl> case ENABLEGOSSIP : probe . startGossiping ( ) ; break ; <nl> case DISABLEHANDOFF : probe . disableHintedHandoff ( ) ; break ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index 43d99d2 . . e6eca7b 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 710 , 6 + 710 , 11 @ @ public class NodeProbe <nl> ssProxy . startNativeTransport ( ) ; <nl> } <nl> <nl> + public boolean isNativeTransportRunning ( ) <nl> + { <nl> + return ssProxy . isNativeTransportRunning ( ) ; <nl> + } <nl> + <nl> public void stopGossiping ( ) <nl> { <nl> ssProxy . stopGossiping ( ) ; <nl> diff - - git a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> index 6551b07 . . f3cd88e 100644 <nl> - - - a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> + + + b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml <nl> @ @ - 55 , 6 + 55 , 9 @ @ commands : <nl> - name : enablebinary <nl> help : | <nl> Reenable native transport ( binary protocol ) <nl> + - name : statusbinary <nl> + help : | <nl> + Status of native transport ( binary protocol ) <nl> - name : disablehandoff <nl> help : | <nl> Disable the future hints storing on the current node

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c8eb6f0 . . d7f1f4e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Better document in code InetAddressAndPort usage post 7544 , incorporate port into UUIDGen node ( CASSANDRA - 14226 ) 
 * Fix sstablemetadata date string for minLocalDeletionTime ( CASSANDRA - 14132 ) 
 * Make it possible to change neverPurgeTombstones during runtime ( CASSANDRA - 14214 ) 
 * Remove GossipDigestSynVerbHandler # doSort ( ) ( CASSANDRA - 14174 ) 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 1db8217 . . 875751b 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 128 , 6 + 128 , 13 @ @ public class Config 
 public boolean listen _ on _ broadcast _ address = false ; 
 public String internode _ authenticator ; 
 
 + / * 
 + * RPC address and interface refer to the address / interface used for the native protocol used to communicate with 
 + * clients . It ' s still called RPC in some places even though Thrift RPC is gone . If you see references to native 
 + * address or native port it ' s derived from the RPC address configuration . 
 + * 
 + * native _ transport _ port is the port that is paired with RPC address to bind on . 
 + * / 
 public String rpc _ address ; 
 public String rpc _ interface ; 
 public boolean rpc _ interface _ prefer _ ipv6 = false ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 0714245 . . ccb0a30 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 1725 , 6 + 1725 , 12 @ @ public class DatabaseDescriptor 
 broadcastAddress = broadcastAdd ; 
 } 
 
 + / * * 
 + * This is the address used to bind for the native protocol to communicate with clients . Most usages in the code 
 + * refer to it as native address although some places still call it RPC address . It ' s not thrift RPC anymore 
 + * so native is more appropriate . The address alone is not enough to uniquely identify this instance because 
 + * multiple instances might use the same interface with different ports . 
 + * / 
 public static InetAddress getRpcAddress ( ) 
 { 
 return rpcAddress ; 
 @ @ - 1736 , 7 + 1742 , 12 @ @ public class DatabaseDescriptor 
 } 
 
 / * * 
 - * May be null , please use { @ link FBUtilities # getBroadcastRpcAddress ( ) } instead . 
 + * This is the address used to reach this instance for the native protocol to communicate with clients . Most usages in the code 
 + * refer to it as native address although some places still call it RPC address . It ' s not thrift RPC anymore 
 + * so native is more appropriate . The address alone is not enough to uniquely identify this instance because 
 + * multiple instances might use the same interface with different ports . 
 + * 
 + * May be null , please use { @ link FBUtilities # getBroadcastNativeAddressAndPort ( ) } instead . 
 * / 
 public static InetAddress getBroadcastRpcAddress ( ) 
 { 
 @ @ - 1763 , 6 + 1774 , 10 @ @ public class DatabaseDescriptor 
 return conf . start _ native _ transport ; 
 } 
 
 + / * * 
 + * This is the port used with RPC address for the native protocol to communicate with clients . Now that thrift RPC 
 + * is no longer in use there is no RPC port . 
 + * / 
 public static int getNativeTransportPort ( ) 
 { 
 return Integer . parseInt ( System . getProperty ( Config . PROPERTY _ PREFIX + " native _ transport _ port " , Integer . toString ( conf . native _ transport _ port ) ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 index 3ca8b89 . . 1565023 100644 
 - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java 
 + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 @ @ - 96 , 7 + 96 , 8 @ @ public class FBUtilities 
 public static final int MAX _ UNSIGNED _ SHORT = 0xFFFF ; 
 
 / * * 
 - * Please use getJustBroadcastAddress instead . You need this only when you have to listen / connect . 
 + * Please use getJustBroadcastAddress instead . You need this only when you have to listen / connect . It ' s also missing 
 + * the port you should be using . 99 % of code doesn ' t want this . 
 * / 
 public static InetAddress getJustLocalAddress ( ) 
 { 
 @ @ - 114 , 6 + 115 , 10 @ @ public class FBUtilities 
 return localInetAddress ; 
 } 
 
 + / * * 
 + * The address and port to listen on for intra - cluster storage traffic ( not client ) . Use this to get the correct 
 + * stuff to listen on for intra - cluster communication . 
 + * / 
 public static InetAddressAndPort getLocalAddressAndPort ( ) 
 { 
 if ( localInetAddressAndPort = = null ) 
 @ @ - 123 , 6 + 128 , 10 @ @ public class FBUtilities 
 return localInetAddressAndPort ; 
 } 
 
 + / * * 
 + * Retrieve just the broadcast address but not the port . This is almost always the wrong thing to be using because 
 + * it ' s ambiguous since you need the address and port to identify a node . You want getBroadcastAddressAndPort 
 + * / 
 public static InetAddress getJustBroadcastAddress ( ) 
 { 
 if ( broadcastInetAddress = = null ) 
 @ @ - 132 , 6 + 141 , 11 @ @ public class FBUtilities 
 return broadcastInetAddress ; 
 } 
 
 + / * * 
 + * Get the broadcast address and port for intra - cluster storage traffic . This the address to advertise that uniquely 
 + * identifies the node and is reachable from everywhere . This is the one you want unless you are trying to connect 
 + * to the local address specifically . 
 + * / 
 public static InetAddressAndPort getBroadcastAddressAndPort ( ) 
 { 
 if ( broadcastInetAddressAndPort = = null ) 
 @ @ - 150 , 6 + 164 , 10 @ @ public class FBUtilities 
 broadcastInetAddressAndPort = InetAddressAndPort . getByAddress ( broadcastInetAddress ) ; 
 } 
 
 + / * * 
 + * This returns the address that is bound to for the native protocol for communicating with clients . This is ambiguous 
 + * because it doesn ' t include the port and it ' s almost always the wrong thing to be using you want getBroadcastNativeAddressAndPort 
 + * / 
 public static InetAddress getJustBroadcastNativeAddress ( ) 
 { 
 if ( broadcastNativeAddress = = null ) 
 @ @ - 159 , 6 + 177 , 10 @ @ public class FBUtilities 
 return broadcastNativeAddress ; 
 } 
 
 + / * * 
 + * This returns the address that is bound to for the native protocol for communicating with clients . This is almost 
 + * always what you need to identify a node and how to connect to it as a client . 
 + * / 
 public static InetAddressAndPort getBroadcastNativeAddressAndPort ( ) 
 { 
 if ( broadcastNativeAddressAndPort = = null ) 
 @ @ - 167 , 25 + 189 , 6 @ @ public class FBUtilities 
 return broadcastNativeAddressAndPort ; 
 } 
 
 - public static Collection < InetAddress > getAllLocalAddresses ( ) 
 - { 
 - Set < InetAddress > localAddresses = new HashSet < InetAddress > ( ) ; 
 - try 
 - { 
 - Enumeration < NetworkInterface > nets = NetworkInterface . getNetworkInterfaces ( ) ; 
 - if ( nets ! = null ) 
 - { 
 - while ( nets . hasMoreElements ( ) ) 
 - localAddresses . addAll ( Collections . list ( nets . nextElement ( ) . getInetAddresses ( ) ) ) ; 
 - } 
 - } 
 - catch ( SocketException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - return localAddresses ; 
 - } 
 - 
 public static String getNetworkInterface ( InetAddress localAddress ) 
 { 
 try 
 diff - - git a / src / java / org / apache / cassandra / utils / UUIDGen . java b / src / java / org / apache / cassandra / utils / UUIDGen . java 
 index 19a0f83 . . 103042d 100644 
 - - - a / src / java / org / apache / cassandra / utils / UUIDGen . java 
 + + + b / src / java / org / apache / cassandra / utils / UUIDGen . java 
 @ @ - 18 , 19 + 18 , 31 @ @ 
 package org . apache . cassandra . utils ; 
 
 import java . net . InetAddress ; 
 + import java . net . NetworkInterface ; 
 + import java . net . SocketException ; 
 import java . nio . ByteBuffer ; 
 import java . security . SecureRandom ; 
 import java . util . Collection ; 
 + import java . util . Collections ; 
 + import java . util . Enumeration ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 import java . util . Random ; 
 + import java . util . Set ; 
 import java . util . UUID ; 
 import java . util . concurrent . atomic . AtomicLong ; 
 import java . util . concurrent . TimeUnit ; 
 + import java . util . function . Function ; 
 + import java . util . stream . Collectors ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . hash . Hasher ; 
 import com . google . common . hash . Hashing ; 
 import com . google . common . primitives . Ints ; 
 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + 
 / * * 
 * The goods are here : www . ietf . org / rfc / rfc4122 . txt . 
 * / 
 @ @ - 361 , 7 + 373 , 7 @ @ public class UUIDGen 
 * instanciation and the UUID generator is used in Stress for instance , 
 * where we don ' t want to require the yaml . 
 * / 
 - Collection < InetAddress > localAddresses = FBUtilities . getAllLocalAddresses ( ) ; 
 + Collection < InetAddressAndPort > localAddresses = getAllLocalAddresses ( ) ; 
 if ( localAddresses . isEmpty ( ) ) 
 throw new RuntimeException ( " Cannot generate the node component of the UUID because cannot retrieve any IP addresses . " ) ; 
 
 @ @ - 377 , 12 + 389 , 15 @ @ public class UUIDGen 
 return node | 0x0000010000000000L ; 
 } 
 
 - private static byte [ ] hash ( Collection < InetAddress > data ) 
 + private static byte [ ] hash ( Collection < InetAddressAndPort > data ) 
 { 
 / / Identify the host . 
 Hasher hasher = Hashing . md5 ( ) . newHasher ( ) ; 
 - for ( InetAddress addr : data ) 
 - hasher . putBytes ( addr . getAddress ( ) ) ; 
 + for ( InetAddressAndPort addr : data ) 
 + { 
 + hasher . putBytes ( addr . addressBytes ) ; 
 + hasher . putInt ( addr . port ) ; 
 + } 
 
 / / Identify the process on the load : we use both the PID and class loader hash . 
 long pid = NativeLibrary . getProcessID ( ) ; 
 @ @ - 396 , 6 + 411 , 41 @ @ public class UUIDGen 
 
 return hasher . hash ( ) . asBytes ( ) ; 
 } 
 + 
 + / * * 
 + * Helper function used exclusively by UUIDGen to create 
 + * * / 
 + public static Collection < InetAddressAndPort > getAllLocalAddresses ( ) 
 + { 
 + Set < InetAddressAndPort > localAddresses = new HashSet < > ( ) ; 
 + try 
 + { 
 + Enumeration < NetworkInterface > nets = NetworkInterface . getNetworkInterfaces ( ) ; 
 + if ( nets ! = null ) 
 + { 
 + while ( nets . hasMoreElements ( ) ) 
 + { 
 + Function < InetAddress , InetAddressAndPort > converter = 
 + address - > InetAddressAndPort . getByAddressOverrideDefaults ( address , 0 ) ; 
 + List < InetAddressAndPort > addresses = 
 + Collections . list ( nets . nextElement ( ) . getInetAddresses ( ) ) . stream ( ) . map ( converter ) . collect ( Collectors . toList ( ) ) ; 
 + localAddresses . addAll ( addresses ) ; 
 + } 
 + } 
 + } 
 + catch ( SocketException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + if ( DatabaseDescriptor . isDaemonInitialized ( ) ) 
 + { 
 + localAddresses . add ( FBUtilities . getBroadcastAddressAndPort ( ) ) ; 
 + localAddresses . add ( FBUtilities . getBroadcastNativeAddressAndPort ( ) ) ; 
 + localAddresses . add ( FBUtilities . getLocalAddressAndPort ( ) ) ; 
 + } 
 + return localAddresses ; 
 + } 
 + 
 } 
 
 / / for the curious , here is how I generated START _ EPOCH

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 4f3e1e1 . . ed82e32 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 145 , 6 + 145 , 7 @ @ public class NodeCmd 
 SETTRACEPROBABILITY , 
 SNAPSHOT , 
 STATUS , 
 + STATUSBINARY , 
 STATUSTHRIFT , 
 STOP , 
 TPSTATS , 
 @ @ - 912 , 6 + 913 , 11 @ @ public class NodeCmd 
 } 
 } 
 
 + private void printIsNativeTransportRunning ( PrintStream outs ) 
 + { 
 + outs . println ( probe . isNativeTransportRunning ( ) ? " running " : " not running " ) ; 
 + } 
 + 
 private void printIsThriftServerRunning ( PrintStream outs ) 
 { 
 outs . println ( probe . isThriftServerRunning ( ) ? " running " : " not running " ) ; 
 @ @ - 1052 , 6 + 1058 , 7 @ @ public class NodeCmd 
 case COMPACTIONSTATS : nodeCmd . printCompactionStats ( System . out ) ; break ; 
 case DISABLEBINARY : probe . stopNativeTransport ( ) ; break ; 
 case ENABLEBINARY : probe . startNativeTransport ( ) ; break ; 
 + case STATUSBINARY : nodeCmd . printIsNativeTransportRunning ( System . out ) ; break ; 
 case DISABLEGOSSIP : probe . stopGossiping ( ) ; break ; 
 case ENABLEGOSSIP : probe . startGossiping ( ) ; break ; 
 case DISABLEHANDOFF : probe . disableHintedHandoff ( ) ; break ; 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index 43d99d2 . . e6eca7b 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 710 , 6 + 710 , 11 @ @ public class NodeProbe 
 ssProxy . startNativeTransport ( ) ; 
 } 
 
 + public boolean isNativeTransportRunning ( ) 
 + { 
 + return ssProxy . isNativeTransportRunning ( ) ; 
 + } 
 + 
 public void stopGossiping ( ) 
 { 
 ssProxy . stopGossiping ( ) ; 
 diff - - git a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 index 6551b07 . . f3cd88e 100644 
 - - - a / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 + + + b / src / resources / org / apache / cassandra / tools / NodeToolHelp . yaml 
 @ @ - 55 , 6 + 55 , 9 @ @ commands : 
 - name : enablebinary 
 help : | 
 Reenable native transport ( binary protocol ) 
 + - name : statusbinary 
 + help : | 
 + Status of native transport ( binary protocol ) 
 - name : disablehandoff 
 help : | 
 Disable the future hints storing on the current node
