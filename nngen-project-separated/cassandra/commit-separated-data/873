BLEU SCORE: 0.0064335654798045845

TEST MSG: Prohibit reversed counter type as part of the primary key . Check the actual CQL3Type to get the base type from the abstract type when comparing against CounterColumnType .
GENERATED MSG: Improve CQL3 batchlog support

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a46aa56 . . 18cd90b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 7 <nl> + * Prohibit Reverse Counter type as part of the PK ( CASSANDRA - 9395 ) <nl> * cqlsh : correctly handle non - ascii chars in error messages ( CASSANDRA - 11626 ) <nl> * Exit JVM if JMX server fails to startup ( CASSANDRA - 11540 ) <nl> * Produce a heap dump when exiting on OOM ( CASSANDRA - 9861 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> index 1b3665c . . e761674 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> @ @ - 268 , 7 + 268 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> { <nl> stmt . keyAliases . add ( alias . bytes ) ; <nl> AbstractType < ? > t = getTypeAndRemove ( stmt . columns , alias ) ; <nl> - if ( t instanceof CounterColumnType ) <nl> + if ( t . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) <nl> throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , alias ) ) ; <nl> if ( staticColumns . contains ( alias ) ) <nl> throw new InvalidRequestException ( String . format ( " Static column % s cannot be part of the PRIMARY KEY " , alias ) ) ; <nl> @ @ - 316 , 7 + 316 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> <nl> stmt . columnAliases . add ( alias . bytes ) ; <nl> AbstractType < ? > at = getTypeAndRemove ( stmt . columns , alias ) ; <nl> - if ( at instanceof CounterColumnType ) <nl> + if ( at . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) <nl> throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , stmt . columnAliases . get ( 0 ) ) ) ; <nl> stmt . comparator = new SimpleDenseCellNameType ( at ) ; <nl> } <nl> @ @ - 328 , 7 + 328 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> stmt . columnAliases . add ( t . bytes ) ; <nl> <nl> AbstractType < ? > type = getTypeAndRemove ( stmt . columns , t ) ; <nl> - if ( type instanceof CounterColumnType ) <nl> + if ( type . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) <nl> throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , t ) ) ; <nl> if ( staticColumns . contains ( t ) ) <nl> throw new InvalidRequestException ( String . format ( " Static column % s cannot be part of the PRIMARY KEY " , t ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java <nl> index e5ff251 . . 41b73bc 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java <nl> @ @ - 112 , 4 + 112 , 15 @ @ public class CountersTest extends CQLTester <nl> row ( 1L ) / / no change to the counter value <nl> ) ; <nl> } <nl> + <nl> + / * * <nl> + * Test for the validation bug of # 9395 . <nl> + * / <nl> + @ Test <nl> + public void testProhibitReversedCounterAsPartOfPrimaryKey ( ) throws Throwable <nl> + { <nl> + assertInvalidThrowMessage ( " counter type is not supported for PRIMARY KEY part a " , <nl> + InvalidRequestException . class , String . format ( " CREATE TABLE % s . % s ( a counter , b int , PRIMARY KEY ( b , a ) ) WITH CLUSTERING ORDER BY ( a desc ) ; " , KEYSPACE , createTableName ( ) ) ) ; <nl> + } <nl> + <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1363c22 . . e922c3c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) <nl> * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) <nl> * add authentication support to sstableloader ( CASSANDRA - 4712 ) <nl> + * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) <nl> Merged from 1 . 0 : <nl> * Switch from NBHM to CHM in MessagingService ' s callback map , which <nl> prevents OOM in long - running instances ( CASSANDRA - 4708 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index bbddee3 . . fac0deb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 88 , 10 + 88 , 16 @ @ public class SelectStatement implements CQLStatement <nl> START ( 0 ) , END ( 1 ) ; <nl> <nl> public final int idx ; <nl> + <nl> Bound ( int idx ) <nl> { <nl> this . idx = idx ; <nl> } <nl> + <nl> + public static Bound reverse ( Bound b ) <nl> + { <nl> + return b = = START ? END : START ; <nl> + } <nl> } ; <nl> <nl> public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters ) <nl> @ @ - 189 , 8 + 195 , 8 @ @ public class SelectStatement implements CQLStatement <nl> / / . . . a range ( slice ) of column names <nl> if ( isColumnRange ( ) ) <nl> { <nl> - ByteBuffer start = getRequestedBound ( isReversed ? Bound . END : Bound . START , variables ) ; <nl> - ByteBuffer finish = getRequestedBound ( isReversed ? Bound . START : Bound . END , variables ) ; <nl> + ByteBuffer start = getRequestedBound ( Bound . START , variables ) ; <nl> + ByteBuffer finish = getRequestedBound ( Bound . END , variables ) ; <nl> <nl> / / Note that we use the total limit for every key . This is <nl> / / potentially inefficient , but then again , IN + LIMIT is not a <nl> @ @ - 478 , 13 + 484 , 18 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> <nl> - private ByteBuffer getRequestedBound ( Bound b , List < ByteBuffer > variables ) throws InvalidRequestException <nl> + private ByteBuffer getRequestedBound ( Bound bound , List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> assert isColumnRange ( ) ; <nl> <nl> ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; <nl> - for ( Restriction r : columnRestrictions ) <nl> + for ( CFDefinition . Name name : cfDef . columns . values ( ) ) <nl> { <nl> + / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . <nl> + / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . <nl> + / / But if the actual comparator itself is reversed , we must inversed the bounds too . <nl> + Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; <nl> + Restriction r = columnRestrictions [ name . position ] ; <nl> if ( r = = null | | ( ! r . isEquality ( ) & & r . bound ( b ) = = null ) ) <nl> { <nl> / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . <nl> @ @ - 926 , 6 + 937 , 11 @ @ public class SelectStatement implements CQLStatement <nl> return new CqlRow ( key , thriftColumns ) ; <nl> } <nl> <nl> + private static boolean isReversedType ( CFDefinition . Name name ) <nl> + { <nl> + return name . type instanceof ReversedType ; <nl> + } <nl> + <nl> public static class RawStatement extends CFStatement <nl> { <nl> private final Parameters parameters ; <nl> @ @ - 1159 , 11 + 1175 , 6 @ @ public class SelectStatement implements CQLStatement <nl> return new ParsedStatement . Prepared ( stmt , Arrays . < CFDefinition . Name > asList ( names ) ) ; <nl> } <nl> <nl> - private static boolean isReversedType ( CFDefinition . Name name ) <nl> - { <nl> - return name . type instanceof ReversedType ; <nl> - } <nl> - <nl> Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel ) throws InvalidRequestException <nl> { <nl> if ( newRel . onToken & & name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a46aa56 . . 18cd90b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 7 
 + * Prohibit Reverse Counter type as part of the PK ( CASSANDRA - 9395 ) 
 * cqlsh : correctly handle non - ascii chars in error messages ( CASSANDRA - 11626 ) 
 * Exit JVM if JMX server fails to startup ( CASSANDRA - 11540 ) 
 * Produce a heap dump when exiting on OOM ( CASSANDRA - 9861 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 index 1b3665c . . e761674 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 @ @ - 268 , 7 + 268 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 { 
 stmt . keyAliases . add ( alias . bytes ) ; 
 AbstractType < ? > t = getTypeAndRemove ( stmt . columns , alias ) ; 
 - if ( t instanceof CounterColumnType ) 
 + if ( t . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) 
 throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , alias ) ) ; 
 if ( staticColumns . contains ( alias ) ) 
 throw new InvalidRequestException ( String . format ( " Static column % s cannot be part of the PRIMARY KEY " , alias ) ) ; 
 @ @ - 316 , 7 + 316 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 
 stmt . columnAliases . add ( alias . bytes ) ; 
 AbstractType < ? > at = getTypeAndRemove ( stmt . columns , alias ) ; 
 - if ( at instanceof CounterColumnType ) 
 + if ( at . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) 
 throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , stmt . columnAliases . get ( 0 ) ) ) ; 
 stmt . comparator = new SimpleDenseCellNameType ( at ) ; 
 } 
 @ @ - 328 , 7 + 328 , 7 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 stmt . columnAliases . add ( t . bytes ) ; 
 
 AbstractType < ? > type = getTypeAndRemove ( stmt . columns , t ) ; 
 - if ( type instanceof CounterColumnType ) 
 + if ( type . asCQL3Type ( ) . getType ( ) instanceof CounterColumnType ) 
 throw new InvalidRequestException ( String . format ( " counter type is not supported for PRIMARY KEY part % s " , t ) ) ; 
 if ( staticColumns . contains ( t ) ) 
 throw new InvalidRequestException ( String . format ( " Static column % s cannot be part of the PRIMARY KEY " , t ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java 
 index e5ff251 . . 41b73bc 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / CountersTest . java 
 @ @ - 112 , 4 + 112 , 15 @ @ public class CountersTest extends CQLTester 
 row ( 1L ) / / no change to the counter value 
 ) ; 
 } 
 + 
 + / * * 
 + * Test for the validation bug of # 9395 . 
 + * / 
 + @ Test 
 + public void testProhibitReversedCounterAsPartOfPrimaryKey ( ) throws Throwable 
 + { 
 + assertInvalidThrowMessage ( " counter type is not supported for PRIMARY KEY part a " , 
 + InvalidRequestException . class , String . format ( " CREATE TABLE % s . % s ( a counter , b int , PRIMARY KEY ( b , a ) ) WITH CLUSTERING ORDER BY ( a desc ) ; " , KEYSPACE , createTableName ( ) ) ) ; 
 + } 
 + 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1363c22 . . e922c3c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) 
 * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) 
 * add authentication support to sstableloader ( CASSANDRA - 4712 ) 
 + * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) 
 Merged from 1 . 0 : 
 * Switch from NBHM to CHM in MessagingService ' s callback map , which 
 prevents OOM in long - running instances ( CASSANDRA - 4708 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index bbddee3 . . fac0deb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 88 , 10 + 88 , 16 @ @ public class SelectStatement implements CQLStatement 
 START ( 0 ) , END ( 1 ) ; 
 
 public final int idx ; 
 + 
 Bound ( int idx ) 
 { 
 this . idx = idx ; 
 } 
 + 
 + public static Bound reverse ( Bound b ) 
 + { 
 + return b = = START ? END : START ; 
 + } 
 } ; 
 
 public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters ) 
 @ @ - 189 , 8 + 195 , 8 @ @ public class SelectStatement implements CQLStatement 
 / / . . . a range ( slice ) of column names 
 if ( isColumnRange ( ) ) 
 { 
 - ByteBuffer start = getRequestedBound ( isReversed ? Bound . END : Bound . START , variables ) ; 
 - ByteBuffer finish = getRequestedBound ( isReversed ? Bound . START : Bound . END , variables ) ; 
 + ByteBuffer start = getRequestedBound ( Bound . START , variables ) ; 
 + ByteBuffer finish = getRequestedBound ( Bound . END , variables ) ; 
 
 / / Note that we use the total limit for every key . This is 
 / / potentially inefficient , but then again , IN + LIMIT is not a 
 @ @ - 478 , 13 + 484 , 18 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 
 - private ByteBuffer getRequestedBound ( Bound b , List < ByteBuffer > variables ) throws InvalidRequestException 
 + private ByteBuffer getRequestedBound ( Bound bound , List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 assert isColumnRange ( ) ; 
 
 ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; 
 - for ( Restriction r : columnRestrictions ) 
 + for ( CFDefinition . Name name : cfDef . columns . values ( ) ) 
 { 
 + / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . 
 + / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . 
 + / / But if the actual comparator itself is reversed , we must inversed the bounds too . 
 + Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; 
 + Restriction r = columnRestrictions [ name . position ] ; 
 if ( r = = null | | ( ! r . isEquality ( ) & & r . bound ( b ) = = null ) ) 
 { 
 / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . 
 @ @ - 926 , 6 + 937 , 11 @ @ public class SelectStatement implements CQLStatement 
 return new CqlRow ( key , thriftColumns ) ; 
 } 
 
 + private static boolean isReversedType ( CFDefinition . Name name ) 
 + { 
 + return name . type instanceof ReversedType ; 
 + } 
 + 
 public static class RawStatement extends CFStatement 
 { 
 private final Parameters parameters ; 
 @ @ - 1159 , 11 + 1175 , 6 @ @ public class SelectStatement implements CQLStatement 
 return new ParsedStatement . Prepared ( stmt , Arrays . < CFDefinition . Name > asList ( names ) ) ; 
 } 
 
 - private static boolean isReversedType ( CFDefinition . Name name ) 
 - { 
 - return name . type instanceof ReversedType ; 
 - } 
 - 
 Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel ) throws InvalidRequestException 
 { 
 if ( newRel . onToken & & name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS )
