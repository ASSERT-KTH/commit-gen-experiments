BLEU SCORE: 0.040583489434387374

TEST MSG: Stop merkle tree recursion at leafs
GENERATED MSG: add leaving mode

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 84aba99 . . 98a1808 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 14 <nl> + * Fix repair process violating start / end token limits for small ranges ( CASSANDRA - 13052 ) <nl> * Add storage port options to sstableloader ( CASSANDRA - 13518 ) <nl> * Properly handle quoted index names in cqlsh DESCRIBE output ( CASSANDRA - 12847 ) <nl> * Avoid reading static row twice from old format sstables ( CASSANDRA - 13236 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / messages / RepairOption . java b / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> index 44a1e57 . . 9d60ad7 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> + + + b / src / java / org / apache / cassandra / repair / messages / RepairOption . java <nl> @ @ - 158 , 6 + 158 , 10 @ @ public class RepairOption <nl> } <nl> Token parsedBeginToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ 0 ] . trim ( ) ) ; <nl> Token parsedEndToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ 1 ] . trim ( ) ) ; <nl> + if ( parsedBeginToken . equals ( parsedEndToken ) ) <nl> + { <nl> + throw new IllegalArgumentException ( " Start and end tokens must be different . " ) ; <nl> + } <nl> ranges . add ( new Range < > ( parsedBeginToken , parsedEndToken ) ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / MerkleTree . java b / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> index 8a8cd9c . . 0d5a469 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> + + + b / src / java / org / apache / cassandra / utils / MerkleTree . java <nl> @ @ - 25 , 6 + 25 , 9 @ @ import java . util . * ; <nl> import com . google . common . base . Preconditions ; <nl> import com . google . common . collect . PeekingIterator ; <nl> <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . IPartitionerDependentSerializer ; <nl> @ @ - 58 , 6 + 61 , 8 @ @ import org . apache . cassandra . net . MessagingService ; <nl> * / <nl> public class MerkleTree implements Serializable <nl> { <nl> + private static Logger logger = LoggerFactory . getLogger ( MerkleTree . class ) ; <nl> + <nl> public static final MerkleTreeSerializer serializer = new MerkleTreeSerializer ( ) ; <nl> private static final long serialVersionUID = 2L ; <nl> <nl> @ @ - 241 , 8 + 246 , 12 @ @ public class MerkleTree implements Serializable <nl> <nl> if ( lhash ! = null & & rhash ! = null & & ! Arrays . equals ( lhash , rhash ) ) <nl> { <nl> + logger . debug ( " Digest mismatch detected , traversing trees [ { } , { } ] " , ltree , rtree ) ; <nl> if ( FULLY _ INCONSISTENT = = differenceHelper ( ltree , rtree , diff , active ) ) <nl> + { <nl> + logger . debug ( " Range { } fully inconsistent " , active ) ; <nl> diff . add ( active ) ; <nl> + } <nl> } <nl> else if ( lhash = = null | | rhash = = null ) <nl> diff . add ( active ) ; <nl> @ @ - 262 , 8 + 271 , 19 @ @ public class MerkleTree implements Serializable <nl> return CONSISTENT ; <nl> <nl> Token midpoint = ltree . partitioner ( ) . midpoint ( active . left , active . right ) ; <nl> + / / sanity check for midpoint calculation , see CASSANDRA - 13052 <nl> + if ( midpoint . equals ( active . left ) | | midpoint . equals ( active . right ) ) <nl> + { <nl> + / / Unfortunately we can ' t throw here to abort the validation process , as the code is executed in it ' s own <nl> + / / thread with the caller waiting for a condition to be signaled after completion and without an option <nl> + / / to indicate an error ( 2 . x only ) . <nl> + logger . error ( " Invalid midpoint { } for [ { } , { } ] , range will be reported inconsistent " , midpoint , active . left , active . right ) ; <nl> + return FULLY _ INCONSISTENT ; <nl> + } <nl> + <nl> TreeDifference left = new TreeDifference ( active . left , midpoint , inc ( active . depth ) ) ; <nl> TreeDifference right = new TreeDifference ( midpoint , active . right , inc ( active . depth ) ) ; <nl> + logger . debug ( " ( { } ) Hashing sub - ranges [ { } , { } ] for { } divided by midpoint { } " , active . depth , left , right , active , midpoint ) ; <nl> byte [ ] lhash , rhash ; <nl> Hashable lnode , rnode ; <nl> <nl> @ @ - 278 , 9 + 298 , 16 @ @ public class MerkleTree implements Serializable <nl> int ldiff = CONSISTENT ; <nl> boolean lreso = lhash ! = null & & rhash ! = null ; <nl> if ( lreso & & ! Arrays . equals ( lhash , rhash ) ) <nl> - ldiff = differenceHelper ( ltree , rtree , diff , left ) ; <nl> + { <nl> + logger . debug ( " ( { } ) Inconsistent digest on left sub - range { } : [ { } , { } ] " , active . depth , left , lnode , rnode ) ; <nl> + if ( lnode instanceof Leaf ) ldiff = FULLY _ INCONSISTENT ; <nl> + else ldiff = differenceHelper ( ltree , rtree , diff , left ) ; <nl> + } <nl> else if ( ! lreso ) <nl> + { <nl> + logger . debug ( " ( { } ) Left sub - range fully inconsistent { } " , active . depth , right ) ; <nl> ldiff = FULLY _ INCONSISTENT ; <nl> + } <nl> <nl> / / see if we should recurse right <nl> lnode = ltree . find ( right ) ; <nl> @ @ - 293 , 25 + 320 , 36 @ @ public class MerkleTree implements Serializable <nl> int rdiff = CONSISTENT ; <nl> boolean rreso = lhash ! = null & & rhash ! = null ; <nl> if ( rreso & & ! Arrays . equals ( lhash , rhash ) ) <nl> - rdiff = differenceHelper ( ltree , rtree , diff , right ) ; <nl> + { <nl> + logger . debug ( " ( { } ) Inconsistent digest on right sub - range { } : [ { } , { } ] " , active . depth , right , lnode , rnode ) ; <nl> + if ( rnode instanceof Leaf ) rdiff = FULLY _ INCONSISTENT ; <nl> + else rdiff = differenceHelper ( ltree , rtree , diff , right ) ; <nl> + } <nl> else if ( ! rreso ) <nl> + { <nl> + logger . debug ( " ( { } ) Right sub - range fully inconsistent { } " , active . depth , right ) ; <nl> rdiff = FULLY _ INCONSISTENT ; <nl> + } <nl> <nl> if ( ldiff = = FULLY _ INCONSISTENT & & rdiff = = FULLY _ INCONSISTENT ) <nl> { <nl> / / both children are fully inconsistent <nl> + logger . debug ( " ( { } ) Fully inconsistent range [ { } , { } ] " , active . depth , left , right ) ; <nl> return FULLY _ INCONSISTENT ; <nl> } <nl> else if ( ldiff = = FULLY _ INCONSISTENT ) <nl> { <nl> + logger . debug ( " ( { } ) Adding left sub - range to diff as fully inconsistent { } " , active . depth , left ) ; <nl> diff . add ( left ) ; <nl> return PARTIALLY _ INCONSISTENT ; <nl> } <nl> else if ( rdiff = = FULLY _ INCONSISTENT ) <nl> { <nl> + logger . debug ( " ( { } ) Adding right sub - range to diff as fully inconsistent { } " , active . depth , right ) ; <nl> diff . add ( right ) ; <nl> return PARTIALLY _ INCONSISTENT ; <nl> } <nl> + logger . debug ( " ( { } ) Range { } partially inconstent " , active . depth , active ) ; <nl> return PARTIALLY _ INCONSISTENT ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> index 27eff56 . . b617e96 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java <nl> @ @ - 122 , 7 + 122 , 7 @ @ public class RepairOptionTest <nl> @ Test <nl> public void testIncrementalRepairWithSubrangesIsNotGlobal ( ) throws Exception <nl> { <nl> - RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 42 : 42 " ) , <nl> + RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 41 : 42 " ) , <nl> Murmur3Partitioner . instance ) ; <nl> assertFalse ( ro . isGlobal ( ) ) ; <nl> ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , <nl> diff - - git a / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java b / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java <nl> index 5924de0 . . c9aa09f 100644 <nl> - - - a / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java <nl> + + + b / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java <nl> @ @ - 21 , 7 + 21 , 7 @ @ package org . apache . cassandra . utils ; <nl> import java . math . BigInteger ; <nl> import java . util . * ; <nl> <nl> - import org . apache . cassandra . utils . AbstractIterator ; <nl> + import com . google . common . collect . Lists ; <nl> <nl> import org . junit . Before ; <nl> import org . junit . Test ; <nl> @ @ - 443 , 6 + 443 , 38 @ @ public class MerkleTreeTest <nl> } <nl> <nl> / * * <nl> + * difference should behave as expected , even with extremely small ranges <nl> + * / <nl> + @ Test <nl> + public void differenceSmallRange ( ) <nl> + { <nl> + Token start = new BigIntegerToken ( " 9 " ) ; <nl> + Token end = new BigIntegerToken ( " 10 " ) ; <nl> + Range < Token > range = new Range < > ( start , end ) ; <nl> + <nl> + MerkleTree ltree = new MerkleTree ( partitioner , range , RECOMMENDED _ DEPTH , 16 ) ; <nl> + ltree . init ( ) ; <nl> + MerkleTree rtree = new MerkleTree ( partitioner , range , RECOMMENDED _ DEPTH , 16 ) ; <nl> + rtree . init ( ) ; <nl> + <nl> + byte [ ] h1 = " asdf " . getBytes ( ) ; <nl> + byte [ ] h2 = " hjkl " . getBytes ( ) ; <nl> + <nl> + / / add dummy hashes to both trees <nl> + for ( TreeRange tree : ltree . invalids ( ) ) <nl> + { <nl> + tree . addHash ( new RowHash ( range . right , h1 , h1 . length ) ) ; <nl> + } <nl> + for ( TreeRange tree : rtree . invalids ( ) ) <nl> + { <nl> + tree . addHash ( new RowHash ( range . right , h2 , h2 . length ) ) ; <nl> + } <nl> + <nl> + List < TreeRange > diffs = MerkleTree . difference ( ltree , rtree ) ; <nl> + assertEquals ( Lists . newArrayList ( range ) , diffs ) ; <nl> + } <nl> + <nl> + / * * <nl> * Return the root hash of a binary tree with leaves at the given depths <nl> * and with the given hash val in each leaf . <nl> * /
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 1083a9c . . 7759c61 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 63 , 8 + 63 , 6 @ @ package org . apache . cassandra . dht ; <nl> * / <nl> public class BootStrapper <nl> { <nl> - public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms <nl> - <nl> private static final Logger logger = Logger . getLogger ( BootStrapper . class ) ; <nl> <nl> / * endpoints that need to be bootstrapped * / <nl> @ @ - 174 , 7 + 172 , 7 @ @ public class BootStrapper <nl> { <nl> for ( Range myRange : myRanges ) <nl> { <nl> - if ( range . contains ( myRange . right ( ) ) ) <nl> + if ( range . contains ( myRange ) ) <nl> { <nl> List < InetAddress > preferred = DatabaseDescriptor . getEndPointSnitch ( ) . sortByProximity ( address , rangeAddresses . get ( range ) ) ; <nl> myRangeAddresses . putAll ( myRange , preferred ) ; <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java b / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java <nl> index 401c973 . . 635fd96 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java <nl> @ @ - 57 , 7 + 57 , 7 @ @ class BootstrapMetadataMessage <nl> { <nl> throw new IOError ( e ) ; <nl> } <nl> - return new Message ( FBUtilities . getLocalAddress ( ) , " " , StorageService . bootstrapMetadataVerbHandler _ , bos . toByteArray ( ) ) ; <nl> + return new Message ( FBUtilities . getLocalAddress ( ) , StorageService . streamStage _ , StorageService . bootstrapMetadataVerbHandler _ , bos . toByteArray ( ) ) ; <nl> } <nl> <nl> protected BootstrapMetadata [ ] bsMetadata _ = new BootstrapMetadata [ 0 ] ; <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java b / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java <nl> index 532990b . . 90fac4c 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java <nl> @ @ - 70 , 7 + 70 , 7 @ @ public class BootstrapMetadataVerbHandler implements IVerbHandler <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( bsmd . toString ( ) ) ; <nl> - Streaming . transferRanges ( bsmd . target _ , bsmd . ranges _ ) ; <nl> + Streaming . transferRanges ( bsmd . target _ , bsmd . ranges _ , null ) ; <nl> } <nl> } <nl> catch ( IOException ex ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java <nl> index c4a30f2 . . 8e3ae23 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Range . java <nl> + + + b / src / java / org / apache / cassandra / dht / Range . java <nl> @ @ - 103 , 6 + 103 , 12 @ @ public class Range implements Comparable < Range > , Serializable <nl> } <nl> } <nl> <nl> + public boolean contains ( Range range ) <nl> + { <nl> + return ( contains ( range . left _ ) | | range . left _ . equals ( left _ ) ) <nl> + & & contains ( range . right _ ) ; <nl> + } <nl> + <nl> / * * <nl> * Tells if the given range is a wrap around . <nl> * @ param range <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index ea042f5 . . 9f88a28 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 76 , 9 + 76 , 9 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC <nl> } <nl> } <nl> } <nl> - catch ( Throwable th ) <nl> + catch ( Exception e ) <nl> { <nl> - logger _ . info ( LogUtil . throwableToString ( th ) ) ; <nl> + throw new RuntimeException ( e ) ; <nl> } <nl> } <nl> } <nl> @ @ - 165 , 19 + 165 , 6 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC <nl> } <nl> <nl> / * * <nl> - * This method is used to forcibly remove a node from the membership <nl> - * set . He is forgotten locally immediately . <nl> - * <nl> - * param @ ep the endpoint to be removed from membership . <nl> - * / <nl> - public synchronized void removeFromMembership ( InetAddress ep ) <nl> - { <nl> - endPointStateMap _ . remove ( ep ) ; <nl> - liveEndpoints _ . remove ( ep ) ; <nl> - unreachableEndpoints _ . remove ( ep ) ; <nl> - } <nl> - <nl> - / * * <nl> * This method is part of IFailureDetectionEventListener interface . This is invoked <nl> * by the Failure Detector when it convicts an end point . <nl> * <nl> @ @ - 792 , 12 + 779 , 6 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC <nl> } <nl> } <nl> <nl> - public ApplicationState getApplicationState ( InetAddress endpoint , String stateName ) <nl> - { <nl> - assert endPointStateMap _ . containsKey ( endpoint ) ; <nl> - return endPointStateMap _ . get ( endpoint ) . getApplicationState ( stateName ) ; <nl> - } <nl> - <nl> / * * <nl> * Start the gossiper with the generation # retrieved from the System <nl> * table <nl> @ @ - 836 , 6 + 817 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC <nl> epState . addApplicationState ( key , appState ) ; <nl> } <nl> <nl> + public void stop ( ) <nl> + { <nl> + gossipTimer _ . cancel ( ) ; <nl> + } <nl> } <nl> <nl> class JoinVerbHandler implements IVerbHandler <nl> diff - - git a / src / java / org / apache / cassandra / io / Streaming . java b / src / java / org / apache / cassandra / io / Streaming . java <nl> index 4e887ba . . a9e4793 100644 <nl> - - - a / src / java / org / apache / cassandra / io / Streaming . java <nl> + + + b / src / java / org / apache / cassandra / io / Streaming . java <nl> @ @ - 27 , 11 + 27 , 12 @ @ import org . apache . cassandra . utils . LogUtil ; <nl> public class Streaming <nl> { <nl> private static Logger logger = Logger . getLogger ( Streaming . class ) ; <nl> + public static final long RING _ DELAY = 30 * 1000 ; / / delay after which we assume ring has stablized <nl> <nl> / * * <nl> * split out files on disk locally for each range and then stream them to the target endpoint <nl> * / <nl> - public static void transferRanges ( InetAddress target , Collection < Range > ranges ) throws IOException <nl> + public static void transferRanges ( InetAddress target , Collection < Range > ranges , Runnable callback ) <nl> { <nl> assert ranges . size ( ) > 0 ; <nl> <nl> @ @ - 46 , 20 + 47 , 29 @ @ public class Streaming <nl> List < String > tables = DatabaseDescriptor . getTables ( ) ; <nl> for ( String tName : tables ) <nl> { <nl> - Table table = Table . open ( tName ) ; <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Flushing memtables . . . " ) ; <nl> - table . flush ( false ) ; <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Performing anticompaction . . . " ) ; <nl> - / * Get the list of files that need to be streamed * / <nl> - List < String > fileList = new ArrayList < String > ( ) ; <nl> - for ( SSTableReader sstable : table . forceAntiCompaction ( ranges , target ) ) <nl> + try <nl> { <nl> - fileList . addAll ( sstable . getAllFilenames ( ) ) ; <nl> + Table table = Table . open ( tName ) ; <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " Flushing memtables . . . " ) ; <nl> + table . flush ( false ) ; <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " Performing anticompaction . . . " ) ; <nl> + / * Get the list of files that need to be streamed * / <nl> + List < String > fileList = new ArrayList < String > ( ) ; <nl> + for ( SSTableReader sstable : table . forceAntiCompaction ( ranges , target ) ) <nl> + { <nl> + fileList . addAll ( sstable . getAllFilenames ( ) ) ; <nl> + } <nl> + transferOneTable ( target , fileList , tName ) ; / / also deletes the file , so no further cleanup needed <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> } <nl> - transferOneTable ( target , fileList , tName ) ; / / also deletes the file , so no further cleanup needed <nl> } <nl> + if ( callback ! = null ) <nl> + callback . run ( ) ; <nl> } <nl> <nl> private static void transferOneTable ( InetAddress target , List < String > fileList , String table ) throws IOException <nl> @ @ - 247 , 8 + 257 , 10 @ @ public class Streaming <nl> MessagingService . instance ( ) . sendOneWay ( message , host ) ; <nl> <nl> / * If we ' re done with everything for this host , remove from bootstrap sources * / <nl> - if ( StorageService . instance ( ) . isBootstrapMode ( ) & & StreamContextManager . isDone ( host ) ) <nl> + if ( StreamContextManager . isDone ( host ) & & StorageService . instance ( ) . isBootstrapMode ( ) ) <nl> + { <nl> StorageService . instance ( ) . removeBootstrapSource ( host ) ; <nl> + } <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index c840950 . . 81e6824 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 205 , 4 + 205 , 48 @ @ public abstract class AbstractReplicationStrategy <nl> temp . update ( pendingToken , pendingAddress ) ; <nl> return getAddressRanges ( temp ) . get ( pendingAddress ) ; <nl> } <nl> + <nl> + / * * <nl> + * @ param endpoint the endpoint leaving <nl> + * @ return a map of where the endpoint ' s current ranges get sent <nl> + * / <nl> + public Multimap < Range , InetAddress > getRangeAddressesAfterLeaving ( InetAddress endpoint ) <nl> + { <nl> + TokenMetadata metadataAfterLeaving = tokenMetadata _ . cloneWithoutPending ( ) ; <nl> + metadataAfterLeaving . removeEndpoint ( endpoint ) ; <nl> + Multimap < Range , InetAddress > rangesAfterLeaving = getRangeAddresses ( metadataAfterLeaving ) ; <nl> + <nl> + Multimap < Range , InetAddress > map = HashMultimap . create ( ) ; <nl> + for ( Range range : getAddressRanges ( ) . get ( endpoint ) ) <nl> + { <nl> + for ( Range newRange : rangesAfterLeaving . keySet ( ) ) <nl> + { <nl> + if ( newRange . contains ( range ) ) <nl> + { <nl> + map . putAll ( range , rangesAfterLeaving . get ( newRange ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + return map ; <nl> + } <nl> + <nl> + public void removeObsoletePendingRanges ( ) <nl> + { <nl> + Multimap < InetAddress , Range > ranges = getAddressRanges ( ) ; <nl> + for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) <nl> + { <nl> + for ( Range currentRange : ranges . get ( entry . getValue ( ) ) ) <nl> + { <nl> + if ( currentRange . contains ( entry . getKey ( ) ) ) <nl> + { <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " Removing obsolete pending range " + entry . getKey ( ) + " from " + entry . getValue ( ) ) ; <nl> + tokenMetadata _ . removePendingRange ( entry . getKey ( ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index f73bb42 . . 5fd7eca 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 29 , 11 + 29 , 6 @ @ import java . net . InetAddress ; <nl> <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . gms . FailureDetector ; <nl> - import org . apache . cassandra . gms . ApplicationState ; <nl> - import org . apache . cassandra . service . UnavailableException ; <nl> - import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; <nl> import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> import com . google . common . collect . BiMap ; <nl> import com . google . common . collect . HashBiMap ; <nl> @ @ - 76 , 7 + 71 , 7 @ @ public class TokenMetadata <nl> Range sourceRange = getPrimaryRangeFor ( getToken ( source ) ) ; <nl> for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) <nl> { <nl> - if ( sourceRange . contains ( entry . getKey ( ) . right ( ) ) | | entry . getValue ( ) . equals ( source ) ) <nl> + if ( sourceRange . contains ( entry . getKey ( ) ) | | entry . getValue ( ) . equals ( source ) ) <nl> n + + ; <nl> } <nl> return n ; <nl> @ @ - 104 , 6 + 99 , 21 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> + public void removeEndpoint ( InetAddress endpoint ) <nl> + { <nl> + assert tokenToEndPointMap . containsValue ( endpoint ) ; <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; <nl> + sortedTokens = sortTokens ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> public Token getToken ( InetAddress endpoint ) <nl> { <nl> assert endpoint ! = null ; <nl> @ @ - 137 , 14 + 147 , 12 @ @ public class TokenMetadata <nl> <nl> public InetAddress getFirstEndpoint ( ) <nl> { <nl> + assert tokenToEndPointMap . size ( ) > 0 ; <nl> + <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - ArrayList < Token > tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; <nl> - if ( tokens . isEmpty ( ) ) <nl> - return null ; <nl> - Collections . sort ( tokens ) ; <nl> - return tokenToEndPointMap . get ( tokens . get ( 0 ) ) ; <nl> + return tokenToEndPointMap . get ( sortedTokens . get ( 0 ) ) ; <nl> } <nl> finally <nl> { <nl> @ @ - 234 , 17 + 242 , 9 @ @ public class TokenMetadata <nl> pendingRanges . put ( range , endpoint ) ; <nl> } <nl> <nl> - public void removePendingRanges ( InetAddress endpoint ) <nl> + public void removePendingRange ( Range range ) <nl> { <nl> - Iterator < Map . Entry < Range , InetAddress > > iter = pendingRanges . entrySet ( ) . iterator ( ) ; <nl> - while ( iter . hasNext ( ) ) <nl> - { <nl> - Map . Entry < Range , InetAddress > entry = iter . next ( ) ; <nl> - if ( entry . getValue ( ) . equals ( endpoint ) ) <nl> - { <nl> - iter . remove ( ) ; <nl> - } <nl> - } <nl> + pendingRanges . remove ( range ) ; <nl> } <nl> <nl> / * * a mutable map may be returned but caller should not modify it * / <nl> @ @ - 253 , 6 + 253 , 19 @ @ public class TokenMetadata <nl> return pendingRanges ; <nl> } <nl> <nl> + public List < Range > getPendingRanges ( InetAddress endpoint ) <nl> + { <nl> + List < Range > ranges = new ArrayList < Range > ( ) ; <nl> + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) <nl> + { <nl> + if ( entry . getValue ( ) . equals ( endpoint ) ) <nl> + { <nl> + ranges . add ( entry . getKey ( ) ) ; <nl> + } <nl> + } <nl> + return ranges ; <nl> + } <nl> + <nl> public Token getPredecessor ( Token token ) <nl> { <nl> List tokens = sortedTokens ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageLoadBalancer . java b / src / java / org / apache / cassandra / service / StorageLoadBalancer . java <nl> index 729ea0a . . 9ddb1d3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageLoadBalancer . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageLoadBalancer . java <nl> @ @ - 29 , 7 + 29 , 6 @ @ import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; <nl> import org . apache . cassandra . concurrent . SingleThreadedStage ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . dht . Token ; <nl> - import org . apache . cassandra . dht . BootStrapper ; <nl> import org . apache . cassandra . gms . ApplicationState ; <nl> import org . apache . cassandra . gms . EndPointState ; <nl> import org . apache . cassandra . gms . Gossiper ; <nl> @ @ - 39 , 6 + 38 , 7 @ @ import org . apache . cassandra . net . IVerbHandler ; <nl> import org . apache . cassandra . net . Message ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . io . Streaming ; <nl> <nl> / * <nl> * The load balancing algorithm here is an implementation of <nl> @ @ - 378 , 7 + 378 , 7 @ @ public final class StorageLoadBalancer implements IEndPointStateChangeSubscriber <nl> Thread . sleep ( 100 ) ; <nl> } <nl> / / one more sleep in case there are some stragglers <nl> - Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; <nl> + Thread . sleep ( Streaming . RING _ DELAY ) ; <nl> } <nl> catch ( InterruptedException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 2f78c53 . . e9d278f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 45 , 6 + 45 , 9 @ @ import org . apache . log4j . Logger ; <nl> import org . apache . log4j . Level ; <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . collect . HashMultimap ; <nl> + <nl> / * <nl> * This abstraction contains the token / identifier of this node <nl> * on the identifier space . This token gets gossiped around . <nl> @ @ - 58 , 11 + 61 , 14 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> / / these aren ' t in an enum since other gossip users can create states ad - hoc too ( e . g . load broadcasting ) <nl> public final static String STATE _ NORMAL = " NORMAL " ; <nl> public final static String STATE _ BOOTSTRAPPING = " BOOTSTRAPPING " ; <nl> + public final static String STATE _ LEAVING = " LEAVING " ; <nl> + public final static String STATE _ LEFT = " LEFT " ; <nl> <nl> / * All stage identifiers * / <nl> public final static String mutationStage _ = " ROW - MUTATION - STAGE " ; <nl> public final static String readStage _ = " ROW - READ - STAGE " ; <nl> - <nl> + public final static String streamStage _ = " STREAM - STAGE " ; <nl> + <nl> / * All verb handler identifiers * / <nl> public final static String mutationVerbHandler _ = " ROW - MUTATION - VERB - HANDLER " ; <nl> public final static String tokenVerbHandler _ = " TOKEN - VERB - HANDLER " ; <nl> @ @ - 228 , 6 + 234 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> new MultiThreadedStage ( StorageService . mutationStage _ , DatabaseDescriptor . getConcurrentWriters ( ) ) ) ; <nl> StageManager . registerStage ( StorageService . readStage _ , <nl> new MultiThreadedStage ( StorageService . readStage _ , DatabaseDescriptor . getConcurrentReaders ( ) ) ) ; <nl> + StageManager . registerStage ( StorageService . streamStage _ , new SingleThreadedStage ( StorageService . streamStage _ ) ) ; <nl> <nl> Class < AbstractReplicationStrategy > cls = DatabaseDescriptor . getReplicaPlacementStrategyClass ( ) ; <nl> Class [ ] parameterTypes = new Class [ ] { TokenMetadata . class , IPartitioner . class , int . class } ; <nl> @ @ - 357 , 21 + 364 , 80 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> * / <nl> public void onChange ( InetAddress endpoint , String stateName , ApplicationState state ) <nl> { <nl> - Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> - <nl> if ( STATE _ BOOTSTRAPPING . equals ( stateName ) ) <nl> { <nl> + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( endpoint + " state bootstrapping , token " + token ) ; <nl> updateBootstrapRanges ( token , endpoint ) ; <nl> } <nl> else if ( STATE _ NORMAL . equals ( stateName ) ) <nl> { <nl> + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( endpoint + " state normal , token " + token ) ; <nl> - tokenMetadata _ . removePendingRanges ( endpoint ) ; <nl> + replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> updateForeignToken ( token , endpoint ) ; <nl> } <nl> + else if ( STATE _ LEAVING . equals ( stateName ) ) <nl> + { <nl> + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> + assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; <nl> + updateLeavingRanges ( endpoint ) ; <nl> + } <nl> + else if ( STATE _ LEFT . equals ( stateName ) ) <nl> + { <nl> + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> + assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; <nl> + tokenMetadata _ . removeEndpoint ( endpoint ) ; <nl> + replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> + } <nl> + } <nl> + <nl> + private Multimap < Range , InetAddress > getChangedRangesForLeaving ( InetAddress endpoint ) <nl> + { <nl> + Multimap < Range , InetAddress > newRangeAddresses = replicationStrategy _ . getRangeAddressesAfterLeaving ( endpoint ) ; <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " leaving node ranges are [ " + StringUtils . join ( newRangeAddresses . keySet ( ) , " , " ) + " ] " ) ; <nl> + Multimap < Range , InetAddress > changedRanges = HashMultimap . create ( ) ; <nl> + for ( final Range range : newRangeAddresses . keySet ( ) ) <nl> + { <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " considering Range " + range ) ; <nl> + for ( InetAddress newEndpoint : newRangeAddresses . get ( range ) ) <nl> + { <nl> + boolean alreadyReplicatesRange = false ; <nl> + for ( Range existingRange : getRangesForEndPoint ( newEndpoint ) ) <nl> + { <nl> + if ( existingRange . contains ( range ) ) <nl> + { <nl> + alreadyReplicatesRange = true ; <nl> + break ; <nl> + } <nl> + } <nl> + if ( ! alreadyReplicatesRange ) <nl> + { <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( newEndpoint + " needs pendingrange " + range ) ; <nl> + changedRanges . put ( range , newEndpoint ) ; <nl> + } <nl> + } <nl> + } <nl> + return changedRanges ; <nl> + } <nl> + <nl> + private void updateLeavingRanges ( final InetAddress endpoint ) <nl> + { <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( endpoint + " is leaving ; calculating pendingranges " ) ; <nl> + Multimap < Range , InetAddress > ranges = getChangedRangesForLeaving ( endpoint ) ; <nl> + for ( Range range : ranges . keySet ( ) ) <nl> + { <nl> + for ( InetAddress newEndpoint : ranges . get ( range ) ) <nl> + { <nl> + tokenMetadata _ . addPendingRange ( range , newEndpoint ) ; <nl> + } <nl> + } <nl> } <nl> <nl> private void updateBootstrapRanges ( Token token , InetAddress endpoint ) <nl> @ @ - 651 , 7 + 717 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> logger _ . debug ( " computing ranges for " + StringUtils . join ( sortedTokens , " , " ) ) ; <nl> <nl> List < Range > ranges = new ArrayList < Range > ( ) ; <nl> - Collections . sort ( sortedTokens ) ; <nl> int size = sortedTokens . size ( ) ; <nl> for ( int i = 1 ; i < size ; + + i ) <nl> { <nl> @ @ - 851 , 6 + 916 , 55 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> return tokens ; <nl> } <nl> <nl> + public void decommission ( ) <nl> + { <nl> + if ( ! tokenMetadata _ . isMember ( FBUtilities . getLocalAddress ( ) ) ) <nl> + throw new UnsupportedOperationException ( " local node is not a member of the token ring yet " ) ; <nl> + if ( tokenMetadata _ . sortedTokens ( ) . size ( ) < 2 ) <nl> + throw new UnsupportedOperationException ( " no other nodes in the ring ; decommission would be pointless " ) ; <nl> + if ( tokenMetadata _ . getPendingRanges ( FBUtilities . getLocalAddress ( ) ) . size ( ) > 0 ) <nl> + throw new UnsupportedOperationException ( " data is currently moving to this node ; unable to leave the ring " ) ; <nl> + <nl> + logger _ . info ( " DECOMMISSIONING " ) ; <nl> + Gossiper . instance ( ) . addApplicationState ( STATE _ LEAVING , new ApplicationState ( getLocalToken ( ) . toString ( ) ) ) ; <nl> + logger _ . info ( " decommission sleeping " + Streaming . RING _ DELAY ) ; <nl> + try <nl> + { <nl> + Thread . sleep ( Streaming . RING _ DELAY ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + <nl> + Multimap < Range , InetAddress > rangesMM = getChangedRangesForLeaving ( FBUtilities . getLocalAddress ( ) ) ; <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " Ranges needing transfer are [ " + StringUtils . join ( rangesMM . keySet ( ) , " , " ) + " ] " ) ; <nl> + final Set < Map . Entry < Range , InetAddress > > pending = new HashSet < Map . Entry < Range , InetAddress > > ( rangesMM . entries ( ) ) ; <nl> + for ( final Map . Entry < Range , InetAddress > entry : rangesMM . entries ( ) ) <nl> + { <nl> + final Range range = entry . getKey ( ) ; <nl> + final InetAddress newEndpoint = entry . getValue ( ) ; <nl> + final Runnable callback = new Runnable ( ) <nl> + { <nl> + public synchronized void run ( ) <nl> + { <nl> + pending . remove ( entry ) ; <nl> + if ( pending . isEmpty ( ) ) <nl> + finishLeaving ( ) ; <nl> + } <nl> + } ; <nl> + StageManager . getStage ( streamStage _ ) . execute ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / TODO each call to transferRanges re - flushes , this is potentially a lot of waste <nl> + Streaming . transferRanges ( newEndpoint , Arrays . asList ( range ) , callback ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> + <nl> public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) <nl> { <nl> return replicationStrategy _ . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; <nl> @ @ - 860 , 4 + 974 , 20 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> { <nl> return replicationStrategy _ ; <nl> } <nl> + <nl> + public void finishLeaving ( ) <nl> + { <nl> + Gossiper . instance ( ) . addApplicationState ( STATE _ LEFT , new ApplicationState ( getLocalToken ( ) . toString ( ) ) ) ; <nl> + try <nl> + { <nl> + Thread . sleep ( 2 * Gossiper . intervalInMillis _ ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + Gossiper . instance ( ) . stop ( ) ; <nl> + logger _ . info ( " DECOMMISSION FINISHED . " ) ; <nl> + / / let op be responsible for killing the process <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index 47b85fb . . 01c9657 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 113 , 6 + 113 , 11 @ @ public interface StorageServiceMBean <nl> * / <nl> public void forceTableFlush ( String tableName , String . . . columnFamilies ) throws IOException ; <nl> <nl> + / * * <nl> + * transfer this node ' s data to other machines and remove it from service . <nl> + * / <nl> + public void decommission ( ) ; <nl> + <nl> / * * set the logging level at runtime * / <nl> public void setLog4jLevel ( String classQualifier , String level ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index de4727f . . 28904d1 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 380 , 6 + 380 , 11 @ @ public class NodeProbe <nl> ssProxy . clearSnapshot ( ) ; <nl> } <nl> <nl> + public void decommission ( ) <nl> + { <nl> + ssProxy . decommission ( ) ; <nl> + } <nl> + <nl> / * * <nl> * Print out the size of the queues in the thread pools <nl> * <nl> @ @ - 474 , 7 + 479 , 8 @ @ public class NodeProbe <nl> { <nl> HelpFormatter hf = new HelpFormatter ( ) ; <nl> String header = String . format ( <nl> - " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , tpstats , flush , " + <nl> + " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , " + <nl> + " tpstats , flush , decommission , " + <nl> " getcompactionthreshold , setcompactionthreshold [ minthreshold ] ( [ maxthreshold ] ) " ) ; <nl> String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; <nl> hf . printHelp ( usage , " " , options , header ) ; <nl> @ @ - 533 , 6 + 539 , 10 @ @ public class NodeProbe <nl> { <nl> probe . printColumnFamilyStats ( System . out ) ; <nl> } <nl> + else if ( cmdName . equals ( " decommission " ) ) <nl> + { <nl> + probe . decommission ( ) ; <nl> + } <nl> else if ( cmdName . equals ( " snapshot " ) ) <nl> { <nl> String snapshotName = " " ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 84aba99 . . 98a1808 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 14 
 + * Fix repair process violating start / end token limits for small ranges ( CASSANDRA - 13052 ) 
 * Add storage port options to sstableloader ( CASSANDRA - 13518 ) 
 * Properly handle quoted index names in cqlsh DESCRIBE output ( CASSANDRA - 12847 ) 
 * Avoid reading static row twice from old format sstables ( CASSANDRA - 13236 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / messages / RepairOption . java b / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 index 44a1e57 . . 9d60ad7 100644 
 - - - a / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 + + + b / src / java / org / apache / cassandra / repair / messages / RepairOption . java 
 @ @ - 158 , 6 + 158 , 10 @ @ public class RepairOption 
 } 
 Token parsedBeginToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ 0 ] . trim ( ) ) ; 
 Token parsedEndToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ 1 ] . trim ( ) ) ; 
 + if ( parsedBeginToken . equals ( parsedEndToken ) ) 
 + { 
 + throw new IllegalArgumentException ( " Start and end tokens must be different . " ) ; 
 + } 
 ranges . add ( new Range < > ( parsedBeginToken , parsedEndToken ) ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / MerkleTree . java b / src / java / org / apache / cassandra / utils / MerkleTree . java 
 index 8a8cd9c . . 0d5a469 100644 
 - - - a / src / java / org / apache / cassandra / utils / MerkleTree . java 
 + + + b / src / java / org / apache / cassandra / utils / MerkleTree . java 
 @ @ - 25 , 6 + 25 , 9 @ @ import java . util . * ; 
 import com . google . common . base . Preconditions ; 
 import com . google . common . collect . PeekingIterator ; 
 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . IPartitionerDependentSerializer ; 
 @ @ - 58 , 6 + 61 , 8 @ @ import org . apache . cassandra . net . MessagingService ; 
 * / 
 public class MerkleTree implements Serializable 
 { 
 + private static Logger logger = LoggerFactory . getLogger ( MerkleTree . class ) ; 
 + 
 public static final MerkleTreeSerializer serializer = new MerkleTreeSerializer ( ) ; 
 private static final long serialVersionUID = 2L ; 
 
 @ @ - 241 , 8 + 246 , 12 @ @ public class MerkleTree implements Serializable 
 
 if ( lhash ! = null & & rhash ! = null & & ! Arrays . equals ( lhash , rhash ) ) 
 { 
 + logger . debug ( " Digest mismatch detected , traversing trees [ { } , { } ] " , ltree , rtree ) ; 
 if ( FULLY _ INCONSISTENT = = differenceHelper ( ltree , rtree , diff , active ) ) 
 + { 
 + logger . debug ( " Range { } fully inconsistent " , active ) ; 
 diff . add ( active ) ; 
 + } 
 } 
 else if ( lhash = = null | | rhash = = null ) 
 diff . add ( active ) ; 
 @ @ - 262 , 8 + 271 , 19 @ @ public class MerkleTree implements Serializable 
 return CONSISTENT ; 
 
 Token midpoint = ltree . partitioner ( ) . midpoint ( active . left , active . right ) ; 
 + / / sanity check for midpoint calculation , see CASSANDRA - 13052 
 + if ( midpoint . equals ( active . left ) | | midpoint . equals ( active . right ) ) 
 + { 
 + / / Unfortunately we can ' t throw here to abort the validation process , as the code is executed in it ' s own 
 + / / thread with the caller waiting for a condition to be signaled after completion and without an option 
 + / / to indicate an error ( 2 . x only ) . 
 + logger . error ( " Invalid midpoint { } for [ { } , { } ] , range will be reported inconsistent " , midpoint , active . left , active . right ) ; 
 + return FULLY _ INCONSISTENT ; 
 + } 
 + 
 TreeDifference left = new TreeDifference ( active . left , midpoint , inc ( active . depth ) ) ; 
 TreeDifference right = new TreeDifference ( midpoint , active . right , inc ( active . depth ) ) ; 
 + logger . debug ( " ( { } ) Hashing sub - ranges [ { } , { } ] for { } divided by midpoint { } " , active . depth , left , right , active , midpoint ) ; 
 byte [ ] lhash , rhash ; 
 Hashable lnode , rnode ; 
 
 @ @ - 278 , 9 + 298 , 16 @ @ public class MerkleTree implements Serializable 
 int ldiff = CONSISTENT ; 
 boolean lreso = lhash ! = null & & rhash ! = null ; 
 if ( lreso & & ! Arrays . equals ( lhash , rhash ) ) 
 - ldiff = differenceHelper ( ltree , rtree , diff , left ) ; 
 + { 
 + logger . debug ( " ( { } ) Inconsistent digest on left sub - range { } : [ { } , { } ] " , active . depth , left , lnode , rnode ) ; 
 + if ( lnode instanceof Leaf ) ldiff = FULLY _ INCONSISTENT ; 
 + else ldiff = differenceHelper ( ltree , rtree , diff , left ) ; 
 + } 
 else if ( ! lreso ) 
 + { 
 + logger . debug ( " ( { } ) Left sub - range fully inconsistent { } " , active . depth , right ) ; 
 ldiff = FULLY _ INCONSISTENT ; 
 + } 
 
 / / see if we should recurse right 
 lnode = ltree . find ( right ) ; 
 @ @ - 293 , 25 + 320 , 36 @ @ public class MerkleTree implements Serializable 
 int rdiff = CONSISTENT ; 
 boolean rreso = lhash ! = null & & rhash ! = null ; 
 if ( rreso & & ! Arrays . equals ( lhash , rhash ) ) 
 - rdiff = differenceHelper ( ltree , rtree , diff , right ) ; 
 + { 
 + logger . debug ( " ( { } ) Inconsistent digest on right sub - range { } : [ { } , { } ] " , active . depth , right , lnode , rnode ) ; 
 + if ( rnode instanceof Leaf ) rdiff = FULLY _ INCONSISTENT ; 
 + else rdiff = differenceHelper ( ltree , rtree , diff , right ) ; 
 + } 
 else if ( ! rreso ) 
 + { 
 + logger . debug ( " ( { } ) Right sub - range fully inconsistent { } " , active . depth , right ) ; 
 rdiff = FULLY _ INCONSISTENT ; 
 + } 
 
 if ( ldiff = = FULLY _ INCONSISTENT & & rdiff = = FULLY _ INCONSISTENT ) 
 { 
 / / both children are fully inconsistent 
 + logger . debug ( " ( { } ) Fully inconsistent range [ { } , { } ] " , active . depth , left , right ) ; 
 return FULLY _ INCONSISTENT ; 
 } 
 else if ( ldiff = = FULLY _ INCONSISTENT ) 
 { 
 + logger . debug ( " ( { } ) Adding left sub - range to diff as fully inconsistent { } " , active . depth , left ) ; 
 diff . add ( left ) ; 
 return PARTIALLY _ INCONSISTENT ; 
 } 
 else if ( rdiff = = FULLY _ INCONSISTENT ) 
 { 
 + logger . debug ( " ( { } ) Adding right sub - range to diff as fully inconsistent { } " , active . depth , right ) ; 
 diff . add ( right ) ; 
 return PARTIALLY _ INCONSISTENT ; 
 } 
 + logger . debug ( " ( { } ) Range { } partially inconstent " , active . depth , active ) ; 
 return PARTIALLY _ INCONSISTENT ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 index 27eff56 . . b617e96 100644 
 - - - a / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / messages / RepairOptionTest . java 
 @ @ - 122 , 7 + 122 , 7 @ @ public class RepairOptionTest 
 @ Test 
 public void testIncrementalRepairWithSubrangesIsNotGlobal ( ) throws Exception 
 { 
 - RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 42 : 42 " ) , 
 + RepairOption ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " 41 : 42 " ) , 
 Murmur3Partitioner . instance ) ; 
 assertFalse ( ro . isGlobal ( ) ) ; 
 ro = RepairOption . parse ( ImmutableMap . of ( RepairOption . INCREMENTAL _ KEY , " true " , RepairOption . RANGES _ KEY , " " ) , 
 diff - - git a / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java b / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java 
 index 5924de0 . . c9aa09f 100644 
 - - - a / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java 
 + + + b / test / unit / org / apache / cassandra / utils / MerkleTreeTest . java 
 @ @ - 21 , 7 + 21 , 7 @ @ package org . apache . cassandra . utils ; 
 import java . math . BigInteger ; 
 import java . util . * ; 
 
 - import org . apache . cassandra . utils . AbstractIterator ; 
 + import com . google . common . collect . Lists ; 
 
 import org . junit . Before ; 
 import org . junit . Test ; 
 @ @ - 443 , 6 + 443 , 38 @ @ public class MerkleTreeTest 
 } 
 
 / * * 
 + * difference should behave as expected , even with extremely small ranges 
 + * / 
 + @ Test 
 + public void differenceSmallRange ( ) 
 + { 
 + Token start = new BigIntegerToken ( " 9 " ) ; 
 + Token end = new BigIntegerToken ( " 10 " ) ; 
 + Range < Token > range = new Range < > ( start , end ) ; 
 + 
 + MerkleTree ltree = new MerkleTree ( partitioner , range , RECOMMENDED _ DEPTH , 16 ) ; 
 + ltree . init ( ) ; 
 + MerkleTree rtree = new MerkleTree ( partitioner , range , RECOMMENDED _ DEPTH , 16 ) ; 
 + rtree . init ( ) ; 
 + 
 + byte [ ] h1 = " asdf " . getBytes ( ) ; 
 + byte [ ] h2 = " hjkl " . getBytes ( ) ; 
 + 
 + / / add dummy hashes to both trees 
 + for ( TreeRange tree : ltree . invalids ( ) ) 
 + { 
 + tree . addHash ( new RowHash ( range . right , h1 , h1 . length ) ) ; 
 + } 
 + for ( TreeRange tree : rtree . invalids ( ) ) 
 + { 
 + tree . addHash ( new RowHash ( range . right , h2 , h2 . length ) ) ; 
 + } 
 + 
 + List < TreeRange > diffs = MerkleTree . difference ( ltree , rtree ) ; 
 + assertEquals ( Lists . newArrayList ( range ) , diffs ) ; 
 + } 
 + 
 + / * * 
 * Return the root hash of a binary tree with leaves at the given depths 
 * and with the given hash val in each leaf . 
 * /

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 1083a9c . . 7759c61 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 63 , 8 + 63 , 6 @ @ package org . apache . cassandra . dht ; 
 * / 
 public class BootStrapper 
 { 
 - public static final long INITIAL _ DELAY = 30 * 1000 ; / / ms 
 - 
 private static final Logger logger = Logger . getLogger ( BootStrapper . class ) ; 
 
 / * endpoints that need to be bootstrapped * / 
 @ @ - 174 , 7 + 172 , 7 @ @ public class BootStrapper 
 { 
 for ( Range myRange : myRanges ) 
 { 
 - if ( range . contains ( myRange . right ( ) ) ) 
 + if ( range . contains ( myRange ) ) 
 { 
 List < InetAddress > preferred = DatabaseDescriptor . getEndPointSnitch ( ) . sortByProximity ( address , rangeAddresses . get ( range ) ) ; 
 myRangeAddresses . putAll ( myRange , preferred ) ; 
 diff - - git a / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java b / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java 
 index 401c973 . . 635fd96 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java 
 + + + b / src / java / org / apache / cassandra / dht / BootstrapMetadataMessage . java 
 @ @ - 57 , 7 + 57 , 7 @ @ class BootstrapMetadataMessage 
 { 
 throw new IOError ( e ) ; 
 } 
 - return new Message ( FBUtilities . getLocalAddress ( ) , " " , StorageService . bootstrapMetadataVerbHandler _ , bos . toByteArray ( ) ) ; 
 + return new Message ( FBUtilities . getLocalAddress ( ) , StorageService . streamStage _ , StorageService . bootstrapMetadataVerbHandler _ , bos . toByteArray ( ) ) ; 
 } 
 
 protected BootstrapMetadata [ ] bsMetadata _ = new BootstrapMetadata [ 0 ] ; 
 diff - - git a / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java b / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java 
 index 532990b . . 90fac4c 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / dht / BootstrapMetadataVerbHandler . java 
 @ @ - 70 , 7 + 70 , 7 @ @ public class BootstrapMetadataVerbHandler implements IVerbHandler 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( bsmd . toString ( ) ) ; 
 - Streaming . transferRanges ( bsmd . target _ , bsmd . ranges _ ) ; 
 + Streaming . transferRanges ( bsmd . target _ , bsmd . ranges _ , null ) ; 
 } 
 } 
 catch ( IOException ex ) 
 diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java 
 index c4a30f2 . . 8e3ae23 100644 
 - - - a / src / java / org / apache / cassandra / dht / Range . java 
 + + + b / src / java / org / apache / cassandra / dht / Range . java 
 @ @ - 103 , 6 + 103 , 12 @ @ public class Range implements Comparable < Range > , Serializable 
 } 
 } 
 
 + public boolean contains ( Range range ) 
 + { 
 + return ( contains ( range . left _ ) | | range . left _ . equals ( left _ ) ) 
 + & & contains ( range . right _ ) ; 
 + } 
 + 
 / * * 
 * Tells if the given range is a wrap around . 
 * @ param range 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index ea042f5 . . 9f88a28 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 76 , 9 + 76 , 9 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC 
 } 
 } 
 } 
 - catch ( Throwable th ) 
 + catch ( Exception e ) 
 { 
 - logger _ . info ( LogUtil . throwableToString ( th ) ) ; 
 + throw new RuntimeException ( e ) ; 
 } 
 } 
 } 
 @ @ - 165 , 19 + 165 , 6 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC 
 } 
 
 / * * 
 - * This method is used to forcibly remove a node from the membership 
 - * set . He is forgotten locally immediately . 
 - * 
 - * param @ ep the endpoint to be removed from membership . 
 - * / 
 - public synchronized void removeFromMembership ( InetAddress ep ) 
 - { 
 - endPointStateMap _ . remove ( ep ) ; 
 - liveEndpoints _ . remove ( ep ) ; 
 - unreachableEndpoints _ . remove ( ep ) ; 
 - } 
 - 
 - / * * 
 * This method is part of IFailureDetectionEventListener interface . This is invoked 
 * by the Failure Detector when it convicts an end point . 
 * 
 @ @ - 792 , 12 + 779 , 6 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC 
 } 
 } 
 
 - public ApplicationState getApplicationState ( InetAddress endpoint , String stateName ) 
 - { 
 - assert endPointStateMap _ . containsKey ( endpoint ) ; 
 - return endPointStateMap _ . get ( endpoint ) . getApplicationState ( stateName ) ; 
 - } 
 - 
 / * * 
 * Start the gossiper with the generation # retrieved from the System 
 * table 
 @ @ - 836 , 6 + 817 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , IEndPointStateC 
 epState . addApplicationState ( key , appState ) ; 
 } 
 
 + public void stop ( ) 
 + { 
 + gossipTimer _ . cancel ( ) ; 
 + } 
 } 
 
 class JoinVerbHandler implements IVerbHandler 
 diff - - git a / src / java / org / apache / cassandra / io / Streaming . java b / src / java / org / apache / cassandra / io / Streaming . java 
 index 4e887ba . . a9e4793 100644 
 - - - a / src / java / org / apache / cassandra / io / Streaming . java 
 + + + b / src / java / org / apache / cassandra / io / Streaming . java 
 @ @ - 27 , 11 + 27 , 12 @ @ import org . apache . cassandra . utils . LogUtil ; 
 public class Streaming 
 { 
 private static Logger logger = Logger . getLogger ( Streaming . class ) ; 
 + public static final long RING _ DELAY = 30 * 1000 ; / / delay after which we assume ring has stablized 
 
 / * * 
 * split out files on disk locally for each range and then stream them to the target endpoint 
 * / 
 - public static void transferRanges ( InetAddress target , Collection < Range > ranges ) throws IOException 
 + public static void transferRanges ( InetAddress target , Collection < Range > ranges , Runnable callback ) 
 { 
 assert ranges . size ( ) > 0 ; 
 
 @ @ - 46 , 20 + 47 , 29 @ @ public class Streaming 
 List < String > tables = DatabaseDescriptor . getTables ( ) ; 
 for ( String tName : tables ) 
 { 
 - Table table = Table . open ( tName ) ; 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Flushing memtables . . . " ) ; 
 - table . flush ( false ) ; 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Performing anticompaction . . . " ) ; 
 - / * Get the list of files that need to be streamed * / 
 - List < String > fileList = new ArrayList < String > ( ) ; 
 - for ( SSTableReader sstable : table . forceAntiCompaction ( ranges , target ) ) 
 + try 
 { 
 - fileList . addAll ( sstable . getAllFilenames ( ) ) ; 
 + Table table = Table . open ( tName ) ; 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " Flushing memtables . . . " ) ; 
 + table . flush ( false ) ; 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " Performing anticompaction . . . " ) ; 
 + / * Get the list of files that need to be streamed * / 
 + List < String > fileList = new ArrayList < String > ( ) ; 
 + for ( SSTableReader sstable : table . forceAntiCompaction ( ranges , target ) ) 
 + { 
 + fileList . addAll ( sstable . getAllFilenames ( ) ) ; 
 + } 
 + transferOneTable ( target , fileList , tName ) ; / / also deletes the file , so no further cleanup needed 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 } 
 - transferOneTable ( target , fileList , tName ) ; / / also deletes the file , so no further cleanup needed 
 } 
 + if ( callback ! = null ) 
 + callback . run ( ) ; 
 } 
 
 private static void transferOneTable ( InetAddress target , List < String > fileList , String table ) throws IOException 
 @ @ - 247 , 8 + 257 , 10 @ @ public class Streaming 
 MessagingService . instance ( ) . sendOneWay ( message , host ) ; 
 
 / * If we ' re done with everything for this host , remove from bootstrap sources * / 
 - if ( StorageService . instance ( ) . isBootstrapMode ( ) & & StreamContextManager . isDone ( host ) ) 
 + if ( StreamContextManager . isDone ( host ) & & StorageService . instance ( ) . isBootstrapMode ( ) ) 
 + { 
 StorageService . instance ( ) . removeBootstrapSource ( host ) ; 
 + } 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index c840950 . . 81e6824 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 205 , 4 + 205 , 48 @ @ public abstract class AbstractReplicationStrategy 
 temp . update ( pendingToken , pendingAddress ) ; 
 return getAddressRanges ( temp ) . get ( pendingAddress ) ; 
 } 
 + 
 + / * * 
 + * @ param endpoint the endpoint leaving 
 + * @ return a map of where the endpoint ' s current ranges get sent 
 + * / 
 + public Multimap < Range , InetAddress > getRangeAddressesAfterLeaving ( InetAddress endpoint ) 
 + { 
 + TokenMetadata metadataAfterLeaving = tokenMetadata _ . cloneWithoutPending ( ) ; 
 + metadataAfterLeaving . removeEndpoint ( endpoint ) ; 
 + Multimap < Range , InetAddress > rangesAfterLeaving = getRangeAddresses ( metadataAfterLeaving ) ; 
 + 
 + Multimap < Range , InetAddress > map = HashMultimap . create ( ) ; 
 + for ( Range range : getAddressRanges ( ) . get ( endpoint ) ) 
 + { 
 + for ( Range newRange : rangesAfterLeaving . keySet ( ) ) 
 + { 
 + if ( newRange . contains ( range ) ) 
 + { 
 + map . putAll ( range , rangesAfterLeaving . get ( newRange ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + 
 + return map ; 
 + } 
 + 
 + public void removeObsoletePendingRanges ( ) 
 + { 
 + Multimap < InetAddress , Range > ranges = getAddressRanges ( ) ; 
 + for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) 
 + { 
 + for ( Range currentRange : ranges . get ( entry . getValue ( ) ) ) 
 + { 
 + if ( currentRange . contains ( entry . getKey ( ) ) ) 
 + { 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " Removing obsolete pending range " + entry . getKey ( ) + " from " + entry . getValue ( ) ) ; 
 + tokenMetadata _ . removePendingRange ( entry . getKey ( ) ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index f73bb42 . . 5fd7eca 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 29 , 11 + 29 , 6 @ @ import java . net . InetAddress ; 
 
 import org . apache . commons . lang . StringUtils ; 
 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . gms . FailureDetector ; 
 - import org . apache . cassandra . gms . ApplicationState ; 
 - import org . apache . cassandra . service . UnavailableException ; 
 - import org . cliffc . high _ scale _ lib . NonBlockingHashSet ; 
 import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 import com . google . common . collect . BiMap ; 
 import com . google . common . collect . HashBiMap ; 
 @ @ - 76 , 7 + 71 , 7 @ @ public class TokenMetadata 
 Range sourceRange = getPrimaryRangeFor ( getToken ( source ) ) ; 
 for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) 
 { 
 - if ( sourceRange . contains ( entry . getKey ( ) . right ( ) ) | | entry . getValue ( ) . equals ( source ) ) 
 + if ( sourceRange . contains ( entry . getKey ( ) ) | | entry . getValue ( ) . equals ( source ) ) 
 n + + ; 
 } 
 return n ; 
 @ @ - 104 , 6 + 99 , 21 @ @ public class TokenMetadata 
 } 
 } 
 
 + public void removeEndpoint ( InetAddress endpoint ) 
 + { 
 + assert tokenToEndPointMap . containsValue ( endpoint ) ; 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; 
 + sortedTokens = sortTokens ( ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 public Token getToken ( InetAddress endpoint ) 
 { 
 assert endpoint ! = null ; 
 @ @ - 137 , 14 + 147 , 12 @ @ public class TokenMetadata 
 
 public InetAddress getFirstEndpoint ( ) 
 { 
 + assert tokenToEndPointMap . size ( ) > 0 ; 
 + 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - ArrayList < Token > tokens = new ArrayList < Token > ( tokenToEndPointMap . keySet ( ) ) ; 
 - if ( tokens . isEmpty ( ) ) 
 - return null ; 
 - Collections . sort ( tokens ) ; 
 - return tokenToEndPointMap . get ( tokens . get ( 0 ) ) ; 
 + return tokenToEndPointMap . get ( sortedTokens . get ( 0 ) ) ; 
 } 
 finally 
 { 
 @ @ - 234 , 17 + 242 , 9 @ @ public class TokenMetadata 
 pendingRanges . put ( range , endpoint ) ; 
 } 
 
 - public void removePendingRanges ( InetAddress endpoint ) 
 + public void removePendingRange ( Range range ) 
 { 
 - Iterator < Map . Entry < Range , InetAddress > > iter = pendingRanges . entrySet ( ) . iterator ( ) ; 
 - while ( iter . hasNext ( ) ) 
 - { 
 - Map . Entry < Range , InetAddress > entry = iter . next ( ) ; 
 - if ( entry . getValue ( ) . equals ( endpoint ) ) 
 - { 
 - iter . remove ( ) ; 
 - } 
 - } 
 + pendingRanges . remove ( range ) ; 
 } 
 
 / * * a mutable map may be returned but caller should not modify it * / 
 @ @ - 253 , 6 + 253 , 19 @ @ public class TokenMetadata 
 return pendingRanges ; 
 } 
 
 + public List < Range > getPendingRanges ( InetAddress endpoint ) 
 + { 
 + List < Range > ranges = new ArrayList < Range > ( ) ; 
 + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) 
 + { 
 + if ( entry . getValue ( ) . equals ( endpoint ) ) 
 + { 
 + ranges . add ( entry . getKey ( ) ) ; 
 + } 
 + } 
 + return ranges ; 
 + } 
 + 
 public Token getPredecessor ( Token token ) 
 { 
 List tokens = sortedTokens ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageLoadBalancer . java b / src / java / org / apache / cassandra / service / StorageLoadBalancer . java 
 index 729ea0a . . 9ddb1d3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageLoadBalancer . java 
 + + + b / src / java / org / apache / cassandra / service / StorageLoadBalancer . java 
 @ @ - 29 , 7 + 29 , 6 @ @ import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; 
 import org . apache . cassandra . concurrent . SingleThreadedStage ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . dht . Token ; 
 - import org . apache . cassandra . dht . BootStrapper ; 
 import org . apache . cassandra . gms . ApplicationState ; 
 import org . apache . cassandra . gms . EndPointState ; 
 import org . apache . cassandra . gms . Gossiper ; 
 @ @ - 39 , 6 + 38 , 7 @ @ import org . apache . cassandra . net . IVerbHandler ; 
 import org . apache . cassandra . net . Message ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . io . Streaming ; 
 
 / * 
 * The load balancing algorithm here is an implementation of 
 @ @ - 378 , 7 + 378 , 7 @ @ public final class StorageLoadBalancer implements IEndPointStateChangeSubscriber 
 Thread . sleep ( 100 ) ; 
 } 
 / / one more sleep in case there are some stragglers 
 - Thread . sleep ( BootStrapper . INITIAL _ DELAY ) ; 
 + Thread . sleep ( Streaming . RING _ DELAY ) ; 
 } 
 catch ( InterruptedException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 2f78c53 . . e9d278f 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 45 , 6 + 45 , 9 @ @ import org . apache . log4j . Logger ; 
 import org . apache . log4j . Level ; 
 import org . apache . commons . lang . StringUtils ; 
 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . collect . HashMultimap ; 
 + 
 / * 
 * This abstraction contains the token / identifier of this node 
 * on the identifier space . This token gets gossiped around . 
 @ @ - 58 , 11 + 61 , 14 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 / / these aren ' t in an enum since other gossip users can create states ad - hoc too ( e . g . load broadcasting ) 
 public final static String STATE _ NORMAL = " NORMAL " ; 
 public final static String STATE _ BOOTSTRAPPING = " BOOTSTRAPPING " ; 
 + public final static String STATE _ LEAVING = " LEAVING " ; 
 + public final static String STATE _ LEFT = " LEFT " ; 
 
 / * All stage identifiers * / 
 public final static String mutationStage _ = " ROW - MUTATION - STAGE " ; 
 public final static String readStage _ = " ROW - READ - STAGE " ; 
 - 
 + public final static String streamStage _ = " STREAM - STAGE " ; 
 + 
 / * All verb handler identifiers * / 
 public final static String mutationVerbHandler _ = " ROW - MUTATION - VERB - HANDLER " ; 
 public final static String tokenVerbHandler _ = " TOKEN - VERB - HANDLER " ; 
 @ @ - 228 , 6 + 234 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 new MultiThreadedStage ( StorageService . mutationStage _ , DatabaseDescriptor . getConcurrentWriters ( ) ) ) ; 
 StageManager . registerStage ( StorageService . readStage _ , 
 new MultiThreadedStage ( StorageService . readStage _ , DatabaseDescriptor . getConcurrentReaders ( ) ) ) ; 
 + StageManager . registerStage ( StorageService . streamStage _ , new SingleThreadedStage ( StorageService . streamStage _ ) ) ; 
 
 Class < AbstractReplicationStrategy > cls = DatabaseDescriptor . getReplicaPlacementStrategyClass ( ) ; 
 Class [ ] parameterTypes = new Class [ ] { TokenMetadata . class , IPartitioner . class , int . class } ; 
 @ @ - 357 , 21 + 364 , 80 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 * / 
 public void onChange ( InetAddress endpoint , String stateName , ApplicationState state ) 
 { 
 - Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 - 
 if ( STATE _ BOOTSTRAPPING . equals ( stateName ) ) 
 { 
 + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( endpoint + " state bootstrapping , token " + token ) ; 
 updateBootstrapRanges ( token , endpoint ) ; 
 } 
 else if ( STATE _ NORMAL . equals ( stateName ) ) 
 { 
 + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( endpoint + " state normal , token " + token ) ; 
 - tokenMetadata _ . removePendingRanges ( endpoint ) ; 
 + replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 updateForeignToken ( token , endpoint ) ; 
 } 
 + else if ( STATE _ LEAVING . equals ( stateName ) ) 
 + { 
 + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 + assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; 
 + updateLeavingRanges ( endpoint ) ; 
 + } 
 + else if ( STATE _ LEFT . equals ( stateName ) ) 
 + { 
 + Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 + assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; 
 + tokenMetadata _ . removeEndpoint ( endpoint ) ; 
 + replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 + } 
 + } 
 + 
 + private Multimap < Range , InetAddress > getChangedRangesForLeaving ( InetAddress endpoint ) 
 + { 
 + Multimap < Range , InetAddress > newRangeAddresses = replicationStrategy _ . getRangeAddressesAfterLeaving ( endpoint ) ; 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " leaving node ranges are [ " + StringUtils . join ( newRangeAddresses . keySet ( ) , " , " ) + " ] " ) ; 
 + Multimap < Range , InetAddress > changedRanges = HashMultimap . create ( ) ; 
 + for ( final Range range : newRangeAddresses . keySet ( ) ) 
 + { 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " considering Range " + range ) ; 
 + for ( InetAddress newEndpoint : newRangeAddresses . get ( range ) ) 
 + { 
 + boolean alreadyReplicatesRange = false ; 
 + for ( Range existingRange : getRangesForEndPoint ( newEndpoint ) ) 
 + { 
 + if ( existingRange . contains ( range ) ) 
 + { 
 + alreadyReplicatesRange = true ; 
 + break ; 
 + } 
 + } 
 + if ( ! alreadyReplicatesRange ) 
 + { 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( newEndpoint + " needs pendingrange " + range ) ; 
 + changedRanges . put ( range , newEndpoint ) ; 
 + } 
 + } 
 + } 
 + return changedRanges ; 
 + } 
 + 
 + private void updateLeavingRanges ( final InetAddress endpoint ) 
 + { 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( endpoint + " is leaving ; calculating pendingranges " ) ; 
 + Multimap < Range , InetAddress > ranges = getChangedRangesForLeaving ( endpoint ) ; 
 + for ( Range range : ranges . keySet ( ) ) 
 + { 
 + for ( InetAddress newEndpoint : ranges . get ( range ) ) 
 + { 
 + tokenMetadata _ . addPendingRange ( range , newEndpoint ) ; 
 + } 
 + } 
 } 
 
 private void updateBootstrapRanges ( Token token , InetAddress endpoint ) 
 @ @ - 651 , 7 + 717 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 logger _ . debug ( " computing ranges for " + StringUtils . join ( sortedTokens , " , " ) ) ; 
 
 List < Range > ranges = new ArrayList < Range > ( ) ; 
 - Collections . sort ( sortedTokens ) ; 
 int size = sortedTokens . size ( ) ; 
 for ( int i = 1 ; i < size ; + + i ) 
 { 
 @ @ - 851 , 6 + 916 , 55 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 return tokens ; 
 } 
 
 + public void decommission ( ) 
 + { 
 + if ( ! tokenMetadata _ . isMember ( FBUtilities . getLocalAddress ( ) ) ) 
 + throw new UnsupportedOperationException ( " local node is not a member of the token ring yet " ) ; 
 + if ( tokenMetadata _ . sortedTokens ( ) . size ( ) < 2 ) 
 + throw new UnsupportedOperationException ( " no other nodes in the ring ; decommission would be pointless " ) ; 
 + if ( tokenMetadata _ . getPendingRanges ( FBUtilities . getLocalAddress ( ) ) . size ( ) > 0 ) 
 + throw new UnsupportedOperationException ( " data is currently moving to this node ; unable to leave the ring " ) ; 
 + 
 + logger _ . info ( " DECOMMISSIONING " ) ; 
 + Gossiper . instance ( ) . addApplicationState ( STATE _ LEAVING , new ApplicationState ( getLocalToken ( ) . toString ( ) ) ) ; 
 + logger _ . info ( " decommission sleeping " + Streaming . RING _ DELAY ) ; 
 + try 
 + { 
 + Thread . sleep ( Streaming . RING _ DELAY ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + 
 + Multimap < Range , InetAddress > rangesMM = getChangedRangesForLeaving ( FBUtilities . getLocalAddress ( ) ) ; 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " Ranges needing transfer are [ " + StringUtils . join ( rangesMM . keySet ( ) , " , " ) + " ] " ) ; 
 + final Set < Map . Entry < Range , InetAddress > > pending = new HashSet < Map . Entry < Range , InetAddress > > ( rangesMM . entries ( ) ) ; 
 + for ( final Map . Entry < Range , InetAddress > entry : rangesMM . entries ( ) ) 
 + { 
 + final Range range = entry . getKey ( ) ; 
 + final InetAddress newEndpoint = entry . getValue ( ) ; 
 + final Runnable callback = new Runnable ( ) 
 + { 
 + public synchronized void run ( ) 
 + { 
 + pending . remove ( entry ) ; 
 + if ( pending . isEmpty ( ) ) 
 + finishLeaving ( ) ; 
 + } 
 + } ; 
 + StageManager . getStage ( streamStage _ ) . execute ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / TODO each call to transferRanges re - flushes , this is potentially a lot of waste 
 + Streaming . transferRanges ( newEndpoint , Arrays . asList ( range ) , callback ) ; 
 + } 
 + } ) ; 
 + } 
 + } 
 + 
 public < T > QuorumResponseHandler < T > getResponseHandler ( IResponseResolver < T > responseResolver , int blockFor , int consistency _ level ) 
 { 
 return replicationStrategy _ . getResponseHandler ( responseResolver , blockFor , consistency _ level ) ; 
 @ @ - 860 , 4 + 974 , 20 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 { 
 return replicationStrategy _ ; 
 } 
 + 
 + public void finishLeaving ( ) 
 + { 
 + Gossiper . instance ( ) . addApplicationState ( STATE _ LEFT , new ApplicationState ( getLocalToken ( ) . toString ( ) ) ) ; 
 + try 
 + { 
 + Thread . sleep ( 2 * Gossiper . intervalInMillis _ ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + Gossiper . instance ( ) . stop ( ) ; 
 + logger _ . info ( " DECOMMISSION FINISHED . " ) ; 
 + / / let op be responsible for killing the process 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index 47b85fb . . 01c9657 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 113 , 6 + 113 , 11 @ @ public interface StorageServiceMBean 
 * / 
 public void forceTableFlush ( String tableName , String . . . columnFamilies ) throws IOException ; 
 
 + / * * 
 + * transfer this node ' s data to other machines and remove it from service . 
 + * / 
 + public void decommission ( ) ; 
 + 
 / * * set the logging level at runtime * / 
 public void setLog4jLevel ( String classQualifier , String level ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index de4727f . . 28904d1 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 380 , 6 + 380 , 11 @ @ public class NodeProbe 
 ssProxy . clearSnapshot ( ) ; 
 } 
 
 + public void decommission ( ) 
 + { 
 + ssProxy . decommission ( ) ; 
 + } 
 + 
 / * * 
 * Print out the size of the queues in the thread pools 
 * 
 @ @ - 474 , 7 + 479 , 8 @ @ public class NodeProbe 
 { 
 HelpFormatter hf = new HelpFormatter ( ) ; 
 String header = String . format ( 
 - " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , tpstats , flush , " + 
 + " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , " + 
 + " tpstats , flush , decommission , " + 
 " getcompactionthreshold , setcompactionthreshold [ minthreshold ] ( [ maxthreshold ] ) " ) ; 
 String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; 
 hf . printHelp ( usage , " " , options , header ) ; 
 @ @ - 533 , 6 + 539 , 10 @ @ public class NodeProbe 
 { 
 probe . printColumnFamilyStats ( System . out ) ; 
 } 
 + else if ( cmdName . equals ( " decommission " ) ) 
 + { 
 + probe . decommission ( ) ; 
 + } 
 else if ( cmdName . equals ( " snapshot " ) ) 
 { 
 String snapshotName = " " ;
