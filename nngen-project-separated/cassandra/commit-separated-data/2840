BLEU SCORE: 0.07160476144948855

TEST MSG: Secondary indexing of map keys
GENERATED MSG: Improve Gossip tolerance of abnormally slow tasks

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 24722b8 . . 58a0906 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 15 , 7 + 15 , 7 @ @ <nl> * User - defined types for CQL3 ( CASSANDRA - 5590 ) <nl> * Use of o . a . c . metrics in nodetool ( CASSANDRA - 5871 , 6406 ) <nl> * Batch read from OTC ' s queue and cleanup ( CASSANDRA - 1632 ) <nl> - * Secondary index support for collections ( CASSANDRA - 4511 ) <nl> + * Secondary index support for collections ( CASSANDRA - 4511 , 6383 ) <nl> * SSTable metadata ( Stats . db ) format change ( CASSANDRA - 6356 ) <nl> * Push composites support in the storage engine <nl> ( CASSANDRA - 5417 , CASSANDRA - 6520 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index f9f66df . . 11291b6 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 552 , 12 + 552 , 18 @ @ createIndexStatement returns [ CreateIndexStatement expr ] <nl> boolean ifNotExists = false ; <nl> } <nl> : K _ CREATE ( K _ CUSTOM { props . isCustom = true ; } ) ? K _ INDEX ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? <nl> - ( idxName = IDENT ) ? K _ ON cf = columnFamilyName ' ( ' id = cident ' ) ' <nl> + ( idxName = IDENT ) ? K _ ON cf = columnFamilyName ' ( ' id = indexIdent ' ) ' <nl> ( K _ USING cls = STRING _ LITERAL { props . customClass = $ cls . text ; } ) ? <nl> ( K _ WITH properties [ props ] ) ? <nl> { $ expr = new CreateIndexStatement ( cf , $ idxName . text , id , props , ifNotExists ) ; } <nl> ; <nl> <nl> + indexIdent returns [ IndexTarget id ] <nl> + : c = cident { $ id = IndexTarget . of ( c ) ; } <nl> + | K _ KEYS ' ( ' c = cident ' ) ' { $ id = IndexTarget . keysOf ( c ) ; } <nl> + ; <nl> + <nl> + <nl> / * * <nl> * CREATE TRIGGER triggerName ON columnFamily USING ' triggerClass ' ; <nl> * / <nl> @ @ - 958 , 7 + 964 , 7 @ @ relation [ List < Relation > clauses ] <nl> { $ clauses . add ( new Relation ( name , Relation . Type . IN , marker ) ) ; } <nl> | name = cident K _ IN { Relation rel = Relation . createInRelation ( $ name . id ) ; } <nl> ' ( ' ( f1 = term { rel . addInValue ( f1 ) ; } ( ' , ' fN = term { rel . addInValue ( fN ) ; } ) * ) ? ' ) ' { $ clauses . add ( rel ) ; } <nl> - | name = cident K _ CONTAINS { Relation . Type rt = Relation . Type . CONTAINS ; } / * ( K _ KEY { rt = Relation . Type . CONTAINS _ KEY } ) ? * / <nl> + | name = cident K _ CONTAINS { Relation . Type rt = Relation . Type . CONTAINS ; } ( K _ KEY { rt = Relation . Type . CONTAINS _ KEY ; } ) ? <nl> t = term { $ clauses . add ( new Relation ( name , rt , t ) ) ; } <nl> | ' ( ' relation [ $ clauses ] ' ) ' <nl> ; <nl> @ @ - 1036 , 6 + 1042 , 7 @ @ unreserved _ function _ keyword returns [ String str ] <nl> <nl> basic _ unreserved _ keyword returns [ String str ] <nl> : k = ( K _ KEY <nl> + | K _ KEYS <nl> | K _ AS <nl> | K _ CLUSTERING <nl> | K _ COMPACT <nl> @ @ - 1070 , 6 + 1077 , 7 @ @ K _ AS : A S ; <nl> K _ WHERE : W H E R E ; <nl> K _ AND : A N D ; <nl> K _ KEY : K E Y ; <nl> + K _ KEYS : K E Y S ; <nl> K _ INSERT : I N S E R T ; <nl> K _ UPDATE : U P D A T E ; <nl> K _ WITH : W I T H ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> index 56b465e . . ca43d20 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java <nl> @ @ - 29 , 6 + 29 , 8 @ @ import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> import org . apache . cassandra . config . IndexType ; <nl> import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . db . index . SecondaryIndex ; <nl> + import org . apache . cassandra . db . marshal . MapType ; <nl> import org . apache . cassandra . exceptions . * ; <nl> import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . service . ClientState ; <nl> @ @ - 42 , 19 + 44 , 19 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> private static final Logger logger = LoggerFactory . getLogger ( CreateIndexStatement . class ) ; <nl> <nl> private final String indexName ; <nl> - private final ColumnIdentifier columnName ; <nl> + private final IndexTarget target ; <nl> private final IndexPropDefs properties ; <nl> private final boolean ifNotExists ; <nl> <nl> public CreateIndexStatement ( CFName name , <nl> String indexName , <nl> - ColumnIdentifier columnName , <nl> + IndexTarget target , <nl> IndexPropDefs properties , <nl> boolean ifNotExists ) <nl> { <nl> super ( name ) ; <nl> this . indexName = indexName ; <nl> - this . columnName = columnName ; <nl> + this . target = target ; <nl> this . properties = properties ; <nl> this . ifNotExists = ifNotExists ; <nl> } <nl> @ @ - 70 , 13 + 72 , 27 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> if ( cfm . getDefaultValidator ( ) . isCommutative ( ) ) <nl> throw new InvalidRequestException ( " Secondary indexes are not supported on counter tables " ) ; <nl> <nl> - ColumnDefinition cd = cfm . getColumnDefinition ( columnName ) ; <nl> + ColumnDefinition cd = cfm . getColumnDefinition ( target . column ) ; <nl> <nl> if ( cd = = null ) <nl> - throw new InvalidRequestException ( " No column definition found for column " + columnName ) ; <nl> + throw new InvalidRequestException ( " No column definition found for column " + target . column ) ; <nl> + <nl> + boolean isMap = cd . type instanceof MapType ; <nl> + if ( target . isCollectionKeys & & ! isMap ) <nl> + throw new InvalidRequestException ( " Cannot create index on keys of column " + target + " with non map type " ) ; <nl> <nl> if ( cd . getIndexType ( ) ! = null ) <nl> { <nl> + boolean previousIsKeys = cd . getIndexOptions ( ) . containsKey ( " index _ keys " ) ; <nl> + if ( isMap & & target . isCollectionKeys ! = previousIsKeys ) <nl> + { <nl> + String msg = " Cannot create index on % s % s , an index on % s % s already exists and indexing " <nl> + + " a map on both keys and values at the same time is not currently supported " ; <nl> + throw new InvalidRequestException ( String . format ( msg , <nl> + target . column , target . isCollectionKeys ? " keys " : " values " , <nl> + target . column , previousIsKeys ? " keys " : " values " ) ) ; <nl> + } <nl> + <nl> if ( ifNotExists ) <nl> return ; <nl> else <nl> @ @ - 87 , 17 + 103 , 17 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> <nl> / / TODO : we could lift that limitation <nl> if ( cfm . comparator . isDense ( ) & & cd . kind ! = ColumnDefinition . Kind . REGULAR ) <nl> - throw new InvalidRequestException ( String . format ( " Secondary index on % s column % s is not yet supported for compact table " , cd . kind , columnName ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Secondary index on % s column % s is not yet supported for compact table " , cd . kind , target . column ) ) ; <nl> <nl> if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cd . isOnAllComponents ( ) ) <nl> - throw new InvalidRequestException ( String . format ( " Cannot add secondary index to already primarily indexed column % s " , columnName ) ) ; <nl> + throw new InvalidRequestException ( String . format ( " Cannot add secondary index to already primarily indexed column % s " , target . column ) ) ; <nl> } <nl> <nl> public void announceMigration ( ) throws RequestValidationException <nl> { <nl> - logger . debug ( " Updating column { } definition for index { } " , columnName , indexName ) ; <nl> + logger . debug ( " Updating column { } definition for index { } " , target . column , indexName ) ; <nl> CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace ( ) , columnFamily ( ) ) . clone ( ) ; <nl> - ColumnDefinition cd = cfm . getColumnDefinition ( columnName ) ; <nl> + ColumnDefinition cd = cfm . getColumnDefinition ( target . column ) ; <nl> <nl> if ( cd . getIndexType ( ) ! = null & & ifNotExists ) <nl> return ; <nl> @ @ - 113 , 7 + 129 , 7 @ @ public class CreateIndexStatement extends SchemaAlteringStatement <nl> / / to also index map keys , so we record that this is the values we index to make our <nl> / / lives easier then . <nl> if ( cd . type . isCollection ( ) ) <nl> - options = ImmutableMap . of ( " index _ values " , " " ) ; <nl> + options = ImmutableMap . of ( target . isCollectionKeys ? " index _ keys " : " index _ values " , " " ) ; <nl> cd . setIndexType ( IndexType . COMPOSITES , options ) ; <nl> } <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java b / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java <nl> new file mode 100644 <nl> index 0000000 . . 58a8c92 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java <nl> @ @ - 0 , 0 + 1 , 42 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 . statements ; <nl> + <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + <nl> + public class IndexTarget <nl> + { <nl> + public final ColumnIdentifier column ; <nl> + public final boolean isCollectionKeys ; <nl> + <nl> + private IndexTarget ( ColumnIdentifier column , boolean isCollectionKeys ) <nl> + { <nl> + this . column = column ; <nl> + this . isCollectionKeys = isCollectionKeys ; <nl> + } <nl> + <nl> + public static IndexTarget of ( ColumnIdentifier c ) <nl> + { <nl> + return new IndexTarget ( c , false ) ; <nl> + } <nl> + <nl> + public static IndexTarget keysOf ( ColumnIdentifier c ) <nl> + { <nl> + return new IndexTarget ( c , true ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java b / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java <nl> index 839df26 . . c92f653 100644 <nl> - - - a / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java <nl> + + + b / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java <nl> @ @ - 65 , 7 + 65 , 9 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn <nl> case SET : <nl> return new CompositesIndexOnCollectionKey ( ) ; <nl> case MAP : <nl> - return new CompositesIndexOnCollectionValue ( ) ; <nl> + return cfDef . getIndexOptions ( ) . containsKey ( " index _ keys " ) <nl> + ? new CompositesIndexOnCollectionKey ( ) <nl> + : new CompositesIndexOnCollectionValue ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 95 , 7 + 97 , 9 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn <nl> case SET : <nl> return CompositesIndexOnCollectionKey . buildIndexComparator ( baseMetadata , cfDef ) ; <nl> case MAP : <nl> - return CompositesIndexOnCollectionValue . buildIndexComparator ( baseMetadata , cfDef ) ; <nl> + return cfDef . getIndexOptions ( ) . containsKey ( " index _ keys " ) <nl> + ? CompositesIndexOnCollectionKey . buildIndexComparator ( baseMetadata , cfDef ) <nl> + : CompositesIndexOnCollectionValue . buildIndexComparator ( baseMetadata , cfDef ) ; <nl> } <nl> } <nl> <nl> @ @ - 154 , 7 + 158 , 10 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn <nl> options . remove ( " prefix _ size " ) ; <nl> <nl> if ( columnDef . type . isCollection ( ) ) <nl> + { <nl> options . remove ( " index _ values " ) ; <nl> + options . remove ( " index _ keys " ) ; <nl> + } <nl> <nl> if ( ! options . isEmpty ( ) ) <nl> throw new ConfigurationException ( " Unknown options provided for COMPOSITES index : " + options . keySet ( ) ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e4f1862 . . 159e8de 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> * Fix serialization bug in PagedRange with 2ndary indexes ( CASSANDRA - 6299 ) <nl> * Fix CQL3 table validation in Thrift ( CASSANDRA - 6140 ) <nl> * Fix bug missing results with IN clauses ( CASSANDRA - 6327 ) <nl> + * Fix paging with reversed slices ( CASSANDRA - 6343 ) <nl> Merged from 1 . 2 : <nl> * add non - jamm path for cached statements ( CASSANDRA - 6293 ) <nl> * ( Hadoop ) Require CFRR batchSize to be at least 2 ( CASSANDRA - 6114 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index b2c5ac4 . . 47b14b9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 451 , 6 + 451 , 11 @ @ public abstract class ColumnFamily implements Iterable < Column > , IRowCacheEntry <nl> return getSortedColumns ( ) . iterator ( ) ; <nl> } <nl> <nl> + public Iterator < Column > reverseIterator ( ) <nl> + { <nl> + return getReverseSortedColumns ( ) . iterator ( ) ; <nl> + } <nl> + <nl> public boolean hasIrrelevantData ( int gcBefore ) <nl> { <nl> / / Do we have gcable deletion infos ? <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> index 62cd454 . . d040203 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> @ @ - 93 , 7 + 93 , 7 @ @ abstract class AbstractQueryPager implements QueryPager <nl> remaining + + ; <nl> } <nl> / / Otherwise , if ' lastWasRecorded ' , we queried for one more than the page size , <nl> - / / so if the page was is full , trim the last entry <nl> + / / so if the page is full , trim the last entry <nl> else if ( lastWasRecorded & & ! exhausted ) <nl> { <nl> / / We ' ve asked for one more than necessary <nl> @ @ - 161 , 11 + 161 , 14 @ @ abstract class AbstractQueryPager implements QueryPager <nl> protected abstract List < Row > queryNextPage ( int pageSize , ConsistencyLevel consistency , boolean localQuery ) throws RequestValidationException , RequestExecutionException ; <nl> protected abstract boolean containsPreviousLast ( Row first ) ; <nl> protected abstract boolean recordLast ( Row last ) ; <nl> + protected abstract boolean isReversed ( ) ; <nl> <nl> private List < Row > discardFirst ( List < Row > rows ) <nl> { <nl> Row first = rows . get ( 0 ) ; <nl> - ColumnFamily newCf = discardFirst ( first . cf ) ; <nl> + ColumnFamily newCf = isReversed ( ) <nl> + ? discardLast ( first . cf ) <nl> + : discardFirst ( first . cf ) ; <nl> <nl> int count = newCf . getColumnCount ( ) ; <nl> List < Row > newRows = new ArrayList < Row > ( count = = 0 ? rows . size ( ) - 1 : rows . size ( ) ) ; <nl> @ @ - 179 , 7 + 182 , 9 @ @ abstract class AbstractQueryPager implements QueryPager <nl> private List < Row > discardLast ( List < Row > rows ) <nl> { <nl> Row last = rows . get ( rows . size ( ) - 1 ) ; <nl> - ColumnFamily newCf = discardLast ( last . cf ) ; <nl> + ColumnFamily newCf = isReversed ( ) <nl> + ? discardFirst ( last . cf ) <nl> + : discardLast ( last . cf ) ; <nl> <nl> int count = newCf . getColumnCount ( ) ; <nl> List < Row > newRows = new ArrayList < Row > ( count = = 0 ? rows . size ( ) - 1 : rows . size ( ) ) ; <nl> @ @ - 200 , 11 + 205 , 27 @ @ abstract class AbstractQueryPager implements QueryPager <nl> <nl> private ColumnFamily discardFirst ( ColumnFamily cf ) <nl> { <nl> + boolean isReversed = isReversed ( ) ; <nl> + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; <nl> + return isReversed <nl> + ? discardTail ( cf , cf . reverseIterator ( ) , tester ) <nl> + : discardHead ( cf , cf . iterator ( ) , tester ) ; <nl> + } <nl> + <nl> + private ColumnFamily discardLast ( ColumnFamily cf ) <nl> + { <nl> + boolean isReversed = isReversed ( ) ; <nl> + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; <nl> + return isReversed <nl> + ? discardHead ( cf , cf . reverseIterator ( ) , tester ) <nl> + : discardTail ( cf , cf . iterator ( ) , tester ) ; <nl> + } <nl> + <nl> + private ColumnFamily discardHead ( ColumnFamily cf , Iterator < Column > iter , DeletionInfo . InOrderTester tester ) <nl> + { <nl> ColumnFamily copy = cf . cloneMeShallow ( ) ; <nl> ColumnCounter counter = columnCounter ( ) ; <nl> <nl> - Iterator < Column > iter = cf . iterator ( ) ; <nl> - DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; <nl> / / Discard the first live <nl> while ( iter . hasNext ( ) ) <nl> { <nl> @ @ - 220 , 22 + 241 , 24 @ @ abstract class AbstractQueryPager implements QueryPager <nl> return copy ; <nl> } <nl> <nl> - private ColumnFamily discardLast ( ColumnFamily cf ) <nl> + private ColumnFamily discardTail ( ColumnFamily cf , Iterator < Column > iter , DeletionInfo . InOrderTester tester ) <nl> { <nl> ColumnFamily copy = cf . cloneMeShallow ( ) ; <nl> - / / Redoing the counting like that is not extremely efficient , but <nl> - / / discardLast is only called in case of a race between paging and <nl> - / / a deletion , which is pretty unlikely , so probably not a big deal <nl> + / / Redoing the counting like that is not extremely efficient . <nl> + / / This is called only for reversed slices or in the case of a race between <nl> + / / paging and a deletion ( pretty unlikely ) , so this is probably acceptable . <nl> int liveCount = columnCounter ( ) . countAll ( cf ) . live ( ) ; <nl> <nl> ColumnCounter counter = columnCounter ( ) ; <nl> - DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; <nl> / / Discard the first live <nl> - for ( Column c : cf ) <nl> + while ( iter . hasNext ( ) ) <nl> { <nl> + Column c = iter . next ( ) ; <nl> counter . count ( c , tester ) ; <nl> - if ( counter . live ( ) < liveCount ) <nl> - copy . addColumn ( c ) ; <nl> + if ( counter . live ( ) > = liveCount ) <nl> + break ; <nl> + <nl> + copy . addColumn ( c ) ; <nl> } <nl> return copy ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> index 57fb05b . . e3b0cf8 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> @ @ - 91 , 6 + 91 , 11 @ @ public class RangeNamesQueryPager extends AbstractQueryPager <nl> return false ; <nl> } <nl> <nl> + protected boolean isReversed ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> private AbstractBounds < RowPosition > makeExcludingKeyBounds ( RowPosition lastReturnedKey ) <nl> { <nl> / / We return a range that always exclude lastReturnedKey , since we ' ve already <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> index 42a9585 . . 1f4ba78 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> @ @ - 91 , 16 + 91 , 21 @ @ public class RangeSliceQueryPager extends AbstractQueryPager <nl> { <nl> return lastReturnedKey ! = null <nl> & & lastReturnedKey . equals ( first . key ) <nl> - & & lastReturnedName . equals ( firstName ( first . cf ) ) ; <nl> + & & lastReturnedName . equals ( isReversed ( ) ? lastName ( first . cf ) : firstName ( first . cf ) ) ; <nl> } <nl> <nl> protected boolean recordLast ( Row last ) <nl> { <nl> lastReturnedKey = last . key ; <nl> - lastReturnedName = lastName ( last . cf ) ; <nl> + lastReturnedName = isReversed ( ) ? firstName ( last . cf ) : lastName ( last . cf ) ; <nl> return true ; <nl> } <nl> <nl> + protected boolean isReversed ( ) <nl> + { <nl> + return ( ( SliceQueryFilter ) command . predicate ) . reversed ; <nl> + } <nl> + <nl> private AbstractBounds < RowPosition > makeIncludingKeyBounds ( RowPosition lastReturnedKey ) <nl> { <nl> / / We always include lastReturnedKey since we may still be paging within a row , <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java <nl> index 1d77144 . . e3825a9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java <nl> @ @ - 76 , 12 + 76 , 17 @ @ public class SliceQueryPager extends AbstractQueryPager implements SinglePartiti <nl> <nl> protected boolean containsPreviousLast ( Row first ) <nl> { <nl> - return lastReturned ! = null & & lastReturned . equals ( firstName ( first . cf ) ) ; <nl> + return lastReturned ! = null & & lastReturned . equals ( isReversed ( ) ? lastName ( first . cf ) : firstName ( first . cf ) ) ; <nl> } <nl> <nl> protected boolean recordLast ( Row last ) <nl> { <nl> - lastReturned = lastName ( last . cf ) ; <nl> + lastReturned = isReversed ( ) ? firstName ( last . cf ) : lastName ( last . cf ) ; <nl> return true ; <nl> } <nl> + <nl> + protected boolean isReversed ( ) <nl> + { <nl> + return command . filter . reversed ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / service / QueryPagerTest . java b / test / unit / org / apache / cassandra / service / QueryPagerTest . java <nl> index 3fc2ac2 . . f395cf4 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / QueryPagerTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / QueryPagerTest . java <nl> @ @ - 117 , 7 + 117 , 12 @ @ public class QueryPagerTest extends SchemaLoader <nl> <nl> private static ReadCommand sliceQuery ( String key , String start , String end , int count ) <nl> { <nl> - SliceQueryFilter filter = new SliceQueryFilter ( bytes ( start ) , bytes ( end ) , false , count ) ; <nl> + return sliceQuery ( key , start , end , false , count ) ; <nl> + } <nl> + <nl> + private static ReadCommand sliceQuery ( String key , String start , String end , boolean reversed , int count ) <nl> + { <nl> + SliceQueryFilter filter = new SliceQueryFilter ( bytes ( start ) , bytes ( end ) , reversed , count ) ; <nl> / / Note : for MultiQueryTest , we need the same timestamp / expireBefore for all queries , so we just use 0 as it doesn ' t matter here . <nl> return new SliceFromReadCommand ( KS , bytes ( key ) , CF , 0 , filter ) ; <nl> } <nl> @ @ - 188 , 6 + 193 , 31 @ @ public class QueryPagerTest extends SchemaLoader <nl> } <nl> <nl> @ Test <nl> + public void reversedSliceQueryTest ( ) throws Exception <nl> + { <nl> + QueryPager pager = QueryPagers . localPager ( sliceQuery ( " k0 " , " c8 " , " c1 " , true , 10 ) ) ; <nl> + <nl> + List < Row > page ; <nl> + <nl> + assertFalse ( pager . isExhausted ( ) ) ; <nl> + page = pager . fetchPage ( 3 ) ; <nl> + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; <nl> + assertRow ( page . get ( 0 ) , " k0 " , " c6 " , " c7 " , " c8 " ) ; <nl> + <nl> + assertFalse ( pager . isExhausted ( ) ) ; <nl> + page = pager . fetchPage ( 3 ) ; <nl> + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; <nl> + assertRow ( page . get ( 0 ) , " k0 " , " c3 " , " c4 " , " c5 " ) ; <nl> + <nl> + assertFalse ( pager . isExhausted ( ) ) ; <nl> + page = pager . fetchPage ( 3 ) ; <nl> + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; <nl> + assertRow ( page . get ( 0 ) , " k0 " , " c1 " , " c2 " ) ; <nl> + <nl> + assertTrue ( pager . isExhausted ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void MultiQueryTest ( ) throws Exception <nl> { <nl> QueryPager pager = QueryPagers . localPager ( new Pageable . ReadCommands ( new ArrayList < ReadCommand > ( ) { {

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 24722b8 . . 58a0906 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 15 , 7 + 15 , 7 @ @ 
 * User - defined types for CQL3 ( CASSANDRA - 5590 ) 
 * Use of o . a . c . metrics in nodetool ( CASSANDRA - 5871 , 6406 ) 
 * Batch read from OTC ' s queue and cleanup ( CASSANDRA - 1632 ) 
 - * Secondary index support for collections ( CASSANDRA - 4511 ) 
 + * Secondary index support for collections ( CASSANDRA - 4511 , 6383 ) 
 * SSTable metadata ( Stats . db ) format change ( CASSANDRA - 6356 ) 
 * Push composites support in the storage engine 
 ( CASSANDRA - 5417 , CASSANDRA - 6520 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index f9f66df . . 11291b6 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 552 , 12 + 552 , 18 @ @ createIndexStatement returns [ CreateIndexStatement expr ] 
 boolean ifNotExists = false ; 
 } 
 : K _ CREATE ( K _ CUSTOM { props . isCustom = true ; } ) ? K _ INDEX ( K _ IF K _ NOT K _ EXISTS { ifNotExists = true ; } ) ? 
 - ( idxName = IDENT ) ? K _ ON cf = columnFamilyName ' ( ' id = cident ' ) ' 
 + ( idxName = IDENT ) ? K _ ON cf = columnFamilyName ' ( ' id = indexIdent ' ) ' 
 ( K _ USING cls = STRING _ LITERAL { props . customClass = $ cls . text ; } ) ? 
 ( K _ WITH properties [ props ] ) ? 
 { $ expr = new CreateIndexStatement ( cf , $ idxName . text , id , props , ifNotExists ) ; } 
 ; 
 
 + indexIdent returns [ IndexTarget id ] 
 + : c = cident { $ id = IndexTarget . of ( c ) ; } 
 + | K _ KEYS ' ( ' c = cident ' ) ' { $ id = IndexTarget . keysOf ( c ) ; } 
 + ; 
 + 
 + 
 / * * 
 * CREATE TRIGGER triggerName ON columnFamily USING ' triggerClass ' ; 
 * / 
 @ @ - 958 , 7 + 964 , 7 @ @ relation [ List < Relation > clauses ] 
 { $ clauses . add ( new Relation ( name , Relation . Type . IN , marker ) ) ; } 
 | name = cident K _ IN { Relation rel = Relation . createInRelation ( $ name . id ) ; } 
 ' ( ' ( f1 = term { rel . addInValue ( f1 ) ; } ( ' , ' fN = term { rel . addInValue ( fN ) ; } ) * ) ? ' ) ' { $ clauses . add ( rel ) ; } 
 - | name = cident K _ CONTAINS { Relation . Type rt = Relation . Type . CONTAINS ; } / * ( K _ KEY { rt = Relation . Type . CONTAINS _ KEY } ) ? * / 
 + | name = cident K _ CONTAINS { Relation . Type rt = Relation . Type . CONTAINS ; } ( K _ KEY { rt = Relation . Type . CONTAINS _ KEY ; } ) ? 
 t = term { $ clauses . add ( new Relation ( name , rt , t ) ) ; } 
 | ' ( ' relation [ $ clauses ] ' ) ' 
 ; 
 @ @ - 1036 , 6 + 1042 , 7 @ @ unreserved _ function _ keyword returns [ String str ] 
 
 basic _ unreserved _ keyword returns [ String str ] 
 : k = ( K _ KEY 
 + | K _ KEYS 
 | K _ AS 
 | K _ CLUSTERING 
 | K _ COMPACT 
 @ @ - 1070 , 6 + 1077 , 7 @ @ K _ AS : A S ; 
 K _ WHERE : W H E R E ; 
 K _ AND : A N D ; 
 K _ KEY : K E Y ; 
 + K _ KEYS : K E Y S ; 
 K _ INSERT : I N S E R T ; 
 K _ UPDATE : U P D A T E ; 
 K _ WITH : W I T H ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 index 56b465e . . ca43d20 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateIndexStatement . java 
 @ @ - 29 , 6 + 29 , 8 @ @ import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 import org . apache . cassandra . config . IndexType ; 
 import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . db . index . SecondaryIndex ; 
 + import org . apache . cassandra . db . marshal . MapType ; 
 import org . apache . cassandra . exceptions . * ; 
 import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . service . ClientState ; 
 @ @ - 42 , 19 + 44 , 19 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 private static final Logger logger = LoggerFactory . getLogger ( CreateIndexStatement . class ) ; 
 
 private final String indexName ; 
 - private final ColumnIdentifier columnName ; 
 + private final IndexTarget target ; 
 private final IndexPropDefs properties ; 
 private final boolean ifNotExists ; 
 
 public CreateIndexStatement ( CFName name , 
 String indexName , 
 - ColumnIdentifier columnName , 
 + IndexTarget target , 
 IndexPropDefs properties , 
 boolean ifNotExists ) 
 { 
 super ( name ) ; 
 this . indexName = indexName ; 
 - this . columnName = columnName ; 
 + this . target = target ; 
 this . properties = properties ; 
 this . ifNotExists = ifNotExists ; 
 } 
 @ @ - 70 , 13 + 72 , 27 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 if ( cfm . getDefaultValidator ( ) . isCommutative ( ) ) 
 throw new InvalidRequestException ( " Secondary indexes are not supported on counter tables " ) ; 
 
 - ColumnDefinition cd = cfm . getColumnDefinition ( columnName ) ; 
 + ColumnDefinition cd = cfm . getColumnDefinition ( target . column ) ; 
 
 if ( cd = = null ) 
 - throw new InvalidRequestException ( " No column definition found for column " + columnName ) ; 
 + throw new InvalidRequestException ( " No column definition found for column " + target . column ) ; 
 + 
 + boolean isMap = cd . type instanceof MapType ; 
 + if ( target . isCollectionKeys & & ! isMap ) 
 + throw new InvalidRequestException ( " Cannot create index on keys of column " + target + " with non map type " ) ; 
 
 if ( cd . getIndexType ( ) ! = null ) 
 { 
 + boolean previousIsKeys = cd . getIndexOptions ( ) . containsKey ( " index _ keys " ) ; 
 + if ( isMap & & target . isCollectionKeys ! = previousIsKeys ) 
 + { 
 + String msg = " Cannot create index on % s % s , an index on % s % s already exists and indexing " 
 + + " a map on both keys and values at the same time is not currently supported " ; 
 + throw new InvalidRequestException ( String . format ( msg , 
 + target . column , target . isCollectionKeys ? " keys " : " values " , 
 + target . column , previousIsKeys ? " keys " : " values " ) ) ; 
 + } 
 + 
 if ( ifNotExists ) 
 return ; 
 else 
 @ @ - 87 , 17 + 103 , 17 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 
 / / TODO : we could lift that limitation 
 if ( cfm . comparator . isDense ( ) & & cd . kind ! = ColumnDefinition . Kind . REGULAR ) 
 - throw new InvalidRequestException ( String . format ( " Secondary index on % s column % s is not yet supported for compact table " , cd . kind , columnName ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Secondary index on % s column % s is not yet supported for compact table " , cd . kind , target . column ) ) ; 
 
 if ( cd . kind = = ColumnDefinition . Kind . PARTITION _ KEY & & cd . isOnAllComponents ( ) ) 
 - throw new InvalidRequestException ( String . format ( " Cannot add secondary index to already primarily indexed column % s " , columnName ) ) ; 
 + throw new InvalidRequestException ( String . format ( " Cannot add secondary index to already primarily indexed column % s " , target . column ) ) ; 
 } 
 
 public void announceMigration ( ) throws RequestValidationException 
 { 
 - logger . debug ( " Updating column { } definition for index { } " , columnName , indexName ) ; 
 + logger . debug ( " Updating column { } definition for index { } " , target . column , indexName ) ; 
 CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace ( ) , columnFamily ( ) ) . clone ( ) ; 
 - ColumnDefinition cd = cfm . getColumnDefinition ( columnName ) ; 
 + ColumnDefinition cd = cfm . getColumnDefinition ( target . column ) ; 
 
 if ( cd . getIndexType ( ) ! = null & & ifNotExists ) 
 return ; 
 @ @ - 113 , 7 + 129 , 7 @ @ public class CreateIndexStatement extends SchemaAlteringStatement 
 / / to also index map keys , so we record that this is the values we index to make our 
 / / lives easier then . 
 if ( cd . type . isCollection ( ) ) 
 - options = ImmutableMap . of ( " index _ values " , " " ) ; 
 + options = ImmutableMap . of ( target . isCollectionKeys ? " index _ keys " : " index _ values " , " " ) ; 
 cd . setIndexType ( IndexType . COMPOSITES , options ) ; 
 } 
 else 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java b / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java 
 new file mode 100644 
 index 0000000 . . 58a8c92 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / IndexTarget . java 
 @ @ - 0 , 0 + 1 , 42 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 . statements ; 
 + 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + 
 + public class IndexTarget 
 + { 
 + public final ColumnIdentifier column ; 
 + public final boolean isCollectionKeys ; 
 + 
 + private IndexTarget ( ColumnIdentifier column , boolean isCollectionKeys ) 
 + { 
 + this . column = column ; 
 + this . isCollectionKeys = isCollectionKeys ; 
 + } 
 + 
 + public static IndexTarget of ( ColumnIdentifier c ) 
 + { 
 + return new IndexTarget ( c , false ) ; 
 + } 
 + 
 + public static IndexTarget keysOf ( ColumnIdentifier c ) 
 + { 
 + return new IndexTarget ( c , true ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java b / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java 
 index 839df26 . . c92f653 100644 
 - - - a / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java 
 + + + b / src / java / org / apache / cassandra / db / index / composites / CompositesIndex . java 
 @ @ - 65 , 7 + 65 , 9 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn 
 case SET : 
 return new CompositesIndexOnCollectionKey ( ) ; 
 case MAP : 
 - return new CompositesIndexOnCollectionValue ( ) ; 
 + return cfDef . getIndexOptions ( ) . containsKey ( " index _ keys " ) 
 + ? new CompositesIndexOnCollectionKey ( ) 
 + : new CompositesIndexOnCollectionValue ( ) ; 
 } 
 } 
 
 @ @ - 95 , 7 + 97 , 9 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn 
 case SET : 
 return CompositesIndexOnCollectionKey . buildIndexComparator ( baseMetadata , cfDef ) ; 
 case MAP : 
 - return CompositesIndexOnCollectionValue . buildIndexComparator ( baseMetadata , cfDef ) ; 
 + return cfDef . getIndexOptions ( ) . containsKey ( " index _ keys " ) 
 + ? CompositesIndexOnCollectionKey . buildIndexComparator ( baseMetadata , cfDef ) 
 + : CompositesIndexOnCollectionValue . buildIndexComparator ( baseMetadata , cfDef ) ; 
 } 
 } 
 
 @ @ - 154 , 7 + 158 , 10 @ @ public abstract class CompositesIndex extends AbstractSimplePerColumnSecondaryIn 
 options . remove ( " prefix _ size " ) ; 
 
 if ( columnDef . type . isCollection ( ) ) 
 + { 
 options . remove ( " index _ values " ) ; 
 + options . remove ( " index _ keys " ) ; 
 + } 
 
 if ( ! options . isEmpty ( ) ) 
 throw new ConfigurationException ( " Unknown options provided for COMPOSITES index : " + options . keySet ( ) ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e4f1862 . . 159e8de 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 * Fix serialization bug in PagedRange with 2ndary indexes ( CASSANDRA - 6299 ) 
 * Fix CQL3 table validation in Thrift ( CASSANDRA - 6140 ) 
 * Fix bug missing results with IN clauses ( CASSANDRA - 6327 ) 
 + * Fix paging with reversed slices ( CASSANDRA - 6343 ) 
 Merged from 1 . 2 : 
 * add non - jamm path for cached statements ( CASSANDRA - 6293 ) 
 * ( Hadoop ) Require CFRR batchSize to be at least 2 ( CASSANDRA - 6114 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index b2c5ac4 . . 47b14b9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 451 , 6 + 451 , 11 @ @ public abstract class ColumnFamily implements Iterable < Column > , IRowCacheEntry 
 return getSortedColumns ( ) . iterator ( ) ; 
 } 
 
 + public Iterator < Column > reverseIterator ( ) 
 + { 
 + return getReverseSortedColumns ( ) . iterator ( ) ; 
 + } 
 + 
 public boolean hasIrrelevantData ( int gcBefore ) 
 { 
 / / Do we have gcable deletion infos ? 
 diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 index 62cd454 . . d040203 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 @ @ - 93 , 7 + 93 , 7 @ @ abstract class AbstractQueryPager implements QueryPager 
 remaining + + ; 
 } 
 / / Otherwise , if ' lastWasRecorded ' , we queried for one more than the page size , 
 - / / so if the page was is full , trim the last entry 
 + / / so if the page is full , trim the last entry 
 else if ( lastWasRecorded & & ! exhausted ) 
 { 
 / / We ' ve asked for one more than necessary 
 @ @ - 161 , 11 + 161 , 14 @ @ abstract class AbstractQueryPager implements QueryPager 
 protected abstract List < Row > queryNextPage ( int pageSize , ConsistencyLevel consistency , boolean localQuery ) throws RequestValidationException , RequestExecutionException ; 
 protected abstract boolean containsPreviousLast ( Row first ) ; 
 protected abstract boolean recordLast ( Row last ) ; 
 + protected abstract boolean isReversed ( ) ; 
 
 private List < Row > discardFirst ( List < Row > rows ) 
 { 
 Row first = rows . get ( 0 ) ; 
 - ColumnFamily newCf = discardFirst ( first . cf ) ; 
 + ColumnFamily newCf = isReversed ( ) 
 + ? discardLast ( first . cf ) 
 + : discardFirst ( first . cf ) ; 
 
 int count = newCf . getColumnCount ( ) ; 
 List < Row > newRows = new ArrayList < Row > ( count = = 0 ? rows . size ( ) - 1 : rows . size ( ) ) ; 
 @ @ - 179 , 7 + 182 , 9 @ @ abstract class AbstractQueryPager implements QueryPager 
 private List < Row > discardLast ( List < Row > rows ) 
 { 
 Row last = rows . get ( rows . size ( ) - 1 ) ; 
 - ColumnFamily newCf = discardLast ( last . cf ) ; 
 + ColumnFamily newCf = isReversed ( ) 
 + ? discardFirst ( last . cf ) 
 + : discardLast ( last . cf ) ; 
 
 int count = newCf . getColumnCount ( ) ; 
 List < Row > newRows = new ArrayList < Row > ( count = = 0 ? rows . size ( ) - 1 : rows . size ( ) ) ; 
 @ @ - 200 , 11 + 205 , 27 @ @ abstract class AbstractQueryPager implements QueryPager 
 
 private ColumnFamily discardFirst ( ColumnFamily cf ) 
 { 
 + boolean isReversed = isReversed ( ) ; 
 + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; 
 + return isReversed 
 + ? discardTail ( cf , cf . reverseIterator ( ) , tester ) 
 + : discardHead ( cf , cf . iterator ( ) , tester ) ; 
 + } 
 + 
 + private ColumnFamily discardLast ( ColumnFamily cf ) 
 + { 
 + boolean isReversed = isReversed ( ) ; 
 + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; 
 + return isReversed 
 + ? discardHead ( cf , cf . reverseIterator ( ) , tester ) 
 + : discardTail ( cf , cf . iterator ( ) , tester ) ; 
 + } 
 + 
 + private ColumnFamily discardHead ( ColumnFamily cf , Iterator < Column > iter , DeletionInfo . InOrderTester tester ) 
 + { 
 ColumnFamily copy = cf . cloneMeShallow ( ) ; 
 ColumnCounter counter = columnCounter ( ) ; 
 
 - Iterator < Column > iter = cf . iterator ( ) ; 
 - DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; 
 / / Discard the first live 
 while ( iter . hasNext ( ) ) 
 { 
 @ @ - 220 , 22 + 241 , 24 @ @ abstract class AbstractQueryPager implements QueryPager 
 return copy ; 
 } 
 
 - private ColumnFamily discardLast ( ColumnFamily cf ) 
 + private ColumnFamily discardTail ( ColumnFamily cf , Iterator < Column > iter , DeletionInfo . InOrderTester tester ) 
 { 
 ColumnFamily copy = cf . cloneMeShallow ( ) ; 
 - / / Redoing the counting like that is not extremely efficient , but 
 - / / discardLast is only called in case of a race between paging and 
 - / / a deletion , which is pretty unlikely , so probably not a big deal 
 + / / Redoing the counting like that is not extremely efficient . 
 + / / This is called only for reversed slices or in the case of a race between 
 + / / paging and a deletion ( pretty unlikely ) , so this is probably acceptable . 
 int liveCount = columnCounter ( ) . countAll ( cf ) . live ( ) ; 
 
 ColumnCounter counter = columnCounter ( ) ; 
 - DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; 
 / / Discard the first live 
 - for ( Column c : cf ) 
 + while ( iter . hasNext ( ) ) 
 { 
 + Column c = iter . next ( ) ; 
 counter . count ( c , tester ) ; 
 - if ( counter . live ( ) < liveCount ) 
 - copy . addColumn ( c ) ; 
 + if ( counter . live ( ) > = liveCount ) 
 + break ; 
 + 
 + copy . addColumn ( c ) ; 
 } 
 return copy ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 index 57fb05b . . e3b0cf8 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 @ @ - 91 , 6 + 91 , 11 @ @ public class RangeNamesQueryPager extends AbstractQueryPager 
 return false ; 
 } 
 
 + protected boolean isReversed ( ) 
 + { 
 + return false ; 
 + } 
 + 
 private AbstractBounds < RowPosition > makeExcludingKeyBounds ( RowPosition lastReturnedKey ) 
 { 
 / / We return a range that always exclude lastReturnedKey , since we ' ve already 
 diff - - git a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 index 42a9585 . . 1f4ba78 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 @ @ - 91 , 16 + 91 , 21 @ @ public class RangeSliceQueryPager extends AbstractQueryPager 
 { 
 return lastReturnedKey ! = null 
 & & lastReturnedKey . equals ( first . key ) 
 - & & lastReturnedName . equals ( firstName ( first . cf ) ) ; 
 + & & lastReturnedName . equals ( isReversed ( ) ? lastName ( first . cf ) : firstName ( first . cf ) ) ; 
 } 
 
 protected boolean recordLast ( Row last ) 
 { 
 lastReturnedKey = last . key ; 
 - lastReturnedName = lastName ( last . cf ) ; 
 + lastReturnedName = isReversed ( ) ? firstName ( last . cf ) : lastName ( last . cf ) ; 
 return true ; 
 } 
 
 + protected boolean isReversed ( ) 
 + { 
 + return ( ( SliceQueryFilter ) command . predicate ) . reversed ; 
 + } 
 + 
 private AbstractBounds < RowPosition > makeIncludingKeyBounds ( RowPosition lastReturnedKey ) 
 { 
 / / We always include lastReturnedKey since we may still be paging within a row , 
 diff - - git a / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java 
 index 1d77144 . . e3825a9 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / SliceQueryPager . java 
 @ @ - 76 , 12 + 76 , 17 @ @ public class SliceQueryPager extends AbstractQueryPager implements SinglePartiti 
 
 protected boolean containsPreviousLast ( Row first ) 
 { 
 - return lastReturned ! = null & & lastReturned . equals ( firstName ( first . cf ) ) ; 
 + return lastReturned ! = null & & lastReturned . equals ( isReversed ( ) ? lastName ( first . cf ) : firstName ( first . cf ) ) ; 
 } 
 
 protected boolean recordLast ( Row last ) 
 { 
 - lastReturned = lastName ( last . cf ) ; 
 + lastReturned = isReversed ( ) ? firstName ( last . cf ) : lastName ( last . cf ) ; 
 return true ; 
 } 
 + 
 + protected boolean isReversed ( ) 
 + { 
 + return command . filter . reversed ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / service / QueryPagerTest . java b / test / unit / org / apache / cassandra / service / QueryPagerTest . java 
 index 3fc2ac2 . . f395cf4 100644 
 - - - a / test / unit / org / apache / cassandra / service / QueryPagerTest . java 
 + + + b / test / unit / org / apache / cassandra / service / QueryPagerTest . java 
 @ @ - 117 , 7 + 117 , 12 @ @ public class QueryPagerTest extends SchemaLoader 
 
 private static ReadCommand sliceQuery ( String key , String start , String end , int count ) 
 { 
 - SliceQueryFilter filter = new SliceQueryFilter ( bytes ( start ) , bytes ( end ) , false , count ) ; 
 + return sliceQuery ( key , start , end , false , count ) ; 
 + } 
 + 
 + private static ReadCommand sliceQuery ( String key , String start , String end , boolean reversed , int count ) 
 + { 
 + SliceQueryFilter filter = new SliceQueryFilter ( bytes ( start ) , bytes ( end ) , reversed , count ) ; 
 / / Note : for MultiQueryTest , we need the same timestamp / expireBefore for all queries , so we just use 0 as it doesn ' t matter here . 
 return new SliceFromReadCommand ( KS , bytes ( key ) , CF , 0 , filter ) ; 
 } 
 @ @ - 188 , 6 + 193 , 31 @ @ public class QueryPagerTest extends SchemaLoader 
 } 
 
 @ Test 
 + public void reversedSliceQueryTest ( ) throws Exception 
 + { 
 + QueryPager pager = QueryPagers . localPager ( sliceQuery ( " k0 " , " c8 " , " c1 " , true , 10 ) ) ; 
 + 
 + List < Row > page ; 
 + 
 + assertFalse ( pager . isExhausted ( ) ) ; 
 + page = pager . fetchPage ( 3 ) ; 
 + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; 
 + assertRow ( page . get ( 0 ) , " k0 " , " c6 " , " c7 " , " c8 " ) ; 
 + 
 + assertFalse ( pager . isExhausted ( ) ) ; 
 + page = pager . fetchPage ( 3 ) ; 
 + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; 
 + assertRow ( page . get ( 0 ) , " k0 " , " c3 " , " c4 " , " c5 " ) ; 
 + 
 + assertFalse ( pager . isExhausted ( ) ) ; 
 + page = pager . fetchPage ( 3 ) ; 
 + assertEquals ( toString ( page ) , 1 , page . size ( ) ) ; 
 + assertRow ( page . get ( 0 ) , " k0 " , " c1 " , " c2 " ) ; 
 + 
 + assertTrue ( pager . isExhausted ( ) ) ; 
 + } 
 + 
 + @ Test 
 public void MultiQueryTest ( ) throws Exception 
 { 
 QueryPager pager = QueryPagers . localPager ( new Pageable . ReadCommands ( new ArrayList < ReadCommand > ( ) { {
