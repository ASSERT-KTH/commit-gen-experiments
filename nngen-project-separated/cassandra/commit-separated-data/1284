BLEU SCORE: 0.2259005009024612

TEST MSG: Simplify MultiCBuilder implementation
GENERATED MSG: add uncommitted files

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / MultiCBuilder . java b / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> index ab1c94d . . be654fa 100644 <nl> - - - a / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> + + + b / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> @ @ - 26 , 101 + 26 , 64 @ @ import org . apache . cassandra . utils . btree . BTreeSet ; <nl> / * * <nl> * Builder that allow to build multiple Clustering / Slice . Bound at the same time . <nl> * / <nl> - public abstract class MultiCBuilder <nl> + public class MultiCBuilder <nl> { <nl> / * * <nl> - * Creates a new empty { @ code MultiCBuilder } . <nl> + * The table comparator . <nl> * / <nl> - public static MultiCBuilder create ( ClusteringComparator comparator ) <nl> - { <nl> - return new ConcreteMultiCBuilder ( comparator ) ; <nl> - } <nl> + private final ClusteringComparator comparator ; <nl> <nl> / * * <nl> - * Wraps an existing { @ code CBuilder } to provide him with a MultiCBuilder interface <nl> - * for the sake of passing it to { @ link Restriction . appendTo } . The resulting <nl> - * { @ code MultiCBuilder } will still only be able to create a single clustering / bound <nl> - * and an { @ code IllegalArgumentException } will be thrown if elements that added that <nl> - * would correspond to building multiple clusterings . <nl> + * The elements of the clusterings <nl> * / <nl> - public static MultiCBuilder wrap ( final CBuilder builder ) <nl> - { <nl> - return new MultiCBuilder ( ) <nl> - { <nl> - private boolean containsNull ; <nl> - private boolean containsUnset ; <nl> - private boolean hasMissingElements ; <nl> - <nl> - public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> - { <nl> - builder . add ( value ) ; <nl> - <nl> - if ( value = = null ) <nl> - containsNull = true ; <nl> - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> - containsUnset = true ; <nl> - <nl> - return this ; <nl> - } <nl> - <nl> - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> - { <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - return this ; <nl> - } <nl> + private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; <nl> <nl> - if ( values . size ( ) > 1 ) <nl> - throw new IllegalArgumentException ( ) ; <nl> - <nl> - return addElementToAll ( values . get ( 0 ) ) ; <nl> - } <nl> - <nl> - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> - { <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - return this ; <nl> - } <nl> - <nl> - if ( values . size ( ) > 1 ) <nl> - throw new IllegalArgumentException ( ) ; <nl> + / * * <nl> + * The number of elements that have been added . <nl> + * / <nl> + private int size ; <nl> <nl> - return addEachElementToAll ( values . get ( 0 ) ) ; <nl> - } <nl> + / * * <nl> + * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . <nl> + * / <nl> + private boolean built ; <nl> <nl> - public int remainingCount ( ) <nl> - { <nl> - return builder . remainingCount ( ) ; <nl> - } <nl> + / * * <nl> + * < code > true < / code > if the clusterings contains some < code > null < / code > elements . <nl> + * / <nl> + private boolean containsNull ; <nl> <nl> - public boolean containsNull ( ) <nl> - { <nl> - return containsNull ; <nl> - } <nl> + / * * <nl> + * < code > true < / code > if the composites contains some < code > unset < / code > elements . <nl> + * / <nl> + private boolean containsUnset ; <nl> <nl> - public boolean containsUnset ( ) <nl> - { <nl> - return containsUnset ; <nl> - } <nl> + / * * <nl> + * < code > true < / code > if some empty collection have been added . <nl> + * / <nl> + private boolean hasMissingElements ; <nl> <nl> - public boolean hasMissingElements ( ) <nl> - { <nl> - return hasMissingElements ; <nl> - } <nl> + private MultiCBuilder ( ClusteringComparator comparator ) <nl> + { <nl> + this . comparator = comparator ; <nl> + } <nl> <nl> - public NavigableSet < Clustering > build ( ) <nl> - { <nl> - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; <nl> - } <nl> + / * * <nl> + * Creates a new empty { @ code MultiCBuilder } . <nl> + * / <nl> + public static MultiCBuilder create ( ClusteringComparator comparator ) <nl> + { <nl> + return new MultiCBuilder ( comparator ) ; <nl> + } <nl> <nl> - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> - { <nl> - return BTreeSet . of ( builder . comparator ( ) , builder . buildBound ( isStart , isInclusive ) ) ; <nl> - } <nl> - } ; <nl> + / * * <nl> + * Checks if this builder is empty . <nl> + * <nl> + * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . <nl> + * / <nl> + private boolean isEmpty ( ) <nl> + { <nl> + return elementsList . isEmpty ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 133 , 7 + 96 , 25 @ @ public abstract class MultiCBuilder <nl> * @ param value the value of the next element <nl> * @ return this < code > MulitCBuilder < / code > <nl> * / <nl> - public abstract MultiCBuilder addElementToAll ( ByteBuffer value ) ; <nl> + public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + if ( value = = null ) <nl> + containsNull = true ; <nl> + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> + containsUnset = true ; <nl> + <nl> + elementsList . get ( i ) . add ( value ) ; <nl> + } <nl> + size + + ; <nl> + return this ; <nl> + } <nl> <nl> / * * <nl> * Adds individually each of the specified elements to the end of all of the existing clusterings . <nl> @ @ - 145 , 7 + 126 , 42 @ @ public abstract class MultiCBuilder <nl> * @ param values the elements to add <nl> * @ return this < code > CompositeBuilder < / code > <nl> * / <nl> - public abstract MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) ; <nl> + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> + <nl> + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> + { <nl> + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> + elementsList . add ( newComposite ) ; <nl> + <nl> + ByteBuffer value = values . get ( j ) ; <nl> + <nl> + if ( value = = null ) <nl> + containsNull = true ; <nl> + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> + containsUnset = true ; <nl> + <nl> + newComposite . add ( values . get ( j ) ) ; <nl> + } <nl> + } <nl> + } <nl> + size + + ; <nl> + return this ; <nl> + } <nl> <nl> / * * <nl> * Adds individually each of the specified list of elements to the end of all of the existing composites . <nl> @ @ - 157 , 48 + 173 , 138 @ @ public abstract class MultiCBuilder <nl> * @ param values the elements to add <nl> * @ return this < code > CompositeBuilder < / code > <nl> * / <nl> - public abstract MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) ; <nl> + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> + <nl> + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> + { <nl> + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> + elementsList . add ( newComposite ) ; <nl> + <nl> + List < ByteBuffer > value = values . get ( j ) ; <nl> + <nl> + if ( value . isEmpty ( ) ) <nl> + hasMissingElements = true ; <nl> + <nl> + if ( value . contains ( null ) ) <nl> + containsNull = true ; <nl> + if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) <nl> + containsUnset = true ; <nl> + <nl> + newComposite . addAll ( value ) ; <nl> + } <nl> + } <nl> + size + = values . get ( 0 ) . size ( ) ; <nl> + } <nl> + return this ; <nl> + } <nl> <nl> / * * <nl> * Returns the number of elements that can be added to the clusterings . <nl> * <nl> * @ return the number of elements that can be added to the clusterings . <nl> * / <nl> - public abstract int remainingCount ( ) ; <nl> + public int remainingCount ( ) <nl> + { <nl> + return comparator . size ( ) - size ; <nl> + } <nl> <nl> / * * <nl> * Checks if the clusterings contains null elements . <nl> * <nl> * @ return < code > true < / code > if the clusterings contains < code > null < / code > elements , < code > false < / code > otherwise . <nl> * / <nl> - public abstract boolean containsNull ( ) ; <nl> + public boolean containsNull ( ) <nl> + { <nl> + return containsNull ; <nl> + } <nl> <nl> / * * <nl> * Checks if the clusterings contains unset elements . <nl> * <nl> * @ return < code > true < / code > if the clusterings contains < code > unset < / code > elements , < code > false < / code > otherwise . <nl> * / <nl> - public abstract boolean containsUnset ( ) ; <nl> + public boolean containsUnset ( ) <nl> + { <nl> + return containsUnset ; <nl> + } <nl> <nl> / * * <nl> * Checks if some empty list of values have been added <nl> * @ return < code > true < / code > if the clusterings have some missing elements , < code > false < / code > otherwise . <nl> * / <nl> - public abstract boolean hasMissingElements ( ) ; <nl> + public boolean hasMissingElements ( ) <nl> + { <nl> + return hasMissingElements ; <nl> + } <nl> <nl> / * * <nl> * Builds the < code > clusterings < / code > . <nl> * <nl> * @ return the clusterings <nl> * / <nl> - public abstract NavigableSet < Clustering > build ( ) ; <nl> + public NavigableSet < Clustering > build ( ) <nl> + { <nl> + built = true ; <nl> + <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> + <nl> + CBuilder builder = CBuilder . create ( comparator ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; <nl> + <nl> + BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> + set . add ( builder . buildWith ( elements ) ) ; <nl> + } <nl> + return set . build ( ) ; <nl> + } <nl> <nl> / * * <nl> * Builds the < code > clusterings < / code > with the specified EOC . <nl> * <nl> * @ return the clusterings <nl> * / <nl> - public abstract NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) ; <nl> + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> + { <nl> + built = true ; <nl> + <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> + <nl> + CBuilder builder = CBuilder . create ( comparator ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; <nl> + <nl> + / / Use a TreeSet to sort and eliminate duplicates <nl> + BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; <nl> + <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> + set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; <nl> + } <nl> + return set . build ( ) ; <nl> + } <nl> <nl> / * * <nl> * Checks if some elements can still be added to the clusterings . <nl> @ @ - 210 , 224 + 316 , 9 @ @ public abstract class MultiCBuilder <nl> return remainingCount ( ) > 0 ; <nl> } <nl> <nl> - <nl> - private static class ConcreteMultiCBuilder extends MultiCBuilder <nl> + private void checkUpdateable ( ) <nl> { <nl> - / * * <nl> - * The table comparator . <nl> - * / <nl> - private final ClusteringComparator comparator ; <nl> - <nl> - / * * <nl> - * The elements of the clusterings <nl> - * / <nl> - private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; <nl> - <nl> - / * * <nl> - * The number of elements that have been added . <nl> - * / <nl> - private int size ; <nl> - <nl> - / * * <nl> - * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . <nl> - * / <nl> - private boolean built ; <nl> - <nl> - / * * <nl> - * < code > true < / code > if the clusterings contains some < code > null < / code > elements . <nl> - * / <nl> - private boolean containsNull ; <nl> - <nl> - / * * <nl> - * < code > true < / code > if the composites contains some < code > unset < / code > elements . <nl> - * / <nl> - private boolean containsUnset ; <nl> - <nl> - / * * <nl> - * < code > true < / code > if some empty collection have been added . <nl> - * / <nl> - private boolean hasMissingElements ; <nl> - <nl> - public ConcreteMultiCBuilder ( ClusteringComparator comparator ) <nl> - { <nl> - this . comparator = comparator ; <nl> - } <nl> - <nl> - public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - if ( value = = null ) <nl> - containsNull = true ; <nl> - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> - containsUnset = true ; <nl> - <nl> - elementsList . get ( i ) . add ( value ) ; <nl> - } <nl> - size + + ; <nl> - return this ; <nl> - } <nl> - <nl> - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> - <nl> - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> - { <nl> - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> - elementsList . add ( newComposite ) ; <nl> - <nl> - ByteBuffer value = values . get ( j ) ; <nl> - <nl> - if ( value = = null ) <nl> - containsNull = true ; <nl> - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> - containsUnset = true ; <nl> - <nl> - newComposite . add ( values . get ( j ) ) ; <nl> - } <nl> - } <nl> - } <nl> - size + + ; <nl> - return this ; <nl> - } <nl> - <nl> - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> - <nl> - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> - { <nl> - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> - elementsList . add ( newComposite ) ; <nl> - <nl> - List < ByteBuffer > value = values . get ( j ) ; <nl> - <nl> - if ( value . isEmpty ( ) ) <nl> - hasMissingElements = true ; <nl> - <nl> - if ( value . contains ( null ) ) <nl> - containsNull = true ; <nl> - if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) <nl> - containsUnset = true ; <nl> - <nl> - newComposite . addAll ( value ) ; <nl> - } <nl> - } <nl> - size + = values . get ( 0 ) . size ( ) ; <nl> - } <nl> - return this ; <nl> - } <nl> - <nl> - public int remainingCount ( ) <nl> - { <nl> - return comparator . size ( ) - size ; <nl> - } <nl> - <nl> - / * * <nl> - * Checks if this builder is empty . <nl> - * <nl> - * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . <nl> - * / <nl> - public boolean isEmpty ( ) <nl> - { <nl> - return elementsList . isEmpty ( ) ; <nl> - } <nl> - <nl> - public boolean containsNull ( ) <nl> - { <nl> - return containsNull ; <nl> - } <nl> - <nl> - public boolean containsUnset ( ) <nl> - { <nl> - return containsUnset ; <nl> - } <nl> - <nl> - public boolean hasMissingElements ( ) <nl> - { <nl> - return hasMissingElements ; <nl> - } <nl> - <nl> - public NavigableSet < Clustering > build ( ) <nl> - { <nl> - built = true ; <nl> - <nl> - if ( hasMissingElements ) <nl> - return BTreeSet . empty ( comparator ) ; <nl> - <nl> - CBuilder builder = CBuilder . create ( comparator ) ; <nl> - <nl> - if ( elementsList . isEmpty ( ) ) <nl> - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; <nl> - <nl> - BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> - set . add ( builder . buildWith ( elements ) ) ; <nl> - } <nl> - return set . build ( ) ; <nl> - } <nl> - <nl> - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> - { <nl> - built = true ; <nl> - <nl> - if ( hasMissingElements ) <nl> - return BTreeSet . empty ( comparator ) ; <nl> - <nl> - CBuilder builder = CBuilder . create ( comparator ) ; <nl> - <nl> - if ( elementsList . isEmpty ( ) ) <nl> - return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; <nl> - <nl> - / / Use a TreeSet to sort and eliminate duplicates <nl> - BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; <nl> - <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> - set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; <nl> - } <nl> - return set . build ( ) ; <nl> - } <nl> - <nl> - private void checkUpdateable ( ) <nl> - { <nl> - if ( ! hasRemaining ( ) | | built ) <nl> - throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; <nl> - } <nl> + if ( ! hasRemaining ( ) | | built ) <nl> + throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index 28d116f . . 80c9f36 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 489 , 16 + 489 , 7 @ @ public class Table <nl> ByteBuffer name = iter . next ( ) ; <nl> IColumn newColumn = cf . getColumn ( name ) ; / / null = = row delete or it wouldn ' t be marked Mutated <nl> if ( newColumn ! = null & & cf . isMarkedForDelete ( ) ) <nl> - { <nl> - / / row is marked for delete , but column was also updated . if column is timestamped less than <nl> - / / the row tombstone , treat it as if it didn ' t exist . Otherwise we don ' t care about row <nl> - / / tombstone for the purpose of the index update and we can proceed as usual . <nl> - if ( newColumn . timestamp ( ) < = cf . getMarkedForDeleteAt ( ) ) <nl> - { <nl> - / / don ' t remove from the cf object ; that can race w / CommitLog write . Leaving it is harmless . <nl> - newColumn = null ; <nl> - } <nl> - } <nl> + throw new UnsupportedOperationException ( " Index manager cannot support deleting and inserting into a row in the same mutation " ) ; <nl> IColumn oldColumn = oldIndexedColumns . getColumn ( name ) ; <nl> <nl> / / deletions are irrelevant to the index unless we ' re changing state from live - > deleted , i . e . ,

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / MultiCBuilder . java b / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 index ab1c94d . . be654fa 100644 
 - - - a / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 + + + b / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 @ @ - 26 , 101 + 26 , 64 @ @ import org . apache . cassandra . utils . btree . BTreeSet ; 
 / * * 
 * Builder that allow to build multiple Clustering / Slice . Bound at the same time . 
 * / 
 - public abstract class MultiCBuilder 
 + public class MultiCBuilder 
 { 
 / * * 
 - * Creates a new empty { @ code MultiCBuilder } . 
 + * The table comparator . 
 * / 
 - public static MultiCBuilder create ( ClusteringComparator comparator ) 
 - { 
 - return new ConcreteMultiCBuilder ( comparator ) ; 
 - } 
 + private final ClusteringComparator comparator ; 
 
 / * * 
 - * Wraps an existing { @ code CBuilder } to provide him with a MultiCBuilder interface 
 - * for the sake of passing it to { @ link Restriction . appendTo } . The resulting 
 - * { @ code MultiCBuilder } will still only be able to create a single clustering / bound 
 - * and an { @ code IllegalArgumentException } will be thrown if elements that added that 
 - * would correspond to building multiple clusterings . 
 + * The elements of the clusterings 
 * / 
 - public static MultiCBuilder wrap ( final CBuilder builder ) 
 - { 
 - return new MultiCBuilder ( ) 
 - { 
 - private boolean containsNull ; 
 - private boolean containsUnset ; 
 - private boolean hasMissingElements ; 
 - 
 - public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 - { 
 - builder . add ( value ) ; 
 - 
 - if ( value = = null ) 
 - containsNull = true ; 
 - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 - containsUnset = true ; 
 - 
 - return this ; 
 - } 
 - 
 - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 - { 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - return this ; 
 - } 
 + private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; 
 
 - if ( values . size ( ) > 1 ) 
 - throw new IllegalArgumentException ( ) ; 
 - 
 - return addElementToAll ( values . get ( 0 ) ) ; 
 - } 
 - 
 - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 - { 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - return this ; 
 - } 
 - 
 - if ( values . size ( ) > 1 ) 
 - throw new IllegalArgumentException ( ) ; 
 + / * * 
 + * The number of elements that have been added . 
 + * / 
 + private int size ; 
 
 - return addEachElementToAll ( values . get ( 0 ) ) ; 
 - } 
 + / * * 
 + * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . 
 + * / 
 + private boolean built ; 
 
 - public int remainingCount ( ) 
 - { 
 - return builder . remainingCount ( ) ; 
 - } 
 + / * * 
 + * < code > true < / code > if the clusterings contains some < code > null < / code > elements . 
 + * / 
 + private boolean containsNull ; 
 
 - public boolean containsNull ( ) 
 - { 
 - return containsNull ; 
 - } 
 + / * * 
 + * < code > true < / code > if the composites contains some < code > unset < / code > elements . 
 + * / 
 + private boolean containsUnset ; 
 
 - public boolean containsUnset ( ) 
 - { 
 - return containsUnset ; 
 - } 
 + / * * 
 + * < code > true < / code > if some empty collection have been added . 
 + * / 
 + private boolean hasMissingElements ; 
 
 - public boolean hasMissingElements ( ) 
 - { 
 - return hasMissingElements ; 
 - } 
 + private MultiCBuilder ( ClusteringComparator comparator ) 
 + { 
 + this . comparator = comparator ; 
 + } 
 
 - public NavigableSet < Clustering > build ( ) 
 - { 
 - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; 
 - } 
 + / * * 
 + * Creates a new empty { @ code MultiCBuilder } . 
 + * / 
 + public static MultiCBuilder create ( ClusteringComparator comparator ) 
 + { 
 + return new MultiCBuilder ( comparator ) ; 
 + } 
 
 - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 - { 
 - return BTreeSet . of ( builder . comparator ( ) , builder . buildBound ( isStart , isInclusive ) ) ; 
 - } 
 - } ; 
 + / * * 
 + * Checks if this builder is empty . 
 + * 
 + * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . 
 + * / 
 + private boolean isEmpty ( ) 
 + { 
 + return elementsList . isEmpty ( ) ; 
 } 
 
 / * * 
 @ @ - 133 , 7 + 96 , 25 @ @ public abstract class MultiCBuilder 
 * @ param value the value of the next element 
 * @ return this < code > MulitCBuilder < / code > 
 * / 
 - public abstract MultiCBuilder addElementToAll ( ByteBuffer value ) ; 
 + public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + if ( value = = null ) 
 + containsNull = true ; 
 + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 + containsUnset = true ; 
 + 
 + elementsList . get ( i ) . add ( value ) ; 
 + } 
 + size + + ; 
 + return this ; 
 + } 
 
 / * * 
 * Adds individually each of the specified elements to the end of all of the existing clusterings . 
 @ @ - 145 , 7 + 126 , 42 @ @ public abstract class MultiCBuilder 
 * @ param values the elements to add 
 * @ return this < code > CompositeBuilder < / code > 
 * / 
 - public abstract MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) ; 
 + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 + 
 + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 + { 
 + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 + elementsList . add ( newComposite ) ; 
 + 
 + ByteBuffer value = values . get ( j ) ; 
 + 
 + if ( value = = null ) 
 + containsNull = true ; 
 + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 + containsUnset = true ; 
 + 
 + newComposite . add ( values . get ( j ) ) ; 
 + } 
 + } 
 + } 
 + size + + ; 
 + return this ; 
 + } 
 
 / * * 
 * Adds individually each of the specified list of elements to the end of all of the existing composites . 
 @ @ - 157 , 48 + 173 , 138 @ @ public abstract class MultiCBuilder 
 * @ param values the elements to add 
 * @ return this < code > CompositeBuilder < / code > 
 * / 
 - public abstract MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) ; 
 + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 + 
 + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 + { 
 + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 + elementsList . add ( newComposite ) ; 
 + 
 + List < ByteBuffer > value = values . get ( j ) ; 
 + 
 + if ( value . isEmpty ( ) ) 
 + hasMissingElements = true ; 
 + 
 + if ( value . contains ( null ) ) 
 + containsNull = true ; 
 + if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) 
 + containsUnset = true ; 
 + 
 + newComposite . addAll ( value ) ; 
 + } 
 + } 
 + size + = values . get ( 0 ) . size ( ) ; 
 + } 
 + return this ; 
 + } 
 
 / * * 
 * Returns the number of elements that can be added to the clusterings . 
 * 
 * @ return the number of elements that can be added to the clusterings . 
 * / 
 - public abstract int remainingCount ( ) ; 
 + public int remainingCount ( ) 
 + { 
 + return comparator . size ( ) - size ; 
 + } 
 
 / * * 
 * Checks if the clusterings contains null elements . 
 * 
 * @ return < code > true < / code > if the clusterings contains < code > null < / code > elements , < code > false < / code > otherwise . 
 * / 
 - public abstract boolean containsNull ( ) ; 
 + public boolean containsNull ( ) 
 + { 
 + return containsNull ; 
 + } 
 
 / * * 
 * Checks if the clusterings contains unset elements . 
 * 
 * @ return < code > true < / code > if the clusterings contains < code > unset < / code > elements , < code > false < / code > otherwise . 
 * / 
 - public abstract boolean containsUnset ( ) ; 
 + public boolean containsUnset ( ) 
 + { 
 + return containsUnset ; 
 + } 
 
 / * * 
 * Checks if some empty list of values have been added 
 * @ return < code > true < / code > if the clusterings have some missing elements , < code > false < / code > otherwise . 
 * / 
 - public abstract boolean hasMissingElements ( ) ; 
 + public boolean hasMissingElements ( ) 
 + { 
 + return hasMissingElements ; 
 + } 
 
 / * * 
 * Builds the < code > clusterings < / code > . 
 * 
 * @ return the clusterings 
 * / 
 - public abstract NavigableSet < Clustering > build ( ) ; 
 + public NavigableSet < Clustering > build ( ) 
 + { 
 + built = true ; 
 + 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 + 
 + CBuilder builder = CBuilder . create ( comparator ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; 
 + 
 + BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > elements = elementsList . get ( i ) ; 
 + set . add ( builder . buildWith ( elements ) ) ; 
 + } 
 + return set . build ( ) ; 
 + } 
 
 / * * 
 * Builds the < code > clusterings < / code > with the specified EOC . 
 * 
 * @ return the clusterings 
 * / 
 - public abstract NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) ; 
 + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 + { 
 + built = true ; 
 + 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 + 
 + CBuilder builder = CBuilder . create ( comparator ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; 
 + 
 + / / Use a TreeSet to sort and eliminate duplicates 
 + BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; 
 + 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > elements = elementsList . get ( i ) ; 
 + set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; 
 + } 
 + return set . build ( ) ; 
 + } 
 
 / * * 
 * Checks if some elements can still be added to the clusterings . 
 @ @ - 210 , 224 + 316 , 9 @ @ public abstract class MultiCBuilder 
 return remainingCount ( ) > 0 ; 
 } 
 
 - 
 - private static class ConcreteMultiCBuilder extends MultiCBuilder 
 + private void checkUpdateable ( ) 
 { 
 - / * * 
 - * The table comparator . 
 - * / 
 - private final ClusteringComparator comparator ; 
 - 
 - / * * 
 - * The elements of the clusterings 
 - * / 
 - private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; 
 - 
 - / * * 
 - * The number of elements that have been added . 
 - * / 
 - private int size ; 
 - 
 - / * * 
 - * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . 
 - * / 
 - private boolean built ; 
 - 
 - / * * 
 - * < code > true < / code > if the clusterings contains some < code > null < / code > elements . 
 - * / 
 - private boolean containsNull ; 
 - 
 - / * * 
 - * < code > true < / code > if the composites contains some < code > unset < / code > elements . 
 - * / 
 - private boolean containsUnset ; 
 - 
 - / * * 
 - * < code > true < / code > if some empty collection have been added . 
 - * / 
 - private boolean hasMissingElements ; 
 - 
 - public ConcreteMultiCBuilder ( ClusteringComparator comparator ) 
 - { 
 - this . comparator = comparator ; 
 - } 
 - 
 - public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - if ( value = = null ) 
 - containsNull = true ; 
 - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 - containsUnset = true ; 
 - 
 - elementsList . get ( i ) . add ( value ) ; 
 - } 
 - size + + ; 
 - return this ; 
 - } 
 - 
 - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 - 
 - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 - { 
 - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 - elementsList . add ( newComposite ) ; 
 - 
 - ByteBuffer value = values . get ( j ) ; 
 - 
 - if ( value = = null ) 
 - containsNull = true ; 
 - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 - containsUnset = true ; 
 - 
 - newComposite . add ( values . get ( j ) ) ; 
 - } 
 - } 
 - } 
 - size + + ; 
 - return this ; 
 - } 
 - 
 - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 - 
 - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 - { 
 - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 - elementsList . add ( newComposite ) ; 
 - 
 - List < ByteBuffer > value = values . get ( j ) ; 
 - 
 - if ( value . isEmpty ( ) ) 
 - hasMissingElements = true ; 
 - 
 - if ( value . contains ( null ) ) 
 - containsNull = true ; 
 - if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) 
 - containsUnset = true ; 
 - 
 - newComposite . addAll ( value ) ; 
 - } 
 - } 
 - size + = values . get ( 0 ) . size ( ) ; 
 - } 
 - return this ; 
 - } 
 - 
 - public int remainingCount ( ) 
 - { 
 - return comparator . size ( ) - size ; 
 - } 
 - 
 - / * * 
 - * Checks if this builder is empty . 
 - * 
 - * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . 
 - * / 
 - public boolean isEmpty ( ) 
 - { 
 - return elementsList . isEmpty ( ) ; 
 - } 
 - 
 - public boolean containsNull ( ) 
 - { 
 - return containsNull ; 
 - } 
 - 
 - public boolean containsUnset ( ) 
 - { 
 - return containsUnset ; 
 - } 
 - 
 - public boolean hasMissingElements ( ) 
 - { 
 - return hasMissingElements ; 
 - } 
 - 
 - public NavigableSet < Clustering > build ( ) 
 - { 
 - built = true ; 
 - 
 - if ( hasMissingElements ) 
 - return BTreeSet . empty ( comparator ) ; 
 - 
 - CBuilder builder = CBuilder . create ( comparator ) ; 
 - 
 - if ( elementsList . isEmpty ( ) ) 
 - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; 
 - 
 - BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > elements = elementsList . get ( i ) ; 
 - set . add ( builder . buildWith ( elements ) ) ; 
 - } 
 - return set . build ( ) ; 
 - } 
 - 
 - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 - { 
 - built = true ; 
 - 
 - if ( hasMissingElements ) 
 - return BTreeSet . empty ( comparator ) ; 
 - 
 - CBuilder builder = CBuilder . create ( comparator ) ; 
 - 
 - if ( elementsList . isEmpty ( ) ) 
 - return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; 
 - 
 - / / Use a TreeSet to sort and eliminate duplicates 
 - BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; 
 - 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > elements = elementsList . get ( i ) ; 
 - set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; 
 - } 
 - return set . build ( ) ; 
 - } 
 - 
 - private void checkUpdateable ( ) 
 - { 
 - if ( ! hasRemaining ( ) | | built ) 
 - throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; 
 - } 
 + if ( ! hasRemaining ( ) | | built ) 
 + throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index 28d116f . . 80c9f36 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 489 , 16 + 489 , 7 @ @ public class Table 
 ByteBuffer name = iter . next ( ) ; 
 IColumn newColumn = cf . getColumn ( name ) ; / / null = = row delete or it wouldn ' t be marked Mutated 
 if ( newColumn ! = null & & cf . isMarkedForDelete ( ) ) 
 - { 
 - / / row is marked for delete , but column was also updated . if column is timestamped less than 
 - / / the row tombstone , treat it as if it didn ' t exist . Otherwise we don ' t care about row 
 - / / tombstone for the purpose of the index update and we can proceed as usual . 
 - if ( newColumn . timestamp ( ) < = cf . getMarkedForDeleteAt ( ) ) 
 - { 
 - / / don ' t remove from the cf object ; that can race w / CommitLog write . Leaving it is harmless . 
 - newColumn = null ; 
 - } 
 - } 
 + throw new UnsupportedOperationException ( " Index manager cannot support deleting and inserting into a row in the same mutation " ) ; 
 IColumn oldColumn = oldIndexedColumns . getColumn ( name ) ; 
 
 / / deletions are irrelevant to the index unless we ' re changing state from live - > deleted , i . e . ,
