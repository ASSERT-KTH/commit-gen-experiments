BLEU SCORE: 0.016932492841722675

TEST MSG: Don ' t delete incremental repair sessions if they still have sstables
GENERATED MSG: Fix error when dropping table during compaction

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e015a0b . . a02a7bf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Don ' t delete incremental repair sessions if they still have sstables ( CASSANDRA - 13758 ) <nl> * Fix pending repair manager index out of bounds check ( CASSANDRA - 13769 ) <nl> * Don ' t use RangeFetchMapCalculator when RF = 1 ( CASSANDRA - 13576 ) <nl> * Don ' t optimise trivial ranges in RangeFetchMapCalculator ( CASSANDRA - 13664 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> index 6342a1b . . 3b1bc41 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> @ @ - 339 , 6 + 339 , 11 @ @ public class CompactionStrategyManager implements INotificationConsumer <nl> return ids ; <nl> } <nl> <nl> + public boolean hasDataForPendingRepair ( UUID sessionID ) <nl> + { <nl> + return Iterables . any ( pendingRepairs , prm - > prm . hasDataForSession ( sessionID ) ) ; <nl> + } <nl> + <nl> public void shutdown ( ) <nl> { <nl> writeLock . lock ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> index 4596381 . . 8ee6025 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java <nl> @ @ - 398 , 6 + 398 , 11 @ @ class PendingRepairManager <nl> return strategies . values ( ) . contains ( strategy ) ; <nl> } <nl> <nl> + public synchronized boolean hasDataForSession ( UUID sessionID ) <nl> + { <nl> + return strategies . keySet ( ) . contains ( sessionID ) ; <nl> + } <nl> + <nl> public Collection < AbstractCompactionTask > createUserDefinedTasks ( List < SSTableReader > sstables , int gcBefore ) <nl> { <nl> Map < UUID , List < SSTableReader > > group = sstables . stream ( ) . collect ( Collectors . groupingBy ( s - > s . getSSTableMetadata ( ) . pendingRepair ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> index a25f65c . . 4ef2c2c 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> + + + b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java <nl> @ @ - 32 , 7 + 32 , 7 @ @ import java . util . UUID ; <nl> import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Executors ; <nl> import java . util . concurrent . TimeUnit ; <nl> - <nl> + import java . util . function . Predicate ; <nl> import javax . annotation . Nullable ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> @ @ - 45 , 18 + 45 , 15 @ @ import com . google . common . primitives . Ints ; <nl> import com . google . common . util . concurrent . FutureCallback ; <nl> import com . google . common . util . concurrent . Futures ; <nl> import com . google . common . util . concurrent . ListenableFuture ; <nl> - <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . db . ColumnFamilyStore ; <nl> - import org . apache . cassandra . db . compaction . CompactionManager ; <nl> - import org . apache . cassandra . schema . Schema ; <nl> - import org . apache . cassandra . schema . SchemaConstants ; <nl> import org . apache . cassandra . cql3 . QueryProcessor ; <nl> import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . SystemKeyspace ; <nl> + import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . marshal . BytesType ; <nl> import org . apache . cassandra . db . marshal . InetAddressType ; <nl> import org . apache . cassandra . db . marshal . UUIDType ; <nl> @ @ - 77 , 6 + 74 , 8 @ @ import org . apache . cassandra . repair . messages . PrepareConsistentResponse ; <nl> import org . apache . cassandra . repair . messages . RepairMessage ; <nl> import org . apache . cassandra . repair . messages . StatusRequest ; <nl> import org . apache . cassandra . repair . messages . StatusResponse ; <nl> + import org . apache . cassandra . schema . Schema ; <nl> + import org . apache . cassandra . schema . SchemaConstants ; <nl> import org . apache . cassandra . schema . TableId ; <nl> import org . apache . cassandra . service . ActiveRepairService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> @ @ - 260 , 8 + 259 , 15 @ @ public class LocalSessions <nl> } <nl> else if ( shouldDelete ( session , now ) ) <nl> { <nl> - logger . debug ( " Auto deleting repair session { } " , session ) ; <nl> - deleteSession ( session . sessionID ) ; <nl> + if ( ! sessionHasData ( session ) ) <nl> + { <nl> + logger . debug ( " Auto deleting repair session { } " , session ) ; <nl> + deleteSession ( session . sessionID ) ; <nl> + } <nl> + else <nl> + { <nl> + logger . warn ( " Skipping delete of LocalSession { } because it still contains sstables " , session . sessionID ) ; <nl> + } <nl> } <nl> else if ( shouldCheckStatus ( session , now ) ) <nl> { <nl> @ @ - 737 , 6 + 743 , 17 @ @ public class LocalSessions <nl> return session ! = null & & session . getState ( ) ! = FINALIZED & & session . getState ( ) ! = FAILED ; <nl> } <nl> <nl> + @ VisibleForTesting <nl> + protected boolean sessionHasData ( LocalSession session ) <nl> + { <nl> + Predicate < TableId > predicate = tid - > { <nl> + ColumnFamilyStore cfs = Schema . instance . getColumnFamilyStoreInstance ( tid ) ; <nl> + return cfs ! = null & & cfs . getCompactionStrategyManager ( ) . hasDataForPendingRepair ( session . sessionID ) ; <nl> + <nl> + } ; <nl> + return Iterables . any ( session . tableIds , predicate : : test ) ; <nl> + } <nl> + <nl> / * * <nl> * Returns the repairedAt time for a sessions which is unknown , failed , or finalized <nl> * calling this for a session which is in progress throws an exception <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> index 33e996b . . 2b88c9c 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java <nl> @ @ - 285 , 4 + 285 , 19 @ @ public class PendingRepairManagerTest extends AbstractPendingRepairTest <nl> SSTableReader sstable = makeSSTable ( true ) ; <nl> prm . getOrCreate ( sstable ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void sessionHasData ( ) <nl> + { <nl> + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; <nl> + <nl> + UUID repairID = registerSession ( cfs , true , true ) ; <nl> + LocalSessionAccessor . prepareUnsafe ( repairID , COORDINATOR , PARTICIPANTS ) ; <nl> + <nl> + Assert . assertFalse ( prm . hasDataForSession ( repairID ) ) ; <nl> + SSTableReader sstable = makeSSTable ( true ) ; <nl> + mutateRepaired ( sstable , repairID ) ; <nl> + prm . addSSTable ( sstable ) ; <nl> + Assert . assertTrue ( prm . hasDataForSession ( repairID ) ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java b / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java <nl> index c59462e . . be048fb 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java <nl> @ @ - 182 , 6 + 182 , 12 @ @ public class LocalSessionTest extends AbstractRepairTest <nl> int calls = completedSessions . getOrDefault ( sessionID , 0 ) ; <nl> completedSessions . put ( sessionID , calls + 1 ) ; <nl> } <nl> + <nl> + boolean sessionHasData = false ; <nl> + protected boolean sessionHasData ( LocalSession session ) <nl> + { <nl> + return sessionHasData ; <nl> + } <nl> } <nl> <nl> private static TableMetadata cfm ; <nl> @ @ - 865 , 10 + 871 , 10 @ @ public class LocalSessionTest extends AbstractRepairTest <nl> } <nl> <nl> / * * <nl> - * Sessions past the auto delete cutoff should be deleted <nl> + * Sessions past the auto delete cutoff with no sstables should be deleted <nl> * / <nl> @ Test <nl> - public void cleanupDelete ( ) throws Exception <nl> + public void cleanupDeleteNoSSTables ( ) throws Exception <nl> { <nl> LocalSessions sessions = new InstrumentedLocalSessions ( ) ; <nl> sessions . start ( ) ; <nl> @ @ - 895 , 6 + 901 , 37 @ @ public class LocalSessionTest extends AbstractRepairTest <nl> } <nl> <nl> / * * <nl> + * Sessions past the auto delete cutoff with no sstables should be deleted <nl> + * / <nl> + @ Test <nl> + public void cleanupDeleteSSTablesRemaining ( ) throws Exception <nl> + { <nl> + InstrumentedLocalSessions sessions = new InstrumentedLocalSessions ( ) ; <nl> + sessions . start ( ) ; <nl> + <nl> + int time = FBUtilities . nowInSeconds ( ) - LocalSessions . AUTO _ FAIL _ TIMEOUT - 1 ; <nl> + LocalSession failed = sessionWithTime ( time - 1 , time ) ; <nl> + failed . setState ( FAILED ) ; <nl> + <nl> + LocalSession finalized = sessionWithTime ( time - 1 , time ) ; <nl> + finalized . setState ( FINALIZED ) ; <nl> + <nl> + sessions . putSessionUnsafe ( failed ) ; <nl> + sessions . putSessionUnsafe ( finalized ) ; <nl> + Assert . assertNotNull ( sessions . getSession ( failed . sessionID ) ) ; <nl> + Assert . assertNotNull ( sessions . getSession ( finalized . sessionID ) ) ; <nl> + <nl> + sessions . sessionHasData = true ; <nl> + sessions . cleanup ( ) ; <nl> + <nl> + Assert . assertNotNull ( sessions . getSession ( failed . sessionID ) ) ; <nl> + Assert . assertNotNull ( sessions . getSession ( finalized . sessionID ) ) ; <nl> + <nl> + Assert . assertNotNull ( sessions . loadUnsafe ( failed . sessionID ) ) ; <nl> + Assert . assertNotNull ( sessions . loadUnsafe ( finalized . sessionID ) ) ; <nl> + } <nl> + <nl> + / * * <nl> * Sessions should start checking the status of their participants if <nl> * there hasn ' t been activity for the CHECK _ STATUS _ TIMEOUT period <nl> * /
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e015a0b . . a02a7bf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Don ' t delete incremental repair sessions if they still have sstables ( CASSANDRA - 13758 ) 
 * Fix pending repair manager index out of bounds check ( CASSANDRA - 13769 ) 
 * Don ' t use RangeFetchMapCalculator when RF = 1 ( CASSANDRA - 13576 ) 
 * Don ' t optimise trivial ranges in RangeFetchMapCalculator ( CASSANDRA - 13664 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 index 6342a1b . . 3b1bc41 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 @ @ - 339 , 6 + 339 , 11 @ @ public class CompactionStrategyManager implements INotificationConsumer 
 return ids ; 
 } 
 
 + public boolean hasDataForPendingRepair ( UUID sessionID ) 
 + { 
 + return Iterables . any ( pendingRepairs , prm - > prm . hasDataForSession ( sessionID ) ) ; 
 + } 
 + 
 public void shutdown ( ) 
 { 
 writeLock . lock ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 index 4596381 . . 8ee6025 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / PendingRepairManager . java 
 @ @ - 398 , 6 + 398 , 11 @ @ class PendingRepairManager 
 return strategies . values ( ) . contains ( strategy ) ; 
 } 
 
 + public synchronized boolean hasDataForSession ( UUID sessionID ) 
 + { 
 + return strategies . keySet ( ) . contains ( sessionID ) ; 
 + } 
 + 
 public Collection < AbstractCompactionTask > createUserDefinedTasks ( List < SSTableReader > sstables , int gcBefore ) 
 { 
 Map < UUID , List < SSTableReader > > group = sstables . stream ( ) . collect ( Collectors . groupingBy ( s - > s . getSSTableMetadata ( ) . pendingRepair ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 index a25f65c . . 4ef2c2c 100644 
 - - - a / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 + + + b / src / java / org / apache / cassandra / repair / consistent / LocalSessions . java 
 @ @ - 32 , 7 + 32 , 7 @ @ import java . util . UUID ; 
 import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Executors ; 
 import java . util . concurrent . TimeUnit ; 
 - 
 + import java . util . function . Predicate ; 
 import javax . annotation . Nullable ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 @ @ - 45 , 18 + 45 , 15 @ @ import com . google . common . primitives . Ints ; 
 import com . google . common . util . concurrent . FutureCallback ; 
 import com . google . common . util . concurrent . Futures ; 
 import com . google . common . util . concurrent . ListenableFuture ; 
 - 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . db . ColumnFamilyStore ; 
 - import org . apache . cassandra . db . compaction . CompactionManager ; 
 - import org . apache . cassandra . schema . Schema ; 
 - import org . apache . cassandra . schema . SchemaConstants ; 
 import org . apache . cassandra . cql3 . QueryProcessor ; 
 import org . apache . cassandra . cql3 . UntypedResultSet ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . SystemKeyspace ; 
 + import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . marshal . BytesType ; 
 import org . apache . cassandra . db . marshal . InetAddressType ; 
 import org . apache . cassandra . db . marshal . UUIDType ; 
 @ @ - 77 , 6 + 74 , 8 @ @ import org . apache . cassandra . repair . messages . PrepareConsistentResponse ; 
 import org . apache . cassandra . repair . messages . RepairMessage ; 
 import org . apache . cassandra . repair . messages . StatusRequest ; 
 import org . apache . cassandra . repair . messages . StatusResponse ; 
 + import org . apache . cassandra . schema . Schema ; 
 + import org . apache . cassandra . schema . SchemaConstants ; 
 import org . apache . cassandra . schema . TableId ; 
 import org . apache . cassandra . service . ActiveRepairService ; 
 import org . apache . cassandra . service . StorageService ; 
 @ @ - 260 , 8 + 259 , 15 @ @ public class LocalSessions 
 } 
 else if ( shouldDelete ( session , now ) ) 
 { 
 - logger . debug ( " Auto deleting repair session { } " , session ) ; 
 - deleteSession ( session . sessionID ) ; 
 + if ( ! sessionHasData ( session ) ) 
 + { 
 + logger . debug ( " Auto deleting repair session { } " , session ) ; 
 + deleteSession ( session . sessionID ) ; 
 + } 
 + else 
 + { 
 + logger . warn ( " Skipping delete of LocalSession { } because it still contains sstables " , session . sessionID ) ; 
 + } 
 } 
 else if ( shouldCheckStatus ( session , now ) ) 
 { 
 @ @ - 737 , 6 + 743 , 17 @ @ public class LocalSessions 
 return session ! = null & & session . getState ( ) ! = FINALIZED & & session . getState ( ) ! = FAILED ; 
 } 
 
 + @ VisibleForTesting 
 + protected boolean sessionHasData ( LocalSession session ) 
 + { 
 + Predicate < TableId > predicate = tid - > { 
 + ColumnFamilyStore cfs = Schema . instance . getColumnFamilyStoreInstance ( tid ) ; 
 + return cfs ! = null & & cfs . getCompactionStrategyManager ( ) . hasDataForPendingRepair ( session . sessionID ) ; 
 + 
 + } ; 
 + return Iterables . any ( session . tableIds , predicate : : test ) ; 
 + } 
 + 
 / * * 
 * Returns the repairedAt time for a sessions which is unknown , failed , or finalized 
 * calling this for a session which is in progress throws an exception 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 index 33e996b . . 2b88c9c 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / PendingRepairManagerTest . java 
 @ @ - 285 , 4 + 285 , 19 @ @ public class PendingRepairManagerTest extends AbstractPendingRepairTest 
 SSTableReader sstable = makeSSTable ( true ) ; 
 prm . getOrCreate ( sstable ) ; 
 } 
 + 
 + @ Test 
 + public void sessionHasData ( ) 
 + { 
 + PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( 0 ) ; 
 + 
 + UUID repairID = registerSession ( cfs , true , true ) ; 
 + LocalSessionAccessor . prepareUnsafe ( repairID , COORDINATOR , PARTICIPANTS ) ; 
 + 
 + Assert . assertFalse ( prm . hasDataForSession ( repairID ) ) ; 
 + SSTableReader sstable = makeSSTable ( true ) ; 
 + mutateRepaired ( sstable , repairID ) ; 
 + prm . addSSTable ( sstable ) ; 
 + Assert . assertTrue ( prm . hasDataForSession ( repairID ) ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java b / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java 
 index c59462e . . be048fb 100644 
 - - - a / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / consistent / LocalSessionTest . java 
 @ @ - 182 , 6 + 182 , 12 @ @ public class LocalSessionTest extends AbstractRepairTest 
 int calls = completedSessions . getOrDefault ( sessionID , 0 ) ; 
 completedSessions . put ( sessionID , calls + 1 ) ; 
 } 
 + 
 + boolean sessionHasData = false ; 
 + protected boolean sessionHasData ( LocalSession session ) 
 + { 
 + return sessionHasData ; 
 + } 
 } 
 
 private static TableMetadata cfm ; 
 @ @ - 865 , 10 + 871 , 10 @ @ public class LocalSessionTest extends AbstractRepairTest 
 } 
 
 / * * 
 - * Sessions past the auto delete cutoff should be deleted 
 + * Sessions past the auto delete cutoff with no sstables should be deleted 
 * / 
 @ Test 
 - public void cleanupDelete ( ) throws Exception 
 + public void cleanupDeleteNoSSTables ( ) throws Exception 
 { 
 LocalSessions sessions = new InstrumentedLocalSessions ( ) ; 
 sessions . start ( ) ; 
 @ @ - 895 , 6 + 901 , 37 @ @ public class LocalSessionTest extends AbstractRepairTest 
 } 
 
 / * * 
 + * Sessions past the auto delete cutoff with no sstables should be deleted 
 + * / 
 + @ Test 
 + public void cleanupDeleteSSTablesRemaining ( ) throws Exception 
 + { 
 + InstrumentedLocalSessions sessions = new InstrumentedLocalSessions ( ) ; 
 + sessions . start ( ) ; 
 + 
 + int time = FBUtilities . nowInSeconds ( ) - LocalSessions . AUTO _ FAIL _ TIMEOUT - 1 ; 
 + LocalSession failed = sessionWithTime ( time - 1 , time ) ; 
 + failed . setState ( FAILED ) ; 
 + 
 + LocalSession finalized = sessionWithTime ( time - 1 , time ) ; 
 + finalized . setState ( FINALIZED ) ; 
 + 
 + sessions . putSessionUnsafe ( failed ) ; 
 + sessions . putSessionUnsafe ( finalized ) ; 
 + Assert . assertNotNull ( sessions . getSession ( failed . sessionID ) ) ; 
 + Assert . assertNotNull ( sessions . getSession ( finalized . sessionID ) ) ; 
 + 
 + sessions . sessionHasData = true ; 
 + sessions . cleanup ( ) ; 
 + 
 + Assert . assertNotNull ( sessions . getSession ( failed . sessionID ) ) ; 
 + Assert . assertNotNull ( sessions . getSession ( finalized . sessionID ) ) ; 
 + 
 + Assert . assertNotNull ( sessions . loadUnsafe ( failed . sessionID ) ) ; 
 + Assert . assertNotNull ( sessions . loadUnsafe ( finalized . sessionID ) ) ; 
 + } 
 + 
 + / * * 
 * Sessions should start checking the status of their participants if 
 * there hasn ' t been activity for the CHECK _ STATUS _ TIMEOUT period 
 * /

NEAREST DIFF:
ELIMINATEDSENTENCE
