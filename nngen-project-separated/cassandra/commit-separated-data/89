BLEU SCORE: 0.005639761817130674

TEST MSG: Add diag events for read repairs
GENERATED MSG: implement keyspace round - robin scheduler . patch by Nirmal Ranganathan ; reviewed by Stu Hood and jbellis for CASSANDRA - 1035

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e40cf27 . . d2d9c86 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add diagnostic events for read repairs ( CASSANDRA - 14668 ) <nl> * Use consistent nowInSeconds and timestamps values within a request ( CASSANDRA - 14671 ) <nl> * Add sampler for query time and expose with nodetool ( CASSANDRA - 14436 ) <nl> * Clean up Message . Request implementations ( CASSANDRA - 14677 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / DigestResolver . java b / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> index b2eb0c6 . . 897892f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> @ @ - 25 , 9 + 25 , 10 @ @ import com . google . common . base . Preconditions ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . partitions . PartitionIterator ; <nl> import org . apache . cassandra . db . partitions . UnfilteredPartitionIterators ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> import org . apache . cassandra . net . MessageIn ; <nl> import org . apache . cassandra . service . reads . repair . ReadRepair ; <nl> - import org . apache . cassandra . tracing . TraceState ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> public class DigestResolver extends ResponseResolver <nl> { <nl> @ @ - 82 , 4 + 83 , 31 @ @ public class DigestResolver extends ResponseResolver <nl> { <nl> return dataResponse ! = null ; <nl> } <nl> + <nl> + public DigestResolverDebugResult [ ] getDigestsByEndpoint ( ) <nl> + { <nl> + DigestResolverDebugResult [ ] ret = new DigestResolverDebugResult [ responses . size ( ) ] ; <nl> + for ( int i = 0 ; i < responses . size ( ) ; i + + ) <nl> + { <nl> + MessageIn < ReadResponse > message = responses . get ( i ) ; <nl> + ReadResponse response = message . payload ; <nl> + String digestHex = ByteBufferUtil . bytesToHex ( response . digest ( command ) ) ; <nl> + ret [ i ] = new DigestResolverDebugResult ( message . from , digestHex , message . payload . isDigestResponse ( ) ) ; <nl> + } <nl> + return ret ; <nl> + } <nl> + <nl> + public static class DigestResolverDebugResult <nl> + { <nl> + public InetAddressAndPort from ; <nl> + public String digestHex ; <nl> + public boolean isDigestResponse ; <nl> + <nl> + private DigestResolverDebugResult ( InetAddressAndPort from , String digestHex , boolean isDigestResponse ) <nl> + { <nl> + this . from = from ; <nl> + this . digestHex = digestHex ; <nl> + this . isDigestResponse = isDigestResponse ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java b / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java <nl> index a1cf827 . . 7e3f0ae 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java <nl> @ @ - 122 , 6 + 122 , 7 @ @ public abstract class AbstractReadRepair implements ReadRepair <nl> Tracing . trace ( " Enqueuing full data read to { } " , endpoint ) ; <nl> sendReadCommand ( endpoint , readCallback ) ; <nl> } <nl> + ReadRepairDiagnostics . startRepair ( this , contactedEndpoints , digestResolver , allEndpoints ) ; <nl> } <nl> <nl> public void awaitReads ( ) throws ReadTimeoutException <nl> @ @ - 167 , 6 + 168 , 7 @ @ public abstract class AbstractReadRepair implements ReadRepair <nl> Tracing . trace ( " Enqueuing speculative full data read to { } " , endpoint ) ; <nl> sendReadCommand ( endpoint . get ( ) , repair . readCallback ) ; <nl> ReadRepairMetrics . speculatedRead . mark ( ) ; <nl> + ReadRepairDiagnostics . speculatedRead ( this , endpoint . get ( ) , candidates ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java b / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java <nl> index eb402ba . . 8d69bef 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java <nl> @ @ - 161 , 6 + 161 , 7 @ @ public class BlockingPartitionRepair extends AbstractFuture < Object > implements I <nl> <nl> if ( ! shouldBlockOn ( destination ) ) <nl> pendingRepairs . remove ( destination ) ; <nl> + ReadRepairDiagnostics . sendInitialRepair ( this , destination , mutation ) ; <nl> } <nl> } <nl> <nl> @ @ - 226 , 14 + 227 , 31 @ @ public class BlockingPartitionRepair extends AbstractFuture < Object > implements I <nl> if ( mutation = = null ) <nl> { <nl> / / the mutation is too large to send . <nl> + ReadRepairDiagnostics . speculatedWriteOversized ( this , endpoint ) ; <nl> continue ; <nl> } <nl> <nl> Tracing . trace ( " Sending speculative read - repair - mutation to { } " , endpoint ) ; <nl> sendRR ( mutation . createMessage ( MessagingService . Verb . READ _ REPAIR ) , endpoint ) ; <nl> + ReadRepairDiagnostics . speculatedWrite ( this , endpoint , mutation ) ; <nl> } <nl> } <nl> <nl> + Keyspace getKeyspace ( ) <nl> + { <nl> + return keyspace ; <nl> + } <nl> + <nl> + DecoratedKey getKey ( ) <nl> + { <nl> + return key ; <nl> + } <nl> + <nl> + ConsistencyLevel getConsistency ( ) <nl> + { <nl> + return consistency ; <nl> + } <nl> + <nl> @ VisibleForTesting <nl> protected Iterable < InetAddressAndPort > getCandidateEndpoints ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java b / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java <nl> new file mode 100644 <nl> index 0000000 . . 04abbcf <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java <nl> @ @ - 0 , 0 + 1 , 102 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service . reads . repair ; <nl> + <nl> + import java . io . Serializable ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import javax . annotation . Nullable ; <nl> + <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . diag . DiagnosticEvent ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + final class PartitionRepairEvent extends DiagnosticEvent <nl> + { <nl> + private final PartitionRepairEventType type ; <nl> + @ VisibleForTesting <nl> + final InetAddressAndPort destination ; <nl> + @ Nullable <nl> + private final Keyspace keyspace ; <nl> + @ Nullable <nl> + private final DecoratedKey key ; <nl> + @ Nullable <nl> + private final ConsistencyLevel consistency ; <nl> + @ Nullable <nl> + @ VisibleForTesting <nl> + String mutationSummary ; <nl> + <nl> + enum PartitionRepairEventType <nl> + { <nl> + SEND _ INITIAL _ REPAIRS , <nl> + SPECULATED _ WRITE , <nl> + UPDATE _ OVERSIZED <nl> + } <nl> + <nl> + PartitionRepairEvent ( PartitionRepairEventType type , BlockingPartitionRepair partitionRepair , <nl> + InetAddressAndPort destination , Mutation mutation ) <nl> + { <nl> + this . type = type ; <nl> + this . destination = destination ; <nl> + this . keyspace = partitionRepair . getKeyspace ( ) ; <nl> + this . consistency = partitionRepair . getConsistency ( ) ; <nl> + this . key = partitionRepair . getKey ( ) ; <nl> + if ( mutation ! = null ) <nl> + { <nl> + try <nl> + { <nl> + this . mutationSummary = mutation . toString ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + this . mutationSummary = String . format ( " < Mutation . toString ( ) : % s > " , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public PartitionRepairEventType getType ( ) <nl> + { <nl> + return type ; <nl> + } <nl> + <nl> + public Map < String , Serializable > toMap ( ) <nl> + { <nl> + HashMap < String , Serializable > ret = new HashMap < > ( ) ; <nl> + if ( keyspace ! = null ) ret . put ( " keyspace " , keyspace . getName ( ) ) ; <nl> + if ( key ! = null ) <nl> + { <nl> + ret . put ( " key " , key . getKey ( ) = = null ? " null " : ByteBufferUtil . bytesToHex ( key . getKey ( ) ) ) ; <nl> + ret . put ( " token " , key . getToken ( ) . toString ( ) ) ; <nl> + } <nl> + if ( consistency ! = null ) ret . put ( " consistency " , consistency . name ( ) ) ; <nl> + <nl> + ret . put ( " destination " , destination . toString ( ) ) ; <nl> + <nl> + if ( mutationSummary ! = null ) ret . put ( " mutation " , mutationSummary ) ; <nl> + <nl> + return ret ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java <nl> new file mode 100644 <nl> index 0000000 . . 1117822 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java <nl> @ @ - 0 , 0 + 1 , 78 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service . reads . repair ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + <nl> + import com . google . common . collect . Lists ; <nl> + <nl> + import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . diag . DiagnosticEventService ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . service . reads . DigestResolver ; <nl> + import org . apache . cassandra . service . reads . repair . PartitionRepairEvent . PartitionRepairEventType ; <nl> + import org . apache . cassandra . service . reads . repair . ReadRepairEvent . ReadRepairEventType ; <nl> + <nl> + final class ReadRepairDiagnostics <nl> + { <nl> + private static final DiagnosticEventService service = DiagnosticEventService . instance ( ) ; <nl> + <nl> + private ReadRepairDiagnostics ( ) <nl> + { <nl> + } <nl> + <nl> + static void startRepair ( AbstractReadRepair readRepair , List < InetAddressAndPort > endpointDestinations , <nl> + DigestResolver digestResolver , List < InetAddressAndPort > allEndpoints ) <nl> + { <nl> + if ( service . isEnabled ( ReadRepairEvent . class , ReadRepairEventType . START _ REPAIR ) ) <nl> + service . publish ( new ReadRepairEvent ( ReadRepairEventType . START _ REPAIR , <nl> + readRepair , endpointDestinations , allEndpoints , digestResolver ) ) ; <nl> + } <nl> + <nl> + static void speculatedRead ( AbstractReadRepair readRepair , InetAddressAndPort endpoint , <nl> + Iterable < InetAddressAndPort > allEndpoints ) <nl> + { <nl> + if ( service . isEnabled ( ReadRepairEvent . class , ReadRepairEventType . SPECULATED _ READ ) ) <nl> + service . publish ( new ReadRepairEvent ( ReadRepairEventType . SPECULATED _ READ , <nl> + readRepair , Collections . singletonList ( endpoint ) , <nl> + Lists . newArrayList ( allEndpoints ) , null ) ) ; <nl> + } <nl> + <nl> + static void sendInitialRepair ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination , Mutation mutation ) <nl> + { <nl> + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . SEND _ INITIAL _ REPAIRS ) ) <nl> + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . SEND _ INITIAL _ REPAIRS , partitionRepair , <nl> + destination , mutation ) ) ; <nl> + } <nl> + <nl> + static void speculatedWrite ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination , Mutation mutation ) <nl> + { <nl> + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . SPECULATED _ WRITE ) ) <nl> + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . SPECULATED _ WRITE , partitionRepair , <nl> + destination , mutation ) ) ; <nl> + } <nl> + <nl> + static void speculatedWriteOversized ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination ) <nl> + { <nl> + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . UPDATE _ OVERSIZED ) ) <nl> + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . UPDATE _ OVERSIZED , partitionRepair , <nl> + destination , null ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java <nl> new file mode 100644 <nl> index 0000000 . . 152f7e6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java <nl> @ @ - 0 , 0 + 1 , 114 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service . reads . repair ; <nl> + <nl> + import java . io . Serializable ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import javax . annotation . Nullable ; <nl> + <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . diag . DiagnosticEvent ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . service . reads . DigestResolver ; <nl> + import org . apache . cassandra . service . reads . DigestResolver . DigestResolverDebugResult ; <nl> + import org . apache . cassandra . service . reads . SpeculativeRetryPolicy ; <nl> + <nl> + final class ReadRepairEvent extends DiagnosticEvent <nl> + { <nl> + <nl> + private final ReadRepairEventType type ; <nl> + private final Keyspace keyspace ; <nl> + private final String tableName ; <nl> + private final String cqlCommand ; <nl> + private final ConsistencyLevel consistency ; <nl> + private final SpeculativeRetryPolicy . Kind speculativeRetry ; <nl> + @ VisibleForTesting <nl> + final List < InetAddressAndPort > destinations ; <nl> + @ VisibleForTesting <nl> + final List < InetAddressAndPort > allEndpoints ; <nl> + @ Nullable <nl> + private final DigestResolverDebugResult [ ] digestsByEndpoint ; <nl> + <nl> + enum ReadRepairEventType <nl> + { <nl> + START _ REPAIR , <nl> + SPECULATED _ READ <nl> + } <nl> + <nl> + ReadRepairEvent ( ReadRepairEventType type , AbstractReadRepair readRepair , List < InetAddressAndPort > destinations , <nl> + List < InetAddressAndPort > allEndpoints , DigestResolver digestResolver ) <nl> + { <nl> + this . keyspace = readRepair . cfs . keyspace ; <nl> + this . tableName = readRepair . cfs . getTableName ( ) ; <nl> + this . cqlCommand = readRepair . command . toCQLString ( ) ; <nl> + this . consistency = readRepair . consistency ; <nl> + this . speculativeRetry = readRepair . cfs . metadata ( ) . params . speculativeRetry . kind ( ) ; <nl> + this . destinations = destinations ; <nl> + this . allEndpoints = allEndpoints ; <nl> + this . digestsByEndpoint = digestResolver ! = null ? digestResolver . getDigestsByEndpoint ( ) : null ; <nl> + this . type = type ; <nl> + } <nl> + <nl> + public ReadRepairEventType getType ( ) <nl> + { <nl> + return type ; <nl> + } <nl> + <nl> + public Map < String , Serializable > toMap ( ) <nl> + { <nl> + HashMap < String , Serializable > ret = new HashMap < > ( ) ; <nl> + <nl> + ret . put ( " keyspace " , keyspace . getName ( ) ) ; <nl> + ret . put ( " table " , tableName ) ; <nl> + ret . put ( " command " , cqlCommand ) ; <nl> + ret . put ( " consistency " , consistency . name ( ) ) ; <nl> + ret . put ( " speculativeRetry " , speculativeRetry . name ( ) ) ; <nl> + <nl> + Set < String > eps = destinations . stream ( ) . map ( InetAddressAndPort : : toString ) . collect ( Collectors . toSet ( ) ) ; <nl> + ret . put ( " endpointDestinations " , new HashSet < > ( eps ) ) ; <nl> + <nl> + if ( digestsByEndpoint ! = null ) <nl> + { <nl> + HashMap < String , Serializable > digestsMap = new HashMap < > ( ) ; <nl> + for ( DigestResolverDebugResult digestsByEndpoint : digestsByEndpoint ) <nl> + { <nl> + HashMap < String , Serializable > digests = new HashMap < > ( ) ; <nl> + digests . put ( " digestHex " , digestsByEndpoint . digestHex ) ; <nl> + digests . put ( " isDigestResponse " , digestsByEndpoint . isDigestResponse ) ; <nl> + digestsMap . put ( digestsByEndpoint . from . toString ( ) , digests ) ; <nl> + } <nl> + ret . put ( " digestsByEndpoint " , digestsMap ) ; <nl> + } <nl> + if ( allEndpoints ! = null ) <nl> + { <nl> + eps = allEndpoints . stream ( ) . map ( InetAddressAndPort : : toString ) . collect ( Collectors . toSet ( ) ) ; <nl> + ret . put ( " allEndpoints " , new HashSet < > ( eps ) ) ; <nl> + } <nl> + return ret ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java b / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1f07c2b <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java <nl> @ @ - 0 , 0 + 1 , 192 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service . reads . repair ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Assert ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . OverrideConfigurationLoader ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . db . ReadCommand ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . diag . DiagnosticEventService ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . net . MessageOut ; <nl> + import org . apache . cassandra . service . reads . ReadCallback ; <nl> + import org . apache . cassandra . service . reads . repair . ReadRepairEvent . ReadRepairEventType ; <nl> + <nl> + / * * <nl> + * Variation of { @ link BlockingReadRepair } using diagnostic events instead of instrumentation for test validation . <nl> + * / <nl> + public class DiagEventsBlockingReadRepairTest extends AbstractReadRepairTest <nl> + { <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) throws Throwable <nl> + { <nl> + OverrideConfigurationLoader . override ( ( config ) - > { <nl> + config . diagnostic _ events _ enabled = true ; <nl> + } ) ; <nl> + configureClass ( ReadRepairStrategy . BLOCKING ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void unsubscribeAll ( ) <nl> + { <nl> + DiagnosticEventService . instance ( ) . cleanup ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void additionalMutationRequired ( ) <nl> + { <nl> + Mutation repair1 = mutation ( cell2 ) ; <nl> + Mutation repair2 = mutation ( cell1 ) ; <nl> + <nl> + / / check that the correct repairs are calculated <nl> + Map < InetAddressAndPort , Mutation > repairs = new HashMap < > ( ) ; <nl> + repairs . put ( target1 , repair1 ) ; <nl> + repairs . put ( target2 , repair2 ) ; <nl> + <nl> + <nl> + DiagnosticPartitionReadRepairHandler handler = createRepairHandler ( repairs , 2 ) ; <nl> + <nl> + Assert . assertTrue ( handler . updatesByEp . isEmpty ( ) ) ; <nl> + <nl> + / / check that the correct mutations are sent <nl> + handler . sendInitialRepairs ( ) ; <nl> + Assert . assertEquals ( 2 , handler . updatesByEp . size ( ) ) ; <nl> + <nl> + Assert . assertEquals ( repair1 . toString ( ) , handler . updatesByEp . get ( target1 ) ) ; <nl> + Assert . assertEquals ( repair2 . toString ( ) , handler . updatesByEp . get ( target2 ) ) ; <nl> + <nl> + / / check that a combined mutation is speculatively sent to the 3rd target <nl> + handler . updatesByEp . clear ( ) ; <nl> + handler . maybeSendAdditionalWrites ( 0 , TimeUnit . NANOSECONDS ) ; <nl> + Assert . assertEquals ( 1 , handler . updatesByEp . size ( ) ) ; <nl> + Assert . assertEquals ( resolved . toString ( ) , handler . updatesByEp . get ( target3 ) ) ; <nl> + <nl> + / / check repairs stop blocking after receiving 2 acks <nl> + Assert . assertFalse ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; <nl> + handler . ack ( target1 ) ; <nl> + Assert . assertFalse ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; <nl> + handler . ack ( target3 ) ; <nl> + Assert . assertTrue ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; <nl> + } <nl> + <nl> + public InstrumentedReadRepair createInstrumentedReadRepair ( ReadCommand command , long queryStartNanoTime , ConsistencyLevel consistency ) <nl> + { <nl> + return new DiagnosticBlockingRepairHandler ( command , queryStartNanoTime , consistency ) ; <nl> + } <nl> + <nl> + private static DiagnosticPartitionReadRepairHandler createRepairHandler ( Map < InetAddressAndPort , Mutation > repairs , int maxBlockFor ) <nl> + { <nl> + Set < InetAddressAndPort > participants = repairs . keySet ( ) ; <nl> + InetAddressAndPort [ ] participantArray = new InetAddressAndPort [ participants . size ( ) ] ; <nl> + participants . toArray ( participantArray ) ; <nl> + return new DiagnosticPartitionReadRepairHandler ( ks , key , ConsistencyLevel . LOCAL _ QUORUM , repairs , maxBlockFor , participantArray ) ; <nl> + } <nl> + <nl> + private static class DiagnosticBlockingRepairHandler extends BlockingReadRepair implements InstrumentedReadRepair <nl> + { <nl> + private Set < InetAddressAndPort > recipients = Collections . emptySet ( ) ; <nl> + private ReadCallback readCallback = null ; <nl> + <nl> + DiagnosticBlockingRepairHandler ( ReadCommand command , long queryStartNanoTime , ConsistencyLevel consistency ) <nl> + { <nl> + super ( command , queryStartNanoTime , consistency ) ; <nl> + DiagnosticEventService . instance ( ) . subscribe ( ReadRepairEvent . class , this : : onRepairEvent ) ; <nl> + } <nl> + <nl> + private void onRepairEvent ( ReadRepairEvent e ) <nl> + { <nl> + if ( e . getType ( ) = = ReadRepairEventType . START _ REPAIR ) recipients = new HashSet < > ( e . destinations ) ; <nl> + else if ( e . getType ( ) = = ReadRepairEventType . SPECULATED _ READ ) recipients . addAll ( e . destinations ) ; <nl> + Assert . assertEquals ( targets , e . allEndpoints ) ; <nl> + Assert . assertNotNull ( e . toMap ( ) ) ; <nl> + } <nl> + <nl> + void sendReadCommand ( InetAddressAndPort to , ReadCallback callback ) <nl> + { <nl> + assert readCallback = = null | | readCallback = = callback ; <nl> + readCallback = callback ; <nl> + } <nl> + <nl> + Iterable < InetAddressAndPort > getCandidatesForToken ( Token token ) <nl> + { <nl> + return targets ; <nl> + } <nl> + <nl> + public Set < InetAddressAndPort > getReadRecipients ( ) <nl> + { <nl> + return recipients ; <nl> + } <nl> + <nl> + public ReadCallback getReadCallback ( ) <nl> + { <nl> + return readCallback ; <nl> + } <nl> + } <nl> + <nl> + private static class DiagnosticPartitionReadRepairHandler extends BlockingPartitionRepair <nl> + { <nl> + private final Map < InetAddressAndPort , String > updatesByEp = new HashMap < > ( ) ; <nl> + <nl> + DiagnosticPartitionReadRepairHandler ( Keyspace keyspace , DecoratedKey key , ConsistencyLevel consistency , Map < InetAddressAndPort , Mutation > repairs , int maxBlockFor , InetAddressAndPort [ ] participants ) <nl> + { <nl> + super ( keyspace , key , consistency , repairs , maxBlockFor , participants ) ; <nl> + DiagnosticEventService . instance ( ) . subscribe ( PartitionRepairEvent . class , this : : onRepairEvent ) ; <nl> + } <nl> + <nl> + private void onRepairEvent ( PartitionRepairEvent e ) <nl> + { <nl> + updatesByEp . put ( e . destination , e . mutationSummary ) ; <nl> + Assert . assertNotNull ( e . toMap ( ) ) ; <nl> + } <nl> + <nl> + protected void sendRR ( MessageOut < Mutation > message , InetAddressAndPort endpoint ) <nl> + { <nl> + } <nl> + <nl> + List < InetAddressAndPort > candidates = targets ; <nl> + <nl> + protected List < InetAddressAndPort > getCandidateEndpoints ( ) <nl> + { <nl> + return candidates ; <nl> + } <nl> + <nl> + @ Override <nl> + protected boolean isLocal ( InetAddressAndPort endpoint ) <nl> + { <nl> + return targets . contains ( endpoint ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index db943a3 . . d482bac 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 18 , 6 + 18 , 8 @ @ Features <nl> - Streaming data for repair or node movement no longer requires <nl> anticompaction step first <nl> - keyspace is per - connection in the thrift API instead of per - call <nl> + - optional round - robin scheduling between keyspaces for multitenant <nl> + clusters <nl> <nl> Configuraton <nl> - - - - - - - - - - - - <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index f812db2 . . 30f85a4 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 141 , 6 + 141 , 35 @ @ gc _ grace _ seconds : 864000 <nl> # org . apache . cassandra . locator . PropertyFileSnitch . <nl> endpoint _ snitch : org . apache . cassandra . locator . SimpleSnitch <nl> <nl> + # request _ scheduler - - Set this to a class that implements <nl> + # RequestScheduler , which will schedule incoming client requests <nl> + # according to the specific policy . This is useful for multi - tenancy <nl> + # with a single Cassandra cluster . <nl> + # NOTE : This is specifically for requests from the client and does <nl> + # not affect inter node communication . <nl> + # org . apache . cassandra . scheduler . NoScheduler - No scheduling takes place <nl> + # org . apache . cassandra . scheduler . RoundRobinScheduler - Round robin of <nl> + # client requests to a node with a sepearte queue for each <nl> + # reques _ scheduler _ id . The requests are throttled based on the limit set <nl> + # in throttle _ limit in the requeset _ scheduler _ options <nl> + request _ scheduler : org . apache . cassandra . scheduler . NoScheduler <nl> + <nl> + # Scheduler Options vary based on the type of scheduler <nl> + # NoScheduler - Has no options <nl> + # RoundRobin <nl> + # - throttle _ limit - - The throttle _ limit is the number of in - flight <nl> + # requests per client . Requests beyond <nl> + # that limit are queued up until <nl> + # running requests can complete . <nl> + # The value of 80 here is twice the number of <nl> + # concurrent _ reads + concurrent _ writes . <nl> + # request _ scheduler _ options : <nl> + # throttle _ limit : 80 <nl> + <nl> + # request _ scheduler _ id - - An identifer based on which to perform <nl> + # the request scheduling . The current supported option is " keyspace " <nl> + request _ scheduler _ id : keyspace <nl> + <nl> # A ColumnFamily is the Cassandra concept closest to a relational table . <nl> # <nl> # Keyspaces are separate groups of ColumnFamilies . Except in very <nl> diff - - git a / src / java / org / apache / cassandra / avro / CassandraServer . java b / src / java / org / apache / cassandra / avro / CassandraServer . java <nl> index 68f4118 . . 2521c05 100644 <nl> - - - a / src / java / org / apache / cassandra / avro / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / avro / CassandraServer . java <nl> @ @ - 43 , 6 + 43 , 7 @ @ import org . slf4j . LoggerFactory ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . config . Config ; <nl> import org . apache . cassandra . config . ConfigurationException ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . KSMetaData ; <nl> @ @ - 53 , 6 + 54 , 7 @ @ import org . apache . cassandra . db . filter . QueryPath ; <nl> import org . apache . cassandra . db . marshal . MarshalException ; <nl> import org . apache . cassandra . db . migration . AddKeyspace ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> + import org . apache . cassandra . scheduler . IRequestScheduler ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . service . StorageService ; <nl> <nl> @ @ - 84 , 12 + 86 , 27 @ @ public class CassandraServer implements Cassandra { <nl> / / Session keyspace . <nl> private ThreadLocal < String > curKeyspace = new ThreadLocal < String > ( ) ; <nl> <nl> + / * <nl> + * An associated Id for scheduling the requests <nl> + * / <nl> + private ThreadLocal < String > requestSchedulerId = new ThreadLocal < String > ( ) ; <nl> + <nl> + / * <nl> + * RequestScheduler to perform the scheduling of incoming requests <nl> + * / <nl> + private final IRequestScheduler requestScheduler ; <nl> + <nl> + public CassandraServer ( ) <nl> + { <nl> + requestScheduler = DatabaseDescriptor . getRequestScheduler ( ) ; <nl> + } <nl> + <nl> @ Override <nl> public ColumnOrSuperColumn get ( ByteBuffer key , ColumnPath columnPath , ConsistencyLevel consistencyLevel ) <nl> throws AvroRemoteException , InvalidRequestException , NotFoundException , UnavailableException , TimedOutException { <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " get " ) ; <nl> - <nl> + <nl> AvroValidation . validateColumnPath ( curKeyspace . get ( ) , columnPath ) ; <nl> <nl> / / FIXME : This is repetitive . <nl> @ @ - 129 , 6 + 146 , 7 @ @ public class CassandraServer implements Cassandra { <nl> List < Row > rows ; <nl> try <nl> { <nl> + schedule ( ) ; <nl> rows = StorageProxy . readProtocol ( commands , thriftConsistencyLevel ( consistency ) ) ; <nl> } <nl> catch ( TimeoutException e ) <nl> @ @ - 145 , 6 + 163 , 10 @ @ public class CassandraServer implements Cassandra { <nl> { <nl> throw new UnavailableException ( ) ; <nl> } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> <nl> for ( Row row : rows ) <nl> { <nl> @ @ - 398 , 6 + 420 , 7 @ @ public class CassandraServer implements Cassandra { <nl> { <nl> try <nl> { <nl> + schedule ( ) ; <nl> StorageProxy . mutateBlocking ( Arrays . asList ( rm ) , thriftConsistencyLevel ( consistency ) ) ; <nl> } <nl> catch ( TimeoutException e ) <nl> @ @ - 408 , 10 + 431 , 22 @ @ public class CassandraServer implements Cassandra { <nl> { <nl> throw new UnavailableException ( ) ; <nl> } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> else <nl> { <nl> - StorageProxy . mutate ( Arrays . asList ( rm ) ) ; <nl> + try <nl> + { <nl> + schedule ( ) ; <nl> + StorageProxy . mutate ( Arrays . asList ( rm ) ) ; <nl> + } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 441 , 12 + 476 , 21 @ @ public class CassandraServer implements Cassandra { <nl> <nl> if ( consistencyLevel = = ConsistencyLevel . ZERO ) <nl> { <nl> - StorageProxy . mutate ( rowMutations ) ; <nl> + try <nl> + { <nl> + schedule ( ) ; <nl> + StorageProxy . mutate ( rowMutations ) ; <nl> + } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> else <nl> { <nl> try <nl> { <nl> + schedule ( ) ; <nl> StorageProxy . mutateBlocking ( rowMutations , thriftConsistencyLevel ( consistencyLevel ) ) ; <nl> } <nl> catch ( TimeoutException te ) <nl> @ @ - 458 , 6 + 502 , 10 @ @ public class CassandraServer implements Cassandra { <nl> { <nl> throw newUnavailableException ( ) ; <nl> } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> <nl> return null ; <nl> @ @ - 553 , 7 + 601 , 11 @ @ public class CassandraServer implements Cassandra { <nl> loginDone . set ( AccessLevel . NONE ) ; <nl> <nl> this . curKeyspace . set ( keyspaceStr ) ; <nl> - <nl> + <nl> + if ( DatabaseDescriptor . getRequestSchedulerId ( ) . equals ( Config . RequestSchedulerId . keyspace ) ) { <nl> + requestSchedulerId . set ( curKeyspace . get ( ) ) ; <nl> + } <nl> + <nl> return null ; <nl> } <nl> <nl> @ @ - 663 , 4 + 715 , 20 @ @ public class CassandraServer implements Cassandra { <nl> logger . debug ( " checking schema agreement " ) ; <nl> return StorageProxy . checkSchemaAgreement ( ) ; <nl> } <nl> + <nl> + / * * <nl> + * Schedule the current thread for access to the required services <nl> + * / <nl> + private void schedule ( ) <nl> + { <nl> + requestScheduler . queue ( Thread . currentThread ( ) , requestSchedulerId . get ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Release a count of resources used to the request scheduler <nl> + * / <nl> + private void release ( ) <nl> + { <nl> + requestScheduler . release ( ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 093ab40 . . 2a5478e 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 72 , 6 + 72 , 10 @ @ public class Config { <nl> <nl> public String endpoint _ snitch ; <nl> <nl> + public String request _ scheduler ; <nl> + public RequestSchedulerId request _ scheduler _ id ; <nl> + public RequestSchedulerOptions request _ scheduler _ options ; <nl> + <nl> public List < Keyspace > keyspaces ; <nl> <nl> public static enum CommitLogSync { <nl> @ @ - 86 , 4 + 90 , 8 @ @ public class Config { <nl> standard , <nl> } <nl> <nl> + public static enum RequestSchedulerId <nl> + { <nl> + keyspace <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 88d7546 . . 0947af0 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . auth . AllowAllAuthenticator ; <nl> import org . apache . cassandra . auth . IAuthenticator ; <nl> + import org . apache . cassandra . config . Config . RequestSchedulerId ; <nl> import org . apache . cassandra . db . ClockType ; <nl> import org . apache . cassandra . db . ColumnFamilyType ; <nl> import org . apache . cassandra . db . DefsTable ; <nl> @ @ - 46 , 6 + 47 , 8 @ @ import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . IEndpointSnitch ; <nl> + import org . apache . cassandra . scheduler . IRequestScheduler ; <nl> + import org . apache . cassandra . scheduler . NoScheduler ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 85 , 6 + 88 , 10 @ @ public class DatabaseDescriptor <nl> <nl> private final static String STORAGE _ CONF _ FILE = " cassandra . yaml " ; <nl> <nl> + private static IRequestScheduler requestScheduler ; <nl> + private static RequestSchedulerId requestSchedulerId ; <nl> + private static RequestSchedulerOptions requestSchedulerOptions ; <nl> + <nl> public static final UUID INITIAL _ VERSION = new UUID ( 4096 , 0 ) ; / / has type nibble set to 1 , everything else to zero . <nl> private static UUID defsVersion = INITIAL _ VERSION ; <nl> <nl> @ @ - 259 , 6 + 266 , 39 @ @ public class DatabaseDescriptor <nl> } <nl> snitch = createEndpointSnitch ( conf . endpoint _ snitch ) ; <nl> <nl> + / * Request Scheduler setup * / <nl> + requestSchedulerOptions = conf . request _ scheduler _ options ; <nl> + if ( conf . request _ scheduler ! = null ) <nl> + { <nl> + try <nl> + { <nl> + if ( requestSchedulerOptions = = null ) <nl> + { <nl> + requestSchedulerOptions = new RequestSchedulerOptions ( ) ; <nl> + } <nl> + Class cls = Class . forName ( conf . request _ scheduler ) ; <nl> + requestScheduler = ( IRequestScheduler ) cls . getConstructor ( RequestSchedulerOptions . class ) . newInstance ( requestSchedulerOptions ) ; <nl> + } <nl> + catch ( ClassNotFoundException e ) <nl> + { <nl> + throw new ConfigurationException ( " Invalid Request Scheduler class " + conf . request _ scheduler ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + requestScheduler = new NoScheduler ( ) ; <nl> + } <nl> + <nl> + if ( conf . request _ scheduler _ id = = RequestSchedulerId . keyspace ) <nl> + { <nl> + requestSchedulerId = conf . request _ scheduler _ id ; <nl> + } <nl> + else <nl> + { <nl> + / / Default to Keyspace <nl> + requestSchedulerId = RequestSchedulerId . keyspace ; <nl> + } <nl> + <nl> if ( logger . isDebugEnabled ( ) & & conf . auto _ bootstrap ! = null ) <nl> { <nl> logger . debug ( " setting auto _ bootstrap to " + conf . auto _ bootstrap ) ; <nl> @ @ - 716 , 6 + 756 , 21 @ @ public class DatabaseDescriptor <nl> return snitch ; <nl> } <nl> <nl> + public static IRequestScheduler getRequestScheduler ( ) <nl> + { <nl> + return requestScheduler ; <nl> + } <nl> + <nl> + public static RequestSchedulerOptions getRequestSchedulerOptions ( ) <nl> + { <nl> + return requestSchedulerOptions ; <nl> + } <nl> + <nl> + public static RequestSchedulerId getRequestSchedulerId ( ) <nl> + { <nl> + return requestSchedulerId ; <nl> + } <nl> + <nl> public static Class < ? extends AbstractReplicationStrategy > getReplicaPlacementStrategyClass ( String table ) <nl> { <nl> 	 KSMetaData meta = tables . get ( table ) ; <nl> diff - - git a / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java b / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java <nl> new file mode 100644 <nl> index 0000000 . . 196e619 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java <nl> @ @ - 0 , 0 + 1 , 41 @ @ <nl> + package org . apache . cassandra . scheduler ; <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + / * * <nl> + * Implementors of IRequestScheduler must provide a constructor taking a RequestSchedulerOptions object . <nl> + * / <nl> + public interface IRequestScheduler <nl> + { <nl> + / * * <nl> + * Queue incoming request threads <nl> + * <nl> + * @ param t Thread handing the request <nl> + * @ param id Scheduling parameter , an id to distinguish profiles ( users / keyspace ) <nl> + * / <nl> + public void queue ( Thread t , String id ) ; <nl> + <nl> + / * * <nl> + * A convenience method for indicating when a particular request has completed <nl> + * processing , and before a return to the client <nl> + * / <nl> + public void release ( ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / scheduler / NoScheduler . java b / src / java / org / apache / cassandra / scheduler / NoScheduler . java <nl> new file mode 100644 <nl> index 0000000 . . 50c255e <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / scheduler / NoScheduler . java <nl> @ @ - 0 , 0 + 1 , 40 @ @ <nl> + package org . apache . cassandra . scheduler ; <nl> + <nl> + import org . apache . cassandra . config . RequestSchedulerOptions ; <nl> + <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + / * * <nl> + * This is basically not having a scheduler , the requests are <nl> + * processed as normally would be handled by the JVM . <nl> + * / <nl> + public class NoScheduler implements IRequestScheduler <nl> + { <nl> + <nl> + public NoScheduler ( RequestSchedulerOptions options ) { } <nl> + <nl> + public NoScheduler ( ) { } <nl> + <nl> + public void queue ( Thread t , String id ) { } <nl> + <nl> + public void release ( ) { } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java b / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java <nl> new file mode 100644 <nl> index 0000000 . . 7bb4339 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java <nl> @ @ - 0 , 0 + 1 , 126 @ @ <nl> + package org . apache . cassandra . scheduler ; <nl> + <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + import java . util . Map ; <nl> + import java . util . concurrent . Semaphore ; <nl> + import java . util . concurrent . SynchronousQueue ; <nl> + <nl> + import org . apache . cassandra . config . RequestSchedulerOptions ; <nl> + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + / * * <nl> + * A very basic Round Robin implementation of the RequestScheduler . It handles <nl> + * request groups identified on user / keyspace by placing them in separate <nl> + * queues and servicing a request from each queue in a RoundRobin fashion . <nl> + * / <nl> + public class RoundRobinScheduler implements IRequestScheduler <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( RoundRobinScheduler . class ) ; <nl> + private final NonBlockingHashMap < String , SynchronousQueue < Thread > > queues ; <nl> + private static boolean started = false ; <nl> + <nl> + private final Semaphore taskCount ; <nl> + <nl> + / / Used by the the scheduler thread so we don ' t need to busy - wait until there is a request to process <nl> + private final Semaphore queueSize = new Semaphore ( 0 , false ) ; <nl> + <nl> + public RoundRobinScheduler ( RequestSchedulerOptions options ) <nl> + { <nl> + assert ! started ; <nl> + <nl> + taskCount = new Semaphore ( options . throttle _ limit ) ; <nl> + queues = new NonBlockingHashMap < String , SynchronousQueue < Thread > > ( ) ; <nl> + Runnable runnable = new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( true ) <nl> + { <nl> + schedule ( ) ; <nl> + } <nl> + } <nl> + } ; <nl> + Thread scheduler = new Thread ( runnable , " REQUEST - SCHEDULER " ) ; <nl> + scheduler . start ( ) ; <nl> + logger . info ( " Started the RoundRobin Request Scheduler " ) ; <nl> + started = true ; <nl> + } <nl> + <nl> + public void queue ( Thread t , String id ) <nl> + { <nl> + SynchronousQueue < Thread > queue = getQueue ( id ) ; <nl> + <nl> + try <nl> + { <nl> + queueSize . release ( ) ; <nl> + queue . put ( t ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( " Interrupted while queueing requests " , e ) ; <nl> + } <nl> + } <nl> + <nl> + public void release ( ) <nl> + { <nl> + taskCount . release ( ) ; <nl> + } <nl> + <nl> + private void schedule ( ) <nl> + { <nl> + queueSize . acquireUninterruptibly ( ) ; <nl> + for ( SynchronousQueue < Thread > queue : queues . values ( ) ) <nl> + { <nl> + Thread t = queue . poll ( ) ; <nl> + if ( t ! = null ) <nl> + { <nl> + taskCount . acquireUninterruptibly ( ) ; <nl> + queueSize . acquireUninterruptibly ( ) ; <nl> + } <nl> + } <nl> + queueSize . release ( ) ; <nl> + } <nl> + <nl> + / * <nl> + * Get the Queue for the respective id , if one is not available <nl> + * create a new queue for that corresponding id and return it <nl> + * / <nl> + private SynchronousQueue < Thread > getQueue ( String id ) <nl> + { <nl> + SynchronousQueue < Thread > queue = queues . get ( id ) ; <nl> + if ( queue ! = null ) <nl> + / / queue existed <nl> + return queue ; <nl> + <nl> + SynchronousQueue < Thread > maybenew = new SynchronousQueue < Thread > ( true ) ; <nl> + queue = queues . putIfAbsent ( id , maybenew ) ; <nl> + if ( queue = = null ) <nl> + / / created new queue <nl> + return maybenew ; <nl> + <nl> + / / another thread created the queue <nl> + return queue ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> index 0e25000 . . 7b7c46c 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> @ @ - 27 , 6 + 27 , 15 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . auth . AllowAllAuthenticator ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> + import org . apache . cassandra . config . ConfigurationException ; <nl> + import org . apache . cassandra . config . KSMetaData ; <nl> + import org . apache . cassandra . db . migration . AddColumnFamily ; <nl> + import org . apache . cassandra . db . migration . AddKeyspace ; <nl> + import org . apache . cassandra . db . migration . DropColumnFamily ; <nl> + import org . apache . cassandra . db . migration . DropKeyspace ; <nl> + import org . apache . cassandra . db . migration . RenameColumnFamily ; <nl> + import org . apache . cassandra . db . migration . RenameKeyspace ; <nl> + import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . config . * ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . ColumnFamily ; <nl> @ @ - 34 , 9 + 43 , 12 @ @ import org . apache . cassandra . db . clock . AbstractReconciler ; <nl> import org . apache . cassandra . db . clock . TimestampReconciler ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> import org . apache . cassandra . db . marshal . MarshalException ; <nl> - import org . apache . cassandra . db . migration . * ; <nl> - import org . apache . cassandra . dht . * ; <nl> - import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> + import org . apache . cassandra . dht . AbstractBounds ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . scheduler . IRequestScheduler ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . thrift . TException ; <nl> @ @ - 64 , 6 + 76 , 16 @ @ public class CassandraServer implements Cassandra . Iface <nl> private ThreadLocal < String > keySpace = new ThreadLocal < String > ( ) ; <nl> <nl> / * <nl> + * An associated Id for scheduling the requests <nl> + * / <nl> + private ThreadLocal < String > requestSchedulerId = new ThreadLocal < String > ( ) ; <nl> + <nl> + / * <nl> + * RequestScheduler to perform the scheduling of incoming requests <nl> + * / <nl> + private final IRequestScheduler requestScheduler ; <nl> + <nl> + / * <nl> * Handle to the storage service to interact with the other machines in the <nl> * cluster . <nl> * / <nl> @ @ - 72 , 6 + 94 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> public CassandraServer ( ) <nl> { <nl> storageService = StorageService . instance ; <nl> + requestScheduler = DatabaseDescriptor . getRequestScheduler ( ) ; <nl> } <nl> <nl> protected Map < DecoratedKey , ColumnFamily > readColumnFamily ( List < ReadCommand > commands , ConsistencyLevel consistency _ level ) <nl> @ @ - 92 , 7 + 115 , 15 @ @ public class CassandraServer implements Cassandra . Iface <nl> List < Row > rows ; <nl> try <nl> { <nl> - rows = StorageProxy . readProtocol ( commands , consistency _ level ) ; <nl> + try <nl> + { <nl> + schedule ( ) ; <nl> + rows = StorageProxy . readProtocol ( commands , consistency _ level ) ; <nl> + } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> catch ( TimeoutException e ) <nl> { <nl> @ @ - 424 , 21 + 455 , 30 @ @ public class CassandraServer implements Cassandra . Iface <nl> <nl> private void doInsert ( ConsistencyLevel consistency _ level , List < RowMutation > mutations ) throws UnavailableException , TimedOutException <nl> { <nl> - if ( consistency _ level = = ConsistencyLevel . ZERO ) <nl> - { <nl> - StorageProxy . mutate ( mutations ) ; <nl> - } <nl> - else <nl> + try <nl> { <nl> - try <nl> + schedule ( ) ; <nl> + <nl> + if ( consistency _ level = = ConsistencyLevel . ZERO ) <nl> { <nl> - 	 StorageProxy . mutateBlocking ( mutations , consistency _ level ) ; <nl> + StorageProxy . mutate ( mutations ) ; <nl> } <nl> - catch ( TimeoutException e ) <nl> + else <nl> { <nl> - 	 throw new TimedOutException ( ) ; <nl> + try <nl> + { <nl> + StorageProxy . mutateBlocking ( mutations , consistency _ level ) ; <nl> + } <nl> + catch ( TimeoutException e ) <nl> + { <nl> + throw new TimedOutException ( ) ; <nl> + } <nl> } <nl> } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> <nl> public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException <nl> @ @ - 503 , 7 + 543 , 15 @ @ public class CassandraServer implements Cassandra . Iface <nl> { <nl> bounds = new Bounds ( p . getToken ( range . start _ key ) , p . getToken ( range . end _ key ) ) ; <nl> } <nl> - rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , range . count ) , consistency _ level ) ; <nl> + try <nl> + { <nl> + schedule ( ) ; <nl> + rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , range . count ) , consistency _ level ) ; <nl> + } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> assert rows ! = null ; <nl> } <nl> catch ( TimeoutException e ) <nl> @ @ - 681 , 6 + 729 , 22 @ @ public class CassandraServer implements Cassandra . Iface <nl> } <nl> } <nl> <nl> + / * * <nl> + * Schedule the current thread for access to the required services <nl> + * / <nl> + private void schedule ( ) <nl> + { <nl> + requestScheduler . queue ( Thread . currentThread ( ) , requestSchedulerId . get ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Release count for the used up resources <nl> + * / <nl> + private void release ( ) <nl> + { <nl> + requestScheduler . release ( ) ; <nl> + } <nl> + <nl> public String system _ add _ column _ family ( CfDef cf _ def ) throws InvalidRequestException , TException <nl> { <nl> checkKeyspaceAndLoginAuthorized ( AccessLevel . FULL ) ; <nl> @ @ - 919 , 6 + 983 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> checkKeyspaceAndLoginAuthorized ( AccessLevel . FULL ) ; <nl> try <nl> { <nl> + schedule ( ) ; <nl> StorageProxy . truncateBlocking ( keySpace . get ( ) , cfname ) ; <nl> } <nl> catch ( TimeoutException e ) <nl> @ @ - 929 , 9 + 994 , 14 @ @ public class CassandraServer implements Cassandra . Iface <nl> { <nl> throw ( UnavailableException ) new UnavailableException ( ) . initCause ( e ) ; <nl> } <nl> + finally <nl> + { <nl> + release ( ) ; <nl> + } <nl> } <nl> <nl> - public void set _ keyspace ( String keyspace ) throws InvalidRequestException , TException { <nl> + public void set _ keyspace ( String keyspace ) throws InvalidRequestException , TException <nl> + { <nl> if ( DatabaseDescriptor . getTableDefinition ( keyspace ) = = null ) <nl> { <nl> throw new InvalidRequestException ( " Keyspace does not exist " ) ; <nl> @ @ - 941 , 7 + 1011 , 8 @ @ public class CassandraServer implements Cassandra . Iface <nl> if ( keySpace . get ( ) ! = null & & ! keySpace . get ( ) . equals ( keyspace ) ) <nl> loginDone . set ( AccessLevel . NONE ) ; <nl> <nl> - keySpace . set ( keyspace ) ; <nl> + keySpace . set ( keyspace ) ; <nl> + requestSchedulerId . set ( keyspace ) ; <nl> } <nl> <nl> public Map < String , List < String > > check _ schema _ agreement ( ) throws TException , InvalidRequestException <nl> diff - - git a / test / conf / cassandra . yaml b / test / conf / cassandra . yaml <nl> index f279206 . . b9e9047 100644 <nl> - - - a / test / conf / cassandra . yaml <nl> + + + b / test / conf / cassandra . yaml <nl> @ @ - 19 , 6 + 19 , 8 @ @ memtable _ operations _ in _ millions : 0 . 00002 <nl> seeds : <nl> - 127 . 0 . 0 . 2 <nl> endpoint _ snitch : org . apache . cassandra . locator . SimpleSnitch <nl> + request _ scheduler : org . apache . cassandra . scheduler . RoundRobinScheduler <nl> + request _ scheduler _ id : keyspace <nl> keyspaces : <nl> - name : Keyspace1 <nl> replica _ placement _ strategy : org . apache . cassandra . locator . RackUnawareStrategy <nl> diff - - git a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1b4913e <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java <nl> @ @ - 0 , 0 + 1 , 150 @ @ <nl> + package org . apache . cassandra . scheduler ; <nl> + <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + import static org . junit . Assert . * ; <nl> + <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . SynchronousQueue ; <nl> + import java . util . concurrent . ThreadPoolExecutor ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import org . apache . cassandra . config . RequestSchedulerOptions ; <nl> + import org . junit . After ; <nl> + import org . junit . Before ; <nl> + import org . junit . Test ; <nl> + <nl> + public class RoundRobinSchedulerTest <nl> + { <nl> + ExecutorService executor ; <nl> + IRequestScheduler scheduler ; <nl> + AtomicInteger counter = new AtomicInteger ( 0 ) ; <nl> + static final String KS1 = " TestKeyspace " ; <nl> + static final String KS2 = " DevKeyspace " ; <nl> + static final String KS3 = " ProdKeyspace " ; <nl> + <nl> + Map < Integer , Integer > testValues = new HashMap < Integer , Integer > ( ) ; <nl> + <nl> + @ Before <nl> + public void setUp ( ) <nl> + { <nl> + RequestSchedulerOptions options = new RequestSchedulerOptions ( ) ; <nl> + options . throttle _ limit = 5 ; <nl> + scheduler = new RoundRobinScheduler ( options ) ; <nl> + SynchronousQueue < Runnable > queue = new SynchronousQueue < Runnable > ( ) ; <nl> + <nl> + executor = new ThreadPoolExecutor ( 20 , <nl> + Integer . MAX _ VALUE , <nl> + 60 * 1000 , <nl> + TimeUnit . MILLISECONDS , <nl> + queue ) ; <nl> + / / When there are large no . of threads , the results become <nl> + / / more unpredictable because of the JVM thread scheduling <nl> + / / and that will be very hard to provide a consistent test <nl> + runKs1 ( 1 , 10 ) ; <nl> + runKs2 ( 11 , 13 ) ; <nl> + runKs3 ( 14 , 15 ) ; <nl> + <nl> + try <nl> + { <nl> + Thread . sleep ( 3000 ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testScheduling ( ) <nl> + { <nl> + for ( Integer initialValue : testValues . keySet ( ) ) <nl> + { <nl> + / / Makes sure , requests to each keyspace get an equal chance <nl> + / / Requests from one keyspace will not block requests from <nl> + / / another keyspacce <nl> + if ( initialValue > 10 ) <nl> + { <nl> + assertTrue ( initialValue > = testValues . get ( initialValue ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + @ After <nl> + public void shutDown ( ) <nl> + { <nl> + executor . shutdown ( ) ; <nl> + } <nl> + <nl> + private void runKs1 ( int start , int end ) <nl> + { <nl> + for ( int i = start ; i < = end ; i + + ) <nl> + { <nl> + executor . execute ( new Worker ( KS1 , i ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void runKs2 ( int start , int end ) <nl> + { <nl> + for ( int i = start ; i < = end ; i + + ) <nl> + { <nl> + executor . execute ( new Worker ( KS2 , i ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void runKs3 ( int start , int end ) <nl> + { <nl> + for ( int i = start ; i < = end ; i + + ) <nl> + { <nl> + executor . execute ( new Worker ( KS3 , i ) ) ; <nl> + } <nl> + } <nl> + <nl> + class Worker implements Runnable <nl> + { <nl> + String id ; <nl> + int initialCount ; <nl> + int runCount ; <nl> + <nl> + public Worker ( String id , int count ) <nl> + { <nl> + this . id = id ; <nl> + initialCount = count ; <nl> + } <nl> + <nl> + public void run ( ) <nl> + { <nl> + scheduler . queue ( Thread . currentThread ( ) , id ) ; <nl> + <nl> + runCount = counter . incrementAndGet ( ) ; <nl> + <nl> + synchronized ( scheduler ) <nl> + { <nl> + testValues . put ( initialCount , runCount ) ; <nl> + } <nl> + scheduler . release ( ) ; <nl> + } <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e40cf27 . . d2d9c86 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add diagnostic events for read repairs ( CASSANDRA - 14668 ) 
 * Use consistent nowInSeconds and timestamps values within a request ( CASSANDRA - 14671 ) 
 * Add sampler for query time and expose with nodetool ( CASSANDRA - 14436 ) 
 * Clean up Message . Request implementations ( CASSANDRA - 14677 ) 
 diff - - git a / src / java / org / apache / cassandra / service / reads / DigestResolver . java b / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 index b2eb0c6 . . 897892f 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 + + + b / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 @ @ - 25 , 9 + 25 , 10 @ @ import com . google . common . base . Preconditions ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . partitions . PartitionIterator ; 
 import org . apache . cassandra . db . partitions . UnfilteredPartitionIterators ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 import org . apache . cassandra . net . MessageIn ; 
 import org . apache . cassandra . service . reads . repair . ReadRepair ; 
 - import org . apache . cassandra . tracing . TraceState ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 public class DigestResolver extends ResponseResolver 
 { 
 @ @ - 82 , 4 + 83 , 31 @ @ public class DigestResolver extends ResponseResolver 
 { 
 return dataResponse ! = null ; 
 } 
 + 
 + public DigestResolverDebugResult [ ] getDigestsByEndpoint ( ) 
 + { 
 + DigestResolverDebugResult [ ] ret = new DigestResolverDebugResult [ responses . size ( ) ] ; 
 + for ( int i = 0 ; i < responses . size ( ) ; i + + ) 
 + { 
 + MessageIn < ReadResponse > message = responses . get ( i ) ; 
 + ReadResponse response = message . payload ; 
 + String digestHex = ByteBufferUtil . bytesToHex ( response . digest ( command ) ) ; 
 + ret [ i ] = new DigestResolverDebugResult ( message . from , digestHex , message . payload . isDigestResponse ( ) ) ; 
 + } 
 + return ret ; 
 + } 
 + 
 + public static class DigestResolverDebugResult 
 + { 
 + public InetAddressAndPort from ; 
 + public String digestHex ; 
 + public boolean isDigestResponse ; 
 + 
 + private DigestResolverDebugResult ( InetAddressAndPort from , String digestHex , boolean isDigestResponse ) 
 + { 
 + this . from = from ; 
 + this . digestHex = digestHex ; 
 + this . isDigestResponse = isDigestResponse ; 
 + } 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java b / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java 
 index a1cf827 . . 7e3f0ae 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java 
 + + + b / src / java / org / apache / cassandra / service / reads / repair / AbstractReadRepair . java 
 @ @ - 122 , 6 + 122 , 7 @ @ public abstract class AbstractReadRepair implements ReadRepair 
 Tracing . trace ( " Enqueuing full data read to { } " , endpoint ) ; 
 sendReadCommand ( endpoint , readCallback ) ; 
 } 
 + ReadRepairDiagnostics . startRepair ( this , contactedEndpoints , digestResolver , allEndpoints ) ; 
 } 
 
 public void awaitReads ( ) throws ReadTimeoutException 
 @ @ - 167 , 6 + 168 , 7 @ @ public abstract class AbstractReadRepair implements ReadRepair 
 Tracing . trace ( " Enqueuing speculative full data read to { } " , endpoint ) ; 
 sendReadCommand ( endpoint . get ( ) , repair . readCallback ) ; 
 ReadRepairMetrics . speculatedRead . mark ( ) ; 
 + ReadRepairDiagnostics . speculatedRead ( this , endpoint . get ( ) , candidates ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java b / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java 
 index eb402ba . . 8d69bef 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java 
 + + + b / src / java / org / apache / cassandra / service / reads / repair / BlockingPartitionRepair . java 
 @ @ - 161 , 6 + 161 , 7 @ @ public class BlockingPartitionRepair extends AbstractFuture < Object > implements I 
 
 if ( ! shouldBlockOn ( destination ) ) 
 pendingRepairs . remove ( destination ) ; 
 + ReadRepairDiagnostics . sendInitialRepair ( this , destination , mutation ) ; 
 } 
 } 
 
 @ @ - 226 , 14 + 227 , 31 @ @ public class BlockingPartitionRepair extends AbstractFuture < Object > implements I 
 if ( mutation = = null ) 
 { 
 / / the mutation is too large to send . 
 + ReadRepairDiagnostics . speculatedWriteOversized ( this , endpoint ) ; 
 continue ; 
 } 
 
 Tracing . trace ( " Sending speculative read - repair - mutation to { } " , endpoint ) ; 
 sendRR ( mutation . createMessage ( MessagingService . Verb . READ _ REPAIR ) , endpoint ) ; 
 + ReadRepairDiagnostics . speculatedWrite ( this , endpoint , mutation ) ; 
 } 
 } 
 
 + Keyspace getKeyspace ( ) 
 + { 
 + return keyspace ; 
 + } 
 + 
 + DecoratedKey getKey ( ) 
 + { 
 + return key ; 
 + } 
 + 
 + ConsistencyLevel getConsistency ( ) 
 + { 
 + return consistency ; 
 + } 
 + 
 @ VisibleForTesting 
 protected Iterable < InetAddressAndPort > getCandidateEndpoints ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java b / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java 
 new file mode 100644 
 index 0000000 . . 04abbcf 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / reads / repair / PartitionRepairEvent . java 
 @ @ - 0 , 0 + 1 , 102 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service . reads . repair ; 
 + 
 + import java . io . Serializable ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import javax . annotation . Nullable ; 
 + 
 + import com . google . common . annotations . VisibleForTesting ; 
 + 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . diag . DiagnosticEvent ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + final class PartitionRepairEvent extends DiagnosticEvent 
 + { 
 + private final PartitionRepairEventType type ; 
 + @ VisibleForTesting 
 + final InetAddressAndPort destination ; 
 + @ Nullable 
 + private final Keyspace keyspace ; 
 + @ Nullable 
 + private final DecoratedKey key ; 
 + @ Nullable 
 + private final ConsistencyLevel consistency ; 
 + @ Nullable 
 + @ VisibleForTesting 
 + String mutationSummary ; 
 + 
 + enum PartitionRepairEventType 
 + { 
 + SEND _ INITIAL _ REPAIRS , 
 + SPECULATED _ WRITE , 
 + UPDATE _ OVERSIZED 
 + } 
 + 
 + PartitionRepairEvent ( PartitionRepairEventType type , BlockingPartitionRepair partitionRepair , 
 + InetAddressAndPort destination , Mutation mutation ) 
 + { 
 + this . type = type ; 
 + this . destination = destination ; 
 + this . keyspace = partitionRepair . getKeyspace ( ) ; 
 + this . consistency = partitionRepair . getConsistency ( ) ; 
 + this . key = partitionRepair . getKey ( ) ; 
 + if ( mutation ! = null ) 
 + { 
 + try 
 + { 
 + this . mutationSummary = mutation . toString ( ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + this . mutationSummary = String . format ( " < Mutation . toString ( ) : % s > " , e . getMessage ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + public PartitionRepairEventType getType ( ) 
 + { 
 + return type ; 
 + } 
 + 
 + public Map < String , Serializable > toMap ( ) 
 + { 
 + HashMap < String , Serializable > ret = new HashMap < > ( ) ; 
 + if ( keyspace ! = null ) ret . put ( " keyspace " , keyspace . getName ( ) ) ; 
 + if ( key ! = null ) 
 + { 
 + ret . put ( " key " , key . getKey ( ) = = null ? " null " : ByteBufferUtil . bytesToHex ( key . getKey ( ) ) ) ; 
 + ret . put ( " token " , key . getToken ( ) . toString ( ) ) ; 
 + } 
 + if ( consistency ! = null ) ret . put ( " consistency " , consistency . name ( ) ) ; 
 + 
 + ret . put ( " destination " , destination . toString ( ) ) ; 
 + 
 + if ( mutationSummary ! = null ) ret . put ( " mutation " , mutationSummary ) ; 
 + 
 + return ret ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java 
 new file mode 100644 
 index 0000000 . . 1117822 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairDiagnostics . java 
 @ @ - 0 , 0 + 1 , 78 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service . reads . repair ; 
 + 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + 
 + import com . google . common . collect . Lists ; 
 + 
 + import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . diag . DiagnosticEventService ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . service . reads . DigestResolver ; 
 + import org . apache . cassandra . service . reads . repair . PartitionRepairEvent . PartitionRepairEventType ; 
 + import org . apache . cassandra . service . reads . repair . ReadRepairEvent . ReadRepairEventType ; 
 + 
 + final class ReadRepairDiagnostics 
 + { 
 + private static final DiagnosticEventService service = DiagnosticEventService . instance ( ) ; 
 + 
 + private ReadRepairDiagnostics ( ) 
 + { 
 + } 
 + 
 + static void startRepair ( AbstractReadRepair readRepair , List < InetAddressAndPort > endpointDestinations , 
 + DigestResolver digestResolver , List < InetAddressAndPort > allEndpoints ) 
 + { 
 + if ( service . isEnabled ( ReadRepairEvent . class , ReadRepairEventType . START _ REPAIR ) ) 
 + service . publish ( new ReadRepairEvent ( ReadRepairEventType . START _ REPAIR , 
 + readRepair , endpointDestinations , allEndpoints , digestResolver ) ) ; 
 + } 
 + 
 + static void speculatedRead ( AbstractReadRepair readRepair , InetAddressAndPort endpoint , 
 + Iterable < InetAddressAndPort > allEndpoints ) 
 + { 
 + if ( service . isEnabled ( ReadRepairEvent . class , ReadRepairEventType . SPECULATED _ READ ) ) 
 + service . publish ( new ReadRepairEvent ( ReadRepairEventType . SPECULATED _ READ , 
 + readRepair , Collections . singletonList ( endpoint ) , 
 + Lists . newArrayList ( allEndpoints ) , null ) ) ; 
 + } 
 + 
 + static void sendInitialRepair ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination , Mutation mutation ) 
 + { 
 + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . SEND _ INITIAL _ REPAIRS ) ) 
 + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . SEND _ INITIAL _ REPAIRS , partitionRepair , 
 + destination , mutation ) ) ; 
 + } 
 + 
 + static void speculatedWrite ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination , Mutation mutation ) 
 + { 
 + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . SPECULATED _ WRITE ) ) 
 + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . SPECULATED _ WRITE , partitionRepair , 
 + destination , mutation ) ) ; 
 + } 
 + 
 + static void speculatedWriteOversized ( BlockingPartitionRepair partitionRepair , InetAddressAndPort destination ) 
 + { 
 + if ( service . isEnabled ( PartitionRepairEvent . class , PartitionRepairEventType . UPDATE _ OVERSIZED ) ) 
 + service . publish ( new PartitionRepairEvent ( PartitionRepairEventType . UPDATE _ OVERSIZED , partitionRepair , 
 + destination , null ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java 
 new file mode 100644 
 index 0000000 . . 152f7e6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / reads / repair / ReadRepairEvent . java 
 @ @ - 0 , 0 + 1 , 114 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service . reads . repair ; 
 + 
 + import java . io . Serializable ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + import java . util . stream . Collectors ; 
 + 
 + import javax . annotation . Nullable ; 
 + 
 + import com . google . common . annotations . VisibleForTesting ; 
 + 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . diag . DiagnosticEvent ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . service . reads . DigestResolver ; 
 + import org . apache . cassandra . service . reads . DigestResolver . DigestResolverDebugResult ; 
 + import org . apache . cassandra . service . reads . SpeculativeRetryPolicy ; 
 + 
 + final class ReadRepairEvent extends DiagnosticEvent 
 + { 
 + 
 + private final ReadRepairEventType type ; 
 + private final Keyspace keyspace ; 
 + private final String tableName ; 
 + private final String cqlCommand ; 
 + private final ConsistencyLevel consistency ; 
 + private final SpeculativeRetryPolicy . Kind speculativeRetry ; 
 + @ VisibleForTesting 
 + final List < InetAddressAndPort > destinations ; 
 + @ VisibleForTesting 
 + final List < InetAddressAndPort > allEndpoints ; 
 + @ Nullable 
 + private final DigestResolverDebugResult [ ] digestsByEndpoint ; 
 + 
 + enum ReadRepairEventType 
 + { 
 + START _ REPAIR , 
 + SPECULATED _ READ 
 + } 
 + 
 + ReadRepairEvent ( ReadRepairEventType type , AbstractReadRepair readRepair , List < InetAddressAndPort > destinations , 
 + List < InetAddressAndPort > allEndpoints , DigestResolver digestResolver ) 
 + { 
 + this . keyspace = readRepair . cfs . keyspace ; 
 + this . tableName = readRepair . cfs . getTableName ( ) ; 
 + this . cqlCommand = readRepair . command . toCQLString ( ) ; 
 + this . consistency = readRepair . consistency ; 
 + this . speculativeRetry = readRepair . cfs . metadata ( ) . params . speculativeRetry . kind ( ) ; 
 + this . destinations = destinations ; 
 + this . allEndpoints = allEndpoints ; 
 + this . digestsByEndpoint = digestResolver ! = null ? digestResolver . getDigestsByEndpoint ( ) : null ; 
 + this . type = type ; 
 + } 
 + 
 + public ReadRepairEventType getType ( ) 
 + { 
 + return type ; 
 + } 
 + 
 + public Map < String , Serializable > toMap ( ) 
 + { 
 + HashMap < String , Serializable > ret = new HashMap < > ( ) ; 
 + 
 + ret . put ( " keyspace " , keyspace . getName ( ) ) ; 
 + ret . put ( " table " , tableName ) ; 
 + ret . put ( " command " , cqlCommand ) ; 
 + ret . put ( " consistency " , consistency . name ( ) ) ; 
 + ret . put ( " speculativeRetry " , speculativeRetry . name ( ) ) ; 
 + 
 + Set < String > eps = destinations . stream ( ) . map ( InetAddressAndPort : : toString ) . collect ( Collectors . toSet ( ) ) ; 
 + ret . put ( " endpointDestinations " , new HashSet < > ( eps ) ) ; 
 + 
 + if ( digestsByEndpoint ! = null ) 
 + { 
 + HashMap < String , Serializable > digestsMap = new HashMap < > ( ) ; 
 + for ( DigestResolverDebugResult digestsByEndpoint : digestsByEndpoint ) 
 + { 
 + HashMap < String , Serializable > digests = new HashMap < > ( ) ; 
 + digests . put ( " digestHex " , digestsByEndpoint . digestHex ) ; 
 + digests . put ( " isDigestResponse " , digestsByEndpoint . isDigestResponse ) ; 
 + digestsMap . put ( digestsByEndpoint . from . toString ( ) , digests ) ; 
 + } 
 + ret . put ( " digestsByEndpoint " , digestsMap ) ; 
 + } 
 + if ( allEndpoints ! = null ) 
 + { 
 + eps = allEndpoints . stream ( ) . map ( InetAddressAndPort : : toString ) . collect ( Collectors . toSet ( ) ) ; 
 + ret . put ( " allEndpoints " , new HashSet < > ( eps ) ) ; 
 + } 
 + return ret ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java b / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java 
 new file mode 100644 
 index 0000000 . . 1f07c2b 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / service / reads / repair / DiagEventsBlockingReadRepairTest . java 
 @ @ - 0 , 0 + 1 , 192 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service . reads . repair ; 
 + 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Assert ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . OverrideConfigurationLoader ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . db . ReadCommand ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . diag . DiagnosticEventService ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . net . MessageOut ; 
 + import org . apache . cassandra . service . reads . ReadCallback ; 
 + import org . apache . cassandra . service . reads . repair . ReadRepairEvent . ReadRepairEventType ; 
 + 
 + / * * 
 + * Variation of { @ link BlockingReadRepair } using diagnostic events instead of instrumentation for test validation . 
 + * / 
 + public class DiagEventsBlockingReadRepairTest extends AbstractReadRepairTest 
 + { 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) throws Throwable 
 + { 
 + OverrideConfigurationLoader . override ( ( config ) - > { 
 + config . diagnostic _ events _ enabled = true ; 
 + } ) ; 
 + configureClass ( ReadRepairStrategy . BLOCKING ) ; 
 + } 
 + 
 + @ After 
 + public void unsubscribeAll ( ) 
 + { 
 + DiagnosticEventService . instance ( ) . cleanup ( ) ; 
 + } 
 + 
 + @ Test 
 + public void additionalMutationRequired ( ) 
 + { 
 + Mutation repair1 = mutation ( cell2 ) ; 
 + Mutation repair2 = mutation ( cell1 ) ; 
 + 
 + / / check that the correct repairs are calculated 
 + Map < InetAddressAndPort , Mutation > repairs = new HashMap < > ( ) ; 
 + repairs . put ( target1 , repair1 ) ; 
 + repairs . put ( target2 , repair2 ) ; 
 + 
 + 
 + DiagnosticPartitionReadRepairHandler handler = createRepairHandler ( repairs , 2 ) ; 
 + 
 + Assert . assertTrue ( handler . updatesByEp . isEmpty ( ) ) ; 
 + 
 + / / check that the correct mutations are sent 
 + handler . sendInitialRepairs ( ) ; 
 + Assert . assertEquals ( 2 , handler . updatesByEp . size ( ) ) ; 
 + 
 + Assert . assertEquals ( repair1 . toString ( ) , handler . updatesByEp . get ( target1 ) ) ; 
 + Assert . assertEquals ( repair2 . toString ( ) , handler . updatesByEp . get ( target2 ) ) ; 
 + 
 + / / check that a combined mutation is speculatively sent to the 3rd target 
 + handler . updatesByEp . clear ( ) ; 
 + handler . maybeSendAdditionalWrites ( 0 , TimeUnit . NANOSECONDS ) ; 
 + Assert . assertEquals ( 1 , handler . updatesByEp . size ( ) ) ; 
 + Assert . assertEquals ( resolved . toString ( ) , handler . updatesByEp . get ( target3 ) ) ; 
 + 
 + / / check repairs stop blocking after receiving 2 acks 
 + Assert . assertFalse ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; 
 + handler . ack ( target1 ) ; 
 + Assert . assertFalse ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; 
 + handler . ack ( target3 ) ; 
 + Assert . assertTrue ( handler . awaitRepairs ( 0 , TimeUnit . NANOSECONDS ) ) ; 
 + } 
 + 
 + public InstrumentedReadRepair createInstrumentedReadRepair ( ReadCommand command , long queryStartNanoTime , ConsistencyLevel consistency ) 
 + { 
 + return new DiagnosticBlockingRepairHandler ( command , queryStartNanoTime , consistency ) ; 
 + } 
 + 
 + private static DiagnosticPartitionReadRepairHandler createRepairHandler ( Map < InetAddressAndPort , Mutation > repairs , int maxBlockFor ) 
 + { 
 + Set < InetAddressAndPort > participants = repairs . keySet ( ) ; 
 + InetAddressAndPort [ ] participantArray = new InetAddressAndPort [ participants . size ( ) ] ; 
 + participants . toArray ( participantArray ) ; 
 + return new DiagnosticPartitionReadRepairHandler ( ks , key , ConsistencyLevel . LOCAL _ QUORUM , repairs , maxBlockFor , participantArray ) ; 
 + } 
 + 
 + private static class DiagnosticBlockingRepairHandler extends BlockingReadRepair implements InstrumentedReadRepair 
 + { 
 + private Set < InetAddressAndPort > recipients = Collections . emptySet ( ) ; 
 + private ReadCallback readCallback = null ; 
 + 
 + DiagnosticBlockingRepairHandler ( ReadCommand command , long queryStartNanoTime , ConsistencyLevel consistency ) 
 + { 
 + super ( command , queryStartNanoTime , consistency ) ; 
 + DiagnosticEventService . instance ( ) . subscribe ( ReadRepairEvent . class , this : : onRepairEvent ) ; 
 + } 
 + 
 + private void onRepairEvent ( ReadRepairEvent e ) 
 + { 
 + if ( e . getType ( ) = = ReadRepairEventType . START _ REPAIR ) recipients = new HashSet < > ( e . destinations ) ; 
 + else if ( e . getType ( ) = = ReadRepairEventType . SPECULATED _ READ ) recipients . addAll ( e . destinations ) ; 
 + Assert . assertEquals ( targets , e . allEndpoints ) ; 
 + Assert . assertNotNull ( e . toMap ( ) ) ; 
 + } 
 + 
 + void sendReadCommand ( InetAddressAndPort to , ReadCallback callback ) 
 + { 
 + assert readCallback = = null | | readCallback = = callback ; 
 + readCallback = callback ; 
 + } 
 + 
 + Iterable < InetAddressAndPort > getCandidatesForToken ( Token token ) 
 + { 
 + return targets ; 
 + } 
 + 
 + public Set < InetAddressAndPort > getReadRecipients ( ) 
 + { 
 + return recipients ; 
 + } 
 + 
 + public ReadCallback getReadCallback ( ) 
 + { 
 + return readCallback ; 
 + } 
 + } 
 + 
 + private static class DiagnosticPartitionReadRepairHandler extends BlockingPartitionRepair 
 + { 
 + private final Map < InetAddressAndPort , String > updatesByEp = new HashMap < > ( ) ; 
 + 
 + DiagnosticPartitionReadRepairHandler ( Keyspace keyspace , DecoratedKey key , ConsistencyLevel consistency , Map < InetAddressAndPort , Mutation > repairs , int maxBlockFor , InetAddressAndPort [ ] participants ) 
 + { 
 + super ( keyspace , key , consistency , repairs , maxBlockFor , participants ) ; 
 + DiagnosticEventService . instance ( ) . subscribe ( PartitionRepairEvent . class , this : : onRepairEvent ) ; 
 + } 
 + 
 + private void onRepairEvent ( PartitionRepairEvent e ) 
 + { 
 + updatesByEp . put ( e . destination , e . mutationSummary ) ; 
 + Assert . assertNotNull ( e . toMap ( ) ) ; 
 + } 
 + 
 + protected void sendRR ( MessageOut < Mutation > message , InetAddressAndPort endpoint ) 
 + { 
 + } 
 + 
 + List < InetAddressAndPort > candidates = targets ; 
 + 
 + protected List < InetAddressAndPort > getCandidateEndpoints ( ) 
 + { 
 + return candidates ; 
 + } 
 + 
 + @ Override 
 + protected boolean isLocal ( InetAddressAndPort endpoint ) 
 + { 
 + return targets . contains ( endpoint ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index db943a3 . . d482bac 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 18 , 6 + 18 , 8 @ @ Features 
 - Streaming data for repair or node movement no longer requires 
 anticompaction step first 
 - keyspace is per - connection in the thrift API instead of per - call 
 + - optional round - robin scheduling between keyspaces for multitenant 
 + clusters 
 
 Configuraton 
 - - - - - - - - - - - - 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index f812db2 . . 30f85a4 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 141 , 6 + 141 , 35 @ @ gc _ grace _ seconds : 864000 
 # org . apache . cassandra . locator . PropertyFileSnitch . 
 endpoint _ snitch : org . apache . cassandra . locator . SimpleSnitch 
 
 + # request _ scheduler - - Set this to a class that implements 
 + # RequestScheduler , which will schedule incoming client requests 
 + # according to the specific policy . This is useful for multi - tenancy 
 + # with a single Cassandra cluster . 
 + # NOTE : This is specifically for requests from the client and does 
 + # not affect inter node communication . 
 + # org . apache . cassandra . scheduler . NoScheduler - No scheduling takes place 
 + # org . apache . cassandra . scheduler . RoundRobinScheduler - Round robin of 
 + # client requests to a node with a sepearte queue for each 
 + # reques _ scheduler _ id . The requests are throttled based on the limit set 
 + # in throttle _ limit in the requeset _ scheduler _ options 
 + request _ scheduler : org . apache . cassandra . scheduler . NoScheduler 
 + 
 + # Scheduler Options vary based on the type of scheduler 
 + # NoScheduler - Has no options 
 + # RoundRobin 
 + # - throttle _ limit - - The throttle _ limit is the number of in - flight 
 + # requests per client . Requests beyond 
 + # that limit are queued up until 
 + # running requests can complete . 
 + # The value of 80 here is twice the number of 
 + # concurrent _ reads + concurrent _ writes . 
 + # request _ scheduler _ options : 
 + # throttle _ limit : 80 
 + 
 + # request _ scheduler _ id - - An identifer based on which to perform 
 + # the request scheduling . The current supported option is " keyspace " 
 + request _ scheduler _ id : keyspace 
 + 
 # A ColumnFamily is the Cassandra concept closest to a relational table . 
 # 
 # Keyspaces are separate groups of ColumnFamilies . Except in very 
 diff - - git a / src / java / org / apache / cassandra / avro / CassandraServer . java b / src / java / org / apache / cassandra / avro / CassandraServer . java 
 index 68f4118 . . 2521c05 100644 
 - - - a / src / java / org / apache / cassandra / avro / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / avro / CassandraServer . java 
 @ @ - 43 , 6 + 43 , 7 @ @ import org . slf4j . LoggerFactory ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . config . Config ; 
 import org . apache . cassandra . config . ConfigurationException ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . KSMetaData ; 
 @ @ - 53 , 6 + 54 , 7 @ @ import org . apache . cassandra . db . filter . QueryPath ; 
 import org . apache . cassandra . db . marshal . MarshalException ; 
 import org . apache . cassandra . db . migration . AddKeyspace ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 + import org . apache . cassandra . scheduler . IRequestScheduler ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . service . StorageService ; 
 
 @ @ - 84 , 12 + 86 , 27 @ @ public class CassandraServer implements Cassandra { 
 / / Session keyspace . 
 private ThreadLocal < String > curKeyspace = new ThreadLocal < String > ( ) ; 
 
 + / * 
 + * An associated Id for scheduling the requests 
 + * / 
 + private ThreadLocal < String > requestSchedulerId = new ThreadLocal < String > ( ) ; 
 + 
 + / * 
 + * RequestScheduler to perform the scheduling of incoming requests 
 + * / 
 + private final IRequestScheduler requestScheduler ; 
 + 
 + public CassandraServer ( ) 
 + { 
 + requestScheduler = DatabaseDescriptor . getRequestScheduler ( ) ; 
 + } 
 + 
 @ Override 
 public ColumnOrSuperColumn get ( ByteBuffer key , ColumnPath columnPath , ConsistencyLevel consistencyLevel ) 
 throws AvroRemoteException , InvalidRequestException , NotFoundException , UnavailableException , TimedOutException { 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " get " ) ; 
 - 
 + 
 AvroValidation . validateColumnPath ( curKeyspace . get ( ) , columnPath ) ; 
 
 / / FIXME : This is repetitive . 
 @ @ - 129 , 6 + 146 , 7 @ @ public class CassandraServer implements Cassandra { 
 List < Row > rows ; 
 try 
 { 
 + schedule ( ) ; 
 rows = StorageProxy . readProtocol ( commands , thriftConsistencyLevel ( consistency ) ) ; 
 } 
 catch ( TimeoutException e ) 
 @ @ - 145 , 6 + 163 , 10 @ @ public class CassandraServer implements Cassandra { 
 { 
 throw new UnavailableException ( ) ; 
 } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 
 for ( Row row : rows ) 
 { 
 @ @ - 398 , 6 + 420 , 7 @ @ public class CassandraServer implements Cassandra { 
 { 
 try 
 { 
 + schedule ( ) ; 
 StorageProxy . mutateBlocking ( Arrays . asList ( rm ) , thriftConsistencyLevel ( consistency ) ) ; 
 } 
 catch ( TimeoutException e ) 
 @ @ - 408 , 10 + 431 , 22 @ @ public class CassandraServer implements Cassandra { 
 { 
 throw new UnavailableException ( ) ; 
 } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 else 
 { 
 - StorageProxy . mutate ( Arrays . asList ( rm ) ) ; 
 + try 
 + { 
 + schedule ( ) ; 
 + StorageProxy . mutate ( Arrays . asList ( rm ) ) ; 
 + } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 } 
 
 @ @ - 441 , 12 + 476 , 21 @ @ public class CassandraServer implements Cassandra { 
 
 if ( consistencyLevel = = ConsistencyLevel . ZERO ) 
 { 
 - StorageProxy . mutate ( rowMutations ) ; 
 + try 
 + { 
 + schedule ( ) ; 
 + StorageProxy . mutate ( rowMutations ) ; 
 + } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 else 
 { 
 try 
 { 
 + schedule ( ) ; 
 StorageProxy . mutateBlocking ( rowMutations , thriftConsistencyLevel ( consistencyLevel ) ) ; 
 } 
 catch ( TimeoutException te ) 
 @ @ - 458 , 6 + 502 , 10 @ @ public class CassandraServer implements Cassandra { 
 { 
 throw newUnavailableException ( ) ; 
 } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 
 return null ; 
 @ @ - 553 , 7 + 601 , 11 @ @ public class CassandraServer implements Cassandra { 
 loginDone . set ( AccessLevel . NONE ) ; 
 
 this . curKeyspace . set ( keyspaceStr ) ; 
 - 
 + 
 + if ( DatabaseDescriptor . getRequestSchedulerId ( ) . equals ( Config . RequestSchedulerId . keyspace ) ) { 
 + requestSchedulerId . set ( curKeyspace . get ( ) ) ; 
 + } 
 + 
 return null ; 
 } 
 
 @ @ - 663 , 4 + 715 , 20 @ @ public class CassandraServer implements Cassandra { 
 logger . debug ( " checking schema agreement " ) ; 
 return StorageProxy . checkSchemaAgreement ( ) ; 
 } 
 + 
 + / * * 
 + * Schedule the current thread for access to the required services 
 + * / 
 + private void schedule ( ) 
 + { 
 + requestScheduler . queue ( Thread . currentThread ( ) , requestSchedulerId . get ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Release a count of resources used to the request scheduler 
 + * / 
 + private void release ( ) 
 + { 
 + requestScheduler . release ( ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 093ab40 . . 2a5478e 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 72 , 6 + 72 , 10 @ @ public class Config { 
 
 public String endpoint _ snitch ; 
 
 + public String request _ scheduler ; 
 + public RequestSchedulerId request _ scheduler _ id ; 
 + public RequestSchedulerOptions request _ scheduler _ options ; 
 + 
 public List < Keyspace > keyspaces ; 
 
 public static enum CommitLogSync { 
 @ @ - 86 , 4 + 90 , 8 @ @ public class Config { 
 standard , 
 } 
 
 + public static enum RequestSchedulerId 
 + { 
 + keyspace 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 88d7546 . . 0947af0 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . auth . AllowAllAuthenticator ; 
 import org . apache . cassandra . auth . IAuthenticator ; 
 + import org . apache . cassandra . config . Config . RequestSchedulerId ; 
 import org . apache . cassandra . db . ClockType ; 
 import org . apache . cassandra . db . ColumnFamilyType ; 
 import org . apache . cassandra . db . DefsTable ; 
 @ @ - 46 , 6 + 47 , 8 @ @ import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . IEndpointSnitch ; 
 + import org . apache . cassandra . scheduler . IRequestScheduler ; 
 + import org . apache . cassandra . scheduler . NoScheduler ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 85 , 6 + 88 , 10 @ @ public class DatabaseDescriptor 
 
 private final static String STORAGE _ CONF _ FILE = " cassandra . yaml " ; 
 
 + private static IRequestScheduler requestScheduler ; 
 + private static RequestSchedulerId requestSchedulerId ; 
 + private static RequestSchedulerOptions requestSchedulerOptions ; 
 + 
 public static final UUID INITIAL _ VERSION = new UUID ( 4096 , 0 ) ; / / has type nibble set to 1 , everything else to zero . 
 private static UUID defsVersion = INITIAL _ VERSION ; 
 
 @ @ - 259 , 6 + 266 , 39 @ @ public class DatabaseDescriptor 
 } 
 snitch = createEndpointSnitch ( conf . endpoint _ snitch ) ; 
 
 + / * Request Scheduler setup * / 
 + requestSchedulerOptions = conf . request _ scheduler _ options ; 
 + if ( conf . request _ scheduler ! = null ) 
 + { 
 + try 
 + { 
 + if ( requestSchedulerOptions = = null ) 
 + { 
 + requestSchedulerOptions = new RequestSchedulerOptions ( ) ; 
 + } 
 + Class cls = Class . forName ( conf . request _ scheduler ) ; 
 + requestScheduler = ( IRequestScheduler ) cls . getConstructor ( RequestSchedulerOptions . class ) . newInstance ( requestSchedulerOptions ) ; 
 + } 
 + catch ( ClassNotFoundException e ) 
 + { 
 + throw new ConfigurationException ( " Invalid Request Scheduler class " + conf . request _ scheduler ) ; 
 + } 
 + } 
 + else 
 + { 
 + requestScheduler = new NoScheduler ( ) ; 
 + } 
 + 
 + if ( conf . request _ scheduler _ id = = RequestSchedulerId . keyspace ) 
 + { 
 + requestSchedulerId = conf . request _ scheduler _ id ; 
 + } 
 + else 
 + { 
 + / / Default to Keyspace 
 + requestSchedulerId = RequestSchedulerId . keyspace ; 
 + } 
 + 
 if ( logger . isDebugEnabled ( ) & & conf . auto _ bootstrap ! = null ) 
 { 
 logger . debug ( " setting auto _ bootstrap to " + conf . auto _ bootstrap ) ; 
 @ @ - 716 , 6 + 756 , 21 @ @ public class DatabaseDescriptor 
 return snitch ; 
 } 
 
 + public static IRequestScheduler getRequestScheduler ( ) 
 + { 
 + return requestScheduler ; 
 + } 
 + 
 + public static RequestSchedulerOptions getRequestSchedulerOptions ( ) 
 + { 
 + return requestSchedulerOptions ; 
 + } 
 + 
 + public static RequestSchedulerId getRequestSchedulerId ( ) 
 + { 
 + return requestSchedulerId ; 
 + } 
 + 
 public static Class < ? extends AbstractReplicationStrategy > getReplicaPlacementStrategyClass ( String table ) 
 { 
 	 KSMetaData meta = tables . get ( table ) ; 
 diff - - git a / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java b / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java 
 new file mode 100644 
 index 0000000 . . 196e619 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / scheduler / IRequestScheduler . java 
 @ @ - 0 , 0 + 1 , 41 @ @ 
 + package org . apache . cassandra . scheduler ; 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + / * * 
 + * Implementors of IRequestScheduler must provide a constructor taking a RequestSchedulerOptions object . 
 + * / 
 + public interface IRequestScheduler 
 + { 
 + / * * 
 + * Queue incoming request threads 
 + * 
 + * @ param t Thread handing the request 
 + * @ param id Scheduling parameter , an id to distinguish profiles ( users / keyspace ) 
 + * / 
 + public void queue ( Thread t , String id ) ; 
 + 
 + / * * 
 + * A convenience method for indicating when a particular request has completed 
 + * processing , and before a return to the client 
 + * / 
 + public void release ( ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / scheduler / NoScheduler . java b / src / java / org / apache / cassandra / scheduler / NoScheduler . java 
 new file mode 100644 
 index 0000000 . . 50c255e 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / scheduler / NoScheduler . java 
 @ @ - 0 , 0 + 1 , 40 @ @ 
 + package org . apache . cassandra . scheduler ; 
 + 
 + import org . apache . cassandra . config . RequestSchedulerOptions ; 
 + 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + / * * 
 + * This is basically not having a scheduler , the requests are 
 + * processed as normally would be handled by the JVM . 
 + * / 
 + public class NoScheduler implements IRequestScheduler 
 + { 
 + 
 + public NoScheduler ( RequestSchedulerOptions options ) { } 
 + 
 + public NoScheduler ( ) { } 
 + 
 + public void queue ( Thread t , String id ) { } 
 + 
 + public void release ( ) { } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java b / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java 
 new file mode 100644 
 index 0000000 . . 7bb4339 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / scheduler / RoundRobinScheduler . java 
 @ @ - 0 , 0 + 1 , 126 @ @ 
 + package org . apache . cassandra . scheduler ; 
 + 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + import java . util . Map ; 
 + import java . util . concurrent . Semaphore ; 
 + import java . util . concurrent . SynchronousQueue ; 
 + 
 + import org . apache . cassandra . config . RequestSchedulerOptions ; 
 + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + / * * 
 + * A very basic Round Robin implementation of the RequestScheduler . It handles 
 + * request groups identified on user / keyspace by placing them in separate 
 + * queues and servicing a request from each queue in a RoundRobin fashion . 
 + * / 
 + public class RoundRobinScheduler implements IRequestScheduler 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( RoundRobinScheduler . class ) ; 
 + private final NonBlockingHashMap < String , SynchronousQueue < Thread > > queues ; 
 + private static boolean started = false ; 
 + 
 + private final Semaphore taskCount ; 
 + 
 + / / Used by the the scheduler thread so we don ' t need to busy - wait until there is a request to process 
 + private final Semaphore queueSize = new Semaphore ( 0 , false ) ; 
 + 
 + public RoundRobinScheduler ( RequestSchedulerOptions options ) 
 + { 
 + assert ! started ; 
 + 
 + taskCount = new Semaphore ( options . throttle _ limit ) ; 
 + queues = new NonBlockingHashMap < String , SynchronousQueue < Thread > > ( ) ; 
 + Runnable runnable = new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( true ) 
 + { 
 + schedule ( ) ; 
 + } 
 + } 
 + } ; 
 + Thread scheduler = new Thread ( runnable , " REQUEST - SCHEDULER " ) ; 
 + scheduler . start ( ) ; 
 + logger . info ( " Started the RoundRobin Request Scheduler " ) ; 
 + started = true ; 
 + } 
 + 
 + public void queue ( Thread t , String id ) 
 + { 
 + SynchronousQueue < Thread > queue = getQueue ( id ) ; 
 + 
 + try 
 + { 
 + queueSize . release ( ) ; 
 + queue . put ( t ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( " Interrupted while queueing requests " , e ) ; 
 + } 
 + } 
 + 
 + public void release ( ) 
 + { 
 + taskCount . release ( ) ; 
 + } 
 + 
 + private void schedule ( ) 
 + { 
 + queueSize . acquireUninterruptibly ( ) ; 
 + for ( SynchronousQueue < Thread > queue : queues . values ( ) ) 
 + { 
 + Thread t = queue . poll ( ) ; 
 + if ( t ! = null ) 
 + { 
 + taskCount . acquireUninterruptibly ( ) ; 
 + queueSize . acquireUninterruptibly ( ) ; 
 + } 
 + } 
 + queueSize . release ( ) ; 
 + } 
 + 
 + / * 
 + * Get the Queue for the respective id , if one is not available 
 + * create a new queue for that corresponding id and return it 
 + * / 
 + private SynchronousQueue < Thread > getQueue ( String id ) 
 + { 
 + SynchronousQueue < Thread > queue = queues . get ( id ) ; 
 + if ( queue ! = null ) 
 + / / queue existed 
 + return queue ; 
 + 
 + SynchronousQueue < Thread > maybenew = new SynchronousQueue < Thread > ( true ) ; 
 + queue = queues . putIfAbsent ( id , maybenew ) ; 
 + if ( queue = = null ) 
 + / / created new queue 
 + return maybenew ; 
 + 
 + / / another thread created the queue 
 + return queue ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 index 0e25000 . . 7b7c46c 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 @ @ - 27 , 6 + 27 , 15 @ @ import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . auth . AllowAllAuthenticator ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 + import org . apache . cassandra . config . ConfigurationException ; 
 + import org . apache . cassandra . config . KSMetaData ; 
 + import org . apache . cassandra . db . migration . AddColumnFamily ; 
 + import org . apache . cassandra . db . migration . AddKeyspace ; 
 + import org . apache . cassandra . db . migration . DropColumnFamily ; 
 + import org . apache . cassandra . db . migration . DropKeyspace ; 
 + import org . apache . cassandra . db . migration . RenameColumnFamily ; 
 + import org . apache . cassandra . db . migration . RenameKeyspace ; 
 + import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . config . * ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . ColumnFamily ; 
 @ @ - 34 , 9 + 43 , 12 @ @ import org . apache . cassandra . db . clock . AbstractReconciler ; 
 import org . apache . cassandra . db . clock . TimestampReconciler ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 import org . apache . cassandra . db . marshal . MarshalException ; 
 - import org . apache . cassandra . db . migration . * ; 
 - import org . apache . cassandra . dht . * ; 
 - import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 + import org . apache . cassandra . dht . AbstractBounds ; 
 + import org . apache . cassandra . dht . Bounds ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . scheduler . IRequestScheduler ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . thrift . TException ; 
 @ @ - 64 , 6 + 76 , 16 @ @ public class CassandraServer implements Cassandra . Iface 
 private ThreadLocal < String > keySpace = new ThreadLocal < String > ( ) ; 
 
 / * 
 + * An associated Id for scheduling the requests 
 + * / 
 + private ThreadLocal < String > requestSchedulerId = new ThreadLocal < String > ( ) ; 
 + 
 + / * 
 + * RequestScheduler to perform the scheduling of incoming requests 
 + * / 
 + private final IRequestScheduler requestScheduler ; 
 + 
 + / * 
 * Handle to the storage service to interact with the other machines in the 
 * cluster . 
 * / 
 @ @ - 72 , 6 + 94 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 public CassandraServer ( ) 
 { 
 storageService = StorageService . instance ; 
 + requestScheduler = DatabaseDescriptor . getRequestScheduler ( ) ; 
 } 
 
 protected Map < DecoratedKey , ColumnFamily > readColumnFamily ( List < ReadCommand > commands , ConsistencyLevel consistency _ level ) 
 @ @ - 92 , 7 + 115 , 15 @ @ public class CassandraServer implements Cassandra . Iface 
 List < Row > rows ; 
 try 
 { 
 - rows = StorageProxy . readProtocol ( commands , consistency _ level ) ; 
 + try 
 + { 
 + schedule ( ) ; 
 + rows = StorageProxy . readProtocol ( commands , consistency _ level ) ; 
 + } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 catch ( TimeoutException e ) 
 { 
 @ @ - 424 , 21 + 455 , 30 @ @ public class CassandraServer implements Cassandra . Iface 
 
 private void doInsert ( ConsistencyLevel consistency _ level , List < RowMutation > mutations ) throws UnavailableException , TimedOutException 
 { 
 - if ( consistency _ level = = ConsistencyLevel . ZERO ) 
 - { 
 - StorageProxy . mutate ( mutations ) ; 
 - } 
 - else 
 + try 
 { 
 - try 
 + schedule ( ) ; 
 + 
 + if ( consistency _ level = = ConsistencyLevel . ZERO ) 
 { 
 - 	 StorageProxy . mutateBlocking ( mutations , consistency _ level ) ; 
 + StorageProxy . mutate ( mutations ) ; 
 } 
 - catch ( TimeoutException e ) 
 + else 
 { 
 - 	 throw new TimedOutException ( ) ; 
 + try 
 + { 
 + StorageProxy . mutateBlocking ( mutations , consistency _ level ) ; 
 + } 
 + catch ( TimeoutException e ) 
 + { 
 + throw new TimedOutException ( ) ; 
 + } 
 } 
 } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 
 public Map < String , Map < String , String > > describe _ keyspace ( String table ) throws NotFoundException 
 @ @ - 503 , 7 + 543 , 15 @ @ public class CassandraServer implements Cassandra . Iface 
 { 
 bounds = new Bounds ( p . getToken ( range . start _ key ) , p . getToken ( range . end _ key ) ) ; 
 } 
 - rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , range . count ) , consistency _ level ) ; 
 + try 
 + { 
 + schedule ( ) ; 
 + rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , range . count ) , consistency _ level ) ; 
 + } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 assert rows ! = null ; 
 } 
 catch ( TimeoutException e ) 
 @ @ - 681 , 6 + 729 , 22 @ @ public class CassandraServer implements Cassandra . Iface 
 } 
 } 
 
 + / * * 
 + * Schedule the current thread for access to the required services 
 + * / 
 + private void schedule ( ) 
 + { 
 + requestScheduler . queue ( Thread . currentThread ( ) , requestSchedulerId . get ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Release count for the used up resources 
 + * / 
 + private void release ( ) 
 + { 
 + requestScheduler . release ( ) ; 
 + } 
 + 
 public String system _ add _ column _ family ( CfDef cf _ def ) throws InvalidRequestException , TException 
 { 
 checkKeyspaceAndLoginAuthorized ( AccessLevel . FULL ) ; 
 @ @ - 919 , 6 + 983 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 checkKeyspaceAndLoginAuthorized ( AccessLevel . FULL ) ; 
 try 
 { 
 + schedule ( ) ; 
 StorageProxy . truncateBlocking ( keySpace . get ( ) , cfname ) ; 
 } 
 catch ( TimeoutException e ) 
 @ @ - 929 , 9 + 994 , 14 @ @ public class CassandraServer implements Cassandra . Iface 
 { 
 throw ( UnavailableException ) new UnavailableException ( ) . initCause ( e ) ; 
 } 
 + finally 
 + { 
 + release ( ) ; 
 + } 
 } 
 
 - public void set _ keyspace ( String keyspace ) throws InvalidRequestException , TException { 
 + public void set _ keyspace ( String keyspace ) throws InvalidRequestException , TException 
 + { 
 if ( DatabaseDescriptor . getTableDefinition ( keyspace ) = = null ) 
 { 
 throw new InvalidRequestException ( " Keyspace does not exist " ) ; 
 @ @ - 941 , 7 + 1011 , 8 @ @ public class CassandraServer implements Cassandra . Iface 
 if ( keySpace . get ( ) ! = null & & ! keySpace . get ( ) . equals ( keyspace ) ) 
 loginDone . set ( AccessLevel . NONE ) ; 
 
 - keySpace . set ( keyspace ) ; 
 + keySpace . set ( keyspace ) ; 
 + requestSchedulerId . set ( keyspace ) ; 
 } 
 
 public Map < String , List < String > > check _ schema _ agreement ( ) throws TException , InvalidRequestException 
 diff - - git a / test / conf / cassandra . yaml b / test / conf / cassandra . yaml 
 index f279206 . . b9e9047 100644 
 - - - a / test / conf / cassandra . yaml 
 + + + b / test / conf / cassandra . yaml 
 @ @ - 19 , 6 + 19 , 8 @ @ memtable _ operations _ in _ millions : 0 . 00002 
 seeds : 
 - 127 . 0 . 0 . 2 
 endpoint _ snitch : org . apache . cassandra . locator . SimpleSnitch 
 + request _ scheduler : org . apache . cassandra . scheduler . RoundRobinScheduler 
 + request _ scheduler _ id : keyspace 
 keyspaces : 
 - name : Keyspace1 
 replica _ placement _ strategy : org . apache . cassandra . locator . RackUnawareStrategy 
 diff - - git a / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java 
 new file mode 100644 
 index 0000000 . . 1b4913e 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / scheduler / RoundRobinSchedulerTest . java 
 @ @ - 0 , 0 + 1 , 150 @ @ 
 + package org . apache . cassandra . scheduler ; 
 + 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + import static org . junit . Assert . * ; 
 + 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . SynchronousQueue ; 
 + import java . util . concurrent . ThreadPoolExecutor ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import org . apache . cassandra . config . RequestSchedulerOptions ; 
 + import org . junit . After ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + 
 + public class RoundRobinSchedulerTest 
 + { 
 + ExecutorService executor ; 
 + IRequestScheduler scheduler ; 
 + AtomicInteger counter = new AtomicInteger ( 0 ) ; 
 + static final String KS1 = " TestKeyspace " ; 
 + static final String KS2 = " DevKeyspace " ; 
 + static final String KS3 = " ProdKeyspace " ; 
 + 
 + Map < Integer , Integer > testValues = new HashMap < Integer , Integer > ( ) ; 
 + 
 + @ Before 
 + public void setUp ( ) 
 + { 
 + RequestSchedulerOptions options = new RequestSchedulerOptions ( ) ; 
 + options . throttle _ limit = 5 ; 
 + scheduler = new RoundRobinScheduler ( options ) ; 
 + SynchronousQueue < Runnable > queue = new SynchronousQueue < Runnable > ( ) ; 
 + 
 + executor = new ThreadPoolExecutor ( 20 , 
 + Integer . MAX _ VALUE , 
 + 60 * 1000 , 
 + TimeUnit . MILLISECONDS , 
 + queue ) ; 
 + / / When there are large no . of threads , the results become 
 + / / more unpredictable because of the JVM thread scheduling 
 + / / and that will be very hard to provide a consistent test 
 + runKs1 ( 1 , 10 ) ; 
 + runKs2 ( 11 , 13 ) ; 
 + runKs3 ( 14 , 15 ) ; 
 + 
 + try 
 + { 
 + Thread . sleep ( 3000 ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testScheduling ( ) 
 + { 
 + for ( Integer initialValue : testValues . keySet ( ) ) 
 + { 
 + / / Makes sure , requests to each keyspace get an equal chance 
 + / / Requests from one keyspace will not block requests from 
 + / / another keyspacce 
 + if ( initialValue > 10 ) 
 + { 
 + assertTrue ( initialValue > = testValues . get ( initialValue ) ) ; 
 + } 
 + } 
 + } 
 + 
 + @ After 
 + public void shutDown ( ) 
 + { 
 + executor . shutdown ( ) ; 
 + } 
 + 
 + private void runKs1 ( int start , int end ) 
 + { 
 + for ( int i = start ; i < = end ; i + + ) 
 + { 
 + executor . execute ( new Worker ( KS1 , i ) ) ; 
 + } 
 + } 
 + 
 + private void runKs2 ( int start , int end ) 
 + { 
 + for ( int i = start ; i < = end ; i + + ) 
 + { 
 + executor . execute ( new Worker ( KS2 , i ) ) ; 
 + } 
 + } 
 + 
 + private void runKs3 ( int start , int end ) 
 + { 
 + for ( int i = start ; i < = end ; i + + ) 
 + { 
 + executor . execute ( new Worker ( KS3 , i ) ) ; 
 + } 
 + } 
 + 
 + class Worker implements Runnable 
 + { 
 + String id ; 
 + int initialCount ; 
 + int runCount ; 
 + 
 + public Worker ( String id , int count ) 
 + { 
 + this . id = id ; 
 + initialCount = count ; 
 + } 
 + 
 + public void run ( ) 
 + { 
 + scheduler . queue ( Thread . currentThread ( ) , id ) ; 
 + 
 + runCount = counter . incrementAndGet ( ) ; 
 + 
 + synchronized ( scheduler ) 
 + { 
 + testValues . put ( initialCount , runCount ) ; 
 + } 
 + scheduler . release ( ) ; 
 + } 
 + } 
 + }
