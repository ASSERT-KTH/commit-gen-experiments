BLEU SCORE: 0.021721299903135396

TEST MSG: Add support for CQL in pygments ( proper syntax highlighting )
GENERATED MSG: add nodeprobe cli tool . patch by Eric Evans ; reviewed by jbellis for CASSANDRA - 211

TEST DIFF (one line): diff - - git a / doc / source / _ util / cql . py b / doc / source / _ util / cql . py <nl> new file mode 100644 <nl> index 0000000 . . b1c8cde <nl> - - - / dev / null <nl> + + + b / doc / source / _ util / cql . py <nl> @ @ - 0 , 0 + 1 , 267 @ @ <nl> + # - * - coding : utf - 8 - * - <nl> + " " " <nl> + CQL pygments lexer <nl> + ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ <nl> + <nl> + Lexer for the Cassandra Query Language ( CQL ) . <nl> + <nl> + This is heavily inspired from the pygments SQL lexer ( and the Postgres one in particular ) but adapted to CQL <nl> + keywords and specificities . <nl> + <nl> + TODO : This has been hacked quickly , but once it ' s more tested , we could submit it upstream . <nl> + In particular , we have alot of keywords whose meaning depends on the context and we could potentially improve <nl> + their handling . For instance , SET is a keyword , but also a type name ( that ' s why currently we also consider <nl> + map and list as keywords , not types ; we could disambiguate by looking if there is a ' < ' afterwards ) . Or things <nl> + like USERS , which can is used in some documentation example as a table name but is a keyword too ( we could <nl> + only consider it a keyword if after LIST for instance ) . Similarly , type nanes are not reserved , so they and <nl> + are sometime used as column identifiers ( also , timestamp is both a type and a keyword ) . I " think " we can <nl> + somewhat disambiguate through " states " , but unclear how far it ' s worth going . <nl> + <nl> + We could also add the predefined functions ? <nl> + " " " <nl> + <nl> + import re <nl> + <nl> + from pygments . lexer import Lexer , RegexLexer , do _ insertions , bygroups , words <nl> + from pygments . token import Punctuation , Whitespace , Error , \ <nl> + Text , Comment , Operator , Keyword , Name , String , Number , Generic , Literal <nl> + from pygments . lexers import get _ lexer _ by _ name , ClassNotFound <nl> + from pygments . util import iteritems <nl> + <nl> + _ _ all _ _ = [ ' CQLLexer ' ] <nl> + <nl> + language _ re = re . compile ( r " \ s + LANGUAGE \ s + ' ? ( \ w + ) ' ? " , re . IGNORECASE ) <nl> + <nl> + KEYWORDS = ( <nl> + ' SELECT ' , <nl> + ' FROM ' , <nl> + ' AS ' , <nl> + ' WHERE ' , <nl> + ' AND ' , <nl> + ' KEY ' , <nl> + ' KEYS ' , <nl> + ' ENTRIES ' , <nl> + ' FULL ' , <nl> + ' INSERT ' , <nl> + ' UPDATE ' , <nl> + ' WITH ' , <nl> + ' LIMIT ' , <nl> + ' PER ' , <nl> + ' PARTITION ' , <nl> + ' USING ' , <nl> + ' USE ' , <nl> + ' DISTINCT ' , <nl> + ' COUNT ' , <nl> + ' SET ' , <nl> + ' BEGIN ' , <nl> + ' UNLOGGED ' , <nl> + ' BATCH ' , <nl> + ' APPLY ' , <nl> + ' TRUNCATE ' , <nl> + ' DELETE ' , <nl> + ' IN ' , <nl> + ' CREATE ' , <nl> + ' KEYSPACE ' , <nl> + ' SCHEMA ' , <nl> + ' KEYSPACES ' , <nl> + ' COLUMNFAMILY ' , <nl> + ' TABLE ' , <nl> + ' MATERIALIZED ' , <nl> + ' VIEW ' , <nl> + ' INDEX ' , <nl> + ' CUSTOM ' , <nl> + ' ON ' , <nl> + ' TO ' , <nl> + ' DROP ' , <nl> + ' PRIMARY ' , <nl> + ' INTO ' , <nl> + ' VALUES ' , <nl> + ' TIMESTAMP ' , <nl> + ' TTL ' , <nl> + ' CAST ' , <nl> + ' ALTER ' , <nl> + ' RENAME ' , <nl> + ' ADD ' , <nl> + ' TYPE ' , <nl> + ' COMPACT ' , <nl> + ' STORAGE ' , <nl> + ' ORDER ' , <nl> + ' BY ' , <nl> + ' ASC ' , <nl> + ' DESC ' , <nl> + ' ALLOW ' , <nl> + ' FILTERING ' , <nl> + ' IF ' , <nl> + ' IS ' , <nl> + ' CONTAINS ' , <nl> + ' GRANT ' , <nl> + ' ALL ' , <nl> + ' PERMISSION ' , <nl> + ' PERMISSIONS ' , <nl> + ' OF ' , <nl> + ' REVOKE ' , <nl> + ' MODIFY ' , <nl> + ' AUTHORIZE ' , <nl> + ' DESCRIBE ' , <nl> + ' EXECUTE ' , <nl> + ' NORECURSIVE ' , <nl> + ' MBEAN ' , <nl> + ' MBEANS ' , <nl> + ' USER ' , <nl> + ' USERS ' , <nl> + ' ROLE ' , <nl> + ' ROLES ' , <nl> + ' SUPERUSER ' , <nl> + ' NOSUPERUSER ' , <nl> + ' PASSWORD ' , <nl> + ' LOGIN ' , <nl> + ' NOLOGIN ' , <nl> + ' OPTIONS ' , <nl> + ' CLUSTERING ' , <nl> + ' TOKEN ' , <nl> + ' WRITETIME ' , <nl> + ' NULL ' , <nl> + ' NOT ' , <nl> + ' EXISTS ' , <nl> + ' MAP ' , <nl> + ' LIST ' , <nl> + ' NAN ' , <nl> + ' INFINITY ' , <nl> + ' TUPLE ' , <nl> + ' TRIGGER ' , <nl> + ' STATIC ' , <nl> + ' FROZEN ' , <nl> + ' FUNCTION ' , <nl> + ' FUNCTIONS ' , <nl> + ' AGGREGATE ' , <nl> + ' SFUNC ' , <nl> + ' STYPE ' , <nl> + ' FINALFUNC ' , <nl> + ' INITCOND ' , <nl> + ' RETURNS ' , <nl> + ' CALLED ' , <nl> + ' INPUT ' , <nl> + ' LANGUAGE ' , <nl> + ' OR ' , <nl> + ' REPLACE ' , <nl> + ' JSON ' , <nl> + ' LIKE ' , <nl> + ) <nl> + <nl> + DATATYPES = ( <nl> + ' ASCII ' , <nl> + ' BIGINT ' , <nl> + ' BLOB ' , <nl> + ' BOOLEAN ' , <nl> + ' COUNTER ' , <nl> + ' DATE ' , <nl> + ' DECIMAL ' , <nl> + ' DOUBLE ' , <nl> + ' EMPTY ' , <nl> + ' FLOAT ' , <nl> + ' INET ' , <nl> + ' INT ' , <nl> + ' SMALLINT ' , <nl> + ' TEXT ' , <nl> + ' TIME ' , <nl> + ' TIMESTAMP ' , <nl> + ' TIMEUUID ' , <nl> + ' TINYINT ' , <nl> + ' UUID ' , <nl> + ' VARCHAR ' , <nl> + ' VARINT ' , <nl> + ) <nl> + <nl> + def language _ callback ( lexer , match ) : <nl> + " " " Parse the content of a $ - string using a lexer <nl> + <nl> + The lexer is chosen looking for a nearby LANGUAGE or assumed as <nl> + java if no LANGUAGE has been found . <nl> + " " " <nl> + l = None <nl> + m = language _ re . match ( lexer . text [ max ( 0 , match . start ( ) - 100 ) : match . start ( ) ] ) <nl> + if m is not None : <nl> + l = lexer . _ get _ lexer ( m . group ( 1 ) ) <nl> + else : <nl> + l = lexer . _ get _ lexer ( ' java ' ) <nl> + <nl> + # 1 = $ , 2 = delimiter , 3 = $ <nl> + yield ( match . start ( 1 ) , String , match . group ( 1 ) ) <nl> + yield ( match . start ( 2 ) , String . Delimiter , match . group ( 2 ) ) <nl> + yield ( match . start ( 3 ) , String , match . group ( 3 ) ) <nl> + # 4 = string contents <nl> + if l : <nl> + for x in l . get _ tokens _ unprocessed ( match . group ( 4 ) ) : <nl> + yield x <nl> + else : <nl> + yield ( match . start ( 4 ) , String , match . group ( 4 ) ) <nl> + # 5 = $ , 6 = delimiter , 7 = $ <nl> + yield ( match . start ( 5 ) , String , match . group ( 5 ) ) <nl> + yield ( match . start ( 6 ) , String . Delimiter , match . group ( 6 ) ) <nl> + yield ( match . start ( 7 ) , String , match . group ( 7 ) ) <nl> + <nl> + <nl> + class CQLLexer ( RegexLexer ) : <nl> + " " " <nl> + Lexer for the Cassandra Query Language . <nl> + " " " <nl> + <nl> + name = ' Cassandra Query Language ' <nl> + aliases = [ ' cql ' ] <nl> + filenames = [ ' * . cql ' ] <nl> + mimetypes = [ ' text / x - cql ' ] <nl> + <nl> + flags = re . IGNORECASE <nl> + tokens = { <nl> + ' root ' : [ <nl> + ( r ' \ s + ' , Text ) , <nl> + ( r ' - - . * \ n ? ' , Comment . Single ) , <nl> + ( r ' / / . * \ n ? ' , Comment . Single ) , <nl> + ( r ' / \ * ' , Comment . Multiline , ' multiline - comments ' ) , <nl> + ( r ' ( ' + ' | ' . join ( s . replace ( " " , " \ s + " ) <nl> + for s in DATATYPES ) <nl> + + r ' ) \ b ' , Name . Builtin ) , <nl> + ( words ( KEYWORDS , suffix = r ' \ b ' ) , Keyword ) , <nl> + ( r ' [ + * / < > = ~ ! @ # % ^ & | ` ? - ] + ' , Operator ) , <nl> + ( r ' \ $ \ d + ' , Name . Variable ) , <nl> + <nl> + # Using Number instead of the more accurate Literal because the latter don ' t seem to e highlighted in most <nl> + # styles <nl> + ( r ' [ 0 - 9a - fA - F ] { 8 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 12 } ' , Number ) , # UUIDs <nl> + ( r ' 0x [ 0 - 9a - fA - F ] + ' , Number ) , # Blobs <nl> + <nl> + ( r ' ( [ 0 - 9 ] * \ . [ 0 - 9 ] * | [ 0 - 9 ] + ) ( e [ + - ] ? [ 0 - 9 ] + ) ? ' , Number . Float ) , <nl> + ( r ' [ 0 - 9 ] + ' , Number . Integer ) , <nl> + ( r " ( ( ? : E | U & ) ? ) ( ' ) " , bygroups ( String . Affix , String . Single ) , ' string ' ) , <nl> + # quoted identifier <nl> + ( r ' ( ( ? : U & ) ? ) ( " ) ' , bygroups ( String . Affix , String . Name ) , ' quoted - ident ' ) , <nl> + ( r ' ( ? s ) ( \ $ ) ( [ ^ $ ] * ) ( \ $ ) ( . * ? ) ( \ $ ) ( \ 2 ) ( \ $ ) ' , language _ callback ) , <nl> + ( r ' [ a - z _ ] \ w * ' , Name ) , <nl> + ( r ' [ ; : ( ) \ [ \ ] { } , . ] ' , Punctuation ) , <nl> + ] , <nl> + ' multiline - comments ' : [ <nl> + ( r ' / \ * ' , Comment . Multiline , ' multiline - comments ' ) , <nl> + ( r ' \ * / ' , Comment . Multiline , ' # pop ' ) , <nl> + ( r ' [ ^ / * ] + ' , Comment . Multiline ) , <nl> + ( r ' [ / * ] ' , Comment . Multiline ) <nl> + ] , <nl> + ' string ' : [ <nl> + ( r " [ ^ ' ] + " , String . Single ) , <nl> + ( r " ' ' " , String . Single ) , <nl> + ( r " ' " , String . Single , ' # pop ' ) , <nl> + ] , <nl> + ' quoted - ident ' : [ <nl> + ( r ' [ ^ " ] + ' , String . Name ) , <nl> + ( r ' " " ' , String . Name ) , <nl> + ( r ' " ' , String . Name , ' # pop ' ) , <nl> + ] , <nl> + } <nl> + <nl> + def get _ tokens _ unprocessed ( self , text , * args ) : <nl> + # Have a copy of the entire text to be used by ` language _ callback ` . <nl> + self . text = text <nl> + for x in RegexLexer . get _ tokens _ unprocessed ( self , text , * args ) : <nl> + yield x <nl> + <nl> + def _ get _ lexer ( self , lang ) : <nl> + return get _ lexer _ by _ name ( lang , * * self . options ) <nl> diff - - git a / doc / source / conf . py b / doc / source / conf . py <nl> index 2b36353 . . 63697aa 100644 <nl> - - - a / doc / source / conf . py <nl> + + + b / doc / source / conf . py <nl> @ @ - 21 , 7 + 21 , 7 @ @ <nl> # <nl> # This file is execfile ( ) d with the current directory set to its containing <nl> # dir . <nl> - import re <nl> + import re , sys , os <nl> <nl> # Finds out the version ( so we don ' t have to manually edit that file every <nl> # time we change the version ) <nl> @ @ - 32 , 6 + 32 , 10 @ @ with open ( cassandra _ build _ file ) as f : <nl> raise RuntimeException ( " Problem finding version in build . xml file , this shouldn ' t happen . " ) <nl> cassandra _ version = m . group ( 1 ) <nl> <nl> + def setup ( sphinx ) : <nl> + sys . path . insert ( 0 , os . path . abspath ( ' . / source / _ util ' ) ) <nl> + from cql import CQLLexer <nl> + sphinx . add _ lexer ( " cql " , CQLLexer ( ) ) <nl> <nl> <nl> # - - General configuration - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> diff - - git a / doc / source / cql / appendices . rst b / doc / source / cql / appendices . rst <nl> index c4bb839 . . 8c63a32 100644 <nl> - - - a / doc / source / cql / appendices . rst <nl> + + + b / doc / source / cql / appendices . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> Appendices <nl> - - - - - - - - - - <nl> diff - - git a / doc / source / cql / changes . rst b / doc / source / cql / changes . rst <nl> index 263df13 . . d9aea85 100644 <nl> - - - a / doc / source / cql / changes . rst <nl> + + + b / doc / source / cql / changes . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> Changes <nl> - - - - - - - <nl> diff - - git a / doc / source / cql / ddl . rst b / doc / source / cql / ddl . rst <nl> index 7f3431a . . 029c1cb 100644 <nl> - - - a / doc / source / cql / ddl . rst <nl> + + + b / doc / source / cql / ddl . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ data - definition : <nl> <nl> diff - - git a / doc / source / cql / definitions . rst b / doc / source / cql / definitions . rst <nl> index 6c3b522 . . e54bcd7 100644 <nl> - - - a / doc / source / cql / definitions . rst <nl> + + + b / doc / source / cql / definitions . rst <nl> @ @ - 16 , 6 + 16 , 8 @ @ <nl> <nl> . . _ UUID : https : / / en . wikipedia . org / wiki / Universally _ unique _ identifier <nl> <nl> + . . highlight : : cql <nl> + <nl> Definitions <nl> - - - - - - - - - - - <nl> <nl> @ @ - 145 , 7 + 147 , 7 @ @ Multi - line comments are also supported through enclosure within ` ` / * ` ` and ` ` * / ` <nl> <nl> : : <nl> <nl> - — This is a comment <nl> + - - This is a comment <nl> / / This is a comment too <nl> / * This is <nl> a multi - line comment * / <nl> diff - - git a / doc / source / cql / dml . rst b / doc / source / cql / dml . rst <nl> index 989c0ca . . b5f9e9f 100644 <nl> - - - a / doc / source / cql / dml . rst <nl> + + + b / doc / source / cql / dml . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ data - manipulation : <nl> <nl> @ @ - 202 , 7 + 202 , 7 @ @ The tuple notation may also be used for ` ` IN ` ` clauses on clustering columns : : <nl> <nl> SELECT * FROM posts <nl> WHERE userid = ' john doe ' <nl> - AND ( blog _ title , posted _ at ) IN ( ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ) , ( ' Extreme Chess ' , ' 2014 - 06 - 01 ' ) ) <nl> + AND ( blog _ title , posted _ at ) IN ( ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ' ) , ( ' Extreme Chess ' , ' 2014 - 06 - 01 ' ) ) <nl> <nl> The ` ` CONTAINS ` ` operator may only be used on collection columns ( lists , sets , and maps ) . In the case of maps , <nl> ` ` CONTAINS ` ` applies to the map values . The ` ` CONTAINS KEY ` ` operator may only be used on map columns and applies to the <nl> diff - - git a / doc / source / cql / functions . rst b / doc / source / cql / functions . rst <nl> index efcdf32 . . 47026cd 100644 <nl> - - - a / doc / source / cql / functions . rst <nl> + + + b / doc / source / cql / functions . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ cql - functions : <nl> <nl> @ @ - 39 , 6 + 39 , 11 @ @ functions . <nl> evil , but no sandbox is perfect so using user - defined functions is opt - in ) . See the ` ` enable _ user _ defined _ functions ` ` <nl> in ` ` cassandra . yaml ` ` to enable them . <nl> <nl> + A function is identifier by its name : <nl> + <nl> + . . productionlist : : <nl> + function _ name : [ ` keyspace _ name ` ' . ' ] ` name ` <nl> + <nl> . . _ scalar - functions : <nl> <nl> Scalar functions <nl> @ @ - 236 , 15 + 241 , 15 @ @ User - defined functions can be used in ` ` SELECT ` ` , ` ` INSERT ` ` and ` ` UPDATE ` ` stat <nl> The implicitly available ` ` udfContext ` ` field ( or binding for script UDFs ) provides the necessary functionality to <nl> create new UDT and tuple values : : <nl> <nl> - CREATE TYPE custom \ _ type ( txt text , i int ) ; <nl> + CREATE TYPE custom _ type ( txt text , i int ) ; <nl> CREATE FUNCTION fct \ _ using \ _ udt ( somearg int ) <nl> RETURNS NULL ON NULL INPUT <nl> - RETURNS custom \ _ type <nl> + RETURNS custom _ type <nl> LANGUAGE java <nl> AS $ $ <nl> UDTValue udt = udfContext . newReturnUDTValue ( ) ; <nl> - udt . setString ( “ txt ” , “ some string ” ) ; <nl> - udt . setInt ( “ i ” , 42 ) ; <nl> + udt . setString ( " txt " , " some string " ) ; <nl> + udt . setInt ( " i " , 42 ) ; <nl> return udt ; <nl> $ $ ; <nl> <nl> @ @ - 447 , 25 + 452 , 25 @ @ statement ) : : <nl> CALLED ON NULL INPUT <nl> RETURNS tuple <nl> LANGUAGE java <nl> - AS ' <nl> + AS $ $ <nl> if ( val ! = null ) { <nl> state . setInt ( 0 , state . getInt ( 0 ) + 1 ) ; <nl> state . setLong ( 1 , state . getLong ( 1 ) + val . intValue ( ) ) ; <nl> } <nl> return state ; <nl> - ' ; <nl> + $ $ ; <nl> <nl> CREATE OR REPLACE FUNCTION averageFinal ( state tuple < int , bigint > ) <nl> CALLED ON NULL INPUT <nl> RETURNS double <nl> LANGUAGE java <nl> - AS ' <nl> + AS $ $ <nl> double r = 0 ; <nl> if ( state . getInt ( 0 ) = = 0 ) return null ; <nl> r = state . getLong ( 1 ) ; <nl> r / = state . getInt ( 0 ) ; <nl> - return Double . valueOf ® ; <nl> - ' ; <nl> + return Double . valueOf ( r ) ; <nl> + $ $ ; <nl> <nl> CREATE OR REPLACE AGGREGATE average ( int ) <nl> SFUNC averageState <nl> diff - - git a / doc / source / cql / indexes . rst b / doc / source / cql / indexes . rst <nl> index fbe5827 . . 81fe429 100644 <nl> - - - a / doc / source / cql / indexes . rst <nl> + + + b / doc / source / cql / indexes . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ secondary - indexes : <nl> <nl> diff - - git a / doc / source / cql / json . rst b / doc / source / cql / json . rst <nl> index 6482fd6 . . f83f16c 100644 <nl> - - - a / doc / source / cql / json . rst <nl> + + + b / doc / source / cql / json . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ cql - json : <nl> <nl> diff - - git a / doc / source / cql / mvs . rst b / doc / source / cql / mvs . rst <nl> index 84c18e0 . . aabea10 100644 <nl> - - - a / doc / source / cql / mvs . rst <nl> + + + b / doc / source / cql / mvs . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ materialized - views : <nl> <nl> @ @ - 46 , 7 + 46 , 7 @ @ For instance : : <nl> SELECT * FROM monkeySpecies <nl> WHERE population IS NOT NULL AND species IS NOT NULL <nl> PRIMARY KEY ( population , species ) <nl> - WITH comment = ‘ Allow query by population instead of species ’ ; <nl> + WITH comment = ' Allow query by population instead of species ' ; <nl> <nl> The ` ` CREATE MATERIALIZED VIEW ` ` statement creates a new materialized view . Each such view is a set of * rows * which <nl> corresponds to rows which are present in the underlying , or base , table specified in the ` ` SELECT ` ` statement . A <nl> diff - - git a / doc / source / cql / security . rst b / doc / source / cql / security . rst <nl> index aa65383 . . 9efe27f 100644 <nl> - - - a / doc / source / cql / security . rst <nl> + + + b / doc / source / cql / security . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ cql - security : <nl> <nl> @ @ - 26 , 6 + 26 , 11 @ @ Security <nl> Database Roles <nl> ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ <nl> <nl> + CQL uses database roles to represent users and group of users . Syntactically , a role is defined by : <nl> + <nl> + . . productionlist : : <nl> + role _ name : ` identifier ` | ` string ` <nl> + <nl> . . _ create - role - statement : <nl> <nl> CREATE ROLE <nl> diff - - git a / doc / source / cql / triggers . rst b / doc / source / cql / triggers . rst <nl> index 3bba72d . . db3f53e 100644 <nl> - - - a / doc / source / cql / triggers . rst <nl> + + + b / doc / source / cql / triggers . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ cql - triggers : <nl> <nl> diff - - git a / doc / source / cql / types . rst b / doc / source / cql / types . rst <nl> index 80cf864 . . e452f35 100644 <nl> - - - a / doc / source / cql / types . rst <nl> + + + b / doc / source / cql / types . rst <nl> @ @ - 14 , 7 + 14 , 7 @ @ <nl> . . See the License for the specific language governing permissions and <nl> . . limitations under the License . <nl> <nl> - . . highlight : : sql <nl> + . . highlight : : cql <nl> <nl> . . _ UUID : https : / / en . wikipedia . org / wiki / Universally _ unique _ identifier <nl>
NEAREST DIFF (one line): diff - - git a / bin / nodeprobe b / bin / nodeprobe <nl> new file mode 100755 <nl> index 0000000 . . beb3c36 <nl> - - - / dev / null <nl> + + + b / bin / nodeprobe <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + # ! / bin / sh <nl> + # Licensed to the Apache Software Foundation ( ASF ) under one <nl> + # or more contributor license agreements . See the NOTICE file <nl> + # distributed with this work for additional information <nl> + # regarding copyright ownership . The ASF licenses this file <nl> + # to you under the Apache License , Version 2 . 0 ( the <nl> + # " License " ) ; you may not use this file except in compliance <nl> + # with the License . You may obtain a copy of the License at <nl> + # <nl> + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + # <nl> + # Unless required by applicable law or agreed to in writing , software <nl> + # distributed under the License is distributed on an " AS IS " BASIS , <nl> + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + # See the License for the specific language governing permissions and <nl> + # limitations under the License . <nl> + <nl> + <nl> + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then <nl> + for include in / usr / share / cassandra / cassandra . in . sh \ <nl> + / usr / local / share / cassandra / cassandra . in . sh \ <nl> + / opt / cassandra / cassandra . in . sh \ <nl> + ` dirname $ 0 ` / cassandra . in . sh ; do <nl> + if [ - r $ include ] ; then <nl> + . $ include <nl> + break <nl> + fi <nl> + done <nl> + elif [ - r $ CASSANDRA _ INCLUDE ] ; then <nl> + . $ CASSANDRA _ INCLUDE <nl> + fi <nl> + <nl> + if [ - z $ CASSANDRA _ CONF - o - z $ CLASSPATH ] ; then <nl> + echo " You must set the CASSANDRA _ CONF and CLASSPATH vars " > & 2 <nl> + exit 1 <nl> + fi <nl> + <nl> + # Special - case path variables . <nl> + case " ` uname ` " in <nl> + CYGWIN * ) <nl> + CLASSPATH = ` cygpath - p - w " $ CLASSPATH " ` <nl> + CASSANDRA _ CONF = ` cygpath - p - w " $ CASSANDRA _ CONF " ` <nl> + ; ; <nl> + esac <nl> + <nl> + java - cp $ CLASSPATH - Dstorage - config = $ CASSANDRA _ CONF \ <nl> + org . apache . cassandra . tools . NodeProbe $ @ <nl> + <nl> + # vi : ai sw = 4 ts = 4 tw = 0 et <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> new file mode 100644 <nl> index 0000000 . . b1acbb4 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 0 , 0 + 1 , 434 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . tools ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . io . PrintStream ; <nl> + import java . lang . management . ManagementFactory ; <nl> + import java . lang . management . MemoryMXBean ; <nl> + import java . lang . management . MemoryUsage ; <nl> + import java . lang . management . RuntimeMXBean ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import javax . management . JMX ; <nl> + import javax . management . MBeanServerConnection ; <nl> + import javax . management . MalformedObjectNameException ; <nl> + import javax . management . ObjectName ; <nl> + import javax . management . remote . JMXConnector ; <nl> + import javax . management . remote . JMXConnectorFactory ; <nl> + import javax . management . remote . JMXServiceURL ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . net . EndPoint ; <nl> + import org . apache . cassandra . service . StorageServiceMBean ; <nl> + import org . apache . commons . cli . CommandLine ; <nl> + import org . apache . commons . cli . CommandLineParser ; <nl> + import org . apache . commons . cli . HelpFormatter ; <nl> + import org . apache . commons . cli . Option ; <nl> + import org . apache . commons . cli . Options ; <nl> + import org . apache . commons . cli . ParseException ; <nl> + import org . apache . commons . cli . PosixParser ; <nl> + <nl> + / * * <nl> + * JMX client operations for Cassandra . <nl> + * / <nl> + public class NodeProbe <nl> + { <nl> + private static final String fmtUrl = " service : jmx : rmi : / / / jndi / rmi : / / % s : % d / jmxrmi " ; <nl> + private static final String ssObjName = " org . apache . cassandra . service : type = StorageService " ; <nl> + private static final String HOST _ OPTION = " host " ; <nl> + private static final String PORT _ OPTION = " port " ; <nl> + private static final int defaultPort = 8080 ; <nl> + private static Options options = null ; <nl> + private CommandLine cmd = null ; <nl> + private String host ; <nl> + private int port ; <nl> + <nl> + private MBeanServerConnection mbeanServerConn ; <nl> + private StorageServiceMBean ssProxy ; <nl> + private MemoryMXBean memProxy ; <nl> + private RuntimeMXBean runtimeProxy ; <nl> + <nl> + static <nl> + { <nl> + options = new Options ( ) ; <nl> + Option optHost = new Option ( HOST _ OPTION , true , " node hostname or ip address " ) ; <nl> + optHost . setRequired ( true ) ; <nl> + options . addOption ( optHost ) ; <nl> + options . addOption ( PORT _ OPTION , true , " remote jmx agent port number " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using command - line arguments . <nl> + * <nl> + * @ param cmdArgs list of arguments passed on the command line <nl> + * @ throws ParseException for missing required , or unrecognized options <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + private NodeProbe ( String [ ] cmdArgs ) throws ParseException , IOException <nl> + { <nl> + parseArgs ( cmdArgs ) ; <nl> + this . host = cmd . getOptionValue ( HOST _ OPTION ) ; <nl> + <nl> + String portNum = cmd . getOptionValue ( PORT _ OPTION ) ; <nl> + if ( portNum ! = null ) <nl> + { <nl> + try <nl> + { <nl> + this . port = Integer . parseInt ( portNum ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ParseException ( " Port must be a number " ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + this . port = defaultPort ; <nl> + } <nl> + <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using the specified JMX host and port . <nl> + * <nl> + * @ param host hostname or IP address of the JMX agent <nl> + * @ param port TCP port of the remote JMX agent <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + public NodeProbe ( String host , int port ) throws IOException <nl> + { <nl> + this . host = host ; <nl> + this . port = port ; <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Creates a NodeProbe using the specified JMX host and default port . <nl> + * <nl> + * @ param host hostname or IP address of the JMX agent <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + public NodeProbe ( String host ) throws IOException <nl> + { <nl> + this . host = host ; <nl> + this . port = defaultPort ; <nl> + connect ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Create a connection to the JMX agent and setup the M [ X ] Bean proxies . <nl> + * <nl> + * @ throws IOException on connection failures <nl> + * / <nl> + private void connect ( ) throws IOException <nl> + { <nl> + JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; <nl> + JMXConnector jmxc = JMXConnectorFactory . connect ( jmxUrl , null ) ; <nl> + mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; <nl> + <nl> + try <nl> + { <nl> + ObjectName name = new ObjectName ( ssObjName ) ; <nl> + ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; <nl> + } catch ( MalformedObjectNameException e ) <nl> + { <nl> + throw new RuntimeException ( <nl> + " Invalid ObjectName ? Please report this as a bug . " , e ) ; <nl> + } <nl> + <nl> + memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , <nl> + ManagementFactory . MEMORY _ MXBEAN _ NAME , MemoryMXBean . class ) ; <nl> + runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( <nl> + mbeanServerConn , ManagementFactory . RUNTIME _ MXBEAN _ NAME , RuntimeMXBean . class ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve a map of range to end points that describe the ring topology <nl> + * of a Cassandra cluster . <nl> + * <nl> + * @ return mapping of ranges to end points <nl> + * / <nl> + public Map < Range , List < EndPoint > > getRangeToEndpointMap ( ) <nl> + { <nl> + return ssProxy . getRangeToEndPointMap ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve the list of live nodes in the cluster , where " liveness " is <nl> + * determined by the failure detector of the node being queried . The <nl> + * returned string is a space delimited list of host : port end points . <nl> + * <nl> + * @ return space delimited list of nodes <nl> + * / <nl> + public String getLiveNodes ( ) <nl> + { <nl> + return ssProxy . getLiveNodes ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve the list of unreachable nodes in the cluster , as determined <nl> + * by this node ' s failure detector . The returned string is a space <nl> + * delimited list of host : port end points . <nl> + * <nl> + * @ return space delimited list of nodes <nl> + * / <nl> + public String getUnreachableNodes ( ) <nl> + { <nl> + return ssProxy . getUnreachableNodes ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Fetch a string representation of the token . <nl> + * <nl> + * @ return a string token <nl> + * / <nl> + public String getToken ( ) <nl> + { <nl> + return ssProxy . getToken ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Return the generation value for this node . <nl> + * <nl> + * @ return generation number <nl> + * / <nl> + public int getCurrentGenerationNumber ( ) <nl> + { <nl> + return ssProxy . getCurrentGenerationNumber ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve a textual representation of the on - disk size of data <nl> + * stored on this node . <nl> + * <nl> + * @ return the size description <nl> + * / <nl> + public String getLoadInfo ( ) <nl> + { <nl> + return ssProxy . getLoadInfo ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Trigger a cleanup of keys on all tables . <nl> + * / <nl> + public void forceTableCleanup ( ) <nl> + { <nl> + ssProxy . forceTableCleanup ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Trigger compaction of all tables . <nl> + * / <nl> + public void forceTableCompaction ( ) <nl> + { <nl> + ssProxy . forceTableCompaction ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Write a textual representation of the Cassandra ring . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printRing ( PrintStream outs ) <nl> + { <nl> + Map < Range , List < EndPoint > > rangeMap = getRangeToEndpointMap ( ) ; <nl> + <nl> + / / Print range - to - endpoint mapping <nl> + int counter = 0 ; <nl> + for ( Range range : rangeMap . keySet ( ) ) { <nl> + List < EndPoint > endpoints = rangeMap . get ( range ) ; <nl> + <nl> + outs . print ( String . format ( " % - 46s " , range . left ( ) ) ) ; <nl> + outs . print ( String . format ( " % 2d " , endpoints . size ( ) ) ) ; <nl> + outs . print ( String . format ( " % - 15s " , endpoints . get ( 0 ) . getHost ( ) ) ) ; <nl> + <nl> + String asciiRingArt ; <nl> + if ( counter = = 0 ) <nl> + { <nl> + asciiRingArt = " | < - - | " ; <nl> + } <nl> + else if ( counter = = ( rangeMap . size ( ) - 1 ) ) <nl> + { <nl> + asciiRingArt = " | - - > | " ; <nl> + } <nl> + else <nl> + { <nl> + if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) = = 0 ) ) <nl> + { <nl> + asciiRingArt = " v | " ; <nl> + } <nl> + else if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) ! = 0 ) ) <nl> + { <nl> + asciiRingArt = " | ^ " ; <nl> + } <nl> + else <nl> + { <nl> + asciiRingArt = " | | " ; <nl> + } <nl> + } <nl> + outs . println ( asciiRingArt ) ; <nl> + <nl> + counter + + ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Write a list of nodes with corresponding status . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printCluster ( PrintStream outs ) <nl> + { <nl> + for ( String upNode : getLiveNodes ( ) . split ( " \ \ s + " ) ) <nl> + { <nl> + if ( upNode . length ( ) > 0 ) <nl> + { <nl> + outs . println ( String . format ( " % - 21s up " , upNode ) ) ; <nl> + } <nl> + } <nl> + <nl> + for ( String downNode : getUnreachableNodes ( ) . split ( " \ \ s + " ) ) <nl> + { <nl> + if ( downNode . length ( ) > 0 ) <nl> + { <nl> + outs . println ( String . format ( " % - 21s down " , downNode ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Write node information . <nl> + * <nl> + * @ param outs the stream to write to <nl> + * / <nl> + public void printInfo ( PrintStream outs ) <nl> + { <nl> + outs . println ( getToken ( ) ) ; <nl> + outs . println ( String . format ( " % - 17s : % s " , " Load Info " , getLoadInfo ( ) ) ) ; <nl> + outs . println ( String . format ( " % - 17s : % s " , " Generation No " , getCurrentGenerationNumber ( ) ) ) ; <nl> + <nl> + / / Uptime <nl> + long secondsUp = runtimeProxy . getUptime ( ) / 1000 ; <nl> + outs . println ( String . format ( " % - 17s : % d " , " Uptime ( seconds ) " , secondsUp ) ) ; <nl> + <nl> + / / Memory usage <nl> + MemoryUsage heapUsage = memProxy . getHeapMemoryUsage ( ) ; <nl> + double memUsed = ( double ) heapUsage . getUsed ( ) / ( 1024 * 1024 ) ; <nl> + double memMax = ( double ) heapUsage . getMax ( ) / ( 1024 * 1024 ) ; <nl> + outs . println ( String . format ( " % - 17s : % . 2f / % . 2f " , " Heap Memory ( MB ) " , memUsed , memMax ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Retrieve any non - option arguments passed on the command line . <nl> + * <nl> + * @ return non - option command args <nl> + * / <nl> + private String [ ] getArgs ( ) <nl> + { <nl> + return cmd . getArgs ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Parse the supplied command line arguments . <nl> + * <nl> + * @ param args arguments passed on the command line <nl> + * @ throws ParseException for missing required , or unrecognized options <nl> + * / <nl> + private void parseArgs ( String [ ] args ) throws ParseException <nl> + { <nl> + CommandLineParser parser = new PosixParser ( ) ; <nl> + cmd = parser . parse ( options , args ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Prints usage information to stdout . <nl> + * / <nl> + private static void printUsage ( ) <nl> + { <nl> + HelpFormatter hf = new HelpFormatter ( ) ; <nl> + String header = String . format ( <nl> + " % nAvailable commands : ring , cluster , info , cleanup , compact " ) ; <nl> + String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; <nl> + hf . printHelp ( usage , " " , options , header ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ param args <nl> + * / <nl> + public static void main ( String [ ] args ) <nl> + { <nl> + NodeProbe probe = null ; <nl> + try <nl> + { <nl> + probe = new NodeProbe ( args ) ; <nl> + } <nl> + catch ( ParseException pe ) <nl> + { <nl> + System . err . println ( pe . getMessage ( ) ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + catch ( IOException ioe ) <nl> + { <nl> + System . err . println ( " Error connecting to remote JMX agent ! " ) ; <nl> + ioe . printStackTrace ( ) ; <nl> + System . exit ( 3 ) ; <nl> + } <nl> + <nl> + if ( probe . getArgs ( ) . length < 1 ) <nl> + { <nl> + System . err . println ( " Missing argument for command . " ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + / / Execute the requested command . <nl> + String cmdName = probe . getArgs ( ) [ 0 ] ; <nl> + if ( cmdName . equals ( " ring " ) ) <nl> + { <nl> + probe . printRing ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " cluster " ) ) <nl> + { <nl> + probe . printCluster ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " info " ) ) <nl> + { <nl> + probe . printInfo ( System . out ) ; <nl> + } <nl> + else if ( cmdName . equals ( " cleanup " ) ) <nl> + { <nl> + probe . forceTableCleanup ( ) ; <nl> + } <nl> + else if ( cmdName . equals ( " compact " ) ) <nl> + { <nl> + probe . forceTableCompaction ( ) ; <nl> + } <nl> + else <nl> + { <nl> + System . err . println ( " Unrecognized command : " + cmdName + " . " ) ; <nl> + NodeProbe . printUsage ( ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + System . exit ( 0 ) ; <nl> + } <nl> + <nl> + }

TEST DIFF:
diff - - git a / doc / source / _ util / cql . py b / doc / source / _ util / cql . py 
 new file mode 100644 
 index 0000000 . . b1c8cde 
 - - - / dev / null 
 + + + b / doc / source / _ util / cql . py 
 @ @ - 0 , 0 + 1 , 267 @ @ 
 + # - * - coding : utf - 8 - * - 
 + " " " 
 + CQL pygments lexer 
 + ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 
 + 
 + Lexer for the Cassandra Query Language ( CQL ) . 
 + 
 + This is heavily inspired from the pygments SQL lexer ( and the Postgres one in particular ) but adapted to CQL 
 + keywords and specificities . 
 + 
 + TODO : This has been hacked quickly , but once it ' s more tested , we could submit it upstream . 
 + In particular , we have alot of keywords whose meaning depends on the context and we could potentially improve 
 + their handling . For instance , SET is a keyword , but also a type name ( that ' s why currently we also consider 
 + map and list as keywords , not types ; we could disambiguate by looking if there is a ' < ' afterwards ) . Or things 
 + like USERS , which can is used in some documentation example as a table name but is a keyword too ( we could 
 + only consider it a keyword if after LIST for instance ) . Similarly , type nanes are not reserved , so they and 
 + are sometime used as column identifiers ( also , timestamp is both a type and a keyword ) . I " think " we can 
 + somewhat disambiguate through " states " , but unclear how far it ' s worth going . 
 + 
 + We could also add the predefined functions ? 
 + " " " 
 + 
 + import re 
 + 
 + from pygments . lexer import Lexer , RegexLexer , do _ insertions , bygroups , words 
 + from pygments . token import Punctuation , Whitespace , Error , \ 
 + Text , Comment , Operator , Keyword , Name , String , Number , Generic , Literal 
 + from pygments . lexers import get _ lexer _ by _ name , ClassNotFound 
 + from pygments . util import iteritems 
 + 
 + _ _ all _ _ = [ ' CQLLexer ' ] 
 + 
 + language _ re = re . compile ( r " \ s + LANGUAGE \ s + ' ? ( \ w + ) ' ? " , re . IGNORECASE ) 
 + 
 + KEYWORDS = ( 
 + ' SELECT ' , 
 + ' FROM ' , 
 + ' AS ' , 
 + ' WHERE ' , 
 + ' AND ' , 
 + ' KEY ' , 
 + ' KEYS ' , 
 + ' ENTRIES ' , 
 + ' FULL ' , 
 + ' INSERT ' , 
 + ' UPDATE ' , 
 + ' WITH ' , 
 + ' LIMIT ' , 
 + ' PER ' , 
 + ' PARTITION ' , 
 + ' USING ' , 
 + ' USE ' , 
 + ' DISTINCT ' , 
 + ' COUNT ' , 
 + ' SET ' , 
 + ' BEGIN ' , 
 + ' UNLOGGED ' , 
 + ' BATCH ' , 
 + ' APPLY ' , 
 + ' TRUNCATE ' , 
 + ' DELETE ' , 
 + ' IN ' , 
 + ' CREATE ' , 
 + ' KEYSPACE ' , 
 + ' SCHEMA ' , 
 + ' KEYSPACES ' , 
 + ' COLUMNFAMILY ' , 
 + ' TABLE ' , 
 + ' MATERIALIZED ' , 
 + ' VIEW ' , 
 + ' INDEX ' , 
 + ' CUSTOM ' , 
 + ' ON ' , 
 + ' TO ' , 
 + ' DROP ' , 
 + ' PRIMARY ' , 
 + ' INTO ' , 
 + ' VALUES ' , 
 + ' TIMESTAMP ' , 
 + ' TTL ' , 
 + ' CAST ' , 
 + ' ALTER ' , 
 + ' RENAME ' , 
 + ' ADD ' , 
 + ' TYPE ' , 
 + ' COMPACT ' , 
 + ' STORAGE ' , 
 + ' ORDER ' , 
 + ' BY ' , 
 + ' ASC ' , 
 + ' DESC ' , 
 + ' ALLOW ' , 
 + ' FILTERING ' , 
 + ' IF ' , 
 + ' IS ' , 
 + ' CONTAINS ' , 
 + ' GRANT ' , 
 + ' ALL ' , 
 + ' PERMISSION ' , 
 + ' PERMISSIONS ' , 
 + ' OF ' , 
 + ' REVOKE ' , 
 + ' MODIFY ' , 
 + ' AUTHORIZE ' , 
 + ' DESCRIBE ' , 
 + ' EXECUTE ' , 
 + ' NORECURSIVE ' , 
 + ' MBEAN ' , 
 + ' MBEANS ' , 
 + ' USER ' , 
 + ' USERS ' , 
 + ' ROLE ' , 
 + ' ROLES ' , 
 + ' SUPERUSER ' , 
 + ' NOSUPERUSER ' , 
 + ' PASSWORD ' , 
 + ' LOGIN ' , 
 + ' NOLOGIN ' , 
 + ' OPTIONS ' , 
 + ' CLUSTERING ' , 
 + ' TOKEN ' , 
 + ' WRITETIME ' , 
 + ' NULL ' , 
 + ' NOT ' , 
 + ' EXISTS ' , 
 + ' MAP ' , 
 + ' LIST ' , 
 + ' NAN ' , 
 + ' INFINITY ' , 
 + ' TUPLE ' , 
 + ' TRIGGER ' , 
 + ' STATIC ' , 
 + ' FROZEN ' , 
 + ' FUNCTION ' , 
 + ' FUNCTIONS ' , 
 + ' AGGREGATE ' , 
 + ' SFUNC ' , 
 + ' STYPE ' , 
 + ' FINALFUNC ' , 
 + ' INITCOND ' , 
 + ' RETURNS ' , 
 + ' CALLED ' , 
 + ' INPUT ' , 
 + ' LANGUAGE ' , 
 + ' OR ' , 
 + ' REPLACE ' , 
 + ' JSON ' , 
 + ' LIKE ' , 
 + ) 
 + 
 + DATATYPES = ( 
 + ' ASCII ' , 
 + ' BIGINT ' , 
 + ' BLOB ' , 
 + ' BOOLEAN ' , 
 + ' COUNTER ' , 
 + ' DATE ' , 
 + ' DECIMAL ' , 
 + ' DOUBLE ' , 
 + ' EMPTY ' , 
 + ' FLOAT ' , 
 + ' INET ' , 
 + ' INT ' , 
 + ' SMALLINT ' , 
 + ' TEXT ' , 
 + ' TIME ' , 
 + ' TIMESTAMP ' , 
 + ' TIMEUUID ' , 
 + ' TINYINT ' , 
 + ' UUID ' , 
 + ' VARCHAR ' , 
 + ' VARINT ' , 
 + ) 
 + 
 + def language _ callback ( lexer , match ) : 
 + " " " Parse the content of a $ - string using a lexer 
 + 
 + The lexer is chosen looking for a nearby LANGUAGE or assumed as 
 + java if no LANGUAGE has been found . 
 + " " " 
 + l = None 
 + m = language _ re . match ( lexer . text [ max ( 0 , match . start ( ) - 100 ) : match . start ( ) ] ) 
 + if m is not None : 
 + l = lexer . _ get _ lexer ( m . group ( 1 ) ) 
 + else : 
 + l = lexer . _ get _ lexer ( ' java ' ) 
 + 
 + # 1 = $ , 2 = delimiter , 3 = $ 
 + yield ( match . start ( 1 ) , String , match . group ( 1 ) ) 
 + yield ( match . start ( 2 ) , String . Delimiter , match . group ( 2 ) ) 
 + yield ( match . start ( 3 ) , String , match . group ( 3 ) ) 
 + # 4 = string contents 
 + if l : 
 + for x in l . get _ tokens _ unprocessed ( match . group ( 4 ) ) : 
 + yield x 
 + else : 
 + yield ( match . start ( 4 ) , String , match . group ( 4 ) ) 
 + # 5 = $ , 6 = delimiter , 7 = $ 
 + yield ( match . start ( 5 ) , String , match . group ( 5 ) ) 
 + yield ( match . start ( 6 ) , String . Delimiter , match . group ( 6 ) ) 
 + yield ( match . start ( 7 ) , String , match . group ( 7 ) ) 
 + 
 + 
 + class CQLLexer ( RegexLexer ) : 
 + " " " 
 + Lexer for the Cassandra Query Language . 
 + " " " 
 + 
 + name = ' Cassandra Query Language ' 
 + aliases = [ ' cql ' ] 
 + filenames = [ ' * . cql ' ] 
 + mimetypes = [ ' text / x - cql ' ] 
 + 
 + flags = re . IGNORECASE 
 + tokens = { 
 + ' root ' : [ 
 + ( r ' \ s + ' , Text ) , 
 + ( r ' - - . * \ n ? ' , Comment . Single ) , 
 + ( r ' / / . * \ n ? ' , Comment . Single ) , 
 + ( r ' / \ * ' , Comment . Multiline , ' multiline - comments ' ) , 
 + ( r ' ( ' + ' | ' . join ( s . replace ( " " , " \ s + " ) 
 + for s in DATATYPES ) 
 + + r ' ) \ b ' , Name . Builtin ) , 
 + ( words ( KEYWORDS , suffix = r ' \ b ' ) , Keyword ) , 
 + ( r ' [ + * / < > = ~ ! @ # % ^ & | ` ? - ] + ' , Operator ) , 
 + ( r ' \ $ \ d + ' , Name . Variable ) , 
 + 
 + # Using Number instead of the more accurate Literal because the latter don ' t seem to e highlighted in most 
 + # styles 
 + ( r ' [ 0 - 9a - fA - F ] { 8 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 4 } - [ 0 - 9a - fA - F ] { 12 } ' , Number ) , # UUIDs 
 + ( r ' 0x [ 0 - 9a - fA - F ] + ' , Number ) , # Blobs 
 + 
 + ( r ' ( [ 0 - 9 ] * \ . [ 0 - 9 ] * | [ 0 - 9 ] + ) ( e [ + - ] ? [ 0 - 9 ] + ) ? ' , Number . Float ) , 
 + ( r ' [ 0 - 9 ] + ' , Number . Integer ) , 
 + ( r " ( ( ? : E | U & ) ? ) ( ' ) " , bygroups ( String . Affix , String . Single ) , ' string ' ) , 
 + # quoted identifier 
 + ( r ' ( ( ? : U & ) ? ) ( " ) ' , bygroups ( String . Affix , String . Name ) , ' quoted - ident ' ) , 
 + ( r ' ( ? s ) ( \ $ ) ( [ ^ $ ] * ) ( \ $ ) ( . * ? ) ( \ $ ) ( \ 2 ) ( \ $ ) ' , language _ callback ) , 
 + ( r ' [ a - z _ ] \ w * ' , Name ) , 
 + ( r ' [ ; : ( ) \ [ \ ] { } , . ] ' , Punctuation ) , 
 + ] , 
 + ' multiline - comments ' : [ 
 + ( r ' / \ * ' , Comment . Multiline , ' multiline - comments ' ) , 
 + ( r ' \ * / ' , Comment . Multiline , ' # pop ' ) , 
 + ( r ' [ ^ / * ] + ' , Comment . Multiline ) , 
 + ( r ' [ / * ] ' , Comment . Multiline ) 
 + ] , 
 + ' string ' : [ 
 + ( r " [ ^ ' ] + " , String . Single ) , 
 + ( r " ' ' " , String . Single ) , 
 + ( r " ' " , String . Single , ' # pop ' ) , 
 + ] , 
 + ' quoted - ident ' : [ 
 + ( r ' [ ^ " ] + ' , String . Name ) , 
 + ( r ' " " ' , String . Name ) , 
 + ( r ' " ' , String . Name , ' # pop ' ) , 
 + ] , 
 + } 
 + 
 + def get _ tokens _ unprocessed ( self , text , * args ) : 
 + # Have a copy of the entire text to be used by ` language _ callback ` . 
 + self . text = text 
 + for x in RegexLexer . get _ tokens _ unprocessed ( self , text , * args ) : 
 + yield x 
 + 
 + def _ get _ lexer ( self , lang ) : 
 + return get _ lexer _ by _ name ( lang , * * self . options ) 
 diff - - git a / doc / source / conf . py b / doc / source / conf . py 
 index 2b36353 . . 63697aa 100644 
 - - - a / doc / source / conf . py 
 + + + b / doc / source / conf . py 
 @ @ - 21 , 7 + 21 , 7 @ @ 
 # 
 # This file is execfile ( ) d with the current directory set to its containing 
 # dir . 
 - import re 
 + import re , sys , os 
 
 # Finds out the version ( so we don ' t have to manually edit that file every 
 # time we change the version ) 
 @ @ - 32 , 6 + 32 , 10 @ @ with open ( cassandra _ build _ file ) as f : 
 raise RuntimeException ( " Problem finding version in build . xml file , this shouldn ' t happen . " ) 
 cassandra _ version = m . group ( 1 ) 
 
 + def setup ( sphinx ) : 
 + sys . path . insert ( 0 , os . path . abspath ( ' . / source / _ util ' ) ) 
 + from cql import CQLLexer 
 + sphinx . add _ lexer ( " cql " , CQLLexer ( ) ) 
 
 
 # - - General configuration - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 diff - - git a / doc / source / cql / appendices . rst b / doc / source / cql / appendices . rst 
 index c4bb839 . . 8c63a32 100644 
 - - - a / doc / source / cql / appendices . rst 
 + + + b / doc / source / cql / appendices . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 Appendices 
 - - - - - - - - - - 
 diff - - git a / doc / source / cql / changes . rst b / doc / source / cql / changes . rst 
 index 263df13 . . d9aea85 100644 
 - - - a / doc / source / cql / changes . rst 
 + + + b / doc / source / cql / changes . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 Changes 
 - - - - - - - 
 diff - - git a / doc / source / cql / ddl . rst b / doc / source / cql / ddl . rst 
 index 7f3431a . . 029c1cb 100644 
 - - - a / doc / source / cql / ddl . rst 
 + + + b / doc / source / cql / ddl . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ data - definition : 
 
 diff - - git a / doc / source / cql / definitions . rst b / doc / source / cql / definitions . rst 
 index 6c3b522 . . e54bcd7 100644 
 - - - a / doc / source / cql / definitions . rst 
 + + + b / doc / source / cql / definitions . rst 
 @ @ - 16 , 6 + 16 , 8 @ @ 
 
 . . _ UUID : https : / / en . wikipedia . org / wiki / Universally _ unique _ identifier 
 
 + . . highlight : : cql 
 + 
 Definitions 
 - - - - - - - - - - - 
 
 @ @ - 145 , 7 + 147 , 7 @ @ Multi - line comments are also supported through enclosure within ` ` / * ` ` and ` ` * / ` 
 
 : : 
 
 - — This is a comment 
 + - - This is a comment 
 / / This is a comment too 
 / * This is 
 a multi - line comment * / 
 diff - - git a / doc / source / cql / dml . rst b / doc / source / cql / dml . rst 
 index 989c0ca . . b5f9e9f 100644 
 - - - a / doc / source / cql / dml . rst 
 + + + b / doc / source / cql / dml . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ data - manipulation : 
 
 @ @ - 202 , 7 + 202 , 7 @ @ The tuple notation may also be used for ` ` IN ` ` clauses on clustering columns : : 
 
 SELECT * FROM posts 
 WHERE userid = ' john doe ' 
 - AND ( blog _ title , posted _ at ) IN ( ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ) , ( ' Extreme Chess ' , ' 2014 - 06 - 01 ' ) ) 
 + AND ( blog _ title , posted _ at ) IN ( ( ' John ' ' s Blog ' , ' 2012 - 01 - 01 ' ) , ( ' Extreme Chess ' , ' 2014 - 06 - 01 ' ) ) 
 
 The ` ` CONTAINS ` ` operator may only be used on collection columns ( lists , sets , and maps ) . In the case of maps , 
 ` ` CONTAINS ` ` applies to the map values . The ` ` CONTAINS KEY ` ` operator may only be used on map columns and applies to the 
 diff - - git a / doc / source / cql / functions . rst b / doc / source / cql / functions . rst 
 index efcdf32 . . 47026cd 100644 
 - - - a / doc / source / cql / functions . rst 
 + + + b / doc / source / cql / functions . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ cql - functions : 
 
 @ @ - 39 , 6 + 39 , 11 @ @ functions . 
 evil , but no sandbox is perfect so using user - defined functions is opt - in ) . See the ` ` enable _ user _ defined _ functions ` ` 
 in ` ` cassandra . yaml ` ` to enable them . 
 
 + A function is identifier by its name : 
 + 
 + . . productionlist : : 
 + function _ name : [ ` keyspace _ name ` ' . ' ] ` name ` 
 + 
 . . _ scalar - functions : 
 
 Scalar functions 
 @ @ - 236 , 15 + 241 , 15 @ @ User - defined functions can be used in ` ` SELECT ` ` , ` ` INSERT ` ` and ` ` UPDATE ` ` stat 
 The implicitly available ` ` udfContext ` ` field ( or binding for script UDFs ) provides the necessary functionality to 
 create new UDT and tuple values : : 
 
 - CREATE TYPE custom \ _ type ( txt text , i int ) ; 
 + CREATE TYPE custom _ type ( txt text , i int ) ; 
 CREATE FUNCTION fct \ _ using \ _ udt ( somearg int ) 
 RETURNS NULL ON NULL INPUT 
 - RETURNS custom \ _ type 
 + RETURNS custom _ type 
 LANGUAGE java 
 AS $ $ 
 UDTValue udt = udfContext . newReturnUDTValue ( ) ; 
 - udt . setString ( “ txt ” , “ some string ” ) ; 
 - udt . setInt ( “ i ” , 42 ) ; 
 + udt . setString ( " txt " , " some string " ) ; 
 + udt . setInt ( " i " , 42 ) ; 
 return udt ; 
 $ $ ; 
 
 @ @ - 447 , 25 + 452 , 25 @ @ statement ) : : 
 CALLED ON NULL INPUT 
 RETURNS tuple 
 LANGUAGE java 
 - AS ' 
 + AS $ $ 
 if ( val ! = null ) { 
 state . setInt ( 0 , state . getInt ( 0 ) + 1 ) ; 
 state . setLong ( 1 , state . getLong ( 1 ) + val . intValue ( ) ) ; 
 } 
 return state ; 
 - ' ; 
 + $ $ ; 
 
 CREATE OR REPLACE FUNCTION averageFinal ( state tuple < int , bigint > ) 
 CALLED ON NULL INPUT 
 RETURNS double 
 LANGUAGE java 
 - AS ' 
 + AS $ $ 
 double r = 0 ; 
 if ( state . getInt ( 0 ) = = 0 ) return null ; 
 r = state . getLong ( 1 ) ; 
 r / = state . getInt ( 0 ) ; 
 - return Double . valueOf ® ; 
 - ' ; 
 + return Double . valueOf ( r ) ; 
 + $ $ ; 
 
 CREATE OR REPLACE AGGREGATE average ( int ) 
 SFUNC averageState 
 diff - - git a / doc / source / cql / indexes . rst b / doc / source / cql / indexes . rst 
 index fbe5827 . . 81fe429 100644 
 - - - a / doc / source / cql / indexes . rst 
 + + + b / doc / source / cql / indexes . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ secondary - indexes : 
 
 diff - - git a / doc / source / cql / json . rst b / doc / source / cql / json . rst 
 index 6482fd6 . . f83f16c 100644 
 - - - a / doc / source / cql / json . rst 
 + + + b / doc / source / cql / json . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ cql - json : 
 
 diff - - git a / doc / source / cql / mvs . rst b / doc / source / cql / mvs . rst 
 index 84c18e0 . . aabea10 100644 
 - - - a / doc / source / cql / mvs . rst 
 + + + b / doc / source / cql / mvs . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ materialized - views : 
 
 @ @ - 46 , 7 + 46 , 7 @ @ For instance : : 
 SELECT * FROM monkeySpecies 
 WHERE population IS NOT NULL AND species IS NOT NULL 
 PRIMARY KEY ( population , species ) 
 - WITH comment = ‘ Allow query by population instead of species ’ ; 
 + WITH comment = ' Allow query by population instead of species ' ; 
 
 The ` ` CREATE MATERIALIZED VIEW ` ` statement creates a new materialized view . Each such view is a set of * rows * which 
 corresponds to rows which are present in the underlying , or base , table specified in the ` ` SELECT ` ` statement . A 
 diff - - git a / doc / source / cql / security . rst b / doc / source / cql / security . rst 
 index aa65383 . . 9efe27f 100644 
 - - - a / doc / source / cql / security . rst 
 + + + b / doc / source / cql / security . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ cql - security : 
 
 @ @ - 26 , 6 + 26 , 11 @ @ Security 
 Database Roles 
 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 
 
 + CQL uses database roles to represent users and group of users . Syntactically , a role is defined by : 
 + 
 + . . productionlist : : 
 + role _ name : ` identifier ` | ` string ` 
 + 
 . . _ create - role - statement : 
 
 CREATE ROLE 
 diff - - git a / doc / source / cql / triggers . rst b / doc / source / cql / triggers . rst 
 index 3bba72d . . db3f53e 100644 
 - - - a / doc / source / cql / triggers . rst 
 + + + b / doc / source / cql / triggers . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ cql - triggers : 
 
 diff - - git a / doc / source / cql / types . rst b / doc / source / cql / types . rst 
 index 80cf864 . . e452f35 100644 
 - - - a / doc / source / cql / types . rst 
 + + + b / doc / source / cql / types . rst 
 @ @ - 14 , 7 + 14 , 7 @ @ 
 . . See the License for the specific language governing permissions and 
 . . limitations under the License . 
 
 - . . highlight : : sql 
 + . . highlight : : cql 
 
 . . _ UUID : https : / / en . wikipedia . org / wiki / Universally _ unique _ identifier 


NEAREST DIFF:
diff - - git a / bin / nodeprobe b / bin / nodeprobe 
 new file mode 100755 
 index 0000000 . . beb3c36 
 - - - / dev / null 
 + + + b / bin / nodeprobe 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + # ! / bin / sh 
 + # Licensed to the Apache Software Foundation ( ASF ) under one 
 + # or more contributor license agreements . See the NOTICE file 
 + # distributed with this work for additional information 
 + # regarding copyright ownership . The ASF licenses this file 
 + # to you under the Apache License , Version 2 . 0 ( the 
 + # " License " ) ; you may not use this file except in compliance 
 + # with the License . You may obtain a copy of the License at 
 + # 
 + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + # 
 + # Unless required by applicable law or agreed to in writing , software 
 + # distributed under the License is distributed on an " AS IS " BASIS , 
 + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + # See the License for the specific language governing permissions and 
 + # limitations under the License . 
 + 
 + 
 + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then 
 + for include in / usr / share / cassandra / cassandra . in . sh \ 
 + / usr / local / share / cassandra / cassandra . in . sh \ 
 + / opt / cassandra / cassandra . in . sh \ 
 + ` dirname $ 0 ` / cassandra . in . sh ; do 
 + if [ - r $ include ] ; then 
 + . $ include 
 + break 
 + fi 
 + done 
 + elif [ - r $ CASSANDRA _ INCLUDE ] ; then 
 + . $ CASSANDRA _ INCLUDE 
 + fi 
 + 
 + if [ - z $ CASSANDRA _ CONF - o - z $ CLASSPATH ] ; then 
 + echo " You must set the CASSANDRA _ CONF and CLASSPATH vars " > & 2 
 + exit 1 
 + fi 
 + 
 + # Special - case path variables . 
 + case " ` uname ` " in 
 + CYGWIN * ) 
 + CLASSPATH = ` cygpath - p - w " $ CLASSPATH " ` 
 + CASSANDRA _ CONF = ` cygpath - p - w " $ CASSANDRA _ CONF " ` 
 + ; ; 
 + esac 
 + 
 + java - cp $ CLASSPATH - Dstorage - config = $ CASSANDRA _ CONF \ 
 + org . apache . cassandra . tools . NodeProbe $ @ 
 + 
 + # vi : ai sw = 4 ts = 4 tw = 0 et 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 new file mode 100644 
 index 0000000 . . b1acbb4 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 0 , 0 + 1 , 434 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . tools ; 
 + 
 + import java . io . IOException ; 
 + import java . io . PrintStream ; 
 + import java . lang . management . ManagementFactory ; 
 + import java . lang . management . MemoryMXBean ; 
 + import java . lang . management . MemoryUsage ; 
 + import java . lang . management . RuntimeMXBean ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import javax . management . JMX ; 
 + import javax . management . MBeanServerConnection ; 
 + import javax . management . MalformedObjectNameException ; 
 + import javax . management . ObjectName ; 
 + import javax . management . remote . JMXConnector ; 
 + import javax . management . remote . JMXConnectorFactory ; 
 + import javax . management . remote . JMXServiceURL ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . net . EndPoint ; 
 + import org . apache . cassandra . service . StorageServiceMBean ; 
 + import org . apache . commons . cli . CommandLine ; 
 + import org . apache . commons . cli . CommandLineParser ; 
 + import org . apache . commons . cli . HelpFormatter ; 
 + import org . apache . commons . cli . Option ; 
 + import org . apache . commons . cli . Options ; 
 + import org . apache . commons . cli . ParseException ; 
 + import org . apache . commons . cli . PosixParser ; 
 + 
 + / * * 
 + * JMX client operations for Cassandra . 
 + * / 
 + public class NodeProbe 
 + { 
 + private static final String fmtUrl = " service : jmx : rmi : / / / jndi / rmi : / / % s : % d / jmxrmi " ; 
 + private static final String ssObjName = " org . apache . cassandra . service : type = StorageService " ; 
 + private static final String HOST _ OPTION = " host " ; 
 + private static final String PORT _ OPTION = " port " ; 
 + private static final int defaultPort = 8080 ; 
 + private static Options options = null ; 
 + private CommandLine cmd = null ; 
 + private String host ; 
 + private int port ; 
 + 
 + private MBeanServerConnection mbeanServerConn ; 
 + private StorageServiceMBean ssProxy ; 
 + private MemoryMXBean memProxy ; 
 + private RuntimeMXBean runtimeProxy ; 
 + 
 + static 
 + { 
 + options = new Options ( ) ; 
 + Option optHost = new Option ( HOST _ OPTION , true , " node hostname or ip address " ) ; 
 + optHost . setRequired ( true ) ; 
 + options . addOption ( optHost ) ; 
 + options . addOption ( PORT _ OPTION , true , " remote jmx agent port number " ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using command - line arguments . 
 + * 
 + * @ param cmdArgs list of arguments passed on the command line 
 + * @ throws ParseException for missing required , or unrecognized options 
 + * @ throws IOException on connection failures 
 + * / 
 + private NodeProbe ( String [ ] cmdArgs ) throws ParseException , IOException 
 + { 
 + parseArgs ( cmdArgs ) ; 
 + this . host = cmd . getOptionValue ( HOST _ OPTION ) ; 
 + 
 + String portNum = cmd . getOptionValue ( PORT _ OPTION ) ; 
 + if ( portNum ! = null ) 
 + { 
 + try 
 + { 
 + this . port = Integer . parseInt ( portNum ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ParseException ( " Port must be a number " ) ; 
 + } 
 + } 
 + else 
 + { 
 + this . port = defaultPort ; 
 + } 
 + 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using the specified JMX host and port . 
 + * 
 + * @ param host hostname or IP address of the JMX agent 
 + * @ param port TCP port of the remote JMX agent 
 + * @ throws IOException on connection failures 
 + * / 
 + public NodeProbe ( String host , int port ) throws IOException 
 + { 
 + this . host = host ; 
 + this . port = port ; 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Creates a NodeProbe using the specified JMX host and default port . 
 + * 
 + * @ param host hostname or IP address of the JMX agent 
 + * @ throws IOException on connection failures 
 + * / 
 + public NodeProbe ( String host ) throws IOException 
 + { 
 + this . host = host ; 
 + this . port = defaultPort ; 
 + connect ( ) ; 
 + } 
 + 
 + / * * 
 + * Create a connection to the JMX agent and setup the M [ X ] Bean proxies . 
 + * 
 + * @ throws IOException on connection failures 
 + * / 
 + private void connect ( ) throws IOException 
 + { 
 + JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; 
 + JMXConnector jmxc = JMXConnectorFactory . connect ( jmxUrl , null ) ; 
 + mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; 
 + 
 + try 
 + { 
 + ObjectName name = new ObjectName ( ssObjName ) ; 
 + ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; 
 + } catch ( MalformedObjectNameException e ) 
 + { 
 + throw new RuntimeException ( 
 + " Invalid ObjectName ? Please report this as a bug . " , e ) ; 
 + } 
 + 
 + memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , 
 + ManagementFactory . MEMORY _ MXBEAN _ NAME , MemoryMXBean . class ) ; 
 + runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( 
 + mbeanServerConn , ManagementFactory . RUNTIME _ MXBEAN _ NAME , RuntimeMXBean . class ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve a map of range to end points that describe the ring topology 
 + * of a Cassandra cluster . 
 + * 
 + * @ return mapping of ranges to end points 
 + * / 
 + public Map < Range , List < EndPoint > > getRangeToEndpointMap ( ) 
 + { 
 + return ssProxy . getRangeToEndPointMap ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve the list of live nodes in the cluster , where " liveness " is 
 + * determined by the failure detector of the node being queried . The 
 + * returned string is a space delimited list of host : port end points . 
 + * 
 + * @ return space delimited list of nodes 
 + * / 
 + public String getLiveNodes ( ) 
 + { 
 + return ssProxy . getLiveNodes ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve the list of unreachable nodes in the cluster , as determined 
 + * by this node ' s failure detector . The returned string is a space 
 + * delimited list of host : port end points . 
 + * 
 + * @ return space delimited list of nodes 
 + * / 
 + public String getUnreachableNodes ( ) 
 + { 
 + return ssProxy . getUnreachableNodes ( ) ; 
 + } 
 + 
 + / * * 
 + * Fetch a string representation of the token . 
 + * 
 + * @ return a string token 
 + * / 
 + public String getToken ( ) 
 + { 
 + return ssProxy . getToken ( ) ; 
 + } 
 + 
 + / * * 
 + * Return the generation value for this node . 
 + * 
 + * @ return generation number 
 + * / 
 + public int getCurrentGenerationNumber ( ) 
 + { 
 + return ssProxy . getCurrentGenerationNumber ( ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve a textual representation of the on - disk size of data 
 + * stored on this node . 
 + * 
 + * @ return the size description 
 + * / 
 + public String getLoadInfo ( ) 
 + { 
 + return ssProxy . getLoadInfo ( ) ; 
 + } 
 + 
 + / * * 
 + * Trigger a cleanup of keys on all tables . 
 + * / 
 + public void forceTableCleanup ( ) 
 + { 
 + ssProxy . forceTableCleanup ( ) ; 
 + } 
 + 
 + / * * 
 + * Trigger compaction of all tables . 
 + * / 
 + public void forceTableCompaction ( ) 
 + { 
 + ssProxy . forceTableCompaction ( ) ; 
 + } 
 + 
 + / * * 
 + * Write a textual representation of the Cassandra ring . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printRing ( PrintStream outs ) 
 + { 
 + Map < Range , List < EndPoint > > rangeMap = getRangeToEndpointMap ( ) ; 
 + 
 + / / Print range - to - endpoint mapping 
 + int counter = 0 ; 
 + for ( Range range : rangeMap . keySet ( ) ) { 
 + List < EndPoint > endpoints = rangeMap . get ( range ) ; 
 + 
 + outs . print ( String . format ( " % - 46s " , range . left ( ) ) ) ; 
 + outs . print ( String . format ( " % 2d " , endpoints . size ( ) ) ) ; 
 + outs . print ( String . format ( " % - 15s " , endpoints . get ( 0 ) . getHost ( ) ) ) ; 
 + 
 + String asciiRingArt ; 
 + if ( counter = = 0 ) 
 + { 
 + asciiRingArt = " | < - - | " ; 
 + } 
 + else if ( counter = = ( rangeMap . size ( ) - 1 ) ) 
 + { 
 + asciiRingArt = " | - - > | " ; 
 + } 
 + else 
 + { 
 + if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) = = 0 ) ) 
 + { 
 + asciiRingArt = " v | " ; 
 + } 
 + else if ( ( rangeMap . size ( ) > 4 ) & & ( ( counter % 2 ) ! = 0 ) ) 
 + { 
 + asciiRingArt = " | ^ " ; 
 + } 
 + else 
 + { 
 + asciiRingArt = " | | " ; 
 + } 
 + } 
 + outs . println ( asciiRingArt ) ; 
 + 
 + counter + + ; 
 + } 
 + } 
 + 
 + / * * 
 + * Write a list of nodes with corresponding status . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printCluster ( PrintStream outs ) 
 + { 
 + for ( String upNode : getLiveNodes ( ) . split ( " \ \ s + " ) ) 
 + { 
 + if ( upNode . length ( ) > 0 ) 
 + { 
 + outs . println ( String . format ( " % - 21s up " , upNode ) ) ; 
 + } 
 + } 
 + 
 + for ( String downNode : getUnreachableNodes ( ) . split ( " \ \ s + " ) ) 
 + { 
 + if ( downNode . length ( ) > 0 ) 
 + { 
 + outs . println ( String . format ( " % - 21s down " , downNode ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Write node information . 
 + * 
 + * @ param outs the stream to write to 
 + * / 
 + public void printInfo ( PrintStream outs ) 
 + { 
 + outs . println ( getToken ( ) ) ; 
 + outs . println ( String . format ( " % - 17s : % s " , " Load Info " , getLoadInfo ( ) ) ) ; 
 + outs . println ( String . format ( " % - 17s : % s " , " Generation No " , getCurrentGenerationNumber ( ) ) ) ; 
 + 
 + / / Uptime 
 + long secondsUp = runtimeProxy . getUptime ( ) / 1000 ; 
 + outs . println ( String . format ( " % - 17s : % d " , " Uptime ( seconds ) " , secondsUp ) ) ; 
 + 
 + / / Memory usage 
 + MemoryUsage heapUsage = memProxy . getHeapMemoryUsage ( ) ; 
 + double memUsed = ( double ) heapUsage . getUsed ( ) / ( 1024 * 1024 ) ; 
 + double memMax = ( double ) heapUsage . getMax ( ) / ( 1024 * 1024 ) ; 
 + outs . println ( String . format ( " % - 17s : % . 2f / % . 2f " , " Heap Memory ( MB ) " , memUsed , memMax ) ) ; 
 + } 
 + 
 + / * * 
 + * Retrieve any non - option arguments passed on the command line . 
 + * 
 + * @ return non - option command args 
 + * / 
 + private String [ ] getArgs ( ) 
 + { 
 + return cmd . getArgs ( ) ; 
 + } 
 + 
 + / * * 
 + * Parse the supplied command line arguments . 
 + * 
 + * @ param args arguments passed on the command line 
 + * @ throws ParseException for missing required , or unrecognized options 
 + * / 
 + private void parseArgs ( String [ ] args ) throws ParseException 
 + { 
 + CommandLineParser parser = new PosixParser ( ) ; 
 + cmd = parser . parse ( options , args ) ; 
 + } 
 + 
 + / * * 
 + * Prints usage information to stdout . 
 + * / 
 + private static void printUsage ( ) 
 + { 
 + HelpFormatter hf = new HelpFormatter ( ) ; 
 + String header = String . format ( 
 + " % nAvailable commands : ring , cluster , info , cleanup , compact " ) ; 
 + String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; 
 + hf . printHelp ( usage , " " , options , header ) ; 
 + } 
 + 
 + / * * 
 + * @ param args 
 + * / 
 + public static void main ( String [ ] args ) 
 + { 
 + NodeProbe probe = null ; 
 + try 
 + { 
 + probe = new NodeProbe ( args ) ; 
 + } 
 + catch ( ParseException pe ) 
 + { 
 + System . err . println ( pe . getMessage ( ) ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + catch ( IOException ioe ) 
 + { 
 + System . err . println ( " Error connecting to remote JMX agent ! " ) ; 
 + ioe . printStackTrace ( ) ; 
 + System . exit ( 3 ) ; 
 + } 
 + 
 + if ( probe . getArgs ( ) . length < 1 ) 
 + { 
 + System . err . println ( " Missing argument for command . " ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + / / Execute the requested command . 
 + String cmdName = probe . getArgs ( ) [ 0 ] ; 
 + if ( cmdName . equals ( " ring " ) ) 
 + { 
 + probe . printRing ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " cluster " ) ) 
 + { 
 + probe . printCluster ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " info " ) ) 
 + { 
 + probe . printInfo ( System . out ) ; 
 + } 
 + else if ( cmdName . equals ( " cleanup " ) ) 
 + { 
 + probe . forceTableCleanup ( ) ; 
 + } 
 + else if ( cmdName . equals ( " compact " ) ) 
 + { 
 + probe . forceTableCompaction ( ) ; 
 + } 
 + else 
 + { 
 + System . err . println ( " Unrecognized command : " + cmdName + " . " ) ; 
 + NodeProbe . printUsage ( ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + System . exit ( 0 ) ; 
 + } 
 + 
 + }
