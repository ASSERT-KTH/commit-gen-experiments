BLEU SCORE: 0.016074772865287294

TEST MSG: Add diagnostic events for user audit logging
GENERATED MSG: Disable passing control to post - flush after flush failure to prevent

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 097e7dd . . d2970a4 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add diagnostic events for user audit logging ( CASSANDRA - 13668 ) <nl> * Allow retrieving diagnostic events via JMX ( CASSANDRA - 14435 ) <nl> * Add base classes for diagnostic events ( CASSANDRA - 13457 ) <nl> * Clear view system metadata when dropping keyspace ( CASSANDRA - 14646 ) <nl> diff - - git a / src / java / org / apache / cassandra / audit / AuditEvent . java b / src / java / org / apache / cassandra / audit / AuditEvent . java <nl> new file mode 100644 <nl> index 0000000 . . b21fe58 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / audit / AuditEvent . java <nl> @ @ - 0 , 0 + 1 , 75 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . audit ; <nl> + <nl> + import java . io . Serializable ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import org . apache . cassandra . diag . DiagnosticEvent ; <nl> + import org . apache . cassandra . diag . DiagnosticEventService ; <nl> + <nl> + / * * <nl> + * { @ Link AuditLogEntry } wrapper to expose audit events as { @ link DiagnosticEvent } s . <nl> + * / <nl> + public final class AuditEvent extends DiagnosticEvent <nl> + { <nl> + private final AuditLogEntry entry ; <nl> + <nl> + private AuditEvent ( AuditLogEntry entry ) <nl> + { <nl> + this . entry = entry ; <nl> + } <nl> + <nl> + static void create ( AuditLogEntry entry ) <nl> + { <nl> + if ( isEnabled ( entry . getType ( ) ) ) <nl> + DiagnosticEventService . instance ( ) . publish ( new AuditEvent ( entry ) ) ; <nl> + } <nl> + <nl> + private static boolean isEnabled ( AuditLogEntryType type ) <nl> + { <nl> + return DiagnosticEventService . instance ( ) . isEnabled ( AuditEvent . class , type ) ; <nl> + } <nl> + <nl> + public Enum < ? > getType ( ) <nl> + { <nl> + return entry . getType ( ) ; <nl> + } <nl> + <nl> + public String getSource ( ) <nl> + { <nl> + return entry . getSource ( ) . toString ( true ) ; <nl> + } <nl> + <nl> + public AuditLogEntry getEntry ( ) <nl> + { <nl> + return entry ; <nl> + } <nl> + <nl> + public Map < String , Serializable > toMap ( ) <nl> + { <nl> + HashMap < String , Serializable > ret = new HashMap < > ( ) ; <nl> + if ( entry . getKeyspace ( ) ! = null ) ret . put ( " keyspace " , entry . getKeyspace ( ) ) ; <nl> + if ( entry . getOperation ( ) ! = null ) ret . put ( " operation " , entry . getOperation ( ) ) ; <nl> + if ( entry . getScope ( ) ! = null ) ret . put ( " scope " , entry . getScope ( ) ) ; <nl> + if ( entry . getUser ( ) ! = null ) ret . put ( " user " , entry . getUser ( ) ) ; <nl> + return ret ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java b / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java <nl> new file mode 100644 <nl> index 0000000 . . 9d586ba <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java <nl> @ @ - 0 , 0 + 1 , 39 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . audit ; <nl> + <nl> + import org . apache . cassandra . diag . DiagnosticEventService ; <nl> + <nl> + public class DiagnosticEventAuditLogger implements IAuditLogger <nl> + { <nl> + public void log ( AuditLogEntry logMessage ) <nl> + { <nl> + AuditEvent . create ( logMessage ) ; <nl> + } <nl> + <nl> + public boolean enabled ( ) <nl> + { <nl> + return DiagnosticEventService . instance ( ) . isDiagnosticsEnabled ( ) ; <nl> + } <nl> + <nl> + public void stop ( ) <nl> + { <nl> + <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java b / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java <nl> new file mode 100644 <nl> index 0000000 . . 82becc7 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java <nl> @ @ - 0 , 0 + 1 , 253 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . transport ; <nl> + <nl> + import java . io . Serializable ; <nl> + import java . net . InetAddress ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . concurrent . BlockingQueue ; <nl> + import java . util . concurrent . LinkedBlockingQueue ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . AfterClass ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import com . datastax . driver . core . Cluster ; <nl> + import com . datastax . driver . core . PreparedStatement ; <nl> + import com . datastax . driver . core . Session ; <nl> + import com . datastax . driver . core . exceptions . AuthenticationException ; <nl> + import org . apache . cassandra . OrderedJUnit4ClassRunner ; <nl> + import org . apache . cassandra . audit . AuditEvent ; <nl> + import org . apache . cassandra . audit . AuditLogEntryType ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . OverrideConfigurationLoader ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + import org . apache . cassandra . diag . DiagnosticEventService ; <nl> + import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . service . EmbeddedCassandraService ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + <nl> + @ RunWith ( OrderedJUnit4ClassRunner . class ) <nl> + public class CQLUserAuditTest <nl> + { <nl> + private static EmbeddedCassandraService embedded ; <nl> + private static final BlockingQueue < AuditEvent > auditEvents = new LinkedBlockingQueue < > ( ) ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) throws Exception <nl> + { <nl> + OverrideConfigurationLoader . override ( ( config ) - > { <nl> + config . authenticator = " PasswordAuthenticator " ; <nl> + config . role _ manager = " CassandraRoleManager " ; <nl> + config . diagnostic _ events _ enabled = true ; <nl> + config . audit _ logging _ options . enabled = true ; <nl> + config . audit _ logging _ options . logger = " DiagnosticEventAuditLogger " ; <nl> + } ) ; <nl> + CQLTester . prepareServer ( ) ; <nl> + <nl> + System . setProperty ( " cassandra . superuser _ setup _ delay _ ms " , " 0 " ) ; <nl> + embedded = new EmbeddedCassandraService ( ) ; <nl> + embedded . start ( ) ; <nl> + <nl> + executeAs ( Arrays . asList ( " CREATE ROLE testuser WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " , <nl> + " CREATE ROLE testuser _ nologin WITH LOGIN = false AND SUPERUSER = false AND PASSWORD = ' foo ' " , <nl> + " CREATE KEYSPACE testks WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , <nl> + " CREATE TABLE testks . table1 ( a text , b int , c int , PRIMARY KEY ( a , b ) ) " , <nl> + " CREATE TABLE testks . table2 ( a text , b int , c int , PRIMARY KEY ( a , b ) ) " ) , <nl> + " cassandra " , " cassandra " , null ) ; <nl> + <nl> + DiagnosticEventService . instance ( ) . subscribe ( AuditEvent . class , auditEvents : : add ) ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void shutdown ( ) <nl> + { <nl> + embedded . stop ( ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void clearQueue ( ) <nl> + { <nl> + auditEvents . clear ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void loginWrongPasswordTest ( ) throws Throwable <nl> + { <nl> + executeAs ( Collections . emptyList ( ) , " testuser " , " wrongpassword " , AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void loginWrongUsernameTest ( ) throws Throwable <nl> + { <nl> + executeAs ( Collections . emptyList ( ) , " wronguser " , " foo " , AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void loginDeniedTest ( ) throws Throwable <nl> + { <nl> + executeAs ( Collections . emptyList ( ) , " testuser _ nologin " , " foo " , AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void loginSuccessfulTest ( ) throws Throwable <nl> + { <nl> + executeAs ( Collections . emptyList ( ) , " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void querySimpleSelect ( ) throws Throwable <nl> + { <nl> + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( " SELECT * FROM testks . table1 " ) , <nl> + " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertEquals ( 1 , events . size ( ) ) ; <nl> + AuditEvent e = events . get ( 0 ) ; <nl> + Map < String , Serializable > m = e . toMap ( ) ; <nl> + assertEquals ( " testuser " , m . get ( " user " ) ) ; <nl> + assertEquals ( " SELECT * FROM testks . table1 " , m . get ( " operation " ) ) ; <nl> + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; <nl> + assertEquals ( " table1 " , m . get ( " scope " ) ) ; <nl> + assertEquals ( AuditLogEntryType . SELECT , e . getType ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void queryInsert ( ) throws Throwable <nl> + { <nl> + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) " ) , <nl> + " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertEquals ( 1 , events . size ( ) ) ; <nl> + AuditEvent e = events . get ( 0 ) ; <nl> + Map < String , Serializable > m = e . toMap ( ) ; <nl> + assertEquals ( " testuser " , m . get ( " user " ) ) ; <nl> + assertEquals ( " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) " , m . get ( " operation " ) ) ; <nl> + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; <nl> + assertEquals ( " table1 " , m . get ( " scope " ) ) ; <nl> + assertEquals ( AuditLogEntryType . UPDATE , e . getType ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void queryBatch ( ) throws Throwable <nl> + { <nl> + String query = " BEGIN BATCH " <nl> + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) ; " <nl> + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' b ' , 1 , 1 ) ; " <nl> + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' b ' , 2 , 2 ) ; " <nl> + + " APPLY BATCH ; " ; <nl> + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( query ) , <nl> + " testuser " , " foo " , <nl> + AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + assertEquals ( 1 , events . size ( ) ) ; <nl> + AuditEvent e = events . get ( 0 ) ; <nl> + Map < String , Serializable > m = e . toMap ( ) ; <nl> + assertEquals ( " testuser " , m . get ( " user " ) ) ; <nl> + assertEquals ( query , m . get ( " operation " ) ) ; <nl> + assertEquals ( AuditLogEntryType . BATCH , e . getType ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void prepareStmt ( ) <nl> + { <nl> + Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) <nl> + . withoutJMXReporting ( ) <nl> + . withCredentials ( " testuser " , " foo " ) <nl> + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; <nl> + String spStmt = " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ? , ? , ? ) " ; <nl> + try ( Session session = cluster . connect ( ) ) <nl> + { <nl> + PreparedStatement pStmt = session . prepare ( spStmt ) ; <nl> + session . execute ( pStmt . bind ( " x " , 9 , 8 ) ) ; <nl> + } <nl> + <nl> + List < AuditEvent > events = auditEvents . stream ( ) . filter ( ( e ) - > e . getType ( ) ! = AuditLogEntryType . LOGIN _ SUCCESS ) <nl> + . collect ( Collectors . toList ( ) ) ; <nl> + AuditEvent e = events . get ( 0 ) ; <nl> + Map < String , Serializable > m = e . toMap ( ) ; <nl> + assertEquals ( 2 , events . size ( ) ) ; <nl> + assertEquals ( " testuser " , m . get ( " user " ) ) ; <nl> + assertEquals ( spStmt , m . get ( " operation " ) ) ; <nl> + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; <nl> + assertEquals ( " table1 " , m . get ( " scope " ) ) ; <nl> + assertEquals ( AuditLogEntryType . PREPARE _ STATEMENT , e . getType ( ) ) ; <nl> + <nl> + e = events . get ( 1 ) ; <nl> + m = e . toMap ( ) ; <nl> + assertEquals ( " testuser " , m . get ( " user " ) ) ; <nl> + assertEquals ( spStmt , m . get ( " operation " ) ) ; <nl> + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; <nl> + assertEquals ( " table1 " , m . get ( " scope " ) ) ; <nl> + assertEquals ( AuditLogEntryType . UPDATE , e . getType ( ) ) ; <nl> + <nl> + } <nl> + <nl> + private static ArrayList < AuditEvent > executeAs ( List < String > queries , String username , String password , <nl> + AuditLogEntryType expectedAuthType ) throws Exception <nl> + { <nl> + boolean authFailed = false ; <nl> + Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) <nl> + . withoutJMXReporting ( ) <nl> + . withCredentials ( username , password ) <nl> + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; <nl> + try ( Session session = cluster . connect ( ) ) <nl> + { <nl> + for ( String query : queries ) <nl> + session . execute ( query ) ; <nl> + } <nl> + catch ( AuthenticationException e ) <nl> + { <nl> + authFailed = true ; <nl> + } <nl> + cluster . close ( ) ; <nl> + <nl> + if ( expectedAuthType = = null ) return null ; <nl> + <nl> + AuditEvent event = auditEvents . poll ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + assertEquals ( expectedAuthType , event . getType ( ) ) ; <nl> + assertTrue ( ! authFailed | | event . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR ) ; <nl> + assertEquals ( InetAddressAndPort . getLoopbackAddress ( ) . address , <nl> + event . getEntry ( ) . getSource ( ) . address ) ; <nl> + assertTrue ( event . getEntry ( ) . getSource ( ) . port > 0 ) ; <nl> + if ( event . getType ( ) ! = AuditLogEntryType . LOGIN _ ERROR ) <nl> + assertEquals ( username , event . toMap ( ) . get ( " user " ) ) ; <nl> + <nl> + / / drain all remaining login related events , as there ' s no specification how connections and login attempts <nl> + / / should be handled by the driver , so we can ' t assert a fixed number of login events <nl> + for ( AuditEvent e = auditEvents . peek ( ) ; <nl> + e ! = null & & ( e . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR <nl> + | | e . getType ( ) = = AuditLogEntryType . LOGIN _ SUCCESS ) ; <nl> + e = auditEvents . peek ( ) ) <nl> + { <nl> + auditEvents . remove ( e ) ; <nl> + } <nl> + <nl> + ArrayList < AuditEvent > ret = new ArrayList < > ( auditEvents . size ( ) ) ; <nl> + auditEvents . drainTo ( ret ) ; <nl> + return ret ; <nl> + } <nl> + } <nl> \ No newline at end of file
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 097e7dd . . d2970a4 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add diagnostic events for user audit logging ( CASSANDRA - 13668 ) 
 * Allow retrieving diagnostic events via JMX ( CASSANDRA - 14435 ) 
 * Add base classes for diagnostic events ( CASSANDRA - 13457 ) 
 * Clear view system metadata when dropping keyspace ( CASSANDRA - 14646 ) 
 diff - - git a / src / java / org / apache / cassandra / audit / AuditEvent . java b / src / java / org / apache / cassandra / audit / AuditEvent . java 
 new file mode 100644 
 index 0000000 . . b21fe58 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / audit / AuditEvent . java 
 @ @ - 0 , 0 + 1 , 75 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . audit ; 
 + 
 + import java . io . Serializable ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import org . apache . cassandra . diag . DiagnosticEvent ; 
 + import org . apache . cassandra . diag . DiagnosticEventService ; 
 + 
 + / * * 
 + * { @ Link AuditLogEntry } wrapper to expose audit events as { @ link DiagnosticEvent } s . 
 + * / 
 + public final class AuditEvent extends DiagnosticEvent 
 + { 
 + private final AuditLogEntry entry ; 
 + 
 + private AuditEvent ( AuditLogEntry entry ) 
 + { 
 + this . entry = entry ; 
 + } 
 + 
 + static void create ( AuditLogEntry entry ) 
 + { 
 + if ( isEnabled ( entry . getType ( ) ) ) 
 + DiagnosticEventService . instance ( ) . publish ( new AuditEvent ( entry ) ) ; 
 + } 
 + 
 + private static boolean isEnabled ( AuditLogEntryType type ) 
 + { 
 + return DiagnosticEventService . instance ( ) . isEnabled ( AuditEvent . class , type ) ; 
 + } 
 + 
 + public Enum < ? > getType ( ) 
 + { 
 + return entry . getType ( ) ; 
 + } 
 + 
 + public String getSource ( ) 
 + { 
 + return entry . getSource ( ) . toString ( true ) ; 
 + } 
 + 
 + public AuditLogEntry getEntry ( ) 
 + { 
 + return entry ; 
 + } 
 + 
 + public Map < String , Serializable > toMap ( ) 
 + { 
 + HashMap < String , Serializable > ret = new HashMap < > ( ) ; 
 + if ( entry . getKeyspace ( ) ! = null ) ret . put ( " keyspace " , entry . getKeyspace ( ) ) ; 
 + if ( entry . getOperation ( ) ! = null ) ret . put ( " operation " , entry . getOperation ( ) ) ; 
 + if ( entry . getScope ( ) ! = null ) ret . put ( " scope " , entry . getScope ( ) ) ; 
 + if ( entry . getUser ( ) ! = null ) ret . put ( " user " , entry . getUser ( ) ) ; 
 + return ret ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java b / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java 
 new file mode 100644 
 index 0000000 . . 9d586ba 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / audit / DiagnosticEventAuditLogger . java 
 @ @ - 0 , 0 + 1 , 39 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . audit ; 
 + 
 + import org . apache . cassandra . diag . DiagnosticEventService ; 
 + 
 + public class DiagnosticEventAuditLogger implements IAuditLogger 
 + { 
 + public void log ( AuditLogEntry logMessage ) 
 + { 
 + AuditEvent . create ( logMessage ) ; 
 + } 
 + 
 + public boolean enabled ( ) 
 + { 
 + return DiagnosticEventService . instance ( ) . isDiagnosticsEnabled ( ) ; 
 + } 
 + 
 + public void stop ( ) 
 + { 
 + 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java b / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java 
 new file mode 100644 
 index 0000000 . . 82becc7 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / transport / CQLUserAuditTest . java 
 @ @ - 0 , 0 + 1 , 253 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . transport ; 
 + 
 + import java . io . Serializable ; 
 + import java . net . InetAddress ; 
 + import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . concurrent . BlockingQueue ; 
 + import java . util . concurrent . LinkedBlockingQueue ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . stream . Collectors ; 
 + 
 + import org . junit . After ; 
 + import org . junit . AfterClass ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import com . datastax . driver . core . Cluster ; 
 + import com . datastax . driver . core . PreparedStatement ; 
 + import com . datastax . driver . core . Session ; 
 + import com . datastax . driver . core . exceptions . AuthenticationException ; 
 + import org . apache . cassandra . OrderedJUnit4ClassRunner ; 
 + import org . apache . cassandra . audit . AuditEvent ; 
 + import org . apache . cassandra . audit . AuditLogEntryType ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . OverrideConfigurationLoader ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + import org . apache . cassandra . diag . DiagnosticEventService ; 
 + import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . service . EmbeddedCassandraService ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + 
 + @ RunWith ( OrderedJUnit4ClassRunner . class ) 
 + public class CQLUserAuditTest 
 + { 
 + private static EmbeddedCassandraService embedded ; 
 + private static final BlockingQueue < AuditEvent > auditEvents = new LinkedBlockingQueue < > ( ) ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) throws Exception 
 + { 
 + OverrideConfigurationLoader . override ( ( config ) - > { 
 + config . authenticator = " PasswordAuthenticator " ; 
 + config . role _ manager = " CassandraRoleManager " ; 
 + config . diagnostic _ events _ enabled = true ; 
 + config . audit _ logging _ options . enabled = true ; 
 + config . audit _ logging _ options . logger = " DiagnosticEventAuditLogger " ; 
 + } ) ; 
 + CQLTester . prepareServer ( ) ; 
 + 
 + System . setProperty ( " cassandra . superuser _ setup _ delay _ ms " , " 0 " ) ; 
 + embedded = new EmbeddedCassandraService ( ) ; 
 + embedded . start ( ) ; 
 + 
 + executeAs ( Arrays . asList ( " CREATE ROLE testuser WITH LOGIN = true AND SUPERUSER = false AND PASSWORD = ' foo ' " , 
 + " CREATE ROLE testuser _ nologin WITH LOGIN = false AND SUPERUSER = false AND PASSWORD = ' foo ' " , 
 + " CREATE KEYSPACE testks WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , 
 + " CREATE TABLE testks . table1 ( a text , b int , c int , PRIMARY KEY ( a , b ) ) " , 
 + " CREATE TABLE testks . table2 ( a text , b int , c int , PRIMARY KEY ( a , b ) ) " ) , 
 + " cassandra " , " cassandra " , null ) ; 
 + 
 + DiagnosticEventService . instance ( ) . subscribe ( AuditEvent . class , auditEvents : : add ) ; 
 + } 
 + 
 + @ AfterClass 
 + public static void shutdown ( ) 
 + { 
 + embedded . stop ( ) ; 
 + } 
 + 
 + @ After 
 + public void clearQueue ( ) 
 + { 
 + auditEvents . clear ( ) ; 
 + } 
 + 
 + @ Test 
 + public void loginWrongPasswordTest ( ) throws Throwable 
 + { 
 + executeAs ( Collections . emptyList ( ) , " testuser " , " wrongpassword " , AuditLogEntryType . LOGIN _ ERROR ) ; 
 + } 
 + 
 + @ Test 
 + public void loginWrongUsernameTest ( ) throws Throwable 
 + { 
 + executeAs ( Collections . emptyList ( ) , " wronguser " , " foo " , AuditLogEntryType . LOGIN _ ERROR ) ; 
 + } 
 + 
 + @ Test 
 + public void loginDeniedTest ( ) throws Throwable 
 + { 
 + executeAs ( Collections . emptyList ( ) , " testuser _ nologin " , " foo " , AuditLogEntryType . LOGIN _ ERROR ) ; 
 + } 
 + 
 + @ Test 
 + public void loginSuccessfulTest ( ) throws Throwable 
 + { 
 + executeAs ( Collections . emptyList ( ) , " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + } 
 + 
 + @ Test 
 + public void querySimpleSelect ( ) throws Throwable 
 + { 
 + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( " SELECT * FROM testks . table1 " ) , 
 + " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertEquals ( 1 , events . size ( ) ) ; 
 + AuditEvent e = events . get ( 0 ) ; 
 + Map < String , Serializable > m = e . toMap ( ) ; 
 + assertEquals ( " testuser " , m . get ( " user " ) ) ; 
 + assertEquals ( " SELECT * FROM testks . table1 " , m . get ( " operation " ) ) ; 
 + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; 
 + assertEquals ( " table1 " , m . get ( " scope " ) ) ; 
 + assertEquals ( AuditLogEntryType . SELECT , e . getType ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void queryInsert ( ) throws Throwable 
 + { 
 + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) " ) , 
 + " testuser " , " foo " , AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertEquals ( 1 , events . size ( ) ) ; 
 + AuditEvent e = events . get ( 0 ) ; 
 + Map < String , Serializable > m = e . toMap ( ) ; 
 + assertEquals ( " testuser " , m . get ( " user " ) ) ; 
 + assertEquals ( " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) " , m . get ( " operation " ) ) ; 
 + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; 
 + assertEquals ( " table1 " , m . get ( " scope " ) ) ; 
 + assertEquals ( AuditLogEntryType . UPDATE , e . getType ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void queryBatch ( ) throws Throwable 
 + { 
 + String query = " BEGIN BATCH " 
 + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' a ' , 1 , 1 ) ; " 
 + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' b ' , 1 , 1 ) ; " 
 + + " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ' b ' , 2 , 2 ) ; " 
 + + " APPLY BATCH ; " ; 
 + ArrayList < AuditEvent > events = executeAs ( Arrays . asList ( query ) , 
 + " testuser " , " foo " , 
 + AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + assertEquals ( 1 , events . size ( ) ) ; 
 + AuditEvent e = events . get ( 0 ) ; 
 + Map < String , Serializable > m = e . toMap ( ) ; 
 + assertEquals ( " testuser " , m . get ( " user " ) ) ; 
 + assertEquals ( query , m . get ( " operation " ) ) ; 
 + assertEquals ( AuditLogEntryType . BATCH , e . getType ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void prepareStmt ( ) 
 + { 
 + Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) 
 + . withoutJMXReporting ( ) 
 + . withCredentials ( " testuser " , " foo " ) 
 + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; 
 + String spStmt = " INSERT INTO testks . table1 ( a , b , c ) VALUES ( ? , ? , ? ) " ; 
 + try ( Session session = cluster . connect ( ) ) 
 + { 
 + PreparedStatement pStmt = session . prepare ( spStmt ) ; 
 + session . execute ( pStmt . bind ( " x " , 9 , 8 ) ) ; 
 + } 
 + 
 + List < AuditEvent > events = auditEvents . stream ( ) . filter ( ( e ) - > e . getType ( ) ! = AuditLogEntryType . LOGIN _ SUCCESS ) 
 + . collect ( Collectors . toList ( ) ) ; 
 + AuditEvent e = events . get ( 0 ) ; 
 + Map < String , Serializable > m = e . toMap ( ) ; 
 + assertEquals ( 2 , events . size ( ) ) ; 
 + assertEquals ( " testuser " , m . get ( " user " ) ) ; 
 + assertEquals ( spStmt , m . get ( " operation " ) ) ; 
 + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; 
 + assertEquals ( " table1 " , m . get ( " scope " ) ) ; 
 + assertEquals ( AuditLogEntryType . PREPARE _ STATEMENT , e . getType ( ) ) ; 
 + 
 + e = events . get ( 1 ) ; 
 + m = e . toMap ( ) ; 
 + assertEquals ( " testuser " , m . get ( " user " ) ) ; 
 + assertEquals ( spStmt , m . get ( " operation " ) ) ; 
 + assertEquals ( " testks " , m . get ( " keyspace " ) ) ; 
 + assertEquals ( " table1 " , m . get ( " scope " ) ) ; 
 + assertEquals ( AuditLogEntryType . UPDATE , e . getType ( ) ) ; 
 + 
 + } 
 + 
 + private static ArrayList < AuditEvent > executeAs ( List < String > queries , String username , String password , 
 + AuditLogEntryType expectedAuthType ) throws Exception 
 + { 
 + boolean authFailed = false ; 
 + Cluster cluster = Cluster . builder ( ) . addContactPoints ( InetAddress . getLoopbackAddress ( ) ) 
 + . withoutJMXReporting ( ) 
 + . withCredentials ( username , password ) 
 + . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; 
 + try ( Session session = cluster . connect ( ) ) 
 + { 
 + for ( String query : queries ) 
 + session . execute ( query ) ; 
 + } 
 + catch ( AuthenticationException e ) 
 + { 
 + authFailed = true ; 
 + } 
 + cluster . close ( ) ; 
 + 
 + if ( expectedAuthType = = null ) return null ; 
 + 
 + AuditEvent event = auditEvents . poll ( 100 , TimeUnit . MILLISECONDS ) ; 
 + assertEquals ( expectedAuthType , event . getType ( ) ) ; 
 + assertTrue ( ! authFailed | | event . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR ) ; 
 + assertEquals ( InetAddressAndPort . getLoopbackAddress ( ) . address , 
 + event . getEntry ( ) . getSource ( ) . address ) ; 
 + assertTrue ( event . getEntry ( ) . getSource ( ) . port > 0 ) ; 
 + if ( event . getType ( ) ! = AuditLogEntryType . LOGIN _ ERROR ) 
 + assertEquals ( username , event . toMap ( ) . get ( " user " ) ) ; 
 + 
 + / / drain all remaining login related events , as there ' s no specification how connections and login attempts 
 + / / should be handled by the driver , so we can ' t assert a fixed number of login events 
 + for ( AuditEvent e = auditEvents . peek ( ) ; 
 + e ! = null & & ( e . getType ( ) = = AuditLogEntryType . LOGIN _ ERROR 
 + | | e . getType ( ) = = AuditLogEntryType . LOGIN _ SUCCESS ) ; 
 + e = auditEvents . peek ( ) ) 
 + { 
 + auditEvents . remove ( e ) ; 
 + } 
 + 
 + ArrayList < AuditEvent > ret = new ArrayList < > ( auditEvents . size ( ) ) ; 
 + auditEvents . drainTo ( ret ) ; 
 + return ret ; 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
ELIMINATEDSENTENCE
