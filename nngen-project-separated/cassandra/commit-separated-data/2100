BLEU SCORE: 0.09770653288423854

TEST MSG: ninja - fix stress : rate limit not honoured for warmup , and ' auto ' rate mode optional with thread ranges
GENERATED MSG: cassandra - stress : merge 7468 into 2 . 1 , and ninja - fix duration setting for user command

TEST DIFF (one line): diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressAction . java b / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> index da32284 . . b50637f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / StressAction . java <nl> @ @ - 56 , 19 + 56 , 24 @ @ public class StressAction implements Runnable <nl> / / creating keyspace and column families <nl> settings . maybeCreateKeyspaces ( ) ; <nl> <nl> - / / TODO : warmup should <nl> + / / TODO : warmup should operate configurably over op / pk / row , and be of configurable length <nl> if ( ! settings . command . noWarmup ) <nl> warmup ( settings . command . getFactory ( settings ) ) ; <nl> <nl> output . println ( " Sleeping 2s . . . " ) ; <nl> Uninterruptibles . sleepUninterruptibly ( 2 , TimeUnit . SECONDS ) ; <nl> <nl> + / / TODO : move this to a new queue wrapper that gates progress based on a poisson ( or configurable ) distribution <nl> + RateLimiter rateLimiter = null ; <nl> + if ( settings . rate . opRateTargetPerSecond > 0 ) <nl> + rateLimiter = RateLimiter . create ( settings . rate . opRateTargetPerSecond ) ; <nl> + <nl> boolean success ; <nl> - if ( settings . rate . auto ) <nl> - success = runAuto ( ) ; <nl> + if ( settings . rate . minThreads > 0 ) <nl> + success = runMulti ( settings . rate . auto , rateLimiter ) ; <nl> else <nl> success = null ! = run ( settings . command . getFactory ( settings ) , settings . rate . threadCount , settings . command . count , <nl> - settings . command . duration , settings . command . durationUnits , output ) ; <nl> + settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; <nl> <nl> if ( success ) <nl> output . println ( " END " ) ; <nl> @ @ - 89 , 16 + 94 , 18 @ @ public class StressAction implements Runnable <nl> / / we need to warm up all the nodes in the cluster ideally , but we may not be the only stress instance ; <nl> / / so warm up all the nodes we ' re speaking to only . <nl> output . println ( String . format ( " Warming up % s with % d iterations . . . " , single . desc ( ) , iterations ) ) ; <nl> - run ( single , 20 , iterations , 0 , null , warmupOutput ) ; <nl> + run ( single , 20 , iterations , 0 , null , null , warmupOutput ) ; <nl> } <nl> } <nl> <nl> / / TODO : permit varying more than just thread count <nl> / / TODO : vary thread count based on percentage improvement of previous increment , not by fixed amounts <nl> - private boolean runAuto ( ) <nl> + private boolean runMulti ( boolean auto , RateLimiter rateLimiter ) <nl> { <nl> + if ( settings . command . targetUncertainty > = 0 ) <nl> + output . println ( " WARNING : uncertainty mode ( err < ) results in uneven workload between thread runs , so should be used for high level analysis only " ) ; <nl> int prevThreadCount = - 1 ; <nl> - int threadCount = settings . rate . minAutoThreads ; <nl> + int threadCount = settings . rate . minThreads ; <nl> List < StressMetrics > results = new ArrayList < > ( ) ; <nl> List < String > runIds = new ArrayList < > ( ) ; <nl> do <nl> @ @ - 106 , 7 + 113 , 7 @ @ public class StressAction implements Runnable <nl> output . println ( String . format ( " Running with % d threadCount " , threadCount ) ) ; <nl> <nl> StressMetrics result = run ( settings . command . getFactory ( settings ) , threadCount , settings . command . count , <nl> - settings . command . duration , settings . command . durationUnits , output ) ; <nl> + settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; <nl> if ( result = = null ) <nl> return false ; <nl> results . add ( result ) ; <nl> @ @ - 122 , 7 + 129 , 7 @ @ public class StressAction implements Runnable <nl> else <nl> threadCount * = 1 . 5 ; <nl> <nl> - if ( ! results . isEmpty ( ) & & threadCount > settings . rate . maxAutoThreads ) <nl> + if ( ! results . isEmpty ( ) & & threadCount > settings . rate . maxThreads ) <nl> break ; <nl> <nl> if ( settings . command . type . updates ) <nl> @ @ - 139 , 7 + 146 , 7 @ @ public class StressAction implements Runnable <nl> } <nl> } <nl> / / run until we have not improved throughput significantly for previous three runs <nl> - } while ( hasAverageImprovement ( results , 3 , 0 ) & & hasAverageImprovement ( results , 5 , settings . command . targetUncertainty ) ) ; <nl> + } while ( ! auto | | ( hasAverageImprovement ( results , 3 , 0 ) & & hasAverageImprovement ( results , 5 , settings . command . targetUncertainty ) ) ) ; <nl> <nl> / / summarise all results <nl> StressMetrics . summarise ( runIds , results , output ) ; <nl> @ @ - 163 , 7 + 170 , 7 @ @ public class StressAction implements Runnable <nl> return improvement / count ; <nl> } <nl> <nl> - private StressMetrics run ( OpDistributionFactory operations , int threadCount , long opCount , long duration , TimeUnit durationUnits , PrintStream output ) <nl> + private StressMetrics run ( OpDistributionFactory operations , int threadCount , long opCount , long duration , RateLimiter rateLimiter , TimeUnit durationUnits , PrintStream output ) <nl> { <nl> output . println ( String . format ( " Running % s with % d threads % s " , <nl> operations . desc ( ) , <nl> @ @ - 177 , 11 + 184 , 6 @ @ public class StressAction implements Runnable <nl> else <nl> workManager = new FixedWorkManager ( opCount ) ; <nl> <nl> - RateLimiter rateLimiter = null ; <nl> - / / TODO : move this to a new queue wrapper that gates progress based on a poisson ( or configurable ) distribution <nl> - if ( settings . rate . opRateTargetPerSecond > 0 ) <nl> - rateLimiter = RateLimiter . create ( settings . rate . opRateTargetPerSecond ) ; <nl> - <nl> final StressMetrics metrics = new StressMetrics ( output , settings . log . intervalMillis , settings ) ; <nl> <nl> final CountDownLatch done = new CountDownLatch ( threadCount ) ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java <nl> index a91f073 . . 0486678 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java <nl> @ @ - 30 , 8 + 30 , 8 @ @ public class SettingsRate implements Serializable <nl> { <nl> <nl> public final boolean auto ; <nl> - public final int minAutoThreads ; <nl> - public final int maxAutoThreads ; <nl> + public final int minThreads ; <nl> + public final int maxThreads ; <nl> public final int threadCount ; <nl> public final int opRateTargetPerSecond ; <nl> <nl> @ @ - 41 , 15 + 41 , 15 @ @ public class SettingsRate implements Serializable <nl> threadCount = Integer . parseInt ( options . threads . value ( ) ) ; <nl> String rateOpt = options . rate . value ( ) ; <nl> opRateTargetPerSecond = Integer . parseInt ( rateOpt . substring ( 0 , rateOpt . length ( ) - 2 ) ) ; <nl> - minAutoThreads = - 1 ; <nl> - maxAutoThreads = - 1 ; <nl> + minThreads = - 1 ; <nl> + maxThreads = - 1 ; <nl> } <nl> <nl> public SettingsRate ( AutoOptions auto ) <nl> { <nl> - this . auto = true ; <nl> - this . minAutoThreads = Integer . parseInt ( auto . minThreads . value ( ) ) ; <nl> - this . maxAutoThreads = Integer . parseInt ( auto . maxThreads . value ( ) ) ; <nl> + this . auto = auto . auto . setByUser ( ) ; <nl> + this . minThreads = Integer . parseInt ( auto . minThreads . value ( ) ) ; <nl> + this . maxThreads = Integer . parseInt ( auto . maxThreads . value ( ) ) ; <nl> this . threadCount = - 1 ; <nl> this . opRateTargetPerSecond = 0 ; <nl> } <nl> @ @ - 59 , 14 + 59 , 14 @ @ public class SettingsRate implements Serializable <nl> <nl> private static final class AutoOptions extends GroupedOptions <nl> { <nl> - final OptionSimple auto = new OptionSimple ( " auto " , " " , null , " test with increasing number of threadCount until performance plateaus " , false ) ; <nl> + final OptionSimple auto = new OptionSimple ( " auto " , " " , null , " stop increasing threads once throughput saturates " , false ) ; <nl> final OptionSimple minThreads = new OptionSimple ( " threads > = " , " [ 0 - 9 ] + " , " 4 " , " run at least this many clients concurrently " , false ) ; <nl> final OptionSimple maxThreads = new OptionSimple ( " threads < = " , " [ 0 - 9 ] + " , " 1000 " , " run at most this many clients concurrently " , false ) ; <nl> <nl> @ Override <nl> public List < ? extends Option > options ( ) <nl> { <nl> - return Arrays . asList ( auto , minThreads , maxThreads ) ; <nl> + return Arrays . asList ( minThreads , maxThreads , auto ) ; <nl> } <nl> } <nl> <nl> @ @ - 96 , 11 + 96 , 13 @ @ public class SettingsRate implements Serializable <nl> if ( command . count > 0 ) <nl> { <nl> ThreadOptions options = new ThreadOptions ( ) ; <nl> - options . accept ( " threads = 50 " ) ; <nl> + options . accept ( " threads = 200 " ) ; <nl> return new SettingsRate ( options ) ; <nl> } <nl> } <nl> - return new SettingsRate ( new AutoOptions ( ) ) ; <nl> + AutoOptions options = new AutoOptions ( ) ; <nl> + options . accept ( " auto " ) ; <nl> + return new SettingsRate ( options ) ; <nl> } <nl> GroupedOptions options = GroupedOptions . select ( params , new AutoOptions ( ) , new ThreadOptions ( ) ) ; <nl> if ( options = = null )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressAction . java b / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 index da32284 . . b50637f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / StressAction . java 
 @ @ - 56 , 19 + 56 , 24 @ @ public class StressAction implements Runnable 
 / / creating keyspace and column families 
 settings . maybeCreateKeyspaces ( ) ; 
 
 - / / TODO : warmup should 
 + / / TODO : warmup should operate configurably over op / pk / row , and be of configurable length 
 if ( ! settings . command . noWarmup ) 
 warmup ( settings . command . getFactory ( settings ) ) ; 
 
 output . println ( " Sleeping 2s . . . " ) ; 
 Uninterruptibles . sleepUninterruptibly ( 2 , TimeUnit . SECONDS ) ; 
 
 + / / TODO : move this to a new queue wrapper that gates progress based on a poisson ( or configurable ) distribution 
 + RateLimiter rateLimiter = null ; 
 + if ( settings . rate . opRateTargetPerSecond > 0 ) 
 + rateLimiter = RateLimiter . create ( settings . rate . opRateTargetPerSecond ) ; 
 + 
 boolean success ; 
 - if ( settings . rate . auto ) 
 - success = runAuto ( ) ; 
 + if ( settings . rate . minThreads > 0 ) 
 + success = runMulti ( settings . rate . auto , rateLimiter ) ; 
 else 
 success = null ! = run ( settings . command . getFactory ( settings ) , settings . rate . threadCount , settings . command . count , 
 - settings . command . duration , settings . command . durationUnits , output ) ; 
 + settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; 
 
 if ( success ) 
 output . println ( " END " ) ; 
 @ @ - 89 , 16 + 94 , 18 @ @ public class StressAction implements Runnable 
 / / we need to warm up all the nodes in the cluster ideally , but we may not be the only stress instance ; 
 / / so warm up all the nodes we ' re speaking to only . 
 output . println ( String . format ( " Warming up % s with % d iterations . . . " , single . desc ( ) , iterations ) ) ; 
 - run ( single , 20 , iterations , 0 , null , warmupOutput ) ; 
 + run ( single , 20 , iterations , 0 , null , null , warmupOutput ) ; 
 } 
 } 
 
 / / TODO : permit varying more than just thread count 
 / / TODO : vary thread count based on percentage improvement of previous increment , not by fixed amounts 
 - private boolean runAuto ( ) 
 + private boolean runMulti ( boolean auto , RateLimiter rateLimiter ) 
 { 
 + if ( settings . command . targetUncertainty > = 0 ) 
 + output . println ( " WARNING : uncertainty mode ( err < ) results in uneven workload between thread runs , so should be used for high level analysis only " ) ; 
 int prevThreadCount = - 1 ; 
 - int threadCount = settings . rate . minAutoThreads ; 
 + int threadCount = settings . rate . minThreads ; 
 List < StressMetrics > results = new ArrayList < > ( ) ; 
 List < String > runIds = new ArrayList < > ( ) ; 
 do 
 @ @ - 106 , 7 + 113 , 7 @ @ public class StressAction implements Runnable 
 output . println ( String . format ( " Running with % d threadCount " , threadCount ) ) ; 
 
 StressMetrics result = run ( settings . command . getFactory ( settings ) , threadCount , settings . command . count , 
 - settings . command . duration , settings . command . durationUnits , output ) ; 
 + settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; 
 if ( result = = null ) 
 return false ; 
 results . add ( result ) ; 
 @ @ - 122 , 7 + 129 , 7 @ @ public class StressAction implements Runnable 
 else 
 threadCount * = 1 . 5 ; 
 
 - if ( ! results . isEmpty ( ) & & threadCount > settings . rate . maxAutoThreads ) 
 + if ( ! results . isEmpty ( ) & & threadCount > settings . rate . maxThreads ) 
 break ; 
 
 if ( settings . command . type . updates ) 
 @ @ - 139 , 7 + 146 , 7 @ @ public class StressAction implements Runnable 
 } 
 } 
 / / run until we have not improved throughput significantly for previous three runs 
 - } while ( hasAverageImprovement ( results , 3 , 0 ) & & hasAverageImprovement ( results , 5 , settings . command . targetUncertainty ) ) ; 
 + } while ( ! auto | | ( hasAverageImprovement ( results , 3 , 0 ) & & hasAverageImprovement ( results , 5 , settings . command . targetUncertainty ) ) ) ; 
 
 / / summarise all results 
 StressMetrics . summarise ( runIds , results , output ) ; 
 @ @ - 163 , 7 + 170 , 7 @ @ public class StressAction implements Runnable 
 return improvement / count ; 
 } 
 
 - private StressMetrics run ( OpDistributionFactory operations , int threadCount , long opCount , long duration , TimeUnit durationUnits , PrintStream output ) 
 + private StressMetrics run ( OpDistributionFactory operations , int threadCount , long opCount , long duration , RateLimiter rateLimiter , TimeUnit durationUnits , PrintStream output ) 
 { 
 output . println ( String . format ( " Running % s with % d threads % s " , 
 operations . desc ( ) , 
 @ @ - 177 , 11 + 184 , 6 @ @ public class StressAction implements Runnable 
 else 
 workManager = new FixedWorkManager ( opCount ) ; 
 
 - RateLimiter rateLimiter = null ; 
 - / / TODO : move this to a new queue wrapper that gates progress based on a poisson ( or configurable ) distribution 
 - if ( settings . rate . opRateTargetPerSecond > 0 ) 
 - rateLimiter = RateLimiter . create ( settings . rate . opRateTargetPerSecond ) ; 
 - 
 final StressMetrics metrics = new StressMetrics ( output , settings . log . intervalMillis , settings ) ; 
 
 final CountDownLatch done = new CountDownLatch ( threadCount ) ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java 
 index a91f073 . . 0486678 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / settings / SettingsRate . java 
 @ @ - 30 , 8 + 30 , 8 @ @ public class SettingsRate implements Serializable 
 { 
 
 public final boolean auto ; 
 - public final int minAutoThreads ; 
 - public final int maxAutoThreads ; 
 + public final int minThreads ; 
 + public final int maxThreads ; 
 public final int threadCount ; 
 public final int opRateTargetPerSecond ; 
 
 @ @ - 41 , 15 + 41 , 15 @ @ public class SettingsRate implements Serializable 
 threadCount = Integer . parseInt ( options . threads . value ( ) ) ; 
 String rateOpt = options . rate . value ( ) ; 
 opRateTargetPerSecond = Integer . parseInt ( rateOpt . substring ( 0 , rateOpt . length ( ) - 2 ) ) ; 
 - minAutoThreads = - 1 ; 
 - maxAutoThreads = - 1 ; 
 + minThreads = - 1 ; 
 + maxThreads = - 1 ; 
 } 
 
 public SettingsRate ( AutoOptions auto ) 
 { 
 - this . auto = true ; 
 - this . minAutoThreads = Integer . parseInt ( auto . minThreads . value ( ) ) ; 
 - this . maxAutoThreads = Integer . parseInt ( auto . maxThreads . value ( ) ) ; 
 + this . auto = auto . auto . setByUser ( ) ; 
 + this . minThreads = Integer . parseInt ( auto . minThreads . value ( ) ) ; 
 + this . maxThreads = Integer . parseInt ( auto . maxThreads . value ( ) ) ; 
 this . threadCount = - 1 ; 
 this . opRateTargetPerSecond = 0 ; 
 } 
 @ @ - 59 , 14 + 59 , 14 @ @ public class SettingsRate implements Serializable 
 
 private static final class AutoOptions extends GroupedOptions 
 { 
 - final OptionSimple auto = new OptionSimple ( " auto " , " " , null , " test with increasing number of threadCount until performance plateaus " , false ) ; 
 + final OptionSimple auto = new OptionSimple ( " auto " , " " , null , " stop increasing threads once throughput saturates " , false ) ; 
 final OptionSimple minThreads = new OptionSimple ( " threads > = " , " [ 0 - 9 ] + " , " 4 " , " run at least this many clients concurrently " , false ) ; 
 final OptionSimple maxThreads = new OptionSimple ( " threads < = " , " [ 0 - 9 ] + " , " 1000 " , " run at most this many clients concurrently " , false ) ; 
 
 @ Override 
 public List < ? extends Option > options ( ) 
 { 
 - return Arrays . asList ( auto , minThreads , maxThreads ) ; 
 + return Arrays . asList ( minThreads , maxThreads , auto ) ; 
 } 
 } 
 
 @ @ - 96 , 11 + 96 , 13 @ @ public class SettingsRate implements Serializable 
 if ( command . count > 0 ) 
 { 
 ThreadOptions options = new ThreadOptions ( ) ; 
 - options . accept ( " threads = 50 " ) ; 
 + options . accept ( " threads = 200 " ) ; 
 return new SettingsRate ( options ) ; 
 } 
 } 
 - return new SettingsRate ( new AutoOptions ( ) ) ; 
 + AutoOptions options = new AutoOptions ( ) ; 
 + options . accept ( " auto " ) ; 
 + return new SettingsRate ( options ) ; 
 } 
 GroupedOptions options = GroupedOptions . select ( params , new AutoOptions ( ) , new ThreadOptions ( ) ) ; 
 if ( options = = null )

NEAREST DIFF:
ELIMINATEDSENTENCE
