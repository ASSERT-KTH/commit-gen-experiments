BLEU SCORE: 0.031247197904994937

TEST MSG: Batch with multiple conditional updates for the same partition causes AssertionError
GENERATED MSG: Fix AssertionError while flushing memtable due to materialized views incorrectly inserting empty rows

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f708602 . . 1d2c8f3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 10 <nl> + * Batch with multiple conditional updates for the same partition causes AssertionError ( CASSANDRA - 12867 ) <nl> * Make AbstractReplicationStrategy extendable from outside its package ( CASSANDRA - 12788 ) <nl> * Fix CommitLogTest . testDeleteIfNotDirty ( CASSANDRA - 12854 ) <nl> * Don ' t tell users to turn off consistent rangemovements during rebuild . ( CASSANDRA - 12296 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java <nl> index cf4110c . . d9e8796 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java <nl> @ @ - 93 , 12 + 93 , 29 @ @ public class CQL3CasRequest implements CASRequest <nl> { <nl> assert condition instanceof ExistCondition | | condition instanceof NotExistCondition ; <nl> RowCondition previous = getConditionsForRow ( clustering ) ; <nl> - if ( previous ! = null & & ! ( previous . getClass ( ) . equals ( condition . getClass ( ) ) ) ) <nl> + if ( previous ! = null ) <nl> { <nl> - / / these should be prevented by the parser , but it doesn ' t hurt to check <nl> - throw ( previous instanceof NotExistCondition | | previous instanceof ExistCondition ) <nl> - ? new InvalidRequestException ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " ) <nl> - : new InvalidRequestException ( " Cannot mix IF conditions and IF " + ( isNotExist ? " NOT " : " " ) + " EXISTS for the same row " ) ; <nl> + if ( previous . getClass ( ) . equals ( condition . getClass ( ) ) ) <nl> + { <nl> + / / We can get here if a BATCH has 2 different statements on the same row with the same " exist " condition . <nl> + / / For instance ( assuming ' k ' is the full PK ) : <nl> + / / BEGIN BATCH <nl> + / / INSERT INTO t ( k , v1 ) VALUES ( 0 , ' foo ' ) IF NOT EXISTS ; <nl> + / / INSERT INTO t ( k , v2 ) VALUES ( 0 , ' bar ' ) IF NOT EXISTS ; <nl> + / / APPLY BATCH ; <nl> + / / Of course , those can be trivially rewritten by the user as a single INSERT statement , but we still don ' t <nl> + / / want this to be a problem ( see # 12867 in particular ) , so we simply return ( the condition itself has <nl> + / / already be set ) . <nl> + assert hasExists ; / / We shouldn ' t have a previous condition unless hasExists has been set already . <nl> + return ; <nl> + } <nl> + else <nl> + { <nl> + / / these should be prevented by the parser , but it doesn ' t hurt to check <nl> + throw ( previous instanceof NotExistCondition | | previous instanceof ExistCondition ) <nl> + ? new InvalidRequestException ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " ) <nl> + : new InvalidRequestException ( " Cannot mix IF conditions and IF " + ( isNotExist ? " NOT " : " " ) + " EXISTS for the same row " ) ; <nl> + } <nl> } <nl> <nl> setConditionsForRow ( clustering , condition ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> index 352100e . . 40db977 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java <nl> @ @ - 1421 , 4 + 1421 , 108 @ @ public class InsertUpdateIfConditionTest extends CQLTester <nl> assertRows ( execute ( " SELECT * FROM % s WHERE a = 7 " ) , <nl> row ( 7 , 7 , null , null , 7 ) ) ; <nl> } <nl> + <nl> + / * * <nl> + * Test for CASSANDRA - 12060 , using a table without clustering . <nl> + * / <nl> + @ Test <nl> + public void testMultiExistConditionOnSameRowNoClustering ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , v1 text , v2 text ) " ) ; <nl> + <nl> + / / Multiple inserts on the same row with not exist conditions <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 0 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " INSERT INTO % 1 $ s ( k , v2 ) values ( 0 , ' bar ' ) IF NOT EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE k = 0 " ) , row ( 0 , " foo " , " bar " ) ) ; <nl> + <nl> + / / Same , but both insert on the same column : doing so would almost surely be a user error , but that ' s the <nl> + / / original case reported in # 12867 , so being thorough . <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' bar ' ) IF NOT EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + / / As all statement gets the same timestamp , the biggest value ends up winning , so that ' s " foo " <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE k = 1 " ) , row ( 1 , " foo " , null ) ) ; <nl> + <nl> + / / Multiple deletes on the same row with exists conditions ( note that this is somewhat non - sensical , one of the <nl> + / / delete is redundant , we ' re just checking it doesn ' t break something ) <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " DELETE FROM % 1 $ s WHERE k = 0 IF EXISTS ; " <nl> + + " DELETE FROM % 1 $ s WHERE k = 0 IF EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE k = 0 " ) ) ; <nl> + <nl> + / / Validate we can ' t mix different type of conditions however <nl> + assertInvalidMessage ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " , <nl> + " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " DELETE FROM % 1 $ s WHERE k = 1 IF EXISTS ; " <nl> + + " APPLY BATCH " ) ; <nl> + <nl> + assertInvalidMessage ( " Cannot mix IF conditions and IF NOT EXISTS for the same row " , <nl> + " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " UPDATE % 1 $ s SET v2 = ' bar ' WHERE k = 1 IF v1 = ' foo ' ; " <nl> + + " APPLY BATCH " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Test for CASSANDRA - 12060 , using a table with clustering . <nl> + * / <nl> + @ Test <nl> + public void testMultiExistConditionOnSameRowClustering ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( k int , t int , v1 text , v2 text , PRIMARY KEY ( k , t ) ) " ) ; <nl> + <nl> + / / Multiple inserts on the same row with not exist conditions <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 0 , 0 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " INSERT INTO % 1 $ s ( k , t , v2 ) values ( 0 , 0 , ' bar ' ) IF NOT EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE k = 0 " ) , row ( 0 , 0 , " foo " , " bar " ) ) ; <nl> + <nl> + / / Same , but both insert on the same column : doing so would almost surely be a user error , but that ' s the <nl> + / / original case reported in # 12867 , so being thorough . <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' bar ' ) IF NOT EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + / / As all statement gets the same timestamp , the biggest value ends up winning , so that ' s " foo " <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE k = 1 " ) , row ( 1 , 0 , " foo " , null ) ) ; <nl> + <nl> + / / Multiple deletes on the same row with exists conditions ( note that this is somewhat non - sensical , one of the <nl> + / / delete is redundant , we ' re just checking it doesn ' t break something ) <nl> + assertRows ( execute ( " BEGIN BATCH " <nl> + + " DELETE FROM % 1 $ s WHERE k = 0 AND t = 0 IF EXISTS ; " <nl> + + " DELETE FROM % 1 $ s WHERE k = 0 AND t = 0 IF EXISTS ; " <nl> + + " APPLY BATCH " ) , <nl> + row ( true ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE k = 0 " ) ) ; <nl> + <nl> + / / Validate we can ' t mix different type of conditions however <nl> + assertInvalidMessage ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " , <nl> + " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " DELETE FROM % 1 $ s WHERE k = 1 AND t = 0 IF EXISTS ; " <nl> + + " APPLY BATCH " ) ; <nl> + <nl> + assertInvalidMessage ( " Cannot mix IF conditions and IF NOT EXISTS for the same row " , <nl> + " BEGIN BATCH " <nl> + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " <nl> + + " UPDATE % 1 $ s SET v2 = ' bar ' WHERE k = 1 AND t = 0 IF v1 = ' foo ' ; " <nl> + + " APPLY BATCH " ) ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f708602 . . 1d2c8f3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 10 
 + * Batch with multiple conditional updates for the same partition causes AssertionError ( CASSANDRA - 12867 ) 
 * Make AbstractReplicationStrategy extendable from outside its package ( CASSANDRA - 12788 ) 
 * Fix CommitLogTest . testDeleteIfNotDirty ( CASSANDRA - 12854 ) 
 * Don ' t tell users to turn off consistent rangemovements during rebuild . ( CASSANDRA - 12296 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java 
 index cf4110c . . d9e8796 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CQL3CasRequest . java 
 @ @ - 93 , 12 + 93 , 29 @ @ public class CQL3CasRequest implements CASRequest 
 { 
 assert condition instanceof ExistCondition | | condition instanceof NotExistCondition ; 
 RowCondition previous = getConditionsForRow ( clustering ) ; 
 - if ( previous ! = null & & ! ( previous . getClass ( ) . equals ( condition . getClass ( ) ) ) ) 
 + if ( previous ! = null ) 
 { 
 - / / these should be prevented by the parser , but it doesn ' t hurt to check 
 - throw ( previous instanceof NotExistCondition | | previous instanceof ExistCondition ) 
 - ? new InvalidRequestException ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " ) 
 - : new InvalidRequestException ( " Cannot mix IF conditions and IF " + ( isNotExist ? " NOT " : " " ) + " EXISTS for the same row " ) ; 
 + if ( previous . getClass ( ) . equals ( condition . getClass ( ) ) ) 
 + { 
 + / / We can get here if a BATCH has 2 different statements on the same row with the same " exist " condition . 
 + / / For instance ( assuming ' k ' is the full PK ) : 
 + / / BEGIN BATCH 
 + / / INSERT INTO t ( k , v1 ) VALUES ( 0 , ' foo ' ) IF NOT EXISTS ; 
 + / / INSERT INTO t ( k , v2 ) VALUES ( 0 , ' bar ' ) IF NOT EXISTS ; 
 + / / APPLY BATCH ; 
 + / / Of course , those can be trivially rewritten by the user as a single INSERT statement , but we still don ' t 
 + / / want this to be a problem ( see # 12867 in particular ) , so we simply return ( the condition itself has 
 + / / already be set ) . 
 + assert hasExists ; / / We shouldn ' t have a previous condition unless hasExists has been set already . 
 + return ; 
 + } 
 + else 
 + { 
 + / / these should be prevented by the parser , but it doesn ' t hurt to check 
 + throw ( previous instanceof NotExistCondition | | previous instanceof ExistCondition ) 
 + ? new InvalidRequestException ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " ) 
 + : new InvalidRequestException ( " Cannot mix IF conditions and IF " + ( isNotExist ? " NOT " : " " ) + " EXISTS for the same row " ) ; 
 + } 
 } 
 
 setConditionsForRow ( clustering , condition ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 index 352100e . . 40db977 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / InsertUpdateIfConditionTest . java 
 @ @ - 1421 , 4 + 1421 , 108 @ @ public class InsertUpdateIfConditionTest extends CQLTester 
 assertRows ( execute ( " SELECT * FROM % s WHERE a = 7 " ) , 
 row ( 7 , 7 , null , null , 7 ) ) ; 
 } 
 + 
 + / * * 
 + * Test for CASSANDRA - 12060 , using a table without clustering . 
 + * / 
 + @ Test 
 + public void testMultiExistConditionOnSameRowNoClustering ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int PRIMARY KEY , v1 text , v2 text ) " ) ; 
 + 
 + / / Multiple inserts on the same row with not exist conditions 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 0 , ' foo ' ) IF NOT EXISTS ; " 
 + + " INSERT INTO % 1 $ s ( k , v2 ) values ( 0 , ' bar ' ) IF NOT EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE k = 0 " ) , row ( 0 , " foo " , " bar " ) ) ; 
 + 
 + / / Same , but both insert on the same column : doing so would almost surely be a user error , but that ' s the 
 + / / original case reported in # 12867 , so being thorough . 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " 
 + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' bar ' ) IF NOT EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + / / As all statement gets the same timestamp , the biggest value ends up winning , so that ' s " foo " 
 + assertRows ( execute ( " SELECT * FROM % s WHERE k = 1 " ) , row ( 1 , " foo " , null ) ) ; 
 + 
 + / / Multiple deletes on the same row with exists conditions ( note that this is somewhat non - sensical , one of the 
 + / / delete is redundant , we ' re just checking it doesn ' t break something ) 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " DELETE FROM % 1 $ s WHERE k = 0 IF EXISTS ; " 
 + + " DELETE FROM % 1 $ s WHERE k = 0 IF EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE k = 0 " ) ) ; 
 + 
 + / / Validate we can ' t mix different type of conditions however 
 + assertInvalidMessage ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " , 
 + " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " 
 + + " DELETE FROM % 1 $ s WHERE k = 1 IF EXISTS ; " 
 + + " APPLY BATCH " ) ; 
 + 
 + assertInvalidMessage ( " Cannot mix IF conditions and IF NOT EXISTS for the same row " , 
 + " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , v1 ) values ( 1 , ' foo ' ) IF NOT EXISTS ; " 
 + + " UPDATE % 1 $ s SET v2 = ' bar ' WHERE k = 1 IF v1 = ' foo ' ; " 
 + + " APPLY BATCH " ) ; 
 + } 
 + 
 + / * * 
 + * Test for CASSANDRA - 12060 , using a table with clustering . 
 + * / 
 + @ Test 
 + public void testMultiExistConditionOnSameRowClustering ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( k int , t int , v1 text , v2 text , PRIMARY KEY ( k , t ) ) " ) ; 
 + 
 + / / Multiple inserts on the same row with not exist conditions 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 0 , 0 , ' foo ' ) IF NOT EXISTS ; " 
 + + " INSERT INTO % 1 $ s ( k , t , v2 ) values ( 0 , 0 , ' bar ' ) IF NOT EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE k = 0 " ) , row ( 0 , 0 , " foo " , " bar " ) ) ; 
 + 
 + / / Same , but both insert on the same column : doing so would almost surely be a user error , but that ' s the 
 + / / original case reported in # 12867 , so being thorough . 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " 
 + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' bar ' ) IF NOT EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + / / As all statement gets the same timestamp , the biggest value ends up winning , so that ' s " foo " 
 + assertRows ( execute ( " SELECT * FROM % s WHERE k = 1 " ) , row ( 1 , 0 , " foo " , null ) ) ; 
 + 
 + / / Multiple deletes on the same row with exists conditions ( note that this is somewhat non - sensical , one of the 
 + / / delete is redundant , we ' re just checking it doesn ' t break something ) 
 + assertRows ( execute ( " BEGIN BATCH " 
 + + " DELETE FROM % 1 $ s WHERE k = 0 AND t = 0 IF EXISTS ; " 
 + + " DELETE FROM % 1 $ s WHERE k = 0 AND t = 0 IF EXISTS ; " 
 + + " APPLY BATCH " ) , 
 + row ( true ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE k = 0 " ) ) ; 
 + 
 + / / Validate we can ' t mix different type of conditions however 
 + assertInvalidMessage ( " Cannot mix IF EXISTS and IF NOT EXISTS conditions for the same row " , 
 + " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " 
 + + " DELETE FROM % 1 $ s WHERE k = 1 AND t = 0 IF EXISTS ; " 
 + + " APPLY BATCH " ) ; 
 + 
 + assertInvalidMessage ( " Cannot mix IF conditions and IF NOT EXISTS for the same row " , 
 + " BEGIN BATCH " 
 + + " INSERT INTO % 1 $ s ( k , t , v1 ) values ( 1 , 0 , ' foo ' ) IF NOT EXISTS ; " 
 + + " UPDATE % 1 $ s SET v2 = ' bar ' WHERE k = 1 AND t = 0 IF v1 = ' foo ' ; " 
 + + " APPLY BATCH " ) ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
