BLEU SCORE: 0.028465126651392333

TEST MSG: Avoid assertion error when IndexSummary > 2G
GENERATED MSG: Make SSTableWriter . openEarly more robust and obvious

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 4302fdf . . f4360be 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 95 , 6 + 95 , 7 @ @ Merged from 2 . 2 : <nl> * Legacy caching options can prevent 3 . 0 upgrade ( CASSANDRA - 13384 ) <nl> * Nodetool upgradesstables / scrub / compact ignores system tables ( CASSANDRA - 13410 ) <nl> * Fix NPE issue in StorageService ( CASSANDRA - 13060 ) <nl> + * Avoid assertion error when IndexSummary > 2G ( CASSANDRA - 12014 ) <nl> Merged from 2 . 2 : <nl> * Avoid starting gossiper in RemoveTest ( CASSANDRA - 13407 ) <nl> * Fix weightedSize ( ) for row - cache reported by JMX and NodeTool ( CASSANDRA - 13393 ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> index 6110afe . . e3006b3 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> @ @ - 25 , 7 + 25 , 9 @ @ import java . util . TreeMap ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import org . apache . cassandra . config . Config ; <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . io . util . Memory ; <nl> import org . apache . cassandra . io . util . SafeMemoryWriter ; <nl> @ @ - 36 , 6 + 38 , 9 @ @ public class IndexSummaryBuilder implements AutoCloseable <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; <nl> <nl> + static final String defaultExpectedKeySizeName = Config . PROPERTY _ PREFIX + " index _ summary _ expected _ key _ size " ; <nl> + static long defaultExpectedKeySize = Long . valueOf ( System . getProperty ( defaultExpectedKeySizeName , " 64 " ) ) ; <nl> + <nl> / / the offset in the keys memory region to look for a given summary boundary <nl> private final SafeMemoryWriter offsets ; <nl> private final SafeMemoryWriter entries ; <nl> @ @ - 85 , 20 + 90 , 30 @ @ public class IndexSummaryBuilder implements AutoCloseable <nl> } <nl> } <nl> <nl> + / * * <nl> + * Build an index summary builder . <nl> + * <nl> + * @ param expectedKeys - the number of keys we expect in the sstable <nl> + * @ param minIndexInterval - the minimum interval between entries selected for sampling <nl> + * @ param samplingLevel - the level at which entries are sampled <nl> + * / <nl> public IndexSummaryBuilder ( long expectedKeys , int minIndexInterval , int samplingLevel ) <nl> { <nl> this . samplingLevel = samplingLevel ; <nl> this . startPoints = Downsampling . getStartPoints ( BASE _ SAMPLING _ LEVEL , samplingLevel ) ; <nl> <nl> + long expectedEntrySize = getEntrySize ( defaultExpectedKeySize ) ; <nl> long maxExpectedEntries = expectedKeys / minIndexInterval ; <nl> - if ( maxExpectedEntries > Integer . MAX _ VALUE ) <nl> + long maxExpectedEntriesSize = maxExpectedEntries * expectedEntrySize ; <nl> + if ( maxExpectedEntriesSize > Integer . MAX _ VALUE ) <nl> { <nl> / / that ' s a _ lot _ of keys , and a very low min index interval <nl> - int effectiveMinInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; <nl> + int effectiveMinInterval = ( int ) Math . ceil ( ( double ) ( expectedKeys * expectedEntrySize ) / Integer . MAX _ VALUE ) ; <nl> maxExpectedEntries = expectedKeys / effectiveMinInterval ; <nl> - assert maxExpectedEntries < = Integer . MAX _ VALUE : maxExpectedEntries ; <nl> - logger . warn ( " min _ index _ interval of { } is too low for { } expected keys ; using interval of { } instead " , <nl> - minIndexInterval , expectedKeys , effectiveMinInterval ) ; <nl> + maxExpectedEntriesSize = maxExpectedEntries * expectedEntrySize ; <nl> + assert maxExpectedEntriesSize < = Integer . MAX _ VALUE : maxExpectedEntriesSize ; <nl> + logger . warn ( " min _ index _ interval of { } is too low for { } expected keys of avg size { } ; using interval of { } instead " , <nl> + minIndexInterval , expectedKeys , defaultExpectedKeySize , effectiveMinInterval ) ; <nl> this . minIndexInterval = effectiveMinInterval ; <nl> } <nl> else <nl> @ @ - 109 , 13 + 124 , 30 @ @ public class IndexSummaryBuilder implements AutoCloseable <nl> / / for initializing data structures , adjust our estimates based on the sampling level <nl> maxExpectedEntries = Math . max ( 1 , ( maxExpectedEntries * samplingLevel ) / BASE _ SAMPLING _ LEVEL ) ; <nl> offsets = new SafeMemoryWriter ( 4 * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; <nl> - entries = new SafeMemoryWriter ( 40 * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; <nl> + entries = new SafeMemoryWriter ( expectedEntrySize * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; <nl> <nl> / / the summary will always contain the first index entry ( downsampling will never remove it ) <nl> nextSamplePosition = 0 ; <nl> indexIntervalMatches + + ; <nl> } <nl> <nl> + / * * <nl> + * Given a key , return how long the serialized index summary entry will be . <nl> + * / <nl> + private static long getEntrySize ( DecoratedKey key ) <nl> + { <nl> + return getEntrySize ( key . getKey ( ) . remaining ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Given a key size , return how long the serialized index summary entry will be , that is add 8 bytes to <nl> + * accomodate for the size of the position . <nl> + * / <nl> + private static long getEntrySize ( long keySize ) <nl> + { <nl> + return keySize + TypeSizes . sizeof ( 0L ) ; <nl> + } <nl> + <nl> / / the index file has been flushed to the provided position ; stash it and use that to recalculate our max readable boundary <nl> public void markIndexSynced ( long upToPosition ) <nl> { <nl> @ @ - 169 , 21 + 201 , 29 @ @ public class IndexSummaryBuilder implements AutoCloseable <nl> { <nl> if ( keysWritten = = nextSamplePosition ) <nl> { <nl> - assert entries . length ( ) < = Integer . MAX _ VALUE ; <nl> - offsets . writeInt ( ( int ) entries . length ( ) ) ; <nl> - entries . write ( decoratedKey . getKey ( ) ) ; <nl> - entries . writeLong ( indexStart ) ; <nl> - setNextSamplePosition ( keysWritten ) ; <nl> + if ( ( entries . length ( ) + getEntrySize ( decoratedKey ) ) < = Integer . MAX _ VALUE ) <nl> + { <nl> + offsets . writeInt ( ( int ) entries . length ( ) ) ; <nl> + entries . write ( decoratedKey . getKey ( ) ) ; <nl> + entries . writeLong ( indexStart ) ; <nl> + setNextSamplePosition ( keysWritten ) ; <nl> + } <nl> + else <nl> + { <nl> + / / we cannot fully sample this sstable due to too much memory in the index summary , so let ' s tell the user <nl> + logger . error ( " Memory capacity of index summary exceeded ( 2GB ) , index summary will not cover full sstable , " + <nl> + " you should increase min _ sampling _ level " ) ; <nl> + } <nl> } <nl> else if ( dataEnd ! = 0 & & keysWritten + 1 = = nextSamplePosition ) <nl> { <nl> / / this is the last key in this summary interval , so stash it <nl> - ReadableBoundary boundary = new ReadableBoundary ( decoratedKey , indexEnd , dataEnd , ( int ) ( offsets . length ( ) / 4 ) , entries . length ( ) ) ; <nl> + ReadableBoundary boundary = new ReadableBoundary ( decoratedKey , indexEnd , dataEnd , ( int ) ( offsets . length ( ) / 4 ) , entries . length ( ) ) ; <nl> lastReadableByData . put ( dataEnd , boundary ) ; <nl> lastReadableByIndex . put ( indexEnd , boundary ) ; <nl> } <nl> - keysWritten + + ; <nl> <nl> + keysWritten + + ; <nl> return this ; <nl> } <nl> <nl> @ @ - 251 , 12 + 291 , 12 @ @ public class IndexSummaryBuilder implements AutoCloseable <nl> return accumulate ; <nl> } <nl> <nl> - public static int entriesAtSamplingLevel ( int samplingLevel , int maxSummarySize ) <nl> + static int entriesAtSamplingLevel ( int samplingLevel , int maxSummarySize ) <nl> { <nl> return ( int ) Math . ceil ( ( samplingLevel * maxSummarySize ) / ( double ) BASE _ SAMPLING _ LEVEL ) ; <nl> } <nl> <nl> - public static int calculateSamplingLevel ( int currentSamplingLevel , int currentNumEntries , long targetNumEntries , int minIndexInterval , int maxIndexInterval ) <nl> + static int calculateSamplingLevel ( int currentSamplingLevel , int currentNumEntries , long targetNumEntries , int minIndexInterval , int maxIndexInterval ) <nl> { <nl> / / effective index interval = = ( BASE _ SAMPLING _ LEVEL / samplingLevel ) * minIndexInterval <nl> / / so we can just solve for minSamplingLevel here : <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> index baa6fad . . ad08ba0 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> <nl> import com . google . common . collect . Lists ; <nl> + import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . Util ; <nl> @ @ - 43 , 7 + 44 , 125 @ @ import static org . junit . Assert . * ; <nl> <nl> public class IndexSummaryTest <nl> { <nl> - IPartitioner partitioner = Util . testPartitioner ( ) ; <nl> + private final static Random random = new Random ( ) ; <nl> + private final static IPartitioner partitioner = Util . testPartitioner ( ) ; <nl> + <nl> + @ BeforeClass <nl> + public static void setup ( ) <nl> + { <nl> + final long seed = System . nanoTime ( ) ; <nl> + System . out . println ( " Using seed : " + seed ) ; <nl> + random . setSeed ( seed ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testIndexSummaryKeySizes ( ) throws IOException <nl> + { <nl> + testIndexSummaryProperties ( 32 , 100 ) ; <nl> + testIndexSummaryProperties ( 64 , 100 ) ; <nl> + testIndexSummaryProperties ( 100 , 100 ) ; <nl> + testIndexSummaryProperties ( 1000 , 100 ) ; <nl> + testIndexSummaryProperties ( 10000 , 100 ) ; <nl> + } <nl> + <nl> + private void testIndexSummaryProperties ( int keySize , int numKeys ) throws IOException <nl> + { <nl> + final int minIndexInterval = 1 ; <nl> + final List < DecoratedKey > keys = new ArrayList < > ( numKeys ) ; <nl> + <nl> + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) <nl> + { <nl> + for ( int i = 0 ; i < numKeys ; i + + ) <nl> + { <nl> + byte [ ] randomBytes = new byte [ keySize ] ; <nl> + random . nextBytes ( randomBytes ) ; <nl> + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; <nl> + keys . add ( key ) ; <nl> + builder . maybeAddEntry ( key , i ) ; <nl> + } <nl> + <nl> + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) <nl> + { <nl> + assertEquals ( numKeys , keys . size ( ) ) ; <nl> + assertEquals ( minIndexInterval , indexSummary . getMinIndexInterval ( ) ) ; <nl> + assertEquals ( numKeys , indexSummary . getMaxNumberOfEntries ( ) ) ; <nl> + assertEquals ( numKeys + 1 , indexSummary . getEstimatedKeyCount ( ) ) ; <nl> + <nl> + for ( int i = 0 ; i < numKeys ; i + + ) <nl> + assertEquals ( keys . get ( i ) . getKey ( ) , ByteBuffer . wrap ( indexSummary . getKey ( i ) ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Test an index summary whose total size is bigger than 2GB , <nl> + * the index summary builder should log an error but it should still <nl> + * create an index summary , albeit one that does not cover the entire sstable . <nl> + * / <nl> + @ Test <nl> + public void tesLargeIndexSummary ( ) throws IOException <nl> + { <nl> + final int numKeys = 1000000 ; <nl> + final int keySize = 3000 ; <nl> + final int minIndexInterval = 1 ; <nl> + <nl> + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) <nl> + { <nl> + for ( int i = 0 ; i < numKeys ; i + + ) <nl> + { <nl> + byte [ ] randomBytes = new byte [ keySize ] ; <nl> + random . nextBytes ( randomBytes ) ; <nl> + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; <nl> + builder . maybeAddEntry ( key , i ) ; <nl> + } <nl> + <nl> + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) <nl> + { <nl> + assertNotNull ( indexSummary ) ; <nl> + assertEquals ( numKeys , indexSummary . getMaxNumberOfEntries ( ) ) ; <nl> + assertEquals ( numKeys + 1 , indexSummary . getEstimatedKeyCount ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Test an index summary whose total size is bigger than 2GB , <nl> + * having updated IndexSummaryBuilder . defaultExpectedKeySize to match the size , <nl> + * the index summary should be downsampled automatically . <nl> + * / <nl> + @ Test <nl> + public void tesLargeIndexSummaryWithExpectedSizeMatching ( ) throws IOException <nl> + { <nl> + final int numKeys = 1000000 ; <nl> + final int keySize = 3000 ; <nl> + final int minIndexInterval = 1 ; <nl> + <nl> + long oldExpectedKeySize = IndexSummaryBuilder . defaultExpectedKeySize ; <nl> + IndexSummaryBuilder . defaultExpectedKeySize = 3000 ; <nl> + <nl> + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) <nl> + { <nl> + for ( int i = 0 ; i < numKeys ; i + + ) <nl> + { <nl> + byte [ ] randomBytes = new byte [ keySize ] ; <nl> + random . nextBytes ( randomBytes ) ; <nl> + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; <nl> + builder . maybeAddEntry ( key , i ) ; <nl> + } <nl> + <nl> + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) <nl> + { <nl> + assertNotNull ( indexSummary ) ; <nl> + assertEquals ( minIndexInterval * 2 , indexSummary . getMinIndexInterval ( ) ) ; <nl> + assertEquals ( numKeys / 2 , indexSummary . getMaxNumberOfEntries ( ) ) ; <nl> + assertEquals ( numKeys + 2 , indexSummary . getEstimatedKeyCount ( ) ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + IndexSummaryBuilder . defaultExpectedKeySize = oldExpectedKeySize ; <nl> + } <nl> + } <nl> <nl> @ Test <nl> public void testGetKey ( )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 4302fdf . . f4360be 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 95 , 6 + 95 , 7 @ @ Merged from 2 . 2 : 
 * Legacy caching options can prevent 3 . 0 upgrade ( CASSANDRA - 13384 ) 
 * Nodetool upgradesstables / scrub / compact ignores system tables ( CASSANDRA - 13410 ) 
 * Fix NPE issue in StorageService ( CASSANDRA - 13060 ) 
 + * Avoid assertion error when IndexSummary > 2G ( CASSANDRA - 12014 ) 
 Merged from 2 . 2 : 
 * Avoid starting gossiper in RemoveTest ( CASSANDRA - 13407 ) 
 * Fix weightedSize ( ) for row - cache reported by JMX and NodeTool ( CASSANDRA - 13393 ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 index 6110afe . . e3006b3 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 @ @ - 25 , 7 + 25 , 9 @ @ import java . util . TreeMap ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import org . apache . cassandra . config . Config ; 
 import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . io . util . Memory ; 
 import org . apache . cassandra . io . util . SafeMemoryWriter ; 
 @ @ - 36 , 6 + 38 , 9 @ @ public class IndexSummaryBuilder implements AutoCloseable 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; 
 
 + static final String defaultExpectedKeySizeName = Config . PROPERTY _ PREFIX + " index _ summary _ expected _ key _ size " ; 
 + static long defaultExpectedKeySize = Long . valueOf ( System . getProperty ( defaultExpectedKeySizeName , " 64 " ) ) ; 
 + 
 / / the offset in the keys memory region to look for a given summary boundary 
 private final SafeMemoryWriter offsets ; 
 private final SafeMemoryWriter entries ; 
 @ @ - 85 , 20 + 90 , 30 @ @ public class IndexSummaryBuilder implements AutoCloseable 
 } 
 } 
 
 + / * * 
 + * Build an index summary builder . 
 + * 
 + * @ param expectedKeys - the number of keys we expect in the sstable 
 + * @ param minIndexInterval - the minimum interval between entries selected for sampling 
 + * @ param samplingLevel - the level at which entries are sampled 
 + * / 
 public IndexSummaryBuilder ( long expectedKeys , int minIndexInterval , int samplingLevel ) 
 { 
 this . samplingLevel = samplingLevel ; 
 this . startPoints = Downsampling . getStartPoints ( BASE _ SAMPLING _ LEVEL , samplingLevel ) ; 
 
 + long expectedEntrySize = getEntrySize ( defaultExpectedKeySize ) ; 
 long maxExpectedEntries = expectedKeys / minIndexInterval ; 
 - if ( maxExpectedEntries > Integer . MAX _ VALUE ) 
 + long maxExpectedEntriesSize = maxExpectedEntries * expectedEntrySize ; 
 + if ( maxExpectedEntriesSize > Integer . MAX _ VALUE ) 
 { 
 / / that ' s a _ lot _ of keys , and a very low min index interval 
 - int effectiveMinInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; 
 + int effectiveMinInterval = ( int ) Math . ceil ( ( double ) ( expectedKeys * expectedEntrySize ) / Integer . MAX _ VALUE ) ; 
 maxExpectedEntries = expectedKeys / effectiveMinInterval ; 
 - assert maxExpectedEntries < = Integer . MAX _ VALUE : maxExpectedEntries ; 
 - logger . warn ( " min _ index _ interval of { } is too low for { } expected keys ; using interval of { } instead " , 
 - minIndexInterval , expectedKeys , effectiveMinInterval ) ; 
 + maxExpectedEntriesSize = maxExpectedEntries * expectedEntrySize ; 
 + assert maxExpectedEntriesSize < = Integer . MAX _ VALUE : maxExpectedEntriesSize ; 
 + logger . warn ( " min _ index _ interval of { } is too low for { } expected keys of avg size { } ; using interval of { } instead " , 
 + minIndexInterval , expectedKeys , defaultExpectedKeySize , effectiveMinInterval ) ; 
 this . minIndexInterval = effectiveMinInterval ; 
 } 
 else 
 @ @ - 109 , 13 + 124 , 30 @ @ public class IndexSummaryBuilder implements AutoCloseable 
 / / for initializing data structures , adjust our estimates based on the sampling level 
 maxExpectedEntries = Math . max ( 1 , ( maxExpectedEntries * samplingLevel ) / BASE _ SAMPLING _ LEVEL ) ; 
 offsets = new SafeMemoryWriter ( 4 * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; 
 - entries = new SafeMemoryWriter ( 40 * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; 
 + entries = new SafeMemoryWriter ( expectedEntrySize * maxExpectedEntries ) . order ( ByteOrder . nativeOrder ( ) ) ; 
 
 / / the summary will always contain the first index entry ( downsampling will never remove it ) 
 nextSamplePosition = 0 ; 
 indexIntervalMatches + + ; 
 } 
 
 + / * * 
 + * Given a key , return how long the serialized index summary entry will be . 
 + * / 
 + private static long getEntrySize ( DecoratedKey key ) 
 + { 
 + return getEntrySize ( key . getKey ( ) . remaining ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Given a key size , return how long the serialized index summary entry will be , that is add 8 bytes to 
 + * accomodate for the size of the position . 
 + * / 
 + private static long getEntrySize ( long keySize ) 
 + { 
 + return keySize + TypeSizes . sizeof ( 0L ) ; 
 + } 
 + 
 / / the index file has been flushed to the provided position ; stash it and use that to recalculate our max readable boundary 
 public void markIndexSynced ( long upToPosition ) 
 { 
 @ @ - 169 , 21 + 201 , 29 @ @ public class IndexSummaryBuilder implements AutoCloseable 
 { 
 if ( keysWritten = = nextSamplePosition ) 
 { 
 - assert entries . length ( ) < = Integer . MAX _ VALUE ; 
 - offsets . writeInt ( ( int ) entries . length ( ) ) ; 
 - entries . write ( decoratedKey . getKey ( ) ) ; 
 - entries . writeLong ( indexStart ) ; 
 - setNextSamplePosition ( keysWritten ) ; 
 + if ( ( entries . length ( ) + getEntrySize ( decoratedKey ) ) < = Integer . MAX _ VALUE ) 
 + { 
 + offsets . writeInt ( ( int ) entries . length ( ) ) ; 
 + entries . write ( decoratedKey . getKey ( ) ) ; 
 + entries . writeLong ( indexStart ) ; 
 + setNextSamplePosition ( keysWritten ) ; 
 + } 
 + else 
 + { 
 + / / we cannot fully sample this sstable due to too much memory in the index summary , so let ' s tell the user 
 + logger . error ( " Memory capacity of index summary exceeded ( 2GB ) , index summary will not cover full sstable , " + 
 + " you should increase min _ sampling _ level " ) ; 
 + } 
 } 
 else if ( dataEnd ! = 0 & & keysWritten + 1 = = nextSamplePosition ) 
 { 
 / / this is the last key in this summary interval , so stash it 
 - ReadableBoundary boundary = new ReadableBoundary ( decoratedKey , indexEnd , dataEnd , ( int ) ( offsets . length ( ) / 4 ) , entries . length ( ) ) ; 
 + ReadableBoundary boundary = new ReadableBoundary ( decoratedKey , indexEnd , dataEnd , ( int ) ( offsets . length ( ) / 4 ) , entries . length ( ) ) ; 
 lastReadableByData . put ( dataEnd , boundary ) ; 
 lastReadableByIndex . put ( indexEnd , boundary ) ; 
 } 
 - keysWritten + + ; 
 
 + keysWritten + + ; 
 return this ; 
 } 
 
 @ @ - 251 , 12 + 291 , 12 @ @ public class IndexSummaryBuilder implements AutoCloseable 
 return accumulate ; 
 } 
 
 - public static int entriesAtSamplingLevel ( int samplingLevel , int maxSummarySize ) 
 + static int entriesAtSamplingLevel ( int samplingLevel , int maxSummarySize ) 
 { 
 return ( int ) Math . ceil ( ( samplingLevel * maxSummarySize ) / ( double ) BASE _ SAMPLING _ LEVEL ) ; 
 } 
 
 - public static int calculateSamplingLevel ( int currentSamplingLevel , int currentNumEntries , long targetNumEntries , int minIndexInterval , int maxIndexInterval ) 
 + static int calculateSamplingLevel ( int currentSamplingLevel , int currentNumEntries , long targetNumEntries , int minIndexInterval , int maxIndexInterval ) 
 { 
 / / effective index interval = = ( BASE _ SAMPLING _ LEVEL / samplingLevel ) * minIndexInterval 
 / / so we can just solve for minSamplingLevel here : 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 index baa6fad . . ad08ba0 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . util . * ; 
 
 import com . google . common . collect . Lists ; 
 + import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . Util ; 
 @ @ - 43 , 7 + 44 , 125 @ @ import static org . junit . Assert . * ; 
 
 public class IndexSummaryTest 
 { 
 - IPartitioner partitioner = Util . testPartitioner ( ) ; 
 + private final static Random random = new Random ( ) ; 
 + private final static IPartitioner partitioner = Util . testPartitioner ( ) ; 
 + 
 + @ BeforeClass 
 + public static void setup ( ) 
 + { 
 + final long seed = System . nanoTime ( ) ; 
 + System . out . println ( " Using seed : " + seed ) ; 
 + random . setSeed ( seed ) ; 
 + } 
 + 
 + @ Test 
 + public void testIndexSummaryKeySizes ( ) throws IOException 
 + { 
 + testIndexSummaryProperties ( 32 , 100 ) ; 
 + testIndexSummaryProperties ( 64 , 100 ) ; 
 + testIndexSummaryProperties ( 100 , 100 ) ; 
 + testIndexSummaryProperties ( 1000 , 100 ) ; 
 + testIndexSummaryProperties ( 10000 , 100 ) ; 
 + } 
 + 
 + private void testIndexSummaryProperties ( int keySize , int numKeys ) throws IOException 
 + { 
 + final int minIndexInterval = 1 ; 
 + final List < DecoratedKey > keys = new ArrayList < > ( numKeys ) ; 
 + 
 + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) 
 + { 
 + for ( int i = 0 ; i < numKeys ; i + + ) 
 + { 
 + byte [ ] randomBytes = new byte [ keySize ] ; 
 + random . nextBytes ( randomBytes ) ; 
 + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; 
 + keys . add ( key ) ; 
 + builder . maybeAddEntry ( key , i ) ; 
 + } 
 + 
 + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) 
 + { 
 + assertEquals ( numKeys , keys . size ( ) ) ; 
 + assertEquals ( minIndexInterval , indexSummary . getMinIndexInterval ( ) ) ; 
 + assertEquals ( numKeys , indexSummary . getMaxNumberOfEntries ( ) ) ; 
 + assertEquals ( numKeys + 1 , indexSummary . getEstimatedKeyCount ( ) ) ; 
 + 
 + for ( int i = 0 ; i < numKeys ; i + + ) 
 + assertEquals ( keys . get ( i ) . getKey ( ) , ByteBuffer . wrap ( indexSummary . getKey ( i ) ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Test an index summary whose total size is bigger than 2GB , 
 + * the index summary builder should log an error but it should still 
 + * create an index summary , albeit one that does not cover the entire sstable . 
 + * / 
 + @ Test 
 + public void tesLargeIndexSummary ( ) throws IOException 
 + { 
 + final int numKeys = 1000000 ; 
 + final int keySize = 3000 ; 
 + final int minIndexInterval = 1 ; 
 + 
 + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) 
 + { 
 + for ( int i = 0 ; i < numKeys ; i + + ) 
 + { 
 + byte [ ] randomBytes = new byte [ keySize ] ; 
 + random . nextBytes ( randomBytes ) ; 
 + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; 
 + builder . maybeAddEntry ( key , i ) ; 
 + } 
 + 
 + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) 
 + { 
 + assertNotNull ( indexSummary ) ; 
 + assertEquals ( numKeys , indexSummary . getMaxNumberOfEntries ( ) ) ; 
 + assertEquals ( numKeys + 1 , indexSummary . getEstimatedKeyCount ( ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * Test an index summary whose total size is bigger than 2GB , 
 + * having updated IndexSummaryBuilder . defaultExpectedKeySize to match the size , 
 + * the index summary should be downsampled automatically . 
 + * / 
 + @ Test 
 + public void tesLargeIndexSummaryWithExpectedSizeMatching ( ) throws IOException 
 + { 
 + final int numKeys = 1000000 ; 
 + final int keySize = 3000 ; 
 + final int minIndexInterval = 1 ; 
 + 
 + long oldExpectedKeySize = IndexSummaryBuilder . defaultExpectedKeySize ; 
 + IndexSummaryBuilder . defaultExpectedKeySize = 3000 ; 
 + 
 + try ( IndexSummaryBuilder builder = new IndexSummaryBuilder ( numKeys , minIndexInterval , BASE _ SAMPLING _ LEVEL ) ) 
 + { 
 + for ( int i = 0 ; i < numKeys ; i + + ) 
 + { 
 + byte [ ] randomBytes = new byte [ keySize ] ; 
 + random . nextBytes ( randomBytes ) ; 
 + DecoratedKey key = partitioner . decorateKey ( ByteBuffer . wrap ( randomBytes ) ) ; 
 + builder . maybeAddEntry ( key , i ) ; 
 + } 
 + 
 + try ( IndexSummary indexSummary = builder . build ( partitioner ) ) 
 + { 
 + assertNotNull ( indexSummary ) ; 
 + assertEquals ( minIndexInterval * 2 , indexSummary . getMinIndexInterval ( ) ) ; 
 + assertEquals ( numKeys / 2 , indexSummary . getMaxNumberOfEntries ( ) ) ; 
 + assertEquals ( numKeys + 2 , indexSummary . getEstimatedKeyCount ( ) ) ; 
 + } 
 + } 
 + finally 
 + { 
 + IndexSummaryBuilder . defaultExpectedKeySize = oldExpectedKeySize ; 
 + } 
 + } 
 
 @ Test 
 public void testGetKey ( )

NEAREST DIFF:
ELIMINATEDSENTENCE
