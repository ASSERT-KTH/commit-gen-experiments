BLEU SCORE: 0.05862502026550899

TEST MSG: Support DISTINCT for static columns
GENERATED MSG: Add ability for CQL3 to list partition keys

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d23ce37 . . 7ec2501 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 20 , 6 + 20 , 8 @ @ <nl> * Account for range tombstones in min / max column names ( CASSANDRA - 7235 ) <nl> * Improve sub range repair validation ( CASSANDRA - 7317 ) <nl> * Accept subtypes for function results , type casts ( CASSANDRA - 6766 ) <nl> + * Support DISTINCT for static columns and fix behaviour when DISTINC is <nl> + not use ( CASSANDRA - 7305 ) . <nl> Merged from 1 . 2 : <nl> * Expose global ColumnFamily metrics ( CASSANDRA - 7273 ) <nl> * Handle possible integer overflow in FastByteArrayOutputStream ( CASSANDRA - 7373 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 422330c . . 0fbc20f 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 16 , 11 + 16 , 16 @ @ using the provided ' sstableupgrade ' tool . <nl> 2 . 0 . 9 <nl> = = = = = <nl> <nl> - Operations <nl> - - - - - - - - - - - <nl> + Upgrading <nl> + - - - - - - - - - <nl> - Default values for read _ repair _ chance and local _ read _ repair _ chance have been <nl> swapped . Namely , default read _ repair _ chance is now set to 0 . 0 , and default <nl> local _ read _ repair _ chance to 0 . 1 . <nl> + - Queries selecting only CQL static columns were ( mistakenly ) not returning one <nl> + result per row in the partition . This has been fixed and a SELECT DISTINCT <nl> + can be used when only the static column of a partition needs to be fetch <nl> + without fetching the whole partition . But if you use static columns , please <nl> + make sure this won ' t affect you ( see CASSANDRA - 7305 for details ) . <nl> <nl> <nl> 2 . 0 . 8 <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 7a91517 . . f106402 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 427 , 12 + 427 , 26 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> } <nl> } <nl> <nl> + private ColumnSlice makeStaticSlice ( ) <nl> + { <nl> + ColumnNameBuilder staticPrefix = cfDef . cfm . getStaticColumnNameBuilder ( ) ; <nl> + / / Note : we could use staticPrefix . build ( ) for the start bound , but EMPTY _ BYTE _ BUFFER gives us the <nl> + / / same effect while saving a few CPU cycles . <nl> + return isReversed <nl> + ? new ColumnSlice ( staticPrefix . buildAsEndOfRange ( ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) <nl> + : new ColumnSlice ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , staticPrefix . buildAsEndOfRange ( ) ) ; <nl> + } <nl> + <nl> private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables , int limit ) <nl> throws InvalidRequestException <nl> { <nl> + int toGroup = cfDef . isCompact ? - 1 : cfDef . clusteringColumnsCount ( ) ; <nl> if ( parameters . isDistinct ) <nl> { <nl> - return new SliceQueryFilter ( ColumnSlice . ALL _ COLUMNS _ ARRAY , false , 1 , - 1 ) ; <nl> + / / For distinct , we only care about fetching the beginning of each partition . If we don ' t have <nl> + / / static columns , we in fact only care about the first cell , so we query only that ( we don ' t " group " ) . <nl> + / / If we do have static columns , we do need to fetch the first full group ( to have the static columns values ) . <nl> + return new SliceQueryFilter ( ColumnSlice . ALL _ COLUMNS _ ARRAY , false , 1 , selectsStaticColumns ? toGroup : - 1 ) ; <nl> } <nl> else if ( isColumnRange ( ) ) <nl> { <nl> @ @ - 440 , 7 + 454 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> / / to account for the grouping of columns . <nl> / / Since that doesn ' t work for maps / sets / lists , we now use the compositesToGroup option of SliceQueryFilter . <nl> / / But we must preserve backward compatibility too ( for mixed version cluster that is ) . <nl> - int toGroup = cfDef . isCompact ? - 1 : cfDef . clusteringColumnsCount ( ) ; <nl> List < ByteBuffer > startBounds = getRequestedBound ( Bound . START , variables ) ; <nl> List < ByteBuffer > endBounds = getRequestedBound ( Bound . END , variables ) ; <nl> assert startBounds . size ( ) = = endBounds . size ( ) ; <nl> @ @ - 448 , 21 + 461 , 9 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> / / Handles fetching static columns . Note that for 2i , the filter is just used to restrict <nl> / / the part of the index to query so adding the static slice would be useless and confusing . <nl> / / For 2i , static columns are retrieve in CompositesSearcher with each index hit . <nl> - ColumnSlice staticSlice = null ; <nl> - if ( selectsStaticColumns & & ! usesSecondaryIndexing ) <nl> - { <nl> - ColumnNameBuilder staticPrefix = cfDef . cfm . getStaticColumnNameBuilder ( ) ; <nl> - / / Note : we could use staticPrefix . build ( ) for the start bound , but EMPTY _ BYTE _ BUFFER gives us the <nl> - / / same effect while saving a few CPU cycles . <nl> - staticSlice = isReversed <nl> - ? new ColumnSlice ( staticPrefix . buildAsEndOfRange ( ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) <nl> - : new ColumnSlice ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , staticPrefix . buildAsEndOfRange ( ) ) ; <nl> - <nl> - / / In the case where we only select static columns , we want to really only check the static columns . <nl> - / / So we return early as the rest of that method would actually make us query everything <nl> - if ( selectsOnlyStaticColumns ) <nl> - return sliceFilter ( staticSlice , limit , toGroup ) ; <nl> - } <nl> + ColumnSlice staticSlice = selectsStaticColumns & & ! usesSecondaryIndexing <nl> + ? makeStaticSlice ( ) <nl> + : null ; <nl> <nl> / / The case where startBounds = = 1 is common enough that it ' s worth optimizing <nl> if ( startBounds . size ( ) = = 1 ) <nl> @ @ - 1088 , 7 + 1089 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> ? ( ( CompositeType ) cfDef . cfm . getKeyValidator ( ) ) . split ( key ) <nl> : new ByteBuffer [ ] { key } ; <nl> <nl> - if ( parameters . isDistinct ) <nl> + if ( parameters . isDistinct & & ! selectsStaticColumns ) <nl> { <nl> if ( ! cf . hasOnlyTombstones ( now ) ) <nl> { <nl> @ @ - 1331 , 6 + 1332 , 23 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> return false ; <nl> } <nl> <nl> + private void validateDistinctSelection ( ) <nl> + throws InvalidRequestException <nl> + { <nl> + Collection < CFDefinition . Name > requestedColumns = selection . getColumns ( ) ; <nl> + for ( CFDefinition . Name name : requestedColumns ) <nl> + if ( name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS & & name . kind ! = CFDefinition . Name . Kind . STATIC ) <nl> + throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must only request partition key columns and / or static columns ( not % s ) " , name ) ) ; <nl> + <nl> + / / If it ' s a key range , we require that all partition key columns are selected so we don ' t have to bother with post - query grouping . <nl> + if ( ! isKeyRange ) <nl> + return ; <nl> + <nl> + for ( CFDefinition . Name name : cfDef . partitionKeys ( ) ) <nl> + if ( ! requestedColumns . contains ( name ) ) <nl> + throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must request all the partition key columns ( missing % s ) " , name ) ) ; <nl> + } <nl> + <nl> public static class RawStatement extends CFStatement <nl> { <nl> private final Parameters parameters ; <nl> @ @ - 1363 , 9 + 1381 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> ? Selection . wildcard ( cfDef ) <nl> : Selection . fromSelectors ( cfDef , selectClause ) ; <nl> <nl> - if ( parameters . isDistinct ) <nl> - validateDistinctSelection ( selection . getColumns ( ) , cfDef . partitionKeys ( ) ) ; <nl> - <nl> SelectStatement stmt = new SelectStatement ( cfDef , boundNames . size ( ) , parameters , selection , prepareLimit ( boundNames ) ) ; <nl> <nl> / * <nl> @ @ - 1440 , 6 + 1455 , 9 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> <nl> checkNeedsFiltering ( stmt ) ; <nl> <nl> + if ( parameters . isDistinct ) <nl> + stmt . validateDistinctSelection ( ) ; <nl> + <nl> return new ParsedStatement . Prepared ( stmt , boundNames ) ; <nl> } <nl> <nl> @ @ - 1961 , 18 + 1979 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> } <nl> } <nl> <nl> - private void validateDistinctSelection ( Collection < CFDefinition . Name > requestedColumns , Collection < CFDefinition . Name > partitionKey ) <nl> - throws InvalidRequestException <nl> - { <nl> - for ( CFDefinition . Name name : requestedColumns ) <nl> - if ( ! partitionKey . contains ( name ) ) <nl> - throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must only request partition key columns ( not % s ) " , name ) ) ; <nl> - <nl> - for ( CFDefinition . Name name : partitionKey ) <nl> - if ( ! requestedColumns . contains ( name ) ) <nl> - throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must request all the partition key columns ( missing % s ) " , name ) ) ; <nl> - } <nl> - <nl> private boolean containsAlias ( final ColumnIdentifier name ) <nl> { <nl> return Iterables . any ( selectClause , new Predicate < RawSelector > ( )
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java b / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java <nl> index b7bb733 . . fb32043 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java <nl> + + + b / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java <nl> @ @ - 119 , 9 + 119 , 9 @ @ public class OffHeapBitSet implements IBitSet <nl> <nl> public static OffHeapBitSet deserialize ( DataInput dis ) throws IOException <nl> { <nl> - int byteCount = dis . readInt ( ) * 8 ; <nl> + long byteCount = dis . readInt ( ) * 8L ; <nl> Memory memory = RefCountedMemory . allocate ( byteCount ) ; <nl> - for ( int i = 0 ; i < byteCount ; ) <nl> + for ( long i = 0 ; i < byteCount ; ) <nl> { <nl> long v = dis . readLong ( ) ; <nl> memory . setByte ( i + + , ( byte ) ( v > > > 0 ) ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d23ce37 . . 7ec2501 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 20 , 6 + 20 , 8 @ @ 
 * Account for range tombstones in min / max column names ( CASSANDRA - 7235 ) 
 * Improve sub range repair validation ( CASSANDRA - 7317 ) 
 * Accept subtypes for function results , type casts ( CASSANDRA - 6766 ) 
 + * Support DISTINCT for static columns and fix behaviour when DISTINC is 
 + not use ( CASSANDRA - 7305 ) . 
 Merged from 1 . 2 : 
 * Expose global ColumnFamily metrics ( CASSANDRA - 7273 ) 
 * Handle possible integer overflow in FastByteArrayOutputStream ( CASSANDRA - 7373 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 422330c . . 0fbc20f 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 16 , 11 + 16 , 16 @ @ using the provided ' sstableupgrade ' tool . 
 2 . 0 . 9 
 = = = = = 
 
 - Operations 
 - - - - - - - - - - - 
 + Upgrading 
 + - - - - - - - - - 
 - Default values for read _ repair _ chance and local _ read _ repair _ chance have been 
 swapped . Namely , default read _ repair _ chance is now set to 0 . 0 , and default 
 local _ read _ repair _ chance to 0 . 1 . 
 + - Queries selecting only CQL static columns were ( mistakenly ) not returning one 
 + result per row in the partition . This has been fixed and a SELECT DISTINCT 
 + can be used when only the static column of a partition needs to be fetch 
 + without fetching the whole partition . But if you use static columns , please 
 + make sure this won ' t affect you ( see CASSANDRA - 7305 for details ) . 
 
 
 2 . 0 . 8 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 7a91517 . . f106402 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 427 , 12 + 427 , 26 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 } 
 } 
 
 + private ColumnSlice makeStaticSlice ( ) 
 + { 
 + ColumnNameBuilder staticPrefix = cfDef . cfm . getStaticColumnNameBuilder ( ) ; 
 + / / Note : we could use staticPrefix . build ( ) for the start bound , but EMPTY _ BYTE _ BUFFER gives us the 
 + / / same effect while saving a few CPU cycles . 
 + return isReversed 
 + ? new ColumnSlice ( staticPrefix . buildAsEndOfRange ( ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) 
 + : new ColumnSlice ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , staticPrefix . buildAsEndOfRange ( ) ) ; 
 + } 
 + 
 private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables , int limit ) 
 throws InvalidRequestException 
 { 
 + int toGroup = cfDef . isCompact ? - 1 : cfDef . clusteringColumnsCount ( ) ; 
 if ( parameters . isDistinct ) 
 { 
 - return new SliceQueryFilter ( ColumnSlice . ALL _ COLUMNS _ ARRAY , false , 1 , - 1 ) ; 
 + / / For distinct , we only care about fetching the beginning of each partition . If we don ' t have 
 + / / static columns , we in fact only care about the first cell , so we query only that ( we don ' t " group " ) . 
 + / / If we do have static columns , we do need to fetch the first full group ( to have the static columns values ) . 
 + return new SliceQueryFilter ( ColumnSlice . ALL _ COLUMNS _ ARRAY , false , 1 , selectsStaticColumns ? toGroup : - 1 ) ; 
 } 
 else if ( isColumnRange ( ) ) 
 { 
 @ @ - 440 , 7 + 454 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 / / to account for the grouping of columns . 
 / / Since that doesn ' t work for maps / sets / lists , we now use the compositesToGroup option of SliceQueryFilter . 
 / / But we must preserve backward compatibility too ( for mixed version cluster that is ) . 
 - int toGroup = cfDef . isCompact ? - 1 : cfDef . clusteringColumnsCount ( ) ; 
 List < ByteBuffer > startBounds = getRequestedBound ( Bound . START , variables ) ; 
 List < ByteBuffer > endBounds = getRequestedBound ( Bound . END , variables ) ; 
 assert startBounds . size ( ) = = endBounds . size ( ) ; 
 @ @ - 448 , 21 + 461 , 9 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 / / Handles fetching static columns . Note that for 2i , the filter is just used to restrict 
 / / the part of the index to query so adding the static slice would be useless and confusing . 
 / / For 2i , static columns are retrieve in CompositesSearcher with each index hit . 
 - ColumnSlice staticSlice = null ; 
 - if ( selectsStaticColumns & & ! usesSecondaryIndexing ) 
 - { 
 - ColumnNameBuilder staticPrefix = cfDef . cfm . getStaticColumnNameBuilder ( ) ; 
 - / / Note : we could use staticPrefix . build ( ) for the start bound , but EMPTY _ BYTE _ BUFFER gives us the 
 - / / same effect while saving a few CPU cycles . 
 - staticSlice = isReversed 
 - ? new ColumnSlice ( staticPrefix . buildAsEndOfRange ( ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER ) 
 - : new ColumnSlice ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , staticPrefix . buildAsEndOfRange ( ) ) ; 
 - 
 - / / In the case where we only select static columns , we want to really only check the static columns . 
 - / / So we return early as the rest of that method would actually make us query everything 
 - if ( selectsOnlyStaticColumns ) 
 - return sliceFilter ( staticSlice , limit , toGroup ) ; 
 - } 
 + ColumnSlice staticSlice = selectsStaticColumns & & ! usesSecondaryIndexing 
 + ? makeStaticSlice ( ) 
 + : null ; 
 
 / / The case where startBounds = = 1 is common enough that it ' s worth optimizing 
 if ( startBounds . size ( ) = = 1 ) 
 @ @ - 1088 , 7 + 1089 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 ? ( ( CompositeType ) cfDef . cfm . getKeyValidator ( ) ) . split ( key ) 
 : new ByteBuffer [ ] { key } ; 
 
 - if ( parameters . isDistinct ) 
 + if ( parameters . isDistinct & & ! selectsStaticColumns ) 
 { 
 if ( ! cf . hasOnlyTombstones ( now ) ) 
 { 
 @ @ - 1331 , 6 + 1332 , 23 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 return false ; 
 } 
 
 + private void validateDistinctSelection ( ) 
 + throws InvalidRequestException 
 + { 
 + Collection < CFDefinition . Name > requestedColumns = selection . getColumns ( ) ; 
 + for ( CFDefinition . Name name : requestedColumns ) 
 + if ( name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS & & name . kind ! = CFDefinition . Name . Kind . STATIC ) 
 + throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must only request partition key columns and / or static columns ( not % s ) " , name ) ) ; 
 + 
 + / / If it ' s a key range , we require that all partition key columns are selected so we don ' t have to bother with post - query grouping . 
 + if ( ! isKeyRange ) 
 + return ; 
 + 
 + for ( CFDefinition . Name name : cfDef . partitionKeys ( ) ) 
 + if ( ! requestedColumns . contains ( name ) ) 
 + throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must request all the partition key columns ( missing % s ) " , name ) ) ; 
 + } 
 + 
 public static class RawStatement extends CFStatement 
 { 
 private final Parameters parameters ; 
 @ @ - 1363 , 9 + 1381 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 ? Selection . wildcard ( cfDef ) 
 : Selection . fromSelectors ( cfDef , selectClause ) ; 
 
 - if ( parameters . isDistinct ) 
 - validateDistinctSelection ( selection . getColumns ( ) , cfDef . partitionKeys ( ) ) ; 
 - 
 SelectStatement stmt = new SelectStatement ( cfDef , boundNames . size ( ) , parameters , selection , prepareLimit ( boundNames ) ) ; 
 
 / * 
 @ @ - 1440 , 6 + 1455 , 9 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 
 checkNeedsFiltering ( stmt ) ; 
 
 + if ( parameters . isDistinct ) 
 + stmt . validateDistinctSelection ( ) ; 
 + 
 return new ParsedStatement . Prepared ( stmt , boundNames ) ; 
 } 
 
 @ @ - 1961 , 18 + 1979 , 6 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 } 
 } 
 
 - private void validateDistinctSelection ( Collection < CFDefinition . Name > requestedColumns , Collection < CFDefinition . Name > partitionKey ) 
 - throws InvalidRequestException 
 - { 
 - for ( CFDefinition . Name name : requestedColumns ) 
 - if ( ! partitionKey . contains ( name ) ) 
 - throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must only request partition key columns ( not % s ) " , name ) ) ; 
 - 
 - for ( CFDefinition . Name name : partitionKey ) 
 - if ( ! requestedColumns . contains ( name ) ) 
 - throw new InvalidRequestException ( String . format ( " SELECT DISTINCT queries must request all the partition key columns ( missing % s ) " , name ) ) ; 
 - } 
 - 
 private boolean containsAlias ( final ColumnIdentifier name ) 
 { 
 return Iterables . any ( selectClause , new Predicate < RawSelector > ( )

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java b / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java 
 index b7bb733 . . fb32043 100644 
 - - - a / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java 
 + + + b / src / java / org / apache / cassandra / utils / obs / OffHeapBitSet . java 
 @ @ - 119 , 9 + 119 , 9 @ @ public class OffHeapBitSet implements IBitSet 
 
 public static OffHeapBitSet deserialize ( DataInput dis ) throws IOException 
 { 
 - int byteCount = dis . readInt ( ) * 8 ; 
 + long byteCount = dis . readInt ( ) * 8L ; 
 Memory memory = RefCountedMemory . allocate ( byteCount ) ; 
 - for ( int i = 0 ; i < byteCount ; ) 
 + for ( long i = 0 ; i < byteCount ; ) 
 { 
 long v = dis . readLong ( ) ; 
 memory . setByte ( i + + , ( byte ) ( v > > > 0 ) ) ;
