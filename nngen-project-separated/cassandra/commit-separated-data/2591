BLEU SCORE: 0.16451929399933107

TEST MSG: Fix error with super columns in mixed 1 . 2 - 2 . 0 cluster
GENERATED MSG: Remove pre - 2 . 0 supercolumn compatibility code

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9d27ebf . . 483ee0b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 39 , 6 + 39 , 7 @ @ <nl> * Make sure upgradesstables keeps sstable level ( CASSANDRA - 6958 ) <nl> * Fix LIMT with static columns ( CASSANDRA - 6956 ) <nl> * Fix clash with CQL column name in thrift validation ( CASSANDRA - 6892 ) <nl> + * Fix error with super columns in mixed 1 . 2 - 2 . 0 clusters ( CASSANDRA - 6966 ) <nl> Merged from 1 . 2 : <nl> * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) <nl> * add extra SSL cipher suites ( CASSANDRA - 6613 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / SuperColumns . java b / src / java / org / apache / cassandra / db / SuperColumns . java <nl> index 513db38 . . 0f74587 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SuperColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / SuperColumns . java <nl> @ @ - 260 , 21 + 260 , 13 @ @ public class SuperColumns <nl> <nl> public static SCFilter namesFilterToSC ( CompositeType type , NamesQueryFilter filter ) <nl> { <nl> - ByteBuffer scName = null ; <nl> - SortedSet < ByteBuffer > newColumns = new TreeSet < ByteBuffer > ( filter . columns . comparator ( ) ) ; <nl> + SortedSet < ByteBuffer > newColumns = new TreeSet < > ( type . types . get ( 1 ) ) ; <nl> + ByteBuffer scName = scName ( filter . columns . first ( ) ) ; <nl> for ( ByteBuffer name : filter . columns ) <nl> { <nl> - ByteBuffer newScName = scName ( name ) ; <nl> - <nl> - if ( scName = = null ) <nl> - { <nl> - scName = newScName ; <nl> - } <nl> - else if ( type . types . get ( 0 ) . compare ( scName , newScName ) ! = 0 ) <nl> - { <nl> - / / If we ' re selecting column across multiple SC , it ' s not something we can translate for an old node <nl> + / / If we ' re selecting column across multiple SC , it ' s not something we can translate for an old node <nl> + if ( type . types . get ( 0 ) . compare ( scName , scName ( name ) ) ! = 0 ) <nl> throw new RuntimeException ( " Cannot convert filter to old super column format . Update all nodes to Cassandra 2 . 0 first . " ) ; <nl> - } <nl> <nl> newColumns . add ( subName ( name ) ) ; <nl> } <nl> @ @ - 331 , 10 + 323 , 14 @ @ public class SuperColumns <nl> return new SCFilter ( null , new SliceQueryFilter ( scName ( start ) , scName ( finish ) , reversed , filter . count ) ) ; <nl> } <nl> } <nl> - else if ( filter . compositesToGroup = = 0 & & type . types . get ( 0 ) . compare ( scName ( start ) , scName ( finish ) ) = = 0 ) <nl> + else if ( filter . compositesToGroup = = - 1 & & type . types . get ( 0 ) . compare ( scName ( start ) , scName ( finish ) ) = = 0 ) <nl> { <nl> / / A slice of subcolumns <nl> - return new SCFilter ( scName ( start ) , filter . withUpdatedSlice ( subName ( start ) , subName ( finish ) ) ) ; <nl> + ByteBuffer newStart = subName ( start ) ; <nl> + ByteBuffer newFinish = subName ( finish ) ; <nl> + return new SCFilter ( scName ( start ) , <nl> + filter . withUpdatedSlice ( newStart = = null ? ByteBufferUtil . EMPTY _ BYTE _ BUFFER : newStart , <nl> + newFinish = = null ? ByteBufferUtil . EMPTY _ BYTE _ BUFFER : newFinish ) ) ; <nl> } <nl> } <nl> else if ( ! reversed )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9d27ebf . . 483ee0b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 39 , 6 + 39 , 7 @ @ 
 * Make sure upgradesstables keeps sstable level ( CASSANDRA - 6958 ) 
 * Fix LIMT with static columns ( CASSANDRA - 6956 ) 
 * Fix clash with CQL column name in thrift validation ( CASSANDRA - 6892 ) 
 + * Fix error with super columns in mixed 1 . 2 - 2 . 0 clusters ( CASSANDRA - 6966 ) 
 Merged from 1 . 2 : 
 * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) 
 * add extra SSL cipher suites ( CASSANDRA - 6613 ) 
 diff - - git a / src / java / org / apache / cassandra / db / SuperColumns . java b / src / java / org / apache / cassandra / db / SuperColumns . java 
 index 513db38 . . 0f74587 100644 
 - - - a / src / java / org / apache / cassandra / db / SuperColumns . java 
 + + + b / src / java / org / apache / cassandra / db / SuperColumns . java 
 @ @ - 260 , 21 + 260 , 13 @ @ public class SuperColumns 
 
 public static SCFilter namesFilterToSC ( CompositeType type , NamesQueryFilter filter ) 
 { 
 - ByteBuffer scName = null ; 
 - SortedSet < ByteBuffer > newColumns = new TreeSet < ByteBuffer > ( filter . columns . comparator ( ) ) ; 
 + SortedSet < ByteBuffer > newColumns = new TreeSet < > ( type . types . get ( 1 ) ) ; 
 + ByteBuffer scName = scName ( filter . columns . first ( ) ) ; 
 for ( ByteBuffer name : filter . columns ) 
 { 
 - ByteBuffer newScName = scName ( name ) ; 
 - 
 - if ( scName = = null ) 
 - { 
 - scName = newScName ; 
 - } 
 - else if ( type . types . get ( 0 ) . compare ( scName , newScName ) ! = 0 ) 
 - { 
 - / / If we ' re selecting column across multiple SC , it ' s not something we can translate for an old node 
 + / / If we ' re selecting column across multiple SC , it ' s not something we can translate for an old node 
 + if ( type . types . get ( 0 ) . compare ( scName , scName ( name ) ) ! = 0 ) 
 throw new RuntimeException ( " Cannot convert filter to old super column format . Update all nodes to Cassandra 2 . 0 first . " ) ; 
 - } 
 
 newColumns . add ( subName ( name ) ) ; 
 } 
 @ @ - 331 , 10 + 323 , 14 @ @ public class SuperColumns 
 return new SCFilter ( null , new SliceQueryFilter ( scName ( start ) , scName ( finish ) , reversed , filter . count ) ) ; 
 } 
 } 
 - else if ( filter . compositesToGroup = = 0 & & type . types . get ( 0 ) . compare ( scName ( start ) , scName ( finish ) ) = = 0 ) 
 + else if ( filter . compositesToGroup = = - 1 & & type . types . get ( 0 ) . compare ( scName ( start ) , scName ( finish ) ) = = 0 ) 
 { 
 / / A slice of subcolumns 
 - return new SCFilter ( scName ( start ) , filter . withUpdatedSlice ( subName ( start ) , subName ( finish ) ) ) ; 
 + ByteBuffer newStart = subName ( start ) ; 
 + ByteBuffer newFinish = subName ( finish ) ; 
 + return new SCFilter ( scName ( start ) , 
 + filter . withUpdatedSlice ( newStart = = null ? ByteBufferUtil . EMPTY _ BYTE _ BUFFER : newStart , 
 + newFinish = = null ? ByteBufferUtil . EMPTY _ BYTE _ BUFFER : newFinish ) ) ; 
 } 
 } 
 else if ( ! reversed )

NEAREST DIFF:
ELIMINATEDSENTENCE
