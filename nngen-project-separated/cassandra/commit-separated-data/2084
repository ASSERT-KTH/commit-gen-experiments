BLEU SCORE: 0.026341919627252283

TEST MSG: Add protocol v4 spec document
GENERATED MSG: Add a build and run script to client _ only example .

TEST DIFF (one line): diff - - git a / doc / native _ protocol _ v4 . spec b / doc / native _ protocol _ v4 . spec <nl> new file mode 100644 <nl> index 0000000 . . 02aac3b <nl> - - - / dev / null <nl> + + + b / doc / native _ protocol _ v4 . spec <nl> @ @ - 0 , 0 + 1 , 899 @ @ <nl> + <nl> + CQL BINARY PROTOCOL v4 <nl> + <nl> + <nl> + Table of Contents <nl> + <nl> + 1 . Overview <nl> + 2 . Frame header <nl> + 2 . 1 . version <nl> + 2 . 2 . flags <nl> + 2 . 3 . stream <nl> + 2 . 4 . opcode <nl> + 2 . 5 . length <nl> + 3 . Notations <nl> + 4 . Messages <nl> + 4 . 1 . Requests <nl> + 4 . 1 . 1 . STARTUP <nl> + 4 . 1 . 2 . AUTH _ RESPONSE <nl> + 4 . 1 . 3 . OPTIONS <nl> + 4 . 1 . 4 . QUERY <nl> + 4 . 1 . 5 . PREPARE <nl> + 4 . 1 . 6 . EXECUTE <nl> + 4 . 1 . 7 . BATCH <nl> + 4 . 1 . 8 . REGISTER <nl> + 4 . 2 . Responses <nl> + 4 . 2 . 1 . ERROR <nl> + 4 . 2 . 2 . READY <nl> + 4 . 2 . 3 . AUTHENTICATE <nl> + 4 . 2 . 4 . SUPPORTED <nl> + 4 . 2 . 5 . RESULT <nl> + 4 . 2 . 5 . 1 . Void <nl> + 4 . 2 . 5 . 2 . Rows <nl> + 4 . 2 . 5 . 3 . Set _ keyspace <nl> + 4 . 2 . 5 . 4 . Prepared <nl> + 4 . 2 . 5 . 5 . Schema _ change <nl> + 4 . 2 . 6 . EVENT <nl> + 4 . 2 . 7 . AUTH _ CHALLENGE <nl> + 4 . 2 . 8 . AUTH _ SUCCESS <nl> + 5 . Compression <nl> + 6 . Collection types <nl> + 7 . User Defined and tuple types <nl> + 8 . Result paging <nl> + 9 . Error codes <nl> + 10 . Changes from v3 <nl> + <nl> + <nl> + 1 . Overview <nl> + <nl> + The CQL binary protocol is a frame based protocol . Frames are defined as : <nl> + <nl> + 0 8 16 24 32 40 <nl> + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + | version | flags | stream | opcode | <nl> + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + | length | <nl> + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + | | <nl> + . . . . body . . . . <nl> + . . <nl> + . . <nl> + + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <nl> + <nl> + The protocol is big - endian ( network byte order ) . <nl> + <nl> + Each frame contains a fixed size header ( 9 bytes ) followed by a variable size <nl> + body . The header is described in Section 2 . The content of the body depends <nl> + on the header opcode value ( the body can in particular be empty for some <nl> + opcode values ) . The list of allowed opcode is defined Section 2 . 3 and the <nl> + details of each corresponding message is described Section 4 . <nl> + <nl> + The protocol distinguishes 2 types of frames : requests and responses . Requests <nl> + are those frame sent by the clients to the server , response are the ones sent <nl> + by the server . Note however that the protocol supports server pushes ( events ) <nl> + so responses does not necessarily come right after a client request . <nl> + <nl> + Note to client implementors : clients library should always assume that the <nl> + body of a given frame may contain more data than what is described in this <nl> + document . It will however always be safe to ignore the remaining of the frame <nl> + body in such cases . The reason is that this may allow to sometimes extend the <nl> + protocol with optional features without needing to change the protocol <nl> + version . <nl> + <nl> + <nl> + <nl> + 2 . Frame header <nl> + <nl> + 2 . 1 . version <nl> + <nl> + The version is a single byte that indicate both the direction of the message <nl> + ( request or response ) and the version of the protocol in use . The up - most bit <nl> + of version is used to define the direction of the message : 0 indicates a <nl> + request , 1 indicates a responses . This can be useful for protocol analyzers to <nl> + distinguish the nature of the packet from the direction which it is moving . <nl> + The rest of that byte is the protocol version ( 4 for the protocol defined in <nl> + this document ) . In other words , for this version of the protocol , version will <nl> + have one of : <nl> + 0x04 Request frame for this protocol version <nl> + 0x84 Response frame for this protocol version <nl> + <nl> + Please note that the while every message ship with the version , only one version <nl> + of messages is accepted on a given connection . In other words , the first message <nl> + exchanged ( STARTUP ) sets the version for the connection for the lifetime of this <nl> + connection . <nl> + <nl> + This document describe the version 3 of the protocol . For the changes made since <nl> + version 3 , see Section 10 . <nl> + <nl> + <nl> + 2 . 2 . flags <nl> + <nl> + Flags applying to this frame . The flags have the following meaning ( described <nl> + by the mask that allow to select them ) : <nl> + 0x01 : Compression flag . If set , the frame body is compressed . The actual <nl> + compression to use should have been set up beforehand through the <nl> + Startup message ( which thus cannot be compressed ; Section 4 . 1 . 1 ) . <nl> + 0x02 : Tracing flag . For a request frame , this indicate the client requires <nl> + tracing of the request . Note that not all requests support tracing . <nl> + Currently , only QUERY , PREPARE and EXECUTE queries support tracing . <nl> + Other requests will simply ignore the tracing flag if set . If a <nl> + request support tracing and the tracing flag was set , the response to <nl> + this request will have the tracing flag set and contain tracing <nl> + information . <nl> + If a response frame has the tracing flag set , its body contains <nl> + a tracing ID . The tracing ID is a [ uuid ] and is the first thing in <nl> + the frame body . The rest of the body will then be the usual body <nl> + corresponding to the response opcode . <nl> + <nl> + The rest of the flags is currently unused and ignored . <nl> + <nl> + 2 . 3 . stream <nl> + <nl> + A frame has a stream id ( a [ short ] value ) . When sending request messages , this <nl> + stream id must be set by the client to a non - negative value ( negative stream id <nl> + are reserved for streams initiated by the server ; currently all EVENT messages <nl> + ( section 4 . 2 . 6 ) have a streamId of - 1 ) . If a client sends a request message <nl> + with the stream id X , it is guaranteed that the stream id of the response to <nl> + that message will be X . <nl> + <nl> + This allow to deal with the asynchronous nature of the protocol . If a client <nl> + sends multiple messages simultaneously ( without waiting for responses ) , there <nl> + is no guarantee on the order of the responses . For instance , if the client <nl> + writes REQ _ 1 , REQ _ 2 , REQ _ 3 on the wire ( in that order ) , the server might <nl> + respond to REQ _ 3 ( or REQ _ 2 ) first . Assigning different stream id to these 3 <nl> + requests allows the client to distinguish to which request an received answer <nl> + respond to . As there can only be 32768 different simultaneous streams , it is up <nl> + to the client to reuse stream id . <nl> + <nl> + Note that clients are free to use the protocol synchronously ( i . e . wait for <nl> + the response to REQ _ N before sending REQ _ N + 1 ) . In that case , the stream id <nl> + can be safely set to 0 . Clients should also feel free to use only a subset of <nl> + the 32768 maximum possible stream ids if it is simpler for those <nl> + implementation . <nl> + <nl> + 2 . 4 . opcode <nl> + <nl> + An integer byte that distinguish the actual message : <nl> + 0x00 ERROR <nl> + 0x01 STARTUP <nl> + 0x02 READY <nl> + 0x03 AUTHENTICATE <nl> + 0x05 OPTIONS <nl> + 0x06 SUPPORTED <nl> + 0x07 QUERY <nl> + 0x08 RESULT <nl> + 0x09 PREPARE <nl> + 0x0A EXECUTE <nl> + 0x0B REGISTER <nl> + 0x0C EVENT <nl> + 0x0D BATCH <nl> + 0x0E AUTH _ CHALLENGE <nl> + 0x0F AUTH _ RESPONSE <nl> + 0x10 AUTH _ SUCCESS <nl> + <nl> + Messages are described in Section 4 . <nl> + <nl> + ( Note that there is no 0x04 message in this version of the protocol ) <nl> + <nl> + <nl> + 2 . 5 . length <nl> + <nl> + A 4 byte integer representing the length of the body of the frame ( note : <nl> + currently a frame is limited to 256MB in length ) . <nl> + <nl> + <nl> + 3 . Notations <nl> + <nl> + To describe the layout of the frame body for the messages in Section 4 , we <nl> + define the following : <nl> + <nl> + [ int ] A 4 bytes integer <nl> + [ long ] A 8 bytes integer <nl> + [ short ] A 2 bytes unsigned integer <nl> + [ string ] A [ short ] n , followed by n bytes representing an UTF - 8 <nl> + string . <nl> + [ long string ] An [ int ] n , followed by n bytes representing an UTF - 8 string . <nl> + [ uuid ] A 16 bytes long uuid . <nl> + [ string list ] A [ short ] n , followed by n [ string ] . <nl> + [ bytes ] A [ int ] n , followed by n bytes if n > = 0 . If n < 0 , <nl> + no byte should follow and the value represented is ` null ` . <nl> + [ short bytes ] A [ short ] n , followed by n bytes if n > = 0 . <nl> + <nl> + [ option ] A pair of < id > < value > where < id > is a [ short ] representing <nl> + the option id and < value > depends on that option ( and can be <nl> + of size 0 ) . The supported id ( and the corresponding < value > ) <nl> + will be described when this is used . <nl> + [ option list ] A [ short ] n , followed by n [ option ] . <nl> + [ inet ] An address ( ip and port ) to a node . It consists of one <nl> + [ byte ] n , that represents the address size , followed by n <nl> + [ byte ] representing the IP address ( in practice n can only be <nl> + either 4 ( IPv4 ) or 16 ( IPv6 ) ) , following by one [ int ] <nl> + representing the port . <nl> + [ consistency ] A consistency level specification . This is a [ short ] <nl> + representing a consistency level with the following <nl> + correspondance : <nl> + 0x0000 ANY <nl> + 0x0001 ONE <nl> + 0x0002 TWO <nl> + 0x0003 THREE <nl> + 0x0004 QUORUM <nl> + 0x0005 ALL <nl> + 0x0006 LOCAL _ QUORUM <nl> + 0x0007 EACH _ QUORUM <nl> + 0x0008 SERIAL <nl> + 0x0009 LOCAL _ SERIAL <nl> + 0x000A LOCAL _ ONE <nl> + <nl> + [ string map ] A [ short ] n , followed by n pair < k > < v > where < k > and < v > <nl> + are [ string ] . <nl> + [ string multimap ] A [ short ] n , followed by n pair < k > < v > where < k > is a <nl> + [ string ] and < v > is a [ string list ] . <nl> + <nl> + <nl> + 4 . Messages <nl> + <nl> + 4 . 1 . Requests <nl> + <nl> + Note that outside of their normal responses ( described below ) , all requests <nl> + can get an ERROR message ( Section 4 . 2 . 1 ) as response . <nl> + <nl> + 4 . 1 . 1 . STARTUP <nl> + <nl> + Initialize the connection . The server will respond by either a READY message <nl> + ( in which case the connection is ready for queries ) or an AUTHENTICATE message <nl> + ( in which case credentials will need to be provided using AUTH _ RESPONSE ) . <nl> + <nl> + This must be the first message of the connection , except for OPTIONS that can <nl> + be sent before to find out the options supported by the server . Once the <nl> + connection has been initialized , a client should not send any more STARTUP <nl> + message . <nl> + <nl> + The body is a [ string map ] of options . Possible options are : <nl> + - " CQL _ VERSION " : the version of CQL to use . This option is mandatory and <nl> + currenty , the only version supported is " 3 . 0 . 0 " . Note that this is <nl> + different from the protocol version . <nl> + - " COMPRESSION " : the compression algorithm to use for frames ( See section 5 ) . <nl> + This is optional , if not specified no compression will be used . <nl> + <nl> + <nl> + 4 . 1 . 2 . AUTH _ RESPONSE <nl> + <nl> + Answers a server authentication challenge . <nl> + <nl> + Authentication in the protocol is SASL based . The server sends authentication <nl> + challenges ( a bytes token ) to which the client answer with this message . Those <nl> + exchanges continue until the server accepts the authentication by sending a <nl> + AUTH _ SUCCESS message after a client AUTH _ RESPONSE . It is however that client that <nl> + initiate the exchange by sending an initial AUTH _ RESPONSE in response to a <nl> + server AUTHENTICATE request . <nl> + <nl> + The body of this message is a single [ bytes ] token . The details of what this <nl> + token contains ( and when it can be null / empty , if ever ) depends on the actual <nl> + authenticator used . <nl> + <nl> + The response to a AUTH _ RESPONSE is either a follow - up AUTH _ CHALLENGE message , <nl> + an AUTH _ SUCCESS message or an ERROR message . <nl> + <nl> + <nl> + 4 . 1 . 3 . OPTIONS <nl> + <nl> + Asks the server to return what STARTUP options are supported . The body of an <nl> + OPTIONS message should be empty and the server will respond with a SUPPORTED <nl> + message . <nl> + <nl> + <nl> + 4 . 1 . 4 . QUERY <nl> + <nl> + Performs a CQL query . The body of the message must be : <nl> + < query > < query _ parameters > <nl> + where < query > is a [ long string ] representing the query and <nl> + < query _ parameters > must be <nl> + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] <nl> + where : <nl> + - < consistency > is the [ consistency ] level for the operation . <nl> + - < flags > is a [ byte ] whose bits define the options for this query and <nl> + in particular influence what the remainder of the message contains . <nl> + A flag is set if the bit corresponding to its ` mask ` is set . Supported <nl> + flags are , given there mask : <nl> + 0x01 : Values . In that case , a [ short ] < n > followed by < n > [ bytes ] <nl> + values are provided . Those value are used for bound variables in <nl> + the query . Optionally , if the 0x40 flag is present , each value <nl> + will be preceded by a [ string ] name , representing the name of <nl> + the marker the value must be binded to . This is optional , and <nl> + if not present , values will be binded by position . <nl> + 0x02 : Skip _ metadata . If present , the Result Set returned as a response <nl> + to that query ( if any ) will have the NO _ METADATA flag ( see <nl> + Section 4 . 2 . 5 . 2 ) . <nl> + 0x04 : Page _ size . In that case , < result _ page _ size > is an [ int ] <nl> + controlling the desired page size of the result ( in CQL3 rows ) . <nl> + See the section on paging ( Section 8 ) for more details . <nl> + 0x08 : With _ paging _ state . If present , < paging _ state > should be present . <nl> + < paging _ state > is a [ bytes ] value that should have been returned <nl> + in a result set ( Section 4 . 2 . 5 . 2 ) . If provided , the query will be <nl> + executed but starting from a given paging state . This also to <nl> + continue paging on a different node from the one it has been <nl> + started ( See Section 8 for more details ) . <nl> + 0x10 : With serial consistency . If present , < serial _ consistency > should be <nl> + present . < serial _ consistency > is the [ consistency ] level for the <nl> + serial phase of conditional updates . That consitency can only be <nl> + either SERIAL or LOCAL _ SERIAL and if not present , it defaults to <nl> + SERIAL . This option will be ignored for anything else that a <nl> + conditional update / insert . <nl> + 0x20 : With default timestamp . If present , < timestamp > should be present . <nl> + < timestamp > is a [ long ] representing the default timestamp for the query <nl> + in microseconds ( negative values are forbidden ) . If provided , this will <nl> + replace the server side assigned timestamp as default timestamp . <nl> + Note that a timestamp in the query itself will still override <nl> + this timestamp . This is entirely optional . <nl> + 0x40 : With names for values . This only makes sense if the 0x01 flag is set and <nl> + is ignored otherwise . If present , the values from the 0x01 flag will <nl> + be preceded by a name ( see above ) . Note that this is only useful for <nl> + QUERY requests where named bind markers are used ; for EXECUTE statements , <nl> + since the names for the expected values was returned during preparation , <nl> + a client can always provide values in the right order without any names <nl> + and using this flag , while supported , is almost surely inefficient . <nl> + <nl> + Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , <nl> + TRUNCATE , . . . ) . <nl> + <nl> + The server will respond to a QUERY message with a RESULT message , the content <nl> + of which depends on the query . <nl> + <nl> + <nl> + 4 . 1 . 5 . PREPARE <nl> + <nl> + Prepare a query for later execution ( through EXECUTE ) . The body consists of <nl> + the CQL query to prepare as a [ long string ] . <nl> + <nl> + The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , <nl> + see Section 4 . 2 . 5 ) . <nl> + <nl> + <nl> + 4 . 1 . 6 . EXECUTE <nl> + <nl> + Executes a prepared query . The body of the message must be : <nl> + < id > < query _ parameters > <nl> + where < id > is the prepared query ID . It ' s the [ short bytes ] returned as a <nl> + response to a PREPARE message . As for < query _ parameters > , it has the exact <nl> + same definition than in QUERY ( see Section 4 . 1 . 4 ) . <nl> + <nl> + The response from the server will be a RESULT message . <nl> + <nl> + <nl> + 4 . 1 . 7 . BATCH <nl> + <nl> + Allows executing a list of queries ( prepared or not ) as a batch ( note that <nl> + only DML statements are accepted in a batch ) . The body of the message must <nl> + be : <nl> + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] <nl> + where : <nl> + - < type > is a [ byte ] indicating the type of batch to use : <nl> + - If < type > = = 0 , the batch will be " logged " . This is equivalent to a <nl> + normal CQL3 batch statement . <nl> + - If < type > = = 1 , the batch will be " unlogged " . <nl> + - If < type > = = 2 , the batch will be a " counter " batch ( and non - counter <nl> + statements will be rejected ) . <nl> + - < flags > is a [ byte ] whose bits define the options for this query and <nl> + in particular influence the remainder of the message contains . It is similar <nl> + to the < flags > from QUERY and EXECUTE methods , except that the 4 rightmost <nl> + bits must always be 0 as their corresponding option do not make sense for <nl> + Batch . A flag is set if the bit corresponding to its ` mask ` is set . Supported <nl> + flags are , given there mask : <nl> + 0x10 : With serial consistency . If present , < serial _ consistency > should be <nl> + present . < serial _ consistency > is the [ consistency ] level for the <nl> + serial phase of conditional updates . That consitency can only be <nl> + either SERIAL or LOCAL _ SERIAL and if not present , it defaults to <nl> + SERIAL . This option will be ignored for anything else that a <nl> + conditional update / insert . <nl> + 0x20 : With default timestamp . If present , < timestamp > should be present . <nl> + < timestamp > is a [ long ] representing the default timestamp for the query <nl> + in microseconds . If provided , this will replace the server side assigned <nl> + timestamp as default timestamp . Note that a timestamp in the query itself <nl> + will still override this timestamp . This is entirely optional . <nl> + 0x40 : With names for values . If set , then all values for all < query _ i > must be <nl> + preceded by a [ string ] < name _ i > that have the same meaning as in QUERY <nl> + requests . <nl> + - < n > is a [ short ] indicating the number of following queries . <nl> + - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the <nl> + form : <nl> + < kind > < string _ or _ id > < n > [ < name _ 1 > ] < value _ 1 > . . . [ < name _ n > ] < value _ n > <nl> + where : <nl> + - < kind > is a [ byte ] indicating whether the following query is a prepared <nl> + one or not . < kind > value must be either 0 or 1 . <nl> + - < string _ or _ id > depends on the value of < kind > . If < kind > = = 0 , it should be <nl> + a [ long string ] query string ( as in QUERY , the query string might contain <nl> + bind markers ) . Otherwise ( that is , if < kind > = = 1 ) , it should be a <nl> + [ short bytes ] representing a prepared query ID . <nl> + - < n > is a [ short ] indicating the number ( possibly 0 ) of following values . <nl> + - < name _ i > is the optional name of the following < value _ i > . It must be present <nl> + if and only if the 0x40 flag is provided for the batch . <nl> + - < value _ i > is the [ bytes ] to use for bound variable i ( of bound variable < name _ i > <nl> + if the 0x40 flag is used ) . <nl> + - < consistency > is the [ consistency ] level for the operation . <nl> + - < serial _ consistency > is only present if the 0x10 flag is set . In that case , <nl> + < serial _ consistency > is the [ consistency ] level for the serial phase of <nl> + conditional updates . That consitency can only be either SERIAL or <nl> + LOCAL _ SERIAL and if not present will defaults to SERIAL . This option will <nl> + be ignored for anything else that a conditional update / insert . <nl> + <nl> + The server will respond with a RESULT message . <nl> + <nl> + <nl> + 4 . 1 . 8 . REGISTER <nl> + <nl> + Register this connection to receive some type of events . The body of the <nl> + message is a [ string list ] representing the event types to register to . See <nl> + section 4 . 2 . 6 for the list of valid event types . <nl> + <nl> + The response to a REGISTER message will be a READY message . <nl> + <nl> + Please note that if a client driver maintains multiple connections to a <nl> + Cassandra node and / or connections to multiple nodes , it is advised to <nl> + dedicate a handful of connections to receive events , but to * not * register <nl> + for events on all connections , as this would only result in receiving <nl> + multiple times the same event messages , wasting bandwidth . <nl> + <nl> + <nl> + 4 . 2 . Responses <nl> + <nl> + This section describes the content of the frame body for the different <nl> + responses . Please note that to make room for future evolution , clients should <nl> + support extra informations ( that they should simply discard ) to the one <nl> + described in this document at the end of the frame body . <nl> + <nl> + 4 . 2 . 1 . ERROR <nl> + <nl> + Indicates an error processing a request . The body of the message will be an <nl> + error code ( [ int ] ) followed by a [ string ] error message . Then , depending on <nl> + the exception , more content may follow . The error codes are defined in <nl> + Section 9 , along with their additional content if any . <nl> + <nl> + <nl> + 4 . 2 . 2 . READY <nl> + <nl> + Indicates that the server is ready to process queries . This message will be <nl> + sent by the server either after a STARTUP message if no authentication is <nl> + required , or after a successful CREDENTIALS message . <nl> + <nl> + The body of a READY message is empty . <nl> + <nl> + <nl> + 4 . 2 . 3 . AUTHENTICATE <nl> + <nl> + Indicates that the server require authentication , and which authentication <nl> + mechanism to use . <nl> + <nl> + The authentication is SASL based and thus consists on a number of server <nl> + challenges ( AUTH _ CHALLENGE , Section 4 . 2 . 7 ) followed by client responses <nl> + ( AUTH _ RESPONSE , Section 4 . 1 . 2 ) . The Initial exchange is however boostrapped <nl> + by an initial client response . The details of that exchange ( including how <nl> + much challenge - response pair are required ) are specific to the authenticator <nl> + in use . The exchange ends when the server sends an AUTH _ SUCCESS message or <nl> + an ERROR message . <nl> + <nl> + This message will be sent following a STARTUP message if authentication is <nl> + required and must be answered by a AUTH _ RESPONSE message from the client . <nl> + <nl> + The body consists of a single [ string ] indicating the full class name of the <nl> + IAuthenticator in use . <nl> + <nl> + <nl> + 4 . 2 . 4 . SUPPORTED <nl> + <nl> + Indicates which startup options are supported by the server . This message <nl> + comes as a response to an OPTIONS message . <nl> + <nl> + The body of a SUPPORTED message is a [ string multimap ] . This multimap gives <nl> + for each of the supported STARTUP options , the list of supported values . <nl> + <nl> + <nl> + 4 . 2 . 5 . RESULT <nl> + <nl> + The result to a query ( QUERY , PREPARE , EXECUTE or BATCH messages ) . <nl> + <nl> + The first element of the body of a RESULT message is an [ int ] representing the <nl> + ` kind ` of result . The rest of the body depends on the kind . The kind can be <nl> + one of : <nl> + 0x0001 Void : for results carrying no information . <nl> + 0x0002 Rows : for results to select queries , returning a set of rows . <nl> + 0x0003 Set _ keyspace : the result to a ` use ` query . <nl> + 0x0004 Prepared : result to a PREPARE message . <nl> + 0x0005 Schema _ change : the result to a schema altering query . <nl> + <nl> + The body for each kind ( after the [ int ] kind ) is defined below . <nl> + <nl> + <nl> + 4 . 2 . 5 . 1 . Void <nl> + <nl> + The rest of the body for a Void result is empty . It indicates that a query was <nl> + successful without providing more information . <nl> + <nl> + <nl> + 4 . 2 . 5 . 2 . Rows <nl> + <nl> + Indicates a set of rows . The rest of body of a Rows result is : <nl> + < metadata > < rows _ count > < rows _ content > <nl> + where : <nl> + - < metadata > is composed of : <nl> + < flags > < columns _ count > [ < paging _ state > ] [ < global _ table _ spec > ? < col _ spec _ 1 > . . . < col _ spec _ n > ] <nl> + where : <nl> + - < flags > is an [ int ] . The bits of < flags > provides information on the <nl> + formatting of the remaining informations . A flag is set if the bit <nl> + corresponding to its ` mask ` is set . Supported flags are , given there <nl> + mask : <nl> + 0x0001 Global _ tables _ spec : if set , only one table spec ( keyspace <nl> + and table name ) is provided as < global _ table _ spec > . If not <nl> + set , < global _ table _ spec > is not present . <nl> + 0x0002 Has _ more _ pages : indicates whether this is not the last <nl> + page of results and more should be retrieve . If set , the <nl> + < paging _ state > will be present . The < paging _ state > is a <nl> + [ bytes ] value that should be used in QUERY / EXECUTE to <nl> + continue paging and retrieve the remained of the result for <nl> + this query ( See Section 8 for more details ) . <nl> + 0x0004 No _ metadata : if set , the < metadata > is only composed of <nl> + these < flags > , the < column _ count > and optionally the <nl> + < paging _ state > ( depending on the Has _ more _ pages flage ) but <nl> + no other information ( so no < global _ table _ spec > nor < col _ spec _ i > ) . <nl> + This will only ever be the case if this was requested <nl> + during the query ( see QUERY and RESULT messages ) . <nl> + - < columns _ count > is an [ int ] representing the number of columns selected <nl> + by the query this result is of . It defines the number of < col _ spec _ i > <nl> + elements in and the number of element for each row in < rows _ content > . <nl> + - < global _ table _ spec > is present if the Global _ tables _ spec is set in <nl> + < flags > . If present , it is composed of two [ string ] representing the <nl> + ( unique ) keyspace name and table name the columns return are of . <nl> + - < col _ spec _ i > specifies the columns returned in the query . There is <nl> + < column _ count > such column specifications that are composed of : <nl> + ( < ksname > < tablename > ) ? < name > < type > <nl> + The initial < ksname > and < tablename > are two [ string ] are only present <nl> + if the Global _ tables _ spec flag is not set . The < column _ name > is a <nl> + [ string ] and < type > is an [ option ] that correspond to the description <nl> + ( what this description is depends a bit on the context : in results to <nl> + selects , this will be either the user chosen alias or the selection used <nl> + ( often a colum name , but it can be a function call too ) . In results to <nl> + a PREPARE , this will be either the name of the bind variable corresponding <nl> + or the column name for the variable if it is " anonymous " ) and type of <nl> + the corresponding result . The option for < type > is either a native <nl> + type ( see below ) , in which case the option has no value , or a <nl> + ' custom ' type , in which case the value is a [ string ] representing <nl> + the full qualified class name of the type represented . Valid option <nl> + ids are : <nl> + 0x0000 Custom : the value is a [ string ] , see above . <nl> + 0x0001 Ascii <nl> + 0x0002 Bigint <nl> + 0x0003 Blob <nl> + 0x0004 Boolean <nl> + 0x0005 Counter <nl> + 0x0006 Decimal <nl> + 0x0007 Double <nl> + 0x0008 Float <nl> + 0x0009 Int <nl> + 0x000B Timestamp <nl> + 0x000C Uuid <nl> + 0x000D Varchar <nl> + 0x000E Varint <nl> + 0x000F Timeuuid <nl> + 0x0010 Inet <nl> + 0x0020 List : the value is an [ option ] , representing the type <nl> + of the elements of the list . <nl> + 0x0021 Map : the value is two [ option ] , representing the types of the <nl> + keys and values of the map <nl> + 0x0022 Set : the value is an [ option ] , representing the type <nl> + of the elements of the set <nl> + 0x0030 UDT : the value is < ks > < udt _ name > < n > < name _ 1 > < type _ 1 > . . . < name _ n > < type _ n > <nl> + where : <nl> + - < ks > is a [ string ] representing the keyspace name this <nl> + UDT is part of . <nl> + - < udt _ name > is a [ string ] representing the UDT name . <nl> + - < n > is a [ short ] reprensenting the number of fields of <nl> + the UDT , and thus the number of < name _ i > < type _ i > pair <nl> + following <nl> + - < name _ i > is a [ string ] representing the name of the <nl> + i _ th field of the UDT . <nl> + - < type _ i > is an [ option ] representing the type of the <nl> + i _ th field of the UDT . <nl> + 0x0031 Tuple : the value is < n > < type _ 1 > . . . < type _ n > where < n > is a [ short ] <nl> + representing the number of value in the type , and < type _ i > <nl> + are [ option ] representing the type of the i _ th component <nl> + of the tuple <nl> + <nl> + - < rows _ count > is an [ int ] representing the number of rows present in this <nl> + result . Those rows are serialized in the < rows _ content > part . <nl> + - < rows _ content > is composed of < row _ 1 > . . . < row _ m > where m is < rows _ count > . <nl> + Each < row _ i > is composed of < value _ 1 > . . . < value _ n > where n is <nl> + < columns _ count > and where < value _ j > is a [ bytes ] representing the value <nl> + returned for the jth column of the ith row . In other words , < rows _ content > <nl> + is composed of ( < rows _ count > * < columns _ count > ) [ bytes ] . <nl> + <nl> + <nl> + 4 . 2 . 5 . 3 . Set _ keyspace <nl> + <nl> + The result to a ` use ` query . The body ( after the kind [ int ] ) is a single <nl> + [ string ] indicating the name of the keyspace that has been set . <nl> + <nl> + <nl> + 4 . 2 . 5 . 4 . Prepared <nl> + <nl> + The result to a PREPARE message . The rest of the body of a Prepared result is : <nl> + < id > < metadata > < result _ metadata > <nl> + where : <nl> + - < id > is [ short bytes ] representing the prepared query ID . <nl> + - < metadata > is defined exactly as for a Rows RESULT ( See section 4 . 2 . 5 . 2 ; you <nl> + can however assume that the Has _ more _ pages flag is always off ) and <nl> + is the specification for the variable bound in this prepare statement . <nl> + - < result _ metadata > is defined exactly as < metadata > but correspond to the <nl> + metadata for the resultSet that execute this query will yield . Note that <nl> + < result _ metadata > may be empty ( have the No _ metadata flag and 0 columns , See <nl> + section 4 . 2 . 5 . 2 ) and will be for any query that is not a Select . There is <nl> + in fact never a guarantee that this will non - empty so client should protect <nl> + themselves accordingly . The presence of this information is an <nl> + optimization that allows to later execute the statement that has been <nl> + prepared without requesting the metadata ( Skip _ metadata flag in EXECUTE ) . <nl> + Clients can safely discard this metadata if they do not want to take <nl> + advantage of that optimization . <nl> + <nl> + Note that prepared query ID return is global to the node on which the query <nl> + has been prepared . It can be used on any connection to that node and this <nl> + until the node is restarted ( after which the query must be reprepared ) . <nl> + <nl> + 4 . 2 . 5 . 5 . Schema _ change <nl> + <nl> + The result to a schema altering query ( creation / update / drop of a <nl> + keyspace / table / index ) . The body ( after the kind [ int ] ) is the same <nl> + as the body for a " SCHEMA _ CHANGE " event , so 3 strings : <nl> + < change _ type > < target > < options > <nl> + Please refer to the section 4 . 2 . 6 below for the meaning of those fields . <nl> + <nl> + Note that queries to create and drop an index are considered as change <nl> + updating the table the index is on . <nl> + <nl> + <nl> + 4 . 2 . 6 . EVENT <nl> + <nl> + And event pushed by the server . A client will only receive events for the <nl> + type it has REGISTER to . The body of an EVENT message will start by a <nl> + [ string ] representing the event type . The rest of the message depends on the <nl> + event type . The valid event types are : <nl> + - " TOPOLOGY _ CHANGE " : events related to change in the cluster topology . <nl> + Currently , events are sent when new nodes are added to the cluster , and <nl> + when nodes are removed . The body of the message ( after the event type ) <nl> + consists of a [ string ] and an [ inet ] , corresponding respectively to the <nl> + type of change ( " NEW _ NODE " or " REMOVED _ NODE " ) followed by the address of <nl> + the new / removed node . <nl> + - " STATUS _ CHANGE " : events related to change of node status . Currently , <nl> + up / down events are sent . The body of the message ( after the event type ) <nl> + consists of a [ string ] and an [ inet ] , corresponding respectively to the <nl> + type of status change ( " UP " or " DOWN " ) followed by the address of the <nl> + concerned node . <nl> + - " SCHEMA _ CHANGE " : events related to schema change . After the event type , <nl> + the rest of the message will be < change _ type > < target > < options > where : <nl> + - < change _ type > is a [ string ] representing the type of changed involved . <nl> + It will be one of " CREATED " , " UPDATED " or " DROPPED " . <nl> + - < target > is a [ string ] that can be one of " KEYSPACE " , " TABLE " or " TYPE " <nl> + and describes what has been modified ( " TYPE " stands for modifications <nl> + related to user types ) . <nl> + - < options > depends on the preceding < target > . If < target > is <nl> + " KEYSPACE " , then < options > will be a single [ string ] representing the <nl> + keyspace changed . Otherwise , if < target > is " TABLE " or " TYPE " , then <nl> + < options > will be 2 [ string ] : the first one will be the keyspace <nl> + containing the affected object , and the second one will be the name <nl> + of said affected object ( so either the table name or the user type <nl> + name ) . <nl> + <nl> + All EVENT message have a streamId of - 1 ( Section 2 . 3 ) . <nl> + <nl> + Please note that " NEW _ NODE " and " UP " events are sent based on internal Gossip <nl> + communication and as such may be sent a short delay before the binary <nl> + protocol server on the newly up node is fully started . Clients are thus <nl> + advise to wait a short time before trying to connect to the node ( 1 seconds <nl> + should be enough ) , otherwise they may experience a connection refusal at <nl> + first . <nl> + <nl> + 4 . 2 . 7 . AUTH _ CHALLENGE <nl> + <nl> + A server authentication challenge ( see AUTH _ RESPONSE ( Section 4 . 1 . 2 ) for more <nl> + details ) . <nl> + <nl> + The body of this message is a single [ bytes ] token . The details of what this <nl> + token contains ( and when it can be null / empty , if ever ) depends on the actual <nl> + authenticator used . <nl> + <nl> + Clients are expected to answer the server challenge by an AUTH _ RESPONSE <nl> + message . <nl> + <nl> + 4 . 2 . 7 . AUTH _ SUCCESS <nl> + <nl> + Indicate the success of the authentication phase . See Section 4 . 2 . 3 for more <nl> + details . <nl> + <nl> + The body of this message is a single [ bytes ] token holding final information <nl> + from the server that the client may require to finish the authentication <nl> + process . What that token contains and whether it can be null depends on the <nl> + actual authenticator used . <nl> + <nl> + <nl> + 5 . Compression <nl> + <nl> + Frame compression is supported by the protocol , but then only the frame body <nl> + is compressed ( the frame header should never be compressed ) . <nl> + <nl> + Before being used , client and server must agree on a compression algorithm to <nl> + use , which is done in the STARTUP message . As a consequence , a STARTUP message <nl> + must never be compressed . However , once the STARTUP frame has been received <nl> + by the server can be compressed ( including the response to the STARTUP <nl> + request ) . Frame do not have to be compressed however , even if compression has <nl> + been agreed upon ( a server may only compress frame above a certain size at its <nl> + discretion ) . A frame body should be compressed if and only if the compressed <nl> + flag ( see Section 2 . 2 ) is set . <nl> + <nl> + As of this version 2 of the protocol , the following compressions are available : <nl> + - lz4 ( https : / / code . google . com / p / lz4 / ) . In that , note that the 4 first bytes <nl> + of the body will be the uncompressed length ( followed by the compressed <nl> + bytes ) . <nl> + - snappy ( https : / / code . google . com / p / snappy / ) . This compression might not be <nl> + available as it depends on a native lib ( server - side ) that might not be <nl> + avaivable on some installation . <nl> + <nl> + <nl> + 6 . Collection types <nl> + <nl> + This section describe the serialization format for the collection types : <nl> + list , map and set . This serialization format is both useful to decode values <nl> + returned in RESULT messages but also to encode values for EXECUTE ones . <nl> + <nl> + The serialization formats are : <nl> + List : a [ int ] n indicating the size of the list , followed by n elements . <nl> + Each element is [ bytes ] representing the serialized element <nl> + value . <nl> + Map : a [ int ] n indicating the size of the map , followed by n entries . <nl> + Each entry is composed of two [ bytes ] representing the key and <nl> + the value of the entry map . <nl> + Set : a [ int ] n indicating the size of the set , followed by n elements . <nl> + Each element is [ bytes ] representing the serialized element <nl> + value . <nl> + <nl> + <nl> + 7 . User defined and tuple types <nl> + <nl> + This section describes the serialization format for User defined types ( UDT ) and <nl> + tuple values . UDT ( resp . tuple ) values are the values of the User Defined Types <nl> + ( resp . tuple type ) as defined in section 4 . 2 . 5 . 2 . <nl> + <nl> + A UDT value is composed of successive [ bytes ] values , one for each field of the UDT <nl> + value ( in the order defined by the type ) . A UDT value will generally have one value <nl> + for each field of the type it represents , but it is allowed to have less values than <nl> + the type has fields . <nl> + <nl> + A tuple value has the exact same serialization format , i . e . a succession of <nl> + [ bytes ] values representing the components of the tuple . <nl> + <nl> + <nl> + 8 . Result paging <nl> + <nl> + The protocol allows for paging the result of queries . For that , the QUERY and <nl> + EXECUTE messages have a < result _ page _ size > value that indicate the desired <nl> + page size in CQL3 rows . <nl> + <nl> + If a positive value is provided for < result _ page _ size > , the result set of the <nl> + RESULT message returned for the query will contain at most the <nl> + < result _ page _ size > first rows of the query result . If that first page of result <nl> + contains the full result set for the query , the RESULT message ( of kind ` Rows ` ) <nl> + will have the Has _ more _ pages flag * not * set . However , if some results are not <nl> + part of the first response , the Has _ more _ pages flag will be set and the result <nl> + will contain a < paging _ state > value . In that case , the < paging _ state > value <nl> + should be used in a QUERY or EXECUTE message ( that has the * same * query than <nl> + the original one or the behavior is undefined ) to retrieve the next page of <nl> + results . <nl> + <nl> + Only CQL3 queries that return a result set ( RESULT message with a Rows ` kind ` ) <nl> + support paging . For other type of queries , the < result _ page _ size > value is <nl> + ignored . <nl> + <nl> + Note to client implementors : <nl> + - While < result _ page _ size > can be as low as 1 , it will likely be detrimental <nl> + to performance to pick a value too low . A value below 100 is probably too <nl> + low for most use cases . <nl> + - Clients should not rely on the actual size of the result set returned to <nl> + decide if there is more result to fetch or not . Instead , they should always <nl> + check the Has _ more _ pages flag ( unless they did not enabled paging for the query <nl> + obviously ) . Clients should also not assert that no result will have more than <nl> + < result _ page _ size > results . While the current implementation always respect <nl> + the exact value of < result _ page _ size > , we reserve ourselves the right to return <nl> + slightly smaller or bigger pages in the future for performance reasons . <nl> + <nl> + <nl> + 9 . Error codes <nl> + <nl> + The supported error codes are described below : <nl> + 0x0000 Server error : something unexpected happened . This indicates a <nl> + server - side bug . <nl> + 0x000A Protocol error : some client message triggered a protocol <nl> + violation ( for instance a QUERY message is sent before a STARTUP <nl> + one has been sent ) <nl> + 0x0100 Bad credentials : CREDENTIALS request failed because Cassandra <nl> + did not accept the provided credentials . <nl> + <nl> + 0x1000 Unavailable exception . The rest of the ERROR message body will be <nl> + < cl > < required > < alive > <nl> + where : <nl> + < cl > is the [ consistency ] level of the query having triggered <nl> + the exception . <nl> + < required > is an [ int ] representing the number of node that <nl> + should be alive to respect < cl > <nl> + < alive > is an [ int ] representing the number of replica that <nl> + were known to be alive when the request has been <nl> + processed ( since an unavailable exception has been <nl> + triggered , there will be < alive > < < required > ) <nl> + 0x1001 Overloaded : the request cannot be processed because the <nl> + coordinator node is overloaded <nl> + 0x1002 Is _ bootstrapping : the request was a read request but the <nl> + coordinator node is bootstrapping <nl> + 0x1003 Truncate _ error : error during a truncation error . <nl> + 0x1100 Write _ timeout : Timeout exception during a write request . The rest <nl> + of the ERROR message body will be <nl> + < cl > < received > < blockfor > < writeType > <nl> + where : <nl> + < cl > is the [ consistency ] level of the query having triggered <nl> + the exception . <nl> + < received > is an [ int ] representing the number of nodes having <nl> + acknowledged the request . <nl> + < blockfor > is the number of replica whose acknowledgement is <nl> + required to achieve < cl > . <nl> + < writeType > is a [ string ] that describe the type of the write <nl> + that timeouted . The value of that string can be one <nl> + of : <nl> + - " SIMPLE " : the write was a non - batched <nl> + non - counter write . <nl> + - " BATCH " : the write was a ( logged ) batch write . <nl> + If this type is received , it means the batch log <nl> + has been successfully written ( otherwise a <nl> + " BATCH _ LOG " type would have been send instead ) . <nl> + - " UNLOGGED _ BATCH " : the write was an unlogged <nl> + batch . Not batch log write has been attempted . <nl> + - " COUNTER " : the write was a counter write <nl> + ( batched or not ) . <nl> + - " BATCH _ LOG " : the timeout occured during the <nl> + write to the batch log when a ( logged ) batch <nl> + write was requested . <nl> + 0x1200 Read _ timeout : Timeout exception during a read request . The rest <nl> + of the ERROR message body will be <nl> + < cl > < received > < blockfor > < data _ present > <nl> + where : <nl> + < cl > is the [ consistency ] level of the query having triggered <nl> + the exception . <nl> + < received > is an [ int ] representing the number of nodes having <nl> + answered the request . <nl> + < blockfor > is the number of replica whose response is <nl> + required to achieve < cl > . Please note that it is <nl> + possible to have < received > > = < blockfor > if <nl> + < data _ present > is false . And also in the ( unlikely ) <nl> + case were < cl > is achieved but the coordinator node <nl> + timeout while waiting for read - repair <nl> + acknowledgement . <nl> + < data _ present > is a single byte . If its value is 0 , it means <nl> + the replica that was asked for data has not <nl> + responded . Otherwise , the value is ! = 0 . <nl> + <nl> + 0x2000 Syntax _ error : The submitted query has a syntax error . <nl> + 0x2100 Unauthorized : The logged user doesn ' t have the right to perform <nl> + the query . <nl> + 0x2200 Invalid : The query is syntactically correct but invalid . <nl> + 0x2300 Config _ error : The query is invalid because of some configuration issue <nl> + 0x2400 Already _ exists : The query attempted to create a keyspace or a <nl> + table that was already existing . The rest of the ERROR message <nl> + body will be < ks > < table > where : <nl> + < ks > is a [ string ] representing either the keyspace that <nl> + already exists , or the keyspace in which the table that <nl> + already exists is . <nl> + < table > is a [ string ] representing the name of the table that <nl> + already exists . If the query was attempting to create a <nl> + keyspace , < table > will be present but will be the empty <nl> + string . <nl> + 0x2500 Unprepared : Can be thrown while a prepared statement tries to be <nl> + executed if the provide prepared statement ID is not known by <nl> + this host . The rest of the ERROR message body will be [ short <nl> + bytes ] representing the unknown ID . <nl> + <nl> + 10 . Changes from v3 <nl> + <nl> +
NEAREST DIFF (one line): diff - - git a / drivers / py / cql / connection . py b / drivers / py / cql / connection . py <nl> index d2131fd . . cd28df4 100644 <nl> - - - a / drivers / py / cql / connection . py <nl> + + + b / drivers / py / cql / connection . py <nl> @ @ - 25 , 7 + 25 , 7 @ @ import zlib <nl> try : <nl> from cassandra import Cassandra <nl> from cassandra . ttypes import Compression , InvalidRequestException , \ <nl> - CqlResultType <nl> + CqlResultType , AuthenticationRequest <nl> except ImportError : <nl> # Hack to run from a source tree <nl> import sys <nl> @ @ - 38 , 7 + 38 , 7 @ @ except ImportError : <nl> ' gen - py ' ) ) <nl> from cassandra import Cassandra <nl> from cassandra . ttypes import Compression , InvalidRequestException , \ <nl> - CqlResultType <nl> + CqlResultType , AuthenticationRequest <nl> <nl> COMPRESSION _ SCHEMES = [ ' GZIP ' ] <nl> DEFAULT _ COMPRESSION = ' GZIP ' <nl> @ @ - 56 , 13 + 56 , 18 @ @ class Connection ( object ) : <nl> . . . for column in row . columns : <nl> . . . print " % s is % s years of age " % ( r . key , column . age ) <nl> " " " <nl> - def _ _ init _ _ ( self , host , port = 9160 , keyspace = None ) : <nl> + def _ _ init _ _ ( self , host , port = 9160 , keyspace = None , username = None , <nl> + password = None ) : <nl> socket = TSocket . TSocket ( host , port ) <nl> self . transport = TTransport . TFramedTransport ( socket ) <nl> protocol = TBinaryProtocol . TBinaryProtocolAccelerated ( self . transport ) <nl> self . client = Cassandra . Client ( protocol ) <nl> socket . open ( ) <nl> <nl> + if username and password : <nl> + credentials = { " username " : username , " password " : password } <nl> + self . client . login ( AuthenticationRequest ( credentials = credentials ) ) <nl> + <nl> if keyspace : <nl> self . execute ( ' USE % s ; ' % keyspace ) <nl> <nl> diff - - git a / drivers / py / cql / connection _ pool . py b / drivers / py / cql / connection _ pool . py <nl> index 44a11fd . . 5d7bde6 100644 <nl> - - - a / drivers / py / cql / connection _ pool . py <nl> + + + b / drivers / py / cql / connection _ pool . py <nl> @ @ - 37 , 26 + 37 , 35 @ @ class ConnectionPool ( object ) : <nl> > > > conn . execute ( . . . ) <nl> > > > pool . return _ connection ( conn ) <nl> " " " <nl> - def _ _ init _ _ ( self , hostname , port = 9160 , keyspace = None , max _ conns = 25 , <nl> - max _ idle = 5 , eviction _ delay = 10000 ) : <nl> + def _ _ init _ _ ( self , hostname , port = 9160 , keyspace = None , username = None , <nl> + password = None , max _ conns = 25 , max _ idle = 5 , eviction _ delay = 10000 ) : <nl> self . hostname = hostname <nl> self . port = port <nl> self . keyspace = keyspace <nl> + self . username = username <nl> + self . password = password <nl> self . max _ conns = max _ conns <nl> self . max _ idle = max _ idle <nl> self . eviction _ delay = eviction _ delay <nl> <nl> self . connections = Queue ( ) <nl> - self . connections . put ( Connection ( hostname , port , keyspace ) ) <nl> + self . connections . put ( self . _ _ create _ connection ( ) ) <nl> self . eviction = Eviction ( self . connections , <nl> self . max _ idle , <nl> self . eviction _ delay ) <nl> + <nl> + def _ _ create _ connection ( self ) : <nl> + return Connection ( self . hostname , <nl> + port = self . port , <nl> + keyspace = self . keyspace , <nl> + username = self . username , <nl> + password = self . password ) <nl> <nl> def borrow _ connection ( self ) : <nl> try : <nl> connection = self . connections . get ( block = False ) <nl> except Empty : <nl> - connection = Connection ( self . hostname , self . port , self . keyspace ) <nl> + connection = self . _ _ create _ connection ( ) <nl> return connection <nl> <nl> def return _ connection ( self , connection ) :

TEST DIFF:
diff - - git a / doc / native _ protocol _ v4 . spec b / doc / native _ protocol _ v4 . spec 
 new file mode 100644 
 index 0000000 . . 02aac3b 
 - - - / dev / null 
 + + + b / doc / native _ protocol _ v4 . spec 
 @ @ - 0 , 0 + 1 , 899 @ @ 
 + 
 + CQL BINARY PROTOCOL v4 
 + 
 + 
 + Table of Contents 
 + 
 + 1 . Overview 
 + 2 . Frame header 
 + 2 . 1 . version 
 + 2 . 2 . flags 
 + 2 . 3 . stream 
 + 2 . 4 . opcode 
 + 2 . 5 . length 
 + 3 . Notations 
 + 4 . Messages 
 + 4 . 1 . Requests 
 + 4 . 1 . 1 . STARTUP 
 + 4 . 1 . 2 . AUTH _ RESPONSE 
 + 4 . 1 . 3 . OPTIONS 
 + 4 . 1 . 4 . QUERY 
 + 4 . 1 . 5 . PREPARE 
 + 4 . 1 . 6 . EXECUTE 
 + 4 . 1 . 7 . BATCH 
 + 4 . 1 . 8 . REGISTER 
 + 4 . 2 . Responses 
 + 4 . 2 . 1 . ERROR 
 + 4 . 2 . 2 . READY 
 + 4 . 2 . 3 . AUTHENTICATE 
 + 4 . 2 . 4 . SUPPORTED 
 + 4 . 2 . 5 . RESULT 
 + 4 . 2 . 5 . 1 . Void 
 + 4 . 2 . 5 . 2 . Rows 
 + 4 . 2 . 5 . 3 . Set _ keyspace 
 + 4 . 2 . 5 . 4 . Prepared 
 + 4 . 2 . 5 . 5 . Schema _ change 
 + 4 . 2 . 6 . EVENT 
 + 4 . 2 . 7 . AUTH _ CHALLENGE 
 + 4 . 2 . 8 . AUTH _ SUCCESS 
 + 5 . Compression 
 + 6 . Collection types 
 + 7 . User Defined and tuple types 
 + 8 . Result paging 
 + 9 . Error codes 
 + 10 . Changes from v3 
 + 
 + 
 + 1 . Overview 
 + 
 + The CQL binary protocol is a frame based protocol . Frames are defined as : 
 + 
 + 0 8 16 24 32 40 
 + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + | version | flags | stream | opcode | 
 + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + | length | 
 + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + | | 
 + . . . . body . . . . 
 + . . 
 + . . 
 + + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 + 
 + The protocol is big - endian ( network byte order ) . 
 + 
 + Each frame contains a fixed size header ( 9 bytes ) followed by a variable size 
 + body . The header is described in Section 2 . The content of the body depends 
 + on the header opcode value ( the body can in particular be empty for some 
 + opcode values ) . The list of allowed opcode is defined Section 2 . 3 and the 
 + details of each corresponding message is described Section 4 . 
 + 
 + The protocol distinguishes 2 types of frames : requests and responses . Requests 
 + are those frame sent by the clients to the server , response are the ones sent 
 + by the server . Note however that the protocol supports server pushes ( events ) 
 + so responses does not necessarily come right after a client request . 
 + 
 + Note to client implementors : clients library should always assume that the 
 + body of a given frame may contain more data than what is described in this 
 + document . It will however always be safe to ignore the remaining of the frame 
 + body in such cases . The reason is that this may allow to sometimes extend the 
 + protocol with optional features without needing to change the protocol 
 + version . 
 + 
 + 
 + 
 + 2 . Frame header 
 + 
 + 2 . 1 . version 
 + 
 + The version is a single byte that indicate both the direction of the message 
 + ( request or response ) and the version of the protocol in use . The up - most bit 
 + of version is used to define the direction of the message : 0 indicates a 
 + request , 1 indicates a responses . This can be useful for protocol analyzers to 
 + distinguish the nature of the packet from the direction which it is moving . 
 + The rest of that byte is the protocol version ( 4 for the protocol defined in 
 + this document ) . In other words , for this version of the protocol , version will 
 + have one of : 
 + 0x04 Request frame for this protocol version 
 + 0x84 Response frame for this protocol version 
 + 
 + Please note that the while every message ship with the version , only one version 
 + of messages is accepted on a given connection . In other words , the first message 
 + exchanged ( STARTUP ) sets the version for the connection for the lifetime of this 
 + connection . 
 + 
 + This document describe the version 3 of the protocol . For the changes made since 
 + version 3 , see Section 10 . 
 + 
 + 
 + 2 . 2 . flags 
 + 
 + Flags applying to this frame . The flags have the following meaning ( described 
 + by the mask that allow to select them ) : 
 + 0x01 : Compression flag . If set , the frame body is compressed . The actual 
 + compression to use should have been set up beforehand through the 
 + Startup message ( which thus cannot be compressed ; Section 4 . 1 . 1 ) . 
 + 0x02 : Tracing flag . For a request frame , this indicate the client requires 
 + tracing of the request . Note that not all requests support tracing . 
 + Currently , only QUERY , PREPARE and EXECUTE queries support tracing . 
 + Other requests will simply ignore the tracing flag if set . If a 
 + request support tracing and the tracing flag was set , the response to 
 + this request will have the tracing flag set and contain tracing 
 + information . 
 + If a response frame has the tracing flag set , its body contains 
 + a tracing ID . The tracing ID is a [ uuid ] and is the first thing in 
 + the frame body . The rest of the body will then be the usual body 
 + corresponding to the response opcode . 
 + 
 + The rest of the flags is currently unused and ignored . 
 + 
 + 2 . 3 . stream 
 + 
 + A frame has a stream id ( a [ short ] value ) . When sending request messages , this 
 + stream id must be set by the client to a non - negative value ( negative stream id 
 + are reserved for streams initiated by the server ; currently all EVENT messages 
 + ( section 4 . 2 . 6 ) have a streamId of - 1 ) . If a client sends a request message 
 + with the stream id X , it is guaranteed that the stream id of the response to 
 + that message will be X . 
 + 
 + This allow to deal with the asynchronous nature of the protocol . If a client 
 + sends multiple messages simultaneously ( without waiting for responses ) , there 
 + is no guarantee on the order of the responses . For instance , if the client 
 + writes REQ _ 1 , REQ _ 2 , REQ _ 3 on the wire ( in that order ) , the server might 
 + respond to REQ _ 3 ( or REQ _ 2 ) first . Assigning different stream id to these 3 
 + requests allows the client to distinguish to which request an received answer 
 + respond to . As there can only be 32768 different simultaneous streams , it is up 
 + to the client to reuse stream id . 
 + 
 + Note that clients are free to use the protocol synchronously ( i . e . wait for 
 + the response to REQ _ N before sending REQ _ N + 1 ) . In that case , the stream id 
 + can be safely set to 0 . Clients should also feel free to use only a subset of 
 + the 32768 maximum possible stream ids if it is simpler for those 
 + implementation . 
 + 
 + 2 . 4 . opcode 
 + 
 + An integer byte that distinguish the actual message : 
 + 0x00 ERROR 
 + 0x01 STARTUP 
 + 0x02 READY 
 + 0x03 AUTHENTICATE 
 + 0x05 OPTIONS 
 + 0x06 SUPPORTED 
 + 0x07 QUERY 
 + 0x08 RESULT 
 + 0x09 PREPARE 
 + 0x0A EXECUTE 
 + 0x0B REGISTER 
 + 0x0C EVENT 
 + 0x0D BATCH 
 + 0x0E AUTH _ CHALLENGE 
 + 0x0F AUTH _ RESPONSE 
 + 0x10 AUTH _ SUCCESS 
 + 
 + Messages are described in Section 4 . 
 + 
 + ( Note that there is no 0x04 message in this version of the protocol ) 
 + 
 + 
 + 2 . 5 . length 
 + 
 + A 4 byte integer representing the length of the body of the frame ( note : 
 + currently a frame is limited to 256MB in length ) . 
 + 
 + 
 + 3 . Notations 
 + 
 + To describe the layout of the frame body for the messages in Section 4 , we 
 + define the following : 
 + 
 + [ int ] A 4 bytes integer 
 + [ long ] A 8 bytes integer 
 + [ short ] A 2 bytes unsigned integer 
 + [ string ] A [ short ] n , followed by n bytes representing an UTF - 8 
 + string . 
 + [ long string ] An [ int ] n , followed by n bytes representing an UTF - 8 string . 
 + [ uuid ] A 16 bytes long uuid . 
 + [ string list ] A [ short ] n , followed by n [ string ] . 
 + [ bytes ] A [ int ] n , followed by n bytes if n > = 0 . If n < 0 , 
 + no byte should follow and the value represented is ` null ` . 
 + [ short bytes ] A [ short ] n , followed by n bytes if n > = 0 . 
 + 
 + [ option ] A pair of < id > < value > where < id > is a [ short ] representing 
 + the option id and < value > depends on that option ( and can be 
 + of size 0 ) . The supported id ( and the corresponding < value > ) 
 + will be described when this is used . 
 + [ option list ] A [ short ] n , followed by n [ option ] . 
 + [ inet ] An address ( ip and port ) to a node . It consists of one 
 + [ byte ] n , that represents the address size , followed by n 
 + [ byte ] representing the IP address ( in practice n can only be 
 + either 4 ( IPv4 ) or 16 ( IPv6 ) ) , following by one [ int ] 
 + representing the port . 
 + [ consistency ] A consistency level specification . This is a [ short ] 
 + representing a consistency level with the following 
 + correspondance : 
 + 0x0000 ANY 
 + 0x0001 ONE 
 + 0x0002 TWO 
 + 0x0003 THREE 
 + 0x0004 QUORUM 
 + 0x0005 ALL 
 + 0x0006 LOCAL _ QUORUM 
 + 0x0007 EACH _ QUORUM 
 + 0x0008 SERIAL 
 + 0x0009 LOCAL _ SERIAL 
 + 0x000A LOCAL _ ONE 
 + 
 + [ string map ] A [ short ] n , followed by n pair < k > < v > where < k > and < v > 
 + are [ string ] . 
 + [ string multimap ] A [ short ] n , followed by n pair < k > < v > where < k > is a 
 + [ string ] and < v > is a [ string list ] . 
 + 
 + 
 + 4 . Messages 
 + 
 + 4 . 1 . Requests 
 + 
 + Note that outside of their normal responses ( described below ) , all requests 
 + can get an ERROR message ( Section 4 . 2 . 1 ) as response . 
 + 
 + 4 . 1 . 1 . STARTUP 
 + 
 + Initialize the connection . The server will respond by either a READY message 
 + ( in which case the connection is ready for queries ) or an AUTHENTICATE message 
 + ( in which case credentials will need to be provided using AUTH _ RESPONSE ) . 
 + 
 + This must be the first message of the connection , except for OPTIONS that can 
 + be sent before to find out the options supported by the server . Once the 
 + connection has been initialized , a client should not send any more STARTUP 
 + message . 
 + 
 + The body is a [ string map ] of options . Possible options are : 
 + - " CQL _ VERSION " : the version of CQL to use . This option is mandatory and 
 + currenty , the only version supported is " 3 . 0 . 0 " . Note that this is 
 + different from the protocol version . 
 + - " COMPRESSION " : the compression algorithm to use for frames ( See section 5 ) . 
 + This is optional , if not specified no compression will be used . 
 + 
 + 
 + 4 . 1 . 2 . AUTH _ RESPONSE 
 + 
 + Answers a server authentication challenge . 
 + 
 + Authentication in the protocol is SASL based . The server sends authentication 
 + challenges ( a bytes token ) to which the client answer with this message . Those 
 + exchanges continue until the server accepts the authentication by sending a 
 + AUTH _ SUCCESS message after a client AUTH _ RESPONSE . It is however that client that 
 + initiate the exchange by sending an initial AUTH _ RESPONSE in response to a 
 + server AUTHENTICATE request . 
 + 
 + The body of this message is a single [ bytes ] token . The details of what this 
 + token contains ( and when it can be null / empty , if ever ) depends on the actual 
 + authenticator used . 
 + 
 + The response to a AUTH _ RESPONSE is either a follow - up AUTH _ CHALLENGE message , 
 + an AUTH _ SUCCESS message or an ERROR message . 
 + 
 + 
 + 4 . 1 . 3 . OPTIONS 
 + 
 + Asks the server to return what STARTUP options are supported . The body of an 
 + OPTIONS message should be empty and the server will respond with a SUPPORTED 
 + message . 
 + 
 + 
 + 4 . 1 . 4 . QUERY 
 + 
 + Performs a CQL query . The body of the message must be : 
 + < query > < query _ parameters > 
 + where < query > is a [ long string ] representing the query and 
 + < query _ parameters > must be 
 + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] 
 + where : 
 + - < consistency > is the [ consistency ] level for the operation . 
 + - < flags > is a [ byte ] whose bits define the options for this query and 
 + in particular influence what the remainder of the message contains . 
 + A flag is set if the bit corresponding to its ` mask ` is set . Supported 
 + flags are , given there mask : 
 + 0x01 : Values . In that case , a [ short ] < n > followed by < n > [ bytes ] 
 + values are provided . Those value are used for bound variables in 
 + the query . Optionally , if the 0x40 flag is present , each value 
 + will be preceded by a [ string ] name , representing the name of 
 + the marker the value must be binded to . This is optional , and 
 + if not present , values will be binded by position . 
 + 0x02 : Skip _ metadata . If present , the Result Set returned as a response 
 + to that query ( if any ) will have the NO _ METADATA flag ( see 
 + Section 4 . 2 . 5 . 2 ) . 
 + 0x04 : Page _ size . In that case , < result _ page _ size > is an [ int ] 
 + controlling the desired page size of the result ( in CQL3 rows ) . 
 + See the section on paging ( Section 8 ) for more details . 
 + 0x08 : With _ paging _ state . If present , < paging _ state > should be present . 
 + < paging _ state > is a [ bytes ] value that should have been returned 
 + in a result set ( Section 4 . 2 . 5 . 2 ) . If provided , the query will be 
 + executed but starting from a given paging state . This also to 
 + continue paging on a different node from the one it has been 
 + started ( See Section 8 for more details ) . 
 + 0x10 : With serial consistency . If present , < serial _ consistency > should be 
 + present . < serial _ consistency > is the [ consistency ] level for the 
 + serial phase of conditional updates . That consitency can only be 
 + either SERIAL or LOCAL _ SERIAL and if not present , it defaults to 
 + SERIAL . This option will be ignored for anything else that a 
 + conditional update / insert . 
 + 0x20 : With default timestamp . If present , < timestamp > should be present . 
 + < timestamp > is a [ long ] representing the default timestamp for the query 
 + in microseconds ( negative values are forbidden ) . If provided , this will 
 + replace the server side assigned timestamp as default timestamp . 
 + Note that a timestamp in the query itself will still override 
 + this timestamp . This is entirely optional . 
 + 0x40 : With names for values . This only makes sense if the 0x01 flag is set and 
 + is ignored otherwise . If present , the values from the 0x01 flag will 
 + be preceded by a name ( see above ) . Note that this is only useful for 
 + QUERY requests where named bind markers are used ; for EXECUTE statements , 
 + since the names for the expected values was returned during preparation , 
 + a client can always provide values in the right order without any names 
 + and using this flag , while supported , is almost surely inefficient . 
 + 
 + Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , 
 + TRUNCATE , . . . ) . 
 + 
 + The server will respond to a QUERY message with a RESULT message , the content 
 + of which depends on the query . 
 + 
 + 
 + 4 . 1 . 5 . PREPARE 
 + 
 + Prepare a query for later execution ( through EXECUTE ) . The body consists of 
 + the CQL query to prepare as a [ long string ] . 
 + 
 + The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , 
 + see Section 4 . 2 . 5 ) . 
 + 
 + 
 + 4 . 1 . 6 . EXECUTE 
 + 
 + Executes a prepared query . The body of the message must be : 
 + < id > < query _ parameters > 
 + where < id > is the prepared query ID . It ' s the [ short bytes ] returned as a 
 + response to a PREPARE message . As for < query _ parameters > , it has the exact 
 + same definition than in QUERY ( see Section 4 . 1 . 4 ) . 
 + 
 + The response from the server will be a RESULT message . 
 + 
 + 
 + 4 . 1 . 7 . BATCH 
 + 
 + Allows executing a list of queries ( prepared or not ) as a batch ( note that 
 + only DML statements are accepted in a batch ) . The body of the message must 
 + be : 
 + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] 
 + where : 
 + - < type > is a [ byte ] indicating the type of batch to use : 
 + - If < type > = = 0 , the batch will be " logged " . This is equivalent to a 
 + normal CQL3 batch statement . 
 + - If < type > = = 1 , the batch will be " unlogged " . 
 + - If < type > = = 2 , the batch will be a " counter " batch ( and non - counter 
 + statements will be rejected ) . 
 + - < flags > is a [ byte ] whose bits define the options for this query and 
 + in particular influence the remainder of the message contains . It is similar 
 + to the < flags > from QUERY and EXECUTE methods , except that the 4 rightmost 
 + bits must always be 0 as their corresponding option do not make sense for 
 + Batch . A flag is set if the bit corresponding to its ` mask ` is set . Supported 
 + flags are , given there mask : 
 + 0x10 : With serial consistency . If present , < serial _ consistency > should be 
 + present . < serial _ consistency > is the [ consistency ] level for the 
 + serial phase of conditional updates . That consitency can only be 
 + either SERIAL or LOCAL _ SERIAL and if not present , it defaults to 
 + SERIAL . This option will be ignored for anything else that a 
 + conditional update / insert . 
 + 0x20 : With default timestamp . If present , < timestamp > should be present . 
 + < timestamp > is a [ long ] representing the default timestamp for the query 
 + in microseconds . If provided , this will replace the server side assigned 
 + timestamp as default timestamp . Note that a timestamp in the query itself 
 + will still override this timestamp . This is entirely optional . 
 + 0x40 : With names for values . If set , then all values for all < query _ i > must be 
 + preceded by a [ string ] < name _ i > that have the same meaning as in QUERY 
 + requests . 
 + - < n > is a [ short ] indicating the number of following queries . 
 + - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the 
 + form : 
 + < kind > < string _ or _ id > < n > [ < name _ 1 > ] < value _ 1 > . . . [ < name _ n > ] < value _ n > 
 + where : 
 + - < kind > is a [ byte ] indicating whether the following query is a prepared 
 + one or not . < kind > value must be either 0 or 1 . 
 + - < string _ or _ id > depends on the value of < kind > . If < kind > = = 0 , it should be 
 + a [ long string ] query string ( as in QUERY , the query string might contain 
 + bind markers ) . Otherwise ( that is , if < kind > = = 1 ) , it should be a 
 + [ short bytes ] representing a prepared query ID . 
 + - < n > is a [ short ] indicating the number ( possibly 0 ) of following values . 
 + - < name _ i > is the optional name of the following < value _ i > . It must be present 
 + if and only if the 0x40 flag is provided for the batch . 
 + - < value _ i > is the [ bytes ] to use for bound variable i ( of bound variable < name _ i > 
 + if the 0x40 flag is used ) . 
 + - < consistency > is the [ consistency ] level for the operation . 
 + - < serial _ consistency > is only present if the 0x10 flag is set . In that case , 
 + < serial _ consistency > is the [ consistency ] level for the serial phase of 
 + conditional updates . That consitency can only be either SERIAL or 
 + LOCAL _ SERIAL and if not present will defaults to SERIAL . This option will 
 + be ignored for anything else that a conditional update / insert . 
 + 
 + The server will respond with a RESULT message . 
 + 
 + 
 + 4 . 1 . 8 . REGISTER 
 + 
 + Register this connection to receive some type of events . The body of the 
 + message is a [ string list ] representing the event types to register to . See 
 + section 4 . 2 . 6 for the list of valid event types . 
 + 
 + The response to a REGISTER message will be a READY message . 
 + 
 + Please note that if a client driver maintains multiple connections to a 
 + Cassandra node and / or connections to multiple nodes , it is advised to 
 + dedicate a handful of connections to receive events , but to * not * register 
 + for events on all connections , as this would only result in receiving 
 + multiple times the same event messages , wasting bandwidth . 
 + 
 + 
 + 4 . 2 . Responses 
 + 
 + This section describes the content of the frame body for the different 
 + responses . Please note that to make room for future evolution , clients should 
 + support extra informations ( that they should simply discard ) to the one 
 + described in this document at the end of the frame body . 
 + 
 + 4 . 2 . 1 . ERROR 
 + 
 + Indicates an error processing a request . The body of the message will be an 
 + error code ( [ int ] ) followed by a [ string ] error message . Then , depending on 
 + the exception , more content may follow . The error codes are defined in 
 + Section 9 , along with their additional content if any . 
 + 
 + 
 + 4 . 2 . 2 . READY 
 + 
 + Indicates that the server is ready to process queries . This message will be 
 + sent by the server either after a STARTUP message if no authentication is 
 + required , or after a successful CREDENTIALS message . 
 + 
 + The body of a READY message is empty . 
 + 
 + 
 + 4 . 2 . 3 . AUTHENTICATE 
 + 
 + Indicates that the server require authentication , and which authentication 
 + mechanism to use . 
 + 
 + The authentication is SASL based and thus consists on a number of server 
 + challenges ( AUTH _ CHALLENGE , Section 4 . 2 . 7 ) followed by client responses 
 + ( AUTH _ RESPONSE , Section 4 . 1 . 2 ) . The Initial exchange is however boostrapped 
 + by an initial client response . The details of that exchange ( including how 
 + much challenge - response pair are required ) are specific to the authenticator 
 + in use . The exchange ends when the server sends an AUTH _ SUCCESS message or 
 + an ERROR message . 
 + 
 + This message will be sent following a STARTUP message if authentication is 
 + required and must be answered by a AUTH _ RESPONSE message from the client . 
 + 
 + The body consists of a single [ string ] indicating the full class name of the 
 + IAuthenticator in use . 
 + 
 + 
 + 4 . 2 . 4 . SUPPORTED 
 + 
 + Indicates which startup options are supported by the server . This message 
 + comes as a response to an OPTIONS message . 
 + 
 + The body of a SUPPORTED message is a [ string multimap ] . This multimap gives 
 + for each of the supported STARTUP options , the list of supported values . 
 + 
 + 
 + 4 . 2 . 5 . RESULT 
 + 
 + The result to a query ( QUERY , PREPARE , EXECUTE or BATCH messages ) . 
 + 
 + The first element of the body of a RESULT message is an [ int ] representing the 
 + ` kind ` of result . The rest of the body depends on the kind . The kind can be 
 + one of : 
 + 0x0001 Void : for results carrying no information . 
 + 0x0002 Rows : for results to select queries , returning a set of rows . 
 + 0x0003 Set _ keyspace : the result to a ` use ` query . 
 + 0x0004 Prepared : result to a PREPARE message . 
 + 0x0005 Schema _ change : the result to a schema altering query . 
 + 
 + The body for each kind ( after the [ int ] kind ) is defined below . 
 + 
 + 
 + 4 . 2 . 5 . 1 . Void 
 + 
 + The rest of the body for a Void result is empty . It indicates that a query was 
 + successful without providing more information . 
 + 
 + 
 + 4 . 2 . 5 . 2 . Rows 
 + 
 + Indicates a set of rows . The rest of body of a Rows result is : 
 + < metadata > < rows _ count > < rows _ content > 
 + where : 
 + - < metadata > is composed of : 
 + < flags > < columns _ count > [ < paging _ state > ] [ < global _ table _ spec > ? < col _ spec _ 1 > . . . < col _ spec _ n > ] 
 + where : 
 + - < flags > is an [ int ] . The bits of < flags > provides information on the 
 + formatting of the remaining informations . A flag is set if the bit 
 + corresponding to its ` mask ` is set . Supported flags are , given there 
 + mask : 
 + 0x0001 Global _ tables _ spec : if set , only one table spec ( keyspace 
 + and table name ) is provided as < global _ table _ spec > . If not 
 + set , < global _ table _ spec > is not present . 
 + 0x0002 Has _ more _ pages : indicates whether this is not the last 
 + page of results and more should be retrieve . If set , the 
 + < paging _ state > will be present . The < paging _ state > is a 
 + [ bytes ] value that should be used in QUERY / EXECUTE to 
 + continue paging and retrieve the remained of the result for 
 + this query ( See Section 8 for more details ) . 
 + 0x0004 No _ metadata : if set , the < metadata > is only composed of 
 + these < flags > , the < column _ count > and optionally the 
 + < paging _ state > ( depending on the Has _ more _ pages flage ) but 
 + no other information ( so no < global _ table _ spec > nor < col _ spec _ i > ) . 
 + This will only ever be the case if this was requested 
 + during the query ( see QUERY and RESULT messages ) . 
 + - < columns _ count > is an [ int ] representing the number of columns selected 
 + by the query this result is of . It defines the number of < col _ spec _ i > 
 + elements in and the number of element for each row in < rows _ content > . 
 + - < global _ table _ spec > is present if the Global _ tables _ spec is set in 
 + < flags > . If present , it is composed of two [ string ] representing the 
 + ( unique ) keyspace name and table name the columns return are of . 
 + - < col _ spec _ i > specifies the columns returned in the query . There is 
 + < column _ count > such column specifications that are composed of : 
 + ( < ksname > < tablename > ) ? < name > < type > 
 + The initial < ksname > and < tablename > are two [ string ] are only present 
 + if the Global _ tables _ spec flag is not set . The < column _ name > is a 
 + [ string ] and < type > is an [ option ] that correspond to the description 
 + ( what this description is depends a bit on the context : in results to 
 + selects , this will be either the user chosen alias or the selection used 
 + ( often a colum name , but it can be a function call too ) . In results to 
 + a PREPARE , this will be either the name of the bind variable corresponding 
 + or the column name for the variable if it is " anonymous " ) and type of 
 + the corresponding result . The option for < type > is either a native 
 + type ( see below ) , in which case the option has no value , or a 
 + ' custom ' type , in which case the value is a [ string ] representing 
 + the full qualified class name of the type represented . Valid option 
 + ids are : 
 + 0x0000 Custom : the value is a [ string ] , see above . 
 + 0x0001 Ascii 
 + 0x0002 Bigint 
 + 0x0003 Blob 
 + 0x0004 Boolean 
 + 0x0005 Counter 
 + 0x0006 Decimal 
 + 0x0007 Double 
 + 0x0008 Float 
 + 0x0009 Int 
 + 0x000B Timestamp 
 + 0x000C Uuid 
 + 0x000D Varchar 
 + 0x000E Varint 
 + 0x000F Timeuuid 
 + 0x0010 Inet 
 + 0x0020 List : the value is an [ option ] , representing the type 
 + of the elements of the list . 
 + 0x0021 Map : the value is two [ option ] , representing the types of the 
 + keys and values of the map 
 + 0x0022 Set : the value is an [ option ] , representing the type 
 + of the elements of the set 
 + 0x0030 UDT : the value is < ks > < udt _ name > < n > < name _ 1 > < type _ 1 > . . . < name _ n > < type _ n > 
 + where : 
 + - < ks > is a [ string ] representing the keyspace name this 
 + UDT is part of . 
 + - < udt _ name > is a [ string ] representing the UDT name . 
 + - < n > is a [ short ] reprensenting the number of fields of 
 + the UDT , and thus the number of < name _ i > < type _ i > pair 
 + following 
 + - < name _ i > is a [ string ] representing the name of the 
 + i _ th field of the UDT . 
 + - < type _ i > is an [ option ] representing the type of the 
 + i _ th field of the UDT . 
 + 0x0031 Tuple : the value is < n > < type _ 1 > . . . < type _ n > where < n > is a [ short ] 
 + representing the number of value in the type , and < type _ i > 
 + are [ option ] representing the type of the i _ th component 
 + of the tuple 
 + 
 + - < rows _ count > is an [ int ] representing the number of rows present in this 
 + result . Those rows are serialized in the < rows _ content > part . 
 + - < rows _ content > is composed of < row _ 1 > . . . < row _ m > where m is < rows _ count > . 
 + Each < row _ i > is composed of < value _ 1 > . . . < value _ n > where n is 
 + < columns _ count > and where < value _ j > is a [ bytes ] representing the value 
 + returned for the jth column of the ith row . In other words , < rows _ content > 
 + is composed of ( < rows _ count > * < columns _ count > ) [ bytes ] . 
 + 
 + 
 + 4 . 2 . 5 . 3 . Set _ keyspace 
 + 
 + The result to a ` use ` query . The body ( after the kind [ int ] ) is a single 
 + [ string ] indicating the name of the keyspace that has been set . 
 + 
 + 
 + 4 . 2 . 5 . 4 . Prepared 
 + 
 + The result to a PREPARE message . The rest of the body of a Prepared result is : 
 + < id > < metadata > < result _ metadata > 
 + where : 
 + - < id > is [ short bytes ] representing the prepared query ID . 
 + - < metadata > is defined exactly as for a Rows RESULT ( See section 4 . 2 . 5 . 2 ; you 
 + can however assume that the Has _ more _ pages flag is always off ) and 
 + is the specification for the variable bound in this prepare statement . 
 + - < result _ metadata > is defined exactly as < metadata > but correspond to the 
 + metadata for the resultSet that execute this query will yield . Note that 
 + < result _ metadata > may be empty ( have the No _ metadata flag and 0 columns , See 
 + section 4 . 2 . 5 . 2 ) and will be for any query that is not a Select . There is 
 + in fact never a guarantee that this will non - empty so client should protect 
 + themselves accordingly . The presence of this information is an 
 + optimization that allows to later execute the statement that has been 
 + prepared without requesting the metadata ( Skip _ metadata flag in EXECUTE ) . 
 + Clients can safely discard this metadata if they do not want to take 
 + advantage of that optimization . 
 + 
 + Note that prepared query ID return is global to the node on which the query 
 + has been prepared . It can be used on any connection to that node and this 
 + until the node is restarted ( after which the query must be reprepared ) . 
 + 
 + 4 . 2 . 5 . 5 . Schema _ change 
 + 
 + The result to a schema altering query ( creation / update / drop of a 
 + keyspace / table / index ) . The body ( after the kind [ int ] ) is the same 
 + as the body for a " SCHEMA _ CHANGE " event , so 3 strings : 
 + < change _ type > < target > < options > 
 + Please refer to the section 4 . 2 . 6 below for the meaning of those fields . 
 + 
 + Note that queries to create and drop an index are considered as change 
 + updating the table the index is on . 
 + 
 + 
 + 4 . 2 . 6 . EVENT 
 + 
 + And event pushed by the server . A client will only receive events for the 
 + type it has REGISTER to . The body of an EVENT message will start by a 
 + [ string ] representing the event type . The rest of the message depends on the 
 + event type . The valid event types are : 
 + - " TOPOLOGY _ CHANGE " : events related to change in the cluster topology . 
 + Currently , events are sent when new nodes are added to the cluster , and 
 + when nodes are removed . The body of the message ( after the event type ) 
 + consists of a [ string ] and an [ inet ] , corresponding respectively to the 
 + type of change ( " NEW _ NODE " or " REMOVED _ NODE " ) followed by the address of 
 + the new / removed node . 
 + - " STATUS _ CHANGE " : events related to change of node status . Currently , 
 + up / down events are sent . The body of the message ( after the event type ) 
 + consists of a [ string ] and an [ inet ] , corresponding respectively to the 
 + type of status change ( " UP " or " DOWN " ) followed by the address of the 
 + concerned node . 
 + - " SCHEMA _ CHANGE " : events related to schema change . After the event type , 
 + the rest of the message will be < change _ type > < target > < options > where : 
 + - < change _ type > is a [ string ] representing the type of changed involved . 
 + It will be one of " CREATED " , " UPDATED " or " DROPPED " . 
 + - < target > is a [ string ] that can be one of " KEYSPACE " , " TABLE " or " TYPE " 
 + and describes what has been modified ( " TYPE " stands for modifications 
 + related to user types ) . 
 + - < options > depends on the preceding < target > . If < target > is 
 + " KEYSPACE " , then < options > will be a single [ string ] representing the 
 + keyspace changed . Otherwise , if < target > is " TABLE " or " TYPE " , then 
 + < options > will be 2 [ string ] : the first one will be the keyspace 
 + containing the affected object , and the second one will be the name 
 + of said affected object ( so either the table name or the user type 
 + name ) . 
 + 
 + All EVENT message have a streamId of - 1 ( Section 2 . 3 ) . 
 + 
 + Please note that " NEW _ NODE " and " UP " events are sent based on internal Gossip 
 + communication and as such may be sent a short delay before the binary 
 + protocol server on the newly up node is fully started . Clients are thus 
 + advise to wait a short time before trying to connect to the node ( 1 seconds 
 + should be enough ) , otherwise they may experience a connection refusal at 
 + first . 
 + 
 + 4 . 2 . 7 . AUTH _ CHALLENGE 
 + 
 + A server authentication challenge ( see AUTH _ RESPONSE ( Section 4 . 1 . 2 ) for more 
 + details ) . 
 + 
 + The body of this message is a single [ bytes ] token . The details of what this 
 + token contains ( and when it can be null / empty , if ever ) depends on the actual 
 + authenticator used . 
 + 
 + Clients are expected to answer the server challenge by an AUTH _ RESPONSE 
 + message . 
 + 
 + 4 . 2 . 7 . AUTH _ SUCCESS 
 + 
 + Indicate the success of the authentication phase . See Section 4 . 2 . 3 for more 
 + details . 
 + 
 + The body of this message is a single [ bytes ] token holding final information 
 + from the server that the client may require to finish the authentication 
 + process . What that token contains and whether it can be null depends on the 
 + actual authenticator used . 
 + 
 + 
 + 5 . Compression 
 + 
 + Frame compression is supported by the protocol , but then only the frame body 
 + is compressed ( the frame header should never be compressed ) . 
 + 
 + Before being used , client and server must agree on a compression algorithm to 
 + use , which is done in the STARTUP message . As a consequence , a STARTUP message 
 + must never be compressed . However , once the STARTUP frame has been received 
 + by the server can be compressed ( including the response to the STARTUP 
 + request ) . Frame do not have to be compressed however , even if compression has 
 + been agreed upon ( a server may only compress frame above a certain size at its 
 + discretion ) . A frame body should be compressed if and only if the compressed 
 + flag ( see Section 2 . 2 ) is set . 
 + 
 + As of this version 2 of the protocol , the following compressions are available : 
 + - lz4 ( https : / / code . google . com / p / lz4 / ) . In that , note that the 4 first bytes 
 + of the body will be the uncompressed length ( followed by the compressed 
 + bytes ) . 
 + - snappy ( https : / / code . google . com / p / snappy / ) . This compression might not be 
 + available as it depends on a native lib ( server - side ) that might not be 
 + avaivable on some installation . 
 + 
 + 
 + 6 . Collection types 
 + 
 + This section describe the serialization format for the collection types : 
 + list , map and set . This serialization format is both useful to decode values 
 + returned in RESULT messages but also to encode values for EXECUTE ones . 
 + 
 + The serialization formats are : 
 + List : a [ int ] n indicating the size of the list , followed by n elements . 
 + Each element is [ bytes ] representing the serialized element 
 + value . 
 + Map : a [ int ] n indicating the size of the map , followed by n entries . 
 + Each entry is composed of two [ bytes ] representing the key and 
 + the value of the entry map . 
 + Set : a [ int ] n indicating the size of the set , followed by n elements . 
 + Each element is [ bytes ] representing the serialized element 
 + value . 
 + 
 + 
 + 7 . User defined and tuple types 
 + 
 + This section describes the serialization format for User defined types ( UDT ) and 
 + tuple values . UDT ( resp . tuple ) values are the values of the User Defined Types 
 + ( resp . tuple type ) as defined in section 4 . 2 . 5 . 2 . 
 + 
 + A UDT value is composed of successive [ bytes ] values , one for each field of the UDT 
 + value ( in the order defined by the type ) . A UDT value will generally have one value 
 + for each field of the type it represents , but it is allowed to have less values than 
 + the type has fields . 
 + 
 + A tuple value has the exact same serialization format , i . e . a succession of 
 + [ bytes ] values representing the components of the tuple . 
 + 
 + 
 + 8 . Result paging 
 + 
 + The protocol allows for paging the result of queries . For that , the QUERY and 
 + EXECUTE messages have a < result _ page _ size > value that indicate the desired 
 + page size in CQL3 rows . 
 + 
 + If a positive value is provided for < result _ page _ size > , the result set of the 
 + RESULT message returned for the query will contain at most the 
 + < result _ page _ size > first rows of the query result . If that first page of result 
 + contains the full result set for the query , the RESULT message ( of kind ` Rows ` ) 
 + will have the Has _ more _ pages flag * not * set . However , if some results are not 
 + part of the first response , the Has _ more _ pages flag will be set and the result 
 + will contain a < paging _ state > value . In that case , the < paging _ state > value 
 + should be used in a QUERY or EXECUTE message ( that has the * same * query than 
 + the original one or the behavior is undefined ) to retrieve the next page of 
 + results . 
 + 
 + Only CQL3 queries that return a result set ( RESULT message with a Rows ` kind ` ) 
 + support paging . For other type of queries , the < result _ page _ size > value is 
 + ignored . 
 + 
 + Note to client implementors : 
 + - While < result _ page _ size > can be as low as 1 , it will likely be detrimental 
 + to performance to pick a value too low . A value below 100 is probably too 
 + low for most use cases . 
 + - Clients should not rely on the actual size of the result set returned to 
 + decide if there is more result to fetch or not . Instead , they should always 
 + check the Has _ more _ pages flag ( unless they did not enabled paging for the query 
 + obviously ) . Clients should also not assert that no result will have more than 
 + < result _ page _ size > results . While the current implementation always respect 
 + the exact value of < result _ page _ size > , we reserve ourselves the right to return 
 + slightly smaller or bigger pages in the future for performance reasons . 
 + 
 + 
 + 9 . Error codes 
 + 
 + The supported error codes are described below : 
 + 0x0000 Server error : something unexpected happened . This indicates a 
 + server - side bug . 
 + 0x000A Protocol error : some client message triggered a protocol 
 + violation ( for instance a QUERY message is sent before a STARTUP 
 + one has been sent ) 
 + 0x0100 Bad credentials : CREDENTIALS request failed because Cassandra 
 + did not accept the provided credentials . 
 + 
 + 0x1000 Unavailable exception . The rest of the ERROR message body will be 
 + < cl > < required > < alive > 
 + where : 
 + < cl > is the [ consistency ] level of the query having triggered 
 + the exception . 
 + < required > is an [ int ] representing the number of node that 
 + should be alive to respect < cl > 
 + < alive > is an [ int ] representing the number of replica that 
 + were known to be alive when the request has been 
 + processed ( since an unavailable exception has been 
 + triggered , there will be < alive > < < required > ) 
 + 0x1001 Overloaded : the request cannot be processed because the 
 + coordinator node is overloaded 
 + 0x1002 Is _ bootstrapping : the request was a read request but the 
 + coordinator node is bootstrapping 
 + 0x1003 Truncate _ error : error during a truncation error . 
 + 0x1100 Write _ timeout : Timeout exception during a write request . The rest 
 + of the ERROR message body will be 
 + < cl > < received > < blockfor > < writeType > 
 + where : 
 + < cl > is the [ consistency ] level of the query having triggered 
 + the exception . 
 + < received > is an [ int ] representing the number of nodes having 
 + acknowledged the request . 
 + < blockfor > is the number of replica whose acknowledgement is 
 + required to achieve < cl > . 
 + < writeType > is a [ string ] that describe the type of the write 
 + that timeouted . The value of that string can be one 
 + of : 
 + - " SIMPLE " : the write was a non - batched 
 + non - counter write . 
 + - " BATCH " : the write was a ( logged ) batch write . 
 + If this type is received , it means the batch log 
 + has been successfully written ( otherwise a 
 + " BATCH _ LOG " type would have been send instead ) . 
 + - " UNLOGGED _ BATCH " : the write was an unlogged 
 + batch . Not batch log write has been attempted . 
 + - " COUNTER " : the write was a counter write 
 + ( batched or not ) . 
 + - " BATCH _ LOG " : the timeout occured during the 
 + write to the batch log when a ( logged ) batch 
 + write was requested . 
 + 0x1200 Read _ timeout : Timeout exception during a read request . The rest 
 + of the ERROR message body will be 
 + < cl > < received > < blockfor > < data _ present > 
 + where : 
 + < cl > is the [ consistency ] level of the query having triggered 
 + the exception . 
 + < received > is an [ int ] representing the number of nodes having 
 + answered the request . 
 + < blockfor > is the number of replica whose response is 
 + required to achieve < cl > . Please note that it is 
 + possible to have < received > > = < blockfor > if 
 + < data _ present > is false . And also in the ( unlikely ) 
 + case were < cl > is achieved but the coordinator node 
 + timeout while waiting for read - repair 
 + acknowledgement . 
 + < data _ present > is a single byte . If its value is 0 , it means 
 + the replica that was asked for data has not 
 + responded . Otherwise , the value is ! = 0 . 
 + 
 + 0x2000 Syntax _ error : The submitted query has a syntax error . 
 + 0x2100 Unauthorized : The logged user doesn ' t have the right to perform 
 + the query . 
 + 0x2200 Invalid : The query is syntactically correct but invalid . 
 + 0x2300 Config _ error : The query is invalid because of some configuration issue 
 + 0x2400 Already _ exists : The query attempted to create a keyspace or a 
 + table that was already existing . The rest of the ERROR message 
 + body will be < ks > < table > where : 
 + < ks > is a [ string ] representing either the keyspace that 
 + already exists , or the keyspace in which the table that 
 + already exists is . 
 + < table > is a [ string ] representing the name of the table that 
 + already exists . If the query was attempting to create a 
 + keyspace , < table > will be present but will be the empty 
 + string . 
 + 0x2500 Unprepared : Can be thrown while a prepared statement tries to be 
 + executed if the provide prepared statement ID is not known by 
 + this host . The rest of the ERROR message body will be [ short 
 + bytes ] representing the unknown ID . 
 + 
 + 10 . Changes from v3 
 + 
 +

NEAREST DIFF:
diff - - git a / drivers / py / cql / connection . py b / drivers / py / cql / connection . py 
 index d2131fd . . cd28df4 100644 
 - - - a / drivers / py / cql / connection . py 
 + + + b / drivers / py / cql / connection . py 
 @ @ - 25 , 7 + 25 , 7 @ @ import zlib 
 try : 
 from cassandra import Cassandra 
 from cassandra . ttypes import Compression , InvalidRequestException , \ 
 - CqlResultType 
 + CqlResultType , AuthenticationRequest 
 except ImportError : 
 # Hack to run from a source tree 
 import sys 
 @ @ - 38 , 7 + 38 , 7 @ @ except ImportError : 
 ' gen - py ' ) ) 
 from cassandra import Cassandra 
 from cassandra . ttypes import Compression , InvalidRequestException , \ 
 - CqlResultType 
 + CqlResultType , AuthenticationRequest 
 
 COMPRESSION _ SCHEMES = [ ' GZIP ' ] 
 DEFAULT _ COMPRESSION = ' GZIP ' 
 @ @ - 56 , 13 + 56 , 18 @ @ class Connection ( object ) : 
 . . . for column in row . columns : 
 . . . print " % s is % s years of age " % ( r . key , column . age ) 
 " " " 
 - def _ _ init _ _ ( self , host , port = 9160 , keyspace = None ) : 
 + def _ _ init _ _ ( self , host , port = 9160 , keyspace = None , username = None , 
 + password = None ) : 
 socket = TSocket . TSocket ( host , port ) 
 self . transport = TTransport . TFramedTransport ( socket ) 
 protocol = TBinaryProtocol . TBinaryProtocolAccelerated ( self . transport ) 
 self . client = Cassandra . Client ( protocol ) 
 socket . open ( ) 
 
 + if username and password : 
 + credentials = { " username " : username , " password " : password } 
 + self . client . login ( AuthenticationRequest ( credentials = credentials ) ) 
 + 
 if keyspace : 
 self . execute ( ' USE % s ; ' % keyspace ) 
 
 diff - - git a / drivers / py / cql / connection _ pool . py b / drivers / py / cql / connection _ pool . py 
 index 44a11fd . . 5d7bde6 100644 
 - - - a / drivers / py / cql / connection _ pool . py 
 + + + b / drivers / py / cql / connection _ pool . py 
 @ @ - 37 , 26 + 37 , 35 @ @ class ConnectionPool ( object ) : 
 > > > conn . execute ( . . . ) 
 > > > pool . return _ connection ( conn ) 
 " " " 
 - def _ _ init _ _ ( self , hostname , port = 9160 , keyspace = None , max _ conns = 25 , 
 - max _ idle = 5 , eviction _ delay = 10000 ) : 
 + def _ _ init _ _ ( self , hostname , port = 9160 , keyspace = None , username = None , 
 + password = None , max _ conns = 25 , max _ idle = 5 , eviction _ delay = 10000 ) : 
 self . hostname = hostname 
 self . port = port 
 self . keyspace = keyspace 
 + self . username = username 
 + self . password = password 
 self . max _ conns = max _ conns 
 self . max _ idle = max _ idle 
 self . eviction _ delay = eviction _ delay 
 
 self . connections = Queue ( ) 
 - self . connections . put ( Connection ( hostname , port , keyspace ) ) 
 + self . connections . put ( self . _ _ create _ connection ( ) ) 
 self . eviction = Eviction ( self . connections , 
 self . max _ idle , 
 self . eviction _ delay ) 
 + 
 + def _ _ create _ connection ( self ) : 
 + return Connection ( self . hostname , 
 + port = self . port , 
 + keyspace = self . keyspace , 
 + username = self . username , 
 + password = self . password ) 
 
 def borrow _ connection ( self ) : 
 try : 
 connection = self . connections . get ( block = False ) 
 except Empty : 
 - connection = Connection ( self . hostname , self . port , self . keyspace ) 
 + connection = self . _ _ create _ connection ( ) 
 return connection 
 
 def return _ connection ( self , connection ) :
