BLEU SCORE: 0.020980574531482755

TEST MSG: Dont try to interrupt index compactions when starting anticompactions .
GENERATED MSG: Fix race / ref leak in anticompaction

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7b06757 . . ffa251b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Don ' t try to cancel 2i compactions when starting anticompaction ( CASSANDRA - 15024 ) <nl> * Avoid NPE in RepairRunnable . recordFailure ( CASSANDRA - 15025 ) <nl> * SSL Cert Hot Reloading should check for sanity of the new keystore / truststore before loading it ( CASSANDRA - 14991 ) <nl> * Avoid leaking threads when failing anticompactions and rate limit anticompactions ( CASSANDRA - 15002 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index da75f43 . . c09b884 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 2185 , 31 + 2185 , 44 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public < V > V runWithCompactionsDisabled ( Callable < V > callable , boolean interruptValidation , boolean interruptViews ) <nl> { <nl> - return runWithCompactionsDisabled ( callable , ( sstable ) - > true , interruptValidation , interruptViews ) ; <nl> + return runWithCompactionsDisabled ( callable , ( sstable ) - > true , interruptValidation , interruptViews , true ) ; <nl> } <nl> <nl> - public < V > V runWithCompactionsDisabled ( Callable < V > callable , Predicate < SSTableReader > sstablesPredicate , boolean interruptValidation , boolean interruptViews ) <nl> + / * * <nl> + * Runs callable with compactions paused and compactions including sstables matching sstablePredicate stopped <nl> + * <nl> + * @ param callable what to do when compactions are paused <nl> + * @ param sstablesPredicate which sstables should we cancel compactions for <nl> + * @ param interruptValidation if we should interrupt validation compactions <nl> + * @ param interruptViews if we should interrupt view compactions <nl> + * @ param interruptIndexes if we should interrupt compactions on indexes . NOTE : if you set this to true your sstablePredicate <nl> + * must be able to handle LocalPartitioner sstables ! <nl> + * / <nl> + public < V > V runWithCompactionsDisabled ( Callable < V > callable , Predicate < SSTableReader > sstablesPredicate , boolean interruptValidation , boolean interruptViews , boolean interruptIndexes ) <nl> { <nl> / / synchronize so that concurrent invocations don ' t re - enable compactions partway through unexpectedly , <nl> / / and so we only run one major compaction at a time <nl> synchronized ( this ) <nl> { <nl> logger . trace ( " Cancelling in - progress compactions for { } " , metadata . name ) ; <nl> + Iterable < ColumnFamilyStore > toInterruptFor = interruptIndexes <nl> + ? concatWithIndexes ( ) <nl> + : Collections . singleton ( this ) ; <nl> <nl> - Iterable < ColumnFamilyStore > selfWithAuxiliaryCfs = interruptViews <nl> - ? Iterables . concat ( concatWithIndexes ( ) , viewManager . allViewsCfs ( ) ) <nl> - : concatWithIndexes ( ) ; <nl> + toInterruptFor = interruptViews <nl> + ? Iterables . concat ( toInterruptFor , viewManager . allViewsCfs ( ) ) <nl> + : toInterruptFor ; <nl> <nl> - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) <nl> + for ( ColumnFamilyStore cfs : toInterruptFor ) <nl> cfs . getCompactionStrategyManager ( ) . pause ( ) ; <nl> try <nl> { <nl> / / interrupt in - progress compactions <nl> - CompactionManager . instance . interruptCompactionForCFs ( selfWithAuxiliaryCfs , sstablesPredicate , interruptValidation ) ; <nl> - CompactionManager . instance . waitForCessation ( selfWithAuxiliaryCfs , sstablesPredicate ) ; <nl> + CompactionManager . instance . interruptCompactionForCFs ( toInterruptFor , sstablesPredicate , interruptValidation ) ; <nl> + CompactionManager . instance . waitForCessation ( toInterruptFor , sstablesPredicate ) ; <nl> <nl> / / doublecheck that we finished , instead of timing out <nl> - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) <nl> + for ( ColumnFamilyStore cfs : toInterruptFor ) <nl> { <nl> if ( cfs . getTracker ( ) . getCompacting ( ) . stream ( ) . anyMatch ( sstablesPredicate ) ) <nl> { <nl> @ @ - 2231 , 7 + 2244 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> finally <nl> { <nl> - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) <nl> + for ( ColumnFamilyStore cfs : toInterruptFor ) <nl> cfs . getCompactionStrategyManager ( ) . resume ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 84a3543 . . 85aff08 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 861 , 7 + 861 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return null ; <nl> } <nl> return cfStore . getCompactionStrategyManager ( ) . getUserDefinedTasks ( sstables , getDefaultGcBefore ( cfStore , FBUtilities . nowInSeconds ( ) ) ) ; <nl> - } , ( sstable ) - > new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( ranges ) , false , false ) ; <nl> + } , ( sstable ) - > new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( ranges ) , false , false , false ) ; <nl> <nl> if ( tasks = = null ) <nl> return ; <nl> diff - - git a / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java b / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java <nl> index 0449cf1 . . d5c3ca0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java <nl> + + + b / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java <nl> @ @ - 140 , 8 + 140 , 8 @ @ public class PendingAntiCompaction <nl> { <nl> / / todo : start tracking the parent repair session id that created the anticompaction to be able to give a better error messsage here : <nl> String message = String . format ( " Prepare phase for incremental repair session % s has failed because it encountered " + <nl> - " intersecting sstables belonging to another incremental repair session . This is " + <nl> - " caused by starting multiple conflicting incremental repairs at the same time " , prsid ) ; <nl> + " intersecting sstables ( % s ) belonging to another incremental repair session . This is " + <nl> + " caused by starting multiple conflicting incremental repairs at the same time " , prsid , ci . getSSTables ( ) ) ; <nl> throw new SSTableAcquisitionException ( message ) ; <nl> } <nl> return true ; <nl> @ @ - 185 , 6 + 185 , 8 @ @ public class PendingAntiCompaction <nl> LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; <nl> if ( txn ! = null ) <nl> return new AcquireResult ( cfs , Refs . ref ( sstables ) , txn ) ; <nl> + else <nl> + logger . error ( " Could not mark compacting for { } ( sstables = { } , compacting = { } ) " , sessionID , sstables , cfs . getTracker ( ) . getCompacting ( ) ) ; <nl> } <nl> catch ( SSTableAcquisitionException e ) <nl> { <nl> @ @ - 212 , 7 + 214 , 7 @ @ public class PendingAntiCompaction <nl> { <nl> / / Note that anticompactions are not disabled when running this . This is safe since runWithCompactionsDisabled <nl> / / is synchronized - acquireTuple and predicate can only be run by a single thread ( for the given cfs ) . <nl> - return cfs . runWithCompactionsDisabled ( this : : acquireTuple , predicate , false , false ) ; <nl> + return cfs . runWithCompactionsDisabled ( this : : acquireTuple , predicate , false , false , false ) ; <nl> } <nl> catch ( SSTableAcquisitionException e ) <nl> { <nl> @ @ - 224 , 9 + 226 , 14 @ @ public class PendingAntiCompaction <nl> Uninterruptibles . sleepUninterruptibly ( acquireSleepMillis , TimeUnit . MILLISECONDS ) ; <nl> <nl> if ( System . currentTimeMillis ( ) - start > delay ) <nl> - logger . debug ( " { } Timed out waiting to acquire sstables " , sessionID , e ) ; <nl> + logger . warn ( " { } Timed out waiting to acquire sstables " , sessionID , e ) ; <nl> <nl> } <nl> + catch ( Throwable t ) <nl> + { <nl> + logger . error ( " Got exception disabling compactions for session { } " , sessionID , t ) ; <nl> + throw t ; <nl> + } <nl> } while ( System . currentTimeMillis ( ) - start < delay ) ; <nl> return null ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java <nl> index 4b05fc4 . . cb4ef4a 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java <nl> @ @ - 36 , 9 + 36 , 11 @ @ import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; <nl> import org . apache . cassandra . db . repair . PendingAntiCompaction ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> @ @ - 61 , 14 + 63 , 8 @ @ import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNotNull ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> - public class CancelCompactionsTest <nl> + public class CancelCompactionsTest extends CQLTester <nl> { <nl> - @ BeforeClass <nl> - public static void setup ( ) <nl> - { <nl> - DatabaseDescriptor . daemonInitialization ( ) ; <nl> - } <nl> - <nl> / * * <nl> * makes sure we only cancel compactions if the precidate says we have overlapping sstables <nl> * / <nl> @ @ - 88 , 14 + 84 , 14 @ @ public class CancelCompactionsTest <nl> assertEquals ( 1 , activeCompactions . size ( ) ) ; <nl> assertEquals ( activeCompactions . get ( 0 ) . getCompactionInfo ( ) . getSSTables ( ) , toMarkCompacting ) ; <nl> / / predicate requires the non - compacting sstables , should not cancel the one currently compacting : <nl> - cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > ! toMarkCompacting . contains ( sstable ) , false , false ) ; <nl> + cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > ! toMarkCompacting . contains ( sstable ) , false , false , true ) ; <nl> assertEquals ( 1 , activeCompactions . size ( ) ) ; <nl> assertFalse ( activeCompactions . get ( 0 ) . isStopRequested ( ) ) ; <nl> <nl> / / predicate requires the compacting ones - make sure stop is requested and that when we abort that <nl> / / compaction we actually run the callable ( countdown the latch ) <nl> CountDownLatch cdl = new CountDownLatch ( 1 ) ; <nl> - Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , toMarkCompacting : : contains , false , false ) ) ; <nl> + Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , toMarkCompacting : : contains , false , false , true ) ) ; <nl> t . start ( ) ; <nl> while ( ! activeCompactions . get ( 0 ) . isStopRequested ( ) ) <nl> Thread . sleep ( 100 ) ; <nl> @ @ - 141 , 13 + 137 , 13 @ @ public class CancelCompactionsTest <nl> expectedSSTables . add ( new HashSet < > ( sstables . subList ( 6 , 9 ) ) ) ; <nl> assertEquals ( compactingSSTables , expectedSSTables ) ; <nl> <nl> - cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > false , false , false ) ; <nl> + cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > false , false , false , true ) ; <nl> assertEquals ( 2 , activeCompactions . size ( ) ) ; <nl> assertTrue ( activeCompactions . stream ( ) . noneMatch ( CompactionInfo . Holder : : isStopRequested ) ) ; <nl> <nl> CountDownLatch cdl = new CountDownLatch ( 1 ) ; <nl> / / start a compaction which only needs the sstables where first token is > 50 - these are the sstables compacted by tcts . get ( 1 ) <nl> - Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , ( sstable ) - > first ( sstable ) > 50 , false , false ) ) ; <nl> + Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , ( sstable ) - > first ( sstable ) > 50 , false , false , true ) ) ; <nl> t . start ( ) ; <nl> activeCompactions = CompactionManager . instance . active . getCompactions ( ) ; <nl> assertEquals ( 2 , activeCompactions . size ( ) ) ; <nl> @ @ - 335 , 7 + 331 , 7 @ @ public class CancelCompactionsTest <nl> } <nl> } <nl> assertTrue ( foundCompaction ) ; <nl> - cfs . runWithCompactionsDisabled ( ( ) - > { compactionsStopped . countDown ( ) ; return null ; } , ( sstable ) - > true , false , false ) ; <nl> + cfs . runWithCompactionsDisabled ( ( ) - > { compactionsStopped . countDown ( ) ; return null ; } , ( sstable ) - > true , false , false , true ) ; <nl> / / wait for the runWithCompactionsDisabled callable <nl> compactionsStopped . await ( ) ; <nl> assertEquals ( 1 , CompactionManager . instance . active . getCompactions ( ) . size ( ) ) ; <nl> @ @ - 418 , 4 + 414 , 40 @ @ public class CancelCompactionsTest <nl> <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void test2iCancellation ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( id int primary key , something int ) " ) ; <nl> + createIndex ( " create index on % s ( something ) " ) ; <nl> + getCurrentColumnFamilyStore ( ) . disableAutoCompaction ( ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + execute ( " insert into % s ( id , something ) values ( ? , ? ) " , i , i ) ; <nl> + flush ( ) ; <nl> + ColumnFamilyStore idx = getCurrentColumnFamilyStore ( ) . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; <nl> + Set < SSTableReader > sstables = new HashSet < > ( ) ; <nl> + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) <nl> + { <nl> + getCurrentColumnFamilyStore ( ) . runWithCompactionsDisabled ( ( ) - > true , ( sstable ) - > { sstables . add ( sstable ) ; return true ; } , false , false , false ) ; <nl> + } <nl> + / / the predicate only gets compacting sstables , and we are only compacting the 2i sstables - with interruptIndexes = false we should see no sstables here <nl> + assertTrue ( sstables . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSubrangeCompactionWith2i ( ) throws Throwable <nl> + { <nl> + createTable ( " create table % s ( id int primary key , something int ) " ) ; <nl> + createIndex ( " create index on % s ( something ) " ) ; <nl> + getCurrentColumnFamilyStore ( ) . disableAutoCompaction ( ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + execute ( " insert into % s ( id , something ) values ( ? , ? ) " , i , i ) ; <nl> + flush ( ) ; <nl> + ColumnFamilyStore idx = getCurrentColumnFamilyStore ( ) . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; <nl> + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) <nl> + { <nl> + IPartitioner partitioner = getCurrentColumnFamilyStore ( ) . getPartitioner ( ) ; <nl> + getCurrentColumnFamilyStore ( ) . forceCompactionForTokenRange ( Collections . singleton ( new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getMaximumToken ( ) ) ) ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java b / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java <nl> index 5adb7d6 . . 62b7db1 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java <nl> @ @ - 30 , 14 + 30 , 18 @ @ import org . junit . Ignore ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> import org . apache . cassandra . cql3 . QueryProcessor ; <nl> import org . apache . cassandra . cql3 . statements . schema . CreateTableStatement ; <nl> + import org . apache . cassandra . cql3 . statements . schema . IndexTarget ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> import org . apache . cassandra . repair . AbstractRepairTest ; <nl> import org . apache . cassandra . repair . consistent . LocalSessionAccessor ; <nl> + import org . apache . cassandra . schema . IndexMetadata ; <nl> + import org . apache . cassandra . schema . Indexes ; <nl> import org . apache . cassandra . schema . KeyspaceParams ; <nl> import org . apache . cassandra . schema . Schema ; <nl> import org . apache . cassandra . schema . TableMetadata ; <nl> @ @ - 79 , 7 + 83 , 15 @ @ public abstract class AbstractPendingAntiCompactionTest <nl> { <nl> ks = " ks _ " + System . currentTimeMillis ( ) ; <nl> cfm = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl ) , ks ) . build ( ) ; <nl> - TableMetadata cfm2 = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl2 ) , ks ) . build ( ) ; <nl> + <nl> + Indexes . Builder indexes = Indexes . builder ( ) ; <nl> + indexes . add ( IndexMetadata . fromIndexTargets ( Collections . singletonList ( new IndexTarget ( new ColumnIdentifier ( " v " , true ) , <nl> + IndexTarget . Type . VALUES ) ) , <nl> + tbl2 + " _ idx " , <nl> + IndexMetadata . Kind . COMPOSITES , Collections . emptyMap ( ) ) ) ; <nl> + <nl> + TableMetadata cfm2 = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl2 ) , ks ) . indexes ( indexes . build ( ) ) . build ( ) ; <nl> + <nl> SchemaLoader . createKeyspace ( ks , KeyspaceParams . simple ( 1 ) , cfm , cfm2 ) ; <nl> cfs = Schema . instance . getColumnFamilyStoreInstance ( cfm . id ) ; <nl> cfs2 = Schema . instance . getColumnFamilyStoreInstance ( cfm2 . id ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java b / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java <nl> index 1d4a97f . . e44c697 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java <nl> @ @ - 677 , 6 + 677 , 35 @ @ public class PendingAntiCompactionTest extends AbstractPendingAntiCompactionTest <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testWith2i ( ) throws ExecutionException , InterruptedException <nl> + { <nl> + cfs2 . disableAutoCompaction ( ) ; <nl> + makeSSTables ( 2 , cfs2 , 100 ) ; <nl> + ColumnFamilyStore idx = cfs2 . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; <nl> + ExecutorService es = Executors . newFixedThreadPool ( 1 ) ; <nl> + try <nl> + { <nl> + UUID prsid = prepareSession ( ) ; <nl> + for ( SSTableReader sstable : cfs2 . getLiveSSTables ( ) ) <nl> + assertFalse ( sstable . isPendingRepair ( ) ) ; <nl> + <nl> + / / mark the sstables pending , with a 2i compaction going , which should be untouched ; <nl> + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) <nl> + { <nl> + PendingAntiCompaction pac = new PendingAntiCompaction ( prsid , Collections . singleton ( cfs2 ) , atEndpoint ( FULL _ RANGE , NO _ RANGES ) , es ) ; <nl> + pac . run ( ) . get ( ) ; <nl> + } <nl> + / / and make sure it succeeded ; <nl> + for ( SSTableReader sstable : cfs2 . getLiveSSTables ( ) ) <nl> + assertTrue ( sstable . isPendingRepair ( ) ) ; <nl> + } <nl> + finally <nl> + { <nl> + es . shutdown ( ) ; <nl> + } <nl> + } <nl> + <nl> private static RangesAtEndpoint atEndpoint ( Collection < Range < Token > > full , Collection < Range < Token > > trans ) <nl> { <nl> RangesAtEndpoint . Builder builder = RangesAtEndpoint . builder ( local ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7b06757 . . ffa251b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Don ' t try to cancel 2i compactions when starting anticompaction ( CASSANDRA - 15024 ) 
 * Avoid NPE in RepairRunnable . recordFailure ( CASSANDRA - 15025 ) 
 * SSL Cert Hot Reloading should check for sanity of the new keystore / truststore before loading it ( CASSANDRA - 14991 ) 
 * Avoid leaking threads when failing anticompactions and rate limit anticompactions ( CASSANDRA - 15002 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index da75f43 . . c09b884 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 2185 , 31 + 2185 , 44 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public < V > V runWithCompactionsDisabled ( Callable < V > callable , boolean interruptValidation , boolean interruptViews ) 
 { 
 - return runWithCompactionsDisabled ( callable , ( sstable ) - > true , interruptValidation , interruptViews ) ; 
 + return runWithCompactionsDisabled ( callable , ( sstable ) - > true , interruptValidation , interruptViews , true ) ; 
 } 
 
 - public < V > V runWithCompactionsDisabled ( Callable < V > callable , Predicate < SSTableReader > sstablesPredicate , boolean interruptValidation , boolean interruptViews ) 
 + / * * 
 + * Runs callable with compactions paused and compactions including sstables matching sstablePredicate stopped 
 + * 
 + * @ param callable what to do when compactions are paused 
 + * @ param sstablesPredicate which sstables should we cancel compactions for 
 + * @ param interruptValidation if we should interrupt validation compactions 
 + * @ param interruptViews if we should interrupt view compactions 
 + * @ param interruptIndexes if we should interrupt compactions on indexes . NOTE : if you set this to true your sstablePredicate 
 + * must be able to handle LocalPartitioner sstables ! 
 + * / 
 + public < V > V runWithCompactionsDisabled ( Callable < V > callable , Predicate < SSTableReader > sstablesPredicate , boolean interruptValidation , boolean interruptViews , boolean interruptIndexes ) 
 { 
 / / synchronize so that concurrent invocations don ' t re - enable compactions partway through unexpectedly , 
 / / and so we only run one major compaction at a time 
 synchronized ( this ) 
 { 
 logger . trace ( " Cancelling in - progress compactions for { } " , metadata . name ) ; 
 + Iterable < ColumnFamilyStore > toInterruptFor = interruptIndexes 
 + ? concatWithIndexes ( ) 
 + : Collections . singleton ( this ) ; 
 
 - Iterable < ColumnFamilyStore > selfWithAuxiliaryCfs = interruptViews 
 - ? Iterables . concat ( concatWithIndexes ( ) , viewManager . allViewsCfs ( ) ) 
 - : concatWithIndexes ( ) ; 
 + toInterruptFor = interruptViews 
 + ? Iterables . concat ( toInterruptFor , viewManager . allViewsCfs ( ) ) 
 + : toInterruptFor ; 
 
 - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) 
 + for ( ColumnFamilyStore cfs : toInterruptFor ) 
 cfs . getCompactionStrategyManager ( ) . pause ( ) ; 
 try 
 { 
 / / interrupt in - progress compactions 
 - CompactionManager . instance . interruptCompactionForCFs ( selfWithAuxiliaryCfs , sstablesPredicate , interruptValidation ) ; 
 - CompactionManager . instance . waitForCessation ( selfWithAuxiliaryCfs , sstablesPredicate ) ; 
 + CompactionManager . instance . interruptCompactionForCFs ( toInterruptFor , sstablesPredicate , interruptValidation ) ; 
 + CompactionManager . instance . waitForCessation ( toInterruptFor , sstablesPredicate ) ; 
 
 / / doublecheck that we finished , instead of timing out 
 - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) 
 + for ( ColumnFamilyStore cfs : toInterruptFor ) 
 { 
 if ( cfs . getTracker ( ) . getCompacting ( ) . stream ( ) . anyMatch ( sstablesPredicate ) ) 
 { 
 @ @ - 2231 , 7 + 2244 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 finally 
 { 
 - for ( ColumnFamilyStore cfs : selfWithAuxiliaryCfs ) 
 + for ( ColumnFamilyStore cfs : toInterruptFor ) 
 cfs . getCompactionStrategyManager ( ) . resume ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 84a3543 . . 85aff08 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 861 , 7 + 861 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return null ; 
 } 
 return cfStore . getCompactionStrategyManager ( ) . getUserDefinedTasks ( sstables , getDefaultGcBefore ( cfStore , FBUtilities . nowInSeconds ( ) ) ) ; 
 - } , ( sstable ) - > new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( ranges ) , false , false ) ; 
 + } , ( sstable ) - > new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( ranges ) , false , false , false ) ; 
 
 if ( tasks = = null ) 
 return ; 
 diff - - git a / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java b / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java 
 index 0449cf1 . . d5c3ca0 100644 
 - - - a / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java 
 + + + b / src / java / org / apache / cassandra / db / repair / PendingAntiCompaction . java 
 @ @ - 140 , 8 + 140 , 8 @ @ public class PendingAntiCompaction 
 { 
 / / todo : start tracking the parent repair session id that created the anticompaction to be able to give a better error messsage here : 
 String message = String . format ( " Prepare phase for incremental repair session % s has failed because it encountered " + 
 - " intersecting sstables belonging to another incremental repair session . This is " + 
 - " caused by starting multiple conflicting incremental repairs at the same time " , prsid ) ; 
 + " intersecting sstables ( % s ) belonging to another incremental repair session . This is " + 
 + " caused by starting multiple conflicting incremental repairs at the same time " , prsid , ci . getSSTables ( ) ) ; 
 throw new SSTableAcquisitionException ( message ) ; 
 } 
 return true ; 
 @ @ - 185 , 6 + 185 , 8 @ @ public class PendingAntiCompaction 
 LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; 
 if ( txn ! = null ) 
 return new AcquireResult ( cfs , Refs . ref ( sstables ) , txn ) ; 
 + else 
 + logger . error ( " Could not mark compacting for { } ( sstables = { } , compacting = { } ) " , sessionID , sstables , cfs . getTracker ( ) . getCompacting ( ) ) ; 
 } 
 catch ( SSTableAcquisitionException e ) 
 { 
 @ @ - 212 , 7 + 214 , 7 @ @ public class PendingAntiCompaction 
 { 
 / / Note that anticompactions are not disabled when running this . This is safe since runWithCompactionsDisabled 
 / / is synchronized - acquireTuple and predicate can only be run by a single thread ( for the given cfs ) . 
 - return cfs . runWithCompactionsDisabled ( this : : acquireTuple , predicate , false , false ) ; 
 + return cfs . runWithCompactionsDisabled ( this : : acquireTuple , predicate , false , false , false ) ; 
 } 
 catch ( SSTableAcquisitionException e ) 
 { 
 @ @ - 224 , 9 + 226 , 14 @ @ public class PendingAntiCompaction 
 Uninterruptibles . sleepUninterruptibly ( acquireSleepMillis , TimeUnit . MILLISECONDS ) ; 
 
 if ( System . currentTimeMillis ( ) - start > delay ) 
 - logger . debug ( " { } Timed out waiting to acquire sstables " , sessionID , e ) ; 
 + logger . warn ( " { } Timed out waiting to acquire sstables " , sessionID , e ) ; 
 
 } 
 + catch ( Throwable t ) 
 + { 
 + logger . error ( " Got exception disabling compactions for session { } " , sessionID , t ) ; 
 + throw t ; 
 + } 
 } while ( System . currentTimeMillis ( ) - start < delay ) ; 
 return null ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java 
 index 4b05fc4 . . cb4ef4a 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / CancelCompactionsTest . java 
 @ @ - 36 , 9 + 36 , 11 @ @ import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; 
 import org . apache . cassandra . db . repair . PendingAntiCompaction ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 @ @ - 61 , 14 + 63 , 8 @ @ import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNotNull ; 
 import static org . junit . Assert . assertTrue ; 
 
 - public class CancelCompactionsTest 
 + public class CancelCompactionsTest extends CQLTester 
 { 
 - @ BeforeClass 
 - public static void setup ( ) 
 - { 
 - DatabaseDescriptor . daemonInitialization ( ) ; 
 - } 
 - 
 / * * 
 * makes sure we only cancel compactions if the precidate says we have overlapping sstables 
 * / 
 @ @ - 88 , 14 + 84 , 14 @ @ public class CancelCompactionsTest 
 assertEquals ( 1 , activeCompactions . size ( ) ) ; 
 assertEquals ( activeCompactions . get ( 0 ) . getCompactionInfo ( ) . getSSTables ( ) , toMarkCompacting ) ; 
 / / predicate requires the non - compacting sstables , should not cancel the one currently compacting : 
 - cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > ! toMarkCompacting . contains ( sstable ) , false , false ) ; 
 + cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > ! toMarkCompacting . contains ( sstable ) , false , false , true ) ; 
 assertEquals ( 1 , activeCompactions . size ( ) ) ; 
 assertFalse ( activeCompactions . get ( 0 ) . isStopRequested ( ) ) ; 
 
 / / predicate requires the compacting ones - make sure stop is requested and that when we abort that 
 / / compaction we actually run the callable ( countdown the latch ) 
 CountDownLatch cdl = new CountDownLatch ( 1 ) ; 
 - Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , toMarkCompacting : : contains , false , false ) ) ; 
 + Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , toMarkCompacting : : contains , false , false , true ) ) ; 
 t . start ( ) ; 
 while ( ! activeCompactions . get ( 0 ) . isStopRequested ( ) ) 
 Thread . sleep ( 100 ) ; 
 @ @ - 141 , 13 + 137 , 13 @ @ public class CancelCompactionsTest 
 expectedSSTables . add ( new HashSet < > ( sstables . subList ( 6 , 9 ) ) ) ; 
 assertEquals ( compactingSSTables , expectedSSTables ) ; 
 
 - cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > false , false , false ) ; 
 + cfs . runWithCompactionsDisabled ( ( ) - > null , ( sstable ) - > false , false , false , true ) ; 
 assertEquals ( 2 , activeCompactions . size ( ) ) ; 
 assertTrue ( activeCompactions . stream ( ) . noneMatch ( CompactionInfo . Holder : : isStopRequested ) ) ; 
 
 CountDownLatch cdl = new CountDownLatch ( 1 ) ; 
 / / start a compaction which only needs the sstables where first token is > 50 - these are the sstables compacted by tcts . get ( 1 ) 
 - Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , ( sstable ) - > first ( sstable ) > 50 , false , false ) ) ; 
 + Thread t = new Thread ( ( ) - > cfs . runWithCompactionsDisabled ( ( ) - > { cdl . countDown ( ) ; return null ; } , ( sstable ) - > first ( sstable ) > 50 , false , false , true ) ) ; 
 t . start ( ) ; 
 activeCompactions = CompactionManager . instance . active . getCompactions ( ) ; 
 assertEquals ( 2 , activeCompactions . size ( ) ) ; 
 @ @ - 335 , 7 + 331 , 7 @ @ public class CancelCompactionsTest 
 } 
 } 
 assertTrue ( foundCompaction ) ; 
 - cfs . runWithCompactionsDisabled ( ( ) - > { compactionsStopped . countDown ( ) ; return null ; } , ( sstable ) - > true , false , false ) ; 
 + cfs . runWithCompactionsDisabled ( ( ) - > { compactionsStopped . countDown ( ) ; return null ; } , ( sstable ) - > true , false , false , true ) ; 
 / / wait for the runWithCompactionsDisabled callable 
 compactionsStopped . await ( ) ; 
 assertEquals ( 1 , CompactionManager . instance . active . getCompactions ( ) . size ( ) ) ; 
 @ @ - 418 , 4 + 414 , 40 @ @ public class CancelCompactionsTest 
 
 } 
 } 
 + 
 + @ Test 
 + public void test2iCancellation ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( id int primary key , something int ) " ) ; 
 + createIndex ( " create index on % s ( something ) " ) ; 
 + getCurrentColumnFamilyStore ( ) . disableAutoCompaction ( ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + execute ( " insert into % s ( id , something ) values ( ? , ? ) " , i , i ) ; 
 + flush ( ) ; 
 + ColumnFamilyStore idx = getCurrentColumnFamilyStore ( ) . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; 
 + Set < SSTableReader > sstables = new HashSet < > ( ) ; 
 + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) 
 + { 
 + getCurrentColumnFamilyStore ( ) . runWithCompactionsDisabled ( ( ) - > true , ( sstable ) - > { sstables . add ( sstable ) ; return true ; } , false , false , false ) ; 
 + } 
 + / / the predicate only gets compacting sstables , and we are only compacting the 2i sstables - with interruptIndexes = false we should see no sstables here 
 + assertTrue ( sstables . isEmpty ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSubrangeCompactionWith2i ( ) throws Throwable 
 + { 
 + createTable ( " create table % s ( id int primary key , something int ) " ) ; 
 + createIndex ( " create index on % s ( something ) " ) ; 
 + getCurrentColumnFamilyStore ( ) . disableAutoCompaction ( ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + execute ( " insert into % s ( id , something ) values ( ? , ? ) " , i , i ) ; 
 + flush ( ) ; 
 + ColumnFamilyStore idx = getCurrentColumnFamilyStore ( ) . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; 
 + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) 
 + { 
 + IPartitioner partitioner = getCurrentColumnFamilyStore ( ) . getPartitioner ( ) ; 
 + getCurrentColumnFamilyStore ( ) . forceCompactionForTokenRange ( Collections . singleton ( new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getMaximumToken ( ) ) ) ) ; 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java b / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java 
 index 5adb7d6 . . 62b7db1 100644 
 - - - a / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java 
 + + + b / test / unit / org / apache / cassandra / db / repair / AbstractPendingAntiCompactionTest . java 
 @ @ - 30 , 14 + 30 , 18 @ @ import org . junit . Ignore ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 import org . apache . cassandra . cql3 . QueryProcessor ; 
 import org . apache . cassandra . cql3 . statements . schema . CreateTableStatement ; 
 + import org . apache . cassandra . cql3 . statements . schema . IndexTarget ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 import org . apache . cassandra . repair . AbstractRepairTest ; 
 import org . apache . cassandra . repair . consistent . LocalSessionAccessor ; 
 + import org . apache . cassandra . schema . IndexMetadata ; 
 + import org . apache . cassandra . schema . Indexes ; 
 import org . apache . cassandra . schema . KeyspaceParams ; 
 import org . apache . cassandra . schema . Schema ; 
 import org . apache . cassandra . schema . TableMetadata ; 
 @ @ - 79 , 7 + 83 , 15 @ @ public abstract class AbstractPendingAntiCompactionTest 
 { 
 ks = " ks _ " + System . currentTimeMillis ( ) ; 
 cfm = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl ) , ks ) . build ( ) ; 
 - TableMetadata cfm2 = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl2 ) , ks ) . build ( ) ; 
 + 
 + Indexes . Builder indexes = Indexes . builder ( ) ; 
 + indexes . add ( IndexMetadata . fromIndexTargets ( Collections . singletonList ( new IndexTarget ( new ColumnIdentifier ( " v " , true ) , 
 + IndexTarget . Type . VALUES ) ) , 
 + tbl2 + " _ idx " , 
 + IndexMetadata . Kind . COMPOSITES , Collections . emptyMap ( ) ) ) ; 
 + 
 + TableMetadata cfm2 = CreateTableStatement . parse ( String . format ( " CREATE TABLE % s . % s ( k INT PRIMARY KEY , v INT ) " , ks , tbl2 ) , ks ) . indexes ( indexes . build ( ) ) . build ( ) ; 
 + 
 SchemaLoader . createKeyspace ( ks , KeyspaceParams . simple ( 1 ) , cfm , cfm2 ) ; 
 cfs = Schema . instance . getColumnFamilyStoreInstance ( cfm . id ) ; 
 cfs2 = Schema . instance . getColumnFamilyStoreInstance ( cfm2 . id ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java b / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java 
 index 1d4a97f . . e44c697 100644 
 - - - a / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java 
 + + + b / test / unit / org / apache / cassandra / db / repair / PendingAntiCompactionTest . java 
 @ @ - 677 , 6 + 677 , 35 @ @ public class PendingAntiCompactionTest extends AbstractPendingAntiCompactionTest 
 } 
 } 
 
 + @ Test 
 + public void testWith2i ( ) throws ExecutionException , InterruptedException 
 + { 
 + cfs2 . disableAutoCompaction ( ) ; 
 + makeSSTables ( 2 , cfs2 , 100 ) ; 
 + ColumnFamilyStore idx = cfs2 . indexManager . getAllIndexColumnFamilyStores ( ) . iterator ( ) . next ( ) ; 
 + ExecutorService es = Executors . newFixedThreadPool ( 1 ) ; 
 + try 
 + { 
 + UUID prsid = prepareSession ( ) ; 
 + for ( SSTableReader sstable : cfs2 . getLiveSSTables ( ) ) 
 + assertFalse ( sstable . isPendingRepair ( ) ) ; 
 + 
 + / / mark the sstables pending , with a 2i compaction going , which should be untouched ; 
 + try ( LifecycleTransaction txn = idx . getTracker ( ) . tryModify ( idx . getLiveSSTables ( ) , OperationType . COMPACTION ) ) 
 + { 
 + PendingAntiCompaction pac = new PendingAntiCompaction ( prsid , Collections . singleton ( cfs2 ) , atEndpoint ( FULL _ RANGE , NO _ RANGES ) , es ) ; 
 + pac . run ( ) . get ( ) ; 
 + } 
 + / / and make sure it succeeded ; 
 + for ( SSTableReader sstable : cfs2 . getLiveSSTables ( ) ) 
 + assertTrue ( sstable . isPendingRepair ( ) ) ; 
 + } 
 + finally 
 + { 
 + es . shutdown ( ) ; 
 + } 
 + } 
 + 
 private static RangesAtEndpoint atEndpoint ( Collection < Range < Token > > full , Collection < Range < Token > > trans ) 
 { 
 RangesAtEndpoint . Builder builder = RangesAtEndpoint . builder ( local ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
