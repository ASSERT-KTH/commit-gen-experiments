BLEU SCORE: 0.05087641220727392

TEST MSG: cqlsh pg - style - strings broken
GENERATED MSG: cqlsh : Fix using COPY through SOURCE or - f

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d2510b6 . . 4e64134 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 3 <nl> + * cqlsh pg - style - strings broken ( CASSANDRA - 10484 ) <nl> * Make Hadoop CF splits more polite to custom orderered partitioners ( CASSANDRA - 10400 ) <nl> Merged from 2 . 1 : <nl> * Update internal python driver used by cqlsh ( CASSANDRA - 10161 ) <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index dcae173 . . 40b7d6b 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 135 , 7 + 135 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> < stringLiteral > : : = < quotedStringLiteral > <nl> | < pgStringLiteral > ; <nl> < quotedStringLiteral > : : = / ' ( [ ^ ' ] | ' ' ) * ' / ; <nl> - < pgStringLiteral > : : = / \ $ \ $ . * \ $ \ $ / ; <nl> + < pgStringLiteral > : : = / \ $ \ $ ( ? : ( ? ! \ $ \ $ ) | [ ^ $ ] ) * \ $ \ $ / ; <nl> < quotedName > : : = / " ( [ ^ " ] | " " ) * " / ; <nl> < float > : : = / - ? [ 0 - 9 ] + \ . [ 0 - 9 ] + / ; <nl> < uuid > : : = / [ 0 - 9a - f ] { 8 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 12 } / ; <nl> @ @ - 154 , 6 + 154 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> | " false " <nl> ; <nl> <nl> + < unclosedPgString > : : = / \ $ \ $ ( ? : ( ? ! \ $ \ $ ) | [ ^ $ ] ) * / ; <nl> < unclosedString > : : = / ' ( [ ^ ' ] | ' ' ) * / ; <nl> < unclosedName > : : = / " ( [ ^ " ] | " " ) * / ; <nl> < unclosedComment > : : = / [ / ] [ * ] . * $ / ; <nl> diff - - git a / pylib / cqlshlib / test / test _ cql _ parsing . py b / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> index cb8e3a6 . . c011d94 100644 <nl> - - - a / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> + + + b / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> @ @ - 31 , 6 + 31 , 41 @ @ class TestCqlParsing ( TestCase ) : <nl> self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " ' eggs ' " ) ) , <nl> [ ( " ' eggs ' " , ' quotedStringLiteral ' ) ] ) <nl> <nl> + tokens = CqlRuleSet . lex ( " ' spam \ nspam \ n \ tsausage ' " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + self . assertEqual ( tokens [ 0 ] [ 0 ] , " quotedStringLiteral " ) <nl> + <nl> + tokens = CqlRuleSet . lex ( " ' spam \ nspam \ n " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + self . assertEqual ( tokens [ 0 ] [ 0 ] , " unclosedString " ) <nl> + <nl> + tokens = CqlRuleSet . lex ( " ' foo bar ' ' spam \ nspam \ n " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + self . assertEqual ( tokens [ 1 ] [ 0 ] , " unclosedString " ) <nl> + <nl> + def test _ parse _ pgstring _ literals ( self ) : <nl> + for n in [ " $ $ eggs $ $ " , " $ $ Sausage 1 $ $ " , " $ $ spam \ nspam \ n \ tsausage $ $ " , " $ $ $ $ " ] : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , <nl> + [ ( n , ' pgStringLiteral ' ) ] ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " $ $ eggs $ $ " ) ) , <nl> + [ ( " $ $ eggs $ $ " , ' pgStringLiteral ' ) ] ) <nl> + <nl> + tokens = CqlRuleSet . lex ( " $ $ spam \ nspam \ n \ tsausage $ $ " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + # [ ( ' pgStringLiteral ' , ' $ $ spam \ nspam \ n \ tsausage $ $ ' , ( 0 , 22 ) ) ] <nl> + self . assertEqual ( tokens [ 0 ] [ 0 ] , " pgStringLiteral " ) <nl> + <nl> + tokens = CqlRuleSet . lex ( " $ $ spam \ nspam \ n " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + # [ ( ' unclosedPgString ' , ' $ $ ' , ( 0 , 2 ) ) , ( ' identifier ' , ' spam ' , ( 2 , 6 ) ) , ( ' identifier ' , ' spam ' , ( 7 , 11 ) ) ] <nl> + self . assertEqual ( tokens [ 0 ] [ 0 ] , " unclosedPgString " ) <nl> + <nl> + tokens = CqlRuleSet . lex ( " $ $ foo bar $ $ $ $ spam \ nspam \ n " ) <nl> + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) <nl> + # [ ( ' pgStringLiteral ' , ' $ $ foo bar $ $ ' , ( 0 , 11 ) ) , ( ' unclosedPgString ' , ' $ $ ' , ( 12 , 14 ) ) , ( ' identifier ' , ' spam ' , ( 14 , 18 ) ) , ( ' identifier ' , ' spam ' , ( 19 , 23 ) ) ] <nl> + self . assertEqual ( tokens [ 0 ] [ 0 ] , " pgStringLiteral " ) <nl> + self . assertEqual ( tokens [ 1 ] [ 0 ] , " unclosedPgString " ) <nl> + <nl> def test _ parse _ numbers ( self ) : <nl> for n in [ ' 6 ' , ' 398 ' , ' 18018 ' ] : <nl> self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) ,
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d2510b6 . . 4e64134 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 3 
 + * cqlsh pg - style - strings broken ( CASSANDRA - 10484 ) 
 * Make Hadoop CF splits more polite to custom orderered partitioners ( CASSANDRA - 10400 ) 
 Merged from 2 . 1 : 
 * Update internal python driver used by cqlsh ( CASSANDRA - 10161 ) 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index dcae173 . . 40b7d6b 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 135 , 7 + 135 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 < stringLiteral > : : = < quotedStringLiteral > 
 | < pgStringLiteral > ; 
 < quotedStringLiteral > : : = / ' ( [ ^ ' ] | ' ' ) * ' / ; 
 - < pgStringLiteral > : : = / \ $ \ $ . * \ $ \ $ / ; 
 + < pgStringLiteral > : : = / \ $ \ $ ( ? : ( ? ! \ $ \ $ ) | [ ^ $ ] ) * \ $ \ $ / ; 
 < quotedName > : : = / " ( [ ^ " ] | " " ) * " / ; 
 < float > : : = / - ? [ 0 - 9 ] + \ . [ 0 - 9 ] + / ; 
 < uuid > : : = / [ 0 - 9a - f ] { 8 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 4 } - [ 0 - 9a - f ] { 12 } / ; 
 @ @ - 154 , 6 + 154 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 | " false " 
 ; 
 
 + < unclosedPgString > : : = / \ $ \ $ ( ? : ( ? ! \ $ \ $ ) | [ ^ $ ] ) * / ; 
 < unclosedString > : : = / ' ( [ ^ ' ] | ' ' ) * / ; 
 < unclosedName > : : = / " ( [ ^ " ] | " " ) * / ; 
 < unclosedComment > : : = / [ / ] [ * ] . * $ / ; 
 diff - - git a / pylib / cqlshlib / test / test _ cql _ parsing . py b / pylib / cqlshlib / test / test _ cql _ parsing . py 
 index cb8e3a6 . . c011d94 100644 
 - - - a / pylib / cqlshlib / test / test _ cql _ parsing . py 
 + + + b / pylib / cqlshlib / test / test _ cql _ parsing . py 
 @ @ - 31 , 6 + 31 , 41 @ @ class TestCqlParsing ( TestCase ) : 
 self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " ' eggs ' " ) ) , 
 [ ( " ' eggs ' " , ' quotedStringLiteral ' ) ] ) 
 
 + tokens = CqlRuleSet . lex ( " ' spam \ nspam \ n \ tsausage ' " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + self . assertEqual ( tokens [ 0 ] [ 0 ] , " quotedStringLiteral " ) 
 + 
 + tokens = CqlRuleSet . lex ( " ' spam \ nspam \ n " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + self . assertEqual ( tokens [ 0 ] [ 0 ] , " unclosedString " ) 
 + 
 + tokens = CqlRuleSet . lex ( " ' foo bar ' ' spam \ nspam \ n " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + self . assertEqual ( tokens [ 1 ] [ 0 ] , " unclosedString " ) 
 + 
 + def test _ parse _ pgstring _ literals ( self ) : 
 + for n in [ " $ $ eggs $ $ " , " $ $ Sausage 1 $ $ " , " $ $ spam \ nspam \ n \ tsausage $ $ " , " $ $ $ $ " ] : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , 
 + [ ( n , ' pgStringLiteral ' ) ] ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " $ $ eggs $ $ " ) ) , 
 + [ ( " $ $ eggs $ $ " , ' pgStringLiteral ' ) ] ) 
 + 
 + tokens = CqlRuleSet . lex ( " $ $ spam \ nspam \ n \ tsausage $ $ " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + # [ ( ' pgStringLiteral ' , ' $ $ spam \ nspam \ n \ tsausage $ $ ' , ( 0 , 22 ) ) ] 
 + self . assertEqual ( tokens [ 0 ] [ 0 ] , " pgStringLiteral " ) 
 + 
 + tokens = CqlRuleSet . lex ( " $ $ spam \ nspam \ n " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + # [ ( ' unclosedPgString ' , ' $ $ ' , ( 0 , 2 ) ) , ( ' identifier ' , ' spam ' , ( 2 , 6 ) ) , ( ' identifier ' , ' spam ' , ( 7 , 11 ) ) ] 
 + self . assertEqual ( tokens [ 0 ] [ 0 ] , " unclosedPgString " ) 
 + 
 + tokens = CqlRuleSet . lex ( " $ $ foo bar $ $ $ $ spam \ nspam \ n " ) 
 + tokens = CqlRuleSet . cql _ massage _ tokens ( tokens ) 
 + # [ ( ' pgStringLiteral ' , ' $ $ foo bar $ $ ' , ( 0 , 11 ) ) , ( ' unclosedPgString ' , ' $ $ ' , ( 12 , 14 ) ) , ( ' identifier ' , ' spam ' , ( 14 , 18 ) ) , ( ' identifier ' , ' spam ' , ( 19 , 23 ) ) ] 
 + self . assertEqual ( tokens [ 0 ] [ 0 ] , " pgStringLiteral " ) 
 + self . assertEqual ( tokens [ 1 ] [ 0 ] , " unclosedPgString " ) 
 + 
 def test _ parse _ numbers ( self ) : 
 for n in [ ' 6 ' , ' 398 ' , ' 18018 ' ] : 
 self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) ,

NEAREST DIFF:
ELIMINATEDSENTENCE
