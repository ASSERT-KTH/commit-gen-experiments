BLEU SCORE: 0.05868924818816534

TEST MSG: Optimize java source - based UDF invocation
GENERATED MSG: Accept Java source code for user - defined functions

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 267c4c2 . . cf8f263 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Optimize java source - based UDF invocation ( CASSANDRA - 7924 ) <nl> * Accept dollar quoted strings in CQL ( CASSANDRA - 7769 ) <nl> * Make assassinate a first class command ( CASSANDRA - 7935 ) <nl> * Support IN clause on any clustering column ( CASSANDRA - 4762 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java b / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java <nl> deleted file mode 100644 <nl> index f147f00 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java <nl> + + + / dev / null <nl> @ @ - 1 , 91 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - package org . apache . cassandra . cql3 . functions ; <nl> - <nl> - import java . lang . reflect . InvocationTargetException ; <nl> - import java . lang . reflect . Method ; <nl> - import java . nio . ByteBuffer ; <nl> - import java . util . List ; <nl> - <nl> - import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> - <nl> - / * * <nl> - * UDF implementation base class for reflection and Java source UDFs . <nl> - * / <nl> - abstract class AbstractJavaUDF extends UDFunction <nl> - { <nl> - private final Method method ; <nl> - <nl> - AbstractJavaUDF ( FunctionName name , <nl> - List < ColumnIdentifier > argNames , <nl> - List < AbstractType < ? > > argTypes , <nl> - AbstractType < ? > returnType , <nl> - String language , <nl> - String body , <nl> - boolean deterministic ) <nl> - throws InvalidRequestException <nl> - { <nl> - super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; <nl> - assert language . equals ( requiredLanguage ( ) ) ; <nl> - this . method = resolveMethod ( ) ; <nl> - } <nl> - <nl> - abstract String requiredLanguage ( ) ; <nl> - <nl> - abstract Method resolveMethod ( ) throws InvalidRequestException ; <nl> - <nl> - protected Class < ? > [ ] javaParamTypes ( ) <nl> - { <nl> - Class < ? > paramTypes [ ] = new Class [ argTypes . size ( ) ] ; <nl> - for ( int i = 0 ; i < paramTypes . length ; i + + ) <nl> - paramTypes [ i ] = argTypes . get ( i ) . getSerializer ( ) . getType ( ) ; <nl> - return paramTypes ; <nl> - } <nl> - <nl> - protected Class < ? > javaReturnType ( ) <nl> - { <nl> - return returnType . getSerializer ( ) . getType ( ) ; <nl> - } <nl> - <nl> - public ByteBuffer execute ( List < ByteBuffer > parameters ) throws InvalidRequestException <nl> - { <nl> - Object [ ] parms = new Object [ argTypes . size ( ) ] ; <nl> - for ( int i = 0 ; i < parms . length ; i + + ) <nl> - { <nl> - ByteBuffer bb = parameters . get ( i ) ; <nl> - if ( bb ! = null ) <nl> - parms [ i ] = argTypes . get ( i ) . compose ( bb ) ; <nl> - } <nl> - <nl> - Object result ; <nl> - try <nl> - { <nl> - result = method . invoke ( null , parms ) ; <nl> - @ SuppressWarnings ( " unchecked " ) ByteBuffer r = result ! = null ? ( ( AbstractType ) returnType ) . decompose ( result ) : null ; <nl> - return r ; <nl> - } <nl> - catch ( InvocationTargetException | IllegalAccessException e ) <nl> - { <nl> - Throwable c = e . getCause ( ) ; <nl> - logger . error ( " Invocation of function ' { } ' failed " , this , c ) ; <nl> - throw new InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + c ) ; <nl> - } <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java <nl> deleted file mode 100644 <nl> index 7e483a0 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java <nl> + + + / dev / null <nl> @ @ - 1 , 112 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - package org . apache . cassandra . cql3 . functions ; <nl> - <nl> - import java . lang . reflect . Method ; <nl> - import java . util . List ; <nl> - import java . util . concurrent . atomic . AtomicInteger ; <nl> - <nl> - import javassist . CannotCompileException ; <nl> - import javassist . ClassPool ; <nl> - import javassist . CtClass ; <nl> - import javassist . CtNewMethod ; <nl> - import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> - <nl> - / * * <nl> - * User - defined function using Java source code in UDF body . <nl> - * < p / > <nl> - * This is used when the LANGUAGE of the UDF definition is " java " . <nl> - * / <nl> - final class JavaSourceBasedUDF extends AbstractJavaUDF <nl> - { <nl> - static final AtomicInteger clsIdgen = new AtomicInteger ( ) ; <nl> - <nl> - JavaSourceBasedUDF ( FunctionName name , <nl> - List < ColumnIdentifier > argNames , <nl> - List < AbstractType < ? > > argTypes , <nl> - AbstractType < ? > returnType , <nl> - String language , <nl> - String body , <nl> - boolean deterministic ) <nl> - throws InvalidRequestException <nl> - { <nl> - super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; <nl> - } <nl> - <nl> - String requiredLanguage ( ) <nl> - { <nl> - return " java " ; <nl> - } <nl> - <nl> - Method resolveMethod ( ) throws InvalidRequestException <nl> - { <nl> - Class < ? > jReturnType = javaReturnType ( ) ; <nl> - Class < ? > [ ] paramTypes = javaParamTypes ( ) ; <nl> - <nl> - StringBuilder code = new StringBuilder ( ) ; <nl> - code . append ( " public static " ) . <nl> - append ( jReturnType . getName ( ) ) . append ( ' ' ) . <nl> - append ( name . name ) . append ( ' ( ' ) ; <nl> - for ( int i = 0 ; i < paramTypes . length ; i + + ) <nl> - { <nl> - if ( i > 0 ) <nl> - code . append ( " , " ) ; <nl> - code . append ( paramTypes [ i ] . getName ( ) ) . <nl> - append ( ' ' ) . <nl> - append ( argNames . get ( i ) ) ; <nl> - } <nl> - code . append ( " ) { " ) ; <nl> - code . append ( body ) ; <nl> - code . append ( ' } ' ) ; <nl> - <nl> - ClassPool classPool = ClassPool . getDefault ( ) ; <nl> - CtClass cc = classPool . makeClass ( " org . apache . cassandra . cql3 . udf . gen . C " + javaIdentifierPart ( name . toString ( ) ) + ' _ ' + clsIdgen . incrementAndGet ( ) ) ; <nl> - try <nl> - { <nl> - cc . addMethod ( CtNewMethod . make ( code . toString ( ) , cc ) ) ; <nl> - Class < ? > clazz = cc . toClass ( ) ; <nl> - return clazz . getMethod ( name . name , paramTypes ) ; <nl> - } <nl> - catch ( LinkageError e ) <nl> - { <nl> - throw new InvalidRequestException ( " Could not compile function ' " + name + " ' from Java source : " + e . getMessage ( ) ) ; <nl> - } <nl> - catch ( CannotCompileException e ) <nl> - { <nl> - throw new InvalidRequestException ( " Could not compile function ' " + name + " ' from Java source : " + e . getReason ( ) ) ; <nl> - } <nl> - catch ( NoSuchMethodException e ) <nl> - { <nl> - throw new InvalidRequestException ( " Could not build function ' " + name + " ' from Java source " ) ; <nl> - } <nl> - } <nl> - <nl> - private static String javaIdentifierPart ( String qualifiedName ) <nl> - { <nl> - StringBuilder sb = new StringBuilder ( qualifiedName . length ( ) ) ; <nl> - for ( int i = 0 ; i < qualifiedName . length ( ) ; i + + ) <nl> - { <nl> - char c = qualifiedName . charAt ( i ) ; <nl> - if ( Character . isJavaIdentifierPart ( c ) ) <nl> - sb . append ( c ) ; <nl> - } <nl> - return sb . toString ( ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java <nl> new file mode 100644 <nl> index 0000000 . . 0f5fe48 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java <nl> @ @ - 0 , 0 + 1 , 252 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 . functions ; <nl> + <nl> + import java . lang . reflect . Constructor ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . List ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import javassist . CannotCompileException ; <nl> + import javassist . ClassPool ; <nl> + import javassist . CtClass ; <nl> + import javassist . CtNewConstructor ; <nl> + import javassist . CtNewMethod ; <nl> + import javassist . NotFoundException ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + <nl> + / * * <nl> + * Java source UDF code generation . <nl> + * / <nl> + public final class JavaSourceUDFFactory <nl> + { <nl> + private static final String GENERATED _ CODE _ PACKAGE = " org . apache . cassandra . cql3 . udf . gen . " ; <nl> + <nl> + protected static final Logger logger = LoggerFactory . getLogger ( JavaSourceUDFFactory . class ) ; <nl> + <nl> + private static final AtomicInteger classSequence = new AtomicInteger ( ) ; <nl> + <nl> + static UDFunction buildUDF ( FunctionName name , <nl> + List < ColumnIdentifier > argNames , <nl> + List < AbstractType < ? > > argTypes , <nl> + AbstractType < ? > returnType , <nl> + String body , <nl> + boolean deterministic ) <nl> + throws InvalidRequestException <nl> + { <nl> + Class < ? > javaReturnType = UDFunction . javaType ( returnType ) ; <nl> + Class < ? > [ ] javaParamTypes = UDFunction . javaParamTypes ( argTypes ) ; <nl> + <nl> + String clsName = generateClassName ( name ) ; <nl> + <nl> + String codeCtor = generateConstructor ( clsName ) ; <nl> + <nl> + / / Generate ' execute ' method ( implements org . apache . cassandra . cql3 . functions . Function . execute ) <nl> + String codeExec = generateExecuteMethod ( argNames , javaParamTypes ) ; <nl> + <nl> + / / Generate the ' executeInternal ' method <nl> + / / It is separated to allow return type and argument type checks during compile time via javassist . <nl> + String codeExecInt = generateExecuteInternalMethod ( argNames , body , javaReturnType , javaParamTypes ) ; <nl> + <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " Generating java source UDF for { } with following c ' tor and functions : \ n { } \ n { } \ n { } " , <nl> + name , codeCtor , codeExecInt , codeExec ) ; <nl> + <nl> + try <nl> + { <nl> + ClassPool classPool = ClassPool . getDefault ( ) ; <nl> + <nl> + / / get super class <nl> + CtClass base = classPool . get ( UDFunction . class . getName ( ) ) ; <nl> + <nl> + / / prepare class to generate <nl> + CtClass cc = classPool . makeClass ( GENERATED _ CODE _ PACKAGE + clsName , base ) ; <nl> + cc . setModifiers ( cc . getModifiers ( ) | Modifier . FINAL ) ; <nl> + <nl> + / / add c ' tor plus methods ( order matters ) <nl> + cc . addConstructor ( CtNewConstructor . make ( codeCtor , cc ) ) ; <nl> + cc . addMethod ( CtNewMethod . make ( codeExecInt , cc ) ) ; <nl> + cc . addMethod ( CtNewMethod . make ( codeExec , cc ) ) ; <nl> + <nl> + Constructor ctor = <nl> + cc . toClass ( ) . getDeclaredConstructor ( <nl> + FunctionName . class , List . class , List . class , <nl> + AbstractType . class , String . class , boolean . class ) ; <nl> + return ( UDFunction ) ctor . newInstance ( name , argNames , argTypes , returnType , body , deterministic ) ; <nl> + } <nl> + catch ( NotFoundException | CannotCompileException | NoSuchMethodException | LinkageError | InstantiationException | IllegalAccessException e ) <nl> + { <nl> + throw new InvalidRequestException ( String . format ( " Could not compile function ' % s ' from Java source : % s " , name , e ) ) ; <nl> + } <nl> + catch ( InvocationTargetException e ) <nl> + { <nl> + / / in case of an ITE , use the cause <nl> + throw new InvalidRequestException ( String . format ( " Could not compile function ' % s ' from Java source : % s " , name , e . getCause ( ) ) ) ; <nl> + } <nl> + } <nl> + <nl> + private static String generateClassName ( FunctionName name ) <nl> + { <nl> + String qualifiedName = name . toString ( ) ; <nl> + <nl> + StringBuilder sb = new StringBuilder ( qualifiedName . length ( ) + 10 ) ; <nl> + sb . append ( ' C ' ) ; <nl> + for ( int i = 0 ; i < qualifiedName . length ( ) ; i + + ) <nl> + { <nl> + char c = qualifiedName . charAt ( i ) ; <nl> + if ( Character . isJavaIdentifierPart ( c ) ) <nl> + sb . append ( c ) ; <nl> + } <nl> + sb . append ( ' _ ' ) ; <nl> + sb . append ( classSequence . incrementAndGet ( ) ) ; <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Generates constructor with just a call super class ( UDFunction ) constructor with constant ' java ' as language . <nl> + * / <nl> + private static String generateConstructor ( String clsName ) <nl> + { <nl> + return " public " + clsName + <nl> + " ( org . apache . cassandra . cql3 . functions . FunctionName name , " + <nl> + " java . util . List argNames , " + <nl> + " java . util . List argTypes , " + <nl> + " org . apache . cassandra . db . marshal . AbstractType returnType , " + <nl> + " String body , " + <nl> + " boolean deterministic ) \ n { " + <nl> + " super ( name , argNames , argTypes , returnType , \ " java \ " , body , deterministic ) ; \ n " + <nl> + " } " ; <nl> + } <nl> + <nl> + / * * <nl> + * Generate executeInternal method ( just there to find return and argument type mismatches in UDF body ) . <nl> + * <nl> + * Generated looks like this : <nl> + * < code > < pre > <nl> + * private < JAVA _ RETURN _ TYPE > executeInternal ( < JAVA _ ARG _ TYPE > paramOne , < JAVA _ ARG _ TYPE > nextParam ) <nl> + * { <nl> + * < UDF _ BODY > <nl> + * } <nl> + * < / pre > < / code > <nl> + * / <nl> + private static String generateExecuteInternalMethod ( List < ColumnIdentifier > argNames , String body , Class < ? > returnType , Class < ? > [ ] paramTypes ) <nl> + { <nl> + / / initial builder size can just be a guess ( prevent temp object allocations ) <nl> + StringBuilder codeInt = new StringBuilder ( 64 + 32 * paramTypes . length + body . length ( ) ) ; <nl> + codeInt . append ( " private " ) . append ( returnType . getName ( ) ) . append ( " executeInternal ( " ) ; <nl> + for ( int i = 0 ; i < paramTypes . length ; i + + ) <nl> + { <nl> + if ( i > 0 ) <nl> + codeInt . append ( " , " ) ; <nl> + codeInt . append ( paramTypes [ i ] . getName ( ) ) . <nl> + append ( ' ' ) . <nl> + append ( argNames . get ( i ) ) ; <nl> + } <nl> + codeInt . append ( " ) \ n { " ) . <nl> + append ( body ) . <nl> + append ( ' } ' ) ; <nl> + return codeInt . toString ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * <nl> + * Generate public execute ( ) method implementation . <nl> + * <nl> + * Generated looks like this : <nl> + * < code > < pre > <nl> + * <nl> + * public java . nio . ByteBuffer execute ( java . util . List params ) <nl> + * throws org . apache . cassandra . exceptions . InvalidRequestException <nl> + * { <nl> + * try <nl> + * { <nl> + * Object result = executeInternal ( <nl> + * ( < cast to JAVA _ ARG _ TYPE > ) org . apache . cassandra . cql3 . functions . JavaSourceUDFFactory . compose ( argTypes , params , 0 ) <nl> + * ) ; <nl> + * return result ! = null ? returnType . decompose ( result ) : null ; <nl> + * } <nl> + * catch ( Throwable t ) <nl> + * { <nl> + * logger . error ( " Invocation of function ' { } ' failed " , this , t ) ; <nl> + * if ( t instanceof VirtualMachineError ) <nl> + * throw ( VirtualMachineError ) t ; <nl> + * throw new org . apache . cassandra . exceptions . InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + t ) ; <nl> + * } <nl> + * } <nl> + * < / pre > < / code > <nl> + * / <nl> + private static String generateExecuteMethod ( List < ColumnIdentifier > argNames , Class < ? > [ ] paramTypes ) <nl> + { <nl> + / / usual methods are 700 - 800 chars long ( prevent temp object allocations ) <nl> + StringBuilder code = new StringBuilder ( 1024 ) ; <nl> + / / overrides org . apache . cassandra . cql3 . functions . Function . execute ( java . util . List ) <nl> + code . append ( " public java . nio . ByteBuffer execute ( java . util . List params ) \ n " + <nl> + " throws org . apache . cassandra . exceptions . InvalidRequestException \ n " + <nl> + " { \ n " + <nl> + " try \ n " + <nl> + " { \ n " + <nl> + " Object result = executeInternal ( " ) ; <nl> + for ( int i = 0 ; i < paramTypes . length ; i + + ) <nl> + { <nl> + if ( i > 0 ) <nl> + code . append ( ' , ' ) ; <nl> + <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + code . append ( " \ n / * " ) . append ( argNames . get ( i ) ) . append ( " * / " ) ; <nl> + <nl> + code . <nl> + / / cast to Java type <nl> + append ( " \ n ( " ) . append ( paramTypes [ i ] . getName ( ) ) . append ( " ) " ) . <nl> + / / generate object representation of input parameter <nl> + append ( " org . apache . cassandra . cql3 . functions . JavaSourceUDFFactory . compose ( argTypes , params , " ) . append ( i ) . append ( ' ) ' ) ; <nl> + } <nl> + <nl> + code . append ( " \ n ) ; \ n " + <nl> + / / generate serialized return value ( returnType is a field in AbstractFunction class ) <nl> + " return result ! = null ? returnType . decompose ( result ) : null ; \ n " + <nl> + / / <nl> + / / error handling . . . <nl> + " } \ n " + <nl> + " catch ( Throwable t ) \ n " + <nl> + " { \ n " + <nl> + " logger . error ( \ " Invocation of function ' { } ' failed \ " , this , t ) ; \ n " + <nl> + / / handle OutOfMemoryError and other fatals not here ! <nl> + " if ( t instanceof VirtualMachineError ) \ n " + <nl> + " throw ( VirtualMachineError ) t ; \ n " + <nl> + " throw new org . apache . cassandra . exceptions . InvalidRequestException ( \ " Invocation of function ' \ " + this + \ " ' failed : \ " + t ) ; \ n " + <nl> + " } \ n " + <nl> + " } " ) ; <nl> + <nl> + return code . toString ( ) ; <nl> + } <nl> + <nl> + / / Used by execute ( ) implementations of generated java source UDFs . <nl> + public static Object compose ( List < AbstractType < ? > > argTypes , List < ByteBuffer > parameters , int param ) <nl> + { <nl> + ByteBuffer bb = parameters . get ( param ) ; <nl> + return bb = = null ? null : argTypes . get ( param ) . compose ( bb ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java <nl> index e02147a . . 911537f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java <nl> @ @ - 17 , 8 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 . functions ; <nl> <nl> - import java . lang . reflect . Method ; <nl> - import java . lang . reflect . Modifier ; <nl> + import java . lang . invoke . MethodHandle ; <nl> + import java . lang . invoke . MethodHandles ; <nl> + import java . lang . invoke . MethodType ; <nl> + import java . nio . ByteBuffer ; <nl> import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> @ @ - 32 , 8 + 34 , 10 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> * <nl> * This is used when the LANGUAGE of the UDF definition is " class " . <nl> * / <nl> - final class ReflectionBasedUDF extends AbstractJavaUDF <nl> + final class ReflectionBasedUDF extends UDFunction <nl> { <nl> + private final MethodHandle method ; <nl> + <nl> ReflectionBasedUDF ( FunctionName name , <nl> List < ColumnIdentifier > argNames , <nl> List < AbstractType < ? > > argTypes , <nl> @ @ - 44 , 17 + 48 , 14 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF <nl> throws InvalidRequestException <nl> { <nl> super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; <nl> + assert language . equals ( " class " ) ; <nl> + this . method = resolveMethod ( ) ; <nl> } <nl> <nl> - String requiredLanguage ( ) <nl> - { <nl> - return " class " ; <nl> - } <nl> - <nl> - Method resolveMethod ( ) throws InvalidRequestException <nl> + private MethodHandle resolveMethod ( ) throws InvalidRequestException <nl> { <nl> - Class < ? > jReturnType = javaReturnType ( ) ; <nl> - Class < ? > [ ] paramTypes = javaParamTypes ( ) ; <nl> + Class < ? > jReturnType = javaType ( returnType ) ; <nl> + Class < ? > [ ] paramTypes = javaParamTypes ( argTypes ) ; <nl> <nl> String className ; <nl> String methodName ; <nl> @ @ - 73 , 18 + 74 , 11 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF <nl> { <nl> Class < ? > cls = Class . forName ( className , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; <nl> <nl> - Method method = cls . getMethod ( methodName , paramTypes ) ; <nl> - <nl> - if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) <nl> - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) is not static " ) ; <nl> - <nl> - if ( ! jReturnType . isAssignableFrom ( method . getReturnType ( ) ) ) <nl> - { <nl> - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) " + <nl> - " has incompatible return type " + method . getReturnType ( ) + " ( not assignable to " + jReturnType + ' ) ' ) ; <nl> - } <nl> + MethodHandles . Lookup handles = MethodHandles . lookup ( ) ; <nl> + MethodType methodType = MethodType . methodType ( jReturnType , paramTypes ) ; <nl> + MethodHandle handle = handles . findStatic ( cls , methodName , methodType ) ; <nl> <nl> - return method ; <nl> + return handle ; <nl> } <nl> catch ( ClassNotFoundException e ) <nl> { <nl> @ @ - 92 , 7 + 86 , 42 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF <nl> } <nl> catch ( NoSuchMethodException e ) <nl> { <nl> - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) does not exist " ) ; <nl> + throw new InvalidRequestException ( " Method ' public static " + jReturnType . getName ( ) + ' ' + <nl> + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + <nl> + " ) ' does not exist - check for static , argument types and return type " ) ; <nl> + } <nl> + catch ( IllegalAccessException e ) <nl> + { <nl> + throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) is not accessible " ) ; <nl> + } <nl> + } <nl> + <nl> + public ByteBuffer execute ( List < ByteBuffer > parameters ) throws InvalidRequestException <nl> + { <nl> + Object [ ] parms = new Object [ argTypes . size ( ) ] ; <nl> + for ( int i = 0 ; i < parms . length ; i + + ) <nl> + { <nl> + ByteBuffer bb = parameters . get ( i ) ; <nl> + if ( bb ! = null ) <nl> + parms [ i ] = argTypes . get ( i ) . compose ( bb ) ; <nl> + } <nl> + <nl> + Object result ; <nl> + try <nl> + { <nl> + result = method . invokeWithArguments ( parms ) ; <nl> + @ SuppressWarnings ( " unchecked " ) ByteBuffer r = result ! = null ? ( ( AbstractType ) returnType ) . decompose ( result ) : null ; <nl> + return r ; <nl> + } <nl> + catch ( VirtualMachineError e ) <nl> + { <nl> + / / handle OutOfMemoryError and other fatals not here ! <nl> + throw e ; <nl> + } <nl> + catch ( Throwable e ) <nl> + { <nl> + logger . error ( " Invocation of function ' { } ' failed " , this , e ) ; <nl> + throw new InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + e ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> index b4a706d . . 3ef5764 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java <nl> @ @ - 77 , 11 + 77 , 24 @ @ public abstract class UDFunction extends AbstractFunction <nl> switch ( language ) <nl> { <nl> case " class " : return new ReflectionBasedUDF ( name , argNames , argTypes , returnType , language , body , deterministic ) ; <nl> - case " java " : return new JavaSourceBasedUDF ( name , argNames , argTypes , returnType , language , body , deterministic ) ; <nl> + case " java " : return JavaSourceUDFFactory . buildUDF ( name , argNames , argTypes , returnType , body , deterministic ) ; <nl> default : throw new InvalidRequestException ( String . format ( " Invalid language % s for ' % s ' " , language , name ) ) ; <nl> } <nl> } <nl> <nl> + static Class < ? > [ ] javaParamTypes ( List < AbstractType < ? > > argTypes ) <nl> + { <nl> + Class < ? > paramTypes [ ] = new Class [ argTypes . size ( ) ] ; <nl> + for ( int i = 0 ; i < paramTypes . length ; i + + ) <nl> + paramTypes [ i ] = javaType ( argTypes . get ( i ) ) ; <nl> + return paramTypes ; <nl> + } <nl> + <nl> + static Class < ? > javaType ( AbstractType < ? > type ) <nl> + { <nl> + return type . getSerializer ( ) . getType ( ) ; <nl> + } <nl> + <nl> / * * <nl> * It can happen that a function has been declared ( is listed in the scheam ) but cannot <nl> * be loaded ( maybe only on some nodes ) . This is the case for instance if the class defining <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> index 3a48500 . . 5dd77bf 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java <nl> @ @ - 146 , 6 + 146 , 9 @ @ public class UFTest extends CQLTester <nl> / / can ' t drop native functions <nl> assertInvalid ( " DROP FUNCTION dateof " ) ; <nl> assertInvalid ( " DROP FUNCTION uuid " ) ; <nl> + <nl> + / / sin ( ) no longer exists <nl> + assertInvalid ( " SELECT key , sin ( d ) FROM % s " ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 213 , 6 + 216 , 11 @ @ public class UFTest extends CQLTester <nl> @ Test <nl> public void testCreateOrReplaceJavaFunction ( ) throws Throwable <nl> { <nl> + createTable ( " CREATE TABLE % s ( key int primary key , val double ) " ) ; <nl> + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 1 , 1d ) ; <nl> + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 2 , 2d ) ; <nl> + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 3 , 3d ) ; <nl> + <nl> execute ( " create function foo : : corjf ( input double ) returns double language java \ n " + <nl> " AS ' \ n " + <nl> " / / parameter val is of type java . lang . Double \ n " + <nl> @ @ - 223 , 16 + 231 , 25 @ @ public class UFTest extends CQLTester <nl> " double v = Math . sin ( input . doubleValue ( ) ) ; \ n " + <nl> " return Double . valueOf ( v ) ; \ n " + <nl> " ' ; " ) ; <nl> + <nl> + / / just check created function <nl> + assertRows ( execute ( " SELECT key , val , foo : : corjf ( val ) FROM % s " ) , <nl> + row ( 1 , 1d , Math . sin ( 1d ) ) , <nl> + row ( 2 , 2d , Math . sin ( 2d ) ) , <nl> + row ( 3 , 3d , Math . sin ( 3d ) ) <nl> + ) ; <nl> + <nl> execute ( " create or replace function foo : : corjf ( input double ) returns double language java \ n " + <nl> " AS ' \ n " + <nl> - " / / parameter val is of type java . lang . Double \ n " + <nl> - " / * return type is of type java . lang . Double * / \ n " + <nl> - " if ( input = = null ) { \ n " + <nl> - " return null ; \ n " + <nl> - " } \ n " + <nl> - " double v = Math . sin ( input . doubleValue ( ) ) ; \ n " + <nl> - " return Double . valueOf ( v ) ; \ n " + <nl> + " return input ; \ n " + <nl> " ' ; " ) ; <nl> + <nl> + / / check if replaced function returns correct result <nl> + assertRows ( execute ( " SELECT key , val , foo : : corjf ( val ) FROM % s " ) , <nl> + row ( 1 , 1d , 1d ) , <nl> + row ( 2 , 2d , 2d ) , <nl> + row ( 3 , 3d , 3d ) <nl> + ) ; <nl> } <nl> <nl> @ Test
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 267c4c2 . . cf8f263 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Optimize java source - based UDF invocation ( CASSANDRA - 7924 ) 
 * Accept dollar quoted strings in CQL ( CASSANDRA - 7769 ) 
 * Make assassinate a first class command ( CASSANDRA - 7935 ) 
 * Support IN clause on any clustering column ( CASSANDRA - 4762 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java b / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java 
 deleted file mode 100644 
 index f147f00 . . 0000000 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / AbstractJavaUDF . java 
 + + + / dev / null 
 @ @ - 1 , 91 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - package org . apache . cassandra . cql3 . functions ; 
 - 
 - import java . lang . reflect . InvocationTargetException ; 
 - import java . lang . reflect . Method ; 
 - import java . nio . ByteBuffer ; 
 - import java . util . List ; 
 - 
 - import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . exceptions . InvalidRequestException ; 
 - 
 - / * * 
 - * UDF implementation base class for reflection and Java source UDFs . 
 - * / 
 - abstract class AbstractJavaUDF extends UDFunction 
 - { 
 - private final Method method ; 
 - 
 - AbstractJavaUDF ( FunctionName name , 
 - List < ColumnIdentifier > argNames , 
 - List < AbstractType < ? > > argTypes , 
 - AbstractType < ? > returnType , 
 - String language , 
 - String body , 
 - boolean deterministic ) 
 - throws InvalidRequestException 
 - { 
 - super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; 
 - assert language . equals ( requiredLanguage ( ) ) ; 
 - this . method = resolveMethod ( ) ; 
 - } 
 - 
 - abstract String requiredLanguage ( ) ; 
 - 
 - abstract Method resolveMethod ( ) throws InvalidRequestException ; 
 - 
 - protected Class < ? > [ ] javaParamTypes ( ) 
 - { 
 - Class < ? > paramTypes [ ] = new Class [ argTypes . size ( ) ] ; 
 - for ( int i = 0 ; i < paramTypes . length ; i + + ) 
 - paramTypes [ i ] = argTypes . get ( i ) . getSerializer ( ) . getType ( ) ; 
 - return paramTypes ; 
 - } 
 - 
 - protected Class < ? > javaReturnType ( ) 
 - { 
 - return returnType . getSerializer ( ) . getType ( ) ; 
 - } 
 - 
 - public ByteBuffer execute ( List < ByteBuffer > parameters ) throws InvalidRequestException 
 - { 
 - Object [ ] parms = new Object [ argTypes . size ( ) ] ; 
 - for ( int i = 0 ; i < parms . length ; i + + ) 
 - { 
 - ByteBuffer bb = parameters . get ( i ) ; 
 - if ( bb ! = null ) 
 - parms [ i ] = argTypes . get ( i ) . compose ( bb ) ; 
 - } 
 - 
 - Object result ; 
 - try 
 - { 
 - result = method . invoke ( null , parms ) ; 
 - @ SuppressWarnings ( " unchecked " ) ByteBuffer r = result ! = null ? ( ( AbstractType ) returnType ) . decompose ( result ) : null ; 
 - return r ; 
 - } 
 - catch ( InvocationTargetException | IllegalAccessException e ) 
 - { 
 - Throwable c = e . getCause ( ) ; 
 - logger . error ( " Invocation of function ' { } ' failed " , this , c ) ; 
 - throw new InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + c ) ; 
 - } 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java 
 deleted file mode 100644 
 index 7e483a0 . . 0000000 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceBasedUDF . java 
 + + + / dev / null 
 @ @ - 1 , 112 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - package org . apache . cassandra . cql3 . functions ; 
 - 
 - import java . lang . reflect . Method ; 
 - import java . util . List ; 
 - import java . util . concurrent . atomic . AtomicInteger ; 
 - 
 - import javassist . CannotCompileException ; 
 - import javassist . ClassPool ; 
 - import javassist . CtClass ; 
 - import javassist . CtNewMethod ; 
 - import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . exceptions . InvalidRequestException ; 
 - 
 - / * * 
 - * User - defined function using Java source code in UDF body . 
 - * < p / > 
 - * This is used when the LANGUAGE of the UDF definition is " java " . 
 - * / 
 - final class JavaSourceBasedUDF extends AbstractJavaUDF 
 - { 
 - static final AtomicInteger clsIdgen = new AtomicInteger ( ) ; 
 - 
 - JavaSourceBasedUDF ( FunctionName name , 
 - List < ColumnIdentifier > argNames , 
 - List < AbstractType < ? > > argTypes , 
 - AbstractType < ? > returnType , 
 - String language , 
 - String body , 
 - boolean deterministic ) 
 - throws InvalidRequestException 
 - { 
 - super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; 
 - } 
 - 
 - String requiredLanguage ( ) 
 - { 
 - return " java " ; 
 - } 
 - 
 - Method resolveMethod ( ) throws InvalidRequestException 
 - { 
 - Class < ? > jReturnType = javaReturnType ( ) ; 
 - Class < ? > [ ] paramTypes = javaParamTypes ( ) ; 
 - 
 - StringBuilder code = new StringBuilder ( ) ; 
 - code . append ( " public static " ) . 
 - append ( jReturnType . getName ( ) ) . append ( ' ' ) . 
 - append ( name . name ) . append ( ' ( ' ) ; 
 - for ( int i = 0 ; i < paramTypes . length ; i + + ) 
 - { 
 - if ( i > 0 ) 
 - code . append ( " , " ) ; 
 - code . append ( paramTypes [ i ] . getName ( ) ) . 
 - append ( ' ' ) . 
 - append ( argNames . get ( i ) ) ; 
 - } 
 - code . append ( " ) { " ) ; 
 - code . append ( body ) ; 
 - code . append ( ' } ' ) ; 
 - 
 - ClassPool classPool = ClassPool . getDefault ( ) ; 
 - CtClass cc = classPool . makeClass ( " org . apache . cassandra . cql3 . udf . gen . C " + javaIdentifierPart ( name . toString ( ) ) + ' _ ' + clsIdgen . incrementAndGet ( ) ) ; 
 - try 
 - { 
 - cc . addMethod ( CtNewMethod . make ( code . toString ( ) , cc ) ) ; 
 - Class < ? > clazz = cc . toClass ( ) ; 
 - return clazz . getMethod ( name . name , paramTypes ) ; 
 - } 
 - catch ( LinkageError e ) 
 - { 
 - throw new InvalidRequestException ( " Could not compile function ' " + name + " ' from Java source : " + e . getMessage ( ) ) ; 
 - } 
 - catch ( CannotCompileException e ) 
 - { 
 - throw new InvalidRequestException ( " Could not compile function ' " + name + " ' from Java source : " + e . getReason ( ) ) ; 
 - } 
 - catch ( NoSuchMethodException e ) 
 - { 
 - throw new InvalidRequestException ( " Could not build function ' " + name + " ' from Java source " ) ; 
 - } 
 - } 
 - 
 - private static String javaIdentifierPart ( String qualifiedName ) 
 - { 
 - StringBuilder sb = new StringBuilder ( qualifiedName . length ( ) ) ; 
 - for ( int i = 0 ; i < qualifiedName . length ( ) ; i + + ) 
 - { 
 - char c = qualifiedName . charAt ( i ) ; 
 - if ( Character . isJavaIdentifierPart ( c ) ) 
 - sb . append ( c ) ; 
 - } 
 - return sb . toString ( ) ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java 
 new file mode 100644 
 index 0000000 . . 0f5fe48 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / JavaSourceUDFFactory . java 
 @ @ - 0 , 0 + 1 , 252 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 . functions ; 
 + 
 + import java . lang . reflect . Constructor ; 
 + import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Modifier ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . List ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import javassist . CannotCompileException ; 
 + import javassist . ClassPool ; 
 + import javassist . CtClass ; 
 + import javassist . CtNewConstructor ; 
 + import javassist . CtNewMethod ; 
 + import javassist . NotFoundException ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + 
 + / * * 
 + * Java source UDF code generation . 
 + * / 
 + public final class JavaSourceUDFFactory 
 + { 
 + private static final String GENERATED _ CODE _ PACKAGE = " org . apache . cassandra . cql3 . udf . gen . " ; 
 + 
 + protected static final Logger logger = LoggerFactory . getLogger ( JavaSourceUDFFactory . class ) ; 
 + 
 + private static final AtomicInteger classSequence = new AtomicInteger ( ) ; 
 + 
 + static UDFunction buildUDF ( FunctionName name , 
 + List < ColumnIdentifier > argNames , 
 + List < AbstractType < ? > > argTypes , 
 + AbstractType < ? > returnType , 
 + String body , 
 + boolean deterministic ) 
 + throws InvalidRequestException 
 + { 
 + Class < ? > javaReturnType = UDFunction . javaType ( returnType ) ; 
 + Class < ? > [ ] javaParamTypes = UDFunction . javaParamTypes ( argTypes ) ; 
 + 
 + String clsName = generateClassName ( name ) ; 
 + 
 + String codeCtor = generateConstructor ( clsName ) ; 
 + 
 + / / Generate ' execute ' method ( implements org . apache . cassandra . cql3 . functions . Function . execute ) 
 + String codeExec = generateExecuteMethod ( argNames , javaParamTypes ) ; 
 + 
 + / / Generate the ' executeInternal ' method 
 + / / It is separated to allow return type and argument type checks during compile time via javassist . 
 + String codeExecInt = generateExecuteInternalMethod ( argNames , body , javaReturnType , javaParamTypes ) ; 
 + 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " Generating java source UDF for { } with following c ' tor and functions : \ n { } \ n { } \ n { } " , 
 + name , codeCtor , codeExecInt , codeExec ) ; 
 + 
 + try 
 + { 
 + ClassPool classPool = ClassPool . getDefault ( ) ; 
 + 
 + / / get super class 
 + CtClass base = classPool . get ( UDFunction . class . getName ( ) ) ; 
 + 
 + / / prepare class to generate 
 + CtClass cc = classPool . makeClass ( GENERATED _ CODE _ PACKAGE + clsName , base ) ; 
 + cc . setModifiers ( cc . getModifiers ( ) | Modifier . FINAL ) ; 
 + 
 + / / add c ' tor plus methods ( order matters ) 
 + cc . addConstructor ( CtNewConstructor . make ( codeCtor , cc ) ) ; 
 + cc . addMethod ( CtNewMethod . make ( codeExecInt , cc ) ) ; 
 + cc . addMethod ( CtNewMethod . make ( codeExec , cc ) ) ; 
 + 
 + Constructor ctor = 
 + cc . toClass ( ) . getDeclaredConstructor ( 
 + FunctionName . class , List . class , List . class , 
 + AbstractType . class , String . class , boolean . class ) ; 
 + return ( UDFunction ) ctor . newInstance ( name , argNames , argTypes , returnType , body , deterministic ) ; 
 + } 
 + catch ( NotFoundException | CannotCompileException | NoSuchMethodException | LinkageError | InstantiationException | IllegalAccessException e ) 
 + { 
 + throw new InvalidRequestException ( String . format ( " Could not compile function ' % s ' from Java source : % s " , name , e ) ) ; 
 + } 
 + catch ( InvocationTargetException e ) 
 + { 
 + / / in case of an ITE , use the cause 
 + throw new InvalidRequestException ( String . format ( " Could not compile function ' % s ' from Java source : % s " , name , e . getCause ( ) ) ) ; 
 + } 
 + } 
 + 
 + private static String generateClassName ( FunctionName name ) 
 + { 
 + String qualifiedName = name . toString ( ) ; 
 + 
 + StringBuilder sb = new StringBuilder ( qualifiedName . length ( ) + 10 ) ; 
 + sb . append ( ' C ' ) ; 
 + for ( int i = 0 ; i < qualifiedName . length ( ) ; i + + ) 
 + { 
 + char c = qualifiedName . charAt ( i ) ; 
 + if ( Character . isJavaIdentifierPart ( c ) ) 
 + sb . append ( c ) ; 
 + } 
 + sb . append ( ' _ ' ) ; 
 + sb . append ( classSequence . incrementAndGet ( ) ) ; 
 + return sb . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * Generates constructor with just a call super class ( UDFunction ) constructor with constant ' java ' as language . 
 + * / 
 + private static String generateConstructor ( String clsName ) 
 + { 
 + return " public " + clsName + 
 + " ( org . apache . cassandra . cql3 . functions . FunctionName name , " + 
 + " java . util . List argNames , " + 
 + " java . util . List argTypes , " + 
 + " org . apache . cassandra . db . marshal . AbstractType returnType , " + 
 + " String body , " + 
 + " boolean deterministic ) \ n { " + 
 + " super ( name , argNames , argTypes , returnType , \ " java \ " , body , deterministic ) ; \ n " + 
 + " } " ; 
 + } 
 + 
 + / * * 
 + * Generate executeInternal method ( just there to find return and argument type mismatches in UDF body ) . 
 + * 
 + * Generated looks like this : 
 + * < code > < pre > 
 + * private < JAVA _ RETURN _ TYPE > executeInternal ( < JAVA _ ARG _ TYPE > paramOne , < JAVA _ ARG _ TYPE > nextParam ) 
 + * { 
 + * < UDF _ BODY > 
 + * } 
 + * < / pre > < / code > 
 + * / 
 + private static String generateExecuteInternalMethod ( List < ColumnIdentifier > argNames , String body , Class < ? > returnType , Class < ? > [ ] paramTypes ) 
 + { 
 + / / initial builder size can just be a guess ( prevent temp object allocations ) 
 + StringBuilder codeInt = new StringBuilder ( 64 + 32 * paramTypes . length + body . length ( ) ) ; 
 + codeInt . append ( " private " ) . append ( returnType . getName ( ) ) . append ( " executeInternal ( " ) ; 
 + for ( int i = 0 ; i < paramTypes . length ; i + + ) 
 + { 
 + if ( i > 0 ) 
 + codeInt . append ( " , " ) ; 
 + codeInt . append ( paramTypes [ i ] . getName ( ) ) . 
 + append ( ' ' ) . 
 + append ( argNames . get ( i ) ) ; 
 + } 
 + codeInt . append ( " ) \ n { " ) . 
 + append ( body ) . 
 + append ( ' } ' ) ; 
 + return codeInt . toString ( ) ; 
 + } 
 + 
 + / * * 
 + * 
 + * Generate public execute ( ) method implementation . 
 + * 
 + * Generated looks like this : 
 + * < code > < pre > 
 + * 
 + * public java . nio . ByteBuffer execute ( java . util . List params ) 
 + * throws org . apache . cassandra . exceptions . InvalidRequestException 
 + * { 
 + * try 
 + * { 
 + * Object result = executeInternal ( 
 + * ( < cast to JAVA _ ARG _ TYPE > ) org . apache . cassandra . cql3 . functions . JavaSourceUDFFactory . compose ( argTypes , params , 0 ) 
 + * ) ; 
 + * return result ! = null ? returnType . decompose ( result ) : null ; 
 + * } 
 + * catch ( Throwable t ) 
 + * { 
 + * logger . error ( " Invocation of function ' { } ' failed " , this , t ) ; 
 + * if ( t instanceof VirtualMachineError ) 
 + * throw ( VirtualMachineError ) t ; 
 + * throw new org . apache . cassandra . exceptions . InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + t ) ; 
 + * } 
 + * } 
 + * < / pre > < / code > 
 + * / 
 + private static String generateExecuteMethod ( List < ColumnIdentifier > argNames , Class < ? > [ ] paramTypes ) 
 + { 
 + / / usual methods are 700 - 800 chars long ( prevent temp object allocations ) 
 + StringBuilder code = new StringBuilder ( 1024 ) ; 
 + / / overrides org . apache . cassandra . cql3 . functions . Function . execute ( java . util . List ) 
 + code . append ( " public java . nio . ByteBuffer execute ( java . util . List params ) \ n " + 
 + " throws org . apache . cassandra . exceptions . InvalidRequestException \ n " + 
 + " { \ n " + 
 + " try \ n " + 
 + " { \ n " + 
 + " Object result = executeInternal ( " ) ; 
 + for ( int i = 0 ; i < paramTypes . length ; i + + ) 
 + { 
 + if ( i > 0 ) 
 + code . append ( ' , ' ) ; 
 + 
 + if ( logger . isDebugEnabled ( ) ) 
 + code . append ( " \ n / * " ) . append ( argNames . get ( i ) ) . append ( " * / " ) ; 
 + 
 + code . 
 + / / cast to Java type 
 + append ( " \ n ( " ) . append ( paramTypes [ i ] . getName ( ) ) . append ( " ) " ) . 
 + / / generate object representation of input parameter 
 + append ( " org . apache . cassandra . cql3 . functions . JavaSourceUDFFactory . compose ( argTypes , params , " ) . append ( i ) . append ( ' ) ' ) ; 
 + } 
 + 
 + code . append ( " \ n ) ; \ n " + 
 + / / generate serialized return value ( returnType is a field in AbstractFunction class ) 
 + " return result ! = null ? returnType . decompose ( result ) : null ; \ n " + 
 + / / 
 + / / error handling . . . 
 + " } \ n " + 
 + " catch ( Throwable t ) \ n " + 
 + " { \ n " + 
 + " logger . error ( \ " Invocation of function ' { } ' failed \ " , this , t ) ; \ n " + 
 + / / handle OutOfMemoryError and other fatals not here ! 
 + " if ( t instanceof VirtualMachineError ) \ n " + 
 + " throw ( VirtualMachineError ) t ; \ n " + 
 + " throw new org . apache . cassandra . exceptions . InvalidRequestException ( \ " Invocation of function ' \ " + this + \ " ' failed : \ " + t ) ; \ n " + 
 + " } \ n " + 
 + " } " ) ; 
 + 
 + return code . toString ( ) ; 
 + } 
 + 
 + / / Used by execute ( ) implementations of generated java source UDFs . 
 + public static Object compose ( List < AbstractType < ? > > argTypes , List < ByteBuffer > parameters , int param ) 
 + { 
 + ByteBuffer bb = parameters . get ( param ) ; 
 + return bb = = null ? null : argTypes . get ( param ) . compose ( bb ) ; 
 + } 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java b / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java 
 index e02147a . . 911537f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / ReflectionBasedUDF . java 
 @ @ - 17 , 8 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . cql3 . functions ; 
 
 - import java . lang . reflect . Method ; 
 - import java . lang . reflect . Modifier ; 
 + import java . lang . invoke . MethodHandle ; 
 + import java . lang . invoke . MethodHandles ; 
 + import java . lang . invoke . MethodType ; 
 + import java . nio . ByteBuffer ; 
 import java . util . Arrays ; 
 import java . util . List ; 
 
 @ @ - 32 , 8 + 34 , 10 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; 
 * 
 * This is used when the LANGUAGE of the UDF definition is " class " . 
 * / 
 - final class ReflectionBasedUDF extends AbstractJavaUDF 
 + final class ReflectionBasedUDF extends UDFunction 
 { 
 + private final MethodHandle method ; 
 + 
 ReflectionBasedUDF ( FunctionName name , 
 List < ColumnIdentifier > argNames , 
 List < AbstractType < ? > > argTypes , 
 @ @ - 44 , 17 + 48 , 14 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF 
 throws InvalidRequestException 
 { 
 super ( name , argNames , argTypes , returnType , language , body , deterministic ) ; 
 + assert language . equals ( " class " ) ; 
 + this . method = resolveMethod ( ) ; 
 } 
 
 - String requiredLanguage ( ) 
 - { 
 - return " class " ; 
 - } 
 - 
 - Method resolveMethod ( ) throws InvalidRequestException 
 + private MethodHandle resolveMethod ( ) throws InvalidRequestException 
 { 
 - Class < ? > jReturnType = javaReturnType ( ) ; 
 - Class < ? > [ ] paramTypes = javaParamTypes ( ) ; 
 + Class < ? > jReturnType = javaType ( returnType ) ; 
 + Class < ? > [ ] paramTypes = javaParamTypes ( argTypes ) ; 
 
 String className ; 
 String methodName ; 
 @ @ - 73 , 18 + 74 , 11 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF 
 { 
 Class < ? > cls = Class . forName ( className , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; 
 
 - Method method = cls . getMethod ( methodName , paramTypes ) ; 
 - 
 - if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) 
 - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) is not static " ) ; 
 - 
 - if ( ! jReturnType . isAssignableFrom ( method . getReturnType ( ) ) ) 
 - { 
 - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) " + 
 - " has incompatible return type " + method . getReturnType ( ) + " ( not assignable to " + jReturnType + ' ) ' ) ; 
 - } 
 + MethodHandles . Lookup handles = MethodHandles . lookup ( ) ; 
 + MethodType methodType = MethodType . methodType ( jReturnType , paramTypes ) ; 
 + MethodHandle handle = handles . findStatic ( cls , methodName , methodType ) ; 
 
 - return method ; 
 + return handle ; 
 } 
 catch ( ClassNotFoundException e ) 
 { 
 @ @ - 92 , 7 + 86 , 42 @ @ final class ReflectionBasedUDF extends AbstractJavaUDF 
 } 
 catch ( NoSuchMethodException e ) 
 { 
 - throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) does not exist " ) ; 
 + throw new InvalidRequestException ( " Method ' public static " + jReturnType . getName ( ) + ' ' + 
 + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + 
 + " ) ' does not exist - check for static , argument types and return type " ) ; 
 + } 
 + catch ( IllegalAccessException e ) 
 + { 
 + throw new InvalidRequestException ( " Method " + className + ' . ' + methodName + ' ( ' + Arrays . toString ( paramTypes ) + " ) is not accessible " ) ; 
 + } 
 + } 
 + 
 + public ByteBuffer execute ( List < ByteBuffer > parameters ) throws InvalidRequestException 
 + { 
 + Object [ ] parms = new Object [ argTypes . size ( ) ] ; 
 + for ( int i = 0 ; i < parms . length ; i + + ) 
 + { 
 + ByteBuffer bb = parameters . get ( i ) ; 
 + if ( bb ! = null ) 
 + parms [ i ] = argTypes . get ( i ) . compose ( bb ) ; 
 + } 
 + 
 + Object result ; 
 + try 
 + { 
 + result = method . invokeWithArguments ( parms ) ; 
 + @ SuppressWarnings ( " unchecked " ) ByteBuffer r = result ! = null ? ( ( AbstractType ) returnType ) . decompose ( result ) : null ; 
 + return r ; 
 + } 
 + catch ( VirtualMachineError e ) 
 + { 
 + / / handle OutOfMemoryError and other fatals not here ! 
 + throw e ; 
 + } 
 + catch ( Throwable e ) 
 + { 
 + logger . error ( " Invocation of function ' { } ' failed " , this , e ) ; 
 + throw new InvalidRequestException ( " Invocation of function ' " + this + " ' failed : " + e ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 index b4a706d . . 3ef5764 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / UDFunction . java 
 @ @ - 77 , 11 + 77 , 24 @ @ public abstract class UDFunction extends AbstractFunction 
 switch ( language ) 
 { 
 case " class " : return new ReflectionBasedUDF ( name , argNames , argTypes , returnType , language , body , deterministic ) ; 
 - case " java " : return new JavaSourceBasedUDF ( name , argNames , argTypes , returnType , language , body , deterministic ) ; 
 + case " java " : return JavaSourceUDFFactory . buildUDF ( name , argNames , argTypes , returnType , body , deterministic ) ; 
 default : throw new InvalidRequestException ( String . format ( " Invalid language % s for ' % s ' " , language , name ) ) ; 
 } 
 } 
 
 + static Class < ? > [ ] javaParamTypes ( List < AbstractType < ? > > argTypes ) 
 + { 
 + Class < ? > paramTypes [ ] = new Class [ argTypes . size ( ) ] ; 
 + for ( int i = 0 ; i < paramTypes . length ; i + + ) 
 + paramTypes [ i ] = javaType ( argTypes . get ( i ) ) ; 
 + return paramTypes ; 
 + } 
 + 
 + static Class < ? > javaType ( AbstractType < ? > type ) 
 + { 
 + return type . getSerializer ( ) . getType ( ) ; 
 + } 
 + 
 / * * 
 * It can happen that a function has been declared ( is listed in the scheam ) but cannot 
 * be loaded ( maybe only on some nodes ) . This is the case for instance if the class defining 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / UFTest . java b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 index 3a48500 . . 5dd77bf 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / UFTest . java 
 @ @ - 146 , 6 + 146 , 9 @ @ public class UFTest extends CQLTester 
 / / can ' t drop native functions 
 assertInvalid ( " DROP FUNCTION dateof " ) ; 
 assertInvalid ( " DROP FUNCTION uuid " ) ; 
 + 
 + / / sin ( ) no longer exists 
 + assertInvalid ( " SELECT key , sin ( d ) FROM % s " ) ; 
 } 
 
 @ Test 
 @ @ - 213 , 6 + 216 , 11 @ @ public class UFTest extends CQLTester 
 @ Test 
 public void testCreateOrReplaceJavaFunction ( ) throws Throwable 
 { 
 + createTable ( " CREATE TABLE % s ( key int primary key , val double ) " ) ; 
 + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 1 , 1d ) ; 
 + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 2 , 2d ) ; 
 + execute ( " INSERT INTO % s ( key , val ) VALUES ( ? , ? ) " , 3 , 3d ) ; 
 + 
 execute ( " create function foo : : corjf ( input double ) returns double language java \ n " + 
 " AS ' \ n " + 
 " / / parameter val is of type java . lang . Double \ n " + 
 @ @ - 223 , 16 + 231 , 25 @ @ public class UFTest extends CQLTester 
 " double v = Math . sin ( input . doubleValue ( ) ) ; \ n " + 
 " return Double . valueOf ( v ) ; \ n " + 
 " ' ; " ) ; 
 + 
 + / / just check created function 
 + assertRows ( execute ( " SELECT key , val , foo : : corjf ( val ) FROM % s " ) , 
 + row ( 1 , 1d , Math . sin ( 1d ) ) , 
 + row ( 2 , 2d , Math . sin ( 2d ) ) , 
 + row ( 3 , 3d , Math . sin ( 3d ) ) 
 + ) ; 
 + 
 execute ( " create or replace function foo : : corjf ( input double ) returns double language java \ n " + 
 " AS ' \ n " + 
 - " / / parameter val is of type java . lang . Double \ n " + 
 - " / * return type is of type java . lang . Double * / \ n " + 
 - " if ( input = = null ) { \ n " + 
 - " return null ; \ n " + 
 - " } \ n " + 
 - " double v = Math . sin ( input . doubleValue ( ) ) ; \ n " + 
 - " return Double . valueOf ( v ) ; \ n " + 
 + " return input ; \ n " + 
 " ' ; " ) ; 
 + 
 + / / check if replaced function returns correct result 
 + assertRows ( execute ( " SELECT key , val , foo : : corjf ( val ) FROM % s " ) , 
 + row ( 1 , 1d , 1d ) , 
 + row ( 2 , 2d , 2d ) , 
 + row ( 3 , 3d , 3d ) 
 + ) ; 
 } 
 
 @ Test

NEAREST DIFF:
ELIMINATEDSENTENCE
