BLEU SCORE: 0.010697691669654345

TEST MSG: Small optimisation to Columns subset serialization
GENERATED MSG: fix fd leak in sstable2json with non - mmap ' d i / o

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / Columns . java b / src / java / org / apache / cassandra / db / Columns . java <nl> index 0b29830 . . f217fd7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Columns . java <nl> + + + b / src / java / org / apache / cassandra / db / Columns . java <nl> @ @ - 484 , 13 + 484 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> public Columns deserializeSubset ( Columns superset , DataInputPlus in ) throws IOException <nl> { <nl> long encoded = in . readUnsignedVInt ( ) ; <nl> - if ( encoded = = - 1L ) <nl> + if ( encoded = = 0L ) <nl> { <nl> - return deserializeLargeSubset ( in , superset ) ; <nl> + return superset ; <nl> } <nl> - else if ( encoded = = 0L ) <nl> + else if ( superset . columnCount ( ) > = 64 ) <nl> { <nl> - return superset ; <nl> + return deserializeLargeSubset ( in , superset , ( int ) encoded ) ; <nl> } <nl> else <nl> { <nl> @ @ - 540 , 7 + 540 , 6 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> private void serializeLargeSubset ( Columns columns , int columnCount , Columns superset , int supersetCount , DataOutputPlus out ) throws IOException <nl> { <nl> / / write flag indicating we ' re in lengthy mode <nl> - out . writeUnsignedVInt ( - 1L ) ; <nl> out . writeUnsignedVInt ( supersetCount - columnCount ) ; <nl> BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; <nl> if ( columnCount < supersetCount / 2 ) <nl> @ @ - 571 , 10 + 570 , 9 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> } <nl> <nl> @ DontInline <nl> - private Columns deserializeLargeSubset ( DataInputPlus in , Columns superset ) throws IOException <nl> + private Columns deserializeLargeSubset ( DataInputPlus in , Columns superset , int delta ) throws IOException <nl> { <nl> int supersetCount = superset . columnCount ( ) ; <nl> - int delta = ( int ) in . readUnsignedVInt ( ) ; <nl> int columnCount = supersetCount - delta ; <nl> <nl> BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; <nl> @ @ - 614 , 7 + 612 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> private int serializeLargeSubsetSize ( Columns columns , int columnCount , Columns superset , int supersetCount ) <nl> { <nl> / / write flag indicating we ' re in lengthy mode <nl> - int size = TypeSizes . sizeofUnsignedVInt ( - 1L ) + TypeSizes . sizeofUnsignedVInt ( supersetCount - columnCount ) ; <nl> + int size = TypeSizes . sizeofUnsignedVInt ( supersetCount - columnCount ) ; <nl> BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; <nl> if ( columnCount < supersetCount / 2 ) <nl> {
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 44ca6d5 . . 75dcf58 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import javax . management . ObjectName ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> import org . apache . commons . collections . IteratorUtils ; <nl> + import org . apache . commons . lang . StringUtils ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 334 , 7 + 335 , 6 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> public void run ( ) <nl> { <nl> - logger . info ( " Creating index { } . { } " , table , indexedCfMetadata . cfName ) ; <nl> try <nl> { <nl> forceBlockingFlush ( ) ; <nl> @ @ - 348 , 7 + 348 , 6 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> throw new AssertionError ( e ) ; <nl> } <nl> buildSecondaryIndexes ( getSSTables ( ) , FBUtilities . singleton ( info . name ) ) ; <nl> - logger . info ( " Index { } complete " , indexedCfMetadata . cfName ) ; <nl> SystemTable . setIndexBuilt ( table . name , indexedCfMetadata . cfName ) ; <nl> } <nl> } ; <nl> @ @ - 357 , 7 + 356 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public void buildSecondaryIndexes ( Collection < SSTableReader > sstables , SortedSet < ByteBuffer > columns ) <nl> { <nl> - logger . debug ( " Submitting index build to compactionmanager " ) ; <nl> + logger . info ( String . format ( " Submitting index build of % s for data in % s " , <nl> + metadata . comparator . getString ( columns ) , StringUtils . join ( sstables , " , " ) ) ) ; <nl> Table . IndexBuilder builder = table . createIndexBuilder ( this , columns , new ReducingKeyIterator ( sstables ) ) ; <nl> Future future = CompactionManager . instance . submitIndexBuild ( this , builder ) ; <nl> try <nl> @ @ - 374 , 6 + 374 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> throw new RuntimeException ( e ) ; <nl> } <nl> + logger . info ( " Index build of " + metadata . comparator . getString ( columns ) + " complete " ) ; <nl> } <nl> <nl> / / called when dropping or renaming a CF . Performs mbean housekeeping and invalidates CFS to other operations . <nl> @ @ - 684 , 26 + 685 , 31 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> try <nl> { <nl> if ( oldMemtable . isFrozen ( ) ) <nl> + { <nl> + logger . debug ( " memtable is already frozen ; another thread must be flushing it " ) ; <nl> return null ; <nl> + } <nl> <nl> boolean isDropped = isIndex ( ) <nl> ? DatabaseDescriptor . getCFMetaData ( table . name , getParentColumnfamily ( ) ) = = null <nl> : DatabaseDescriptor . getCFMetaData ( metadata . cfId ) = = null ; <nl> if ( isDropped ) <nl> - return null ; / / column family was dropped . no point in flushing . <nl> + { <nl> + logger . debug ( " column family was dropped ; no point in flushing " ) ; <nl> + return null ; <nl> + } <nl> <nl> assert memtable = = oldMemtable ; <nl> memtable . freeze ( ) ; <nl> final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance . getContext ( ) : null ; <nl> - logger . info ( " switching in a fresh Memtable for " + columnFamily + " at " + ctx ) ; <nl> <nl> / / submit the memtable for any indexed sub - cfses , and our own . <nl> List < ColumnFamilyStore > icc = new ArrayList < ColumnFamilyStore > ( indexedColumns . size ( ) ) ; <nl> - icc . add ( this ) ; <nl> - for ( ColumnFamilyStore indexCfs : indexedColumns . values ( ) ) <nl> + / / don ' t assume that this . memtable is dirty ; forceFlush can bring us here during index build even if it is not <nl> + for ( ColumnFamilyStore cfs : Iterables . concat ( Collections . singleton ( this ) , indexedColumns . values ( ) ) ) <nl> { <nl> - if ( ! indexCfs . memtable . isClean ( ) ) <nl> - icc . add ( indexCfs ) ; <nl> + if ( ! cfs . memtable . isClean ( ) ) <nl> + icc . add ( cfs ) ; <nl> } <nl> final CountDownLatch latch = new CountDownLatch ( icc . size ( ) ) ; <nl> for ( ColumnFamilyStore cfs : icc ) <nl> @ @ - 711 , 6 + 717 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> submitFlush ( cfs . memtable , latch ) ; <nl> cfs . memtable = new Memtable ( cfs ) ; <nl> } <nl> + / / we marked our memtable as frozen as part of the concurrency control , <nl> + / / so even if there was nothing to flush we need to switch it out <nl> + if ( ! icc . contains ( this ) ) <nl> + memtable = new Memtable ( this ) ; <nl> <nl> / / when all the memtables have been written , including for indexes , mark the flush in the commitlog header . <nl> / / a second executor makes sure the onMemtableFlushes get called in the right order , <nl> @ @ - 754 , 8 + 764 , 17 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public Future < ? > forceFlush ( ) <nl> { <nl> - if ( memtable . isClean ( ) ) <nl> + / / during index build , 2ary index memtables can be dirty even if parent is not . if so , <nl> + / / we want flushLargestMemtables to flush the 2ary index ones too . <nl> + boolean clean = true ; <nl> + for ( ColumnFamilyStore cfs : Iterables . concat ( Collections . singleton ( this ) , getIndexColumnFamilyStores ( ) ) ) <nl> + clean & = cfs . memtable . isClean ( ) ; <nl> + <nl> + if ( clean ) <nl> + { <nl> + logger . debug ( " forceFlush requested but everything is clean " ) ; <nl> return null ; <nl> + } <nl> <nl> return maybeSwitchMemtable ( memtable , true ) ; <nl> } <nl> @ @ - 1937 , 6 + 1956 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return indexedColumns . get ( column ) ; <nl> } <nl> <nl> + public Collection < ColumnFamilyStore > getIndexColumnFamilyStores ( ) <nl> + { <nl> + return indexedColumns . values ( ) ; <nl> + } <nl> + <nl> public ColumnFamily newIndexedColumnFamily ( ByteBuffer column ) <nl> { <nl> return ColumnFamily . create ( indexedColumns . get ( column ) . metadata ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 14c2e25 . . aba9850 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import javax . management . ObjectName ; <nl> <nl> import com . google . common . base . Charsets ; <nl> import com . google . common . collect . HashMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Multimap ; <nl> <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> @ @ - 2195 , 14 + 2196 , 28 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> ColumnFamilyStore largestByThroughput = null ; <nl> for ( ColumnFamilyStore cfs : ColumnFamilyStore . all ( ) ) <nl> { <nl> - if ( largestByOps = = null | | cfs . getMemtableColumnsCount ( ) > largestByOps . getMemtableColumnsCount ( ) ) <nl> + long ops = 0 ; <nl> + long throughput = 0 ; <nl> + for ( ColumnFamilyStore subordinate : Iterables . concat ( Collections . singleton ( cfs ) , cfs . getIndexColumnFamilyStores ( ) ) ) <nl> + { <nl> + ops + = subordinate . getMemtableColumnsCount ( ) ; <nl> + throughput = subordinate . getMemtableThroughputInMB ( ) ; <nl> + } <nl> + <nl> + if ( ops > 0 & & ( largestByOps = = null | | ops > largestByOps . getMemtableColumnsCount ( ) ) ) <nl> + { <nl> + logger _ . debug ( ops + " total ops in " + cfs ) ; <nl> largestByOps = cfs ; <nl> - if ( largestByThroughput = = null | | cfs . getMemtableThroughputInMB ( ) > largestByThroughput . getMemtableThroughputInMB ( ) ) <nl> + } <nl> + if ( throughput > 0 & & ( largestByThroughput = = null | | throughput > largestByThroughput . getMemtableThroughputInMB ( ) ) ) <nl> + { <nl> + logger _ . debug ( throughput + " total throughput in " + cfs ) ; <nl> largestByThroughput = cfs ; <nl> + } <nl> } <nl> if ( largestByOps = = null ) <nl> { <nl> - logger _ . error ( " Unable to reduce heap usage since there are no column families defined " ) ; <nl> + logger _ . info ( " Unable to reduce heap usage since there are no dirty column families " ) ; <nl> return ; <nl> } <nl>

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / Columns . java b / src / java / org / apache / cassandra / db / Columns . java 
 index 0b29830 . . f217fd7 100644 
 - - - a / src / java / org / apache / cassandra / db / Columns . java 
 + + + b / src / java / org / apache / cassandra / db / Columns . java 
 @ @ - 484 , 13 + 484 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > 
 public Columns deserializeSubset ( Columns superset , DataInputPlus in ) throws IOException 
 { 
 long encoded = in . readUnsignedVInt ( ) ; 
 - if ( encoded = = - 1L ) 
 + if ( encoded = = 0L ) 
 { 
 - return deserializeLargeSubset ( in , superset ) ; 
 + return superset ; 
 } 
 - else if ( encoded = = 0L ) 
 + else if ( superset . columnCount ( ) > = 64 ) 
 { 
 - return superset ; 
 + return deserializeLargeSubset ( in , superset , ( int ) encoded ) ; 
 } 
 else 
 { 
 @ @ - 540 , 7 + 540 , 6 @ @ public class Columns implements Iterable < ColumnDefinition > 
 private void serializeLargeSubset ( Columns columns , int columnCount , Columns superset , int supersetCount , DataOutputPlus out ) throws IOException 
 { 
 / / write flag indicating we ' re in lengthy mode 
 - out . writeUnsignedVInt ( - 1L ) ; 
 out . writeUnsignedVInt ( supersetCount - columnCount ) ; 
 BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; 
 if ( columnCount < supersetCount / 2 ) 
 @ @ - 571 , 10 + 570 , 9 @ @ public class Columns implements Iterable < ColumnDefinition > 
 } 
 
 @ DontInline 
 - private Columns deserializeLargeSubset ( DataInputPlus in , Columns superset ) throws IOException 
 + private Columns deserializeLargeSubset ( DataInputPlus in , Columns superset , int delta ) throws IOException 
 { 
 int supersetCount = superset . columnCount ( ) ; 
 - int delta = ( int ) in . readUnsignedVInt ( ) ; 
 int columnCount = supersetCount - delta ; 
 
 BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; 
 @ @ - 614 , 7 + 612 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 private int serializeLargeSubsetSize ( Columns columns , int columnCount , Columns superset , int supersetCount ) 
 { 
 / / write flag indicating we ' re in lengthy mode 
 - int size = TypeSizes . sizeofUnsignedVInt ( - 1L ) + TypeSizes . sizeofUnsignedVInt ( supersetCount - columnCount ) ; 
 + int size = TypeSizes . sizeofUnsignedVInt ( supersetCount - columnCount ) ; 
 BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; 
 if ( columnCount < supersetCount / 2 ) 
 {

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 44ca6d5 . . 75dcf58 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import javax . management . ObjectName ; 
 
 import com . google . common . collect . Iterables ; 
 import org . apache . commons . collections . IteratorUtils ; 
 + import org . apache . commons . lang . StringUtils ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 334 , 7 + 335 , 6 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 public void run ( ) 
 { 
 - logger . info ( " Creating index { } . { } " , table , indexedCfMetadata . cfName ) ; 
 try 
 { 
 forceBlockingFlush ( ) ; 
 @ @ - 348 , 7 + 348 , 6 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 throw new AssertionError ( e ) ; 
 } 
 buildSecondaryIndexes ( getSSTables ( ) , FBUtilities . singleton ( info . name ) ) ; 
 - logger . info ( " Index { } complete " , indexedCfMetadata . cfName ) ; 
 SystemTable . setIndexBuilt ( table . name , indexedCfMetadata . cfName ) ; 
 } 
 } ; 
 @ @ - 357 , 7 + 356 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public void buildSecondaryIndexes ( Collection < SSTableReader > sstables , SortedSet < ByteBuffer > columns ) 
 { 
 - logger . debug ( " Submitting index build to compactionmanager " ) ; 
 + logger . info ( String . format ( " Submitting index build of % s for data in % s " , 
 + metadata . comparator . getString ( columns ) , StringUtils . join ( sstables , " , " ) ) ) ; 
 Table . IndexBuilder builder = table . createIndexBuilder ( this , columns , new ReducingKeyIterator ( sstables ) ) ; 
 Future future = CompactionManager . instance . submitIndexBuild ( this , builder ) ; 
 try 
 @ @ - 374 , 6 + 374 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 throw new RuntimeException ( e ) ; 
 } 
 + logger . info ( " Index build of " + metadata . comparator . getString ( columns ) + " complete " ) ; 
 } 
 
 / / called when dropping or renaming a CF . Performs mbean housekeeping and invalidates CFS to other operations . 
 @ @ - 684 , 26 + 685 , 31 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 try 
 { 
 if ( oldMemtable . isFrozen ( ) ) 
 + { 
 + logger . debug ( " memtable is already frozen ; another thread must be flushing it " ) ; 
 return null ; 
 + } 
 
 boolean isDropped = isIndex ( ) 
 ? DatabaseDescriptor . getCFMetaData ( table . name , getParentColumnfamily ( ) ) = = null 
 : DatabaseDescriptor . getCFMetaData ( metadata . cfId ) = = null ; 
 if ( isDropped ) 
 - return null ; / / column family was dropped . no point in flushing . 
 + { 
 + logger . debug ( " column family was dropped ; no point in flushing " ) ; 
 + return null ; 
 + } 
 
 assert memtable = = oldMemtable ; 
 memtable . freeze ( ) ; 
 final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance . getContext ( ) : null ; 
 - logger . info ( " switching in a fresh Memtable for " + columnFamily + " at " + ctx ) ; 
 
 / / submit the memtable for any indexed sub - cfses , and our own . 
 List < ColumnFamilyStore > icc = new ArrayList < ColumnFamilyStore > ( indexedColumns . size ( ) ) ; 
 - icc . add ( this ) ; 
 - for ( ColumnFamilyStore indexCfs : indexedColumns . values ( ) ) 
 + / / don ' t assume that this . memtable is dirty ; forceFlush can bring us here during index build even if it is not 
 + for ( ColumnFamilyStore cfs : Iterables . concat ( Collections . singleton ( this ) , indexedColumns . values ( ) ) ) 
 { 
 - if ( ! indexCfs . memtable . isClean ( ) ) 
 - icc . add ( indexCfs ) ; 
 + if ( ! cfs . memtable . isClean ( ) ) 
 + icc . add ( cfs ) ; 
 } 
 final CountDownLatch latch = new CountDownLatch ( icc . size ( ) ) ; 
 for ( ColumnFamilyStore cfs : icc ) 
 @ @ - 711 , 6 + 717 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 submitFlush ( cfs . memtable , latch ) ; 
 cfs . memtable = new Memtable ( cfs ) ; 
 } 
 + / / we marked our memtable as frozen as part of the concurrency control , 
 + / / so even if there was nothing to flush we need to switch it out 
 + if ( ! icc . contains ( this ) ) 
 + memtable = new Memtable ( this ) ; 
 
 / / when all the memtables have been written , including for indexes , mark the flush in the commitlog header . 
 / / a second executor makes sure the onMemtableFlushes get called in the right order , 
 @ @ - 754 , 8 + 764 , 17 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public Future < ? > forceFlush ( ) 
 { 
 - if ( memtable . isClean ( ) ) 
 + / / during index build , 2ary index memtables can be dirty even if parent is not . if so , 
 + / / we want flushLargestMemtables to flush the 2ary index ones too . 
 + boolean clean = true ; 
 + for ( ColumnFamilyStore cfs : Iterables . concat ( Collections . singleton ( this ) , getIndexColumnFamilyStores ( ) ) ) 
 + clean & = cfs . memtable . isClean ( ) ; 
 + 
 + if ( clean ) 
 + { 
 + logger . debug ( " forceFlush requested but everything is clean " ) ; 
 return null ; 
 + } 
 
 return maybeSwitchMemtable ( memtable , true ) ; 
 } 
 @ @ - 1937 , 6 + 1956 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return indexedColumns . get ( column ) ; 
 } 
 
 + public Collection < ColumnFamilyStore > getIndexColumnFamilyStores ( ) 
 + { 
 + return indexedColumns . values ( ) ; 
 + } 
 + 
 public ColumnFamily newIndexedColumnFamily ( ByteBuffer column ) 
 { 
 return ColumnFamily . create ( indexedColumns . get ( column ) . metadata ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 14c2e25 . . aba9850 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import javax . management . ObjectName ; 
 
 import com . google . common . base . Charsets ; 
 import com . google . common . collect . HashMultimap ; 
 + import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Multimap ; 
 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 @ @ - 2195 , 14 + 2196 , 28 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 ColumnFamilyStore largestByThroughput = null ; 
 for ( ColumnFamilyStore cfs : ColumnFamilyStore . all ( ) ) 
 { 
 - if ( largestByOps = = null | | cfs . getMemtableColumnsCount ( ) > largestByOps . getMemtableColumnsCount ( ) ) 
 + long ops = 0 ; 
 + long throughput = 0 ; 
 + for ( ColumnFamilyStore subordinate : Iterables . concat ( Collections . singleton ( cfs ) , cfs . getIndexColumnFamilyStores ( ) ) ) 
 + { 
 + ops + = subordinate . getMemtableColumnsCount ( ) ; 
 + throughput = subordinate . getMemtableThroughputInMB ( ) ; 
 + } 
 + 
 + if ( ops > 0 & & ( largestByOps = = null | | ops > largestByOps . getMemtableColumnsCount ( ) ) ) 
 + { 
 + logger _ . debug ( ops + " total ops in " + cfs ) ; 
 largestByOps = cfs ; 
 - if ( largestByThroughput = = null | | cfs . getMemtableThroughputInMB ( ) > largestByThroughput . getMemtableThroughputInMB ( ) ) 
 + } 
 + if ( throughput > 0 & & ( largestByThroughput = = null | | throughput > largestByThroughput . getMemtableThroughputInMB ( ) ) ) 
 + { 
 + logger _ . debug ( throughput + " total throughput in " + cfs ) ; 
 largestByThroughput = cfs ; 
 + } 
 } 
 if ( largestByOps = = null ) 
 { 
 - logger _ . error ( " Unable to reduce heap usage since there are no column families defined " ) ; 
 + logger _ . info ( " Unable to reduce heap usage since there are no dirty column families " ) ; 
 return ; 
 } 

