BLEU SCORE: 0.040583489434387374

TEST MSG: Always mark sstable suspected on corruption
GENERATED MSG: single - pass streaming

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d23661d . . 1aad965 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 16 : <nl> + * Always mark sstable suspect when corrupted ( CASSANDRA - 9478 ) <nl> * Add database users and permissions to CQL3 documentation ( CASSANDRA - 7558 ) <nl> * Allow JVM _ OPTS to be passed to standalone tools ( CASSANDRA - 5969 ) <nl> * Fix bad condition in RangeTombstoneList ( CASSANDRA - 9485 ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> index 52da9bb . . 8b45005 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java <nl> @ @ - 50 , 6 + 50 , 9 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat <nl> private final boolean validateColumns ; <nl> private final String filename ; <nl> <nl> + / / Not every SSTableIdentifyIterator is attached to a sstable , so this can be null . <nl> + private final SSTableReader sstable ; <nl> + <nl> / * * <nl> * Used to iterate through the columns of a row . <nl> * @ param sstable SSTable we are reading ffrom . <nl> @ @ - 96 , 6 + 99 , 7 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat <nl> this . flag = flag ; <nl> this . validateColumns = checkData ; <nl> this . dataVersion = sstable = = null ? Descriptor . Version . CURRENT : sstable . descriptor . version ; <nl> + this . sstable = sstable ; <nl> <nl> try <nl> { <nl> @ @ - 132 , 9 + 136 , 15 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat <nl> { <nl> / / catch here b / c atomIterator is an AbstractIterator ; hasNext reads the value <nl> if ( e . getCause ( ) instanceof IOException ) <nl> + { <nl> + if ( sstable ! = null ) <nl> + sstable . markSuspect ( ) ; <nl> throw new CorruptSSTableException ( ( IOException ) e . getCause ( ) , filename ) ; <nl> + } <nl> else <nl> + { <nl> throw e ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 181 , 22 + 191 , 39 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat <nl> { <nl> ColumnFamily cf = columnFamily . cloneMeShallow ( containerFactory , false ) ; <nl> / / since we already read column count , just pass that value and continue deserialization <nl> - Iterator < OnDiskAtom > iter = cf . metadata ( ) . getOnDiskIterator ( in , columnCount , flag , expireBefore , dataVersion ) ; <nl> - while ( iter . hasNext ( ) ) <nl> - cf . addAtom ( iter . next ( ) ) ; <nl> + try <nl> + { <nl> + Iterator < OnDiskAtom > iter = cf . metadata ( ) . getOnDiskIterator ( in , columnCount , flag , expireBefore , dataVersion ) ; <nl> + while ( iter . hasNext ( ) ) <nl> + cf . addAtom ( iter . next ( ) ) ; <nl> <nl> - if ( validateColumns ) <nl> + if ( validateColumns ) <nl> + { <nl> + try <nl> + { <nl> + cf . metadata ( ) . validateColumns ( cf ) ; <nl> + } <nl> + catch ( MarshalException e ) <nl> + { <nl> + throw new RuntimeException ( " Error validating row " + key , e ) ; <nl> + } <nl> + } <nl> + return cf ; <nl> + } <nl> + catch ( IOError e ) <nl> { <nl> - try <nl> + / / catch here b / c atomIterator is an AbstractIterator ; hasNext reads the value <nl> + if ( e . getCause ( ) instanceof IOException ) <nl> { <nl> - cf . metadata ( ) . validateColumns ( cf ) ; <nl> + if ( sstable ! = null ) <nl> + sstable . markSuspect ( ) ; <nl> + throw new CorruptSSTableException ( ( IOException ) e . getCause ( ) , filename ) ; <nl> } <nl> - catch ( MarshalException e ) <nl> + else <nl> { <nl> - throw new RuntimeException ( " Error validating row " + key , e ) ; <nl> + throw e ; <nl> } <nl> } <nl> - return cf ; <nl> } <nl> <nl> public int compareTo ( SSTableIdentityIterator o ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java <nl> index e392a4b . . 08d1d66 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java <nl> @ @ - 22 , 9 + 22 , 7 @ @ package org . apache . cassandra . db . compaction ; <nl> <nl> <nl> import java . io . RandomAccessFile ; <nl> - import java . util . Collection ; <nl> - import java . util . HashSet ; <nl> - import java . util . Set ; <nl> + import java . util . * ; <nl> <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> @ @ - 41 , 6 + 39 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertNotNull ; <nl> + import static org . junit . Assert . assertTrue ; <nl> <nl> public class BlacklistingCompactionsTest extends SchemaLoader <nl> { <nl> @ @ - 121 , 7 + 120 , 14 @ @ public class BlacklistingCompactionsTest extends SchemaLoader <nl> { <nl> raf = new RandomAccessFile ( sstable . getFilename ( ) , " rw " ) ; <nl> assertNotNull ( raf ) ; <nl> - raf . write ( 0xFFFFFF ) ; <nl> + assertTrue ( raf . length ( ) > 20 ) ; <nl> + raf . seek ( new Random ( ) . nextInt ( ( int ) ( raf . length ( ) - 20 ) ) ) ; <nl> + / / We want to write something large enough that the corruption cannot get undetected <nl> + / / ( even without compression ) <nl> + byte [ ] corruption = new byte [ 20 ] ; <nl> + Arrays . fill ( corruption , ( byte ) 0xFF ) ; <nl> + raf . write ( corruption ) ; <nl> + <nl> } <nl> finally <nl> { <nl> @ @ - 155 , 6 + 161 , 6 @ @ public class BlacklistingCompactionsTest extends SchemaLoader <nl> <nl> <nl> cfs . truncateBlocking ( ) ; <nl> - assertEquals ( failures , sstablesToCorrupt ) ; <nl> + assertEquals ( sstablesToCorrupt , failures ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / utils / BytesReadTracker . java b / src / java / org / apache / cassandra / utils / BytesReadTracker . java <nl> new file mode 100644 <nl> index 0000000 . . 8e7f15c <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / BytesReadTracker . java <nl> @ @ - 0 , 0 + 1 , 167 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . io . DataInput ; <nl> + import java . io . DataInputStream ; <nl> + import java . io . IOException ; <nl> + <nl> + / * * <nl> + * This class is to track bytes read from given DataInput <nl> + * / <nl> + public class BytesReadTracker implements DataInput <nl> + { <nl> + <nl> + private long bytesRead ; <nl> + private DataInput source ; <nl> + <nl> + public BytesReadTracker ( DataInput source ) <nl> + { <nl> + this . source = source ; <nl> + } <nl> + <nl> + public long getBytesRead ( ) <nl> + { <nl> + return bytesRead ; <nl> + } <nl> + <nl> + / * * <nl> + * reset counter to 0 <nl> + * / <nl> + public void reset ( ) <nl> + { <nl> + bytesRead = 0 ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean readBoolean ( ) throws IOException <nl> + { <nl> + boolean bool = source . readBoolean ( ) ; <nl> + bytesRead + = 1 ; <nl> + return bool ; <nl> + } <nl> + <nl> + @ Override <nl> + public byte readByte ( ) throws IOException <nl> + { <nl> + byte b = source . readByte ( ) ; <nl> + bytesRead + = 1 ; <nl> + return b ; <nl> + } <nl> + <nl> + @ Override <nl> + public char readChar ( ) throws IOException <nl> + { <nl> + char c = source . readChar ( ) ; <nl> + bytesRead + = 1 ; <nl> + return c ; <nl> + } <nl> + <nl> + @ Override <nl> + public double readDouble ( ) throws IOException <nl> + { <nl> + double d = source . readDouble ( ) ; <nl> + bytesRead + = 8 ; <nl> + return d ; <nl> + } <nl> + <nl> + @ Override <nl> + public float readFloat ( ) throws IOException <nl> + { <nl> + float f = source . readFloat ( ) ; <nl> + bytesRead + = 4 ; <nl> + return f ; <nl> + } <nl> + <nl> + @ Override <nl> + public void readFully ( byte [ ] b , int off , int len ) throws IOException <nl> + { <nl> + source . readFully ( b , off , len ) ; <nl> + bytesRead + = len ; <nl> + } <nl> + <nl> + @ Override <nl> + public void readFully ( byte [ ] b ) throws IOException <nl> + { <nl> + source . readFully ( b ) ; <nl> + bytesRead + = b . length ; <nl> + } <nl> + <nl> + @ Override <nl> + public int readInt ( ) throws IOException <nl> + { <nl> + int i = source . readInt ( ) ; <nl> + bytesRead + = 4 ; <nl> + return i ; <nl> + } <nl> + <nl> + @ Override <nl> + public String readLine ( ) throws IOException <nl> + { <nl> + / / since this method is deprecated and cannot track bytes read <nl> + / / just throw exception <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long readLong ( ) throws IOException <nl> + { <nl> + long l = source . readLong ( ) ; <nl> + bytesRead + = 8 ; <nl> + return l ; <nl> + } <nl> + <nl> + @ Override <nl> + public short readShort ( ) throws IOException <nl> + { <nl> + short s = source . readShort ( ) ; <nl> + bytesRead + = 2 ; <nl> + return s ; <nl> + } <nl> + <nl> + @ Override <nl> + public String readUTF ( ) throws IOException <nl> + { <nl> + return DataInputStream . readUTF ( this ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public int readUnsignedByte ( ) throws IOException <nl> + { <nl> + int i = source . readUnsignedByte ( ) ; <nl> + bytesRead + = 1 ; <nl> + return i ; <nl> + } <nl> + <nl> + @ Override <nl> + public int readUnsignedShort ( ) throws IOException <nl> + { <nl> + int i = source . readUnsignedShort ( ) ; <nl> + bytesRead + = 2 ; <nl> + return i ; <nl> + } <nl> + <nl> + @ Override <nl> + public int skipBytes ( int n ) throws IOException <nl> + { <nl> + int skipped = source . skipBytes ( n ) ; <nl> + bytesRead + = n ; <nl> + return skipped ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d23661d . . 1aad965 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 16 : 
 + * Always mark sstable suspect when corrupted ( CASSANDRA - 9478 ) 
 * Add database users and permissions to CQL3 documentation ( CASSANDRA - 7558 ) 
 * Allow JVM _ OPTS to be passed to standalone tools ( CASSANDRA - 5969 ) 
 * Fix bad condition in RangeTombstoneList ( CASSANDRA - 9485 ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 index 52da9bb . . 8b45005 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableIdentityIterator . java 
 @ @ - 50 , 6 + 50 , 9 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat 
 private final boolean validateColumns ; 
 private final String filename ; 
 
 + / / Not every SSTableIdentifyIterator is attached to a sstable , so this can be null . 
 + private final SSTableReader sstable ; 
 + 
 / * * 
 * Used to iterate through the columns of a row . 
 * @ param sstable SSTable we are reading ffrom . 
 @ @ - 96 , 6 + 99 , 7 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat 
 this . flag = flag ; 
 this . validateColumns = checkData ; 
 this . dataVersion = sstable = = null ? Descriptor . Version . CURRENT : sstable . descriptor . version ; 
 + this . sstable = sstable ; 
 
 try 
 { 
 @ @ - 132 , 9 + 136 , 15 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat 
 { 
 / / catch here b / c atomIterator is an AbstractIterator ; hasNext reads the value 
 if ( e . getCause ( ) instanceof IOException ) 
 + { 
 + if ( sstable ! = null ) 
 + sstable . markSuspect ( ) ; 
 throw new CorruptSSTableException ( ( IOException ) e . getCause ( ) , filename ) ; 
 + } 
 else 
 + { 
 throw e ; 
 + } 
 } 
 } 
 
 @ @ - 181 , 22 + 191 , 39 @ @ public class SSTableIdentityIterator implements Comparable < SSTableIdentityIterat 
 { 
 ColumnFamily cf = columnFamily . cloneMeShallow ( containerFactory , false ) ; 
 / / since we already read column count , just pass that value and continue deserialization 
 - Iterator < OnDiskAtom > iter = cf . metadata ( ) . getOnDiskIterator ( in , columnCount , flag , expireBefore , dataVersion ) ; 
 - while ( iter . hasNext ( ) ) 
 - cf . addAtom ( iter . next ( ) ) ; 
 + try 
 + { 
 + Iterator < OnDiskAtom > iter = cf . metadata ( ) . getOnDiskIterator ( in , columnCount , flag , expireBefore , dataVersion ) ; 
 + while ( iter . hasNext ( ) ) 
 + cf . addAtom ( iter . next ( ) ) ; 
 
 - if ( validateColumns ) 
 + if ( validateColumns ) 
 + { 
 + try 
 + { 
 + cf . metadata ( ) . validateColumns ( cf ) ; 
 + } 
 + catch ( MarshalException e ) 
 + { 
 + throw new RuntimeException ( " Error validating row " + key , e ) ; 
 + } 
 + } 
 + return cf ; 
 + } 
 + catch ( IOError e ) 
 { 
 - try 
 + / / catch here b / c atomIterator is an AbstractIterator ; hasNext reads the value 
 + if ( e . getCause ( ) instanceof IOException ) 
 { 
 - cf . metadata ( ) . validateColumns ( cf ) ; 
 + if ( sstable ! = null ) 
 + sstable . markSuspect ( ) ; 
 + throw new CorruptSSTableException ( ( IOException ) e . getCause ( ) , filename ) ; 
 } 
 - catch ( MarshalException e ) 
 + else 
 { 
 - throw new RuntimeException ( " Error validating row " + key , e ) ; 
 + throw e ; 
 } 
 } 
 - return cf ; 
 } 
 
 public int compareTo ( SSTableIdentityIterator o ) 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java 
 index e392a4b . . 08d1d66 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / BlacklistingCompactionsTest . java 
 @ @ - 22 , 9 + 22 , 7 @ @ package org . apache . cassandra . db . compaction ; 
 
 
 import java . io . RandomAccessFile ; 
 - import java . util . Collection ; 
 - import java . util . HashSet ; 
 - import java . util . Set ; 
 + import java . util . * ; 
 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 @ @ - 41 , 6 + 39 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertNotNull ; 
 + import static org . junit . Assert . assertTrue ; 
 
 public class BlacklistingCompactionsTest extends SchemaLoader 
 { 
 @ @ - 121 , 7 + 120 , 14 @ @ public class BlacklistingCompactionsTest extends SchemaLoader 
 { 
 raf = new RandomAccessFile ( sstable . getFilename ( ) , " rw " ) ; 
 assertNotNull ( raf ) ; 
 - raf . write ( 0xFFFFFF ) ; 
 + assertTrue ( raf . length ( ) > 20 ) ; 
 + raf . seek ( new Random ( ) . nextInt ( ( int ) ( raf . length ( ) - 20 ) ) ) ; 
 + / / We want to write something large enough that the corruption cannot get undetected 
 + / / ( even without compression ) 
 + byte [ ] corruption = new byte [ 20 ] ; 
 + Arrays . fill ( corruption , ( byte ) 0xFF ) ; 
 + raf . write ( corruption ) ; 
 + 
 } 
 finally 
 { 
 @ @ - 155 , 6 + 161 , 6 @ @ public class BlacklistingCompactionsTest extends SchemaLoader 
 
 
 cfs . truncateBlocking ( ) ; 
 - assertEquals ( failures , sstablesToCorrupt ) ; 
 + assertEquals ( sstablesToCorrupt , failures ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / utils / BytesReadTracker . java b / src / java / org / apache / cassandra / utils / BytesReadTracker . java 
 new file mode 100644 
 index 0000000 . . 8e7f15c 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / BytesReadTracker . java 
 @ @ - 0 , 0 + 1 , 167 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . io . DataInput ; 
 + import java . io . DataInputStream ; 
 + import java . io . IOException ; 
 + 
 + / * * 
 + * This class is to track bytes read from given DataInput 
 + * / 
 + public class BytesReadTracker implements DataInput 
 + { 
 + 
 + private long bytesRead ; 
 + private DataInput source ; 
 + 
 + public BytesReadTracker ( DataInput source ) 
 + { 
 + this . source = source ; 
 + } 
 + 
 + public long getBytesRead ( ) 
 + { 
 + return bytesRead ; 
 + } 
 + 
 + / * * 
 + * reset counter to 0 
 + * / 
 + public void reset ( ) 
 + { 
 + bytesRead = 0 ; 
 + } 
 + 
 + @ Override 
 + public boolean readBoolean ( ) throws IOException 
 + { 
 + boolean bool = source . readBoolean ( ) ; 
 + bytesRead + = 1 ; 
 + return bool ; 
 + } 
 + 
 + @ Override 
 + public byte readByte ( ) throws IOException 
 + { 
 + byte b = source . readByte ( ) ; 
 + bytesRead + = 1 ; 
 + return b ; 
 + } 
 + 
 + @ Override 
 + public char readChar ( ) throws IOException 
 + { 
 + char c = source . readChar ( ) ; 
 + bytesRead + = 1 ; 
 + return c ; 
 + } 
 + 
 + @ Override 
 + public double readDouble ( ) throws IOException 
 + { 
 + double d = source . readDouble ( ) ; 
 + bytesRead + = 8 ; 
 + return d ; 
 + } 
 + 
 + @ Override 
 + public float readFloat ( ) throws IOException 
 + { 
 + float f = source . readFloat ( ) ; 
 + bytesRead + = 4 ; 
 + return f ; 
 + } 
 + 
 + @ Override 
 + public void readFully ( byte [ ] b , int off , int len ) throws IOException 
 + { 
 + source . readFully ( b , off , len ) ; 
 + bytesRead + = len ; 
 + } 
 + 
 + @ Override 
 + public void readFully ( byte [ ] b ) throws IOException 
 + { 
 + source . readFully ( b ) ; 
 + bytesRead + = b . length ; 
 + } 
 + 
 + @ Override 
 + public int readInt ( ) throws IOException 
 + { 
 + int i = source . readInt ( ) ; 
 + bytesRead + = 4 ; 
 + return i ; 
 + } 
 + 
 + @ Override 
 + public String readLine ( ) throws IOException 
 + { 
 + / / since this method is deprecated and cannot track bytes read 
 + / / just throw exception 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public long readLong ( ) throws IOException 
 + { 
 + long l = source . readLong ( ) ; 
 + bytesRead + = 8 ; 
 + return l ; 
 + } 
 + 
 + @ Override 
 + public short readShort ( ) throws IOException 
 + { 
 + short s = source . readShort ( ) ; 
 + bytesRead + = 2 ; 
 + return s ; 
 + } 
 + 
 + @ Override 
 + public String readUTF ( ) throws IOException 
 + { 
 + return DataInputStream . readUTF ( this ) ; 
 + } 
 + 
 + @ Override 
 + public int readUnsignedByte ( ) throws IOException 
 + { 
 + int i = source . readUnsignedByte ( ) ; 
 + bytesRead + = 1 ; 
 + return i ; 
 + } 
 + 
 + @ Override 
 + public int readUnsignedShort ( ) throws IOException 
 + { 
 + int i = source . readUnsignedShort ( ) ; 
 + bytesRead + = 2 ; 
 + return i ; 
 + } 
 + 
 + @ Override 
 + public int skipBytes ( int n ) throws IOException 
 + { 
 + int skipped = source . skipBytes ( n ) ; 
 + bytesRead + = n ; 
 + return skipped ; 
 + } 
 + }
