BLEU SCORE: 0.026279617104084448

TEST MSG: Avoid recycling CL segments until all writes have been flushed for all keyspaces in segment
GENERATED MSG: Workaround for netty issue causing corrupted data to come off the wire

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java <nl> index e1a7e39 . . 05b3aa5 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java <nl> @ @ - 21 , 9 + 21 , 11 @ @ import java . io . File ; <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . HashSet ; <nl> import java . util . LinkedHashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> + import java . util . Set ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . BlockingQueue ; <nl> import java . util . concurrent . Callable ; <nl> @ @ - 292 , 8 + 294 , 21 @ @ public class CommitLogSegmentManager <nl> CommitLogSegment last = segmentsToRecycle . get ( segmentsToRecycle . size ( ) - 1 ) ; <nl> advanceAllocatingFrom ( last ) ; <nl> <nl> + / / wait for the commit log modifications <nl> last . waitForModifications ( ) ; <nl> <nl> + / / make sure the writes have materialized inside of the memtables by waiting for all outstanding writes <nl> + / / on the relevant keyspaces to complete <nl> + Set < Keyspace > keyspaces = new HashSet < > ( ) ; <nl> + for ( UUID cfId : last . getDirtyCFIDs ( ) ) <nl> + { <nl> + ColumnFamilyStore cfs = Schema . instance . getColumnFamilyStoreInstance ( cfId ) ; <nl> + if ( cfs ! = null ) <nl> + keyspaces . add ( cfs . keyspace ) ; <nl> + } <nl> + for ( Keyspace keyspace : keyspaces ) <nl> + keyspace . writeOrder . awaitNewBarrier ( ) ; <nl> + <nl> / / flush and wait for all CFs that are dirty in segments up - to and including ' last ' <nl> Future < ? > future = flushDataFrom ( segmentsToRecycle , true ) ; <nl> try <nl> diff - - git a / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java b / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java <nl> new file mode 100644 <nl> index 0000000 . . a0bacea <nl> - - - / dev / null <nl> + + + b / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java <nl> @ @ - 0 , 0 + 1 , 91 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import org . junit . After ; <nl> + import org . junit . Test ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + <nl> + import static org . apache . cassandra . cql3 . QueryProcessor . executeOnceInternal ; <nl> + <nl> + / * * <nl> + * Base class for CQL tests . <nl> + * / <nl> + public class DropKeyspaceCommitLogRecycleTest <nl> + { <nl> + protected static final Logger logger = LoggerFactory . getLogger ( DropKeyspaceCommitLogRecycleTest . class ) ; <nl> + <nl> + private static final String KEYSPACE = " cql _ test _ keyspace " ; <nl> + private static final String KEYSPACE2 = " cql _ test _ keyspace2 " ; <nl> + <nl> + static <nl> + { <nl> + / / Once per - JVM is enough <nl> + SchemaLoader . prepareServer ( ) ; <nl> + } <nl> + <nl> + private void create ( boolean both ) <nl> + { <nl> + executeOnceInternal ( String . format ( " CREATE KEYSPACE % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , KEYSPACE ) ) ; <nl> + executeOnceInternal ( String . format ( " CREATE TABLE % s . test ( k1 int , k2 int , v int , PRIMARY KEY ( k1 , k2 ) ) " , KEYSPACE ) ) ; <nl> + <nl> + if ( both ) <nl> + { <nl> + executeOnceInternal ( String . format ( " CREATE KEYSPACE % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , KEYSPACE2 ) ) ; <nl> + executeOnceInternal ( String . format ( " CREATE TABLE % s . test ( k1 int , k2 int , v int , PRIMARY KEY ( k1 , k2 ) ) " , KEYSPACE2 ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void insert ( ) <nl> + { <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 0 , 0 , 0 ) " , KEYSPACE ) ) ; <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 1 , 1 , 1 ) " , KEYSPACE ) ) ; <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 2 , 2 , 2 ) " , KEYSPACE ) ) ; <nl> + <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 0 , 0 , 0 ) " , KEYSPACE2 ) ) ; <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 1 , 1 , 1 ) " , KEYSPACE2 ) ) ; <nl> + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 2 , 2 , 2 ) " , KEYSPACE2 ) ) ; <nl> + } <nl> + <nl> + private void drop ( boolean both ) <nl> + { <nl> + executeOnceInternal ( String . format ( " DROP KEYSPACE IF EXISTS % s " , KEYSPACE ) ) ; <nl> + if ( both ) <nl> + executeOnceInternal ( String . format ( " DROP KEYSPACE IF EXISTS % s " , KEYSPACE2 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRecycle ( ) <nl> + { <nl> + for ( int i = 0 ; i < 1000 ; i + + ) <nl> + { <nl> + create ( i = = 0 ) ; <nl> + insert ( ) ; <nl> + drop ( false ) ; <nl> + } <nl> + } <nl> + <nl> + @ After <nl> + public void afterTest ( ) throws Throwable <nl> + { <nl> + drop ( true ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java 
 index e1a7e39 . . 05b3aa5 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegmentManager . java 
 @ @ - 21 , 9 + 21 , 11 @ @ import java . io . File ; 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . HashSet ; 
 import java . util . LinkedHashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 + import java . util . Set ; 
 import java . util . UUID ; 
 import java . util . concurrent . BlockingQueue ; 
 import java . util . concurrent . Callable ; 
 @ @ - 292 , 8 + 294 , 21 @ @ public class CommitLogSegmentManager 
 CommitLogSegment last = segmentsToRecycle . get ( segmentsToRecycle . size ( ) - 1 ) ; 
 advanceAllocatingFrom ( last ) ; 
 
 + / / wait for the commit log modifications 
 last . waitForModifications ( ) ; 
 
 + / / make sure the writes have materialized inside of the memtables by waiting for all outstanding writes 
 + / / on the relevant keyspaces to complete 
 + Set < Keyspace > keyspaces = new HashSet < > ( ) ; 
 + for ( UUID cfId : last . getDirtyCFIDs ( ) ) 
 + { 
 + ColumnFamilyStore cfs = Schema . instance . getColumnFamilyStoreInstance ( cfId ) ; 
 + if ( cfs ! = null ) 
 + keyspaces . add ( cfs . keyspace ) ; 
 + } 
 + for ( Keyspace keyspace : keyspaces ) 
 + keyspace . writeOrder . awaitNewBarrier ( ) ; 
 + 
 / / flush and wait for all CFs that are dirty in segments up - to and including ' last ' 
 Future < ? > future = flushDataFrom ( segmentsToRecycle , true ) ; 
 try 
 diff - - git a / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java b / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java 
 new file mode 100644 
 index 0000000 . . a0bacea 
 - - - / dev / null 
 + + + b / test / long / org / apache / cassandra / cql3 / DropKeyspaceCommitLogRecycleTest . java 
 @ @ - 0 , 0 + 1 , 91 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import org . junit . After ; 
 + import org . junit . Test ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + 
 + import static org . apache . cassandra . cql3 . QueryProcessor . executeOnceInternal ; 
 + 
 + / * * 
 + * Base class for CQL tests . 
 + * / 
 + public class DropKeyspaceCommitLogRecycleTest 
 + { 
 + protected static final Logger logger = LoggerFactory . getLogger ( DropKeyspaceCommitLogRecycleTest . class ) ; 
 + 
 + private static final String KEYSPACE = " cql _ test _ keyspace " ; 
 + private static final String KEYSPACE2 = " cql _ test _ keyspace2 " ; 
 + 
 + static 
 + { 
 + / / Once per - JVM is enough 
 + SchemaLoader . prepareServer ( ) ; 
 + } 
 + 
 + private void create ( boolean both ) 
 + { 
 + executeOnceInternal ( String . format ( " CREATE KEYSPACE % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , KEYSPACE ) ) ; 
 + executeOnceInternal ( String . format ( " CREATE TABLE % s . test ( k1 int , k2 int , v int , PRIMARY KEY ( k1 , k2 ) ) " , KEYSPACE ) ) ; 
 + 
 + if ( both ) 
 + { 
 + executeOnceInternal ( String . format ( " CREATE KEYSPACE % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " , KEYSPACE2 ) ) ; 
 + executeOnceInternal ( String . format ( " CREATE TABLE % s . test ( k1 int , k2 int , v int , PRIMARY KEY ( k1 , k2 ) ) " , KEYSPACE2 ) ) ; 
 + } 
 + } 
 + 
 + private void insert ( ) 
 + { 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 0 , 0 , 0 ) " , KEYSPACE ) ) ; 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 1 , 1 , 1 ) " , KEYSPACE ) ) ; 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 2 , 2 , 2 ) " , KEYSPACE ) ) ; 
 + 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 0 , 0 , 0 ) " , KEYSPACE2 ) ) ; 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 1 , 1 , 1 ) " , KEYSPACE2 ) ) ; 
 + executeOnceInternal ( String . format ( " INSERT INTO % s . test ( k1 , k2 , v ) VALUES ( 2 , 2 , 2 ) " , KEYSPACE2 ) ) ; 
 + } 
 + 
 + private void drop ( boolean both ) 
 + { 
 + executeOnceInternal ( String . format ( " DROP KEYSPACE IF EXISTS % s " , KEYSPACE ) ) ; 
 + if ( both ) 
 + executeOnceInternal ( String . format ( " DROP KEYSPACE IF EXISTS % s " , KEYSPACE2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testRecycle ( ) 
 + { 
 + for ( int i = 0 ; i < 1000 ; i + + ) 
 + { 
 + create ( i = = 0 ) ; 
 + insert ( ) ; 
 + drop ( false ) ; 
 + } 
 + } 
 + 
 + @ After 
 + public void afterTest ( ) throws Throwable 
 + { 
 + drop ( true ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
