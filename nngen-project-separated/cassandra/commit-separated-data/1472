BLEU SCORE: 0.040583489434387374

TEST MSG: Remove repair snapshot leftover on startup
GENERATED MSG: add listsnapshots command to nodetool

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c6774c2 . . 26ee348 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 4 , 6 + 4 , 7 @ @ <nl> * Fix clientutil jar and tests ( CASSANDRA - 9760 ) <nl> * ( cqlsh ) Allow the SSL protocol version to be specified through the <nl> config file or environment variables ( CASSANDRA - 9544 ) <nl> + * Remove repair snapshot leftover on startup ( CASSANDRA - 7357 ) <nl> Merged from 2 . 0 : <nl> * Complete CASSANDRA - 8448 fix ( CASSANDRA - 9519 ) <nl> * Don ' t include auth credentials in debug log ( CASSANDRA - 9682 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index aec5f35 . . 20e74dc 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db ; <nl> import java . io . * ; <nl> import java . lang . management . ManagementFactory ; <nl> import java . nio . ByteBuffer ; <nl> + import java . nio . file . Files ; <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> @ @ - 35 , 7 + 36 , 6 @ @ import com . google . common . collect . * ; <nl> import com . google . common . util . concurrent . * ; <nl> <nl> import org . apache . cassandra . io . FSWriteError ; <nl> - import org . apache . cassandra . utils . memory . MemtablePool ; <nl> import org . json . simple . * ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 501 , 6 + 501 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> Directories directories = new Directories ( metadata ) ; <nl> <nl> + / / clear ephemeral snapshots that were not properly cleared last session ( CASSANDRA - 7357 ) <nl> + clearEphemeralSnapshots ( directories ) ; <nl> + <nl> / / remove any left - behind SSTables from failed / stalled streaming <nl> FileFilter filter = new FileFilter ( ) <nl> { <nl> @ @ - 2249 , 10 + 2252 , 13 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> public void snapshotWithoutFlush ( String snapshotName ) <nl> { <nl> - snapshotWithoutFlush ( snapshotName , null ) ; <nl> + snapshotWithoutFlush ( snapshotName , null , false ) ; <nl> } <nl> <nl> - public void snapshotWithoutFlush ( String snapshotName , Predicate < SSTableReader > predicate ) <nl> + / * * <nl> + * @ param ephemeral If this flag is set to true , the snapshot will be cleaned during next startup <nl> + * / <nl> + public void snapshotWithoutFlush ( String snapshotName , Predicate < SSTableReader > predicate , boolean ephemeral ) <nl> { <nl> for ( ColumnFamilyStore cfs : concatWithIndexes ( ) ) <nl> { <nl> @ @ - 2267 , 6 + 2273 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> File snapshotDirectory = Directories . getSnapshotDirectory ( ssTable . descriptor , snapshotName ) ; <nl> ssTable . createLinks ( snapshotDirectory . getPath ( ) ) ; / / hard links <nl> filesJSONArr . add ( ssTable . descriptor . relativeFilenameFor ( Component . DATA ) ) ; <nl> + <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Snapshot for { } keyspace data file { } created in { } " , keyspace , ssTable . getFilename ( ) , snapshotDirectory ) ; <nl> } <nl> @ @ - 2274 , 6 + 2281 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> writeSnapshotManifest ( filesJSONArr , snapshotName ) ; <nl> } <nl> } <nl> + if ( ephemeral ) <nl> + createEphemeralSnapshotMarkerFile ( snapshotName ) ; <nl> } <nl> <nl> private void writeSnapshotManifest ( final JSONArray filesJSONArr , final String snapshotName ) <nl> @ @ - 2296 , 6 + 2305 , 36 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> + private void createEphemeralSnapshotMarkerFile ( final String snapshot ) <nl> + { <nl> + final File ephemeralSnapshotMarker = directories . getNewEphemeralSnapshotMarkerFile ( snapshot ) ; <nl> + <nl> + try <nl> + { <nl> + if ( ! ephemeralSnapshotMarker . getParentFile ( ) . exists ( ) ) <nl> + ephemeralSnapshotMarker . getParentFile ( ) . mkdirs ( ) ; <nl> + <nl> + Files . createFile ( ephemeralSnapshotMarker . toPath ( ) ) ; <nl> + logger . debug ( " Created ephemeral snapshot marker file on { } . " , ephemeralSnapshotMarker . getAbsolutePath ( ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger . warn ( String . format ( " Could not create marker file % s for ephemeral snapshot % s . " + <nl> + " In case there is a failure in the operation that created " + <nl> + " this snapshot , you may need to clean it manually afterwards . " , <nl> + ephemeralSnapshotMarker . getAbsolutePath ( ) , snapshot ) , e ) ; <nl> + } <nl> + } <nl> + <nl> + protected static void clearEphemeralSnapshots ( Directories directories ) <nl> + { <nl> + for ( String ephemeralSnapshot : directories . listEphemeralSnapshots ( ) ) <nl> + { <nl> + logger . debug ( " Clearing ephemeral snapshot { } leftover from previous session . " , ephemeralSnapshot ) ; <nl> + Directories . clearSnapshot ( ephemeralSnapshot , directories . getCFDirectories ( ) ) ; <nl> + } <nl> + } <nl> + <nl> public Refs < SSTableReader > getSnapshotSSTableReader ( String tag ) throws IOException <nl> { <nl> Map < Integer , SSTableReader > active = new HashMap < > ( ) ; <nl> @ @ - 2341 , 13 + 2380 , 16 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * / <nl> public void snapshot ( String snapshotName ) <nl> { <nl> - snapshot ( snapshotName , null ) ; <nl> + snapshot ( snapshotName , null , false ) ; <nl> } <nl> <nl> - public void snapshot ( String snapshotName , Predicate < SSTableReader > predicate ) <nl> + / * * <nl> + * @ param ephemeral If this flag is set to true , the snapshot will be cleaned up during next startup <nl> + * / <nl> + public void snapshot ( String snapshotName , Predicate < SSTableReader > predicate , boolean ephemeral ) <nl> { <nl> forceBlockingFlush ( ) ; <nl> - snapshotWithoutFlush ( snapshotName , predicate ) ; <nl> + snapshotWithoutFlush ( snapshotName , predicate , ephemeral ) ; <nl> } <nl> <nl> public boolean snapshotExists ( String snapshotName ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java <nl> index 2e0b60c . . 810c336 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Directories . java <nl> + + + b / src / java / org / apache / cassandra / db / Directories . java <nl> @ @ - 376 , 6 + 376 , 17 @ @ public class Directories <nl> return new File ( getDirectoryForNewSSTables ( ) , join ( SNAPSHOT _ SUBDIR , snapshotName , " manifest . json " ) ) ; <nl> } <nl> <nl> + public File getNewEphemeralSnapshotMarkerFile ( String snapshotName ) <nl> + { <nl> + File snapshotDir = new File ( getWriteableLocationAsFile ( 1L ) , join ( SNAPSHOT _ SUBDIR , snapshotName ) ) ; <nl> + return getEphemeralSnapshotMarkerFile ( snapshotDir ) ; <nl> + } <nl> + <nl> + private static File getEphemeralSnapshotMarkerFile ( File snapshotDirectory ) <nl> + { <nl> + return new File ( snapshotDirectory , " ephemeral . snapshot " ) ; <nl> + } <nl> + <nl> public static File getBackupsDirectory ( Descriptor desc ) <nl> { <nl> return getOrCreate ( desc . directory , BACKUPS _ SUBDIR ) ; <nl> @ @ - 563 , 34 + 574 , 55 @ @ public class Directories <nl> public Map < String , Pair < Long , Long > > getSnapshotDetails ( ) <nl> { <nl> final Map < String , Pair < Long , Long > > snapshotSpaceMap = new HashMap < > ( ) ; <nl> + for ( File snapshot : listSnapshots ( ) ) <nl> + { <nl> + final long sizeOnDisk = FileUtils . folderSize ( snapshot ) ; <nl> + final long trueSize = getTrueAllocatedSizeIn ( snapshot ) ; <nl> + Pair < Long , Long > spaceUsed = snapshotSpaceMap . get ( snapshot . getName ( ) ) ; <nl> + if ( spaceUsed = = null ) <nl> + spaceUsed = Pair . create ( sizeOnDisk , trueSize ) ; <nl> + else <nl> + spaceUsed = Pair . create ( spaceUsed . left + sizeOnDisk , spaceUsed . right + trueSize ) ; <nl> + snapshotSpaceMap . put ( snapshot . getName ( ) , spaceUsed ) ; <nl> + } <nl> + return snapshotSpaceMap ; <nl> + } <nl> + <nl> + <nl> + public List < String > listEphemeralSnapshots ( ) <nl> + { <nl> + final List < String > ephemeralSnapshots = new LinkedList < > ( ) ; <nl> + for ( File snapshot : listSnapshots ( ) ) <nl> + { <nl> + if ( getEphemeralSnapshotMarkerFile ( snapshot ) . exists ( ) ) <nl> + ephemeralSnapshots . add ( snapshot . getName ( ) ) ; <nl> + } <nl> + return ephemeralSnapshots ; <nl> + } <nl> + <nl> + private List < File > listSnapshots ( ) <nl> + { <nl> + final List < File > snapshots = new LinkedList < > ( ) ; <nl> for ( final File dir : dataPaths ) <nl> { <nl> final File snapshotDir = new File ( dir , SNAPSHOT _ SUBDIR ) ; <nl> if ( snapshotDir . exists ( ) & & snapshotDir . isDirectory ( ) ) <nl> { <nl> - final File [ ] snapshots = snapshotDir . listFiles ( ) ; <nl> - if ( snapshots ! = null ) <nl> + final File [ ] snapshotDirs = snapshotDir . listFiles ( ) ; <nl> + if ( snapshotDirs ! = null ) <nl> { <nl> - for ( final File snapshot : snapshots ) <nl> + for ( final File snapshot : snapshotDirs ) <nl> { <nl> if ( snapshot . isDirectory ( ) ) <nl> - { <nl> - final long sizeOnDisk = FileUtils . folderSize ( snapshot ) ; <nl> - final long trueSize = getTrueAllocatedSizeIn ( snapshot ) ; <nl> - Pair < Long , Long > spaceUsed = snapshotSpaceMap . get ( snapshot . getName ( ) ) ; <nl> - if ( spaceUsed = = null ) <nl> - spaceUsed = Pair . create ( sizeOnDisk , trueSize ) ; <nl> - else <nl> - spaceUsed = Pair . create ( spaceUsed . left + sizeOnDisk , spaceUsed . right + trueSize ) ; <nl> - snapshotSpaceMap . put ( snapshot . getName ( ) , spaceUsed ) ; <nl> - } <nl> + snapshots . add ( snapshot ) ; <nl> } <nl> } <nl> } <nl> } <nl> <nl> - return snapshotSpaceMap ; <nl> + return snapshots ; <nl> } <nl> + <nl> public boolean snapshotExists ( String snapshotName ) <nl> { <nl> for ( File dir : dataPaths ) <nl> @ @ - 611 , 8 + 643 , 7 @ @ public class Directories <nl> File snapshotDir = new File ( dir , join ( SNAPSHOT _ SUBDIR , tag ) ) ; <nl> if ( snapshotDir . exists ( ) ) <nl> { <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " Removing snapshot directory { } " , snapshotDir ) ; <nl> + logger . debug ( " Removing snapshot directory { } " , snapshotDir ) ; <nl> FileUtils . deleteRecursive ( snapshotDir ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> index 872978e . . fd4ac28 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> @ @ - 87 , 7 + 87 , 7 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > <nl> ! ( sstable . partitioner instanceof LocalPartitioner ) & & / / exclude SSTables from 2i <nl> new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( Collections . singleton ( repairingRange ) ) ; <nl> } <nl> - } ) ; <nl> + } , true ) ; / / ephemeral snapshot , if repair fails , it will be cleaned next startup <nl> <nl> logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ; <nl> MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) , id , message . from ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 949ea4c . . 2c141a6 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 49 , 7 + 49 , 6 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> - import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . io . FSError ; <nl> import org . apache . cassandra . io . sstable . CorruptSSTableException ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> index 5faab78 . . 35814f0 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> @ @ - 1441 , 6 + 1441 , 48 @ @ public class ColumnFamilyStoreTest extends SchemaLoader <nl> findRowGetSlicesAndAssertColsFound ( cfs , multiRangeReverseWithCounting , " a " , " colI " , " colD " , " colC " ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testClearEphemeralSnapshots ( ) throws Throwable <nl> + { <nl> + Mutation rm ; <nl> + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace3 " ) . getColumnFamilyStore ( " Indexed1 " ) ; <nl> + for ( int i = 0 ; i < 100 ; i + + ) <nl> + { <nl> + rm = new Mutation ( " Keyspace3 " , ByteBufferUtil . bytes ( " key " + i ) ) ; <nl> + rm . add ( " Indexed1 " , cellname ( " birthdate " ) , ByteBufferUtil . bytes ( 34L ) , 0 ) ; <nl> + rm . add ( " Indexed1 " , cellname ( " notbirthdate " ) , ByteBufferUtil . bytes ( ( long ) ( i % 2 ) ) , 0 ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + } <nl> + <nl> + / / cleanup any previous test gargbage <nl> + cfs . clearSnapshot ( " " ) ; <nl> + <nl> + Cell [ ] cols = new Cell [ 5 ] ; <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + cols [ i ] = column ( " c " + i , " value " , 1 ) ; <nl> + <nl> + putColsStandard ( cfs , Util . dk ( " a " ) , cols [ 0 ] , cols [ 1 ] , cols [ 2 ] , cols [ 3 ] , cols [ 4 ] ) ; <nl> + putColsStandard ( cfs , Util . dk ( " b " ) , cols [ 0 ] , cols [ 1 ] ) ; <nl> + putColsStandard ( cfs , Util . dk ( " c " ) , cols [ 0 ] , cols [ 1 ] , cols [ 2 ] , cols [ 3 ] ) ; <nl> + <nl> + cfs . snapshot ( " nonEphemeralSnapshot " , null , false ) ; <nl> + cfs . snapshot ( " ephemeralSnapshot " , null , true ) ; <nl> + <nl> + Map < String , Pair < Long , Long > > snapshotDetails = cfs . getSnapshotDetails ( ) ; <nl> + assertEquals ( 2 , snapshotDetails . size ( ) ) ; <nl> + assertTrue ( snapshotDetails . containsKey ( " ephemeralSnapshot " ) ) ; <nl> + assertTrue ( snapshotDetails . containsKey ( " nonEphemeralSnapshot " ) ) ; <nl> + <nl> + ColumnFamilyStore . clearEphemeralSnapshots ( cfs . directories ) ; <nl> + <nl> + snapshotDetails = cfs . getSnapshotDetails ( ) ; <nl> + assertEquals ( 1 , snapshotDetails . size ( ) ) ; <nl> + assertTrue ( snapshotDetails . containsKey ( " nonEphemeralSnapshot " ) ) ; <nl> + <nl> + / / test cleanup <nl> + cfs . clearSnapshot ( " " ) ; <nl> + } <nl> + <nl> @ SuppressWarnings ( " unchecked " ) <nl> @ Test <nl> public void testMultiRangeSomeEmptyIndexed ( ) throws Throwable
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c6774c2 . . 26ee348 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 4 , 6 + 4 , 7 @ @ 
 * Fix clientutil jar and tests ( CASSANDRA - 9760 ) 
 * ( cqlsh ) Allow the SSL protocol version to be specified through the 
 config file or environment variables ( CASSANDRA - 9544 ) 
 + * Remove repair snapshot leftover on startup ( CASSANDRA - 7357 ) 
 Merged from 2 . 0 : 
 * Complete CASSANDRA - 8448 fix ( CASSANDRA - 9519 ) 
 * Don ' t include auth credentials in debug log ( CASSANDRA - 9682 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index aec5f35 . . 20e74dc 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db ; 
 import java . io . * ; 
 import java . lang . management . ManagementFactory ; 
 import java . nio . ByteBuffer ; 
 + import java . nio . file . Files ; 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 @ @ - 35 , 7 + 36 , 6 @ @ import com . google . common . collect . * ; 
 import com . google . common . util . concurrent . * ; 
 
 import org . apache . cassandra . io . FSWriteError ; 
 - import org . apache . cassandra . utils . memory . MemtablePool ; 
 import org . json . simple . * ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 501 , 6 + 501 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 Directories directories = new Directories ( metadata ) ; 
 
 + / / clear ephemeral snapshots that were not properly cleared last session ( CASSANDRA - 7357 ) 
 + clearEphemeralSnapshots ( directories ) ; 
 + 
 / / remove any left - behind SSTables from failed / stalled streaming 
 FileFilter filter = new FileFilter ( ) 
 { 
 @ @ - 2249 , 10 + 2252 , 13 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 public void snapshotWithoutFlush ( String snapshotName ) 
 { 
 - snapshotWithoutFlush ( snapshotName , null ) ; 
 + snapshotWithoutFlush ( snapshotName , null , false ) ; 
 } 
 
 - public void snapshotWithoutFlush ( String snapshotName , Predicate < SSTableReader > predicate ) 
 + / * * 
 + * @ param ephemeral If this flag is set to true , the snapshot will be cleaned during next startup 
 + * / 
 + public void snapshotWithoutFlush ( String snapshotName , Predicate < SSTableReader > predicate , boolean ephemeral ) 
 { 
 for ( ColumnFamilyStore cfs : concatWithIndexes ( ) ) 
 { 
 @ @ - 2267 , 6 + 2273 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 File snapshotDirectory = Directories . getSnapshotDirectory ( ssTable . descriptor , snapshotName ) ; 
 ssTable . createLinks ( snapshotDirectory . getPath ( ) ) ; / / hard links 
 filesJSONArr . add ( ssTable . descriptor . relativeFilenameFor ( Component . DATA ) ) ; 
 + 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Snapshot for { } keyspace data file { } created in { } " , keyspace , ssTable . getFilename ( ) , snapshotDirectory ) ; 
 } 
 @ @ - 2274 , 6 + 2281 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 writeSnapshotManifest ( filesJSONArr , snapshotName ) ; 
 } 
 } 
 + if ( ephemeral ) 
 + createEphemeralSnapshotMarkerFile ( snapshotName ) ; 
 } 
 
 private void writeSnapshotManifest ( final JSONArray filesJSONArr , final String snapshotName ) 
 @ @ - 2296 , 6 + 2305 , 36 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 + private void createEphemeralSnapshotMarkerFile ( final String snapshot ) 
 + { 
 + final File ephemeralSnapshotMarker = directories . getNewEphemeralSnapshotMarkerFile ( snapshot ) ; 
 + 
 + try 
 + { 
 + if ( ! ephemeralSnapshotMarker . getParentFile ( ) . exists ( ) ) 
 + ephemeralSnapshotMarker . getParentFile ( ) . mkdirs ( ) ; 
 + 
 + Files . createFile ( ephemeralSnapshotMarker . toPath ( ) ) ; 
 + logger . debug ( " Created ephemeral snapshot marker file on { } . " , ephemeralSnapshotMarker . getAbsolutePath ( ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger . warn ( String . format ( " Could not create marker file % s for ephemeral snapshot % s . " + 
 + " In case there is a failure in the operation that created " + 
 + " this snapshot , you may need to clean it manually afterwards . " , 
 + ephemeralSnapshotMarker . getAbsolutePath ( ) , snapshot ) , e ) ; 
 + } 
 + } 
 + 
 + protected static void clearEphemeralSnapshots ( Directories directories ) 
 + { 
 + for ( String ephemeralSnapshot : directories . listEphemeralSnapshots ( ) ) 
 + { 
 + logger . debug ( " Clearing ephemeral snapshot { } leftover from previous session . " , ephemeralSnapshot ) ; 
 + Directories . clearSnapshot ( ephemeralSnapshot , directories . getCFDirectories ( ) ) ; 
 + } 
 + } 
 + 
 public Refs < SSTableReader > getSnapshotSSTableReader ( String tag ) throws IOException 
 { 
 Map < Integer , SSTableReader > active = new HashMap < > ( ) ; 
 @ @ - 2341 , 13 + 2380 , 16 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * / 
 public void snapshot ( String snapshotName ) 
 { 
 - snapshot ( snapshotName , null ) ; 
 + snapshot ( snapshotName , null , false ) ; 
 } 
 
 - public void snapshot ( String snapshotName , Predicate < SSTableReader > predicate ) 
 + / * * 
 + * @ param ephemeral If this flag is set to true , the snapshot will be cleaned up during next startup 
 + * / 
 + public void snapshot ( String snapshotName , Predicate < SSTableReader > predicate , boolean ephemeral ) 
 { 
 forceBlockingFlush ( ) ; 
 - snapshotWithoutFlush ( snapshotName , predicate ) ; 
 + snapshotWithoutFlush ( snapshotName , predicate , ephemeral ) ; 
 } 
 
 public boolean snapshotExists ( String snapshotName ) 
 diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java 
 index 2e0b60c . . 810c336 100644 
 - - - a / src / java / org / apache / cassandra / db / Directories . java 
 + + + b / src / java / org / apache / cassandra / db / Directories . java 
 @ @ - 376 , 6 + 376 , 17 @ @ public class Directories 
 return new File ( getDirectoryForNewSSTables ( ) , join ( SNAPSHOT _ SUBDIR , snapshotName , " manifest . json " ) ) ; 
 } 
 
 + public File getNewEphemeralSnapshotMarkerFile ( String snapshotName ) 
 + { 
 + File snapshotDir = new File ( getWriteableLocationAsFile ( 1L ) , join ( SNAPSHOT _ SUBDIR , snapshotName ) ) ; 
 + return getEphemeralSnapshotMarkerFile ( snapshotDir ) ; 
 + } 
 + 
 + private static File getEphemeralSnapshotMarkerFile ( File snapshotDirectory ) 
 + { 
 + return new File ( snapshotDirectory , " ephemeral . snapshot " ) ; 
 + } 
 + 
 public static File getBackupsDirectory ( Descriptor desc ) 
 { 
 return getOrCreate ( desc . directory , BACKUPS _ SUBDIR ) ; 
 @ @ - 563 , 34 + 574 , 55 @ @ public class Directories 
 public Map < String , Pair < Long , Long > > getSnapshotDetails ( ) 
 { 
 final Map < String , Pair < Long , Long > > snapshotSpaceMap = new HashMap < > ( ) ; 
 + for ( File snapshot : listSnapshots ( ) ) 
 + { 
 + final long sizeOnDisk = FileUtils . folderSize ( snapshot ) ; 
 + final long trueSize = getTrueAllocatedSizeIn ( snapshot ) ; 
 + Pair < Long , Long > spaceUsed = snapshotSpaceMap . get ( snapshot . getName ( ) ) ; 
 + if ( spaceUsed = = null ) 
 + spaceUsed = Pair . create ( sizeOnDisk , trueSize ) ; 
 + else 
 + spaceUsed = Pair . create ( spaceUsed . left + sizeOnDisk , spaceUsed . right + trueSize ) ; 
 + snapshotSpaceMap . put ( snapshot . getName ( ) , spaceUsed ) ; 
 + } 
 + return snapshotSpaceMap ; 
 + } 
 + 
 + 
 + public List < String > listEphemeralSnapshots ( ) 
 + { 
 + final List < String > ephemeralSnapshots = new LinkedList < > ( ) ; 
 + for ( File snapshot : listSnapshots ( ) ) 
 + { 
 + if ( getEphemeralSnapshotMarkerFile ( snapshot ) . exists ( ) ) 
 + ephemeralSnapshots . add ( snapshot . getName ( ) ) ; 
 + } 
 + return ephemeralSnapshots ; 
 + } 
 + 
 + private List < File > listSnapshots ( ) 
 + { 
 + final List < File > snapshots = new LinkedList < > ( ) ; 
 for ( final File dir : dataPaths ) 
 { 
 final File snapshotDir = new File ( dir , SNAPSHOT _ SUBDIR ) ; 
 if ( snapshotDir . exists ( ) & & snapshotDir . isDirectory ( ) ) 
 { 
 - final File [ ] snapshots = snapshotDir . listFiles ( ) ; 
 - if ( snapshots ! = null ) 
 + final File [ ] snapshotDirs = snapshotDir . listFiles ( ) ; 
 + if ( snapshotDirs ! = null ) 
 { 
 - for ( final File snapshot : snapshots ) 
 + for ( final File snapshot : snapshotDirs ) 
 { 
 if ( snapshot . isDirectory ( ) ) 
 - { 
 - final long sizeOnDisk = FileUtils . folderSize ( snapshot ) ; 
 - final long trueSize = getTrueAllocatedSizeIn ( snapshot ) ; 
 - Pair < Long , Long > spaceUsed = snapshotSpaceMap . get ( snapshot . getName ( ) ) ; 
 - if ( spaceUsed = = null ) 
 - spaceUsed = Pair . create ( sizeOnDisk , trueSize ) ; 
 - else 
 - spaceUsed = Pair . create ( spaceUsed . left + sizeOnDisk , spaceUsed . right + trueSize ) ; 
 - snapshotSpaceMap . put ( snapshot . getName ( ) , spaceUsed ) ; 
 - } 
 + snapshots . add ( snapshot ) ; 
 } 
 } 
 } 
 } 
 
 - return snapshotSpaceMap ; 
 + return snapshots ; 
 } 
 + 
 public boolean snapshotExists ( String snapshotName ) 
 { 
 for ( File dir : dataPaths ) 
 @ @ - 611 , 8 + 643 , 7 @ @ public class Directories 
 File snapshotDir = new File ( dir , join ( SNAPSHOT _ SUBDIR , tag ) ) ; 
 if ( snapshotDir . exists ( ) ) 
 { 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " Removing snapshot directory { } " , snapshotDir ) ; 
 + logger . debug ( " Removing snapshot directory { } " , snapshotDir ) ; 
 FileUtils . deleteRecursive ( snapshotDir ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 index 872978e . . fd4ac28 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 @ @ - 87 , 7 + 87 , 7 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > 
 ! ( sstable . partitioner instanceof LocalPartitioner ) & & / / exclude SSTables from 2i 
 new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( Collections . singleton ( repairingRange ) ) ; 
 } 
 - } ) ; 
 + } , true ) ; / / ephemeral snapshot , if repair fails , it will be cleaned next startup 
 
 logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ; 
 MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) , id , message . from ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 949ea4c . . 2c141a6 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 49 , 7 + 49 , 6 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 - import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . io . FSError ; 
 import org . apache . cassandra . io . sstable . CorruptSSTableException ; 
 diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 index 5faab78 . . 35814f0 100644 
 - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 @ @ - 1441 , 6 + 1441 , 48 @ @ public class ColumnFamilyStoreTest extends SchemaLoader 
 findRowGetSlicesAndAssertColsFound ( cfs , multiRangeReverseWithCounting , " a " , " colI " , " colD " , " colC " ) ; 
 } 
 
 + @ Test 
 + public void testClearEphemeralSnapshots ( ) throws Throwable 
 + { 
 + Mutation rm ; 
 + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace3 " ) . getColumnFamilyStore ( " Indexed1 " ) ; 
 + for ( int i = 0 ; i < 100 ; i + + ) 
 + { 
 + rm = new Mutation ( " Keyspace3 " , ByteBufferUtil . bytes ( " key " + i ) ) ; 
 + rm . add ( " Indexed1 " , cellname ( " birthdate " ) , ByteBufferUtil . bytes ( 34L ) , 0 ) ; 
 + rm . add ( " Indexed1 " , cellname ( " notbirthdate " ) , ByteBufferUtil . bytes ( ( long ) ( i % 2 ) ) , 0 ) ; 
 + rm . applyUnsafe ( ) ; 
 + } 
 + 
 + / / cleanup any previous test gargbage 
 + cfs . clearSnapshot ( " " ) ; 
 + 
 + Cell [ ] cols = new Cell [ 5 ] ; 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + cols [ i ] = column ( " c " + i , " value " , 1 ) ; 
 + 
 + putColsStandard ( cfs , Util . dk ( " a " ) , cols [ 0 ] , cols [ 1 ] , cols [ 2 ] , cols [ 3 ] , cols [ 4 ] ) ; 
 + putColsStandard ( cfs , Util . dk ( " b " ) , cols [ 0 ] , cols [ 1 ] ) ; 
 + putColsStandard ( cfs , Util . dk ( " c " ) , cols [ 0 ] , cols [ 1 ] , cols [ 2 ] , cols [ 3 ] ) ; 
 + 
 + cfs . snapshot ( " nonEphemeralSnapshot " , null , false ) ; 
 + cfs . snapshot ( " ephemeralSnapshot " , null , true ) ; 
 + 
 + Map < String , Pair < Long , Long > > snapshotDetails = cfs . getSnapshotDetails ( ) ; 
 + assertEquals ( 2 , snapshotDetails . size ( ) ) ; 
 + assertTrue ( snapshotDetails . containsKey ( " ephemeralSnapshot " ) ) ; 
 + assertTrue ( snapshotDetails . containsKey ( " nonEphemeralSnapshot " ) ) ; 
 + 
 + ColumnFamilyStore . clearEphemeralSnapshots ( cfs . directories ) ; 
 + 
 + snapshotDetails = cfs . getSnapshotDetails ( ) ; 
 + assertEquals ( 1 , snapshotDetails . size ( ) ) ; 
 + assertTrue ( snapshotDetails . containsKey ( " nonEphemeralSnapshot " ) ) ; 
 + 
 + / / test cleanup 
 + cfs . clearSnapshot ( " " ) ; 
 + } 
 + 
 @ SuppressWarnings ( " unchecked " ) 
 @ Test 
 public void testMultiRangeSomeEmptyIndexed ( ) throws Throwable

NEAREST DIFF:
ELIMINATEDSENTENCE
