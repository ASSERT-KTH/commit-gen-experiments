BLEU SCORE: 0.018738883683389617

TEST MSG: Invalidate row / counter cache after stream receive task is completed
GENERATED MSG: Allow skipping file syncs during tests

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fa2017a . . 92244a0 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 12 <nl> + * Invalidate cache after stream receive task is completed ( CASSANDRA - 10341 ) <nl> * Reject counter writes in CQLSSTableWriter ( CASSANDRA - 10258 ) <nl> * Remove superfluous COUNTER _ MUTATION stage mapping ( CASSANDRA - 10605 ) <nl> * Improve json2sstable error reporting on nonexistent columns ( CASSANDRA - 10401 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 906e18c . . 54f6fff 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 2505 , 6 + 2505 , 37 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> CacheService . instance . invalidateCounterCacheForCf ( metadata . ksAndCFName ) ; <nl> } <nl> <nl> + public int invalidateRowCache ( Collection < Bounds < Token > > boundsToInvalidate ) <nl> + { <nl> + int invalidatedKeys = 0 ; <nl> + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) <nl> + { <nl> + DecoratedKey dk = partitioner . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; <nl> + if ( key . ksAndCFName . equals ( metadata . ksAndCFName ) & & Bounds . isInBounds ( dk . getToken ( ) , boundsToInvalidate ) ) <nl> + { <nl> + invalidateCachedRow ( dk ) ; <nl> + invalidatedKeys + + ; <nl> + } <nl> + } <nl> + <nl> + return invalidatedKeys ; <nl> + } <nl> + <nl> + public int invalidateCounterCache ( Collection < Bounds < Token > > boundsToInvalidate ) <nl> + { <nl> + int invalidatedKeys = 0 ; <nl> + for ( CounterCacheKey key : CacheService . instance . counterCache . getKeySet ( ) ) <nl> + { <nl> + DecoratedKey dk = partitioner . decorateKey ( ByteBuffer . wrap ( key . partitionKey ) ) ; <nl> + if ( key . ksAndCFName . equals ( metadata . ksAndCFName ) & & Bounds . isInBounds ( dk . getToken ( ) , boundsToInvalidate ) ) <nl> + { <nl> + CacheService . instance . counterCache . remove ( key ) ; <nl> + invalidatedKeys + + ; <nl> + } <nl> + } <nl> + return invalidatedKeys ; <nl> + } <nl> + <nl> / * * <nl> * @ return true if @ param key is contained in the row cache <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> index f8ff163 . . 35d0832 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> @ @ - 189 , 11 + 189 , 6 @ @ public class CompactionController implements AutoCloseable <nl> return min ; <nl> } <nl> <nl> - public void invalidateCachedRow ( DecoratedKey key ) <nl> - { <nl> - cfs . invalidateCachedRow ( key ) ; <nl> - } <nl> - <nl> public void close ( ) <nl> { <nl> overlappingSSTables . release ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java <nl> index 42eea77 . . 5ffde42 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Bounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / Bounds . java <nl> @ @ - 17 , 8 + 17 , 17 @ @ <nl> * / <nl> package org . apache . cassandra . dht ; <nl> <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . Comparator ; <nl> import java . util . List ; <nl> + import java . util . Set ; <nl> + <nl> + import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . PeekingIterator ; <nl> + import com . google . common . collect . Sets ; <nl> <nl> import org . apache . cassandra . db . RowPosition ; <nl> import org . apache . cassandra . service . StorageService ; <nl> @ @ - 108 , 6 + 117 , 20 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > <nl> return " ] " ; <nl> } <nl> <nl> + public static < T extends RingPosition < T > > boolean isInBounds ( T token , Iterable < Bounds < T > > bounds ) <nl> + { <nl> + assert bounds ! = null ; <nl> + <nl> + for ( Bounds < T > bound : bounds ) <nl> + { <nl> + if ( bound . contains ( token ) ) <nl> + { <nl> + return true ; <nl> + } <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> / * * <nl> * Compute a bounds of keys corresponding to a given bounds of token . <nl> * / <nl> @ @ - 132 , 4 + 155 , 43 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > <nl> { <nl> return new Bounds < T > ( left , newRight ) ; <nl> } <nl> + <nl> + / * * <nl> + * Retrieves non - overlapping bounds for the list of input bounds <nl> + * <nl> + * Assume we have the following bounds <nl> + * ( brackets representing left / right bound ) : <nl> + * [ ] [ ] [ ] [ ] <nl> + * [ ] [ ] <nl> + * This method will return the following bounds : <nl> + * [ ] [ ] <nl> + * <nl> + * @ param bounds unsorted bounds to find overlaps <nl> + * @ return the non - overlapping bounds <nl> + * / <nl> + public static < T extends RingPosition < T > > Set < Bounds < T > > getNonOverlappingBounds ( Iterable < Bounds < T > > bounds ) <nl> + { <nl> + ArrayList < Bounds < T > > sortedBounds = Lists . newArrayList ( bounds ) ; <nl> + Collections . sort ( sortedBounds , new Comparator < Bounds < T > > ( ) <nl> + { <nl> + public int compare ( Bounds < T > o1 , Bounds < T > o2 ) <nl> + { <nl> + return o1 . left . compareTo ( o2 . left ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + Set < Bounds < T > > nonOverlappingBounds = Sets . newHashSet ( ) ; <nl> + <nl> + PeekingIterator < Bounds < T > > it = Iterators . peekingIterator ( sortedBounds . iterator ( ) ) ; <nl> + while ( it . hasNext ( ) ) <nl> + { <nl> + Bounds < T > beginBound = it . next ( ) ; <nl> + Bounds < T > endBound = beginBound ; <nl> + while ( it . hasNext ( ) & & endBound . right . compareTo ( it . peek ( ) . left ) > = 0 ) <nl> + endBound = it . next ( ) ; <nl> + nonOverlappingBounds . add ( new Bounds < > ( beginBound . left , endBound . right ) ) ; <nl> + } <nl> + <nl> + return nonOverlappingBounds ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> index 82492a8 . . af5d1d3 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java <nl> @ @ - 32 , 7 + 32 , 6 @ @ import org . apache . cassandra . db . DecoratedKey ; <nl> import org . apache . cassandra . db . RowIndexEntry ; <nl> import org . apache . cassandra . db . compaction . AbstractCompactedRow ; <nl> import org . apache . cassandra . utils . CLibrary ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> import static org . apache . cassandra . utils . Throwables . merge ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamReader . java b / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> index 5389a80 . . 18013fe 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamReader . java <nl> @ @ - 166 , 6 + 166 , 5 @ @ public class StreamReader <nl> { <nl> DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( ByteBufferUtil . readWithShortLength ( in ) ) ; <nl> writer . appendFromStream ( key , cfs . metadata , in , inputVersion ) ; <nl> - cfs . invalidateCachedRow ( key ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> index da2d7d6 . . 738c93c 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> @ @ - 23 , 14 + 23 , 20 @ @ import java . io . IOException ; <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> + import java . util . Set ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . ThreadPoolExecutor ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . sstable . SSTableWriter ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> @ @ - 47 , 6 + 53 , 8 @ @ public class StreamReceiveTask extends StreamTask <nl> FBUtilities . getAvailableProcessors ( ) , <nl> 60 , TimeUnit . SECONDS ) ; <nl> <nl> + private static final Logger logger = LoggerFactory . getLogger ( StreamReceiveTask . class ) ; <nl> + <nl> / / number of files to receive <nl> private final int totalFiles ; <nl> / / total size of files to receive <nl> @ @ - 79 , 6 + 87 , 7 @ @ public class StreamReceiveTask extends StreamTask <nl> assert cfId . equals ( sstable . metadata . cfId ) ; <nl> <nl> sstables . add ( sstable ) ; <nl> + <nl> if ( sstables . size ( ) = = totalFiles ) <nl> { <nl> done = true ; <nl> @ @ - 134 , 6 + 143 , 33 @ @ public class StreamReceiveTask extends StreamTask <nl> / / add sstables and build secondary indexes <nl> cfs . addSSTables ( readers ) ; <nl> cfs . indexManager . maybeBuildSecondaryIndexes ( readers , cfs . indexManager . allIndexesNames ( ) ) ; <nl> + <nl> + / / invalidate row and counter cache <nl> + if ( cfs . isRowCacheEnabled ( ) | | cfs . metadata . isCounter ( ) ) <nl> + { <nl> + List < Bounds < Token > > boundsToInvalidate = new ArrayList < > ( readers . size ( ) ) ; <nl> + for ( SSTableReader sstable : readers ) <nl> + boundsToInvalidate . add ( new Bounds < Token > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ) ; <nl> + Set < Bounds < Token > > nonOverlappingBounds = Bounds . getNonOverlappingBounds ( boundsToInvalidate ) ; <nl> + <nl> + if ( cfs . isRowCacheEnabled ( ) ) <nl> + { <nl> + int invalidatedKeys = cfs . invalidateRowCache ( nonOverlappingBounds ) ; <nl> + if ( invalidatedKeys > 0 ) <nl> + logger . debug ( " [ Stream # { } ] Invalidated { } row cache entries on table { } . { } after stream " + <nl> + " receive task completed . " , task . session . planId ( ) , invalidatedKeys , <nl> + cfs . keyspace . getName ( ) , cfs . getColumnFamilyName ( ) ) ; <nl> + } <nl> + <nl> + if ( cfs . metadata . isCounter ( ) ) <nl> + { <nl> + int invalidatedKeys = cfs . invalidateCounterCache ( nonOverlappingBounds ) ; <nl> + if ( invalidatedKeys > 0 ) <nl> + logger . debug ( " [ Stream # { } ] Invalidated { } counter cache entries on table { } . { } after stream " + <nl> + " receive task completed . " , task . session . planId ( ) , invalidatedKeys , <nl> + cfs . keyspace . getName ( ) , cfs . getColumnFamilyName ( ) ) ; <nl> + } <nl> + } <nl> } <nl> <nl> task . session . taskCompleted ( task ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / CounterCacheTest . java b / test / unit / org / apache / cassandra / db / CounterCacheTest . java <nl> index 20e067c . . 542358d 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / CounterCacheTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / CounterCacheTest . java <nl> @ @ - 17 , 6 + 17 , 7 @ @ <nl> * / <nl> package org . apache . cassandra . db ; <nl> <nl> + import java . util . Collections ; <nl> import java . util . concurrent . ExecutionException ; <nl> <nl> import org . junit . AfterClass ; <nl> @ @ - 24 , 6 + 25 , 8 @ @ import org . junit . Test ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . exceptions . WriteTimeoutException ; <nl> import org . apache . cassandra . service . CacheService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> @ @ - 71 , 6 + 74 , 48 @ @ public class CounterCacheTest extends SchemaLoader <nl> } <nl> <nl> @ Test <nl> + public void testCounterCacheInvalidate ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KS ) . getColumnFamilyStore ( CF ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> + CacheService . instance . invalidateCounterCache ( ) ; <nl> + <nl> + assertEquals ( 0 , CacheService . instance . counterCache . size ( ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; <nl> + <nl> + cfs . putCachedCounter ( bytes ( 1 ) , cellname ( 1 ) , ClockAndCount . create ( 1L , 1L ) ) ; <nl> + cfs . putCachedCounter ( bytes ( 1 ) , cellname ( 2 ) , ClockAndCount . create ( 1L , 2L ) ) ; <nl> + cfs . putCachedCounter ( bytes ( 2 ) , cellname ( 1 ) , ClockAndCount . create ( 2L , 1L ) ) ; <nl> + cfs . putCachedCounter ( bytes ( 2 ) , cellname ( 2 ) , ClockAndCount . create ( 2L , 2L ) ) ; <nl> + cfs . putCachedCounter ( bytes ( 3 ) , cellname ( 1 ) , ClockAndCount . create ( 3L , 1L ) ) ; <nl> + cfs . putCachedCounter ( bytes ( 3 ) , cellname ( 2 ) , ClockAndCount . create ( 3L , 2L ) ) ; <nl> + <nl> + assertEquals ( 6 , CacheService . instance . counterCache . size ( ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 1L , 1L ) , cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 1L , 2L ) , cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 2L , 1L ) , cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 2L , 2L ) , cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 3L , 1L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 3L , 2L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; <nl> + <nl> + cfs . invalidateCounterCache ( Collections . singleton ( new Bounds < Token > ( cfs . partitioner . decorateKey ( bytes ( 1 ) ) . getToken ( ) , <nl> + cfs . partitioner . decorateKey ( bytes ( 2 ) ) . getToken ( ) ) ) ) ; <nl> + <nl> + assertEquals ( 2 , CacheService . instance . counterCache . size ( ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; <nl> + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 3L , 1L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; <nl> + assertEquals ( ClockAndCount . create ( 3L , 2L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testSaveLoad ( ) throws ExecutionException , InterruptedException , WriteTimeoutException <nl> { <nl> ColumnFamilyStore cfs = Keyspace . open ( KS ) . getColumnFamilyStore ( CF ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / RowCacheTest . java b / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> index 6d4554d . . 719c771 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RowCacheTest . java <nl> @ @ - 20 , 8 + 20 , 12 @ @ package org . apache . cassandra . db ; <nl> <nl> import java . net . InetAddress ; <nl> import java . nio . ByteBuffer ; <nl> + import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> + import java . util . Iterator ; <nl> + import java . util . TreeSet ; <nl> <nl> + import com . google . common . collect . Lists ; <nl> import org . junit . AfterClass ; <nl> import org . junit . Test ; <nl> <nl> @ @ - 32 , 13 + 36 , 15 @ @ import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . composites . * ; <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . filter . QueryFilter ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> import org . apache . cassandra . dht . BytesToken ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . service . CacheService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> import static org . junit . Assert . assertEquals ; <nl> - import static org . junit . Assert . assertTrue ; <nl> <nl> public class RowCacheTest extends SchemaLoader <nl> { <nl> @ @ - 152 , 6 + 158 , 51 @ @ public class RowCacheTest extends SchemaLoader <nl> } <nl> <nl> @ Test <nl> + public void testInvalidateRowCache ( ) throws Exception <nl> + { <nl> + StorageService . instance . initServer ( 0 ) ; <nl> + CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; <nl> + rowCacheLoad ( 100 , Integer . MAX _ VALUE , 1000 ) ; <nl> + <nl> + ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; <nl> + assertEquals ( CacheService . instance . rowCache . getKeySet ( ) . size ( ) , 100 ) ; <nl> + <nl> + / / construct 5 ranges of 20 elements each <nl> + ArrayList < Bounds < Token > > subranges = getBounds ( 20 ) ; <nl> + <nl> + / / invalidate 3 of the 5 ranges <nl> + ArrayList < Bounds < Token > > boundsToInvalidate = Lists . newArrayList ( subranges . get ( 0 ) , subranges . get ( 2 ) , subranges . get ( 4 ) ) ; <nl> + int invalidatedKeys = store . invalidateRowCache ( boundsToInvalidate ) ; <nl> + assertEquals ( 60 , invalidatedKeys ) ; <nl> + <nl> + / / now there should be only 40 cached entries left <nl> + assertEquals ( 40 , CacheService . instance . rowCache . getKeySet ( ) . size ( ) ) ; <nl> + CacheService . instance . setRowCacheCapacityInMB ( 0 ) ; <nl> + } <nl> + <nl> + private ArrayList < Bounds < Token > > getBounds ( int nElements ) <nl> + { <nl> + ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; <nl> + TreeSet < DecoratedKey > orderedKeys = new TreeSet < > ( ) ; <nl> + <nl> + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) <nl> + orderedKeys . add ( store . partitioner . decorateKey ( ByteBuffer . wrap ( key . key ) ) ) ; <nl> + <nl> + ArrayList < Bounds < Token > > boundsToInvalidate = new ArrayList < > ( ) ; <nl> + Iterator < DecoratedKey > iterator = orderedKeys . iterator ( ) ; <nl> + <nl> + while ( iterator . hasNext ( ) ) <nl> + { <nl> + Token startRange = iterator . next ( ) . getToken ( ) ; <nl> + for ( int i = 0 ; i < nElements - 2 ; i + + ) <nl> + iterator . next ( ) ; <nl> + Token endRange = iterator . next ( ) . getToken ( ) ; <nl> + boundsToInvalidate . add ( new Bounds < > ( startRange , endRange ) ) ; <nl> + } <nl> + return boundsToInvalidate ; <nl> + } <nl> + <nl> + @ Test <nl> public void testRowCachePartialLoad ( ) throws Exception <nl> { <nl> CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; <nl> @ @ - 220 , 9 + 271 , 9 @ @ public class RowCacheTest extends SchemaLoader <nl> <nl> / / populate row cache , we should not get a row cache hit ; <nl> cachedStore . getColumnFamily ( QueryFilter . getSliceFilter ( dk , cf , <nl> - Composites . EMPTY , <nl> - Composites . EMPTY , <nl> - false , 10 , System . currentTimeMillis ( ) ) ) ; <nl> + Composites . EMPTY , <nl> + Composites . EMPTY , <nl> + false , 10 , System . currentTimeMillis ( ) ) ) ; <nl> assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . count ( ) ) ; <nl> <nl> / / do another query , limit is 20 , which is < 100 that we cache , we should get a hit and it should be in range <nl> @ @ - 272 , 8 + 323 , 6 @ @ public class RowCacheTest extends SchemaLoader <nl> { <nl> CompactionManager . instance . disableAutoCompaction ( ) ; <nl> <nl> - ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; <nl> - <nl> / / empty the cache <nl> CacheService . instance . invalidateRowCache ( ) ; <nl> assert CacheService . instance . rowCache . size ( ) = = 0 ; <nl> diff - - git a / test / unit / org / apache / cassandra / dht / BoundsTest . java b / test / unit / org / apache / cassandra / dht / BoundsTest . java <nl> new file mode 100644 <nl> index 0000000 . . 527b498 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / dht / BoundsTest . java <nl> @ @ - 0 , 0 + 1 , 61 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . dht ; <nl> + <nl> + import java . util . LinkedList ; <nl> + import java . util . List ; <nl> + import java . util . Set ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class BoundsTest <nl> + { <nl> + <nl> + private Bounds < Token > bounds ( long left , long right ) <nl> + { <nl> + return new Bounds < Token > ( new LongToken ( left ) , new LongToken ( right ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + / * * <nl> + * [ 0 , 1 ] , [ 0 , 5 ] , [ 1 , 8 ] , [ 4 , 10 ] = [ 0 , 10 ] <nl> + * [ 15 , 19 ] [ 19 , 20 ] = [ 15 , 20 ] <nl> + * [ 21 , 22 ] = [ 21 , 22 ] <nl> + * / <nl> + public void testGetNonOverlappingBounds ( ) <nl> + { <nl> + List < Bounds < Token > > bounds = new LinkedList < > ( ) ; <nl> + bounds . add ( bounds ( 19 , 20 ) ) ; <nl> + bounds . add ( bounds ( 0 , 1 ) ) ; <nl> + bounds . add ( bounds ( 4 , 10 ) ) ; <nl> + bounds . add ( bounds ( 15 , 19 ) ) ; <nl> + bounds . add ( bounds ( 0 , 5 ) ) ; <nl> + bounds . add ( bounds ( 21 , 22 ) ) ; <nl> + bounds . add ( bounds ( 1 , 8 ) ) ; <nl> + <nl> + Set < Bounds < Token > > nonOverlappingBounds = Bounds . getNonOverlappingBounds ( bounds ) ; <nl> + assertEquals ( 3 , nonOverlappingBounds . size ( ) ) ; <nl> + assertTrue ( nonOverlappingBounds . contains ( bounds ( 0 , 10 ) ) ) ; <nl> + assertTrue ( nonOverlappingBounds . contains ( bounds ( 15 , 20 ) ) ) ; <nl> + assertTrue ( nonOverlappingBounds . contains ( bounds ( 21 , 22 ) ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fa2017a . . 92244a0 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 12 
 + * Invalidate cache after stream receive task is completed ( CASSANDRA - 10341 ) 
 * Reject counter writes in CQLSSTableWriter ( CASSANDRA - 10258 ) 
 * Remove superfluous COUNTER _ MUTATION stage mapping ( CASSANDRA - 10605 ) 
 * Improve json2sstable error reporting on nonexistent columns ( CASSANDRA - 10401 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 906e18c . . 54f6fff 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 2505 , 6 + 2505 , 37 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 CacheService . instance . invalidateCounterCacheForCf ( metadata . ksAndCFName ) ; 
 } 
 
 + public int invalidateRowCache ( Collection < Bounds < Token > > boundsToInvalidate ) 
 + { 
 + int invalidatedKeys = 0 ; 
 + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) 
 + { 
 + DecoratedKey dk = partitioner . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; 
 + if ( key . ksAndCFName . equals ( metadata . ksAndCFName ) & & Bounds . isInBounds ( dk . getToken ( ) , boundsToInvalidate ) ) 
 + { 
 + invalidateCachedRow ( dk ) ; 
 + invalidatedKeys + + ; 
 + } 
 + } 
 + 
 + return invalidatedKeys ; 
 + } 
 + 
 + public int invalidateCounterCache ( Collection < Bounds < Token > > boundsToInvalidate ) 
 + { 
 + int invalidatedKeys = 0 ; 
 + for ( CounterCacheKey key : CacheService . instance . counterCache . getKeySet ( ) ) 
 + { 
 + DecoratedKey dk = partitioner . decorateKey ( ByteBuffer . wrap ( key . partitionKey ) ) ; 
 + if ( key . ksAndCFName . equals ( metadata . ksAndCFName ) & & Bounds . isInBounds ( dk . getToken ( ) , boundsToInvalidate ) ) 
 + { 
 + CacheService . instance . counterCache . remove ( key ) ; 
 + invalidatedKeys + + ; 
 + } 
 + } 
 + return invalidatedKeys ; 
 + } 
 + 
 / * * 
 * @ return true if @ param key is contained in the row cache 
 * / 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 index f8ff163 . . 35d0832 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 @ @ - 189 , 11 + 189 , 6 @ @ public class CompactionController implements AutoCloseable 
 return min ; 
 } 
 
 - public void invalidateCachedRow ( DecoratedKey key ) 
 - { 
 - cfs . invalidateCachedRow ( key ) ; 
 - } 
 - 
 public void close ( ) 
 { 
 overlappingSSTables . release ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java 
 index 42eea77 . . 5ffde42 100644 
 - - - a / src / java / org / apache / cassandra / dht / Bounds . java 
 + + + b / src / java / org / apache / cassandra / dht / Bounds . java 
 @ @ - 17 , 8 + 17 , 17 @ @ 
 * / 
 package org . apache . cassandra . dht ; 
 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . Comparator ; 
 import java . util . List ; 
 + import java . util . Set ; 
 + 
 + import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . PeekingIterator ; 
 + import com . google . common . collect . Sets ; 
 
 import org . apache . cassandra . db . RowPosition ; 
 import org . apache . cassandra . service . StorageService ; 
 @ @ - 108 , 6 + 117 , 20 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > 
 return " ] " ; 
 } 
 
 + public static < T extends RingPosition < T > > boolean isInBounds ( T token , Iterable < Bounds < T > > bounds ) 
 + { 
 + assert bounds ! = null ; 
 + 
 + for ( Bounds < T > bound : bounds ) 
 + { 
 + if ( bound . contains ( token ) ) 
 + { 
 + return true ; 
 + } 
 + } 
 + return false ; 
 + } 
 + 
 / * * 
 * Compute a bounds of keys corresponding to a given bounds of token . 
 * / 
 @ @ - 132 , 4 + 155 , 43 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > 
 { 
 return new Bounds < T > ( left , newRight ) ; 
 } 
 + 
 + / * * 
 + * Retrieves non - overlapping bounds for the list of input bounds 
 + * 
 + * Assume we have the following bounds 
 + * ( brackets representing left / right bound ) : 
 + * [ ] [ ] [ ] [ ] 
 + * [ ] [ ] 
 + * This method will return the following bounds : 
 + * [ ] [ ] 
 + * 
 + * @ param bounds unsorted bounds to find overlaps 
 + * @ return the non - overlapping bounds 
 + * / 
 + public static < T extends RingPosition < T > > Set < Bounds < T > > getNonOverlappingBounds ( Iterable < Bounds < T > > bounds ) 
 + { 
 + ArrayList < Bounds < T > > sortedBounds = Lists . newArrayList ( bounds ) ; 
 + Collections . sort ( sortedBounds , new Comparator < Bounds < T > > ( ) 
 + { 
 + public int compare ( Bounds < T > o1 , Bounds < T > o2 ) 
 + { 
 + return o1 . left . compareTo ( o2 . left ) ; 
 + } 
 + } ) ; 
 + 
 + Set < Bounds < T > > nonOverlappingBounds = Sets . newHashSet ( ) ; 
 + 
 + PeekingIterator < Bounds < T > > it = Iterators . peekingIterator ( sortedBounds . iterator ( ) ) ; 
 + while ( it . hasNext ( ) ) 
 + { 
 + Bounds < T > beginBound = it . next ( ) ; 
 + Bounds < T > endBound = beginBound ; 
 + while ( it . hasNext ( ) & & endBound . right . compareTo ( it . peek ( ) . left ) > = 0 ) 
 + endBound = it . next ( ) ; 
 + nonOverlappingBounds . add ( new Bounds < > ( beginBound . left , endBound . right ) ) ; 
 + } 
 + 
 + return nonOverlappingBounds ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 index 82492a8 . . af5d1d3 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableRewriter . java 
 @ @ - 32 , 7 + 32 , 6 @ @ import org . apache . cassandra . db . DecoratedKey ; 
 import org . apache . cassandra . db . RowIndexEntry ; 
 import org . apache . cassandra . db . compaction . AbstractCompactedRow ; 
 import org . apache . cassandra . utils . CLibrary ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 
 import static org . apache . cassandra . utils . Throwables . merge ; 
 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamReader . java b / src / java / org / apache / cassandra / streaming / StreamReader . java 
 index 5389a80 . . 18013fe 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamReader . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamReader . java 
 @ @ - 166 , 6 + 166 , 5 @ @ public class StreamReader 
 { 
 DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( ByteBufferUtil . readWithShortLength ( in ) ) ; 
 writer . appendFromStream ( key , cfs . metadata , in , inputVersion ) ; 
 - cfs . invalidateCachedRow ( key ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 index da2d7d6 . . 738c93c 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 @ @ - 23 , 14 + 23 , 20 @ @ import java . io . IOException ; 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 + import java . util . Set ; 
 import java . util . UUID ; 
 import java . util . concurrent . ThreadPoolExecutor ; 
 import java . util . concurrent . TimeUnit ; 
 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . dht . Bounds ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . sstable . SSTableWriter ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 @ @ - 47 , 6 + 53 , 8 @ @ public class StreamReceiveTask extends StreamTask 
 FBUtilities . getAvailableProcessors ( ) , 
 60 , TimeUnit . SECONDS ) ; 
 
 + private static final Logger logger = LoggerFactory . getLogger ( StreamReceiveTask . class ) ; 
 + 
 / / number of files to receive 
 private final int totalFiles ; 
 / / total size of files to receive 
 @ @ - 79 , 6 + 87 , 7 @ @ public class StreamReceiveTask extends StreamTask 
 assert cfId . equals ( sstable . metadata . cfId ) ; 
 
 sstables . add ( sstable ) ; 
 + 
 if ( sstables . size ( ) = = totalFiles ) 
 { 
 done = true ; 
 @ @ - 134 , 6 + 143 , 33 @ @ public class StreamReceiveTask extends StreamTask 
 / / add sstables and build secondary indexes 
 cfs . addSSTables ( readers ) ; 
 cfs . indexManager . maybeBuildSecondaryIndexes ( readers , cfs . indexManager . allIndexesNames ( ) ) ; 
 + 
 + / / invalidate row and counter cache 
 + if ( cfs . isRowCacheEnabled ( ) | | cfs . metadata . isCounter ( ) ) 
 + { 
 + List < Bounds < Token > > boundsToInvalidate = new ArrayList < > ( readers . size ( ) ) ; 
 + for ( SSTableReader sstable : readers ) 
 + boundsToInvalidate . add ( new Bounds < Token > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ) ; 
 + Set < Bounds < Token > > nonOverlappingBounds = Bounds . getNonOverlappingBounds ( boundsToInvalidate ) ; 
 + 
 + if ( cfs . isRowCacheEnabled ( ) ) 
 + { 
 + int invalidatedKeys = cfs . invalidateRowCache ( nonOverlappingBounds ) ; 
 + if ( invalidatedKeys > 0 ) 
 + logger . debug ( " [ Stream # { } ] Invalidated { } row cache entries on table { } . { } after stream " + 
 + " receive task completed . " , task . session . planId ( ) , invalidatedKeys , 
 + cfs . keyspace . getName ( ) , cfs . getColumnFamilyName ( ) ) ; 
 + } 
 + 
 + if ( cfs . metadata . isCounter ( ) ) 
 + { 
 + int invalidatedKeys = cfs . invalidateCounterCache ( nonOverlappingBounds ) ; 
 + if ( invalidatedKeys > 0 ) 
 + logger . debug ( " [ Stream # { } ] Invalidated { } counter cache entries on table { } . { } after stream " + 
 + " receive task completed . " , task . session . planId ( ) , invalidatedKeys , 
 + cfs . keyspace . getName ( ) , cfs . getColumnFamilyName ( ) ) ; 
 + } 
 + } 
 } 
 
 task . session . taskCompleted ( task ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / CounterCacheTest . java b / test / unit / org / apache / cassandra / db / CounterCacheTest . java 
 index 20e067c . . 542358d 100644 
 - - - a / test / unit / org / apache / cassandra / db / CounterCacheTest . java 
 + + + b / test / unit / org / apache / cassandra / db / CounterCacheTest . java 
 @ @ - 17 , 6 + 17 , 7 @ @ 
 * / 
 package org . apache . cassandra . db ; 
 
 + import java . util . Collections ; 
 import java . util . concurrent . ExecutionException ; 
 
 import org . junit . AfterClass ; 
 @ @ - 24 , 6 + 25 , 8 @ @ import org . junit . Test ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . dht . Bounds ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . exceptions . WriteTimeoutException ; 
 import org . apache . cassandra . service . CacheService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 @ @ - 71 , 6 + 74 , 48 @ @ public class CounterCacheTest extends SchemaLoader 
 } 
 
 @ Test 
 + public void testCounterCacheInvalidate ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KS ) . getColumnFamilyStore ( CF ) ; 
 + cfs . truncateBlocking ( ) ; 
 + CacheService . instance . invalidateCounterCache ( ) ; 
 + 
 + assertEquals ( 0 , CacheService . instance . counterCache . size ( ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; 
 + 
 + cfs . putCachedCounter ( bytes ( 1 ) , cellname ( 1 ) , ClockAndCount . create ( 1L , 1L ) ) ; 
 + cfs . putCachedCounter ( bytes ( 1 ) , cellname ( 2 ) , ClockAndCount . create ( 1L , 2L ) ) ; 
 + cfs . putCachedCounter ( bytes ( 2 ) , cellname ( 1 ) , ClockAndCount . create ( 2L , 1L ) ) ; 
 + cfs . putCachedCounter ( bytes ( 2 ) , cellname ( 2 ) , ClockAndCount . create ( 2L , 2L ) ) ; 
 + cfs . putCachedCounter ( bytes ( 3 ) , cellname ( 1 ) , ClockAndCount . create ( 3L , 1L ) ) ; 
 + cfs . putCachedCounter ( bytes ( 3 ) , cellname ( 2 ) , ClockAndCount . create ( 3L , 2L ) ) ; 
 + 
 + assertEquals ( 6 , CacheService . instance . counterCache . size ( ) ) ; 
 + assertEquals ( ClockAndCount . create ( 1L , 1L ) , cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 1L , 2L ) , cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 2L , 1L ) , cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 2L , 2L ) , cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 3L , 1L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 3L , 2L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; 
 + 
 + cfs . invalidateCounterCache ( Collections . singleton ( new Bounds < Token > ( cfs . partitioner . decorateKey ( bytes ( 1 ) ) . getToken ( ) , 
 + cfs . partitioner . decorateKey ( bytes ( 2 ) ) . getToken ( ) ) ) ) ; 
 + 
 + assertEquals ( 2 , CacheService . instance . counterCache . size ( ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 1 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 1 ) , cellname ( 2 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 1 ) ) ) ; 
 + assertNull ( cfs . getCachedCounter ( bytes ( 2 ) , cellname ( 2 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 3L , 1L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 1 ) ) ) ; 
 + assertEquals ( ClockAndCount . create ( 3L , 2L ) , cfs . getCachedCounter ( bytes ( 3 ) , cellname ( 2 ) ) ) ; 
 + } 
 + 
 + @ Test 
 public void testSaveLoad ( ) throws ExecutionException , InterruptedException , WriteTimeoutException 
 { 
 ColumnFamilyStore cfs = Keyspace . open ( KS ) . getColumnFamilyStore ( CF ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / RowCacheTest . java b / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 index 6d4554d . . 719c771 100644 
 - - - a / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RowCacheTest . java 
 @ @ - 20 , 8 + 20 , 12 @ @ package org . apache . cassandra . db ; 
 
 import java . net . InetAddress ; 
 import java . nio . ByteBuffer ; 
 + import java . util . ArrayList ; 
 import java . util . Collection ; 
 + import java . util . Iterator ; 
 + import java . util . TreeSet ; 
 
 + import com . google . common . collect . Lists ; 
 import org . junit . AfterClass ; 
 import org . junit . Test ; 
 
 @ @ - 32 , 13 + 36 , 15 @ @ import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . composites . * ; 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . filter . QueryFilter ; 
 + import org . apache . cassandra . dht . Bounds ; 
 import org . apache . cassandra . dht . BytesToken ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . service . CacheService ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 import static org . junit . Assert . assertEquals ; 
 - import static org . junit . Assert . assertTrue ; 
 
 public class RowCacheTest extends SchemaLoader 
 { 
 @ @ - 152 , 6 + 158 , 51 @ @ public class RowCacheTest extends SchemaLoader 
 } 
 
 @ Test 
 + public void testInvalidateRowCache ( ) throws Exception 
 + { 
 + StorageService . instance . initServer ( 0 ) ; 
 + CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; 
 + rowCacheLoad ( 100 , Integer . MAX _ VALUE , 1000 ) ; 
 + 
 + ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; 
 + assertEquals ( CacheService . instance . rowCache . getKeySet ( ) . size ( ) , 100 ) ; 
 + 
 + / / construct 5 ranges of 20 elements each 
 + ArrayList < Bounds < Token > > subranges = getBounds ( 20 ) ; 
 + 
 + / / invalidate 3 of the 5 ranges 
 + ArrayList < Bounds < Token > > boundsToInvalidate = Lists . newArrayList ( subranges . get ( 0 ) , subranges . get ( 2 ) , subranges . get ( 4 ) ) ; 
 + int invalidatedKeys = store . invalidateRowCache ( boundsToInvalidate ) ; 
 + assertEquals ( 60 , invalidatedKeys ) ; 
 + 
 + / / now there should be only 40 cached entries left 
 + assertEquals ( 40 , CacheService . instance . rowCache . getKeySet ( ) . size ( ) ) ; 
 + CacheService . instance . setRowCacheCapacityInMB ( 0 ) ; 
 + } 
 + 
 + private ArrayList < Bounds < Token > > getBounds ( int nElements ) 
 + { 
 + ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; 
 + TreeSet < DecoratedKey > orderedKeys = new TreeSet < > ( ) ; 
 + 
 + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) 
 + orderedKeys . add ( store . partitioner . decorateKey ( ByteBuffer . wrap ( key . key ) ) ) ; 
 + 
 + ArrayList < Bounds < Token > > boundsToInvalidate = new ArrayList < > ( ) ; 
 + Iterator < DecoratedKey > iterator = orderedKeys . iterator ( ) ; 
 + 
 + while ( iterator . hasNext ( ) ) 
 + { 
 + Token startRange = iterator . next ( ) . getToken ( ) ; 
 + for ( int i = 0 ; i < nElements - 2 ; i + + ) 
 + iterator . next ( ) ; 
 + Token endRange = iterator . next ( ) . getToken ( ) ; 
 + boundsToInvalidate . add ( new Bounds < > ( startRange , endRange ) ) ; 
 + } 
 + return boundsToInvalidate ; 
 + } 
 + 
 + @ Test 
 public void testRowCachePartialLoad ( ) throws Exception 
 { 
 CacheService . instance . setRowCacheCapacityInMB ( 1 ) ; 
 @ @ - 220 , 9 + 271 , 9 @ @ public class RowCacheTest extends SchemaLoader 
 
 / / populate row cache , we should not get a row cache hit ; 
 cachedStore . getColumnFamily ( QueryFilter . getSliceFilter ( dk , cf , 
 - Composites . EMPTY , 
 - Composites . EMPTY , 
 - false , 10 , System . currentTimeMillis ( ) ) ) ; 
 + Composites . EMPTY , 
 + Composites . EMPTY , 
 + false , 10 , System . currentTimeMillis ( ) ) ) ; 
 assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . count ( ) ) ; 
 
 / / do another query , limit is 20 , which is < 100 that we cache , we should get a hit and it should be in range 
 @ @ - 272 , 8 + 323 , 6 @ @ public class RowCacheTest extends SchemaLoader 
 { 
 CompactionManager . instance . disableAutoCompaction ( ) ; 
 
 - ColumnFamilyStore store = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( COLUMN _ FAMILY ) ; 
 - 
 / / empty the cache 
 CacheService . instance . invalidateRowCache ( ) ; 
 assert CacheService . instance . rowCache . size ( ) = = 0 ; 
 diff - - git a / test / unit / org / apache / cassandra / dht / BoundsTest . java b / test / unit / org / apache / cassandra / dht / BoundsTest . java 
 new file mode 100644 
 index 0000000 . . 527b498 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / dht / BoundsTest . java 
 @ @ - 0 , 0 + 1 , 61 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . dht ; 
 + 
 + import java . util . LinkedList ; 
 + import java . util . List ; 
 + import java . util . Set ; 
 + 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class BoundsTest 
 + { 
 + 
 + private Bounds < Token > bounds ( long left , long right ) 
 + { 
 + return new Bounds < Token > ( new LongToken ( left ) , new LongToken ( right ) ) ; 
 + } 
 + 
 + @ Test 
 + / * * 
 + * [ 0 , 1 ] , [ 0 , 5 ] , [ 1 , 8 ] , [ 4 , 10 ] = [ 0 , 10 ] 
 + * [ 15 , 19 ] [ 19 , 20 ] = [ 15 , 20 ] 
 + * [ 21 , 22 ] = [ 21 , 22 ] 
 + * / 
 + public void testGetNonOverlappingBounds ( ) 
 + { 
 + List < Bounds < Token > > bounds = new LinkedList < > ( ) ; 
 + bounds . add ( bounds ( 19 , 20 ) ) ; 
 + bounds . add ( bounds ( 0 , 1 ) ) ; 
 + bounds . add ( bounds ( 4 , 10 ) ) ; 
 + bounds . add ( bounds ( 15 , 19 ) ) ; 
 + bounds . add ( bounds ( 0 , 5 ) ) ; 
 + bounds . add ( bounds ( 21 , 22 ) ) ; 
 + bounds . add ( bounds ( 1 , 8 ) ) ; 
 + 
 + Set < Bounds < Token > > nonOverlappingBounds = Bounds . getNonOverlappingBounds ( bounds ) ; 
 + assertEquals ( 3 , nonOverlappingBounds . size ( ) ) ; 
 + assertTrue ( nonOverlappingBounds . contains ( bounds ( 0 , 10 ) ) ) ; 
 + assertTrue ( nonOverlappingBounds . contains ( bounds ( 15 , 20 ) ) ) ; 
 + assertTrue ( nonOverlappingBounds . contains ( bounds ( 21 , 22 ) ) ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
