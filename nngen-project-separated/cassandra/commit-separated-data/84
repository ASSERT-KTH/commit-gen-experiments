BLEU SCORE: 0.028465126651392333

TEST MSG: fix handleRepairStatusChangedNotification to remove first then add
GENERATED MSG: run LongLeveledCompactionStrategyTest . testLeveledScanner in a separate table

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ef285e0 . . 3cfdcff 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * fix handleRepairStatusChangedNotification to remove first then add ( CASSANDRA - 14720 ) <nl> * Allow transient node to serve as a repair coordinator ( CASSANDRA - 14693 ) <nl> * DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot returns wrong value for size ( ) and incorrectly calculates count ( CASSANDRA - 14696 ) <nl> * AbstractReplicaCollection equals and hash code should throw due to conflict between order sensitive / insensitive uses ( CASSANDRA - 14700 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> index afe628b . . 45ccbe2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java <nl> @ @ - 735 , 13 + 735 , 16 @ @ public class CompactionStrategyManager implements INotificationConsumer <nl> continue ; <nl> <nl> AbstractStrategyHolder dstHolder = holders . get ( i ) ; <nl> - dstHolder . addSSTables ( group ) ; <nl> <nl> for ( AbstractStrategyHolder holder : holders ) <nl> { <nl> if ( holder ! = dstHolder ) <nl> holder . removeSSTables ( group ) ; <nl> } <nl> + <nl> + / / adding sstables into another strategy may change its level , <nl> + / / thus it won ' t be removed from original LCS . We have to remove sstables first <nl> + dstHolder . addSSTables ( group ) ; <nl> } <nl> } <nl> finally <nl> diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> index 56eef17 . . 3bcd9d1 100644 <nl> - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db . compaction ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> import java . util . concurrent . * ; <nl> + import java . util . stream . Collectors ; <nl> <nl> import com . google . common . collect . Lists ; <nl> <nl> @ @ - 38 , 8 + 39 , 11 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . schema . CompactionParams ; <nl> import org . apache . cassandra . schema . KeyspaceParams ; <nl> + import org . apache . cassandra . service . ActiveRepairService ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> + import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> public class LongLeveledCompactionStrategyTest <nl> @ @ - 75 , 22 + 79 , 7 @ @ public class LongLeveledCompactionStrategyTest <nl> <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files <nl> <nl> - / / Enough data to have a level 1 and 2 <nl> - int rows = 128 ; <nl> - int columns = 10 ; <nl> - <nl> - / / Adds enough data to trigger multiple sstable per level <nl> - for ( int r = 0 ; r < rows ; r + + ) <nl> - { <nl> - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; <nl> - UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; <nl> - for ( int c = 0 ; c < columns ; c + + ) <nl> - builder . newRow ( " column " + c ) . add ( " val " , value ) ; <nl> - <nl> - Mutation rm = new Mutation ( builder . build ( ) ) ; <nl> - rm . apply ( ) ; <nl> - store . forceBlockingFlush ( ) ; <nl> - } <nl> + populateSSTables ( store ) ; <nl> <nl> / / Execute LCS in parallel <nl> ExecutorService executor = new ThreadPoolExecutor ( 4 , 4 , <nl> @ @ - 153 , 22 + 142 , 8 @ @ public class LongLeveledCompactionStrategyTest <nl> ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF _ STANDARDLVL2 ) ; <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files <nl> <nl> - / / Enough data to have a level 1 and 2 <nl> - int rows = 128 ; <nl> - int columns = 10 ; <nl> - <nl> - / / Adds enough data to trigger multiple sstable per level <nl> - for ( int r = 0 ; r < rows ; r + + ) <nl> - { <nl> - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; <nl> - UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; <nl> - for ( int c = 0 ; c < columns ; c + + ) <nl> - builder . newRow ( " column " + c ) . add ( " val " , value ) ; <nl> + populateSSTables ( store ) ; <nl> <nl> - Mutation rm = new Mutation ( builder . build ( ) ) ; <nl> - rm . apply ( ) ; <nl> - store . forceBlockingFlush ( ) ; <nl> - } <nl> LeveledCompactionStrategyTest . waitForLeveling ( store ) ; <nl> store . disableAutoCompaction ( ) ; <nl> CompactionStrategyManager mgr = store . getCompactionStrategyManager ( ) ; <nl> @ @ - 229 , 4 + 204 , 66 @ @ public class LongLeveledCompactionStrategyTest <nl> <nl> <nl> } <nl> + <nl> + @ Test <nl> + public void testRepairStatusChanges ( ) throws Exception <nl> + { <nl> + String ksname = KEYSPACE1 ; <nl> + String cfname = " StandardLeveled " ; <nl> + Keyspace keyspace = Keyspace . open ( ksname ) ; <nl> + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; <nl> + store . disableAutoCompaction ( ) ; <nl> + <nl> + CompactionStrategyManager mgr = store . getCompactionStrategyManager ( ) ; <nl> + LeveledCompactionStrategy repaired = ( LeveledCompactionStrategy ) mgr . getStrategies ( ) . get ( 0 ) . get ( 0 ) ; <nl> + LeveledCompactionStrategy unrepaired = ( LeveledCompactionStrategy ) mgr . getStrategies ( ) . get ( 1 ) . get ( 0 ) ; <nl> + <nl> + / / populate repaired sstables <nl> + populateSSTables ( store ) ; <nl> + assertTrue ( repaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + mgr . mutateRepaired ( store . getLiveSSTables ( ) , FBUtilities . nowInSeconds ( ) , null , false ) ; <nl> + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + assertTrue ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + <nl> + / / populate unrepaired sstables <nl> + populateSSTables ( store ) ; <nl> + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + <nl> + / / compact them into upper levels <nl> + store . forceMajorCompaction ( ) ; <nl> + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + <nl> + / / mark unrepair <nl> + mgr . mutateRepaired ( store . getLiveSSTables ( ) . stream ( ) . filter ( s - > s . isRepaired ( ) ) . collect ( Collectors . toList ( ) ) , <nl> + ActiveRepairService . UNREPAIRED _ SSTABLE , <nl> + null , <nl> + false ) ; <nl> + assertTrue ( repaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + private void populateSSTables ( ColumnFamilyStore store ) <nl> + { <nl> + ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files <nl> + <nl> + / / Enough data to have a level 1 and 2 <nl> + int rows = 128 ; <nl> + int columns = 10 ; <nl> + <nl> + / / Adds enough data to trigger multiple sstable per level <nl> + for ( int r = 0 ; r < rows ; r + + ) <nl> + { <nl> + DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; <nl> + UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; <nl> + for ( int c = 0 ; c < columns ; c + + ) <nl> + builder . newRow ( " column " + c ) . add ( " val " , value ) ; <nl> + <nl> + Mutation rm = new Mutation ( builder . build ( ) ) ; <nl> + rm . apply ( ) ; <nl> + store . forceBlockingFlush ( ) ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ef285e0 . . 3cfdcff 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * fix handleRepairStatusChangedNotification to remove first then add ( CASSANDRA - 14720 ) 
 * Allow transient node to serve as a repair coordinator ( CASSANDRA - 14693 ) 
 * DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot returns wrong value for size ( ) and incorrectly calculates count ( CASSANDRA - 14696 ) 
 * AbstractReplicaCollection equals and hash code should throw due to conflict between order sensitive / insensitive uses ( CASSANDRA - 14700 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 index afe628b . . 45ccbe2 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionStrategyManager . java 
 @ @ - 735 , 13 + 735 , 16 @ @ public class CompactionStrategyManager implements INotificationConsumer 
 continue ; 
 
 AbstractStrategyHolder dstHolder = holders . get ( i ) ; 
 - dstHolder . addSSTables ( group ) ; 
 
 for ( AbstractStrategyHolder holder : holders ) 
 { 
 if ( holder ! = dstHolder ) 
 holder . removeSSTables ( group ) ; 
 } 
 + 
 + / / adding sstables into another strategy may change its level , 
 + / / thus it won ' t be removed from original LCS . We have to remove sstables first 
 + dstHolder . addSSTables ( group ) ; 
 } 
 } 
 finally 
 diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 index 56eef17 . . 3bcd9d1 100644 
 - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db . compaction ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 import java . util . concurrent . * ; 
 + import java . util . stream . Collectors ; 
 
 import com . google . common . collect . Lists ; 
 
 @ @ - 38 , 8 + 39 , 11 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . schema . CompactionParams ; 
 import org . apache . cassandra . schema . KeyspaceParams ; 
 + import org . apache . cassandra . service . ActiveRepairService ; 
 + import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 + import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertTrue ; 
 
 public class LongLeveledCompactionStrategyTest 
 @ @ - 75 , 22 + 79 , 7 @ @ public class LongLeveledCompactionStrategyTest 
 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files 
 
 - / / Enough data to have a level 1 and 2 
 - int rows = 128 ; 
 - int columns = 10 ; 
 - 
 - / / Adds enough data to trigger multiple sstable per level 
 - for ( int r = 0 ; r < rows ; r + + ) 
 - { 
 - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; 
 - UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; 
 - for ( int c = 0 ; c < columns ; c + + ) 
 - builder . newRow ( " column " + c ) . add ( " val " , value ) ; 
 - 
 - Mutation rm = new Mutation ( builder . build ( ) ) ; 
 - rm . apply ( ) ; 
 - store . forceBlockingFlush ( ) ; 
 - } 
 + populateSSTables ( store ) ; 
 
 / / Execute LCS in parallel 
 ExecutorService executor = new ThreadPoolExecutor ( 4 , 4 , 
 @ @ - 153 , 22 + 142 , 8 @ @ public class LongLeveledCompactionStrategyTest 
 ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF _ STANDARDLVL2 ) ; 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files 
 
 - / / Enough data to have a level 1 and 2 
 - int rows = 128 ; 
 - int columns = 10 ; 
 - 
 - / / Adds enough data to trigger multiple sstable per level 
 - for ( int r = 0 ; r < rows ; r + + ) 
 - { 
 - DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; 
 - UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; 
 - for ( int c = 0 ; c < columns ; c + + ) 
 - builder . newRow ( " column " + c ) . add ( " val " , value ) ; 
 + populateSSTables ( store ) ; 
 
 - Mutation rm = new Mutation ( builder . build ( ) ) ; 
 - rm . apply ( ) ; 
 - store . forceBlockingFlush ( ) ; 
 - } 
 LeveledCompactionStrategyTest . waitForLeveling ( store ) ; 
 store . disableAutoCompaction ( ) ; 
 CompactionStrategyManager mgr = store . getCompactionStrategyManager ( ) ; 
 @ @ - 229 , 4 + 204 , 66 @ @ public class LongLeveledCompactionStrategyTest 
 
 
 } 
 + 
 + @ Test 
 + public void testRepairStatusChanges ( ) throws Exception 
 + { 
 + String ksname = KEYSPACE1 ; 
 + String cfname = " StandardLeveled " ; 
 + Keyspace keyspace = Keyspace . open ( ksname ) ; 
 + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; 
 + store . disableAutoCompaction ( ) ; 
 + 
 + CompactionStrategyManager mgr = store . getCompactionStrategyManager ( ) ; 
 + LeveledCompactionStrategy repaired = ( LeveledCompactionStrategy ) mgr . getStrategies ( ) . get ( 0 ) . get ( 0 ) ; 
 + LeveledCompactionStrategy unrepaired = ( LeveledCompactionStrategy ) mgr . getStrategies ( ) . get ( 1 ) . get ( 0 ) ; 
 + 
 + / / populate repaired sstables 
 + populateSSTables ( store ) ; 
 + assertTrue ( repaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + mgr . mutateRepaired ( store . getLiveSSTables ( ) , FBUtilities . nowInSeconds ( ) , null , false ) ; 
 + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + assertTrue ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + 
 + / / populate unrepaired sstables 
 + populateSSTables ( store ) ; 
 + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + 
 + / / compact them into upper levels 
 + store . forceMajorCompaction ( ) ; 
 + assertFalse ( repaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + 
 + / / mark unrepair 
 + mgr . mutateRepaired ( store . getLiveSSTables ( ) . stream ( ) . filter ( s - > s . isRepaired ( ) ) . collect ( Collectors . toList ( ) ) , 
 + ActiveRepairService . UNREPAIRED _ SSTABLE , 
 + null , 
 + false ) ; 
 + assertTrue ( repaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + assertFalse ( unrepaired . getSSTables ( ) . isEmpty ( ) ) ; 
 + } 
 + 
 + private void populateSSTables ( ColumnFamilyStore store ) 
 + { 
 + ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files 
 + 
 + / / Enough data to have a level 1 and 2 
 + int rows = 128 ; 
 + int columns = 10 ; 
 + 
 + / / Adds enough data to trigger multiple sstable per level 
 + for ( int r = 0 ; r < rows ; r + + ) 
 + { 
 + DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; 
 + UpdateBuilder builder = UpdateBuilder . create ( store . metadata ( ) , key ) ; 
 + for ( int c = 0 ; c < columns ; c + + ) 
 + builder . newRow ( " column " + c ) . add ( " val " , value ) ; 
 + 
 + Mutation rm = new Mutation ( builder . build ( ) ) ; 
 + rm . apply ( ) ; 
 + store . forceBlockingFlush ( ) ; 
 + } 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
