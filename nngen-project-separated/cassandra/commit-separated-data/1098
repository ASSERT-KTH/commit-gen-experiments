BLEU SCORE: 0.005593057954211756

TEST MSG: Support counter - columns for native aggregates ( sum , avg , max , min )
GENERATED MSG: clean out unused code from TcpConnectionManager ; split connections to a node into " command " and " ack " , which will allow us to use backpressure on the command socket . patch by gdusbabek ; reviewed by jbellis for CASSANDRA - 488

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> index 7b5bdb8 . . a1b67e1 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java <nl> @ @ - 47 , 6 + 47 , 7 @ @ public abstract class AggregateFcts <nl> functions . add ( sumFunctionForDouble ) ; <nl> functions . add ( sumFunctionForDecimal ) ; <nl> functions . add ( sumFunctionForVarint ) ; <nl> + functions . add ( sumFunctionForCounter ) ; <nl> <nl> / / avg for primitives <nl> functions . add ( avgFunctionForByte ) ; <nl> @ @ - 57 , 6 + 58 , 7 @ @ public abstract class AggregateFcts <nl> functions . add ( avgFunctionForDouble ) ; <nl> functions . add ( avgFunctionForDecimal ) ; <nl> functions . add ( avgFunctionForVarint ) ; <nl> + functions . add ( avgFunctionForCounter ) ; <nl> <nl> / / count , max , and min for all standard types <nl> for ( CQL3Type type : CQL3Type . Native . values ( ) ) <nl> @ @ - 64 , 8 + 66 , 16 @ @ public abstract class AggregateFcts <nl> if ( type ! = CQL3Type . Native . VARCHAR ) / / varchar and text both mapping to UTF8Type <nl> { <nl> functions . add ( AggregateFcts . makeCountFunction ( type . getType ( ) ) ) ; <nl> - functions . add ( AggregateFcts . makeMaxFunction ( type . getType ( ) ) ) ; <nl> - functions . add ( AggregateFcts . makeMinFunction ( type . getType ( ) ) ) ; <nl> + if ( type ! = CQL3Type . Native . COUNTER ) <nl> + { <nl> + functions . add ( AggregateFcts . makeMaxFunction ( type . getType ( ) ) ) ; <nl> + functions . add ( AggregateFcts . makeMinFunction ( type . getType ( ) ) ) ; <nl> + } <nl> + else <nl> + { <nl> + functions . add ( AggregateFcts . maxFunctionForCounter ) ; <nl> + functions . add ( AggregateFcts . minFunctionForCounter ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 515 , 31 + 525 , 7 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> - { <nl> - private long sum ; <nl> - <nl> - public void reset ( ) <nl> - { <nl> - sum = 0 ; <nl> - } <nl> - <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> - { <nl> - return ( ( LongType ) returnType ( ) ) . decompose ( sum ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . longValue ( ) ; <nl> - } <nl> - } ; <nl> + return new LongSumAggregate ( ) ; <nl> } <nl> } ; <nl> <nl> @ @ - 551 , 37 + 537 , 7 @ @ public abstract class AggregateFcts <nl> { <nl> public Aggregate newAggregate ( ) <nl> { <nl> - return new Aggregate ( ) <nl> - { <nl> - private long sum ; <nl> - <nl> - private int count ; <nl> - <nl> - public void reset ( ) <nl> - { <nl> - count = 0 ; <nl> - sum = 0 ; <nl> - } <nl> - <nl> - public ByteBuffer compute ( int protocolVersion ) <nl> - { <nl> - long avg = count = = 0 ? 0 : sum / count ; <nl> - <nl> - return ( ( LongType ) returnType ( ) ) . decompose ( avg ) ; <nl> - } <nl> - <nl> - public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> - { <nl> - ByteBuffer value = values . get ( 0 ) ; <nl> - <nl> - if ( value = = null ) <nl> - return ; <nl> - <nl> - count + + ; <nl> - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; <nl> - sum + = number . longValue ( ) ; <nl> - } <nl> - } ; <nl> + return new LongAvgAggregate ( ) ; <nl> } <nl> } ; <nl> <nl> @ @ - 742 , 6 + 698 , 106 @ @ public abstract class AggregateFcts <nl> } ; <nl> <nl> / * * <nl> + * The SUM function for counter column values . <nl> + * / <nl> + public static final AggregateFunction sumFunctionForCounter = <nl> + new NativeAggregateFunction ( " sum " , CounterColumnType . instance , CounterColumnType . instance ) <nl> + { <nl> + public Aggregate newAggregate ( ) <nl> + { <nl> + return new LongSumAggregate ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + / * * <nl> + * AVG function for counter column values . <nl> + * / <nl> + public static final AggregateFunction avgFunctionForCounter = <nl> + new NativeAggregateFunction ( " avg " , CounterColumnType . instance , CounterColumnType . instance ) <nl> + { <nl> + public Aggregate newAggregate ( ) <nl> + { <nl> + return new LongAvgAggregate ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + / * * <nl> + * The MIN function for counter column values . <nl> + * / <nl> + public static final AggregateFunction minFunctionForCounter = <nl> + new NativeAggregateFunction ( " min " , CounterColumnType . instance , CounterColumnType . instance ) <nl> + { <nl> + public Aggregate newAggregate ( ) <nl> + { <nl> + return new Aggregate ( ) <nl> + { <nl> + private Long min ; <nl> + <nl> + public void reset ( ) <nl> + { <nl> + min = null ; <nl> + } <nl> + <nl> + public ByteBuffer compute ( int protocolVersion ) <nl> + { <nl> + return min ! = null ? LongType . instance . decompose ( min ) : null ; <nl> + } <nl> + <nl> + public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + { <nl> + ByteBuffer value = values . get ( 0 ) ; <nl> + <nl> + if ( value = = null ) <nl> + return ; <nl> + <nl> + long lval = LongType . instance . compose ( value ) ; <nl> + <nl> + if ( min = = null | | lval < min ) <nl> + min = lval ; <nl> + } <nl> + } ; <nl> + } <nl> + } ; <nl> + <nl> + / * * <nl> + * AVG function for counter column values . <nl> + * / <nl> + public static final AggregateFunction maxFunctionForCounter = <nl> + new NativeAggregateFunction ( " max " , CounterColumnType . instance , CounterColumnType . instance ) <nl> + { <nl> + public Aggregate newAggregate ( ) <nl> + { <nl> + return new Aggregate ( ) <nl> + { <nl> + private Long max ; <nl> + <nl> + public void reset ( ) <nl> + { <nl> + max = null ; <nl> + } <nl> + <nl> + public ByteBuffer compute ( int protocolVersion ) <nl> + { <nl> + return max ! = null ? LongType . instance . decompose ( max ) : null ; <nl> + } <nl> + <nl> + public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + { <nl> + ByteBuffer value = values . get ( 0 ) ; <nl> + <nl> + if ( value = = null ) <nl> + return ; <nl> + <nl> + long lval = LongType . instance . compose ( value ) ; <nl> + <nl> + if ( max = = null | | lval > max ) <nl> + max = lval ; <nl> + } <nl> + } ; <nl> + } <nl> + } ; <nl> + <nl> + / * * <nl> * Creates a MAX function for the specified type . <nl> * <nl> * @ param inputType the function input and output type <nl> @ @ - 862 , 4 + 918 , 62 @ @ public abstract class AggregateFcts <nl> } <nl> } ; <nl> } <nl> + <nl> + private static class LongSumAggregate implements AggregateFunction . Aggregate <nl> + { <nl> + private long sum ; <nl> + <nl> + public void reset ( ) <nl> + { <nl> + sum = 0 ; <nl> + } <nl> + <nl> + public ByteBuffer compute ( int protocolVersion ) <nl> + { <nl> + return LongType . instance . decompose ( sum ) ; <nl> + } <nl> + <nl> + public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + { <nl> + ByteBuffer value = values . get ( 0 ) ; <nl> + <nl> + if ( value = = null ) <nl> + return ; <nl> + <nl> + Number number = LongType . instance . compose ( value ) ; <nl> + sum + = number . longValue ( ) ; <nl> + } <nl> + } <nl> + <nl> + private static class LongAvgAggregate implements AggregateFunction . Aggregate <nl> + { <nl> + private long sum ; <nl> + <nl> + private int count ; <nl> + <nl> + public void reset ( ) <nl> + { <nl> + count = 0 ; <nl> + sum = 0 ; <nl> + } <nl> + <nl> + public ByteBuffer compute ( int protocolVersion ) <nl> + { <nl> + long avg = count = = 0 ? 0 : sum / count ; <nl> + <nl> + return LongType . instance . decompose ( avg ) ; <nl> + } <nl> + <nl> + public void addInput ( int protocolVersion , List < ByteBuffer > values ) <nl> + { <nl> + ByteBuffer value = values . get ( 0 ) ; <nl> + <nl> + if ( value = = null ) <nl> + return ; <nl> + <nl> + count + + ; <nl> + Number number = LongType . instance . compose ( value ) ; <nl> + sum + = number . longValue ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java <nl> index 467a082 . . 704a6c9 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java <nl> @ @ - 707 , 6 + 707 , 32 @ @ public class UFTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> + public void testJavaFunctionCounter ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( key int primary key , val counter ) " ) ; <nl> + <nl> + String fName = createFunction ( KEYSPACE , " counter " , <nl> + " CREATE OR REPLACE FUNCTION % s ( val counter ) " + <nl> + " CALLED ON NULL INPUT " + <nl> + " RETURNS bigint " + <nl> + " LANGUAGE JAVA " + <nl> + " AS ' return val + 1 ; ' ; " ) ; <nl> + <nl> + execute ( " UPDATE % s SET val = val + 1 WHERE key = 1 " ) ; <nl> + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , <nl> + row ( 1 , 1L , 2L ) ) ; <nl> + execute ( " UPDATE % s SET val = val + 1 WHERE key = 1 " ) ; <nl> + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , <nl> + row ( 1 , 2L , 3L ) ) ; <nl> + execute ( " UPDATE % s SET val = val + 2 WHERE key = 1 " ) ; <nl> + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , <nl> + row ( 1 , 4L , 5L ) ) ; <nl> + execute ( " UPDATE % s SET val = val - 2 WHERE key = 1 " ) ; <nl> + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , <nl> + row ( 1 , 2L , 3L ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testFunctionInTargetKeyspace ( ) throws Throwable <nl> { <nl> createTable ( " CREATE TABLE % s ( key int primary key , val double ) " ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> index 2713895 . . 221f48e 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> @ @ - 174 , 6 + 174 , 47 @ @ public class AggregationTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> + public void testAggregateOnCounters ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int , b counter , primary key ( a ) ) " ) ; <nl> + <nl> + / / Test with empty table <nl> + assertColumnNames ( execute ( " SELECT count ( b ) , max ( b ) as max , b FROM % s " ) , <nl> + " system . count ( b ) " , " max " , " b " ) ; <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , b FROM % s " ) , <nl> + row ( 0L , null , null ) ) ; <nl> + <nl> + execute ( " UPDATE % s SET b = b + 1 WHERE a = 1 " ) ; <nl> + execute ( " UPDATE % s SET b = b + 1 WHERE a = 1 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 1L , 2L , 2L , 2L , 2L ) ) ; <nl> + flush ( ) ; <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 1L , 2L , 2L , 2L , 2L ) ) ; <nl> + <nl> + execute ( " UPDATE % s SET b = b + 2 WHERE a = 1 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 1L , 4L , 4L , 4L , 4L ) ) ; <nl> + <nl> + execute ( " UPDATE % s SET b = b - 2 WHERE a = 1 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 1L , 2L , 2L , 2L , 2L ) ) ; <nl> + flush ( ) ; <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 1L , 2L , 2L , 2L , 2L ) ) ; <nl> + <nl> + execute ( " UPDATE % s SET b = b + 1 WHERE a = 2 " ) ; <nl> + execute ( " UPDATE % s SET b = b + 1 WHERE a = 2 " ) ; <nl> + execute ( " UPDATE % s SET b = b + 2 WHERE a = 2 " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , <nl> + row ( 2L , 4L , 2L , 3L , 6L ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testAggregateWithUdtFields ( ) throws Throwable <nl> { <nl> String myType = createType ( " CREATE TYPE % s ( x int ) " ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / net / MessagingConfig . java b / src / java / org / apache / cassandra / net / MessagingConfig . java <nl> deleted file mode 100644 <nl> index 4df69f6 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingConfig . java <nl> + + + / dev / null <nl> @ @ - 1 , 92 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - public class MessagingConfig <nl> - { <nl> - / / The expected time for one message round trip . It does not reflect message processing <nl> - / / time at the receiver . <nl> - private static int expectedRoundTripTime _ = 400 ; <nl> - private static int numberOfPorts _ = 2 ; <nl> - private static int threadCount _ = 4 ; <nl> - <nl> - public static int getMessagingThreadCount ( ) <nl> - { <nl> - return threadCount _ ; <nl> - } <nl> - <nl> - public static void setMessagingThreadCount ( int threadCount ) <nl> - { <nl> - threadCount _ = threadCount ; <nl> - } <nl> - <nl> - public static void setExpectedRoundTripTime ( int roundTripTimeMillis ) { <nl> - 	 if ( roundTripTimeMillis > 0 ) <nl> - 	 	 expectedRoundTripTime _ = roundTripTimeMillis ; <nl> - } <nl> - <nl> - public static int getExpectedRoundTripTime ( ) <nl> - { <nl> - return expectedRoundTripTime _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolInitialSize ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . initialSize _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolGrowthFactor ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . growthFactor _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolMaxSize ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . maxSize _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolWaitTimeout ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . waitTimeout _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolMonitorInterval ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . monitorInterval _ ; <nl> - } <nl> - <nl> - public static void setNumberOfPorts ( int n ) <nl> - { <nl> - numberOfPorts _ = n ; <nl> - } <nl> - <nl> - public static int getNumberOfPorts ( ) <nl> - { <nl> - return numberOfPorts _ ; <nl> - } <nl> - } <nl> - <nl> - class ConnectionPoolConfiguration <nl> - { <nl> - public static int initialSize _ = 1 ; <nl> - public static int growthFactor _ = 1 ; <nl> - public static int maxSize _ = 1 ; <nl> - public static int waitTimeout _ = 10 ; <nl> - public static int monitorInterval _ = 300 ; <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 20a0d2b . . 6fbe9e0 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 91 , 6 + 91 , 8 @ @ public class MessagingService implements IMessagingService <nl> <nl> private static IMessagingService messagingService _ = new MessagingService ( ) ; <nl> <nl> + private static final int MESSAGE _ DESERIALIZE _ THREADS = 4 ; <nl> + <nl> public static int getVersion ( ) <nl> { <nl> return version _ ; <nl> @ @ - 137 , 7 + 139 , 7 @ @ public class MessagingService implements IMessagingService <nl> * which is the sum of the threads in the pool that adds shit into the table and the <nl> * pool that retrives the callback from here . <nl> * / <nl> - int maxSize = MessagingConfig . getMessagingThreadCount ( ) ; <nl> + int maxSize = MESSAGE _ DESERIALIZE _ THREADS ; <nl> callbackMap _ = new Cachetable < String , IAsyncCallback > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; <nl> taskCompletionMap _ = new Cachetable < String , IAsyncResult > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; <nl> <nl> @ @ - 185 , 7 + 187 , 7 @ @ public class MessagingService implements IMessagingService <nl> public void listen ( InetAddress localEp ) throws IOException <nl> { <nl> ServerSocketChannel serverChannel = ServerSocketChannel . open ( ) ; <nl> - ServerSocket ss = serverChannel . socket ( ) ; <nl> + ServerSocket ss = serverChannel . socket ( ) ; <nl> ss . bind ( new InetSocketAddress ( localEp , DatabaseDescriptor . getStoragePort ( ) ) ) ; <nl> serverChannel . configureBlocking ( false ) ; <nl> <nl> @ @ - 224 , 9 + 226 , 7 @ @ public class MessagingService implements IMessagingService <nl> cp = poolTable _ . get ( key ) ; <nl> if ( cp = = null ) <nl> { <nl> - cp = new TcpConnectionManager ( MessagingConfig . getConnectionPoolInitialSize ( ) , <nl> - MessagingConfig . getConnectionPoolGrowthFactor ( ) , <nl> - MessagingConfig . getConnectionPoolMaxSize ( ) , from , to ) ; <nl> + cp = new TcpConnectionManager ( from , to ) ; <nl> poolTable _ . put ( key , cp ) ; <nl> } <nl> } <nl> @ @ - 238 , 9 + 238 , 9 @ @ public class MessagingService implements IMessagingService <nl> return cp ; <nl> } <nl> <nl> - public static TcpConnection getConnection ( InetAddress from , InetAddress to ) throws IOException <nl> + public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException <nl> { <nl> - return getConnectionPool ( from , to ) . getConnection ( ) ; <nl> + return getConnectionPool ( from , to ) . getConnection ( msg ) ; <nl> } <nl> <nl> private void checkForReservedVerb ( String type ) <nl> @ @ - 324 , 14 + 324 , 14 @ @ public class MessagingService implements IMessagingService <nl> Use this version for fire and forget style messaging . <nl> * / <nl> public void sendOneWay ( Message message , InetAddress to ) <nl> - { <nl> - / / do local deliveries <nl> + { <nl> + / / do local deliveries <nl> if ( message . getFrom ( ) . equals ( to ) ) <nl> - { <nl> + { <nl> MessagingService . receive ( message ) ; <nl> return ; <nl> } <nl> - <nl> + <nl> TcpConnection connection = null ; <nl> try <nl> { <nl> @ @ - 340 , 7 + 340 , 7 @ @ public class MessagingService implements IMessagingService <nl> { <nl> return ; <nl> } <nl> - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; <nl> + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> connection . write ( message ) ; <nl> } <nl> catch ( SocketException se ) <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> index 83c534b . . ea780a9 100644 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> @ @ - 67 , 14 + 67 , 12 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> private boolean bStream _ = false ; <nl> private Lock lock _ ; <nl> private Condition condition _ ; <nl> - <nl> - / / used from getConnection - outgoing <nl> - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - pool _ = pool ; <nl> - <nl> + <nl> + private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException <nl> + { <nl> + socketChannel _ = SocketChannel . open ( ) ; <nl> + socketChannel _ . configureBlocking ( false ) ; <nl> + <nl> localEp _ = from ; <nl> remoteEp _ = to ; <nl> <nl> @ @ - 86 , 6 + 84 , 24 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> { <nl> key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> } <nl> + <nl> + if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) <nl> + throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; <nl> + <nl> + if ( pool ! = null ) <nl> + pool _ = pool ; <nl> + if ( streaming ) <nl> + { <nl> + bStream _ = true ; <nl> + lock _ = new ReentrantLock ( ) ; <nl> + condition _ = lock _ . newCondition ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / used from getConnection - outgoing <nl> + TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> + { <nl> + this ( from , to , pool , false ) ; <nl> } <nl> <nl> / * <nl> @ @ - 93 , 23 + 109 , 7 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> * / <nl> TcpConnection ( InetAddress from , InetAddress to ) throws IOException <nl> { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - <nl> - localEp _ = from ; <nl> - remoteEp _ = to ; <nl> - <nl> - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; <nl> - } <nl> - else <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> - } <nl> - bStream _ = true ; <nl> - lock _ = new ReentrantLock ( ) ; <nl> - condition _ = lock _ . newCondition ( ) ; <nl> + this ( from , to , null , true ) ; <nl> } <nl> <nl> / * <nl> @ @ - 135 , 27 + 135 , 13 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> isIncoming _ = isIncoming ; <nl> localEp _ = localEp ; <nl> } <nl> - <nl> - InetAddress getLocalEp ( ) <nl> - { <nl> - return localEp _ ; <nl> - } <nl> - <nl> - public void setLocalEp ( InetAddress localEp ) <nl> - { <nl> - localEp _ = localEp ; <nl> - } <nl> + <nl> <nl> public InetAddress getEndPoint ( ) <nl> { <nl> return remoteEp _ ; <nl> } <nl> - <nl> - public boolean isIncoming ( ) <nl> - { <nl> - return isIncoming _ ; <nl> - } <nl> - <nl> + <nl> public SocketChannel getSocketChannel ( ) <nl> { <nl> return socketChannel _ ; <nl> @ @ - 274 , 8 + 260 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> public void close ( ) <nl> { <nl> inUse _ = false ; <nl> - if ( pool _ . contains ( this ) ) <nl> - pool _ . decUsed ( ) ; <nl> } <nl> <nl> public boolean isConnected ( ) <nl> @ @ - 305 , 10 + 289 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> void closeSocket ( ) <nl> { <nl> logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; <nl> - if ( pool _ ! = null ) <nl> - { <nl> - pool _ . removeConnection ( this ) ; <nl> - } <nl> cancel ( key _ ) ; <nl> pendingWrites _ . clear ( ) ; <nl> } <nl> @ @ - 318 , 11 + 298 , 8 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> logger _ . warn ( " Closing down connection " + socketChannel _ ) ; <nl> pendingWrites _ . clear ( ) ; <nl> cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - if ( pool _ ! = null ) <nl> - { <nl> - pool _ . removeConnection ( this ) ; <nl> - } <nl> + pendingWrites _ . clear ( ) ; <nl> + pool _ . destroy ( this ) ; <nl> } <nl> <nl> private void cancel ( SelectionKey key ) <nl> @ @ - 456 , 9 + 433 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> if ( remoteEp _ = = null ) <nl> { <nl> remoteEp _ = socketChannel _ . socket ( ) . getInetAddress ( ) ; <nl> - / / put connection into pool if possible <nl> - pool _ = MessagingService . getConnectionPool ( localEp _ , remoteEp _ ) ; <nl> - pool _ . addToPool ( TcpConnection . this ) ; <nl> } <nl> <nl> / * Deserialize and handle the message * / <nl> @ @ - 497 , 11 + 471 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> } <nl> } <nl> <nl> - public int pending ( ) <nl> - { <nl> - return pendingWrites _ . size ( ) ; <nl> - } <nl> - <nl> public int compareTo ( Object o ) <nl> { <nl> if ( o instanceof TcpConnection ) <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> index 7cbbde3 . . 4485435 100644 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> + + + b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> @ @ - 27 , 205 + 27 , 61 @ @ import org . apache . log4j . Logger ; <nl> <nl> class TcpConnectionManager <nl> { <nl> - private Lock lock _ = new ReentrantLock ( ) ; <nl> - private List < TcpConnection > allConnections _ ; <nl> private InetAddress localEp _ ; <nl> private InetAddress remoteEp _ ; <nl> - private int maxSize _ ; <nl> + private TcpConnection cmdCon ; <nl> + private TcpConnection ackCon ; <nl> <nl> - private int inUse _ ; <nl> - <nl> - / / TODO ! this whole thing is a giant no - op , since " contains " only relies on TcpConnection . equals , which <nl> - / / is true for any ( local , remote ) pairs . So there is only ever at most one TcpConnection per Manager ! <nl> - TcpConnectionManager ( int initialSize , int growthFactor , int maxSize , InetAddress localEp , InetAddress remoteEp ) <nl> + TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) <nl> { <nl> - maxSize _ = maxSize ; <nl> localEp _ = localEp ; <nl> remoteEp _ = remoteEp ; <nl> - allConnections _ = new ArrayList < TcpConnection > ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * returns the least loaded connection to remoteEp , creating a new connection if necessary <nl> - * / <nl> - TcpConnection getConnection ( ) throws IOException <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - if ( allConnections _ . isEmpty ( ) ) <nl> - { <nl> - TcpConnection conn = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - addToPool ( conn ) ; <nl> - conn . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return conn ; <nl> - } <nl> - <nl> - TcpConnection least = getLeastLoaded ( ) ; <nl> - <nl> - if ( ( least ! = null & & least . pending ( ) = = 0 ) | | allConnections _ . size ( ) = = maxSize _ ) <nl> - { <nl> - least . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return least ; <nl> - } <nl> - <nl> - TcpConnection connection = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - if ( ! contains ( connection ) ) <nl> - { <nl> - addToPool ( connection ) ; <nl> - connection . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return connection ; <nl> - } <nl> - else <nl> - { <nl> - connection . closeSocket ( ) ; <nl> - return getLeastLoaded ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - protected TcpConnection getLeastLoaded ( ) <nl> - { <nl> - TcpConnection connection = null ; <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - Collections . sort ( allConnections _ ) ; <nl> - connection = ( allConnections _ . size ( ) > 0 ) ? allConnections _ . get ( 0 ) : null ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - return connection ; <nl> - } <nl> - <nl> - void removeConnection ( TcpConnection connection ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - allConnections _ . remove ( connection ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - void incUsed ( ) <nl> - { <nl> - inUse _ + + ; <nl> } <nl> <nl> - void decUsed ( ) <nl> + private TcpConnection newCon ( ) throws IOException <nl> { <nl> - inUse _ - - ; <nl> + TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> + con . inUse _ = true ; <nl> + return con ; <nl> } <nl> <nl> - int getConnectionsInUse ( ) <nl> - { <nl> - return inUse _ ; <nl> - } <nl> - <nl> - void addToPool ( TcpConnection connection ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - if ( contains ( connection ) ) <nl> - return ; <nl> - <nl> - if ( allConnections _ . size ( ) < maxSize _ ) <nl> - { <nl> - allConnections _ . add ( connection ) ; <nl> - } <nl> - else <nl> - { <nl> - connection . closeSocket ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - void shutdown ( ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - while ( allConnections _ . size ( ) > 0 ) <nl> - { <nl> - TcpConnection connection = allConnections _ . remove ( 0 ) ; <nl> - connection . closeSocket ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - int getPoolSize ( ) <nl> + / * * <nl> + * returns the appropriate connection based on message type . <nl> + * / <nl> + synchronized TcpConnection getConnection ( Message msg ) throws IOException <nl> { <nl> - lock _ . lock ( ) ; <nl> - try <nl> + if ( MessagingService . responseStage _ . equals ( msg . getMessageType ( ) ) ) <nl> { <nl> - return allConnections _ . size ( ) ; <nl> + if ( ackCon = = null ) <nl> + ackCon = newCon ( ) ; <nl> + return ackCon ; <nl> } <nl> - finally <nl> + else <nl> { <nl> - lock _ . unlock ( ) ; <nl> + if ( cmdCon = = null ) <nl> + cmdCon = newCon ( ) ; <nl> + return cmdCon ; <nl> } <nl> } <nl> <nl> - InetAddress getLocalEndPoint ( ) <nl> - { <nl> - return localEp _ ; <nl> - } <nl> - <nl> - InetAddress getRemoteEndPoint ( ) <nl> + synchronized void shutdown ( ) <nl> { <nl> - return remoteEp _ ; <nl> - } <nl> - <nl> - int getPendingWrites ( ) <nl> - { <nl> - int total = 0 ; <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - for ( TcpConnection connection : allConnections _ ) <nl> - { <nl> - total + = connection . pending ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - return total ; <nl> + for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) <nl> + if ( con ! = null ) <nl> + con . closeSocket ( ) ; <nl> } <nl> <nl> - boolean contains ( TcpConnection connection ) <nl> + synchronized void destroy ( TcpConnection con ) <nl> { <nl> - lock _ . lock ( ) ; <nl> - try <nl> + assert con ! = null ; <nl> + if ( cmdCon = = con ) <nl> { <nl> - return allConnections _ . contains ( connection ) ; <nl> + cmdCon = null ; <nl> } <nl> - finally <nl> + else <nl> { <nl> - lock _ . unlock ( ) ; <nl> + assert ackCon = = con ; <nl> + ackCon = null ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 index 7b5bdb8 . . a1b67e1 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / AggregateFcts . java 
 @ @ - 47 , 6 + 47 , 7 @ @ public abstract class AggregateFcts 
 functions . add ( sumFunctionForDouble ) ; 
 functions . add ( sumFunctionForDecimal ) ; 
 functions . add ( sumFunctionForVarint ) ; 
 + functions . add ( sumFunctionForCounter ) ; 
 
 / / avg for primitives 
 functions . add ( avgFunctionForByte ) ; 
 @ @ - 57 , 6 + 58 , 7 @ @ public abstract class AggregateFcts 
 functions . add ( avgFunctionForDouble ) ; 
 functions . add ( avgFunctionForDecimal ) ; 
 functions . add ( avgFunctionForVarint ) ; 
 + functions . add ( avgFunctionForCounter ) ; 
 
 / / count , max , and min for all standard types 
 for ( CQL3Type type : CQL3Type . Native . values ( ) ) 
 @ @ - 64 , 8 + 66 , 16 @ @ public abstract class AggregateFcts 
 if ( type ! = CQL3Type . Native . VARCHAR ) / / varchar and text both mapping to UTF8Type 
 { 
 functions . add ( AggregateFcts . makeCountFunction ( type . getType ( ) ) ) ; 
 - functions . add ( AggregateFcts . makeMaxFunction ( type . getType ( ) ) ) ; 
 - functions . add ( AggregateFcts . makeMinFunction ( type . getType ( ) ) ) ; 
 + if ( type ! = CQL3Type . Native . COUNTER ) 
 + { 
 + functions . add ( AggregateFcts . makeMaxFunction ( type . getType ( ) ) ) ; 
 + functions . add ( AggregateFcts . makeMinFunction ( type . getType ( ) ) ) ; 
 + } 
 + else 
 + { 
 + functions . add ( AggregateFcts . maxFunctionForCounter ) ; 
 + functions . add ( AggregateFcts . minFunctionForCounter ) ; 
 + } 
 } 
 } 
 
 @ @ - 515 , 31 + 525 , 7 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 - { 
 - private long sum ; 
 - 
 - public void reset ( ) 
 - { 
 - sum = 0 ; 
 - } 
 - 
 - public ByteBuffer compute ( int protocolVersion ) 
 - { 
 - return ( ( LongType ) returnType ( ) ) . decompose ( sum ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . longValue ( ) ; 
 - } 
 - } ; 
 + return new LongSumAggregate ( ) ; 
 } 
 } ; 
 
 @ @ - 551 , 37 + 537 , 7 @ @ public abstract class AggregateFcts 
 { 
 public Aggregate newAggregate ( ) 
 { 
 - return new Aggregate ( ) 
 - { 
 - private long sum ; 
 - 
 - private int count ; 
 - 
 - public void reset ( ) 
 - { 
 - count = 0 ; 
 - sum = 0 ; 
 - } 
 - 
 - public ByteBuffer compute ( int protocolVersion ) 
 - { 
 - long avg = count = = 0 ? 0 : sum / count ; 
 - 
 - return ( ( LongType ) returnType ( ) ) . decompose ( avg ) ; 
 - } 
 - 
 - public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 - { 
 - ByteBuffer value = values . get ( 0 ) ; 
 - 
 - if ( value = = null ) 
 - return ; 
 - 
 - count + + ; 
 - Number number = ( ( Number ) argTypes ( ) . get ( 0 ) . compose ( value ) ) ; 
 - sum + = number . longValue ( ) ; 
 - } 
 - } ; 
 + return new LongAvgAggregate ( ) ; 
 } 
 } ; 
 
 @ @ - 742 , 6 + 698 , 106 @ @ public abstract class AggregateFcts 
 } ; 
 
 / * * 
 + * The SUM function for counter column values . 
 + * / 
 + public static final AggregateFunction sumFunctionForCounter = 
 + new NativeAggregateFunction ( " sum " , CounterColumnType . instance , CounterColumnType . instance ) 
 + { 
 + public Aggregate newAggregate ( ) 
 + { 
 + return new LongSumAggregate ( ) ; 
 + } 
 + } ; 
 + 
 + / * * 
 + * AVG function for counter column values . 
 + * / 
 + public static final AggregateFunction avgFunctionForCounter = 
 + new NativeAggregateFunction ( " avg " , CounterColumnType . instance , CounterColumnType . instance ) 
 + { 
 + public Aggregate newAggregate ( ) 
 + { 
 + return new LongAvgAggregate ( ) ; 
 + } 
 + } ; 
 + 
 + / * * 
 + * The MIN function for counter column values . 
 + * / 
 + public static final AggregateFunction minFunctionForCounter = 
 + new NativeAggregateFunction ( " min " , CounterColumnType . instance , CounterColumnType . instance ) 
 + { 
 + public Aggregate newAggregate ( ) 
 + { 
 + return new Aggregate ( ) 
 + { 
 + private Long min ; 
 + 
 + public void reset ( ) 
 + { 
 + min = null ; 
 + } 
 + 
 + public ByteBuffer compute ( int protocolVersion ) 
 + { 
 + return min ! = null ? LongType . instance . decompose ( min ) : null ; 
 + } 
 + 
 + public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + { 
 + ByteBuffer value = values . get ( 0 ) ; 
 + 
 + if ( value = = null ) 
 + return ; 
 + 
 + long lval = LongType . instance . compose ( value ) ; 
 + 
 + if ( min = = null | | lval < min ) 
 + min = lval ; 
 + } 
 + } ; 
 + } 
 + } ; 
 + 
 + / * * 
 + * AVG function for counter column values . 
 + * / 
 + public static final AggregateFunction maxFunctionForCounter = 
 + new NativeAggregateFunction ( " max " , CounterColumnType . instance , CounterColumnType . instance ) 
 + { 
 + public Aggregate newAggregate ( ) 
 + { 
 + return new Aggregate ( ) 
 + { 
 + private Long max ; 
 + 
 + public void reset ( ) 
 + { 
 + max = null ; 
 + } 
 + 
 + public ByteBuffer compute ( int protocolVersion ) 
 + { 
 + return max ! = null ? LongType . instance . decompose ( max ) : null ; 
 + } 
 + 
 + public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + { 
 + ByteBuffer value = values . get ( 0 ) ; 
 + 
 + if ( value = = null ) 
 + return ; 
 + 
 + long lval = LongType . instance . compose ( value ) ; 
 + 
 + if ( max = = null | | lval > max ) 
 + max = lval ; 
 + } 
 + } ; 
 + } 
 + } ; 
 + 
 + / * * 
 * Creates a MAX function for the specified type . 
 * 
 * @ param inputType the function input and output type 
 @ @ - 862 , 4 + 918 , 62 @ @ public abstract class AggregateFcts 
 } 
 } ; 
 } 
 + 
 + private static class LongSumAggregate implements AggregateFunction . Aggregate 
 + { 
 + private long sum ; 
 + 
 + public void reset ( ) 
 + { 
 + sum = 0 ; 
 + } 
 + 
 + public ByteBuffer compute ( int protocolVersion ) 
 + { 
 + return LongType . instance . decompose ( sum ) ; 
 + } 
 + 
 + public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + { 
 + ByteBuffer value = values . get ( 0 ) ; 
 + 
 + if ( value = = null ) 
 + return ; 
 + 
 + Number number = LongType . instance . compose ( value ) ; 
 + sum + = number . longValue ( ) ; 
 + } 
 + } 
 + 
 + private static class LongAvgAggregate implements AggregateFunction . Aggregate 
 + { 
 + private long sum ; 
 + 
 + private int count ; 
 + 
 + public void reset ( ) 
 + { 
 + count = 0 ; 
 + sum = 0 ; 
 + } 
 + 
 + public ByteBuffer compute ( int protocolVersion ) 
 + { 
 + long avg = count = = 0 ? 0 : sum / count ; 
 + 
 + return LongType . instance . decompose ( avg ) ; 
 + } 
 + 
 + public void addInput ( int protocolVersion , List < ByteBuffer > values ) 
 + { 
 + ByteBuffer value = values . get ( 0 ) ; 
 + 
 + if ( value = = null ) 
 + return ; 
 + 
 + count + + ; 
 + Number number = LongType . instance . compose ( value ) ; 
 + sum + = number . longValue ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java 
 index 467a082 . . 704a6c9 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / UFTest . java 
 @ @ - 707 , 6 + 707 , 32 @ @ public class UFTest extends CQLTester 
 } 
 
 @ Test 
 + public void testJavaFunctionCounter ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( key int primary key , val counter ) " ) ; 
 + 
 + String fName = createFunction ( KEYSPACE , " counter " , 
 + " CREATE OR REPLACE FUNCTION % s ( val counter ) " + 
 + " CALLED ON NULL INPUT " + 
 + " RETURNS bigint " + 
 + " LANGUAGE JAVA " + 
 + " AS ' return val + 1 ; ' ; " ) ; 
 + 
 + execute ( " UPDATE % s SET val = val + 1 WHERE key = 1 " ) ; 
 + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , 
 + row ( 1 , 1L , 2L ) ) ; 
 + execute ( " UPDATE % s SET val = val + 1 WHERE key = 1 " ) ; 
 + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , 
 + row ( 1 , 2L , 3L ) ) ; 
 + execute ( " UPDATE % s SET val = val + 2 WHERE key = 1 " ) ; 
 + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , 
 + row ( 1 , 4L , 5L ) ) ; 
 + execute ( " UPDATE % s SET val = val - 2 WHERE key = 1 " ) ; 
 + assertRows ( execute ( " SELECT key , val , " + fName + " ( val ) FROM % s " ) , 
 + row ( 1 , 2L , 3L ) ) ; 
 + } 
 + 
 + @ Test 
 public void testFunctionInTargetKeyspace ( ) throws Throwable 
 { 
 createTable ( " CREATE TABLE % s ( key int primary key , val double ) " ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 index 2713895 . . 221f48e 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 @ @ - 174 , 6 + 174 , 47 @ @ public class AggregationTest extends CQLTester 
 } 
 
 @ Test 
 + public void testAggregateOnCounters ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int , b counter , primary key ( a ) ) " ) ; 
 + 
 + / / Test with empty table 
 + assertColumnNames ( execute ( " SELECT count ( b ) , max ( b ) as max , b FROM % s " ) , 
 + " system . count ( b ) " , " max " , " b " ) ; 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , b FROM % s " ) , 
 + row ( 0L , null , null ) ) ; 
 + 
 + execute ( " UPDATE % s SET b = b + 1 WHERE a = 1 " ) ; 
 + execute ( " UPDATE % s SET b = b + 1 WHERE a = 1 " ) ; 
 + 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 1L , 2L , 2L , 2L , 2L ) ) ; 
 + flush ( ) ; 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 1L , 2L , 2L , 2L , 2L ) ) ; 
 + 
 + execute ( " UPDATE % s SET b = b + 2 WHERE a = 1 " ) ; 
 + 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 1L , 4L , 4L , 4L , 4L ) ) ; 
 + 
 + execute ( " UPDATE % s SET b = b - 2 WHERE a = 1 " ) ; 
 + 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 1L , 2L , 2L , 2L , 2L ) ) ; 
 + flush ( ) ; 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 1L , 2L , 2L , 2L , 2L ) ) ; 
 + 
 + execute ( " UPDATE % s SET b = b + 1 WHERE a = 2 " ) ; 
 + execute ( " UPDATE % s SET b = b + 1 WHERE a = 2 " ) ; 
 + execute ( " UPDATE % s SET b = b + 2 WHERE a = 2 " ) ; 
 + 
 + assertRows ( execute ( " SELECT count ( b ) , max ( b ) as max , min ( b ) as min , avg ( b ) as avg , sum ( b ) as sum FROM % s " ) , 
 + row ( 2L , 4L , 2L , 3L , 6L ) ) ; 
 + } 
 + 
 + @ Test 
 public void testAggregateWithUdtFields ( ) throws Throwable 
 { 
 String myType = createType ( " CREATE TYPE % s ( x int ) " ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / net / MessagingConfig . java b / src / java / org / apache / cassandra / net / MessagingConfig . java 
 deleted file mode 100644 
 index 4df69f6 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / MessagingConfig . java 
 + + + / dev / null 
 @ @ - 1 , 92 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - public class MessagingConfig 
 - { 
 - / / The expected time for one message round trip . It does not reflect message processing 
 - / / time at the receiver . 
 - private static int expectedRoundTripTime _ = 400 ; 
 - private static int numberOfPorts _ = 2 ; 
 - private static int threadCount _ = 4 ; 
 - 
 - public static int getMessagingThreadCount ( ) 
 - { 
 - return threadCount _ ; 
 - } 
 - 
 - public static void setMessagingThreadCount ( int threadCount ) 
 - { 
 - threadCount _ = threadCount ; 
 - } 
 - 
 - public static void setExpectedRoundTripTime ( int roundTripTimeMillis ) { 
 - 	 if ( roundTripTimeMillis > 0 ) 
 - 	 	 expectedRoundTripTime _ = roundTripTimeMillis ; 
 - } 
 - 
 - public static int getExpectedRoundTripTime ( ) 
 - { 
 - return expectedRoundTripTime _ ; 
 - } 
 - 
 - public static int getConnectionPoolInitialSize ( ) 
 - { 
 - return ConnectionPoolConfiguration . initialSize _ ; 
 - } 
 - 
 - public static int getConnectionPoolGrowthFactor ( ) 
 - { 
 - return ConnectionPoolConfiguration . growthFactor _ ; 
 - } 
 - 
 - public static int getConnectionPoolMaxSize ( ) 
 - { 
 - return ConnectionPoolConfiguration . maxSize _ ; 
 - } 
 - 
 - public static int getConnectionPoolWaitTimeout ( ) 
 - { 
 - return ConnectionPoolConfiguration . waitTimeout _ ; 
 - } 
 - 
 - public static int getConnectionPoolMonitorInterval ( ) 
 - { 
 - return ConnectionPoolConfiguration . monitorInterval _ ; 
 - } 
 - 
 - public static void setNumberOfPorts ( int n ) 
 - { 
 - numberOfPorts _ = n ; 
 - } 
 - 
 - public static int getNumberOfPorts ( ) 
 - { 
 - return numberOfPorts _ ; 
 - } 
 - } 
 - 
 - class ConnectionPoolConfiguration 
 - { 
 - public static int initialSize _ = 1 ; 
 - public static int growthFactor _ = 1 ; 
 - public static int maxSize _ = 1 ; 
 - public static int waitTimeout _ = 10 ; 
 - public static int monitorInterval _ = 300 ; 
 - } 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 20a0d2b . . 6fbe9e0 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 91 , 6 + 91 , 8 @ @ public class MessagingService implements IMessagingService 
 
 private static IMessagingService messagingService _ = new MessagingService ( ) ; 
 
 + private static final int MESSAGE _ DESERIALIZE _ THREADS = 4 ; 
 + 
 public static int getVersion ( ) 
 { 
 return version _ ; 
 @ @ - 137 , 7 + 139 , 7 @ @ public class MessagingService implements IMessagingService 
 * which is the sum of the threads in the pool that adds shit into the table and the 
 * pool that retrives the callback from here . 
 * / 
 - int maxSize = MessagingConfig . getMessagingThreadCount ( ) ; 
 + int maxSize = MESSAGE _ DESERIALIZE _ THREADS ; 
 callbackMap _ = new Cachetable < String , IAsyncCallback > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; 
 taskCompletionMap _ = new Cachetable < String , IAsyncResult > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; 
 
 @ @ - 185 , 7 + 187 , 7 @ @ public class MessagingService implements IMessagingService 
 public void listen ( InetAddress localEp ) throws IOException 
 { 
 ServerSocketChannel serverChannel = ServerSocketChannel . open ( ) ; 
 - ServerSocket ss = serverChannel . socket ( ) ; 
 + ServerSocket ss = serverChannel . socket ( ) ; 
 ss . bind ( new InetSocketAddress ( localEp , DatabaseDescriptor . getStoragePort ( ) ) ) ; 
 serverChannel . configureBlocking ( false ) ; 
 
 @ @ - 224 , 9 + 226 , 7 @ @ public class MessagingService implements IMessagingService 
 cp = poolTable _ . get ( key ) ; 
 if ( cp = = null ) 
 { 
 - cp = new TcpConnectionManager ( MessagingConfig . getConnectionPoolInitialSize ( ) , 
 - MessagingConfig . getConnectionPoolGrowthFactor ( ) , 
 - MessagingConfig . getConnectionPoolMaxSize ( ) , from , to ) ; 
 + cp = new TcpConnectionManager ( from , to ) ; 
 poolTable _ . put ( key , cp ) ; 
 } 
 } 
 @ @ - 238 , 9 + 238 , 9 @ @ public class MessagingService implements IMessagingService 
 return cp ; 
 } 
 
 - public static TcpConnection getConnection ( InetAddress from , InetAddress to ) throws IOException 
 + public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException 
 { 
 - return getConnectionPool ( from , to ) . getConnection ( ) ; 
 + return getConnectionPool ( from , to ) . getConnection ( msg ) ; 
 } 
 
 private void checkForReservedVerb ( String type ) 
 @ @ - 324 , 14 + 324 , 14 @ @ public class MessagingService implements IMessagingService 
 Use this version for fire and forget style messaging . 
 * / 
 public void sendOneWay ( Message message , InetAddress to ) 
 - { 
 - / / do local deliveries 
 + { 
 + / / do local deliveries 
 if ( message . getFrom ( ) . equals ( to ) ) 
 - { 
 + { 
 MessagingService . receive ( message ) ; 
 return ; 
 } 
 - 
 + 
 TcpConnection connection = null ; 
 try 
 { 
 @ @ - 340 , 7 + 340 , 7 @ @ public class MessagingService implements IMessagingService 
 { 
 return ; 
 } 
 - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; 
 + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 connection . write ( message ) ; 
 } 
 catch ( SocketException se ) 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java 
 index 83c534b . . ea780a9 100644 
 - - - a / src / java / org / apache / cassandra / net / TcpConnection . java 
 + + + b / src / java / org / apache / cassandra / net / TcpConnection . java 
 @ @ - 67 , 14 + 67 , 12 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 private boolean bStream _ = false ; 
 private Lock lock _ ; 
 private Condition condition _ ; 
 - 
 - / / used from getConnection - outgoing 
 - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 - { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - pool _ = pool ; 
 - 
 + 
 + private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException 
 + { 
 + socketChannel _ = SocketChannel . open ( ) ; 
 + socketChannel _ . configureBlocking ( false ) ; 
 + 
 localEp _ = from ; 
 remoteEp _ = to ; 
 
 @ @ - 86 , 6 + 84 , 24 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 { 
 key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 } 
 + 
 + if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) 
 + throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; 
 + 
 + if ( pool ! = null ) 
 + pool _ = pool ; 
 + if ( streaming ) 
 + { 
 + bStream _ = true ; 
 + lock _ = new ReentrantLock ( ) ; 
 + condition _ = lock _ . newCondition ( ) ; 
 + } 
 + } 
 + 
 + / / used from getConnection - outgoing 
 + TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 + { 
 + this ( from , to , pool , false ) ; 
 } 
 
 / * 
 @ @ - 93 , 23 + 109 , 7 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 * / 
 TcpConnection ( InetAddress from , InetAddress to ) throws IOException 
 { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - 
 - localEp _ = from ; 
 - remoteEp _ = to ; 
 - 
 - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; 
 - } 
 - else 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 - } 
 - bStream _ = true ; 
 - lock _ = new ReentrantLock ( ) ; 
 - condition _ = lock _ . newCondition ( ) ; 
 + this ( from , to , null , true ) ; 
 } 
 
 / * 
 @ @ - 135 , 27 + 135 , 13 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 isIncoming _ = isIncoming ; 
 localEp _ = localEp ; 
 } 
 - 
 - InetAddress getLocalEp ( ) 
 - { 
 - return localEp _ ; 
 - } 
 - 
 - public void setLocalEp ( InetAddress localEp ) 
 - { 
 - localEp _ = localEp ; 
 - } 
 + 
 
 public InetAddress getEndPoint ( ) 
 { 
 return remoteEp _ ; 
 } 
 - 
 - public boolean isIncoming ( ) 
 - { 
 - return isIncoming _ ; 
 - } 
 - 
 + 
 public SocketChannel getSocketChannel ( ) 
 { 
 return socketChannel _ ; 
 @ @ - 274 , 8 + 260 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 public void close ( ) 
 { 
 inUse _ = false ; 
 - if ( pool _ . contains ( this ) ) 
 - pool _ . decUsed ( ) ; 
 } 
 
 public boolean isConnected ( ) 
 @ @ - 305 , 10 + 289 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 void closeSocket ( ) 
 { 
 logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; 
 - if ( pool _ ! = null ) 
 - { 
 - pool _ . removeConnection ( this ) ; 
 - } 
 cancel ( key _ ) ; 
 pendingWrites _ . clear ( ) ; 
 } 
 @ @ - 318 , 11 + 298 , 8 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 logger _ . warn ( " Closing down connection " + socketChannel _ ) ; 
 pendingWrites _ . clear ( ) ; 
 cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - if ( pool _ ! = null ) 
 - { 
 - pool _ . removeConnection ( this ) ; 
 - } 
 + pendingWrites _ . clear ( ) ; 
 + pool _ . destroy ( this ) ; 
 } 
 
 private void cancel ( SelectionKey key ) 
 @ @ - 456 , 9 + 433 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 if ( remoteEp _ = = null ) 
 { 
 remoteEp _ = socketChannel _ . socket ( ) . getInetAddress ( ) ; 
 - / / put connection into pool if possible 
 - pool _ = MessagingService . getConnectionPool ( localEp _ , remoteEp _ ) ; 
 - pool _ . addToPool ( TcpConnection . this ) ; 
 } 
 
 / * Deserialize and handle the message * / 
 @ @ - 497 , 11 + 471 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 } 
 } 
 
 - public int pending ( ) 
 - { 
 - return pendingWrites _ . size ( ) ; 
 - } 
 - 
 public int compareTo ( Object o ) 
 { 
 if ( o instanceof TcpConnection ) 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 index 7cbbde3 . . 4485435 100644 
 - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 + + + b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 @ @ - 27 , 205 + 27 , 61 @ @ import org . apache . log4j . Logger ; 
 
 class TcpConnectionManager 
 { 
 - private Lock lock _ = new ReentrantLock ( ) ; 
 - private List < TcpConnection > allConnections _ ; 
 private InetAddress localEp _ ; 
 private InetAddress remoteEp _ ; 
 - private int maxSize _ ; 
 + private TcpConnection cmdCon ; 
 + private TcpConnection ackCon ; 
 
 - private int inUse _ ; 
 - 
 - / / TODO ! this whole thing is a giant no - op , since " contains " only relies on TcpConnection . equals , which 
 - / / is true for any ( local , remote ) pairs . So there is only ever at most one TcpConnection per Manager ! 
 - TcpConnectionManager ( int initialSize , int growthFactor , int maxSize , InetAddress localEp , InetAddress remoteEp ) 
 + TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) 
 { 
 - maxSize _ = maxSize ; 
 localEp _ = localEp ; 
 remoteEp _ = remoteEp ; 
 - allConnections _ = new ArrayList < TcpConnection > ( ) ; 
 - } 
 - 
 - / * * 
 - * returns the least loaded connection to remoteEp , creating a new connection if necessary 
 - * / 
 - TcpConnection getConnection ( ) throws IOException 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - if ( allConnections _ . isEmpty ( ) ) 
 - { 
 - TcpConnection conn = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - addToPool ( conn ) ; 
 - conn . inUse _ = true ; 
 - incUsed ( ) ; 
 - return conn ; 
 - } 
 - 
 - TcpConnection least = getLeastLoaded ( ) ; 
 - 
 - if ( ( least ! = null & & least . pending ( ) = = 0 ) | | allConnections _ . size ( ) = = maxSize _ ) 
 - { 
 - least . inUse _ = true ; 
 - incUsed ( ) ; 
 - return least ; 
 - } 
 - 
 - TcpConnection connection = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - if ( ! contains ( connection ) ) 
 - { 
 - addToPool ( connection ) ; 
 - connection . inUse _ = true ; 
 - incUsed ( ) ; 
 - return connection ; 
 - } 
 - else 
 - { 
 - connection . closeSocket ( ) ; 
 - return getLeastLoaded ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - protected TcpConnection getLeastLoaded ( ) 
 - { 
 - TcpConnection connection = null ; 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - Collections . sort ( allConnections _ ) ; 
 - connection = ( allConnections _ . size ( ) > 0 ) ? allConnections _ . get ( 0 ) : null ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - return connection ; 
 - } 
 - 
 - void removeConnection ( TcpConnection connection ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - allConnections _ . remove ( connection ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - void incUsed ( ) 
 - { 
 - inUse _ + + ; 
 } 
 
 - void decUsed ( ) 
 + private TcpConnection newCon ( ) throws IOException 
 { 
 - inUse _ - - ; 
 + TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 + con . inUse _ = true ; 
 + return con ; 
 } 
 
 - int getConnectionsInUse ( ) 
 - { 
 - return inUse _ ; 
 - } 
 - 
 - void addToPool ( TcpConnection connection ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - if ( contains ( connection ) ) 
 - return ; 
 - 
 - if ( allConnections _ . size ( ) < maxSize _ ) 
 - { 
 - allConnections _ . add ( connection ) ; 
 - } 
 - else 
 - { 
 - connection . closeSocket ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - void shutdown ( ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - while ( allConnections _ . size ( ) > 0 ) 
 - { 
 - TcpConnection connection = allConnections _ . remove ( 0 ) ; 
 - connection . closeSocket ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - int getPoolSize ( ) 
 + / * * 
 + * returns the appropriate connection based on message type . 
 + * / 
 + synchronized TcpConnection getConnection ( Message msg ) throws IOException 
 { 
 - lock _ . lock ( ) ; 
 - try 
 + if ( MessagingService . responseStage _ . equals ( msg . getMessageType ( ) ) ) 
 { 
 - return allConnections _ . size ( ) ; 
 + if ( ackCon = = null ) 
 + ackCon = newCon ( ) ; 
 + return ackCon ; 
 } 
 - finally 
 + else 
 { 
 - lock _ . unlock ( ) ; 
 + if ( cmdCon = = null ) 
 + cmdCon = newCon ( ) ; 
 + return cmdCon ; 
 } 
 } 
 
 - InetAddress getLocalEndPoint ( ) 
 - { 
 - return localEp _ ; 
 - } 
 - 
 - InetAddress getRemoteEndPoint ( ) 
 + synchronized void shutdown ( ) 
 { 
 - return remoteEp _ ; 
 - } 
 - 
 - int getPendingWrites ( ) 
 - { 
 - int total = 0 ; 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - for ( TcpConnection connection : allConnections _ ) 
 - { 
 - total + = connection . pending ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - return total ; 
 + for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) 
 + if ( con ! = null ) 
 + con . closeSocket ( ) ; 
 } 
 
 - boolean contains ( TcpConnection connection ) 
 + synchronized void destroy ( TcpConnection con ) 
 { 
 - lock _ . lock ( ) ; 
 - try 
 + assert con ! = null ; 
 + if ( cmdCon = = con ) 
 { 
 - return allConnections _ . contains ( connection ) ; 
 + cmdCon = null ; 
 } 
 - finally 
 + else 
 { 
 - lock _ . unlock ( ) ; 
 + assert ackCon = = con ; 
 + ackCon = null ; 
 } 
 } 
 }
