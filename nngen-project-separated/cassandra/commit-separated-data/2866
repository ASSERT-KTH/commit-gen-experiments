BLEU SCORE: 0.0114347838903095

TEST MSG: src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java
GENERATED MSG: Throw IRE if a prepared query has more markers than supported

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java b / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java <nl> index 3dda264 . . 76d8026 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java <nl> @ @ - 187 , 10 + 187 , 11 @ @ public class CqlStorage extends AbstractCassandraStorage <nl> { <nl> / / standard <nl> Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; <nl> - if ( validators . get ( col . name ( ) ) = = null ) <nl> + ByteBuffer cellName = col . name ( ) . toByteBuffer ( ) ; <nl> + if ( validators . get ( cellName ) = = null ) <nl> return cassandraToObj ( getDefaultMarshallers ( cfDef ) . get ( MarshallerType . DEFAULT _ VALIDATOR ) , col . value ( ) ) ; <nl> else <nl> - return cassandraToObj ( validators . get ( col . name ( ) ) , col . value ( ) ) ; <nl> + return cassandraToObj ( validators . get ( cellName ) , col . value ( ) ) ; <nl> } <nl> <nl> / * * set read configuration settings * /
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index ccc15ab . . 86bb7b4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 873 , 7 + 873 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> / * <nl> - This is complicated because we need to preserve deleted columns , supercolumns , and columnfamilies <nl> + This is complicated because we need to preserve deleted columns and columnfamilies <nl> until they have been deleted for at least GC _ GRACE _ IN _ SECONDS . But , we do not need to preserve <nl> their contents ; just the object itself as a " tombstone " that can be used to repair other <nl> replicas that do not know about the deletion . <nl> @ @ - 885 , 16 + 885 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return null ; <nl> } <nl> <nl> - removeDeletedColumnsOnly ( cf , gcBefore , indexer ) ; <nl> - return removeDeletedCF ( cf , gcBefore ) ; <nl> - } <nl> - <nl> - private static long removeDeletedColumnsOnly ( ColumnFamily cf , int gcBefore , SecondaryIndexManager . Updater indexer ) <nl> - { <nl> Iterator < Column > iter = cf . iterator ( ) ; <nl> DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; <nl> boolean hasDroppedColumns = ! cf . metadata . getDroppedColumns ( ) . isEmpty ( ) ; <nl> - long removedBytes = 0 ; <nl> while ( iter . hasNext ( ) ) <nl> { <nl> Column c = iter . next ( ) ; <nl> @ @ - 906 , 15 + 899 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> iter . remove ( ) ; <nl> indexer . remove ( c ) ; <nl> - removedBytes + = c . dataSize ( ) ; <nl> } <nl> } <nl> - return removedBytes ; <nl> - } <nl> <nl> - public static long removeDeletedColumnsOnly ( ColumnFamily cf , int gcBefore ) <nl> - { <nl> - return removeDeletedColumnsOnly ( cf , gcBefore , SecondaryIndexManager . nullUpdater ) ; <nl> + return removeDeletedCF ( cf , gcBefore ) ; <nl> } <nl> <nl> / / returns true if <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnIndex . java b / src / java / org / apache / cassandra / db / ColumnIndex . java <nl> index 6dd2028 . . 8729238 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnIndex . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnIndex . java <nl> @ @ - 119 , 18 + 119 , 25 @ @ public class ColumnIndex <nl> public ColumnIndex build ( ColumnFamily cf ) throws IOException <nl> { <nl> / / cf has disentangled the columns and range tombstones , we need to re - interleave them in comparator order <nl> + Comparator < ByteBuffer > comparator = cf . getComparator ( ) ; <nl> + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( ) ; <nl> Iterator < RangeTombstone > rangeIter = cf . deletionInfo ( ) . rangeIterator ( ) ; <nl> RangeTombstone tombstone = rangeIter . hasNext ( ) ? rangeIter . next ( ) : null ; <nl> - Comparator < ByteBuffer > comparator = cf . getComparator ( ) ; <nl> <nl> for ( Column c : cf ) <nl> { <nl> while ( tombstone ! = null & & comparator . compare ( c . name ( ) , tombstone . min ) > = 0 ) <nl> { <nl> - add ( tombstone ) ; <nl> + / / skip range tombstones that are shadowed by partition tombstones <nl> + if ( ! cf . deletionInfo ( ) . getTopLevelDeletion ( ) . isDeleted ( tombstone ) ) <nl> + add ( tombstone ) ; <nl> tombstone = rangeIter . hasNext ( ) ? rangeIter . next ( ) : null ; <nl> } <nl> - add ( c ) ; <nl> + <nl> + / / We can skip any cell if it ' s shadowed by a tombstone already . This is a more <nl> + / / general case than was handled by CASSANDRA - 2589 . <nl> + if ( ! tester . isDeleted ( c ) ) <nl> + add ( c ) ; <nl> } <nl> <nl> while ( tombstone ! = null ) <nl> @ @ - 158 , 9 + 165 , 8 @ @ public class ColumnIndex <nl> OnDiskAtom c = columns . next ( ) ; <nl> add ( c ) ; <nl> } <nl> - ColumnIndex index = build ( ) ; <nl> <nl> - return index ; <nl> + return build ( ) ; <nl> } <nl> <nl> public void add ( OnDiskAtom column ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / db / DeletionTime . java b / src / java / org / apache / cassandra / db / DeletionTime . java <nl> index 3d6fad4 . . 79244a6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DeletionTime . java <nl> + + + b / src / java / org / apache / cassandra / db / DeletionTime . java <nl> @ @ - 83 , 9 + 83 , 9 @ @ public class DeletionTime implements Comparable < DeletionTime > <nl> return localDeletionTime < gcBefore ; <nl> } <nl> <nl> - public boolean isDeleted ( Column column ) <nl> + public boolean isDeleted ( OnDiskAtom atom ) <nl> { <nl> - return column . timestamp ( ) < = markedForDeleteAt ; <nl> + return atom . maxTimestamp ( ) < = markedForDeleteAt ; <nl> } <nl> <nl> public long memorySize ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java <nl> index 6819cda . . 064851a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / java / org / apache / cassandra / db / Memtable . java <nl> @ @ - 351 , 16 + 351 , 6 @ @ public class Memtable <nl> / / See CASSANDRA - 4667 . <nl> if ( cfs . name . equals ( SystemKeyspace . BATCHLOG _ CF ) & & cfs . keyspace . getName ( ) . equals ( Keyspace . SYSTEM _ KS ) & & ! ( cf . getColumnCount ( ) = = 0 ) ) <nl> continue ; <nl> - <nl> - / / Pedantically , you could purge column level tombstones that are past GcGRace when writing to the SSTable . <nl> - / / But it can result in unexpected behaviour where deletes never make it to disk , <nl> - / / as they are lost and so cannot override existing column values . So we only remove deleted columns if there <nl> - / / is a CF level tombstone to ensure the delete makes it into an SSTable . <nl> - / / We also shouldn ' t be dropping any columns obsoleted by partition and / or range tombstones in case <nl> - / / the table has secondary indexes , or else the stale entries wouldn ' t be cleaned up during compaction , <nl> - / / and will only be dropped during 2i query read - repair , if at all . <nl> - if ( ! cfs . indexManager . hasIndexes ( ) ) <nl> - currentSize . addAndGet ( - ColumnFamilyStore . removeDeletedColumnsOnly ( cf , Integer . MIN _ VALUE ) ) ; <nl> } <nl> <nl> if ( cf . getColumnCount ( ) > 0 | | cf . isMarkedForDelete ( ) )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java b / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java 
 index 3dda264 . . 76d8026 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java 
 + + + b / src / java / org / apache / cassandra / hadoop / pig / CqlStorage . java 
 @ @ - 187 , 10 + 187 , 11 @ @ public class CqlStorage extends AbstractCassandraStorage 
 { 
 / / standard 
 Map < ByteBuffer , AbstractType > validators = getValidatorMap ( cfDef ) ; 
 - if ( validators . get ( col . name ( ) ) = = null ) 
 + ByteBuffer cellName = col . name ( ) . toByteBuffer ( ) ; 
 + if ( validators . get ( cellName ) = = null ) 
 return cassandraToObj ( getDefaultMarshallers ( cfDef ) . get ( MarshallerType . DEFAULT _ VALIDATOR ) , col . value ( ) ) ; 
 else 
 - return cassandraToObj ( validators . get ( col . name ( ) ) , col . value ( ) ) ; 
 + return cassandraToObj ( validators . get ( cellName ) , col . value ( ) ) ; 
 } 
 
 / * * set read configuration settings * /

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index ccc15ab . . 86bb7b4 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 873 , 7 + 873 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 / * 
 - This is complicated because we need to preserve deleted columns , supercolumns , and columnfamilies 
 + This is complicated because we need to preserve deleted columns and columnfamilies 
 until they have been deleted for at least GC _ GRACE _ IN _ SECONDS . But , we do not need to preserve 
 their contents ; just the object itself as a " tombstone " that can be used to repair other 
 replicas that do not know about the deletion . 
 @ @ - 885 , 16 + 885 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return null ; 
 } 
 
 - removeDeletedColumnsOnly ( cf , gcBefore , indexer ) ; 
 - return removeDeletedCF ( cf , gcBefore ) ; 
 - } 
 - 
 - private static long removeDeletedColumnsOnly ( ColumnFamily cf , int gcBefore , SecondaryIndexManager . Updater indexer ) 
 - { 
 Iterator < Column > iter = cf . iterator ( ) ; 
 DeletionInfo . InOrderTester tester = cf . inOrderDeletionTester ( ) ; 
 boolean hasDroppedColumns = ! cf . metadata . getDroppedColumns ( ) . isEmpty ( ) ; 
 - long removedBytes = 0 ; 
 while ( iter . hasNext ( ) ) 
 { 
 Column c = iter . next ( ) ; 
 @ @ - 906 , 15 + 899 , 10 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 iter . remove ( ) ; 
 indexer . remove ( c ) ; 
 - removedBytes + = c . dataSize ( ) ; 
 } 
 } 
 - return removedBytes ; 
 - } 
 
 - public static long removeDeletedColumnsOnly ( ColumnFamily cf , int gcBefore ) 
 - { 
 - return removeDeletedColumnsOnly ( cf , gcBefore , SecondaryIndexManager . nullUpdater ) ; 
 + return removeDeletedCF ( cf , gcBefore ) ; 
 } 
 
 / / returns true if 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnIndex . java b / src / java / org / apache / cassandra / db / ColumnIndex . java 
 index 6dd2028 . . 8729238 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnIndex . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnIndex . java 
 @ @ - 119 , 18 + 119 , 25 @ @ public class ColumnIndex 
 public ColumnIndex build ( ColumnFamily cf ) throws IOException 
 { 
 / / cf has disentangled the columns and range tombstones , we need to re - interleave them in comparator order 
 + Comparator < ByteBuffer > comparator = cf . getComparator ( ) ; 
 + DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( ) ; 
 Iterator < RangeTombstone > rangeIter = cf . deletionInfo ( ) . rangeIterator ( ) ; 
 RangeTombstone tombstone = rangeIter . hasNext ( ) ? rangeIter . next ( ) : null ; 
 - Comparator < ByteBuffer > comparator = cf . getComparator ( ) ; 
 
 for ( Column c : cf ) 
 { 
 while ( tombstone ! = null & & comparator . compare ( c . name ( ) , tombstone . min ) > = 0 ) 
 { 
 - add ( tombstone ) ; 
 + / / skip range tombstones that are shadowed by partition tombstones 
 + if ( ! cf . deletionInfo ( ) . getTopLevelDeletion ( ) . isDeleted ( tombstone ) ) 
 + add ( tombstone ) ; 
 tombstone = rangeIter . hasNext ( ) ? rangeIter . next ( ) : null ; 
 } 
 - add ( c ) ; 
 + 
 + / / We can skip any cell if it ' s shadowed by a tombstone already . This is a more 
 + / / general case than was handled by CASSANDRA - 2589 . 
 + if ( ! tester . isDeleted ( c ) ) 
 + add ( c ) ; 
 } 
 
 while ( tombstone ! = null ) 
 @ @ - 158 , 9 + 165 , 8 @ @ public class ColumnIndex 
 OnDiskAtom c = columns . next ( ) ; 
 add ( c ) ; 
 } 
 - ColumnIndex index = build ( ) ; 
 
 - return index ; 
 + return build ( ) ; 
 } 
 
 public void add ( OnDiskAtom column ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / db / DeletionTime . java b / src / java / org / apache / cassandra / db / DeletionTime . java 
 index 3d6fad4 . . 79244a6 100644 
 - - - a / src / java / org / apache / cassandra / db / DeletionTime . java 
 + + + b / src / java / org / apache / cassandra / db / DeletionTime . java 
 @ @ - 83 , 9 + 83 , 9 @ @ public class DeletionTime implements Comparable < DeletionTime > 
 return localDeletionTime < gcBefore ; 
 } 
 
 - public boolean isDeleted ( Column column ) 
 + public boolean isDeleted ( OnDiskAtom atom ) 
 { 
 - return column . timestamp ( ) < = markedForDeleteAt ; 
 + return atom . maxTimestamp ( ) < = markedForDeleteAt ; 
 } 
 
 public long memorySize ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java 
 index 6819cda . . 064851a 100644 
 - - - a / src / java / org / apache / cassandra / db / Memtable . java 
 + + + b / src / java / org / apache / cassandra / db / Memtable . java 
 @ @ - 351 , 16 + 351 , 6 @ @ public class Memtable 
 / / See CASSANDRA - 4667 . 
 if ( cfs . name . equals ( SystemKeyspace . BATCHLOG _ CF ) & & cfs . keyspace . getName ( ) . equals ( Keyspace . SYSTEM _ KS ) & & ! ( cf . getColumnCount ( ) = = 0 ) ) 
 continue ; 
 - 
 - / / Pedantically , you could purge column level tombstones that are past GcGRace when writing to the SSTable . 
 - / / But it can result in unexpected behaviour where deletes never make it to disk , 
 - / / as they are lost and so cannot override existing column values . So we only remove deleted columns if there 
 - / / is a CF level tombstone to ensure the delete makes it into an SSTable . 
 - / / We also shouldn ' t be dropping any columns obsoleted by partition and / or range tombstones in case 
 - / / the table has secondary indexes , or else the stale entries wouldn ' t be cleaned up during compaction , 
 - / / and will only be dropped during 2i query read - repair , if at all . 
 - if ( ! cfs . indexManager . hasIndexes ( ) ) 
 - currentSize . addAndGet ( - ColumnFamilyStore . removeDeletedColumnsOnly ( cf , Integer . MIN _ VALUE ) ) ; 
 } 
 
 if ( cf . getColumnCount ( ) > 0 | | cf . isMarkedForDelete ( ) )
