BLEU SCORE: 0.03283637368030199

TEST MSG: Make batchlog replica selection rack - aware
GENERATED MSG: Add Google Compute Engine snitch .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9ab1a5f . . 5799659 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 5 @ @ <nl> 2 . 0 . 8 <nl> - = = = = = = = <nl> + * Make batchlog replica selection rack - aware ( CASSANDRA - 6551 ) <nl> * Add Google Compute Engine snitch ( CASSANDRA - 7132 ) <nl> * Allow overriding cassandra - rackdc . properties file ( CASSANDRA - 7072 ) <nl> * Set JMX RMI port to 7199 ( CASSANDRA - 7087 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java b / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java <nl> new file mode 100644 <nl> index 0000000 . . bf032f5 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java <nl> @ @ - 0 , 0 + 1 , 110 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . service ; <nl> + <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + <nl> + import org . apache . cassandra . gms . FailureDetector ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Iterables ; <nl> + import com . google . common . collect . ListMultimap ; <nl> + import com . google . common . collect . Lists ; <nl> + import com . google . common . collect . Multimap ; <nl> + <nl> + public class BatchlogEndpointSelector <nl> + { <nl> + private final String localRack ; <nl> + <nl> + public BatchlogEndpointSelector ( String localRack ) <nl> + { <nl> + this . localRack = localRack ; <nl> + } <nl> + <nl> + / * * <nl> + * @ param endpoints nodes in the local datacenter , grouped by rack name <nl> + * @ return list of candidates for batchlog hosting . if possible these will be two nodes from different racks . <nl> + * / <nl> + public Collection < InetAddress > chooseEndpoints ( Multimap < String , InetAddress > endpoints ) <nl> + { <nl> + / / strip out dead endpoints and localhost <nl> + ListMultimap < String , InetAddress > validated = ArrayListMultimap . create ( ) ; <nl> + for ( Map . Entry < String , InetAddress > entry : endpoints . entries ( ) ) <nl> + { <nl> + if ( isValid ( entry . getValue ( ) ) ) <nl> + validated . put ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> + } <nl> + if ( validated . size ( ) < = 2 ) <nl> + return validated . values ( ) ; <nl> + <nl> + if ( ( validated . size ( ) - validated . get ( localRack ) . size ( ) ) > = 2 ) <nl> + { <nl> + / / we have enough endpoints in other racks <nl> + validated . removeAll ( localRack ) ; <nl> + } <nl> + <nl> + if ( validated . keySet ( ) . size ( ) = = 1 ) <nl> + { <nl> + / / we have only 1 ` other ` rack <nl> + Collection < InetAddress > otherRack = Iterables . getOnlyElement ( validated . asMap ( ) . values ( ) ) ; <nl> + return Lists . newArrayList ( Iterables . limit ( otherRack , 2 ) ) ; <nl> + } <nl> + <nl> + / / randomize which racks we pick from if more than 2 remaining <nl> + Collection < String > racks ; <nl> + if ( validated . keySet ( ) . size ( ) = = 2 ) <nl> + { <nl> + racks = validated . keySet ( ) ; <nl> + } <nl> + else <nl> + { <nl> + racks = Lists . newArrayList ( validated . keySet ( ) ) ; <nl> + Collections . shuffle ( ( List ) racks ) ; <nl> + } <nl> + <nl> + / / grab a random member of up to two racks <nl> + List < InetAddress > result = new ArrayList < > ( 2 ) ; <nl> + for ( String rack : Iterables . limit ( racks , 2 ) ) <nl> + { <nl> + List < InetAddress > rackMembers = validated . get ( rack ) ; <nl> + result . add ( rackMembers . get ( getRandomInt ( rackMembers . size ( ) ) ) ) ; <nl> + } <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + protected boolean isValid ( InetAddress input ) <nl> + { <nl> + return ! input . equals ( FBUtilities . getBroadcastAddress ( ) ) & & FailureDetector . instance . isAlive ( input ) ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + protected int getRandomInt ( int bound ) <nl> + { <nl> + return FBUtilities . threadLocalRandom ( ) . nextInt ( bound ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 14d5ee2 . . 2bf8e7f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import java . lang . management . ManagementFactory ; <nl> import java . net . InetAddress ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . Random ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import javax . management . MBeanServer ; <nl> @ @ - 729 , 24 + 728 , 14 @ @ public class StorageProxy implements StorageProxyMBean <nl> throws UnavailableException <nl> { <nl> TokenMetadata . Topology topology = StorageService . instance . getTokenMetadata ( ) . cachedOnlyTokenMap ( ) . getTopology ( ) ; <nl> - List < InetAddress > localEndpoints = new ArrayList < > ( topology . getDatacenterEndpoints ( ) . get ( localDataCenter ) ) ; <nl> - <nl> + Multimap < String , InetAddress > localEndpoints = HashMultimap . create ( topology . getDatacenterRacks ( ) . get ( localDataCenter ) ) ; <nl> + <nl> / / special case for single - node datacenters <nl> if ( localEndpoints . size ( ) = = 1 ) <nl> - return localEndpoints ; <nl> - <nl> - List < InetAddress > chosenEndpoints = new ArrayList < > ( 2 ) ; <nl> - int startOffset = new Random ( ) . nextInt ( localEndpoints . size ( ) ) ; <nl> + return localEndpoints . values ( ) ; <nl> <nl> - / / starts at some random point in the list , advances forward until the end , then loops <nl> - / / around to the beginning , advancing again until it is back at the starting point again . <nl> - for ( int i = 0 ; i < localEndpoints . size ( ) & & chosenEndpoints . size ( ) < 2 ; i + + ) <nl> - { <nl> - InetAddress endpoint = localEndpoints . get ( ( i + startOffset ) % localEndpoints . size ( ) ) ; <nl> - / / skip localhost and non - alive nodes <nl> - if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & FailureDetector . instance . isAlive ( endpoint ) ) <nl> - chosenEndpoints . add ( endpoint ) ; <nl> - } <nl> + String localRack = DatabaseDescriptor . getEndpointSnitch ( ) . getRack ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + Collection < InetAddress > chosenEndpoints = new BatchlogEndpointSelector ( localRack ) . chooseEndpoints ( localEndpoints ) ; <nl> <nl> if ( chosenEndpoints . isEmpty ( ) ) <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java b / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java <nl> new file mode 100644 <nl> index 0000000 . . 293078d <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java <nl> @ @ - 0 , 0 + 1 , 116 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import static org . hamcrest . CoreMatchers . is ; <nl> + import static org . junit . Assert . assertThat ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . Collection ; <nl> + <nl> + import org . junit . Test ; <nl> + import org . junit . matchers . JUnitMatchers ; <nl> + <nl> + import com . google . common . collect . ImmutableMultimap ; <nl> + import com . google . common . collect . Multimap ; <nl> + <nl> + public class BatchlogEndpointSelectorTest <nl> + { <nl> + private final BatchlogEndpointSelector target ; <nl> + private static final String LOCAL = " local " ; <nl> + <nl> + <nl> + public BatchlogEndpointSelectorTest ( ) throws UnknownHostException <nl> + { <nl> + target = new BatchlogEndpointSelector ( LOCAL ) <nl> + { <nl> + @ Override <nl> + protected boolean isValid ( InetAddress input ) <nl> + { <nl> + / / we will use always alive non - localhost endpoints <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + protected int getRandomInt ( int bound ) <nl> + { <nl> + / / we don ' t need a random behavior here <nl> + return bound - 1 ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldSelect2hostsFromNonLocalRacks ( ) throws UnknownHostException <nl> + { <nl> + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 11 " ) ) <nl> + . put ( " 2 " , InetAddress . getByName ( " 2 " ) ) <nl> + . put ( " 2 " , InetAddress . getByName ( " 22 " ) ) <nl> + . build ( ) ; <nl> + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; <nl> + assertThat ( result . size ( ) , is ( 2 ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 11 " ) ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 22 " ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldSelectHostFromLocal ( ) throws UnknownHostException <nl> + { <nl> + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) <nl> + . build ( ) ; <nl> + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; <nl> + assertThat ( result . size ( ) , is ( 2 ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 1 " ) ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 0 " ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldReturnAsIsIfNoEnoughEndpoints ( ) throws UnknownHostException <nl> + { <nl> + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) <nl> + . build ( ) ; <nl> + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; <nl> + assertThat ( result . size ( ) , is ( 1 ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 0 " ) ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void shouldSelectTwoFirstHostsFromSingleOtherRack ( ) throws UnknownHostException <nl> + { <nl> + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) <nl> + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 11 " ) ) <nl> + . put ( " 1 " , InetAddress . getByName ( " 111 " ) ) <nl> + . build ( ) ; <nl> + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; <nl> + assertThat ( result . size ( ) , is ( 2 ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 1 " ) ) ) ; <nl> + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 11 " ) ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9ab1a5f . . 5799659 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 5 @ @ 
 2 . 0 . 8 
 - = = = = = = = 
 + * Make batchlog replica selection rack - aware ( CASSANDRA - 6551 ) 
 * Add Google Compute Engine snitch ( CASSANDRA - 7132 ) 
 * Allow overriding cassandra - rackdc . properties file ( CASSANDRA - 7072 ) 
 * Set JMX RMI port to 7199 ( CASSANDRA - 7087 ) 
 diff - - git a / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java b / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java 
 new file mode 100644 
 index 0000000 . . bf032f5 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / BatchlogEndpointSelector . java 
 @ @ - 0 , 0 + 1 , 110 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . service ; 
 + 
 + 
 + import java . net . InetAddress ; 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + 
 + import org . apache . cassandra . gms . FailureDetector ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Iterables ; 
 + import com . google . common . collect . ListMultimap ; 
 + import com . google . common . collect . Lists ; 
 + import com . google . common . collect . Multimap ; 
 + 
 + public class BatchlogEndpointSelector 
 + { 
 + private final String localRack ; 
 + 
 + public BatchlogEndpointSelector ( String localRack ) 
 + { 
 + this . localRack = localRack ; 
 + } 
 + 
 + / * * 
 + * @ param endpoints nodes in the local datacenter , grouped by rack name 
 + * @ return list of candidates for batchlog hosting . if possible these will be two nodes from different racks . 
 + * / 
 + public Collection < InetAddress > chooseEndpoints ( Multimap < String , InetAddress > endpoints ) 
 + { 
 + / / strip out dead endpoints and localhost 
 + ListMultimap < String , InetAddress > validated = ArrayListMultimap . create ( ) ; 
 + for ( Map . Entry < String , InetAddress > entry : endpoints . entries ( ) ) 
 + { 
 + if ( isValid ( entry . getValue ( ) ) ) 
 + validated . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 + } 
 + if ( validated . size ( ) < = 2 ) 
 + return validated . values ( ) ; 
 + 
 + if ( ( validated . size ( ) - validated . get ( localRack ) . size ( ) ) > = 2 ) 
 + { 
 + / / we have enough endpoints in other racks 
 + validated . removeAll ( localRack ) ; 
 + } 
 + 
 + if ( validated . keySet ( ) . size ( ) = = 1 ) 
 + { 
 + / / we have only 1 ` other ` rack 
 + Collection < InetAddress > otherRack = Iterables . getOnlyElement ( validated . asMap ( ) . values ( ) ) ; 
 + return Lists . newArrayList ( Iterables . limit ( otherRack , 2 ) ) ; 
 + } 
 + 
 + / / randomize which racks we pick from if more than 2 remaining 
 + Collection < String > racks ; 
 + if ( validated . keySet ( ) . size ( ) = = 2 ) 
 + { 
 + racks = validated . keySet ( ) ; 
 + } 
 + else 
 + { 
 + racks = Lists . newArrayList ( validated . keySet ( ) ) ; 
 + Collections . shuffle ( ( List ) racks ) ; 
 + } 
 + 
 + / / grab a random member of up to two racks 
 + List < InetAddress > result = new ArrayList < > ( 2 ) ; 
 + for ( String rack : Iterables . limit ( racks , 2 ) ) 
 + { 
 + List < InetAddress > rackMembers = validated . get ( rack ) ; 
 + result . add ( rackMembers . get ( getRandomInt ( rackMembers . size ( ) ) ) ) ; 
 + } 
 + 
 + return result ; 
 + } 
 + 
 + @ VisibleForTesting 
 + protected boolean isValid ( InetAddress input ) 
 + { 
 + return ! input . equals ( FBUtilities . getBroadcastAddress ( ) ) & & FailureDetector . instance . isAlive ( input ) ; 
 + } 
 + 
 + @ VisibleForTesting 
 + protected int getRandomInt ( int bound ) 
 + { 
 + return FBUtilities . threadLocalRandom ( ) . nextInt ( bound ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 14d5ee2 . . 2bf8e7f 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import java . lang . management . ManagementFactory ; 
 import java . net . InetAddress ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . Random ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import javax . management . MBeanServer ; 
 @ @ - 729 , 24 + 728 , 14 @ @ public class StorageProxy implements StorageProxyMBean 
 throws UnavailableException 
 { 
 TokenMetadata . Topology topology = StorageService . instance . getTokenMetadata ( ) . cachedOnlyTokenMap ( ) . getTopology ( ) ; 
 - List < InetAddress > localEndpoints = new ArrayList < > ( topology . getDatacenterEndpoints ( ) . get ( localDataCenter ) ) ; 
 - 
 + Multimap < String , InetAddress > localEndpoints = HashMultimap . create ( topology . getDatacenterRacks ( ) . get ( localDataCenter ) ) ; 
 + 
 / / special case for single - node datacenters 
 if ( localEndpoints . size ( ) = = 1 ) 
 - return localEndpoints ; 
 - 
 - List < InetAddress > chosenEndpoints = new ArrayList < > ( 2 ) ; 
 - int startOffset = new Random ( ) . nextInt ( localEndpoints . size ( ) ) ; 
 + return localEndpoints . values ( ) ; 
 
 - / / starts at some random point in the list , advances forward until the end , then loops 
 - / / around to the beginning , advancing again until it is back at the starting point again . 
 - for ( int i = 0 ; i < localEndpoints . size ( ) & & chosenEndpoints . size ( ) < 2 ; i + + ) 
 - { 
 - InetAddress endpoint = localEndpoints . get ( ( i + startOffset ) % localEndpoints . size ( ) ) ; 
 - / / skip localhost and non - alive nodes 
 - if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & FailureDetector . instance . isAlive ( endpoint ) ) 
 - chosenEndpoints . add ( endpoint ) ; 
 - } 
 + String localRack = DatabaseDescriptor . getEndpointSnitch ( ) . getRack ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + Collection < InetAddress > chosenEndpoints = new BatchlogEndpointSelector ( localRack ) . chooseEndpoints ( localEndpoints ) ; 
 
 if ( chosenEndpoints . isEmpty ( ) ) 
 { 
 diff - - git a / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java b / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java 
 new file mode 100644 
 index 0000000 . . 293078d 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / service / BatchlogEndpointSelectorTest . java 
 @ @ - 0 , 0 + 1 , 116 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . service ; 
 + 
 + import static org . hamcrest . CoreMatchers . is ; 
 + import static org . junit . Assert . assertThat ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . Collection ; 
 + 
 + import org . junit . Test ; 
 + import org . junit . matchers . JUnitMatchers ; 
 + 
 + import com . google . common . collect . ImmutableMultimap ; 
 + import com . google . common . collect . Multimap ; 
 + 
 + public class BatchlogEndpointSelectorTest 
 + { 
 + private final BatchlogEndpointSelector target ; 
 + private static final String LOCAL = " local " ; 
 + 
 + 
 + public BatchlogEndpointSelectorTest ( ) throws UnknownHostException 
 + { 
 + target = new BatchlogEndpointSelector ( LOCAL ) 
 + { 
 + @ Override 
 + protected boolean isValid ( InetAddress input ) 
 + { 
 + / / we will use always alive non - localhost endpoints 
 + return true ; 
 + } 
 + 
 + @ Override 
 + protected int getRandomInt ( int bound ) 
 + { 
 + / / we don ' t need a random behavior here 
 + return bound - 1 ; 
 + } 
 + } ; 
 + } 
 + 
 + @ Test 
 + public void shouldSelect2hostsFromNonLocalRacks ( ) throws UnknownHostException 
 + { 
 + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) 
 + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) 
 + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 11 " ) ) 
 + . put ( " 2 " , InetAddress . getByName ( " 2 " ) ) 
 + . put ( " 2 " , InetAddress . getByName ( " 22 " ) ) 
 + . build ( ) ; 
 + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; 
 + assertThat ( result . size ( ) , is ( 2 ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 11 " ) ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 22 " ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void shouldSelectHostFromLocal ( ) throws UnknownHostException 
 + { 
 + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) 
 + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) 
 + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) 
 + . build ( ) ; 
 + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; 
 + assertThat ( result . size ( ) , is ( 2 ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 1 " ) ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 0 " ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void shouldReturnAsIsIfNoEnoughEndpoints ( ) throws UnknownHostException 
 + { 
 + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) 
 + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) 
 + . build ( ) ; 
 + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; 
 + assertThat ( result . size ( ) , is ( 1 ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 0 " ) ) ) ; 
 + } 
 + 
 + @ Test 
 + public void shouldSelectTwoFirstHostsFromSingleOtherRack ( ) throws UnknownHostException 
 + { 
 + Multimap < String , InetAddress > endpoints = ImmutableMultimap . < String , InetAddress > builder ( ) 
 + . put ( LOCAL , InetAddress . getByName ( " 0 " ) ) 
 + . put ( LOCAL , InetAddress . getByName ( " 00 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 1 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 11 " ) ) 
 + . put ( " 1 " , InetAddress . getByName ( " 111 " ) ) 
 + . build ( ) ; 
 + Collection < InetAddress > result = target . chooseEndpoints ( endpoints ) ; 
 + assertThat ( result . size ( ) , is ( 2 ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 1 " ) ) ) ; 
 + assertThat ( result , JUnitMatchers . hasItem ( InetAddress . getByName ( " 11 " ) ) ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
