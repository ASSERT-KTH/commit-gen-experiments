BLEU SCORE: 0.05073552004225952

TEST MSG: Update error message in cqlsh test to match latest
GENERATED MSG: Ninja - fix test _ cqlsh _ output . py

TEST DIFF (one line): diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ output . py b / pylib / cqlshlib / test / test _ cqlsh _ output . py <nl> index baf72c1 . . 60ef3a4 100644 <nl> - - - a / pylib / cqlshlib / test / test _ cqlsh _ output . py <nl> + + + b / pylib / cqlshlib / test / test _ cqlsh _ output . py <nl> @ @ - 544 , 7 + 544 , 7 @ @ class TestCqlshOutput ( BaseTestCase ) : <nl> self . assertEqual ( outputlines [ 2 ] , ' cqlsh : system > ' ) <nl> midline = ColoredText ( outputlines [ 1 ] ) <nl> self . assertEqual ( midline . plain ( ) , <nl> - ' code = 2200 [ Invalid query ] message = " Keyspace \ ' nonexistentkeyspace \ ' does not exist " ' ) <nl> + ' InvalidRequest : code = 2200 [ Invalid query ] message = " Keyspace \ ' nonexistentkeyspace \ ' does not exist " ' ) <nl> self . assertColorFromTags ( midline , <nl> " RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR " ) <nl>
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0774d90 . . d880c4d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 <nl> + * Removed token range bisection ( CASSANDRA - 5518 ) <nl> * Removed compatibility with pre - 1 . 2 . 5 sstables and network messages <nl> ( CASSANDRA - 5511 ) <nl> * removed PBSPredictor ( CASSANDRA - 5455 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 1a1425c . . 1e86cab 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 20 , 6 + 20 , 10 @ @ Upgrading <nl> - Replication and strategy options do not accept unknown options anymore . <nl> This was already the case for CQL3 in 1 . 2 but this is now the case for <nl> thrift too . <nl> + - auto _ bootstrap of a single - token node with no initial _ token will <nl> + now pick a random token instead of bisecting an existing token <nl> + range . We recommend upgrading to vnodes ; failing that , we <nl> + recommend specifying initial _ token . <nl> - reduce _ cache _ sizes _ at , reduce _ cache _ capacity _ to , and <nl> flush _ largest _ memtables _ at options have been removed from cassandra . yaml . <nl> - CacheServiceMBean . reduceCacheSizes ( ) has been removed . <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index a1dfce8 . . f354b08 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 22 , 29 + 22 , 21 @ @ import java . io . DataOutput ; <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> import java . util . * ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . locks . Condition ; <nl> <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> - import org . apache . cassandra . config . Schema ; <nl> <nl> - import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . db . Table ; <nl> + import org . apache . cassandra . db . TypeSizes ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . gms . FailureDetector ; <nl> + import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> - import org . apache . cassandra . net . IAsyncCallback ; <nl> - import org . apache . cassandra . net . IVerbHandler ; <nl> - import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . streaming . OperationType ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . SimpleCondition ; <nl> - import org . apache . cassandra . db . TypeSizes ; <nl> - import org . apache . cassandra . gms . FailureDetector ; <nl> - import org . apache . cassandra . io . IVersionedSerializer ; <nl> - import org . apache . cassandra . net . * ; <nl> <nl> public class BootStrapper <nl> { <nl> @ @ - 111 , 8 + 103 , 9 @ @ public class BootStrapper <nl> int numTokens = DatabaseDescriptor . getNumTokens ( ) ; <nl> if ( numTokens < 1 ) <nl> throw new ConfigurationException ( " num _ tokens must be > = 1 " ) ; <nl> + <nl> if ( numTokens = = 1 ) <nl> - return Collections . singleton ( getBalancedToken ( metadata , load ) ) ; <nl> + logger . warn ( " Picking random token for a single vnode . You should probably add more vnodes ; failing that , you should probably specify the token manually " ) ; <nl> <nl> return getRandomTokens ( metadata , numTokens ) ; <nl> } <nl> @ @ - 129 , 124 + 122 , 6 @ @ public class BootStrapper <nl> return tokens ; <nl> } <nl> <nl> - @ Deprecated <nl> - public static Token getBalancedToken ( TokenMetadata metadata , Map < InetAddress , Double > load ) <nl> - { <nl> - InetAddress maxEndpoint = getBootstrapSource ( metadata , load ) ; <nl> - Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; <nl> - logger . info ( " New token will be " + t + " to assume load from " + maxEndpoint ) ; <nl> - return t ; <nl> - } <nl> - <nl> - @ Deprecated <nl> - static InetAddress getBootstrapSource ( final TokenMetadata metadata , final Map < InetAddress , Double > load ) <nl> - { <nl> - / / sort first by number of nodes already bootstrapping into a source node ' s range , then by load . <nl> - List < InetAddress > endpoints = new ArrayList < InetAddress > ( load . size ( ) ) ; <nl> - for ( InetAddress endpoint : load . keySet ( ) ) <nl> - { <nl> - if ( ! metadata . isMember ( endpoint ) | | ! FailureDetector . instance . isAlive ( endpoint ) ) <nl> - continue ; <nl> - endpoints . add ( endpoint ) ; <nl> - } <nl> - <nl> - if ( endpoints . isEmpty ( ) ) <nl> - throw new RuntimeException ( " No other nodes seen ! Unable to bootstrap . " <nl> - + " If you intended to start a single - node cluster , you should make sure " <nl> - + " your broadcast _ address ( or listen _ address ) is listed as a seed . " <nl> - + " Otherwise , you need to determine why the seed being contacted " <nl> - + " has no knowledge of the rest of the cluster . Usually , this can be solved " <nl> - + " by giving all nodes the same seed list . " ) ; <nl> - Collections . sort ( endpoints , new Comparator < InetAddress > ( ) <nl> - { <nl> - public int compare ( InetAddress ia1 , InetAddress ia2 ) <nl> - { <nl> - int n1 = metadata . pendingRangeChanges ( ia1 ) ; <nl> - int n2 = metadata . pendingRangeChanges ( ia2 ) ; <nl> - if ( n1 ! = n2 ) <nl> - return - ( n1 - n2 ) ; / / more targets = _ less _ priority ! <nl> - <nl> - double load1 = load . get ( ia1 ) ; <nl> - double load2 = load . get ( ia2 ) ; <nl> - if ( load1 = = load2 ) <nl> - return 0 ; <nl> - return load1 < load2 ? - 1 : 1 ; <nl> - } <nl> - } ) ; <nl> - <nl> - InetAddress maxEndpoint = endpoints . get ( endpoints . size ( ) - 1 ) ; <nl> - assert ! maxEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - if ( metadata . pendingRangeChanges ( maxEndpoint ) > 0 ) <nl> - throw new RuntimeException ( " Every node is a bootstrap source ! Please specify an initial token manually or wait for an existing bootstrap operation to finish . " ) ; <nl> - <nl> - return maxEndpoint ; <nl> - } <nl> - <nl> - @ Deprecated <nl> - static Token < ? > getBootstrapTokenFrom ( InetAddress maxEndpoint ) <nl> - { <nl> - MessageOut message = new MessageOut ( MessagingService . Verb . BOOTSTRAP _ TOKEN ) ; <nl> - int retries = 5 ; <nl> - long timeout = Math . max ( DatabaseDescriptor . getRpcTimeout ( ) , BOOTSTRAP _ TIMEOUT ) ; <nl> - <nl> - while ( retries > 0 ) <nl> - { <nl> - BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; <nl> - MessagingService . instance ( ) . sendRR ( message , maxEndpoint , btc , timeout ) ; <nl> - Token token = btc . getToken ( timeout ) ; <nl> - if ( token ! = null ) <nl> - return token ; <nl> - <nl> - retries - - ; <nl> - } <nl> - throw new RuntimeException ( " Bootstrap failed , could not obtain token from : " + maxEndpoint ) ; <nl> - } <nl> - <nl> - @ Deprecated <nl> - public static class BootstrapTokenVerbHandler implements IVerbHandler <nl> - { <nl> - public void doVerb ( MessageIn message , int id ) <nl> - { <nl> - StorageService ss = StorageService . instance ; <nl> - String tokenString = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toString ( ss . getBootstrapToken ( ) ) ; <nl> - MessageOut < String > response = new MessageOut < String > ( MessagingService . Verb . INTERNAL _ RESPONSE , tokenString , StringSerializer . instance ) ; <nl> - MessagingService . instance ( ) . sendReply ( response , id , message . from ) ; <nl> - } <nl> - } <nl> - <nl> - @ Deprecated <nl> - private static class BootstrapTokenCallback implements IAsyncCallback < String > <nl> - { <nl> - private volatile Token < ? > token ; <nl> - private final Condition condition = new SimpleCondition ( ) ; <nl> - <nl> - public Token < ? > getToken ( long timeout ) <nl> - { <nl> - boolean success ; <nl> - try <nl> - { <nl> - success = condition . await ( timeout , TimeUnit . MILLISECONDS ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - <nl> - return success ? token : null ; <nl> - } <nl> - <nl> - public void response ( MessageIn < String > msg ) <nl> - { <nl> - token = StorageService . getPartitioner ( ) . getTokenFactory ( ) . fromString ( msg . payload ) ; <nl> - condition . signalAll ( ) ; <nl> - } <nl> - <nl> - public boolean isLatencyForSnitch ( ) <nl> - { <nl> - return false ; <nl> - } <nl> - } <nl> - <nl> public static class StringSerializer implements IVersionedSerializer < String > <nl> { <nl> public static final StringSerializer instance = new StringSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 7314429 . . 5e1cc28 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 437 , 6 + 437 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> EndpointState epState = endpointStateMap . get ( endpoint ) ; <nl> Collection < Token > tokens = null ; <nl> logger . warn ( " Assassinating { } via gossip " , endpoint ) ; <nl> + <nl> if ( epState = = null ) <nl> { <nl> epState = new EndpointState ( new HeartBeatState ( ( int ) ( ( System . currentTimeMillis ( ) + 60000 ) / 1000 ) , 9999 ) ) ; <nl> @ @ - 447 , 19 + 448 , 15 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> { <nl> tokens = StorageService . instance . getTokenMetadata ( ) . getTokens ( endpoint ) ; <nl> } <nl> - catch ( AssertionError e ) <nl> + catch ( Throwable th ) <nl> { <nl> + / / TODO this is broken <nl> + logger . warn ( " Unable to calculate tokens for { } . Will use a random one " , address ) ; <nl> + tokens = Collections . singletonList ( StorageService . getPartitioner ( ) . getRandomToken ( ) ) ; <nl> } <nl> int generation = epState . getHeartBeatState ( ) . getGeneration ( ) ; <nl> logger . info ( " Sleeping for " + StorageService . RING _ DELAY + " ms to ensure " + endpoint + " does not change " ) ; <nl> - try <nl> - { <nl> - Thread . sleep ( StorageService . RING _ DELAY ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> + FBUtilities . sleep ( StorageService . RING _ DELAY ) ; <nl> / / make sure it did not change <nl> epState = endpointStateMap . get ( endpoint ) ; <nl> if ( epState . getHeartBeatState ( ) . getGeneration ( ) ! = generation ) <nl> @ @ - 467 , 19 + 464 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> epState . updateTimestamp ( ) ; / / make sure we don ' t evict it too soon <nl> epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; <nl> } <nl> - if ( tokens = = null ) <nl> - tokens = Arrays . asList ( StorageService . instance . getBootstrapToken ( ) ) ; <nl> + <nl> / / do not pass go , do not collect 200 dollars , just gtfo <nl> epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . left ( tokens , computeExpireTime ( ) ) ) ; <nl> handleMajorStateChange ( endpoint , epState ) ; <nl> - try <nl> - { <nl> - Thread . sleep ( intervalInMillis * 4 ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> + FBUtilities . sleep ( intervalInMillis * 4 ) ; <nl> logger . warn ( " Finished killing { } " , endpoint ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 40cf665 . . c0de7c9 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 95 , 7 + 95 , 7 @ @ public final class MessagingService implements MessagingServiceMBean <nl> STREAM _ REPLY , <nl> STREAM _ REQUEST , <nl> RANGE _ SLICE , <nl> - BOOTSTRAP _ TOKEN , <nl> + @ Deprecated BOOTSTRAP _ TOKEN , <nl> TREE _ REQUEST , <nl> TREE _ RESPONSE , <nl> @ Deprecated JOIN , <nl> @ @ - 147 , 7 + 147 , 6 @ @ public final class MessagingService implements MessagingServiceMBean <nl> <nl> put ( Verb . STREAM _ REPLY , Stage . MISC ) ; / / actually handled by FileStreamTask and streamExecutors <nl> put ( Verb . STREAM _ REQUEST , Stage . MISC ) ; <nl> - put ( Verb . BOOTSTRAP _ TOKEN , Stage . MISC ) ; <nl> put ( Verb . REPLICATION _ FINISHED , Stage . MISC ) ; <nl> put ( Verb . SNAPSHOT , Stage . MISC ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index c44dfb2 . . a86d856 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 34 , 6 + 34 , 7 @ @ import javax . management . Notification ; <nl> import javax . management . NotificationBroadcasterSupport ; <nl> import javax . management . ObjectName ; <nl> <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . collect . * ; <nl> import com . google . common . util . concurrent . AtomicDouble ; <nl> import org . apache . log4j . Level ; <nl> @ @ - 152 , 18 + 153 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return getPrimaryRangesForEndpoint ( keyspace , FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> <nl> - @ Deprecated <nl> - public Range < Token > getLocalPrimaryRange ( ) <nl> - { <nl> - return getPrimaryRangeForEndpoint ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - } <nl> - <nl> - / / For JMX ' s sake . Use getLocalPrimaryRange for internal uses <nl> - public List < String > getPrimaryRange ( ) <nl> - { <nl> - return getLocalPrimaryRange ( ) . asList ( ) ; <nl> - } <nl> - <nl> private final Set < InetAddress > replicatingNodes = Collections . synchronizedSet ( new HashSet < InetAddress > ( ) ) ; <nl> private CassandraDaemon daemon ; <nl> <nl> @ @ - 242 , 7 + 231 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . PAXOS _ COMMIT , new CommitVerbHandler ( ) ) ; <nl> <nl> / / see BootStrapper for a summary of how the bootstrap verbs interact <nl> - MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BOOTSTRAP _ TOKEN , new BootStrapper . BootstrapTokenVerbHandler ( ) ) ; <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . STREAM _ REQUEST , new StreamRequestVerbHandler ( ) ) ; <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . STREAM _ REPLY , new StreamReplyVerbHandler ( ) ) ; <nl> MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . REPLICATION _ FINISHED , new ReplicationFinishedVerbHandler ( ) ) ; <nl> @ @ - 2518 , 6 + 2506 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> * @ return range for the specified endpoint . <nl> * / <nl> @ Deprecated <nl> + @ VisibleForTesting <nl> public Range < Token > getPrimaryRangeForEndpoint ( InetAddress ep ) <nl> { <nl> return tokenMetadata . getPrimaryRangeFor ( tokenMetadata . getToken ( ep ) ) ; <nl> @ @ - 2684 , 36 + 2673 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return keys ; <nl> } <nl> <nl> - / * * return a token to which if a node bootstraps it will get about 1 / 2 of this node ' s range * / <nl> - public Token getBootstrapToken ( ) <nl> - { <nl> - Range < Token > range = getLocalPrimaryRange ( ) ; <nl> - <nl> - List < DecoratedKey > keys = keySamples ( ColumnFamilyStore . allUserDefined ( ) , range ) ; <nl> - <nl> - Token token ; <nl> - if ( keys . size ( ) < 3 ) <nl> - { <nl> - token = getPartitioner ( ) . midpoint ( range . left , range . right ) ; <nl> - logger . debug ( " Used midpoint to assign token " + token ) ; <nl> - } <nl> - else <nl> - { <nl> - token = keys . get ( keys . size ( ) / 2 ) . token ; <nl> - logger . debug ( " Used key sample of size " + keys . size ( ) + " to assign token " + token ) ; <nl> - } <nl> - if ( tokenMetadata . getEndpoint ( token ) ! = null & & tokenMetadata . isMember ( tokenMetadata . getEndpoint ( token ) ) ) <nl> - throw new RuntimeException ( " Chose token " + token + " which is already in use by " + tokenMetadata . getEndpoint ( token ) + " - - specify one manually with initial _ token " ) ; <nl> - / / Hack to prevent giving nodes tokens with DELIMITER _ STR in them ( which is fine in a row key / token ) <nl> - if ( token instanceof StringToken ) <nl> - { <nl> - token = new StringToken ( ( ( String ) token . token ) . replaceAll ( VersionedValue . DELIMITER _ STR , " " ) ) ; <nl> - if ( tokenMetadata . getNormalAndBootstrappingTokenToEndpointMap ( ) . containsKey ( token ) ) <nl> - throw new RuntimeException ( " Unable to compute unique token for new node - - specify one manually with initial _ token " ) ; <nl> - } <nl> - return token ; <nl> - } <nl> - <nl> / * * <nl> * Broadcast leaving status and update local tokenMetadata accordingly <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index 9548fcc . . ef619c5 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 140 , 11 + 140 , 6 @ @ public interface StorageServiceMBean extends NotificationEmitter <nl> public List < String > describeRingJMX ( String keyspace ) throws IOException ; <nl> <nl> / * * <nl> - * Returns the local node ' s primary range . <nl> - * / <nl> - public List < String > getPrimaryRange ( ) ; <nl> - <nl> - / * * <nl> * Retrieve a map of pending ranges to endpoints that describe the ring topology <nl> * @ param keyspace the keyspace to get the pending range map for . <nl> * @ return a map of pending ranges to endpoints <nl> diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> index ae7e36c . . 0ad663a 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> @ @ - 51 , 117 + 51 , 6 @ @ import static org . junit . Assert . * ; <nl> public class BootStrapperTest extends SchemaLoader <nl> { <nl> @ Test <nl> - public void testTokenRoundtrip ( ) throws Exception <nl> - { <nl> - StorageService . instance . initServer ( 0 ) ; <nl> - / / fetch a bootstrap token from the local node <nl> - assert BootStrapper . getBootstrapTokenFrom ( FBUtilities . getBroadcastAddress ( ) ) ! = null ; <nl> - } <nl> - <nl> - @ Test <nl> - public void testMulitipleAutomaticBootstraps ( ) throws IOException <nl> - { <nl> - StorageService ss = StorageService . instance ; <nl> - generateFakeEndpoints ( 5 ) ; <nl> - InetAddress [ ] addrs = new InetAddress [ ] <nl> - { <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) , <nl> - } ; <nl> - InetAddress [ ] bootstrapAddrs = new InetAddress [ ] <nl> - { <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 12 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 13 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 14 " ) , <nl> - InetAddress . getByName ( " 127 . 0 . 0 . 15 " ) , <nl> - } ; <nl> - Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; <nl> - for ( int i = 0 ; i < addrs . length ; i + + ) <nl> - { <nl> - Gossiper . instance . initializeNodeUnsafe ( addrs [ i ] , UUID . randomUUID ( ) , 1 ) ; <nl> - load . put ( addrs [ i ] , ( double ) i + 2 ) ; <nl> - / / also make bootstrapping nodes present in gossip <nl> - Gossiper . instance . initializeNodeUnsafe ( bootstrapAddrs [ i ] , UUID . randomUUID ( ) , 1 ) ; <nl> - } <nl> - <nl> - / / give every node a bootstrap source . <nl> - for ( int i = 3 ; i > = 0 ; i - - ) <nl> - { <nl> - InetAddress bootstrapSource = BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; <nl> - assert bootstrapSource ! = null ; <nl> - assert bootstrapSource . equals ( addrs [ i ] ) : String . format ( " expected % s but got % s for % d " , addrs [ i ] , bootstrapSource , i ) ; <nl> - assert ! ss . getTokenMetadata ( ) . getBootstrapTokens ( ) . containsValue ( bootstrapSource ) ; <nl> - <nl> - Range < Token > range = ss . getPrimaryRangeForEndpoint ( bootstrapSource ) ; <nl> - Token token = StorageService . getPartitioner ( ) . midpoint ( range . left , range . right ) ; <nl> - assert range . contains ( token ) ; <nl> - Gossiper . instance . injectApplicationState ( bootstrapAddrs [ i ] , ApplicationState . TOKENS , ss . valueFactory . tokens ( Collections . singleton ( token ) ) ) ; <nl> - ss . onChange ( bootstrapAddrs [ i ] , <nl> - ApplicationState . STATUS , <nl> - StorageService . instance . valueFactory . bootstrapping ( Collections . < Token > singleton ( token ) ) ) ; <nl> - } <nl> - <nl> - / / any further attempt to bootsrtap should fail since every node in the cluster is splitting . <nl> - try <nl> - { <nl> - BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; <nl> - throw new AssertionError ( " This bootstrap should have failed . " ) ; <nl> - } <nl> - catch ( RuntimeException ex ) <nl> - { <nl> - / / success ! <nl> - } <nl> - <nl> - / / indicate that one of the nodes is done . see if the node it was bootstrapping from is still available . <nl> - Range < Token > range = ss . getPrimaryRangeForEndpoint ( addrs [ 2 ] ) ; <nl> - Token token = StorageService . getPartitioner ( ) . midpoint ( range . left , range . right ) ; <nl> - ss . onChange ( bootstrapAddrs [ 2 ] , <nl> - ApplicationState . STATUS , <nl> - StorageService . instance . valueFactory . normal ( Collections . singleton ( token ) ) ) ; <nl> - load . put ( bootstrapAddrs [ 2 ] , 0d ) ; <nl> - InetAddress addr = BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; <nl> - assert addr ! = null & & addr . equals ( addrs [ 2 ] ) ; <nl> - } <nl> - <nl> - @ Test <nl> - public void testGuessToken ( ) throws IOException <nl> - { <nl> - StorageService ss = StorageService . instance ; <nl> - <nl> - generateFakeEndpoints ( 5 ) ; <nl> - <nl> - InetAddress two = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> - InetAddress three = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; <nl> - InetAddress four = InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ; <nl> - InetAddress five = InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ; <nl> - <nl> - Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; <nl> - load . put ( two , 2 . 0 ) ; <nl> - load . put ( three , 3 . 0 ) ; <nl> - load . put ( four , 4 . 0 ) ; <nl> - load . put ( five , 5 . 0 ) ; <nl> - <nl> - TokenMetadata tmd = ss . getTokenMetadata ( ) ; <nl> - InetAddress source = BootStrapper . getBootstrapSource ( tmd , load ) ; <nl> - assert five . equals ( source ) : five + " ! = " + source ; <nl> - <nl> - InetAddress myEndpoint = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> - Range < Token > range5 = ss . getPrimaryRangeForEndpoint ( five ) ; <nl> - Token fakeToken = StorageService . getPartitioner ( ) . midpoint ( range5 . left , range5 . right ) ; <nl> - assert range5 . contains ( fakeToken ) ; <nl> - Gossiper . instance . injectApplicationState ( myEndpoint , ApplicationState . TOKENS , ss . valueFactory . tokens ( Collections . singleton ( fakeToken ) ) ) ; <nl> - ss . onChange ( myEndpoint , <nl> - ApplicationState . STATUS , <nl> - StorageService . instance . valueFactory . bootstrapping ( Collections . < Token > singleton ( fakeToken ) ) ) ; <nl> - tmd = ss . getTokenMetadata ( ) ; <nl> - <nl> - InetAddress source4 = BootStrapper . getBootstrapSource ( tmd , load ) ; <nl> - assert four . equals ( source4 ) : four + " ! = " + source4 ; <nl> - } <nl> - <nl> - @ Test <nl> public void testSourceTargetComputation ( ) throws UnknownHostException <nl> { <nl> final int [ ] clusterSizes = new int [ ] { 1 , 3 , 5 , 10 , 100 } ;

TEST DIFF:
diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ output . py b / pylib / cqlshlib / test / test _ cqlsh _ output . py 
 index baf72c1 . . 60ef3a4 100644 
 - - - a / pylib / cqlshlib / test / test _ cqlsh _ output . py 
 + + + b / pylib / cqlshlib / test / test _ cqlsh _ output . py 
 @ @ - 544 , 7 + 544 , 7 @ @ class TestCqlshOutput ( BaseTestCase ) : 
 self . assertEqual ( outputlines [ 2 ] , ' cqlsh : system > ' ) 
 midline = ColoredText ( outputlines [ 1 ] ) 
 self . assertEqual ( midline . plain ( ) , 
 - ' code = 2200 [ Invalid query ] message = " Keyspace \ ' nonexistentkeyspace \ ' does not exist " ' ) 
 + ' InvalidRequest : code = 2200 [ Invalid query ] message = " Keyspace \ ' nonexistentkeyspace \ ' does not exist " ' ) 
 self . assertColorFromTags ( midline , 
 " RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR " ) 


NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0774d90 . . d880c4d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 
 + * Removed token range bisection ( CASSANDRA - 5518 ) 
 * Removed compatibility with pre - 1 . 2 . 5 sstables and network messages 
 ( CASSANDRA - 5511 ) 
 * removed PBSPredictor ( CASSANDRA - 5455 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 1a1425c . . 1e86cab 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 20 , 6 + 20 , 10 @ @ Upgrading 
 - Replication and strategy options do not accept unknown options anymore . 
 This was already the case for CQL3 in 1 . 2 but this is now the case for 
 thrift too . 
 + - auto _ bootstrap of a single - token node with no initial _ token will 
 + now pick a random token instead of bisecting an existing token 
 + range . We recommend upgrading to vnodes ; failing that , we 
 + recommend specifying initial _ token . 
 - reduce _ cache _ sizes _ at , reduce _ cache _ capacity _ to , and 
 flush _ largest _ memtables _ at options have been removed from cassandra . yaml . 
 - CacheServiceMBean . reduceCacheSizes ( ) has been removed . 
 diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index a1dfce8 . . f354b08 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 22 , 29 + 22 , 21 @ @ import java . io . DataOutput ; 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 import java . util . * ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . locks . Condition ; 
 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 - import org . apache . cassandra . config . Schema ; 
 
 - import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . db . Table ; 
 + import org . apache . cassandra . db . TypeSizes ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . gms . FailureDetector ; 
 + import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 - import org . apache . cassandra . net . IAsyncCallback ; 
 - import org . apache . cassandra . net . IVerbHandler ; 
 - import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . streaming . OperationType ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . SimpleCondition ; 
 - import org . apache . cassandra . db . TypeSizes ; 
 - import org . apache . cassandra . gms . FailureDetector ; 
 - import org . apache . cassandra . io . IVersionedSerializer ; 
 - import org . apache . cassandra . net . * ; 
 
 public class BootStrapper 
 { 
 @ @ - 111 , 8 + 103 , 9 @ @ public class BootStrapper 
 int numTokens = DatabaseDescriptor . getNumTokens ( ) ; 
 if ( numTokens < 1 ) 
 throw new ConfigurationException ( " num _ tokens must be > = 1 " ) ; 
 + 
 if ( numTokens = = 1 ) 
 - return Collections . singleton ( getBalancedToken ( metadata , load ) ) ; 
 + logger . warn ( " Picking random token for a single vnode . You should probably add more vnodes ; failing that , you should probably specify the token manually " ) ; 
 
 return getRandomTokens ( metadata , numTokens ) ; 
 } 
 @ @ - 129 , 124 + 122 , 6 @ @ public class BootStrapper 
 return tokens ; 
 } 
 
 - @ Deprecated 
 - public static Token getBalancedToken ( TokenMetadata metadata , Map < InetAddress , Double > load ) 
 - { 
 - InetAddress maxEndpoint = getBootstrapSource ( metadata , load ) ; 
 - Token < ? > t = getBootstrapTokenFrom ( maxEndpoint ) ; 
 - logger . info ( " New token will be " + t + " to assume load from " + maxEndpoint ) ; 
 - return t ; 
 - } 
 - 
 - @ Deprecated 
 - static InetAddress getBootstrapSource ( final TokenMetadata metadata , final Map < InetAddress , Double > load ) 
 - { 
 - / / sort first by number of nodes already bootstrapping into a source node ' s range , then by load . 
 - List < InetAddress > endpoints = new ArrayList < InetAddress > ( load . size ( ) ) ; 
 - for ( InetAddress endpoint : load . keySet ( ) ) 
 - { 
 - if ( ! metadata . isMember ( endpoint ) | | ! FailureDetector . instance . isAlive ( endpoint ) ) 
 - continue ; 
 - endpoints . add ( endpoint ) ; 
 - } 
 - 
 - if ( endpoints . isEmpty ( ) ) 
 - throw new RuntimeException ( " No other nodes seen ! Unable to bootstrap . " 
 - + " If you intended to start a single - node cluster , you should make sure " 
 - + " your broadcast _ address ( or listen _ address ) is listed as a seed . " 
 - + " Otherwise , you need to determine why the seed being contacted " 
 - + " has no knowledge of the rest of the cluster . Usually , this can be solved " 
 - + " by giving all nodes the same seed list . " ) ; 
 - Collections . sort ( endpoints , new Comparator < InetAddress > ( ) 
 - { 
 - public int compare ( InetAddress ia1 , InetAddress ia2 ) 
 - { 
 - int n1 = metadata . pendingRangeChanges ( ia1 ) ; 
 - int n2 = metadata . pendingRangeChanges ( ia2 ) ; 
 - if ( n1 ! = n2 ) 
 - return - ( n1 - n2 ) ; / / more targets = _ less _ priority ! 
 - 
 - double load1 = load . get ( ia1 ) ; 
 - double load2 = load . get ( ia2 ) ; 
 - if ( load1 = = load2 ) 
 - return 0 ; 
 - return load1 < load2 ? - 1 : 1 ; 
 - } 
 - } ) ; 
 - 
 - InetAddress maxEndpoint = endpoints . get ( endpoints . size ( ) - 1 ) ; 
 - assert ! maxEndpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - if ( metadata . pendingRangeChanges ( maxEndpoint ) > 0 ) 
 - throw new RuntimeException ( " Every node is a bootstrap source ! Please specify an initial token manually or wait for an existing bootstrap operation to finish . " ) ; 
 - 
 - return maxEndpoint ; 
 - } 
 - 
 - @ Deprecated 
 - static Token < ? > getBootstrapTokenFrom ( InetAddress maxEndpoint ) 
 - { 
 - MessageOut message = new MessageOut ( MessagingService . Verb . BOOTSTRAP _ TOKEN ) ; 
 - int retries = 5 ; 
 - long timeout = Math . max ( DatabaseDescriptor . getRpcTimeout ( ) , BOOTSTRAP _ TIMEOUT ) ; 
 - 
 - while ( retries > 0 ) 
 - { 
 - BootstrapTokenCallback btc = new BootstrapTokenCallback ( ) ; 
 - MessagingService . instance ( ) . sendRR ( message , maxEndpoint , btc , timeout ) ; 
 - Token token = btc . getToken ( timeout ) ; 
 - if ( token ! = null ) 
 - return token ; 
 - 
 - retries - - ; 
 - } 
 - throw new RuntimeException ( " Bootstrap failed , could not obtain token from : " + maxEndpoint ) ; 
 - } 
 - 
 - @ Deprecated 
 - public static class BootstrapTokenVerbHandler implements IVerbHandler 
 - { 
 - public void doVerb ( MessageIn message , int id ) 
 - { 
 - StorageService ss = StorageService . instance ; 
 - String tokenString = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toString ( ss . getBootstrapToken ( ) ) ; 
 - MessageOut < String > response = new MessageOut < String > ( MessagingService . Verb . INTERNAL _ RESPONSE , tokenString , StringSerializer . instance ) ; 
 - MessagingService . instance ( ) . sendReply ( response , id , message . from ) ; 
 - } 
 - } 
 - 
 - @ Deprecated 
 - private static class BootstrapTokenCallback implements IAsyncCallback < String > 
 - { 
 - private volatile Token < ? > token ; 
 - private final Condition condition = new SimpleCondition ( ) ; 
 - 
 - public Token < ? > getToken ( long timeout ) 
 - { 
 - boolean success ; 
 - try 
 - { 
 - success = condition . await ( timeout , TimeUnit . MILLISECONDS ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - 
 - return success ? token : null ; 
 - } 
 - 
 - public void response ( MessageIn < String > msg ) 
 - { 
 - token = StorageService . getPartitioner ( ) . getTokenFactory ( ) . fromString ( msg . payload ) ; 
 - condition . signalAll ( ) ; 
 - } 
 - 
 - public boolean isLatencyForSnitch ( ) 
 - { 
 - return false ; 
 - } 
 - } 
 - 
 public static class StringSerializer implements IVersionedSerializer < String > 
 { 
 public static final StringSerializer instance = new StringSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 7314429 . . 5e1cc28 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 437 , 6 + 437 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 EndpointState epState = endpointStateMap . get ( endpoint ) ; 
 Collection < Token > tokens = null ; 
 logger . warn ( " Assassinating { } via gossip " , endpoint ) ; 
 + 
 if ( epState = = null ) 
 { 
 epState = new EndpointState ( new HeartBeatState ( ( int ) ( ( System . currentTimeMillis ( ) + 60000 ) / 1000 ) , 9999 ) ) ; 
 @ @ - 447 , 19 + 448 , 15 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 { 
 tokens = StorageService . instance . getTokenMetadata ( ) . getTokens ( endpoint ) ; 
 } 
 - catch ( AssertionError e ) 
 + catch ( Throwable th ) 
 { 
 + / / TODO this is broken 
 + logger . warn ( " Unable to calculate tokens for { } . Will use a random one " , address ) ; 
 + tokens = Collections . singletonList ( StorageService . getPartitioner ( ) . getRandomToken ( ) ) ; 
 } 
 int generation = epState . getHeartBeatState ( ) . getGeneration ( ) ; 
 logger . info ( " Sleeping for " + StorageService . RING _ DELAY + " ms to ensure " + endpoint + " does not change " ) ; 
 - try 
 - { 
 - Thread . sleep ( StorageService . RING _ DELAY ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 + FBUtilities . sleep ( StorageService . RING _ DELAY ) ; 
 / / make sure it did not change 
 epState = endpointStateMap . get ( endpoint ) ; 
 if ( epState . getHeartBeatState ( ) . getGeneration ( ) ! = generation ) 
 @ @ - 467 , 19 + 464 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 epState . updateTimestamp ( ) ; / / make sure we don ' t evict it too soon 
 epState . getHeartBeatState ( ) . forceNewerGenerationUnsafe ( ) ; 
 } 
 - if ( tokens = = null ) 
 - tokens = Arrays . asList ( StorageService . instance . getBootstrapToken ( ) ) ; 
 + 
 / / do not pass go , do not collect 200 dollars , just gtfo 
 epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . left ( tokens , computeExpireTime ( ) ) ) ; 
 handleMajorStateChange ( endpoint , epState ) ; 
 - try 
 - { 
 - Thread . sleep ( intervalInMillis * 4 ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 + FBUtilities . sleep ( intervalInMillis * 4 ) ; 
 logger . warn ( " Finished killing { } " , endpoint ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 40cf665 . . c0de7c9 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 95 , 7 + 95 , 7 @ @ public final class MessagingService implements MessagingServiceMBean 
 STREAM _ REPLY , 
 STREAM _ REQUEST , 
 RANGE _ SLICE , 
 - BOOTSTRAP _ TOKEN , 
 + @ Deprecated BOOTSTRAP _ TOKEN , 
 TREE _ REQUEST , 
 TREE _ RESPONSE , 
 @ Deprecated JOIN , 
 @ @ - 147 , 7 + 147 , 6 @ @ public final class MessagingService implements MessagingServiceMBean 
 
 put ( Verb . STREAM _ REPLY , Stage . MISC ) ; / / actually handled by FileStreamTask and streamExecutors 
 put ( Verb . STREAM _ REQUEST , Stage . MISC ) ; 
 - put ( Verb . BOOTSTRAP _ TOKEN , Stage . MISC ) ; 
 put ( Verb . REPLICATION _ FINISHED , Stage . MISC ) ; 
 put ( Verb . SNAPSHOT , Stage . MISC ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index c44dfb2 . . a86d856 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 34 , 6 + 34 , 7 @ @ import javax . management . Notification ; 
 import javax . management . NotificationBroadcasterSupport ; 
 import javax . management . ObjectName ; 
 
 + import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . collect . * ; 
 import com . google . common . util . concurrent . AtomicDouble ; 
 import org . apache . log4j . Level ; 
 @ @ - 152 , 18 + 153 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return getPrimaryRangesForEndpoint ( keyspace , FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 
 - @ Deprecated 
 - public Range < Token > getLocalPrimaryRange ( ) 
 - { 
 - return getPrimaryRangeForEndpoint ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - } 
 - 
 - / / For JMX ' s sake . Use getLocalPrimaryRange for internal uses 
 - public List < String > getPrimaryRange ( ) 
 - { 
 - return getLocalPrimaryRange ( ) . asList ( ) ; 
 - } 
 - 
 private final Set < InetAddress > replicatingNodes = Collections . synchronizedSet ( new HashSet < InetAddress > ( ) ) ; 
 private CassandraDaemon daemon ; 
 
 @ @ - 242 , 7 + 231 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . PAXOS _ COMMIT , new CommitVerbHandler ( ) ) ; 
 
 / / see BootStrapper for a summary of how the bootstrap verbs interact 
 - MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . BOOTSTRAP _ TOKEN , new BootStrapper . BootstrapTokenVerbHandler ( ) ) ; 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . STREAM _ REQUEST , new StreamRequestVerbHandler ( ) ) ; 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . STREAM _ REPLY , new StreamReplyVerbHandler ( ) ) ; 
 MessagingService . instance ( ) . registerVerbHandlers ( MessagingService . Verb . REPLICATION _ FINISHED , new ReplicationFinishedVerbHandler ( ) ) ; 
 @ @ - 2518 , 6 + 2506 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 * @ return range for the specified endpoint . 
 * / 
 @ Deprecated 
 + @ VisibleForTesting 
 public Range < Token > getPrimaryRangeForEndpoint ( InetAddress ep ) 
 { 
 return tokenMetadata . getPrimaryRangeFor ( tokenMetadata . getToken ( ep ) ) ; 
 @ @ - 2684 , 36 + 2673 , 6 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return keys ; 
 } 
 
 - / * * return a token to which if a node bootstraps it will get about 1 / 2 of this node ' s range * / 
 - public Token getBootstrapToken ( ) 
 - { 
 - Range < Token > range = getLocalPrimaryRange ( ) ; 
 - 
 - List < DecoratedKey > keys = keySamples ( ColumnFamilyStore . allUserDefined ( ) , range ) ; 
 - 
 - Token token ; 
 - if ( keys . size ( ) < 3 ) 
 - { 
 - token = getPartitioner ( ) . midpoint ( range . left , range . right ) ; 
 - logger . debug ( " Used midpoint to assign token " + token ) ; 
 - } 
 - else 
 - { 
 - token = keys . get ( keys . size ( ) / 2 ) . token ; 
 - logger . debug ( " Used key sample of size " + keys . size ( ) + " to assign token " + token ) ; 
 - } 
 - if ( tokenMetadata . getEndpoint ( token ) ! = null & & tokenMetadata . isMember ( tokenMetadata . getEndpoint ( token ) ) ) 
 - throw new RuntimeException ( " Chose token " + token + " which is already in use by " + tokenMetadata . getEndpoint ( token ) + " - - specify one manually with initial _ token " ) ; 
 - / / Hack to prevent giving nodes tokens with DELIMITER _ STR in them ( which is fine in a row key / token ) 
 - if ( token instanceof StringToken ) 
 - { 
 - token = new StringToken ( ( ( String ) token . token ) . replaceAll ( VersionedValue . DELIMITER _ STR , " " ) ) ; 
 - if ( tokenMetadata . getNormalAndBootstrappingTokenToEndpointMap ( ) . containsKey ( token ) ) 
 - throw new RuntimeException ( " Unable to compute unique token for new node - - specify one manually with initial _ token " ) ; 
 - } 
 - return token ; 
 - } 
 - 
 / * * 
 * Broadcast leaving status and update local tokenMetadata accordingly 
 * / 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index 9548fcc . . ef619c5 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 140 , 11 + 140 , 6 @ @ public interface StorageServiceMBean extends NotificationEmitter 
 public List < String > describeRingJMX ( String keyspace ) throws IOException ; 
 
 / * * 
 - * Returns the local node ' s primary range . 
 - * / 
 - public List < String > getPrimaryRange ( ) ; 
 - 
 - / * * 
 * Retrieve a map of pending ranges to endpoints that describe the ring topology 
 * @ param keyspace the keyspace to get the pending range map for . 
 * @ return a map of pending ranges to endpoints 
 diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 index ae7e36c . . 0ad663a 100644 
 - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 @ @ - 51 , 117 + 51 , 6 @ @ import static org . junit . Assert . * ; 
 public class BootStrapperTest extends SchemaLoader 
 { 
 @ Test 
 - public void testTokenRoundtrip ( ) throws Exception 
 - { 
 - StorageService . instance . initServer ( 0 ) ; 
 - / / fetch a bootstrap token from the local node 
 - assert BootStrapper . getBootstrapTokenFrom ( FBUtilities . getBroadcastAddress ( ) ) ! = null ; 
 - } 
 - 
 - @ Test 
 - public void testMulitipleAutomaticBootstraps ( ) throws IOException 
 - { 
 - StorageService ss = StorageService . instance ; 
 - generateFakeEndpoints ( 5 ) ; 
 - InetAddress [ ] addrs = new InetAddress [ ] 
 - { 
 - InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) , 
 - } ; 
 - InetAddress [ ] bootstrapAddrs = new InetAddress [ ] 
 - { 
 - InetAddress . getByName ( " 127 . 0 . 0 . 12 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 13 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 14 " ) , 
 - InetAddress . getByName ( " 127 . 0 . 0 . 15 " ) , 
 - } ; 
 - Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; 
 - for ( int i = 0 ; i < addrs . length ; i + + ) 
 - { 
 - Gossiper . instance . initializeNodeUnsafe ( addrs [ i ] , UUID . randomUUID ( ) , 1 ) ; 
 - load . put ( addrs [ i ] , ( double ) i + 2 ) ; 
 - / / also make bootstrapping nodes present in gossip 
 - Gossiper . instance . initializeNodeUnsafe ( bootstrapAddrs [ i ] , UUID . randomUUID ( ) , 1 ) ; 
 - } 
 - 
 - / / give every node a bootstrap source . 
 - for ( int i = 3 ; i > = 0 ; i - - ) 
 - { 
 - InetAddress bootstrapSource = BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; 
 - assert bootstrapSource ! = null ; 
 - assert bootstrapSource . equals ( addrs [ i ] ) : String . format ( " expected % s but got % s for % d " , addrs [ i ] , bootstrapSource , i ) ; 
 - assert ! ss . getTokenMetadata ( ) . getBootstrapTokens ( ) . containsValue ( bootstrapSource ) ; 
 - 
 - Range < Token > range = ss . getPrimaryRangeForEndpoint ( bootstrapSource ) ; 
 - Token token = StorageService . getPartitioner ( ) . midpoint ( range . left , range . right ) ; 
 - assert range . contains ( token ) ; 
 - Gossiper . instance . injectApplicationState ( bootstrapAddrs [ i ] , ApplicationState . TOKENS , ss . valueFactory . tokens ( Collections . singleton ( token ) ) ) ; 
 - ss . onChange ( bootstrapAddrs [ i ] , 
 - ApplicationState . STATUS , 
 - StorageService . instance . valueFactory . bootstrapping ( Collections . < Token > singleton ( token ) ) ) ; 
 - } 
 - 
 - / / any further attempt to bootsrtap should fail since every node in the cluster is splitting . 
 - try 
 - { 
 - BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; 
 - throw new AssertionError ( " This bootstrap should have failed . " ) ; 
 - } 
 - catch ( RuntimeException ex ) 
 - { 
 - / / success ! 
 - } 
 - 
 - / / indicate that one of the nodes is done . see if the node it was bootstrapping from is still available . 
 - Range < Token > range = ss . getPrimaryRangeForEndpoint ( addrs [ 2 ] ) ; 
 - Token token = StorageService . getPartitioner ( ) . midpoint ( range . left , range . right ) ; 
 - ss . onChange ( bootstrapAddrs [ 2 ] , 
 - ApplicationState . STATUS , 
 - StorageService . instance . valueFactory . normal ( Collections . singleton ( token ) ) ) ; 
 - load . put ( bootstrapAddrs [ 2 ] , 0d ) ; 
 - InetAddress addr = BootStrapper . getBootstrapSource ( ss . getTokenMetadata ( ) , load ) ; 
 - assert addr ! = null & & addr . equals ( addrs [ 2 ] ) ; 
 - } 
 - 
 - @ Test 
 - public void testGuessToken ( ) throws IOException 
 - { 
 - StorageService ss = StorageService . instance ; 
 - 
 - generateFakeEndpoints ( 5 ) ; 
 - 
 - InetAddress two = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 - InetAddress three = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; 
 - InetAddress four = InetAddress . getByName ( " 127 . 0 . 0 . 4 " ) ; 
 - InetAddress five = InetAddress . getByName ( " 127 . 0 . 0 . 5 " ) ; 
 - 
 - Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; 
 - load . put ( two , 2 . 0 ) ; 
 - load . put ( three , 3 . 0 ) ; 
 - load . put ( four , 4 . 0 ) ; 
 - load . put ( five , 5 . 0 ) ; 
 - 
 - TokenMetadata tmd = ss . getTokenMetadata ( ) ; 
 - InetAddress source = BootStrapper . getBootstrapSource ( tmd , load ) ; 
 - assert five . equals ( source ) : five + " ! = " + source ; 
 - 
 - InetAddress myEndpoint = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 - Range < Token > range5 = ss . getPrimaryRangeForEndpoint ( five ) ; 
 - Token fakeToken = StorageService . getPartitioner ( ) . midpoint ( range5 . left , range5 . right ) ; 
 - assert range5 . contains ( fakeToken ) ; 
 - Gossiper . instance . injectApplicationState ( myEndpoint , ApplicationState . TOKENS , ss . valueFactory . tokens ( Collections . singleton ( fakeToken ) ) ) ; 
 - ss . onChange ( myEndpoint , 
 - ApplicationState . STATUS , 
 - StorageService . instance . valueFactory . bootstrapping ( Collections . < Token > singleton ( fakeToken ) ) ) ; 
 - tmd = ss . getTokenMetadata ( ) ; 
 - 
 - InetAddress source4 = BootStrapper . getBootstrapSource ( tmd , load ) ; 
 - assert four . equals ( source4 ) : four + " ! = " + source4 ; 
 - } 
 - 
 - @ Test 
 public void testSourceTargetComputation ( ) throws UnknownHostException 
 { 
 final int [ ] clusterSizes = new int [ ] { 1 , 3 , 5 , 10 , 100 } ;
