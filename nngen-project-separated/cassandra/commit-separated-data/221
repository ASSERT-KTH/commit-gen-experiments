BLEU SCORE: 0.040583489434387374

TEST MSG: Improve commit log chain marker updating
GENERATED MSG: More frequent commitlog chained markers

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6bfddcc . . ee90a67 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 16 <nl> + * Improve commit log chain marker updating ( CASSANDRA - 14108 ) <nl> * Extra range tombstone bound creates double rows ( CASSANDRA - 14008 ) <nl> * Fix SStable ordering by max timestamp in SinglePartitionReadCommand ( CASSANDRA - 14010 ) <nl> * Accept role names containing forward - slash ( CASSANDRA - 14088 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 71e0b2a . . ef7b034 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 304 , 14 + 304 , 6 @ @ counter _ cache _ save _ period : 7200 <nl> commitlog _ sync : periodic <nl> commitlog _ sync _ period _ in _ ms : 10000 <nl> <nl> - # Time interval in millis at which we should update the chained markers in the commitlog . <nl> - # This allows more of the commitlog to be replayed from the mmapped file <nl> - # if the cassandra process crashes ; this does not help in durability for surviving a host fail . <nl> - # This value only makes sense if it is significantly less that commitlog _ sync _ period _ in _ ms , <nl> - # and only applies to periodic mode when not using commitlog compression or encryption . <nl> - # commitlog _ marker _ period _ in _ ms : 100 <nl> - <nl> - <nl> # The size of the individual commitlog file segments . A commitlog <nl> # segment may be archived , deleted , or recycled once all the data <nl> # in it ( potentially from each columnfamily in the system ) has been <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 0796183 . . 64d41bb 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 192 , 7 + 192 , 6 @ @ public class Config <nl> public CommitLogSync commitlog _ sync ; <nl> public Double commitlog _ sync _ batch _ window _ in _ ms ; <nl> public Integer commitlog _ sync _ period _ in _ ms ; <nl> - public Integer commitlog _ marker _ period _ in _ ms = 0 ; <nl> public int commitlog _ segment _ size _ in _ mb = 32 ; <nl> public ParameterizedClass commitlog _ compression ; <nl> public int commitlog _ max _ compression _ buffers _ in _ pool = 3 ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 169ed3d . . efc71ef 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 1519 , 16 + 1519 , 6 @ @ public class DatabaseDescriptor <nl> conf . commitlog _ sync _ period _ in _ ms = periodMillis ; <nl> } <nl> <nl> - public static void setCommitLogMarkerPeriod ( int markerPeriod ) <nl> - { <nl> - conf . commitlog _ marker _ period _ in _ ms = markerPeriod ; <nl> - } <nl> - <nl> - public static int getCommitLogMarkerPeriod ( ) <nl> - { <nl> - return conf . commitlog _ marker _ period _ in _ ms ; <nl> - } <nl> - <nl> public static Config . CommitLogSync getCommitLogSync ( ) <nl> { <nl> return conf . commitlog _ sync ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java <nl> index 8a03b2f . . 829530d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java <nl> @ @ - 19 , 8 + 19 , 8 @ @ package org . apache . cassandra . db . commitlog ; <nl> <nl> import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . config . Config ; <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . commitlog . CommitLogSegment . Allocation ; <nl> + import org . apache . cassandra . utils . Clock ; <nl> import org . apache . cassandra . utils . NoSpamLogger ; <nl> import org . apache . cassandra . utils . concurrent . WaitQueue ; <nl> import org . slf4j . * ; <nl> @ @ - 31 , 6 + 31 , 11 @ @ import java . util . concurrent . atomic . AtomicLong ; <nl> <nl> public abstract class AbstractCommitLogService <nl> { <nl> + / * * <nl> + * When in { @ link Config . CommitLogSync # periodic } mode , the default number of milliseconds to wait between updating <nl> + * the commit log chained markers . <nl> + * / <nl> + static final long DEFAULT _ MARKER _ INTERVAL _ MILLIS = 100 ; <nl> <nl> private Thread thread ; <nl> private volatile boolean shutdown = false ; <nl> @ @ - 52 , 13 + 57 , 13 @ @ public abstract class AbstractCommitLogService <nl> / * * <nl> * The duration between syncs to disk . <nl> * / <nl> - private final long syncIntervalMillis ; <nl> + final long syncIntervalMillis ; <nl> <nl> / * * <nl> * The duration between updating the chained markers in the the commit log file . This value should be <nl> * 0 < { @ link # markerIntervalMillis } < = { @ link # syncIntervalMillis } . <nl> * / <nl> - private final long markerIntervalMillis ; <nl> + final long markerIntervalMillis ; <nl> <nl> / * * <nl> * A flag that callers outside of the sync thread can use to signal they want the commitlog segments <nl> @ @ - 75 , 9 + 80 , 9 @ @ public abstract class AbstractCommitLogService <nl> * <nl> * Subclasses may be notified when a sync finishes by using the syncComplete WaitQueue . <nl> * / <nl> - AbstractCommitLogService ( final CommitLog commitLog , final String name , final long syncIntervalMillis ) <nl> + AbstractCommitLogService ( final CommitLog commitLog , final String name , long syncIntervalMillis ) <nl> { <nl> - this ( commitLog , name , syncIntervalMillis , syncIntervalMillis ) ; <nl> + this ( commitLog , name , syncIntervalMillis , false ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 85 , 138 + 90 , 163 @ @ public abstract class AbstractCommitLogService <nl> * Batch or Periodic contract . <nl> * <nl> * Subclasses may be notified when a sync finishes by using the syncComplete WaitQueue . <nl> + * <nl> + * @ param markHeadersFaster true if the chained markers should be updated more frequently than on the disk sync bounds . <nl> * / <nl> - AbstractCommitLogService ( final CommitLog commitLog , final String name , final long syncIntervalMillis , long markerIntervalMillis ) <nl> + AbstractCommitLogService ( final CommitLog commitLog , final String name , long syncIntervalMillis , boolean markHeadersFaster ) <nl> { <nl> this . commitLog = commitLog ; <nl> this . name = name ; <nl> - this . syncIntervalMillis = syncIntervalMillis ; <nl> <nl> - / / if we are not using periodic mode , or we using compression , we shouldn ' t update the chained markers <nl> - / / faster than the sync interval <nl> - if ( DatabaseDescriptor . getCommitLogSync ( ) ! = Config . CommitLogSync . periodic | | commitLog . configuration . useCompression ( ) ) <nl> - markerIntervalMillis = syncIntervalMillis ; <nl> + if ( markHeadersFaster & & syncIntervalMillis > DEFAULT _ MARKER _ INTERVAL _ MILLIS ) <nl> + { <nl> + markerIntervalMillis = DEFAULT _ MARKER _ INTERVAL _ MILLIS ; <nl> + long modulo = syncIntervalMillis % markerIntervalMillis ; <nl> + if ( modulo ! = 0 ) <nl> + { <nl> + / / quantize syncIntervalMillis to a multiple of markerIntervalMillis <nl> + syncIntervalMillis - = modulo ; <nl> <nl> - / / apply basic bounds checking on the marker interval <nl> - if ( markerIntervalMillis < = 0 | | markerIntervalMillis > syncIntervalMillis ) <nl> + if ( modulo > = markerIntervalMillis / 2 ) <nl> + syncIntervalMillis + = markerIntervalMillis ; <nl> + } <nl> + logger . debug ( " Will update the commitlog markers every { } ms and flush every { } ms " , markerIntervalMillis , syncIntervalMillis ) ; <nl> + } <nl> + else <nl> { <nl> - logger . debug ( " commit log marker interval { } is less than zero or above the sync interval { } ; setting value to sync interval " , <nl> - markerIntervalMillis , syncIntervalMillis ) ; <nl> markerIntervalMillis = syncIntervalMillis ; <nl> } <nl> <nl> - this . markerIntervalMillis = markerIntervalMillis ; <nl> + assert syncIntervalMillis % markerIntervalMillis = = 0 ; <nl> + this . syncIntervalMillis = syncIntervalMillis ; <nl> } <nl> <nl> / / Separated into individual method to ensure relevant objects are constructed before this is started . <nl> void start ( ) <nl> { <nl> if ( syncIntervalMillis < 1 ) <nl> - throw new IllegalArgumentException ( String . format ( " Commit log flush interval must be positive : % fms " , <nl> - syncIntervalMillis * 1e - 6 ) ) ; <nl> + throw new IllegalArgumentException ( String . format ( " Commit log flush interval must be positive : % dms " , <nl> + syncIntervalMillis ) ) ; <nl> + shutdown = false ; <nl> + Runnable runnable = new SyncRunnable ( new Clock ( ) ) ; <nl> + thread = new Thread ( NamedThreadFactory . threadLocalDeallocator ( runnable ) , name ) ; <nl> + thread . start ( ) ; <nl> + } <nl> <nl> - Runnable runnable = new Runnable ( ) <nl> + class SyncRunnable implements Runnable <nl> + { <nl> + final Clock clock ; <nl> + long firstLagAt = 0 ; <nl> + long totalSyncDuration = 0 ; / / total time spent syncing since firstLagAt <nl> + long syncExceededIntervalBy = 0 ; / / time that syncs exceeded pollInterval since firstLagAt <nl> + int lagCount = 0 ; <nl> + int syncCount = 0 ; <nl> + <nl> + SyncRunnable ( Clock clock ) <nl> { <nl> - public void run ( ) <nl> + this . clock = clock ; <nl> + } <nl> + <nl> + public void run ( ) <nl> + { <nl> + while ( true ) <nl> { <nl> - long firstLagAt = 0 ; <nl> - long totalSyncDuration = 0 ; / / total time spent syncing since firstLagAt <nl> - long syncExceededIntervalBy = 0 ; / / time that syncs exceeded pollInterval since firstLagAt <nl> - int lagCount = 0 ; <nl> - int syncCount = 0 ; <nl> - <nl> - boolean run = true ; <nl> - while ( run ) <nl> + if ( ! sync ( ) ) <nl> + break ; <nl> + } <nl> + } <nl> + <nl> + boolean sync ( ) <nl> + { <nl> + try <nl> + { <nl> + / / always run once after shutdown signalled <nl> + boolean run = ! shutdown ; <nl> + <nl> + / / sync and signal <nl> + long pollStarted = clock . currentTimeMillis ( ) ; <nl> + if ( lastSyncedAt + syncIntervalMillis < = pollStarted | | shutdown | | syncRequested ) <nl> { <nl> - try <nl> - { <nl> - / / always run once after shutdown signalled <nl> - run = ! shutdown ; <nl> - <nl> - / / sync and signal <nl> - long pollStarted = System . currentTimeMillis ( ) ; <nl> - if ( lastSyncedAt + syncIntervalMillis < = pollStarted | | shutdown | | syncRequested ) <nl> - { <nl> - / / in this branch , we want to flush the commit log to disk <nl> - commitLog . sync ( shutdown , true ) ; <nl> - syncRequested = false ; <nl> - lastSyncedAt = pollStarted ; <nl> - syncComplete . signalAll ( ) ; <nl> - } <nl> - else <nl> - { <nl> - / / in this branch , just update the commit log sync headers <nl> - commitLog . sync ( false , false ) ; <nl> - } <nl> - <nl> - / / sleep any time we have left before the next one is due <nl> - long now = System . currentTimeMillis ( ) ; <nl> - long sleep = pollStarted + markerIntervalMillis - now ; <nl> - if ( sleep < 0 ) <nl> - { <nl> - / / if we have lagged noticeably , update our lag counter <nl> - if ( firstLagAt = = 0 ) <nl> - { <nl> - firstLagAt = now ; <nl> - totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = 0 ; <nl> - } <nl> - syncExceededIntervalBy - = sleep ; <nl> - lagCount + + ; <nl> - } <nl> - syncCount + + ; <nl> - totalSyncDuration + = now - pollStarted ; <nl> - <nl> - if ( firstLagAt > 0 ) <nl> - { <nl> - / / Only reset the lag tracking if it actually logged this time <nl> - boolean logged = NoSpamLogger . log ( <nl> - logger , <nl> - NoSpamLogger . Level . WARN , <nl> - 5 , <nl> - TimeUnit . MINUTES , <nl> - " Out of { } commit log syncs over the past { } s with average duration of { } ms , { } have exceeded the configured commit interval by an average of { } ms " , <nl> - syncCount , ( now - firstLagAt ) / 1000 , String . format ( " % . 2f " , ( double ) totalSyncDuration / syncCount ) , lagCount , String . format ( " % . 2f " , ( double ) syncExceededIntervalBy / lagCount ) ) ; <nl> - if ( logged ) <nl> - firstLagAt = 0 ; <nl> - } <nl> - <nl> - / / if we have lagged this round , we probably have work to do already so we don ' t sleep <nl> - if ( sleep < 0 | | ! run ) <nl> - continue ; <nl> - <nl> - try <nl> - { <nl> - haveWork . tryAcquire ( sleep , TimeUnit . MILLISECONDS ) ; <nl> - haveWork . drainPermits ( ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( ) ; <nl> - } <nl> - } <nl> - catch ( Throwable t ) <nl> + / / in this branch , we want to flush the commit log to disk <nl> + commitLog . sync ( shutdown , true ) ; <nl> + syncRequested = false ; <nl> + lastSyncedAt = pollStarted ; <nl> + syncComplete . signalAll ( ) ; <nl> + } <nl> + else <nl> + { <nl> + / / in this branch , just update the commit log sync headers <nl> + commitLog . sync ( false , false ) ; <nl> + } <nl> + <nl> + / / sleep any time we have left before the next one is due <nl> + long now = clock . currentTimeMillis ( ) ; <nl> + long sleep = pollStarted + markerIntervalMillis - now ; <nl> + if ( sleep < 0 ) <nl> + { <nl> + / / if we have lagged noticeably , update our lag counter <nl> + if ( firstLagAt = = 0 ) <nl> { <nl> - if ( ! CommitLog . handleCommitError ( " Failed to persist commits to disk " , t ) ) <nl> - break ; <nl> - <nl> - / / sleep for full poll - interval after an error , so we don ' t spam the log file <nl> - try <nl> - { <nl> - haveWork . tryAcquire ( markerIntervalMillis , TimeUnit . MILLISECONDS ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( ) ; <nl> - } <nl> + firstLagAt = now ; <nl> + totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = 0 ; <nl> } <nl> + syncExceededIntervalBy - = sleep ; <nl> + lagCount + + ; <nl> + } <nl> + syncCount + + ; <nl> + totalSyncDuration + = now - pollStarted ; <nl> + <nl> + if ( firstLagAt > 0 ) <nl> + { <nl> + / / Only reset the lag tracking if it actually logged this time <nl> + boolean logged = NoSpamLogger . log ( <nl> + logger , <nl> + NoSpamLogger . Level . WARN , <nl> + 5 , <nl> + TimeUnit . MINUTES , <nl> + " Out of { } commit log syncs over the past { } s with average duration of { } ms , { } have exceeded the configured commit interval by an average of { } ms " , <nl> + syncCount , ( now - firstLagAt ) / 1000 , String . format ( " % . 2f " , ( double ) totalSyncDuration / syncCount ) , lagCount , String . format ( " % . 2f " , ( double ) syncExceededIntervalBy / lagCount ) ) ; <nl> + if ( logged ) <nl> + firstLagAt = 0 ; <nl> + } <nl> + <nl> + if ( ! run ) <nl> + return false ; <nl> + <nl> + / / if we have lagged this round , we probably have work to do already so we don ' t sleep <nl> + if ( sleep < 0 ) <nl> + return true ; <nl> + <nl> + try <nl> + { <nl> + haveWork . tryAcquire ( sleep , TimeUnit . MILLISECONDS ) ; <nl> + haveWork . drainPermits ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> } <nl> } <nl> - } ; <nl> + catch ( Throwable t ) <nl> + { <nl> + if ( ! CommitLog . handleCommitError ( " Failed to persist commits to disk " , t ) ) <nl> + return false ; <nl> <nl> - thread = new Thread ( NamedThreadFactory . threadLocalDeallocator ( runnable ) , name ) ; <nl> - thread . start ( ) ; <nl> + / / sleep for full poll - interval after an error , so we don ' t spam the log file <nl> + try <nl> + { <nl> + haveWork . tryAcquire ( markerIntervalMillis , TimeUnit . MILLISECONDS ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + } <nl> + return true ; <nl> + } <nl> } <nl> <nl> + <nl> / * * <nl> * Block for @ param alloc to be sync ' d as necessary , and handle bookkeeping <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java <nl> index 76419b7 . . 7a09de0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java <nl> @ @ - 26 , 7 + 26 , 8 @ @ class PeriodicCommitLogService extends AbstractCommitLogService <nl> <nl> public PeriodicCommitLogService ( final CommitLog commitLog ) <nl> { <nl> - super ( commitLog , " PERIODIC - COMMIT - LOG - SYNCER " , DatabaseDescriptor . getCommitLogSyncPeriod ( ) , DatabaseDescriptor . getCommitLogMarkerPeriod ( ) ) ; <nl> + super ( commitLog , " PERIODIC - COMMIT - LOG - SYNCER " , DatabaseDescriptor . getCommitLogSyncPeriod ( ) , <nl> + ! commitLog . configuration . useCompression ( ) ) ; <nl> } <nl> <nl> protected void maybeWaitForSync ( CommitLogSegment . Allocation alloc ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / Clock . java b / src / java / org / apache / cassandra / utils / Clock . java <nl> new file mode 100644 <nl> index 0000000 . . eb9822c <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / utils / Clock . java <nl> @ @ - 0 , 0 + 1 , 80 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + / * * <nl> + * Wrapper around time related functions that are either implemented by using the default JVM calls <nl> + * or by using a custom implementation for testing purposes . <nl> + * <nl> + * See { @ link # instance } for how to use a custom implementation . <nl> + * <nl> + * Please note that { @ link java . time . Clock } wasn ' t used , as it would not be possible to provide an <nl> + * implementation for { @ link # nanoTime ( ) } with the exact same properties of { @ link System # nanoTime ( ) } . <nl> + * / <nl> + public class Clock <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( Clock . class ) ; <nl> + <nl> + / * * <nl> + * Static singleton object that will be instanciated by default with a system clock <nl> + * implementation . Set < code > cassandra . clock < / code > system property to a FQCN to use a <nl> + * different implementation instead . <nl> + * / <nl> + public static Clock instance ; <nl> + <nl> + static <nl> + { <nl> + String sclock = System . getProperty ( " cassandra . clock " ) ; <nl> + if ( sclock = = null ) <nl> + { <nl> + instance = new Clock ( ) ; <nl> + } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + logger . debug ( " Using custom clock implementation : { } " , sclock ) ; <nl> + instance = ( Clock ) Class . forName ( sclock ) . newInstance ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + logger . error ( e . getMessage ( ) , e ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * @ see System # nanoTime ( ) <nl> + * / <nl> + public long nanoTime ( ) <nl> + { <nl> + return System . nanoTime ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * @ see System # currentTimeMillis ( ) <nl> + * / <nl> + public long currentTimeMillis ( ) <nl> + { <nl> + return System . currentTimeMillis ( ) ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java b / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java <nl> new file mode 100644 <nl> index 0000000 . . 5a46e5f <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java <nl> @ @ - 0 , 0 + 1 , 176 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . db . commitlog ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Ignore ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . Config ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . utils . Clock ; <nl> + import org . apache . cassandra . utils . FreeRunningClock ; <nl> + <nl> + import static org . apache . cassandra . db . commitlog . AbstractCommitLogService . DEFAULT _ MARKER _ INTERVAL _ MILLIS ; <nl> + <nl> + public class AbstractCommitLogServiceTest <nl> + { <nl> + @ BeforeClass <nl> + public static void before ( ) <nl> + { <nl> + DatabaseDescriptor . setCommitLogSync ( Config . CommitLogSync . periodic ) ; <nl> + DatabaseDescriptor . setCommitLogSyncPeriod ( 10 * 1000 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConstructorSyncIsQuantized ( ) <nl> + { <nl> + long syncTimeMillis = 10 * 1000 ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; <nl> + Assert . assertEquals ( syncTimeMillis , commitLogService . syncIntervalMillis ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConstructorSyncEqualsMarkerDefault ( ) <nl> + { <nl> + long syncTimeMillis = 100 ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; <nl> + Assert . assertEquals ( syncTimeMillis , commitLogService . syncIntervalMillis ) ; <nl> + Assert . assertEquals ( commitLogService . markerIntervalMillis , commitLogService . syncIntervalMillis ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConstructorSyncShouldRoundUp ( ) <nl> + { <nl> + long syncTimeMillis = 151 ; <nl> + long expectedMillis = 200 ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; <nl> + Assert . assertEquals ( expectedMillis , commitLogService . syncIntervalMillis ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConstructorSyncShouldRoundDown ( ) <nl> + { <nl> + long syncTimeMillis = 121 ; <nl> + long expectedMillis = 100 ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; <nl> + Assert . assertEquals ( expectedMillis , commitLogService . syncIntervalMillis ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testConstructorSyncTinyValue ( ) <nl> + { <nl> + long syncTimeMillis = 10 ; <nl> + long expectedNanos = syncTimeMillis ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + Assert . assertEquals ( expectedNanos , commitLogService . markerIntervalMillis ) ; <nl> + Assert . assertEquals ( expectedNanos , commitLogService . syncIntervalMillis ) ; <nl> + } <nl> + <nl> + private static class FakeCommitLogService extends AbstractCommitLogService <nl> + { <nl> + FakeCommitLogService ( long syncIntervalMillis ) <nl> + { <nl> + super ( new FakeCommitLog ( ) , " This is not a real commit log " , syncIntervalMillis , true ) ; <nl> + lastSyncedAt = 0 ; <nl> + } <nl> + <nl> + @ Override <nl> + void start ( ) <nl> + { <nl> + / / nop <nl> + } <nl> + <nl> + protected void maybeWaitForSync ( CommitLogSegment . Allocation alloc ) <nl> + { <nl> + / / nop <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testSync ( ) <nl> + { <nl> + long syncTimeMillis = AbstractCommitLogService . DEFAULT _ MARKER _ INTERVAL _ MILLIS * 2 ; <nl> + FreeRunningClock clock = new FreeRunningClock ( ) ; <nl> + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; <nl> + AbstractCommitLogService . SyncRunnable syncRunnable = commitLogService . new SyncRunnable ( clock ) ; <nl> + FakeCommitLog commitLog = ( FakeCommitLog ) commitLogService . commitLog ; <nl> + <nl> + / / at time 0 <nl> + Assert . assertTrue ( syncRunnable . sync ( ) ) ; <nl> + Assert . assertEquals ( 1 , commitLog . markCount . get ( ) ) ; <nl> + Assert . assertEquals ( 0 , commitLog . syncCount . get ( ) ) ; <nl> + <nl> + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS <nl> + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; <nl> + Assert . assertTrue ( syncRunnable . sync ( ) ) ; <nl> + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; <nl> + Assert . assertEquals ( 0 , commitLog . syncCount . get ( ) ) ; <nl> + <nl> + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS * 2 <nl> + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; <nl> + Assert . assertTrue ( syncRunnable . sync ( ) ) ; <nl> + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; <nl> + Assert . assertEquals ( 1 , commitLog . syncCount . get ( ) ) ; <nl> + <nl> + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS * 3 , but with shutdown ! <nl> + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; <nl> + commitLogService . shutdown ( ) ; <nl> + Assert . assertFalse ( syncRunnable . sync ( ) ) ; <nl> + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; <nl> + Assert . assertEquals ( 2 , commitLog . syncCount . get ( ) ) ; <nl> + } <nl> + <nl> + private static class FakeCommitLog extends CommitLog <nl> + { <nl> + private final AtomicInteger markCount = new AtomicInteger ( ) ; <nl> + private final AtomicInteger syncCount = new AtomicInteger ( ) ; <nl> + <nl> + FakeCommitLog ( ) <nl> + { <nl> + super ( DatabaseDescriptor . getCommitLogLocation ( ) , null ) ; <nl> + } <nl> + <nl> + @ Override <nl> + CommitLog start ( ) <nl> + { <nl> + / / this is a bit dicey . we need to start the allocator , but starting the parent ' s executor will muck things <nl> + / / up as it is pointing to a different executor service , not the fake one in this test class . <nl> + allocator . start ( ) ; <nl> + return this ; <nl> + } <nl> + <nl> + @ Override <nl> + public void sync ( boolean syncAllSegments , boolean flush ) <nl> + { <nl> + if ( flush ) <nl> + syncCount . incrementAndGet ( ) ; <nl> + else <nl> + markCount . incrementAndGet ( ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java <nl> index e2b9f72 . . b73275b 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java <nl> @ @ - 65 , 7 + 65 , 6 @ @ public class CommitLogChainedMarkersTest <nl> DatabaseDescriptor . setCommitLogSegmentSize ( 5 ) ; <nl> DatabaseDescriptor . setCommitLogSync ( Config . CommitLogSync . periodic ) ; <nl> DatabaseDescriptor . setCommitLogSyncPeriod ( 10000 * 1000 ) ; <nl> - DatabaseDescriptor . setCommitLogMarkerPeriod ( 1 ) ; <nl> SchemaLoader . prepareServer ( ) ; <nl> SchemaLoader . createKeyspace ( KEYSPACE1 , <nl> KeyspaceParams . simple ( 1 ) , <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java <nl> index a1999ef . . c615880 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java <nl> @ @ - 64 , 13 + 64 , 13 @ @ public class CommitLogSegmentBackpressureTest <nl> <nl> @ Test <nl> @ BMRules ( rules = { @ BMRule ( name = " Acquire Semaphore before sync " , <nl> - targetClass = " AbstractCommitLogService $ 1 " , <nl> - targetMethod = " run " , <nl> + targetClass = " AbstractCommitLogService $ SyncRunnable " , <nl> + targetMethod = " sync " , <nl> targetLocation = " AT INVOKE org . apache . cassandra . db . commitlog . CommitLog . sync ( boolean , boolean ) " , <nl> action = " org . apache . cassandra . db . commitlog . CommitLogSegmentBackpressureTest . allowSync . acquire ( ) " ) , <nl> @ BMRule ( name = " Release Semaphore after sync " , <nl> - targetClass = " AbstractCommitLogService $ 1 " , <nl> - targetMethod = " run " , <nl> + targetClass = " AbstractCommitLogService $ SyncRunnable " , <nl> + targetMethod = " sync " , <nl> targetLocation = " AFTER INVOKE org . apache . cassandra . db . commitlog . CommitLog . sync ( boolean , boolean ) " , <nl> action = " org . apache . cassandra . db . commitlog . CommitLogSegmentBackpressureTest . allowSync . release ( ) " ) } ) <nl> public void testCompressedCommitLogBackpressure ( ) throws Throwable <nl> diff - - git a / test / unit / org / apache / cassandra / utils / FreeRunningClock . java b / test / unit / org / apache / cassandra / utils / FreeRunningClock . java <nl> new file mode 100644 <nl> index 0000000 . . 83c8db7 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / utils / FreeRunningClock . java <nl> @ @ - 0 , 0 + 1 , 46 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . utils ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + / * * <nl> + * A freely adjustable clock that can be used for unit testing . See { @ link Clock # instance } how to <nl> + * enable this class . <nl> + * / <nl> + public class FreeRunningClock extends Clock <nl> + { <nl> + private long nanoTime = 0 ; <nl> + <nl> + @ Override <nl> + public long nanoTime ( ) <nl> + { <nl> + return nanoTime ; <nl> + } <nl> + <nl> + @ Override <nl> + public long currentTimeMillis ( ) <nl> + { <nl> + return TimeUnit . NANOSECONDS . toMillis ( nanoTime ( ) ) ; <nl> + } <nl> + <nl> + public void advance ( long time , TimeUnit unit ) <nl> + { <nl> + nanoTime + = unit . toNanos ( time ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6bfddcc . . ee90a67 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 16 
 + * Improve commit log chain marker updating ( CASSANDRA - 14108 ) 
 * Extra range tombstone bound creates double rows ( CASSANDRA - 14008 ) 
 * Fix SStable ordering by max timestamp in SinglePartitionReadCommand ( CASSANDRA - 14010 ) 
 * Accept role names containing forward - slash ( CASSANDRA - 14088 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 71e0b2a . . ef7b034 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 304 , 14 + 304 , 6 @ @ counter _ cache _ save _ period : 7200 
 commitlog _ sync : periodic 
 commitlog _ sync _ period _ in _ ms : 10000 
 
 - # Time interval in millis at which we should update the chained markers in the commitlog . 
 - # This allows more of the commitlog to be replayed from the mmapped file 
 - # if the cassandra process crashes ; this does not help in durability for surviving a host fail . 
 - # This value only makes sense if it is significantly less that commitlog _ sync _ period _ in _ ms , 
 - # and only applies to periodic mode when not using commitlog compression or encryption . 
 - # commitlog _ marker _ period _ in _ ms : 100 
 - 
 - 
 # The size of the individual commitlog file segments . A commitlog 
 # segment may be archived , deleted , or recycled once all the data 
 # in it ( potentially from each columnfamily in the system ) has been 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 0796183 . . 64d41bb 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 192 , 7 + 192 , 6 @ @ public class Config 
 public CommitLogSync commitlog _ sync ; 
 public Double commitlog _ sync _ batch _ window _ in _ ms ; 
 public Integer commitlog _ sync _ period _ in _ ms ; 
 - public Integer commitlog _ marker _ period _ in _ ms = 0 ; 
 public int commitlog _ segment _ size _ in _ mb = 32 ; 
 public ParameterizedClass commitlog _ compression ; 
 public int commitlog _ max _ compression _ buffers _ in _ pool = 3 ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 169ed3d . . efc71ef 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 1519 , 16 + 1519 , 6 @ @ public class DatabaseDescriptor 
 conf . commitlog _ sync _ period _ in _ ms = periodMillis ; 
 } 
 
 - public static void setCommitLogMarkerPeriod ( int markerPeriod ) 
 - { 
 - conf . commitlog _ marker _ period _ in _ ms = markerPeriod ; 
 - } 
 - 
 - public static int getCommitLogMarkerPeriod ( ) 
 - { 
 - return conf . commitlog _ marker _ period _ in _ ms ; 
 - } 
 - 
 public static Config . CommitLogSync getCommitLogSync ( ) 
 { 
 return conf . commitlog _ sync ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java 
 index 8a03b2f . . 829530d 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogService . java 
 @ @ - 19 , 8 + 19 , 8 @ @ package org . apache . cassandra . db . commitlog ; 
 
 import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . config . Config ; 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . commitlog . CommitLogSegment . Allocation ; 
 + import org . apache . cassandra . utils . Clock ; 
 import org . apache . cassandra . utils . NoSpamLogger ; 
 import org . apache . cassandra . utils . concurrent . WaitQueue ; 
 import org . slf4j . * ; 
 @ @ - 31 , 6 + 31 , 11 @ @ import java . util . concurrent . atomic . AtomicLong ; 
 
 public abstract class AbstractCommitLogService 
 { 
 + / * * 
 + * When in { @ link Config . CommitLogSync # periodic } mode , the default number of milliseconds to wait between updating 
 + * the commit log chained markers . 
 + * / 
 + static final long DEFAULT _ MARKER _ INTERVAL _ MILLIS = 100 ; 
 
 private Thread thread ; 
 private volatile boolean shutdown = false ; 
 @ @ - 52 , 13 + 57 , 13 @ @ public abstract class AbstractCommitLogService 
 / * * 
 * The duration between syncs to disk . 
 * / 
 - private final long syncIntervalMillis ; 
 + final long syncIntervalMillis ; 
 
 / * * 
 * The duration between updating the chained markers in the the commit log file . This value should be 
 * 0 < { @ link # markerIntervalMillis } < = { @ link # syncIntervalMillis } . 
 * / 
 - private final long markerIntervalMillis ; 
 + final long markerIntervalMillis ; 
 
 / * * 
 * A flag that callers outside of the sync thread can use to signal they want the commitlog segments 
 @ @ - 75 , 9 + 80 , 9 @ @ public abstract class AbstractCommitLogService 
 * 
 * Subclasses may be notified when a sync finishes by using the syncComplete WaitQueue . 
 * / 
 - AbstractCommitLogService ( final CommitLog commitLog , final String name , final long syncIntervalMillis ) 
 + AbstractCommitLogService ( final CommitLog commitLog , final String name , long syncIntervalMillis ) 
 { 
 - this ( commitLog , name , syncIntervalMillis , syncIntervalMillis ) ; 
 + this ( commitLog , name , syncIntervalMillis , false ) ; 
 } 
 
 / * * 
 @ @ - 85 , 138 + 90 , 163 @ @ public abstract class AbstractCommitLogService 
 * Batch or Periodic contract . 
 * 
 * Subclasses may be notified when a sync finishes by using the syncComplete WaitQueue . 
 + * 
 + * @ param markHeadersFaster true if the chained markers should be updated more frequently than on the disk sync bounds . 
 * / 
 - AbstractCommitLogService ( final CommitLog commitLog , final String name , final long syncIntervalMillis , long markerIntervalMillis ) 
 + AbstractCommitLogService ( final CommitLog commitLog , final String name , long syncIntervalMillis , boolean markHeadersFaster ) 
 { 
 this . commitLog = commitLog ; 
 this . name = name ; 
 - this . syncIntervalMillis = syncIntervalMillis ; 
 
 - / / if we are not using periodic mode , or we using compression , we shouldn ' t update the chained markers 
 - / / faster than the sync interval 
 - if ( DatabaseDescriptor . getCommitLogSync ( ) ! = Config . CommitLogSync . periodic | | commitLog . configuration . useCompression ( ) ) 
 - markerIntervalMillis = syncIntervalMillis ; 
 + if ( markHeadersFaster & & syncIntervalMillis > DEFAULT _ MARKER _ INTERVAL _ MILLIS ) 
 + { 
 + markerIntervalMillis = DEFAULT _ MARKER _ INTERVAL _ MILLIS ; 
 + long modulo = syncIntervalMillis % markerIntervalMillis ; 
 + if ( modulo ! = 0 ) 
 + { 
 + / / quantize syncIntervalMillis to a multiple of markerIntervalMillis 
 + syncIntervalMillis - = modulo ; 
 
 - / / apply basic bounds checking on the marker interval 
 - if ( markerIntervalMillis < = 0 | | markerIntervalMillis > syncIntervalMillis ) 
 + if ( modulo > = markerIntervalMillis / 2 ) 
 + syncIntervalMillis + = markerIntervalMillis ; 
 + } 
 + logger . debug ( " Will update the commitlog markers every { } ms and flush every { } ms " , markerIntervalMillis , syncIntervalMillis ) ; 
 + } 
 + else 
 { 
 - logger . debug ( " commit log marker interval { } is less than zero or above the sync interval { } ; setting value to sync interval " , 
 - markerIntervalMillis , syncIntervalMillis ) ; 
 markerIntervalMillis = syncIntervalMillis ; 
 } 
 
 - this . markerIntervalMillis = markerIntervalMillis ; 
 + assert syncIntervalMillis % markerIntervalMillis = = 0 ; 
 + this . syncIntervalMillis = syncIntervalMillis ; 
 } 
 
 / / Separated into individual method to ensure relevant objects are constructed before this is started . 
 void start ( ) 
 { 
 if ( syncIntervalMillis < 1 ) 
 - throw new IllegalArgumentException ( String . format ( " Commit log flush interval must be positive : % fms " , 
 - syncIntervalMillis * 1e - 6 ) ) ; 
 + throw new IllegalArgumentException ( String . format ( " Commit log flush interval must be positive : % dms " , 
 + syncIntervalMillis ) ) ; 
 + shutdown = false ; 
 + Runnable runnable = new SyncRunnable ( new Clock ( ) ) ; 
 + thread = new Thread ( NamedThreadFactory . threadLocalDeallocator ( runnable ) , name ) ; 
 + thread . start ( ) ; 
 + } 
 
 - Runnable runnable = new Runnable ( ) 
 + class SyncRunnable implements Runnable 
 + { 
 + final Clock clock ; 
 + long firstLagAt = 0 ; 
 + long totalSyncDuration = 0 ; / / total time spent syncing since firstLagAt 
 + long syncExceededIntervalBy = 0 ; / / time that syncs exceeded pollInterval since firstLagAt 
 + int lagCount = 0 ; 
 + int syncCount = 0 ; 
 + 
 + SyncRunnable ( Clock clock ) 
 { 
 - public void run ( ) 
 + this . clock = clock ; 
 + } 
 + 
 + public void run ( ) 
 + { 
 + while ( true ) 
 { 
 - long firstLagAt = 0 ; 
 - long totalSyncDuration = 0 ; / / total time spent syncing since firstLagAt 
 - long syncExceededIntervalBy = 0 ; / / time that syncs exceeded pollInterval since firstLagAt 
 - int lagCount = 0 ; 
 - int syncCount = 0 ; 
 - 
 - boolean run = true ; 
 - while ( run ) 
 + if ( ! sync ( ) ) 
 + break ; 
 + } 
 + } 
 + 
 + boolean sync ( ) 
 + { 
 + try 
 + { 
 + / / always run once after shutdown signalled 
 + boolean run = ! shutdown ; 
 + 
 + / / sync and signal 
 + long pollStarted = clock . currentTimeMillis ( ) ; 
 + if ( lastSyncedAt + syncIntervalMillis < = pollStarted | | shutdown | | syncRequested ) 
 { 
 - try 
 - { 
 - / / always run once after shutdown signalled 
 - run = ! shutdown ; 
 - 
 - / / sync and signal 
 - long pollStarted = System . currentTimeMillis ( ) ; 
 - if ( lastSyncedAt + syncIntervalMillis < = pollStarted | | shutdown | | syncRequested ) 
 - { 
 - / / in this branch , we want to flush the commit log to disk 
 - commitLog . sync ( shutdown , true ) ; 
 - syncRequested = false ; 
 - lastSyncedAt = pollStarted ; 
 - syncComplete . signalAll ( ) ; 
 - } 
 - else 
 - { 
 - / / in this branch , just update the commit log sync headers 
 - commitLog . sync ( false , false ) ; 
 - } 
 - 
 - / / sleep any time we have left before the next one is due 
 - long now = System . currentTimeMillis ( ) ; 
 - long sleep = pollStarted + markerIntervalMillis - now ; 
 - if ( sleep < 0 ) 
 - { 
 - / / if we have lagged noticeably , update our lag counter 
 - if ( firstLagAt = = 0 ) 
 - { 
 - firstLagAt = now ; 
 - totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = 0 ; 
 - } 
 - syncExceededIntervalBy - = sleep ; 
 - lagCount + + ; 
 - } 
 - syncCount + + ; 
 - totalSyncDuration + = now - pollStarted ; 
 - 
 - if ( firstLagAt > 0 ) 
 - { 
 - / / Only reset the lag tracking if it actually logged this time 
 - boolean logged = NoSpamLogger . log ( 
 - logger , 
 - NoSpamLogger . Level . WARN , 
 - 5 , 
 - TimeUnit . MINUTES , 
 - " Out of { } commit log syncs over the past { } s with average duration of { } ms , { } have exceeded the configured commit interval by an average of { } ms " , 
 - syncCount , ( now - firstLagAt ) / 1000 , String . format ( " % . 2f " , ( double ) totalSyncDuration / syncCount ) , lagCount , String . format ( " % . 2f " , ( double ) syncExceededIntervalBy / lagCount ) ) ; 
 - if ( logged ) 
 - firstLagAt = 0 ; 
 - } 
 - 
 - / / if we have lagged this round , we probably have work to do already so we don ' t sleep 
 - if ( sleep < 0 | | ! run ) 
 - continue ; 
 - 
 - try 
 - { 
 - haveWork . tryAcquire ( sleep , TimeUnit . MILLISECONDS ) ; 
 - haveWork . drainPermits ( ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( ) ; 
 - } 
 - } 
 - catch ( Throwable t ) 
 + / / in this branch , we want to flush the commit log to disk 
 + commitLog . sync ( shutdown , true ) ; 
 + syncRequested = false ; 
 + lastSyncedAt = pollStarted ; 
 + syncComplete . signalAll ( ) ; 
 + } 
 + else 
 + { 
 + / / in this branch , just update the commit log sync headers 
 + commitLog . sync ( false , false ) ; 
 + } 
 + 
 + / / sleep any time we have left before the next one is due 
 + long now = clock . currentTimeMillis ( ) ; 
 + long sleep = pollStarted + markerIntervalMillis - now ; 
 + if ( sleep < 0 ) 
 + { 
 + / / if we have lagged noticeably , update our lag counter 
 + if ( firstLagAt = = 0 ) 
 { 
 - if ( ! CommitLog . handleCommitError ( " Failed to persist commits to disk " , t ) ) 
 - break ; 
 - 
 - / / sleep for full poll - interval after an error , so we don ' t spam the log file 
 - try 
 - { 
 - haveWork . tryAcquire ( markerIntervalMillis , TimeUnit . MILLISECONDS ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( ) ; 
 - } 
 + firstLagAt = now ; 
 + totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = 0 ; 
 } 
 + syncExceededIntervalBy - = sleep ; 
 + lagCount + + ; 
 + } 
 + syncCount + + ; 
 + totalSyncDuration + = now - pollStarted ; 
 + 
 + if ( firstLagAt > 0 ) 
 + { 
 + / / Only reset the lag tracking if it actually logged this time 
 + boolean logged = NoSpamLogger . log ( 
 + logger , 
 + NoSpamLogger . Level . WARN , 
 + 5 , 
 + TimeUnit . MINUTES , 
 + " Out of { } commit log syncs over the past { } s with average duration of { } ms , { } have exceeded the configured commit interval by an average of { } ms " , 
 + syncCount , ( now - firstLagAt ) / 1000 , String . format ( " % . 2f " , ( double ) totalSyncDuration / syncCount ) , lagCount , String . format ( " % . 2f " , ( double ) syncExceededIntervalBy / lagCount ) ) ; 
 + if ( logged ) 
 + firstLagAt = 0 ; 
 + } 
 + 
 + if ( ! run ) 
 + return false ; 
 + 
 + / / if we have lagged this round , we probably have work to do already so we don ' t sleep 
 + if ( sleep < 0 ) 
 + return true ; 
 + 
 + try 
 + { 
 + haveWork . tryAcquire ( sleep , TimeUnit . MILLISECONDS ) ; 
 + haveWork . drainPermits ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 } 
 } 
 - } ; 
 + catch ( Throwable t ) 
 + { 
 + if ( ! CommitLog . handleCommitError ( " Failed to persist commits to disk " , t ) ) 
 + return false ; 
 
 - thread = new Thread ( NamedThreadFactory . threadLocalDeallocator ( runnable ) , name ) ; 
 - thread . start ( ) ; 
 + / / sleep for full poll - interval after an error , so we don ' t spam the log file 
 + try 
 + { 
 + haveWork . tryAcquire ( markerIntervalMillis , TimeUnit . MILLISECONDS ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( ) ; 
 + } 
 + } 
 + return true ; 
 + } 
 } 
 
 + 
 / * * 
 * Block for @ param alloc to be sync ' d as necessary , and handle bookkeeping 
 * / 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java 
 index 76419b7 . . 7a09de0 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogService . java 
 @ @ - 26 , 7 + 26 , 8 @ @ class PeriodicCommitLogService extends AbstractCommitLogService 
 
 public PeriodicCommitLogService ( final CommitLog commitLog ) 
 { 
 - super ( commitLog , " PERIODIC - COMMIT - LOG - SYNCER " , DatabaseDescriptor . getCommitLogSyncPeriod ( ) , DatabaseDescriptor . getCommitLogMarkerPeriod ( ) ) ; 
 + super ( commitLog , " PERIODIC - COMMIT - LOG - SYNCER " , DatabaseDescriptor . getCommitLogSyncPeriod ( ) , 
 + ! commitLog . configuration . useCompression ( ) ) ; 
 } 
 
 protected void maybeWaitForSync ( CommitLogSegment . Allocation alloc ) 
 diff - - git a / src / java / org / apache / cassandra / utils / Clock . java b / src / java / org / apache / cassandra / utils / Clock . java 
 new file mode 100644 
 index 0000000 . . eb9822c 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / utils / Clock . java 
 @ @ - 0 , 0 + 1 , 80 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + / * * 
 + * Wrapper around time related functions that are either implemented by using the default JVM calls 
 + * or by using a custom implementation for testing purposes . 
 + * 
 + * See { @ link # instance } for how to use a custom implementation . 
 + * 
 + * Please note that { @ link java . time . Clock } wasn ' t used , as it would not be possible to provide an 
 + * implementation for { @ link # nanoTime ( ) } with the exact same properties of { @ link System # nanoTime ( ) } . 
 + * / 
 + public class Clock 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( Clock . class ) ; 
 + 
 + / * * 
 + * Static singleton object that will be instanciated by default with a system clock 
 + * implementation . Set < code > cassandra . clock < / code > system property to a FQCN to use a 
 + * different implementation instead . 
 + * / 
 + public static Clock instance ; 
 + 
 + static 
 + { 
 + String sclock = System . getProperty ( " cassandra . clock " ) ; 
 + if ( sclock = = null ) 
 + { 
 + instance = new Clock ( ) ; 
 + } 
 + else 
 + { 
 + try 
 + { 
 + logger . debug ( " Using custom clock implementation : { } " , sclock ) ; 
 + instance = ( Clock ) Class . forName ( sclock ) . newInstance ( ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + logger . error ( e . getMessage ( ) , e ) ; 
 + } 
 + } 
 + } 
 + 
 + / * * 
 + * @ see System # nanoTime ( ) 
 + * / 
 + public long nanoTime ( ) 
 + { 
 + return System . nanoTime ( ) ; 
 + } 
 + 
 + / * * 
 + * @ see System # currentTimeMillis ( ) 
 + * / 
 + public long currentTimeMillis ( ) 
 + { 
 + return System . currentTimeMillis ( ) ; 
 + } 
 + 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java b / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java 
 new file mode 100644 
 index 0000000 . . 5a46e5f 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / AbstractCommitLogServiceTest . java 
 @ @ - 0 , 0 + 1 , 176 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . db . commitlog ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Ignore ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . Config ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . utils . Clock ; 
 + import org . apache . cassandra . utils . FreeRunningClock ; 
 + 
 + import static org . apache . cassandra . db . commitlog . AbstractCommitLogService . DEFAULT _ MARKER _ INTERVAL _ MILLIS ; 
 + 
 + public class AbstractCommitLogServiceTest 
 + { 
 + @ BeforeClass 
 + public static void before ( ) 
 + { 
 + DatabaseDescriptor . setCommitLogSync ( Config . CommitLogSync . periodic ) ; 
 + DatabaseDescriptor . setCommitLogSyncPeriod ( 10 * 1000 ) ; 
 + } 
 + 
 + @ Test 
 + public void testConstructorSyncIsQuantized ( ) 
 + { 
 + long syncTimeMillis = 10 * 1000 ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; 
 + Assert . assertEquals ( syncTimeMillis , commitLogService . syncIntervalMillis ) ; 
 + } 
 + 
 + @ Test 
 + public void testConstructorSyncEqualsMarkerDefault ( ) 
 + { 
 + long syncTimeMillis = 100 ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; 
 + Assert . assertEquals ( syncTimeMillis , commitLogService . syncIntervalMillis ) ; 
 + Assert . assertEquals ( commitLogService . markerIntervalMillis , commitLogService . syncIntervalMillis ) ; 
 + } 
 + 
 + @ Test 
 + public void testConstructorSyncShouldRoundUp ( ) 
 + { 
 + long syncTimeMillis = 151 ; 
 + long expectedMillis = 200 ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; 
 + Assert . assertEquals ( expectedMillis , commitLogService . syncIntervalMillis ) ; 
 + } 
 + 
 + @ Test 
 + public void testConstructorSyncShouldRoundDown ( ) 
 + { 
 + long syncTimeMillis = 121 ; 
 + long expectedMillis = 100 ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + Assert . assertEquals ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , commitLogService . markerIntervalMillis ) ; 
 + Assert . assertEquals ( expectedMillis , commitLogService . syncIntervalMillis ) ; 
 + } 
 + 
 + @ Test 
 + public void testConstructorSyncTinyValue ( ) 
 + { 
 + long syncTimeMillis = 10 ; 
 + long expectedNanos = syncTimeMillis ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + Assert . assertEquals ( expectedNanos , commitLogService . markerIntervalMillis ) ; 
 + Assert . assertEquals ( expectedNanos , commitLogService . syncIntervalMillis ) ; 
 + } 
 + 
 + private static class FakeCommitLogService extends AbstractCommitLogService 
 + { 
 + FakeCommitLogService ( long syncIntervalMillis ) 
 + { 
 + super ( new FakeCommitLog ( ) , " This is not a real commit log " , syncIntervalMillis , true ) ; 
 + lastSyncedAt = 0 ; 
 + } 
 + 
 + @ Override 
 + void start ( ) 
 + { 
 + / / nop 
 + } 
 + 
 + protected void maybeWaitForSync ( CommitLogSegment . Allocation alloc ) 
 + { 
 + / / nop 
 + } 
 + } 
 + 
 + @ Test 
 + public void testSync ( ) 
 + { 
 + long syncTimeMillis = AbstractCommitLogService . DEFAULT _ MARKER _ INTERVAL _ MILLIS * 2 ; 
 + FreeRunningClock clock = new FreeRunningClock ( ) ; 
 + FakeCommitLogService commitLogService = new FakeCommitLogService ( syncTimeMillis ) ; 
 + AbstractCommitLogService . SyncRunnable syncRunnable = commitLogService . new SyncRunnable ( clock ) ; 
 + FakeCommitLog commitLog = ( FakeCommitLog ) commitLogService . commitLog ; 
 + 
 + / / at time 0 
 + Assert . assertTrue ( syncRunnable . sync ( ) ) ; 
 + Assert . assertEquals ( 1 , commitLog . markCount . get ( ) ) ; 
 + Assert . assertEquals ( 0 , commitLog . syncCount . get ( ) ) ; 
 + 
 + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS 
 + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; 
 + Assert . assertTrue ( syncRunnable . sync ( ) ) ; 
 + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; 
 + Assert . assertEquals ( 0 , commitLog . syncCount . get ( ) ) ; 
 + 
 + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS * 2 
 + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; 
 + Assert . assertTrue ( syncRunnable . sync ( ) ) ; 
 + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; 
 + Assert . assertEquals ( 1 , commitLog . syncCount . get ( ) ) ; 
 + 
 + / / at time DEFAULT _ MARKER _ INTERVAL _ MILLIS * 3 , but with shutdown ! 
 + clock . advance ( DEFAULT _ MARKER _ INTERVAL _ MILLIS , TimeUnit . MILLISECONDS ) ; 
 + commitLogService . shutdown ( ) ; 
 + Assert . assertFalse ( syncRunnable . sync ( ) ) ; 
 + Assert . assertEquals ( 2 , commitLog . markCount . get ( ) ) ; 
 + Assert . assertEquals ( 2 , commitLog . syncCount . get ( ) ) ; 
 + } 
 + 
 + private static class FakeCommitLog extends CommitLog 
 + { 
 + private final AtomicInteger markCount = new AtomicInteger ( ) ; 
 + private final AtomicInteger syncCount = new AtomicInteger ( ) ; 
 + 
 + FakeCommitLog ( ) 
 + { 
 + super ( DatabaseDescriptor . getCommitLogLocation ( ) , null ) ; 
 + } 
 + 
 + @ Override 
 + CommitLog start ( ) 
 + { 
 + / / this is a bit dicey . we need to start the allocator , but starting the parent ' s executor will muck things 
 + / / up as it is pointing to a different executor service , not the fake one in this test class . 
 + allocator . start ( ) ; 
 + return this ; 
 + } 
 + 
 + @ Override 
 + public void sync ( boolean syncAllSegments , boolean flush ) 
 + { 
 + if ( flush ) 
 + syncCount . incrementAndGet ( ) ; 
 + else 
 + markCount . incrementAndGet ( ) ; 
 + } 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java 
 index e2b9f72 . . b73275b 100644 
 - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogChainedMarkersTest . java 
 @ @ - 65 , 7 + 65 , 6 @ @ public class CommitLogChainedMarkersTest 
 DatabaseDescriptor . setCommitLogSegmentSize ( 5 ) ; 
 DatabaseDescriptor . setCommitLogSync ( Config . CommitLogSync . periodic ) ; 
 DatabaseDescriptor . setCommitLogSyncPeriod ( 10000 * 1000 ) ; 
 - DatabaseDescriptor . setCommitLogMarkerPeriod ( 1 ) ; 
 SchemaLoader . prepareServer ( ) ; 
 SchemaLoader . createKeyspace ( KEYSPACE1 , 
 KeyspaceParams . simple ( 1 ) , 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java 
 index a1999ef . . c615880 100644 
 - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogSegmentBackpressureTest . java 
 @ @ - 64 , 13 + 64 , 13 @ @ public class CommitLogSegmentBackpressureTest 
 
 @ Test 
 @ BMRules ( rules = { @ BMRule ( name = " Acquire Semaphore before sync " , 
 - targetClass = " AbstractCommitLogService $ 1 " , 
 - targetMethod = " run " , 
 + targetClass = " AbstractCommitLogService $ SyncRunnable " , 
 + targetMethod = " sync " , 
 targetLocation = " AT INVOKE org . apache . cassandra . db . commitlog . CommitLog . sync ( boolean , boolean ) " , 
 action = " org . apache . cassandra . db . commitlog . CommitLogSegmentBackpressureTest . allowSync . acquire ( ) " ) , 
 @ BMRule ( name = " Release Semaphore after sync " , 
 - targetClass = " AbstractCommitLogService $ 1 " , 
 - targetMethod = " run " , 
 + targetClass = " AbstractCommitLogService $ SyncRunnable " , 
 + targetMethod = " sync " , 
 targetLocation = " AFTER INVOKE org . apache . cassandra . db . commitlog . CommitLog . sync ( boolean , boolean ) " , 
 action = " org . apache . cassandra . db . commitlog . CommitLogSegmentBackpressureTest . allowSync . release ( ) " ) } ) 
 public void testCompressedCommitLogBackpressure ( ) throws Throwable 
 diff - - git a / test / unit / org / apache / cassandra / utils / FreeRunningClock . java b / test / unit / org / apache / cassandra / utils / FreeRunningClock . java 
 new file mode 100644 
 index 0000000 . . 83c8db7 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / utils / FreeRunningClock . java 
 @ @ - 0 , 0 + 1 , 46 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . utils ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + / * * 
 + * A freely adjustable clock that can be used for unit testing . See { @ link Clock # instance } how to 
 + * enable this class . 
 + * / 
 + public class FreeRunningClock extends Clock 
 + { 
 + private long nanoTime = 0 ; 
 + 
 + @ Override 
 + public long nanoTime ( ) 
 + { 
 + return nanoTime ; 
 + } 
 + 
 + @ Override 
 + public long currentTimeMillis ( ) 
 + { 
 + return TimeUnit . NANOSECONDS . toMillis ( nanoTime ( ) ) ; 
 + } 
 + 
 + public void advance ( long time , TimeUnit unit ) 
 + { 
 + nanoTime + = unit . toNanos ( time ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
