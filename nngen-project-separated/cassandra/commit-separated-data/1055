BLEU SCORE: 0.028398387225677897

TEST MSG: Run STCS in L0 even when the higher levels do not produce a candidate
GENERATED MSG: fix bug in sstable blacklisting with LCS

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ae3082a . . 751267e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 2 . 5 <nl> + * Start L0 STCS - compactions even if there is a L0 - > L1 compaction <nl> + going ( CASSANDRA - 10979 ) <nl> * Make UUID LSB unique per process ( CASSANDRA - 7925 ) <nl> * Avoid NPE when performing sstable tasks ( scrub etc . ) ( CASSANDRA - 10980 ) <nl> * Make sure client gets tombstone overwhelmed warning ( CASSANDRA - 9465 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index d90318f . . 544b0a8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 322 , 15 + 322 , 9 @ @ public class LeveledManifest <nl> if ( score > 1 . 001 ) <nl> { <nl> / / before proceeding with a higher level , let ' s see if L0 is far enough behind to warrant STCS <nl> - if ( ! DatabaseDescriptor . getDisableSTCSInL0 ( ) & & getLevel ( 0 ) . size ( ) > MAX _ COMPACTING _ L0 ) <nl> - { <nl> - List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( 0 ) ) ; <nl> - if ( ! mostInteresting . isEmpty ( ) ) <nl> - { <nl> - logger . trace ( " L0 is too far behind , performing size - tiering there first " ) ; <nl> - return new CompactionCandidate ( mostInteresting , 0 , Long . MAX _ VALUE ) ; <nl> - } <nl> - } <nl> + CompactionCandidate l0Compaction = getSTCSInL0CompactionCandidate ( ) ; <nl> + if ( l0Compaction ! = null ) <nl> + return l0Compaction ; <nl> <nl> / / L0 is fine , proceed with this level <nl> Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; <nl> @ @ - 354 , 10 + 348 , 30 @ @ public class LeveledManifest <nl> return null ; <nl> Collection < SSTableReader > candidates = getCandidatesFor ( 0 ) ; <nl> if ( candidates . isEmpty ( ) ) <nl> - return null ; <nl> + { <nl> + / / Since we don ' t have any other compactions to do , see if there is a STCS compaction to perform in L0 ; if <nl> + / / there is a long running compaction , we want to make sure that we continue to keep the number of SSTables <nl> + / / small in L0 . <nl> + return getSTCSInL0CompactionCandidate ( ) ; <nl> + } <nl> return new CompactionCandidate ( candidates , getNextLevel ( candidates ) , cfs . getCompactionStrategy ( ) . getMaxSSTableBytes ( ) ) ; <nl> } <nl> <nl> + private CompactionCandidate getSTCSInL0CompactionCandidate ( ) <nl> + { <nl> + if ( ! DatabaseDescriptor . getDisableSTCSInL0 ( ) & & getLevel ( 0 ) . size ( ) > MAX _ COMPACTING _ L0 ) <nl> + { <nl> + List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( 0 ) ) ; <nl> + if ( ! mostInteresting . isEmpty ( ) ) <nl> + { <nl> + logger . debug ( " L0 is too far behind , performing size - tiering there first " ) ; <nl> + return new CompactionCandidate ( mostInteresting , 0 , Long . MAX _ VALUE ) ; <nl> + } <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> private List < SSTableReader > getSSTablesForSTCS ( Collection < SSTableReader > sstables ) <nl> { <nl> Iterable < SSTableReader > candidates = cfs . getTracker ( ) . getUncompacting ( sstables ) ;
NEAREST DIFF (one line): diff - - git a / build . xml b / build . xml <nl> index 2f005f7 . . c5778ff 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 997 , 7 + 997 , 8 @ @ <nl> < javac <nl> debug = " true " <nl> debuglevel = " $ { debuglevel } " <nl> - destdir = " $ { test . classes } " > <nl> + destdir = " $ { test . classes } " <nl> + includeantruntime = " false " > <nl> < classpath > <nl> < path refid = " cassandra . classpath " / > <nl> < / classpath >

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ae3082a . . 751267e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 2 . 5 
 + * Start L0 STCS - compactions even if there is a L0 - > L1 compaction 
 + going ( CASSANDRA - 10979 ) 
 * Make UUID LSB unique per process ( CASSANDRA - 7925 ) 
 * Avoid NPE when performing sstable tasks ( scrub etc . ) ( CASSANDRA - 10980 ) 
 * Make sure client gets tombstone overwhelmed warning ( CASSANDRA - 9465 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index d90318f . . 544b0a8 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 322 , 15 + 322 , 9 @ @ public class LeveledManifest 
 if ( score > 1 . 001 ) 
 { 
 / / before proceeding with a higher level , let ' s see if L0 is far enough behind to warrant STCS 
 - if ( ! DatabaseDescriptor . getDisableSTCSInL0 ( ) & & getLevel ( 0 ) . size ( ) > MAX _ COMPACTING _ L0 ) 
 - { 
 - List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( 0 ) ) ; 
 - if ( ! mostInteresting . isEmpty ( ) ) 
 - { 
 - logger . trace ( " L0 is too far behind , performing size - tiering there first " ) ; 
 - return new CompactionCandidate ( mostInteresting , 0 , Long . MAX _ VALUE ) ; 
 - } 
 - } 
 + CompactionCandidate l0Compaction = getSTCSInL0CompactionCandidate ( ) ; 
 + if ( l0Compaction ! = null ) 
 + return l0Compaction ; 
 
 / / L0 is fine , proceed with this level 
 Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; 
 @ @ - 354 , 10 + 348 , 30 @ @ public class LeveledManifest 
 return null ; 
 Collection < SSTableReader > candidates = getCandidatesFor ( 0 ) ; 
 if ( candidates . isEmpty ( ) ) 
 - return null ; 
 + { 
 + / / Since we don ' t have any other compactions to do , see if there is a STCS compaction to perform in L0 ; if 
 + / / there is a long running compaction , we want to make sure that we continue to keep the number of SSTables 
 + / / small in L0 . 
 + return getSTCSInL0CompactionCandidate ( ) ; 
 + } 
 return new CompactionCandidate ( candidates , getNextLevel ( candidates ) , cfs . getCompactionStrategy ( ) . getMaxSSTableBytes ( ) ) ; 
 } 
 
 + private CompactionCandidate getSTCSInL0CompactionCandidate ( ) 
 + { 
 + if ( ! DatabaseDescriptor . getDisableSTCSInL0 ( ) & & getLevel ( 0 ) . size ( ) > MAX _ COMPACTING _ L0 ) 
 + { 
 + List < SSTableReader > mostInteresting = getSSTablesForSTCS ( getLevel ( 0 ) ) ; 
 + if ( ! mostInteresting . isEmpty ( ) ) 
 + { 
 + logger . debug ( " L0 is too far behind , performing size - tiering there first " ) ; 
 + return new CompactionCandidate ( mostInteresting , 0 , Long . MAX _ VALUE ) ; 
 + } 
 + } 
 + 
 + return null ; 
 + } 
 + 
 private List < SSTableReader > getSSTablesForSTCS ( Collection < SSTableReader > sstables ) 
 { 
 Iterable < SSTableReader > candidates = cfs . getTracker ( ) . getUncompacting ( sstables ) ;

NEAREST DIFF:
diff - - git a / build . xml b / build . xml 
 index 2f005f7 . . c5778ff 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 997 , 7 + 997 , 8 @ @ 
 < javac 
 debug = " true " 
 debuglevel = " $ { debuglevel } " 
 - destdir = " $ { test . classes } " > 
 + destdir = " $ { test . classes } " 
 + includeantruntime = " false " > 
 < classpath > 
 < path refid = " cassandra . classpath " / > 
 < / classpath >
