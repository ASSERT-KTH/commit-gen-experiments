BLEU SCORE: 0.041961149062965476

TEST MSG: Add a check for receiving digest response from transient node
GENERATED MSG: merge # 3440 from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 76b7b8b . . f9d2f3c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add a check for receiving digest response from transient node ( CASSANDRA - 14750 ) <nl> * Fail query on transient replica if coordinator only expects full data ( CASSANDRA - 14704 ) <nl> * Remove mentions of transient replication from repair path ( CASSANDRA - 14698 ) <nl> * Fix handleRepairStatusChangedNotification to remove first then add ( CASSANDRA - 14720 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> index 79db18a . . 7928039 100644 <nl> - - - a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java <nl> @ @ - 21 , 7 + 21 , 6 @ @ import java . io . IOException ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> <nl> - import org . apache . cassandra . net . ParameterType ; <nl> import org . apache . cassandra . schema . TableMetadata ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . filter . * ; <nl> @ @ - 173 , 7 + 172 , 8 @ @ public class PartitionRangeReadCommand extends ReadCommand implements PartitionR <nl> indexMetadata ( ) ) ; <nl> } <nl> <nl> - public PartitionRangeReadCommand copyAsDigestQuery ( ) <nl> + @ Override <nl> + protected PartitionRangeReadCommand copyAsDigestQuery ( ) <nl> { <nl> return new PartitionRangeReadCommand ( true , <nl> digestVersion ( ) , <nl> @ @ - 187 , 7 + 187 , 8 @ @ public class PartitionRangeReadCommand extends ReadCommand implements PartitionR <nl> indexMetadata ( ) ) ; <nl> } <nl> <nl> - public PartitionRangeReadCommand copyAsTransientQuery ( ) <nl> + @ Override <nl> + protected PartitionRangeReadCommand copyAsTransientQuery ( ) <nl> { <nl> return new PartitionRangeReadCommand ( false , <nl> 0 , <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> index e146b8a . . ada4ae6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . util . function . LongPredicate ; <nl> <nl> import javax . annotation . Nullable ; <nl> <nl> + import com . google . common . base . Preconditions ; <nl> import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Sets ; <nl> import com . google . common . hash . Hasher ; <nl> @ @ - 49 , 6 + 50 , 8 @ @ import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> + import org . apache . cassandra . locator . Replica ; <nl> + import org . apache . cassandra . locator . ReplicaCollection ; <nl> import org . apache . cassandra . metrics . TableMetrics ; <nl> import org . apache . cassandra . net . MessageOut ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> @ @ - 142 , 6 + 145 , 9 @ @ public abstract class ReadCommand extends AbstractReadQuery <nl> IndexMetadata index ) <nl> { <nl> super ( metadata , nowInSec , columnFilter , rowFilter , limits ) ; <nl> + if ( acceptsTransient & & isDigestQuery ) <nl> + throw new IllegalArgumentException ( " Attempted to issue a digest response to transient replica " ) ; <nl> + <nl> this . kind = kind ; <nl> this . isDigestQuery = isDigestQuery ; <nl> this . digestVersion = digestVersion ; <nl> @ @ - 308 , 10 + 314 , 49 @ @ public abstract class ReadCommand extends AbstractReadQuery <nl> public abstract ReadCommand copy ( ) ; <nl> <nl> / * * <nl> + * Returns a copy of this command with acceptsTransient set to true . <nl> + * / <nl> + public ReadCommand copyAsTransientQuery ( Replica replica ) <nl> + { <nl> + Preconditions . checkArgument ( replica . isTransient ( ) , <nl> + " Can ' t make a transient request on a full replica : " + replica ) ; <nl> + return copyAsTransientQuery ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns a copy of this command with acceptsTransient set to true . <nl> + * / <nl> + public ReadCommand copyAsTransientQuery ( ReplicaCollection < ? > replicas ) <nl> + { <nl> + if ( Iterables . any ( replicas , Replica : : isFull ) ) <nl> + throw new IllegalArgumentException ( " Can ' t make a transient request on full replicas : " + replicas . filter ( Replica : : isFull ) ) ; <nl> + return copyAsTransientQuery ( ) ; <nl> + } <nl> + <nl> + protected abstract ReadCommand copyAsTransientQuery ( ) ; <nl> + <nl> + / * * <nl> * Returns a copy of this command with isDigestQuery set to true . <nl> * / <nl> - public abstract ReadCommand copyAsDigestQuery ( ) ; <nl> - public abstract ReadCommand copyAsTransientQuery ( ) ; <nl> + public ReadCommand copyAsDigestQuery ( Replica replica ) <nl> + { <nl> + Preconditions . checkArgument ( replica . isFull ( ) , <nl> + " Can ' t make a digest request on a transient replica " + replica ) ; <nl> + return copyAsDigestQuery ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns a copy of this command with isDigestQuery set to true . <nl> + * / <nl> + public ReadCommand copyAsDigestQuery ( ReplicaCollection < ? > replicas ) <nl> + { <nl> + if ( Iterables . any ( replicas , Replica : : isTransient ) ) <nl> + throw new IllegalArgumentException ( " Can ' t make a digest request on a transient replica " + replicas . filter ( Replica : : isTransient ) ) ; <nl> + <nl> + return copyAsDigestQuery ( ) ; <nl> + } <nl> + <nl> + protected abstract ReadCommand copyAsDigestQuery ( ) ; <nl> <nl> protected abstract UnfilteredPartitionIterator queryStorage ( ColumnFamilyStore cfs , ReadExecutionController executionController ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> index e99a487 . . b763217 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> @ @ - 22 , 6 + 22 , 8 @ @ import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . base . Preconditions ; <nl> + import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Sets ; <nl> <nl> import org . apache . cassandra . cache . IRowCacheEntry ; <nl> @ @ - 40 , 6 + 42 , 8 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReadsListener ; <nl> import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> + import org . apache . cassandra . locator . Replica ; <nl> + import org . apache . cassandra . locator . ReplicaCollection ; <nl> import org . apache . cassandra . metrics . TableMetrics ; <nl> import org . apache . cassandra . net . MessageOut ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> @ @ - 294 , 7 + 298 , 8 @ @ public class SinglePartitionReadCommand extends ReadCommand implements SinglePar <nl> indexMetadata ( ) ) ; <nl> } <nl> <nl> - public SinglePartitionReadCommand copyAsDigestQuery ( ) <nl> + @ Override <nl> + protected SinglePartitionReadCommand copyAsDigestQuery ( ) <nl> { <nl> return new SinglePartitionReadCommand ( true , <nl> digestVersion ( ) , <nl> @ @ - 309 , 7 + 314 , 8 @ @ public class SinglePartitionReadCommand extends ReadCommand implements SinglePar <nl> indexMetadata ( ) ) ; <nl> } <nl> <nl> - public SinglePartitionReadCommand copyAsTransientQuery ( ) <nl> + @ Override <nl> + protected SinglePartitionReadCommand copyAsTransientQuery ( ) <nl> { <nl> return new SinglePartitionReadCommand ( false , <nl> 0 , <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index fc49330 . . 0d52afa 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 2107 , 7 + 2107 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> for ( Replica replica : replicaPlan . contacts ( ) ) <nl> { <nl> Tracing . trace ( " Enqueuing request to { } " , replica ) ; <nl> - PartitionRangeReadCommand command = replica . isFull ( ) ? rangeCommand : rangeCommand . copyAsTransientQuery ( ) ; <nl> + ReadCommand command = replica . isFull ( ) ? rangeCommand : rangeCommand . copyAsTransientQuery ( replica ) ; <nl> MessageOut < ReadCommand > message = command . createMessage ( ) ; <nl> if ( command . isTrackingRepairedStatus ( ) & & replica . isFull ( ) ) <nl> message = message . withParameter ( ParameterType . TRACK _ REPAIRED _ DATA , MessagingService . ONE _ BYTE ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java b / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java <nl> index c296cba . . 6881a2f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java <nl> @ @ - 119 , 14 + 119 , 14 @ @ public abstract class AbstractReadExecutor <nl> <nl> protected void makeTransientDataRequests ( ReplicaCollection < ? > replicas ) <nl> { <nl> - makeRequests ( command . copyAsTransientQuery ( ) , replicas ) ; <nl> + makeRequests ( command . copyAsTransientQuery ( replicas ) , replicas ) ; <nl> } <nl> <nl> protected void makeDigestRequests ( ReplicaCollection < ? > replicas ) <nl> { <nl> assert all ( replicas , Replica : : isFull ) ; <nl> / / only send digest requests to full replicas , send data requests instead to the transient replicas <nl> - makeRequests ( command . copyAsDigestQuery ( ) , replicas ) ; <nl> + makeRequests ( command . copyAsDigestQuery ( replicas ) , replicas ) ; <nl> } <nl> <nl> private void makeRequests ( ReadCommand readCommand , ReplicaCollection < ? > replicas ) <nl> @ @ - 284 , 8 + 284 , 8 @ @ public abstract class AbstractReadExecutor <nl> assert extraReplica ! = null ; <nl> <nl> retryCommand = extraReplica . isTransient ( ) <nl> - ? command . copyAsTransientQuery ( ) <nl> - : command . copyAsDigestQuery ( ) ; <nl> + ? command . copyAsTransientQuery ( extraReplica ) <nl> + : command . copyAsDigestQuery ( extraReplica ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / DigestResolver . java b / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> index 0dcae95 . . 899baf9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / DigestResolver . java <nl> @ @ - 57 , 13 + 57 , 7 @ @ public class DigestResolver < E extends Endpoints < E > , P extends ReplicaPlan . ForRea <nl> super . preprocess ( message ) ; <nl> Replica replica = replicaPlan ( ) . getReplicaFor ( message . from ) ; <nl> if ( dataResponse = = null & & ! message . payload . isDigestResponse ( ) & & replica . isFull ( ) ) <nl> - { <nl> dataResponse = message ; <nl> - } <nl> - else if ( replica . isTransient ( ) & & message . payload . isDigestResponse ( ) ) <nl> - { <nl> - throw new IllegalStateException ( " digest response received from transient replica " ) ; <nl> - } <nl> } <nl> <nl> @ VisibleForTesting <nl> diff - - git a / src / java / org / apache / cassandra / service / reads / ResponseResolver . java b / src / java / org / apache / cassandra / service / reads / ResponseResolver . java <nl> index 0c1e1ba . . aaead84 100644 <nl> - - - a / src / java / org / apache / cassandra / service / reads / ResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / reads / ResponseResolver . java <nl> @ @ - 55 , 6 + 55 , 10 @ @ public abstract class ResponseResolver < E extends Endpoints < E > , P extends Replica <nl> <nl> public void preprocess ( MessageIn < ReadResponse > message ) <nl> { <nl> + if ( replicaPlan ( ) . getReplicaFor ( message . from ) . isTransient ( ) & & <nl> + message . payload . isDigestResponse ( ) ) <nl> + throw new IllegalArgumentException ( " Digest response received from transient replica " ) ; <nl> + <nl> try <nl> { <nl> responses . add ( message ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / ReadCommandTest . java b / test / unit / org / apache / cassandra / db / ReadCommandTest . java <nl> index 8df7651 . . fba2bf2 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ReadCommandTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ReadCommandTest . java <nl> @ @ - 52 , 7 + 52 , 9 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . io . util . DataInputBuffer ; <nl> import org . apache . cassandra . io . util . DataOutputBuffer ; <nl> import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; <nl> + import org . apache . cassandra . locator . EndpointsForToken ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . locator . ReplicaUtils ; <nl> import org . apache . cassandra . net . MessageOut ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . repair . consistent . LocalSessionAccessor ; <nl> @ @ - 681 , 6 + 683 , 50 @ @ public class ReadCommandTest <nl> assertEquals ( cacheHits , cfs . metric . rowCacheHit . getCount ( ) ) ; <nl> } <nl> <nl> + @ Test ( expected = IllegalArgumentException . class ) <nl> + public void copyFullAsTransientTest ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; <nl> + ReadCommand readCommand = Util . cmd ( cfs , Util . dk ( " key " ) ) . build ( ) ; <nl> + readCommand . copyAsTransientQuery ( ReplicaUtils . full ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) ; <nl> + } <nl> + <nl> + @ Test ( expected = IllegalArgumentException . class ) <nl> + public void copyTransientAsDigestQuery ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; <nl> + ReadCommand readCommand = Util . cmd ( cfs , Util . dk ( " key " ) ) . build ( ) ; <nl> + readCommand . copyAsDigestQuery ( ReplicaUtils . trans ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) ; <nl> + } <nl> + <nl> + @ Test ( expected = IllegalArgumentException . class ) <nl> + public void copyMultipleFullAsTransientTest ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; <nl> + DecoratedKey key = Util . dk ( " key " ) ; <nl> + Token token = key . getToken ( ) ; <nl> + / / Address is unimportant for this test <nl> + InetAddressAndPort addr = FBUtilities . getBroadcastAddressAndPort ( ) ; <nl> + ReadCommand readCommand = Util . cmd ( cfs , key ) . build ( ) ; <nl> + readCommand . copyAsTransientQuery ( EndpointsForToken . of ( token , <nl> + ReplicaUtils . trans ( addr , token ) , <nl> + ReplicaUtils . full ( addr , token ) ) ) ; <nl> + } <nl> + <nl> + @ Test ( expected = IllegalArgumentException . class ) <nl> + public void copyMultipleTransientAsDigestQuery ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; <nl> + DecoratedKey key = Util . dk ( " key " ) ; <nl> + Token token = key . getToken ( ) ; <nl> + / / Address is unimportant for this test <nl> + InetAddressAndPort addr = FBUtilities . getBroadcastAddressAndPort ( ) ; <nl> + ReadCommand readCommand = Util . cmd ( cfs , key ) . build ( ) ; <nl> + readCommand . copyAsDigestQuery ( EndpointsForToken . of ( token , <nl> + ReplicaUtils . trans ( addr , token ) , <nl> + ReplicaUtils . full ( addr , token ) ) ) ; <nl> + } <nl> + <nl> private void testRepairedDataTracking ( ColumnFamilyStore cfs , ReadCommand readCommand ) throws IOException <nl> { <nl> cfs . truncateBlocking ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / ReplicaUtils . java b / test / unit / org / apache / cassandra / locator / ReplicaUtils . java <nl> index 66f538f . . c5350dc 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / ReplicaUtils . java <nl> + + + b / test / unit / org / apache / cassandra / locator / ReplicaUtils . java <nl> @ @ - 41 , 4 + 41 , 14 @ @ public class ReplicaUtils <nl> { <nl> return transientReplica ( endpoint , FULL _ RANGE ) ; <nl> } <nl> + <nl> + public static Replica full ( InetAddressAndPort endpoint , Token token ) <nl> + { <nl> + return fullReplica ( endpoint , new Range < > ( token , token ) ) ; <nl> + } <nl> + <nl> + public static Replica trans ( InetAddressAndPort endpoint , Token token ) <nl> + { <nl> + return transientReplica ( endpoint , new Range < > ( token , token ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6ef1317 . . 2bd02c4 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 15 , 7 + 15 , 7 @ @ Merged from 0 . 8 : <nl> * fix array out of bounds error in counter shard removal ( CASSANDRA - 3514 ) <nl> * avoid dropping tombstones when they might still be needed to shadow <nl> data in a different sstable ( CASSANDRA - 2786 ) <nl> - <nl> + * fix ConcurrentModificationException in Table . all ( ) ( CASSANDRA - 3529 ) <nl> <nl> 1 . 0 . 3 <nl> * revert name - based query defragmentation aka CASSANDRA - 2503 ( CASSANDRA - 3491 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java <nl> index 924d1be . . 99ca791 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Schema . java <nl> + + + b / src / java / org / apache / cassandra / config / Schema . java <nl> @ @ - 49 , 13 + 49 , 13 @ @ public class Schema <nl> private final AtomicInteger cfIdGen = new AtomicInteger ( MIN _ CF _ ID ) ; <nl> <nl> / * metadata map for faster table lookup * / <nl> - private final Map < String , KSMetaData > tables ; <nl> + private final Map < String , KSMetaData > tables = new NonBlockingHashMap < String , KSMetaData > ( ) ; <nl> <nl> / * Table objects , one per keyspace . Only one instance should ever exist for any given keyspace . * / <nl> - private final Map < String , Table > tableInstances ; <nl> + private final Map < String , Table > tableInstances = new NonBlockingHashMap < String , Table > ( ) ; <nl> <nl> / * metadata map for faster ColumnFamily lookup * / <nl> - private final BiMap < Pair < String , String > , Integer > cfIdMap ; <nl> + private final BiMap < Pair < String , String > , Integer > cfIdMap = HashBiMap . create ( ) ; <nl> <nl> private volatile UUID version ; <nl> <nl> @ @ - 65 , 9 + 65 , 6 @ @ public class Schema <nl> * / <nl> public Schema ( UUID initialVersion ) <nl> { <nl> - tables = new HashMap < String , KSMetaData > ( ) ; <nl> - tableInstances = new NonBlockingHashMap < String , Table > ( ) ; <nl> - cfIdMap = HashBiMap . create ( ) ; <nl> version = initialVersion ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 76b7b8b . . f9d2f3c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add a check for receiving digest response from transient node ( CASSANDRA - 14750 ) 
 * Fail query on transient replica if coordinator only expects full data ( CASSANDRA - 14704 ) 
 * Remove mentions of transient replication from repair path ( CASSANDRA - 14698 ) 
 * Fix handleRepairStatusChangedNotification to remove first then add ( CASSANDRA - 14720 ) 
 diff - - git a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 index 79db18a . . 7928039 100644 
 - - - a / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / PartitionRangeReadCommand . java 
 @ @ - 21 , 7 + 21 , 6 @ @ import java . io . IOException ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 
 - import org . apache . cassandra . net . ParameterType ; 
 import org . apache . cassandra . schema . TableMetadata ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . filter . * ; 
 @ @ - 173 , 7 + 172 , 8 @ @ public class PartitionRangeReadCommand extends ReadCommand implements PartitionR 
 indexMetadata ( ) ) ; 
 } 
 
 - public PartitionRangeReadCommand copyAsDigestQuery ( ) 
 + @ Override 
 + protected PartitionRangeReadCommand copyAsDigestQuery ( ) 
 { 
 return new PartitionRangeReadCommand ( true , 
 digestVersion ( ) , 
 @ @ - 187 , 7 + 187 , 8 @ @ public class PartitionRangeReadCommand extends ReadCommand implements PartitionR 
 indexMetadata ( ) ) ; 
 } 
 
 - public PartitionRangeReadCommand copyAsTransientQuery ( ) 
 + @ Override 
 + protected PartitionRangeReadCommand copyAsTransientQuery ( ) 
 { 
 return new PartitionRangeReadCommand ( false , 
 0 , 
 diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java 
 index e146b8a . . ada4ae6 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / ReadCommand . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . util . function . LongPredicate ; 
 
 import javax . annotation . Nullable ; 
 
 + import com . google . common . base . Preconditions ; 
 import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Sets ; 
 import com . google . common . hash . Hasher ; 
 @ @ - 49 , 6 + 50 , 8 @ @ import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 + import org . apache . cassandra . locator . Replica ; 
 + import org . apache . cassandra . locator . ReplicaCollection ; 
 import org . apache . cassandra . metrics . TableMetrics ; 
 import org . apache . cassandra . net . MessageOut ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 @ @ - 142 , 6 + 145 , 9 @ @ public abstract class ReadCommand extends AbstractReadQuery 
 IndexMetadata index ) 
 { 
 super ( metadata , nowInSec , columnFilter , rowFilter , limits ) ; 
 + if ( acceptsTransient & & isDigestQuery ) 
 + throw new IllegalArgumentException ( " Attempted to issue a digest response to transient replica " ) ; 
 + 
 this . kind = kind ; 
 this . isDigestQuery = isDigestQuery ; 
 this . digestVersion = digestVersion ; 
 @ @ - 308 , 10 + 314 , 49 @ @ public abstract class ReadCommand extends AbstractReadQuery 
 public abstract ReadCommand copy ( ) ; 
 
 / * * 
 + * Returns a copy of this command with acceptsTransient set to true . 
 + * / 
 + public ReadCommand copyAsTransientQuery ( Replica replica ) 
 + { 
 + Preconditions . checkArgument ( replica . isTransient ( ) , 
 + " Can ' t make a transient request on a full replica : " + replica ) ; 
 + return copyAsTransientQuery ( ) ; 
 + } 
 + 
 + / * * 
 + * Returns a copy of this command with acceptsTransient set to true . 
 + * / 
 + public ReadCommand copyAsTransientQuery ( ReplicaCollection < ? > replicas ) 
 + { 
 + if ( Iterables . any ( replicas , Replica : : isFull ) ) 
 + throw new IllegalArgumentException ( " Can ' t make a transient request on full replicas : " + replicas . filter ( Replica : : isFull ) ) ; 
 + return copyAsTransientQuery ( ) ; 
 + } 
 + 
 + protected abstract ReadCommand copyAsTransientQuery ( ) ; 
 + 
 + / * * 
 * Returns a copy of this command with isDigestQuery set to true . 
 * / 
 - public abstract ReadCommand copyAsDigestQuery ( ) ; 
 - public abstract ReadCommand copyAsTransientQuery ( ) ; 
 + public ReadCommand copyAsDigestQuery ( Replica replica ) 
 + { 
 + Preconditions . checkArgument ( replica . isFull ( ) , 
 + " Can ' t make a digest request on a transient replica " + replica ) ; 
 + return copyAsDigestQuery ( ) ; 
 + } 
 + 
 + / * * 
 + * Returns a copy of this command with isDigestQuery set to true . 
 + * / 
 + public ReadCommand copyAsDigestQuery ( ReplicaCollection < ? > replicas ) 
 + { 
 + if ( Iterables . any ( replicas , Replica : : isTransient ) ) 
 + throw new IllegalArgumentException ( " Can ' t make a digest request on a transient replica " + replicas . filter ( Replica : : isTransient ) ) ; 
 + 
 + return copyAsDigestQuery ( ) ; 
 + } 
 + 
 + protected abstract ReadCommand copyAsDigestQuery ( ) ; 
 
 protected abstract UnfilteredPartitionIterator queryStorage ( ColumnFamilyStore cfs , ReadExecutionController executionController ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 index e99a487 . . b763217 100644 
 - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 @ @ - 22 , 6 + 22 , 8 @ @ import java . nio . ByteBuffer ; 
 import java . util . * ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . base . Preconditions ; 
 + import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Sets ; 
 
 import org . apache . cassandra . cache . IRowCacheEntry ; 
 @ @ - 40 , 6 + 42 , 8 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . io . sstable . format . SSTableReadsListener ; 
 import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 + import org . apache . cassandra . locator . Replica ; 
 + import org . apache . cassandra . locator . ReplicaCollection ; 
 import org . apache . cassandra . metrics . TableMetrics ; 
 import org . apache . cassandra . net . MessageOut ; 
 import org . apache . cassandra . net . MessagingService ; 
 @ @ - 294 , 7 + 298 , 8 @ @ public class SinglePartitionReadCommand extends ReadCommand implements SinglePar 
 indexMetadata ( ) ) ; 
 } 
 
 - public SinglePartitionReadCommand copyAsDigestQuery ( ) 
 + @ Override 
 + protected SinglePartitionReadCommand copyAsDigestQuery ( ) 
 { 
 return new SinglePartitionReadCommand ( true , 
 digestVersion ( ) , 
 @ @ - 309 , 7 + 314 , 8 @ @ public class SinglePartitionReadCommand extends ReadCommand implements SinglePar 
 indexMetadata ( ) ) ; 
 } 
 
 - public SinglePartitionReadCommand copyAsTransientQuery ( ) 
 + @ Override 
 + protected SinglePartitionReadCommand copyAsTransientQuery ( ) 
 { 
 return new SinglePartitionReadCommand ( false , 
 0 , 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index fc49330 . . 0d52afa 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 2107 , 7 + 2107 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 for ( Replica replica : replicaPlan . contacts ( ) ) 
 { 
 Tracing . trace ( " Enqueuing request to { } " , replica ) ; 
 - PartitionRangeReadCommand command = replica . isFull ( ) ? rangeCommand : rangeCommand . copyAsTransientQuery ( ) ; 
 + ReadCommand command = replica . isFull ( ) ? rangeCommand : rangeCommand . copyAsTransientQuery ( replica ) ; 
 MessageOut < ReadCommand > message = command . createMessage ( ) ; 
 if ( command . isTrackingRepairedStatus ( ) & & replica . isFull ( ) ) 
 message = message . withParameter ( ParameterType . TRACK _ REPAIRED _ DATA , MessagingService . ONE _ BYTE ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java b / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java 
 index c296cba . . 6881a2f 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java 
 + + + b / src / java / org / apache / cassandra / service / reads / AbstractReadExecutor . java 
 @ @ - 119 , 14 + 119 , 14 @ @ public abstract class AbstractReadExecutor 
 
 protected void makeTransientDataRequests ( ReplicaCollection < ? > replicas ) 
 { 
 - makeRequests ( command . copyAsTransientQuery ( ) , replicas ) ; 
 + makeRequests ( command . copyAsTransientQuery ( replicas ) , replicas ) ; 
 } 
 
 protected void makeDigestRequests ( ReplicaCollection < ? > replicas ) 
 { 
 assert all ( replicas , Replica : : isFull ) ; 
 / / only send digest requests to full replicas , send data requests instead to the transient replicas 
 - makeRequests ( command . copyAsDigestQuery ( ) , replicas ) ; 
 + makeRequests ( command . copyAsDigestQuery ( replicas ) , replicas ) ; 
 } 
 
 private void makeRequests ( ReadCommand readCommand , ReplicaCollection < ? > replicas ) 
 @ @ - 284 , 8 + 284 , 8 @ @ public abstract class AbstractReadExecutor 
 assert extraReplica ! = null ; 
 
 retryCommand = extraReplica . isTransient ( ) 
 - ? command . copyAsTransientQuery ( ) 
 - : command . copyAsDigestQuery ( ) ; 
 + ? command . copyAsTransientQuery ( extraReplica ) 
 + : command . copyAsDigestQuery ( extraReplica ) ; 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / reads / DigestResolver . java b / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 index 0dcae95 . . 899baf9 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 + + + b / src / java / org / apache / cassandra / service / reads / DigestResolver . java 
 @ @ - 57 , 13 + 57 , 7 @ @ public class DigestResolver < E extends Endpoints < E > , P extends ReplicaPlan . ForRea 
 super . preprocess ( message ) ; 
 Replica replica = replicaPlan ( ) . getReplicaFor ( message . from ) ; 
 if ( dataResponse = = null & & ! message . payload . isDigestResponse ( ) & & replica . isFull ( ) ) 
 - { 
 dataResponse = message ; 
 - } 
 - else if ( replica . isTransient ( ) & & message . payload . isDigestResponse ( ) ) 
 - { 
 - throw new IllegalStateException ( " digest response received from transient replica " ) ; 
 - } 
 } 
 
 @ VisibleForTesting 
 diff - - git a / src / java / org / apache / cassandra / service / reads / ResponseResolver . java b / src / java / org / apache / cassandra / service / reads / ResponseResolver . java 
 index 0c1e1ba . . aaead84 100644 
 - - - a / src / java / org / apache / cassandra / service / reads / ResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / reads / ResponseResolver . java 
 @ @ - 55 , 6 + 55 , 10 @ @ public abstract class ResponseResolver < E extends Endpoints < E > , P extends Replica 
 
 public void preprocess ( MessageIn < ReadResponse > message ) 
 { 
 + if ( replicaPlan ( ) . getReplicaFor ( message . from ) . isTransient ( ) & & 
 + message . payload . isDigestResponse ( ) ) 
 + throw new IllegalArgumentException ( " Digest response received from transient replica " ) ; 
 + 
 try 
 { 
 responses . add ( message ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / ReadCommandTest . java b / test / unit / org / apache / cassandra / db / ReadCommandTest . java 
 index 8df7651 . . fba2bf2 100644 
 - - - a / test / unit / org / apache / cassandra / db / ReadCommandTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ReadCommandTest . java 
 @ @ - 52 , 7 + 52 , 9 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . io . util . DataInputBuffer ; 
 import org . apache . cassandra . io . util . DataOutputBuffer ; 
 import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; 
 + import org . apache . cassandra . locator . EndpointsForToken ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . locator . ReplicaUtils ; 
 import org . apache . cassandra . net . MessageOut ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . repair . consistent . LocalSessionAccessor ; 
 @ @ - 681 , 6 + 683 , 50 @ @ public class ReadCommandTest 
 assertEquals ( cacheHits , cfs . metric . rowCacheHit . getCount ( ) ) ; 
 } 
 
 + @ Test ( expected = IllegalArgumentException . class ) 
 + public void copyFullAsTransientTest ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; 
 + ReadCommand readCommand = Util . cmd ( cfs , Util . dk ( " key " ) ) . build ( ) ; 
 + readCommand . copyAsTransientQuery ( ReplicaUtils . full ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) ; 
 + } 
 + 
 + @ Test ( expected = IllegalArgumentException . class ) 
 + public void copyTransientAsDigestQuery ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; 
 + ReadCommand readCommand = Util . cmd ( cfs , Util . dk ( " key " ) ) . build ( ) ; 
 + readCommand . copyAsDigestQuery ( ReplicaUtils . trans ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) ; 
 + } 
 + 
 + @ Test ( expected = IllegalArgumentException . class ) 
 + public void copyMultipleFullAsTransientTest ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; 
 + DecoratedKey key = Util . dk ( " key " ) ; 
 + Token token = key . getToken ( ) ; 
 + / / Address is unimportant for this test 
 + InetAddressAndPort addr = FBUtilities . getBroadcastAddressAndPort ( ) ; 
 + ReadCommand readCommand = Util . cmd ( cfs , key ) . build ( ) ; 
 + readCommand . copyAsTransientQuery ( EndpointsForToken . of ( token , 
 + ReplicaUtils . trans ( addr , token ) , 
 + ReplicaUtils . full ( addr , token ) ) ) ; 
 + } 
 + 
 + @ Test ( expected = IllegalArgumentException . class ) 
 + public void copyMultipleTransientAsDigestQuery ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( CF6 ) ; 
 + DecoratedKey key = Util . dk ( " key " ) ; 
 + Token token = key . getToken ( ) ; 
 + / / Address is unimportant for this test 
 + InetAddressAndPort addr = FBUtilities . getBroadcastAddressAndPort ( ) ; 
 + ReadCommand readCommand = Util . cmd ( cfs , key ) . build ( ) ; 
 + readCommand . copyAsDigestQuery ( EndpointsForToken . of ( token , 
 + ReplicaUtils . trans ( addr , token ) , 
 + ReplicaUtils . full ( addr , token ) ) ) ; 
 + } 
 + 
 private void testRepairedDataTracking ( ColumnFamilyStore cfs , ReadCommand readCommand ) throws IOException 
 { 
 cfs . truncateBlocking ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / ReplicaUtils . java b / test / unit / org / apache / cassandra / locator / ReplicaUtils . java 
 index 66f538f . . c5350dc 100644 
 - - - a / test / unit / org / apache / cassandra / locator / ReplicaUtils . java 
 + + + b / test / unit / org / apache / cassandra / locator / ReplicaUtils . java 
 @ @ - 41 , 4 + 41 , 14 @ @ public class ReplicaUtils 
 { 
 return transientReplica ( endpoint , FULL _ RANGE ) ; 
 } 
 + 
 + public static Replica full ( InetAddressAndPort endpoint , Token token ) 
 + { 
 + return fullReplica ( endpoint , new Range < > ( token , token ) ) ; 
 + } 
 + 
 + public static Replica trans ( InetAddressAndPort endpoint , Token token ) 
 + { 
 + return transientReplica ( endpoint , new Range < > ( token , token ) ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6ef1317 . . 2bd02c4 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 15 , 7 + 15 , 7 @ @ Merged from 0 . 8 : 
 * fix array out of bounds error in counter shard removal ( CASSANDRA - 3514 ) 
 * avoid dropping tombstones when they might still be needed to shadow 
 data in a different sstable ( CASSANDRA - 2786 ) 
 - 
 + * fix ConcurrentModificationException in Table . all ( ) ( CASSANDRA - 3529 ) 
 
 1 . 0 . 3 
 * revert name - based query defragmentation aka CASSANDRA - 2503 ( CASSANDRA - 3491 ) 
 diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java 
 index 924d1be . . 99ca791 100644 
 - - - a / src / java / org / apache / cassandra / config / Schema . java 
 + + + b / src / java / org / apache / cassandra / config / Schema . java 
 @ @ - 49 , 13 + 49 , 13 @ @ public class Schema 
 private final AtomicInteger cfIdGen = new AtomicInteger ( MIN _ CF _ ID ) ; 
 
 / * metadata map for faster table lookup * / 
 - private final Map < String , KSMetaData > tables ; 
 + private final Map < String , KSMetaData > tables = new NonBlockingHashMap < String , KSMetaData > ( ) ; 
 
 / * Table objects , one per keyspace . Only one instance should ever exist for any given keyspace . * / 
 - private final Map < String , Table > tableInstances ; 
 + private final Map < String , Table > tableInstances = new NonBlockingHashMap < String , Table > ( ) ; 
 
 / * metadata map for faster ColumnFamily lookup * / 
 - private final BiMap < Pair < String , String > , Integer > cfIdMap ; 
 + private final BiMap < Pair < String , String > , Integer > cfIdMap = HashBiMap . create ( ) ; 
 
 private volatile UUID version ; 
 
 @ @ - 65 , 9 + 65 , 6 @ @ public class Schema 
 * / 
 public Schema ( UUID initialVersion ) 
 { 
 - tables = new HashMap < String , KSMetaData > ( ) ; 
 - tableInstances = new NonBlockingHashMap < String , Table > ( ) ; 
 - cfIdMap = HashBiMap . create ( ) ; 
 version = initialVersion ; 
 } 

