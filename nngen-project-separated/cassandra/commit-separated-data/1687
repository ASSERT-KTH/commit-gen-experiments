BLEU SCORE: 0.002659170925018653

TEST MSG: Make CompactionAwareWriterTest work with compression
GENERATED MSG: move blacklist tests to another class where closing System . err is less likely to bite us in the ass

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> index 18c58ea . . c97270c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> @ @ - 46 , 7 + 46 , 7 @ @ public class SplittingSizeTieredCompactionWriter extends CompactionAwareWriter <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( SplittingSizeTieredCompactionWriter . class ) ; <nl> <nl> - private static final long DEFAULT _ SMALLEST _ SSTABLE _ BYTES = 50 _ 000 _ 000 ; <nl> + public static final long DEFAULT _ SMALLEST _ SSTABLE _ BYTES = 50 _ 000 _ 000 ; <nl> private final double [ ] ratios ; <nl> private final SSTableRewriter sstableWriter ; <nl> private final long totalSize ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java <nl> index ac12491 . . 88074af 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java <nl> @ @ - 17 , 17 + 17 , 12 @ @ <nl> * / <nl> package org . apache . cassandra . db . compaction ; <nl> <nl> - import java . util . ArrayList ; <nl> - import java . util . Arrays ; <nl> - import java . util . Collection ; <nl> - import java . util . Collections ; <nl> - import java . util . Comparator ; <nl> - import java . util . HashSet ; <nl> - import java . util . Iterator ; <nl> - import java . util . List ; <nl> - import java . util . Set ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . * ; <nl> + import java . util . concurrent . ExecutionException ; <nl> <nl> import com . google . common . primitives . Longs ; <nl> + import org . junit . Before ; <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> @ @ - 68 , 6 + 63 , 16 @ @ public class CompactionAwareWriterTest <nl> SchemaLoader . standardCFMD ( KEYSPACE1 , CF ) ) ; <nl> <nl> } <nl> + <nl> + @ Before <nl> + public void clear ( ) <nl> + { <nl> + / / avoid one test affecting the next one <nl> + Keyspace ks = Keyspace . open ( KEYSPACE1 ) ; <nl> + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CF ) ; <nl> + cfs . clearUnsafe ( ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testDefaultCompactionWriter ( ) <nl> { <nl> @ @ - 97 , 8 + 102 , 8 @ @ public class CompactionAwareWriterTest <nl> populate ( cfs , rowCount ) ; <nl> Set < SSTableReader > sstables = new HashSet < > ( cfs . getSSTables ( ) ) ; <nl> long beforeSize = sstables . iterator ( ) . next ( ) . onDiskLength ( ) ; <nl> - int sstableCount = ( int ) beforeSize / 10 ; <nl> - CompactionAwareWriter writer = new MaxSSTableSizeWriter ( cfs , sstables , sstables , sstableCount , 0 , false , OperationType . COMPACTION ) ; <nl> + int sstableSize = ( int ) beforeSize / 10 ; <nl> + CompactionAwareWriter writer = new MaxSSTableSizeWriter ( cfs , sstables , sstables , sstableSize , 0 , false , OperationType . COMPACTION ) ; <nl> int rows = compact ( cfs , sstables , writer ) ; <nl> assertEquals ( 10 , cfs . getSSTables ( ) . size ( ) ) ; <nl> assertEquals ( rowCount , rows ) ; <nl> @ @ - 130 , 7 + 135 , 9 @ @ public class CompactionAwareWriterTest <nl> } ) ; <nl> for ( SSTableReader sstable : sortedSSTables ) <nl> { <nl> - assertEquals ( expectedSize , sstable . onDiskLength ( ) , 10000 ) ; <nl> + / / we dont create smaller files than this , everything will be in the last file <nl> + if ( expectedSize > SplittingSizeTieredCompactionWriter . DEFAULT _ SMALLEST _ SSTABLE _ BYTES ) <nl> + assertEquals ( expectedSize , sstable . onDiskLength ( ) , expectedSize / 100 ) ; / / allow 1 % diff in estimated vs actual size <nl> expectedSize / = 2 ; <nl> } <nl> assertEquals ( rowCount , rows ) ; <nl> @ @ - 144 , 14 + 151 , 15 @ @ public class CompactionAwareWriterTest <nl> Keyspace ks = Keyspace . open ( KEYSPACE1 ) ; <nl> ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CF ) ; <nl> cfs . disableAutoCompaction ( ) ; <nl> - int rowCount = 10000 ; <nl> + int rowCount = 20000 ; <nl> + int targetSSTableCount = 50 ; <nl> populate ( cfs , rowCount ) ; <nl> Set < SSTableReader > sstables = new HashSet < > ( cfs . getSSTables ( ) ) ; <nl> long beforeSize = sstables . iterator ( ) . next ( ) . onDiskLength ( ) ; <nl> - int sstableCount = ( int ) beforeSize / 100 ; <nl> - CompactionAwareWriter writer = new MajorLeveledCompactionWriter ( cfs , sstables , sstables , sstableCount , false , OperationType . COMPACTION ) ; <nl> + int sstableSize = ( int ) beforeSize / targetSSTableCount ; <nl> + CompactionAwareWriter writer = new MajorLeveledCompactionWriter ( cfs , sstables , sstables , sstableSize , false , OperationType . COMPACTION ) ; <nl> int rows = compact ( cfs , sstables , writer ) ; <nl> - assertEquals ( 100 , cfs . getSSTables ( ) . size ( ) ) ; <nl> + assertEquals ( targetSSTableCount , cfs . getSSTables ( ) . size ( ) ) ; <nl> int [ ] levelCounts = new int [ 5 ] ; <nl> assertEquals ( rowCount , rows ) ; <nl> for ( SSTableReader sstable : cfs . getSSTables ( ) ) <nl> @ @ - 160 , 7 + 168 , 7 @ @ public class CompactionAwareWriterTest <nl> } <nl> assertEquals ( 0 , levelCounts [ 0 ] ) ; <nl> assertEquals ( 10 , levelCounts [ 1 ] ) ; <nl> - assertEquals ( 90 , levelCounts [ 2 ] ) ; <nl> + assertEquals ( targetSSTableCount - 10 , levelCounts [ 2 ] ) ; / / note that if we want more levels , fix this <nl> for ( int i = 3 ; i < levelCounts . length ; i + + ) <nl> assertEquals ( 0 , levelCounts [ i ] ) ; <nl> validateData ( cfs , rowCount ) ; <nl> @ @ - 190 , 17 + 198 , 32 @ @ public class CompactionAwareWriterTest <nl> private void populate ( ColumnFamilyStore cfs , int count ) <nl> { <nl> long timestamp = System . currentTimeMillis ( ) ; <nl> + byte [ ] payload = new byte [ 1000 ] ; <nl> + new Random ( ) . nextBytes ( payload ) ; <nl> + ByteBuffer b = ByteBuffer . wrap ( payload ) ; <nl> for ( int i = 0 ; i < count ; i + + ) <nl> { <nl> DecoratedKey key = Util . dk ( Integer . toString ( i ) ) ; <nl> Mutation rm = new Mutation ( KEYSPACE1 , key . getKey ( ) ) ; <nl> for ( int j = 0 ; j < 10 ; j + + ) <nl> rm . add ( CF , Util . cellname ( Integer . toString ( j ) ) , <nl> - ByteBufferUtil . EMPTY _ BYTE _ BUFFER , <nl> + b , <nl> timestamp ) ; <nl> rm . applyUnsafe ( ) ; <nl> } <nl> cfs . forceBlockingFlush ( ) ; <nl> + if ( cfs . getSSTables ( ) . size ( ) > 1 ) <nl> + { <nl> + / / we want just one big sstable to avoid doing actual compaction in compact ( ) above <nl> + try <nl> + { <nl> + cfs . forceMajorCompaction ( ) ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + throw new RuntimeException ( t ) ; <nl> + } <nl> + } <nl> assert cfs . getSSTables ( ) . size ( ) = = 1 : cfs . getSSTables ( ) ; <nl> } <nl> private void validateData ( ColumnFamilyStore cfs , int rowCount )
NEAREST DIFF (one line): diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> index 11d7966 . . fabebe9 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java <nl> @ @ - 42 , 7 + 42 , 6 @ @ import org . apache . cassandra . db . marshal . CompositeType ; <nl> import org . apache . cassandra . io . sstable . Component ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . sstable . SSTableScanner ; <nl> - import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 222 , 12 + 221 , 12 @ @ public class CompactionsTest extends SchemaLoader <nl> public void testDontPurgeAccidentaly ( ) throws IOException , ExecutionException , InterruptedException <nl> { <nl> / / Testing with and without forcing deserialization . Without deserialization , EchoedRow will be used . <nl> - testDontPurgeAccidentaly ( " test1 " , " Super5 " , false ) ; <nl> - testDontPurgeAccidentaly ( " test2 " , " Super5 " , true ) ; <nl> + testDontPurgeAccidentaly ( " test1 " , " Super5 " ) ; <nl> + testDontPurgeAccidentaly ( " test2 " , " Super5 " ) ; <nl> <nl> / / Use CF with gc _ grace = 0 , see last bug of CASSANDRA - 2786 <nl> - testDontPurgeAccidentaly ( " test1 " , " SuperDirectGC " , false ) ; <nl> - testDontPurgeAccidentaly ( " test2 " , " SuperDirectGC " , true ) ; <nl> + testDontPurgeAccidentaly ( " test1 " , " SuperDirectGC " ) ; <nl> + testDontPurgeAccidentaly ( " test2 " , " SuperDirectGC " ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 299 , 7 + 298 , 7 @ @ public class CompactionsTest extends SchemaLoader <nl> assert ! compactionLogs . containsKey ( Pair . create ( TABLE1 , cf ) ) ; <nl> } <nl> <nl> - private void testDontPurgeAccidentaly ( String k , String cfname , boolean forceDeserialize ) throws IOException , ExecutionException , InterruptedException <nl> + private void testDontPurgeAccidentaly ( String k , String cfname ) throws IOException , ExecutionException , InterruptedException <nl> { <nl> / / This test catches the regression of CASSANDRA - 2786 <nl> Table table = Table . open ( TABLE1 ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 index 18c58ea . . c97270c 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 @ @ - 46 , 7 + 46 , 7 @ @ public class SplittingSizeTieredCompactionWriter extends CompactionAwareWriter 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( SplittingSizeTieredCompactionWriter . class ) ; 
 
 - private static final long DEFAULT _ SMALLEST _ SSTABLE _ BYTES = 50 _ 000 _ 000 ; 
 + public static final long DEFAULT _ SMALLEST _ SSTABLE _ BYTES = 50 _ 000 _ 000 ; 
 private final double [ ] ratios ; 
 private final SSTableRewriter sstableWriter ; 
 private final long totalSize ; 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java 
 index ac12491 . . 88074af 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionAwareWriterTest . java 
 @ @ - 17 , 17 + 17 , 12 @ @ 
 * / 
 package org . apache . cassandra . db . compaction ; 
 
 - import java . util . ArrayList ; 
 - import java . util . Arrays ; 
 - import java . util . Collection ; 
 - import java . util . Collections ; 
 - import java . util . Comparator ; 
 - import java . util . HashSet ; 
 - import java . util . Iterator ; 
 - import java . util . List ; 
 - import java . util . Set ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . * ; 
 + import java . util . concurrent . ExecutionException ; 
 
 import com . google . common . primitives . Longs ; 
 + import org . junit . Before ; 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 @ @ - 68 , 6 + 63 , 16 @ @ public class CompactionAwareWriterTest 
 SchemaLoader . standardCFMD ( KEYSPACE1 , CF ) ) ; 
 
 } 
 + 
 + @ Before 
 + public void clear ( ) 
 + { 
 + / / avoid one test affecting the next one 
 + Keyspace ks = Keyspace . open ( KEYSPACE1 ) ; 
 + ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CF ) ; 
 + cfs . clearUnsafe ( ) ; 
 + } 
 + 
 @ Test 
 public void testDefaultCompactionWriter ( ) 
 { 
 @ @ - 97 , 8 + 102 , 8 @ @ public class CompactionAwareWriterTest 
 populate ( cfs , rowCount ) ; 
 Set < SSTableReader > sstables = new HashSet < > ( cfs . getSSTables ( ) ) ; 
 long beforeSize = sstables . iterator ( ) . next ( ) . onDiskLength ( ) ; 
 - int sstableCount = ( int ) beforeSize / 10 ; 
 - CompactionAwareWriter writer = new MaxSSTableSizeWriter ( cfs , sstables , sstables , sstableCount , 0 , false , OperationType . COMPACTION ) ; 
 + int sstableSize = ( int ) beforeSize / 10 ; 
 + CompactionAwareWriter writer = new MaxSSTableSizeWriter ( cfs , sstables , sstables , sstableSize , 0 , false , OperationType . COMPACTION ) ; 
 int rows = compact ( cfs , sstables , writer ) ; 
 assertEquals ( 10 , cfs . getSSTables ( ) . size ( ) ) ; 
 assertEquals ( rowCount , rows ) ; 
 @ @ - 130 , 7 + 135 , 9 @ @ public class CompactionAwareWriterTest 
 } ) ; 
 for ( SSTableReader sstable : sortedSSTables ) 
 { 
 - assertEquals ( expectedSize , sstable . onDiskLength ( ) , 10000 ) ; 
 + / / we dont create smaller files than this , everything will be in the last file 
 + if ( expectedSize > SplittingSizeTieredCompactionWriter . DEFAULT _ SMALLEST _ SSTABLE _ BYTES ) 
 + assertEquals ( expectedSize , sstable . onDiskLength ( ) , expectedSize / 100 ) ; / / allow 1 % diff in estimated vs actual size 
 expectedSize / = 2 ; 
 } 
 assertEquals ( rowCount , rows ) ; 
 @ @ - 144 , 14 + 151 , 15 @ @ public class CompactionAwareWriterTest 
 Keyspace ks = Keyspace . open ( KEYSPACE1 ) ; 
 ColumnFamilyStore cfs = ks . getColumnFamilyStore ( CF ) ; 
 cfs . disableAutoCompaction ( ) ; 
 - int rowCount = 10000 ; 
 + int rowCount = 20000 ; 
 + int targetSSTableCount = 50 ; 
 populate ( cfs , rowCount ) ; 
 Set < SSTableReader > sstables = new HashSet < > ( cfs . getSSTables ( ) ) ; 
 long beforeSize = sstables . iterator ( ) . next ( ) . onDiskLength ( ) ; 
 - int sstableCount = ( int ) beforeSize / 100 ; 
 - CompactionAwareWriter writer = new MajorLeveledCompactionWriter ( cfs , sstables , sstables , sstableCount , false , OperationType . COMPACTION ) ; 
 + int sstableSize = ( int ) beforeSize / targetSSTableCount ; 
 + CompactionAwareWriter writer = new MajorLeveledCompactionWriter ( cfs , sstables , sstables , sstableSize , false , OperationType . COMPACTION ) ; 
 int rows = compact ( cfs , sstables , writer ) ; 
 - assertEquals ( 100 , cfs . getSSTables ( ) . size ( ) ) ; 
 + assertEquals ( targetSSTableCount , cfs . getSSTables ( ) . size ( ) ) ; 
 int [ ] levelCounts = new int [ 5 ] ; 
 assertEquals ( rowCount , rows ) ; 
 for ( SSTableReader sstable : cfs . getSSTables ( ) ) 
 @ @ - 160 , 7 + 168 , 7 @ @ public class CompactionAwareWriterTest 
 } 
 assertEquals ( 0 , levelCounts [ 0 ] ) ; 
 assertEquals ( 10 , levelCounts [ 1 ] ) ; 
 - assertEquals ( 90 , levelCounts [ 2 ] ) ; 
 + assertEquals ( targetSSTableCount - 10 , levelCounts [ 2 ] ) ; / / note that if we want more levels , fix this 
 for ( int i = 3 ; i < levelCounts . length ; i + + ) 
 assertEquals ( 0 , levelCounts [ i ] ) ; 
 validateData ( cfs , rowCount ) ; 
 @ @ - 190 , 17 + 198 , 32 @ @ public class CompactionAwareWriterTest 
 private void populate ( ColumnFamilyStore cfs , int count ) 
 { 
 long timestamp = System . currentTimeMillis ( ) ; 
 + byte [ ] payload = new byte [ 1000 ] ; 
 + new Random ( ) . nextBytes ( payload ) ; 
 + ByteBuffer b = ByteBuffer . wrap ( payload ) ; 
 for ( int i = 0 ; i < count ; i + + ) 
 { 
 DecoratedKey key = Util . dk ( Integer . toString ( i ) ) ; 
 Mutation rm = new Mutation ( KEYSPACE1 , key . getKey ( ) ) ; 
 for ( int j = 0 ; j < 10 ; j + + ) 
 rm . add ( CF , Util . cellname ( Integer . toString ( j ) ) , 
 - ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 
 + b , 
 timestamp ) ; 
 rm . applyUnsafe ( ) ; 
 } 
 cfs . forceBlockingFlush ( ) ; 
 + if ( cfs . getSSTables ( ) . size ( ) > 1 ) 
 + { 
 + / / we want just one big sstable to avoid doing actual compaction in compact ( ) above 
 + try 
 + { 
 + cfs . forceMajorCompaction ( ) ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + throw new RuntimeException ( t ) ; 
 + } 
 + } 
 assert cfs . getSSTables ( ) . size ( ) = = 1 : cfs . getSSTables ( ) ; 
 } 
 private void validateData ( ColumnFamilyStore cfs , int rowCount )

NEAREST DIFF:
diff - - git a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 index 11d7966 . . fabebe9 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / CompactionsTest . java 
 @ @ - 42 , 7 + 42 , 6 @ @ import org . apache . cassandra . db . marshal . CompositeType ; 
 import org . apache . cassandra . io . sstable . Component ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . sstable . SSTableScanner ; 
 - import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 222 , 12 + 221 , 12 @ @ public class CompactionsTest extends SchemaLoader 
 public void testDontPurgeAccidentaly ( ) throws IOException , ExecutionException , InterruptedException 
 { 
 / / Testing with and without forcing deserialization . Without deserialization , EchoedRow will be used . 
 - testDontPurgeAccidentaly ( " test1 " , " Super5 " , false ) ; 
 - testDontPurgeAccidentaly ( " test2 " , " Super5 " , true ) ; 
 + testDontPurgeAccidentaly ( " test1 " , " Super5 " ) ; 
 + testDontPurgeAccidentaly ( " test2 " , " Super5 " ) ; 
 
 / / Use CF with gc _ grace = 0 , see last bug of CASSANDRA - 2786 
 - testDontPurgeAccidentaly ( " test1 " , " SuperDirectGC " , false ) ; 
 - testDontPurgeAccidentaly ( " test2 " , " SuperDirectGC " , true ) ; 
 + testDontPurgeAccidentaly ( " test1 " , " SuperDirectGC " ) ; 
 + testDontPurgeAccidentaly ( " test2 " , " SuperDirectGC " ) ; 
 } 
 
 @ Test 
 @ @ - 299 , 7 + 298 , 7 @ @ public class CompactionsTest extends SchemaLoader 
 assert ! compactionLogs . containsKey ( Pair . create ( TABLE1 , cf ) ) ; 
 } 
 
 - private void testDontPurgeAccidentaly ( String k , String cfname , boolean forceDeserialize ) throws IOException , ExecutionException , InterruptedException 
 + private void testDontPurgeAccidentaly ( String k , String cfname ) throws IOException , ExecutionException , InterruptedException 
 { 
 / / This test catches the regression of CASSANDRA - 2786 
 Table table = Table . open ( TABLE1 ) ;
