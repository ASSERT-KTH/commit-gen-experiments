BLEU SCORE: 0.020980574531482755

TEST MSG: Implement / integrate FileSegmentInputStream . seek ( ) into CommitLogReader
GENERATED MSG: add JVM shutdownhook to sync commitlog

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f3fc2ca . . 0695654 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 8 <nl> + * Support seek ( ) in EncryptedFileSegmentInputStream ( CASSANDRA - 11957 ) <nl> * SSTable tools mishandling LocalPartitioner ( CASSANDRA - 12002 ) <nl> * When SEPWorker assigned work , set thread name to match pool ( CASSANDRA - 11966 ) <nl> * Add cross - DC latency metrics ( CASSANDRA - 11596 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java <nl> index 6c4bb60 . . a914cc9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java <nl> @ @ - 199 , 8 + 199 , 6 @ @ public class CommitLogReader <nl> <nl> statusTracker . errorContext = String . format ( " Next section at % d in % s " , syncSegment . fileStartPosition , desc . fileName ( ) ) ; <nl> <nl> - / / TODO : Since EncryptedFileSegmentInputStream doesn ' t implement seek ( ) , we cannot pre - emptively seek <nl> - / / to the desired offset in the syncSegment before reading the section and deserializing the mutations . <nl> readSection ( handler , syncSegment . input , minPosition , syncSegment . endPosition , statusTracker , desc ) ; <nl> if ( ! statusTracker . shouldContinue ( ) ) <nl> break ; <nl> @ @ - 254 , 6 + 252 , 10 @ @ public class CommitLogReader <nl> ReadStatusTracker statusTracker , <nl> CommitLogDescriptor desc ) throws IOException <nl> { <nl> + / / seek rather than deserializing mutation - by - mutation to reach the desired minPosition in this SyncSegment <nl> + if ( desc . id = = minPosition . segmentId & & reader . getFilePointer ( ) < minPosition . position ) <nl> + reader . seek ( minPosition . position ) ; <nl> + <nl> while ( statusTracker . shouldContinue ( ) & & reader . getFilePointer ( ) < end & & ! reader . isEOF ( ) ) <nl> { <nl> long mutationStart = reader . getFilePointer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java b / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java <nl> index cd7f7cb . . 9da3d50 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java <nl> @ @ - 38 , 7 + 38 , 7 @ @ public class EncryptedFileSegmentInputStream extends FileSegmentInputStream impl <nl> private final ChunkProvider chunkProvider ; <nl> <nl> / * * <nl> - * offset the decrypted chunks already processed in this segment . <nl> + * Offset representing the decrypted chunks already processed in this segment . <nl> * / <nl> private int totalChunkOffset ; <nl> <nl> @ @ - 76 , 8 + 76 , 23 @ @ public class EncryptedFileSegmentInputStream extends FileSegmentInputStream impl <nl> <nl> public void seek ( long position ) <nl> { <nl> - / / implement this when we actually need it <nl> - throw new UnsupportedOperationException ( ) ; <nl> + long bufferPos = position - totalChunkOffset - segmentOffset ; <nl> + while ( buffer ! = null & & bufferPos > buffer . capacity ( ) ) <nl> + { <nl> + / / rebuffer repeatedly until we have reached desired position <nl> + buffer . position ( buffer . limit ( ) ) ; <nl> + <nl> + / / increases totalChunkOffset <nl> + reBuffer ( ) ; <nl> + bufferPos = position - totalChunkOffset - segmentOffset ; <nl> + } <nl> + if ( buffer = = null | | bufferPos < 0 | | bufferPos > buffer . capacity ( ) ) <nl> + throw new IllegalArgumentException ( <nl> + String . format ( " Unable to seek to position % d in % s ( % d bytes ) in partial mode " , <nl> + position , <nl> + getPath ( ) , <nl> + segmentOffset + expectedLength ) ) ; <nl> + buffer . position ( ( int ) bufferPos ) ; <nl> } <nl> <nl> public long bytesPastMark ( DataPosition mark ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java b / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java <nl> index 034566e . . 88300a1 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java <nl> @ @ - 26 , 6 + 26 , 8 @ @ import java . nio . ByteBuffer ; <nl> import java . nio . channels . FileChannel ; <nl> import java . util . Collections ; <nl> import java . util . Random ; <nl> + import java . util . function . BiFunction ; <nl> + <nl> import javax . crypto . Cipher ; <nl> <nl> import org . junit . Assert ; <nl> @ @ - 106 , 15 + 108 , 61 @ @ public class SegmentReaderTest <nl> } <nl> } <nl> <nl> - private ByteBuffer readBytes ( DataInput input , int len ) throws IOException <nl> + private ByteBuffer readBytes ( FileDataInput input , int len ) <nl> { <nl> byte [ ] buf = new byte [ len ] ; <nl> - input . readFully ( buf ) ; <nl> + try <nl> + { <nl> + input . readFully ( buf ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> return ByteBuffer . wrap ( buf ) ; <nl> } <nl> <nl> + private ByteBuffer readBytesSeek ( FileDataInput input , int len ) <nl> + { <nl> + byte [ ] buf = new byte [ len ] ; <nl> + <nl> + / / / divide output buffer into 5 <nl> + int [ ] offsets = new int [ ] { 0 , len / 5 , 2 * len / 5 , 3 * len / 5 , 4 * len / 5 , len } ; <nl> + <nl> + / / seek offset <nl> + long inputStart = input . getFilePointer ( ) ; <nl> + <nl> + for ( int i = 0 ; i < offsets . length - 1 ; i + + ) <nl> + { <nl> + try <nl> + { <nl> + / / seek to beginning of offet <nl> + input . seek ( inputStart + offsets [ i ] ) ; <nl> + / / read this segment <nl> + input . readFully ( buf , offsets [ i ] , offsets [ i + 1 ] - offsets [ i ] ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + return ByteBuffer . wrap ( buf ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void encryptedSegmenterRead ( ) throws IOException <nl> + { <nl> + underlyingEncryptedSegmenterTest ( ( s , t ) - > readBytes ( s , t ) ) ; <nl> + } <nl> + <nl> @ Test <nl> - public void encryptedSegmenter ( ) throws IOException <nl> + public void encryptedSegmenterSeek ( ) throws IOException <nl> + { <nl> + underlyingEncryptedSegmenterTest ( ( s , t ) - > readBytesSeek ( s , t ) ) ; <nl> + } <nl> + <nl> + public void underlyingEncryptedSegmenterTest ( BiFunction < FileDataInput , Integer , ByteBuffer > readFun ) <nl> + throws IOException <nl> { <nl> EncryptionContext context = EncryptionContextGenerator . createContext ( true ) ; <nl> CipherFactory cipherFactory = new CipherFactory ( context . getTransparentDataEncryptionOptions ( ) ) ; <nl> @ @ - 140 , 7 + 188 , 7 @ @ public class SegmentReaderTest <nl> <nl> / / EncryptedSegmenter includes the Sync header length in the syncSegment . endPosition ( value ) <nl> Assert . assertEquals ( plainTextLength , syncSegment . endPosition - CommitLogSegment . SYNC _ MARKER _ SIZE ) ; <nl> - ByteBuffer fileBuffer = readBytes ( syncSegment . input , plainTextLength ) ; <nl> + ByteBuffer fileBuffer = readFun . apply ( syncSegment . input , plainTextLength ) ; <nl> plainTextBuffer . position ( 0 ) ; <nl> Assert . assertEquals ( plainTextBuffer , fileBuffer ) ; <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f147b0f . . e03d2a9 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 9 , 6 + 9 , 7 @ @ <nl> <nl> 0 . 7 . 2 - dev <nl> * fix potential overflow in nodetool cfstats <nl> + * offline nodes ( CASSANDRA - 1951 ) <nl> <nl> <nl> 0 . 7 . 1 <nl> diff - - git a / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java b / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java <nl> index b6c0841 . . 36d66e5 100644 <nl> - - - a / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java <nl> + + + b / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java <nl> @ @ - 63 , 7 + 63 , 6 @ @ import org . junit . Test ; <nl> public class CassandraServiceTest { <nl> <nl> private static EmbeddedCassandraService cassandra ; <nl> - private static Thread cassandraRunner ; <nl> private static CassandraServiceDataCleaner cleaner ; <nl> <nl> / * * <nl> @ @ - 90 , 13 + 89 , 7 @ @ public class CassandraServiceTest { <nl> cleaner . prepare ( ) ; <nl> <nl> cassandra = new EmbeddedCassandraService ( ) ; <nl> - cassandra . init ( ) ; <nl> - <nl> - if ( cassandraRunner = = null ) { <nl> - cassandraRunner = new Thread ( cassandra ) ; <nl> - cassandraRunner . setDaemon ( true ) ; <nl> - cassandraRunner . start ( ) ; <nl> - } <nl> + cassandra . start ( ) ; <nl> } <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java b / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java <nl> index 0563a7a . . 6b60c9f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java <nl> @ @ - 56 , 6 + 56 , 10 @ @ import org . mortbay . thread . ThreadPool ; <nl> * / <nl> public abstract class AbstractCassandraDaemon implements CassandraDaemon <nl> { <nl> + public AbstractCassandraDaemon ( ) <nl> + { <nl> + StorageService . instance . registerDaemon ( this ) ; <nl> + } <nl> <nl> / / Initialize logging in such a way that it checks for config changes every 10 seconds . <nl> static <nl> @ @ - 82 , 6 + 86 , 7 @ @ public abstract class AbstractCassandraDaemon implements CassandraDaemon <nl> <nl> protected InetAddress listenAddr ; <nl> protected int listenPort ; <nl> + protected volatile boolean isRunning = false ; <nl> <nl> public static final int MIN _ WORKER _ THREADS = 64 ; <nl> <nl> @ @ - 211 , 15 + 216 , 82 @ @ public abstract class AbstractCassandraDaemon implements CassandraDaemon <nl> * Start the Cassandra Daemon , assuming that it has already been <nl> * initialized , via either { @ link # init ( String [ ] ) } or <nl> * { @ link # load ( String [ ] ) } . <nl> - * <nl> + * <nl> + * Hook for JSVC <nl> + * <nl> * @ throws IOException <nl> * / <nl> - public abstract void start ( ) throws IOException ; <nl> + public void start ( ) <nl> + { <nl> + if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . start _ rpc " , " true " ) ) ) <nl> + { <nl> + startRPCServer ( ) ; <nl> + } <nl> + else <nl> + { <nl> + logger . info ( " Not starting RPC server as requested . Use JMX ( StorageService - > startRPCServer ( ) ) to start it " ) ; <nl> + } <nl> + } <nl> <nl> / * * <nl> * Stop the daemon , ideally in an idempotent manner . <nl> + * <nl> + * Hook for JSVC <nl> + * / <nl> + public void stop ( ) <nl> + { <nl> + / / this doesn ' t entirely shut down Cassandra , just the RPC server . <nl> + / / jsvc takes care of taking the rest down <nl> + logger . info ( " Cassandra shutting down . . . " ) ; <nl> + stopRPCServer ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Start the underlying RPC server in idempotent manner . <nl> + * / <nl> + public void startRPCServer ( ) <nl> + { <nl> + if ( ! isRunning ) <nl> + { <nl> + startServer ( ) ; <nl> + isRunning = true ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Stop the underlying RPC server in idempotent manner . <nl> + * / <nl> + public void stopRPCServer ( ) <nl> + { <nl> + if ( isRunning ) <nl> + { <nl> + stopServer ( ) ; <nl> + isRunning = false ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Returns whether the underlying RPC server is running or not . <nl> + * / <nl> + public boolean isRPCServerRunning ( ) <nl> + { <nl> + return isRunning ; <nl> + } <nl> + <nl> + / * * <nl> + * Start the underlying RPC server . <nl> + * This method shoud be able to restart a server stopped through stopServer ( ) . <nl> + * Should throw a RuntimeException if the server cannot be started <nl> * / <nl> - public abstract void stop ( ) ; <nl> + protected abstract void startServer ( ) ; <nl> + <nl> + / * * <nl> + * Stop the underlying RPC server . <nl> + * This method should be able to stop server started through startServer ( ) . <nl> + * Should throw a RuntimeException if the server cannot be stopped <nl> + * / <nl> + protected abstract void stopServer ( ) ; <nl> + <nl> <nl> / * * <nl> * Clean up all resources obtained during the lifetime of the daemon . This <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index c26e646 . . 3522cff 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 60 , 6 + 60 , 10 @ @ public interface CassandraDaemon <nl> * to clarify , this is a hook for JSVC . <nl> * / <nl> public void destroy ( ) ; <nl> + <nl> + public void startRPCServer ( ) ; <nl> + public void stopRPCServer ( ) ; <nl> + public boolean isRPCServerRunning ( ) ; <nl> <nl> / * * <nl> * A convenience method to initialize and start the daemon in one shot . <nl> diff - - git a / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java b / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java <nl> index 25d31ae . . 6ccf3e4 100644 <nl> - - - a / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java <nl> + + + b / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java <nl> @ @ - 37 , 35 + 37 , 26 @ @ import org . apache . thrift . transport . TTransportException ; <nl> * This is the implementation of https : / / issues . apache . org / jira / browse / CASSANDRA - 740 <nl> * < p > <nl> * How to use : <nl> - * In the client code create a new thread and spawn it with its { @ link Thread # start ( ) } method . <nl> + * In the client code simply create a new EmbeddedCassandraService and start it . <nl> * Example : <nl> * < pre > <nl> <nl> cassandra = new EmbeddedCassandraService ( ) ; <nl> - cassandra . init ( ) ; <nl> - <nl> - / / spawn cassandra in a new thread <nl> - Thread t = new Thread ( cassandra ) ; <nl> - t . setDaemon ( true ) ; <nl> - t . start ( ) ; <nl> + cassandra . start ( ) ; <nl> <nl> * < / pre > <nl> * @ author Ran Tavory ( rantav @ gmail . com ) <nl> * <nl> * / <nl> - public class EmbeddedCassandraService implements Runnable <nl> + public class EmbeddedCassandraService <nl> { <nl> <nl> CassandraDaemon cassandraDaemon ; <nl> <nl> - public void init ( ) throws TTransportException , IOException <nl> + public void start ( ) throws IOException <nl> { <nl> cassandraDaemon = new CassandraDaemon ( ) ; <nl> cassandraDaemon . init ( null ) ; <nl> - } <nl> - <nl> - public void run ( ) <nl> - { <nl> cassandraDaemon . start ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 8f7c182 . . 56ffbbf 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 172 , 6 + 172 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> private TokenMetadata tokenMetadata _ = new TokenMetadata ( ) ; <nl> <nl> private Set < InetAddress > replicatingNodes = Collections . synchronizedSet ( new HashSet < InetAddress > ( ) ) ; <nl> + private CassandraDaemon daemon ; <nl> + <nl> private InetAddress removingNode ; <nl> <nl> / * Are we starting this node in bootstrap mode ? * / <nl> @ @ - 248 , 6 + 250 , 11 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> throw new RuntimeException ( " Streaming service is unavailable . " ) ; <nl> } <nl> <nl> + public void registerDaemon ( CassandraDaemon daemon ) <nl> + { <nl> + this . daemon = daemon ; <nl> + } <nl> + <nl> / / should only be called via JMX <nl> public void stopGossiping ( ) <nl> { <nl> @ @ - 270 , 6 + 277 , 35 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> } <nl> <nl> + / / should only be called via JMX <nl> + public void startRPCServer ( ) <nl> + { <nl> + if ( daemon = = null ) <nl> + { <nl> + throw new IllegalStateException ( " No configured RPC daemon " ) ; <nl> + } <nl> + daemon . startRPCServer ( ) ; <nl> + } <nl> + <nl> + / / should only be called via JMX <nl> + public void stopRPCServer ( ) <nl> + { <nl> + if ( daemon = = null ) <nl> + { <nl> + throw new IllegalStateException ( " No configured RPC daemon " ) ; <nl> + } <nl> + daemon . stopRPCServer ( ) ; <nl> + } <nl> + <nl> + public boolean isRPCServerRunning ( ) <nl> + { <nl> + if ( daemon = = null ) <nl> + { <nl> + throw new IllegalStateException ( " No configured RPC daemon " ) ; <nl> + } <nl> + return daemon . isRPCServerRunning ( ) ; <nl> + } <nl> + <nl> public void stopClient ( ) <nl> { <nl> Gossiper . instance . unregister ( migrationManager ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index 55293d0 . . 2a8c9b8 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 281 , 6 + 281 , 15 @ @ public interface StorageServiceMBean <nl> / / to determine if gossip is disabled <nl> public boolean isInitialized ( ) ; <nl> <nl> + / / allows a user to disable thrift <nl> + public void stopRPCServer ( ) ; <nl> + <nl> + / / allows a user to reenable thrift <nl> + public void startRPCServer ( ) ; <nl> + <nl> + / / to determine if thrift is running <nl> + public boolean isRPCServerRunning ( ) ; <nl> + <nl> public void invalidateKeyCaches ( String ks , String . . . cfs ) throws IOException ; <nl> public void invalidateRowCaches ( String ks , String . . . cfs ) throws IOException ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / thrift / CassandraDaemon . java b / src / java / org / apache / cassandra / thrift / CassandraDaemon . java <nl> index 42ce6c6 . . fe607e2 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CassandraDaemon . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> package org . apache . cassandra . thrift ; <nl> <nl> import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> import java . net . InetSocketAddress ; <nl> import java . util . concurrent . ExecutorService ; <nl> <nl> @ @ - 47 , 89 + 48 , 118 @ @ import org . apache . thrift . transport . TTransportFactory ; <nl> public class CassandraDaemon extends org . apache . cassandra . service . AbstractCassandraDaemon <nl> { <nl> private static Logger logger = LoggerFactory . getLogger ( CassandraDaemon . class ) ; <nl> - private TServer serverEngine ; <nl> + private ThriftServer server ; <nl> <nl> - protected void setup ( ) throws IOException <nl> + protected void startServer ( ) <nl> { <nl> - super . setup ( ) ; <nl> - <nl> - / / now we start listening for clients <nl> - final CassandraServer cassandraServer = new CassandraServer ( ) ; <nl> - Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; <nl> - <nl> - / / Transport <nl> - TServerSocket tServerSocket = null ; <nl> - <nl> - try <nl> - { <nl> - tServerSocket = new TCustomServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) , <nl> - DatabaseDescriptor . getRpcKeepAlive ( ) , <nl> - DatabaseDescriptor . getRpcSendBufferSize ( ) , <nl> - DatabaseDescriptor . getRpcRecvBufferSize ( ) ) ; <nl> - } <nl> - catch ( TTransportException e ) <nl> - { <nl> - throw new IOException ( String . format ( " Unable to create thrift socket to % s : % s " , <nl> - listenAddr , listenPort ) , e ) ; <nl> - } <nl> - <nl> - logger . info ( String . format ( " Binding thrift service to % s : % s " , listenAddr , listenPort ) ) ; <nl> - <nl> - / / Protocol factory <nl> - TProtocolFactory tProtocolFactory = new TBinaryProtocol . Factory ( true , <nl> - true , <nl> - DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; <nl> - <nl> - / / Transport factory <nl> - TTransportFactory inTransportFactory , outTransportFactory ; <nl> - if ( DatabaseDescriptor . isThriftFramed ( ) ) <nl> - { <nl> - int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; <nl> - inTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; <nl> - outTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; <nl> - logger . info ( " Using TFastFramedTransport with a max frame size of { } bytes . " , tFramedTransportSize ) ; <nl> - } <nl> - else <nl> + if ( server = = null ) <nl> { <nl> - inTransportFactory = new TTransportFactory ( ) ; <nl> - outTransportFactory = new TTransportFactory ( ) ; <nl> + server = new ThriftServer ( listenAddr , listenPort ) ; <nl> + server . start ( ) ; <nl> } <nl> - <nl> - / / ThreadPool Server <nl> - CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; <nl> - options . minWorkerThreads = MIN _ WORKER _ THREADS ; <nl> - <nl> - ExecutorService executorService = new CleaningThreadPool ( cassandraServer . clientState , <nl> - options . minWorkerThreads , <nl> - options . maxWorkerThreads ) ; <nl> - serverEngine = new CustomTThreadPoolServer ( new TProcessorFactory ( processor ) , <nl> - tServerSocket , <nl> - inTransportFactory , <nl> - outTransportFactory , <nl> - tProtocolFactory , <nl> - tProtocolFactory , <nl> - options , <nl> - executorService ) ; <nl> } <nl> <nl> - / * * hook for JSVC * / <nl> - public void start ( ) <nl> + protected void stopServer ( ) <nl> { <nl> - logger . info ( " Listening for thrift clients . . . " ) ; <nl> - serverEngine . serve ( ) ; <nl> + if ( server ! = null ) <nl> + { <nl> + server . stopServer ( ) ; <nl> + try <nl> + { <nl> + server . join ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + logger . error ( " Interrupted while waiting thrift server to stop " , e ) ; <nl> + } <nl> + server = null ; <nl> + } <nl> } <nl> <nl> - / * * hook for JSVC * / <nl> - public void stop ( ) <nl> - { <nl> - / / this doesn ' t entirely shut down Cassandra , just the Thrift server . <nl> - / / jsvc takes care of taking the rest down <nl> - logger . info ( " Cassandra shutting down . . . " ) ; <nl> - serverEngine . stop ( ) ; <nl> - } <nl> - <nl> public static void main ( String [ ] args ) <nl> { <nl> new CassandraDaemon ( ) . activate ( ) ; <nl> } <nl> + <nl> + / * * <nl> + * Simple class to run the thrift connection accepting code in separate <nl> + * thread of control . <nl> + * / <nl> + private static class ThriftServer extends Thread <nl> + { <nl> + private TServer serverEngine ; <nl> + <nl> + public ThriftServer ( InetAddress listenAddr , int listenPort ) <nl> + { <nl> + / / now we start listening for clients <nl> + final CassandraServer cassandraServer = new CassandraServer ( ) ; <nl> + Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; <nl> + <nl> + / / Transport <nl> + TServerSocket tServerSocket = null ; <nl> + <nl> + try <nl> + { <nl> + tServerSocket = new TCustomServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) , <nl> + DatabaseDescriptor . getRpcKeepAlive ( ) , <nl> + DatabaseDescriptor . getRpcSendBufferSize ( ) , <nl> + DatabaseDescriptor . getRpcRecvBufferSize ( ) ) ; <nl> + } <nl> + catch ( TTransportException e ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Unable to create thrift socket to % s : % s " , <nl> + listenAddr , listenPort ) , e ) ; <nl> + } <nl> + <nl> + logger . info ( String . format ( " Binding thrift service to % s : % s " , listenAddr , listenPort ) ) ; <nl> + <nl> + / / Protocol factory <nl> + TProtocolFactory tProtocolFactory = new TBinaryProtocol . Factory ( true , <nl> + true , <nl> + DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; <nl> + <nl> + / / Transport factory <nl> + TTransportFactory inTransportFactory , outTransportFactory ; <nl> + if ( DatabaseDescriptor . isThriftFramed ( ) ) <nl> + { <nl> + int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; <nl> + inTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; <nl> + outTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; <nl> + logger . info ( " Using TFastFramedTransport with a max frame size of { } bytes . " , tFramedTransportSize ) ; <nl> + } <nl> + else <nl> + { <nl> + inTransportFactory = new TTransportFactory ( ) ; <nl> + outTransportFactory = new TTransportFactory ( ) ; <nl> + } <nl> + <nl> + / / ThreadPool Server <nl> + CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; <nl> + options . minWorkerThreads = MIN _ WORKER _ THREADS ; <nl> + <nl> + ExecutorService executorService = new CleaningThreadPool ( cassandraServer . clientState , <nl> + options . minWorkerThreads , <nl> + options . maxWorkerThreads ) ; <nl> + serverEngine = new CustomTThreadPoolServer ( new TProcessorFactory ( processor ) , <nl> + tServerSocket , <nl> + inTransportFactory , <nl> + outTransportFactory , <nl> + tProtocolFactory , <nl> + tProtocolFactory , <nl> + options , <nl> + executorService ) ; <nl> + } <nl> + <nl> + public void run ( ) <nl> + { <nl> + logger . info ( " Listening for thrift clients . . . " ) ; <nl> + serverEngine . serve ( ) ; <nl> + } <nl> + <nl> + public void stopServer ( ) <nl> + { <nl> + logger . info ( " Stop listening to thrift clients " ) ; <nl> + serverEngine . stop ( ) ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cli / CliTest . java b / test / unit / org / apache / cassandra / cli / CliTest . java <nl> index a34feac . . 580b127 100644 <nl> - - - a / test / unit / org / apache / cassandra / cli / CliTest . java <nl> + + + b / test / unit / org / apache / cassandra / cli / CliTest . java <nl> @ @ - 146 , 7 + 146 , 7 @ @ public class CliTest extends CleanupHelper <nl> @ Test <nl> public void testCli ( ) throws IOException , TTransportException , ConfigurationException <nl> { <nl> - setup ( ) ; <nl> + new EmbeddedCassandraService ( ) . start ( ) ; <nl> <nl> / / new error / output streams for CliSessionState <nl> ByteArrayOutputStream errStream = new ByteArrayOutputStream ( ) ; <nl> @ @ - 204 , 24 + 204 , 4 @ @ public class CliTest extends CleanupHelper <nl> errStream . reset ( ) ; / / no errors to the end user . <nl> } <nl> } <nl> - <nl> - / * * <nl> - * Setup embedded cassandra instance using test config . <nl> - * @ throws TTransportException - when trying to bind address <nl> - * @ throws IOException - when reading config file <nl> - * @ throws ConfigurationException - when can set up configuration <nl> - * / <nl> - private void setup ( ) throws TTransportException , IOException , ConfigurationException <nl> - { <nl> - EmbeddedCassandraService cassandra ; <nl> - <nl> - cassandra = new EmbeddedCassandraService ( ) ; <nl> - cassandra . init ( ) ; <nl> - <nl> - / / spawn cassandra in a new thread <nl> - Thread t = new Thread ( cassandra ) ; <nl> - t . setDaemon ( true ) ; <nl> - t . start ( ) ; <nl> - } <nl> - <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java b / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java <nl> index e02432f . . efd2e11 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java <nl> @ @ - 64 , 14 + 64 , 8 @ @ public class EmbeddedCassandraServiceTest extends CleanupHelper <nl> @ BeforeClass <nl> public static void setup ( ) throws TTransportException , IOException , InterruptedException , ConfigurationException <nl> { <nl> - <nl> cassandra = new EmbeddedCassandraService ( ) ; <nl> - cassandra . init ( ) ; <nl> - <nl> - / / spawn cassandra in a new thread <nl> - Thread t = new Thread ( cassandra ) ; <nl> - t . setDaemon ( true ) ; <nl> - t . start ( ) ; <nl> + cassandra . start ( ) ; <nl> } <nl> <nl> @ Test

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f3fc2ca . . 0695654 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 8 
 + * Support seek ( ) in EncryptedFileSegmentInputStream ( CASSANDRA - 11957 ) 
 * SSTable tools mishandling LocalPartitioner ( CASSANDRA - 12002 ) 
 * When SEPWorker assigned work , set thread name to match pool ( CASSANDRA - 11966 ) 
 * Add cross - DC latency metrics ( CASSANDRA - 11596 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java 
 index 6c4bb60 . . a914cc9 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReader . java 
 @ @ - 199 , 8 + 199 , 6 @ @ public class CommitLogReader 
 
 statusTracker . errorContext = String . format ( " Next section at % d in % s " , syncSegment . fileStartPosition , desc . fileName ( ) ) ; 
 
 - / / TODO : Since EncryptedFileSegmentInputStream doesn ' t implement seek ( ) , we cannot pre - emptively seek 
 - / / to the desired offset in the syncSegment before reading the section and deserializing the mutations . 
 readSection ( handler , syncSegment . input , minPosition , syncSegment . endPosition , statusTracker , desc ) ; 
 if ( ! statusTracker . shouldContinue ( ) ) 
 break ; 
 @ @ - 254 , 6 + 252 , 10 @ @ public class CommitLogReader 
 ReadStatusTracker statusTracker , 
 CommitLogDescriptor desc ) throws IOException 
 { 
 + / / seek rather than deserializing mutation - by - mutation to reach the desired minPosition in this SyncSegment 
 + if ( desc . id = = minPosition . segmentId & & reader . getFilePointer ( ) < minPosition . position ) 
 + reader . seek ( minPosition . position ) ; 
 + 
 while ( statusTracker . shouldContinue ( ) & & reader . getFilePointer ( ) < end & & ! reader . isEOF ( ) ) 
 { 
 long mutationStart = reader . getFilePointer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java b / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java 
 index cd7f7cb . . 9da3d50 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / EncryptedFileSegmentInputStream . java 
 @ @ - 38 , 7 + 38 , 7 @ @ public class EncryptedFileSegmentInputStream extends FileSegmentInputStream impl 
 private final ChunkProvider chunkProvider ; 
 
 / * * 
 - * offset the decrypted chunks already processed in this segment . 
 + * Offset representing the decrypted chunks already processed in this segment . 
 * / 
 private int totalChunkOffset ; 
 
 @ @ - 76 , 8 + 76 , 23 @ @ public class EncryptedFileSegmentInputStream extends FileSegmentInputStream impl 
 
 public void seek ( long position ) 
 { 
 - / / implement this when we actually need it 
 - throw new UnsupportedOperationException ( ) ; 
 + long bufferPos = position - totalChunkOffset - segmentOffset ; 
 + while ( buffer ! = null & & bufferPos > buffer . capacity ( ) ) 
 + { 
 + / / rebuffer repeatedly until we have reached desired position 
 + buffer . position ( buffer . limit ( ) ) ; 
 + 
 + / / increases totalChunkOffset 
 + reBuffer ( ) ; 
 + bufferPos = position - totalChunkOffset - segmentOffset ; 
 + } 
 + if ( buffer = = null | | bufferPos < 0 | | bufferPos > buffer . capacity ( ) ) 
 + throw new IllegalArgumentException ( 
 + String . format ( " Unable to seek to position % d in % s ( % d bytes ) in partial mode " , 
 + position , 
 + getPath ( ) , 
 + segmentOffset + expectedLength ) ) ; 
 + buffer . position ( ( int ) bufferPos ) ; 
 } 
 
 public long bytesPastMark ( DataPosition mark ) 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java b / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java 
 index 034566e . . 88300a1 100644 
 - - - a / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / SegmentReaderTest . java 
 @ @ - 26 , 6 + 26 , 8 @ @ import java . nio . ByteBuffer ; 
 import java . nio . channels . FileChannel ; 
 import java . util . Collections ; 
 import java . util . Random ; 
 + import java . util . function . BiFunction ; 
 + 
 import javax . crypto . Cipher ; 
 
 import org . junit . Assert ; 
 @ @ - 106 , 15 + 108 , 61 @ @ public class SegmentReaderTest 
 } 
 } 
 
 - private ByteBuffer readBytes ( DataInput input , int len ) throws IOException 
 + private ByteBuffer readBytes ( FileDataInput input , int len ) 
 { 
 byte [ ] buf = new byte [ len ] ; 
 - input . readFully ( buf ) ; 
 + try 
 + { 
 + input . readFully ( buf ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 return ByteBuffer . wrap ( buf ) ; 
 } 
 
 + private ByteBuffer readBytesSeek ( FileDataInput input , int len ) 
 + { 
 + byte [ ] buf = new byte [ len ] ; 
 + 
 + / / / divide output buffer into 5 
 + int [ ] offsets = new int [ ] { 0 , len / 5 , 2 * len / 5 , 3 * len / 5 , 4 * len / 5 , len } ; 
 + 
 + / / seek offset 
 + long inputStart = input . getFilePointer ( ) ; 
 + 
 + for ( int i = 0 ; i < offsets . length - 1 ; i + + ) 
 + { 
 + try 
 + { 
 + / / seek to beginning of offet 
 + input . seek ( inputStart + offsets [ i ] ) ; 
 + / / read this segment 
 + input . readFully ( buf , offsets [ i ] , offsets [ i + 1 ] - offsets [ i ] ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + return ByteBuffer . wrap ( buf ) ; 
 + } 
 + 
 + @ Test 
 + public void encryptedSegmenterRead ( ) throws IOException 
 + { 
 + underlyingEncryptedSegmenterTest ( ( s , t ) - > readBytes ( s , t ) ) ; 
 + } 
 + 
 @ Test 
 - public void encryptedSegmenter ( ) throws IOException 
 + public void encryptedSegmenterSeek ( ) throws IOException 
 + { 
 + underlyingEncryptedSegmenterTest ( ( s , t ) - > readBytesSeek ( s , t ) ) ; 
 + } 
 + 
 + public void underlyingEncryptedSegmenterTest ( BiFunction < FileDataInput , Integer , ByteBuffer > readFun ) 
 + throws IOException 
 { 
 EncryptionContext context = EncryptionContextGenerator . createContext ( true ) ; 
 CipherFactory cipherFactory = new CipherFactory ( context . getTransparentDataEncryptionOptions ( ) ) ; 
 @ @ - 140 , 7 + 188 , 7 @ @ public class SegmentReaderTest 
 
 / / EncryptedSegmenter includes the Sync header length in the syncSegment . endPosition ( value ) 
 Assert . assertEquals ( plainTextLength , syncSegment . endPosition - CommitLogSegment . SYNC _ MARKER _ SIZE ) ; 
 - ByteBuffer fileBuffer = readBytes ( syncSegment . input , plainTextLength ) ; 
 + ByteBuffer fileBuffer = readFun . apply ( syncSegment . input , plainTextLength ) ; 
 plainTextBuffer . position ( 0 ) ; 
 Assert . assertEquals ( plainTextBuffer , fileBuffer ) ; 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f147b0f . . e03d2a9 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 9 , 6 + 9 , 7 @ @ 
 
 0 . 7 . 2 - dev 
 * fix potential overflow in nodetool cfstats 
 + * offline nodes ( CASSANDRA - 1951 ) 
 
 
 0 . 7 . 1 
 diff - - git a / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java b / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java 
 index b6c0841 . . 36d66e5 100644 
 - - - a / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java 
 + + + b / contrib / javautils / src / test / java / org / apache / cassandra / contrib / utils / service / CassandraServiceTest . java 
 @ @ - 63 , 7 + 63 , 6 @ @ import org . junit . Test ; 
 public class CassandraServiceTest { 
 
 private static EmbeddedCassandraService cassandra ; 
 - private static Thread cassandraRunner ; 
 private static CassandraServiceDataCleaner cleaner ; 
 
 / * * 
 @ @ - 90 , 13 + 89 , 7 @ @ public class CassandraServiceTest { 
 cleaner . prepare ( ) ; 
 
 cassandra = new EmbeddedCassandraService ( ) ; 
 - cassandra . init ( ) ; 
 - 
 - if ( cassandraRunner = = null ) { 
 - cassandraRunner = new Thread ( cassandra ) ; 
 - cassandraRunner . setDaemon ( true ) ; 
 - cassandraRunner . start ( ) ; 
 - } 
 + cassandra . start ( ) ; 
 } 
 
 
 diff - - git a / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java b / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java 
 index 0563a7a . . 6b60c9f 100644 
 - - - a / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / AbstractCassandraDaemon . java 
 @ @ - 56 , 6 + 56 , 10 @ @ import org . mortbay . thread . ThreadPool ; 
 * / 
 public abstract class AbstractCassandraDaemon implements CassandraDaemon 
 { 
 + public AbstractCassandraDaemon ( ) 
 + { 
 + StorageService . instance . registerDaemon ( this ) ; 
 + } 
 
 / / Initialize logging in such a way that it checks for config changes every 10 seconds . 
 static 
 @ @ - 82 , 6 + 86 , 7 @ @ public abstract class AbstractCassandraDaemon implements CassandraDaemon 
 
 protected InetAddress listenAddr ; 
 protected int listenPort ; 
 + protected volatile boolean isRunning = false ; 
 
 public static final int MIN _ WORKER _ THREADS = 64 ; 
 
 @ @ - 211 , 15 + 216 , 82 @ @ public abstract class AbstractCassandraDaemon implements CassandraDaemon 
 * Start the Cassandra Daemon , assuming that it has already been 
 * initialized , via either { @ link # init ( String [ ] ) } or 
 * { @ link # load ( String [ ] ) } . 
 - * 
 + * 
 + * Hook for JSVC 
 + * 
 * @ throws IOException 
 * / 
 - public abstract void start ( ) throws IOException ; 
 + public void start ( ) 
 + { 
 + if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . start _ rpc " , " true " ) ) ) 
 + { 
 + startRPCServer ( ) ; 
 + } 
 + else 
 + { 
 + logger . info ( " Not starting RPC server as requested . Use JMX ( StorageService - > startRPCServer ( ) ) to start it " ) ; 
 + } 
 + } 
 
 / * * 
 * Stop the daemon , ideally in an idempotent manner . 
 + * 
 + * Hook for JSVC 
 + * / 
 + public void stop ( ) 
 + { 
 + / / this doesn ' t entirely shut down Cassandra , just the RPC server . 
 + / / jsvc takes care of taking the rest down 
 + logger . info ( " Cassandra shutting down . . . " ) ; 
 + stopRPCServer ( ) ; 
 + } 
 + 
 + / * * 
 + * Start the underlying RPC server in idempotent manner . 
 + * / 
 + public void startRPCServer ( ) 
 + { 
 + if ( ! isRunning ) 
 + { 
 + startServer ( ) ; 
 + isRunning = true ; 
 + } 
 + } 
 + 
 + / * * 
 + * Stop the underlying RPC server in idempotent manner . 
 + * / 
 + public void stopRPCServer ( ) 
 + { 
 + if ( isRunning ) 
 + { 
 + stopServer ( ) ; 
 + isRunning = false ; 
 + } 
 + } 
 + 
 + / * * 
 + * Returns whether the underlying RPC server is running or not . 
 + * / 
 + public boolean isRPCServerRunning ( ) 
 + { 
 + return isRunning ; 
 + } 
 + 
 + / * * 
 + * Start the underlying RPC server . 
 + * This method shoud be able to restart a server stopped through stopServer ( ) . 
 + * Should throw a RuntimeException if the server cannot be started 
 * / 
 - public abstract void stop ( ) ; 
 + protected abstract void startServer ( ) ; 
 + 
 + / * * 
 + * Stop the underlying RPC server . 
 + * This method should be able to stop server started through startServer ( ) . 
 + * Should throw a RuntimeException if the server cannot be stopped 
 + * / 
 + protected abstract void stopServer ( ) ; 
 + 
 
 / * * 
 * Clean up all resources obtained during the lifetime of the daemon . This 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index c26e646 . . 3522cff 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 60 , 6 + 60 , 10 @ @ public interface CassandraDaemon 
 * to clarify , this is a hook for JSVC . 
 * / 
 public void destroy ( ) ; 
 + 
 + public void startRPCServer ( ) ; 
 + public void stopRPCServer ( ) ; 
 + public boolean isRPCServerRunning ( ) ; 
 
 / * * 
 * A convenience method to initialize and start the daemon in one shot . 
 diff - - git a / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java b / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java 
 index 25d31ae . . 6ccf3e4 100644 
 - - - a / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java 
 + + + b / src / java / org / apache / cassandra / service / EmbeddedCassandraService . java 
 @ @ - 37 , 35 + 37 , 26 @ @ import org . apache . thrift . transport . TTransportException ; 
 * This is the implementation of https : / / issues . apache . org / jira / browse / CASSANDRA - 740 
 * < p > 
 * How to use : 
 - * In the client code create a new thread and spawn it with its { @ link Thread # start ( ) } method . 
 + * In the client code simply create a new EmbeddedCassandraService and start it . 
 * Example : 
 * < pre > 
 
 cassandra = new EmbeddedCassandraService ( ) ; 
 - cassandra . init ( ) ; 
 - 
 - / / spawn cassandra in a new thread 
 - Thread t = new Thread ( cassandra ) ; 
 - t . setDaemon ( true ) ; 
 - t . start ( ) ; 
 + cassandra . start ( ) ; 
 
 * < / pre > 
 * @ author Ran Tavory ( rantav @ gmail . com ) 
 * 
 * / 
 - public class EmbeddedCassandraService implements Runnable 
 + public class EmbeddedCassandraService 
 { 
 
 CassandraDaemon cassandraDaemon ; 
 
 - public void init ( ) throws TTransportException , IOException 
 + public void start ( ) throws IOException 
 { 
 cassandraDaemon = new CassandraDaemon ( ) ; 
 cassandraDaemon . init ( null ) ; 
 - } 
 - 
 - public void run ( ) 
 - { 
 cassandraDaemon . start ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 8f7c182 . . 56ffbbf 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 172 , 6 + 172 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 private TokenMetadata tokenMetadata _ = new TokenMetadata ( ) ; 
 
 private Set < InetAddress > replicatingNodes = Collections . synchronizedSet ( new HashSet < InetAddress > ( ) ) ; 
 + private CassandraDaemon daemon ; 
 + 
 private InetAddress removingNode ; 
 
 / * Are we starting this node in bootstrap mode ? * / 
 @ @ - 248 , 6 + 250 , 11 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 throw new RuntimeException ( " Streaming service is unavailable . " ) ; 
 } 
 
 + public void registerDaemon ( CassandraDaemon daemon ) 
 + { 
 + this . daemon = daemon ; 
 + } 
 + 
 / / should only be called via JMX 
 public void stopGossiping ( ) 
 { 
 @ @ - 270 , 6 + 277 , 35 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 } 
 
 + / / should only be called via JMX 
 + public void startRPCServer ( ) 
 + { 
 + if ( daemon = = null ) 
 + { 
 + throw new IllegalStateException ( " No configured RPC daemon " ) ; 
 + } 
 + daemon . startRPCServer ( ) ; 
 + } 
 + 
 + / / should only be called via JMX 
 + public void stopRPCServer ( ) 
 + { 
 + if ( daemon = = null ) 
 + { 
 + throw new IllegalStateException ( " No configured RPC daemon " ) ; 
 + } 
 + daemon . stopRPCServer ( ) ; 
 + } 
 + 
 + public boolean isRPCServerRunning ( ) 
 + { 
 + if ( daemon = = null ) 
 + { 
 + throw new IllegalStateException ( " No configured RPC daemon " ) ; 
 + } 
 + return daemon . isRPCServerRunning ( ) ; 
 + } 
 + 
 public void stopClient ( ) 
 { 
 Gossiper . instance . unregister ( migrationManager ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index 55293d0 . . 2a8c9b8 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 281 , 6 + 281 , 15 @ @ public interface StorageServiceMBean 
 / / to determine if gossip is disabled 
 public boolean isInitialized ( ) ; 
 
 + / / allows a user to disable thrift 
 + public void stopRPCServer ( ) ; 
 + 
 + / / allows a user to reenable thrift 
 + public void startRPCServer ( ) ; 
 + 
 + / / to determine if thrift is running 
 + public boolean isRPCServerRunning ( ) ; 
 + 
 public void invalidateKeyCaches ( String ks , String . . . cfs ) throws IOException ; 
 public void invalidateRowCaches ( String ks , String . . . cfs ) throws IOException ; 
 
 diff - - git a / src / java / org / apache / cassandra / thrift / CassandraDaemon . java b / src / java / org / apache / cassandra / thrift / CassandraDaemon . java 
 index 42ce6c6 . . fe607e2 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / thrift / CassandraDaemon . java 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 package org . apache . cassandra . thrift ; 
 
 import java . io . IOException ; 
 + import java . net . InetAddress ; 
 import java . net . InetSocketAddress ; 
 import java . util . concurrent . ExecutorService ; 
 
 @ @ - 47 , 89 + 48 , 118 @ @ import org . apache . thrift . transport . TTransportFactory ; 
 public class CassandraDaemon extends org . apache . cassandra . service . AbstractCassandraDaemon 
 { 
 private static Logger logger = LoggerFactory . getLogger ( CassandraDaemon . class ) ; 
 - private TServer serverEngine ; 
 + private ThriftServer server ; 
 
 - protected void setup ( ) throws IOException 
 + protected void startServer ( ) 
 { 
 - super . setup ( ) ; 
 - 
 - / / now we start listening for clients 
 - final CassandraServer cassandraServer = new CassandraServer ( ) ; 
 - Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; 
 - 
 - / / Transport 
 - TServerSocket tServerSocket = null ; 
 - 
 - try 
 - { 
 - tServerSocket = new TCustomServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) , 
 - DatabaseDescriptor . getRpcKeepAlive ( ) , 
 - DatabaseDescriptor . getRpcSendBufferSize ( ) , 
 - DatabaseDescriptor . getRpcRecvBufferSize ( ) ) ; 
 - } 
 - catch ( TTransportException e ) 
 - { 
 - throw new IOException ( String . format ( " Unable to create thrift socket to % s : % s " , 
 - listenAddr , listenPort ) , e ) ; 
 - } 
 - 
 - logger . info ( String . format ( " Binding thrift service to % s : % s " , listenAddr , listenPort ) ) ; 
 - 
 - / / Protocol factory 
 - TProtocolFactory tProtocolFactory = new TBinaryProtocol . Factory ( true , 
 - true , 
 - DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; 
 - 
 - / / Transport factory 
 - TTransportFactory inTransportFactory , outTransportFactory ; 
 - if ( DatabaseDescriptor . isThriftFramed ( ) ) 
 - { 
 - int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; 
 - inTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; 
 - outTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; 
 - logger . info ( " Using TFastFramedTransport with a max frame size of { } bytes . " , tFramedTransportSize ) ; 
 - } 
 - else 
 + if ( server = = null ) 
 { 
 - inTransportFactory = new TTransportFactory ( ) ; 
 - outTransportFactory = new TTransportFactory ( ) ; 
 + server = new ThriftServer ( listenAddr , listenPort ) ; 
 + server . start ( ) ; 
 } 
 - 
 - / / ThreadPool Server 
 - CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; 
 - options . minWorkerThreads = MIN _ WORKER _ THREADS ; 
 - 
 - ExecutorService executorService = new CleaningThreadPool ( cassandraServer . clientState , 
 - options . minWorkerThreads , 
 - options . maxWorkerThreads ) ; 
 - serverEngine = new CustomTThreadPoolServer ( new TProcessorFactory ( processor ) , 
 - tServerSocket , 
 - inTransportFactory , 
 - outTransportFactory , 
 - tProtocolFactory , 
 - tProtocolFactory , 
 - options , 
 - executorService ) ; 
 } 
 
 - / * * hook for JSVC * / 
 - public void start ( ) 
 + protected void stopServer ( ) 
 { 
 - logger . info ( " Listening for thrift clients . . . " ) ; 
 - serverEngine . serve ( ) ; 
 + if ( server ! = null ) 
 + { 
 + server . stopServer ( ) ; 
 + try 
 + { 
 + server . join ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + logger . error ( " Interrupted while waiting thrift server to stop " , e ) ; 
 + } 
 + server = null ; 
 + } 
 } 
 
 - / * * hook for JSVC * / 
 - public void stop ( ) 
 - { 
 - / / this doesn ' t entirely shut down Cassandra , just the Thrift server . 
 - / / jsvc takes care of taking the rest down 
 - logger . info ( " Cassandra shutting down . . . " ) ; 
 - serverEngine . stop ( ) ; 
 - } 
 - 
 public static void main ( String [ ] args ) 
 { 
 new CassandraDaemon ( ) . activate ( ) ; 
 } 
 + 
 + / * * 
 + * Simple class to run the thrift connection accepting code in separate 
 + * thread of control . 
 + * / 
 + private static class ThriftServer extends Thread 
 + { 
 + private TServer serverEngine ; 
 + 
 + public ThriftServer ( InetAddress listenAddr , int listenPort ) 
 + { 
 + / / now we start listening for clients 
 + final CassandraServer cassandraServer = new CassandraServer ( ) ; 
 + Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; 
 + 
 + / / Transport 
 + TServerSocket tServerSocket = null ; 
 + 
 + try 
 + { 
 + tServerSocket = new TCustomServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) , 
 + DatabaseDescriptor . getRpcKeepAlive ( ) , 
 + DatabaseDescriptor . getRpcSendBufferSize ( ) , 
 + DatabaseDescriptor . getRpcRecvBufferSize ( ) ) ; 
 + } 
 + catch ( TTransportException e ) 
 + { 
 + throw new RuntimeException ( String . format ( " Unable to create thrift socket to % s : % s " , 
 + listenAddr , listenPort ) , e ) ; 
 + } 
 + 
 + logger . info ( String . format ( " Binding thrift service to % s : % s " , listenAddr , listenPort ) ) ; 
 + 
 + / / Protocol factory 
 + TProtocolFactory tProtocolFactory = new TBinaryProtocol . Factory ( true , 
 + true , 
 + DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; 
 + 
 + / / Transport factory 
 + TTransportFactory inTransportFactory , outTransportFactory ; 
 + if ( DatabaseDescriptor . isThriftFramed ( ) ) 
 + { 
 + int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; 
 + inTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; 
 + outTransportFactory = new TFastFramedTransport . Factory ( 64 * 1024 , tFramedTransportSize ) ; 
 + logger . info ( " Using TFastFramedTransport with a max frame size of { } bytes . " , tFramedTransportSize ) ; 
 + } 
 + else 
 + { 
 + inTransportFactory = new TTransportFactory ( ) ; 
 + outTransportFactory = new TTransportFactory ( ) ; 
 + } 
 + 
 + / / ThreadPool Server 
 + CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; 
 + options . minWorkerThreads = MIN _ WORKER _ THREADS ; 
 + 
 + ExecutorService executorService = new CleaningThreadPool ( cassandraServer . clientState , 
 + options . minWorkerThreads , 
 + options . maxWorkerThreads ) ; 
 + serverEngine = new CustomTThreadPoolServer ( new TProcessorFactory ( processor ) , 
 + tServerSocket , 
 + inTransportFactory , 
 + outTransportFactory , 
 + tProtocolFactory , 
 + tProtocolFactory , 
 + options , 
 + executorService ) ; 
 + } 
 + 
 + public void run ( ) 
 + { 
 + logger . info ( " Listening for thrift clients . . . " ) ; 
 + serverEngine . serve ( ) ; 
 + } 
 + 
 + public void stopServer ( ) 
 + { 
 + logger . info ( " Stop listening to thrift clients " ) ; 
 + serverEngine . stop ( ) ; 
 + } 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cli / CliTest . java b / test / unit / org / apache / cassandra / cli / CliTest . java 
 index a34feac . . 580b127 100644 
 - - - a / test / unit / org / apache / cassandra / cli / CliTest . java 
 + + + b / test / unit / org / apache / cassandra / cli / CliTest . java 
 @ @ - 146 , 7 + 146 , 7 @ @ public class CliTest extends CleanupHelper 
 @ Test 
 public void testCli ( ) throws IOException , TTransportException , ConfigurationException 
 { 
 - setup ( ) ; 
 + new EmbeddedCassandraService ( ) . start ( ) ; 
 
 / / new error / output streams for CliSessionState 
 ByteArrayOutputStream errStream = new ByteArrayOutputStream ( ) ; 
 @ @ - 204 , 24 + 204 , 4 @ @ public class CliTest extends CleanupHelper 
 errStream . reset ( ) ; / / no errors to the end user . 
 } 
 } 
 - 
 - / * * 
 - * Setup embedded cassandra instance using test config . 
 - * @ throws TTransportException - when trying to bind address 
 - * @ throws IOException - when reading config file 
 - * @ throws ConfigurationException - when can set up configuration 
 - * / 
 - private void setup ( ) throws TTransportException , IOException , ConfigurationException 
 - { 
 - EmbeddedCassandraService cassandra ; 
 - 
 - cassandra = new EmbeddedCassandraService ( ) ; 
 - cassandra . init ( ) ; 
 - 
 - / / spawn cassandra in a new thread 
 - Thread t = new Thread ( cassandra ) ; 
 - t . setDaemon ( true ) ; 
 - t . start ( ) ; 
 - } 
 - 
 } 
 diff - - git a / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java b / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java 
 index e02432f . . efd2e11 100644 
 - - - a / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java 
 + + + b / test / unit / org / apache / cassandra / service / EmbeddedCassandraServiceTest . java 
 @ @ - 64 , 14 + 64 , 8 @ @ public class EmbeddedCassandraServiceTest extends CleanupHelper 
 @ BeforeClass 
 public static void setup ( ) throws TTransportException , IOException , InterruptedException , ConfigurationException 
 { 
 - 
 cassandra = new EmbeddedCassandraService ( ) ; 
 - cassandra . init ( ) ; 
 - 
 - / / spawn cassandra in a new thread 
 - Thread t = new Thread ( cassandra ) ; 
 - t . setDaemon ( true ) ; 
 - t . start ( ) ; 
 + cassandra . start ( ) ; 
 } 
 
 @ Test
