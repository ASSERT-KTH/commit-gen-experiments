BLEU SCORE: 0.04799810699119213

TEST MSG: cqlsh : fix DESCRIBE KEYSPACES
GENERATED MSG: Fix cqlsh ASSUME broken by CASSANDRA - 4198 .

TEST DIFF (one line): diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 9f872f8 . . bf0f8fd 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 1423 , 7 + 1423 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> what = parsed . matched [ 1 ] [ 1 ] . lower ( ) <nl> if what = = ' keyspaces ' : <nl> self . describe _ keyspaces ( ) <nl> - if what = = ' keyspace ' : <nl> + elif what = = ' keyspace ' : <nl> ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) <nl> if not ksname : <nl> ksname = self . current _ keyspace
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 693b03b . . ec03ca6 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 10 , 6 + 10 , 7 @ @ <nl> * ( cql3 ) Reject ( not yet supported ) creation of 2ndardy indexes on tables with <nl> composite primary keys ( CASSANDRA - 4328 ) <nl> * Set JVM stack size to 160k for java 7 ( CASSANDRA - 4275 ) <nl> + * cqlsh : add COPY command to load data from CSV flat files ( CASSANDRA - 4012 ) <nl> Merged from 1 . 0 : <nl> * Set gc _ grace on index CF to 0 ( CASSANDRA - 4314 ) <nl> <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index fecd472 . . 842a313 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 36 , 7 + 36 , 7 @ @ version = " 2 . 2 . 0 " <nl> <nl> from StringIO import StringIO <nl> from itertools import groupby <nl> - from contextlib import contextmanager <nl> + from contextlib import contextmanager , closing <nl> from glob import glob <nl> from functools import partial <nl> from collections import defaultdict <nl> @ @ - 52 , 6 + 52 , 7 @ @ import locale <nl> import re <nl> import platform <nl> import warnings <nl> + import csv <nl> <nl> # cqlsh should run correctly when run out of a Cassandra source tree , <nl> # out of an unpacked Cassandra tarball , and after a proper package install . <nl> @ @ - 189 , 6 + 190 , 7 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' <nl> | < assumeCommand > <nl> | < sourceCommand > <nl> | < captureCommand > <nl> + | < copyCommand > <nl> | < debugCommand > <nl> | < helpCommand > <nl> | < exitCommand > <nl> @ @ - 220 , 6 + 222 , 15 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' <nl> < captureCommand > : : = " CAPTURE " ( fname = ( < stringLiteral > | " OFF " ) ) ? <nl> ; <nl> <nl> + < copyCommand > : : = " COPY " cf = < columnFamilyName > <nl> + ( " ( " [ colnames ] = < colname > ( " , " [ colnames ] = < colname > ) * " ) " ) ? <nl> + " FROM " ( fname = < stringLiteral > | " STDIN " ) <nl> + ( " WITH " < copyOption > ( " AND " < copyOption > ) * ) ? <nl> + ; <nl> + <nl> + < copyOption > : : = [ optnames ] = < cfOptionName > " = " [ optvals ] = < cfOptionVal > <nl> + ; <nl> + <nl> # avoiding just " DEBUG " so that this rule doesn ' t get treated as a terminal <nl> < debugCommand > : : = " DEBUG " " THINGS " ? <nl> ; <nl> @ @ - 272 , 6 + 283 , 41 @ @ cqlsh _ syntax _ completer ( ' sourceCommand ' , ' fname ' ) \ <nl> cqlsh _ syntax _ completer ( ' captureCommand ' , ' fname ' ) \ <nl> ( complete _ source _ quoted _ filename ) <nl> <nl> + @ cqlsh _ syntax _ completer ( ' copyCommand ' , ' fname ' ) <nl> + def copy _ fname _ completer ( ctxt , cqlsh ) : <nl> + lasttype = ctxt . get _ binding ( ' * LASTTYPE * ' ) <nl> + if lasttype = = ' unclosedString ' : <nl> + return complete _ source _ quoted _ filename ( ctxt , cqlsh ) <nl> + partial = ctxt . get _ binding ( ' partial ' ) <nl> + if partial = = ' ' : <nl> + return [ " ' " ] <nl> + return ( ) <nl> + <nl> + @ cqlsh _ syntax _ completer ( ' copyCommand ' , ' colnames ' ) <nl> + def complete _ copy _ column _ names ( ctxt , cqlsh ) : <nl> + existcols = map ( cqlsh . cql _ unprotect _ name , ctxt . get _ binding ( ' colnames ' , ( ) ) ) <nl> + ks = cqlsh . cql _ unprotect _ name ( ctxt . get _ binding ( ' ksname ' , None ) ) <nl> + cf = cqlsh . cql _ unprotect _ name ( ctxt . get _ binding ( ' cfname ' ) ) <nl> + colnames = cqlsh . get _ column _ names ( ks , cf ) <nl> + if len ( existcols ) = = 0 : <nl> + return [ colnames [ 0 ] ] <nl> + return set ( colnames [ 1 : ] ) - set ( existcols ) <nl> + <nl> + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' ) <nl> + <nl> + @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) <nl> + def complete _ copy _ options ( ctxt , cqlsh ) : <nl> + optnames = map ( str . upper , ctxt . get _ binding ( ' optnames ' , ( ) ) ) <nl> + return set ( COPY _ OPTIONS ) - set ( optnames ) <nl> + <nl> + @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optvals ' ) <nl> + def complete _ copy _ opt _ values ( ctxt , cqlsh ) : <nl> + optnames = ctxt . get _ binding ( ' optnames ' , ( ) ) <nl> + lastopt = optnames [ - 1 ] . lower ( ) <nl> + if lastopt = = ' header ' : <nl> + return [ ' true ' , ' false ' ] <nl> + return [ cqlhandling . Hint ( ' < single _ character _ string > ' ) ] <nl> + <nl> class NoKeyspaceError ( Exception ) : <nl> pass <nl> <nl> @ @ - 469 , 6 + 515 , 22 @ @ def show _ warning _ without _ quoting _ line ( message , category , filename , lineno , file = <nl> warnings . showwarning = show _ warning _ without _ quoting _ line <nl> warnings . filterwarnings ( ' always ' , category = cql3handling . UnexpectedTableStructure ) <nl> <nl> + def describe _ interval ( seconds ) : <nl> + desc = [ ] <nl> + for length , unit in ( ( 86400 , ' day ' ) , ( 3600 , ' hour ' ) , ( 60 , ' minute ' ) ) : <nl> + num = int ( seconds ) / length <nl> + if num > 0 : <nl> + desc . append ( ' % d % s ' % ( num , unit ) ) <nl> + if num > 1 : <nl> + desc [ - 1 ] + = ' s ' <nl> + seconds % = length <nl> + words = ' % . 03f seconds ' % seconds <nl> + if len ( desc ) > 1 : <nl> + words = ' , ' . join ( desc ) + ' , and ' + words <nl> + elif len ( desc ) = = 1 : <nl> + words = desc [ 0 ] + ' and ' + words <nl> + return words <nl> + <nl> class Shell ( cmd . Cmd ) : <nl> default _ prompt = " cqlsh > " <nl> continue _ prompt = " . . . " <nl> @ @ - 481 , 6 + 543 , 8 @ @ class Shell ( cmd . Cmd ) : <nl> debug = False <nl> stop = False <nl> shunted _ query _ out = None <nl> + csv _ dialect _ defaults = dict ( delimiter = ' , ' , doublequote = False , <nl> + escapechar = ' \ \ ' , quotechar = ' " ' ) <nl> <nl> def _ _ init _ _ ( self , hostname , port , color = False , username = None , <nl> password = None , encoding = None , stdin = None , tty = True , <nl> @ @ - 522 , 7 + 586 , 6 @ @ class Shell ( cmd . Cmd ) : <nl> stdin = sys . stdin <nl> self . tty = tty <nl> if tty : <nl> - self . prompt = None <nl> self . reset _ prompt ( ) <nl> self . report _ connection ( ) <nl> print ' Use HELP for help . ' <nl> @ @ - 661 , 6 + 724 , 25 @ @ class Shell ( cmd . Cmd ) : <nl> filterable . add ( cm . name ) <nl> return filterable <nl> <nl> + def get _ column _ names ( self , ksname , cfname ) : <nl> + if ksname is None : <nl> + ksname = self . current _ keyspace <nl> + if self . cqlver _ atleast ( 3 ) : <nl> + return self . get _ column _ names _ from _ layout ( ksname , cfname ) <nl> + else : <nl> + return self . get _ column _ names _ from _ cfdef ( ksname , cfname ) <nl> + <nl> + def get _ column _ names _ from _ layout ( self , ksname , cfname ) : <nl> + layout = self . get _ columnfamily _ layout ( ksname , cfname ) <nl> + return [ col . name for col in layout . columns ] <nl> + <nl> + def get _ column _ names _ from _ cfdef ( self , ksname , cfname ) : <nl> + cfdef = self . get _ columnfamily ( cfname , ksname = ksname ) <nl> + key _ alias = cfdef . key _ alias <nl> + if key _ alias is None : <nl> + key _ alias = ' KEY ' <nl> + return [ key _ alias ] + [ cm . name for cm in cfdef . column _ metadata ] <nl> + <nl> # = = = = = thrift - dependent parts = = = = = <nl> <nl> def get _ cluster _ name ( self ) : <nl> @ @ - 758 , 16 + 840 , 25 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> def get _ input _ line ( self , prompt = ' ' ) : <nl> if self . tty : <nl> - line = raw _ input ( self . prompt ) + ' \ n ' <nl> + line = raw _ input ( prompt ) + ' \ n ' <nl> else : <nl> - sys . stdout . write ( self . prompt ) <nl> - sys . stdout . flush ( ) <nl> line = self . stdin . readline ( ) <nl> if not len ( line ) : <nl> raise EOFError <nl> self . lineno + = 1 <nl> return line <nl> <nl> + def use _ stdin _ reader ( self , until = ' ' , prompt = ' ' ) : <nl> + until + = ' \ n ' <nl> + while True : <nl> + try : <nl> + newline = self . get _ input _ line ( prompt = prompt ) <nl> + except EOFError : <nl> + return <nl> + if newline = = until : <nl> + return <nl> + yield newline <nl> + <nl> def cmdloop ( self ) : <nl> " " " <nl> Adapted from cmd . Cmd ' s version , because there is literally no way with <nl> @ @ - 1065 , 8 + 1156 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> debug = debug _ completion , startsymbol = ' cqlshCommand ' ) <nl> <nl> def set _ prompt ( self , prompt ) : <nl> - if self . prompt ! = ' ' : <nl> - self . prompt = prompt <nl> + self . prompt = prompt <nl> <nl> def cql _ protect _ name ( self , name ) : <nl> return cqlruleset . maybe _ escape _ name ( name ) <nl> @ @ - 1339 , 6 + 1429 , 125 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> do _ desc = do _ describe <nl> <nl> + def do _ copy ( self , parsed ) : <nl> + r " " " <nl> + COPY [ cqlsh only ] <nl> + <nl> + Imports CSV data into a Cassandra table . <nl> + <nl> + COPY < table _ name > [ ( column [ , . . . ] ) ] <nl> + FROM ( ' < filename > ' | STDIN ) <nl> + [ WITH < option > = ' value ' [ AND . . . ] ] ; <nl> + <nl> + Available options and defaults : <nl> + <nl> + DELIMITER = ' , ' - character that appears between records <nl> + QUOTE = ' " ' - quoting character to be used to quote fields <nl> + ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted <nl> + HEADER = false - whether to ignore the first line <nl> + <nl> + When entering CSV data on STDIN , you can use the sequence " \ . " <nl> + on a line by itself to end the data input . <nl> + " " " <nl> + <nl> + ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) <nl> + if ks is None : <nl> + ks = self . current _ keyspace <nl> + cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) <nl> + columns = parsed . get _ binding ( ' colnames ' , None ) <nl> + if columns is None : <nl> + # default to all known columns <nl> + columns = self . get _ column _ names ( ks , cf ) <nl> + else : <nl> + columns = map ( self . cql _ unprotect _ name , columns ) <nl> + fname = parsed . get _ binding ( ' fname ' , None ) <nl> + if fname is not None : <nl> + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) <nl> + copyoptnames = map ( str . lower , parsed . get _ binding ( ' optnames ' , ( ) ) ) <nl> + copyoptvals = map ( self . cql _ unprotect _ value , parsed . get _ binding ( ' optvals ' , ( ) ) ) <nl> + opts = dict ( zip ( copyoptnames , copyoptvals ) ) <nl> + <nl> + # when / if COPY TO is supported , this would be a good place to branch <nl> + # on direction . <nl> + <nl> + timestart = time . time ( ) <nl> + rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) <nl> + timeend = time . time ( ) <nl> + <nl> + print " % d rows imported in % s . " % ( rows , describe _ interval ( timeend - timestart ) ) <nl> + <nl> + def perform _ csv _ import ( self , ks , cf , columns , fname , opts ) : <nl> + dialect _ options = self . csv _ dialect _ defaults . copy ( ) <nl> + if ' quote ' in opts : <nl> + dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) <nl> + if ' escape ' in opts : <nl> + dialect _ options [ ' escapechar ' ] = opts . pop ( ' escape ' ) <nl> + if ' delimiter ' in opts : <nl> + dialect _ options [ ' delimiter ' ] = opts . pop ( ' delimiter ' ) <nl> + header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) <nl> + if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : <nl> + dialect _ options [ ' doublequote ' ] = True <nl> + del dialect _ options [ ' escapechar ' ] <nl> + <nl> + if opts : <nl> + self . printerr ( ' Unrecognized COPY FROM options : % s ' <nl> + % ' , ' . join ( opts . keys ( ) ) ) <nl> + return 0 <nl> + <nl> + if fname is None : <nl> + do _ close = False <nl> + print " [ Use \ . on a line by itself to end input ] " <nl> + linesource = self . use _ stdin _ reader ( prompt = ' [ copy ] ' , until = r ' \ . ' ) <nl> + else : <nl> + do _ close = True <nl> + try : <nl> + linesource = open ( fname , ' r ' ) <nl> + except IOError , e : <nl> + self . printerr ( " Can ' t open % r for reading : % s " % ( fname , e ) ) <nl> + return 0 <nl> + if header : <nl> + linesource . next ( ) <nl> + <nl> + prepq = self . prep _ import _ insert ( ks , cf , columns ) <nl> + try : <nl> + reader = csv . reader ( linesource , * * dialect _ options ) <nl> + for rownum , row in enumerate ( reader ) : <nl> + if len ( row ) ! = len ( columns ) : <nl> + self . printerr ( " Record # % d ( line % d ) has the wrong number of fields " <nl> + " ( % d instead of % d ) . " <nl> + % ( rownum , reader . line _ num , len ( row ) , len ( columns ) ) ) <nl> + return rownum <nl> + if not self . do _ import _ insert ( prepq , row ) : <nl> + self . printerr ( " Aborting import at record # % d ( line % d ) . " <nl> + " Previously - inserted values still present . " <nl> + % ( rownum , reader . line _ num ) ) <nl> + return rownum <nl> + finally : <nl> + if do _ close : <nl> + linesource . close ( ) <nl> + elif self . tty : <nl> + print <nl> + return rownum + 1 <nl> + <nl> + def prep _ import _ insert ( self , ks , cf , columns ) : <nl> + # would be nice to be able to use a prepared query here , but in order <nl> + # to use that interface , we ' d need to have all the input as native <nl> + # values already , reading them from text just like the various <nl> + # Cassandra cql types do . Better just to submit them all as intact <nl> + # CQL string literals and let Cassandra do its thing . <nl> + return ' INSERT INTO % s . % s ( % s ) VALUES ( % % s ) ' % ( <nl> + self . cql _ protect _ name ( ks ) , <nl> + self . cql _ protect _ name ( cf ) , <nl> + ' , ' . join ( map ( self . cql _ protect _ name , columns ) ) <nl> + ) <nl> + <nl> + def do _ import _ insert ( self , prepq , rowvalues ) : <nl> + valstring = ' , ' . join ( map ( self . cql _ protect _ value , rowvalues ) ) <nl> + cql = prepq % valstring <nl> + if self . debug : <nl> + print " Import using CQL : % s " % cql <nl> + return self . perform _ statement ( cql ) <nl> + <nl> def do _ show ( self , parsed ) : <nl> " " " <nl> SHOW [ cqlsh only ] <nl> @ @ - 1457 , 7 + 1666 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> " " " <nl> <nl> fname = parsed . get _ binding ( ' fname ' ) <nl> - fname = os . path . expanduser ( cqlsh . cql _ unprotect _ value ( fname ) ) <nl> + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) <nl> try : <nl> f = open ( fname , ' r ' ) <nl> except IOError , e : <nl> @ @ - 1521 , 7 + 1730 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> ' to disable . ' % ( self . query _ out . name , ) ) <nl> return <nl> <nl> - fname = os . path . expanduser ( cqlsh . cql _ unprotect _ value ( fname ) ) <nl> + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) <nl> try : <nl> f = open ( fname , ' a ' ) <nl> except IOError , e : <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 8785a65 . . 2bc7ef9 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 267 , 8 + 267 , 8 @ @ def unreserved _ keyword _ completer ( ctxt , cass ) : <nl> return ( ) <nl> <nl> def get _ cf _ layout ( ctxt , cass ) : <nl> - ks = ctxt . get _ binding ( ' ksname ' , None ) <nl> - cf = ctxt . get _ binding ( ' cfname ' ) <nl> + ks = dequote _ name ( ctxt . get _ binding ( ' ksname ' , None ) ) <nl> + cf = dequote _ name ( ctxt . get _ binding ( ' cfname ' ) ) <nl> return cass . get _ columnfamily _ layout ( ks , cf ) <nl> <nl> syntax _ rules + = r ' ' ' <nl> diff - - git a / pylib / cqlshlib / cqlhandling . py b / pylib / cqlshlib / cqlhandling . py <nl> index 3866f3c . . aa29c60 100644 <nl> - - - a / pylib / cqlshlib / cqlhandling . py <nl> + + + b / pylib / cqlshlib / cqlhandling . py <nl> @ @ - 215 , 22 + 215 , 25 @ @ class CqlParsingRuleSet ( pylexotron . ParsingRuleSet ) : <nl> # inside a string literal <nl> prefix = None <nl> dequoter = util . identity <nl> + lasttype = None <nl> if tokens : <nl> - if tokens [ - 1 ] [ 0 ] = = ' unclosedString ' : <nl> + lasttype = tokens [ - 1 ] [ 0 ] <nl> + if lasttype = = ' unclosedString ' : <nl> prefix = self . token _ dequote ( tokens [ - 1 ] ) <nl> tokens = tokens [ : - 1 ] <nl> partial = prefix + partial <nl> dequoter = self . dequote _ value <nl> requoter = self . escape _ value <nl> - elif tokens [ - 1 ] [ 0 ] = = ' unclosedName ' : <nl> + elif lasttype = = ' unclosedName ' : <nl> prefix = self . token _ dequote ( tokens [ - 1 ] ) <nl> tokens = tokens [ : - 1 ] <nl> partial = prefix + partial <nl> dequoter = self . dequote _ name <nl> requoter = self . escape _ name <nl> - elif tokens [ - 1 ] [ 0 ] = = ' unclosedComment ' : <nl> + elif lasttype = = ' unclosedComment ' : <nl> return [ ] <nl> bindings [ ' partial ' ] = partial <nl> + bindings [ ' * LASTTYPE * ' ] = lasttype <nl> bindings [ ' * SRC * ' ] = text <nl> <nl> # find completions for the position <nl> @ @ - 302 , 6 + 305 , 7 @ @ class CqlParsingRuleSet ( pylexotron . ParsingRuleSet ) : <nl> init _ bindings = { ' cassandra _ conn ' : cassandra _ conn } <nl> if debug : <nl> init _ bindings [ ' * DEBUG * ' ] = True <nl> + print " cql _ complete ( % r , partial = % r ) " % ( text , partial ) <nl> <nl> completions , hints = self . cql _ complete _ single ( text , partial , init _ bindings , <nl> startsymbol = startsymbol ) <nl> @ @ - 495 , 6 + 499 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> ; <nl> < colname > : : = < term > <nl> | < identifier > <nl> + | nocomplete = < K _ KEY > <nl> ; <nl> <nl> < statementBody > : : = < useStatement > <nl> @ @ - 528 , 6 + 533 , 10 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; <nl> < columnFamilyName > : : = ( ksname = < name > " . " ) ? cfname = < name > ; <nl> ' ' ' <nl> <nl> + @ completer _ for ( ' colname ' , ' nocomplete ' ) <nl> + def nocomplete ( ctxt , cass ) : <nl> + return ( ) <nl> + <nl> @ completer _ for ( ' consistencylevel ' , ' cl ' ) <nl> def cl _ completer ( ctxt , cass ) : <nl> return CqlRuleSet . consistency _ levels

TEST DIFF:
diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 9f872f8 . . bf0f8fd 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 1423 , 7 + 1423 , 7 @ @ class Shell ( cmd . Cmd ) : 
 what = parsed . matched [ 1 ] [ 1 ] . lower ( ) 
 if what = = ' keyspaces ' : 
 self . describe _ keyspaces ( ) 
 - if what = = ' keyspace ' : 
 + elif what = = ' keyspace ' : 
 ksname = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , ' ' ) ) 
 if not ksname : 
 ksname = self . current _ keyspace

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 693b03b . . ec03ca6 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 10 , 6 + 10 , 7 @ @ 
 * ( cql3 ) Reject ( not yet supported ) creation of 2ndardy indexes on tables with 
 composite primary keys ( CASSANDRA - 4328 ) 
 * Set JVM stack size to 160k for java 7 ( CASSANDRA - 4275 ) 
 + * cqlsh : add COPY command to load data from CSV flat files ( CASSANDRA - 4012 ) 
 Merged from 1 . 0 : 
 * Set gc _ grace on index CF to 0 ( CASSANDRA - 4314 ) 
 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index fecd472 . . 842a313 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 36 , 7 + 36 , 7 @ @ version = " 2 . 2 . 0 " 
 
 from StringIO import StringIO 
 from itertools import groupby 
 - from contextlib import contextmanager 
 + from contextlib import contextmanager , closing 
 from glob import glob 
 from functools import partial 
 from collections import defaultdict 
 @ @ - 52 , 6 + 52 , 7 @ @ import locale 
 import re 
 import platform 
 import warnings 
 + import csv 
 
 # cqlsh should run correctly when run out of a Cassandra source tree , 
 # out of an unpacked Cassandra tarball , and after a proper package install . 
 @ @ - 189 , 6 + 190 , 7 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' 
 | < assumeCommand > 
 | < sourceCommand > 
 | < captureCommand > 
 + | < copyCommand > 
 | < debugCommand > 
 | < helpCommand > 
 | < exitCommand > 
 @ @ - 220 , 6 + 222 , 15 @ @ cqlsh _ extra _ syntax _ rules = r ' ' ' 
 < captureCommand > : : = " CAPTURE " ( fname = ( < stringLiteral > | " OFF " ) ) ? 
 ; 
 
 + < copyCommand > : : = " COPY " cf = < columnFamilyName > 
 + ( " ( " [ colnames ] = < colname > ( " , " [ colnames ] = < colname > ) * " ) " ) ? 
 + " FROM " ( fname = < stringLiteral > | " STDIN " ) 
 + ( " WITH " < copyOption > ( " AND " < copyOption > ) * ) ? 
 + ; 
 + 
 + < copyOption > : : = [ optnames ] = < cfOptionName > " = " [ optvals ] = < cfOptionVal > 
 + ; 
 + 
 # avoiding just " DEBUG " so that this rule doesn ' t get treated as a terminal 
 < debugCommand > : : = " DEBUG " " THINGS " ? 
 ; 
 @ @ - 272 , 6 + 283 , 41 @ @ cqlsh _ syntax _ completer ( ' sourceCommand ' , ' fname ' ) \ 
 cqlsh _ syntax _ completer ( ' captureCommand ' , ' fname ' ) \ 
 ( complete _ source _ quoted _ filename ) 
 
 + @ cqlsh _ syntax _ completer ( ' copyCommand ' , ' fname ' ) 
 + def copy _ fname _ completer ( ctxt , cqlsh ) : 
 + lasttype = ctxt . get _ binding ( ' * LASTTYPE * ' ) 
 + if lasttype = = ' unclosedString ' : 
 + return complete _ source _ quoted _ filename ( ctxt , cqlsh ) 
 + partial = ctxt . get _ binding ( ' partial ' ) 
 + if partial = = ' ' : 
 + return [ " ' " ] 
 + return ( ) 
 + 
 + @ cqlsh _ syntax _ completer ( ' copyCommand ' , ' colnames ' ) 
 + def complete _ copy _ column _ names ( ctxt , cqlsh ) : 
 + existcols = map ( cqlsh . cql _ unprotect _ name , ctxt . get _ binding ( ' colnames ' , ( ) ) ) 
 + ks = cqlsh . cql _ unprotect _ name ( ctxt . get _ binding ( ' ksname ' , None ) ) 
 + cf = cqlsh . cql _ unprotect _ name ( ctxt . get _ binding ( ' cfname ' ) ) 
 + colnames = cqlsh . get _ column _ names ( ks , cf ) 
 + if len ( existcols ) = = 0 : 
 + return [ colnames [ 0 ] ] 
 + return set ( colnames [ 1 : ] ) - set ( existcols ) 
 + 
 + COPY _ OPTIONS = ( ' DELIMITER ' , ' QUOTE ' , ' ESCAPE ' , ' HEADER ' ) 
 + 
 + @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optnames ' ) 
 + def complete _ copy _ options ( ctxt , cqlsh ) : 
 + optnames = map ( str . upper , ctxt . get _ binding ( ' optnames ' , ( ) ) ) 
 + return set ( COPY _ OPTIONS ) - set ( optnames ) 
 + 
 + @ cqlsh _ syntax _ completer ( ' copyOption ' , ' optvals ' ) 
 + def complete _ copy _ opt _ values ( ctxt , cqlsh ) : 
 + optnames = ctxt . get _ binding ( ' optnames ' , ( ) ) 
 + lastopt = optnames [ - 1 ] . lower ( ) 
 + if lastopt = = ' header ' : 
 + return [ ' true ' , ' false ' ] 
 + return [ cqlhandling . Hint ( ' < single _ character _ string > ' ) ] 
 + 
 class NoKeyspaceError ( Exception ) : 
 pass 
 
 @ @ - 469 , 6 + 515 , 22 @ @ def show _ warning _ without _ quoting _ line ( message , category , filename , lineno , file = 
 warnings . showwarning = show _ warning _ without _ quoting _ line 
 warnings . filterwarnings ( ' always ' , category = cql3handling . UnexpectedTableStructure ) 
 
 + def describe _ interval ( seconds ) : 
 + desc = [ ] 
 + for length , unit in ( ( 86400 , ' day ' ) , ( 3600 , ' hour ' ) , ( 60 , ' minute ' ) ) : 
 + num = int ( seconds ) / length 
 + if num > 0 : 
 + desc . append ( ' % d % s ' % ( num , unit ) ) 
 + if num > 1 : 
 + desc [ - 1 ] + = ' s ' 
 + seconds % = length 
 + words = ' % . 03f seconds ' % seconds 
 + if len ( desc ) > 1 : 
 + words = ' , ' . join ( desc ) + ' , and ' + words 
 + elif len ( desc ) = = 1 : 
 + words = desc [ 0 ] + ' and ' + words 
 + return words 
 + 
 class Shell ( cmd . Cmd ) : 
 default _ prompt = " cqlsh > " 
 continue _ prompt = " . . . " 
 @ @ - 481 , 6 + 543 , 8 @ @ class Shell ( cmd . Cmd ) : 
 debug = False 
 stop = False 
 shunted _ query _ out = None 
 + csv _ dialect _ defaults = dict ( delimiter = ' , ' , doublequote = False , 
 + escapechar = ' \ \ ' , quotechar = ' " ' ) 
 
 def _ _ init _ _ ( self , hostname , port , color = False , username = None , 
 password = None , encoding = None , stdin = None , tty = True , 
 @ @ - 522 , 7 + 586 , 6 @ @ class Shell ( cmd . Cmd ) : 
 stdin = sys . stdin 
 self . tty = tty 
 if tty : 
 - self . prompt = None 
 self . reset _ prompt ( ) 
 self . report _ connection ( ) 
 print ' Use HELP for help . ' 
 @ @ - 661 , 6 + 724 , 25 @ @ class Shell ( cmd . Cmd ) : 
 filterable . add ( cm . name ) 
 return filterable 
 
 + def get _ column _ names ( self , ksname , cfname ) : 
 + if ksname is None : 
 + ksname = self . current _ keyspace 
 + if self . cqlver _ atleast ( 3 ) : 
 + return self . get _ column _ names _ from _ layout ( ksname , cfname ) 
 + else : 
 + return self . get _ column _ names _ from _ cfdef ( ksname , cfname ) 
 + 
 + def get _ column _ names _ from _ layout ( self , ksname , cfname ) : 
 + layout = self . get _ columnfamily _ layout ( ksname , cfname ) 
 + return [ col . name for col in layout . columns ] 
 + 
 + def get _ column _ names _ from _ cfdef ( self , ksname , cfname ) : 
 + cfdef = self . get _ columnfamily ( cfname , ksname = ksname ) 
 + key _ alias = cfdef . key _ alias 
 + if key _ alias is None : 
 + key _ alias = ' KEY ' 
 + return [ key _ alias ] + [ cm . name for cm in cfdef . column _ metadata ] 
 + 
 # = = = = = thrift - dependent parts = = = = = 
 
 def get _ cluster _ name ( self ) : 
 @ @ - 758 , 16 + 840 , 25 @ @ class Shell ( cmd . Cmd ) : 
 
 def get _ input _ line ( self , prompt = ' ' ) : 
 if self . tty : 
 - line = raw _ input ( self . prompt ) + ' \ n ' 
 + line = raw _ input ( prompt ) + ' \ n ' 
 else : 
 - sys . stdout . write ( self . prompt ) 
 - sys . stdout . flush ( ) 
 line = self . stdin . readline ( ) 
 if not len ( line ) : 
 raise EOFError 
 self . lineno + = 1 
 return line 
 
 + def use _ stdin _ reader ( self , until = ' ' , prompt = ' ' ) : 
 + until + = ' \ n ' 
 + while True : 
 + try : 
 + newline = self . get _ input _ line ( prompt = prompt ) 
 + except EOFError : 
 + return 
 + if newline = = until : 
 + return 
 + yield newline 
 + 
 def cmdloop ( self ) : 
 " " " 
 Adapted from cmd . Cmd ' s version , because there is literally no way with 
 @ @ - 1065 , 8 + 1156 , 7 @ @ class Shell ( cmd . Cmd ) : 
 debug = debug _ completion , startsymbol = ' cqlshCommand ' ) 
 
 def set _ prompt ( self , prompt ) : 
 - if self . prompt ! = ' ' : 
 - self . prompt = prompt 
 + self . prompt = prompt 
 
 def cql _ protect _ name ( self , name ) : 
 return cqlruleset . maybe _ escape _ name ( name ) 
 @ @ - 1339 , 6 + 1429 , 125 @ @ class Shell ( cmd . Cmd ) : 
 
 do _ desc = do _ describe 
 
 + def do _ copy ( self , parsed ) : 
 + r " " " 
 + COPY [ cqlsh only ] 
 + 
 + Imports CSV data into a Cassandra table . 
 + 
 + COPY < table _ name > [ ( column [ , . . . ] ) ] 
 + FROM ( ' < filename > ' | STDIN ) 
 + [ WITH < option > = ' value ' [ AND . . . ] ] ; 
 + 
 + Available options and defaults : 
 + 
 + DELIMITER = ' , ' - character that appears between records 
 + QUOTE = ' " ' - quoting character to be used to quote fields 
 + ESCAPE = ' \ ' - character to appear before the QUOTE char when quoted 
 + HEADER = false - whether to ignore the first line 
 + 
 + When entering CSV data on STDIN , you can use the sequence " \ . " 
 + on a line by itself to end the data input . 
 + " " " 
 + 
 + ks = self . cql _ unprotect _ name ( parsed . get _ binding ( ' ksname ' , None ) ) 
 + if ks is None : 
 + ks = self . current _ keyspace 
 + cf = self . cql _ unprotect _ name ( parsed . get _ binding ( ' cfname ' ) ) 
 + columns = parsed . get _ binding ( ' colnames ' , None ) 
 + if columns is None : 
 + # default to all known columns 
 + columns = self . get _ column _ names ( ks , cf ) 
 + else : 
 + columns = map ( self . cql _ unprotect _ name , columns ) 
 + fname = parsed . get _ binding ( ' fname ' , None ) 
 + if fname is not None : 
 + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) 
 + copyoptnames = map ( str . lower , parsed . get _ binding ( ' optnames ' , ( ) ) ) 
 + copyoptvals = map ( self . cql _ unprotect _ value , parsed . get _ binding ( ' optvals ' , ( ) ) ) 
 + opts = dict ( zip ( copyoptnames , copyoptvals ) ) 
 + 
 + # when / if COPY TO is supported , this would be a good place to branch 
 + # on direction . 
 + 
 + timestart = time . time ( ) 
 + rows = self . perform _ csv _ import ( ks , cf , columns , fname , opts ) 
 + timeend = time . time ( ) 
 + 
 + print " % d rows imported in % s . " % ( rows , describe _ interval ( timeend - timestart ) ) 
 + 
 + def perform _ csv _ import ( self , ks , cf , columns , fname , opts ) : 
 + dialect _ options = self . csv _ dialect _ defaults . copy ( ) 
 + if ' quote ' in opts : 
 + dialect _ options [ ' quotechar ' ] = opts . pop ( ' quote ' ) 
 + if ' escape ' in opts : 
 + dialect _ options [ ' escapechar ' ] = opts . pop ( ' escape ' ) 
 + if ' delimiter ' in opts : 
 + dialect _ options [ ' delimiter ' ] = opts . pop ( ' delimiter ' ) 
 + header = bool ( opts . pop ( ' header ' , ' ' ) . lower ( ) = = ' true ' ) 
 + if dialect _ options [ ' quotechar ' ] = = dialect _ options [ ' escapechar ' ] : 
 + dialect _ options [ ' doublequote ' ] = True 
 + del dialect _ options [ ' escapechar ' ] 
 + 
 + if opts : 
 + self . printerr ( ' Unrecognized COPY FROM options : % s ' 
 + % ' , ' . join ( opts . keys ( ) ) ) 
 + return 0 
 + 
 + if fname is None : 
 + do _ close = False 
 + print " [ Use \ . on a line by itself to end input ] " 
 + linesource = self . use _ stdin _ reader ( prompt = ' [ copy ] ' , until = r ' \ . ' ) 
 + else : 
 + do _ close = True 
 + try : 
 + linesource = open ( fname , ' r ' ) 
 + except IOError , e : 
 + self . printerr ( " Can ' t open % r for reading : % s " % ( fname , e ) ) 
 + return 0 
 + if header : 
 + linesource . next ( ) 
 + 
 + prepq = self . prep _ import _ insert ( ks , cf , columns ) 
 + try : 
 + reader = csv . reader ( linesource , * * dialect _ options ) 
 + for rownum , row in enumerate ( reader ) : 
 + if len ( row ) ! = len ( columns ) : 
 + self . printerr ( " Record # % d ( line % d ) has the wrong number of fields " 
 + " ( % d instead of % d ) . " 
 + % ( rownum , reader . line _ num , len ( row ) , len ( columns ) ) ) 
 + return rownum 
 + if not self . do _ import _ insert ( prepq , row ) : 
 + self . printerr ( " Aborting import at record # % d ( line % d ) . " 
 + " Previously - inserted values still present . " 
 + % ( rownum , reader . line _ num ) ) 
 + return rownum 
 + finally : 
 + if do _ close : 
 + linesource . close ( ) 
 + elif self . tty : 
 + print 
 + return rownum + 1 
 + 
 + def prep _ import _ insert ( self , ks , cf , columns ) : 
 + # would be nice to be able to use a prepared query here , but in order 
 + # to use that interface , we ' d need to have all the input as native 
 + # values already , reading them from text just like the various 
 + # Cassandra cql types do . Better just to submit them all as intact 
 + # CQL string literals and let Cassandra do its thing . 
 + return ' INSERT INTO % s . % s ( % s ) VALUES ( % % s ) ' % ( 
 + self . cql _ protect _ name ( ks ) , 
 + self . cql _ protect _ name ( cf ) , 
 + ' , ' . join ( map ( self . cql _ protect _ name , columns ) ) 
 + ) 
 + 
 + def do _ import _ insert ( self , prepq , rowvalues ) : 
 + valstring = ' , ' . join ( map ( self . cql _ protect _ value , rowvalues ) ) 
 + cql = prepq % valstring 
 + if self . debug : 
 + print " Import using CQL : % s " % cql 
 + return self . perform _ statement ( cql ) 
 + 
 def do _ show ( self , parsed ) : 
 " " " 
 SHOW [ cqlsh only ] 
 @ @ - 1457 , 7 + 1666 , 7 @ @ class Shell ( cmd . Cmd ) : 
 " " " 
 
 fname = parsed . get _ binding ( ' fname ' ) 
 - fname = os . path . expanduser ( cqlsh . cql _ unprotect _ value ( fname ) ) 
 + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) 
 try : 
 f = open ( fname , ' r ' ) 
 except IOError , e : 
 @ @ - 1521 , 7 + 1730 , 7 @ @ class Shell ( cmd . Cmd ) : 
 ' to disable . ' % ( self . query _ out . name , ) ) 
 return 
 
 - fname = os . path . expanduser ( cqlsh . cql _ unprotect _ value ( fname ) ) 
 + fname = os . path . expanduser ( self . cql _ unprotect _ value ( fname ) ) 
 try : 
 f = open ( fname , ' a ' ) 
 except IOError , e : 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 8785a65 . . 2bc7ef9 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 267 , 8 + 267 , 8 @ @ def unreserved _ keyword _ completer ( ctxt , cass ) : 
 return ( ) 
 
 def get _ cf _ layout ( ctxt , cass ) : 
 - ks = ctxt . get _ binding ( ' ksname ' , None ) 
 - cf = ctxt . get _ binding ( ' cfname ' ) 
 + ks = dequote _ name ( ctxt . get _ binding ( ' ksname ' , None ) ) 
 + cf = dequote _ name ( ctxt . get _ binding ( ' cfname ' ) ) 
 return cass . get _ columnfamily _ layout ( ks , cf ) 
 
 syntax _ rules + = r ' ' ' 
 diff - - git a / pylib / cqlshlib / cqlhandling . py b / pylib / cqlshlib / cqlhandling . py 
 index 3866f3c . . aa29c60 100644 
 - - - a / pylib / cqlshlib / cqlhandling . py 
 + + + b / pylib / cqlshlib / cqlhandling . py 
 @ @ - 215 , 22 + 215 , 25 @ @ class CqlParsingRuleSet ( pylexotron . ParsingRuleSet ) : 
 # inside a string literal 
 prefix = None 
 dequoter = util . identity 
 + lasttype = None 
 if tokens : 
 - if tokens [ - 1 ] [ 0 ] = = ' unclosedString ' : 
 + lasttype = tokens [ - 1 ] [ 0 ] 
 + if lasttype = = ' unclosedString ' : 
 prefix = self . token _ dequote ( tokens [ - 1 ] ) 
 tokens = tokens [ : - 1 ] 
 partial = prefix + partial 
 dequoter = self . dequote _ value 
 requoter = self . escape _ value 
 - elif tokens [ - 1 ] [ 0 ] = = ' unclosedName ' : 
 + elif lasttype = = ' unclosedName ' : 
 prefix = self . token _ dequote ( tokens [ - 1 ] ) 
 tokens = tokens [ : - 1 ] 
 partial = prefix + partial 
 dequoter = self . dequote _ name 
 requoter = self . escape _ name 
 - elif tokens [ - 1 ] [ 0 ] = = ' unclosedComment ' : 
 + elif lasttype = = ' unclosedComment ' : 
 return [ ] 
 bindings [ ' partial ' ] = partial 
 + bindings [ ' * LASTTYPE * ' ] = lasttype 
 bindings [ ' * SRC * ' ] = text 
 
 # find completions for the position 
 @ @ - 302 , 6 + 305 , 7 @ @ class CqlParsingRuleSet ( pylexotron . ParsingRuleSet ) : 
 init _ bindings = { ' cassandra _ conn ' : cassandra _ conn } 
 if debug : 
 init _ bindings [ ' * DEBUG * ' ] = True 
 + print " cql _ complete ( % r , partial = % r ) " % ( text , partial ) 
 
 completions , hints = self . cql _ complete _ single ( text , partial , init _ bindings , 
 startsymbol = startsymbol ) 
 @ @ - 495 , 6 + 499 , 7 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 ; 
 < colname > : : = < term > 
 | < identifier > 
 + | nocomplete = < K _ KEY > 
 ; 
 
 < statementBody > : : = < useStatement > 
 @ @ - 528 , 6 + 533 , 10 @ @ JUNK : : = / ( [ \ t \ r \ f \ v ] + | ( - - | [ / ] [ / ] ) [ ^ \ n \ r ] * ( [ \ n \ r ] | $ ) | [ / ] [ * ] . * ? [ * ] [ / ] ) / ; 
 < columnFamilyName > : : = ( ksname = < name > " . " ) ? cfname = < name > ; 
 ' ' ' 
 
 + @ completer _ for ( ' colname ' , ' nocomplete ' ) 
 + def nocomplete ( ctxt , cass ) : 
 + return ( ) 
 + 
 @ completer _ for ( ' consistencylevel ' , ' cl ' ) 
 def cl _ completer ( ctxt , cass ) : 
 return CqlRuleSet . consistency _ levels
