BLEU SCORE: 0.09535414040914189

TEST MSG: Allow manually specifying start / end tokens in CFIF
GENERATED MSG: Fix InputKeyRange in CFIF

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 65f4f3b . . 477afd9 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 7 <nl> + * ( Hadoop ) Allow manually specifying start / end tokens in CFIF ( CASSANDRA - 6436 ) <nl> * Fix NPE in MeteredFlusher ( CASSANDRA - 6820 ) <nl> * Fix race processing range scan responses ( CASSANDRA - 6820 ) <nl> * Allow deleting snapshots from dropped keyspaces ( CASSANDRA - 6821 ) <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java b / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java <nl> index ba79eee . . 03b1576 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java <nl> @ @ - 141 , 11 + 141 , 7 @ @ public abstract class AbstractColumnFamilyInputFormat < K , Y > extends InputFormat < <nl> Range < Token > jobRange = null ; <nl> if ( jobKeyRange ! = null ) <nl> { <nl> - if ( jobKeyRange . start _ key = = null ) <nl> - { <nl> - logger . warn ( " ignoring jobKeyRange specified without start _ key " ) ; <nl> - } <nl> - else <nl> + if ( jobKeyRange . start _ key ! = null ) <nl> { <nl> if ( ! partitioner . preservesOrder ( ) ) <nl> throw new UnsupportedOperationException ( " KeyRange based on keys can only be used with a order preserving paritioner " ) ; <nl> @ @ - 153 , 9 + 149 , 19 @ @ public abstract class AbstractColumnFamilyInputFormat < K , Y > extends InputFormat < <nl> throw new IllegalArgumentException ( " only start _ key supported " ) ; <nl> if ( jobKeyRange . end _ token ! = null ) <nl> throw new IllegalArgumentException ( " only start _ key supported " ) ; <nl> - jobRange = new Range < Token > ( partitioner . getToken ( jobKeyRange . start _ key ) , <nl> - partitioner . getToken ( jobKeyRange . end _ key ) , <nl> - partitioner ) ; <nl> + jobRange = new Range < > ( partitioner . getToken ( jobKeyRange . start _ key ) , <nl> + partitioner . getToken ( jobKeyRange . end _ key ) , <nl> + partitioner ) ; <nl> + } <nl> + else if ( jobKeyRange . start _ token ! = null ) <nl> + { <nl> + jobRange = new Range < > ( partitioner . getTokenFactory ( ) . fromString ( jobKeyRange . start _ token ) , <nl> + partitioner . getTokenFactory ( ) . fromString ( jobKeyRange . end _ token ) , <nl> + partitioner ) ; <nl> + } <nl> + else <nl> + { <nl> + logger . warn ( " ignoring jobKeyRange specified without start _ key or start _ token " ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e233ba0 . . e630d23 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 53 , 6 + 53 , 7 @ @ <nl> * Track max / min column names in sstables to be able to optimize slice <nl> queries ( CASSANDRA - 5514 ) <nl> * Binary protocol : allow batching already prepared statements ( CASSANDRA - 4693 ) <nl> + * Allow preparing timestamp , ttl and limit in CQL3 queries ( CASSANDRA - 4450 ) <nl> <nl> 1 . 2 . 6 <nl> * ( Hadoop ) Fix InputKeyRange in CFIF ( CASSANDRA - 5536 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Attributes . java b / src / java / org / apache / cassandra / cql3 / Attributes . java <nl> index 62f98b2 . . 511f34e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Attributes . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / Attributes . java <nl> @ @ - 17 , 7 + 17 , 13 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 ; <nl> <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . List ; <nl> + <nl> import org . apache . cassandra . db . ExpiringColumn ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . marshal . LongType ; <nl> + import org . apache . cassandra . db . marshal . MarshalException ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> <nl> / * * <nl> @ @ - 26 , 15 + 32 , 107 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> * / <nl> public class Attributes <nl> { <nl> - public Long timestamp ; <nl> - public int timeToLive ; <nl> + private final Term timestamp ; <nl> + private final Term timeToLive ; <nl> + <nl> + public static Attributes none ( ) <nl> + { <nl> + return new Attributes ( null , null ) ; <nl> + } <nl> + <nl> + private Attributes ( Term timestamp , Term timeToLive ) <nl> + { <nl> + this . timestamp = timestamp ; <nl> + this . timeToLive = timeToLive ; <nl> + } <nl> + <nl> + public boolean isTimestampSet ( ) <nl> + { <nl> + return timestamp ! = null ; <nl> + } <nl> + <nl> + public boolean isTimeToLiveSet ( ) <nl> + { <nl> + return timeToLive ! = null ; <nl> + } <nl> + <nl> + public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException <nl> + { <nl> + if ( timestamp = = null ) <nl> + return now ; <nl> + <nl> + ByteBuffer tval = timestamp . bindAndGet ( variables ) ; <nl> + if ( tval = = null ) <nl> + throw new InvalidRequestException ( " Invalid null value of timestamp " ) ; <nl> <nl> - public void validate ( ) throws InvalidRequestException <nl> + try <nl> + { <nl> + LongType . instance . validate ( tval ) ; <nl> + } <nl> + catch ( MarshalException e ) <nl> + { <nl> + throw new InvalidRequestException ( " Invalid timestamp value " ) ; <nl> + } <nl> + <nl> + return LongType . instance . compose ( tval ) ; <nl> + } <nl> + <nl> + public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> - if ( timeToLive < 0 ) <nl> + if ( timeToLive = = null ) <nl> + return 0 ; <nl> + <nl> + ByteBuffer tval = timeToLive . bindAndGet ( variables ) ; <nl> + if ( tval = = null ) <nl> + throw new InvalidRequestException ( " Invalid null value of TTL " ) ; <nl> + <nl> + try <nl> + { <nl> + Int32Type . instance . validate ( tval ) ; <nl> + } <nl> + catch ( MarshalException e ) <nl> + { <nl> + throw new InvalidRequestException ( " Invalid timestamp value " ) ; <nl> + } <nl> + <nl> + int ttl = Int32Type . instance . compose ( tval ) ; <nl> + if ( ttl < 0 ) <nl> throw new InvalidRequestException ( " A TTL must be greater or equal to 0 " ) ; <nl> <nl> - if ( timeToLive > ExpiringColumn . MAX _ TTL ) <nl> - throw new InvalidRequestException ( String . format ( " ttl is too large . requested ( % d ) maximum ( % d ) " , timeToLive , ExpiringColumn . MAX _ TTL ) ) ; <nl> + if ( ttl > ExpiringColumn . MAX _ TTL ) <nl> + throw new InvalidRequestException ( String . format ( " ttl is too large . requested ( % d ) maximum ( % d ) " , ttl , ExpiringColumn . MAX _ TTL ) ) ; <nl> + <nl> + return ttl ; <nl> + } <nl> + <nl> + public void collectMarkerSpecification ( ColumnSpecification [ ] boundNames ) <nl> + { <nl> + if ( timestamp ! = null ) <nl> + timestamp . collectMarkerSpecification ( boundNames ) ; <nl> + if ( timeToLive ! = null ) <nl> + timeToLive . collectMarkerSpecification ( boundNames ) ; <nl> + } <nl> + <nl> + public static class Raw <nl> + { <nl> + public Term . Raw timestamp ; <nl> + public Term . Raw timeToLive ; <nl> + <nl> + public Attributes prepare ( String ksName , String cfName ) throws InvalidRequestException <nl> + { <nl> + Term ts = timestamp = = null ? null : timestamp . prepare ( timestampReceiver ( ksName , cfName ) ) ; <nl> + Term ttl = timeToLive = = null ? null : timeToLive . prepare ( timeToLiveReceiver ( ksName , cfName ) ) ; <nl> + return new Attributes ( ts , ttl ) ; <nl> + } <nl> + <nl> + private ColumnSpecification timestampReceiver ( String ksName , String cfName ) <nl> + { <nl> + return new ColumnSpecification ( ksName , cfName , new ColumnIdentifier ( " [ timestamp ] " , true ) , LongType . instance ) ; <nl> + } <nl> + <nl> + private ColumnSpecification timeToLiveReceiver ( String ksName , String cfName ) <nl> + { <nl> + return new ColumnSpecification ( ksName , cfName , new ColumnIdentifier ( " [ ttl ] " , true ) , Int32Type . instance ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index 8d31de9 . . 913f6ea 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 212 , 7 + 212 , 7 @ @ selectStatement returns [ SelectStatement . RawStatement expr ] <nl> @ init { <nl> boolean isCount = false ; <nl> ColumnIdentifier countAlias = null ; <nl> - int limit = Integer . MAX _ VALUE ; <nl> + Term . Raw limit = null ; <nl> Map < ColumnIdentifier , Boolean > orderings = new LinkedHashMap < ColumnIdentifier , Boolean > ( ) ; <nl> boolean allowFiltering = false ; <nl> } <nl> @ @ - 221 , 15 + 221 , 14 @ @ selectStatement returns [ SelectStatement . RawStatement expr ] <nl> K _ FROM cf = columnFamilyName <nl> ( K _ WHERE wclause = whereClause ) ? <nl> ( K _ ORDER K _ BY orderByClause [ orderings ] ( ' , ' orderByClause [ orderings ] ) * ) ? <nl> - ( K _ LIMIT rows = INTEGER { limit = Integer . parseInt ( $ rows . text ) ; } ) ? <nl> + ( K _ LIMIT rows = intValue { limit = rows ; } ) ? <nl> ( K _ ALLOW K _ FILTERING { allowFiltering = true ; } ) ? <nl> { <nl> - SelectStatement . Parameters params = new SelectStatement . Parameters ( limit , <nl> - orderings , <nl> + SelectStatement . Parameters params = new SelectStatement . Parameters ( orderings , <nl> isCount , <nl> countAlias , <nl> allowFiltering ) ; <nl> - $ expr = new SelectStatement . RawStatement ( cf , params , sclause , wclause ) ; <nl> + $ expr = new SelectStatement . RawStatement ( cf , params , sclause , wclause , limit ) ; <nl> } <nl> ; <nl> <nl> @ @ - 283 , 7 + 282 , 7 @ @ orderByClause [ Map < ColumnIdentifier , Boolean > orderings ] <nl> * / <nl> insertStatement returns [ UpdateStatement . ParsedInsert expr ] <nl> @ init { <nl> - Attributes attrs = new Attributes ( ) ; <nl> + Attributes . Raw attrs = new Attributes . Raw ( ) ; <nl> List < ColumnIdentifier > columnNames = new ArrayList < ColumnIdentifier > ( ) ; <nl> List < Term . Raw > values = new ArrayList < Term . Raw > ( ) ; <nl> } <nl> @ @ - 297 , 21 + 296 , 21 @ @ insertStatement returns [ UpdateStatement . ParsedInsert expr ] <nl> } <nl> ; <nl> <nl> - usingClause [ Attributes attrs ] <nl> + usingClause [ Attributes . Raw attrs ] <nl> : K _ USING usingClauseObjective [ attrs ] ( K _ AND ? usingClauseObjective [ attrs ] ) * <nl> ; <nl> <nl> - usingClauseDelete [ Attributes attrs ] <nl> + usingClauseDelete [ Attributes . Raw attrs ] <nl> : K _ USING usingClauseDeleteObjective [ attrs ] ( K _ AND ? usingClauseDeleteObjective [ attrs ] ) * <nl> ; <nl> <nl> - usingClauseDeleteObjective [ Attributes attrs ] <nl> - : K _ TIMESTAMP ts = INTEGER { attrs . timestamp = Long . valueOf ( $ ts . text ) ; } <nl> + usingClauseDeleteObjective [ Attributes . Raw attrs ] <nl> + : K _ TIMESTAMP ts = intValue { attrs . timestamp = ts ; } <nl> ; <nl> <nl> - usingClauseObjective [ Attributes attrs ] <nl> + usingClauseObjective [ Attributes . Raw attrs ] <nl> : usingClauseDeleteObjective [ attrs ] <nl> - | K _ TTL t = INTEGER { attrs . timeToLive = Integer . valueOf ( $ t . text ) ; } <nl> + | K _ TTL t = intValue { attrs . timeToLive = t ; } <nl> ; <nl> <nl> / * * <nl> @ @ - 322 , 7 + 321 , 7 @ @ usingClauseObjective [ Attributes attrs ] <nl> * / <nl> updateStatement returns [ UpdateStatement . ParsedUpdate expr ] <nl> @ init { <nl> - Attributes attrs = new Attributes ( ) ; <nl> + Attributes . Raw attrs = new Attributes . Raw ( ) ; <nl> List < Pair < ColumnIdentifier , Operation . RawUpdate > > operations = new ArrayList < Pair < ColumnIdentifier , Operation . RawUpdate > > ( ) ; <nl> boolean ifNotExists = false ; <nl> } <nl> @ @ - 354 , 7 + 353 , 7 @ @ updateCondition returns [ List < Pair < ColumnIdentifier , Operation . RawUpdate > > condi <nl> * / <nl> deleteStatement returns [ DeleteStatement . Parsed expr ] <nl> @ init { <nl> - Attributes attrs = new Attributes ( ) ; <nl> + Attributes . Raw attrs = new Attributes . Raw ( ) ; <nl> List < Operation . RawDeletion > columnDeletions = Collections . emptyList ( ) ; <nl> } <nl> : K _ DELETE ( dels = deleteSelection { columnDeletions = dels ; } ) ? <nl> @ @ - 410 , 7 + 409 , 7 @ @ batchStatement returns [ BatchStatement . Parsed expr ] <nl> @ init { <nl> BatchStatement . Type type = BatchStatement . Type . LOGGED ; <nl> List < ModificationStatement . Parsed > statements = new ArrayList < ModificationStatement . Parsed > ( ) ; <nl> - Attributes attrs = new Attributes ( ) ; <nl> + Attributes . Raw attrs = new Attributes . Raw ( ) ; <nl> } <nl> : K _ BEGIN <nl> ( K _ UNLOGGED { type = BatchStatement . Type . UNLOGGED ; } | K _ COUNTER { type = BatchStatement . Type . COUNTER ; } ) ? <nl> @ @ - 738 , 6 + 737 , 12 @ @ value returns [ Term . Raw value ] <nl> | QMARK { $ value = new AbstractMarker . Raw ( + + currentBindMarkerIdx ) ; } <nl> ; <nl> <nl> + intValue returns [ Term . Raw value ] <nl> + : <nl> + | t = INTEGER { $ value = Constants . Literal . integer ( $ t . text ) ; } <nl> + | QMARK { $ value = new AbstractMarker . Raw ( + + currentBindMarkerIdx ) ; } <nl> + ; <nl> + <nl> functionName returns [ String s ] <nl> : f = IDENT { $ s = $ f . text ; } <nl> | u = unreserved _ function _ keyword { $ s = u ; } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> index d6d0e16 . . 777c80f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> @ @ - 76 , 23 + 76 , 16 @ @ public class BatchStatement implements CQLStatement <nl> <nl> public void validate ( ClientState state ) throws InvalidRequestException <nl> { <nl> - if ( attrs . timeToLive ! = 0 ) <nl> + if ( attrs . isTimeToLiveSet ( ) ) <nl> throw new InvalidRequestException ( " Global TTL on the BATCH statement is not supported . " ) ; <nl> <nl> for ( ModificationStatement statement : statements ) <nl> { <nl> - statement . validate ( state ) ; <nl> - <nl> - if ( attrs . timestamp ! = null & & statement . isSetTimestamp ( ) ) <nl> + if ( attrs . isTimestampSet ( ) & & statement . isTimestampSet ( ) ) <nl> throw new InvalidRequestException ( " Timestamp must be set either on BATCH or individual statements " ) ; <nl> } <nl> } <nl> <nl> - public long getTimestamp ( long now ) <nl> - { <nl> - return attrs . timestamp = = null ? now : attrs . timestamp ; <nl> - } <nl> - <nl> private Collection < ? extends IMutation > getMutations ( List < ByteBuffer > variables , boolean local , ConsistencyLevel cl , long now ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> @ @ - 125 , 7 + 118 , 7 @ @ public class BatchStatement implements CQLStatement <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> / / Group mutation together , otherwise they won ' t get applied atomically <nl> - for ( IMutation m : statement . getMutations ( variables , local , cl , getTimestamp ( now ) , true ) ) <nl> + for ( IMutation m : statement . getMutations ( variables , local , cl , attrs . getTimestamp ( now , variables ) , true ) ) <nl> { <nl> Pair < String , ByteBuffer > key = Pair . create ( m . getTable ( ) , m . key ( ) ) ; <nl> IMutation existing = mutations . get ( key ) ; <nl> @ @ - 179 , 10 + 172 , 10 @ @ public class BatchStatement implements CQLStatement <nl> public static class Parsed extends CFStatement <nl> { <nl> private final Type type ; <nl> - private final Attributes attrs ; <nl> + private final Attributes . Raw attrs ; <nl> private final List < ModificationStatement . Parsed > parsedStatements ; <nl> <nl> - public Parsed ( Type type , Attributes attrs , List < ModificationStatement . Parsed > parsedStatements ) <nl> + public Parsed ( Type type , Attributes . Raw attrs , List < ModificationStatement . Parsed > parsedStatements ) <nl> { <nl> super ( null ) ; <nl> this . type = type ; <nl> @ @ - 217 , 7 + 210 , 10 @ @ public class BatchStatement implements CQLStatement <nl> statements . add ( stmt ) ; <nl> } <nl> <nl> - return new ParsedStatement . Prepared ( new BatchStatement ( getBoundsTerms ( ) , type , statements , attrs ) , Arrays . < ColumnSpecification > asList ( boundNames ) ) ; <nl> + Attributes prepAttrs = attrs . prepare ( " [ batch ] " , " [ batch ] " ) ; <nl> + prepAttrs . collectMarkerSpecification ( boundNames ) ; <nl> + <nl> + return new ParsedStatement . Prepared ( new BatchStatement ( getBoundsTerms ( ) , type , statements , prepAttrs ) , Arrays . < ColumnSpecification > asList ( boundNames ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> index db3c41c . . 54a1034 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java <nl> @ @ - 93 , 7 + 93 , 7 @ @ public class DeleteStatement extends ModificationStatement <nl> private final List < Relation > whereClause ; <nl> <nl> public Parsed ( CFName name , <nl> - Attributes attrs , <nl> + Attributes . Raw attrs , <nl> List < Operation . RawDeletion > deletions , <nl> List < Relation > whereClause , <nl> List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions ) <nl> @ @ - 103 , 7 + 103 , 7 @ @ public class DeleteStatement extends ModificationStatement <nl> this . whereClause = whereClause ; <nl> } <nl> <nl> - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException <nl> + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException <nl> { <nl> DeleteStatement stmt = new DeleteStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index 7766f94 . . f6b7140 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 85 , 19 + 85 , 19 @ @ public abstract class ModificationStatement implements CQLStatement <nl> return cfm . getDefaultValidator ( ) . isCommutative ( ) ; <nl> } <nl> <nl> - public int getTimeToLive ( ) <nl> + public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> - return attrs . timeToLive ; <nl> + return attrs . getTimestamp ( now , variables ) ; <nl> } <nl> <nl> - public long getTimestamp ( long now ) <nl> + public boolean isTimestampSet ( ) <nl> { <nl> - return attrs . timestamp = = null ? now : attrs . timestamp ; <nl> + return attrs . isTimestampSet ( ) ; <nl> } <nl> <nl> - public boolean isSetTimestamp ( ) <nl> + public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> - return attrs . timestamp ! = null ; <nl> + return attrs . getTimeToLive ( variables ) ; <nl> } <nl> <nl> public void checkAccess ( ClientState state ) throws InvalidRequestException , UnauthorizedException <nl> @ @ - 107 , 7 + 107 , 6 @ @ public abstract class ModificationStatement implements CQLStatement <nl> <nl> public void validate ( ClientState state ) throws InvalidRequestException <nl> { <nl> - attrs . validate ( ) ; <nl> } <nl> <nl> public void addOperation ( Operation op ) <nl> @ @ - 363 , 7 + 362 , 7 @ @ public abstract class ModificationStatement implements CQLStatement <nl> throw new InvalidRequestException ( " IN on the partition key is not supported with conditional updates " ) ; <nl> <nl> ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder ( variables ) ; <nl> - UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( queryState . getTimestamp ( ) ) , getTimeToLive ( ) , null ) ; <nl> + UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( queryState . getTimestamp ( ) , variables ) , getTimeToLive ( variables ) , null ) ; <nl> <nl> ByteBuffer key = keys . get ( 0 ) ; <nl> ThriftValidation . validateKey ( cfm , key ) ; <nl> @ @ - 407 , 7 + 406 , 7 @ @ public abstract class ModificationStatement implements CQLStatement <nl> <nl> / / Some lists operation requires reading <nl> Map < ByteBuffer , ColumnGroupMap > rows = readRequiredRows ( keys , clusteringPrefix , local , cl ) ; <nl> - UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( now ) , getTimeToLive ( ) , rows ) ; <nl> + UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( now , variables ) , getTimeToLive ( variables ) , rows ) ; <nl> <nl> Collection < IMutation > mutations = new ArrayList < IMutation > ( ) ; <nl> for ( ByteBuffer key : keys ) <nl> @ @ - 449 , 11 + 448 , 11 @ @ public abstract class ModificationStatement implements CQLStatement <nl> <nl> public static abstract class Parsed extends CFStatement <nl> { <nl> - protected final Attributes attrs ; <nl> + protected final Attributes . Raw attrs ; <nl> private final List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions ; <nl> private final boolean ifNotExists ; <nl> <nl> - protected Parsed ( CFName name , Attributes attrs , List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , boolean ifNotExists ) <nl> + protected Parsed ( CFName name , Attributes . Raw attrs , List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , boolean ifNotExists ) <nl> { <nl> super ( name ) ; <nl> this . attrs = attrs ; <nl> @ @ - 473 , 7 + 472 , 10 @ @ public abstract class ModificationStatement implements CQLStatement <nl> CFMetaData metadata = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; <nl> CFDefinition cfDef = metadata . getCfDef ( ) ; <nl> <nl> - ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; <nl> + Attributes preparedAttributes = attrs . prepare ( keyspace ( ) , columnFamily ( ) ) ; <nl> + preparedAttributes . collectMarkerSpecification ( boundNames ) ; <nl> + <nl> + ModificationStatement stmt = prepareInternal ( cfDef , boundNames , preparedAttributes ) ; <nl> <nl> if ( ifNotExists | | ( conditions ! = null & & ! conditions . isEmpty ( ) ) ) <nl> { <nl> @ @ - 528 , 6 + 530 , 6 @ @ public abstract class ModificationStatement implements CQLStatement <nl> return stmt ; <nl> } <nl> <nl> - protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException ; <nl> + protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index d45b730 . . 9630771 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 58 , 6 + 58 , 7 @ @ public class SelectStatement implements CQLStatement <nl> public final CFDefinition cfDef ; <nl> public final Parameters parameters ; <nl> private final Selection selection ; <nl> + private final Term limit ; <nl> <nl> private final Restriction [ ] keyRestrictions ; <nl> private final Restriction [ ] columnRestrictions ; <nl> @ @ - 92 , 7 + 93 , 7 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> <nl> - public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters , Selection selection ) <nl> + public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters , Selection selection , Term limit ) <nl> { <nl> this . cfDef = cfDef ; <nl> this . boundTerms = boundTerms ; <nl> @ @ - 100 , 6 + 101 , 7 @ @ public class SelectStatement implements CQLStatement <nl> this . keyRestrictions = new Restriction [ cfDef . keys . size ( ) ] ; <nl> this . columnRestrictions = new Restriction [ cfDef . columns . size ( ) ] ; <nl> this . parameters = parameters ; <nl> + this . limit = limit ; <nl> } <nl> <nl> public int getBoundsTerms ( ) <nl> @ @ - 124 , 17 + 126 , 18 @ @ public class SelectStatement implements CQLStatement <nl> <nl> cl . validateForRead ( keyspace ( ) ) ; <nl> <nl> + int limit = getLimit ( variables ) ; <nl> List < Row > rows = isKeyRange | | usesSecondaryIndexing <nl> - ? StorageProxy . getRangeSlice ( getRangeCommand ( variables ) , cl ) <nl> - : StorageProxy . read ( getSliceCommands ( variables ) , cl ) ; <nl> + ? StorageProxy . getRangeSlice ( getRangeCommand ( variables , limit ) , cl ) <nl> + : StorageProxy . read ( getSliceCommands ( variables , limit ) , cl ) ; <nl> <nl> - return processResults ( rows , variables ) ; <nl> + return processResults ( rows , variables , limit ) ; <nl> } <nl> <nl> - private ResultMessage . Rows processResults ( List < Row > rows , List < ByteBuffer > variables ) throws RequestValidationException <nl> + private ResultMessage . Rows processResults ( List < Row > rows , List < ByteBuffer > variables , int limit ) throws RequestValidationException <nl> { <nl> / / Even for count , we need to process the result as it ' ll group some column together in sparse column families <nl> - ResultSet rset = process ( rows , variables ) ; <nl> + ResultSet rset = process ( rows , variables , limit ) ; <nl> rset = parameters . isCount ? rset . makeCountResult ( parameters . countAlias ) : rset ; <nl> return new ResultMessage . Rows ( rset ) ; <nl> } <nl> @ @ - 150 , 17 + 153 , 19 @ @ public class SelectStatement implements CQLStatement <nl> <nl> public ResultMessage . Rows executeInternal ( QueryState state ) throws RequestExecutionException , RequestValidationException <nl> { <nl> + List < ByteBuffer > variables = Collections . < ByteBuffer > emptyList ( ) ; <nl> + int limit = getLimit ( variables ) ; <nl> List < Row > rows = isKeyRange | | usesSecondaryIndexing <nl> - ? RangeSliceVerbHandler . executeLocally ( getRangeCommand ( Collections . < ByteBuffer > emptyList ( ) ) ) <nl> - : readLocally ( keyspace ( ) , getSliceCommands ( Collections . < ByteBuffer > emptyList ( ) ) ) ; <nl> + ? RangeSliceVerbHandler . executeLocally ( getRangeCommand ( variables , limit ) ) <nl> + : readLocally ( keyspace ( ) , getSliceCommands ( variables , limit ) ) ; <nl> <nl> - return processResults ( rows , Collections . < ByteBuffer > emptyList ( ) ) ; <nl> + return processResults ( rows , variables , limit ) ; <nl> } <nl> <nl> public ResultSet process ( List < Row > rows ) throws InvalidRequestException <nl> { <nl> assert ! parameters . isCount ; / / not yet needed <nl> - return process ( rows , Collections . < ByteBuffer > emptyList ( ) ) ; <nl> + return process ( rows , Collections . < ByteBuffer > emptyList ( ) , getLimit ( Collections . < ByteBuffer > emptyList ( ) ) ) ; <nl> } <nl> <nl> public String keyspace ( ) <nl> @ @ - 173 , 12 + 178 , 12 @ @ public class SelectStatement implements CQLStatement <nl> return cfDef . cfm . cfName ; <nl> } <nl> <nl> - private List < ReadCommand > getSliceCommands ( List < ByteBuffer > variables ) throws RequestValidationException <nl> + private List < ReadCommand > getSliceCommands ( List < ByteBuffer > variables , int limit ) throws RequestValidationException <nl> { <nl> Collection < ByteBuffer > keys = getKeys ( variables ) ; <nl> List < ReadCommand > commands = new ArrayList < ReadCommand > ( keys . size ( ) ) ; <nl> <nl> - IDiskAtomFilter filter = makeFilter ( variables ) ; <nl> + IDiskAtomFilter filter = makeFilter ( variables , limit ) ; <nl> / / Note that we use the total limit for every key , which is potentially inefficient . <nl> / / However , IN + LIMIT is not a very sensible choice . <nl> for ( ByteBuffer key : keys ) <nl> @ @ - 192 , 9 + 197 , 9 @ @ public class SelectStatement implements CQLStatement <nl> return commands ; <nl> } <nl> <nl> - private RangeSliceCommand getRangeCommand ( List < ByteBuffer > variables ) throws RequestValidationException <nl> + private RangeSliceCommand getRangeCommand ( List < ByteBuffer > variables , int limit ) throws RequestValidationException <nl> { <nl> - IDiskAtomFilter filter = makeFilter ( variables ) ; <nl> + IDiskAtomFilter filter = makeFilter ( variables , limit ) ; <nl> List < IndexExpression > expressions = getIndexExpressions ( variables ) ; <nl> / / The LIMIT provided by the user is the number of CQL row he wants returned . <nl> / / We want to have getRangeSlice to count the number of columns , not the number of keys . <nl> @ @ - 203 , 7 + 208 , 7 @ @ public class SelectStatement implements CQLStatement <nl> filter , <nl> getKeyBounds ( variables ) , <nl> expressions , <nl> - getLimit ( ) , <nl> + limit , <nl> true , <nl> false ) ; <nl> } <nl> @ @ - 252 , 7 + 257 , 7 @ @ public class SelectStatement implements CQLStatement <nl> return bounds ; <nl> } <nl> <nl> - private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables ) <nl> + private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables , int limit ) <nl> throws InvalidRequestException <nl> { <nl> if ( isColumnRange ( ) ) <nl> @ @ - 266 , 7 + 271 , 7 @ @ public class SelectStatement implements CQLStatement <nl> getRequestedBound ( Bound . END , variables ) ) ; <nl> SliceQueryFilter filter = new SliceQueryFilter ( new ColumnSlice [ ] { slice } , <nl> isReversed , <nl> - getLimit ( ) , <nl> + limit , <nl> toGroup ) ; <nl> QueryProcessor . validateSliceFilter ( cfDef . cfm , filter ) ; <nl> return filter ; <nl> @ @ - 279 , 13 + 284 , 35 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> <nl> - private int getLimit ( ) <nl> + private int getLimit ( List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> + int l = Integer . MAX _ VALUE ; <nl> + if ( limit ! = null ) <nl> + { <nl> + ByteBuffer b = limit . bindAndGet ( variables ) ; <nl> + if ( b = = null ) <nl> + throw new InvalidRequestException ( " Invalid null value of limit " ) ; <nl> + <nl> + try <nl> + { <nl> + Int32Type . instance . validate ( b ) ; <nl> + l = Int32Type . instance . compose ( b ) ; <nl> + } <nl> + catch ( MarshalException e ) <nl> + { <nl> + throw new InvalidRequestException ( " Invalid limit value " ) ; <nl> + } <nl> + } <nl> + <nl> + if ( l < = 0 ) <nl> + throw new InvalidRequestException ( " LIMIT must be strictly positive " ) ; <nl> + <nl> / / Internally , we don ' t support exclusive bounds for slices . Instead , <nl> / / we query one more element if necessary and exclude <nl> - return sliceRestriction ! = null & & ! sliceRestriction . isInclusive ( Bound . START ) & & parameters . limit ! = Integer . MAX _ VALUE <nl> - ? parameters . limit + 1 <nl> - : parameters . limit ; <nl> + if ( sliceRestriction ! = null & & ! sliceRestriction . isInclusive ( Bound . START ) & & l ! = Integer . MAX _ VALUE ) <nl> + l + = 1 ; <nl> + <nl> + return l ; <nl> } <nl> <nl> private Collection < ByteBuffer > getKeys ( final List < ByteBuffer > variables ) throws InvalidRequestException <nl> @ @ - 634 , 7 + 661 , 7 @ @ public class SelectStatement implements CQLStatement <nl> } ; <nl> } <nl> <nl> - private ResultSet process ( List < Row > rows , List < ByteBuffer > variables ) throws InvalidRequestException <nl> + private ResultSet process ( List < Row > rows , List < ByteBuffer > variables , int limit ) throws InvalidRequestException <nl> { <nl> Selection . ResultSetBuilder result = selection . resultSetBuilder ( ) ; <nl> for ( org . apache . cassandra . db . Row row : rows ) <nl> @ @ - 740 , 7 + 767 , 7 @ @ public class SelectStatement implements CQLStatement <nl> cqlRows . reverse ( ) ; <nl> <nl> / / Trim result if needed to respect the limit <nl> - cqlRows . trim ( parameters . limit ) ; <nl> + cqlRows . trim ( limit ) ; <nl> return cqlRows ; <nl> } <nl> <nl> @ @ - 839 , 22 + 866 , 21 @ @ public class SelectStatement implements CQLStatement <nl> private final Parameters parameters ; <nl> private final List < RawSelector > selectClause ; <nl> private final List < Relation > whereClause ; <nl> + private final Term . Raw limit ; <nl> <nl> - public RawStatement ( CFName cfName , Parameters parameters , List < RawSelector > selectClause , List < Relation > whereClause ) <nl> + public RawStatement ( CFName cfName , Parameters parameters , List < RawSelector > selectClause , List < Relation > whereClause , Term . Raw limit ) <nl> { <nl> super ( cfName ) ; <nl> this . parameters = parameters ; <nl> this . selectClause = selectClause ; <nl> this . whereClause = whereClause = = null ? Collections . < Relation > emptyList ( ) : whereClause ; <nl> + this . limit = limit ; <nl> } <nl> <nl> public ParsedStatement . Prepared prepare ( ) throws InvalidRequestException <nl> { <nl> CFMetaData cfm = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; <nl> <nl> - if ( parameters . limit < = 0 ) <nl> - throw new InvalidRequestException ( " LIMIT must be strictly positive " ) ; <nl> - <nl> CFDefinition cfDef = cfm . getCfDef ( ) ; <nl> <nl> ColumnSpecification [ ] names = new ColumnSpecification [ getBoundsTerms ( ) ] ; <nl> @ @ - 868 , 7 + 894 , 14 @ @ public class SelectStatement implements CQLStatement <nl> ? Selection . wildcard ( cfDef ) <nl> : Selection . fromSelectors ( cfDef , selectClause ) ; <nl> <nl> - SelectStatement stmt = new SelectStatement ( cfDef , getBoundsTerms ( ) , parameters , selection ) ; <nl> + Term prepLimit = null ; <nl> + if ( limit ! = null ) <nl> + { <nl> + prepLimit = limit . prepare ( limitReceiver ( ) ) ; <nl> + prepLimit . collectMarkerSpecification ( names ) ; <nl> + } <nl> + <nl> + SelectStatement stmt = new SelectStatement ( cfDef , getBoundsTerms ( ) , parameters , selection , prepLimit ) ; <nl> <nl> / * <nl> * WHERE clause . For a given entity , rules are : <nl> @ @ - 1209 , 6 + 1242 , 11 @ @ public class SelectStatement implements CQLStatement <nl> } ) ; <nl> } <nl> <nl> + private ColumnSpecification limitReceiver ( ) <nl> + { <nl> + return new ColumnSpecification ( keyspace ( ) , columnFamily ( ) , new ColumnIdentifier ( " [ limit ] " , true ) , Int32Type . instance ) ; <nl> + } <nl> + <nl> Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel , ColumnSpecification [ ] boundNames ) throws InvalidRequestException <nl> { <nl> ColumnSpecification receiver = name ; <nl> @ @ - 1265 , 12 + 1303 , 11 @ @ public class SelectStatement implements CQLStatement <nl> @ Override <nl> public String toString ( ) <nl> { <nl> - return String . format ( " SelectRawStatement [ name = % s , selectClause = % s , whereClause = % s , isCount = % s , limit = % s ] " , <nl> + return String . format ( " SelectRawStatement [ name = % s , selectClause = % s , whereClause = % s , isCount = % s ] " , <nl> cfName , <nl> selectClause , <nl> whereClause , <nl> - parameters . isCount , <nl> - parameters . limit ) ; <nl> + parameters . isCount ) ; <nl> } <nl> } <nl> <nl> @ @ - 1409 , 15 + 1446 , 13 @ @ public class SelectStatement implements CQLStatement <nl> <nl> public static class Parameters <nl> { <nl> - private final int limit ; <nl> private final Map < ColumnIdentifier , Boolean > orderings ; <nl> private final boolean isCount ; <nl> private final ColumnIdentifier countAlias ; <nl> private final boolean allowFiltering ; <nl> <nl> - public Parameters ( int limit , Map < ColumnIdentifier , Boolean > orderings , boolean isCount , ColumnIdentifier countAlias , boolean allowFiltering ) <nl> + public Parameters ( Map < ColumnIdentifier , Boolean > orderings , boolean isCount , ColumnIdentifier countAlias , boolean allowFiltering ) <nl> { <nl> - this . limit = limit ; <nl> this . orderings = orderings ; <nl> this . isCount = isCount ; <nl> this . countAlias = countAlias ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java b / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java <nl> index bc05dd6 . . cff4105 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java <nl> @ @ - 115 , 14 + 115 , 14 @ @ public class UpdateStatement extends ModificationStatement <nl> * @ param columnValues list of column values ( corresponds to names ) <nl> * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) <nl> * / <nl> - public ParsedInsert ( CFName name , Attributes attrs , List < ColumnIdentifier > columnNames , List < Term . Raw > columnValues ) <nl> + public ParsedInsert ( CFName name , Attributes . Raw attrs , List < ColumnIdentifier > columnNames , List < Term . Raw > columnValues ) <nl> { <nl> super ( name , attrs , Collections . < Pair < ColumnIdentifier , Operation . RawUpdate > > emptyList ( ) , false ) ; <nl> this . columnNames = columnNames ; <nl> this . columnValues = columnValues ; <nl> } <nl> <nl> - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException <nl> + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException <nl> { <nl> UpdateStatement stmt = new UpdateStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; <nl> <nl> @ @ - 182 , 7 + 182 , 7 @ @ public class UpdateStatement extends ModificationStatement <nl> * @ param whereClause the where clause <nl> * / <nl> public ParsedUpdate ( CFName name , <nl> - Attributes attrs , <nl> + Attributes . Raw attrs , <nl> List < Pair < ColumnIdentifier , Operation . RawUpdate > > updates , <nl> List < Relation > whereClause , <nl> List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , <nl> @ @ - 193 , 7 + 193 , 7 @ @ public class UpdateStatement extends ModificationStatement <nl> this . whereClause = whereClause ; <nl> } <nl> <nl> - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException <nl> + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException <nl> { <nl> UpdateStatement stmt = new UpdateStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> index 3bec918 . . ed8aaaf 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> @ @ - 221 , 7 + 221 , 7 @ @ public class BatchMessage extends Message . Request <nl> <nl> / / Note : It ' s ok at this point to pass a bogus value for the number of bound terms in the BatchState ctor <nl> / / ( and no value would be really correct , so we prefer passing a clearly wrong one ) . <nl> - BatchStatement batch = new BatchStatement ( - 1 , type , statements , new Attributes ( ) ) ; <nl> + BatchStatement batch = new BatchStatement ( - 1 , type , statements , Attributes . none ( ) ) ; <nl> Message . Response response = QueryProcessor . processBatch ( batch , consistency , state , values ) ; <nl> <nl> if ( tracingId ! = null )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 65f4f3b . . 477afd9 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 7 
 + * ( Hadoop ) Allow manually specifying start / end tokens in CFIF ( CASSANDRA - 6436 ) 
 * Fix NPE in MeteredFlusher ( CASSANDRA - 6820 ) 
 * Fix race processing range scan responses ( CASSANDRA - 6820 ) 
 * Allow deleting snapshots from dropped keyspaces ( CASSANDRA - 6821 ) 
 diff - - git a / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java b / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java 
 index ba79eee . . 03b1576 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java 
 + + + b / src / java / org / apache / cassandra / hadoop / AbstractColumnFamilyInputFormat . java 
 @ @ - 141 , 11 + 141 , 7 @ @ public abstract class AbstractColumnFamilyInputFormat < K , Y > extends InputFormat < 
 Range < Token > jobRange = null ; 
 if ( jobKeyRange ! = null ) 
 { 
 - if ( jobKeyRange . start _ key = = null ) 
 - { 
 - logger . warn ( " ignoring jobKeyRange specified without start _ key " ) ; 
 - } 
 - else 
 + if ( jobKeyRange . start _ key ! = null ) 
 { 
 if ( ! partitioner . preservesOrder ( ) ) 
 throw new UnsupportedOperationException ( " KeyRange based on keys can only be used with a order preserving paritioner " ) ; 
 @ @ - 153 , 9 + 149 , 19 @ @ public abstract class AbstractColumnFamilyInputFormat < K , Y > extends InputFormat < 
 throw new IllegalArgumentException ( " only start _ key supported " ) ; 
 if ( jobKeyRange . end _ token ! = null ) 
 throw new IllegalArgumentException ( " only start _ key supported " ) ; 
 - jobRange = new Range < Token > ( partitioner . getToken ( jobKeyRange . start _ key ) , 
 - partitioner . getToken ( jobKeyRange . end _ key ) , 
 - partitioner ) ; 
 + jobRange = new Range < > ( partitioner . getToken ( jobKeyRange . start _ key ) , 
 + partitioner . getToken ( jobKeyRange . end _ key ) , 
 + partitioner ) ; 
 + } 
 + else if ( jobKeyRange . start _ token ! = null ) 
 + { 
 + jobRange = new Range < > ( partitioner . getTokenFactory ( ) . fromString ( jobKeyRange . start _ token ) , 
 + partitioner . getTokenFactory ( ) . fromString ( jobKeyRange . end _ token ) , 
 + partitioner ) ; 
 + } 
 + else 
 + { 
 + logger . warn ( " ignoring jobKeyRange specified without start _ key or start _ token " ) ; 
 } 
 } 


NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e233ba0 . . e630d23 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 53 , 6 + 53 , 7 @ @ 
 * Track max / min column names in sstables to be able to optimize slice 
 queries ( CASSANDRA - 5514 ) 
 * Binary protocol : allow batching already prepared statements ( CASSANDRA - 4693 ) 
 + * Allow preparing timestamp , ttl and limit in CQL3 queries ( CASSANDRA - 4450 ) 
 
 1 . 2 . 6 
 * ( Hadoop ) Fix InputKeyRange in CFIF ( CASSANDRA - 5536 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Attributes . java b / src / java / org / apache / cassandra / cql3 / Attributes . java 
 index 62f98b2 . . 511f34e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Attributes . java 
 + + + b / src / java / org / apache / cassandra / cql3 / Attributes . java 
 @ @ - 17 , 7 + 17 , 13 @ @ 
 * / 
 package org . apache . cassandra . cql3 ; 
 
 + import java . nio . ByteBuffer ; 
 + import java . util . List ; 
 + 
 import org . apache . cassandra . db . ExpiringColumn ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . marshal . LongType ; 
 + import org . apache . cassandra . db . marshal . MarshalException ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 
 / * * 
 @ @ - 26 , 15 + 32 , 107 @ @ import org . apache . cassandra . exceptions . InvalidRequestException ; 
 * / 
 public class Attributes 
 { 
 - public Long timestamp ; 
 - public int timeToLive ; 
 + private final Term timestamp ; 
 + private final Term timeToLive ; 
 + 
 + public static Attributes none ( ) 
 + { 
 + return new Attributes ( null , null ) ; 
 + } 
 + 
 + private Attributes ( Term timestamp , Term timeToLive ) 
 + { 
 + this . timestamp = timestamp ; 
 + this . timeToLive = timeToLive ; 
 + } 
 + 
 + public boolean isTimestampSet ( ) 
 + { 
 + return timestamp ! = null ; 
 + } 
 + 
 + public boolean isTimeToLiveSet ( ) 
 + { 
 + return timeToLive ! = null ; 
 + } 
 + 
 + public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException 
 + { 
 + if ( timestamp = = null ) 
 + return now ; 
 + 
 + ByteBuffer tval = timestamp . bindAndGet ( variables ) ; 
 + if ( tval = = null ) 
 + throw new InvalidRequestException ( " Invalid null value of timestamp " ) ; 
 
 - public void validate ( ) throws InvalidRequestException 
 + try 
 + { 
 + LongType . instance . validate ( tval ) ; 
 + } 
 + catch ( MarshalException e ) 
 + { 
 + throw new InvalidRequestException ( " Invalid timestamp value " ) ; 
 + } 
 + 
 + return LongType . instance . compose ( tval ) ; 
 + } 
 + 
 + public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 - if ( timeToLive < 0 ) 
 + if ( timeToLive = = null ) 
 + return 0 ; 
 + 
 + ByteBuffer tval = timeToLive . bindAndGet ( variables ) ; 
 + if ( tval = = null ) 
 + throw new InvalidRequestException ( " Invalid null value of TTL " ) ; 
 + 
 + try 
 + { 
 + Int32Type . instance . validate ( tval ) ; 
 + } 
 + catch ( MarshalException e ) 
 + { 
 + throw new InvalidRequestException ( " Invalid timestamp value " ) ; 
 + } 
 + 
 + int ttl = Int32Type . instance . compose ( tval ) ; 
 + if ( ttl < 0 ) 
 throw new InvalidRequestException ( " A TTL must be greater or equal to 0 " ) ; 
 
 - if ( timeToLive > ExpiringColumn . MAX _ TTL ) 
 - throw new InvalidRequestException ( String . format ( " ttl is too large . requested ( % d ) maximum ( % d ) " , timeToLive , ExpiringColumn . MAX _ TTL ) ) ; 
 + if ( ttl > ExpiringColumn . MAX _ TTL ) 
 + throw new InvalidRequestException ( String . format ( " ttl is too large . requested ( % d ) maximum ( % d ) " , ttl , ExpiringColumn . MAX _ TTL ) ) ; 
 + 
 + return ttl ; 
 + } 
 + 
 + public void collectMarkerSpecification ( ColumnSpecification [ ] boundNames ) 
 + { 
 + if ( timestamp ! = null ) 
 + timestamp . collectMarkerSpecification ( boundNames ) ; 
 + if ( timeToLive ! = null ) 
 + timeToLive . collectMarkerSpecification ( boundNames ) ; 
 + } 
 + 
 + public static class Raw 
 + { 
 + public Term . Raw timestamp ; 
 + public Term . Raw timeToLive ; 
 + 
 + public Attributes prepare ( String ksName , String cfName ) throws InvalidRequestException 
 + { 
 + Term ts = timestamp = = null ? null : timestamp . prepare ( timestampReceiver ( ksName , cfName ) ) ; 
 + Term ttl = timeToLive = = null ? null : timeToLive . prepare ( timeToLiveReceiver ( ksName , cfName ) ) ; 
 + return new Attributes ( ts , ttl ) ; 
 + } 
 + 
 + private ColumnSpecification timestampReceiver ( String ksName , String cfName ) 
 + { 
 + return new ColumnSpecification ( ksName , cfName , new ColumnIdentifier ( " [ timestamp ] " , true ) , LongType . instance ) ; 
 + } 
 + 
 + private ColumnSpecification timeToLiveReceiver ( String ksName , String cfName ) 
 + { 
 + return new ColumnSpecification ( ksName , cfName , new ColumnIdentifier ( " [ ttl ] " , true ) , Int32Type . instance ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index 8d31de9 . . 913f6ea 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 212 , 7 + 212 , 7 @ @ selectStatement returns [ SelectStatement . RawStatement expr ] 
 @ init { 
 boolean isCount = false ; 
 ColumnIdentifier countAlias = null ; 
 - int limit = Integer . MAX _ VALUE ; 
 + Term . Raw limit = null ; 
 Map < ColumnIdentifier , Boolean > orderings = new LinkedHashMap < ColumnIdentifier , Boolean > ( ) ; 
 boolean allowFiltering = false ; 
 } 
 @ @ - 221 , 15 + 221 , 14 @ @ selectStatement returns [ SelectStatement . RawStatement expr ] 
 K _ FROM cf = columnFamilyName 
 ( K _ WHERE wclause = whereClause ) ? 
 ( K _ ORDER K _ BY orderByClause [ orderings ] ( ' , ' orderByClause [ orderings ] ) * ) ? 
 - ( K _ LIMIT rows = INTEGER { limit = Integer . parseInt ( $ rows . text ) ; } ) ? 
 + ( K _ LIMIT rows = intValue { limit = rows ; } ) ? 
 ( K _ ALLOW K _ FILTERING { allowFiltering = true ; } ) ? 
 { 
 - SelectStatement . Parameters params = new SelectStatement . Parameters ( limit , 
 - orderings , 
 + SelectStatement . Parameters params = new SelectStatement . Parameters ( orderings , 
 isCount , 
 countAlias , 
 allowFiltering ) ; 
 - $ expr = new SelectStatement . RawStatement ( cf , params , sclause , wclause ) ; 
 + $ expr = new SelectStatement . RawStatement ( cf , params , sclause , wclause , limit ) ; 
 } 
 ; 
 
 @ @ - 283 , 7 + 282 , 7 @ @ orderByClause [ Map < ColumnIdentifier , Boolean > orderings ] 
 * / 
 insertStatement returns [ UpdateStatement . ParsedInsert expr ] 
 @ init { 
 - Attributes attrs = new Attributes ( ) ; 
 + Attributes . Raw attrs = new Attributes . Raw ( ) ; 
 List < ColumnIdentifier > columnNames = new ArrayList < ColumnIdentifier > ( ) ; 
 List < Term . Raw > values = new ArrayList < Term . Raw > ( ) ; 
 } 
 @ @ - 297 , 21 + 296 , 21 @ @ insertStatement returns [ UpdateStatement . ParsedInsert expr ] 
 } 
 ; 
 
 - usingClause [ Attributes attrs ] 
 + usingClause [ Attributes . Raw attrs ] 
 : K _ USING usingClauseObjective [ attrs ] ( K _ AND ? usingClauseObjective [ attrs ] ) * 
 ; 
 
 - usingClauseDelete [ Attributes attrs ] 
 + usingClauseDelete [ Attributes . Raw attrs ] 
 : K _ USING usingClauseDeleteObjective [ attrs ] ( K _ AND ? usingClauseDeleteObjective [ attrs ] ) * 
 ; 
 
 - usingClauseDeleteObjective [ Attributes attrs ] 
 - : K _ TIMESTAMP ts = INTEGER { attrs . timestamp = Long . valueOf ( $ ts . text ) ; } 
 + usingClauseDeleteObjective [ Attributes . Raw attrs ] 
 + : K _ TIMESTAMP ts = intValue { attrs . timestamp = ts ; } 
 ; 
 
 - usingClauseObjective [ Attributes attrs ] 
 + usingClauseObjective [ Attributes . Raw attrs ] 
 : usingClauseDeleteObjective [ attrs ] 
 - | K _ TTL t = INTEGER { attrs . timeToLive = Integer . valueOf ( $ t . text ) ; } 
 + | K _ TTL t = intValue { attrs . timeToLive = t ; } 
 ; 
 
 / * * 
 @ @ - 322 , 7 + 321 , 7 @ @ usingClauseObjective [ Attributes attrs ] 
 * / 
 updateStatement returns [ UpdateStatement . ParsedUpdate expr ] 
 @ init { 
 - Attributes attrs = new Attributes ( ) ; 
 + Attributes . Raw attrs = new Attributes . Raw ( ) ; 
 List < Pair < ColumnIdentifier , Operation . RawUpdate > > operations = new ArrayList < Pair < ColumnIdentifier , Operation . RawUpdate > > ( ) ; 
 boolean ifNotExists = false ; 
 } 
 @ @ - 354 , 7 + 353 , 7 @ @ updateCondition returns [ List < Pair < ColumnIdentifier , Operation . RawUpdate > > condi 
 * / 
 deleteStatement returns [ DeleteStatement . Parsed expr ] 
 @ init { 
 - Attributes attrs = new Attributes ( ) ; 
 + Attributes . Raw attrs = new Attributes . Raw ( ) ; 
 List < Operation . RawDeletion > columnDeletions = Collections . emptyList ( ) ; 
 } 
 : K _ DELETE ( dels = deleteSelection { columnDeletions = dels ; } ) ? 
 @ @ - 410 , 7 + 409 , 7 @ @ batchStatement returns [ BatchStatement . Parsed expr ] 
 @ init { 
 BatchStatement . Type type = BatchStatement . Type . LOGGED ; 
 List < ModificationStatement . Parsed > statements = new ArrayList < ModificationStatement . Parsed > ( ) ; 
 - Attributes attrs = new Attributes ( ) ; 
 + Attributes . Raw attrs = new Attributes . Raw ( ) ; 
 } 
 : K _ BEGIN 
 ( K _ UNLOGGED { type = BatchStatement . Type . UNLOGGED ; } | K _ COUNTER { type = BatchStatement . Type . COUNTER ; } ) ? 
 @ @ - 738 , 6 + 737 , 12 @ @ value returns [ Term . Raw value ] 
 | QMARK { $ value = new AbstractMarker . Raw ( + + currentBindMarkerIdx ) ; } 
 ; 
 
 + intValue returns [ Term . Raw value ] 
 + : 
 + | t = INTEGER { $ value = Constants . Literal . integer ( $ t . text ) ; } 
 + | QMARK { $ value = new AbstractMarker . Raw ( + + currentBindMarkerIdx ) ; } 
 + ; 
 + 
 functionName returns [ String s ] 
 : f = IDENT { $ s = $ f . text ; } 
 | u = unreserved _ function _ keyword { $ s = u ; } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 index d6d0e16 . . 777c80f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 @ @ - 76 , 23 + 76 , 16 @ @ public class BatchStatement implements CQLStatement 
 
 public void validate ( ClientState state ) throws InvalidRequestException 
 { 
 - if ( attrs . timeToLive ! = 0 ) 
 + if ( attrs . isTimeToLiveSet ( ) ) 
 throw new InvalidRequestException ( " Global TTL on the BATCH statement is not supported . " ) ; 
 
 for ( ModificationStatement statement : statements ) 
 { 
 - statement . validate ( state ) ; 
 - 
 - if ( attrs . timestamp ! = null & & statement . isSetTimestamp ( ) ) 
 + if ( attrs . isTimestampSet ( ) & & statement . isTimestampSet ( ) ) 
 throw new InvalidRequestException ( " Timestamp must be set either on BATCH or individual statements " ) ; 
 } 
 } 
 
 - public long getTimestamp ( long now ) 
 - { 
 - return attrs . timestamp = = null ? now : attrs . timestamp ; 
 - } 
 - 
 private Collection < ? extends IMutation > getMutations ( List < ByteBuffer > variables , boolean local , ConsistencyLevel cl , long now ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 @ @ - 125 , 7 + 118 , 7 @ @ public class BatchStatement implements CQLStatement 
 throws RequestExecutionException , RequestValidationException 
 { 
 / / Group mutation together , otherwise they won ' t get applied atomically 
 - for ( IMutation m : statement . getMutations ( variables , local , cl , getTimestamp ( now ) , true ) ) 
 + for ( IMutation m : statement . getMutations ( variables , local , cl , attrs . getTimestamp ( now , variables ) , true ) ) 
 { 
 Pair < String , ByteBuffer > key = Pair . create ( m . getTable ( ) , m . key ( ) ) ; 
 IMutation existing = mutations . get ( key ) ; 
 @ @ - 179 , 10 + 172 , 10 @ @ public class BatchStatement implements CQLStatement 
 public static class Parsed extends CFStatement 
 { 
 private final Type type ; 
 - private final Attributes attrs ; 
 + private final Attributes . Raw attrs ; 
 private final List < ModificationStatement . Parsed > parsedStatements ; 
 
 - public Parsed ( Type type , Attributes attrs , List < ModificationStatement . Parsed > parsedStatements ) 
 + public Parsed ( Type type , Attributes . Raw attrs , List < ModificationStatement . Parsed > parsedStatements ) 
 { 
 super ( null ) ; 
 this . type = type ; 
 @ @ - 217 , 7 + 210 , 10 @ @ public class BatchStatement implements CQLStatement 
 statements . add ( stmt ) ; 
 } 
 
 - return new ParsedStatement . Prepared ( new BatchStatement ( getBoundsTerms ( ) , type , statements , attrs ) , Arrays . < ColumnSpecification > asList ( boundNames ) ) ; 
 + Attributes prepAttrs = attrs . prepare ( " [ batch ] " , " [ batch ] " ) ; 
 + prepAttrs . collectMarkerSpecification ( boundNames ) ; 
 + 
 + return new ParsedStatement . Prepared ( new BatchStatement ( getBoundsTerms ( ) , type , statements , prepAttrs ) , Arrays . < ColumnSpecification > asList ( boundNames ) ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 index db3c41c . . 54a1034 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / DeleteStatement . java 
 @ @ - 93 , 7 + 93 , 7 @ @ public class DeleteStatement extends ModificationStatement 
 private final List < Relation > whereClause ; 
 
 public Parsed ( CFName name , 
 - Attributes attrs , 
 + Attributes . Raw attrs , 
 List < Operation . RawDeletion > deletions , 
 List < Relation > whereClause , 
 List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions ) 
 @ @ - 103 , 7 + 103 , 7 @ @ public class DeleteStatement extends ModificationStatement 
 this . whereClause = whereClause ; 
 } 
 
 - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException 
 + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException 
 { 
 DeleteStatement stmt = new DeleteStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index 7766f94 . . f6b7140 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 85 , 19 + 85 , 19 @ @ public abstract class ModificationStatement implements CQLStatement 
 return cfm . getDefaultValidator ( ) . isCommutative ( ) ; 
 } 
 
 - public int getTimeToLive ( ) 
 + public long getTimestamp ( long now , List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 - return attrs . timeToLive ; 
 + return attrs . getTimestamp ( now , variables ) ; 
 } 
 
 - public long getTimestamp ( long now ) 
 + public boolean isTimestampSet ( ) 
 { 
 - return attrs . timestamp = = null ? now : attrs . timestamp ; 
 + return attrs . isTimestampSet ( ) ; 
 } 
 
 - public boolean isSetTimestamp ( ) 
 + public int getTimeToLive ( List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 - return attrs . timestamp ! = null ; 
 + return attrs . getTimeToLive ( variables ) ; 
 } 
 
 public void checkAccess ( ClientState state ) throws InvalidRequestException , UnauthorizedException 
 @ @ - 107 , 7 + 107 , 6 @ @ public abstract class ModificationStatement implements CQLStatement 
 
 public void validate ( ClientState state ) throws InvalidRequestException 
 { 
 - attrs . validate ( ) ; 
 } 
 
 public void addOperation ( Operation op ) 
 @ @ - 363 , 7 + 362 , 7 @ @ public abstract class ModificationStatement implements CQLStatement 
 throw new InvalidRequestException ( " IN on the partition key is not supported with conditional updates " ) ; 
 
 ColumnNameBuilder clusteringPrefix = createClusteringPrefixBuilder ( variables ) ; 
 - UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( queryState . getTimestamp ( ) ) , getTimeToLive ( ) , null ) ; 
 + UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( queryState . getTimestamp ( ) , variables ) , getTimeToLive ( variables ) , null ) ; 
 
 ByteBuffer key = keys . get ( 0 ) ; 
 ThriftValidation . validateKey ( cfm , key ) ; 
 @ @ - 407 , 7 + 406 , 7 @ @ public abstract class ModificationStatement implements CQLStatement 
 
 / / Some lists operation requires reading 
 Map < ByteBuffer , ColumnGroupMap > rows = readRequiredRows ( keys , clusteringPrefix , local , cl ) ; 
 - UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( now ) , getTimeToLive ( ) , rows ) ; 
 + UpdateParameters params = new UpdateParameters ( cfm , variables , getTimestamp ( now , variables ) , getTimeToLive ( variables ) , rows ) ; 
 
 Collection < IMutation > mutations = new ArrayList < IMutation > ( ) ; 
 for ( ByteBuffer key : keys ) 
 @ @ - 449 , 11 + 448 , 11 @ @ public abstract class ModificationStatement implements CQLStatement 
 
 public static abstract class Parsed extends CFStatement 
 { 
 - protected final Attributes attrs ; 
 + protected final Attributes . Raw attrs ; 
 private final List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions ; 
 private final boolean ifNotExists ; 
 
 - protected Parsed ( CFName name , Attributes attrs , List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , boolean ifNotExists ) 
 + protected Parsed ( CFName name , Attributes . Raw attrs , List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , boolean ifNotExists ) 
 { 
 super ( name ) ; 
 this . attrs = attrs ; 
 @ @ - 473 , 7 + 472 , 10 @ @ public abstract class ModificationStatement implements CQLStatement 
 CFMetaData metadata = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; 
 CFDefinition cfDef = metadata . getCfDef ( ) ; 
 
 - ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; 
 + Attributes preparedAttributes = attrs . prepare ( keyspace ( ) , columnFamily ( ) ) ; 
 + preparedAttributes . collectMarkerSpecification ( boundNames ) ; 
 + 
 + ModificationStatement stmt = prepareInternal ( cfDef , boundNames , preparedAttributes ) ; 
 
 if ( ifNotExists | | ( conditions ! = null & & ! conditions . isEmpty ( ) ) ) 
 { 
 @ @ - 528 , 6 + 530 , 6 @ @ public abstract class ModificationStatement implements CQLStatement 
 return stmt ; 
 } 
 
 - protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException ; 
 + protected abstract ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index d45b730 . . 9630771 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 58 , 6 + 58 , 7 @ @ public class SelectStatement implements CQLStatement 
 public final CFDefinition cfDef ; 
 public final Parameters parameters ; 
 private final Selection selection ; 
 + private final Term limit ; 
 
 private final Restriction [ ] keyRestrictions ; 
 private final Restriction [ ] columnRestrictions ; 
 @ @ - 92 , 7 + 93 , 7 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 
 - public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters , Selection selection ) 
 + public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters , Selection selection , Term limit ) 
 { 
 this . cfDef = cfDef ; 
 this . boundTerms = boundTerms ; 
 @ @ - 100 , 6 + 101 , 7 @ @ public class SelectStatement implements CQLStatement 
 this . keyRestrictions = new Restriction [ cfDef . keys . size ( ) ] ; 
 this . columnRestrictions = new Restriction [ cfDef . columns . size ( ) ] ; 
 this . parameters = parameters ; 
 + this . limit = limit ; 
 } 
 
 public int getBoundsTerms ( ) 
 @ @ - 124 , 17 + 126 , 18 @ @ public class SelectStatement implements CQLStatement 
 
 cl . validateForRead ( keyspace ( ) ) ; 
 
 + int limit = getLimit ( variables ) ; 
 List < Row > rows = isKeyRange | | usesSecondaryIndexing 
 - ? StorageProxy . getRangeSlice ( getRangeCommand ( variables ) , cl ) 
 - : StorageProxy . read ( getSliceCommands ( variables ) , cl ) ; 
 + ? StorageProxy . getRangeSlice ( getRangeCommand ( variables , limit ) , cl ) 
 + : StorageProxy . read ( getSliceCommands ( variables , limit ) , cl ) ; 
 
 - return processResults ( rows , variables ) ; 
 + return processResults ( rows , variables , limit ) ; 
 } 
 
 - private ResultMessage . Rows processResults ( List < Row > rows , List < ByteBuffer > variables ) throws RequestValidationException 
 + private ResultMessage . Rows processResults ( List < Row > rows , List < ByteBuffer > variables , int limit ) throws RequestValidationException 
 { 
 / / Even for count , we need to process the result as it ' ll group some column together in sparse column families 
 - ResultSet rset = process ( rows , variables ) ; 
 + ResultSet rset = process ( rows , variables , limit ) ; 
 rset = parameters . isCount ? rset . makeCountResult ( parameters . countAlias ) : rset ; 
 return new ResultMessage . Rows ( rset ) ; 
 } 
 @ @ - 150 , 17 + 153 , 19 @ @ public class SelectStatement implements CQLStatement 
 
 public ResultMessage . Rows executeInternal ( QueryState state ) throws RequestExecutionException , RequestValidationException 
 { 
 + List < ByteBuffer > variables = Collections . < ByteBuffer > emptyList ( ) ; 
 + int limit = getLimit ( variables ) ; 
 List < Row > rows = isKeyRange | | usesSecondaryIndexing 
 - ? RangeSliceVerbHandler . executeLocally ( getRangeCommand ( Collections . < ByteBuffer > emptyList ( ) ) ) 
 - : readLocally ( keyspace ( ) , getSliceCommands ( Collections . < ByteBuffer > emptyList ( ) ) ) ; 
 + ? RangeSliceVerbHandler . executeLocally ( getRangeCommand ( variables , limit ) ) 
 + : readLocally ( keyspace ( ) , getSliceCommands ( variables , limit ) ) ; 
 
 - return processResults ( rows , Collections . < ByteBuffer > emptyList ( ) ) ; 
 + return processResults ( rows , variables , limit ) ; 
 } 
 
 public ResultSet process ( List < Row > rows ) throws InvalidRequestException 
 { 
 assert ! parameters . isCount ; / / not yet needed 
 - return process ( rows , Collections . < ByteBuffer > emptyList ( ) ) ; 
 + return process ( rows , Collections . < ByteBuffer > emptyList ( ) , getLimit ( Collections . < ByteBuffer > emptyList ( ) ) ) ; 
 } 
 
 public String keyspace ( ) 
 @ @ - 173 , 12 + 178 , 12 @ @ public class SelectStatement implements CQLStatement 
 return cfDef . cfm . cfName ; 
 } 
 
 - private List < ReadCommand > getSliceCommands ( List < ByteBuffer > variables ) throws RequestValidationException 
 + private List < ReadCommand > getSliceCommands ( List < ByteBuffer > variables , int limit ) throws RequestValidationException 
 { 
 Collection < ByteBuffer > keys = getKeys ( variables ) ; 
 List < ReadCommand > commands = new ArrayList < ReadCommand > ( keys . size ( ) ) ; 
 
 - IDiskAtomFilter filter = makeFilter ( variables ) ; 
 + IDiskAtomFilter filter = makeFilter ( variables , limit ) ; 
 / / Note that we use the total limit for every key , which is potentially inefficient . 
 / / However , IN + LIMIT is not a very sensible choice . 
 for ( ByteBuffer key : keys ) 
 @ @ - 192 , 9 + 197 , 9 @ @ public class SelectStatement implements CQLStatement 
 return commands ; 
 } 
 
 - private RangeSliceCommand getRangeCommand ( List < ByteBuffer > variables ) throws RequestValidationException 
 + private RangeSliceCommand getRangeCommand ( List < ByteBuffer > variables , int limit ) throws RequestValidationException 
 { 
 - IDiskAtomFilter filter = makeFilter ( variables ) ; 
 + IDiskAtomFilter filter = makeFilter ( variables , limit ) ; 
 List < IndexExpression > expressions = getIndexExpressions ( variables ) ; 
 / / The LIMIT provided by the user is the number of CQL row he wants returned . 
 / / We want to have getRangeSlice to count the number of columns , not the number of keys . 
 @ @ - 203 , 7 + 208 , 7 @ @ public class SelectStatement implements CQLStatement 
 filter , 
 getKeyBounds ( variables ) , 
 expressions , 
 - getLimit ( ) , 
 + limit , 
 true , 
 false ) ; 
 } 
 @ @ - 252 , 7 + 257 , 7 @ @ public class SelectStatement implements CQLStatement 
 return bounds ; 
 } 
 
 - private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables ) 
 + private IDiskAtomFilter makeFilter ( List < ByteBuffer > variables , int limit ) 
 throws InvalidRequestException 
 { 
 if ( isColumnRange ( ) ) 
 @ @ - 266 , 7 + 271 , 7 @ @ public class SelectStatement implements CQLStatement 
 getRequestedBound ( Bound . END , variables ) ) ; 
 SliceQueryFilter filter = new SliceQueryFilter ( new ColumnSlice [ ] { slice } , 
 isReversed , 
 - getLimit ( ) , 
 + limit , 
 toGroup ) ; 
 QueryProcessor . validateSliceFilter ( cfDef . cfm , filter ) ; 
 return filter ; 
 @ @ - 279 , 13 + 284 , 35 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 
 - private int getLimit ( ) 
 + private int getLimit ( List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 + int l = Integer . MAX _ VALUE ; 
 + if ( limit ! = null ) 
 + { 
 + ByteBuffer b = limit . bindAndGet ( variables ) ; 
 + if ( b = = null ) 
 + throw new InvalidRequestException ( " Invalid null value of limit " ) ; 
 + 
 + try 
 + { 
 + Int32Type . instance . validate ( b ) ; 
 + l = Int32Type . instance . compose ( b ) ; 
 + } 
 + catch ( MarshalException e ) 
 + { 
 + throw new InvalidRequestException ( " Invalid limit value " ) ; 
 + } 
 + } 
 + 
 + if ( l < = 0 ) 
 + throw new InvalidRequestException ( " LIMIT must be strictly positive " ) ; 
 + 
 / / Internally , we don ' t support exclusive bounds for slices . Instead , 
 / / we query one more element if necessary and exclude 
 - return sliceRestriction ! = null & & ! sliceRestriction . isInclusive ( Bound . START ) & & parameters . limit ! = Integer . MAX _ VALUE 
 - ? parameters . limit + 1 
 - : parameters . limit ; 
 + if ( sliceRestriction ! = null & & ! sliceRestriction . isInclusive ( Bound . START ) & & l ! = Integer . MAX _ VALUE ) 
 + l + = 1 ; 
 + 
 + return l ; 
 } 
 
 private Collection < ByteBuffer > getKeys ( final List < ByteBuffer > variables ) throws InvalidRequestException 
 @ @ - 634 , 7 + 661 , 7 @ @ public class SelectStatement implements CQLStatement 
 } ; 
 } 
 
 - private ResultSet process ( List < Row > rows , List < ByteBuffer > variables ) throws InvalidRequestException 
 + private ResultSet process ( List < Row > rows , List < ByteBuffer > variables , int limit ) throws InvalidRequestException 
 { 
 Selection . ResultSetBuilder result = selection . resultSetBuilder ( ) ; 
 for ( org . apache . cassandra . db . Row row : rows ) 
 @ @ - 740 , 7 + 767 , 7 @ @ public class SelectStatement implements CQLStatement 
 cqlRows . reverse ( ) ; 
 
 / / Trim result if needed to respect the limit 
 - cqlRows . trim ( parameters . limit ) ; 
 + cqlRows . trim ( limit ) ; 
 return cqlRows ; 
 } 
 
 @ @ - 839 , 22 + 866 , 21 @ @ public class SelectStatement implements CQLStatement 
 private final Parameters parameters ; 
 private final List < RawSelector > selectClause ; 
 private final List < Relation > whereClause ; 
 + private final Term . Raw limit ; 
 
 - public RawStatement ( CFName cfName , Parameters parameters , List < RawSelector > selectClause , List < Relation > whereClause ) 
 + public RawStatement ( CFName cfName , Parameters parameters , List < RawSelector > selectClause , List < Relation > whereClause , Term . Raw limit ) 
 { 
 super ( cfName ) ; 
 this . parameters = parameters ; 
 this . selectClause = selectClause ; 
 this . whereClause = whereClause = = null ? Collections . < Relation > emptyList ( ) : whereClause ; 
 + this . limit = limit ; 
 } 
 
 public ParsedStatement . Prepared prepare ( ) throws InvalidRequestException 
 { 
 CFMetaData cfm = ThriftValidation . validateColumnFamily ( keyspace ( ) , columnFamily ( ) ) ; 
 
 - if ( parameters . limit < = 0 ) 
 - throw new InvalidRequestException ( " LIMIT must be strictly positive " ) ; 
 - 
 CFDefinition cfDef = cfm . getCfDef ( ) ; 
 
 ColumnSpecification [ ] names = new ColumnSpecification [ getBoundsTerms ( ) ] ; 
 @ @ - 868 , 7 + 894 , 14 @ @ public class SelectStatement implements CQLStatement 
 ? Selection . wildcard ( cfDef ) 
 : Selection . fromSelectors ( cfDef , selectClause ) ; 
 
 - SelectStatement stmt = new SelectStatement ( cfDef , getBoundsTerms ( ) , parameters , selection ) ; 
 + Term prepLimit = null ; 
 + if ( limit ! = null ) 
 + { 
 + prepLimit = limit . prepare ( limitReceiver ( ) ) ; 
 + prepLimit . collectMarkerSpecification ( names ) ; 
 + } 
 + 
 + SelectStatement stmt = new SelectStatement ( cfDef , getBoundsTerms ( ) , parameters , selection , prepLimit ) ; 
 
 / * 
 * WHERE clause . For a given entity , rules are : 
 @ @ - 1209 , 6 + 1242 , 11 @ @ public class SelectStatement implements CQLStatement 
 } ) ; 
 } 
 
 + private ColumnSpecification limitReceiver ( ) 
 + { 
 + return new ColumnSpecification ( keyspace ( ) , columnFamily ( ) , new ColumnIdentifier ( " [ limit ] " , true ) , Int32Type . instance ) ; 
 + } 
 + 
 Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel , ColumnSpecification [ ] boundNames ) throws InvalidRequestException 
 { 
 ColumnSpecification receiver = name ; 
 @ @ - 1265 , 12 + 1303 , 11 @ @ public class SelectStatement implements CQLStatement 
 @ Override 
 public String toString ( ) 
 { 
 - return String . format ( " SelectRawStatement [ name = % s , selectClause = % s , whereClause = % s , isCount = % s , limit = % s ] " , 
 + return String . format ( " SelectRawStatement [ name = % s , selectClause = % s , whereClause = % s , isCount = % s ] " , 
 cfName , 
 selectClause , 
 whereClause , 
 - parameters . isCount , 
 - parameters . limit ) ; 
 + parameters . isCount ) ; 
 } 
 } 
 
 @ @ - 1409 , 15 + 1446 , 13 @ @ public class SelectStatement implements CQLStatement 
 
 public static class Parameters 
 { 
 - private final int limit ; 
 private final Map < ColumnIdentifier , Boolean > orderings ; 
 private final boolean isCount ; 
 private final ColumnIdentifier countAlias ; 
 private final boolean allowFiltering ; 
 
 - public Parameters ( int limit , Map < ColumnIdentifier , Boolean > orderings , boolean isCount , ColumnIdentifier countAlias , boolean allowFiltering ) 
 + public Parameters ( Map < ColumnIdentifier , Boolean > orderings , boolean isCount , ColumnIdentifier countAlias , boolean allowFiltering ) 
 { 
 - this . limit = limit ; 
 this . orderings = orderings ; 
 this . isCount = isCount ; 
 this . countAlias = countAlias ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java b / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java 
 index bc05dd6 . . cff4105 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / UpdateStatement . java 
 @ @ - 115 , 14 + 115 , 14 @ @ public class UpdateStatement extends ModificationStatement 
 * @ param columnValues list of column values ( corresponds to names ) 
 * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) 
 * / 
 - public ParsedInsert ( CFName name , Attributes attrs , List < ColumnIdentifier > columnNames , List < Term . Raw > columnValues ) 
 + public ParsedInsert ( CFName name , Attributes . Raw attrs , List < ColumnIdentifier > columnNames , List < Term . Raw > columnValues ) 
 { 
 super ( name , attrs , Collections . < Pair < ColumnIdentifier , Operation . RawUpdate > > emptyList ( ) , false ) ; 
 this . columnNames = columnNames ; 
 this . columnValues = columnValues ; 
 } 
 
 - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException 
 + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException 
 { 
 UpdateStatement stmt = new UpdateStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; 
 
 @ @ - 182 , 7 + 182 , 7 @ @ public class UpdateStatement extends ModificationStatement 
 * @ param whereClause the where clause 
 * / 
 public ParsedUpdate ( CFName name , 
 - Attributes attrs , 
 + Attributes . Raw attrs , 
 List < Pair < ColumnIdentifier , Operation . RawUpdate > > updates , 
 List < Relation > whereClause , 
 List < Pair < ColumnIdentifier , Operation . RawUpdate > > conditions , 
 @ @ - 193 , 7 + 193 , 7 @ @ public class UpdateStatement extends ModificationStatement 
 this . whereClause = whereClause ; 
 } 
 
 - protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames ) throws InvalidRequestException 
 + protected ModificationStatement prepareInternal ( CFDefinition cfDef , ColumnSpecification [ ] boundNames , Attributes attrs ) throws InvalidRequestException 
 { 
 UpdateStatement stmt = new UpdateStatement ( getBoundsTerms ( ) , cfDef . cfm , attrs ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 index 3bec918 . . ed8aaaf 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 @ @ - 221 , 7 + 221 , 7 @ @ public class BatchMessage extends Message . Request 
 
 / / Note : It ' s ok at this point to pass a bogus value for the number of bound terms in the BatchState ctor 
 / / ( and no value would be really correct , so we prefer passing a clearly wrong one ) . 
 - BatchStatement batch = new BatchStatement ( - 1 , type , statements , new Attributes ( ) ) ; 
 + BatchStatement batch = new BatchStatement ( - 1 , type , statements , Attributes . none ( ) ) ; 
 Message . Response response = QueryProcessor . processBatch ( batch , consistency , state , values ) ; 
 
 if ( tracingId ! = null )
