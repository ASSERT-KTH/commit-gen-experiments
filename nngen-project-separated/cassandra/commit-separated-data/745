BLEU SCORE: 0.044568827606990644

TEST MSG: Use custom RMI registry to avoid issues with JMX and SSL
GENERATED MSG: Bind JMX to localhost unless explicitly configured otherwise

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index dac46ab . . c9dce65 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 9 + 1 , 11 @ @ <nl> 3 . 9 <nl> + * Fix SSL JMX requiring truststore containing server cert ( CASSANDRA - 12109 ) <nl> Merged from 3 . 0 : <nl> * Fix problem with undeleteable rows on upgrade to new sstable format ( CASSANDRA - 12144 ) <nl> Merged from 2 . 2 : <nl> * Fixed cqlshlib . test . remove _ test _ db ( CASSANDRA - 12214 ) <nl> <nl> + <nl> 3 . 8 <nl> * Fix hdr logging for single operation workloads ( CASSANDRA - 12145 ) <nl> * Fix SASI PREFIX search in CONTAINS mode with partial terms ( CASSANDRA - 12073 ) <nl> diff - - git a / conf / cassandra - env . ps1 b / conf / cassandra - env . ps1 <nl> index 9373ba6 . . d7a4867 100644 <nl> - - - a / conf / cassandra - env . ps1 <nl> + + + b / conf / cassandra - env . ps1 <nl> @ @ - 450 , 14 + 450 , 13 @ @ Function SetCassandraEnvironment <nl> # <nl> # JMX SSL options <nl> # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = true " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . registry . ssl = true " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = C : / keystore " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = C : / truststore " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . keyStore = C : / keystore " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . trustStore = C : / truststore " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " <nl> # <nl> # JMX auth options <nl> # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = true " <nl> @ @ - 469 , 12 + 468 , 12 @ @ Function SetCassandraEnvironment <nl> # # JAAS login modules can be used for authentication by uncommenting these two properties . <nl> # # Cassandra ships with a LoginModule implementation - org . apache . cassandra . auth . CassandraLoginModule - <nl> # # which delegates to the IAuthenticator configured in cassandra . yaml <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . remote . login . config = CassandraLogin " <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djava . security . auth . login . config = C : / cassandra - jaas . config " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . remote . login . config = CassandraLogin " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djava . security . auth . login . config = C : / cassandra - jaas . config " <nl> <nl> # # Cassandra also ships with a helper for delegating JMX authz calls to the configured IAuthorizer , <nl> # # uncomment this to use it . Requires one of the two authentication options to be enabled <nl> - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . authorizer = org . apache . cassandra . auth . jmx . AuthorizationProxy " <nl> + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . authorizer = org . apache . cassandra . auth . jmx . AuthorizationProxy " <nl> <nl> # Default JMX setup , bound to local loopback address only <nl> $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . local . port = $ JMX _ PORT " <nl> diff - - git a / conf / cassandra - env . sh b / conf / cassandra - env . sh <nl> index 93434c9 . . 5a02f79 100644 <nl> - - - a / conf / cassandra - env . sh <nl> + + + b / conf / cassandra - env . sh <nl> @ @ - 242 , 20 + 242 , 23 @ @ if [ " $ LOCAL _ JMX " = " yes " ] ; then <nl> JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = false " <nl> else <nl> JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . remote . port = $ JMX _ PORT " <nl> + # if ssl is enabled the same port cannot be used for both jmx and rmi so either <nl> + # pick another value for this property or comment out to use a random port ( though see CASSANDRA - 7087 for origins ) <nl> JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . rmi . port = $ JMX _ PORT " <nl> + <nl> + # turn on JMX authentication . See below for further options <nl> JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = true " <nl> - fi <nl> <nl> - # jmx ssl options <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = false " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . registry . ssl = true " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = / path / to / keystore " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = / path / to / truststore " <nl> - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " <nl> + # jmx ssl options <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = true " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = / path / to / keystore " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = / path / to / truststore " <nl> + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " <nl> + fi <nl> <nl> # jmx authentication and authorization options . By default , auth is only <nl> # activated for remote connections but they can also be enabled for local only JMX <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 88b3c88 . . 0151208 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 137 , 7 + 137 , 6 @ @ public class CassandraDaemon <nl> jmxServer = JMXServerUtils . createJMXServer ( Integer . parseInt ( jmxPort ) , localOnly ) ; <nl> if ( jmxServer = = null ) <nl> return ; <nl> - jmxServer . start ( ) ; <nl> } <nl> catch ( IOException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / utils / JMXServerUtils . java b / src / java / org / apache / cassandra / utils / JMXServerUtils . java <nl> index ad87efd . . dad757e 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / JMXServerUtils . java <nl> + + + b / src / java / org / apache / cassandra / utils / JMXServerUtils . java <nl> @ @ - 23 , 10 + 23 , 7 @ @ import java . lang . management . ManagementFactory ; <nl> import java . lang . reflect . InvocationHandler ; <nl> import java . lang . reflect . Proxy ; <nl> import java . net . InetAddress ; <nl> - import java . rmi . NoSuchObjectException ; <nl> - import java . rmi . Remote ; <nl> - import java . rmi . RemoteException ; <nl> - import java . rmi . registry . LocateRegistry ; <nl> + import java . rmi . * ; <nl> import java . rmi . server . RMIClientSocketFactory ; <nl> import java . rmi . server . RMIServerSocketFactory ; <nl> import java . rmi . server . UnicastRemoteObject ; <nl> @ @ - 36 , 7 + 33 , 6 @ @ import java . util . Map ; <nl> import java . util . stream . Collectors ; <nl> import javax . management . remote . * ; <nl> import javax . management . remote . rmi . RMIConnectorServer ; <nl> - import javax . management . remote . rmi . RMIJRMPServerImpl ; <nl> import javax . rmi . ssl . SslRMIClientSocketFactory ; <nl> import javax . rmi . ssl . SslRMIServerSocketFactory ; <nl> import javax . security . auth . Subject ; <nl> @ @ - 49 , 12 + 45 , 15 @ @ import org . slf4j . LoggerFactory ; <nl> import com . sun . jmx . remote . internal . RMIExporter ; <nl> import com . sun . jmx . remote . security . JMXPluggableAuthenticator ; <nl> import org . apache . cassandra . auth . jmx . AuthenticationProxy ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import sun . rmi . registry . RegistryImpl ; <nl> import sun . rmi . server . UnicastServerRef2 ; <nl> <nl> public class JMXServerUtils <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( JMXServerUtils . class ) ; <nl> <nl> + private static java . rmi . registry . Registry registry ; <nl> <nl> / * * <nl> * Creates a server programmatically . This allows us to set parameters which normally are <nl> @ @ - 74 , 12 + 73 , 8 @ @ public class JMXServerUtils <nl> } <nl> <nl> / / Configure the RMI client & server socket factories , including SSL config . <nl> - env . putAll ( configureJmxSocketFactories ( serverAddress ) ) ; <nl> + env . putAll ( configureJmxSocketFactories ( serverAddress , local ) ) ; <nl> <nl> - String url = String . format ( urlTemplate , ( serverAddress ! = null ? serverAddress . getHostAddress ( ) : " 0 . 0 . 0 . 0 " ) , port ) ; <nl> - LocateRegistry . createRegistry ( port , <nl> - ( RMIClientSocketFactory ) env . get ( RMIConnectorServer . RMI _ CLIENT _ SOCKET _ FACTORY _ ATTRIBUTE ) , <nl> - ( RMIServerSocketFactory ) env . get ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE ) ) ; <nl> <nl> / / Configure authn , using a JMXAuthenticator which either wraps a set log LoginModules configured <nl> / / via a JAAS configuration entry , or one which delegates to the standard file based authenticator . <nl> @ @ - 96 , 8 + 91 , 11 @ @ public class JMXServerUtils <nl> / / sun . rmi . dgc . server . gcInterval millis ( default is 3600000ms / 1 hour ) <nl> env . put ( RMIExporter . EXPORTER _ ATTRIBUTE , new Exporter ( ) ) ; <nl> <nl> + String url = String . format ( urlTemplate , ( serverAddress ! = null ? serverAddress . getHostAddress ( ) : " 0 . 0 . 0 . 0 " ) , port ) ; <nl> + <nl> + int rmiPort = Integer . getInteger ( " com . sun . management . jmxremote . rmi . port " , 0 ) ; <nl> JMXConnectorServer jmxServer = <nl> - JMXConnectorServerFactory . newJMXConnectorServer ( new JMXServiceURL ( url ) , <nl> + JMXConnectorServerFactory . newJMXConnectorServer ( new JMXServiceURL ( " rmi " , null , rmiPort ) , <nl> env , <nl> ManagementFactory . getPlatformMBeanServer ( ) ) ; <nl> <nl> @ @ - 105 , 10 + 103 , 33 @ @ public class JMXServerUtils <nl> if ( authzProxy ! = null ) <nl> jmxServer . setMBeanServerForwarder ( authzProxy ) ; <nl> <nl> + jmxServer . start ( ) ; <nl> + <nl> + / / use a custom Registry to avoid having to interact with it internally using the remoting interface <nl> + configureRMIRegistry ( port , env ) ; <nl> + <nl> logger . info ( " Configured JMX server at : { } " , url ) ; <nl> return jmxServer ; <nl> } <nl> <nl> + private static void configureRMIRegistry ( int port , Map < String , Object > env ) throws RemoteException <nl> + { <nl> + Exporter exporter = ( Exporter ) env . get ( RMIExporter . EXPORTER _ ATTRIBUTE ) ; <nl> + / / If ssl is enabled , make sure it ' s also in place for the RMI registry <nl> + / / by using the SSL socket factories already created and stashed in env <nl> + if ( Boolean . getBoolean ( " com . sun . management . jmxremote . ssl " ) ) <nl> + { <nl> + registry = new Registry ( port , <nl> + ( RMIClientSocketFactory ) env . get ( RMIConnectorServer . RMI _ CLIENT _ SOCKET _ FACTORY _ ATTRIBUTE ) , <nl> + ( RMIServerSocketFactory ) env . get ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE ) , <nl> + exporter . connectorServer ) ; <nl> + } <nl> + else <nl> + { <nl> + registry = new Registry ( port , exporter . connectorServer ) ; <nl> + } <nl> + } <nl> + <nl> private static Map < String , Object > configureJmxAuthentication ( ) <nl> { <nl> Map < String , Object > env = new HashMap < > ( ) ; <nl> @ @ - 173 , 7 + 194 , 7 @ @ public class JMXServerUtils <nl> } <nl> } <nl> <nl> - private static Map < String , Object > configureJmxSocketFactories ( InetAddress serverAddress ) <nl> + private static Map < String , Object > configureJmxSocketFactories ( InetAddress serverAddress , boolean localOnly ) <nl> { <nl> Map < String , Object > env = new HashMap < > ( ) ; <nl> if ( Boolean . getBoolean ( " com . sun . management . jmxremote . ssl " ) ) <nl> @ @ - 202 , 8 + 223 , 7 @ @ public class JMXServerUtils <nl> env . put ( " com . sun . jndi . rmi . factory . socket " , clientFactory ) ; <nl> logJmxSslConfig ( serverFactory ) ; <nl> } <nl> - else <nl> - { <nl> + else if ( localOnly ) { <nl> env . put ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE , <nl> new RMIServerSocketFactoryImpl ( serverAddress ) ) ; <nl> } <nl> @ @ - 265 , 16 + 285 , 20 @ @ public class JMXServerUtils <nl> * / <nl> private static class Exporter implements RMIExporter <nl> { <nl> + / / the first object to be exported by this instance is * always * the JMXConnectorServer <nl> + / / instance created by createJMXServer . Keep a handle to it , as it needs to be supplied <nl> + / / to our custom Registry too . <nl> + private Remote connectorServer ; <nl> + <nl> public Remote exportObject ( Remote obj , int port , RMIClientSocketFactory csf , RMIServerSocketFactory ssf ) <nl> throws RemoteException <nl> { <nl> - / / We should only ever get here by configuring our own JMX Connector server , <nl> - / / so assert some invariants we expect to be true in that case <nl> - assert ssf ! = null ; / / we always configure a custom server socket factory <nl> + Remote remote = new UnicastServerRef2 ( port , csf , ssf ) . exportObject ( obj , null , true ) ; <nl> + / / Keep a reference to the first object exported , the JMXConnectorServer <nl> + if ( connectorServer = = null ) <nl> + connectorServer = remote ; <nl> <nl> - / / as we always configure a custom server socket factory , either for SSL or to ensure <nl> - / / only loopback addresses , we use a UnicastServerRef2 for exporting <nl> - return new UnicastServerRef2 ( port , csf , ssf ) . exportObject ( obj , null , true ) ; <nl> + return remote ; <nl> } <nl> <nl> public boolean unexportObject ( Remote obj , boolean force ) throws NoSuchObjectException <nl> @ @ - 282 , 4 + 306 , 66 @ @ public class JMXServerUtils <nl> return UnicastRemoteObject . unexportObject ( obj , force ) ; <nl> } <nl> } <nl> + <nl> + / * * <nl> + * Using this class avoids the necessity to interact with the registry via its <nl> + * remoting interface . This is necessary because when SSL is enabled for the registry , <nl> + * that remote interaction is treated just the same as one from an external client . <nl> + * That is problematic when binding the JMXConnectorServer to the Registry as it requires <nl> + * the client , which in this case is our own internal code , to connect like any other SSL <nl> + * client , meaning we need a truststore containing our own certificate . <nl> + * This bypasses the binding API completely , which emulates the behaviour of <nl> + * ConnectorBootstrap when the subsystem is initialized by the JVM Agent directly . <nl> + * <nl> + * See CASSANDRA - 12109 . <nl> + * / <nl> + private static class Registry extends RegistryImpl <nl> + { <nl> + private final static String KEY = " jmxrmi " ; <nl> + private final Remote connectorServer ; <nl> + <nl> + private Registry ( int port , Remote connectorServer ) throws RemoteException <nl> + { <nl> + super ( port ) ; <nl> + this . connectorServer = connectorServer ; <nl> + } <nl> + <nl> + private Registry ( int port , <nl> + RMIClientSocketFactory csf , <nl> + RMIServerSocketFactory ssf , <nl> + Remote connectorServer ) throws RemoteException <nl> + { <nl> + super ( port , csf , ssf ) ; <nl> + this . connectorServer = connectorServer ; <nl> + } <nl> + <nl> + public Remote lookup ( String name ) throws RemoteException , NotBoundException <nl> + { <nl> + if ( name . equals ( KEY ) ) <nl> + return connectorServer ; <nl> + <nl> + throw new NotBoundException ( String . format ( " Only the JMX Connector Server named % s " + <nl> + " is bound in this registry " , KEY ) ) ; <nl> + } <nl> + <nl> + public void bind ( String name , Remote obj ) throws RemoteException , AlreadyBoundException <nl> + { <nl> + throw new UnsupportedOperationException ( " Unsupported " ) ; <nl> + } <nl> + <nl> + public void unbind ( String name ) throws RemoteException , NotBoundException <nl> + { <nl> + throw new UnsupportedOperationException ( " Unsupported " ) ; <nl> + } <nl> + <nl> + public void rebind ( String name , Remote obj ) throws RemoteException <nl> + { <nl> + throw new UnsupportedOperationException ( " Unsupported " ) ; <nl> + } <nl> + <nl> + public String [ ] list ( ) throws RemoteException <nl> + { <nl> + return new String [ ] { KEY } ; <nl> + } <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index dac46ab . . c9dce65 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 9 + 1 , 11 @ @ 
 3 . 9 
 + * Fix SSL JMX requiring truststore containing server cert ( CASSANDRA - 12109 ) 
 Merged from 3 . 0 : 
 * Fix problem with undeleteable rows on upgrade to new sstable format ( CASSANDRA - 12144 ) 
 Merged from 2 . 2 : 
 * Fixed cqlshlib . test . remove _ test _ db ( CASSANDRA - 12214 ) 
 
 + 
 3 . 8 
 * Fix hdr logging for single operation workloads ( CASSANDRA - 12145 ) 
 * Fix SASI PREFIX search in CONTAINS mode with partial terms ( CASSANDRA - 12073 ) 
 diff - - git a / conf / cassandra - env . ps1 b / conf / cassandra - env . ps1 
 index 9373ba6 . . d7a4867 100644 
 - - - a / conf / cassandra - env . ps1 
 + + + b / conf / cassandra - env . ps1 
 @ @ - 450 , 14 + 450 , 13 @ @ Function SetCassandraEnvironment 
 # 
 # JMX SSL options 
 # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = true " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . registry . ssl = true " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = C : / keystore " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = C : / truststore " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . keyStore = C : / keystore " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . trustStore = C : / truststore " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " 
 # 
 # JMX auth options 
 # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = true " 
 @ @ - 469 , 12 + 468 , 12 @ @ Function SetCassandraEnvironment 
 # # JAAS login modules can be used for authentication by uncommenting these two properties . 
 # # Cassandra ships with a LoginModule implementation - org . apache . cassandra . auth . CassandraLoginModule - 
 # # which delegates to the IAuthenticator configured in cassandra . yaml 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . remote . login . config = CassandraLogin " 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Djava . security . auth . login . config = C : / cassandra - jaas . config " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . remote . login . config = CassandraLogin " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Djava . security . auth . login . config = C : / cassandra - jaas . config " 
 
 # # Cassandra also ships with a helper for delegating JMX authz calls to the configured IAuthorizer , 
 # # uncomment this to use it . Requires one of the two authentication options to be enabled 
 - # $ env : JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . authorizer = org . apache . cassandra . auth . jmx . AuthorizationProxy " 
 + # $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . authorizer = org . apache . cassandra . auth . jmx . AuthorizationProxy " 
 
 # Default JMX setup , bound to local loopback address only 
 $ env : JVM _ OPTS = " $ env : JVM _ OPTS - Dcassandra . jmx . local . port = $ JMX _ PORT " 
 diff - - git a / conf / cassandra - env . sh b / conf / cassandra - env . sh 
 index 93434c9 . . 5a02f79 100644 
 - - - a / conf / cassandra - env . sh 
 + + + b / conf / cassandra - env . sh 
 @ @ - 242 , 20 + 242 , 23 @ @ if [ " $ LOCAL _ JMX " = " yes " ] ; then 
 JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = false " 
 else 
 JVM _ OPTS = " $ JVM _ OPTS - Dcassandra . jmx . remote . port = $ JMX _ PORT " 
 + # if ssl is enabled the same port cannot be used for both jmx and rmi so either 
 + # pick another value for this property or comment out to use a random port ( though see CASSANDRA - 7087 for origins ) 
 JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . rmi . port = $ JMX _ PORT " 
 + 
 + # turn on JMX authentication . See below for further options 
 JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . authenticate = true " 
 - fi 
 
 - # jmx ssl options 
 - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = false " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . registry . ssl = true " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = / path / to / keystore " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = / path / to / truststore " 
 - # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " 
 + # jmx ssl options 
 + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl = true " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . need . client . auth = true " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . protocols = < enabled - protocols > " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Dcom . sun . management . jmxremote . ssl . enabled . cipher . suites = < enabled - cipher - suites > " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStore = / path / to / keystore " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . keyStorePassword = < keystore - password > " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStore = / path / to / truststore " 
 + # JVM _ OPTS = " $ JVM _ OPTS - Djavax . net . ssl . trustStorePassword = < truststore - password > " 
 + fi 
 
 # jmx authentication and authorization options . By default , auth is only 
 # activated for remote connections but they can also be enabled for local only JMX 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 88b3c88 . . 0151208 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 137 , 7 + 137 , 6 @ @ public class CassandraDaemon 
 jmxServer = JMXServerUtils . createJMXServer ( Integer . parseInt ( jmxPort ) , localOnly ) ; 
 if ( jmxServer = = null ) 
 return ; 
 - jmxServer . start ( ) ; 
 } 
 catch ( IOException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / utils / JMXServerUtils . java b / src / java / org / apache / cassandra / utils / JMXServerUtils . java 
 index ad87efd . . dad757e 100644 
 - - - a / src / java / org / apache / cassandra / utils / JMXServerUtils . java 
 + + + b / src / java / org / apache / cassandra / utils / JMXServerUtils . java 
 @ @ - 23 , 10 + 23 , 7 @ @ import java . lang . management . ManagementFactory ; 
 import java . lang . reflect . InvocationHandler ; 
 import java . lang . reflect . Proxy ; 
 import java . net . InetAddress ; 
 - import java . rmi . NoSuchObjectException ; 
 - import java . rmi . Remote ; 
 - import java . rmi . RemoteException ; 
 - import java . rmi . registry . LocateRegistry ; 
 + import java . rmi . * ; 
 import java . rmi . server . RMIClientSocketFactory ; 
 import java . rmi . server . RMIServerSocketFactory ; 
 import java . rmi . server . UnicastRemoteObject ; 
 @ @ - 36 , 7 + 33 , 6 @ @ import java . util . Map ; 
 import java . util . stream . Collectors ; 
 import javax . management . remote . * ; 
 import javax . management . remote . rmi . RMIConnectorServer ; 
 - import javax . management . remote . rmi . RMIJRMPServerImpl ; 
 import javax . rmi . ssl . SslRMIClientSocketFactory ; 
 import javax . rmi . ssl . SslRMIServerSocketFactory ; 
 import javax . security . auth . Subject ; 
 @ @ - 49 , 12 + 45 , 15 @ @ import org . slf4j . LoggerFactory ; 
 import com . sun . jmx . remote . internal . RMIExporter ; 
 import com . sun . jmx . remote . security . JMXPluggableAuthenticator ; 
 import org . apache . cassandra . auth . jmx . AuthenticationProxy ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import sun . rmi . registry . RegistryImpl ; 
 import sun . rmi . server . UnicastServerRef2 ; 
 
 public class JMXServerUtils 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( JMXServerUtils . class ) ; 
 
 + private static java . rmi . registry . Registry registry ; 
 
 / * * 
 * Creates a server programmatically . This allows us to set parameters which normally are 
 @ @ - 74 , 12 + 73 , 8 @ @ public class JMXServerUtils 
 } 
 
 / / Configure the RMI client & server socket factories , including SSL config . 
 - env . putAll ( configureJmxSocketFactories ( serverAddress ) ) ; 
 + env . putAll ( configureJmxSocketFactories ( serverAddress , local ) ) ; 
 
 - String url = String . format ( urlTemplate , ( serverAddress ! = null ? serverAddress . getHostAddress ( ) : " 0 . 0 . 0 . 0 " ) , port ) ; 
 - LocateRegistry . createRegistry ( port , 
 - ( RMIClientSocketFactory ) env . get ( RMIConnectorServer . RMI _ CLIENT _ SOCKET _ FACTORY _ ATTRIBUTE ) , 
 - ( RMIServerSocketFactory ) env . get ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE ) ) ; 
 
 / / Configure authn , using a JMXAuthenticator which either wraps a set log LoginModules configured 
 / / via a JAAS configuration entry , or one which delegates to the standard file based authenticator . 
 @ @ - 96 , 8 + 91 , 11 @ @ public class JMXServerUtils 
 / / sun . rmi . dgc . server . gcInterval millis ( default is 3600000ms / 1 hour ) 
 env . put ( RMIExporter . EXPORTER _ ATTRIBUTE , new Exporter ( ) ) ; 
 
 + String url = String . format ( urlTemplate , ( serverAddress ! = null ? serverAddress . getHostAddress ( ) : " 0 . 0 . 0 . 0 " ) , port ) ; 
 + 
 + int rmiPort = Integer . getInteger ( " com . sun . management . jmxremote . rmi . port " , 0 ) ; 
 JMXConnectorServer jmxServer = 
 - JMXConnectorServerFactory . newJMXConnectorServer ( new JMXServiceURL ( url ) , 
 + JMXConnectorServerFactory . newJMXConnectorServer ( new JMXServiceURL ( " rmi " , null , rmiPort ) , 
 env , 
 ManagementFactory . getPlatformMBeanServer ( ) ) ; 
 
 @ @ - 105 , 10 + 103 , 33 @ @ public class JMXServerUtils 
 if ( authzProxy ! = null ) 
 jmxServer . setMBeanServerForwarder ( authzProxy ) ; 
 
 + jmxServer . start ( ) ; 
 + 
 + / / use a custom Registry to avoid having to interact with it internally using the remoting interface 
 + configureRMIRegistry ( port , env ) ; 
 + 
 logger . info ( " Configured JMX server at : { } " , url ) ; 
 return jmxServer ; 
 } 
 
 + private static void configureRMIRegistry ( int port , Map < String , Object > env ) throws RemoteException 
 + { 
 + Exporter exporter = ( Exporter ) env . get ( RMIExporter . EXPORTER _ ATTRIBUTE ) ; 
 + / / If ssl is enabled , make sure it ' s also in place for the RMI registry 
 + / / by using the SSL socket factories already created and stashed in env 
 + if ( Boolean . getBoolean ( " com . sun . management . jmxremote . ssl " ) ) 
 + { 
 + registry = new Registry ( port , 
 + ( RMIClientSocketFactory ) env . get ( RMIConnectorServer . RMI _ CLIENT _ SOCKET _ FACTORY _ ATTRIBUTE ) , 
 + ( RMIServerSocketFactory ) env . get ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE ) , 
 + exporter . connectorServer ) ; 
 + } 
 + else 
 + { 
 + registry = new Registry ( port , exporter . connectorServer ) ; 
 + } 
 + } 
 + 
 private static Map < String , Object > configureJmxAuthentication ( ) 
 { 
 Map < String , Object > env = new HashMap < > ( ) ; 
 @ @ - 173 , 7 + 194 , 7 @ @ public class JMXServerUtils 
 } 
 } 
 
 - private static Map < String , Object > configureJmxSocketFactories ( InetAddress serverAddress ) 
 + private static Map < String , Object > configureJmxSocketFactories ( InetAddress serverAddress , boolean localOnly ) 
 { 
 Map < String , Object > env = new HashMap < > ( ) ; 
 if ( Boolean . getBoolean ( " com . sun . management . jmxremote . ssl " ) ) 
 @ @ - 202 , 8 + 223 , 7 @ @ public class JMXServerUtils 
 env . put ( " com . sun . jndi . rmi . factory . socket " , clientFactory ) ; 
 logJmxSslConfig ( serverFactory ) ; 
 } 
 - else 
 - { 
 + else if ( localOnly ) { 
 env . put ( RMIConnectorServer . RMI _ SERVER _ SOCKET _ FACTORY _ ATTRIBUTE , 
 new RMIServerSocketFactoryImpl ( serverAddress ) ) ; 
 } 
 @ @ - 265 , 16 + 285 , 20 @ @ public class JMXServerUtils 
 * / 
 private static class Exporter implements RMIExporter 
 { 
 + / / the first object to be exported by this instance is * always * the JMXConnectorServer 
 + / / instance created by createJMXServer . Keep a handle to it , as it needs to be supplied 
 + / / to our custom Registry too . 
 + private Remote connectorServer ; 
 + 
 public Remote exportObject ( Remote obj , int port , RMIClientSocketFactory csf , RMIServerSocketFactory ssf ) 
 throws RemoteException 
 { 
 - / / We should only ever get here by configuring our own JMX Connector server , 
 - / / so assert some invariants we expect to be true in that case 
 - assert ssf ! = null ; / / we always configure a custom server socket factory 
 + Remote remote = new UnicastServerRef2 ( port , csf , ssf ) . exportObject ( obj , null , true ) ; 
 + / / Keep a reference to the first object exported , the JMXConnectorServer 
 + if ( connectorServer = = null ) 
 + connectorServer = remote ; 
 
 - / / as we always configure a custom server socket factory , either for SSL or to ensure 
 - / / only loopback addresses , we use a UnicastServerRef2 for exporting 
 - return new UnicastServerRef2 ( port , csf , ssf ) . exportObject ( obj , null , true ) ; 
 + return remote ; 
 } 
 
 public boolean unexportObject ( Remote obj , boolean force ) throws NoSuchObjectException 
 @ @ - 282 , 4 + 306 , 66 @ @ public class JMXServerUtils 
 return UnicastRemoteObject . unexportObject ( obj , force ) ; 
 } 
 } 
 + 
 + / * * 
 + * Using this class avoids the necessity to interact with the registry via its 
 + * remoting interface . This is necessary because when SSL is enabled for the registry , 
 + * that remote interaction is treated just the same as one from an external client . 
 + * That is problematic when binding the JMXConnectorServer to the Registry as it requires 
 + * the client , which in this case is our own internal code , to connect like any other SSL 
 + * client , meaning we need a truststore containing our own certificate . 
 + * This bypasses the binding API completely , which emulates the behaviour of 
 + * ConnectorBootstrap when the subsystem is initialized by the JVM Agent directly . 
 + * 
 + * See CASSANDRA - 12109 . 
 + * / 
 + private static class Registry extends RegistryImpl 
 + { 
 + private final static String KEY = " jmxrmi " ; 
 + private final Remote connectorServer ; 
 + 
 + private Registry ( int port , Remote connectorServer ) throws RemoteException 
 + { 
 + super ( port ) ; 
 + this . connectorServer = connectorServer ; 
 + } 
 + 
 + private Registry ( int port , 
 + RMIClientSocketFactory csf , 
 + RMIServerSocketFactory ssf , 
 + Remote connectorServer ) throws RemoteException 
 + { 
 + super ( port , csf , ssf ) ; 
 + this . connectorServer = connectorServer ; 
 + } 
 + 
 + public Remote lookup ( String name ) throws RemoteException , NotBoundException 
 + { 
 + if ( name . equals ( KEY ) ) 
 + return connectorServer ; 
 + 
 + throw new NotBoundException ( String . format ( " Only the JMX Connector Server named % s " + 
 + " is bound in this registry " , KEY ) ) ; 
 + } 
 + 
 + public void bind ( String name , Remote obj ) throws RemoteException , AlreadyBoundException 
 + { 
 + throw new UnsupportedOperationException ( " Unsupported " ) ; 
 + } 
 + 
 + public void unbind ( String name ) throws RemoteException , NotBoundException 
 + { 
 + throw new UnsupportedOperationException ( " Unsupported " ) ; 
 + } 
 + 
 + public void rebind ( String name , Remote obj ) throws RemoteException 
 + { 
 + throw new UnsupportedOperationException ( " Unsupported " ) ; 
 + } 
 + 
 + public String [ ] list ( ) throws RemoteException 
 + { 
 + return new String [ ] { KEY } ; 
 + } 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
