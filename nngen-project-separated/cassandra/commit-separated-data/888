BLEU SCORE: 0.04194930905450255

TEST MSG: Make prepared statement cache size configurable
GENERATED MSG: add file _ cache _ size _ in _ mb setting

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c49249c . . c802031 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 6 <nl> + * Make prepared statement cache size configurable ( CASSANDRA - 11555 ) <nl> * Integrated JMX authentication and authorization ( CASSANDRA - 10091 ) <nl> * Add units to stress ouput ( CASSANDRA - 11352 ) <nl> * Fix PER PARTITION LIMIT for single and multi partitions queries ( CASSANDRA - 11603 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 48bad2c . . 9eb55e1 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 215 , 6 + 215 , 34 @ @ disk _ failure _ policy : stop <nl> # ignore : ignore fatal errors and let the batches fail <nl> commit _ failure _ policy : stop <nl> <nl> + # Maximum size of the native protocol prepared statement cache <nl> + # <nl> + # Valid values are either " auto " ( omitting the value ) or a value greater 0 . <nl> + # <nl> + # Note that specifying a too large value will result in long running GCs and possbily <nl> + # out - of - memory errors . Keep the value at a small fraction of the heap . <nl> + # <nl> + # If you constantly see " prepared statements discarded in the last minute because <nl> + # cache limit reached " messages , the first step is to investigate the root cause <nl> + # of these messages and check whether prepared statements are used correctly - <nl> + # i . e . use bind markers for variable parts . <nl> + # <nl> + # Do only change the default value , if you really have more prepared statements than <nl> + # fit in the cache . In most cases it is not neccessary to change this value . <nl> + # Constantly re - preparing statements is a performance penalty . <nl> + # <nl> + # Default value ( " auto " ) is 1 / 256th of the heap or 10MB , whichever is greater <nl> + prepared _ statements _ cache _ size _ mb : <nl> + <nl> + # Maximum size of the Thrift prepared statement cache <nl> + # <nl> + # If you do not use Thrift at all , it is safe to leave this value at " auto " . <nl> + # <nl> + # See description of ' prepared _ statements _ cache _ size _ mb ' above for more information . <nl> + # <nl> + # Default value ( " auto " ) is 1 / 256th of the heap or 10MB , whichever is greater <nl> + thrift _ prepared _ statements _ cache _ size _ mb : <nl> + <nl> # Maximum size of the key cache in memory . <nl> # <nl> # Each key cache hit saves 1 seek and each row cache hit saves 2 seeks at the <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 809966d . . 02635bf 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 288 , 6 + 288 , 17 @ @ public class Config <nl> <nl> public int windows _ timer _ interval = 0 ; <nl> <nl> + / * * <nl> + * Size of the CQL prepared statements cache in MB . <nl> + * Defaults to 1 / 256th of the heap size or 10MB , whichever is greater . <nl> + * / <nl> + public Long prepared _ statements _ cache _ size _ mb = null ; <nl> + / * * <nl> + * Size of the Thrift prepared statements cache in MB . <nl> + * Defaults to 1 / 256th of the heap size or 10MB , whichever is greater . <nl> + * / <nl> + public Long thrift _ prepared _ statements _ cache _ size _ mb = null ; <nl> + <nl> public boolean enable _ user _ defined _ functions = false ; <nl> public boolean enable _ scripted _ user _ defined _ functions = false ; <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index b98d103 . . d8acdb8 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 96 , 6 + 96 , 9 @ @ public class DatabaseDescriptor <nl> private static RequestSchedulerId requestSchedulerId ; <nl> private static RequestSchedulerOptions requestSchedulerOptions ; <nl> <nl> + private static long preparedStatementsCacheSizeInMB ; <nl> + private static long thriftPreparedStatementsCacheSizeInMB ; <nl> + <nl> private static long keyCacheSizeInMB ; <nl> private static long counterCacheSizeInMB ; <nl> private static long indexSummaryCapacityInMB ; <nl> @ @ - 641 , 6 + 644 , 38 @ @ public class DatabaseDescriptor <nl> <nl> try <nl> { <nl> + / / if prepared _ statements _ cache _ size _ mb option was set to " auto " then size of the cache should be " max ( 1 / 256 of Heap ( in MB ) , 10MB ) " <nl> + preparedStatementsCacheSizeInMB = ( conf . prepared _ statements _ cache _ size _ mb = = null ) <nl> + ? Math . max ( 10 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 1024 / 1024 / 256 ) ) <nl> + : conf . prepared _ statements _ cache _ size _ mb ; <nl> + <nl> + if ( preparedStatementsCacheSizeInMB < = 0 ) <nl> + throw new NumberFormatException ( ) ; / / to escape duplicating error message <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ConfigurationException ( " prepared _ statements _ cache _ size _ mb option was set incorrectly to ' " <nl> + + conf . prepared _ statements _ cache _ size _ mb + " ' , supported values are < integer > > = 0 . " , false ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / if thrift _ prepared _ statements _ cache _ size _ mb option was set to " auto " then size of the cache should be " max ( 1 / 256 of Heap ( in MB ) , 10MB ) " <nl> + thriftPreparedStatementsCacheSizeInMB = ( conf . thrift _ prepared _ statements _ cache _ size _ mb = = null ) <nl> + ? Math . max ( 10 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 1024 / 1024 / 256 ) ) <nl> + : conf . thrift _ prepared _ statements _ cache _ size _ mb ; <nl> + <nl> + if ( thriftPreparedStatementsCacheSizeInMB < = 0 ) <nl> + throw new NumberFormatException ( ) ; / / to escape duplicating error message <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new ConfigurationException ( " thrift _ prepared _ statements _ cache _ size _ mb option was set incorrectly to ' " <nl> + + conf . thrift _ prepared _ statements _ cache _ size _ mb + " ' , supported values are < integer > > = 0 . " , false ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> / / if key _ cache _ size _ in _ mb option was set to " auto " then size of the cache should be " min ( 5 % of Heap ( in MB ) , 100MB ) <nl> keyCacheSizeInMB = ( conf . key _ cache _ size _ in _ mb = = null ) <nl> ? Math . min ( Math . max ( 1 , ( int ) ( Runtime . getRuntime ( ) . totalMemory ( ) * 0 . 05 / 1024 / 1024 ) ) , 100 ) <nl> @ @ - 1992 , 6 + 2027 , 16 @ @ public class DatabaseDescriptor <nl> return conf . windows _ timer _ interval ; <nl> } <nl> <nl> + public static long getPreparedStatementsCacheSizeMB ( ) <nl> + { <nl> + return preparedStatementsCacheSizeInMB ; <nl> + } <nl> + <nl> + public static long getThriftPreparedStatementsCacheSizeMB ( ) <nl> + { <nl> + return thriftPreparedStatementsCacheSizeInMB ; <nl> + } <nl> + <nl> public static boolean enableUserDefinedFunctions ( ) <nl> { <nl> return conf . enable _ user _ defined _ functions ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 5f4b0f6 . . 39a9c03 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 34 , 9 + 34 , 9 @ @ import org . slf4j . LoggerFactory ; <nl> <nl> import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; <nl> import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; <nl> - import com . googlecode . concurrentlinkedhashmap . EvictionListener ; <nl> import org . antlr . runtime . * ; <nl> import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . cql3 . functions . Function ; <nl> import org . apache . cassandra . cql3 . functions . FunctionName ; <nl> @ @ - 65 , 7 + 65 , 6 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; <nl> private static final MemoryMeter meter = new MemoryMeter ( ) . withGuessing ( MemoryMeter . Guess . FALLBACK _ BEST ) . ignoreKnownSingletons ( ) ; <nl> - private static final long MAX _ CACHE _ PREPARED _ MEMORY = Runtime . getRuntime ( ) . maxMemory ( ) / 256 ; <nl> <nl> private static final EntryWeigher < MD5Digest , ParsedStatement . Prepared > cqlMemoryUsageWeigher = new EntryWeigher < MD5Digest , ParsedStatement . Prepared > ( ) <nl> { <nl> @ @ - 97 , 45 + 96 , 48 @ @ public class QueryProcessor implements QueryHandler <nl> public static final CQLMetrics metrics = new CQLMetrics ( ) ; <nl> <nl> private static final AtomicInteger lastMinuteEvictionsCount = new AtomicInteger ( 0 ) ; <nl> + private static final AtomicInteger thriftLastMinuteEvictionsCount = new AtomicInteger ( 0 ) ; <nl> <nl> static <nl> { <nl> preparedStatements = new ConcurrentLinkedHashMap . Builder < MD5Digest , ParsedStatement . Prepared > ( ) <nl> - . maximumWeightedCapacity ( MAX _ CACHE _ PREPARED _ MEMORY ) <nl> + . maximumWeightedCapacity ( capacityToBytes ( DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ) <nl> . weigher ( cqlMemoryUsageWeigher ) <nl> - . listener ( new EvictionListener < MD5Digest , ParsedStatement . Prepared > ( ) <nl> - { <nl> - public void onEviction ( MD5Digest md5Digest , ParsedStatement . Prepared prepared ) <nl> - { <nl> - metrics . preparedStatementsEvicted . inc ( ) ; <nl> - lastMinuteEvictionsCount . incrementAndGet ( ) ; <nl> - } <nl> + . listener ( ( md5Digest , prepared ) - > { <nl> + metrics . preparedStatementsEvicted . inc ( ) ; <nl> + lastMinuteEvictionsCount . incrementAndGet ( ) ; <nl> } ) . build ( ) ; <nl> <nl> thriftPreparedStatements = new ConcurrentLinkedHashMap . Builder < Integer , ParsedStatement . Prepared > ( ) <nl> - . maximumWeightedCapacity ( MAX _ CACHE _ PREPARED _ MEMORY ) <nl> + . maximumWeightedCapacity ( capacityToBytes ( DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ) <nl> . weigher ( thriftMemoryUsageWeigher ) <nl> - . listener ( new EvictionListener < Integer , ParsedStatement . Prepared > ( ) <nl> - { <nl> - public void onEviction ( Integer integer , ParsedStatement . Prepared prepared ) <nl> - { <nl> - metrics . preparedStatementsEvicted . inc ( ) ; <nl> - lastMinuteEvictionsCount . incrementAndGet ( ) ; <nl> - } <nl> + . listener ( ( integer , prepared ) - > { <nl> + metrics . preparedStatementsEvicted . inc ( ) ; <nl> + thriftLastMinuteEvictionsCount . incrementAndGet ( ) ; <nl> } ) <nl> . build ( ) ; <nl> <nl> - ScheduledExecutors . scheduledTasks . scheduleAtFixedRate ( new Runnable ( ) <nl> - { <nl> - public void run ( ) <nl> - { <nl> - long count = lastMinuteEvictionsCount . getAndSet ( 0 ) ; <nl> - if ( count > 0 ) <nl> - logger . info ( " { } prepared statements discarded in the last minute because cache limit reached ( { } ) " , <nl> - count , <nl> - FBUtilities . prettyPrintMemory ( MAX _ CACHE _ PREPARED _ MEMORY ) ) ; <nl> - } <nl> + ScheduledExecutors . scheduledTasks . scheduleAtFixedRate ( ( ) - > { <nl> + long count = lastMinuteEvictionsCount . getAndSet ( 0 ) ; <nl> + if ( count > 0 ) <nl> + logger . warn ( " { } prepared statements discarded in the last minute because cache limit reached ( { } MB ) " , <nl> + count , <nl> + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ; <nl> + count = thriftLastMinuteEvictionsCount . getAndSet ( 0 ) ; <nl> + if ( count > 0 ) <nl> + logger . warn ( " { } prepared Thrift statements discarded in the last minute because cache limit reached ( { } MB ) " , <nl> + count , <nl> + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ; <nl> } , 1 , 1 , TimeUnit . MINUTES ) ; <nl> + <nl> + logger . info ( " Initialized prepared statement caches with { } MB ( native ) and { } MB ( Thrift ) " , <nl> + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) , <nl> + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ; <nl> + } <nl> + <nl> + private static long capacityToBytes ( long cacheSizeMB ) <nl> + { <nl> + return cacheSizeMB * 1024 * 1024 ; <nl> } <nl> <nl> public static int preparedStatementsCount ( ) <nl> @ @ - 428 , 18 + 430 , 24 @ @ public class QueryProcessor implements QueryHandler <nl> / / ( if the keyspace is null , queryString has to have a fully - qualified keyspace so it ' s fine . <nl> long statementSize = measure ( prepared . statement ) ; <nl> / / don ' t execute the statement if it ' s bigger than the allowed threshold <nl> - if ( statementSize > MAX _ CACHE _ PREPARED _ MEMORY ) <nl> - throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d bytes . " , <nl> - statementSize , <nl> - MAX _ CACHE _ PREPARED _ MEMORY ) ) ; <nl> if ( forThrift ) <nl> { <nl> + if ( statementSize > capacityToBytes ( DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ) <nl> + throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d MB : % s . . . " , <nl> + statementSize , <nl> + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) , <nl> + queryString . substring ( 0 , 200 ) ) ) ; <nl> Integer statementId = computeThriftId ( queryString , keyspace ) ; <nl> thriftPreparedStatements . put ( statementId , prepared ) ; <nl> return ResultMessage . Prepared . forThrift ( statementId , prepared . boundNames ) ; <nl> } <nl> else <nl> { <nl> + if ( statementSize > capacityToBytes ( DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ) <nl> + throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d MB : % s . . . " , <nl> + statementSize , <nl> + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) , <nl> + queryString . substring ( 0 , 200 ) ) ) ; <nl> MD5Digest statementId = computeId ( queryString , keyspace ) ; <nl> preparedStatements . put ( statementId , prepared ) ; <nl> return new ResultMessage . Prepared ( statementId , prepared ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2192fe9 . . c2a55df 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> * Fix potential AssertionError during tracing ( CASSANDRA - 6041 ) <nl> * Fix NPE in sstablesplit ( CASSANDRA - 6027 ) <nl> Merged from 1 . 2 : <nl> + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) <nl> * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) <nl> * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) <nl> * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 4decf6c . . df4501e 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 238 , 6 + 238 , 10 @ @ seed _ provider : <nl> concurrent _ reads : 32 <nl> concurrent _ writes : 32 <nl> <nl> + # Total memory to use for sstable - reading buffers . Defaults to <nl> + # the smaller of 1 / 4 of heap or 512MB . <nl> + # file _ cache _ size _ in _ mb : 512 <nl> + <nl> # Total memory to use for memtables . Cassandra will flush the largest <nl> # memtable when this much memory is used . <nl> # If omitted , Cassandra will set it to 1 / 3 of the heap . <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index dd0728c . . 0414269 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 167 , 12 + 167 , 14 @ @ public class Config <nl> public String memory _ allocator = NativeAllocator . class . getSimpleName ( ) ; <nl> public boolean populate _ io _ cache _ on _ flush = false ; <nl> <nl> - public boolean inter _ dc _ tcp _ nodelay = false ; <nl> - <nl> private static boolean isClientMode = false ; <nl> <nl> public boolean preheat _ kernel _ page _ cache = false ; <nl> <nl> + public Integer file _ cache _ size _ in _ mb ; <nl> + <nl> + public boolean inter _ dc _ tcp _ nodelay = true ; <nl> + <nl> public String memtable _ allocator = " SlabAllocator " ; <nl> <nl> private static boolean outboundBindAny = false ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index c2f3fa6 . . b3eeca6 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 245 , 6 + 245 , 9 @ @ public class DatabaseDescriptor <nl> throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; <nl> } <nl> <nl> + if ( conf . file _ cache _ size _ in _ mb = = null ) <nl> + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; <nl> + <nl> if ( conf . memtable _ total _ space _ in _ mb = = null ) <nl> conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; <nl> if ( conf . memtable _ total _ space _ in _ mb < = 0 ) <nl> @ @ - 1137 , 6 + 1140 , 11 @ @ public class DatabaseDescriptor <nl> return conf . memtable _ flush _ queue _ size ; <nl> } <nl> <nl> + public static int getFileCacheSizeInMB ( ) <nl> + { <nl> + return conf . file _ cache _ size _ in _ mb ; <nl> + } <nl> + <nl> public static int getTotalMemtableSpaceInMB ( ) <nl> { <nl> / / should only be called if estimatesRealMemtableSize ( ) is true <nl> diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> index 4173d5a . . 892611c 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java <nl> @ @ - 17 , 13 + 17 , 10 @ @ <nl> * / <nl> package org . apache . cassandra . io . util ; <nl> <nl> - import java . util . Queue ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> <nl> public abstract class PoolingSegmentedFile extends SegmentedFile <nl> { <nl> - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> - <nl> protected PoolingSegmentedFile ( String path , long length ) <nl> { <nl> super ( path , length ) ; <nl> @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public FileDataInput getSegment ( long position ) <nl> { <nl> - RandomAccessReader reader = pool . poll ( ) ; <nl> + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; <nl> + <nl> if ( reader = = null ) <nl> reader = createReader ( path ) ; <nl> + <nl> reader . seek ( position ) ; <nl> return reader ; <nl> } <nl> @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile <nl> <nl> public void recycle ( RandomAccessReader reader ) <nl> { <nl> - pool . add ( reader ) ; <nl> + FileCacheService . instance . put ( reader ) ; <nl> } <nl> <nl> public void cleanup ( ) <nl> { <nl> - for ( RandomAccessReader reader : pool ) <nl> - reader . deallocate ( ) ; <nl> + FileCacheService . instance . invalidate ( path ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> index bcf6ae3 . . 4ceb3c4 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java <nl> @ @ - 152 , 6 + 152 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu <nl> return filePath ; <nl> } <nl> <nl> + public int getBufferSize ( ) <nl> + { <nl> + return buffer . length ; <nl> + } <nl> + <nl> public void reset ( ) <nl> { <nl> seek ( markedPointer ) ; <nl> diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> new file mode 100644 <nl> index 0000000 . . 9b21de6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java <nl> @ @ - 0 , 0 + 1 , 64 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . yammer . metrics . Metrics ; <nl> + import com . yammer . metrics . core . Gauge ; <nl> + import com . yammer . metrics . core . Meter ; <nl> + import com . yammer . metrics . core . MetricName ; <nl> + import com . yammer . metrics . util . RatioGauge ; <nl> + import org . apache . cassandra . service . FileCacheService ; <nl> + <nl> + public class FileCacheMetrics <nl> + { <nl> + / * * Total number of hits * / <nl> + public final Meter hits ; <nl> + / * * Total number of requests * / <nl> + public final Meter requests ; <nl> + / * * hit rate * / <nl> + public final Gauge < Double > hitRate ; <nl> + / * * Total size of file cache , in bytes * / <nl> + public final Gauge < Long > size ; <nl> + <nl> + public FileCacheMetrics ( ) <nl> + { <nl> + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; <nl> + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; <nl> + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) <nl> + { <nl> + protected double getNumerator ( ) <nl> + { <nl> + return hits . count ( ) ; <nl> + } <nl> + <nl> + protected double getDenominator ( ) <nl> + { <nl> + return requests . count ( ) ; <nl> + } <nl> + } ) ; <nl> + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) <nl> + { <nl> + public Long value ( ) <nl> + { <nl> + return FileCacheService . instance . sizeInBytes ( ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> new file mode 100644 <nl> index 0000000 . . 9dd1b15 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / service / FileCacheService . java <nl> @ @ - 0 , 0 + 1 , 139 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . service ; <nl> + <nl> + import java . util . Queue ; <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ConcurrentLinkedQueue ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . google . common . cache . Cache ; <nl> + import com . google . common . cache . CacheBuilder ; <nl> + import com . google . common . cache . RemovalListener ; <nl> + import com . google . common . cache . RemovalNotification ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . io . util . RandomAccessReader ; <nl> + import org . apache . cassandra . metrics . FileCacheMetrics ; <nl> + <nl> + public class FileCacheService <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; <nl> + <nl> + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; <nl> + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis <nl> + <nl> + public static FileCacheService instance = new FileCacheService ( ) ; <nl> + <nl> + private final Cache < String , Queue < RandomAccessReader > > cache ; <nl> + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; <nl> + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public Queue < RandomAccessReader > call ( ) throws Exception <nl> + { <nl> + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + protected FileCacheService ( ) <nl> + { <nl> + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) <nl> + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) <nl> + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) <nl> + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) <nl> + { <nl> + @ Override <nl> + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) <nl> + { <nl> + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; <nl> + <nl> + if ( cachedInstances = = null ) <nl> + return ; <nl> + <nl> + for ( RandomAccessReader reader : cachedInstances ) <nl> + reader . deallocate ( ) ; <nl> + } <nl> + } ) <nl> + . build ( ) ; <nl> + } <nl> + <nl> + public RandomAccessReader get ( String path ) <nl> + { <nl> + metrics . requests . mark ( ) ; <nl> + <nl> + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; <nl> + <nl> + if ( instances = = null ) <nl> + return null ; <nl> + <nl> + RandomAccessReader result = instances . poll ( ) ; <nl> + <nl> + if ( result ! = null ) <nl> + metrics . hits . mark ( ) ; <nl> + <nl> + return result ; <nl> + } <nl> + <nl> + private Queue < RandomAccessReader > getCacheFor ( String path ) <nl> + { <nl> + try <nl> + { <nl> + return cache . get ( path , cacheForPathCreator ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + / / if something bad happened , let ' s just carry on and return null <nl> + / / as dysfunctional queue should not interrupt normal operation <nl> + logger . debug ( " Exception fetching cache " , e ) ; <nl> + } <nl> + <nl> + return null ; <nl> + } <nl> + <nl> + public void put ( RandomAccessReader instance ) <nl> + { <nl> + / / This wouldn ' t be precise sometimes when CRAR is used because <nl> + / / there is a way for users to dynamically change the size of the buffer , <nl> + / / but we don ' t expect that to happen frequently in production . <nl> + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . <nl> + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; <nl> + <nl> + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) <nl> + instance . deallocate ( ) ; <nl> + else <nl> + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; <nl> + } <nl> + <nl> + public void invalidate ( String path ) <nl> + { <nl> + cache . invalidate ( path ) ; <nl> + } <nl> + <nl> + public long sizeInBytes ( ) <nl> + { <nl> + long n = 0 ; <nl> + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) <nl> + for ( RandomAccessReader reader : queue ) <nl> + n + = reader . getBufferSize ( ) ; <nl> + return n ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c49249c . . c802031 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 6 
 + * Make prepared statement cache size configurable ( CASSANDRA - 11555 ) 
 * Integrated JMX authentication and authorization ( CASSANDRA - 10091 ) 
 * Add units to stress ouput ( CASSANDRA - 11352 ) 
 * Fix PER PARTITION LIMIT for single and multi partitions queries ( CASSANDRA - 11603 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 48bad2c . . 9eb55e1 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 215 , 6 + 215 , 34 @ @ disk _ failure _ policy : stop 
 # ignore : ignore fatal errors and let the batches fail 
 commit _ failure _ policy : stop 
 
 + # Maximum size of the native protocol prepared statement cache 
 + # 
 + # Valid values are either " auto " ( omitting the value ) or a value greater 0 . 
 + # 
 + # Note that specifying a too large value will result in long running GCs and possbily 
 + # out - of - memory errors . Keep the value at a small fraction of the heap . 
 + # 
 + # If you constantly see " prepared statements discarded in the last minute because 
 + # cache limit reached " messages , the first step is to investigate the root cause 
 + # of these messages and check whether prepared statements are used correctly - 
 + # i . e . use bind markers for variable parts . 
 + # 
 + # Do only change the default value , if you really have more prepared statements than 
 + # fit in the cache . In most cases it is not neccessary to change this value . 
 + # Constantly re - preparing statements is a performance penalty . 
 + # 
 + # Default value ( " auto " ) is 1 / 256th of the heap or 10MB , whichever is greater 
 + prepared _ statements _ cache _ size _ mb : 
 + 
 + # Maximum size of the Thrift prepared statement cache 
 + # 
 + # If you do not use Thrift at all , it is safe to leave this value at " auto " . 
 + # 
 + # See description of ' prepared _ statements _ cache _ size _ mb ' above for more information . 
 + # 
 + # Default value ( " auto " ) is 1 / 256th of the heap or 10MB , whichever is greater 
 + thrift _ prepared _ statements _ cache _ size _ mb : 
 + 
 # Maximum size of the key cache in memory . 
 # 
 # Each key cache hit saves 1 seek and each row cache hit saves 2 seeks at the 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 809966d . . 02635bf 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 288 , 6 + 288 , 17 @ @ public class Config 
 
 public int windows _ timer _ interval = 0 ; 
 
 + / * * 
 + * Size of the CQL prepared statements cache in MB . 
 + * Defaults to 1 / 256th of the heap size or 10MB , whichever is greater . 
 + * / 
 + public Long prepared _ statements _ cache _ size _ mb = null ; 
 + / * * 
 + * Size of the Thrift prepared statements cache in MB . 
 + * Defaults to 1 / 256th of the heap size or 10MB , whichever is greater . 
 + * / 
 + public Long thrift _ prepared _ statements _ cache _ size _ mb = null ; 
 + 
 public boolean enable _ user _ defined _ functions = false ; 
 public boolean enable _ scripted _ user _ defined _ functions = false ; 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index b98d103 . . d8acdb8 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 96 , 6 + 96 , 9 @ @ public class DatabaseDescriptor 
 private static RequestSchedulerId requestSchedulerId ; 
 private static RequestSchedulerOptions requestSchedulerOptions ; 
 
 + private static long preparedStatementsCacheSizeInMB ; 
 + private static long thriftPreparedStatementsCacheSizeInMB ; 
 + 
 private static long keyCacheSizeInMB ; 
 private static long counterCacheSizeInMB ; 
 private static long indexSummaryCapacityInMB ; 
 @ @ - 641 , 6 + 644 , 38 @ @ public class DatabaseDescriptor 
 
 try 
 { 
 + / / if prepared _ statements _ cache _ size _ mb option was set to " auto " then size of the cache should be " max ( 1 / 256 of Heap ( in MB ) , 10MB ) " 
 + preparedStatementsCacheSizeInMB = ( conf . prepared _ statements _ cache _ size _ mb = = null ) 
 + ? Math . max ( 10 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 1024 / 1024 / 256 ) ) 
 + : conf . prepared _ statements _ cache _ size _ mb ; 
 + 
 + if ( preparedStatementsCacheSizeInMB < = 0 ) 
 + throw new NumberFormatException ( ) ; / / to escape duplicating error message 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ConfigurationException ( " prepared _ statements _ cache _ size _ mb option was set incorrectly to ' " 
 + + conf . prepared _ statements _ cache _ size _ mb + " ' , supported values are < integer > > = 0 . " , false ) ; 
 + } 
 + 
 + try 
 + { 
 + / / if thrift _ prepared _ statements _ cache _ size _ mb option was set to " auto " then size of the cache should be " max ( 1 / 256 of Heap ( in MB ) , 10MB ) " 
 + thriftPreparedStatementsCacheSizeInMB = ( conf . thrift _ prepared _ statements _ cache _ size _ mb = = null ) 
 + ? Math . max ( 10 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / 1024 / 1024 / 256 ) ) 
 + : conf . thrift _ prepared _ statements _ cache _ size _ mb ; 
 + 
 + if ( thriftPreparedStatementsCacheSizeInMB < = 0 ) 
 + throw new NumberFormatException ( ) ; / / to escape duplicating error message 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new ConfigurationException ( " thrift _ prepared _ statements _ cache _ size _ mb option was set incorrectly to ' " 
 + + conf . thrift _ prepared _ statements _ cache _ size _ mb + " ' , supported values are < integer > > = 0 . " , false ) ; 
 + } 
 + 
 + try 
 + { 
 / / if key _ cache _ size _ in _ mb option was set to " auto " then size of the cache should be " min ( 5 % of Heap ( in MB ) , 100MB ) 
 keyCacheSizeInMB = ( conf . key _ cache _ size _ in _ mb = = null ) 
 ? Math . min ( Math . max ( 1 , ( int ) ( Runtime . getRuntime ( ) . totalMemory ( ) * 0 . 05 / 1024 / 1024 ) ) , 100 ) 
 @ @ - 1992 , 6 + 2027 , 16 @ @ public class DatabaseDescriptor 
 return conf . windows _ timer _ interval ; 
 } 
 
 + public static long getPreparedStatementsCacheSizeMB ( ) 
 + { 
 + return preparedStatementsCacheSizeInMB ; 
 + } 
 + 
 + public static long getThriftPreparedStatementsCacheSizeMB ( ) 
 + { 
 + return thriftPreparedStatementsCacheSizeInMB ; 
 + } 
 + 
 public static boolean enableUserDefinedFunctions ( ) 
 { 
 return conf . enable _ user _ defined _ functions ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 5f4b0f6 . . 39a9c03 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 34 , 9 + 34 , 9 @ @ import org . slf4j . LoggerFactory ; 
 
 import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; 
 import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; 
 - import com . googlecode . concurrentlinkedhashmap . EvictionListener ; 
 import org . antlr . runtime . * ; 
 import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . cql3 . functions . Function ; 
 import org . apache . cassandra . cql3 . functions . FunctionName ; 
 @ @ - 65 , 7 + 65 , 6 @ @ public class QueryProcessor implements QueryHandler 
 
 private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; 
 private static final MemoryMeter meter = new MemoryMeter ( ) . withGuessing ( MemoryMeter . Guess . FALLBACK _ BEST ) . ignoreKnownSingletons ( ) ; 
 - private static final long MAX _ CACHE _ PREPARED _ MEMORY = Runtime . getRuntime ( ) . maxMemory ( ) / 256 ; 
 
 private static final EntryWeigher < MD5Digest , ParsedStatement . Prepared > cqlMemoryUsageWeigher = new EntryWeigher < MD5Digest , ParsedStatement . Prepared > ( ) 
 { 
 @ @ - 97 , 45 + 96 , 48 @ @ public class QueryProcessor implements QueryHandler 
 public static final CQLMetrics metrics = new CQLMetrics ( ) ; 
 
 private static final AtomicInteger lastMinuteEvictionsCount = new AtomicInteger ( 0 ) ; 
 + private static final AtomicInteger thriftLastMinuteEvictionsCount = new AtomicInteger ( 0 ) ; 
 
 static 
 { 
 preparedStatements = new ConcurrentLinkedHashMap . Builder < MD5Digest , ParsedStatement . Prepared > ( ) 
 - . maximumWeightedCapacity ( MAX _ CACHE _ PREPARED _ MEMORY ) 
 + . maximumWeightedCapacity ( capacityToBytes ( DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ) 
 . weigher ( cqlMemoryUsageWeigher ) 
 - . listener ( new EvictionListener < MD5Digest , ParsedStatement . Prepared > ( ) 
 - { 
 - public void onEviction ( MD5Digest md5Digest , ParsedStatement . Prepared prepared ) 
 - { 
 - metrics . preparedStatementsEvicted . inc ( ) ; 
 - lastMinuteEvictionsCount . incrementAndGet ( ) ; 
 - } 
 + . listener ( ( md5Digest , prepared ) - > { 
 + metrics . preparedStatementsEvicted . inc ( ) ; 
 + lastMinuteEvictionsCount . incrementAndGet ( ) ; 
 } ) . build ( ) ; 
 
 thriftPreparedStatements = new ConcurrentLinkedHashMap . Builder < Integer , ParsedStatement . Prepared > ( ) 
 - . maximumWeightedCapacity ( MAX _ CACHE _ PREPARED _ MEMORY ) 
 + . maximumWeightedCapacity ( capacityToBytes ( DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ) 
 . weigher ( thriftMemoryUsageWeigher ) 
 - . listener ( new EvictionListener < Integer , ParsedStatement . Prepared > ( ) 
 - { 
 - public void onEviction ( Integer integer , ParsedStatement . Prepared prepared ) 
 - { 
 - metrics . preparedStatementsEvicted . inc ( ) ; 
 - lastMinuteEvictionsCount . incrementAndGet ( ) ; 
 - } 
 + . listener ( ( integer , prepared ) - > { 
 + metrics . preparedStatementsEvicted . inc ( ) ; 
 + thriftLastMinuteEvictionsCount . incrementAndGet ( ) ; 
 } ) 
 . build ( ) ; 
 
 - ScheduledExecutors . scheduledTasks . scheduleAtFixedRate ( new Runnable ( ) 
 - { 
 - public void run ( ) 
 - { 
 - long count = lastMinuteEvictionsCount . getAndSet ( 0 ) ; 
 - if ( count > 0 ) 
 - logger . info ( " { } prepared statements discarded in the last minute because cache limit reached ( { } ) " , 
 - count , 
 - FBUtilities . prettyPrintMemory ( MAX _ CACHE _ PREPARED _ MEMORY ) ) ; 
 - } 
 + ScheduledExecutors . scheduledTasks . scheduleAtFixedRate ( ( ) - > { 
 + long count = lastMinuteEvictionsCount . getAndSet ( 0 ) ; 
 + if ( count > 0 ) 
 + logger . warn ( " { } prepared statements discarded in the last minute because cache limit reached ( { } MB ) " , 
 + count , 
 + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ; 
 + count = thriftLastMinuteEvictionsCount . getAndSet ( 0 ) ; 
 + if ( count > 0 ) 
 + logger . warn ( " { } prepared Thrift statements discarded in the last minute because cache limit reached ( { } MB ) " , 
 + count , 
 + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ; 
 } , 1 , 1 , TimeUnit . MINUTES ) ; 
 + 
 + logger . info ( " Initialized prepared statement caches with { } MB ( native ) and { } MB ( Thrift ) " , 
 + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) , 
 + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ; 
 + } 
 + 
 + private static long capacityToBytes ( long cacheSizeMB ) 
 + { 
 + return cacheSizeMB * 1024 * 1024 ; 
 } 
 
 public static int preparedStatementsCount ( ) 
 @ @ - 428 , 18 + 430 , 24 @ @ public class QueryProcessor implements QueryHandler 
 / / ( if the keyspace is null , queryString has to have a fully - qualified keyspace so it ' s fine . 
 long statementSize = measure ( prepared . statement ) ; 
 / / don ' t execute the statement if it ' s bigger than the allowed threshold 
 - if ( statementSize > MAX _ CACHE _ PREPARED _ MEMORY ) 
 - throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d bytes . " , 
 - statementSize , 
 - MAX _ CACHE _ PREPARED _ MEMORY ) ) ; 
 if ( forThrift ) 
 { 
 + if ( statementSize > capacityToBytes ( DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) ) ) 
 + throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d MB : % s . . . " , 
 + statementSize , 
 + DatabaseDescriptor . getThriftPreparedStatementsCacheSizeMB ( ) , 
 + queryString . substring ( 0 , 200 ) ) ) ; 
 Integer statementId = computeThriftId ( queryString , keyspace ) ; 
 thriftPreparedStatements . put ( statementId , prepared ) ; 
 return ResultMessage . Prepared . forThrift ( statementId , prepared . boundNames ) ; 
 } 
 else 
 { 
 + if ( statementSize > capacityToBytes ( DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) ) ) 
 + throw new InvalidRequestException ( String . format ( " Prepared statement of size % d bytes is larger than allowed maximum of % d MB : % s . . . " , 
 + statementSize , 
 + DatabaseDescriptor . getPreparedStatementsCacheSizeMB ( ) , 
 + queryString . substring ( 0 , 200 ) ) ) ; 
 MD5Digest statementId = computeId ( queryString , keyspace ) ; 
 preparedStatements . put ( statementId , prepared ) ; 
 return new ResultMessage . Prepared ( statementId , prepared ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2192fe9 . . c2a55df 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 * Fix potential AssertionError during tracing ( CASSANDRA - 6041 ) 
 * Fix NPE in sstablesplit ( CASSANDRA - 6027 ) 
 Merged from 1 . 2 : 
 + * add file _ cache _ size _ in _ mb setting ( CASSANDRA - 5661 ) 
 * Tuning knobs for dealing with large blobs and many CFs ( CASSANDRA - 5982 ) 
 * ( Hadoop ) Fix CQLRW for thrift tables ( CASSANDRA - 6002 ) 
 * Fix possible divide - by - zero in HHOM ( CASSANDRA - 5990 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 4decf6c . . df4501e 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 238 , 6 + 238 , 10 @ @ seed _ provider : 
 concurrent _ reads : 32 
 concurrent _ writes : 32 
 
 + # Total memory to use for sstable - reading buffers . Defaults to 
 + # the smaller of 1 / 4 of heap or 512MB . 
 + # file _ cache _ size _ in _ mb : 512 
 + 
 # Total memory to use for memtables . Cassandra will flush the largest 
 # memtable when this much memory is used . 
 # If omitted , Cassandra will set it to 1 / 3 of the heap . 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index dd0728c . . 0414269 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 167 , 12 + 167 , 14 @ @ public class Config 
 public String memory _ allocator = NativeAllocator . class . getSimpleName ( ) ; 
 public boolean populate _ io _ cache _ on _ flush = false ; 
 
 - public boolean inter _ dc _ tcp _ nodelay = false ; 
 - 
 private static boolean isClientMode = false ; 
 
 public boolean preheat _ kernel _ page _ cache = false ; 
 
 + public Integer file _ cache _ size _ in _ mb ; 
 + 
 + public boolean inter _ dc _ tcp _ nodelay = true ; 
 + 
 public String memtable _ allocator = " SlabAllocator " ; 
 
 private static boolean outboundBindAny = false ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index c2f3fa6 . . b3eeca6 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 245 , 6 + 245 , 9 @ @ public class DatabaseDescriptor 
 throw new ConfigurationException ( " concurrent _ replicates must be at least 2 " ) ; 
 } 
 
 + if ( conf . file _ cache _ size _ in _ mb = = null ) 
 + conf . file _ cache _ size _ in _ mb = Math . min ( 512 , ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 4 * 1048576 ) ) ) ; 
 + 
 if ( conf . memtable _ total _ space _ in _ mb = = null ) 
 conf . memtable _ total _ space _ in _ mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( 3 * 1048576 ) ) ; 
 if ( conf . memtable _ total _ space _ in _ mb < = 0 ) 
 @ @ - 1137 , 6 + 1140 , 11 @ @ public class DatabaseDescriptor 
 return conf . memtable _ flush _ queue _ size ; 
 } 
 
 + public static int getFileCacheSizeInMB ( ) 
 + { 
 + return conf . file _ cache _ size _ in _ mb ; 
 + } 
 + 
 public static int getTotalMemtableSpaceInMB ( ) 
 { 
 / / should only be called if estimatesRealMemtableSize ( ) is true 
 diff - - git a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 index 4173d5a . . 892611c 100644 
 - - - a / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 + + + b / src / java / org / apache / cassandra / io / util / PoolingSegmentedFile . java 
 @ @ - 17 , 13 + 17 , 10 @ @ 
 * / 
 package org . apache . cassandra . io . util ; 
 
 - import java . util . Queue ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 
 public abstract class PoolingSegmentedFile extends SegmentedFile 
 { 
 - public final Queue < RandomAccessReader > pool = new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 - 
 protected PoolingSegmentedFile ( String path , long length ) 
 { 
 super ( path , length ) ; 
 @ @ - 36 , 9 + 33 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public FileDataInput getSegment ( long position ) 
 { 
 - RandomAccessReader reader = pool . poll ( ) ; 
 + RandomAccessReader reader = FileCacheService . instance . get ( path ) ; 
 + 
 if ( reader = = null ) 
 reader = createReader ( path ) ; 
 + 
 reader . seek ( position ) ; 
 return reader ; 
 } 
 @ @ - 47 , 12 + 46 , 11 @ @ public abstract class PoolingSegmentedFile extends SegmentedFile 
 
 public void recycle ( RandomAccessReader reader ) 
 { 
 - pool . add ( reader ) ; 
 + FileCacheService . instance . put ( reader ) ; 
 } 
 
 public void cleanup ( ) 
 { 
 - for ( RandomAccessReader reader : pool ) 
 - reader . deallocate ( ) ; 
 + FileCacheService . instance . invalidate ( path ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 index bcf6ae3 . . 4ceb3c4 100644 
 - - - a / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 + + + b / src / java / org / apache / cassandra / io / util / RandomAccessReader . java 
 @ @ - 152 , 6 + 152 , 11 @ @ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu 
 return filePath ; 
 } 
 
 + public int getBufferSize ( ) 
 + { 
 + return buffer . length ; 
 + } 
 + 
 public void reset ( ) 
 { 
 seek ( markedPointer ) ; 
 diff - - git a / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 new file mode 100644 
 index 0000000 . . 9b21de6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / metrics / FileCacheMetrics . java 
 @ @ - 0 , 0 + 1 , 64 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . yammer . metrics . Metrics ; 
 + import com . yammer . metrics . core . Gauge ; 
 + import com . yammer . metrics . core . Meter ; 
 + import com . yammer . metrics . core . MetricName ; 
 + import com . yammer . metrics . util . RatioGauge ; 
 + import org . apache . cassandra . service . FileCacheService ; 
 + 
 + public class FileCacheMetrics 
 + { 
 + / * * Total number of hits * / 
 + public final Meter hits ; 
 + / * * Total number of requests * / 
 + public final Meter requests ; 
 + / * * hit rate * / 
 + public final Gauge < Double > hitRate ; 
 + / * * Total size of file cache , in bytes * / 
 + public final Gauge < Long > size ; 
 + 
 + public FileCacheMetrics ( ) 
 + { 
 + hits = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Hits " ) , " hits " , TimeUnit . SECONDS ) ; 
 + requests = Metrics . newMeter ( new MetricName ( FileCacheService . class , " Requests " ) , " requests " , TimeUnit . SECONDS ) ; 
 + hitRate = Metrics . newGauge ( new MetricName ( FileCacheService . class , " HitRate " ) , new RatioGauge ( ) 
 + { 
 + protected double getNumerator ( ) 
 + { 
 + return hits . count ( ) ; 
 + } 
 + 
 + protected double getDenominator ( ) 
 + { 
 + return requests . count ( ) ; 
 + } 
 + } ) ; 
 + size = Metrics . newGauge ( new MetricName ( FileCacheService . class , " Size " ) , new Gauge < Long > ( ) 
 + { 
 + public Long value ( ) 
 + { 
 + return FileCacheService . instance . sizeInBytes ( ) ; 
 + } 
 + } ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / service / FileCacheService . java b / src / java / org / apache / cassandra / service / FileCacheService . java 
 new file mode 100644 
 index 0000000 . . 9dd1b15 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / service / FileCacheService . java 
 @ @ - 0 , 0 + 1 , 139 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . service ; 
 + 
 + import java . util . Queue ; 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ConcurrentLinkedQueue ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . google . common . cache . Cache ; 
 + import com . google . common . cache . CacheBuilder ; 
 + import com . google . common . cache . RemovalListener ; 
 + import com . google . common . cache . RemovalNotification ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . io . util . RandomAccessReader ; 
 + import org . apache . cassandra . metrics . FileCacheMetrics ; 
 + 
 + public class FileCacheService 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( FileCacheService . class ) ; 
 + 
 + private static final long MEMORY _ USAGE _ THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * 1024 * 1024 ; 
 + private static final int AFTER _ ACCESS _ EXPIRATION = 512 ; / / in millis 
 + 
 + public static FileCacheService instance = new FileCacheService ( ) ; 
 + 
 + private final Cache < String , Queue < RandomAccessReader > > cache ; 
 + private final FileCacheMetrics metrics = new FileCacheMetrics ( ) ; 
 + public final Callable < Queue < RandomAccessReader > > cacheForPathCreator = new Callable < Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public Queue < RandomAccessReader > call ( ) throws Exception 
 + { 
 + return new ConcurrentLinkedQueue < RandomAccessReader > ( ) ; 
 + } 
 + } ; 
 + 
 + protected FileCacheService ( ) 
 + { 
 + cache = CacheBuilder . < String , Queue < RandomAccessReader > > newBuilder ( ) 
 + . expireAfterAccess ( AFTER _ ACCESS _ EXPIRATION , TimeUnit . MILLISECONDS ) 
 + . concurrencyLevel ( DatabaseDescriptor . getConcurrentReaders ( ) ) 
 + . removalListener ( new RemovalListener < String , Queue < RandomAccessReader > > ( ) 
 + { 
 + @ Override 
 + public void onRemoval ( RemovalNotification < String , Queue < RandomAccessReader > > notification ) 
 + { 
 + Queue < RandomAccessReader > cachedInstances = notification . getValue ( ) ; 
 + 
 + if ( cachedInstances = = null ) 
 + return ; 
 + 
 + for ( RandomAccessReader reader : cachedInstances ) 
 + reader . deallocate ( ) ; 
 + } 
 + } ) 
 + . build ( ) ; 
 + } 
 + 
 + public RandomAccessReader get ( String path ) 
 + { 
 + metrics . requests . mark ( ) ; 
 + 
 + Queue < RandomAccessReader > instances = getCacheFor ( path ) ; 
 + 
 + if ( instances = = null ) 
 + return null ; 
 + 
 + RandomAccessReader result = instances . poll ( ) ; 
 + 
 + if ( result ! = null ) 
 + metrics . hits . mark ( ) ; 
 + 
 + return result ; 
 + } 
 + 
 + private Queue < RandomAccessReader > getCacheFor ( String path ) 
 + { 
 + try 
 + { 
 + return cache . get ( path , cacheForPathCreator ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + / / if something bad happened , let ' s just carry on and return null 
 + / / as dysfunctional queue should not interrupt normal operation 
 + logger . debug ( " Exception fetching cache " , e ) ; 
 + } 
 + 
 + return null ; 
 + } 
 + 
 + public void put ( RandomAccessReader instance ) 
 + { 
 + / / This wouldn ' t be precise sometimes when CRAR is used because 
 + / / there is a way for users to dynamically change the size of the buffer , 
 + / / but we don ' t expect that to happen frequently in production . 
 + / / Doing accounting this way also allows us to avoid atomic CAS operation on read path . 
 + long memoryUsage = ( cache . size ( ) + 1 ) * instance . getBufferSize ( ) ; 
 + 
 + if ( memoryUsage > = MEMORY _ USAGE _ THRESHOLD ) 
 + instance . deallocate ( ) ; 
 + else 
 + getCacheFor ( instance . getPath ( ) ) . add ( instance ) ; 
 + } 
 + 
 + public void invalidate ( String path ) 
 + { 
 + cache . invalidate ( path ) ; 
 + } 
 + 
 + public long sizeInBytes ( ) 
 + { 
 + long n = 0 ; 
 + for ( Queue < RandomAccessReader > queue : cache . asMap ( ) . values ( ) ) 
 + for ( RandomAccessReader reader : queue ) 
 + n + = reader . getBufferSize ( ) ; 
 + return n ; 
 + } 
 + }
