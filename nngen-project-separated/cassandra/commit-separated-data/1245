BLEU SCORE: 0.01849981860969758

TEST MSG: Properly handle static when dealing with range tombstone in backward compatibility / thrift code
GENERATED MSG: clean out unused code from MessagingService . Inline sink processing into sendOneWay instead of having another executor for that .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a53a299 . . e2d9dd7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 - rc2 <nl> + * Fix handling of static columns for range tombstones in thrift ( CASSANDRA - 10174 ) <nl> * Support empty ColumnFilter for backward compatility on empty IN ( CASSANDRA - 10471 ) <nl> * Remove Pig support ( CASSANDRA - 10542 ) <nl> * Fix LogFile throws Exception when assertion is disabled ( CASSANDRA - 10522 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index d57bc6b . . 194b6e8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 506 , 13 + 506 , 37 @ @ public abstract class LegacyLayout <nl> boolean reversed , <nl> SerializationHelper helper ) <nl> { <nl> + / / A reducer that basically does nothing , we know the 2 merged iterators can ' t have conflicting atoms ( since we merge cells with range tombstones ) . <nl> + MergeIterator . Reducer < LegacyAtom , LegacyAtom > reducer = new MergeIterator . Reducer < LegacyAtom , LegacyAtom > ( ) <nl> + { <nl> + private LegacyAtom atom ; <nl> + <nl> + public void reduce ( int idx , LegacyAtom current ) <nl> + { <nl> + / / We ' re merging cell with range tombstones , so we should always only have a single atom to reduce . <nl> + assert atom = = null ; <nl> + atom = current ; <nl> + } <nl> + <nl> + protected LegacyAtom getReduced ( ) <nl> + { <nl> + return atom ; <nl> + } <nl> + <nl> + protected void onKeyChange ( ) <nl> + { <nl> + atom = null ; <nl> + } <nl> + } ; <nl> + List < Iterator < LegacyAtom > > iterators = Arrays . asList ( asLegacyAtomIterator ( cells ) , asLegacyAtomIterator ( delInfo . inRowRangeTombstones ( ) ) ) ; <nl> + PeekingIterator < LegacyAtom > atoms = Iterators . peekingIterator ( MergeIterator . get ( iterators , legacyAtomComparator ( metadata ) , reducer ) ) ; <nl> + <nl> / / Check if we have some static <nl> - PeekingIterator < LegacyCell > iter = Iterators . peekingIterator ( cells ) ; <nl> - Row staticRow = iter . hasNext ( ) & & iter . peek ( ) . name . clustering = = Clustering . STATIC _ CLUSTERING <nl> - ? getNextRow ( CellGrouper . staticGrouper ( metadata , helper ) , iter ) <nl> + Row staticRow = atoms . hasNext ( ) & & atoms . peek ( ) . isStatic ( ) <nl> + ? getNextRow ( CellGrouper . staticGrouper ( metadata , helper ) , atoms ) <nl> : Rows . EMPTY _ STATIC _ ROW ; <nl> <nl> - Iterator < Row > rows = convertToRows ( new CellGrouper ( metadata , helper ) , iter , delInfo ) ; <nl> + Iterator < Row > rows = convertToRows ( new CellGrouper ( metadata , helper ) , atoms ) ; <nl> Iterator < RangeTombstone > ranges = delInfo . deletionInfo . rangeIterator ( reversed ) ; <nl> return new RowAndDeletionMergeIterator ( metadata , <nl> key , <nl> @ @ - 587 , 34 + 611 , 8 @ @ public abstract class LegacyLayout <nl> return ( Iterator < LegacyAtom > ) iter ; <nl> } <nl> <nl> - private static Iterator < Row > convertToRows ( final CellGrouper grouper , final Iterator < LegacyCell > cells , final LegacyDeletionInfo delInfo ) <nl> + private static Iterator < Row > convertToRows ( final CellGrouper grouper , final PeekingIterator < LegacyAtom > atoms ) <nl> { <nl> - / / A reducer that basically does nothing , we know the 2 merge iterators can ' t have conflicting atoms . <nl> - MergeIterator . Reducer < LegacyAtom , LegacyAtom > reducer = new MergeIterator . Reducer < LegacyAtom , LegacyAtom > ( ) <nl> - { <nl> - private LegacyAtom atom ; <nl> - <nl> - public void reduce ( int idx , LegacyAtom current ) <nl> - { <nl> - / / We ' re merging cell with range tombstones , so we should always only have a single atom to reduce . <nl> - assert atom = = null ; <nl> - atom = current ; <nl> - } <nl> - <nl> - protected LegacyAtom getReduced ( ) <nl> - { <nl> - return atom ; <nl> - } <nl> - <nl> - protected void onKeyChange ( ) <nl> - { <nl> - atom = null ; <nl> - } <nl> - } ; <nl> - List < Iterator < LegacyAtom > > iterators = Arrays . asList ( asLegacyAtomIterator ( cells ) , asLegacyAtomIterator ( delInfo . inRowRangeTombstones ( ) ) ) ; <nl> - Iterator < LegacyAtom > merged = MergeIterator . get ( iterators , legacyAtomComparator ( grouper . metadata ) , reducer ) ; <nl> - final PeekingIterator < LegacyAtom > atoms = Iterators . peekingIterator ( merged ) ; <nl> - <nl> return new AbstractIterator < Row > ( ) <nl> { <nl> protected Row computeNext ( ) <nl> @ @ - 871 , 6 + 869 , 14 @ @ public abstract class LegacyLayout <nl> / / First we want to compare by clustering , but we have to be careful with range tombstone , because <nl> / / we can have collection deletion and we want those to sort properly just before the column they <nl> / / delete , not before the whole row . <nl> + / / We also want to special case static so they sort before any non - static . Note in particular that <nl> + / / this special casing is important in the case of one of the Atom being Slice . Bound . BOTTOM : we want <nl> + / / it to sort after the static as we deal with static first in toUnfilteredAtomIterator and having <nl> + / / Slice . Bound . BOTTOM first would mess that up ( note that static deletion is handled through a specific <nl> + / / static tombstone , see LegacyDeletionInfo . add ( ) ) . <nl> + if ( o1 . isStatic ( ) ! = o2 . isStatic ( ) ) <nl> + return o1 . isStatic ( ) ? - 1 : 1 ; <nl> + <nl> ClusteringPrefix c1 = o1 . clustering ( ) ; <nl> ClusteringPrefix c2 = o2 . clustering ( ) ; <nl> <nl> @ @ - 1290 , 6 + 1296 , 9 @ @ public abstract class LegacyLayout <nl> <nl> public Clustering getAsClustering ( CFMetaData metadata ) <nl> { <nl> + if ( isStatic ) <nl> + return Clustering . STATIC _ CLUSTERING ; <nl> + <nl> assert bound . size ( ) = = metadata . comparator . size ( ) ; <nl> ByteBuffer [ ] values = new ByteBuffer [ bound . size ( ) ] ; <nl> for ( int i = 0 ; i < bound . size ( ) ; i + + ) <nl> @ @ - 1499 , 6 + 1508 , 16 @ @ public abstract class LegacyLayout <nl> return start . bound ; <nl> } <nl> <nl> + public LegacyRangeTombstone withNewStart ( LegacyBound newStart ) <nl> + { <nl> + return new LegacyRangeTombstone ( newStart , stop , deletionTime ) ; <nl> + } <nl> + <nl> + public LegacyRangeTombstone withNewEnd ( LegacyBound newStop ) <nl> + { <nl> + return new LegacyRangeTombstone ( start , newStop , deletionTime ) ; <nl> + } <nl> + <nl> public boolean isCell ( ) <nl> { <nl> return false ; <nl> @ @ - 1506 , 7 + 1525 , 7 @ @ public abstract class LegacyLayout <nl> <nl> public boolean isStatic ( ) <nl> { <nl> - return start . isStatic ; <nl> + return start . isStatic | | stop . isStatic ; <nl> } <nl> <nl> public LegacyCell asCell ( ) <nl> @ @ - 1565 , 8 + 1584 , 60 @ @ public abstract class LegacyLayout <nl> deletionInfo . add ( topLevel ) ; <nl> } <nl> <nl> + private static Slice . Bound staticBound ( CFMetaData metadata , boolean isStart ) <nl> + { <nl> + / / In pre - 3 . 0 nodes , static row started by a clustering with all empty values so we <nl> + / / preserve that here . Note that in practice , it doesn ' t really matter since the rest <nl> + / / of the code will ignore the bound for RT that have their static flag set . <nl> + ByteBuffer [ ] values = new ByteBuffer [ metadata . comparator . size ( ) ] ; <nl> + for ( int i = 0 ; i < values . length ; i + + ) <nl> + values [ i ] = ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> + return isStart <nl> + ? Slice . Bound . inclusiveStartOf ( values ) <nl> + : Slice . Bound . inclusiveEndOf ( values ) ; <nl> + } <nl> + <nl> public void add ( CFMetaData metadata , LegacyRangeTombstone tombstone ) <nl> { <nl> + if ( metadata . hasStaticColumns ( ) ) <nl> + { <nl> + / * <nl> + * For table having static columns we have to deal with the following cases : <nl> + * 1 . the end of the tombstone is static ( in which case either the start is static or is BOTTOM , which is the same <nl> + * for our consideration ) . This mean that either the range only delete the static row , or that it ' s a collection <nl> + * tombstone of a static collection . In both case , we just add the tombstone to the inRowTombstones . <nl> + * 2 . only the start is static . There is then 2 subcase : either the start is inclusive , and that mean we include the <nl> + * static row and more ( so we add an inRowTombstone for the static and deal with the rest normally ) . Or the start <nl> + * is exclusive , and that means we explicitely exclude the static ( in which case we can just add the tombstone <nl> + * as if it started at BOTTOM ) . <nl> + * 3 . none of the bound are static but the start is BOTTOM . This means we intended to delete the static row so we <nl> + * need to add it to the inRowTombstones ( and otherwise handle the range normally ) . <nl> + * / <nl> + if ( tombstone . stop . isStatic ) <nl> + { <nl> + / / If the start is BOTTOM , we replace it by the beginning of the starting row so as to not confuse the <nl> + / / RangeTombstone . isRowDeletion ( ) method <nl> + if ( tombstone . start = = LegacyBound . BOTTOM ) <nl> + tombstone = tombstone . withNewStart ( new LegacyBound ( staticBound ( metadata , true ) , true , null ) ) ; <nl> + inRowTombstones . add ( tombstone ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( tombstone . start . isStatic ) <nl> + { <nl> + if ( tombstone . start . bound . isInclusive ( ) ) <nl> + inRowTombstones . add ( tombstone . withNewEnd ( new LegacyBound ( staticBound ( metadata , false ) , true , null ) ) ) ; <nl> + <nl> + tombstone = tombstone . withNewStart ( LegacyBound . BOTTOM ) ; <nl> + } <nl> + else if ( tombstone . start = = LegacyBound . BOTTOM ) <nl> + { <nl> + inRowTombstones . add ( new LegacyRangeTombstone ( new LegacyBound ( staticBound ( metadata , true ) , true , null ) , <nl> + new LegacyBound ( staticBound ( metadata , false ) , true , null ) , <nl> + tombstone . deletionTime ) ) ; <nl> + } <nl> + } <nl> + <nl> if ( tombstone . isCollectionTombstone ( ) | | tombstone . isRowDeletion ( metadata ) ) <nl> inRowTombstones . add ( tombstone ) ; <nl> else
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java b / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java <nl> deleted file mode 100644 <nl> index 74495cf . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java <nl> + + + / dev / null <nl> @ @ - 1 , 39 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . concurrent ; <nl> - <nl> - / * * <nl> - * Use this implementation over Java ' s ThreadLocal or InheritableThreadLocal when <nl> - * you need to add multiple key / value pairs into ThreadLocalContext for a given thread . <nl> - * / <nl> - <nl> - public class ThreadLocalContext <nl> - { <nl> - private static InheritableThreadLocal < Context > tls _ = new InheritableThreadLocal < Context > ( ) ; <nl> - <nl> - public static void put ( Context value ) <nl> - { <nl> - tls _ . set ( value ) ; <nl> - } <nl> - <nl> - public static Context get ( ) <nl> - { <nl> - return tls _ . get ( ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessageSerializationTask . java b / src / java / org / apache / cassandra / net / MessageSerializationTask . java <nl> deleted file mode 100644 <nl> index fc40c9a . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / MessageSerializationTask . java <nl> + + + / dev / null <nl> @ @ - 1 , 96 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . IOException ; <nl> - import java . net . SocketException ; <nl> - <nl> - import org . apache . cassandra . concurrent . Context ; <nl> - import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; <nl> - import org . apache . cassandra . concurrent . ThreadLocalContext ; <nl> - import org . apache . cassandra . net . sink . SinkManager ; <nl> - import org . apache . cassandra . utils . LogUtil ; <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - class MessageSerializationTask implements Runnable <nl> - { <nl> - private static Logger logger _ = Logger . getLogger ( MessageSerializationTask . class ) ; <nl> - private Message message _ ; <nl> - private EndPoint to _ ; <nl> - <nl> - public MessageSerializationTask ( Message message , EndPoint to ) <nl> - { <nl> - message _ = message ; <nl> - to _ = to ; <nl> - } <nl> - <nl> - public Message getMessage ( ) <nl> - { <nl> - return message _ ; <nl> - } <nl> - <nl> - public void run ( ) <nl> - { <nl> - / * Adding the message to be serialized in the TLS . For accessing in the afterExecute ( ) * / <nl> - Context ctx = new Context ( ) ; <nl> - ctx . put ( this . getClass ( ) . getName ( ) , message _ ) ; <nl> - ThreadLocalContext . put ( ctx ) ; <nl> - <nl> - TcpConnection connection = null ; <nl> - try <nl> - { <nl> - Message message = SinkManager . processClientMessageSink ( message _ ) ; <nl> - if ( null = = message ) <nl> - return ; <nl> - connection = MessagingService . getConnection ( message _ . getFrom ( ) , to _ ) ; <nl> - connection . write ( message ) ; <nl> - } <nl> - catch ( SocketException se ) <nl> - { <nl> - / / Shutting down the entire pool . May be too conservative an approach . <nl> - MessagingService . getConnectionPool ( message _ . getFrom ( ) , to _ ) . shutdown ( ) ; <nl> - logger _ . warn ( LogUtil . throwableToString ( se ) ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - logConnectAndIOException ( e , connection ) ; <nl> - } <nl> - catch ( Throwable th ) <nl> - { <nl> - logger _ . warn ( LogUtil . throwableToString ( th ) ) ; <nl> - } <nl> - finally <nl> - { <nl> - if ( connection ! = null ) <nl> - { <nl> - connection . close ( ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - private void logConnectAndIOException ( IOException ex , TcpConnection connection ) <nl> - { <nl> - if ( connection ! = null ) <nl> - { <nl> - connection . errorClose ( ) ; <nl> - } <nl> - logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; <nl> - } <nl> - } <nl> - <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index d38b055 . . f649bb0 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 21 , 12 + 21 , 14 @ @ package org . apache . cassandra . net ; <nl> import org . apache . cassandra . concurrent . * ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . net . io . SerializerType ; <nl> + import org . apache . cassandra . net . sink . SinkManager ; <nl> import org . apache . cassandra . utils . * ; <nl> import org . apache . log4j . Logger ; <nl> <nl> import java . io . IOException ; <nl> import java . net . MulticastSocket ; <nl> import java . net . ServerSocket ; <nl> + import java . net . SocketException ; <nl> import java . nio . ByteBuffer ; <nl> import java . nio . channels . SelectionKey ; <nl> import java . nio . channels . ServerSocketChannel ; <nl> @ @ - 40 , 8 + 42 , 6 @ @ import java . util . concurrent . locks . ReentrantLock ; <nl> <nl> public class MessagingService implements IMessagingService <nl> { <nl> - private static boolean debugOn _ = false ; <nl> - <nl> private static int version _ = 1 ; <nl> / / TODO : make this parameter dynamic somehow . Not sure if config is appropriate . <nl> private static SerializerType serializerType _ = SerializerType . BINARY ; <nl> @ @ - 51 , 7 + 51 , 8 @ @ public class MessagingService implements IMessagingService <nl> public static final String responseVerbHandler _ = " RESPONSE " ; <nl> / * Stage for responses . * / <nl> public static final String responseStage _ = " RESPONSE - STAGE " ; <nl> - private enum ReservedVerbs _ { RESPONSE } ; <nl> + private enum ReservedVerbs _ { <nl> + } ; <nl> <nl> private static Map < String , String > reservedVerbs _ = new Hashtable < String , String > ( ) ; <nl> / * Indicate if we are currently streaming data to another node or receiving streaming data * / <nl> @ @ - 69 , 15 + 70 , 10 @ @ public class MessagingService implements IMessagingService <nl> <nl> / * Lookup table for registering message handlers based on the verb . * / <nl> private static Map < String , IVerbHandler > verbHandlers _ ; <nl> - <nl> - private static Map < String , MulticastSocket > mCastMembership _ = new HashMap < String , MulticastSocket > ( ) ; <nl> - <nl> + <nl> / * Thread pool to handle messaging read activities of Socket and default stage * / <nl> private static ExecutorService messageDeserializationExecutor _ ; <nl> <nl> - / * Thread pool to handle messaging write activities * / <nl> - private static ExecutorService messageSerializerExecutor _ ; <nl> - <nl> / * Thread pool to handle deserialization of messages read from the socket . * / <nl> private static ExecutorService messageDeserializerExecutor _ ; <nl> <nl> @ @ - 92 , 48 + 88 , 12 @ @ public class MessagingService implements IMessagingService <nl> private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; <nl> <nl> private static IMessagingService messagingService _ = new MessagingService ( ) ; <nl> - <nl> - public static boolean isDebugOn ( ) <nl> - { <nl> - return debugOn _ ; <nl> - } <nl> - <nl> - public static void debugOn ( boolean on ) <nl> - { <nl> - debugOn _ = on ; <nl> - } <nl> - <nl> - public static SerializerType getSerializerType ( ) <nl> - { <nl> - return serializerType _ ; <nl> - } <nl> - <nl> - public synchronized static void serializerType ( String type ) <nl> - { <nl> - if ( type . equalsIgnoreCase ( " binary " ) ) <nl> - { <nl> - serializerType _ = SerializerType . BINARY ; <nl> - } <nl> - else if ( type . equalsIgnoreCase ( " java " ) ) <nl> - { <nl> - serializerType _ = SerializerType . JAVA ; <nl> - } <nl> - else if ( type . equalsIgnoreCase ( " xml " ) ) <nl> - { <nl> - serializerType _ = SerializerType . XML ; <nl> - } <nl> - } <nl> - <nl> + <nl> public static int getVersion ( ) <nl> { <nl> return version _ ; <nl> } <nl> - <nl> - public static void setVersion ( int version ) <nl> - { <nl> - version _ = version ; <nl> - } <nl> - <nl> + <nl> public static IMessagingService getMessagingInstance ( ) <nl> { <nl> 	 if ( bShutdown _ ) <nl> @ @ - 186 , 15 + 146 , 7 @ @ public class MessagingService implements IMessagingService <nl> new LinkedBlockingQueue < Runnable > ( ) , <nl> new ThreadFactoryImpl ( " MESSAGING - SERVICE - POOL " ) <nl> ) ; <nl> - <nl> - messageSerializerExecutor _ = new DebuggableThreadPoolExecutor ( maxSize , <nl> - maxSize , <nl> - Integer . MAX _ VALUE , <nl> - TimeUnit . SECONDS , <nl> - new LinkedBlockingQueue < Runnable > ( ) , <nl> - new ThreadFactoryImpl ( " MESSAGE - SERIALIZER - POOL " ) <nl> - ) ; <nl> - <nl> + <nl> messageDeserializerExecutor _ = new DebuggableThreadPoolExecutor ( maxSize , <nl> maxSize , <nl> Integer . MAX _ VALUE , <nl> @ @ - 284 , 19 + 236 , 6 @ @ public class MessagingService implements IMessagingService <nl> return cp ; <nl> } <nl> <nl> - public static ConnectionStatistics [ ] getPoolStatistics ( ) <nl> - { <nl> - Set < ConnectionStatistics > stats = new HashSet < ConnectionStatistics > ( ) ; <nl> - Iterator < TcpConnectionManager > it = poolTable _ . values ( ) . iterator ( ) ; <nl> - while ( it . hasNext ( ) ) <nl> - { <nl> - TcpConnectionManager cp = it . next ( ) ; <nl> - ConnectionStatistics cs = new ConnectionStatistics ( cp . getLocalEndPoint ( ) , cp . getRemoteEndPoint ( ) , cp . getPoolSize ( ) , cp . getConnectionsInUse ( ) ) ; <nl> - stats . add ( cs ) ; <nl> - } <nl> - return stats . toArray ( new ConnectionStatistics [ 0 ] ) ; <nl> - } <nl> - <nl> public static TcpConnection getConnection ( EndPoint from , EndPoint to ) throws IOException <nl> { <nl> return getConnectionPool ( from , to ) . getConnection ( ) ; <nl> @ @ - 419 , 8 + 358 , 38 @ @ public class MessagingService implements IMessagingService <nl> return ; <nl> } <nl> <nl> - Runnable tcpWriteEvent = new MessageSerializationTask ( message , to ) ; <nl> - messageSerializerExecutor _ . execute ( tcpWriteEvent ) ; <nl> + TcpConnection connection = null ; <nl> + try <nl> + { <nl> + Message processedMessage = SinkManager . processClientMessageSink ( message ) ; <nl> + if ( processedMessage = = null ) <nl> + { <nl> + return ; <nl> + } <nl> + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; <nl> + connection . write ( message ) ; <nl> + } <nl> + catch ( SocketException se ) <nl> + { <nl> + / / Shutting down the entire pool . May be too conservative an approach . <nl> + MessagingService . getConnectionPool ( message . getFrom ( ) , to ) . shutdown ( ) ; <nl> + logger _ . error ( " socket error writing to " + to , se ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + if ( connection ! = null ) <nl> + { <nl> + connection . errorClose ( ) ; <nl> + } <nl> + logger _ . error ( " unexpected error writing " + message , e ) ; <nl> + } <nl> + finally <nl> + { <nl> + if ( connection ! = null ) <nl> + { <nl> + connection . close ( ) ; <nl> + } <nl> + } <nl> } <nl> <nl> public IAsyncResult sendRR ( Message message , EndPoint to ) <nl> @ @ - 463 , 34 + 432 , 12 @ @ public class MessagingService implements IMessagingService <nl> Runnable streamingTask = new FileStreamTask ( file , startPosition , total , from , to ) ; <nl> streamExecutor _ . execute ( streamingTask ) ; <nl> } <nl> - <nl> - / * <nl> - * Does the application determine if we are currently streaming data . <nl> - * This would imply either streaming to a receiver , receiving streamed <nl> - * data or both . <nl> - * / <nl> - public static boolean isStreaming ( ) <nl> - { <nl> - return isStreaming _ . get ( ) ; <nl> - } <nl> - <nl> + <nl> public static void setStreamingMode ( boolean bVal ) <nl> { <nl> isStreaming _ . set ( bVal ) ; <nl> } <nl> - public static void flushAndshutdown ( ) <nl> - { <nl> - / / safely shutdown and send all writes <nl> - for ( Map . Entry < String , TcpConnectionManager > entry : poolTable _ . entrySet ( ) ) <nl> - { <nl> - for ( TcpConnection connection : entry . getValue ( ) . getConnections ( ) ) <nl> - { <nl> - connection . doPendingWrites ( ) ; <nl> - } <nl> - } <nl> - shutdown ( ) ; <nl> - } <nl> - <nl> + <nl> public static void shutdown ( ) <nl> { <nl> logger _ . info ( " Shutting down . . . " ) ; <nl> @ @ - 510 , 7 + 457 , 6 @ @ public class MessagingService implements IMessagingService <nl> <nl> / * Shutdown the threads in the EventQueue ' s * / <nl> messageDeserializationExecutor _ . shutdownNow ( ) ; <nl> - messageSerializerExecutor _ . shutdownNow ( ) ; <nl> messageDeserializerExecutor _ . shutdownNow ( ) ; <nl> streamExecutor _ . shutdownNow ( ) ; <nl> <nl> @ @ - 534 , 12 + 480 , 7 @ @ public class MessagingService implements IMessagingService <nl> { <nl> enqueueRunnable ( message . getMessageType ( ) , new MessageDeliveryTask ( message ) ) ; <nl> } <nl> - <nl> - public static boolean isLocalEndPoint ( EndPoint ep ) <nl> - { <nl> - return ( endPoints _ . contains ( ep ) ) ; <nl> - } <nl> - <nl> + <nl> private static void enqueueRunnable ( String stageName , Runnable runnable ) { <nl> <nl> IStage stage = StageManager . getStage ( stageName ) ; <nl> @ @ - 550 , 8 + 491 , 8 @ @ public class MessagingService implements IMessagingService <nl> } <nl> else <nl> { <nl> - logger _ . info ( " Running on default stage - beware " ) ; <nl> - messageSerializerExecutor _ . execute ( runnable ) ; <nl> + logger _ . warn ( " Running on default stage - beware " ) ; <nl> + messageDeserializerExecutor _ . execute ( runnable ) ; <nl> } <nl> } <nl> <nl> @ @ - 569 , 27 + 510 , 12 @ @ public class MessagingService implements IMessagingService <nl> { <nl> return taskCompletionMap _ . remove ( key ) ; <nl> } <nl> - <nl> - public static void removeAsyncResult ( String key ) <nl> - { <nl> - taskCompletionMap _ . remove ( key ) ; <nl> - } <nl> <nl> - public static byte [ ] getProtocol ( ) <nl> - { <nl> - return protocol _ ; <nl> - } <nl> - <nl> public static ExecutorService getReadExecutor ( ) <nl> { <nl> return messageDeserializationExecutor _ ; <nl> } <nl> - <nl> - public static ExecutorService getWriteExecutor ( ) <nl> - { <nl> - return messageSerializerExecutor _ ; <nl> - } <nl> - <nl> + <nl> public static ExecutorService getDeserializationExecutor ( ) <nl> { <nl> return messageDeserializerExecutor _ ; <nl> diff - - git a / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java b / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java <nl> deleted file mode 100644 <nl> index 243c3c1 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java <nl> + + + / dev / null <nl> @ @ - 1 , 246 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . service ; <nl> - <nl> - import java . io . IOException ; <nl> - import java . util . HashMap ; <nl> - import java . util . List ; <nl> - import java . util . ArrayList ; <nl> - import java . util . Map ; <nl> - import java . util . concurrent . atomic . AtomicBoolean ; <nl> - import java . util . concurrent . locks . * ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . TimeoutException ; <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . db . ReadCommand ; <nl> - import org . apache . cassandra . db . Row ; <nl> - import org . apache . cassandra . net . EndPoint ; <nl> - import org . apache . cassandra . net . IAsyncCallback ; <nl> - import org . apache . cassandra . net . Message ; <nl> - import org . apache . cassandra . net . MessagingService ; <nl> - import org . apache . cassandra . utils . LogUtil ; <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - public class MultiQuorumResponseHandler implements IAsyncCallback <nl> - { <nl> - private static Logger logger _ = Logger . getLogger ( QuorumResponseHandler . class ) ; <nl> - private Lock lock _ = new ReentrantLock ( ) ; <nl> - private Condition condition _ ; <nl> - / * This maps the keys to the original data read messages * / <nl> - private Map < String , ReadCommand > readMessages _ = new HashMap < String , ReadCommand > ( ) ; <nl> - / * This maps the key to its set of replicas * / <nl> - private Map < String , EndPoint [ ] > endpoints _ = new HashMap < String , EndPoint [ ] > ( ) ; <nl> - / * This maps the groupId to the individual callback for the set of messages * / <nl> - private Map < String , SingleQuorumResponseHandler > handlers _ = new HashMap < String , SingleQuorumResponseHandler > ( ) ; <nl> - / * This should hold all the responses for the keys * / <nl> - private List < Row > responses _ = new ArrayList < Row > ( ) ; <nl> - private AtomicBoolean done _ = new AtomicBoolean ( false ) ; <nl> - <nl> - / * * <nl> - * This is used to handle the responses from the individual messages <nl> - * that are sent out to the replicas . <nl> - * / <nl> - private class SingleQuorumResponseHandler implements IAsyncCallback <nl> - { <nl> - private Lock lock _ = new ReentrantLock ( ) ; <nl> - private IResponseResolver < Row > responseResolver _ ; <nl> - private List < Message > responses _ = new ArrayList < Message > ( ) ; <nl> - <nl> - SingleQuorumResponseHandler ( IResponseResolver < Row > responseResolver ) <nl> - { <nl> - responseResolver _ = responseResolver ; <nl> - } <nl> - <nl> - public void attachContext ( Object o ) <nl> - { <nl> - throw new UnsupportedOperationException ( " This operation is not supported in this implementation " ) ; <nl> - } <nl> - <nl> - public void response ( Message response ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - responses _ . add ( response ) ; <nl> - int majority = ( DatabaseDescriptor . getReplicationFactor ( ) > > 1 ) + 1 ; <nl> - if ( responses _ . size ( ) > = majority & & responseResolver _ . isDataPresent ( responses _ ) ) <nl> - { <nl> - onCompletion ( ) ; <nl> - } <nl> - } <nl> - catch ( IOException ex ) <nl> - { <nl> - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - private void onCompletion ( ) throws IOException <nl> - { <nl> - try <nl> - { <nl> - Row row = responseResolver _ . resolve ( responses _ ) ; <nl> - MultiQuorumResponseHandler . this . onCompleteResponse ( row ) ; <nl> - } <nl> - catch ( DigestMismatchException ex ) <nl> - { <nl> - / * <nl> - * The DigestMismatchException has the key for which the mismatch <nl> - * occurred bundled in it as context <nl> - * / <nl> - String key = ex . getMessage ( ) ; <nl> - onDigestMismatch ( key ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * This method is invoked on a digest match . We pass in the key <nl> - * in order to retrieve the appropriate data message that needs <nl> - * to be sent out to the replicas . <nl> - * <nl> - * @ param key for which the mismatch occurred . <nl> - * / <nl> - private void onDigestMismatch ( String key ) throws IOException <nl> - { <nl> - if ( DatabaseDescriptor . getConsistencyCheck ( ) ) <nl> - { <nl> - ReadCommand readCommand = readMessages _ . get ( key ) ; <nl> - readCommand . setDigestQuery ( false ) ; <nl> - Message messageRepair = readCommand . makeReadMessage ( ) ; <nl> - EndPoint [ ] endpoints = MultiQuorumResponseHandler . this . endpoints _ . get ( readCommand . key ) ; <nl> - Message [ ] [ ] messages = new Message [ ] [ ] { { messageRepair , messageRepair , messageRepair } } ; <nl> - EndPoint [ ] [ ] epList = new EndPoint [ ] [ ] { endpoints } ; <nl> - MessagingService . getMessagingInstance ( ) . sendRR ( messages , epList , MultiQuorumResponseHandler . this ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - public MultiQuorumResponseHandler ( Map < String , ReadCommand > readMessages , Map < String , EndPoint [ ] > endpoints ) <nl> - { <nl> - condition _ = lock _ . newCondition ( ) ; <nl> - readMessages _ = readMessages ; <nl> - endpoints _ = endpoints ; <nl> - } <nl> - <nl> - public Row [ ] get ( ) throws TimeoutException <nl> - { <nl> - long startTime = System . currentTimeMillis ( ) ; <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - boolean bVal = true ; <nl> - try <nl> - { <nl> - if ( ! done _ . get ( ) ) <nl> - { <nl> - bVal = condition _ . await ( DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) ; <nl> - } <nl> - } <nl> - catch ( InterruptedException ex ) <nl> - { <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( LogUtil . throwableToString ( ex ) ) ; <nl> - } <nl> - <nl> - if ( ! bVal & & ! done _ . get ( ) ) <nl> - { <nl> - StringBuilder sb = new StringBuilder ( " " ) ; <nl> - for ( Row row : responses _ ) <nl> - { <nl> - sb . append ( row . key ( ) ) ; <nl> - sb . append ( " : " ) ; <nl> - } <nl> - throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - <nl> - logger _ . info ( " MultiQuorumResponseHandler : " + ( System . currentTimeMillis ( ) - startTime ) + " ms . " ) ; <nl> - return responses _ . toArray ( new Row [ 0 ] ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Invoked when a complete response has been obtained <nl> - * for one of the sub - groups a . k . a keys for the query <nl> - * has been performed . <nl> - * <nl> - * @ param row obtained as a result of the response . <nl> - * / <nl> - void onCompleteResponse ( Row row ) <nl> - { <nl> - if ( ! done _ . get ( ) ) <nl> - { <nl> - responses _ . add ( row ) ; <nl> - if ( responses _ . size ( ) = = readMessages _ . size ( ) ) <nl> - { <nl> - done _ . set ( true ) ; <nl> - condition _ . signal ( ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * The handler of the response message that has been <nl> - * sent by one of the replicas for one of the keys . <nl> - * <nl> - * @ param message the response message for one of the <nl> - * message that we sent out . <nl> - * / <nl> - public void response ( Message message ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - SingleQuorumResponseHandler handler = handlers _ . get ( message . getMessageId ( ) ) ; <nl> - handler . response ( message ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - / * * <nl> - * The context that is passed in for the query of <nl> - * multiple keys in the system . For each message <nl> - * id in the context register a callback handler <nl> - * for the same . This is done so that all responses <nl> - * for a given key use the same callback handler . <nl> - * <nl> - * @ param o the context which is an array of strings <nl> - * corresponding to the message id ' s for each <nl> - * key . <nl> - * / <nl> - public void attachContext ( Object o ) <nl> - { <nl> - String [ ] gids = ( String [ ] ) o ; <nl> - for ( String gid : gids ) <nl> - { <nl> - IResponseResolver < Row > responseResolver = new ReadResponseResolver ( ) ; <nl> - SingleQuorumResponseHandler handler = new SingleQuorumResponseHandler ( responseResolver ) ; <nl> - handlers _ . put ( gid , handler ) ; <nl> - } <nl> - } <nl> - }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a53a299 . . e2d9dd7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 - rc2 
 + * Fix handling of static columns for range tombstones in thrift ( CASSANDRA - 10174 ) 
 * Support empty ColumnFilter for backward compatility on empty IN ( CASSANDRA - 10471 ) 
 * Remove Pig support ( CASSANDRA - 10542 ) 
 * Fix LogFile throws Exception when assertion is disabled ( CASSANDRA - 10522 ) 
 diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index d57bc6b . . 194b6e8 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 506 , 13 + 506 , 37 @ @ public abstract class LegacyLayout 
 boolean reversed , 
 SerializationHelper helper ) 
 { 
 + / / A reducer that basically does nothing , we know the 2 merged iterators can ' t have conflicting atoms ( since we merge cells with range tombstones ) . 
 + MergeIterator . Reducer < LegacyAtom , LegacyAtom > reducer = new MergeIterator . Reducer < LegacyAtom , LegacyAtom > ( ) 
 + { 
 + private LegacyAtom atom ; 
 + 
 + public void reduce ( int idx , LegacyAtom current ) 
 + { 
 + / / We ' re merging cell with range tombstones , so we should always only have a single atom to reduce . 
 + assert atom = = null ; 
 + atom = current ; 
 + } 
 + 
 + protected LegacyAtom getReduced ( ) 
 + { 
 + return atom ; 
 + } 
 + 
 + protected void onKeyChange ( ) 
 + { 
 + atom = null ; 
 + } 
 + } ; 
 + List < Iterator < LegacyAtom > > iterators = Arrays . asList ( asLegacyAtomIterator ( cells ) , asLegacyAtomIterator ( delInfo . inRowRangeTombstones ( ) ) ) ; 
 + PeekingIterator < LegacyAtom > atoms = Iterators . peekingIterator ( MergeIterator . get ( iterators , legacyAtomComparator ( metadata ) , reducer ) ) ; 
 + 
 / / Check if we have some static 
 - PeekingIterator < LegacyCell > iter = Iterators . peekingIterator ( cells ) ; 
 - Row staticRow = iter . hasNext ( ) & & iter . peek ( ) . name . clustering = = Clustering . STATIC _ CLUSTERING 
 - ? getNextRow ( CellGrouper . staticGrouper ( metadata , helper ) , iter ) 
 + Row staticRow = atoms . hasNext ( ) & & atoms . peek ( ) . isStatic ( ) 
 + ? getNextRow ( CellGrouper . staticGrouper ( metadata , helper ) , atoms ) 
 : Rows . EMPTY _ STATIC _ ROW ; 
 
 - Iterator < Row > rows = convertToRows ( new CellGrouper ( metadata , helper ) , iter , delInfo ) ; 
 + Iterator < Row > rows = convertToRows ( new CellGrouper ( metadata , helper ) , atoms ) ; 
 Iterator < RangeTombstone > ranges = delInfo . deletionInfo . rangeIterator ( reversed ) ; 
 return new RowAndDeletionMergeIterator ( metadata , 
 key , 
 @ @ - 587 , 34 + 611 , 8 @ @ public abstract class LegacyLayout 
 return ( Iterator < LegacyAtom > ) iter ; 
 } 
 
 - private static Iterator < Row > convertToRows ( final CellGrouper grouper , final Iterator < LegacyCell > cells , final LegacyDeletionInfo delInfo ) 
 + private static Iterator < Row > convertToRows ( final CellGrouper grouper , final PeekingIterator < LegacyAtom > atoms ) 
 { 
 - / / A reducer that basically does nothing , we know the 2 merge iterators can ' t have conflicting atoms . 
 - MergeIterator . Reducer < LegacyAtom , LegacyAtom > reducer = new MergeIterator . Reducer < LegacyAtom , LegacyAtom > ( ) 
 - { 
 - private LegacyAtom atom ; 
 - 
 - public void reduce ( int idx , LegacyAtom current ) 
 - { 
 - / / We ' re merging cell with range tombstones , so we should always only have a single atom to reduce . 
 - assert atom = = null ; 
 - atom = current ; 
 - } 
 - 
 - protected LegacyAtom getReduced ( ) 
 - { 
 - return atom ; 
 - } 
 - 
 - protected void onKeyChange ( ) 
 - { 
 - atom = null ; 
 - } 
 - } ; 
 - List < Iterator < LegacyAtom > > iterators = Arrays . asList ( asLegacyAtomIterator ( cells ) , asLegacyAtomIterator ( delInfo . inRowRangeTombstones ( ) ) ) ; 
 - Iterator < LegacyAtom > merged = MergeIterator . get ( iterators , legacyAtomComparator ( grouper . metadata ) , reducer ) ; 
 - final PeekingIterator < LegacyAtom > atoms = Iterators . peekingIterator ( merged ) ; 
 - 
 return new AbstractIterator < Row > ( ) 
 { 
 protected Row computeNext ( ) 
 @ @ - 871 , 6 + 869 , 14 @ @ public abstract class LegacyLayout 
 / / First we want to compare by clustering , but we have to be careful with range tombstone , because 
 / / we can have collection deletion and we want those to sort properly just before the column they 
 / / delete , not before the whole row . 
 + / / We also want to special case static so they sort before any non - static . Note in particular that 
 + / / this special casing is important in the case of one of the Atom being Slice . Bound . BOTTOM : we want 
 + / / it to sort after the static as we deal with static first in toUnfilteredAtomIterator and having 
 + / / Slice . Bound . BOTTOM first would mess that up ( note that static deletion is handled through a specific 
 + / / static tombstone , see LegacyDeletionInfo . add ( ) ) . 
 + if ( o1 . isStatic ( ) ! = o2 . isStatic ( ) ) 
 + return o1 . isStatic ( ) ? - 1 : 1 ; 
 + 
 ClusteringPrefix c1 = o1 . clustering ( ) ; 
 ClusteringPrefix c2 = o2 . clustering ( ) ; 
 
 @ @ - 1290 , 6 + 1296 , 9 @ @ public abstract class LegacyLayout 
 
 public Clustering getAsClustering ( CFMetaData metadata ) 
 { 
 + if ( isStatic ) 
 + return Clustering . STATIC _ CLUSTERING ; 
 + 
 assert bound . size ( ) = = metadata . comparator . size ( ) ; 
 ByteBuffer [ ] values = new ByteBuffer [ bound . size ( ) ] ; 
 for ( int i = 0 ; i < bound . size ( ) ; i + + ) 
 @ @ - 1499 , 6 + 1508 , 16 @ @ public abstract class LegacyLayout 
 return start . bound ; 
 } 
 
 + public LegacyRangeTombstone withNewStart ( LegacyBound newStart ) 
 + { 
 + return new LegacyRangeTombstone ( newStart , stop , deletionTime ) ; 
 + } 
 + 
 + public LegacyRangeTombstone withNewEnd ( LegacyBound newStop ) 
 + { 
 + return new LegacyRangeTombstone ( start , newStop , deletionTime ) ; 
 + } 
 + 
 public boolean isCell ( ) 
 { 
 return false ; 
 @ @ - 1506 , 7 + 1525 , 7 @ @ public abstract class LegacyLayout 
 
 public boolean isStatic ( ) 
 { 
 - return start . isStatic ; 
 + return start . isStatic | | stop . isStatic ; 
 } 
 
 public LegacyCell asCell ( ) 
 @ @ - 1565 , 8 + 1584 , 60 @ @ public abstract class LegacyLayout 
 deletionInfo . add ( topLevel ) ; 
 } 
 
 + private static Slice . Bound staticBound ( CFMetaData metadata , boolean isStart ) 
 + { 
 + / / In pre - 3 . 0 nodes , static row started by a clustering with all empty values so we 
 + / / preserve that here . Note that in practice , it doesn ' t really matter since the rest 
 + / / of the code will ignore the bound for RT that have their static flag set . 
 + ByteBuffer [ ] values = new ByteBuffer [ metadata . comparator . size ( ) ] ; 
 + for ( int i = 0 ; i < values . length ; i + + ) 
 + values [ i ] = ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 + return isStart 
 + ? Slice . Bound . inclusiveStartOf ( values ) 
 + : Slice . Bound . inclusiveEndOf ( values ) ; 
 + } 
 + 
 public void add ( CFMetaData metadata , LegacyRangeTombstone tombstone ) 
 { 
 + if ( metadata . hasStaticColumns ( ) ) 
 + { 
 + / * 
 + * For table having static columns we have to deal with the following cases : 
 + * 1 . the end of the tombstone is static ( in which case either the start is static or is BOTTOM , which is the same 
 + * for our consideration ) . This mean that either the range only delete the static row , or that it ' s a collection 
 + * tombstone of a static collection . In both case , we just add the tombstone to the inRowTombstones . 
 + * 2 . only the start is static . There is then 2 subcase : either the start is inclusive , and that mean we include the 
 + * static row and more ( so we add an inRowTombstone for the static and deal with the rest normally ) . Or the start 
 + * is exclusive , and that means we explicitely exclude the static ( in which case we can just add the tombstone 
 + * as if it started at BOTTOM ) . 
 + * 3 . none of the bound are static but the start is BOTTOM . This means we intended to delete the static row so we 
 + * need to add it to the inRowTombstones ( and otherwise handle the range normally ) . 
 + * / 
 + if ( tombstone . stop . isStatic ) 
 + { 
 + / / If the start is BOTTOM , we replace it by the beginning of the starting row so as to not confuse the 
 + / / RangeTombstone . isRowDeletion ( ) method 
 + if ( tombstone . start = = LegacyBound . BOTTOM ) 
 + tombstone = tombstone . withNewStart ( new LegacyBound ( staticBound ( metadata , true ) , true , null ) ) ; 
 + inRowTombstones . add ( tombstone ) ; 
 + return ; 
 + } 
 + 
 + if ( tombstone . start . isStatic ) 
 + { 
 + if ( tombstone . start . bound . isInclusive ( ) ) 
 + inRowTombstones . add ( tombstone . withNewEnd ( new LegacyBound ( staticBound ( metadata , false ) , true , null ) ) ) ; 
 + 
 + tombstone = tombstone . withNewStart ( LegacyBound . BOTTOM ) ; 
 + } 
 + else if ( tombstone . start = = LegacyBound . BOTTOM ) 
 + { 
 + inRowTombstones . add ( new LegacyRangeTombstone ( new LegacyBound ( staticBound ( metadata , true ) , true , null ) , 
 + new LegacyBound ( staticBound ( metadata , false ) , true , null ) , 
 + tombstone . deletionTime ) ) ; 
 + } 
 + } 
 + 
 if ( tombstone . isCollectionTombstone ( ) | | tombstone . isRowDeletion ( metadata ) ) 
 inRowTombstones . add ( tombstone ) ; 
 else

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java b / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java 
 deleted file mode 100644 
 index 74495cf . . 0000000 
 - - - a / src / java / org / apache / cassandra / concurrent / ThreadLocalContext . java 
 + + + / dev / null 
 @ @ - 1 , 39 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . concurrent ; 
 - 
 - / * * 
 - * Use this implementation over Java ' s ThreadLocal or InheritableThreadLocal when 
 - * you need to add multiple key / value pairs into ThreadLocalContext for a given thread . 
 - * / 
 - 
 - public class ThreadLocalContext 
 - { 
 - private static InheritableThreadLocal < Context > tls _ = new InheritableThreadLocal < Context > ( ) ; 
 - 
 - public static void put ( Context value ) 
 - { 
 - tls _ . set ( value ) ; 
 - } 
 - 
 - public static Context get ( ) 
 - { 
 - return tls _ . get ( ) ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / net / MessageSerializationTask . java b / src / java / org / apache / cassandra / net / MessageSerializationTask . java 
 deleted file mode 100644 
 index fc40c9a . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / MessageSerializationTask . java 
 + + + / dev / null 
 @ @ - 1 , 96 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . IOException ; 
 - import java . net . SocketException ; 
 - 
 - import org . apache . cassandra . concurrent . Context ; 
 - import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; 
 - import org . apache . cassandra . concurrent . ThreadLocalContext ; 
 - import org . apache . cassandra . net . sink . SinkManager ; 
 - import org . apache . cassandra . utils . LogUtil ; 
 - import org . apache . log4j . Logger ; 
 - 
 - class MessageSerializationTask implements Runnable 
 - { 
 - private static Logger logger _ = Logger . getLogger ( MessageSerializationTask . class ) ; 
 - private Message message _ ; 
 - private EndPoint to _ ; 
 - 
 - public MessageSerializationTask ( Message message , EndPoint to ) 
 - { 
 - message _ = message ; 
 - to _ = to ; 
 - } 
 - 
 - public Message getMessage ( ) 
 - { 
 - return message _ ; 
 - } 
 - 
 - public void run ( ) 
 - { 
 - / * Adding the message to be serialized in the TLS . For accessing in the afterExecute ( ) * / 
 - Context ctx = new Context ( ) ; 
 - ctx . put ( this . getClass ( ) . getName ( ) , message _ ) ; 
 - ThreadLocalContext . put ( ctx ) ; 
 - 
 - TcpConnection connection = null ; 
 - try 
 - { 
 - Message message = SinkManager . processClientMessageSink ( message _ ) ; 
 - if ( null = = message ) 
 - return ; 
 - connection = MessagingService . getConnection ( message _ . getFrom ( ) , to _ ) ; 
 - connection . write ( message ) ; 
 - } 
 - catch ( SocketException se ) 
 - { 
 - / / Shutting down the entire pool . May be too conservative an approach . 
 - MessagingService . getConnectionPool ( message _ . getFrom ( ) , to _ ) . shutdown ( ) ; 
 - logger _ . warn ( LogUtil . throwableToString ( se ) ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - logConnectAndIOException ( e , connection ) ; 
 - } 
 - catch ( Throwable th ) 
 - { 
 - logger _ . warn ( LogUtil . throwableToString ( th ) ) ; 
 - } 
 - finally 
 - { 
 - if ( connection ! = null ) 
 - { 
 - connection . close ( ) ; 
 - } 
 - } 
 - } 
 - 
 - private void logConnectAndIOException ( IOException ex , TcpConnection connection ) 
 - { 
 - if ( connection ! = null ) 
 - { 
 - connection . errorClose ( ) ; 
 - } 
 - logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; 
 - } 
 - } 
 - 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index d38b055 . . f649bb0 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 21 , 12 + 21 , 14 @ @ package org . apache . cassandra . net ; 
 import org . apache . cassandra . concurrent . * ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . net . io . SerializerType ; 
 + import org . apache . cassandra . net . sink . SinkManager ; 
 import org . apache . cassandra . utils . * ; 
 import org . apache . log4j . Logger ; 
 
 import java . io . IOException ; 
 import java . net . MulticastSocket ; 
 import java . net . ServerSocket ; 
 + import java . net . SocketException ; 
 import java . nio . ByteBuffer ; 
 import java . nio . channels . SelectionKey ; 
 import java . nio . channels . ServerSocketChannel ; 
 @ @ - 40 , 8 + 42 , 6 @ @ import java . util . concurrent . locks . ReentrantLock ; 
 
 public class MessagingService implements IMessagingService 
 { 
 - private static boolean debugOn _ = false ; 
 - 
 private static int version _ = 1 ; 
 / / TODO : make this parameter dynamic somehow . Not sure if config is appropriate . 
 private static SerializerType serializerType _ = SerializerType . BINARY ; 
 @ @ - 51 , 7 + 51 , 8 @ @ public class MessagingService implements IMessagingService 
 public static final String responseVerbHandler _ = " RESPONSE " ; 
 / * Stage for responses . * / 
 public static final String responseStage _ = " RESPONSE - STAGE " ; 
 - private enum ReservedVerbs _ { RESPONSE } ; 
 + private enum ReservedVerbs _ { 
 + } ; 
 
 private static Map < String , String > reservedVerbs _ = new Hashtable < String , String > ( ) ; 
 / * Indicate if we are currently streaming data to another node or receiving streaming data * / 
 @ @ - 69 , 15 + 70 , 10 @ @ public class MessagingService implements IMessagingService 
 
 / * Lookup table for registering message handlers based on the verb . * / 
 private static Map < String , IVerbHandler > verbHandlers _ ; 
 - 
 - private static Map < String , MulticastSocket > mCastMembership _ = new HashMap < String , MulticastSocket > ( ) ; 
 - 
 + 
 / * Thread pool to handle messaging read activities of Socket and default stage * / 
 private static ExecutorService messageDeserializationExecutor _ ; 
 
 - / * Thread pool to handle messaging write activities * / 
 - private static ExecutorService messageSerializerExecutor _ ; 
 - 
 / * Thread pool to handle deserialization of messages read from the socket . * / 
 private static ExecutorService messageDeserializerExecutor _ ; 
 
 @ @ - 92 , 48 + 88 , 12 @ @ public class MessagingService implements IMessagingService 
 private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; 
 
 private static IMessagingService messagingService _ = new MessagingService ( ) ; 
 - 
 - public static boolean isDebugOn ( ) 
 - { 
 - return debugOn _ ; 
 - } 
 - 
 - public static void debugOn ( boolean on ) 
 - { 
 - debugOn _ = on ; 
 - } 
 - 
 - public static SerializerType getSerializerType ( ) 
 - { 
 - return serializerType _ ; 
 - } 
 - 
 - public synchronized static void serializerType ( String type ) 
 - { 
 - if ( type . equalsIgnoreCase ( " binary " ) ) 
 - { 
 - serializerType _ = SerializerType . BINARY ; 
 - } 
 - else if ( type . equalsIgnoreCase ( " java " ) ) 
 - { 
 - serializerType _ = SerializerType . JAVA ; 
 - } 
 - else if ( type . equalsIgnoreCase ( " xml " ) ) 
 - { 
 - serializerType _ = SerializerType . XML ; 
 - } 
 - } 
 - 
 + 
 public static int getVersion ( ) 
 { 
 return version _ ; 
 } 
 - 
 - public static void setVersion ( int version ) 
 - { 
 - version _ = version ; 
 - } 
 - 
 + 
 public static IMessagingService getMessagingInstance ( ) 
 { 
 	 if ( bShutdown _ ) 
 @ @ - 186 , 15 + 146 , 7 @ @ public class MessagingService implements IMessagingService 
 new LinkedBlockingQueue < Runnable > ( ) , 
 new ThreadFactoryImpl ( " MESSAGING - SERVICE - POOL " ) 
 ) ; 
 - 
 - messageSerializerExecutor _ = new DebuggableThreadPoolExecutor ( maxSize , 
 - maxSize , 
 - Integer . MAX _ VALUE , 
 - TimeUnit . SECONDS , 
 - new LinkedBlockingQueue < Runnable > ( ) , 
 - new ThreadFactoryImpl ( " MESSAGE - SERIALIZER - POOL " ) 
 - ) ; 
 - 
 + 
 messageDeserializerExecutor _ = new DebuggableThreadPoolExecutor ( maxSize , 
 maxSize , 
 Integer . MAX _ VALUE , 
 @ @ - 284 , 19 + 236 , 6 @ @ public class MessagingService implements IMessagingService 
 return cp ; 
 } 
 
 - public static ConnectionStatistics [ ] getPoolStatistics ( ) 
 - { 
 - Set < ConnectionStatistics > stats = new HashSet < ConnectionStatistics > ( ) ; 
 - Iterator < TcpConnectionManager > it = poolTable _ . values ( ) . iterator ( ) ; 
 - while ( it . hasNext ( ) ) 
 - { 
 - TcpConnectionManager cp = it . next ( ) ; 
 - ConnectionStatistics cs = new ConnectionStatistics ( cp . getLocalEndPoint ( ) , cp . getRemoteEndPoint ( ) , cp . getPoolSize ( ) , cp . getConnectionsInUse ( ) ) ; 
 - stats . add ( cs ) ; 
 - } 
 - return stats . toArray ( new ConnectionStatistics [ 0 ] ) ; 
 - } 
 - 
 public static TcpConnection getConnection ( EndPoint from , EndPoint to ) throws IOException 
 { 
 return getConnectionPool ( from , to ) . getConnection ( ) ; 
 @ @ - 419 , 8 + 358 , 38 @ @ public class MessagingService implements IMessagingService 
 return ; 
 } 
 
 - Runnable tcpWriteEvent = new MessageSerializationTask ( message , to ) ; 
 - messageSerializerExecutor _ . execute ( tcpWriteEvent ) ; 
 + TcpConnection connection = null ; 
 + try 
 + { 
 + Message processedMessage = SinkManager . processClientMessageSink ( message ) ; 
 + if ( processedMessage = = null ) 
 + { 
 + return ; 
 + } 
 + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; 
 + connection . write ( message ) ; 
 + } 
 + catch ( SocketException se ) 
 + { 
 + / / Shutting down the entire pool . May be too conservative an approach . 
 + MessagingService . getConnectionPool ( message . getFrom ( ) , to ) . shutdown ( ) ; 
 + logger _ . error ( " socket error writing to " + to , se ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + if ( connection ! = null ) 
 + { 
 + connection . errorClose ( ) ; 
 + } 
 + logger _ . error ( " unexpected error writing " + message , e ) ; 
 + } 
 + finally 
 + { 
 + if ( connection ! = null ) 
 + { 
 + connection . close ( ) ; 
 + } 
 + } 
 } 
 
 public IAsyncResult sendRR ( Message message , EndPoint to ) 
 @ @ - 463 , 34 + 432 , 12 @ @ public class MessagingService implements IMessagingService 
 Runnable streamingTask = new FileStreamTask ( file , startPosition , total , from , to ) ; 
 streamExecutor _ . execute ( streamingTask ) ; 
 } 
 - 
 - / * 
 - * Does the application determine if we are currently streaming data . 
 - * This would imply either streaming to a receiver , receiving streamed 
 - * data or both . 
 - * / 
 - public static boolean isStreaming ( ) 
 - { 
 - return isStreaming _ . get ( ) ; 
 - } 
 - 
 + 
 public static void setStreamingMode ( boolean bVal ) 
 { 
 isStreaming _ . set ( bVal ) ; 
 } 
 - public static void flushAndshutdown ( ) 
 - { 
 - / / safely shutdown and send all writes 
 - for ( Map . Entry < String , TcpConnectionManager > entry : poolTable _ . entrySet ( ) ) 
 - { 
 - for ( TcpConnection connection : entry . getValue ( ) . getConnections ( ) ) 
 - { 
 - connection . doPendingWrites ( ) ; 
 - } 
 - } 
 - shutdown ( ) ; 
 - } 
 - 
 + 
 public static void shutdown ( ) 
 { 
 logger _ . info ( " Shutting down . . . " ) ; 
 @ @ - 510 , 7 + 457 , 6 @ @ public class MessagingService implements IMessagingService 
 
 / * Shutdown the threads in the EventQueue ' s * / 
 messageDeserializationExecutor _ . shutdownNow ( ) ; 
 - messageSerializerExecutor _ . shutdownNow ( ) ; 
 messageDeserializerExecutor _ . shutdownNow ( ) ; 
 streamExecutor _ . shutdownNow ( ) ; 
 
 @ @ - 534 , 12 + 480 , 7 @ @ public class MessagingService implements IMessagingService 
 { 
 enqueueRunnable ( message . getMessageType ( ) , new MessageDeliveryTask ( message ) ) ; 
 } 
 - 
 - public static boolean isLocalEndPoint ( EndPoint ep ) 
 - { 
 - return ( endPoints _ . contains ( ep ) ) ; 
 - } 
 - 
 + 
 private static void enqueueRunnable ( String stageName , Runnable runnable ) { 
 
 IStage stage = StageManager . getStage ( stageName ) ; 
 @ @ - 550 , 8 + 491 , 8 @ @ public class MessagingService implements IMessagingService 
 } 
 else 
 { 
 - logger _ . info ( " Running on default stage - beware " ) ; 
 - messageSerializerExecutor _ . execute ( runnable ) ; 
 + logger _ . warn ( " Running on default stage - beware " ) ; 
 + messageDeserializerExecutor _ . execute ( runnable ) ; 
 } 
 } 
 
 @ @ - 569 , 27 + 510 , 12 @ @ public class MessagingService implements IMessagingService 
 { 
 return taskCompletionMap _ . remove ( key ) ; 
 } 
 - 
 - public static void removeAsyncResult ( String key ) 
 - { 
 - taskCompletionMap _ . remove ( key ) ; 
 - } 
 
 - public static byte [ ] getProtocol ( ) 
 - { 
 - return protocol _ ; 
 - } 
 - 
 public static ExecutorService getReadExecutor ( ) 
 { 
 return messageDeserializationExecutor _ ; 
 } 
 - 
 - public static ExecutorService getWriteExecutor ( ) 
 - { 
 - return messageSerializerExecutor _ ; 
 - } 
 - 
 + 
 public static ExecutorService getDeserializationExecutor ( ) 
 { 
 return messageDeserializerExecutor _ ; 
 diff - - git a / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java b / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java 
 deleted file mode 100644 
 index 243c3c1 . . 0000000 
 - - - a / src / java / org / apache / cassandra / service / MultiQuorumResponseHandler . java 
 + + + / dev / null 
 @ @ - 1 , 246 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . service ; 
 - 
 - import java . io . IOException ; 
 - import java . util . HashMap ; 
 - import java . util . List ; 
 - import java . util . ArrayList ; 
 - import java . util . Map ; 
 - import java . util . concurrent . atomic . AtomicBoolean ; 
 - import java . util . concurrent . locks . * ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . TimeoutException ; 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . db . ReadCommand ; 
 - import org . apache . cassandra . db . Row ; 
 - import org . apache . cassandra . net . EndPoint ; 
 - import org . apache . cassandra . net . IAsyncCallback ; 
 - import org . apache . cassandra . net . Message ; 
 - import org . apache . cassandra . net . MessagingService ; 
 - import org . apache . cassandra . utils . LogUtil ; 
 - import org . apache . log4j . Logger ; 
 - 
 - public class MultiQuorumResponseHandler implements IAsyncCallback 
 - { 
 - private static Logger logger _ = Logger . getLogger ( QuorumResponseHandler . class ) ; 
 - private Lock lock _ = new ReentrantLock ( ) ; 
 - private Condition condition _ ; 
 - / * This maps the keys to the original data read messages * / 
 - private Map < String , ReadCommand > readMessages _ = new HashMap < String , ReadCommand > ( ) ; 
 - / * This maps the key to its set of replicas * / 
 - private Map < String , EndPoint [ ] > endpoints _ = new HashMap < String , EndPoint [ ] > ( ) ; 
 - / * This maps the groupId to the individual callback for the set of messages * / 
 - private Map < String , SingleQuorumResponseHandler > handlers _ = new HashMap < String , SingleQuorumResponseHandler > ( ) ; 
 - / * This should hold all the responses for the keys * / 
 - private List < Row > responses _ = new ArrayList < Row > ( ) ; 
 - private AtomicBoolean done _ = new AtomicBoolean ( false ) ; 
 - 
 - / * * 
 - * This is used to handle the responses from the individual messages 
 - * that are sent out to the replicas . 
 - * / 
 - private class SingleQuorumResponseHandler implements IAsyncCallback 
 - { 
 - private Lock lock _ = new ReentrantLock ( ) ; 
 - private IResponseResolver < Row > responseResolver _ ; 
 - private List < Message > responses _ = new ArrayList < Message > ( ) ; 
 - 
 - SingleQuorumResponseHandler ( IResponseResolver < Row > responseResolver ) 
 - { 
 - responseResolver _ = responseResolver ; 
 - } 
 - 
 - public void attachContext ( Object o ) 
 - { 
 - throw new UnsupportedOperationException ( " This operation is not supported in this implementation " ) ; 
 - } 
 - 
 - public void response ( Message response ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - responses _ . add ( response ) ; 
 - int majority = ( DatabaseDescriptor . getReplicationFactor ( ) > > 1 ) + 1 ; 
 - if ( responses _ . size ( ) > = majority & & responseResolver _ . isDataPresent ( responses _ ) ) 
 - { 
 - onCompletion ( ) ; 
 - } 
 - } 
 - catch ( IOException ex ) 
 - { 
 - logger _ . info ( LogUtil . throwableToString ( ex ) ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - private void onCompletion ( ) throws IOException 
 - { 
 - try 
 - { 
 - Row row = responseResolver _ . resolve ( responses _ ) ; 
 - MultiQuorumResponseHandler . this . onCompleteResponse ( row ) ; 
 - } 
 - catch ( DigestMismatchException ex ) 
 - { 
 - / * 
 - * The DigestMismatchException has the key for which the mismatch 
 - * occurred bundled in it as context 
 - * / 
 - String key = ex . getMessage ( ) ; 
 - onDigestMismatch ( key ) ; 
 - } 
 - } 
 - 
 - / * * 
 - * This method is invoked on a digest match . We pass in the key 
 - * in order to retrieve the appropriate data message that needs 
 - * to be sent out to the replicas . 
 - * 
 - * @ param key for which the mismatch occurred . 
 - * / 
 - private void onDigestMismatch ( String key ) throws IOException 
 - { 
 - if ( DatabaseDescriptor . getConsistencyCheck ( ) ) 
 - { 
 - ReadCommand readCommand = readMessages _ . get ( key ) ; 
 - readCommand . setDigestQuery ( false ) ; 
 - Message messageRepair = readCommand . makeReadMessage ( ) ; 
 - EndPoint [ ] endpoints = MultiQuorumResponseHandler . this . endpoints _ . get ( readCommand . key ) ; 
 - Message [ ] [ ] messages = new Message [ ] [ ] { { messageRepair , messageRepair , messageRepair } } ; 
 - EndPoint [ ] [ ] epList = new EndPoint [ ] [ ] { endpoints } ; 
 - MessagingService . getMessagingInstance ( ) . sendRR ( messages , epList , MultiQuorumResponseHandler . this ) ; 
 - } 
 - } 
 - } 
 - 
 - public MultiQuorumResponseHandler ( Map < String , ReadCommand > readMessages , Map < String , EndPoint [ ] > endpoints ) 
 - { 
 - condition _ = lock _ . newCondition ( ) ; 
 - readMessages _ = readMessages ; 
 - endpoints _ = endpoints ; 
 - } 
 - 
 - public Row [ ] get ( ) throws TimeoutException 
 - { 
 - long startTime = System . currentTimeMillis ( ) ; 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - boolean bVal = true ; 
 - try 
 - { 
 - if ( ! done _ . get ( ) ) 
 - { 
 - bVal = condition _ . await ( DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) ; 
 - } 
 - } 
 - catch ( InterruptedException ex ) 
 - { 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( LogUtil . throwableToString ( ex ) ) ; 
 - } 
 - 
 - if ( ! bVal & & ! done _ . get ( ) ) 
 - { 
 - StringBuilder sb = new StringBuilder ( " " ) ; 
 - for ( Row row : responses _ ) 
 - { 
 - sb . append ( row . key ( ) ) ; 
 - sb . append ( " : " ) ; 
 - } 
 - throw new TimeoutException ( " Operation timed out - received only " + responses _ . size ( ) + " responses from " + sb . toString ( ) + " . " ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - 
 - logger _ . info ( " MultiQuorumResponseHandler : " + ( System . currentTimeMillis ( ) - startTime ) + " ms . " ) ; 
 - return responses _ . toArray ( new Row [ 0 ] ) ; 
 - } 
 - 
 - / * * 
 - * Invoked when a complete response has been obtained 
 - * for one of the sub - groups a . k . a keys for the query 
 - * has been performed . 
 - * 
 - * @ param row obtained as a result of the response . 
 - * / 
 - void onCompleteResponse ( Row row ) 
 - { 
 - if ( ! done _ . get ( ) ) 
 - { 
 - responses _ . add ( row ) ; 
 - if ( responses _ . size ( ) = = readMessages _ . size ( ) ) 
 - { 
 - done _ . set ( true ) ; 
 - condition _ . signal ( ) ; 
 - } 
 - } 
 - } 
 - 
 - / * * 
 - * The handler of the response message that has been 
 - * sent by one of the replicas for one of the keys . 
 - * 
 - * @ param message the response message for one of the 
 - * message that we sent out . 
 - * / 
 - public void response ( Message message ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - SingleQuorumResponseHandler handler = handlers _ . get ( message . getMessageId ( ) ) ; 
 - handler . response ( message ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - / * * 
 - * The context that is passed in for the query of 
 - * multiple keys in the system . For each message 
 - * id in the context register a callback handler 
 - * for the same . This is done so that all responses 
 - * for a given key use the same callback handler . 
 - * 
 - * @ param o the context which is an array of strings 
 - * corresponding to the message id ' s for each 
 - * key . 
 - * / 
 - public void attachContext ( Object o ) 
 - { 
 - String [ ] gids = ( String [ ] ) o ; 
 - for ( String gid : gids ) 
 - { 
 - IResponseResolver < Row > responseResolver = new ReadResponseResolver ( ) ; 
 - SingleQuorumResponseHandler handler = new SingleQuorumResponseHandler ( responseResolver ) ; 
 - handlers _ . put ( gid , handler ) ; 
 - } 
 - } 
 - }
