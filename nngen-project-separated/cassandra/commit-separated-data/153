BLEU SCORE: 0.049900497019368314

TEST MSG: Fix JSON queries with IN restrictions and ORDER BY clause
GENERATED MSG: Fix secondary index queries regression

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5221b1e . . 967ee05 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 13 <nl> + * Fix JSON queries with IN restrictions and ORDER BY clause ( CASSANDRA - 14286 ) <nl> * CQL fromJson ( null ) throws NullPointerException ( CASSANDRA - 13891 ) <nl> * Fix query pager DEBUG log leak causing hit in paged reads throughput ( CASSANDRA - 14318 ) <nl> * Backport circleci yaml ( CASSANDRA - 14240 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / ResultSet . java b / src / java / org / apache / cassandra / cql3 / ResultSet . java <nl> index 028691f . . 16f0d1b 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / ResultSet . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / ResultSet . java <nl> @ @ - 254 , 6 + 254 , 11 @ @ public class ResultSet <nl> return new ResultMetadata ( EnumSet . copyOf ( flags ) , names , columnCount , pagingState ) ; <nl> } <nl> <nl> + public int getColumnCount ( ) <nl> + { <nl> + return columnCount ; <nl> + } <nl> + <nl> / * * <nl> * Return only the column names requested by the user , excluding those added for post - query re - orderings , <nl> * see definition of names and columnCount . <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / selection / Selection . java b / src / java / org / apache / cassandra / cql3 / selection / Selection . java <nl> index dc4e240 . . 5385fc6 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / selection / Selection . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / selection / Selection . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import com . google . common . base . Objects ; <nl> import com . google . common . base . Predicate ; <nl> import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . Lists ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> @ @ - 56 , 6 + 57 , 8 @ @ public abstract class Selection <nl> private final ResultSet . ResultMetadata metadata ; <nl> private final boolean collectTimestamps ; <nl> private final boolean collectTTLs ; <nl> + / / Columns used to order the result set for multi - partition queries <nl> + private Map < ColumnDefinition , Integer > orderingIndex ; <nl> <nl> protected Selection ( CFMetaData cfm , <nl> List < ColumnDefinition > columns , <nl> @ @ - 130 , 6 + 133 , 24 @ @ public abstract class Selection <nl> return false ; <nl> } <nl> <nl> + public Map < ColumnDefinition , Integer > getOrderingIndex ( boolean isJson ) <nl> + { <nl> + if ( ! isJson ) <nl> + return orderingIndex ; <nl> + <nl> + / / If we order post - query in json , the first and only column that we ship to the client is the json column . <nl> + / / In that case , we should keep ordering columns around to perform the ordering , then these columns will <nl> + / / be placed after the json column . As a consequence of where the colums are placed , we should give the <nl> + / / ordering index a value based on their position in the json encoding and discard the original index . <nl> + / / ( CASSANDRA - 14286 ) <nl> + int columnIndex = 1 ; <nl> + Map < ColumnDefinition , Integer > jsonOrderingIndex = new LinkedHashMap < > ( orderingIndex . size ( ) ) ; <nl> + for ( ColumnDefinition column : orderingIndex . keySet ( ) ) <nl> + jsonOrderingIndex . put ( column , columnIndex + + ) ; <nl> + <nl> + return jsonOrderingIndex ; <nl> + } <nl> + <nl> public ResultSet . ResultMetadata getResultMetadata ( boolean isJson ) <nl> { <nl> if ( ! isJson ) <nl> @ @ - 137 , 7 + 158 , 13 @ @ public abstract class Selection <nl> <nl> ColumnSpecification firstColumn = metadata . names . get ( 0 ) ; <nl> ColumnSpecification jsonSpec = new ColumnSpecification ( firstColumn . ksName , firstColumn . cfName , Json . JSON _ COLUMN _ ID , UTF8Type . instance ) ; <nl> - return new ResultSet . ResultMetadata ( Arrays . asList ( jsonSpec ) ) ; <nl> + ResultSet . ResultMetadata resultMetadata = new ResultSet . ResultMetadata ( Lists . newArrayList ( jsonSpec ) ) ; <nl> + if ( orderingIndex ! = null ) <nl> + { <nl> + for ( ColumnDefinition orderingColumn : orderingIndex . keySet ( ) ) <nl> + resultMetadata . addNonSerializedColumn ( orderingColumn ) ; <nl> + } <nl> + return resultMetadata ; <nl> } <nl> <nl> public static Selection wildcard ( CFMetaData cfm ) <nl> @ @ - 152 , 7 + 179 , 20 @ @ public abstract class Selection <nl> return new SimpleSelection ( cfm , columns , false ) ; <nl> } <nl> <nl> - public int addColumnForOrdering ( ColumnDefinition c ) <nl> + public void addColumnForOrdering ( ColumnDefinition c ) <nl> + { <nl> + if ( orderingIndex = = null ) <nl> + orderingIndex = new LinkedHashMap < > ( ) ; <nl> + <nl> + int index = getResultSetIndex ( c ) ; <nl> + <nl> + if ( index < 0 ) <nl> + index = addOrderingColumn ( c ) ; <nl> + <nl> + orderingIndex . put ( c , index ) ; <nl> + } <nl> + <nl> + protected int addOrderingColumn ( ColumnDefinition c ) <nl> { <nl> columns . add ( c ) ; <nl> metadata . addNonSerializedColumn ( c ) ; <nl> @ @ - 356 , 14 + 396 , 25 @ @ public abstract class Selection <nl> private List < ByteBuffer > getOutputRow ( int protocolVersion ) <nl> { <nl> List < ByteBuffer > outputRow = selectors . getOutputRow ( protocolVersion ) ; <nl> - return isJson ? rowToJson ( outputRow , protocolVersion ) <nl> - : outputRow ; <nl> + if ( isJson ) <nl> + { <nl> + List < ByteBuffer > jsonRow = rowToJson ( outputRow , protocolVersion ) ; <nl> + <nl> + / / Keep ordering columns around for possible post - query ordering . ( CASSANDRA - 14286 ) <nl> + if ( orderingIndex ! = null ) <nl> + { <nl> + for ( Integer orderingColumnIndex : orderingIndex . values ( ) ) <nl> + jsonRow . add ( outputRow . get ( orderingColumnIndex ) ) ; <nl> + } <nl> + outputRow = jsonRow ; <nl> + } <nl> + return outputRow ; <nl> } <nl> <nl> private List < ByteBuffer > rowToJson ( List < ByteBuffer > row , int protocolVersion ) <nl> { <nl> StringBuilder sb = new StringBuilder ( " { " ) ; <nl> - for ( int i = 0 ; i < metadata . names . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < metadata . getColumnCount ( ) ; i + + ) <nl> { <nl> if ( i > 0 ) <nl> sb . append ( " , " ) ; <nl> @ @ - 383 , 7 + 434 , 9 @ @ public abstract class Selection <nl> sb . append ( spec . type . toJSONString ( buffer , protocolVersion ) ) ; <nl> } <nl> sb . append ( " } " ) ; <nl> - return Collections . singletonList ( UTF8Type . instance . getSerializer ( ) . serialize ( sb . toString ( ) ) ) ; <nl> + List < ByteBuffer > jsonRow = new ArrayList < > ( ) ; <nl> + jsonRow . add ( UTF8Type . instance . getSerializer ( ) . serialize ( sb . toString ( ) ) ) ; <nl> + return jsonRow ; <nl> } <nl> <nl> private ByteBuffer value ( Cell c ) <nl> @ @ - 515 , 9 + 568 , 9 @ @ public abstract class Selection <nl> } <nl> <nl> @ Override <nl> - public int addColumnForOrdering ( ColumnDefinition c ) <nl> + protected int addOrderingColumn ( ColumnDefinition c ) <nl> { <nl> - int index = super . addColumnForOrdering ( c ) ; <nl> + int index = super . addOrderingColumn ( c ) ; <nl> factories . addSelectorForOrdering ( c , index ) ; <nl> return factories . size ( ) - 1 ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 13276c7 . . 729cf83 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 842 , 7 + 842 , 7 @ @ public class SelectStatement implements CQLStatement <nl> if ( ! parameters . orderings . isEmpty ( ) ) <nl> { <nl> verifyOrderingIsAllowed ( restrictions ) ; <nl> - orderingComparator = getOrderingComparator ( cfm , selection , restrictions ) ; <nl> + orderingComparator = getOrderingComparator ( cfm , selection , restrictions , parameters . isJson ) ; <nl> isReversed = isReversed ( cfm ) ; <nl> } <nl> <nl> @ @ - 942 , 13 + 942 , 14 @ @ public class SelectStatement implements CQLStatement <nl> <nl> private Comparator < List < ByteBuffer > > getOrderingComparator ( CFMetaData cfm , <nl> Selection selection , <nl> - StatementRestrictions restrictions ) <nl> + StatementRestrictions restrictions , <nl> + boolean isJson ) <nl> throws InvalidRequestException <nl> { <nl> if ( ! restrictions . keyIsInRelation ( ) ) <nl> return null ; <nl> <nl> - Map < ColumnIdentifier , Integer > orderingIndexes = getOrderingIndex ( cfm , selection ) ; <nl> + Map < ColumnDefinition , Integer > orderingIndexes = getOrderingIndex ( cfm , selection , isJson ) ; <nl> <nl> List < Integer > idToSort = new ArrayList < Integer > ( ) ; <nl> List < Comparator < ByteBuffer > > sorters = new ArrayList < Comparator < ByteBuffer > > ( ) ; <nl> @ @ - 957 , 32 + 958 , 28 @ @ public class SelectStatement implements CQLStatement <nl> { <nl> ColumnIdentifier identifier = raw . prepare ( cfm ) ; <nl> ColumnDefinition orderingColumn = cfm . getColumnDefinition ( identifier ) ; <nl> - idToSort . add ( orderingIndexes . get ( orderingColumn . name ) ) ; <nl> + idToSort . add ( orderingIndexes . get ( orderingColumn ) ) ; <nl> sorters . add ( orderingColumn . type ) ; <nl> } <nl> return idToSort . size ( ) = = 1 ? new SingleColumnComparator ( idToSort . get ( 0 ) , sorters . get ( 0 ) ) <nl> : new CompositeComparator ( sorters , idToSort ) ; <nl> } <nl> <nl> - private Map < ColumnIdentifier , Integer > getOrderingIndex ( CFMetaData cfm , Selection selection ) <nl> + private Map < ColumnDefinition , Integer > getOrderingIndex ( CFMetaData cfm , Selection selection , boolean isJson ) <nl> throws InvalidRequestException <nl> { <nl> / / If we order post - query ( see orderResults ) , the sorted column needs to be in the ResultSet for sorting , <nl> / / even if we don ' t <nl> / / ultimately ship them to the client ( CASSANDRA - 4911 ) . <nl> - Map < ColumnIdentifier , Integer > orderingIndexes = new HashMap < > ( ) ; <nl> for ( ColumnIdentifier . Raw raw : parameters . orderings . keySet ( ) ) <nl> { <nl> ColumnIdentifier column = raw . prepare ( cfm ) ; <nl> final ColumnDefinition def = cfm . getColumnDefinition ( column ) ; <nl> if ( def = = null ) <nl> handleUnrecognizedOrderingColumn ( column ) ; <nl> - int index = selection . getResultSetIndex ( def ) ; <nl> - if ( index < 0 ) <nl> - index = selection . addColumnForOrdering ( def ) ; <nl> - orderingIndexes . put ( def . name , index ) ; <nl> + selection . addColumnForOrdering ( def ) ; <nl> } <nl> - return orderingIndexes ; <nl> + return selection . getOrderingIndex ( isJson ) ; <nl> } <nl> <nl> private boolean isReversed ( CFMetaData cfm ) throws InvalidRequestException <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java <nl> index 46cdd52 . . 9d40038 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java <nl> @ @ - 1264 , 4 + 1264 , 25 @ @ public class JsonTest extends CQLTester <nl> executor . shutdown ( ) ; <nl> Assert . assertTrue ( executor . awaitTermination ( 30 , TimeUnit . SECONDS ) ) ; <nl> } <nl> + <nl> + / / CASSANDRA - 14286 <nl> + @ Test <nl> + public void testJsonOrdering ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( PRIMARY KEY ( a , b ) , a INT , b INT ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 20 , 30 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 100 , 200 ) ; " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT JSON a , b FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b " ) , <nl> + row ( " { \ " a \ " : 20 , \ " b \ " : 30 } " ) , <nl> + row ( " { \ " a \ " : 100 , \ " b \ " : 200 } " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT JSON a , b FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b DESC " ) , <nl> + row ( " { \ " a \ " : 100 , \ " b \ " : 200 } " ) , <nl> + row ( " { \ " a \ " : 20 , \ " b \ " : 30 } " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT JSON a FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b DESC " ) , <nl> + row ( " { \ " a \ " : 100 } " ) , <nl> + row ( " { \ " a \ " : 20 } " ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5221b1e . . 967ee05 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 13 
 + * Fix JSON queries with IN restrictions and ORDER BY clause ( CASSANDRA - 14286 ) 
 * CQL fromJson ( null ) throws NullPointerException ( CASSANDRA - 13891 ) 
 * Fix query pager DEBUG log leak causing hit in paged reads throughput ( CASSANDRA - 14318 ) 
 * Backport circleci yaml ( CASSANDRA - 14240 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / ResultSet . java b / src / java / org / apache / cassandra / cql3 / ResultSet . java 
 index 028691f . . 16f0d1b 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / ResultSet . java 
 + + + b / src / java / org / apache / cassandra / cql3 / ResultSet . java 
 @ @ - 254 , 6 + 254 , 11 @ @ public class ResultSet 
 return new ResultMetadata ( EnumSet . copyOf ( flags ) , names , columnCount , pagingState ) ; 
 } 
 
 + public int getColumnCount ( ) 
 + { 
 + return columnCount ; 
 + } 
 + 
 / * * 
 * Return only the column names requested by the user , excluding those added for post - query re - orderings , 
 * see definition of names and columnCount . 
 diff - - git a / src / java / org / apache / cassandra / cql3 / selection / Selection . java b / src / java / org / apache / cassandra / cql3 / selection / Selection . java 
 index dc4e240 . . 5385fc6 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / selection / Selection . java 
 + + + b / src / java / org / apache / cassandra / cql3 / selection / Selection . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import com . google . common . base . Objects ; 
 import com . google . common . base . Predicate ; 
 import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . Lists ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 @ @ - 56 , 6 + 57 , 8 @ @ public abstract class Selection 
 private final ResultSet . ResultMetadata metadata ; 
 private final boolean collectTimestamps ; 
 private final boolean collectTTLs ; 
 + / / Columns used to order the result set for multi - partition queries 
 + private Map < ColumnDefinition , Integer > orderingIndex ; 
 
 protected Selection ( CFMetaData cfm , 
 List < ColumnDefinition > columns , 
 @ @ - 130 , 6 + 133 , 24 @ @ public abstract class Selection 
 return false ; 
 } 
 
 + public Map < ColumnDefinition , Integer > getOrderingIndex ( boolean isJson ) 
 + { 
 + if ( ! isJson ) 
 + return orderingIndex ; 
 + 
 + / / If we order post - query in json , the first and only column that we ship to the client is the json column . 
 + / / In that case , we should keep ordering columns around to perform the ordering , then these columns will 
 + / / be placed after the json column . As a consequence of where the colums are placed , we should give the 
 + / / ordering index a value based on their position in the json encoding and discard the original index . 
 + / / ( CASSANDRA - 14286 ) 
 + int columnIndex = 1 ; 
 + Map < ColumnDefinition , Integer > jsonOrderingIndex = new LinkedHashMap < > ( orderingIndex . size ( ) ) ; 
 + for ( ColumnDefinition column : orderingIndex . keySet ( ) ) 
 + jsonOrderingIndex . put ( column , columnIndex + + ) ; 
 + 
 + return jsonOrderingIndex ; 
 + } 
 + 
 public ResultSet . ResultMetadata getResultMetadata ( boolean isJson ) 
 { 
 if ( ! isJson ) 
 @ @ - 137 , 7 + 158 , 13 @ @ public abstract class Selection 
 
 ColumnSpecification firstColumn = metadata . names . get ( 0 ) ; 
 ColumnSpecification jsonSpec = new ColumnSpecification ( firstColumn . ksName , firstColumn . cfName , Json . JSON _ COLUMN _ ID , UTF8Type . instance ) ; 
 - return new ResultSet . ResultMetadata ( Arrays . asList ( jsonSpec ) ) ; 
 + ResultSet . ResultMetadata resultMetadata = new ResultSet . ResultMetadata ( Lists . newArrayList ( jsonSpec ) ) ; 
 + if ( orderingIndex ! = null ) 
 + { 
 + for ( ColumnDefinition orderingColumn : orderingIndex . keySet ( ) ) 
 + resultMetadata . addNonSerializedColumn ( orderingColumn ) ; 
 + } 
 + return resultMetadata ; 
 } 
 
 public static Selection wildcard ( CFMetaData cfm ) 
 @ @ - 152 , 7 + 179 , 20 @ @ public abstract class Selection 
 return new SimpleSelection ( cfm , columns , false ) ; 
 } 
 
 - public int addColumnForOrdering ( ColumnDefinition c ) 
 + public void addColumnForOrdering ( ColumnDefinition c ) 
 + { 
 + if ( orderingIndex = = null ) 
 + orderingIndex = new LinkedHashMap < > ( ) ; 
 + 
 + int index = getResultSetIndex ( c ) ; 
 + 
 + if ( index < 0 ) 
 + index = addOrderingColumn ( c ) ; 
 + 
 + orderingIndex . put ( c , index ) ; 
 + } 
 + 
 + protected int addOrderingColumn ( ColumnDefinition c ) 
 { 
 columns . add ( c ) ; 
 metadata . addNonSerializedColumn ( c ) ; 
 @ @ - 356 , 14 + 396 , 25 @ @ public abstract class Selection 
 private List < ByteBuffer > getOutputRow ( int protocolVersion ) 
 { 
 List < ByteBuffer > outputRow = selectors . getOutputRow ( protocolVersion ) ; 
 - return isJson ? rowToJson ( outputRow , protocolVersion ) 
 - : outputRow ; 
 + if ( isJson ) 
 + { 
 + List < ByteBuffer > jsonRow = rowToJson ( outputRow , protocolVersion ) ; 
 + 
 + / / Keep ordering columns around for possible post - query ordering . ( CASSANDRA - 14286 ) 
 + if ( orderingIndex ! = null ) 
 + { 
 + for ( Integer orderingColumnIndex : orderingIndex . values ( ) ) 
 + jsonRow . add ( outputRow . get ( orderingColumnIndex ) ) ; 
 + } 
 + outputRow = jsonRow ; 
 + } 
 + return outputRow ; 
 } 
 
 private List < ByteBuffer > rowToJson ( List < ByteBuffer > row , int protocolVersion ) 
 { 
 StringBuilder sb = new StringBuilder ( " { " ) ; 
 - for ( int i = 0 ; i < metadata . names . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < metadata . getColumnCount ( ) ; i + + ) 
 { 
 if ( i > 0 ) 
 sb . append ( " , " ) ; 
 @ @ - 383 , 7 + 434 , 9 @ @ public abstract class Selection 
 sb . append ( spec . type . toJSONString ( buffer , protocolVersion ) ) ; 
 } 
 sb . append ( " } " ) ; 
 - return Collections . singletonList ( UTF8Type . instance . getSerializer ( ) . serialize ( sb . toString ( ) ) ) ; 
 + List < ByteBuffer > jsonRow = new ArrayList < > ( ) ; 
 + jsonRow . add ( UTF8Type . instance . getSerializer ( ) . serialize ( sb . toString ( ) ) ) ; 
 + return jsonRow ; 
 } 
 
 private ByteBuffer value ( Cell c ) 
 @ @ - 515 , 9 + 568 , 9 @ @ public abstract class Selection 
 } 
 
 @ Override 
 - public int addColumnForOrdering ( ColumnDefinition c ) 
 + protected int addOrderingColumn ( ColumnDefinition c ) 
 { 
 - int index = super . addColumnForOrdering ( c ) ; 
 + int index = super . addOrderingColumn ( c ) ; 
 factories . addSelectorForOrdering ( c , index ) ; 
 return factories . size ( ) - 1 ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 13276c7 . . 729cf83 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 842 , 7 + 842 , 7 @ @ public class SelectStatement implements CQLStatement 
 if ( ! parameters . orderings . isEmpty ( ) ) 
 { 
 verifyOrderingIsAllowed ( restrictions ) ; 
 - orderingComparator = getOrderingComparator ( cfm , selection , restrictions ) ; 
 + orderingComparator = getOrderingComparator ( cfm , selection , restrictions , parameters . isJson ) ; 
 isReversed = isReversed ( cfm ) ; 
 } 
 
 @ @ - 942 , 13 + 942 , 14 @ @ public class SelectStatement implements CQLStatement 
 
 private Comparator < List < ByteBuffer > > getOrderingComparator ( CFMetaData cfm , 
 Selection selection , 
 - StatementRestrictions restrictions ) 
 + StatementRestrictions restrictions , 
 + boolean isJson ) 
 throws InvalidRequestException 
 { 
 if ( ! restrictions . keyIsInRelation ( ) ) 
 return null ; 
 
 - Map < ColumnIdentifier , Integer > orderingIndexes = getOrderingIndex ( cfm , selection ) ; 
 + Map < ColumnDefinition , Integer > orderingIndexes = getOrderingIndex ( cfm , selection , isJson ) ; 
 
 List < Integer > idToSort = new ArrayList < Integer > ( ) ; 
 List < Comparator < ByteBuffer > > sorters = new ArrayList < Comparator < ByteBuffer > > ( ) ; 
 @ @ - 957 , 32 + 958 , 28 @ @ public class SelectStatement implements CQLStatement 
 { 
 ColumnIdentifier identifier = raw . prepare ( cfm ) ; 
 ColumnDefinition orderingColumn = cfm . getColumnDefinition ( identifier ) ; 
 - idToSort . add ( orderingIndexes . get ( orderingColumn . name ) ) ; 
 + idToSort . add ( orderingIndexes . get ( orderingColumn ) ) ; 
 sorters . add ( orderingColumn . type ) ; 
 } 
 return idToSort . size ( ) = = 1 ? new SingleColumnComparator ( idToSort . get ( 0 ) , sorters . get ( 0 ) ) 
 : new CompositeComparator ( sorters , idToSort ) ; 
 } 
 
 - private Map < ColumnIdentifier , Integer > getOrderingIndex ( CFMetaData cfm , Selection selection ) 
 + private Map < ColumnDefinition , Integer > getOrderingIndex ( CFMetaData cfm , Selection selection , boolean isJson ) 
 throws InvalidRequestException 
 { 
 / / If we order post - query ( see orderResults ) , the sorted column needs to be in the ResultSet for sorting , 
 / / even if we don ' t 
 / / ultimately ship them to the client ( CASSANDRA - 4911 ) . 
 - Map < ColumnIdentifier , Integer > orderingIndexes = new HashMap < > ( ) ; 
 for ( ColumnIdentifier . Raw raw : parameters . orderings . keySet ( ) ) 
 { 
 ColumnIdentifier column = raw . prepare ( cfm ) ; 
 final ColumnDefinition def = cfm . getColumnDefinition ( column ) ; 
 if ( def = = null ) 
 handleUnrecognizedOrderingColumn ( column ) ; 
 - int index = selection . getResultSetIndex ( def ) ; 
 - if ( index < 0 ) 
 - index = selection . addColumnForOrdering ( def ) ; 
 - orderingIndexes . put ( def . name , index ) ; 
 + selection . addColumnForOrdering ( def ) ; 
 } 
 - return orderingIndexes ; 
 + return selection . getOrderingIndex ( isJson ) ; 
 } 
 
 private boolean isReversed ( CFMetaData cfm ) throws InvalidRequestException 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java 
 index 46cdd52 . . 9d40038 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / JsonTest . java 
 @ @ - 1264 , 4 + 1264 , 25 @ @ public class JsonTest extends CQLTester 
 executor . shutdown ( ) ; 
 Assert . assertTrue ( executor . awaitTermination ( 30 , TimeUnit . SECONDS ) ) ; 
 } 
 + 
 + / / CASSANDRA - 14286 
 + @ Test 
 + public void testJsonOrdering ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( PRIMARY KEY ( a , b ) , a INT , b INT ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 20 , 30 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 100 , 200 ) ; " ) ; 
 + 
 + assertRows ( execute ( " SELECT JSON a , b FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b " ) , 
 + row ( " { \ " a \ " : 20 , \ " b \ " : 30 } " ) , 
 + row ( " { \ " a \ " : 100 , \ " b \ " : 200 } " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT JSON a , b FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b DESC " ) , 
 + row ( " { \ " a \ " : 100 , \ " b \ " : 200 } " ) , 
 + row ( " { \ " a \ " : 20 , \ " b \ " : 30 } " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT JSON a FROM % s WHERE a IN ( 20 , 100 ) ORDER BY b DESC " ) , 
 + row ( " { \ " a \ " : 100 } " ) , 
 + row ( " { \ " a \ " : 20 } " ) ) ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
