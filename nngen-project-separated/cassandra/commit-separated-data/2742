BLEU SCORE: 0.027611988917697356

TEST MSG: Optimize CollationController . collectTimeOrderedData post CASSANDRA - 6662
GENERATED MSG: Improve CQL3 batchlog support

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index a6153e4 . . 8049d87 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 186 , 8 + 186 , 11 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns <nl> } <nl> else <nl> { <nl> - / / Append to the end , making cells unsorted from now on <nl> - internalAdd ( cell ) ; <nl> + int pos = binarySearch ( cell . name ( ) ) ; <nl> + if ( pos > = 0 ) / / Reconcile with an existing cell <nl> + reconcileWith ( pos , cell ) ; <nl> + else <nl> + internalAdd ( cell ) ; / / Append to the end , making cells unsorted from now on <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java <nl> index 3fd3e8b . . e5d3495 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CollationController . java <nl> + + + b / src / java / org / apache / cassandra / db / CollationController . java <nl> @ @ - 62 , 16 + 62 , 10 @ @ public class CollationController <nl> private ColumnFamily collectTimeOrderedData ( ) <nl> { <nl> final ColumnFamily container = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; <nl> - List < OnDiskAtomIterator > iterators = new ArrayList < OnDiskAtomIterator > ( ) ; <nl> + List < OnDiskAtomIterator > iterators = new ArrayList < > ( ) ; <nl> Tracing . trace ( " Acquiring sstable references " ) ; <nl> ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; <nl> <nl> - / / We use a temporary CF object per memtable or sstable source so we can accomodate this . factory being ABSC , <nl> - / / which requires addAtom to happen in sorted order . Then we use addAll to merge into the final collection , <nl> - / / which allows a ( sorted ) set of columns to be merged even if they are not uniformly sorted after the existing <nl> - / / ones . <nl> - ColumnFamily temp = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; <nl> - <nl> try <nl> { <nl> Tracing . trace ( " Merging memtable contents " ) ; <nl> @ @ - 81 , 13 + 75 , 10 @ @ public class CollationController <nl> if ( iter ! = null ) <nl> { <nl> iterators . add ( iter ) ; <nl> - temp . delete ( iter . getColumnFamily ( ) ) ; <nl> + container . delete ( iter . getColumnFamily ( ) ) ; <nl> while ( iter . hasNext ( ) ) <nl> - temp . addAtom ( iter . next ( ) ) ; <nl> + container . addAtom ( iter . next ( ) ) ; <nl> } <nl> - <nl> - container . addAll ( temp ) ; <nl> - temp . clear ( ) ; <nl> } <nl> <nl> / / avoid changing the filter columns of the original filter <nl> @ @ - 122 , 14 + 113 , 11 @ @ public class CollationController <nl> ColumnFamily cf = iter . getColumnFamily ( ) ; <nl> if ( cf . isMarkedForDelete ( ) ) <nl> mostRecentRowTombstone = cf . deletionInfo ( ) . getTopLevelDeletion ( ) . markedForDeleteAt ; <nl> - temp . delete ( cf ) ; <nl> + container . delete ( cf ) ; <nl> sstablesIterated + + ; <nl> while ( iter . hasNext ( ) ) <nl> - temp . addAtom ( iter . next ( ) ) ; <nl> + container . addAtom ( iter . next ( ) ) ; <nl> } <nl> - <nl> - container . addAll ( temp ) ; <nl> - temp . clear ( ) ; <nl> } <nl> <nl> / / we need to distinguish between " there is no data at all for this row " ( BF will let us rebuild that efficiently ) <nl> @ @ - 189 , 7 + 177 , 7 @ @ public class CollationController <nl> { <nl> Tracing . trace ( " Acquiring sstable references " ) ; <nl> ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; <nl> - List < OnDiskAtomIterator > iterators = new ArrayList < OnDiskAtomIterator > ( Iterables . size ( view . memtables ) + view . sstables . size ( ) ) ; <nl> + List < OnDiskAtomIterator > iterators = new ArrayList < > ( Iterables . size ( view . memtables ) + view . sstables . size ( ) ) ; <nl> ColumnFamily returnCF = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; <nl> <nl> try <nl> @ @ - 238 , 7 + 226 , 7 @ @ public class CollationController <nl> if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ! = Integer . MAX _ VALUE ) <nl> { <nl> if ( skippedSSTables = = null ) <nl> - skippedSSTables = new ArrayList < SSTableReader > ( ) ; <nl> + skippedSSTables = new ArrayList < > ( ) ; <nl> skippedSSTables . add ( sstable ) ; <nl> } <nl> continue ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1363c22 . . e922c3c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 13 , 6 + 13 , 7 @ @ <nl> * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) <nl> * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) <nl> * add authentication support to sstableloader ( CASSANDRA - 4712 ) <nl> + * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) <nl> Merged from 1 . 0 : <nl> * Switch from NBHM to CHM in MessagingService ' s callback map , which <nl> prevents OOM in long - running instances ( CASSANDRA - 4708 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index bbddee3 . . fac0deb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 88 , 10 + 88 , 16 @ @ public class SelectStatement implements CQLStatement <nl> START ( 0 ) , END ( 1 ) ; <nl> <nl> public final int idx ; <nl> + <nl> Bound ( int idx ) <nl> { <nl> this . idx = idx ; <nl> } <nl> + <nl> + public static Bound reverse ( Bound b ) <nl> + { <nl> + return b = = START ? END : START ; <nl> + } <nl> } ; <nl> <nl> public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters ) <nl> @ @ - 189 , 8 + 195 , 8 @ @ public class SelectStatement implements CQLStatement <nl> / / . . . a range ( slice ) of column names <nl> if ( isColumnRange ( ) ) <nl> { <nl> - ByteBuffer start = getRequestedBound ( isReversed ? Bound . END : Bound . START , variables ) ; <nl> - ByteBuffer finish = getRequestedBound ( isReversed ? Bound . START : Bound . END , variables ) ; <nl> + ByteBuffer start = getRequestedBound ( Bound . START , variables ) ; <nl> + ByteBuffer finish = getRequestedBound ( Bound . END , variables ) ; <nl> <nl> / / Note that we use the total limit for every key . This is <nl> / / potentially inefficient , but then again , IN + LIMIT is not a <nl> @ @ - 478 , 13 + 484 , 18 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> <nl> - private ByteBuffer getRequestedBound ( Bound b , List < ByteBuffer > variables ) throws InvalidRequestException <nl> + private ByteBuffer getRequestedBound ( Bound bound , List < ByteBuffer > variables ) throws InvalidRequestException <nl> { <nl> assert isColumnRange ( ) ; <nl> <nl> ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; <nl> - for ( Restriction r : columnRestrictions ) <nl> + for ( CFDefinition . Name name : cfDef . columns . values ( ) ) <nl> { <nl> + / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . <nl> + / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . <nl> + / / But if the actual comparator itself is reversed , we must inversed the bounds too . <nl> + Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; <nl> + Restriction r = columnRestrictions [ name . position ] ; <nl> if ( r = = null | | ( ! r . isEquality ( ) & & r . bound ( b ) = = null ) ) <nl> { <nl> / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . <nl> @ @ - 926 , 6 + 937 , 11 @ @ public class SelectStatement implements CQLStatement <nl> return new CqlRow ( key , thriftColumns ) ; <nl> } <nl> <nl> + private static boolean isReversedType ( CFDefinition . Name name ) <nl> + { <nl> + return name . type instanceof ReversedType ; <nl> + } <nl> + <nl> public static class RawStatement extends CFStatement <nl> { <nl> private final Parameters parameters ; <nl> @ @ - 1159 , 11 + 1175 , 6 @ @ public class SelectStatement implements CQLStatement <nl> return new ParsedStatement . Prepared ( stmt , Arrays . < CFDefinition . Name > asList ( names ) ) ; <nl> } <nl> <nl> - private static boolean isReversedType ( CFDefinition . Name name ) <nl> - { <nl> - return name . type instanceof ReversedType ; <nl> - } <nl> - <nl> Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel ) throws InvalidRequestException <nl> { <nl> if ( newRel . onToken & & name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index a6153e4 . . 8049d87 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 186 , 8 + 186 , 11 @ @ public class ArrayBackedSortedColumns extends AbstractThreadUnsafeSortedColumns 
 } 
 else 
 { 
 - / / Append to the end , making cells unsorted from now on 
 - internalAdd ( cell ) ; 
 + int pos = binarySearch ( cell . name ( ) ) ; 
 + if ( pos > = 0 ) / / Reconcile with an existing cell 
 + reconcileWith ( pos , cell ) ; 
 + else 
 + internalAdd ( cell ) ; / / Append to the end , making cells unsorted from now on 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / CollationController . java b / src / java / org / apache / cassandra / db / CollationController . java 
 index 3fd3e8b . . e5d3495 100644 
 - - - a / src / java / org / apache / cassandra / db / CollationController . java 
 + + + b / src / java / org / apache / cassandra / db / CollationController . java 
 @ @ - 62 , 16 + 62 , 10 @ @ public class CollationController 
 private ColumnFamily collectTimeOrderedData ( ) 
 { 
 final ColumnFamily container = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; 
 - List < OnDiskAtomIterator > iterators = new ArrayList < OnDiskAtomIterator > ( ) ; 
 + List < OnDiskAtomIterator > iterators = new ArrayList < > ( ) ; 
 Tracing . trace ( " Acquiring sstable references " ) ; 
 ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; 
 
 - / / We use a temporary CF object per memtable or sstable source so we can accomodate this . factory being ABSC , 
 - / / which requires addAtom to happen in sorted order . Then we use addAll to merge into the final collection , 
 - / / which allows a ( sorted ) set of columns to be merged even if they are not uniformly sorted after the existing 
 - / / ones . 
 - ColumnFamily temp = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; 
 - 
 try 
 { 
 Tracing . trace ( " Merging memtable contents " ) ; 
 @ @ - 81 , 13 + 75 , 10 @ @ public class CollationController 
 if ( iter ! = null ) 
 { 
 iterators . add ( iter ) ; 
 - temp . delete ( iter . getColumnFamily ( ) ) ; 
 + container . delete ( iter . getColumnFamily ( ) ) ; 
 while ( iter . hasNext ( ) ) 
 - temp . addAtom ( iter . next ( ) ) ; 
 + container . addAtom ( iter . next ( ) ) ; 
 } 
 - 
 - container . addAll ( temp ) ; 
 - temp . clear ( ) ; 
 } 
 
 / / avoid changing the filter columns of the original filter 
 @ @ - 122 , 14 + 113 , 11 @ @ public class CollationController 
 ColumnFamily cf = iter . getColumnFamily ( ) ; 
 if ( cf . isMarkedForDelete ( ) ) 
 mostRecentRowTombstone = cf . deletionInfo ( ) . getTopLevelDeletion ( ) . markedForDeleteAt ; 
 - temp . delete ( cf ) ; 
 + container . delete ( cf ) ; 
 sstablesIterated + + ; 
 while ( iter . hasNext ( ) ) 
 - temp . addAtom ( iter . next ( ) ) ; 
 + container . addAtom ( iter . next ( ) ) ; 
 } 
 - 
 - container . addAll ( temp ) ; 
 - temp . clear ( ) ; 
 } 
 
 / / we need to distinguish between " there is no data at all for this row " ( BF will let us rebuild that efficiently ) 
 @ @ - 189 , 7 + 177 , 7 @ @ public class CollationController 
 { 
 Tracing . trace ( " Acquiring sstable references " ) ; 
 ColumnFamilyStore . ViewFragment view = cfs . markReferenced ( filter . key ) ; 
 - List < OnDiskAtomIterator > iterators = new ArrayList < OnDiskAtomIterator > ( Iterables . size ( view . memtables ) + view . sstables . size ( ) ) ; 
 + List < OnDiskAtomIterator > iterators = new ArrayList < > ( Iterables . size ( view . memtables ) + view . sstables . size ( ) ) ; 
 ColumnFamily returnCF = ArrayBackedSortedColumns . factory . create ( cfs . metadata , filter . filter . isReversed ( ) ) ; 
 
 try 
 @ @ - 238 , 7 + 226 , 7 @ @ public class CollationController 
 if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ! = Integer . MAX _ VALUE ) 
 { 
 if ( skippedSSTables = = null ) 
 - skippedSSTables = new ArrayList < SSTableReader > ( ) ; 
 + skippedSSTables = new ArrayList < > ( ) ; 
 skippedSSTables . add ( sstable ) ; 
 } 
 continue ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1363c22 . . e922c3c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 13 , 6 + 13 , 7 @ @ 
 * fix re - created keyspace disappering after 1 . 1 . 5 upgrade ( CASSANDRA - 4698 ) 
 * ( CLI ) display elapsed time in 2 fraction digits ( CASSANDRA - 3460 ) 
 * add authentication support to sstableloader ( CASSANDRA - 4712 ) 
 + * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) 
 Merged from 1 . 0 : 
 * Switch from NBHM to CHM in MessagingService ' s callback map , which 
 prevents OOM in long - running instances ( CASSANDRA - 4708 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index bbddee3 . . fac0deb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 88 , 10 + 88 , 16 @ @ public class SelectStatement implements CQLStatement 
 START ( 0 ) , END ( 1 ) ; 
 
 public final int idx ; 
 + 
 Bound ( int idx ) 
 { 
 this . idx = idx ; 
 } 
 + 
 + public static Bound reverse ( Bound b ) 
 + { 
 + return b = = START ? END : START ; 
 + } 
 } ; 
 
 public SelectStatement ( CFDefinition cfDef , int boundTerms , Parameters parameters ) 
 @ @ - 189 , 8 + 195 , 8 @ @ public class SelectStatement implements CQLStatement 
 / / . . . a range ( slice ) of column names 
 if ( isColumnRange ( ) ) 
 { 
 - ByteBuffer start = getRequestedBound ( isReversed ? Bound . END : Bound . START , variables ) ; 
 - ByteBuffer finish = getRequestedBound ( isReversed ? Bound . START : Bound . END , variables ) ; 
 + ByteBuffer start = getRequestedBound ( Bound . START , variables ) ; 
 + ByteBuffer finish = getRequestedBound ( Bound . END , variables ) ; 
 
 / / Note that we use the total limit for every key . This is 
 / / potentially inefficient , but then again , IN + LIMIT is not a 
 @ @ - 478 , 13 + 484 , 18 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 
 - private ByteBuffer getRequestedBound ( Bound b , List < ByteBuffer > variables ) throws InvalidRequestException 
 + private ByteBuffer getRequestedBound ( Bound bound , List < ByteBuffer > variables ) throws InvalidRequestException 
 { 
 assert isColumnRange ( ) ; 
 
 ColumnNameBuilder builder = cfDef . getColumnNameBuilder ( ) ; 
 - for ( Restriction r : columnRestrictions ) 
 + for ( CFDefinition . Name name : cfDef . columns . values ( ) ) 
 { 
 + / / In a restriction , we always have Bound . START < Bound . END for the " base " comparator . 
 + / / So if we ' re doing a reverse slice , we must inverse the bounds when giving them as start and end of the slice filter . 
 + / / But if the actual comparator itself is reversed , we must inversed the bounds too . 
 + Bound b = isReversed = = isReversedType ( name ) ? bound : Bound . reverse ( bound ) ; 
 + Restriction r = columnRestrictions [ name . position ] ; 
 if ( r = = null | | ( ! r . isEquality ( ) & & r . bound ( b ) = = null ) ) 
 { 
 / / There wasn ' t any non EQ relation on that key , we select all records having the preceding component as prefix . 
 @ @ - 926 , 6 + 937 , 11 @ @ public class SelectStatement implements CQLStatement 
 return new CqlRow ( key , thriftColumns ) ; 
 } 
 
 + private static boolean isReversedType ( CFDefinition . Name name ) 
 + { 
 + return name . type instanceof ReversedType ; 
 + } 
 + 
 public static class RawStatement extends CFStatement 
 { 
 private final Parameters parameters ; 
 @ @ - 1159 , 11 + 1175 , 6 @ @ public class SelectStatement implements CQLStatement 
 return new ParsedStatement . Prepared ( stmt , Arrays . < CFDefinition . Name > asList ( names ) ) ; 
 } 
 
 - private static boolean isReversedType ( CFDefinition . Name name ) 
 - { 
 - return name . type instanceof ReversedType ; 
 - } 
 - 
 Restriction updateRestriction ( CFDefinition . Name name , Restriction restriction , Relation newRel ) throws InvalidRequestException 
 { 
 if ( newRel . onToken & & name . kind ! = CFDefinition . Name . Kind . KEY _ ALIAS )
