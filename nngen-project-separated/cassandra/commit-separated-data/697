BLEU SCORE: 0.044568827606990644

TEST MSG: Fix clean interval not sent to commit log for empty memtable flush
GENERATED MSG: Fix truncate to always call flush on table

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 959b967 . . cccb62d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Fix clean interval not sent to commit log for empty memtable flush ( CASSANDRA - 12436 ) <nl> * Fix potential resource leak in RMIServerSocketFactoryImpl ( CASSANDRA - 12331 ) <nl> * Backport CASSANDRA - 12002 ( CASSANDRA - 12177 ) <nl> * Make sure compaction stats are updated when compaction is interrupted ( CASSANDRA - 12100 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 82604e2 . . 6c02909 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1039 , 20 + 1039 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> writeBarrier . markBlocking ( ) ; <nl> writeBarrier . await ( ) ; <nl> <nl> - / / mark all memtables as flushing , removing them from the live memtable list , and <nl> - / / remove any memtables that are already clean from the set we need to flush <nl> - Iterator < Memtable > iter = memtables . iterator ( ) ; <nl> - while ( iter . hasNext ( ) ) <nl> - { <nl> - Memtable memtable = iter . next ( ) ; <nl> + / / mark all memtables as flushing , removing them from the live memtable list <nl> + for ( Memtable memtable : memtables ) <nl> memtable . cfs . data . markFlushing ( memtable ) ; <nl> - if ( memtable . isClean ( ) | | truncate ) <nl> - { <nl> - memtable . cfs . replaceFlushed ( memtable , Collections . emptyList ( ) ) ; <nl> - reclaim ( memtable ) ; <nl> - iter . remove ( ) ; <nl> - } <nl> - } <nl> <nl> metric . memtableSwitchCount . inc ( ) ; <nl> <nl> @ @ - 1060 , 7 + 1049 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> for ( Memtable memtable : memtables ) <nl> { <nl> - Collection < SSTableReader > readers = memtable . flush ( ) ; <nl> + Collection < SSTableReader > readers = Collections . emptyList ( ) ; <nl> + if ( ! memtable . isClean ( ) & & ! truncate ) <nl> + readers = memtable . flush ( ) ; <nl> memtable . cfs . replaceFlushed ( memtable , readers ) ; <nl> reclaim ( memtable ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index dfe3f91 . . d167735 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 313 , 8 + 313 , 9 @ @ public class CommitLog implements CommitLogMBean <nl> } <nl> else <nl> { <nl> - logger . trace ( " Not safe to delete { } commit log segment { } ; dirty is { } " , <nl> - ( iter . hasNext ( ) ? " " : " active " ) , segment , segment . dirtyString ( ) ) ; <nl> + if ( logger . isTraceEnabled ( ) ) <nl> + logger . trace ( " Not safe to delete { } commit log segment { } ; dirty is { } " , <nl> + ( iter . hasNext ( ) ? " " : " active " ) , segment , segment . dirtyString ( ) ) ; <nl> } <nl> <nl> / / Don ' t mark or try to delete any newer segments once we ' ve reached the one containing the <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index d2f12bf . . 0a03c3c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 536 , 7 + 536 , 10 @ @ public abstract class CommitLogSegment <nl> for ( UUID cfId : getDirtyCFIDs ( ) ) <nl> { <nl> CFMetaData m = Schema . instance . getCFMetaData ( cfId ) ; <nl> - sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) . append ( " ) , " ) ; <nl> + sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) <nl> + . append ( " , dirty : " ) . append ( cfDirty . get ( cfId ) ) <nl> + . append ( " , clean : " ) . append ( cfClean . get ( cfId ) ) <nl> + . append ( " ) , " ) ; <nl> } <nl> return sb . toString ( ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java <nl> new file mode 100644 <nl> index 0000000 . . 8537ebb <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java <nl> @ @ - 0 , 0 + 1 , 41 @ @ <nl> + package org . apache . cassandra . db . commitlog ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . Collection ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + <nl> + public class CommitLogCQLTest extends CQLTester <nl> + { <nl> + @ Test <nl> + public void testTruncateSegmentDiscard ( ) throws Throwable <nl> + { <nl> + String otherTable = createTable ( " CREATE TABLE % s ( idx INT , data TEXT , PRIMARY KEY ( idx ) ) ; " ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( idx INT , data TEXT , PRIMARY KEY ( idx ) ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( idx , data ) VALUES ( ? , ? ) " , 15 , Integer . toString ( 15 ) ) ; <nl> + flush ( ) ; <nl> + <nl> + / / We write something in different table to advance the commit log position . Current table remains clean . <nl> + execute ( String . format ( " INSERT INTO % s . % s ( idx , data ) VALUES ( ? , ? ) " , keyspace ( ) , otherTable ) , 16 , Integer . toString ( 16 ) ) ; <nl> + <nl> + ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; <nl> + assert cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . isClean ( ) ; <nl> + / / Calling switchMemtable directly applies Flush even though memtable is empty . This can happen with some races <nl> + / / ( flush with recycling by segment manager ) . It should still tell commitlog that the memtable ' s region is clean . <nl> + / / CASSANDRA - 12436 <nl> + cfs . switchMemtable ( ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( idx , data ) VALUES ( ? , ? ) " , 15 , Integer . toString ( 17 ) ) ; <nl> + <nl> + Collection < CommitLogSegment > active = new ArrayList < > ( CommitLog . instance . allocator . getActiveSegments ( ) ) ; <nl> + CommitLog . instance . forceRecycleAllSegments ( ) ; <nl> + <nl> + / / If one of the previous segments remains , it wasn ' t clean . <nl> + active . retainAll ( CommitLog . instance . allocator . getActiveSegments ( ) ) ; <nl> + assert active . isEmpty ( ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 959b967 . . cccb62d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Fix clean interval not sent to commit log for empty memtable flush ( CASSANDRA - 12436 ) 
 * Fix potential resource leak in RMIServerSocketFactoryImpl ( CASSANDRA - 12331 ) 
 * Backport CASSANDRA - 12002 ( CASSANDRA - 12177 ) 
 * Make sure compaction stats are updated when compaction is interrupted ( CASSANDRA - 12100 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 82604e2 . . 6c02909 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1039 , 20 + 1039 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 writeBarrier . markBlocking ( ) ; 
 writeBarrier . await ( ) ; 
 
 - / / mark all memtables as flushing , removing them from the live memtable list , and 
 - / / remove any memtables that are already clean from the set we need to flush 
 - Iterator < Memtable > iter = memtables . iterator ( ) ; 
 - while ( iter . hasNext ( ) ) 
 - { 
 - Memtable memtable = iter . next ( ) ; 
 + / / mark all memtables as flushing , removing them from the live memtable list 
 + for ( Memtable memtable : memtables ) 
 memtable . cfs . data . markFlushing ( memtable ) ; 
 - if ( memtable . isClean ( ) | | truncate ) 
 - { 
 - memtable . cfs . replaceFlushed ( memtable , Collections . emptyList ( ) ) ; 
 - reclaim ( memtable ) ; 
 - iter . remove ( ) ; 
 - } 
 - } 
 
 metric . memtableSwitchCount . inc ( ) ; 
 
 @ @ - 1060 , 7 + 1049 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 for ( Memtable memtable : memtables ) 
 { 
 - Collection < SSTableReader > readers = memtable . flush ( ) ; 
 + Collection < SSTableReader > readers = Collections . emptyList ( ) ; 
 + if ( ! memtable . isClean ( ) & & ! truncate ) 
 + readers = memtable . flush ( ) ; 
 memtable . cfs . replaceFlushed ( memtable , readers ) ; 
 reclaim ( memtable ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index dfe3f91 . . d167735 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 313 , 8 + 313 , 9 @ @ public class CommitLog implements CommitLogMBean 
 } 
 else 
 { 
 - logger . trace ( " Not safe to delete { } commit log segment { } ; dirty is { } " , 
 - ( iter . hasNext ( ) ? " " : " active " ) , segment , segment . dirtyString ( ) ) ; 
 + if ( logger . isTraceEnabled ( ) ) 
 + logger . trace ( " Not safe to delete { } commit log segment { } ; dirty is { } " , 
 + ( iter . hasNext ( ) ? " " : " active " ) , segment , segment . dirtyString ( ) ) ; 
 } 
 
 / / Don ' t mark or try to delete any newer segments once we ' ve reached the one containing the 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index d2f12bf . . 0a03c3c 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 536 , 7 + 536 , 10 @ @ public abstract class CommitLogSegment 
 for ( UUID cfId : getDirtyCFIDs ( ) ) 
 { 
 CFMetaData m = Schema . instance . getCFMetaData ( cfId ) ; 
 - sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) . append ( " ) , " ) ; 
 + sb . append ( m = = null ? " < deleted > " : m . cfName ) . append ( " ( " ) . append ( cfId ) 
 + . append ( " , dirty : " ) . append ( cfDirty . get ( cfId ) ) 
 + . append ( " , clean : " ) . append ( cfClean . get ( cfId ) ) 
 + . append ( " ) , " ) ; 
 } 
 return sb . toString ( ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java 
 new file mode 100644 
 index 0000000 . . 8537ebb 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogCQLTest . java 
 @ @ - 0 , 0 + 1 , 41 @ @ 
 + package org . apache . cassandra . db . commitlog ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . Collection ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + 
 + public class CommitLogCQLTest extends CQLTester 
 + { 
 + @ Test 
 + public void testTruncateSegmentDiscard ( ) throws Throwable 
 + { 
 + String otherTable = createTable ( " CREATE TABLE % s ( idx INT , data TEXT , PRIMARY KEY ( idx ) ) ; " ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( idx INT , data TEXT , PRIMARY KEY ( idx ) ) ; " ) ; 
 + execute ( " INSERT INTO % s ( idx , data ) VALUES ( ? , ? ) " , 15 , Integer . toString ( 15 ) ) ; 
 + flush ( ) ; 
 + 
 + / / We write something in different table to advance the commit log position . Current table remains clean . 
 + execute ( String . format ( " INSERT INTO % s . % s ( idx , data ) VALUES ( ? , ? ) " , keyspace ( ) , otherTable ) , 16 , Integer . toString ( 16 ) ) ; 
 + 
 + ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; 
 + assert cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . isClean ( ) ; 
 + / / Calling switchMemtable directly applies Flush even though memtable is empty . This can happen with some races 
 + / / ( flush with recycling by segment manager ) . It should still tell commitlog that the memtable ' s region is clean . 
 + / / CASSANDRA - 12436 
 + cfs . switchMemtable ( ) ; 
 + 
 + execute ( " INSERT INTO % s ( idx , data ) VALUES ( ? , ? ) " , 15 , Integer . toString ( 17 ) ) ; 
 + 
 + Collection < CommitLogSegment > active = new ArrayList < > ( CommitLog . instance . allocator . getActiveSegments ( ) ) ; 
 + CommitLog . instance . forceRecycleAllSegments ( ) ; 
 + 
 + / / If one of the previous segments remains , it wasn ' t clean . 
 + active . retainAll ( CommitLog . instance . allocator . getActiveSegments ( ) ) ; 
 + assert active . isEmpty ( ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
