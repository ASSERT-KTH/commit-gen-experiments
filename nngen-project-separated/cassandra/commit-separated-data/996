BLEU SCORE: 0.009055400496876965

TEST MSG: Add support for custom tracing implementations
GENERATED MSG: Bulk loader is no longer a fat client , hadoop bulk loader output format .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 50a298e . . bc21818 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 4 <nl> + * Allow custom tracing implementations ( CASSANDRA - 10392 ) <nl> * Extract LoaderOptions to be able to be used from outside ( CASSANDRA - 10637 ) <nl> * fix OnDiskIndexTest to properly treat empty ranges ( CASSANDRA - 11205 ) <nl> * fix TrackerTest to handle new notifications ( CASSANDRA - 11178 ) <nl> diff - - git a / src / java / org / apache / cassandra / net / MessageOut . java b / src / java / org / apache / cassandra / net / MessageOut . java <nl> index a524e7a . . bc5c41b 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessageOut . java <nl> + + + b / src / java / org / apache / cassandra / net / MessageOut . java <nl> @ @ - 33 , 10 + 33 , 6 @ @ import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . UUIDGen ; <nl> - <nl> - import static org . apache . cassandra . tracing . Tracing . TRACE _ HEADER ; <nl> - import static org . apache . cassandra . tracing . Tracing . TRACE _ TYPE ; <nl> import static org . apache . cassandra . tracing . Tracing . isTracing ; <nl> <nl> public class MessageOut < T > <nl> @ @ - 61 , 8 + 57 , 7 @ @ public class MessageOut < T > <nl> payload , <nl> serializer , <nl> isTracing ( ) <nl> - ? ImmutableMap . of ( TRACE _ HEADER , UUIDGen . decompose ( Tracing . instance . getSessionId ( ) ) , <nl> - TRACE _ TYPE , new byte [ ] { Tracing . TraceType . serialize ( Tracing . instance . getTraceType ( ) ) } ) <nl> + ? Tracing . instance . getTraceHeaders ( ) <nl> : Collections . < String , byte [ ] > emptyMap ( ) ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> index 7b6e26e . . 8b1ecf3 100644 <nl> - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> @ @ - 284 , 7 + 284 , 7 @ @ public class OutboundTcpConnection extends Thread <nl> { <nl> byte [ ] traceTypeBytes = qm . message . parameters . get ( Tracing . TRACE _ TYPE ) ; <nl> Tracing . TraceType traceType = traceTypeBytes = = null ? Tracing . TraceType . QUERY : Tracing . TraceType . deserialize ( traceTypeBytes [ 0 ] ) ; <nl> - TraceState . mutateWithTracing ( ByteBuffer . wrap ( sessionBytes ) , message , - 1 , traceType . getTTL ( ) ) ; <nl> + Tracing . instance . trace ( ByteBuffer . wrap ( sessionBytes ) , message , traceType . getTTL ( ) ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / QueryState . java b / src / java / org / apache / cassandra / service / QueryState . java <nl> index ddbc959 . . c70c692 100644 <nl> - - - a / src / java / org / apache / cassandra / service / QueryState . java <nl> + + + b / src / java / org / apache / cassandra / service / QueryState . java <nl> @ @ - 18 , 6 + 18 , 9 @ @ <nl> package org . apache . cassandra . service ; <nl> <nl> import java . net . InetAddress ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Collections ; <nl> + import java . util . Map ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . ThreadLocalRandom ; <nl> <nl> @ @ - 76 , 14 + 79 , 19 @ @ public class QueryState <nl> <nl> public void createTracingSession ( ) <nl> { <nl> + createTracingSession ( Collections . EMPTY _ MAP ) ; <nl> + } <nl> + <nl> + public void createTracingSession ( Map < String , ByteBuffer > customPayload ) <nl> + { <nl> UUID session = this . preparedTracingSession ; <nl> if ( session = = null ) <nl> { <nl> - Tracing . instance . newSession ( ) ; <nl> + Tracing . instance . newSession ( customPayload ) ; <nl> } <nl> else <nl> { <nl> - Tracing . instance . newSession ( session ) ; <nl> + Tracing . instance . newSession ( session , customPayload ) ; <nl> this . preparedTracingSession = null ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java b / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java <nl> index 5cc3c21 . . fbe2c33 100644 <nl> - - - a / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java <nl> + + + b / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java <nl> @ @ - 1 , 5 + 1 , 5 @ @ <nl> / * <nl> - * <nl> + * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> * or more contributor license agreements . See the NOTICE file <nl> * distributed with this work for additional information <nl> @ @ - 7 , 33 + 7 , 39 @ @ <nl> * to you under the Apache License , Version 2 . 0 ( the <nl> * " License " ) ; you may not use this file except in compliance <nl> * with the License . You may obtain a copy of the License at <nl> - * <nl> + * <nl> * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> + * <nl> * Unless required by applicable law or agreed to in writing , <nl> * software distributed under the License is distributed on an <nl> * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> * KIND , either express or implied . See the License for the <nl> * specific language governing permissions and limitations <nl> * under the License . <nl> - * <nl> + * <nl> * / <nl> <nl> package org . apache . cassandra . tracing ; <nl> <nl> - import java . util . UUID ; <nl> - <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> - public class ExpiredTraceState extends TraceState <nl> + class ExpiredTraceState extends TraceState <nl> { <nl> - public ExpiredTraceState ( UUID sessionId , Tracing . TraceType traceType ) <nl> + private final TraceState delegate ; <nl> + <nl> + ExpiredTraceState ( TraceState delegate ) <nl> { <nl> - super ( FBUtilities . getBroadcastAddress ( ) , sessionId , traceType ) ; <nl> + super ( FBUtilities . getBroadcastAddress ( ) , delegate . sessionId , delegate . traceType ) ; <nl> + this . delegate = delegate ; <nl> } <nl> <nl> public int elapsed ( ) <nl> { <nl> return - 1 ; <nl> } <nl> + <nl> + protected void traceImpl ( String message ) <nl> + { <nl> + delegate . traceImpl ( message ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tracing / TraceState . java b / src / java / org / apache / cassandra / tracing / TraceState . java <nl> index e882e67 . . 5365d09 100644 <nl> - - - a / src / java / org / apache / cassandra / tracing / TraceState . java <nl> + + + b / src / java / org / apache / cassandra / tracing / TraceState . java <nl> @ @ - 19 , 7 + 19 , 6 @ @ package org . apache . cassandra . tracing ; <nl> <nl> import java . net . InetAddress ; <nl> import java . nio . ByteBuffer ; <nl> - import java . util . Collections ; <nl> import java . util . List ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> @ @ - 29 , 14 + 28 , 7 @ @ import java . util . concurrent . atomic . AtomicInteger ; <nl> import com . google . common . base . Stopwatch ; <nl> import org . slf4j . helpers . MessageFormatter ; <nl> <nl> - import org . apache . cassandra . concurrent . Stage ; <nl> - import org . apache . cassandra . concurrent . StageManager ; <nl> - import org . apache . cassandra . db . ConsistencyLevel ; <nl> - import org . apache . cassandra . db . Mutation ; <nl> - import org . apache . cassandra . exceptions . OverloadedException ; <nl> - import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> - import org . apache . cassandra . utils . WrappedRunnable ; <nl> import org . apache . cassandra . utils . progress . ProgressEvent ; <nl> import org . apache . cassandra . utils . progress . ProgressEventNotifier ; <nl> import org . apache . cassandra . utils . progress . ProgressListener ; <nl> @ @ - 45 , 7 + 37 , 7 @ @ import org . apache . cassandra . utils . progress . ProgressListener ; <nl> * ThreadLocal state for a tracing session . The presence of an instance of this class as a ThreadLocal denotes that an <nl> * operation is being traced . <nl> * / <nl> - public class TraceState implements ProgressEventNotifier <nl> + public abstract class TraceState implements ProgressEventNotifier <nl> { <nl> public final UUID sessionId ; <nl> public final InetAddress coordinator ; <nl> @ @ - 71 , 7 + 63 , 7 @ @ public class TraceState implements ProgressEventNotifier <nl> / / See CASSANDRA - 7626 for more details . <nl> private final AtomicInteger references = new AtomicInteger ( 1 ) ; <nl> <nl> - public TraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) <nl> + protected TraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) <nl> { <nl> assert coordinator ! = null ; <nl> assert sessionId ! = null ; <nl> @ @ - 83 , 7 + 75 , 7 @ @ public class TraceState implements ProgressEventNotifier <nl> this . ttl = traceType . getTTL ( ) ; <nl> watch = Stopwatch . createStarted ( ) ; <nl> this . status = Status . IDLE ; <nl> - } <nl> + } <nl> <nl> / * * <nl> * Activate notification with provided { @ code tag } name . <nl> @ @ - 151 , 7 + 143 , 7 @ @ public class TraceState implements ProgressEventNotifier <nl> return status ; <nl> } <nl> <nl> - private synchronized void notifyActivity ( ) <nl> + protected synchronized void notifyActivity ( ) <nl> { <nl> status = Status . ACTIVE ; <nl> notifyAll ( ) ; <nl> @ @ - 177 , 10 + 169 , 7 @ @ public class TraceState implements ProgressEventNotifier <nl> if ( notify ) <nl> notifyActivity ( ) ; <nl> <nl> - final String threadName = Thread . currentThread ( ) . getName ( ) ; <nl> - final int elapsed = elapsed ( ) ; <nl> - <nl> - executeMutation ( TraceKeyspace . makeEventMutation ( sessionIdBytes , message , elapsed , threadName , ttl ) ) ; <nl> + traceImpl ( message ) ; <nl> <nl> for ( ProgressListener listener : listeners ) <nl> { <nl> @ @ - 188 , 45 + 177 , 7 @ @ public class TraceState implements ProgressEventNotifier <nl> } <nl> } <nl> <nl> - static void executeMutation ( final Mutation mutation ) <nl> - { <nl> - StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) <nl> - { <nl> - protected void runMayThrow ( ) throws Exception <nl> - { <nl> - mutateWithCatch ( mutation ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces <nl> - * that are not initiated by local node = = coordinator ) . <nl> - * / <nl> - public static void mutateWithTracing ( final ByteBuffer sessionId , final String message , final int elapsed , final int ttl ) <nl> - { <nl> - final String threadName = Thread . currentThread ( ) . getName ( ) ; <nl> - <nl> - StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) <nl> - { <nl> - public void runMayThrow ( ) <nl> - { <nl> - mutateWithCatch ( TraceKeyspace . makeEventMutation ( sessionId , message , elapsed , threadName , ttl ) ) ; <nl> - } <nl> - } ) ; <nl> - } <nl> - <nl> - static void mutateWithCatch ( Mutation mutation ) <nl> - { <nl> - try <nl> - { <nl> - StorageProxy . mutate ( Collections . singletonList ( mutation ) , ConsistencyLevel . ANY ) ; <nl> - } <nl> - catch ( OverloadedException e ) <nl> - { <nl> - Tracing . logger . warn ( " Too many nodes are overloaded to save trace events " ) ; <nl> - } <nl> - } <nl> + protected abstract void traceImpl ( String message ) ; <nl> <nl> public boolean acquireReference ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / tracing / TraceStateImpl . java b / src / java / org / apache / cassandra / tracing / TraceStateImpl . java <nl> new file mode 100644 <nl> index 0000000 . . 1bc210a <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / tracing / TraceStateImpl . java <nl> @ @ - 0 , 0 + 1 , 74 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . tracing ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Collections ; <nl> + import java . util . UUID ; <nl> + <nl> + import org . apache . cassandra . concurrent . Stage ; <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . Mutation ; <nl> + import org . apache . cassandra . exceptions . OverloadedException ; <nl> + import org . apache . cassandra . service . StorageProxy ; <nl> + import org . apache . cassandra . utils . WrappedRunnable ; <nl> + <nl> + / * * <nl> + * ThreadLocal state for a tracing session . The presence of an instance of this class as a ThreadLocal denotes that an <nl> + * operation is being traced . <nl> + * / <nl> + public class TraceStateImpl extends TraceState <nl> + { <nl> + public TraceStateImpl ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) <nl> + { <nl> + super ( coordinator , sessionId , traceType ) ; <nl> + } <nl> + <nl> + protected void traceImpl ( String message ) <nl> + { <nl> + final String threadName = Thread . currentThread ( ) . getName ( ) ; <nl> + final int elapsed = elapsed ( ) ; <nl> + <nl> + executeMutation ( TraceKeyspace . makeEventMutation ( sessionIdBytes , message , elapsed , threadName , ttl ) ) ; <nl> + } <nl> + <nl> + static void executeMutation ( final Mutation mutation ) <nl> + { <nl> + StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) <nl> + { <nl> + protected void runMayThrow ( ) throws Exception <nl> + { <nl> + mutateWithCatch ( mutation ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + static void mutateWithCatch ( Mutation mutation ) <nl> + { <nl> + try <nl> + { <nl> + StorageProxy . mutate ( Collections . singletonList ( mutation ) , ConsistencyLevel . ANY ) ; <nl> + } <nl> + catch ( OverloadedException e ) <nl> + { <nl> + Tracing . logger . warn ( " Too many nodes are overloaded to save trace events " ) ; <nl> + } <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / tracing / Tracing . java b / src / java / org / apache / cassandra / tracing / Tracing . java <nl> index bf9cee7 . . e69645f 100644 <nl> - - - a / src / java / org / apache / cassandra / tracing / Tracing . java <nl> + + + b / src / java / org / apache / cassandra / tracing / Tracing . java <nl> @ @ - 21 , 11 + 21 , 13 @ @ package org . apache . cassandra . tracing ; <nl> <nl> import java . net . InetAddress ; <nl> import java . nio . ByteBuffer ; <nl> + import java . util . Collections ; <nl> import java . util . Map ; <nl> import java . util . UUID ; <nl> import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . ConcurrentMap ; <nl> <nl> + import com . google . common . collect . ImmutableMap ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 35 , 14 + 37 , 15 @ @ import org . apache . cassandra . db . marshal . TimeUUIDType ; <nl> import org . apache . cassandra . net . MessageIn ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . JVMStabilityInspector ; <nl> import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> <nl> / * * <nl> * A trace session context . Able to track and store trace sessions . A session is usually a user initiated query , and may <nl> - * have multiple local and remote events before it is completed . All events and sessions are stored at keyspace . <nl> + * have multiple local and remote events before it is completed . <nl> * / <nl> - public class Tracing implements ExecutorLocal < TraceState > <nl> + public abstract class Tracing implements ExecutorLocal < TraceState > <nl> { <nl> public static final String TRACE _ HEADER = " TraceSession " ; <nl> public static final String TRACE _ TYPE = " TraceType " ; <nl> @ @ - 77 , 15 + 80 , 34 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> } <nl> } <nl> <nl> - static final Logger logger = LoggerFactory . getLogger ( Tracing . class ) ; <nl> + protected static final Logger logger = LoggerFactory . getLogger ( Tracing . class ) ; <nl> <nl> private final InetAddress localAddress = FBUtilities . getLocalAddress ( ) ; <nl> <nl> private final ThreadLocal < TraceState > state = new ThreadLocal < > ( ) ; <nl> <nl> - private final ConcurrentMap < UUID , TraceState > sessions = new ConcurrentHashMap < > ( ) ; <nl> + protected final ConcurrentMap < UUID , TraceState > sessions = new ConcurrentHashMap < > ( ) ; <nl> <nl> - public static final Tracing instance = new Tracing ( ) ; <nl> + public static final Tracing instance ; <nl> + <nl> + static { <nl> + Tracing tracing = null ; <nl> + String customTracingClass = System . getProperty ( " cassandra . custom _ tracing _ class " ) ; <nl> + if ( null ! = customTracingClass ) <nl> + { <nl> + try <nl> + { <nl> + tracing = FBUtilities . construct ( customTracingClass , " Tracing " ) ; <nl> + logger . info ( " Using { } as tracing queries ( as requested with - Dcassandra . custom _ tracing _ class ) " , customTracingClass ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + JVMStabilityInspector . inspectThrowable ( e ) ; <nl> + logger . error ( " Cannot use class { } for tracing ( { } ) , ignoring by defaulting on normal tracing " , customTracingClass , e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + instance = null ! = tracing ? tracing : new TracingImpl ( ) ; <nl> + } <nl> <nl> public UUID getSessionId ( ) <nl> { <nl> @ @ - 110 , 30 + 132 , 33 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> * / <nl> public static boolean isTracing ( ) <nl> { <nl> - return instance . state . get ( ) ! = null ; <nl> + return instance . get ( ) ! = null ; <nl> } <nl> <nl> - public UUID newSession ( ) <nl> + public UUID newSession ( Map < String , ByteBuffer > customPayload ) <nl> { <nl> return newSession ( TraceType . QUERY ) ; <nl> } <nl> <nl> public UUID newSession ( TraceType traceType ) <nl> { <nl> - return newSession ( TimeUUIDType . instance . compose ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) , traceType ) ; <nl> + return newSession ( <nl> + TimeUUIDType . instance . compose ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) , <nl> + traceType , <nl> + Collections . EMPTY _ MAP ) ; <nl> } <nl> <nl> - public UUID newSession ( UUID sessionId ) <nl> + public UUID newSession ( UUID sessionId , Map < String , ByteBuffer > customPayload ) <nl> { <nl> - return newSession ( sessionId , TraceType . QUERY ) ; <nl> + return newSession ( sessionId , TraceType . QUERY , Collections . EMPTY _ MAP ) ; <nl> } <nl> <nl> - private UUID newSession ( UUID sessionId , TraceType traceType ) <nl> + protected UUID newSession ( UUID sessionId , TraceType traceType , Map < String , ByteBuffer > customPayload ) <nl> { <nl> - assert state . get ( ) = = null ; <nl> + assert get ( ) = = null ; <nl> <nl> - TraceState ts = new TraceState ( localAddress , sessionId , traceType ) ; <nl> - state . set ( ts ) ; <nl> + TraceState ts = newTraceState ( localAddress , sessionId , traceType ) ; <nl> + set ( ts ) ; <nl> sessions . put ( sessionId , ts ) ; <nl> <nl> return sessionId ; <nl> @ @ - 145 , 30 + 170 , 29 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> sessions . remove ( state . sessionId ) ; <nl> } <nl> <nl> + <nl> / * * <nl> * Stop the session and record its complete . Called by coodinator when request is complete . <nl> * / <nl> public void stopSession ( ) <nl> { <nl> - TraceState state = this . state . get ( ) ; <nl> + TraceState state = get ( ) ; <nl> if ( state = = null ) / / inline isTracing to avoid implicit two calls to state . get ( ) <nl> { <nl> logger . trace ( " request complete " ) ; <nl> } <nl> else <nl> { <nl> - final int elapsed = state . elapsed ( ) ; <nl> - final ByteBuffer sessionId = state . sessionIdBytes ; <nl> - final int ttl = state . ttl ; <nl> - <nl> - TraceState . executeMutation ( TraceKeyspace . makeStopSessionMutation ( sessionId , elapsed , ttl ) ) ; <nl> + stopSessionImpl ( ) ; <nl> <nl> state . stop ( ) ; <nl> sessions . remove ( state . sessionId ) ; <nl> - this . state . set ( null ) ; <nl> + set ( null ) ; <nl> } <nl> } <nl> <nl> + protected abstract void stopSessionImpl ( ) ; <nl> + <nl> public TraceState get ( ) <nl> { <nl> return state . get ( ) ; <nl> @ @ - 189 , 24 + 213 , 11 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> return begin ( request , null , parameters ) ; <nl> } <nl> <nl> - public TraceState begin ( final String request , final InetAddress client , final Map < String , String > parameters ) <nl> - { <nl> - assert isTracing ( ) ; <nl> - <nl> - final TraceState state = this . state . get ( ) ; <nl> - final long startedAt = System . currentTimeMillis ( ) ; <nl> - final ByteBuffer sessionId = state . sessionIdBytes ; <nl> - final String command = state . traceType . toString ( ) ; <nl> - final int ttl = state . ttl ; <nl> - <nl> - TraceState . executeMutation ( TraceKeyspace . makeStartSessionMutation ( sessionId , client , parameters , request , startedAt , command , ttl ) ) ; <nl> - <nl> - return state ; <nl> - } <nl> + public abstract TraceState begin ( String request , InetAddress client , Map < String , String > parameters ) ; <nl> <nl> / * * <nl> * Determines the tracing context from a message . Does NOT set the threadlocal state . <nl> - * <nl> + * <nl> * @ param message The internode message <nl> * / <nl> public TraceState initializeFromMessage ( final MessageIn < ? > message ) <nl> @ @ - 218 , 7 + 229 , 7 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> <nl> assert sessionBytes . length = = 16 ; <nl> UUID sessionId = UUIDGen . getUUID ( ByteBuffer . wrap ( sessionBytes ) ) ; <nl> - TraceState ts = sessions . get ( sessionId ) ; <nl> + TraceState ts = get ( sessionId ) ; <nl> if ( ts ! = null & & ts . acquireReference ( ) ) <nl> return ts ; <nl> <nl> @ @ - 230 , 16 + 241 , 26 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> if ( message . verb = = MessagingService . Verb . REQUEST _ RESPONSE ) <nl> { <nl> / / received a message for a session we ' ve already closed out . see CASSANDRA - 5668 <nl> - return new ExpiredTraceState ( sessionId , traceType ) ; <nl> + return new ExpiredTraceState ( newTraceState ( message . from , sessionId , traceType ) ) ; <nl> } <nl> else <nl> { <nl> - ts = new TraceState ( message . from , sessionId , traceType ) ; <nl> + ts = newTraceState ( message . from , sessionId , traceType ) ; <nl> sessions . put ( sessionId , ts ) ; <nl> return ts ; <nl> } <nl> } <nl> <nl> + public Map < String , byte [ ] > getTraceHeaders ( ) <nl> + { <nl> + assert isTracing ( ) ; <nl> + <nl> + return ImmutableMap . of ( <nl> + TRACE _ HEADER , UUIDGen . decompose ( Tracing . instance . getSessionId ( ) ) , <nl> + TRACE _ TYPE , new byte [ ] { Tracing . TraceType . serialize ( Tracing . instance . getTraceType ( ) ) } ) ; <nl> + } <nl> + <nl> + protected abstract TraceState newTraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) ; <nl> <nl> / / repair just gets a varargs method since it ' s so heavyweight anyway <nl> public static void traceRepair ( String format , Object . . . args ) <nl> @ @ - 287 , 4 + 308 , 10 @ @ public class Tracing implements ExecutorLocal < TraceState > <nl> <nl> state . trace ( format , args ) ; <nl> } <nl> + <nl> + / * * <nl> + * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces <nl> + * that are not initiated by local node = = coordinator ) . <nl> + * / <nl> + public abstract void trace ( ByteBuffer sessionId , String message , int ttl ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / tracing / TracingImpl . java b / src / java / org / apache / cassandra / tracing / TracingImpl . java <nl> new file mode 100644 <nl> index 0000000 . . 52ac183 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / tracing / TracingImpl . java <nl> @ @ - 0 , 0 + 1 , 89 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + package org . apache . cassandra . tracing ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Map ; <nl> + import java . util . UUID ; <nl> + <nl> + import org . apache . cassandra . concurrent . Stage ; <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> + import org . apache . cassandra . utils . WrappedRunnable ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + <nl> + <nl> + / * * <nl> + * A trace session context . Able to track and store trace sessions . A session is usually a user initiated query , and may <nl> + * have multiple local and remote events before it is completed . All events and sessions are stored at keyspace . <nl> + * / <nl> + class TracingImpl extends Tracing <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( TracingImpl . class ) ; <nl> + <nl> + public void stopSessionImpl ( ) { <nl> + TraceState state = get ( ) ; <nl> + int elapsed = state . elapsed ( ) ; <nl> + ByteBuffer sessionId = state . sessionIdBytes ; <nl> + int ttl = state . ttl ; <nl> + TraceStateImpl . executeMutation ( TraceKeyspace . makeStopSessionMutation ( sessionId , elapsed , ttl ) ) ; <nl> + } <nl> + <nl> + public TraceState begin ( final String request , final InetAddress client , final Map < String , String > parameters ) <nl> + { <nl> + assert isTracing ( ) ; <nl> + <nl> + final TraceState state = get ( ) ; <nl> + final long startedAt = System . currentTimeMillis ( ) ; <nl> + final ByteBuffer sessionId = state . sessionIdBytes ; <nl> + final String command = state . traceType . toString ( ) ; <nl> + final int ttl = state . ttl ; <nl> + <nl> + TraceStateImpl . executeMutation ( TraceKeyspace . makeStartSessionMutation ( sessionId , client , parameters , request , startedAt , command , ttl ) ) ; <nl> + <nl> + return state ; <nl> + } <nl> + <nl> + @ Override <nl> + protected TraceState newTraceState ( InetAddress coordinator , UUID sessionId , TraceType traceType ) <nl> + { <nl> + return new TraceStateImpl ( coordinator , sessionId , traceType ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces <nl> + * that are not initiated by local node = = coordinator ) . <nl> + * / <nl> + public void trace ( final ByteBuffer sessionId , final String message , final int ttl ) <nl> + { <nl> + final String threadName = Thread . currentThread ( ) . getName ( ) ; <nl> + <nl> + StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) <nl> + { <nl> + TraceStateImpl . mutateWithCatch ( TraceKeyspace . makeEventMutation ( sessionId , message , - 1 , threadName , ttl ) ) ; <nl> + } <nl> + } ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> index e9923b4 . . df6acc0 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java <nl> @ @ - 110 , 7 + 110 , 7 @ @ public class ExecuteMessage extends Message . Request <nl> <nl> if ( state . traceNextQuery ( ) ) <nl> { <nl> - state . createTracingSession ( ) ; <nl> + state . createTracingSession ( getCustomPayload ( ) ) ; <nl> <nl> ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; <nl> if ( options . getPageSize ( ) > 0 ) <nl> diff - - git a / test / unit / org / apache / cassandra / tracing / TracingTest . java b / test / unit / org / apache / cassandra / tracing / TracingTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1b0e507 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / tracing / TracingTest . java <nl> @ @ - 0 , 0 + 1 , 173 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . tracing ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . UUID ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . utils . progress . ProgressEvent ; <nl> + import org . apache . cassandra . utils . progress . ProgressListener ; <nl> + <nl> + public final class TracingTest <nl> + { <nl> + <nl> + @ Test <nl> + public void test ( ) <nl> + { <nl> + List < String > traces = new ArrayList < > ( ) ; <nl> + Tracing tracing = new TracingImpl ( traces ) ; <nl> + tracing . newSession ( Tracing . TraceType . NONE ) ; <nl> + TraceState state = tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; <nl> + state . trace ( " test - 1 " ) ; <nl> + state . trace ( " test - 2 " ) ; <nl> + state . trace ( " test - 3 " ) ; <nl> + tracing . stopSession ( ) ; <nl> + <nl> + assert null = = tracing . get ( ) ; <nl> + assert 4 = = traces . size ( ) ; <nl> + assert " test - request " . equals ( traces . get ( 0 ) ) ; <nl> + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; <nl> + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; <nl> + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void test _ get ( ) <nl> + { <nl> + List < String > traces = new ArrayList < > ( ) ; <nl> + Tracing tracing = new TracingImpl ( traces ) ; <nl> + tracing . newSession ( Tracing . TraceType . NONE ) ; <nl> + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; <nl> + tracing . get ( ) . trace ( " test - 1 " ) ; <nl> + tracing . get ( ) . trace ( " test - 2 " ) ; <nl> + tracing . get ( ) . trace ( " test - 3 " ) ; <nl> + tracing . stopSession ( ) ; <nl> + <nl> + assert null = = tracing . get ( ) ; <nl> + assert 4 = = traces . size ( ) ; <nl> + assert " test - request " . equals ( traces . get ( 0 ) ) ; <nl> + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; <nl> + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; <nl> + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void test _ get _ uuid ( ) <nl> + { <nl> + List < String > traces = new ArrayList < > ( ) ; <nl> + Tracing tracing = new TracingImpl ( traces ) ; <nl> + UUID uuid = tracing . newSession ( Tracing . TraceType . NONE ) ; <nl> + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; <nl> + tracing . get ( uuid ) . trace ( " test - 1 " ) ; <nl> + tracing . get ( uuid ) . trace ( " test - 2 " ) ; <nl> + tracing . get ( uuid ) . trace ( " test - 3 " ) ; <nl> + tracing . stopSession ( ) ; <nl> + <nl> + assert null = = tracing . get ( ) ; <nl> + assert 4 = = traces . size ( ) ; <nl> + assert " test - request " . equals ( traces . get ( 0 ) ) ; <nl> + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; <nl> + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; <nl> + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void test _ states ( ) <nl> + { <nl> + List < String > traces = new ArrayList < > ( ) ; <nl> + Tracing tracing = new TracingImpl ( traces ) ; <nl> + tracing . newSession ( Tracing . TraceType . REPAIR ) ; <nl> + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; <nl> + tracing . get ( ) . enableActivityNotification ( " test - tag " ) ; <nl> + assert TraceState . Status . IDLE = = tracing . get ( ) . waitActivity ( 1 ) ; <nl> + tracing . get ( ) . trace ( " test - 1 " ) ; <nl> + assert TraceState . Status . ACTIVE = = tracing . get ( ) . waitActivity ( 1 ) ; <nl> + tracing . get ( ) . stop ( ) ; <nl> + assert TraceState . Status . STOPPED = = tracing . get ( ) . waitActivity ( 1 ) ; <nl> + tracing . stopSession ( ) ; <nl> + assert null = = tracing . get ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void test _ progress _ listener ( ) <nl> + { <nl> + List < String > traces = new ArrayList < > ( ) ; <nl> + Tracing tracing = new TracingImpl ( traces ) ; <nl> + tracing . newSession ( Tracing . TraceType . REPAIR ) ; <nl> + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; <nl> + tracing . get ( ) . enableActivityNotification ( " test - tag " ) ; <nl> + <nl> + tracing . get ( ) . addProgressListener ( <nl> + new ProgressListener ( ) <nl> + { <nl> + public void progress ( String tag , ProgressEvent pe ) <nl> + { <nl> + assert " test - tag " . equals ( tag ) ; <nl> + assert " test - trace " . equals ( pe . getMessage ( ) ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + tracing . get ( ) . trace ( " test - trace " ) ; <nl> + tracing . stopSession ( ) ; <nl> + assert null = = tracing . get ( ) ; <nl> + } <nl> + <nl> + private class TracingImpl extends Tracing <nl> + { <nl> + private final List < String > traces ; <nl> + <nl> + public TracingImpl ( List < String > traces ) <nl> + { <nl> + this . traces = traces ; <nl> + } <nl> + <nl> + public void stopSessionImpl ( ) <nl> + { } <nl> + <nl> + public TraceState begin ( String request , InetAddress ia , Map < String , String > map ) <nl> + { <nl> + traces . add ( request ) ; <nl> + return get ( ) ; <nl> + } <nl> + <nl> + protected TraceState newTraceState ( InetAddress ia , UUID uuid , Tracing . TraceType tt ) <nl> + { <nl> + return new TraceState ( ia , uuid , tt ) <nl> + { <nl> + protected void traceImpl ( String string ) <nl> + { <nl> + traces . add ( string ) ; <nl> + } <nl> + <nl> + } ; <nl> + } <nl> + <nl> + public void trace ( ByteBuffer bb , String string , int i ) <nl> + { <nl> + throw new UnsupportedOperationException ( " Not supported yet . " ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7be913e . . 7c5a752 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 2 , 6 + 2 , 8 @ @ <nl> * add command to stop compactions ( CASSANDRA - 1740 ) <nl> * filter out unavailable cipher suites when using encryption ( CASSANDRA - 3178 ) <nl> * ( HADOOP ) add old - style api support for CFIF and CFRR ( CASSANDRA - 2799 ) <nl> + * Support TimeUUIDType column names in Stress . java tool ( CASSANDRA - 3541 ) <nl> + <nl> <nl> 1 . 0 . 5 <nl> * revert CASSANDRA - 3407 ( see CASSANDRA - 3540 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / Session . java b / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> index abbea50 . . ddc6a69 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / Session . java <nl> @ @ - 27 , 9 + 27 , 7 @ @ import java . util . concurrent . atomic . AtomicLong ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ConfigurationException ; <nl> - import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . db . marshal . TypeParser ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . commons . cli . * ; <nl> <nl> import org . apache . cassandra . db . ColumnFamilyType ; <nl> @ @ - 50 , 6 + 48 , 8 @ @ public class Session implements Serializable <nl> public static final String DEFAULT _ COMPARATOR = " AsciiType " ; <nl> public static final String DEFAULT _ VALIDATOR = " BytesType " ; <nl> <nl> + private static InetAddress localInetAddress ; <nl> + <nl> public final AtomicInteger operations ; <nl> public final AtomicInteger keys ; <nl> public final AtomicLong latency ; <nl> @ @ - 89 , 6 + 89 , 7 @ @ public class Session implements Serializable <nl> availableOptions . addOption ( " I " , " compression " , true , " Specify the compression to use for sstable , default : no compression " ) ; <nl> availableOptions . addOption ( " Q " , " query - names " , true , " Comma - separated list of column names to retrieve from each row . " ) ; <nl> availableOptions . addOption ( " Z " , " compaction - strategy " , true , " CompactionStrategy to use . " ) ; <nl> + availableOptions . addOption ( " U " , " comparator " , true , " Column Comparator to use . Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; <nl> } <nl> <nl> private int numKeys = 1000 * 1000 ; <nl> @ @ - 131 , 6 + 132 , 8 @ @ public class Session implements Serializable <nl> protected float sigma ; <nl> <nl> public final InetAddress sendToDaemon ; <nl> + public final String comparator ; <nl> + public final boolean timeUUIDComparator ; <nl> <nl> public Session ( String [ ] arguments ) throws IllegalArgumentException <nl> { <nl> @ @ - 321 , 6 + 324 , 35 @ @ public class Session implements Serializable <nl> System . exit ( 1 ) ; <nl> } <nl> } <nl> + <nl> + if ( cmd . hasOption ( " U " ) ) <nl> + { <nl> + AbstractType parsed = null ; <nl> + <nl> + try <nl> + { <nl> + parsed = TypeParser . parse ( cmd . getOptionValue ( " U " ) ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + System . err . println ( e . getMessage ( ) ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + comparator = cmd . getOptionValue ( " U " ) ; <nl> + timeUUIDComparator = parsed instanceof TimeUUIDType ; <nl> + <nl> + if ( ! ( parsed instanceof TimeUUIDType | | parsed instanceof AsciiType | | parsed instanceof UTF8Type ) ) <nl> + { <nl> + System . err . println ( " Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + } <nl> + else <nl> + { <nl> + comparator = null ; <nl> + timeUUIDComparator = false ; <nl> + } <nl> } <nl> catch ( ParseException e ) <nl> { <nl> @ @ - 464 , 6 + 496 , 7 @ @ public class Session implements Serializable <nl> public void createKeySpaces ( ) <nl> { <nl> KsDef keyspace = new KsDef ( ) ; <nl> + String defaultComparator = comparator = = null ? DEFAULT _ COMPARATOR : comparator ; <nl> <nl> / / column family for standard columns <nl> CfDef standardCfDef = new CfDef ( " Keyspace1 " , " Standard1 " ) ; <nl> @ @ - 471 , 7 + 504 , 7 @ @ public class Session implements Serializable <nl> if ( compression ! = null ) <nl> compressionOptions . put ( " sstable _ compression " , compression ) ; <nl> <nl> - standardCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) <nl> + standardCfDef . setComparator _ type ( defaultComparator ) <nl> . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) <nl> . setCompression _ options ( compressionOptions ) ; <nl> <nl> @ @ - 485 , 7 + 518 , 7 @ @ public class Session implements Serializable <nl> / / column family with super columns <nl> CfDef superCfDef = new CfDef ( " Keyspace1 " , " Super1 " ) . setColumn _ type ( " Super " ) ; <nl> superCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) <nl> - . setSubcomparator _ type ( DEFAULT _ COMPARATOR ) <nl> + . setSubcomparator _ type ( defaultComparator ) <nl> . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) <nl> . setCompression _ options ( compressionOptions ) ; <nl> <nl> @ @ - 574 , 4 + 607 , 20 @ @ public class Session implements Serializable <nl> return client ; <nl> } <nl> <nl> + public static InetAddress getLocalAddress ( ) <nl> + { <nl> + if ( localInetAddress = = null ) <nl> + { <nl> + try <nl> + { <nl> + localInetAddress = InetAddress . getLocalHost ( ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + return localInetAddress ; <nl> + } <nl> } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> index 45d33cb . . c81df6f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java <nl> @ @ - 52 , 9 + 52 , 9 @ @ public class Inserter extends Operation <nl> <nl> for ( int i = 0 ; i < session . getColumnsPerKey ( ) ; i + + ) <nl> { <nl> - String columnName = ( " C " + Integer . toString ( i ) ) ; <nl> - ByteBuffer columnValue = values . get ( i % values . size ( ) ) ; <nl> - columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) ) . setValue ( columnValue ) . setTimestamp ( System . currentTimeMillis ( ) ) ) ; <nl> + columns . add ( new Column ( columnName ( i , session . timeUUIDComparator ) ) <nl> + . setValue ( values . get ( i % values . size ( ) ) ) <nl> + . setTimestamp ( System . currentTimeMillis ( ) ) ) ; <nl> } <nl> <nl> if ( session . getColumnFamilyType ( ) = = ColumnFamilyType . Super ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> index 10b97ad . . dd5128f 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java <nl> @ @ - 27 , 11 + 27 , 14 @ @ import java . util . Random ; <nl> <nl> import static com . google . common . base . Charsets . UTF _ 8 ; <nl> <nl> + import org . apache . cassandra . db . marshal . TimeUUIDType ; <nl> import org . apache . cassandra . stress . Session ; <nl> import org . apache . cassandra . stress . Stress ; <nl> import org . apache . cassandra . thrift . Cassandra ; <nl> import org . apache . cassandra . thrift . InvalidRequestException ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> public abstract class Operation <nl> { <nl> @ @ - 200 , 6 + 203 , 13 @ @ public abstract class Operation <nl> return result . toString ( ) ; <nl> } <nl> <nl> + protected ByteBuffer columnName ( int index , boolean timeUUIDComparator ) <nl> + { <nl> + return timeUUIDComparator <nl> + ? TimeUUIDType . instance . decompose ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) ) <nl> + : ByteBufferUtil . bytes ( String . format ( " C % d " , index ) ) ; <nl> + } <nl> + <nl> protected String getExceptionMessage ( Exception e ) <nl> { <nl> String className = e . getClass ( ) . getSimpleName ( ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 50a298e . . bc21818 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 4 
 + * Allow custom tracing implementations ( CASSANDRA - 10392 ) 
 * Extract LoaderOptions to be able to be used from outside ( CASSANDRA - 10637 ) 
 * fix OnDiskIndexTest to properly treat empty ranges ( CASSANDRA - 11205 ) 
 * fix TrackerTest to handle new notifications ( CASSANDRA - 11178 ) 
 diff - - git a / src / java / org / apache / cassandra / net / MessageOut . java b / src / java / org / apache / cassandra / net / MessageOut . java 
 index a524e7a . . bc5c41b 100644 
 - - - a / src / java / org / apache / cassandra / net / MessageOut . java 
 + + + b / src / java / org / apache / cassandra / net / MessageOut . java 
 @ @ - 33 , 10 + 33 , 6 @ @ import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . tracing . Tracing ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . UUIDGen ; 
 - 
 - import static org . apache . cassandra . tracing . Tracing . TRACE _ HEADER ; 
 - import static org . apache . cassandra . tracing . Tracing . TRACE _ TYPE ; 
 import static org . apache . cassandra . tracing . Tracing . isTracing ; 
 
 public class MessageOut < T > 
 @ @ - 61 , 8 + 57 , 7 @ @ public class MessageOut < T > 
 payload , 
 serializer , 
 isTracing ( ) 
 - ? ImmutableMap . of ( TRACE _ HEADER , UUIDGen . decompose ( Tracing . instance . getSessionId ( ) ) , 
 - TRACE _ TYPE , new byte [ ] { Tracing . TraceType . serialize ( Tracing . instance . getTraceType ( ) ) } ) 
 + ? Tracing . instance . getTraceHeaders ( ) 
 : Collections . < String , byte [ ] > emptyMap ( ) ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 index 7b6e26e . . 8b1ecf3 100644 
 - - - a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 @ @ - 284 , 7 + 284 , 7 @ @ public class OutboundTcpConnection extends Thread 
 { 
 byte [ ] traceTypeBytes = qm . message . parameters . get ( Tracing . TRACE _ TYPE ) ; 
 Tracing . TraceType traceType = traceTypeBytes = = null ? Tracing . TraceType . QUERY : Tracing . TraceType . deserialize ( traceTypeBytes [ 0 ] ) ; 
 - TraceState . mutateWithTracing ( ByteBuffer . wrap ( sessionBytes ) , message , - 1 , traceType . getTTL ( ) ) ; 
 + Tracing . instance . trace ( ByteBuffer . wrap ( sessionBytes ) , message , traceType . getTTL ( ) ) ; 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / QueryState . java b / src / java / org / apache / cassandra / service / QueryState . java 
 index ddbc959 . . c70c692 100644 
 - - - a / src / java / org / apache / cassandra / service / QueryState . java 
 + + + b / src / java / org / apache / cassandra / service / QueryState . java 
 @ @ - 18 , 6 + 18 , 9 @ @ 
 package org . apache . cassandra . service ; 
 
 import java . net . InetAddress ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . Collections ; 
 + import java . util . Map ; 
 import java . util . UUID ; 
 import java . util . concurrent . ThreadLocalRandom ; 
 
 @ @ - 76 , 14 + 79 , 19 @ @ public class QueryState 
 
 public void createTracingSession ( ) 
 { 
 + createTracingSession ( Collections . EMPTY _ MAP ) ; 
 + } 
 + 
 + public void createTracingSession ( Map < String , ByteBuffer > customPayload ) 
 + { 
 UUID session = this . preparedTracingSession ; 
 if ( session = = null ) 
 { 
 - Tracing . instance . newSession ( ) ; 
 + Tracing . instance . newSession ( customPayload ) ; 
 } 
 else 
 { 
 - Tracing . instance . newSession ( session ) ; 
 + Tracing . instance . newSession ( session , customPayload ) ; 
 this . preparedTracingSession = null ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java b / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java 
 index 5cc3c21 . . fbe2c33 100644 
 - - - a / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java 
 + + + b / src / java / org / apache / cassandra / tracing / ExpiredTraceState . java 
 @ @ - 1 , 5 + 1 , 5 @ @ 
 / * 
 - * 
 + * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 * or more contributor license agreements . See the NOTICE file 
 * distributed with this work for additional information 
 @ @ - 7 , 33 + 7 , 39 @ @ 
 * to you under the Apache License , Version 2 . 0 ( the 
 * " License " ) ; you may not use this file except in compliance 
 * with the License . You may obtain a copy of the License at 
 - * 
 + * 
 * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 + * 
 * Unless required by applicable law or agreed to in writing , 
 * software distributed under the License is distributed on an 
 * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 * KIND , either express or implied . See the License for the 
 * specific language governing permissions and limitations 
 * under the License . 
 - * 
 + * 
 * / 
 
 package org . apache . cassandra . tracing ; 
 
 - import java . util . UUID ; 
 - 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 - public class ExpiredTraceState extends TraceState 
 + class ExpiredTraceState extends TraceState 
 { 
 - public ExpiredTraceState ( UUID sessionId , Tracing . TraceType traceType ) 
 + private final TraceState delegate ; 
 + 
 + ExpiredTraceState ( TraceState delegate ) 
 { 
 - super ( FBUtilities . getBroadcastAddress ( ) , sessionId , traceType ) ; 
 + super ( FBUtilities . getBroadcastAddress ( ) , delegate . sessionId , delegate . traceType ) ; 
 + this . delegate = delegate ; 
 } 
 
 public int elapsed ( ) 
 { 
 return - 1 ; 
 } 
 + 
 + protected void traceImpl ( String message ) 
 + { 
 + delegate . traceImpl ( message ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / tracing / TraceState . java b / src / java / org / apache / cassandra / tracing / TraceState . java 
 index e882e67 . . 5365d09 100644 
 - - - a / src / java / org / apache / cassandra / tracing / TraceState . java 
 + + + b / src / java / org / apache / cassandra / tracing / TraceState . java 
 @ @ - 19 , 7 + 19 , 6 @ @ package org . apache . cassandra . tracing ; 
 
 import java . net . InetAddress ; 
 import java . nio . ByteBuffer ; 
 - import java . util . Collections ; 
 import java . util . List ; 
 import java . util . UUID ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 @ @ - 29 , 14 + 28 , 7 @ @ import java . util . concurrent . atomic . AtomicInteger ; 
 import com . google . common . base . Stopwatch ; 
 import org . slf4j . helpers . MessageFormatter ; 
 
 - import org . apache . cassandra . concurrent . Stage ; 
 - import org . apache . cassandra . concurrent . StageManager ; 
 - import org . apache . cassandra . db . ConsistencyLevel ; 
 - import org . apache . cassandra . db . Mutation ; 
 - import org . apache . cassandra . exceptions . OverloadedException ; 
 - import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 - import org . apache . cassandra . utils . WrappedRunnable ; 
 import org . apache . cassandra . utils . progress . ProgressEvent ; 
 import org . apache . cassandra . utils . progress . ProgressEventNotifier ; 
 import org . apache . cassandra . utils . progress . ProgressListener ; 
 @ @ - 45 , 7 + 37 , 7 @ @ import org . apache . cassandra . utils . progress . ProgressListener ; 
 * ThreadLocal state for a tracing session . The presence of an instance of this class as a ThreadLocal denotes that an 
 * operation is being traced . 
 * / 
 - public class TraceState implements ProgressEventNotifier 
 + public abstract class TraceState implements ProgressEventNotifier 
 { 
 public final UUID sessionId ; 
 public final InetAddress coordinator ; 
 @ @ - 71 , 7 + 63 , 7 @ @ public class TraceState implements ProgressEventNotifier 
 / / See CASSANDRA - 7626 for more details . 
 private final AtomicInteger references = new AtomicInteger ( 1 ) ; 
 
 - public TraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) 
 + protected TraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) 
 { 
 assert coordinator ! = null ; 
 assert sessionId ! = null ; 
 @ @ - 83 , 7 + 75 , 7 @ @ public class TraceState implements ProgressEventNotifier 
 this . ttl = traceType . getTTL ( ) ; 
 watch = Stopwatch . createStarted ( ) ; 
 this . status = Status . IDLE ; 
 - } 
 + } 
 
 / * * 
 * Activate notification with provided { @ code tag } name . 
 @ @ - 151 , 7 + 143 , 7 @ @ public class TraceState implements ProgressEventNotifier 
 return status ; 
 } 
 
 - private synchronized void notifyActivity ( ) 
 + protected synchronized void notifyActivity ( ) 
 { 
 status = Status . ACTIVE ; 
 notifyAll ( ) ; 
 @ @ - 177 , 10 + 169 , 7 @ @ public class TraceState implements ProgressEventNotifier 
 if ( notify ) 
 notifyActivity ( ) ; 
 
 - final String threadName = Thread . currentThread ( ) . getName ( ) ; 
 - final int elapsed = elapsed ( ) ; 
 - 
 - executeMutation ( TraceKeyspace . makeEventMutation ( sessionIdBytes , message , elapsed , threadName , ttl ) ) ; 
 + traceImpl ( message ) ; 
 
 for ( ProgressListener listener : listeners ) 
 { 
 @ @ - 188 , 45 + 177 , 7 @ @ public class TraceState implements ProgressEventNotifier 
 } 
 } 
 
 - static void executeMutation ( final Mutation mutation ) 
 - { 
 - StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) 
 - { 
 - protected void runMayThrow ( ) throws Exception 
 - { 
 - mutateWithCatch ( mutation ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 - / * * 
 - * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces 
 - * that are not initiated by local node = = coordinator ) . 
 - * / 
 - public static void mutateWithTracing ( final ByteBuffer sessionId , final String message , final int elapsed , final int ttl ) 
 - { 
 - final String threadName = Thread . currentThread ( ) . getName ( ) ; 
 - 
 - StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) 
 - { 
 - public void runMayThrow ( ) 
 - { 
 - mutateWithCatch ( TraceKeyspace . makeEventMutation ( sessionId , message , elapsed , threadName , ttl ) ) ; 
 - } 
 - } ) ; 
 - } 
 - 
 - static void mutateWithCatch ( Mutation mutation ) 
 - { 
 - try 
 - { 
 - StorageProxy . mutate ( Collections . singletonList ( mutation ) , ConsistencyLevel . ANY ) ; 
 - } 
 - catch ( OverloadedException e ) 
 - { 
 - Tracing . logger . warn ( " Too many nodes are overloaded to save trace events " ) ; 
 - } 
 - } 
 + protected abstract void traceImpl ( String message ) ; 
 
 public boolean acquireReference ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / tracing / TraceStateImpl . java b / src / java / org / apache / cassandra / tracing / TraceStateImpl . java 
 new file mode 100644 
 index 0000000 . . 1bc210a 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / tracing / TraceStateImpl . java 
 @ @ - 0 , 0 + 1 , 74 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . tracing ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Collections ; 
 + import java . util . UUID ; 
 + 
 + import org . apache . cassandra . concurrent . Stage ; 
 + import org . apache . cassandra . concurrent . StageManager ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . Mutation ; 
 + import org . apache . cassandra . exceptions . OverloadedException ; 
 + import org . apache . cassandra . service . StorageProxy ; 
 + import org . apache . cassandra . utils . WrappedRunnable ; 
 + 
 + / * * 
 + * ThreadLocal state for a tracing session . The presence of an instance of this class as a ThreadLocal denotes that an 
 + * operation is being traced . 
 + * / 
 + public class TraceStateImpl extends TraceState 
 + { 
 + public TraceStateImpl ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) 
 + { 
 + super ( coordinator , sessionId , traceType ) ; 
 + } 
 + 
 + protected void traceImpl ( String message ) 
 + { 
 + final String threadName = Thread . currentThread ( ) . getName ( ) ; 
 + final int elapsed = elapsed ( ) ; 
 + 
 + executeMutation ( TraceKeyspace . makeEventMutation ( sessionIdBytes , message , elapsed , threadName , ttl ) ) ; 
 + } 
 + 
 + static void executeMutation ( final Mutation mutation ) 
 + { 
 + StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) 
 + { 
 + protected void runMayThrow ( ) throws Exception 
 + { 
 + mutateWithCatch ( mutation ) ; 
 + } 
 + } ) ; 
 + } 
 + 
 + static void mutateWithCatch ( Mutation mutation ) 
 + { 
 + try 
 + { 
 + StorageProxy . mutate ( Collections . singletonList ( mutation ) , ConsistencyLevel . ANY ) ; 
 + } 
 + catch ( OverloadedException e ) 
 + { 
 + Tracing . logger . warn ( " Too many nodes are overloaded to save trace events " ) ; 
 + } 
 + } 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / tracing / Tracing . java b / src / java / org / apache / cassandra / tracing / Tracing . java 
 index bf9cee7 . . e69645f 100644 
 - - - a / src / java / org / apache / cassandra / tracing / Tracing . java 
 + + + b / src / java / org / apache / cassandra / tracing / Tracing . java 
 @ @ - 21 , 11 + 21 , 13 @ @ package org . apache . cassandra . tracing ; 
 
 import java . net . InetAddress ; 
 import java . nio . ByteBuffer ; 
 + import java . util . Collections ; 
 import java . util . Map ; 
 import java . util . UUID ; 
 import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . ConcurrentMap ; 
 
 + import com . google . common . collect . ImmutableMap ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 35 , 14 + 37 , 15 @ @ import org . apache . cassandra . db . marshal . TimeUUIDType ; 
 import org . apache . cassandra . net . MessageIn ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . JVMStabilityInspector ; 
 import org . apache . cassandra . utils . UUIDGen ; 
 
 
 / * * 
 * A trace session context . Able to track and store trace sessions . A session is usually a user initiated query , and may 
 - * have multiple local and remote events before it is completed . All events and sessions are stored at keyspace . 
 + * have multiple local and remote events before it is completed . 
 * / 
 - public class Tracing implements ExecutorLocal < TraceState > 
 + public abstract class Tracing implements ExecutorLocal < TraceState > 
 { 
 public static final String TRACE _ HEADER = " TraceSession " ; 
 public static final String TRACE _ TYPE = " TraceType " ; 
 @ @ - 77 , 15 + 80 , 34 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 } 
 } 
 
 - static final Logger logger = LoggerFactory . getLogger ( Tracing . class ) ; 
 + protected static final Logger logger = LoggerFactory . getLogger ( Tracing . class ) ; 
 
 private final InetAddress localAddress = FBUtilities . getLocalAddress ( ) ; 
 
 private final ThreadLocal < TraceState > state = new ThreadLocal < > ( ) ; 
 
 - private final ConcurrentMap < UUID , TraceState > sessions = new ConcurrentHashMap < > ( ) ; 
 + protected final ConcurrentMap < UUID , TraceState > sessions = new ConcurrentHashMap < > ( ) ; 
 
 - public static final Tracing instance = new Tracing ( ) ; 
 + public static final Tracing instance ; 
 + 
 + static { 
 + Tracing tracing = null ; 
 + String customTracingClass = System . getProperty ( " cassandra . custom _ tracing _ class " ) ; 
 + if ( null ! = customTracingClass ) 
 + { 
 + try 
 + { 
 + tracing = FBUtilities . construct ( customTracingClass , " Tracing " ) ; 
 + logger . info ( " Using { } as tracing queries ( as requested with - Dcassandra . custom _ tracing _ class ) " , customTracingClass ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + JVMStabilityInspector . inspectThrowable ( e ) ; 
 + logger . error ( " Cannot use class { } for tracing ( { } ) , ignoring by defaulting on normal tracing " , customTracingClass , e . getMessage ( ) ) ; 
 + } 
 + } 
 + instance = null ! = tracing ? tracing : new TracingImpl ( ) ; 
 + } 
 
 public UUID getSessionId ( ) 
 { 
 @ @ - 110 , 30 + 132 , 33 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 * / 
 public static boolean isTracing ( ) 
 { 
 - return instance . state . get ( ) ! = null ; 
 + return instance . get ( ) ! = null ; 
 } 
 
 - public UUID newSession ( ) 
 + public UUID newSession ( Map < String , ByteBuffer > customPayload ) 
 { 
 return newSession ( TraceType . QUERY ) ; 
 } 
 
 public UUID newSession ( TraceType traceType ) 
 { 
 - return newSession ( TimeUUIDType . instance . compose ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) , traceType ) ; 
 + return newSession ( 
 + TimeUUIDType . instance . compose ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) , 
 + traceType , 
 + Collections . EMPTY _ MAP ) ; 
 } 
 
 - public UUID newSession ( UUID sessionId ) 
 + public UUID newSession ( UUID sessionId , Map < String , ByteBuffer > customPayload ) 
 { 
 - return newSession ( sessionId , TraceType . QUERY ) ; 
 + return newSession ( sessionId , TraceType . QUERY , Collections . EMPTY _ MAP ) ; 
 } 
 
 - private UUID newSession ( UUID sessionId , TraceType traceType ) 
 + protected UUID newSession ( UUID sessionId , TraceType traceType , Map < String , ByteBuffer > customPayload ) 
 { 
 - assert state . get ( ) = = null ; 
 + assert get ( ) = = null ; 
 
 - TraceState ts = new TraceState ( localAddress , sessionId , traceType ) ; 
 - state . set ( ts ) ; 
 + TraceState ts = newTraceState ( localAddress , sessionId , traceType ) ; 
 + set ( ts ) ; 
 sessions . put ( sessionId , ts ) ; 
 
 return sessionId ; 
 @ @ - 145 , 30 + 170 , 29 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 sessions . remove ( state . sessionId ) ; 
 } 
 
 + 
 / * * 
 * Stop the session and record its complete . Called by coodinator when request is complete . 
 * / 
 public void stopSession ( ) 
 { 
 - TraceState state = this . state . get ( ) ; 
 + TraceState state = get ( ) ; 
 if ( state = = null ) / / inline isTracing to avoid implicit two calls to state . get ( ) 
 { 
 logger . trace ( " request complete " ) ; 
 } 
 else 
 { 
 - final int elapsed = state . elapsed ( ) ; 
 - final ByteBuffer sessionId = state . sessionIdBytes ; 
 - final int ttl = state . ttl ; 
 - 
 - TraceState . executeMutation ( TraceKeyspace . makeStopSessionMutation ( sessionId , elapsed , ttl ) ) ; 
 + stopSessionImpl ( ) ; 
 
 state . stop ( ) ; 
 sessions . remove ( state . sessionId ) ; 
 - this . state . set ( null ) ; 
 + set ( null ) ; 
 } 
 } 
 
 + protected abstract void stopSessionImpl ( ) ; 
 + 
 public TraceState get ( ) 
 { 
 return state . get ( ) ; 
 @ @ - 189 , 24 + 213 , 11 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 return begin ( request , null , parameters ) ; 
 } 
 
 - public TraceState begin ( final String request , final InetAddress client , final Map < String , String > parameters ) 
 - { 
 - assert isTracing ( ) ; 
 - 
 - final TraceState state = this . state . get ( ) ; 
 - final long startedAt = System . currentTimeMillis ( ) ; 
 - final ByteBuffer sessionId = state . sessionIdBytes ; 
 - final String command = state . traceType . toString ( ) ; 
 - final int ttl = state . ttl ; 
 - 
 - TraceState . executeMutation ( TraceKeyspace . makeStartSessionMutation ( sessionId , client , parameters , request , startedAt , command , ttl ) ) ; 
 - 
 - return state ; 
 - } 
 + public abstract TraceState begin ( String request , InetAddress client , Map < String , String > parameters ) ; 
 
 / * * 
 * Determines the tracing context from a message . Does NOT set the threadlocal state . 
 - * 
 + * 
 * @ param message The internode message 
 * / 
 public TraceState initializeFromMessage ( final MessageIn < ? > message ) 
 @ @ - 218 , 7 + 229 , 7 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 
 assert sessionBytes . length = = 16 ; 
 UUID sessionId = UUIDGen . getUUID ( ByteBuffer . wrap ( sessionBytes ) ) ; 
 - TraceState ts = sessions . get ( sessionId ) ; 
 + TraceState ts = get ( sessionId ) ; 
 if ( ts ! = null & & ts . acquireReference ( ) ) 
 return ts ; 
 
 @ @ - 230 , 16 + 241 , 26 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 if ( message . verb = = MessagingService . Verb . REQUEST _ RESPONSE ) 
 { 
 / / received a message for a session we ' ve already closed out . see CASSANDRA - 5668 
 - return new ExpiredTraceState ( sessionId , traceType ) ; 
 + return new ExpiredTraceState ( newTraceState ( message . from , sessionId , traceType ) ) ; 
 } 
 else 
 { 
 - ts = new TraceState ( message . from , sessionId , traceType ) ; 
 + ts = newTraceState ( message . from , sessionId , traceType ) ; 
 sessions . put ( sessionId , ts ) ; 
 return ts ; 
 } 
 } 
 
 + public Map < String , byte [ ] > getTraceHeaders ( ) 
 + { 
 + assert isTracing ( ) ; 
 + 
 + return ImmutableMap . of ( 
 + TRACE _ HEADER , UUIDGen . decompose ( Tracing . instance . getSessionId ( ) ) , 
 + TRACE _ TYPE , new byte [ ] { Tracing . TraceType . serialize ( Tracing . instance . getTraceType ( ) ) } ) ; 
 + } 
 + 
 + protected abstract TraceState newTraceState ( InetAddress coordinator , UUID sessionId , Tracing . TraceType traceType ) ; 
 
 / / repair just gets a varargs method since it ' s so heavyweight anyway 
 public static void traceRepair ( String format , Object . . . args ) 
 @ @ - 287 , 4 + 308 , 10 @ @ public class Tracing implements ExecutorLocal < TraceState > 
 
 state . trace ( format , args ) ; 
 } 
 + 
 + / * * 
 + * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces 
 + * that are not initiated by local node = = coordinator ) . 
 + * / 
 + public abstract void trace ( ByteBuffer sessionId , String message , int ttl ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / tracing / TracingImpl . java b / src / java / org / apache / cassandra / tracing / TracingImpl . java 
 new file mode 100644 
 index 0000000 . . 52ac183 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / tracing / TracingImpl . java 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + package org . apache . cassandra . tracing ; 
 + 
 + import java . net . InetAddress ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . Map ; 
 + import java . util . UUID ; 
 + 
 + import org . apache . cassandra . concurrent . Stage ; 
 + import org . apache . cassandra . concurrent . StageManager ; 
 + import org . apache . cassandra . utils . WrappedRunnable ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + 
 + 
 + / * * 
 + * A trace session context . Able to track and store trace sessions . A session is usually a user initiated query , and may 
 + * have multiple local and remote events before it is completed . All events and sessions are stored at keyspace . 
 + * / 
 + class TracingImpl extends Tracing 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( TracingImpl . class ) ; 
 + 
 + public void stopSessionImpl ( ) { 
 + TraceState state = get ( ) ; 
 + int elapsed = state . elapsed ( ) ; 
 + ByteBuffer sessionId = state . sessionIdBytes ; 
 + int ttl = state . ttl ; 
 + TraceStateImpl . executeMutation ( TraceKeyspace . makeStopSessionMutation ( sessionId , elapsed , ttl ) ) ; 
 + } 
 + 
 + public TraceState begin ( final String request , final InetAddress client , final Map < String , String > parameters ) 
 + { 
 + assert isTracing ( ) ; 
 + 
 + final TraceState state = get ( ) ; 
 + final long startedAt = System . currentTimeMillis ( ) ; 
 + final ByteBuffer sessionId = state . sessionIdBytes ; 
 + final String command = state . traceType . toString ( ) ; 
 + final int ttl = state . ttl ; 
 + 
 + TraceStateImpl . executeMutation ( TraceKeyspace . makeStartSessionMutation ( sessionId , client , parameters , request , startedAt , command , ttl ) ) ; 
 + 
 + return state ; 
 + } 
 + 
 + @ Override 
 + protected TraceState newTraceState ( InetAddress coordinator , UUID sessionId , TraceType traceType ) 
 + { 
 + return new TraceStateImpl ( coordinator , sessionId , traceType ) ; 
 + } 
 + 
 + / * * 
 + * Called from { @ link org . apache . cassandra . net . OutboundTcpConnection } for non - local traces ( traces 
 + * that are not initiated by local node = = coordinator ) . 
 + * / 
 + public void trace ( final ByteBuffer sessionId , final String message , final int ttl ) 
 + { 
 + final String threadName = Thread . currentThread ( ) . getName ( ) ; 
 + 
 + StageManager . getStage ( Stage . TRACING ) . execute ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) 
 + { 
 + TraceStateImpl . mutateWithCatch ( TraceKeyspace . makeEventMutation ( sessionId , message , - 1 , threadName , ttl ) ) ; 
 + } 
 + } ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 index e9923b4 . . df6acc0 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / ExecuteMessage . java 
 @ @ - 110 , 7 + 110 , 7 @ @ public class ExecuteMessage extends Message . Request 
 
 if ( state . traceNextQuery ( ) ) 
 { 
 - state . createTracingSession ( ) ; 
 + state . createTracingSession ( getCustomPayload ( ) ) ; 
 
 ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; 
 if ( options . getPageSize ( ) > 0 ) 
 diff - - git a / test / unit / org / apache / cassandra / tracing / TracingTest . java b / test / unit / org / apache / cassandra / tracing / TracingTest . java 
 new file mode 100644 
 index 0000000 . . 1b0e507 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / tracing / TracingTest . java 
 @ @ - 0 , 0 + 1 , 173 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . tracing ; 
 + 
 + import java . net . InetAddress ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . UUID ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . utils . progress . ProgressEvent ; 
 + import org . apache . cassandra . utils . progress . ProgressListener ; 
 + 
 + public final class TracingTest 
 + { 
 + 
 + @ Test 
 + public void test ( ) 
 + { 
 + List < String > traces = new ArrayList < > ( ) ; 
 + Tracing tracing = new TracingImpl ( traces ) ; 
 + tracing . newSession ( Tracing . TraceType . NONE ) ; 
 + TraceState state = tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; 
 + state . trace ( " test - 1 " ) ; 
 + state . trace ( " test - 2 " ) ; 
 + state . trace ( " test - 3 " ) ; 
 + tracing . stopSession ( ) ; 
 + 
 + assert null = = tracing . get ( ) ; 
 + assert 4 = = traces . size ( ) ; 
 + assert " test - request " . equals ( traces . get ( 0 ) ) ; 
 + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; 
 + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; 
 + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void test _ get ( ) 
 + { 
 + List < String > traces = new ArrayList < > ( ) ; 
 + Tracing tracing = new TracingImpl ( traces ) ; 
 + tracing . newSession ( Tracing . TraceType . NONE ) ; 
 + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; 
 + tracing . get ( ) . trace ( " test - 1 " ) ; 
 + tracing . get ( ) . trace ( " test - 2 " ) ; 
 + tracing . get ( ) . trace ( " test - 3 " ) ; 
 + tracing . stopSession ( ) ; 
 + 
 + assert null = = tracing . get ( ) ; 
 + assert 4 = = traces . size ( ) ; 
 + assert " test - request " . equals ( traces . get ( 0 ) ) ; 
 + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; 
 + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; 
 + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void test _ get _ uuid ( ) 
 + { 
 + List < String > traces = new ArrayList < > ( ) ; 
 + Tracing tracing = new TracingImpl ( traces ) ; 
 + UUID uuid = tracing . newSession ( Tracing . TraceType . NONE ) ; 
 + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; 
 + tracing . get ( uuid ) . trace ( " test - 1 " ) ; 
 + tracing . get ( uuid ) . trace ( " test - 2 " ) ; 
 + tracing . get ( uuid ) . trace ( " test - 3 " ) ; 
 + tracing . stopSession ( ) ; 
 + 
 + assert null = = tracing . get ( ) ; 
 + assert 4 = = traces . size ( ) ; 
 + assert " test - request " . equals ( traces . get ( 0 ) ) ; 
 + assert " test - 1 " . equals ( traces . get ( 1 ) ) ; 
 + assert " test - 2 " . equals ( traces . get ( 2 ) ) ; 
 + assert " test - 3 " . equals ( traces . get ( 3 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void test _ states ( ) 
 + { 
 + List < String > traces = new ArrayList < > ( ) ; 
 + Tracing tracing = new TracingImpl ( traces ) ; 
 + tracing . newSession ( Tracing . TraceType . REPAIR ) ; 
 + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; 
 + tracing . get ( ) . enableActivityNotification ( " test - tag " ) ; 
 + assert TraceState . Status . IDLE = = tracing . get ( ) . waitActivity ( 1 ) ; 
 + tracing . get ( ) . trace ( " test - 1 " ) ; 
 + assert TraceState . Status . ACTIVE = = tracing . get ( ) . waitActivity ( 1 ) ; 
 + tracing . get ( ) . stop ( ) ; 
 + assert TraceState . Status . STOPPED = = tracing . get ( ) . waitActivity ( 1 ) ; 
 + tracing . stopSession ( ) ; 
 + assert null = = tracing . get ( ) ; 
 + } 
 + 
 + @ Test 
 + public void test _ progress _ listener ( ) 
 + { 
 + List < String > traces = new ArrayList < > ( ) ; 
 + Tracing tracing = new TracingImpl ( traces ) ; 
 + tracing . newSession ( Tracing . TraceType . REPAIR ) ; 
 + tracing . begin ( " test - request " , Collections . < String , String > emptyMap ( ) ) ; 
 + tracing . get ( ) . enableActivityNotification ( " test - tag " ) ; 
 + 
 + tracing . get ( ) . addProgressListener ( 
 + new ProgressListener ( ) 
 + { 
 + public void progress ( String tag , ProgressEvent pe ) 
 + { 
 + assert " test - tag " . equals ( tag ) ; 
 + assert " test - trace " . equals ( pe . getMessage ( ) ) ; 
 + } 
 + } ) ; 
 + 
 + tracing . get ( ) . trace ( " test - trace " ) ; 
 + tracing . stopSession ( ) ; 
 + assert null = = tracing . get ( ) ; 
 + } 
 + 
 + private class TracingImpl extends Tracing 
 + { 
 + private final List < String > traces ; 
 + 
 + public TracingImpl ( List < String > traces ) 
 + { 
 + this . traces = traces ; 
 + } 
 + 
 + public void stopSessionImpl ( ) 
 + { } 
 + 
 + public TraceState begin ( String request , InetAddress ia , Map < String , String > map ) 
 + { 
 + traces . add ( request ) ; 
 + return get ( ) ; 
 + } 
 + 
 + protected TraceState newTraceState ( InetAddress ia , UUID uuid , Tracing . TraceType tt ) 
 + { 
 + return new TraceState ( ia , uuid , tt ) 
 + { 
 + protected void traceImpl ( String string ) 
 + { 
 + traces . add ( string ) ; 
 + } 
 + 
 + } ; 
 + } 
 + 
 + public void trace ( ByteBuffer bb , String string , int i ) 
 + { 
 + throw new UnsupportedOperationException ( " Not supported yet . " ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7be913e . . 7c5a752 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 2 , 6 + 2 , 8 @ @ 
 * add command to stop compactions ( CASSANDRA - 1740 ) 
 * filter out unavailable cipher suites when using encryption ( CASSANDRA - 3178 ) 
 * ( HADOOP ) add old - style api support for CFIF and CFRR ( CASSANDRA - 2799 ) 
 + * Support TimeUUIDType column names in Stress . java tool ( CASSANDRA - 3541 ) 
 + 
 
 1 . 0 . 5 
 * revert CASSANDRA - 3407 ( see CASSANDRA - 3540 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / Session . java b / tools / stress / src / org / apache / cassandra / stress / Session . java 
 index abbea50 . . ddc6a69 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / Session . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / Session . java 
 @ @ - 27 , 9 + 27 , 7 @ @ import java . util . concurrent . atomic . AtomicLong ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ConfigurationException ; 
 - import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . db . marshal . TypeParser ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . commons . cli . * ; 
 
 import org . apache . cassandra . db . ColumnFamilyType ; 
 @ @ - 50 , 6 + 48 , 8 @ @ public class Session implements Serializable 
 public static final String DEFAULT _ COMPARATOR = " AsciiType " ; 
 public static final String DEFAULT _ VALIDATOR = " BytesType " ; 
 
 + private static InetAddress localInetAddress ; 
 + 
 public final AtomicInteger operations ; 
 public final AtomicInteger keys ; 
 public final AtomicLong latency ; 
 @ @ - 89 , 6 + 89 , 7 @ @ public class Session implements Serializable 
 availableOptions . addOption ( " I " , " compression " , true , " Specify the compression to use for sstable , default : no compression " ) ; 
 availableOptions . addOption ( " Q " , " query - names " , true , " Comma - separated list of column names to retrieve from each row . " ) ; 
 availableOptions . addOption ( " Z " , " compaction - strategy " , true , " CompactionStrategy to use . " ) ; 
 + availableOptions . addOption ( " U " , " comparator " , true , " Column Comparator to use . Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; 
 } 
 
 private int numKeys = 1000 * 1000 ; 
 @ @ - 131 , 6 + 132 , 8 @ @ public class Session implements Serializable 
 protected float sigma ; 
 
 public final InetAddress sendToDaemon ; 
 + public final String comparator ; 
 + public final boolean timeUUIDComparator ; 
 
 public Session ( String [ ] arguments ) throws IllegalArgumentException 
 { 
 @ @ - 321 , 6 + 324 , 35 @ @ public class Session implements Serializable 
 System . exit ( 1 ) ; 
 } 
 } 
 + 
 + if ( cmd . hasOption ( " U " ) ) 
 + { 
 + AbstractType parsed = null ; 
 + 
 + try 
 + { 
 + parsed = TypeParser . parse ( cmd . getOptionValue ( " U " ) ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + System . err . println ( e . getMessage ( ) ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + comparator = cmd . getOptionValue ( " U " ) ; 
 + timeUUIDComparator = parsed instanceof TimeUUIDType ; 
 + 
 + if ( ! ( parsed instanceof TimeUUIDType | | parsed instanceof AsciiType | | parsed instanceof UTF8Type ) ) 
 + { 
 + System . err . println ( " Currently supported types are : TimeUUIDType , AsciiType , UTF8Type . " ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + } 
 + else 
 + { 
 + comparator = null ; 
 + timeUUIDComparator = false ; 
 + } 
 } 
 catch ( ParseException e ) 
 { 
 @ @ - 464 , 6 + 496 , 7 @ @ public class Session implements Serializable 
 public void createKeySpaces ( ) 
 { 
 KsDef keyspace = new KsDef ( ) ; 
 + String defaultComparator = comparator = = null ? DEFAULT _ COMPARATOR : comparator ; 
 
 / / column family for standard columns 
 CfDef standardCfDef = new CfDef ( " Keyspace1 " , " Standard1 " ) ; 
 @ @ - 471 , 7 + 504 , 7 @ @ public class Session implements Serializable 
 if ( compression ! = null ) 
 compressionOptions . put ( " sstable _ compression " , compression ) ; 
 
 - standardCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) 
 + standardCfDef . setComparator _ type ( defaultComparator ) 
 . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) 
 . setCompression _ options ( compressionOptions ) ; 
 
 @ @ - 485 , 7 + 518 , 7 @ @ public class Session implements Serializable 
 / / column family with super columns 
 CfDef superCfDef = new CfDef ( " Keyspace1 " , " Super1 " ) . setColumn _ type ( " Super " ) ; 
 superCfDef . setComparator _ type ( DEFAULT _ COMPARATOR ) 
 - . setSubcomparator _ type ( DEFAULT _ COMPARATOR ) 
 + . setSubcomparator _ type ( defaultComparator ) 
 . setDefault _ validation _ class ( DEFAULT _ VALIDATOR ) 
 . setCompression _ options ( compressionOptions ) ; 
 
 @ @ - 574 , 4 + 607 , 20 @ @ public class Session implements Serializable 
 return client ; 
 } 
 
 + public static InetAddress getLocalAddress ( ) 
 + { 
 + if ( localInetAddress = = null ) 
 + { 
 + try 
 + { 
 + localInetAddress = InetAddress . getLocalHost ( ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + return localInetAddress ; 
 + } 
 } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 index 45d33cb . . c81df6f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / Inserter . java 
 @ @ - 52 , 9 + 52 , 9 @ @ public class Inserter extends Operation 
 
 for ( int i = 0 ; i < session . getColumnsPerKey ( ) ; i + + ) 
 { 
 - String columnName = ( " C " + Integer . toString ( i ) ) ; 
 - ByteBuffer columnValue = values . get ( i % values . size ( ) ) ; 
 - columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) ) . setValue ( columnValue ) . setTimestamp ( System . currentTimeMillis ( ) ) ) ; 
 + columns . add ( new Column ( columnName ( i , session . timeUUIDComparator ) ) 
 + . setValue ( values . get ( i % values . size ( ) ) ) 
 + . setTimestamp ( System . currentTimeMillis ( ) ) ) ; 
 } 
 
 if ( session . getColumnFamilyType ( ) = = ColumnFamilyType . Super ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 index 10b97ad . . dd5128f 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / util / Operation . java 
 @ @ - 27 , 11 + 27 , 14 @ @ import java . util . Random ; 
 
 import static com . google . common . base . Charsets . UTF _ 8 ; 
 
 + import org . apache . cassandra . db . marshal . TimeUUIDType ; 
 import org . apache . cassandra . stress . Session ; 
 import org . apache . cassandra . stress . Stress ; 
 import org . apache . cassandra . thrift . Cassandra ; 
 import org . apache . cassandra . thrift . InvalidRequestException ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 
 public abstract class Operation 
 { 
 @ @ - 200 , 6 + 203 , 13 @ @ public abstract class Operation 
 return result . toString ( ) ; 
 } 
 
 + protected ByteBuffer columnName ( int index , boolean timeUUIDComparator ) 
 + { 
 + return timeUUIDComparator 
 + ? TimeUUIDType . instance . decompose ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) ) 
 + : ByteBufferUtil . bytes ( String . format ( " C % d " , index ) ) ; 
 + } 
 + 
 protected String getExceptionMessage ( Exception e ) 
 { 
 String className = e . getClass ( ) . getSimpleName ( ) ;
