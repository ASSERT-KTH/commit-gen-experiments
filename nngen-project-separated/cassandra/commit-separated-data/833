BLEU SCORE: 0.03684138084561721

TEST MSG: Fix example metrics
GENERATED MSG: add jmx listener to publish metrics for cassandra - 5838

TEST DIFF (one line): diff - - git a / conf / metrics - reporter - config - sample . yaml b / conf / metrics - reporter - config - sample . yaml <nl> index 34b1d7e . . 54f2657 100644 <nl> - - - a / conf / metrics - reporter - config - sample . yaml <nl> + + + b / conf / metrics - reporter - config - sample . yaml <nl> @ @ - 35 , 7 + 35 , 7 @ @ console : <nl> - " ^ org . apache . cassandra . metrics . ClientRequest . + " # includes ClientRequestMetrics <nl> - " ^ org . apache . cassandra . metrics . CommitLog . + " <nl> - " ^ org . apache . cassandra . metrics . Compaction . + " <nl> - - " ^ org . apache . cassandra . metrics . DroppedMetrics . + " <nl> + - " ^ org . apache . cassandra . metrics . DroppedMessage . + " <nl> - " ^ org . apache . cassandra . metrics . ReadRepair . + " <nl> - " ^ org . apache . cassandra . metrics . Storage . + " <nl> - " ^ org . apache . cassandra . metrics . ThreadPools . + "
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f7e439c . . 805dca2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 3 , 7 + 3 , 7 @ @ <nl> * Log Merkle tree stats ( CASSANDRA - 2698 ) <nl> * Switch from crc32 to adler32 for compressed sstable checksums ( CASSANDRA - 5862 ) <nl> * Improve offheap memcpy performance ( CASSANDRA - 5884 ) <nl> - <nl> + * Use a range aware scanner for cleanup ( CASSANDRA - 2524 ) <nl> <nl> 2 . 0 . 0 - rc2 <nl> * enable vnodes by default ( CASSANDRA - 5869 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 7b11672 . . 2adda32 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1459 , 6 + 1459 , 18 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return columns ; <nl> } <nl> <nl> + public void cleanupCache ( ) <nl> + { <nl> + Collection < Range < Token > > ranges = StorageService . instance . getLocalRanges ( keyspace . getName ( ) ) ; <nl> + <nl> + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) <nl> + { <nl> + DecoratedKey dk = StorageService . getPartitioner ( ) . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; <nl> + if ( key . cfId = = metadata . cfId & & ! Range . isInRanges ( dk . token , ranges ) ) <nl> + invalidateCachedRow ( dk ) ; <nl> + } <nl> + } <nl> + <nl> public static abstract class AbstractScanIterator extends AbstractIterator < Row > implements CloseableIterator < Row > <nl> { <nl> public boolean needsFiltering ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> index 35354c8 . . ed6770f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java <nl> @ @ - 97 , 6 + 97 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> <nl> private final CompactionExecutor executor = new CompactionExecutor ( ) ; <nl> private final CompactionExecutor validationExecutor = new ValidationExecutor ( ) ; <nl> + private final static CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor ( ) ; <nl> + <nl> private final CompactionMetrics metrics = new CompactionMetrics ( executor , validationExecutor ) ; <nl> private final Multiset < ColumnFamilyStore > compactingCF = ConcurrentHashMultiset . create ( ) ; <nl> <nl> @ @ - 461 , 7 + 463 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> * <nl> * @ throws IOException <nl> * / <nl> - private void doCleanupCompaction ( ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException <nl> + private void doCleanupCompaction ( final ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException <nl> { <nl> assert ! cfs . isIndex ( ) ; <nl> Keyspace keyspace = cfs . keyspace ; <nl> @ @ - 472 , 8 + 474 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return ; <nl> } <nl> <nl> - boolean isCommutative = cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ; <nl> boolean hasIndexes = ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) ; <nl> + CleanupStrategy cleanupStrategy = CleanupStrategy . get ( cfs , ranges , renewer ) ; <nl> <nl> for ( SSTableReader sstable : sstables ) <nl> { <nl> @ @ - 500 , 10 + 502 , 9 @ @ public class CompactionManager implements CompactionManagerMBean <nl> if ( compactionFileLocation = = null ) <nl> throw new IOException ( " disk full " ) ; <nl> <nl> - SSTableScanner scanner = sstable . getScanner ( getRateLimiter ( ) ) ; <nl> - List < Column > indexedColumnsInRow = null ; <nl> + ICompactionScanner scanner = cleanupStrategy . getScanner ( sstable , getRateLimiter ( ) ) ; <nl> + CleanupInfo ci = new CleanupInfo ( sstable , ( SSTableScanner ) scanner ) ; <nl> <nl> - CleanupInfo ci = new CleanupInfo ( sstable , scanner ) ; <nl> metrics . beginCompaction ( ci ) ; <nl> SSTableWriter writer = createWriter ( cfs , <nl> compactionFileLocation , <nl> @ @ - 517 , 50 + 518 , 13 @ @ public class CompactionManager implements CompactionManagerMBean <nl> if ( ci . isStopRequested ( ) ) <nl> throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; <nl> SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; <nl> - if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) <nl> - { <nl> - AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; <nl> - if ( writer . append ( compactedRow ) ! = null ) <nl> - totalkeysWritten + + ; <nl> - } <nl> - else <nl> - { <nl> - cfs . invalidateCachedRow ( row . getKey ( ) ) ; <nl> - <nl> - if ( hasIndexes | | isCommutative ) <nl> - { <nl> - if ( indexedColumnsInRow ! = null ) <nl> - indexedColumnsInRow . clear ( ) ; <nl> - <nl> - while ( row . hasNext ( ) ) <nl> - { <nl> - OnDiskAtom column = row . next ( ) ; <nl> - if ( column instanceof CounterColumn ) <nl> - renewer . maybeRenew ( ( CounterColumn ) column ) ; <nl> - if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) <nl> - { <nl> - if ( indexedColumnsInRow = = null ) <nl> - indexedColumnsInRow = new ArrayList < Column > ( ) ; <nl> - <nl> - indexedColumnsInRow . add ( ( Column ) column ) ; <nl> - } <nl> - } <nl> - <nl> - if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) <nl> - { <nl> - / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 <nl> - Keyspace . switchLock . readLock ( ) . lock ( ) ; <nl> - try <nl> - { <nl> - cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; <nl> - } <nl> - finally <nl> - { <nl> - Keyspace . switchLock . readLock ( ) . unlock ( ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> + <nl> + row = cleanupStrategy . cleanup ( row ) ; <nl> + if ( row = = null ) <nl> + continue ; <nl> + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; <nl> + if ( writer . append ( compactedRow ) ! = null ) <nl> + totalkeysWritten + + ; <nl> } <nl> if ( totalkeysWritten > 0 ) <nl> newSstable = writer . closeAndOpenReader ( sstable . maxDataAge ) ; <nl> @ @ - 599 , 6 + 563 , 114 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> + private static abstract class CleanupStrategy <nl> + { <nl> + public static CleanupStrategy get ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) <nl> + { <nl> + if ( ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) | | cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) <nl> + return new Full ( cfs , ranges , renewer ) ; <nl> + <nl> + return new Bounded ( cfs , ranges ) ; <nl> + } <nl> + <nl> + public abstract ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) ; <nl> + public abstract SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) ; <nl> + <nl> + private static final class Bounded extends CleanupStrategy <nl> + { <nl> + private final Collection < Range < Token > > ranges ; <nl> + <nl> + public Bounded ( final ColumnFamilyStore cfs , Collection < Range < Token > > ranges ) <nl> + { <nl> + this . ranges = ranges ; <nl> + cacheCleanupExecutor . submit ( new Runnable ( ) <nl> + { <nl> + @ Override <nl> + public void run ( ) <nl> + { <nl> + cfs . cleanupCache ( ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + } <nl> + @ Override <nl> + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) <nl> + { <nl> + return sstable . getScanner ( ranges , limiter ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) <nl> + { <nl> + return row ; <nl> + } <nl> + } <nl> + <nl> + private static final class Full extends CleanupStrategy <nl> + { <nl> + private final Collection < Range < Token > > ranges ; <nl> + private final ColumnFamilyStore cfs ; <nl> + private List < Column > indexedColumnsInRow ; <nl> + private final CounterId . OneShotRenewer renewer ; <nl> + <nl> + public Full ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) <nl> + { <nl> + this . cfs = cfs ; <nl> + this . ranges = ranges ; <nl> + this . indexedColumnsInRow = null ; <nl> + this . renewer = renewer ; <nl> + } <nl> + <nl> + @ Override <nl> + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) <nl> + { <nl> + return sstable . getScanner ( limiter ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) <nl> + { <nl> + if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) <nl> + return row ; <nl> + <nl> + cfs . invalidateCachedRow ( row . getKey ( ) ) ; <nl> + <nl> + if ( indexedColumnsInRow ! = null ) <nl> + indexedColumnsInRow . clear ( ) ; <nl> + <nl> + while ( row . hasNext ( ) ) <nl> + { <nl> + OnDiskAtom column = row . next ( ) ; <nl> + if ( column instanceof CounterColumn ) <nl> + renewer . maybeRenew ( ( CounterColumn ) column ) ; <nl> + <nl> + if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) <nl> + { <nl> + if ( indexedColumnsInRow = = null ) <nl> + indexedColumnsInRow = new ArrayList < > ( ) ; <nl> + <nl> + indexedColumnsInRow . add ( ( Column ) column ) ; <nl> + } <nl> + } <nl> + <nl> + if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) <nl> + { <nl> + / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 <nl> + Keyspace . switchLock . readLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; <nl> + } <nl> + finally <nl> + { <nl> + Keyspace . switchLock . readLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + return null ; <nl> + } <nl> + } <nl> + } <nl> + <nl> public static SSTableWriter createWriter ( ColumnFamilyStore cfs , <nl> File compactionFileLocation , <nl> int expectedBloomFilterSize , <nl> @ @ - 847 , 6 + 919 , 14 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> + private static class CacheCleanupExecutor extends CompactionExecutor <nl> + { <nl> + public CacheCleanupExecutor ( ) <nl> + { <nl> + super ( 1 , " CacheCleanupExecutor " ) ; <nl> + } <nl> + } <nl> + <nl> public interface CompactionExecutorStatsCollector <nl> { <nl> void beginCompaction ( CompactionInfo . Holder ci ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 4a62d85 . . bbca089 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 1081 , 11 + 1081 , 23 @ @ public class SSTableReader extends SSTable <nl> { <nl> if ( range = = null ) <nl> return getScanner ( limiter ) ; <nl> + return getScanner ( Collections . singletonList ( range ) , limiter ) ; <nl> + } <nl> <nl> + / * * <nl> + * Direct I / O SSTableScanner over a defined collection of ranges of tokens . <nl> + * <nl> + * @ param ranges the range of keys to cover <nl> + * @ return A Scanner for seeking over the rows of the SSTable . <nl> + * / <nl> + public ICompactionScanner getScanner ( Collection < Range < Token > > ranges , RateLimiter limiter ) <nl> + { <nl> / / We want to avoid allocating a SSTableScanner if the range don ' t overlap the sstable

TEST DIFF:
diff - - git a / conf / metrics - reporter - config - sample . yaml b / conf / metrics - reporter - config - sample . yaml 
 index 34b1d7e . . 54f2657 100644 
 - - - a / conf / metrics - reporter - config - sample . yaml 
 + + + b / conf / metrics - reporter - config - sample . yaml 
 @ @ - 35 , 7 + 35 , 7 @ @ console : 
 - " ^ org . apache . cassandra . metrics . ClientRequest . + " # includes ClientRequestMetrics 
 - " ^ org . apache . cassandra . metrics . CommitLog . + " 
 - " ^ org . apache . cassandra . metrics . Compaction . + " 
 - - " ^ org . apache . cassandra . metrics . DroppedMetrics . + " 
 + - " ^ org . apache . cassandra . metrics . DroppedMessage . + " 
 - " ^ org . apache . cassandra . metrics . ReadRepair . + " 
 - " ^ org . apache . cassandra . metrics . Storage . + " 
 - " ^ org . apache . cassandra . metrics . ThreadPools . + "

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f7e439c . . 805dca2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 3 , 7 + 3 , 7 @ @ 
 * Log Merkle tree stats ( CASSANDRA - 2698 ) 
 * Switch from crc32 to adler32 for compressed sstable checksums ( CASSANDRA - 5862 ) 
 * Improve offheap memcpy performance ( CASSANDRA - 5884 ) 
 - 
 + * Use a range aware scanner for cleanup ( CASSANDRA - 2524 ) 
 
 2 . 0 . 0 - rc2 
 * enable vnodes by default ( CASSANDRA - 5869 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 7b11672 . . 2adda32 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1459 , 6 + 1459 , 18 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return columns ; 
 } 
 
 + public void cleanupCache ( ) 
 + { 
 + Collection < Range < Token > > ranges = StorageService . instance . getLocalRanges ( keyspace . getName ( ) ) ; 
 + 
 + for ( RowCacheKey key : CacheService . instance . rowCache . getKeySet ( ) ) 
 + { 
 + DecoratedKey dk = StorageService . getPartitioner ( ) . decorateKey ( ByteBuffer . wrap ( key . key ) ) ; 
 + if ( key . cfId = = metadata . cfId & & ! Range . isInRanges ( dk . token , ranges ) ) 
 + invalidateCachedRow ( dk ) ; 
 + } 
 + } 
 + 
 public static abstract class AbstractScanIterator extends AbstractIterator < Row > implements CloseableIterator < Row > 
 { 
 public boolean needsFiltering ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 index 35354c8 . . ed6770f 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionManager . java 
 @ @ - 97 , 6 + 97 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 
 private final CompactionExecutor executor = new CompactionExecutor ( ) ; 
 private final CompactionExecutor validationExecutor = new ValidationExecutor ( ) ; 
 + private final static CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor ( ) ; 
 + 
 private final CompactionMetrics metrics = new CompactionMetrics ( executor , validationExecutor ) ; 
 private final Multiset < ColumnFamilyStore > compactingCF = ConcurrentHashMultiset . create ( ) ; 
 
 @ @ - 461 , 7 + 463 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 * 
 * @ throws IOException 
 * / 
 - private void doCleanupCompaction ( ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException 
 + private void doCleanupCompaction ( final ColumnFamilyStore cfs , Collection < SSTableReader > sstables , CounterId . OneShotRenewer renewer ) throws IOException 
 { 
 assert ! cfs . isIndex ( ) ; 
 Keyspace keyspace = cfs . keyspace ; 
 @ @ - 472 , 8 + 474 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 return ; 
 } 
 
 - boolean isCommutative = cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ; 
 boolean hasIndexes = ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) ; 
 + CleanupStrategy cleanupStrategy = CleanupStrategy . get ( cfs , ranges , renewer ) ; 
 
 for ( SSTableReader sstable : sstables ) 
 { 
 @ @ - 500 , 10 + 502 , 9 @ @ public class CompactionManager implements CompactionManagerMBean 
 if ( compactionFileLocation = = null ) 
 throw new IOException ( " disk full " ) ; 
 
 - SSTableScanner scanner = sstable . getScanner ( getRateLimiter ( ) ) ; 
 - List < Column > indexedColumnsInRow = null ; 
 + ICompactionScanner scanner = cleanupStrategy . getScanner ( sstable , getRateLimiter ( ) ) ; 
 + CleanupInfo ci = new CleanupInfo ( sstable , ( SSTableScanner ) scanner ) ; 
 
 - CleanupInfo ci = new CleanupInfo ( sstable , scanner ) ; 
 metrics . beginCompaction ( ci ) ; 
 SSTableWriter writer = createWriter ( cfs , 
 compactionFileLocation , 
 @ @ - 517 , 50 + 518 , 13 @ @ public class CompactionManager implements CompactionManagerMBean 
 if ( ci . isStopRequested ( ) ) 
 throw new CompactionInterruptedException ( ci . getCompactionInfo ( ) ) ; 
 SSTableIdentityIterator row = ( SSTableIdentityIterator ) scanner . next ( ) ; 
 - if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) 
 - { 
 - AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; 
 - if ( writer . append ( compactedRow ) ! = null ) 
 - totalkeysWritten + + ; 
 - } 
 - else 
 - { 
 - cfs . invalidateCachedRow ( row . getKey ( ) ) ; 
 - 
 - if ( hasIndexes | | isCommutative ) 
 - { 
 - if ( indexedColumnsInRow ! = null ) 
 - indexedColumnsInRow . clear ( ) ; 
 - 
 - while ( row . hasNext ( ) ) 
 - { 
 - OnDiskAtom column = row . next ( ) ; 
 - if ( column instanceof CounterColumn ) 
 - renewer . maybeRenew ( ( CounterColumn ) column ) ; 
 - if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) 
 - { 
 - if ( indexedColumnsInRow = = null ) 
 - indexedColumnsInRow = new ArrayList < Column > ( ) ; 
 - 
 - indexedColumnsInRow . add ( ( Column ) column ) ; 
 - } 
 - } 
 - 
 - if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) 
 - { 
 - / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 
 - Keyspace . switchLock . readLock ( ) . lock ( ) ; 
 - try 
 - { 
 - cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; 
 - } 
 - finally 
 - { 
 - Keyspace . switchLock . readLock ( ) . unlock ( ) ; 
 - } 
 - } 
 - } 
 - } 
 + 
 + row = cleanupStrategy . cleanup ( row ) ; 
 + if ( row = = null ) 
 + continue ; 
 + AbstractCompactedRow compactedRow = controller . getCompactedRow ( row ) ; 
 + if ( writer . append ( compactedRow ) ! = null ) 
 + totalkeysWritten + + ; 
 } 
 if ( totalkeysWritten > 0 ) 
 newSstable = writer . closeAndOpenReader ( sstable . maxDataAge ) ; 
 @ @ - 599 , 6 + 563 , 114 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 + private static abstract class CleanupStrategy 
 + { 
 + public static CleanupStrategy get ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) 
 + { 
 + if ( ! cfs . indexManager . getIndexes ( ) . isEmpty ( ) | | cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) 
 + return new Full ( cfs , ranges , renewer ) ; 
 + 
 + return new Bounded ( cfs , ranges ) ; 
 + } 
 + 
 + public abstract ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) ; 
 + public abstract SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) ; 
 + 
 + private static final class Bounded extends CleanupStrategy 
 + { 
 + private final Collection < Range < Token > > ranges ; 
 + 
 + public Bounded ( final ColumnFamilyStore cfs , Collection < Range < Token > > ranges ) 
 + { 
 + this . ranges = ranges ; 
 + cacheCleanupExecutor . submit ( new Runnable ( ) 
 + { 
 + @ Override 
 + public void run ( ) 
 + { 
 + cfs . cleanupCache ( ) ; 
 + } 
 + } ) ; 
 + 
 + } 
 + @ Override 
 + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) 
 + { 
 + return sstable . getScanner ( ranges , limiter ) ; 
 + } 
 + 
 + @ Override 
 + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) 
 + { 
 + return row ; 
 + } 
 + } 
 + 
 + private static final class Full extends CleanupStrategy 
 + { 
 + private final Collection < Range < Token > > ranges ; 
 + private final ColumnFamilyStore cfs ; 
 + private List < Column > indexedColumnsInRow ; 
 + private final CounterId . OneShotRenewer renewer ; 
 + 
 + public Full ( ColumnFamilyStore cfs , Collection < Range < Token > > ranges , CounterId . OneShotRenewer renewer ) 
 + { 
 + this . cfs = cfs ; 
 + this . ranges = ranges ; 
 + this . indexedColumnsInRow = null ; 
 + this . renewer = renewer ; 
 + } 
 + 
 + @ Override 
 + public ICompactionScanner getScanner ( SSTableReader sstable , RateLimiter limiter ) 
 + { 
 + return sstable . getScanner ( limiter ) ; 
 + } 
 + 
 + @ Override 
 + public SSTableIdentityIterator cleanup ( SSTableIdentityIterator row ) 
 + { 
 + if ( Range . isInRanges ( row . getKey ( ) . token , ranges ) ) 
 + return row ; 
 + 
 + cfs . invalidateCachedRow ( row . getKey ( ) ) ; 
 + 
 + if ( indexedColumnsInRow ! = null ) 
 + indexedColumnsInRow . clear ( ) ; 
 + 
 + while ( row . hasNext ( ) ) 
 + { 
 + OnDiskAtom column = row . next ( ) ; 
 + if ( column instanceof CounterColumn ) 
 + renewer . maybeRenew ( ( CounterColumn ) column ) ; 
 + 
 + if ( column instanceof Column & & cfs . indexManager . indexes ( ( Column ) column ) ) 
 + { 
 + if ( indexedColumnsInRow = = null ) 
 + indexedColumnsInRow = new ArrayList < > ( ) ; 
 + 
 + indexedColumnsInRow . add ( ( Column ) column ) ; 
 + } 
 + } 
 + 
 + if ( indexedColumnsInRow ! = null & & ! indexedColumnsInRow . isEmpty ( ) ) 
 + { 
 + / / acquire memtable lock here because secondary index deletion may cause a race . See CASSANDRA - 3712 
 + Keyspace . switchLock . readLock ( ) . lock ( ) ; 
 + try 
 + { 
 + cfs . indexManager . deleteFromIndexes ( row . getKey ( ) , indexedColumnsInRow ) ; 
 + } 
 + finally 
 + { 
 + Keyspace . switchLock . readLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + return null ; 
 + } 
 + } 
 + } 
 + 
 public static SSTableWriter createWriter ( ColumnFamilyStore cfs , 
 File compactionFileLocation , 
 int expectedBloomFilterSize , 
 @ @ - 847 , 6 + 919 , 14 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 + private static class CacheCleanupExecutor extends CompactionExecutor 
 + { 
 + public CacheCleanupExecutor ( ) 
 + { 
 + super ( 1 , " CacheCleanupExecutor " ) ; 
 + } 
 + } 
 + 
 public interface CompactionExecutorStatsCollector 
 { 
 void beginCompaction ( CompactionInfo . Holder ci ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 4a62d85 . . bbca089 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 1081 , 11 + 1081 , 23 @ @ public class SSTableReader extends SSTable 
 { 
 if ( range = = null ) 
 return getScanner ( limiter ) ; 
 + return getScanner ( Collections . singletonList ( range ) , limiter ) ; 
 + } 
 
 + / * * 
 + * Direct I / O SSTableScanner over a defined collection of ranges of tokens . 
 + * 
 + * @ param ranges the range of keys to cover 
 + * @ return A Scanner for seeking over the rows of the SSTable . 
 + * / 
 + public ICompactionScanner getScanner ( Collection < Range < Token > > ranges , RateLimiter limiter ) 
 + { 
 / / We want to avoid allocating a SSTableScanner if the range don ' t overlap the sstable
