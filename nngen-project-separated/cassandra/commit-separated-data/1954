BLEU SCORE: 0.027611988917697356

TEST MSG: Avoid stack overflow on large clustering IN values
GENERATED MSG: Remove dead ColumnSlice . NavigatableMapIterator

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index cc426bb . . 6cecf99 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 12 : <nl> + * Avoid StackOverflowError when a large list of IN values <nl> + is used for a clustering column ( CASSANDRA - 8410 ) <nl> * Fix NPE when writetime ( ) or ttl ( ) calls are wrapped by <nl> another function call ( CASSANDRA - 8451 ) <nl> * Fix NPE after dropping a keyspace ( CASSANDRA - 8332 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> index 9eff12a . . 6a9efbb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> @ @ - 130 , 36 + 130 , 36 @ @ public class ColumnSlice <nl> <nl> protected Column computeNext ( ) <nl> { <nl> - if ( currentSlice = = null ) <nl> + while ( currentSlice ! = null | | idx < slices . length ) <nl> { <nl> - if ( idx > = slices . length ) <nl> - return endOfData ( ) ; <nl> - <nl> - ColumnSlice slice = slices [ idx + + ] ; <nl> - / / Note : we specialize the case of start = = " " and finish = " " because it is slightly more efficient , but also they have a specific <nl> - / / meaning ( namely , they always extend to the beginning / end of the range ) . <nl> - if ( slice . start . remaining ( ) = = 0 ) <nl> + if ( currentSlice = = null ) <nl> { <nl> - if ( slice . finish . remaining ( ) = = 0 ) <nl> - currentSlice = map . values ( ) . iterator ( ) ; <nl> + ColumnSlice slice = slices [ idx + + ] ; <nl> + / / Note : we specialize the case of start = = " " and finish = " " because it is slightly more efficient , but also they have a specific <nl> + / / meaning ( namely , they always extend to the beginning / end of the range ) . <nl> + if ( slice . start . remaining ( ) = = 0 ) <nl> + { <nl> + if ( slice . finish . remaining ( ) = = 0 ) <nl> + currentSlice = map . values ( ) . iterator ( ) ; <nl> + else <nl> + currentSlice = map . headMap ( slice . finish , true ) . values ( ) . iterator ( ) ; <nl> + } <nl> + else if ( slice . finish . remaining ( ) = = 0 ) <nl> + { <nl> + currentSlice = map . tailMap ( slice . start , true ) . values ( ) . iterator ( ) ; <nl> + } <nl> else <nl> - currentSlice = map . headMap ( slice . finish , true ) . values ( ) . iterator ( ) ; <nl> - } <nl> - else if ( slice . finish . remaining ( ) = = 0 ) <nl> - { <nl> - currentSlice = map . tailMap ( slice . start , true ) . values ( ) . iterator ( ) ; <nl> + { <nl> + currentSlice = map . subMap ( slice . start , true , slice . finish , true ) . values ( ) . iterator ( ) ; <nl> + } <nl> } <nl> - else <nl> - { <nl> - currentSlice = map . subMap ( slice . start , true , slice . finish , true ) . values ( ) . iterator ( ) ; <nl> - } <nl> - } <nl> <nl> - if ( currentSlice . hasNext ( ) ) <nl> - return currentSlice . next ( ) ; <nl> + if ( currentSlice . hasNext ( ) ) <nl> + return currentSlice . next ( ) ; <nl> <nl> - currentSlice = null ; <nl> - return computeNext ( ) ; <nl> + currentSlice = null ; <nl> + } <nl> + return endOfData ( ) ; <nl> } <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index cc426bb . . 6cecf99 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 12 : 
 + * Avoid StackOverflowError when a large list of IN values 
 + is used for a clustering column ( CASSANDRA - 8410 ) 
 * Fix NPE when writetime ( ) or ttl ( ) calls are wrapped by 
 another function call ( CASSANDRA - 8451 ) 
 * Fix NPE after dropping a keyspace ( CASSANDRA - 8332 ) 
 diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 index 9eff12a . . 6a9efbb 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 @ @ - 130 , 36 + 130 , 36 @ @ public class ColumnSlice 
 
 protected Column computeNext ( ) 
 { 
 - if ( currentSlice = = null ) 
 + while ( currentSlice ! = null | | idx < slices . length ) 
 { 
 - if ( idx > = slices . length ) 
 - return endOfData ( ) ; 
 - 
 - ColumnSlice slice = slices [ idx + + ] ; 
 - / / Note : we specialize the case of start = = " " and finish = " " because it is slightly more efficient , but also they have a specific 
 - / / meaning ( namely , they always extend to the beginning / end of the range ) . 
 - if ( slice . start . remaining ( ) = = 0 ) 
 + if ( currentSlice = = null ) 
 { 
 - if ( slice . finish . remaining ( ) = = 0 ) 
 - currentSlice = map . values ( ) . iterator ( ) ; 
 + ColumnSlice slice = slices [ idx + + ] ; 
 + / / Note : we specialize the case of start = = " " and finish = " " because it is slightly more efficient , but also they have a specific 
 + / / meaning ( namely , they always extend to the beginning / end of the range ) . 
 + if ( slice . start . remaining ( ) = = 0 ) 
 + { 
 + if ( slice . finish . remaining ( ) = = 0 ) 
 + currentSlice = map . values ( ) . iterator ( ) ; 
 + else 
 + currentSlice = map . headMap ( slice . finish , true ) . values ( ) . iterator ( ) ; 
 + } 
 + else if ( slice . finish . remaining ( ) = = 0 ) 
 + { 
 + currentSlice = map . tailMap ( slice . start , true ) . values ( ) . iterator ( ) ; 
 + } 
 else 
 - currentSlice = map . headMap ( slice . finish , true ) . values ( ) . iterator ( ) ; 
 - } 
 - else if ( slice . finish . remaining ( ) = = 0 ) 
 - { 
 - currentSlice = map . tailMap ( slice . start , true ) . values ( ) . iterator ( ) ; 
 + { 
 + currentSlice = map . subMap ( slice . start , true , slice . finish , true ) . values ( ) . iterator ( ) ; 
 + } 
 } 
 - else 
 - { 
 - currentSlice = map . subMap ( slice . start , true , slice . finish , true ) . values ( ) . iterator ( ) ; 
 - } 
 - } 
 
 - if ( currentSlice . hasNext ( ) ) 
 - return currentSlice . next ( ) ; 
 + if ( currentSlice . hasNext ( ) ) 
 + return currentSlice . next ( ) ; 
 
 - currentSlice = null ; 
 - return computeNext ( ) ; 
 + currentSlice = null ; 
 + } 
 + return endOfData ( ) ; 
 } 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
