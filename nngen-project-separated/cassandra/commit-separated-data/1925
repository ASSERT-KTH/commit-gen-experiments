BLEU SCORE: 0.03283637368030199

TEST MSG: Allow mixing token and partition key restrictions
GENERATED MSG: Murmur3Partitioner improvements

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8ccc014 . . 9f946a3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Allow mixing token and partition key restrictions ( CASSANDRA - 7016 ) <nl> * Support index key / value entries on map collections ( CASSANDRA - 8473 ) <nl> * Modernize schema tables ( CASSANDRA - 8261 ) <nl> * Support for user - defined aggregation functions ( CASSANDRA - 8053 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / TokenRelation . java b / src / java / org / apache / cassandra / cql3 / TokenRelation . java <nl> index d1bd265 . . 5896fae 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / TokenRelation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / TokenRelation . java <nl> @ @ - 69 , 7 + 69 , 7 @ @ public final class TokenRelation extends Relation <nl> { <nl> List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; <nl> Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; <nl> - return new TokenRestriction . EQ ( columnDefs , term ) ; <nl> + return new TokenRestriction . EQ ( cfm . getKeyValidatorAsCType ( ) , columnDefs , term ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 86 , 7 + 86 , 7 @ @ public final class TokenRelation extends Relation <nl> { <nl> List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; <nl> Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; <nl> - return new TokenRestriction . Slice ( columnDefs , bound , inclusive , term ) ; <nl> + return new TokenRestriction . Slice ( cfm . getKeyValidatorAsCType ( ) , columnDefs , bound , inclusive , term ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java <nl> index f137a77 . . 0107603 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java <nl> @ @ - 17 , 11 + 17 , 23 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 . restrictions ; <nl> <nl> + import org . apache . cassandra . db . composites . CType ; <nl> + <nl> / * * <nl> * Base class for < code > PrimaryKeyRestrictions < / code > . <nl> * / <nl> abstract class AbstractPrimaryKeyRestrictions extends AbstractRestriction implements PrimaryKeyRestrictions <nl> { <nl> + / * * <nl> + * The composite type . <nl> + * / <nl> + protected final CType ctype ; <nl> + <nl> + public AbstractPrimaryKeyRestrictions ( CType ctype ) <nl> + { <nl> + this . ctype = ctype ; <nl> + } <nl> + <nl> @ Override <nl> public final boolean isEmpty ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java <nl> index e3b3c4c . . 2d6deeb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java <nl> @ @ - 43 , 8 + 43 , 6 @ @ import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidReq <nl> <nl> public abstract class MultiColumnRestriction extends AbstractPrimaryKeyRestrictions <nl> { <nl> - protected final CType ctype ; <nl> - <nl> / * * <nl> * The columns to which the restriction apply . <nl> * / <nl> @ @ - 52 , 7 + 50 , 7 @ @ public abstract class MultiColumnRestriction extends AbstractPrimaryKeyRestricti <nl> <nl> public MultiColumnRestriction ( CType ctype , List < ColumnDefinition > columnDefs ) <nl> { <nl> - this . ctype = ctype ; <nl> + super ( ctype ) ; <nl> this . columnDefs = columnDefs ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java <nl> index 5c8386e . . d2a3885 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java <nl> @ @ - 43 , 11 + 43 , 6 @ @ import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; <nl> final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestrictions <nl> { <nl> / * * <nl> - * The composite type . <nl> - * / <nl> - private final CType ctype ; <nl> - <nl> - / * * <nl> * The restrictions . <nl> * / <nl> private final SingleColumnRestrictions restrictions ; <nl> @ @ - 74 , 7 + 69 , 7 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric <nl> <nl> public SingleColumnPrimaryKeyRestrictions ( CType ctype ) <nl> { <nl> - this . ctype = ctype ; <nl> + super ( ctype ) ; <nl> this . restrictions = new SingleColumnRestrictions ( ) ; <nl> this . eq = true ; <nl> } <nl> @ @ - 82 , 8 + 77 , 8 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric <nl> private SingleColumnPrimaryKeyRestrictions ( SingleColumnPrimaryKeyRestrictions primaryKeyRestrictions , <nl> SingleColumnRestriction restriction ) throws InvalidRequestException <nl> { <nl> + super ( primaryKeyRestrictions . ctype ) ; <nl> this . restrictions = primaryKeyRestrictions . restrictions . addRestriction ( restriction ) ; <nl> - this . ctype = primaryKeyRestrictions . ctype ; <nl> <nl> if ( ! primaryKeyRestrictions . isEmpty ( ) ) <nl> { <nl> @ @ - 166 , 9 + 161 , 10 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric <nl> <nl> if ( restriction . isOnToken ( ) ) <nl> { <nl> - checkTrue ( isEmpty ( ) , " Columns \ " % s \ " cannot be restricted by both a normal relation and a token relation " , <nl> - ( ( TokenRestriction ) restriction ) . getColumnNamesAsString ( ) ) ; <nl> - return ( PrimaryKeyRestrictions ) restriction ; <nl> + if ( isEmpty ( ) ) <nl> + return ( PrimaryKeyRestrictions ) restriction ; <nl> + <nl> + return new TokenFilter ( this , ( TokenRestriction ) restriction ) ; <nl> } <nl> <nl> return new SingleColumnPrimaryKeyRestrictions ( this , ( SingleColumnRestriction ) restriction ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> index 60c7465 . . 598478c 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> @ @ - 259 , 10 + 259 , 9 @ @ public final class StatementRestrictions <nl> / / If a component of the partition key is restricted by a relation , all preceding <nl> / / components must have a EQ . Only the last partition key component can be in IN relation . <nl> if ( partitionKeyRestrictions . isOnToken ( ) ) <nl> - { <nl> isKeyRange = true ; <nl> - } <nl> - else if ( hasPartitionKeyUnrestrictedComponents ( ) ) <nl> + <nl> + if ( hasPartitionKeyUnrestrictedComponents ( ) ) <nl> { <nl> if ( ! partitionKeyRestrictions . isEmpty ( ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java b / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java <nl> new file mode 100644 <nl> index 0000000 . . 4b5383b <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java <nl> @ @ - 0 , 0 + 1 , 237 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 . restrictions ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + import com . google . common . collect . BoundType ; <nl> + import com . google . common . collect . ImmutableRangeSet ; <nl> + import com . google . common . collect . Range ; <nl> + import com . google . common . collect . RangeSet ; <nl> + <nl> + import org . apache . cassandra . cql3 . QueryOptions ; <nl> + import org . apache . cassandra . cql3 . statements . Bound ; <nl> + import org . apache . cassandra . db . composites . Composite ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> + <nl> + import static org . apache . cassandra . cql3 . statements . Bound . END ; <nl> + import static org . apache . cassandra . cql3 . statements . Bound . START ; <nl> + <nl> + / * * <nl> + * < code > Restriction < / code > decorator used to merge non - token restriction and token restriction on partition keys . <nl> + * / <nl> + final class TokenFilter extends ForwardingPrimaryKeyRestrictions <nl> + { <nl> + / * * <nl> + * The decorated restriction <nl> + * / <nl> + private PrimaryKeyRestrictions restrictions ; <nl> + <nl> + / * * <nl> + * The restriction on the token <nl> + * / <nl> + private TokenRestriction tokenRestriction ; <nl> + <nl> + / * * <nl> + * The partitioner <nl> + * / <nl> + private static final IPartitioner partitioner = StorageService . getPartitioner ( ) ; <nl> + <nl> + @ Override <nl> + protected PrimaryKeyRestrictions getDelegate ( ) <nl> + { <nl> + return restrictions ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isOnToken ( ) <nl> + { <nl> + / / if all partition key columns have non - token restrictions , we can simply use the token range to filter <nl> + / / those restrictions and then ignore the token range <nl> + return restrictions . size ( ) < tokenRestriction . size ( ) ; <nl> + } <nl> + <nl> + public TokenFilter ( PrimaryKeyRestrictions restrictions , TokenRestriction tokenRestriction ) <nl> + { <nl> + this . restrictions = restrictions ; <nl> + this . tokenRestriction = tokenRestriction ; <nl> + } <nl> + <nl> + @ Override <nl> + public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + return filter ( restrictions . values ( options ) , options ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public List < Composite > valuesAsComposites ( QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + throw new UnsupportedOperationException ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException <nl> + { <nl> + if ( restriction . isOnToken ( ) ) <nl> + return new TokenFilter ( restrictions , ( TokenRestriction ) tokenRestriction . mergeWith ( restriction ) ) ; <nl> + <nl> + return new TokenFilter ( super . mergeWith ( restriction ) , tokenRestriction ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isInclusive ( Bound bound ) <nl> + { <nl> + return tokenRestriction . isInclusive ( bound ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean hasBound ( Bound b ) <nl> + { <nl> + return tokenRestriction . hasBound ( b ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public List < ByteBuffer > bounds ( Bound bound , QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + return tokenRestriction . bounds ( bound , options ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public List < Composite > boundsAsComposites ( Bound bound , QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + return tokenRestriction . boundsAsComposites ( bound , options ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Filter the values returned by the restriction . <nl> + * <nl> + * @ param values the values returned by the decorated restriction <nl> + * @ param options the query options <nl> + * @ return the values matching the token restriction <nl> + * @ throws InvalidRequestException if the request is invalid <nl> + * / <nl> + private List < ByteBuffer > filter ( List < ByteBuffer > values , QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + RangeSet < Token > rangeSet = tokenRestriction . isSlice ( ) ? toRangeSet ( tokenRestriction , options ) <nl> + : toRangeSet ( tokenRestriction . values ( options ) ) ; <nl> + <nl> + return filterWithRangeSet ( rangeSet , values ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Filter out the values for which the tokens are not included within the specified range . <nl> + * <nl> + * @ param tokens the tokens range <nl> + * @ param values the restricted values <nl> + * @ return the values for which the tokens are not included within the specified range . <nl> + * / <nl> + private static List < ByteBuffer > filterWithRangeSet ( RangeSet < Token > tokens , List < ByteBuffer > values ) <nl> + { <nl> + List < ByteBuffer > remaining = new ArrayList < > ( ) ; <nl> + <nl> + for ( ByteBuffer value : values ) <nl> + { <nl> + Token token = partitioner . getToken ( value ) ; <nl> + <nl> + if ( ! tokens . contains ( token ) ) <nl> + continue ; <nl> + <nl> + remaining . add ( value ) ; <nl> + } <nl> + return remaining ; <nl> + } <nl> + <nl> + / * * <nl> + * Converts the specified list into a range set . <nl> + * <nl> + * @ param buffers the token restriction values <nl> + * @ return the range set corresponding to the specified list <nl> + * / <nl> + private static RangeSet < Token > toRangeSet ( List < ByteBuffer > buffers ) <nl> + { <nl> + ImmutableRangeSet . Builder < Token > builder = ImmutableRangeSet . builder ( ) ; <nl> + <nl> + for ( ByteBuffer buffer : buffers ) <nl> + builder . add ( Range . singleton ( deserializeToken ( buffer ) ) ) ; <nl> + <nl> + return builder . build ( ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Converts the specified slice into a range set . <nl> + * <nl> + * @ param slice the slice to convert <nl> + * @ param options the query option <nl> + * @ return the range set corresponding to the specified slice <nl> + * @ throws InvalidRequestException if the request is invalid <nl> + * / <nl> + private static RangeSet < Token > toRangeSet ( TokenRestriction slice , QueryOptions options ) throws InvalidRequestException <nl> + { <nl> + if ( slice . hasBound ( START ) ) <nl> + { <nl> + Token start = deserializeToken ( slice . bounds ( START , options ) . get ( 0 ) ) ; <nl> + <nl> + BoundType startBoundType = toBoundType ( slice . isInclusive ( START ) ) ; <nl> + BoundType endBoundType = toBoundType ( slice . isInclusive ( END ) ) ; <nl> + <nl> + if ( slice . hasBound ( END ) ) <nl> + { <nl> + Token end = deserializeToken ( slice . bounds ( END , options ) . get ( 0 ) ) ; <nl> + <nl> + if ( start . equals ( end ) & & ( BoundType . OPEN = = startBoundType | | BoundType . OPEN = = endBoundType ) ) <nl> + return ImmutableRangeSet . of ( ) ; <nl> + <nl> + if ( start . compareTo ( end ) < = 0 ) <nl> + return ImmutableRangeSet . of ( Range . range ( start , <nl> + startBoundType , <nl> + end , <nl> + endBoundType ) ) ; <nl> + <nl> + return ImmutableRangeSet . < Token > builder ( ) <nl> + . add ( Range . upTo ( end , endBoundType ) ) <nl> + . add ( Range . downTo ( start , startBoundType ) ) <nl> + . build ( ) ; <nl> + } <nl> + return ImmutableRangeSet . of ( Range . downTo ( start , <nl> + startBoundType ) ) ; <nl> + } <nl> + Token end = deserializeToken ( slice . bounds ( END , options ) . get ( 0 ) ) ; <nl> + return ImmutableRangeSet . of ( Range . upTo ( end , toBoundType ( slice . isInclusive ( END ) ) ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Deserializes the token corresponding to the specified buffer . <nl> + * <nl> + * @ param buffer the buffer <nl> + * @ return the token corresponding to the specified buffer <nl> + * / <nl> + private static Token deserializeToken ( ByteBuffer buffer ) <nl> + { <nl> + return partitioner . getTokenFactory ( ) . fromByteArray ( buffer ) ; <nl> + } <nl> + <nl> + private static BoundType toBoundType ( boolean inclusive ) <nl> + { <nl> + return inclusive ? BoundType . CLOSED : BoundType . OPEN ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java <nl> index 85d614e . . 8d63fea 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . cassandra . cql3 . QueryOptions ; <nl> import org . apache . cassandra . cql3 . Term ; <nl> import org . apache . cassandra . cql3 . statements . Bound ; <nl> import org . apache . cassandra . db . IndexExpression ; <nl> + import org . apache . cassandra . db . composites . CType ; <nl> import org . apache . cassandra . db . composites . Composite ; <nl> import org . apache . cassandra . db . index . SecondaryIndexManager ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> @ @ - 48 , 10 + 49 , 12 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> / * * <nl> * Creates a new < code > TokenRestriction < / code > that apply to the specified columns . <nl> * <nl> + * @ param ctype the composite type <nl> * @ param columnDefs the definition of the columns to which apply the token restriction <nl> * / <nl> - public TokenRestriction ( List < ColumnDefinition > columnDefs ) <nl> + public TokenRestriction ( CType ctype , List < ColumnDefinition > columnDefs ) <nl> { <nl> + super ( ctype ) ; <nl> this . columnDefs = columnDefs ; <nl> } <nl> <nl> @ @ - 101 , 13 + 104 , 43 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> return Joiner . on ( " , " ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ; <nl> } <nl> <nl> + @ Override <nl> + public final PrimaryKeyRestrictions mergeWith ( Restriction otherRestriction ) throws InvalidRequestException <nl> + { <nl> + if ( ! otherRestriction . isOnToken ( ) ) <nl> + return new TokenFilter ( toPrimaryKeyRestriction ( otherRestriction ) , this ) ; <nl> + <nl> + return doMergeWith ( ( TokenRestriction ) otherRestriction ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Merges this restriction with the specified < code > TokenRestriction < / code > . <nl> + * @ param otherRestriction the < code > TokenRestriction < / code > to merge with . <nl> + * / <nl> + protected abstract PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException ; <nl> + <nl> + / * * <nl> + * Converts the specified restriction into a < code > PrimaryKeyRestrictions < / code > . <nl> + * <nl> + * @ param restriction the restriction to convert <nl> + * @ return a < code > PrimaryKeyRestrictions < / code > <nl> + * @ throws InvalidRequestException if a problem occurs while converting the restriction <nl> + * / <nl> + private PrimaryKeyRestrictions toPrimaryKeyRestriction ( Restriction restriction ) throws InvalidRequestException <nl> + { <nl> + if ( restriction instanceof PrimaryKeyRestrictions ) <nl> + return ( PrimaryKeyRestrictions ) restriction ; <nl> + <nl> + return new SingleColumnPrimaryKeyRestrictions ( ctype ) . mergeWith ( restriction ) ; <nl> + } <nl> + <nl> public static final class EQ extends TokenRestriction <nl> { <nl> private final Term value ; <nl> <nl> - public EQ ( List < ColumnDefinition > columnDefs , Term value ) <nl> + public EQ ( CType ctype , List < ColumnDefinition > columnDefs , Term value ) <nl> { <nl> - super ( columnDefs ) ; <nl> + super ( ctype , columnDefs ) ; <nl> this . value = value ; <nl> } <nl> <nl> @ @ - 124 , 7 + 157 , 7 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> } <nl> <nl> @ Override <nl> - public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException <nl> + protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException <nl> { <nl> throw invalidRequest ( " % s cannot be restricted by more than one relation if it includes an Equal " , <nl> Joiner . on ( " , " ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ) ; <nl> @ @ - 141 , 9 + 174 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> { <nl> private final TermSlice slice ; <nl> <nl> - public Slice ( List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) <nl> + public Slice ( CType ctype , List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) <nl> { <nl> - super ( columnDefs ) ; <nl> + super ( ctype , columnDefs ) ; <nl> slice = TermSlice . newInstance ( bound , inclusive , term ) ; <nl> } <nl> <nl> @ @ - 185 , 13 + 218 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> } <nl> <nl> @ Override <nl> - public PrimaryKeyRestrictions mergeWith ( Restriction otherRestriction ) <nl> + protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) <nl> throws InvalidRequestException <nl> { <nl> - if ( ! otherRestriction . isOnToken ( ) ) <nl> - throw invalidRequest ( " Columns \ " % s \ " cannot be restricted by both a normal relation and a token relation " , <nl> - getColumnNamesAsString ( ) ) ; <nl> - <nl> if ( ! otherRestriction . isSlice ( ) ) <nl> throw invalidRequest ( " Columns \ " % s \ " cannot be restricted by both an equality and an inequality relation " , <nl> getColumnNamesAsString ( ) ) ; <nl> @ @ - 206 , 7 + 235 , 7 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> throw invalidRequest ( " More than one restriction was found for the end bound on % s " , <nl> getColumnNamesAsString ( ) ) ; <nl> <nl> - return new Slice ( columnDefs , slice . merge ( otherSlice . slice ) ) ; <nl> + return new Slice ( ctype , columnDefs , slice . merge ( otherSlice . slice ) ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 215 , 9 + 244 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions <nl> return String . format ( " SLICE % s " , slice ) ; <nl> } <nl> <nl> - private Slice ( List < ColumnDefinition > columnDefs , TermSlice slice ) <nl> + private Slice ( CType ctype , List < ColumnDefinition > columnDefs , TermSlice slice ) <nl> { <nl> - super ( columnDefs ) ; <nl> + super ( ctype , columnDefs ) ; <nl> this . slice = slice ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java b / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java <nl> index 39b62e3 . . a365c09 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 ; <nl> <nl> + import java . util . Arrays ; <nl> + <nl> import org . junit . Test ; <nl> <nl> public class SelectWithTokenFunctionTest extends CQLTester <nl> @ @ - 30 , 10 + 32 , 6 @ @ public class SelectWithTokenFunctionTest extends CQLTester <nl> assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) " , 0 ) , row ( 0 , " a " ) ) ; <nl> assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) and token ( a ) < token ( ? ) " , 0 , 1 ) , row ( 0 , " a " ) ) ; <nl> assertInvalid ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) " , " a " ) ; <nl> - assertInvalidMessage ( " Columns \ " a \ " cannot be restricted by both a normal relation and a token relation " , <nl> - " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? " , 1 , 1 ) ; <nl> - assertInvalidMessage ( " Columns \ " a \ " cannot be restricted by both a normal relation and a token relation " , <nl> - " SELECT * FROM % s WHERE a = ? and token ( a ) > token ( ? ) " , 1 , 1 ) ; <nl> assertInvalidMessage ( " The token ( ) function must contains only partition key components " , <nl> " SELECT * FROM % s WHERE token ( a , b ) > = token ( ? , ? ) " , " b " , 0 ) ; <nl> assertInvalidMessage ( " More than one restriction was found for the start bound on a " , <nl> @ @ - 88 , 4 + 86 , 137 @ @ public class SelectWithTokenFunctionTest extends CQLTester <nl> assertInvalidMessage ( " The token ( ) function must be applied to all partition key components or none of them " , <nl> " SELECT * FROM % s WHERE token ( a ) > token ( ? , ? ) and token ( b ) > token ( ? , ? ) " , 0 , " a " , 0 , " a " ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testSingleColumnPartitionKeyWithTokenNonTokenRestrictionsMix ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int primary key , b int ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 0 , 0 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 1 , 1 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 2 , 2 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 3 , 3 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b ) VALUES ( 4 , 4 ) ; " ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) ; " , 1 , 3 ) , <nl> + row ( 1 , 1 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) and token ( a ) < = token ( ? ) ; " , 1 , 3 ) , <nl> + row ( 2 , 2 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) = token ( 2 ) ; " ) , <nl> + row ( 2 , 2 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a IN ( ? , ? ) ; " , <nl> + 1 , 3 , 1 , 3 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) < token ( ? ) AND token ( a ) > = token ( ? ) AND a IN ( ? , ? ) ; " , <nl> + 1 , 3 , 1 , 3 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertInvalidMessage ( " Only EQ and IN relation are supported on the partition key ( unless you use the token ( ) function ) " , <nl> + " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a > ? ; " , 1 , 3 , 1 ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a IN ? ; " , <nl> + 1 , 3 , Arrays . asList ( 1 , 3 ) ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? ; " , 1 , 3 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a ) > token ( ? ) ; " , 3 , 1 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? ; " , 3 , 1 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a ) > token ( ? ) ; " , 1 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a IN ( ? , ? ) ; " , 2 , 1 , 3 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) AND a IN ( ? , ? ) ; " , 2 , 5 , 1 , 3 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) AND token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) ; " , 1 , 3 , 2 , 5 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a IN ( ? , ? ) AND token ( a ) < token ( ? ) ; " , 2 , 1 , 3 , 5 ) , <nl> + row ( 3 , 3 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) AND token ( a ) > token ( ? ) ; " , 1 , 3 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 ) , <nl> + row ( 2 , 2 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 3 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) = token ( ? ) AND a = ? ; " , 2 , 3 ) ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) AND token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) , <nl> + row ( 2 , 2 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) AND token ( a ) < token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testMultiColumnPartitionKeyWithTokenNonTokenRestrictionsMix ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int , b int , c int , primary key ( ( a , b ) ) ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 0 , 0 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 1 , 1 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 2 , 2 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 0 , 3 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 1 , 4 ) ; " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) ; " , 0 , 0 ) , <nl> + row ( 0 , 1 , 1 ) , <nl> + row ( 0 , 2 , 2 ) , <nl> + row ( 1 , 0 , 3 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND a = ? AND b IN ( ? , ? ) ; " , <nl> + 0 , 0 , 1 , 0 , 1 ) , <nl> + row ( 1 , 0 , 3 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a , b ) > token ( ? , ? ) AND b IN ( ? , ? ) ; " , <nl> + 1 , 0 , 0 , 0 , 1 ) , <nl> + row ( 1 , 0 , 3 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND a = ? ; " , <nl> + 0 , 1 , 0 , 0 , 1 ) , <nl> + row ( 1 , 0 , 3 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND token ( a , b ) < token ( ? , ? ) AND a = ? ; " , <nl> + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND token ( a , b ) < = token ( ? , ? ) AND a = ? ; " , <nl> + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > = token ( ? , ? ) AND token ( a , b ) < token ( ? , ? ) AND a = ? ; " , <nl> + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) = token ( ? , ? ) AND a = ? ; " , <nl> + 0 , 1 , 0 , 0 , 1 ) ) ; <nl> + <nl> + assertInvalidMessage ( " Partition key parts : b must be restricted as other parts are " , <nl> + " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND a = ? ; " , 0 , 0 , 1 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testMultiColumnPartitionKeyWithIndexAndTokenNonTokenRestrictionsMix ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int , b int , c int , primary key ( ( a , b ) ) ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( b ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( c ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 0 , 0 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 1 , 1 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 2 , 2 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 0 , 3 ) ; " ) ; <nl> + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 1 , 4 ) ; " ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? ; " , 1 ) , <nl> + row ( 0 , 1 , 1 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND b = ? ; " , 0 , 0 , 1 ) , <nl> + row ( 0 , 1 , 1 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? AND token ( a , b ) > token ( ? , ? ) ; " , 1 , 0 , 0 ) , <nl> + row ( 0 , 1 , 1 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? AND token ( a , b ) > token ( ? , ? ) and c = ? ALLOW FILTERING ; " , 1 , 0 , 0 , 4 ) , <nl> + row ( 1 , 1 , 4 ) ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / AntiEntropyService . java b / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> index 0ded3cd . . 7bdeb20 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> + + + b / src / java / org / apache / cassandra / service / AntiEntropyService . java <nl> @ @ - 259 , 7 + 259 , 7 @ @ public class AntiEntropyService <nl> private transient DecoratedKey lastKey ; <nl> <nl> public final static MerkleTree . RowHash EMPTY _ ROW = new MerkleTree . RowHash ( null , new byte [ 0 ] ) ; <nl> - <nl> + <nl> Validator ( TreeRequest request ) <nl> { <nl> this ( request , <nl> @ @ - 451 , 9 + 451 , 9 @ @ public class AntiEntropyService <nl> * Trigger a validation compaction which will return the tree upon completion . <nl> * / <nl> public void doVerb ( Message message , String id ) <nl> - { <nl> + { <nl> byte [ ] bytes = message . getMessageBody ( ) ; <nl> - <nl> + <nl> DataInputStream buffer = new DataInputStream ( new FastByteArrayInputStream ( bytes ) ) ; <nl> try <nl> { <nl> @ @ - 468 , 7 + 468 , 7 @ @ public class AntiEntropyService <nl> } <nl> catch ( IOException e ) <nl> { <nl> - throw new IOError ( e ) ; <nl> + throw new IOError ( e ) ; <nl> } <nl> } <nl> } <nl> @ @ - 487 , 9 + 487 , 9 @ @ public class AntiEntropyService <nl> 	 FastByteArrayOutputStream bos = new FastByteArrayOutputStream ( ) ; <nl> DataOutputStream dos = new DataOutputStream ( bos ) ; <nl> SERIALIZER . serialize ( validator , dos , Gossiper . instance . getVersion ( validator . request . endpoint ) ) ; <nl> - return new Message ( local , <nl> - StorageService . Verb . TREE _ RESPONSE , <nl> - bos . toByteArray ( ) , <nl> + return new Message ( local , <nl> + StorageService . Verb . TREE _ RESPONSE , <nl> + bos . toByteArray ( ) , <nl> Gossiper . instance . getVersion ( validator . request . endpoint ) ) ; <nl> } <nl> catch ( IOException e ) <nl> @ @ - 519 , 7 + 519 , 7 @ @ public class AntiEntropyService <nl> } <nl> <nl> public void doVerb ( Message message , String id ) <nl> - { <nl> + { <nl> byte [ ] bytes = message . getMessageBody ( ) ; <nl> DataInputStream buffer = new DataInputStream ( new FastByteArrayInputStream ( bytes ) ) ; <nl> <nl> @ @ - 572 , 7 + 572 , 7 @ @ public class AntiEntropyService <nl> { <nl> return Objects . hashCode ( sessionid , endpoint , cf , range ) ; <nl> } <nl> - <nl> + <nl> @ Override <nl> public final boolean equals ( Object o ) <nl> { <nl> @ @ - 582 , 7 + 582 , 7 @ @ public class AntiEntropyService <nl> / / handles nulls properly <nl> return Objects . equal ( sessionid , that . sessionid ) & & Objects . equal ( endpoint , that . endpoint ) & & Objects . equal ( cf , that . cf ) & & Objects . equal ( range , that . range ) ; <nl> } <nl> - <nl> + <nl> @ Override <nl> public String toString ( ) <nl> { <nl> @ @ - 660 , 7 + 660 , 7 @ @ public class AntiEntropyService <nl> if ( endpoints . isEmpty ( ) ) <nl> { <nl> differencingDone . signalAll ( ) ; <nl> - logger . info ( " [ repair # % s ] No neighbors to repair with on range % s : session completed " , getName ( ) , range ) ; <nl> + logger . info ( String . format ( " [ repair # % s ] No neighbors to repair with on range % s : session completed " , getName ( ) , range ) ) ; <nl> return ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8ccc014 . . 9f946a3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Allow mixing token and partition key restrictions ( CASSANDRA - 7016 ) 
 * Support index key / value entries on map collections ( CASSANDRA - 8473 ) 
 * Modernize schema tables ( CASSANDRA - 8261 ) 
 * Support for user - defined aggregation functions ( CASSANDRA - 8053 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / TokenRelation . java b / src / java / org / apache / cassandra / cql3 / TokenRelation . java 
 index d1bd265 . . 5896fae 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / TokenRelation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / TokenRelation . java 
 @ @ - 69 , 7 + 69 , 7 @ @ public final class TokenRelation extends Relation 
 { 
 List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; 
 Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; 
 - return new TokenRestriction . EQ ( columnDefs , term ) ; 
 + return new TokenRestriction . EQ ( cfm . getKeyValidatorAsCType ( ) , columnDefs , term ) ; 
 } 
 
 @ Override 
 @ @ - 86 , 7 + 86 , 7 @ @ public final class TokenRelation extends Relation 
 { 
 List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; 
 Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; 
 - return new TokenRestriction . Slice ( columnDefs , bound , inclusive , term ) ; 
 + return new TokenRestriction . Slice ( cfm . getKeyValidatorAsCType ( ) , columnDefs , bound , inclusive , term ) ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java 
 index f137a77 . . 0107603 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / AbstractPrimaryKeyRestrictions . java 
 @ @ - 17 , 11 + 17 , 23 @ @ 
 * / 
 package org . apache . cassandra . cql3 . restrictions ; 
 
 + import org . apache . cassandra . db . composites . CType ; 
 + 
 / * * 
 * Base class for < code > PrimaryKeyRestrictions < / code > . 
 * / 
 abstract class AbstractPrimaryKeyRestrictions extends AbstractRestriction implements PrimaryKeyRestrictions 
 { 
 + / * * 
 + * The composite type . 
 + * / 
 + protected final CType ctype ; 
 + 
 + public AbstractPrimaryKeyRestrictions ( CType ctype ) 
 + { 
 + this . ctype = ctype ; 
 + } 
 + 
 @ Override 
 public final boolean isEmpty ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java 
 index e3b3c4c . . 2d6deeb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / MultiColumnRestriction . java 
 @ @ - 43 , 8 + 43 , 6 @ @ import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidReq 
 
 public abstract class MultiColumnRestriction extends AbstractPrimaryKeyRestrictions 
 { 
 - protected final CType ctype ; 
 - 
 / * * 
 * The columns to which the restriction apply . 
 * / 
 @ @ - 52 , 7 + 50 , 7 @ @ public abstract class MultiColumnRestriction extends AbstractPrimaryKeyRestricti 
 
 public MultiColumnRestriction ( CType ctype , List < ColumnDefinition > columnDefs ) 
 { 
 - this . ctype = ctype ; 
 + super ( ctype ) ; 
 this . columnDefs = columnDefs ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java 
 index 5c8386e . . d2a3885 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / SingleColumnPrimaryKeyRestrictions . java 
 @ @ - 43 , 11 + 43 , 6 @ @ import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; 
 final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestrictions 
 { 
 / * * 
 - * The composite type . 
 - * / 
 - private final CType ctype ; 
 - 
 - / * * 
 * The restrictions . 
 * / 
 private final SingleColumnRestrictions restrictions ; 
 @ @ - 74 , 7 + 69 , 7 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric 
 
 public SingleColumnPrimaryKeyRestrictions ( CType ctype ) 
 { 
 - this . ctype = ctype ; 
 + super ( ctype ) ; 
 this . restrictions = new SingleColumnRestrictions ( ) ; 
 this . eq = true ; 
 } 
 @ @ - 82 , 8 + 77 , 8 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric 
 private SingleColumnPrimaryKeyRestrictions ( SingleColumnPrimaryKeyRestrictions primaryKeyRestrictions , 
 SingleColumnRestriction restriction ) throws InvalidRequestException 
 { 
 + super ( primaryKeyRestrictions . ctype ) ; 
 this . restrictions = primaryKeyRestrictions . restrictions . addRestriction ( restriction ) ; 
 - this . ctype = primaryKeyRestrictions . ctype ; 
 
 if ( ! primaryKeyRestrictions . isEmpty ( ) ) 
 { 
 @ @ - 166 , 9 + 161 , 10 @ @ final class SingleColumnPrimaryKeyRestrictions extends AbstractPrimaryKeyRestric 
 
 if ( restriction . isOnToken ( ) ) 
 { 
 - checkTrue ( isEmpty ( ) , " Columns \ " % s \ " cannot be restricted by both a normal relation and a token relation " , 
 - ( ( TokenRestriction ) restriction ) . getColumnNamesAsString ( ) ) ; 
 - return ( PrimaryKeyRestrictions ) restriction ; 
 + if ( isEmpty ( ) ) 
 + return ( PrimaryKeyRestrictions ) restriction ; 
 + 
 + return new TokenFilter ( this , ( TokenRestriction ) restriction ) ; 
 } 
 
 return new SingleColumnPrimaryKeyRestrictions ( this , ( SingleColumnRestriction ) restriction ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 index 60c7465 . . 598478c 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 @ @ - 259 , 10 + 259 , 9 @ @ public final class StatementRestrictions 
 / / If a component of the partition key is restricted by a relation , all preceding 
 / / components must have a EQ . Only the last partition key component can be in IN relation . 
 if ( partitionKeyRestrictions . isOnToken ( ) ) 
 - { 
 isKeyRange = true ; 
 - } 
 - else if ( hasPartitionKeyUnrestrictedComponents ( ) ) 
 + 
 + if ( hasPartitionKeyUnrestrictedComponents ( ) ) 
 { 
 if ( ! partitionKeyRestrictions . isEmpty ( ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java b / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java 
 new file mode 100644 
 index 0000000 . . 4b5383b 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / TokenFilter . java 
 @ @ - 0 , 0 + 1 , 237 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 . restrictions ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + import com . google . common . collect . BoundType ; 
 + import com . google . common . collect . ImmutableRangeSet ; 
 + import com . google . common . collect . Range ; 
 + import com . google . common . collect . RangeSet ; 
 + 
 + import org . apache . cassandra . cql3 . QueryOptions ; 
 + import org . apache . cassandra . cql3 . statements . Bound ; 
 + import org . apache . cassandra . db . composites . Composite ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . exceptions . InvalidRequestException ; 
 + import org . apache . cassandra . service . StorageService ; 
 + 
 + import static org . apache . cassandra . cql3 . statements . Bound . END ; 
 + import static org . apache . cassandra . cql3 . statements . Bound . START ; 
 + 
 + / * * 
 + * < code > Restriction < / code > decorator used to merge non - token restriction and token restriction on partition keys . 
 + * / 
 + final class TokenFilter extends ForwardingPrimaryKeyRestrictions 
 + { 
 + / * * 
 + * The decorated restriction 
 + * / 
 + private PrimaryKeyRestrictions restrictions ; 
 + 
 + / * * 
 + * The restriction on the token 
 + * / 
 + private TokenRestriction tokenRestriction ; 
 + 
 + / * * 
 + * The partitioner 
 + * / 
 + private static final IPartitioner partitioner = StorageService . getPartitioner ( ) ; 
 + 
 + @ Override 
 + protected PrimaryKeyRestrictions getDelegate ( ) 
 + { 
 + return restrictions ; 
 + } 
 + 
 + @ Override 
 + public boolean isOnToken ( ) 
 + { 
 + / / if all partition key columns have non - token restrictions , we can simply use the token range to filter 
 + / / those restrictions and then ignore the token range 
 + return restrictions . size ( ) < tokenRestriction . size ( ) ; 
 + } 
 + 
 + public TokenFilter ( PrimaryKeyRestrictions restrictions , TokenRestriction tokenRestriction ) 
 + { 
 + this . restrictions = restrictions ; 
 + this . tokenRestriction = tokenRestriction ; 
 + } 
 + 
 + @ Override 
 + public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException 
 + { 
 + return filter ( restrictions . values ( options ) , options ) ; 
 + } 
 + 
 + @ Override 
 + public List < Composite > valuesAsComposites ( QueryOptions options ) throws InvalidRequestException 
 + { 
 + throw new UnsupportedOperationException ( ) ; 
 + } 
 + 
 + @ Override 
 + public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException 
 + { 
 + if ( restriction . isOnToken ( ) ) 
 + return new TokenFilter ( restrictions , ( TokenRestriction ) tokenRestriction . mergeWith ( restriction ) ) ; 
 + 
 + return new TokenFilter ( super . mergeWith ( restriction ) , tokenRestriction ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isInclusive ( Bound bound ) 
 + { 
 + return tokenRestriction . isInclusive ( bound ) ; 
 + } 
 + 
 + @ Override 
 + public boolean hasBound ( Bound b ) 
 + { 
 + return tokenRestriction . hasBound ( b ) ; 
 + } 
 + 
 + @ Override 
 + public List < ByteBuffer > bounds ( Bound bound , QueryOptions options ) throws InvalidRequestException 
 + { 
 + return tokenRestriction . bounds ( bound , options ) ; 
 + } 
 + 
 + @ Override 
 + public List < Composite > boundsAsComposites ( Bound bound , QueryOptions options ) throws InvalidRequestException 
 + { 
 + return tokenRestriction . boundsAsComposites ( bound , options ) ; 
 + } 
 + 
 + / * * 
 + * Filter the values returned by the restriction . 
 + * 
 + * @ param values the values returned by the decorated restriction 
 + * @ param options the query options 
 + * @ return the values matching the token restriction 
 + * @ throws InvalidRequestException if the request is invalid 
 + * / 
 + private List < ByteBuffer > filter ( List < ByteBuffer > values , QueryOptions options ) throws InvalidRequestException 
 + { 
 + RangeSet < Token > rangeSet = tokenRestriction . isSlice ( ) ? toRangeSet ( tokenRestriction , options ) 
 + : toRangeSet ( tokenRestriction . values ( options ) ) ; 
 + 
 + return filterWithRangeSet ( rangeSet , values ) ; 
 + } 
 + 
 + / * * 
 + * Filter out the values for which the tokens are not included within the specified range . 
 + * 
 + * @ param tokens the tokens range 
 + * @ param values the restricted values 
 + * @ return the values for which the tokens are not included within the specified range . 
 + * / 
 + private static List < ByteBuffer > filterWithRangeSet ( RangeSet < Token > tokens , List < ByteBuffer > values ) 
 + { 
 + List < ByteBuffer > remaining = new ArrayList < > ( ) ; 
 + 
 + for ( ByteBuffer value : values ) 
 + { 
 + Token token = partitioner . getToken ( value ) ; 
 + 
 + if ( ! tokens . contains ( token ) ) 
 + continue ; 
 + 
 + remaining . add ( value ) ; 
 + } 
 + return remaining ; 
 + } 
 + 
 + / * * 
 + * Converts the specified list into a range set . 
 + * 
 + * @ param buffers the token restriction values 
 + * @ return the range set corresponding to the specified list 
 + * / 
 + private static RangeSet < Token > toRangeSet ( List < ByteBuffer > buffers ) 
 + { 
 + ImmutableRangeSet . Builder < Token > builder = ImmutableRangeSet . builder ( ) ; 
 + 
 + for ( ByteBuffer buffer : buffers ) 
 + builder . add ( Range . singleton ( deserializeToken ( buffer ) ) ) ; 
 + 
 + return builder . build ( ) ; 
 + } 
 + 
 + / * * 
 + * Converts the specified slice into a range set . 
 + * 
 + * @ param slice the slice to convert 
 + * @ param options the query option 
 + * @ return the range set corresponding to the specified slice 
 + * @ throws InvalidRequestException if the request is invalid 
 + * / 
 + private static RangeSet < Token > toRangeSet ( TokenRestriction slice , QueryOptions options ) throws InvalidRequestException 
 + { 
 + if ( slice . hasBound ( START ) ) 
 + { 
 + Token start = deserializeToken ( slice . bounds ( START , options ) . get ( 0 ) ) ; 
 + 
 + BoundType startBoundType = toBoundType ( slice . isInclusive ( START ) ) ; 
 + BoundType endBoundType = toBoundType ( slice . isInclusive ( END ) ) ; 
 + 
 + if ( slice . hasBound ( END ) ) 
 + { 
 + Token end = deserializeToken ( slice . bounds ( END , options ) . get ( 0 ) ) ; 
 + 
 + if ( start . equals ( end ) & & ( BoundType . OPEN = = startBoundType | | BoundType . OPEN = = endBoundType ) ) 
 + return ImmutableRangeSet . of ( ) ; 
 + 
 + if ( start . compareTo ( end ) < = 0 ) 
 + return ImmutableRangeSet . of ( Range . range ( start , 
 + startBoundType , 
 + end , 
 + endBoundType ) ) ; 
 + 
 + return ImmutableRangeSet . < Token > builder ( ) 
 + . add ( Range . upTo ( end , endBoundType ) ) 
 + . add ( Range . downTo ( start , startBoundType ) ) 
 + . build ( ) ; 
 + } 
 + return ImmutableRangeSet . of ( Range . downTo ( start , 
 + startBoundType ) ) ; 
 + } 
 + Token end = deserializeToken ( slice . bounds ( END , options ) . get ( 0 ) ) ; 
 + return ImmutableRangeSet . of ( Range . upTo ( end , toBoundType ( slice . isInclusive ( END ) ) ) ) ; 
 + } 
 + 
 + / * * 
 + * Deserializes the token corresponding to the specified buffer . 
 + * 
 + * @ param buffer the buffer 
 + * @ return the token corresponding to the specified buffer 
 + * / 
 + private static Token deserializeToken ( ByteBuffer buffer ) 
 + { 
 + return partitioner . getTokenFactory ( ) . fromByteArray ( buffer ) ; 
 + } 
 + 
 + private static BoundType toBoundType ( boolean inclusive ) 
 + { 
 + return inclusive ? BoundType . CLOSED : BoundType . OPEN ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java b / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java 
 index 85d614e . . 8d63fea 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / TokenRestriction . java 
 @ @ - 29 , 6 + 29 , 7 @ @ import org . apache . cassandra . cql3 . QueryOptions ; 
 import org . apache . cassandra . cql3 . Term ; 
 import org . apache . cassandra . cql3 . statements . Bound ; 
 import org . apache . cassandra . db . IndexExpression ; 
 + import org . apache . cassandra . db . composites . CType ; 
 import org . apache . cassandra . db . composites . Composite ; 
 import org . apache . cassandra . db . index . SecondaryIndexManager ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 @ @ - 48 , 10 + 49 , 12 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 / * * 
 * Creates a new < code > TokenRestriction < / code > that apply to the specified columns . 
 * 
 + * @ param ctype the composite type 
 * @ param columnDefs the definition of the columns to which apply the token restriction 
 * / 
 - public TokenRestriction ( List < ColumnDefinition > columnDefs ) 
 + public TokenRestriction ( CType ctype , List < ColumnDefinition > columnDefs ) 
 { 
 + super ( ctype ) ; 
 this . columnDefs = columnDefs ; 
 } 
 
 @ @ - 101 , 13 + 104 , 43 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 return Joiner . on ( " , " ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ; 
 } 
 
 + @ Override 
 + public final PrimaryKeyRestrictions mergeWith ( Restriction otherRestriction ) throws InvalidRequestException 
 + { 
 + if ( ! otherRestriction . isOnToken ( ) ) 
 + return new TokenFilter ( toPrimaryKeyRestriction ( otherRestriction ) , this ) ; 
 + 
 + return doMergeWith ( ( TokenRestriction ) otherRestriction ) ; 
 + } 
 + 
 + / * * 
 + * Merges this restriction with the specified < code > TokenRestriction < / code > . 
 + * @ param otherRestriction the < code > TokenRestriction < / code > to merge with . 
 + * / 
 + protected abstract PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException ; 
 + 
 + / * * 
 + * Converts the specified restriction into a < code > PrimaryKeyRestrictions < / code > . 
 + * 
 + * @ param restriction the restriction to convert 
 + * @ return a < code > PrimaryKeyRestrictions < / code > 
 + * @ throws InvalidRequestException if a problem occurs while converting the restriction 
 + * / 
 + private PrimaryKeyRestrictions toPrimaryKeyRestriction ( Restriction restriction ) throws InvalidRequestException 
 + { 
 + if ( restriction instanceof PrimaryKeyRestrictions ) 
 + return ( PrimaryKeyRestrictions ) restriction ; 
 + 
 + return new SingleColumnPrimaryKeyRestrictions ( ctype ) . mergeWith ( restriction ) ; 
 + } 
 + 
 public static final class EQ extends TokenRestriction 
 { 
 private final Term value ; 
 
 - public EQ ( List < ColumnDefinition > columnDefs , Term value ) 
 + public EQ ( CType ctype , List < ColumnDefinition > columnDefs , Term value ) 
 { 
 - super ( columnDefs ) ; 
 + super ( ctype , columnDefs ) ; 
 this . value = value ; 
 } 
 
 @ @ - 124 , 7 + 157 , 7 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 } 
 
 @ Override 
 - public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException 
 + protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException 
 { 
 throw invalidRequest ( " % s cannot be restricted by more than one relation if it includes an Equal " , 
 Joiner . on ( " , " ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ) ; 
 @ @ - 141 , 9 + 174 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 { 
 private final TermSlice slice ; 
 
 - public Slice ( List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) 
 + public Slice ( CType ctype , List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) 
 { 
 - super ( columnDefs ) ; 
 + super ( ctype , columnDefs ) ; 
 slice = TermSlice . newInstance ( bound , inclusive , term ) ; 
 } 
 
 @ @ - 185 , 13 + 218 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 } 
 
 @ Override 
 - public PrimaryKeyRestrictions mergeWith ( Restriction otherRestriction ) 
 + protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) 
 throws InvalidRequestException 
 { 
 - if ( ! otherRestriction . isOnToken ( ) ) 
 - throw invalidRequest ( " Columns \ " % s \ " cannot be restricted by both a normal relation and a token relation " , 
 - getColumnNamesAsString ( ) ) ; 
 - 
 if ( ! otherRestriction . isSlice ( ) ) 
 throw invalidRequest ( " Columns \ " % s \ " cannot be restricted by both an equality and an inequality relation " , 
 getColumnNamesAsString ( ) ) ; 
 @ @ - 206 , 7 + 235 , 7 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 throw invalidRequest ( " More than one restriction was found for the end bound on % s " , 
 getColumnNamesAsString ( ) ) ; 
 
 - return new Slice ( columnDefs , slice . merge ( otherSlice . slice ) ) ; 
 + return new Slice ( ctype , columnDefs , slice . merge ( otherSlice . slice ) ) ; 
 } 
 
 @ Override 
 @ @ - 215 , 9 + 244 , 9 @ @ public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions 
 return String . format ( " SLICE % s " , slice ) ; 
 } 
 
 - private Slice ( List < ColumnDefinition > columnDefs , TermSlice slice ) 
 + private Slice ( CType ctype , List < ColumnDefinition > columnDefs , TermSlice slice ) 
 { 
 - super ( columnDefs ) ; 
 + super ( ctype , columnDefs ) ; 
 this . slice = slice ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java b / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java 
 index 39b62e3 . . a365c09 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / SelectWithTokenFunctionTest . java 
 @ @ - 17 , 6 + 17 , 8 @ @ 
 * / 
 package org . apache . cassandra . cql3 ; 
 
 + import java . util . Arrays ; 
 + 
 import org . junit . Test ; 
 
 public class SelectWithTokenFunctionTest extends CQLTester 
 @ @ - 30 , 10 + 32 , 6 @ @ public class SelectWithTokenFunctionTest extends CQLTester 
 assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) " , 0 ) , row ( 0 , " a " ) ) ; 
 assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) and token ( a ) < token ( ? ) " , 0 , 1 ) , row ( 0 , " a " ) ) ; 
 assertInvalid ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) " , " a " ) ; 
 - assertInvalidMessage ( " Columns \ " a \ " cannot be restricted by both a normal relation and a token relation " , 
 - " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? " , 1 , 1 ) ; 
 - assertInvalidMessage ( " Columns \ " a \ " cannot be restricted by both a normal relation and a token relation " , 
 - " SELECT * FROM % s WHERE a = ? and token ( a ) > token ( ? ) " , 1 , 1 ) ; 
 assertInvalidMessage ( " The token ( ) function must contains only partition key components " , 
 " SELECT * FROM % s WHERE token ( a , b ) > = token ( ? , ? ) " , " b " , 0 ) ; 
 assertInvalidMessage ( " More than one restriction was found for the start bound on a " , 
 @ @ - 88 , 4 + 86 , 137 @ @ public class SelectWithTokenFunctionTest extends CQLTester 
 assertInvalidMessage ( " The token ( ) function must be applied to all partition key components or none of them " , 
 " SELECT * FROM % s WHERE token ( a ) > token ( ? , ? ) and token ( b ) > token ( ? , ? ) " , 0 , " a " , 0 , " a " ) ; 
 } 
 + 
 + @ Test 
 + public void testSingleColumnPartitionKeyWithTokenNonTokenRestrictionsMix ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int primary key , b int ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 0 , 0 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 1 , 1 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 2 , 2 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 3 , 3 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b ) VALUES ( 4 , 4 ) ; " ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) ; " , 1 , 3 ) , 
 + row ( 1 , 1 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) and token ( a ) < = token ( ? ) ; " , 1 , 3 ) , 
 + row ( 2 , 2 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) = token ( 2 ) ; " ) , 
 + row ( 2 , 2 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a IN ( ? , ? ) ; " , 
 + 1 , 3 , 1 , 3 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) < token ( ? ) AND token ( a ) > = token ( ? ) AND a IN ( ? , ? ) ; " , 
 + 1 , 3 , 1 , 3 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertInvalidMessage ( " Only EQ and IN relation are supported on the partition key ( unless you use the token ( ) function ) " , 
 + " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a > ? ; " , 1 , 3 , 1 ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a IN ? ; " , 
 + 1 , 3 , Arrays . asList ( 1 , 3 ) ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? ; " , 1 , 3 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a ) > token ( ? ) ; " , 3 , 1 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a = ? ; " , 3 , 1 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a ) > token ( ? ) ; " , 1 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a IN ( ? , ? ) ; " , 2 , 1 , 3 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) AND a IN ( ? , ? ) ; " , 2 , 5 , 1 , 3 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) AND token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) ; " , 1 , 3 , 2 , 5 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND a IN ( ? , ? ) AND token ( a ) < token ( ? ) ; " , 2 , 1 , 3 , 5 ) , 
 + row ( 3 , 3 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE a IN ( ? , ? ) AND token ( a ) > token ( ? ) ; " , 1 , 3 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 ) , 
 + row ( 2 , 2 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 3 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) = token ( ? ) AND a = ? ; " , 2 , 3 ) ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) AND token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) , 
 + row ( 2 , 2 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > = token ( ? ) AND token ( a ) < token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < = token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE token ( a ) > token ( ? ) AND token ( a ) < token ( ? ) AND a = ? ; " , 2 , 2 , 2 ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testMultiColumnPartitionKeyWithTokenNonTokenRestrictionsMix ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int , b int , c int , primary key ( ( a , b ) ) ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 0 , 0 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 1 , 1 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 2 , 2 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 0 , 3 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 1 , 4 ) ; " ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) ; " , 0 , 0 ) , 
 + row ( 0 , 1 , 1 ) , 
 + row ( 0 , 2 , 2 ) , 
 + row ( 1 , 0 , 3 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND a = ? AND b IN ( ? , ? ) ; " , 
 + 0 , 0 , 1 , 0 , 1 ) , 
 + row ( 1 , 0 , 3 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE a = ? AND token ( a , b ) > token ( ? , ? ) AND b IN ( ? , ? ) ; " , 
 + 1 , 0 , 0 , 0 , 1 ) , 
 + row ( 1 , 0 , 3 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND a = ? ; " , 
 + 0 , 1 , 0 , 0 , 1 ) , 
 + row ( 1 , 0 , 3 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND token ( a , b ) < token ( ? , ? ) AND a = ? ; " , 
 + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > token ( ? , ? ) AND token ( a , b ) < = token ( ? , ? ) AND a = ? ; " , 
 + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) > = token ( ? , ? ) AND token ( a , b ) < token ( ? , ? ) AND a = ? ; " , 
 + 0 , 1 , 0 , 0 , 0 , 0 , 1 ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE b IN ( ? , ? ) AND token ( a , b ) = token ( ? , ? ) AND a = ? ; " , 
 + 0 , 1 , 0 , 0 , 1 ) ) ; 
 + 
 + assertInvalidMessage ( " Partition key parts : b must be restricted as other parts are " , 
 + " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND a = ? ; " , 0 , 0 , 1 ) ; 
 + } 
 + 
 + @ Test 
 + public void testMultiColumnPartitionKeyWithIndexAndTokenNonTokenRestrictionsMix ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int , b int , c int , primary key ( ( a , b ) ) ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( b ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( c ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 0 , 0 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 1 , 1 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 0 , 2 , 2 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 0 , 3 ) ; " ) ; 
 + execute ( " INSERT INTO % s ( a , b , c ) VALUES ( 1 , 1 , 4 ) ; " ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? ; " , 1 ) , 
 + row ( 0 , 1 , 1 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE token ( a , b ) > token ( ? , ? ) AND b = ? ; " , 0 , 0 , 1 ) , 
 + row ( 0 , 1 , 1 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? AND token ( a , b ) > token ( ? , ? ) ; " , 1 , 0 , 0 ) , 
 + row ( 0 , 1 , 1 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE b = ? AND token ( a , b ) > token ( ? , ? ) and c = ? ALLOW FILTERING ; " , 1 , 0 , 0 , 4 ) , 
 + row ( 1 , 1 , 4 ) ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / AntiEntropyService . java b / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 index 0ded3cd . . 7bdeb20 100644 
 - - - a / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 + + + b / src / java / org / apache / cassandra / service / AntiEntropyService . java 
 @ @ - 259 , 7 + 259 , 7 @ @ public class AntiEntropyService 
 private transient DecoratedKey lastKey ; 
 
 public final static MerkleTree . RowHash EMPTY _ ROW = new MerkleTree . RowHash ( null , new byte [ 0 ] ) ; 
 - 
 + 
 Validator ( TreeRequest request ) 
 { 
 this ( request , 
 @ @ - 451 , 9 + 451 , 9 @ @ public class AntiEntropyService 
 * Trigger a validation compaction which will return the tree upon completion . 
 * / 
 public void doVerb ( Message message , String id ) 
 - { 
 + { 
 byte [ ] bytes = message . getMessageBody ( ) ; 
 - 
 + 
 DataInputStream buffer = new DataInputStream ( new FastByteArrayInputStream ( bytes ) ) ; 
 try 
 { 
 @ @ - 468 , 7 + 468 , 7 @ @ public class AntiEntropyService 
 } 
 catch ( IOException e ) 
 { 
 - throw new IOError ( e ) ; 
 + throw new IOError ( e ) ; 
 } 
 } 
 } 
 @ @ - 487 , 9 + 487 , 9 @ @ public class AntiEntropyService 
 	 FastByteArrayOutputStream bos = new FastByteArrayOutputStream ( ) ; 
 DataOutputStream dos = new DataOutputStream ( bos ) ; 
 SERIALIZER . serialize ( validator , dos , Gossiper . instance . getVersion ( validator . request . endpoint ) ) ; 
 - return new Message ( local , 
 - StorageService . Verb . TREE _ RESPONSE , 
 - bos . toByteArray ( ) , 
 + return new Message ( local , 
 + StorageService . Verb . TREE _ RESPONSE , 
 + bos . toByteArray ( ) , 
 Gossiper . instance . getVersion ( validator . request . endpoint ) ) ; 
 } 
 catch ( IOException e ) 
 @ @ - 519 , 7 + 519 , 7 @ @ public class AntiEntropyService 
 } 
 
 public void doVerb ( Message message , String id ) 
 - { 
 + { 
 byte [ ] bytes = message . getMessageBody ( ) ; 
 DataInputStream buffer = new DataInputStream ( new FastByteArrayInputStream ( bytes ) ) ; 
 
 @ @ - 572 , 7 + 572 , 7 @ @ public class AntiEntropyService 
 { 
 return Objects . hashCode ( sessionid , endpoint , cf , range ) ; 
 } 
 - 
 + 
 @ Override 
 public final boolean equals ( Object o ) 
 { 
 @ @ - 582 , 7 + 582 , 7 @ @ public class AntiEntropyService 
 / / handles nulls properly 
 return Objects . equal ( sessionid , that . sessionid ) & & Objects . equal ( endpoint , that . endpoint ) & & Objects . equal ( cf , that . cf ) & & Objects . equal ( range , that . range ) ; 
 } 
 - 
 + 
 @ Override 
 public String toString ( ) 
 { 
 @ @ - 660 , 7 + 660 , 7 @ @ public class AntiEntropyService 
 if ( endpoints . isEmpty ( ) ) 
 { 
 differencingDone . signalAll ( ) ; 
 - logger . info ( " [ repair # % s ] No neighbors to repair with on range % s : session completed " , getName ( ) , range ) ; 
 + logger . info ( String . format ( " [ repair # % s ] No neighbors to repair with on range % s : session completed " , getName ( ) , range ) ) ; 
 return ; 
 } 

