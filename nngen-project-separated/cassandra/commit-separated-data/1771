BLEU SCORE: 0.037477767366779206

TEST MSG: Check for overlap with non - early opened files in LCS
GENERATED MSG: LCS will merge up to 32 L0 sstables as intended

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 25b0a06 . . 924bdcf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 4 <nl> + * Check for overlap with non - early sstables in LCS ( CASSANDRA - 8739 ) <nl> * Only calculate max purgable timestamp if we have to ( CASSANDRA - 8914 ) <nl> * ( cqlsh ) Greatly improve performance of COPY FROM ( CASSANDRA - 8225 ) <nl> * IndexSummary effectiveIndexInterval is now a guideline , not a rule ( CASSANDRA - 8993 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index c076a64 . . ecebfe0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 534 , 7 + 534 , 7 @ @ public class LeveledManifest <nl> <nl> if ( level = = 0 ) <nl> { <nl> - Set < SSTableReader > compactingL0 = ImmutableSet . copyOf ( Iterables . filter ( getLevel ( 0 ) , Predicates . in ( compacting ) ) ) ; <nl> + Set < SSTableReader > compactingL0 = getCompacting ( 0 ) ; <nl> <nl> RowPosition lastCompactingKey = null ; <nl> RowPosition firstCompactingKey = null ; <nl> @ @ - 595 , 6 + 595 , 8 @ @ public class LeveledManifest <nl> Set < SSTableReader > l1overlapping = overlapping ( candidates , getLevel ( 1 ) ) ; <nl> if ( Sets . intersection ( l1overlapping , compacting ) . size ( ) > 0 ) <nl> return Collections . emptyList ( ) ; <nl> + if ( ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) <nl> + return Collections . emptyList ( ) ; <nl> candidates = Sets . union ( candidates , l1overlapping ) ; <nl> } <nl> if ( candidates . size ( ) < 2 ) <nl> @ @ - 632 , 6 + 634 , 18 @ @ public class LeveledManifest <nl> return Collections . emptyList ( ) ; <nl> } <nl> <nl> + private Set < SSTableReader > getCompacting ( int level ) <nl> + { <nl> + Set < SSTableReader > sstables = new HashSet < > ( ) ; <nl> + Set < SSTableReader > levelSSTables = new HashSet < > ( getLevel ( level ) ) ; <nl> + for ( SSTableReader sstable : cfs . getDataTracker ( ) . getCompacting ( ) ) <nl> + { <nl> + if ( levelSSTables . contains ( sstable ) ) <nl> + sstables . add ( sstable ) ; <nl> + } <nl> + return sstables ; <nl> + } <nl> + <nl> private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) <nl> { <nl> List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fd58882 . . 41b29fa 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 96 , 6 + 96 , 7 @ @ <nl> <nl> <nl> 1 . 1 . 6 <nl> + * LCS will merge up to 32 L0 sstables as intended ( CASSANDRA - 4778 ) <nl> * NTS will default unconfigured DC replicas to zero ( CASSANDRA - 4675 ) <nl> * use default consistency level in counter validation if none is <nl> explicitly provide ( CASSANDRA - 4700 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> index b7c728f . . 380bebf 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java <nl> @ @ - 54 , 7 + 54 , 7 @ @ public class LeveledManifest <nl> * uses a pessimistic estimate of how many keys overlap ( none ) , so we risk wasting memory <nl> * or even OOMing when compacting highly overlapping sstables <nl> * / <nl> - static final int MAX _ COMPACTING _ L0 = 32 ; <nl> + private static final int MAX _ COMPACTING _ L0 = 32 ; <nl> <nl> private final ColumnFamilyStore cfs ; <nl> private final List < SSTableReader > [ ] generations ; <nl> @ @ - 472 , 22 + 472 , 16 @ @ public class LeveledManifest <nl> List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ; <nl> Collections . sort ( ageSortedCandidates , SSTable . maxTimestampComparator ) ; <nl> candidates = new HashSet < SSTableReader > ( ageSortedCandidates . subList ( 0 , MAX _ COMPACTING _ L0 ) ) ; <nl> - if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) <nl> - { <nl> - / / add sstables from L1 that overlap candidates <nl> - candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; <nl> - } <nl> - return candidates ; <nl> - } <nl> - <nl> - if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) <nl> - { <nl> - / / add sstables from L1 that overlap candidates <nl> - candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; <nl> break ; <nl> } <nl> } <nl> <nl> + if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) <nl> + { <nl> + / / add sstables from L1 that overlap candidates <nl> + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; <nl> + } <nl> + <nl> return candidates ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 25b0a06 . . 924bdcf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 4 
 + * Check for overlap with non - early sstables in LCS ( CASSANDRA - 8739 ) 
 * Only calculate max purgable timestamp if we have to ( CASSANDRA - 8914 ) 
 * ( cqlsh ) Greatly improve performance of COPY FROM ( CASSANDRA - 8225 ) 
 * IndexSummary effectiveIndexInterval is now a guideline , not a rule ( CASSANDRA - 8993 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index c076a64 . . ecebfe0 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 534 , 7 + 534 , 7 @ @ public class LeveledManifest 
 
 if ( level = = 0 ) 
 { 
 - Set < SSTableReader > compactingL0 = ImmutableSet . copyOf ( Iterables . filter ( getLevel ( 0 ) , Predicates . in ( compacting ) ) ) ; 
 + Set < SSTableReader > compactingL0 = getCompacting ( 0 ) ; 
 
 RowPosition lastCompactingKey = null ; 
 RowPosition firstCompactingKey = null ; 
 @ @ - 595 , 6 + 595 , 8 @ @ public class LeveledManifest 
 Set < SSTableReader > l1overlapping = overlapping ( candidates , getLevel ( 1 ) ) ; 
 if ( Sets . intersection ( l1overlapping , compacting ) . size ( ) > 0 ) 
 return Collections . emptyList ( ) ; 
 + if ( ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) 
 + return Collections . emptyList ( ) ; 
 candidates = Sets . union ( candidates , l1overlapping ) ; 
 } 
 if ( candidates . size ( ) < 2 ) 
 @ @ - 632 , 6 + 634 , 18 @ @ public class LeveledManifest 
 return Collections . emptyList ( ) ; 
 } 
 
 + private Set < SSTableReader > getCompacting ( int level ) 
 + { 
 + Set < SSTableReader > sstables = new HashSet < > ( ) ; 
 + Set < SSTableReader > levelSSTables = new HashSet < > ( getLevel ( level ) ) ; 
 + for ( SSTableReader sstable : cfs . getDataTracker ( ) . getCompacting ( ) ) 
 + { 
 + if ( levelSSTables . contains ( sstable ) ) 
 + sstables . add ( sstable ) ; 
 + } 
 + return sstables ; 
 + } 
 + 
 private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) 
 { 
 List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fd58882 . . 41b29fa 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 96 , 6 + 96 , 7 @ @ 
 
 
 1 . 1 . 6 
 + * LCS will merge up to 32 L0 sstables as intended ( CASSANDRA - 4778 ) 
 * NTS will default unconfigured DC replicas to zero ( CASSANDRA - 4675 ) 
 * use default consistency level in counter validation if none is 
 explicitly provide ( CASSANDRA - 4700 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 index b7c728f . . 380bebf 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / LeveledManifest . java 
 @ @ - 54 , 7 + 54 , 7 @ @ public class LeveledManifest 
 * uses a pessimistic estimate of how many keys overlap ( none ) , so we risk wasting memory 
 * or even OOMing when compacting highly overlapping sstables 
 * / 
 - static final int MAX _ COMPACTING _ L0 = 32 ; 
 + private static final int MAX _ COMPACTING _ L0 = 32 ; 
 
 private final ColumnFamilyStore cfs ; 
 private final List < SSTableReader > [ ] generations ; 
 @ @ - 472 , 22 + 472 , 16 @ @ public class LeveledManifest 
 List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ; 
 Collections . sort ( ageSortedCandidates , SSTable . maxTimestampComparator ) ; 
 candidates = new HashSet < SSTableReader > ( ageSortedCandidates . subList ( 0 , MAX _ COMPACTING _ L0 ) ) ; 
 - if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) 
 - { 
 - / / add sstables from L1 that overlap candidates 
 - candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; 
 - } 
 - return candidates ; 
 - } 
 - 
 - if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) 
 - { 
 - / / add sstables from L1 that overlap candidates 
 - candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; 
 break ; 
 } 
 } 
 
 + if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) 
 + { 
 + / / add sstables from L1 that overlap candidates 
 + candidates . addAll ( overlapping ( candidates , generations [ 1 ] ) ) ; 
 + } 
 + 
 return candidates ; 
 } 

