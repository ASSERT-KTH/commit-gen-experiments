BLEU SCORE: 0.04935157841536379

TEST MSG: Fix regression in select count with limit
GENERATED MSG: ( cql3 ) Fix queries using LIMIT missing results

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index efae4ab . . 0714076 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 3 + 1 , 5 @ @ <nl> + 2 . 2 . 4 <nl> + * Fix the regression when using LIMIT with aggregates ( CASSANDRA - 10487 ) <nl> 2 . 2 . 3 <nl> * Avoid NoClassDefFoundError during DataDescriptor initialization on windows ( CASSANDRA - 10412 ) <nl> * Preserve case of quoted Role & User names ( CASSANDRA - 10394 ) <nl> @ @ - 8 , 7 + 10 , 6 @ @ Merged from 2 . 1 : <nl> * Allow LOCAL _ JMX to be easily overridden ( CASSANDRA - 10275 ) <nl> * Mark nodes as dead even if they ' ve already left ( CASSANDRA - 10205 ) <nl> * Update internal python driver used by cqlsh ( CASSANDRA - 10161 ) <nl> - <nl> 2 . 2 . 2 <nl> * cqlsh prompt includes name of keyspace after failed ` use ` statement ( CASSANDRA - 10369 ) <nl> * Configurable page size in cqlsh ( CASSANDRA - 9855 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 69f2412 . . 5808cdf 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 75 , 6 + 75 , 9 @ @ New features <nl> <nl> New features <nl> - - - - - - - - - - - - <nl> + - The LIMIT clause applies now only to the number of rows returned to the user , <nl> + not to the number of row queried . By consequence , queries using aggregates will not <nl> + be impacted by the LIMIT clause anymore . <nl> - Very large batches will now be rejected ( defaults to 50kb ) . This <nl> can be customized by modifying batch _ size _ fail _ threshold _ in _ kb . <nl> - Selecting columns , scalar functions , UDT fields , writetime or ttl together <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 3edb7d0 . . e6ac6c0 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 536 , 6 + 536 , 10 @ @ public class SelectStatement implements CQLStatement <nl> <nl> private int updateLimitForQuery ( int limit ) <nl> { <nl> + / / If the query is for an aggregate , we do not want to limit the number of rows retrieved . The LIMIT <nl> + / / clause apply to the number of rows returned to the user and not to the number of rows retrieved . <nl> + if ( selection . isAggregate ( ) ) <nl> + return Integer . MAX _ VALUE ; <nl> / / Internally , we don ' t support exclusive bounds for slices . Instead , we query one more element if necessary <nl> / / and exclude it later ( in processColumnFamily ) <nl> return restrictions . isNonCompositeSliceWithExclusiveBounds ( ) & & limit ! = Integer . MAX _ VALUE <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> index b2ecd04 . . 1649654 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java <nl> @ @ - 90 , 6 + 90 , 10 @ @ public class AggregationTest extends CQLTester <nl> assertRows ( execute ( " SELECT COUNT ( * ) FROM % s " ) , row ( 4L ) ) ; <nl> assertRows ( execute ( " SELECT COUNT ( 1 ) FROM % s " ) , row ( 4L ) ) ; <nl> assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s " ) , row ( 4L , 3L , 3L , 3L ) ) ; <nl> + / / Makes sure that LIMIT does not affect the result of aggregates <nl> + assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s LIMIT 2 " ) , row ( 4L , 3L , 3L , 3L ) ) ; <nl> + assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s WHERE a = 1 LIMIT 2 " ) , <nl> + row ( 4L , 3L , 3L , 3L ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 129 , 6 + 133 , 9 @ @ public class AggregationTest extends CQLTester <nl> assertRows ( execute ( " SELECT COUNT ( 1 ) FROM % s " ) , row ( 4L ) ) ; <nl> assertRows ( execute ( " SELECT max ( b ) , b , COUNT ( * ) FROM % s " ) , row ( 5 , 1 , 4L ) ) ; <nl> assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s " ) , row ( 5 , 4L , 1 ) ) ; <nl> + / / Makes sure that LIMIT does not affect the result of aggregates <nl> + assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s LIMIT 2 " ) , row ( 5 , 4L , 1 ) ) ; <nl> + assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s WHERE a = 1 LIMIT 2 " ) , row ( 5 , 4L , 1 ) ) ; <nl> } <nl> <nl> @ Test
NEAREST DIFF (one line): diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index 42a77cc . . 43b1e53 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 434 , 6 + 434 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> tempcurs . execute ( ' USE % s ; ' % self . cql _ protect _ name ( keyspace ) ) <nl> tempcurs . close ( ) <nl> self . cursor = self . conn . cursor ( ) <nl> + self . get _ connection _ versions ( ) <nl> <nl> self . current _ keyspace = keyspace <nl> <nl> @ @ - 470 , 6 + 471 , 9 @ @ class Shell ( cmd . Cmd ) : <nl> def cqlver _ atleast ( self , major , minor = 0 , patch = 0 ) : <nl> return self . cql _ ver _ tuple [ : 3 ] > = ( major , minor , patch ) <nl> <nl> + def cassandraver _ atleast ( self , major , minor = 0 , patch = 0 ) : <nl> + return self . cass _ ver _ tuple [ : 3 ] > = ( major , minor , patch ) <nl> + <nl> def myformat _ value ( self , val , casstype , * * kwargs ) : <nl> if isinstance ( val , DecodeError ) : <nl> self . decoding _ errors . append ( val ) <nl> @ @ - 491 , 7 + 495 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> self . port ) <nl> <nl> def show _ version ( self ) : <nl> - vers = self . get _ cluster _ versions ( ) <nl> + vers = self . connection _ versions . copy ( ) <nl> vers [ ' shver ' ] = version <nl> # system . Versions [ ' cql ' ] apparently does not reflect changes with <nl> # set _ cql _ version . <nl> @ @ - 524 , 7 + 528 , 22 @ @ class Shell ( cmd . Cmd ) : <nl> % ( cf , colname , cql _ typename ( vtype ) ) <nl> print <nl> <nl> - def get _ cluster _ versions ( self ) : <nl> + def get _ connection _ versions ( self ) : <nl> + try : <nl> + self . cursor . execute ( " select * from system . local where key = ' local ' " ) <nl> + except cql . ProgrammingError : <nl> + vers = self . get _ connection _ versions _ fallback ( ) <nl> + else : <nl> + result = self . fetchdict ( ) <nl> + vers = { <nl> + ' build ' : result [ ' release _ version ' ] , <nl> + ' thrift ' : result [ ' thrift _ version ' ] , <nl> + ' cql ' : result [ ' cql _ version ' ] , <nl> + } <nl> + self . connection _ versions = vers <nl> + self . cass _ ver _ tuple = tuple ( map ( int , vers [ ' build ' ] . split ( ' - ' , 1 ) [ 0 ] . split ( ' . ' , 2 ) ) ) <nl> + <nl> + def get _ connection _ versions _ fallback ( self ) : <nl> if self . cqlver _ atleast ( 3 ) : <nl> query = ' select component , version from system . " Versions " ' <nl> else : <nl> @ @ - 660 , 15 + 679 , 21 @ @ class Shell ( cmd . Cmd ) : <nl> def get _ columnfamily _ layout ( self , ksname , cfname ) : <nl> if ksname is None : <nl> ksname = self . current _ keyspace <nl> - self . cursor . execute ( " " " select * from system . schema _ columnfamilies <nl> - where " keyspace " = : ks and " columnfamily " = : cf " " " , <nl> - { ' ks ' : ksname , ' cf ' : cfname } ) <nl> + if self . cassandraver _ atleast ( 1 , 2 ) : <nl> + cf _ q = " " " select * from system . schema _ columnfamilies <nl> + where keyspace _ name = : ks and columnfamily _ name = : cf " " " <nl> + col _ q = " " " select * from system . schema _ columns <nl> + where keyspace _ name = : ks and columnfamily _ name = : cf " " " <nl> + else : <nl> + cf _ q = " " " select * from system . schema _ columnfamilies <nl> + where " keyspace " = : ks and " columnfamily " = : cf " " " <nl> + col _ q = " " " select * from system . schema _ columns <nl> + where " keyspace " = : ks and " columnfamily " = : cf " " " <nl> + self . cursor . execute ( cf _ q , { ' ks ' : ksname , ' cf ' : cfname } ) <nl> layout = self . fetchdict ( ) <nl> if layout is None : <nl> raise ColumnFamilyNotFound ( " Column family % r not found " % cfname ) <nl> - self . cursor . execute ( " " " select * from system . schema _ columns <nl> - where " keyspace " = : ks and " columnfamily " = : cf " " " , <nl> - { ' ks ' : ksname , ' cf ' : cfname } ) <nl> + self . cursor . execute ( col _ q , { ' ks ' : ksname , ' cf ' : cfname } ) <nl> cols = self . fetchdict _ all ( ) <nl> return cql3handling . CqlTableDef . from _ layout ( layout , cols ) <nl> <nl> @ @ - 1544 , 6 + 1569 , 7 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> showwhat = parsed . get _ binding ( ' what ' ) . lower ( ) <nl> if showwhat = = ' version ' : <nl> + self . get _ connection _ versions ( ) <nl> self . show _ version ( ) <nl> elif showwhat = = ' host ' : <nl> self . show _ host ( ) <nl> diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 13ce07a . . f1d7f81 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 692 , 7 + 692 , 11 @ @ class CqlColumnDef : <nl> <nl> @ classmethod <nl> def from _ layout ( cls , layout ) : <nl> - c = cls ( layout [ u ' column ' ] , cql _ typename ( layout [ u ' validator ' ] ) ) <nl> + try : <nl> + colname = layout [ u ' column _ name ' ] <nl> + except KeyError : <nl> + colname = layout [ u ' column ' ] <nl> + c = cls ( colname , cql _ typename ( layout [ u ' validator ' ] ) ) <nl> c . index _ name = layout [ u ' index _ name ' ] <nl> return c <nl> <nl> @ @ - 716 , 7 + 720 , 11 @ @ class CqlTableDef : <nl> <nl> @ classmethod <nl> def from _ layout ( cls , layout , coldefs ) : <nl> - cf = cls ( name = layout [ u ' columnfamily ' ] ) <nl> + try : <nl> + cfname = layout [ u ' columnfamily _ name ' ] <nl> + except KeyError : <nl> + cfname = layout [ u ' columnfamily ' ] <nl> + cf = cls ( name = cfname ) <nl> for attr , val in layout . items ( ) : <nl> setattr ( cf , attr . encode ( ' ascii ' ) , val ) <nl> for attr in cls . json _ attrs :

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index efae4ab . . 0714076 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 3 + 1 , 5 @ @ 
 + 2 . 2 . 4 
 + * Fix the regression when using LIMIT with aggregates ( CASSANDRA - 10487 ) 
 2 . 2 . 3 
 * Avoid NoClassDefFoundError during DataDescriptor initialization on windows ( CASSANDRA - 10412 ) 
 * Preserve case of quoted Role & User names ( CASSANDRA - 10394 ) 
 @ @ - 8 , 7 + 10 , 6 @ @ Merged from 2 . 1 : 
 * Allow LOCAL _ JMX to be easily overridden ( CASSANDRA - 10275 ) 
 * Mark nodes as dead even if they ' ve already left ( CASSANDRA - 10205 ) 
 * Update internal python driver used by cqlsh ( CASSANDRA - 10161 ) 
 - 
 2 . 2 . 2 
 * cqlsh prompt includes name of keyspace after failed ` use ` statement ( CASSANDRA - 10369 ) 
 * Configurable page size in cqlsh ( CASSANDRA - 9855 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 69f2412 . . 5808cdf 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 75 , 6 + 75 , 9 @ @ New features 
 
 New features 
 - - - - - - - - - - - - 
 + - The LIMIT clause applies now only to the number of rows returned to the user , 
 + not to the number of row queried . By consequence , queries using aggregates will not 
 + be impacted by the LIMIT clause anymore . 
 - Very large batches will now be rejected ( defaults to 50kb ) . This 
 can be customized by modifying batch _ size _ fail _ threshold _ in _ kb . 
 - Selecting columns , scalar functions , UDT fields , writetime or ttl together 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 3edb7d0 . . e6ac6c0 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 536 , 6 + 536 , 10 @ @ public class SelectStatement implements CQLStatement 
 
 private int updateLimitForQuery ( int limit ) 
 { 
 + / / If the query is for an aggregate , we do not want to limit the number of rows retrieved . The LIMIT 
 + / / clause apply to the number of rows returned to the user and not to the number of rows retrieved . 
 + if ( selection . isAggregate ( ) ) 
 + return Integer . MAX _ VALUE ; 
 / / Internally , we don ' t support exclusive bounds for slices . Instead , we query one more element if necessary 
 / / and exclude it later ( in processColumnFamily ) 
 return restrictions . isNonCompositeSliceWithExclusiveBounds ( ) & & limit ! = Integer . MAX _ VALUE 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 index b2ecd04 . . 1649654 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AggregationTest . java 
 @ @ - 90 , 6 + 90 , 10 @ @ public class AggregationTest extends CQLTester 
 assertRows ( execute ( " SELECT COUNT ( * ) FROM % s " ) , row ( 4L ) ) ; 
 assertRows ( execute ( " SELECT COUNT ( 1 ) FROM % s " ) , row ( 4L ) ) ; 
 assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s " ) , row ( 4L , 3L , 3L , 3L ) ) ; 
 + / / Makes sure that LIMIT does not affect the result of aggregates 
 + assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s LIMIT 2 " ) , row ( 4L , 3L , 3L , 3L ) ) ; 
 + assertRows ( execute ( " SELECT COUNT ( b ) , count ( c ) , count ( e ) , count ( f ) FROM % s WHERE a = 1 LIMIT 2 " ) , 
 + row ( 4L , 3L , 3L , 3L ) ) ; 
 } 
 
 @ Test 
 @ @ - 129 , 6 + 133 , 9 @ @ public class AggregationTest extends CQLTester 
 assertRows ( execute ( " SELECT COUNT ( 1 ) FROM % s " ) , row ( 4L ) ) ; 
 assertRows ( execute ( " SELECT max ( b ) , b , COUNT ( * ) FROM % s " ) , row ( 5 , 1 , 4L ) ) ; 
 assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s " ) , row ( 5 , 4L , 1 ) ) ; 
 + / / Makes sure that LIMIT does not affect the result of aggregates 
 + assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s LIMIT 2 " ) , row ( 5 , 4L , 1 ) ) ; 
 + assertRows ( execute ( " SELECT max ( b ) , COUNT ( 1 ) , b FROM % s WHERE a = 1 LIMIT 2 " ) , row ( 5 , 4L , 1 ) ) ; 
 } 
 
 @ Test

NEAREST DIFF:
diff - - git a / bin / cqlsh b / bin / cqlsh 
 index 42a77cc . . 43b1e53 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 434 , 6 + 434 , 7 @ @ class Shell ( cmd . Cmd ) : 
 tempcurs . execute ( ' USE % s ; ' % self . cql _ protect _ name ( keyspace ) ) 
 tempcurs . close ( ) 
 self . cursor = self . conn . cursor ( ) 
 + self . get _ connection _ versions ( ) 
 
 self . current _ keyspace = keyspace 
 
 @ @ - 470 , 6 + 471 , 9 @ @ class Shell ( cmd . Cmd ) : 
 def cqlver _ atleast ( self , major , minor = 0 , patch = 0 ) : 
 return self . cql _ ver _ tuple [ : 3 ] > = ( major , minor , patch ) 
 
 + def cassandraver _ atleast ( self , major , minor = 0 , patch = 0 ) : 
 + return self . cass _ ver _ tuple [ : 3 ] > = ( major , minor , patch ) 
 + 
 def myformat _ value ( self , val , casstype , * * kwargs ) : 
 if isinstance ( val , DecodeError ) : 
 self . decoding _ errors . append ( val ) 
 @ @ - 491 , 7 + 495 , 7 @ @ class Shell ( cmd . Cmd ) : 
 self . port ) 
 
 def show _ version ( self ) : 
 - vers = self . get _ cluster _ versions ( ) 
 + vers = self . connection _ versions . copy ( ) 
 vers [ ' shver ' ] = version 
 # system . Versions [ ' cql ' ] apparently does not reflect changes with 
 # set _ cql _ version . 
 @ @ - 524 , 7 + 528 , 22 @ @ class Shell ( cmd . Cmd ) : 
 % ( cf , colname , cql _ typename ( vtype ) ) 
 print 
 
 - def get _ cluster _ versions ( self ) : 
 + def get _ connection _ versions ( self ) : 
 + try : 
 + self . cursor . execute ( " select * from system . local where key = ' local ' " ) 
 + except cql . ProgrammingError : 
 + vers = self . get _ connection _ versions _ fallback ( ) 
 + else : 
 + result = self . fetchdict ( ) 
 + vers = { 
 + ' build ' : result [ ' release _ version ' ] , 
 + ' thrift ' : result [ ' thrift _ version ' ] , 
 + ' cql ' : result [ ' cql _ version ' ] , 
 + } 
 + self . connection _ versions = vers 
 + self . cass _ ver _ tuple = tuple ( map ( int , vers [ ' build ' ] . split ( ' - ' , 1 ) [ 0 ] . split ( ' . ' , 2 ) ) ) 
 + 
 + def get _ connection _ versions _ fallback ( self ) : 
 if self . cqlver _ atleast ( 3 ) : 
 query = ' select component , version from system . " Versions " ' 
 else : 
 @ @ - 660 , 15 + 679 , 21 @ @ class Shell ( cmd . Cmd ) : 
 def get _ columnfamily _ layout ( self , ksname , cfname ) : 
 if ksname is None : 
 ksname = self . current _ keyspace 
 - self . cursor . execute ( " " " select * from system . schema _ columnfamilies 
 - where " keyspace " = : ks and " columnfamily " = : cf " " " , 
 - { ' ks ' : ksname , ' cf ' : cfname } ) 
 + if self . cassandraver _ atleast ( 1 , 2 ) : 
 + cf _ q = " " " select * from system . schema _ columnfamilies 
 + where keyspace _ name = : ks and columnfamily _ name = : cf " " " 
 + col _ q = " " " select * from system . schema _ columns 
 + where keyspace _ name = : ks and columnfamily _ name = : cf " " " 
 + else : 
 + cf _ q = " " " select * from system . schema _ columnfamilies 
 + where " keyspace " = : ks and " columnfamily " = : cf " " " 
 + col _ q = " " " select * from system . schema _ columns 
 + where " keyspace " = : ks and " columnfamily " = : cf " " " 
 + self . cursor . execute ( cf _ q , { ' ks ' : ksname , ' cf ' : cfname } ) 
 layout = self . fetchdict ( ) 
 if layout is None : 
 raise ColumnFamilyNotFound ( " Column family % r not found " % cfname ) 
 - self . cursor . execute ( " " " select * from system . schema _ columns 
 - where " keyspace " = : ks and " columnfamily " = : cf " " " , 
 - { ' ks ' : ksname , ' cf ' : cfname } ) 
 + self . cursor . execute ( col _ q , { ' ks ' : ksname , ' cf ' : cfname } ) 
 cols = self . fetchdict _ all ( ) 
 return cql3handling . CqlTableDef . from _ layout ( layout , cols ) 
 
 @ @ - 1544 , 6 + 1569 , 7 @ @ class Shell ( cmd . Cmd ) : 
 
 showwhat = parsed . get _ binding ( ' what ' ) . lower ( ) 
 if showwhat = = ' version ' : 
 + self . get _ connection _ versions ( ) 
 self . show _ version ( ) 
 elif showwhat = = ' host ' : 
 self . show _ host ( ) 
 diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 13ce07a . . f1d7f81 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 692 , 7 + 692 , 11 @ @ class CqlColumnDef : 
 
 @ classmethod 
 def from _ layout ( cls , layout ) : 
 - c = cls ( layout [ u ' column ' ] , cql _ typename ( layout [ u ' validator ' ] ) ) 
 + try : 
 + colname = layout [ u ' column _ name ' ] 
 + except KeyError : 
 + colname = layout [ u ' column ' ] 
 + c = cls ( colname , cql _ typename ( layout [ u ' validator ' ] ) ) 
 c . index _ name = layout [ u ' index _ name ' ] 
 return c 
 
 @ @ - 716 , 7 + 720 , 11 @ @ class CqlTableDef : 
 
 @ classmethod 
 def from _ layout ( cls , layout , coldefs ) : 
 - cf = cls ( name = layout [ u ' columnfamily ' ] ) 
 + try : 
 + cfname = layout [ u ' columnfamily _ name ' ] 
 + except KeyError : 
 + cfname = layout [ u ' columnfamily ' ] 
 + cf = cls ( name = cfname ) 
 for attr , val in layout . items ( ) : 
 setattr ( cf , attr . encode ( ' ascii ' ) , val ) 
 for attr in cls . json _ attrs :
