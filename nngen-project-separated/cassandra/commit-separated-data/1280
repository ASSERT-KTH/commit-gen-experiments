BLEU SCORE: 0.1413328873311171

TEST MSG: Suppress some pushed events when rpc _ address is shared
GENERATED MSG: Use rpc _ address for binary protocol and change default port

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 3364dcd . . 0ad2b36 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 1 . 10 <nl> + * Avoid misleading pushed notifications when multiple nodes <nl> + share an rpc _ address ( CASSANDRA - 10052 ) <nl> * Fix dropping undroppable when message queue is full ( CASSANDRA - 10113 ) <nl> * Fix potential ClassCastException during paging ( CASSANDRA - 10352 ) <nl> * Prevent ALTER TYPE from creating circular references ( CASSANDRA - 10339 ) <nl> diff - - git a / src / java / org / apache / cassandra / transport / Event . java b / src / java / org / apache / cassandra / transport / Event . java <nl> index b7c5e68 . . 12ad6e9 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Event . java <nl> + + + b / src / java / org / apache / cassandra / transport / Event . java <nl> @ @ - 62 , 18 + 62 , 32 @ @ public abstract class Event <nl> protected abstract void serializeEvent ( ByteBuf dest , int version ) ; <nl> protected abstract int eventSerializedSize ( int version ) ; <nl> <nl> - public static class TopologyChange extends Event <nl> + public static abstract class NodeEvent extends Event <nl> + { <nl> + public final InetSocketAddress node ; <nl> + <nl> + public InetAddress nodeAddress ( ) <nl> + { <nl> + return node . getAddress ( ) ; <nl> + } <nl> + <nl> + private NodeEvent ( Type type , InetSocketAddress node ) <nl> + { <nl> + super ( type ) ; <nl> + this . node = node ; <nl> + } <nl> + } <nl> + <nl> + public static class TopologyChange extends NodeEvent <nl> { <nl> public enum Change { NEW _ NODE , REMOVED _ NODE , MOVED _ NODE } <nl> <nl> public final Change change ; <nl> - public final InetSocketAddress node ; <nl> <nl> private TopologyChange ( Change change , InetSocketAddress node ) <nl> { <nl> - super ( Type . TOPOLOGY _ CHANGE ) ; <nl> + super ( Type . TOPOLOGY _ CHANGE , node ) ; <nl> this . change = change ; <nl> - this . node = node ; <nl> } <nl> <nl> public static TopologyChange newNode ( InetAddress host , int port ) <nl> @ @ - 134 , 18 + 148 , 17 @ @ public abstract class Event <nl> } <nl> } <nl> <nl> - public static class StatusChange extends Event <nl> + <nl> + public static class StatusChange extends NodeEvent <nl> { <nl> public enum Status { UP , DOWN } <nl> <nl> public final Status status ; <nl> - public final InetSocketAddress node ; <nl> <nl> private StatusChange ( Status status , InetSocketAddress node ) <nl> { <nl> - super ( Type . STATUS _ CHANGE ) ; <nl> + super ( Type . STATUS _ CHANGE , node ) ; <nl> this . status = status ; <nl> - this . node = node ; <nl> } <nl> <nl> public static StatusChange nodeUp ( InetAddress host , int port ) <nl> diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java <nl> index 8f0f89f . . c21a669 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Server . java <nl> + + + b / src / java / org / apache / cassandra / transport / Server . java <nl> @ @ - 55 , 6 + 55 , 7 @ @ import io . netty . channel . * ; <nl> import io . netty . channel . group . ChannelGroup ; <nl> import io . netty . channel . group . DefaultChannelGroup ; <nl> import io . netty . handler . ssl . SslHandler ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> public class Server implements CassandraDaemon . Server <nl> { <nl> @ @ - 381 , 78 + 382 , 97 @ @ public class Server implements CassandraDaemon . Server <nl> } <nl> } <nl> <nl> + private void send ( InetAddress endpoint , Event . NodeEvent event ) <nl> + { <nl> + / / If the endpoint is not the local node , extract the node address <nl> + / / and if it is the same as our own RPC broadcast address ( which defaults to the rcp address ) <nl> + / / then don ' t send the notification . This covers the case of rpc _ address set to " localhost " , <nl> + / / which is not useful to any driver and in fact may cauase serious problems to some drivers , <nl> + / / see CASSANDRA - 10052 <nl> + if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & <nl> + event . nodeAddress ( ) . equals ( DatabaseDescriptor . getBroadcastRpcAddress ( ) ) ) <nl> + return ; <nl> + <nl> + send ( event ) ; <nl> + } <nl> + <nl> + private void send ( Event event ) <nl> + { <nl> + server . connectionTracker . send ( event ) ; <nl> + } <nl> + <nl> public void onJoinCluster ( InetAddress endpoint ) <nl> { <nl> - server . connectionTracker . send ( Event . TopologyChange . newNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> + send ( endpoint , Event . TopologyChange . newNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> } <nl> <nl> public void onLeaveCluster ( InetAddress endpoint ) <nl> { <nl> - server . connectionTracker . send ( Event . TopologyChange . removedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> + send ( endpoint , Event . TopologyChange . removedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> } <nl> <nl> public void onMove ( InetAddress endpoint ) <nl> { <nl> - server . connectionTracker . send ( Event . TopologyChange . movedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> + send ( endpoint , Event . TopologyChange . movedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> } <nl> <nl> public void onUp ( InetAddress endpoint ) <nl> { <nl> Event . StatusChange . Status prev = lastStatusChange . put ( endpoint , Event . StatusChange . Status . UP ) ; <nl> if ( prev = = null | | prev ! = Event . StatusChange . Status . UP ) <nl> - server . connectionTracker . send ( Event . StatusChange . nodeUp ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> + send ( endpoint , Event . StatusChange . nodeUp ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> } <nl> <nl> public void onDown ( InetAddress endpoint ) <nl> { <nl> Event . StatusChange . Status prev = lastStatusChange . put ( endpoint , Event . StatusChange . Status . DOWN ) ; <nl> if ( prev = = null | | prev ! = Event . StatusChange . Status . DOWN ) <nl> - server . connectionTracker . send ( Event . StatusChange . nodeDown ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> + send ( endpoint , Event . StatusChange . nodeDown ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; <nl> } <nl> <nl> public void onCreateKeyspace ( String ksName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , ksName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , ksName ) ) ; <nl> } <nl> <nl> public void onCreateColumnFamily ( String ksName , String cfName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> } <nl> <nl> public void onCreateUserType ( String ksName , String typeName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> } <nl> <nl> public void onUpdateKeyspace ( String ksName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , ksName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , ksName ) ) ; <nl> } <nl> <nl> public void onUpdateColumnFamily ( String ksName , String cfName , boolean columnsDidChange ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> } <nl> <nl> public void onUpdateUserType ( String ksName , String typeName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> } <nl> <nl> public void onDropKeyspace ( String ksName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , ksName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , ksName ) ) ; <nl> } <nl> <nl> public void onDropColumnFamily ( String ksName , String cfName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; <nl> } <nl> <nl> public void onDropUserType ( String ksName , String typeName ) <nl> { <nl> - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; <nl> } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d803c0f . . cb725cc 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 16 , 6 + 16 , 7 @ @ <nl> * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) <nl> * ( CQL3 ) Don ' t return ReversedType in result set metadata ( CASSANDRA - 4717 ) <nl> * Pluggable Thrift transport factories for CLI ( CASSANDRA - 4609 ) <nl> + * Backport adding AlterKeyspace statement ( CASSANDRA - 4611 ) <nl> Merged from 1 . 0 : <nl> * Switch from NBHM to CHM in MessagingService ' s callback map , which <nl> prevents OOM in long - running instances ( CASSANDRA - 4708 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> index 7b27875 . . a5fccc3 100644 <nl> - - - a / src / java / org / apache / cassandra / config / KSMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> @ @ - 60 , 18 + 60 , 18 @ @ public final class KSMetaData <nl> } <nl> <nl> / / For new user created keyspaces ( through CQL ) <nl> - public static KSMetaData newKeyspace ( String name , String strategyName , Map < String , String > options ) throws ConfigurationException <nl> + public static KSMetaData newKeyspace ( String name , String strategyName , Map < String , String > options , boolean durableWrites ) throws ConfigurationException <nl> { <nl> Class < ? extends AbstractReplicationStrategy > cls = AbstractReplicationStrategy . getClass ( strategyName ) ; <nl> if ( cls . equals ( LocalStrategy . class ) ) <nl> throw new ConfigurationException ( " Unable to use given strategy class : LocalStrategy is reserved for internal use . " ) ; <nl> <nl> - return newKeyspace ( name , cls , options , Collections . < CFMetaData > emptyList ( ) ) ; <nl> + return newKeyspace ( name , cls , options , durableWrites , Collections . < CFMetaData > emptyList ( ) ) ; <nl> } <nl> <nl> - public static KSMetaData newKeyspace ( String name , Class < ? extends AbstractReplicationStrategy > strategyClass , Map < String , String > options , Iterable < CFMetaData > cfDefs ) <nl> + public static KSMetaData newKeyspace ( String name , Class < ? extends AbstractReplicationStrategy > strategyClass , Map < String , String > options , boolean durablesWrites , Iterable < CFMetaData > cfDefs ) <nl> { <nl> - return new KSMetaData ( name , strategyClass , options , true , cfDefs ) ; <nl> + return new KSMetaData ( name , strategyClass , options , durablesWrites , cfDefs ) ; <nl> } <nl> <nl> public static KSMetaData cloneWith ( KSMetaData ksm , Iterable < CFMetaData > cfDefs ) <nl> diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> index 4a829c6 . . ab1c15b 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> @ @ - 700 , 7 + 700 , 8 @ @ public class QueryProcessor <nl> { <nl> KSMetaData ksm = KSMetaData . newKeyspace ( create . getName ( ) , <nl> create . getStrategyClass ( ) , <nl> - create . getStrategyOptions ( ) ) ; <nl> + create . getStrategyOptions ( ) , <nl> + true ) ; <nl> ThriftValidation . validateKeyspaceNotYetExisting ( ksm . name ) ; <nl> MigrationManager . announceNewKeyspace ( ksm ) ; <nl> validateSchemaIsSettled ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CFPropDefs . java b / src / java / org / apache / cassandra / cql3 / CFPropDefs . java <nl> index 01e14fb . . ab209dd 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CFPropDefs . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CFPropDefs . java <nl> @ @ - 18 , 7 + 18 , 16 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 ; <nl> <nl> + import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> + import java . util . HashSet ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + <nl> import com . google . common . collect . Sets ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ConfigurationException ; <nl> import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; <nl> @ @ - 29 , 12 + 38 , 7 @ @ import org . apache . cassandra . thrift . InvalidRequestException ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> - import java . util . HashMap ; <nl> - import java . util . HashSet ; <nl> - import java . util . Map ; <nl> - import java . util . Set ; <nl> - <nl> - public class CFPropDefs <nl> + public class CFPropDefs extends PropertyDefinitions <nl> { <nl> private static Logger logger = LoggerFactory . getLogger ( CFPropDefs . class ) ; <nl> <nl> @ @ - 89 , 7 + 93 , 6 @ @ public class CFPropDefs <nl> allowedKeywords . addAll ( obsoleteKeywords ) ; <nl> } <nl> <nl> - public final Map < String , String > properties = new HashMap < String , String > ( ) ; <nl> private Class < ? extends AbstractCompactionStrategy > compactionStrategyClass = null ; <nl> public final Map < String , String > compactionStrategyOptions = new HashMap < String , String > ( ) ; <nl> public final Map < String , String > compressionParameters = new HashMap < String , String > ( ) <nl> @ @ - 115 , 18 + 118 , 9 @ @ public class CFPropDefs <nl> } <nl> } <nl> <nl> - / * If not comparator / validator is not specified , default to text ( BytesType is the wrong default for CQL <nl> - * since it uses hex terms ) . If the value specified is not found in the comparators map , assume the user <nl> - * knows what they are doing ( a custom comparator / validator for example ) , and pass it on as - is . <nl> - * / <nl> - <nl> - public void validate ( ) throws ConfigurationException <nl> + public void validate ( ) throws ConfigurationException , InvalidRequestException <nl> { <nl> - / / Catch the case where someone passed a kwarg that is not recognized . <nl> - for ( String bogus : Sets . difference ( properties . keySet ( ) , allowedKeywords ) ) <nl> - throw new ConfigurationException ( bogus + " is not a valid keyword argument for CREATE TABLE " ) ; <nl> - for ( String obsolete : Sets . intersection ( properties . keySet ( ) , obsoleteKeywords ) ) <nl> - logger . warn ( " Ignoring obsolete property { } " , obsolete ) ; <nl> + validate ( keywords , obsoleteKeywords ) ; <nl> <nl> if ( properties . containsKey ( KW _ COMPACTION _ STRATEGY _ CLASS ) ) <nl> { <nl> @ @ - 135 , 8 + 129 , 8 @ @ public class CFPropDefs <nl> } <nl> } <nl> <nl> - / * * Map a keyword to the corresponding value * / <nl> - public void addProperty ( String name , String value ) <nl> + @ Override <nl> + public void addProperty ( String name , String value ) throws InvalidRequestException <nl> { <nl> String [ ] composite = name . split ( " : " ) ; <nl> if ( composite . length > 1 ) <nl> @ @ - 152 , 24 + 146 , 13 @ @ public class CFPropDefs <nl> return ; <nl> } <nl> } <nl> - properties . put ( name , value ) ; <nl> - } <nl> - <nl> - public void addAll ( Map < String , String > propertyMap ) <nl> - { <nl> - for ( Map . Entry < String , String > entry : propertyMap . entrySet ( ) ) <nl> - addProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; <nl> - } <nl> - <nl> - public Boolean hasProperty ( String name ) <nl> - { <nl> - return properties . containsKey ( name ) ; <nl> + super . addProperty ( name , value ) ; <nl> } <nl> <nl> - public void applyToCFMetadata ( CFMetaData cfm ) throws ConfigurationException <nl> + public void applyToCFMetadata ( CFMetaData cfm ) throws ConfigurationException , InvalidRequestException <nl> { <nl> if ( hasProperty ( KW _ COMMENT ) ) <nl> - cfm . comment ( get ( KW _ COMMENT ) ) ; <nl> + cfm . comment ( getString ( KW _ COMMENT , " " ) ) ; <nl> <nl> cfm . readRepairChance ( getDouble ( KW _ READREPAIRCHANCE , cfm . getReadRepairChance ( ) ) ) ; <nl> cfm . dcLocalReadRepairChance ( getDouble ( KW _ DCLOCALREADREPAIRCHANCE , cfm . getDcLocalReadRepair ( ) ) ) ; <nl> @ @ - 181 , 80 + 164 , 12 @ @ public class CFPropDefs <nl> cfm . bloomFilterFpChance ( getDouble ( KW _ BF _ FP _ CHANCE , cfm . getBloomFilterFpChance ( ) ) ) ; <nl> <nl> if ( compactionStrategyClass ! = null ) <nl> + { <nl> cfm . compactionStrategyClass ( compactionStrategyClass ) ; <nl> - <nl> - if ( ! compactionStrategyOptions . isEmpty ( ) ) <nl> cfm . compactionStrategyOptions ( new HashMap < String , String > ( compactionStrategyOptions ) ) ; <nl> - <nl> - if ( ! compressionParameters . isEmpty ( ) ) <nl> - cfm . compressionParameters ( CompressionParameters . create ( compressionParameters ) ) ; <nl> - } <nl> - <nl> - public String get ( String name ) <nl> - { <nl> - return properties . get ( name ) ; <nl> - } <nl> - <nl> - public String getString ( String key , String defaultValue ) <nl> - { <nl> - String value = properties . get ( key ) ; <nl> - return value ! = null ? value : defaultValue ; <nl> - } <nl> - <nl> - / / Return a property value , typed as a Boolean <nl> - public Boolean getBoolean ( String key , Boolean defaultValue ) <nl> - { <nl> - String value = properties . get ( key ) ; <nl> - return ( value = = null ) ? defaultValue : value . toLowerCase ( ) . matches ( " ( 1 | true | yes ) " ) ; <nl> - } <nl> - <nl> - / / Return a property value , typed as a Double <nl> - public Double getDouble ( String key , Double defaultValue ) throws ConfigurationException <nl> - { <nl> - Double result ; <nl> - String value = properties . get ( key ) ; <nl> - <nl> - if ( value = = null ) <nl> - result = defaultValue ; <nl> - else <nl> - { <nl> - try <nl> - { <nl> - result = Double . parseDouble ( value ) ; <nl> - } <nl> - catch ( NumberFormatException e ) <nl> - { <nl> - throw new ConfigurationException ( String . format ( " % s not valid for \ " % s \ " " , value , key ) ) ; <nl> - } <nl> } <nl> - return result ; <nl> - } <nl> - <nl> - / / Return a property value , typed as an Integer <nl> - public Integer getInt ( String key , Integer defaultValue ) throws ConfigurationException <nl> - { <nl> - String value = properties . get ( key ) ; <nl> - return toInt ( key , value , defaultValue ) ; <nl> - } <nl> - <nl> - public static Integer toInt ( String key , String value , Integer defaultValue ) throws ConfigurationException <nl> - { <nl> - Integer result ; <nl> <nl> - if ( value = = null ) <nl> - result = defaultValue ; <nl> - else <nl> - { <nl> - try <nl> - { <nl> - result = Integer . parseInt ( value ) ; <nl> - } <nl> - catch ( NumberFormatException e ) <nl> - { <nl> - throw new ConfigurationException ( String . format ( " % s not valid for \ " % s \ " " , value , key ) ) ; <nl> - } <nl> - } <nl> - return result ; <nl> + cfm . compressionParameters ( CompressionParameters . create ( compressionParameters ) ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index f0481f6 . . 387e694 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 144 , 6 + 144 , 7 @ @ cqlStatement returns [ ParsedStatement stmt ] <nl> | st15 = grantStatement { $ stmt = st15 ; } <nl> | st16 = revokeStatement { $ stmt = st16 ; } <nl> | st17 = listGrantsStatement { $ stmt = st17 ; } <nl> + | st18 = alterKeyspaceStatement { $ stmt = st18 ; } <nl> ; <nl> <nl> / * <nl> @ @ - 341 , 8 + 342 , 9 @ @ batchStatementObjective returns [ ModificationStatement statement ] <nl> * CREATE KEYSPACE < KEYSPACE > WITH attr1 = value1 AND attr2 = value2 ; <nl> * / <nl> createKeyspaceStatement returns [ CreateKeyspaceStatement expr ] <nl> + @ init { KSPropDefs attrs = new KSPropDefs ( ) ; } <nl> : K _ CREATE K _ KEYSPACE ks = keyspaceName <nl> - K _ WITH props = properties { $ expr = new CreateKeyspaceStatement ( ks , props ) ; } <nl> + K _ WITH properties [ attrs ] { $ expr = new CreateKeyspaceStatement ( ks , attrs ) ; } <nl> ; <nl> <nl> / * * <nl> @ @ - 368 , 7 + 370 , 7 @ @ cfamColumns [ CreateColumnFamilyStatement . RawStatement expr ] <nl> ; <nl> <nl> cfamProperty [ CreateColumnFamilyStatement . RawStatement expr ] <nl> - : k = property ' = ' v = propertyValue { $ expr . addProperty ( k , v ) ; } <nl> + : k = propertyKey ' = ' v = propertyValue { try { $ expr . addProperty ( k , v ) ; } catch ( InvalidRequestException e ) { addRecognitionError ( e . getMessage ( ) ) ; } } <nl> | K _ COMPACT K _ STORAGE { $ expr . setCompactStorage ( ) ; } <nl> | K _ CLUSTERING K _ ORDER K _ BY ' ( ' cfamOrdering [ expr ] ( ' , ' cfamOrdering [ expr ] ) * ' ) ' <nl> ; <nl> @ @ - 387 , 6 + 389 , 16 @ @ createIndexStatement returns [ CreateIndexStatement expr ] <nl> ; <nl> <nl> / * * <nl> + * ALTER KEYSPACE < KS > WITH < property > = < value > ; <nl> + * / <nl> + alterKeyspaceStatement returns [ AlterKeyspaceStatement expr ] <nl> + @ init { KSPropDefs attrs = new KSPropDefs ( ) ; } <nl> + : K _ ALTER K _ KEYSPACE ks = keyspaceName <nl> + K _ WITH properties [ attrs ] { $ expr = new AlterKeyspaceStatement ( ks , attrs ) ; } <nl> + ; <nl> + <nl> + <nl> + / * * <nl> * ALTER COLUMN FAMILY < CF > ALTER < column > TYPE < newtype > ; <nl> * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; <nl> * ALTER COLUMN FAMILY < CF > DROP < column > ; <nl> @ @ - 395 , 13 + 407 , 13 @ @ createIndexStatement returns [ CreateIndexStatement expr ] <nl> alterTableStatement returns [ AlterTableStatement expr ] <nl> @ init { <nl> AlterTableStatement . Type type = null ; <nl> - props = new HashMap < String , String > ( ) ; <nl> + CFPropDefs props = new CFPropDefs ( ) ; <nl> } <nl> : K _ ALTER K _ COLUMNFAMILY cf = columnFamilyName <nl> ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } <nl> | K _ ADD id = cident v = comparatorType { type = AlterTableStatement . Type . ADD ; } <nl> | K _ DROP id = cident { type = AlterTableStatement . Type . DROP ; } <nl> - | K _ WITH props = properties { type = AlterTableStatement . Type . OPTS ; } <nl> + | K _ WITH properties [ props ] { type = AlterTableStatement . Type . OPTS ; } <nl> ) <nl> { <nl> $ expr = new AlterTableStatement ( cf , type , id , v , props ) ; <nl> @ @ - 545 , 7 + 557 , 15 @ @ termPairWithOperation [ Map < ColumnIdentifier , Operation > columns ] <nl> ) <nl> ; <nl> <nl> - property returns [ String str ] <nl> + properties [ PropertyDefinitions props ] <nl> + : property [ props ] ( K _ AND property [ props ] ) * <nl> + ; <nl> + <nl> + property [ PropertyDefinitions props ] <nl> + : k = propertyKey ' = ' simple = propertyValue { try { $ props . addProperty ( k , simple ) ; } catch ( InvalidRequestException e ) { addRecognitionError ( e . getMessage ( ) ) ; } } <nl> + ; <nl> + <nl> + propertyKey returns [ String str ] <nl> @ init { StringBuilder sb = new StringBuilder ( ) ; } <nl> : c1 = cident { sb . append ( c1 ) ; } ( ' : ' cn = cident { sb . append ( ' : ' ) . append ( cn ) ; } ) * { $ str = sb . toString ( ) ; } <nl> ; <nl> @ @ - 555 , 11 + 575 , 6 @ @ propertyValue returns [ String str ] <nl> | u = unreserved _ keyword { $ str = u ; } <nl> ; <nl> <nl> - properties returns [ Map < String , String > props ] <nl> - @ init { $ props = new HashMap < String , String > ( ) ; } <nl> - : k1 = property ' = ' v1 = propertyValue { $ props . put ( k1 , v1 ) ; } ( K _ AND kn = property ' = ' vn = propertyValue { $ props . put ( kn , vn ) ; } ) * <nl> - ; <nl> - <nl> relation returns [ Relation rel ] <nl> : name = cident type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term { $ rel = new Relation ( $ name . id , $ type . text , $ t . term ) ; } <nl> | K _ TOKEN ' ( ' name = cident ' ) ' type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = extendedTerm { $ rel = new Relation ( $ name . id , $ type . text , $ t . term , true ) ; } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / KSPropDefs . java b / src / java / org / apache / cassandra / cql3 / KSPropDefs . java <nl> new file mode 100644 <nl> index 0000000 . . d480df4 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / KSPropDefs . java <nl> @ @ - 0 , 0 + 1 , 89 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import java . util . * ; <nl> + <nl> + import org . apache . cassandra . config . KSMetaData ; <nl> + import org . apache . cassandra . config . ConfigurationException ; <nl> + import org . apache . cassandra . thrift . InvalidRequestException ; <nl> + <nl> + public class KSPropDefs extends PropertyDefinitions <nl> + { <nl> + public static final String KW _ DURABLE _ WRITES = " durable _ writes " ; <nl> + <nl> + public static final String KW _ REPLICATION _ STRATEGY = " strategy _ class " ; <nl> + <nl> + public static final Set < String > keywords = new HashSet < String > ( ) ; <nl> + public static final Set < String > obsoleteKeywords = new HashSet < String > ( ) ; <nl> + <nl> + static <nl> + { <nl> + keywords . add ( KW _ DURABLE _ WRITES ) ; <nl> + keywords . add ( KW _ REPLICATION _ STRATEGY ) ; <nl> + } <nl> + <nl> + private String strategyClass ; <nl> + private final Map < String , String > strategyOptions = new HashMap < String , String > ( ) ; <nl> + <nl> + public void validate ( ) throws ConfigurationException , InvalidRequestException <nl> + { <nl> + validate ( keywords , obsoleteKeywords ) ; <nl> + <nl> + if ( ! properties . containsKey ( " strategy _ class " ) ) <nl> + throw new InvalidRequestException ( " missing required argument \ " strategy _ class \ " " ) ; <nl> + strategyClass = properties . get ( " strategy _ class " ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void addProperty ( String name , String value ) throws InvalidRequestException <nl> + { <nl> + / / optional <nl> + if ( name . contains ( " : " ) & & name . startsWith ( " strategy _ options " ) ) <nl> + strategyOptions . put ( name . split ( " : " ) [ 1 ] , value ) ; <nl> + else <nl> + super . addProperty ( name , value ) ; <nl> + } <nl> + <nl> + public String getReplicationStrategyClass ( ) <nl> + { <nl> + return strategyClass ; <nl> + } <nl> + <nl> + public Map < String , String > getReplicationOptions ( ) <nl> + { <nl> + return strategyOptions ; <nl> + } <nl> + <nl> + public KSMetaData asKSMetadata ( String ksName ) throws InvalidRequestException , ConfigurationException <nl> + { <nl> + return KSMetaData . newKeyspace ( ksName , getReplicationStrategyClass ( ) , getReplicationOptions ( ) , getBoolean ( KW _ DURABLE _ WRITES , true ) ) ; <nl> + } <nl> + <nl> + public KSMetaData asKSMetadataUpdate ( KSMetaData old ) throws InvalidRequestException , ConfigurationException <nl> + { <nl> + String sClass = strategyClass ; <nl> + Map < String , String > sOptions = getReplicationOptions ( ) ; <nl> + if ( sClass = = null ) <nl> + { <nl> + sClass = old . strategyClass . getName ( ) ; <nl> + sOptions = old . strategyOptions ; <nl> + } <nl> + return KSMetaData . newKeyspace ( old . name , sClass , sOptions , getBoolean ( KW _ DURABLE _ WRITES , old . durableWrites ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java b / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java <nl> new file mode 100644 <nl> index 0000000 . . 75b8ba5 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java <nl> @ @ - 0 , 0 + 1 , 122 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import java . util . * ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . thrift . InvalidRequestException ; <nl> + <nl> + public class PropertyDefinitions <nl> + { <nl> + protected static final Logger logger = LoggerFactory . getLogger ( PropertyDefinitions . class ) ; <nl> + <nl> + protected final Map < String , String > properties = new HashMap < String , String > ( ) ; <nl> + <nl> + public void addProperty ( String name , String value ) throws InvalidRequestException <nl> + { <nl> + if ( properties . put ( name , value ) ! = null ) <nl> + throw new InvalidRequestException ( String . format ( " Multiple definition for property ' % s ' " , name ) ) ; <nl> + } <nl> + <nl> + public void validate ( Set < String > keywords , Set < String > obsolete ) throws InvalidRequestException <nl> + { <nl> + for ( String name : properties . keySet ( ) ) <nl> + { <nl> + if ( keywords . contains ( name ) ) <nl> + continue ; <nl> + <nl> + if ( obsolete . contains ( name ) ) <nl> + logger . warn ( " Ignoring obsolete property { } " , name ) ; <nl> + else <nl> + throw new InvalidRequestException ( String . format ( " Unknown property ' % s ' " , name ) ) ; <nl> + } <nl> + } <nl> + <nl> + protected String getSimple ( String name ) throws InvalidRequestException <nl> + { <nl> + return properties . get ( name ) ; <nl> + } <nl> + <nl> + public Boolean hasProperty ( String name ) <nl> + { <nl> + return properties . containsKey ( name ) ; <nl> + } <nl> + <nl> + public String getString ( String key , String defaultValue ) throws InvalidRequestException <nl> + { <nl> + String value = getSimple ( key ) ; <nl> + return value ! = null ? value : defaultValue ; <nl> + } <nl> + <nl> + / / Return a property value , typed as a Boolean <nl> + public Boolean getBoolean ( String key , Boolean defaultValue ) throws InvalidRequestException <nl> + { <nl> + String value = getSimple ( key ) ; <nl> + return ( value = = null ) ? defaultValue : value . toLowerCase ( ) . matches ( " ( 1 | true | yes ) " ) ; <nl> + } <nl> + <nl> + / / Return a property value , typed as a Double <nl> + public Double getDouble ( String key , Double defaultValue ) throws InvalidRequestException <nl> + { <nl> + String value = getSimple ( key ) ; <nl> + if ( value = = null ) <nl> + { <nl> + return defaultValue ; <nl> + } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + return Double . valueOf ( value ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new InvalidRequestException ( String . format ( " Invalid double value % s for ' % s ' " , value , key ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + / / Return a property value , typed as an Integer <nl> + public Integer getInt ( String key , Integer defaultValue ) throws InvalidRequestException <nl> + { <nl> + String value = getSimple ( key ) ; <nl> + return toInt ( key , value , defaultValue ) ; <nl> + } <nl> + <nl> + public static Integer toInt ( String key , String value , Integer defaultValue ) throws InvalidRequestException <nl> + { <nl> + if ( value = = null ) <nl> + { <nl> + return defaultValue ; <nl> + } <nl> + else <nl> + { <nl> + try <nl> + { <nl> + return Integer . valueOf ( value ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new InvalidRequestException ( String . format ( " Invalid integer value % s for ' % s ' " , value , key ) ) ; <nl> + } <nl> + } <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java <nl> new file mode 100644 <nl> index 0000000 . . 644fd24 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java <nl> @ @ - 0 , 0 + 1 , 95 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 . statements ; <nl> + <nl> + import org . apache . cassandra . auth . Permission ; <nl> + import org . apache . cassandra . config . ConfigurationException ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . KSMetaData ; <nl> + import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . cql3 . KSPropDefs ; <nl> + import org . apache . cassandra . db . Table ; <nl> + import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> + import org . apache . cassandra . service . MigrationManager ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . thrift . InvalidRequestException ; <nl> + import org . apache . cassandra . thrift . SchemaDisagreementException ; <nl> + <nl> + public class AlterKeyspaceStatement extends SchemaAlteringStatement <nl> + { <nl> + private final String name ; <nl> + private final KSPropDefs attrs ; <nl> + <nl> + public AlterKeyspaceStatement ( String name , KSPropDefs attrs ) <nl> + { <nl> + super ( ) ; <nl> + this . name = name ; <nl> + this . attrs = attrs ; <nl> + } <nl> + <nl> + public void checkAccess ( ClientState state ) throws InvalidRequestException <nl> + { <nl> + state . hasKeyspaceAccess ( name , Permission . ALTER ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void validate ( ClientState state ) throws InvalidRequestException , SchemaDisagreementException <nl> + { <nl> + super . validate ( state ) ; <nl> + <nl> + KSMetaData ksm = Schema . instance . getKSMetaData ( name ) ; <nl> + if ( ksm = = null ) <nl> + throw new InvalidRequestException ( " Unknown keyspace " + name ) ; <nl> + if ( ksm . name . equalsIgnoreCase ( Table . SYSTEM _ TABLE ) ) <nl> + throw new InvalidRequestException ( " Cannot alter system keyspace " ) ; <nl> + <nl> + try <nl> + { <nl> + attrs . validate ( ) ; <nl> + <nl> + if ( attrs . getReplicationStrategyClass ( ) = = null & & ! attrs . getReplicationOptions ( ) . isEmpty ( ) ) <nl> + { <nl> + throw new InvalidRequestException ( " Missing replication strategy class " ) ; <nl> + } <nl> + else if ( attrs . getReplicationStrategyClass ( ) ! = null ) <nl> + { <nl> + / / trial run to let ARS validate class + per - class options <nl> + AbstractReplicationStrategy . createReplicationStrategy ( name , <nl> + AbstractReplicationStrategy . getClass ( attrs . getReplicationStrategyClass ( ) ) , <nl> + StorageService . instance . getTokenMetadata ( ) , <nl> + DatabaseDescriptor . getEndpointSnitch ( ) , <nl> + attrs . getReplicationOptions ( ) ) ; <nl> + } <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + throw new InvalidRequestException ( e . getMessage ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + public void announceMigration ( ) throws InvalidRequestException , ConfigurationException <nl> + { <nl> + KSMetaData ksm = Schema . instance . getKSMetaData ( name ) ; <nl> + / / In the ( very ) unlikely case the keyspace was dropped since validate ( ) <nl> + if ( ksm = = null ) <nl> + throw new InvalidRequestException ( " Unknown keyspace " + name ) ; <nl> + <nl> + MigrationManager . announceKeyspaceUpdate ( attrs . asKSMetadataUpdate ( ksm ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> index 7867019 . . 965b27e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> @ @ - 23 , 9 + 23 , 7 @ @ import java . util . * ; <nl> import org . apache . cassandra . auth . Permission ; <nl> import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . config . * ; <nl> - import org . apache . cassandra . db . marshal . AbstractType ; <nl> - import org . apache . cassandra . db . marshal . CompositeType ; <nl> - import org . apache . cassandra . db . marshal . CounterColumnType ; <nl> + import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . MigrationManager ; <nl> import org . apache . cassandra . thrift . InvalidRequestException ; <nl> @ @ - 42 , 15 + 40 , 15 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> public final Type oType ; <nl> public final String validator ; <nl> public final ColumnIdentifier columnName ; <nl> - private final CFPropDefs cfProps = new CFPropDefs ( ) ; <nl> + private final CFPropDefs cfProps ; <nl> <nl> - public AlterTableStatement ( CFName name , Type type , ColumnIdentifier columnName , String validator , Map < String , String > propertyMap ) <nl> + public AlterTableStatement ( CFName name , Type type , ColumnIdentifier columnName , String validator , CFPropDefs cfProps ) <nl> { <nl> super ( name ) ; <nl> this . oType = type ; <nl> this . columnName = columnName ; <nl> this . validator = validator ; / / used only for ADD / ALTER commands <nl> - this . cfProps . addAll ( propertyMap ) ; <nl> + this . cfProps = cfProps ; <nl> } <nl> <nl> public void checkAccess ( ClientState state ) throws InvalidRequestException <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java <nl> index 763db28 . . 286f265 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java <nl> @ @ - 108 , 14 + 108 , 7 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement <nl> comparator , <nl> null ) ; <nl> <nl> - newCFMD . defaultValidator ( defaultValidator ) <nl> - . columnMetadata ( getColumns ( ) ) <nl> - . keyValidator ( keyValidator ) <nl> - . keyAlias ( keyAlias ) <nl> - . columnAliases ( columnAliases ) <nl> - . valueAlias ( valueAlias ) ; <nl> - <nl> - properties . applyToCFMetadata ( newCFMD ) ; <nl> + applyPropertiesTo ( newCFMD ) ; <nl> } <nl> catch ( ConfigurationException e ) <nl> { <nl> @ @ - 124 , 6 + 117 , 18 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement <nl> return newCFMD ; <nl> } <nl> <nl> + public void applyPropertiesTo ( CFMetaData cfmd ) throws InvalidRequestException , ConfigurationException <nl> + { <nl> + cfmd . defaultValidator ( defaultValidator ) <nl> + . columnMetadata ( getColumns ( ) ) <nl> + . keyValidator ( keyValidator ) <nl> + . keyAlias ( keyAlias ) <nl> + . columnAliases ( columnAliases ) <nl> + . valueAlias ( valueAlias ) ; <nl> + <nl> + properties . applyToCFMetadata ( cfmd ) ; <nl> + } <nl> + <nl> public static class RawStatement extends CFStatement <nl> { <nl> private final Map < ColumnIdentifier , String > definitions = new HashMap < ColumnIdentifier , String > ( ) ; <nl> @ @ - 277 , 7 + 282 , 7 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement <nl> columnAliases . add ( alias ) ; <nl> } <nl> <nl> - public void addProperty ( String name , String value ) <nl> + public void addProperty ( String name , String value ) throws InvalidRequestException <nl> { <nl> properties . addProperty ( name , value ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java <nl> index 863a869 . . 9b36531 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . config . ConfigurationException ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . KSMetaData ; <nl> import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . cql3 . KSPropDefs ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . MigrationManager ; <nl> @ @ - 38 , 9 + 39 , 7 @ @ import org . apache . cassandra . thrift . ThriftValidation ; <nl> public class CreateKeyspaceStatement extends SchemaAlteringStatement <nl> { <nl> private final String name ; <nl> - private final Map < String , String > attrs ; <nl> - private String strategyClass ; <nl> - private Map < String , String > strategyOptions = new HashMap < String , String > ( ) ; <nl> + private final KSPropDefs attrs ; <nl> <nl> / * * <nl> * Creates a new < code > CreateKeyspaceStatement < / code > instance for a given <nl> @ @ - 49 , 7 + 48 , 7 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement <nl> * @ param name the name of the keyspace to create <nl> * @ param attrs map of the raw keyword arguments that followed the < code > WITH < / code > keyword . <nl> * / <nl> - public CreateKeyspaceStatement ( String name , Map < String , String > attrs ) <nl> + public CreateKeyspaceStatement ( String name , KSPropDefs attrs ) <nl> { <nl> super ( ) ; <nl> this . name = name ; <nl> @ @ - 80 , 24 + 79 , 19 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement <nl> if ( name . length ( ) > Schema . NAME _ LENGTH ) <nl> throw new InvalidRequestException ( String . format ( " Keyspace names shouldn ' t be more than % s characters long ( got \ " % s \ " ) " , Schema . NAME _ LENGTH , name ) ) ; <nl> <nl> - / / required <nl> - if ( ! attrs . containsKey ( " strategy _ class " ) ) <nl> - throw new InvalidRequestException ( " missing required argument \ " strategy _ class \ " " ) ; <nl> - strategyClass = attrs . get ( " strategy _ class " ) ; <nl> - <nl> - / / optional <nl> - for ( String key : attrs . keySet ( ) ) <nl> - if ( ( key . contains ( " : " ) ) & & ( key . startsWith ( " strategy _ options " ) ) ) <nl> - strategyOptions . put ( key . split ( " : " ) [ 1 ] , attrs . get ( key ) ) ; <nl> - <nl> - / / trial run to let ARS validate class + per - class options <nl> try <nl> { <nl> + attrs . validate ( ) ; <nl> + <nl> + if ( attrs . getReplicationStrategyClass ( ) = = null ) <nl> + throw new ConfigurationException ( " Missing mandatory replication strategy class " ) ; <nl> + <nl> + / / trial run to let ARS validate class + per - class options <nl> AbstractReplicationStrategy . createReplicationStrategy ( name , <nl> - AbstractReplicationStrategy . getClass ( strategyClass ) , <nl> + AbstractReplicationStrategy . getClass ( attrs . getReplicationStrategyClass ( ) ) , <nl> StorageService . instance . getTokenMetadata ( ) , <nl> DatabaseDescriptor . getEndpointSnitch ( ) , <nl> - strategyOptions ) ; <nl> + attrs . getReplicationOptions ( ) ) ; <nl> } <nl> catch ( ConfigurationException e ) <nl> { <nl> @ @ - 107 , 8 + 101 , 7 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement <nl> <nl> public void announceMigration ( ) throws InvalidRequestException , ConfigurationException <nl> { <nl> - KSMetaData ksm = KSMetaData . newKeyspace ( name , strategyClass , strategyOptions ) ; <nl> ThriftValidation . validateKeyspaceNotYetExisting ( name ) ; <nl> - MigrationManager . announceNewKeyspace ( ksm ) ; <nl> + MigrationManager . announceNewKeyspace ( attrs . asKSMetadata ( name ) ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 3364dcd . . 0ad2b36 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 1 . 10 
 + * Avoid misleading pushed notifications when multiple nodes 
 + share an rpc _ address ( CASSANDRA - 10052 ) 
 * Fix dropping undroppable when message queue is full ( CASSANDRA - 10113 ) 
 * Fix potential ClassCastException during paging ( CASSANDRA - 10352 ) 
 * Prevent ALTER TYPE from creating circular references ( CASSANDRA - 10339 ) 
 diff - - git a / src / java / org / apache / cassandra / transport / Event . java b / src / java / org / apache / cassandra / transport / Event . java 
 index b7c5e68 . . 12ad6e9 100644 
 - - - a / src / java / org / apache / cassandra / transport / Event . java 
 + + + b / src / java / org / apache / cassandra / transport / Event . java 
 @ @ - 62 , 18 + 62 , 32 @ @ public abstract class Event 
 protected abstract void serializeEvent ( ByteBuf dest , int version ) ; 
 protected abstract int eventSerializedSize ( int version ) ; 
 
 - public static class TopologyChange extends Event 
 + public static abstract class NodeEvent extends Event 
 + { 
 + public final InetSocketAddress node ; 
 + 
 + public InetAddress nodeAddress ( ) 
 + { 
 + return node . getAddress ( ) ; 
 + } 
 + 
 + private NodeEvent ( Type type , InetSocketAddress node ) 
 + { 
 + super ( type ) ; 
 + this . node = node ; 
 + } 
 + } 
 + 
 + public static class TopologyChange extends NodeEvent 
 { 
 public enum Change { NEW _ NODE , REMOVED _ NODE , MOVED _ NODE } 
 
 public final Change change ; 
 - public final InetSocketAddress node ; 
 
 private TopologyChange ( Change change , InetSocketAddress node ) 
 { 
 - super ( Type . TOPOLOGY _ CHANGE ) ; 
 + super ( Type . TOPOLOGY _ CHANGE , node ) ; 
 this . change = change ; 
 - this . node = node ; 
 } 
 
 public static TopologyChange newNode ( InetAddress host , int port ) 
 @ @ - 134 , 18 + 148 , 17 @ @ public abstract class Event 
 } 
 } 
 
 - public static class StatusChange extends Event 
 + 
 + public static class StatusChange extends NodeEvent 
 { 
 public enum Status { UP , DOWN } 
 
 public final Status status ; 
 - public final InetSocketAddress node ; 
 
 private StatusChange ( Status status , InetSocketAddress node ) 
 { 
 - super ( Type . STATUS _ CHANGE ) ; 
 + super ( Type . STATUS _ CHANGE , node ) ; 
 this . status = status ; 
 - this . node = node ; 
 } 
 
 public static StatusChange nodeUp ( InetAddress host , int port ) 
 diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java 
 index 8f0f89f . . c21a669 100644 
 - - - a / src / java / org / apache / cassandra / transport / Server . java 
 + + + b / src / java / org / apache / cassandra / transport / Server . java 
 @ @ - 55 , 6 + 55 , 7 @ @ import io . netty . channel . * ; 
 import io . netty . channel . group . ChannelGroup ; 
 import io . netty . channel . group . DefaultChannelGroup ; 
 import io . netty . handler . ssl . SslHandler ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 
 public class Server implements CassandraDaemon . Server 
 { 
 @ @ - 381 , 78 + 382 , 97 @ @ public class Server implements CassandraDaemon . Server 
 } 
 } 
 
 + private void send ( InetAddress endpoint , Event . NodeEvent event ) 
 + { 
 + / / If the endpoint is not the local node , extract the node address 
 + / / and if it is the same as our own RPC broadcast address ( which defaults to the rcp address ) 
 + / / then don ' t send the notification . This covers the case of rpc _ address set to " localhost " , 
 + / / which is not useful to any driver and in fact may cauase serious problems to some drivers , 
 + / / see CASSANDRA - 10052 
 + if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & 
 + event . nodeAddress ( ) . equals ( DatabaseDescriptor . getBroadcastRpcAddress ( ) ) ) 
 + return ; 
 + 
 + send ( event ) ; 
 + } 
 + 
 + private void send ( Event event ) 
 + { 
 + server . connectionTracker . send ( event ) ; 
 + } 
 + 
 public void onJoinCluster ( InetAddress endpoint ) 
 { 
 - server . connectionTracker . send ( Event . TopologyChange . newNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 + send ( endpoint , Event . TopologyChange . newNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 } 
 
 public void onLeaveCluster ( InetAddress endpoint ) 
 { 
 - server . connectionTracker . send ( Event . TopologyChange . removedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 + send ( endpoint , Event . TopologyChange . removedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 } 
 
 public void onMove ( InetAddress endpoint ) 
 { 
 - server . connectionTracker . send ( Event . TopologyChange . movedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 + send ( endpoint , Event . TopologyChange . movedNode ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 } 
 
 public void onUp ( InetAddress endpoint ) 
 { 
 Event . StatusChange . Status prev = lastStatusChange . put ( endpoint , Event . StatusChange . Status . UP ) ; 
 if ( prev = = null | | prev ! = Event . StatusChange . Status . UP ) 
 - server . connectionTracker . send ( Event . StatusChange . nodeUp ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 + send ( endpoint , Event . StatusChange . nodeUp ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 } 
 
 public void onDown ( InetAddress endpoint ) 
 { 
 Event . StatusChange . Status prev = lastStatusChange . put ( endpoint , Event . StatusChange . Status . DOWN ) ; 
 if ( prev = = null | | prev ! = Event . StatusChange . Status . DOWN ) 
 - server . connectionTracker . send ( Event . StatusChange . nodeDown ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 + send ( endpoint , Event . StatusChange . nodeDown ( getRpcAddress ( endpoint ) , server . socket . getPort ( ) ) ) ; 
 } 
 
 public void onCreateKeyspace ( String ksName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , ksName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , ksName ) ) ; 
 } 
 
 public void onCreateColumnFamily ( String ksName , String cfName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 } 
 
 public void onCreateUserType ( String ksName , String typeName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 } 
 
 public void onUpdateKeyspace ( String ksName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , ksName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , ksName ) ) ; 
 } 
 
 public void onUpdateColumnFamily ( String ksName , String cfName , boolean columnsDidChange ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 } 
 
 public void onUpdateUserType ( String ksName , String typeName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 } 
 
 public void onDropKeyspace ( String ksName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , ksName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , ksName ) ) ; 
 } 
 
 public void onDropColumnFamily ( String ksName , String cfName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TABLE , ksName , cfName ) ) ; 
 } 
 
 public void onDropUserType ( String ksName , String typeName ) 
 { 
 - server . connectionTracker . send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 + send ( new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . TYPE , ksName , typeName ) ) ; 
 } 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d803c0f . . cb725cc 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 16 , 6 + 16 , 7 @ @ 
 * Fix CQL3 ' is reversed ' logic ( CASSANDRA - 4716 ) 
 * ( CQL3 ) Don ' t return ReversedType in result set metadata ( CASSANDRA - 4717 ) 
 * Pluggable Thrift transport factories for CLI ( CASSANDRA - 4609 ) 
 + * Backport adding AlterKeyspace statement ( CASSANDRA - 4611 ) 
 Merged from 1 . 0 : 
 * Switch from NBHM to CHM in MessagingService ' s callback map , which 
 prevents OOM in long - running instances ( CASSANDRA - 4708 ) 
 diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java 
 index 7b27875 . . a5fccc3 100644 
 - - - a / src / java / org / apache / cassandra / config / KSMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / KSMetaData . java 
 @ @ - 60 , 18 + 60 , 18 @ @ public final class KSMetaData 
 } 
 
 / / For new user created keyspaces ( through CQL ) 
 - public static KSMetaData newKeyspace ( String name , String strategyName , Map < String , String > options ) throws ConfigurationException 
 + public static KSMetaData newKeyspace ( String name , String strategyName , Map < String , String > options , boolean durableWrites ) throws ConfigurationException 
 { 
 Class < ? extends AbstractReplicationStrategy > cls = AbstractReplicationStrategy . getClass ( strategyName ) ; 
 if ( cls . equals ( LocalStrategy . class ) ) 
 throw new ConfigurationException ( " Unable to use given strategy class : LocalStrategy is reserved for internal use . " ) ; 
 
 - return newKeyspace ( name , cls , options , Collections . < CFMetaData > emptyList ( ) ) ; 
 + return newKeyspace ( name , cls , options , durableWrites , Collections . < CFMetaData > emptyList ( ) ) ; 
 } 
 
 - public static KSMetaData newKeyspace ( String name , Class < ? extends AbstractReplicationStrategy > strategyClass , Map < String , String > options , Iterable < CFMetaData > cfDefs ) 
 + public static KSMetaData newKeyspace ( String name , Class < ? extends AbstractReplicationStrategy > strategyClass , Map < String , String > options , boolean durablesWrites , Iterable < CFMetaData > cfDefs ) 
 { 
 - return new KSMetaData ( name , strategyClass , options , true , cfDefs ) ; 
 + return new KSMetaData ( name , strategyClass , options , durablesWrites , cfDefs ) ; 
 } 
 
 public static KSMetaData cloneWith ( KSMetaData ksm , Iterable < CFMetaData > cfDefs ) 
 diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 index 4a829c6 . . ab1c15b 100644 
 - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 @ @ - 700 , 7 + 700 , 8 @ @ public class QueryProcessor 
 { 
 KSMetaData ksm = KSMetaData . newKeyspace ( create . getName ( ) , 
 create . getStrategyClass ( ) , 
 - create . getStrategyOptions ( ) ) ; 
 + create . getStrategyOptions ( ) , 
 + true ) ; 
 ThriftValidation . validateKeyspaceNotYetExisting ( ksm . name ) ; 
 MigrationManager . announceNewKeyspace ( ksm ) ; 
 validateSchemaIsSettled ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CFPropDefs . java b / src / java / org / apache / cassandra / cql3 / CFPropDefs . java 
 index 01e14fb . . ab209dd 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CFPropDefs . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CFPropDefs . java 
 @ @ - 18 , 7 + 18 , 16 @ @ 
 * / 
 package org . apache . cassandra . cql3 ; 
 
 + import java . util . Collections ; 
 + import java . util . HashMap ; 
 + import java . util . HashSet ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + 
 import com . google . common . collect . Sets ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ConfigurationException ; 
 import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; 
 @ @ - 29 , 12 + 38 , 7 @ @ import org . apache . cassandra . thrift . InvalidRequestException ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 - import java . util . HashMap ; 
 - import java . util . HashSet ; 
 - import java . util . Map ; 
 - import java . util . Set ; 
 - 
 - public class CFPropDefs 
 + public class CFPropDefs extends PropertyDefinitions 
 { 
 private static Logger logger = LoggerFactory . getLogger ( CFPropDefs . class ) ; 
 
 @ @ - 89 , 7 + 93 , 6 @ @ public class CFPropDefs 
 allowedKeywords . addAll ( obsoleteKeywords ) ; 
 } 
 
 - public final Map < String , String > properties = new HashMap < String , String > ( ) ; 
 private Class < ? extends AbstractCompactionStrategy > compactionStrategyClass = null ; 
 public final Map < String , String > compactionStrategyOptions = new HashMap < String , String > ( ) ; 
 public final Map < String , String > compressionParameters = new HashMap < String , String > ( ) 
 @ @ - 115 , 18 + 118 , 9 @ @ public class CFPropDefs 
 } 
 } 
 
 - / * If not comparator / validator is not specified , default to text ( BytesType is the wrong default for CQL 
 - * since it uses hex terms ) . If the value specified is not found in the comparators map , assume the user 
 - * knows what they are doing ( a custom comparator / validator for example ) , and pass it on as - is . 
 - * / 
 - 
 - public void validate ( ) throws ConfigurationException 
 + public void validate ( ) throws ConfigurationException , InvalidRequestException 
 { 
 - / / Catch the case where someone passed a kwarg that is not recognized . 
 - for ( String bogus : Sets . difference ( properties . keySet ( ) , allowedKeywords ) ) 
 - throw new ConfigurationException ( bogus + " is not a valid keyword argument for CREATE TABLE " ) ; 
 - for ( String obsolete : Sets . intersection ( properties . keySet ( ) , obsoleteKeywords ) ) 
 - logger . warn ( " Ignoring obsolete property { } " , obsolete ) ; 
 + validate ( keywords , obsoleteKeywords ) ; 
 
 if ( properties . containsKey ( KW _ COMPACTION _ STRATEGY _ CLASS ) ) 
 { 
 @ @ - 135 , 8 + 129 , 8 @ @ public class CFPropDefs 
 } 
 } 
 
 - / * * Map a keyword to the corresponding value * / 
 - public void addProperty ( String name , String value ) 
 + @ Override 
 + public void addProperty ( String name , String value ) throws InvalidRequestException 
 { 
 String [ ] composite = name . split ( " : " ) ; 
 if ( composite . length > 1 ) 
 @ @ - 152 , 24 + 146 , 13 @ @ public class CFPropDefs 
 return ; 
 } 
 } 
 - properties . put ( name , value ) ; 
 - } 
 - 
 - public void addAll ( Map < String , String > propertyMap ) 
 - { 
 - for ( Map . Entry < String , String > entry : propertyMap . entrySet ( ) ) 
 - addProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; 
 - } 
 - 
 - public Boolean hasProperty ( String name ) 
 - { 
 - return properties . containsKey ( name ) ; 
 + super . addProperty ( name , value ) ; 
 } 
 
 - public void applyToCFMetadata ( CFMetaData cfm ) throws ConfigurationException 
 + public void applyToCFMetadata ( CFMetaData cfm ) throws ConfigurationException , InvalidRequestException 
 { 
 if ( hasProperty ( KW _ COMMENT ) ) 
 - cfm . comment ( get ( KW _ COMMENT ) ) ; 
 + cfm . comment ( getString ( KW _ COMMENT , " " ) ) ; 
 
 cfm . readRepairChance ( getDouble ( KW _ READREPAIRCHANCE , cfm . getReadRepairChance ( ) ) ) ; 
 cfm . dcLocalReadRepairChance ( getDouble ( KW _ DCLOCALREADREPAIRCHANCE , cfm . getDcLocalReadRepair ( ) ) ) ; 
 @ @ - 181 , 80 + 164 , 12 @ @ public class CFPropDefs 
 cfm . bloomFilterFpChance ( getDouble ( KW _ BF _ FP _ CHANCE , cfm . getBloomFilterFpChance ( ) ) ) ; 
 
 if ( compactionStrategyClass ! = null ) 
 + { 
 cfm . compactionStrategyClass ( compactionStrategyClass ) ; 
 - 
 - if ( ! compactionStrategyOptions . isEmpty ( ) ) 
 cfm . compactionStrategyOptions ( new HashMap < String , String > ( compactionStrategyOptions ) ) ; 
 - 
 - if ( ! compressionParameters . isEmpty ( ) ) 
 - cfm . compressionParameters ( CompressionParameters . create ( compressionParameters ) ) ; 
 - } 
 - 
 - public String get ( String name ) 
 - { 
 - return properties . get ( name ) ; 
 - } 
 - 
 - public String getString ( String key , String defaultValue ) 
 - { 
 - String value = properties . get ( key ) ; 
 - return value ! = null ? value : defaultValue ; 
 - } 
 - 
 - / / Return a property value , typed as a Boolean 
 - public Boolean getBoolean ( String key , Boolean defaultValue ) 
 - { 
 - String value = properties . get ( key ) ; 
 - return ( value = = null ) ? defaultValue : value . toLowerCase ( ) . matches ( " ( 1 | true | yes ) " ) ; 
 - } 
 - 
 - / / Return a property value , typed as a Double 
 - public Double getDouble ( String key , Double defaultValue ) throws ConfigurationException 
 - { 
 - Double result ; 
 - String value = properties . get ( key ) ; 
 - 
 - if ( value = = null ) 
 - result = defaultValue ; 
 - else 
 - { 
 - try 
 - { 
 - result = Double . parseDouble ( value ) ; 
 - } 
 - catch ( NumberFormatException e ) 
 - { 
 - throw new ConfigurationException ( String . format ( " % s not valid for \ " % s \ " " , value , key ) ) ; 
 - } 
 } 
 - return result ; 
 - } 
 - 
 - / / Return a property value , typed as an Integer 
 - public Integer getInt ( String key , Integer defaultValue ) throws ConfigurationException 
 - { 
 - String value = properties . get ( key ) ; 
 - return toInt ( key , value , defaultValue ) ; 
 - } 
 - 
 - public static Integer toInt ( String key , String value , Integer defaultValue ) throws ConfigurationException 
 - { 
 - Integer result ; 
 
 - if ( value = = null ) 
 - result = defaultValue ; 
 - else 
 - { 
 - try 
 - { 
 - result = Integer . parseInt ( value ) ; 
 - } 
 - catch ( NumberFormatException e ) 
 - { 
 - throw new ConfigurationException ( String . format ( " % s not valid for \ " % s \ " " , value , key ) ) ; 
 - } 
 - } 
 - return result ; 
 + cfm . compressionParameters ( CompressionParameters . create ( compressionParameters ) ) ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index f0481f6 . . 387e694 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 144 , 6 + 144 , 7 @ @ cqlStatement returns [ ParsedStatement stmt ] 
 | st15 = grantStatement { $ stmt = st15 ; } 
 | st16 = revokeStatement { $ stmt = st16 ; } 
 | st17 = listGrantsStatement { $ stmt = st17 ; } 
 + | st18 = alterKeyspaceStatement { $ stmt = st18 ; } 
 ; 
 
 / * 
 @ @ - 341 , 8 + 342 , 9 @ @ batchStatementObjective returns [ ModificationStatement statement ] 
 * CREATE KEYSPACE < KEYSPACE > WITH attr1 = value1 AND attr2 = value2 ; 
 * / 
 createKeyspaceStatement returns [ CreateKeyspaceStatement expr ] 
 + @ init { KSPropDefs attrs = new KSPropDefs ( ) ; } 
 : K _ CREATE K _ KEYSPACE ks = keyspaceName 
 - K _ WITH props = properties { $ expr = new CreateKeyspaceStatement ( ks , props ) ; } 
 + K _ WITH properties [ attrs ] { $ expr = new CreateKeyspaceStatement ( ks , attrs ) ; } 
 ; 
 
 / * * 
 @ @ - 368 , 7 + 370 , 7 @ @ cfamColumns [ CreateColumnFamilyStatement . RawStatement expr ] 
 ; 
 
 cfamProperty [ CreateColumnFamilyStatement . RawStatement expr ] 
 - : k = property ' = ' v = propertyValue { $ expr . addProperty ( k , v ) ; } 
 + : k = propertyKey ' = ' v = propertyValue { try { $ expr . addProperty ( k , v ) ; } catch ( InvalidRequestException e ) { addRecognitionError ( e . getMessage ( ) ) ; } } 
 | K _ COMPACT K _ STORAGE { $ expr . setCompactStorage ( ) ; } 
 | K _ CLUSTERING K _ ORDER K _ BY ' ( ' cfamOrdering [ expr ] ( ' , ' cfamOrdering [ expr ] ) * ' ) ' 
 ; 
 @ @ - 387 , 6 + 389 , 16 @ @ createIndexStatement returns [ CreateIndexStatement expr ] 
 ; 
 
 / * * 
 + * ALTER KEYSPACE < KS > WITH < property > = < value > ; 
 + * / 
 + alterKeyspaceStatement returns [ AlterKeyspaceStatement expr ] 
 + @ init { KSPropDefs attrs = new KSPropDefs ( ) ; } 
 + : K _ ALTER K _ KEYSPACE ks = keyspaceName 
 + K _ WITH properties [ attrs ] { $ expr = new AlterKeyspaceStatement ( ks , attrs ) ; } 
 + ; 
 + 
 + 
 + / * * 
 * ALTER COLUMN FAMILY < CF > ALTER < column > TYPE < newtype > ; 
 * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; 
 * ALTER COLUMN FAMILY < CF > DROP < column > ; 
 @ @ - 395 , 13 + 407 , 13 @ @ createIndexStatement returns [ CreateIndexStatement expr ] 
 alterTableStatement returns [ AlterTableStatement expr ] 
 @ init { 
 AlterTableStatement . Type type = null ; 
 - props = new HashMap < String , String > ( ) ; 
 + CFPropDefs props = new CFPropDefs ( ) ; 
 } 
 : K _ ALTER K _ COLUMNFAMILY cf = columnFamilyName 
 ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } 
 | K _ ADD id = cident v = comparatorType { type = AlterTableStatement . Type . ADD ; } 
 | K _ DROP id = cident { type = AlterTableStatement . Type . DROP ; } 
 - | K _ WITH props = properties { type = AlterTableStatement . Type . OPTS ; } 
 + | K _ WITH properties [ props ] { type = AlterTableStatement . Type . OPTS ; } 
 ) 
 { 
 $ expr = new AlterTableStatement ( cf , type , id , v , props ) ; 
 @ @ - 545 , 7 + 557 , 15 @ @ termPairWithOperation [ Map < ColumnIdentifier , Operation > columns ] 
 ) 
 ; 
 
 - property returns [ String str ] 
 + properties [ PropertyDefinitions props ] 
 + : property [ props ] ( K _ AND property [ props ] ) * 
 + ; 
 + 
 + property [ PropertyDefinitions props ] 
 + : k = propertyKey ' = ' simple = propertyValue { try { $ props . addProperty ( k , simple ) ; } catch ( InvalidRequestException e ) { addRecognitionError ( e . getMessage ( ) ) ; } } 
 + ; 
 + 
 + propertyKey returns [ String str ] 
 @ init { StringBuilder sb = new StringBuilder ( ) ; } 
 : c1 = cident { sb . append ( c1 ) ; } ( ' : ' cn = cident { sb . append ( ' : ' ) . append ( cn ) ; } ) * { $ str = sb . toString ( ) ; } 
 ; 
 @ @ - 555 , 11 + 575 , 6 @ @ propertyValue returns [ String str ] 
 | u = unreserved _ keyword { $ str = u ; } 
 ; 
 
 - properties returns [ Map < String , String > props ] 
 - @ init { $ props = new HashMap < String , String > ( ) ; } 
 - : k1 = property ' = ' v1 = propertyValue { $ props . put ( k1 , v1 ) ; } ( K _ AND kn = property ' = ' vn = propertyValue { $ props . put ( kn , vn ) ; } ) * 
 - ; 
 - 
 relation returns [ Relation rel ] 
 : name = cident type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term { $ rel = new Relation ( $ name . id , $ type . text , $ t . term ) ; } 
 | K _ TOKEN ' ( ' name = cident ' ) ' type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = extendedTerm { $ rel = new Relation ( $ name . id , $ type . text , $ t . term , true ) ; } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / KSPropDefs . java b / src / java / org / apache / cassandra / cql3 / KSPropDefs . java 
 new file mode 100644 
 index 0000000 . . d480df4 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / KSPropDefs . java 
 @ @ - 0 , 0 + 1 , 89 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import java . util . * ; 
 + 
 + import org . apache . cassandra . config . KSMetaData ; 
 + import org . apache . cassandra . config . ConfigurationException ; 
 + import org . apache . cassandra . thrift . InvalidRequestException ; 
 + 
 + public class KSPropDefs extends PropertyDefinitions 
 + { 
 + public static final String KW _ DURABLE _ WRITES = " durable _ writes " ; 
 + 
 + public static final String KW _ REPLICATION _ STRATEGY = " strategy _ class " ; 
 + 
 + public static final Set < String > keywords = new HashSet < String > ( ) ; 
 + public static final Set < String > obsoleteKeywords = new HashSet < String > ( ) ; 
 + 
 + static 
 + { 
 + keywords . add ( KW _ DURABLE _ WRITES ) ; 
 + keywords . add ( KW _ REPLICATION _ STRATEGY ) ; 
 + } 
 + 
 + private String strategyClass ; 
 + private final Map < String , String > strategyOptions = new HashMap < String , String > ( ) ; 
 + 
 + public void validate ( ) throws ConfigurationException , InvalidRequestException 
 + { 
 + validate ( keywords , obsoleteKeywords ) ; 
 + 
 + if ( ! properties . containsKey ( " strategy _ class " ) ) 
 + throw new InvalidRequestException ( " missing required argument \ " strategy _ class \ " " ) ; 
 + strategyClass = properties . get ( " strategy _ class " ) ; 
 + } 
 + 
 + @ Override 
 + public void addProperty ( String name , String value ) throws InvalidRequestException 
 + { 
 + / / optional 
 + if ( name . contains ( " : " ) & & name . startsWith ( " strategy _ options " ) ) 
 + strategyOptions . put ( name . split ( " : " ) [ 1 ] , value ) ; 
 + else 
 + super . addProperty ( name , value ) ; 
 + } 
 + 
 + public String getReplicationStrategyClass ( ) 
 + { 
 + return strategyClass ; 
 + } 
 + 
 + public Map < String , String > getReplicationOptions ( ) 
 + { 
 + return strategyOptions ; 
 + } 
 + 
 + public KSMetaData asKSMetadata ( String ksName ) throws InvalidRequestException , ConfigurationException 
 + { 
 + return KSMetaData . newKeyspace ( ksName , getReplicationStrategyClass ( ) , getReplicationOptions ( ) , getBoolean ( KW _ DURABLE _ WRITES , true ) ) ; 
 + } 
 + 
 + public KSMetaData asKSMetadataUpdate ( KSMetaData old ) throws InvalidRequestException , ConfigurationException 
 + { 
 + String sClass = strategyClass ; 
 + Map < String , String > sOptions = getReplicationOptions ( ) ; 
 + if ( sClass = = null ) 
 + { 
 + sClass = old . strategyClass . getName ( ) ; 
 + sOptions = old . strategyOptions ; 
 + } 
 + return KSMetaData . newKeyspace ( old . name , sClass , sOptions , getBoolean ( KW _ DURABLE _ WRITES , old . durableWrites ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java b / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java 
 new file mode 100644 
 index 0000000 . . 75b8ba5 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / PropertyDefinitions . java 
 @ @ - 0 , 0 + 1 , 122 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import java . util . * ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . thrift . InvalidRequestException ; 
 + 
 + public class PropertyDefinitions 
 + { 
 + protected static final Logger logger = LoggerFactory . getLogger ( PropertyDefinitions . class ) ; 
 + 
 + protected final Map < String , String > properties = new HashMap < String , String > ( ) ; 
 + 
 + public void addProperty ( String name , String value ) throws InvalidRequestException 
 + { 
 + if ( properties . put ( name , value ) ! = null ) 
 + throw new InvalidRequestException ( String . format ( " Multiple definition for property ' % s ' " , name ) ) ; 
 + } 
 + 
 + public void validate ( Set < String > keywords , Set < String > obsolete ) throws InvalidRequestException 
 + { 
 + for ( String name : properties . keySet ( ) ) 
 + { 
 + if ( keywords . contains ( name ) ) 
 + continue ; 
 + 
 + if ( obsolete . contains ( name ) ) 
 + logger . warn ( " Ignoring obsolete property { } " , name ) ; 
 + else 
 + throw new InvalidRequestException ( String . format ( " Unknown property ' % s ' " , name ) ) ; 
 + } 
 + } 
 + 
 + protected String getSimple ( String name ) throws InvalidRequestException 
 + { 
 + return properties . get ( name ) ; 
 + } 
 + 
 + public Boolean hasProperty ( String name ) 
 + { 
 + return properties . containsKey ( name ) ; 
 + } 
 + 
 + public String getString ( String key , String defaultValue ) throws InvalidRequestException 
 + { 
 + String value = getSimple ( key ) ; 
 + return value ! = null ? value : defaultValue ; 
 + } 
 + 
 + / / Return a property value , typed as a Boolean 
 + public Boolean getBoolean ( String key , Boolean defaultValue ) throws InvalidRequestException 
 + { 
 + String value = getSimple ( key ) ; 
 + return ( value = = null ) ? defaultValue : value . toLowerCase ( ) . matches ( " ( 1 | true | yes ) " ) ; 
 + } 
 + 
 + / / Return a property value , typed as a Double 
 + public Double getDouble ( String key , Double defaultValue ) throws InvalidRequestException 
 + { 
 + String value = getSimple ( key ) ; 
 + if ( value = = null ) 
 + { 
 + return defaultValue ; 
 + } 
 + else 
 + { 
 + try 
 + { 
 + return Double . valueOf ( value ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new InvalidRequestException ( String . format ( " Invalid double value % s for ' % s ' " , value , key ) ) ; 
 + } 
 + } 
 + } 
 + 
 + / / Return a property value , typed as an Integer 
 + public Integer getInt ( String key , Integer defaultValue ) throws InvalidRequestException 
 + { 
 + String value = getSimple ( key ) ; 
 + return toInt ( key , value , defaultValue ) ; 
 + } 
 + 
 + public static Integer toInt ( String key , String value , Integer defaultValue ) throws InvalidRequestException 
 + { 
 + if ( value = = null ) 
 + { 
 + return defaultValue ; 
 + } 
 + else 
 + { 
 + try 
 + { 
 + return Integer . valueOf ( value ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new InvalidRequestException ( String . format ( " Invalid integer value % s for ' % s ' " , value , key ) ) ; 
 + } 
 + } 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java 
 new file mode 100644 
 index 0000000 . . 644fd24 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterKeyspaceStatement . java 
 @ @ - 0 , 0 + 1 , 95 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 . statements ; 
 + 
 + import org . apache . cassandra . auth . Permission ; 
 + import org . apache . cassandra . config . ConfigurationException ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . KSMetaData ; 
 + import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . cql3 . KSPropDefs ; 
 + import org . apache . cassandra . db . Table ; 
 + import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 + import org . apache . cassandra . service . ClientState ; 
 + import org . apache . cassandra . service . MigrationManager ; 
 + import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . thrift . InvalidRequestException ; 
 + import org . apache . cassandra . thrift . SchemaDisagreementException ; 
 + 
 + public class AlterKeyspaceStatement extends SchemaAlteringStatement 
 + { 
 + private final String name ; 
 + private final KSPropDefs attrs ; 
 + 
 + public AlterKeyspaceStatement ( String name , KSPropDefs attrs ) 
 + { 
 + super ( ) ; 
 + this . name = name ; 
 + this . attrs = attrs ; 
 + } 
 + 
 + public void checkAccess ( ClientState state ) throws InvalidRequestException 
 + { 
 + state . hasKeyspaceAccess ( name , Permission . ALTER ) ; 
 + } 
 + 
 + @ Override 
 + public void validate ( ClientState state ) throws InvalidRequestException , SchemaDisagreementException 
 + { 
 + super . validate ( state ) ; 
 + 
 + KSMetaData ksm = Schema . instance . getKSMetaData ( name ) ; 
 + if ( ksm = = null ) 
 + throw new InvalidRequestException ( " Unknown keyspace " + name ) ; 
 + if ( ksm . name . equalsIgnoreCase ( Table . SYSTEM _ TABLE ) ) 
 + throw new InvalidRequestException ( " Cannot alter system keyspace " ) ; 
 + 
 + try 
 + { 
 + attrs . validate ( ) ; 
 + 
 + if ( attrs . getReplicationStrategyClass ( ) = = null & & ! attrs . getReplicationOptions ( ) . isEmpty ( ) ) 
 + { 
 + throw new InvalidRequestException ( " Missing replication strategy class " ) ; 
 + } 
 + else if ( attrs . getReplicationStrategyClass ( ) ! = null ) 
 + { 
 + / / trial run to let ARS validate class + per - class options 
 + AbstractReplicationStrategy . createReplicationStrategy ( name , 
 + AbstractReplicationStrategy . getClass ( attrs . getReplicationStrategyClass ( ) ) , 
 + StorageService . instance . getTokenMetadata ( ) , 
 + DatabaseDescriptor . getEndpointSnitch ( ) , 
 + attrs . getReplicationOptions ( ) ) ; 
 + } 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + throw new InvalidRequestException ( e . getMessage ( ) ) ; 
 + } 
 + } 
 + 
 + public void announceMigration ( ) throws InvalidRequestException , ConfigurationException 
 + { 
 + KSMetaData ksm = Schema . instance . getKSMetaData ( name ) ; 
 + / / In the ( very ) unlikely case the keyspace was dropped since validate ( ) 
 + if ( ksm = = null ) 
 + throw new InvalidRequestException ( " Unknown keyspace " + name ) ; 
 + 
 + MigrationManager . announceKeyspaceUpdate ( attrs . asKSMetadataUpdate ( ksm ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 index 7867019 . . 965b27e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 @ @ - 23 , 9 + 23 , 7 @ @ import java . util . * ; 
 import org . apache . cassandra . auth . Permission ; 
 import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . config . * ; 
 - import org . apache . cassandra . db . marshal . AbstractType ; 
 - import org . apache . cassandra . db . marshal . CompositeType ; 
 - import org . apache . cassandra . db . marshal . CounterColumnType ; 
 + import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . MigrationManager ; 
 import org . apache . cassandra . thrift . InvalidRequestException ; 
 @ @ - 42 , 15 + 40 , 15 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 public final Type oType ; 
 public final String validator ; 
 public final ColumnIdentifier columnName ; 
 - private final CFPropDefs cfProps = new CFPropDefs ( ) ; 
 + private final CFPropDefs cfProps ; 
 
 - public AlterTableStatement ( CFName name , Type type , ColumnIdentifier columnName , String validator , Map < String , String > propertyMap ) 
 + public AlterTableStatement ( CFName name , Type type , ColumnIdentifier columnName , String validator , CFPropDefs cfProps ) 
 { 
 super ( name ) ; 
 this . oType = type ; 
 this . columnName = columnName ; 
 this . validator = validator ; / / used only for ADD / ALTER commands 
 - this . cfProps . addAll ( propertyMap ) ; 
 + this . cfProps = cfProps ; 
 } 
 
 public void checkAccess ( ClientState state ) throws InvalidRequestException 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java 
 index 763db28 . . 286f265 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateColumnFamilyStatement . java 
 @ @ - 108 , 14 + 108 , 7 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement 
 comparator , 
 null ) ; 
 
 - newCFMD . defaultValidator ( defaultValidator ) 
 - . columnMetadata ( getColumns ( ) ) 
 - . keyValidator ( keyValidator ) 
 - . keyAlias ( keyAlias ) 
 - . columnAliases ( columnAliases ) 
 - . valueAlias ( valueAlias ) ; 
 - 
 - properties . applyToCFMetadata ( newCFMD ) ; 
 + applyPropertiesTo ( newCFMD ) ; 
 } 
 catch ( ConfigurationException e ) 
 { 
 @ @ - 124 , 6 + 117 , 18 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement 
 return newCFMD ; 
 } 
 
 + public void applyPropertiesTo ( CFMetaData cfmd ) throws InvalidRequestException , ConfigurationException 
 + { 
 + cfmd . defaultValidator ( defaultValidator ) 
 + . columnMetadata ( getColumns ( ) ) 
 + . keyValidator ( keyValidator ) 
 + . keyAlias ( keyAlias ) 
 + . columnAliases ( columnAliases ) 
 + . valueAlias ( valueAlias ) ; 
 + 
 + properties . applyToCFMetadata ( cfmd ) ; 
 + } 
 + 
 public static class RawStatement extends CFStatement 
 { 
 private final Map < ColumnIdentifier , String > definitions = new HashMap < ColumnIdentifier , String > ( ) ; 
 @ @ - 277 , 7 + 282 , 7 @ @ public class CreateColumnFamilyStatement extends SchemaAlteringStatement 
 columnAliases . add ( alias ) ; 
 } 
 
 - public void addProperty ( String name , String value ) 
 + public void addProperty ( String name , String value ) throws InvalidRequestException 
 { 
 properties . addProperty ( name , value ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java 
 index 863a869 . . 9b36531 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateKeyspaceStatement . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . config . ConfigurationException ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . KSMetaData ; 
 import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . cql3 . KSPropDefs ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . MigrationManager ; 
 @ @ - 38 , 9 + 39 , 7 @ @ import org . apache . cassandra . thrift . ThriftValidation ; 
 public class CreateKeyspaceStatement extends SchemaAlteringStatement 
 { 
 private final String name ; 
 - private final Map < String , String > attrs ; 
 - private String strategyClass ; 
 - private Map < String , String > strategyOptions = new HashMap < String , String > ( ) ; 
 + private final KSPropDefs attrs ; 
 
 / * * 
 * Creates a new < code > CreateKeyspaceStatement < / code > instance for a given 
 @ @ - 49 , 7 + 48 , 7 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement 
 * @ param name the name of the keyspace to create 
 * @ param attrs map of the raw keyword arguments that followed the < code > WITH < / code > keyword . 
 * / 
 - public CreateKeyspaceStatement ( String name , Map < String , String > attrs ) 
 + public CreateKeyspaceStatement ( String name , KSPropDefs attrs ) 
 { 
 super ( ) ; 
 this . name = name ; 
 @ @ - 80 , 24 + 79 , 19 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement 
 if ( name . length ( ) > Schema . NAME _ LENGTH ) 
 throw new InvalidRequestException ( String . format ( " Keyspace names shouldn ' t be more than % s characters long ( got \ " % s \ " ) " , Schema . NAME _ LENGTH , name ) ) ; 
 
 - / / required 
 - if ( ! attrs . containsKey ( " strategy _ class " ) ) 
 - throw new InvalidRequestException ( " missing required argument \ " strategy _ class \ " " ) ; 
 - strategyClass = attrs . get ( " strategy _ class " ) ; 
 - 
 - / / optional 
 - for ( String key : attrs . keySet ( ) ) 
 - if ( ( key . contains ( " : " ) ) & & ( key . startsWith ( " strategy _ options " ) ) ) 
 - strategyOptions . put ( key . split ( " : " ) [ 1 ] , attrs . get ( key ) ) ; 
 - 
 - / / trial run to let ARS validate class + per - class options 
 try 
 { 
 + attrs . validate ( ) ; 
 + 
 + if ( attrs . getReplicationStrategyClass ( ) = = null ) 
 + throw new ConfigurationException ( " Missing mandatory replication strategy class " ) ; 
 + 
 + / / trial run to let ARS validate class + per - class options 
 AbstractReplicationStrategy . createReplicationStrategy ( name , 
 - AbstractReplicationStrategy . getClass ( strategyClass ) , 
 + AbstractReplicationStrategy . getClass ( attrs . getReplicationStrategyClass ( ) ) , 
 StorageService . instance . getTokenMetadata ( ) , 
 DatabaseDescriptor . getEndpointSnitch ( ) , 
 - strategyOptions ) ; 
 + attrs . getReplicationOptions ( ) ) ; 
 } 
 catch ( ConfigurationException e ) 
 { 
 @ @ - 107 , 8 + 101 , 7 @ @ public class CreateKeyspaceStatement extends SchemaAlteringStatement 
 
 public void announceMigration ( ) throws InvalidRequestException , ConfigurationException 
 { 
 - KSMetaData ksm = KSMetaData . newKeyspace ( name , strategyClass , strategyOptions ) ; 
 ThriftValidation . validateKeyspaceNotYetExisting ( name ) ; 
 - MigrationManager . announceNewKeyspace ( ksm ) ; 
 + MigrationManager . announceNewKeyspace ( attrs . asKSMetadata ( name ) ) ; 
 } 
 }
