BLEU SCORE: 1.0

TEST MSG: Fixed checkAvailableDiskSpace to properly recalculate expected disk usage of compaction task before reducing scope
GENERATED MSG: Fixed checkAvailableDiskSpace to properly recalculate expected disk usage of compaction task before reducing scope

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1b74dc7 . . 99f6613 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 110 , 6 + 110 , 7 @ @ <nl> * Restore resumable hints delivery ( CASSANDRA - 11960 ) <nl> * Properly report LWT contention ( CASSANDRA - 12626 ) <nl> Merged from 3 . 0 : <nl> + * CompactionTasks now correctly drops sstables out of compaction when not enough disk space is available ( CASSANDRA - 12979 ) <nl> * Replace empty strings with null values if they cannot be converted ( CASSANDRA - 12794 ) <nl> * Fix deserialization of 2 . x DeletedCells ( CASSANDRA - 12620 ) <nl> * Add parent repair session id to anticompaction log message ( CASSANDRA - 12186 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 9f376ff . . 7bccaae 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 24 , 6 + 24 , 9 @ @ Upgrading <nl> - Only Java and JavaScript are now supported UDF languages . <nl> The sandbox in 3 . 0 already prevented the use of script languages except Java <nl> and JavaScript . <nl> + - Compaction now correctly drops sstables out of CompactionTask when there <nl> + isn ' t enough disk space to perform the full compaction . This should reduce <nl> + pending compaction tasks on systems with little remaining disk space . <nl> <nl> 3 . 10 <nl> = = = = <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> index a9d6c7c . . b2e9b8c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java <nl> @ @ - 86 , 12 + 86 , 15 @ @ public class CompactionTask extends AbstractCompactionTask <nl> return transaction . originals ( ) . size ( ) ; <nl> } <nl> <nl> - public boolean reduceScopeForLimitedSpace ( ) <nl> + public boolean reduceScopeForLimitedSpace ( long expectedSize ) <nl> { <nl> if ( partialCompactionsAcceptable ( ) & & transaction . originals ( ) . size ( ) > 1 ) <nl> { <nl> / / Try again w / o the largest one . <nl> - logger . warn ( " Insufficient space to compact all requested files { } " , StringUtils . join ( transaction . originals ( ) , " , " ) ) ; <nl> + logger . warn ( " insufficient space to compact all requested files . { } MB required , { } " , <nl> + ( float ) expectedSize / 1024 / 1024 , <nl> + StringUtils . join ( transaction . originals ( ) , " , " ) ) ; <nl> + <nl> / / Note that we have removed files that are still marked as compacting . <nl> / / This suboptimal but ok since the caller will unmark all the sstables at the end . <nl> SSTableReader removedSSTable = cfs . getMaxSizeFile ( transaction . originals ( ) ) ; <nl> @ @ - 124 , 9 + 127 , 8 @ @ public class CompactionTask extends AbstractCompactionTask <nl> <nl> / / note that we need to do a rough estimate early if we can fit the compaction on disk - this is pessimistic , but <nl> / / since we might remove sstables from the compaction in checkAvailableDiskSpace it needs to be done here <nl> - long expectedWriteSize = cfs . getExpectedCompactedFileSize ( transaction . originals ( ) , compactionType ) ; <nl> - long earlySSTableEstimate = Math . max ( 1 , expectedWriteSize / strategy . getMaxSSTableBytes ( ) ) ; <nl> - checkAvailableDiskSpace ( earlySSTableEstimate , expectedWriteSize ) ; <nl> + <nl> + checkAvailableDiskSpace ( ) ; <nl> <nl> / / sanity check : all sstables must belong to the same cfs <nl> assert ! Iterables . any ( transaction . originals ( ) , new Predicate < SSTableReader > ( ) <nl> @ @ - 317 , 7 + 319 , 12 @ @ public class CompactionTask extends AbstractCompactionTask <nl> return minRepairedAt ; <nl> } <nl> <nl> - protected void checkAvailableDiskSpace ( long estimatedSSTables , long expectedWriteSize ) <nl> + / * <nl> + Checks if we have enough disk space to execute the compaction . Drops the largest sstable out of the Task until <nl> + there ' s enough space ( in theory ) to handle the compaction . Does not take into account space that will be taken by <nl> + other compactions . <nl> + * / <nl> + protected void checkAvailableDiskSpace ( ) <nl> { <nl> if ( ! cfs . isCompactionDiskSpaceCheckEnabled ( ) & & compactionType = = OperationType . COMPACTION ) <nl> { <nl> @ @ - 325 , 10 + 332 , 26 @ @ public class CompactionTask extends AbstractCompactionTask <nl> return ; <nl> } <nl> <nl> - while ( ! getDirectories ( ) . hasAvailableDiskSpace ( estimatedSSTables , expectedWriteSize ) ) <nl> + CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; <nl> + <nl> + while ( true ) <nl> { <nl> - if ( ! reduceScopeForLimitedSpace ( ) ) <nl> - throw new RuntimeException ( String . format ( " Not enough space for compaction , estimated sstables = % d , expected write size = % d " , estimatedSSTables , expectedWriteSize ) ) ; <nl> + long expectedWriteSize = cfs . getExpectedCompactedFileSize ( transaction . originals ( ) , compactionType ) ; <nl> + long estimatedSSTables = Math . max ( 1 , expectedWriteSize / strategy . getMaxSSTableBytes ( ) ) ; <nl> + <nl> + if ( cfs . getDirectories ( ) . hasAvailableDiskSpace ( estimatedSSTables , expectedWriteSize ) ) <nl> + break ; <nl> + <nl> + if ( ! reduceScopeForLimitedSpace ( expectedWriteSize ) ) <nl> + { <nl> + / / we end up here if we can ' t take any more sstables out of the compaction . <nl> + / / usually means we ' ve run out of disk space <nl> + String msg = String . format ( " Not enough space for compaction , estimated sstables = % d , expected write size = % d " , estimatedSSTables , expectedWriteSize ) ; <nl> + logger . warn ( msg ) ; <nl> + throw new RuntimeException ( msg ) ; <nl> + } <nl> + logger . warn ( " Not enough space for compaction , { } MB estimated . Reducing scope . " , <nl> + ( float ) expectedWriteSize / 1024 / 1024 ) ; <nl> } <nl> } <nl>
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1b74dc7 . . 99f6613 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 110 , 6 + 110 , 7 @ @ 
 * Restore resumable hints delivery ( CASSANDRA - 11960 ) 
 * Properly report LWT contention ( CASSANDRA - 12626 ) 
 Merged from 3 . 0 : 
 + * CompactionTasks now correctly drops sstables out of compaction when not enough disk space is available ( CASSANDRA - 12979 ) 
 * Replace empty strings with null values if they cannot be converted ( CASSANDRA - 12794 ) 
 * Fix deserialization of 2 . x DeletedCells ( CASSANDRA - 12620 ) 
 * Add parent repair session id to anticompaction log message ( CASSANDRA - 12186 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 9f376ff . . 7bccaae 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 24 , 6 + 24 , 9 @ @ Upgrading 
 - Only Java and JavaScript are now supported UDF languages . 
 The sandbox in 3 . 0 already prevented the use of script languages except Java 
 and JavaScript . 
 + - Compaction now correctly drops sstables out of CompactionTask when there 
 + isn ' t enough disk space to perform the full compaction . This should reduce 
 + pending compaction tasks on systems with little remaining disk space . 
 
 3 . 10 
 = = = = 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 index a9d6c7c . . b2e9b8c 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionTask . java 
 @ @ - 86 , 12 + 86 , 15 @ @ public class CompactionTask extends AbstractCompactionTask 
 return transaction . originals ( ) . size ( ) ; 
 } 
 
 - public boolean reduceScopeForLimitedSpace ( ) 
 + public boolean reduceScopeForLimitedSpace ( long expectedSize ) 
 { 
 if ( partialCompactionsAcceptable ( ) & & transaction . originals ( ) . size ( ) > 1 ) 
 { 
 / / Try again w / o the largest one . 
 - logger . warn ( " Insufficient space to compact all requested files { } " , StringUtils . join ( transaction . originals ( ) , " , " ) ) ; 
 + logger . warn ( " insufficient space to compact all requested files . { } MB required , { } " , 
 + ( float ) expectedSize / 1024 / 1024 , 
 + StringUtils . join ( transaction . originals ( ) , " , " ) ) ; 
 + 
 / / Note that we have removed files that are still marked as compacting . 
 / / This suboptimal but ok since the caller will unmark all the sstables at the end . 
 SSTableReader removedSSTable = cfs . getMaxSizeFile ( transaction . originals ( ) ) ; 
 @ @ - 124 , 9 + 127 , 8 @ @ public class CompactionTask extends AbstractCompactionTask 
 
 / / note that we need to do a rough estimate early if we can fit the compaction on disk - this is pessimistic , but 
 / / since we might remove sstables from the compaction in checkAvailableDiskSpace it needs to be done here 
 - long expectedWriteSize = cfs . getExpectedCompactedFileSize ( transaction . originals ( ) , compactionType ) ; 
 - long earlySSTableEstimate = Math . max ( 1 , expectedWriteSize / strategy . getMaxSSTableBytes ( ) ) ; 
 - checkAvailableDiskSpace ( earlySSTableEstimate , expectedWriteSize ) ; 
 + 
 + checkAvailableDiskSpace ( ) ; 
 
 / / sanity check : all sstables must belong to the same cfs 
 assert ! Iterables . any ( transaction . originals ( ) , new Predicate < SSTableReader > ( ) 
 @ @ - 317 , 7 + 319 , 12 @ @ public class CompactionTask extends AbstractCompactionTask 
 return minRepairedAt ; 
 } 
 
 - protected void checkAvailableDiskSpace ( long estimatedSSTables , long expectedWriteSize ) 
 + / * 
 + Checks if we have enough disk space to execute the compaction . Drops the largest sstable out of the Task until 
 + there ' s enough space ( in theory ) to handle the compaction . Does not take into account space that will be taken by 
 + other compactions . 
 + * / 
 + protected void checkAvailableDiskSpace ( ) 
 { 
 if ( ! cfs . isCompactionDiskSpaceCheckEnabled ( ) & & compactionType = = OperationType . COMPACTION ) 
 { 
 @ @ - 325 , 10 + 332 , 26 @ @ public class CompactionTask extends AbstractCompactionTask 
 return ; 
 } 
 
 - while ( ! getDirectories ( ) . hasAvailableDiskSpace ( estimatedSSTables , expectedWriteSize ) ) 
 + CompactionStrategyManager strategy = cfs . getCompactionStrategyManager ( ) ; 
 + 
 + while ( true ) 
 { 
 - if ( ! reduceScopeForLimitedSpace ( ) ) 
 - throw new RuntimeException ( String . format ( " Not enough space for compaction , estimated sstables = % d , expected write size = % d " , estimatedSSTables , expectedWriteSize ) ) ; 
 + long expectedWriteSize = cfs . getExpectedCompactedFileSize ( transaction . originals ( ) , compactionType ) ; 
 + long estimatedSSTables = Math . max ( 1 , expectedWriteSize / strategy . getMaxSSTableBytes ( ) ) ; 
 + 
 + if ( cfs . getDirectories ( ) . hasAvailableDiskSpace ( estimatedSSTables , expectedWriteSize ) ) 
 + break ; 
 + 
 + if ( ! reduceScopeForLimitedSpace ( expectedWriteSize ) ) 
 + { 
 + / / we end up here if we can ' t take any more sstables out of the compaction . 
 + / / usually means we ' ve run out of disk space 
 + String msg = String . format ( " Not enough space for compaction , estimated sstables = % d , expected write size = % d " , estimatedSSTables , expectedWriteSize ) ; 
 + logger . warn ( msg ) ; 
 + throw new RuntimeException ( msg ) ; 
 + } 
 + logger . warn ( " Not enough space for compaction , { } MB estimated . Reducing scope . " , 
 + ( float ) expectedWriteSize / 1024 / 1024 ) ; 
 } 
 } 


NEAREST DIFF:
ELIMINATEDSENTENCE
