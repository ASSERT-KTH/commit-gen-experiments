BLEU SCORE: 0.031085583786586417

TEST MSG: ( Hadoop ) fix cluster initialisation for a split fetching
GENERATED MSG: fix strange line endings and indentation so we can apply patches sanely .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 17c0671 . . 71cfca0 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 10 <nl> + * ( Hadoop ) fix cluster initialisation for a split fetching ( CASSANDRA - 7774 ) <nl> * Configure system . paxos with LeveledCompactionStrategy ( CASSANDRA - 7753 ) <nl> * Fix ALTER clustering column type from DateType to TimestampType when <nl> using DESC clustering order ( CASSANRDA - 7797 ) <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> index e894996 . . 137bddf 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> @ @ - 288 , 16 + 288 , 22 @ @ public class CqlConfigHelper <nl> <nl> public static Cluster getInputCluster ( String host , Configuration conf ) <nl> { <nl> + / / this method has been left for backward compatibility <nl> + return getInputCluster ( new String [ ] { host } , conf ) ; <nl> + } <nl> + <nl> + public static Cluster getInputCluster ( String [ ] hosts , Configuration conf ) <nl> + { <nl> int port = getInputNativePort ( conf ) ; <nl> Optional < AuthProvider > authProvider = getAuthProvider ( conf ) ; <nl> Optional < SSLOptions > sslOptions = getSSLOptions ( conf ) ; <nl> - LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , host ) ; <nl> + LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , hosts ) ; <nl> SocketOptions socketOptions = getReadSocketOptions ( conf ) ; <nl> QueryOptions queryOptions = getReadQueryOptions ( conf ) ; <nl> PoolingOptions poolingOptions = getReadPoolingOptions ( conf ) ; <nl> <nl> Cluster . Builder builder = Cluster . builder ( ) <nl> - . addContactPoint ( host ) <nl> + . addContactPoints ( hosts ) <nl> . withPort ( port ) <nl> . withCompression ( ProtocolOptions . Compression . NONE ) ; <nl> <nl> @ @ - 480 , 84 + 486 , 9 @ @ public class CqlConfigHelper <nl> return socketOptions ; <nl> } <nl> <nl> - private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String stickHost ) <nl> + private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String [ ] stickHosts ) <nl> { <nl> - return new LoadBalancingPolicy ( ) <nl> - { <nl> - private Host origHost ; <nl> - private Set < Host > liveRemoteHosts = Sets . newHashSet ( ) ; <nl> - <nl> - @ Override <nl> - public void onAdd ( Host host ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - origHost = host ; <nl> - } <nl> - <nl> - @ Override <nl> - public void onDown ( Host host ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - origHost = null ; <nl> - liveRemoteHosts . remove ( host ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public void onRemove ( Host host ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - origHost = null ; <nl> - liveRemoteHosts . remove ( host ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public void onUp ( Host host ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - origHost = host ; <nl> - liveRemoteHosts . add ( host ) ; <nl> - } <nl> - <nl> - @ Override <nl> - public void onSuspected ( Host host ) <nl> - { <nl> - } <nl> - <nl> - @ Override <nl> - public HostDistance distance ( Host host ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - return HostDistance . LOCAL ; <nl> - else <nl> - return HostDistance . REMOTE ; <nl> - } <nl> - <nl> - @ Override <nl> - public void init ( Cluster cluster , Collection < Host > hosts ) <nl> - { <nl> - for ( Host host : hosts ) <nl> - { <nl> - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) <nl> - { <nl> - origHost = host ; <nl> - break ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - @ Override <nl> - public Iterator < Host > newQueryPlan ( String loggedKeyspace , Statement statement ) <nl> - { <nl> - if ( origHost ! = null ) <nl> - { <nl> - return Iterators . concat ( Collections . singletonList ( origHost ) . iterator ( ) , liveRemoteHosts . iterator ( ) ) ; <nl> - } <nl> - else <nl> - { <nl> - return liveRemoteHosts . iterator ( ) ; <nl> - } <nl> - } <nl> - } ; <nl> + return new LimitedLocalNodeFirstLocalBalancingPolicy ( stickHosts ) ; <nl> } <nl> <nl> private static Optional < AuthProvider > getAuthProvider ( Configuration conf ) <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java <nl> index 9167ac3 . . 3eab7c0 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java <nl> @ @ - 124 , 24 + 124 , 9 @ @ public class CqlRecordReader extends RecordReader < Long , Row > <nl> if ( cluster ! = null ) <nl> return ; <nl> <nl> - / / create connection using thrift <nl> + / / create a Cluster instance <nl> String [ ] locations = split . getLocations ( ) ; <nl> - Exception lastException = null ; <nl> - for ( String location : locations ) <nl> - { <nl> - try <nl> - { <nl> - cluster = CqlConfigHelper . getInputCluster ( location , conf ) ; <nl> - break ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - lastException = e ; <nl> - logger . warn ( " Failed to create authenticated client to { } " , location ) ; <nl> - } <nl> - } <nl> - if ( cluster = = null & & lastException ! = null ) <nl> - throw lastException ; <nl> + cluster = CqlConfigHelper . getInputCluster ( locations , conf ) ; <nl> } <nl> catch ( Exception e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java b / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java <nl> new file mode 100644 <nl> index 0000000 . . 3aa7df0 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java <nl> @ @ - 0 , 0 + 1 , 185 @ @ <nl> + package org . apache . cassandra . hadoop . cql3 ; <nl> + <nl> + import com . datastax . driver . core . Cluster ; <nl> + import com . datastax . driver . core . Host ; <nl> + import com . datastax . driver . core . HostDistance ; <nl> + import com . datastax . driver . core . Statement ; <nl> + import com . datastax . driver . core . policies . LoadBalancingPolicy ; <nl> + import com . google . common . base . Function ; <nl> + import com . google . common . collect . Iterators ; <nl> + import com . google . common . collect . Sets ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . NetworkInterface ; <nl> + import java . net . SocketException ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . * ; <nl> + import java . util . concurrent . CopyOnWriteArraySet ; <nl> + <nl> + / * * <nl> + * This load balancing policy is intended to be used only for CqlRecordReader when it fetches a particular split . <nl> + * < p / > <nl> + * It chooses alive hosts only from the set of the given replicas - because the connection is used to load the data from <nl> + * the particular split , with a strictly defined list of the replicas , it is pointless to try the other nodes . <nl> + * The policy tracks which of the replicas are alive , and when a new query plan is requested , it returns those replicas <nl> + * in the following order : <nl> + * < ul > <nl> + * < li > the local node < / li > <nl> + * < li > the collection of the remaining hosts ( which is shuffled on each request ) < / li > <nl> + * < / ul > <nl> + * / <nl> + class LimitedLocalNodeFirstLocalBalancingPolicy implements LoadBalancingPolicy <nl> + { <nl> + private final static Logger logger = LoggerFactory . getLogger ( LimitedLocalNodeFirstLocalBalancingPolicy . class ) ; <nl> + <nl> + private final static Set < InetAddress > localAddresses = Collections . unmodifiableSet ( getLocalInetAddresses ( ) ) ; <nl> + <nl> + private final CopyOnWriteArraySet < Host > liveReplicaHosts = new CopyOnWriteArraySet < > ( ) ; <nl> + <nl> + private final Set < InetAddress > replicaAddresses = new HashSet < > ( ) ; <nl> + <nl> + public LimitedLocalNodeFirstLocalBalancingPolicy ( String [ ] replicas ) <nl> + { <nl> + for ( String replica : replicas ) <nl> + { <nl> + try <nl> + { <nl> + InetAddress [ ] addresses = InetAddress . getAllByName ( replica ) ; <nl> + Collections . addAll ( replicaAddresses , addresses ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + logger . warn ( " Invalid replica host name : { } , skipping it " , replica ) ; <nl> + } <nl> + } <nl> + logger . debug ( " Created instance with the following replicas : { } " , Arrays . asList ( replicas ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void init ( Cluster cluster , Collection < Host > hosts ) <nl> + { <nl> + List < Host > replicaHosts = new ArrayList < > ( ) ; <nl> + for ( Host host : hosts ) <nl> + { <nl> + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) <nl> + { <nl> + replicaHosts . add ( host ) ; <nl> + } <nl> + } <nl> + liveReplicaHosts . addAll ( replicaHosts ) ; <nl> + logger . debug ( " Initialized with replica hosts : { } " , replicaHosts ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public HostDistance distance ( Host host ) <nl> + { <nl> + if ( isLocalHost ( host ) ) <nl> + { <nl> + return HostDistance . LOCAL ; <nl> + } <nl> + else <nl> + { <nl> + return HostDistance . REMOTE ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < Host > newQueryPlan ( String keyspace , Statement statement ) <nl> + { <nl> + List < Host > local = new ArrayList < > ( 1 ) ; <nl> + List < Host > remote = new ArrayList < > ( liveReplicaHosts . size ( ) ) ; <nl> + for ( Host liveReplicaHost : liveReplicaHosts ) <nl> + { <nl> + if ( isLocalHost ( liveReplicaHost ) ) <nl> + { <nl> + local . add ( liveReplicaHost ) ; <nl> + } <nl> + else <nl> + { <nl> + remote . add ( liveReplicaHost ) ; <nl> + } <nl> + } <nl> + <nl> + Collections . shuffle ( remote ) ; <nl> + <nl> + logger . debug ( " Using the following hosts order for the new query plan : { } | { } " , local , remote ) ; <nl> + <nl> + return Iterators . concat ( local . iterator ( ) , remote . iterator ( ) ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void onAdd ( Host host ) <nl> + { <nl> + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) <nl> + { <nl> + liveReplicaHosts . add ( host ) ; <nl> + logger . debug ( " Added a new host { } " , host ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onUp ( Host host ) <nl> + { <nl> + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) <nl> + { <nl> + liveReplicaHosts . add ( host ) ; <nl> + logger . debug ( " The host { } is now up " , host ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onDown ( Host host ) <nl> + { <nl> + if ( liveReplicaHosts . remove ( host ) ) <nl> + { <nl> + logger . debug ( " The host { } is now down " , host ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + @ Override <nl> + public void onRemove ( Host host ) <nl> + { <nl> + if ( liveReplicaHosts . remove ( host ) ) <nl> + { <nl> + logger . debug ( " Removed the host { } " , host ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void onSuspected ( Host host ) <nl> + { <nl> + / / not supported by this load balancing policy <nl> + } <nl> + <nl> + private static boolean isLocalHost ( Host host ) <nl> + { <nl> + InetAddress hostAddress = host . getAddress ( ) ; <nl> + return hostAddress . isLoopbackAddress ( ) | | localAddresses . contains ( hostAddress ) ; <nl> + } <nl> + <nl> + private static Set < InetAddress > getLocalInetAddresses ( ) <nl> + { <nl> + try <nl> + { <nl> + return Sets . newHashSet ( Iterators . concat ( <nl> + Iterators . transform ( <nl> + Iterators . forEnumeration ( NetworkInterface . getNetworkInterfaces ( ) ) , <nl> + new Function < NetworkInterface , Iterator < InetAddress > > ( ) <nl> + { <nl> + @ Override <nl> + public Iterator < InetAddress > apply ( NetworkInterface netIface ) <nl> + { <nl> + return Iterators . forEnumeration ( netIface . getInetAddresses ( ) ) ; <nl> + } <nl> + } ) ) ) ; <nl> + } <nl> + catch ( SocketException e ) <nl> + { <nl> + logger . warn ( " Could not retrieve local network interfaces . " , e ) ; <nl> + return Collections . emptySet ( ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / org / apache / cassandra / net / EndPoint . java b / src / org / apache / cassandra / net / EndPoint . java <nl> index 2dda419 . . 03d9f56 100644 <nl> - - - a / src / org / apache / cassandra / net / EndPoint . java <nl> + + + b / src / org / apache / cassandra / net / EndPoint . java <nl> @ @ - 1 + 1 , 180 @ @ <nl> - / * * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> * or more contributor license agreements . See the NOTICE file <nl> * distributed with this work for additional information <nl> * regarding copyright ownership . The ASF licenses this file <nl> * to you under the Apache License , Version 2 . 0 ( the <nl> * " License " ) ; you may not use this file except in compliance <nl> * with the License . You may obtain a copy of the License at <nl> * <nl> * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> * <nl> * Unless required by applicable law or agreed to in writing , software <nl> * distributed under the License is distributed on an " AS IS " BASIS , <nl> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> * See the License for the specific language governing permissions and <nl> * limitations under the License . <nl> * / <nl> <nl> package org . apache . cassandra . net ; <nl> <nl> <nl> import java . io . IOException ; <nl> import java . io . Serializable ; <nl> import java . net . * ; <nl> import java . nio . ByteBuffer ; <nl> import java . nio . CharBuffer ; <nl> import java . util . HashMap ; <nl> import java . util . Map ; <nl> <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . LogUtil ; <nl> import org . apache . log4j . Logger ; <nl> <nl> / * * <nl> * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) <nl> * / <nl> <nl> public class EndPoint implements Serializable , Comparable < EndPoint > <nl> { <nl> 	 / / logging and profiling . <nl> 	 private static Logger logger _ = Logger . getLogger ( EndPoint . class ) ; <nl> 	 private static final long serialVersionUID = - 4962625949179835907L ; <nl> 	 private static Map < CharBuffer , String > hostNames _ = new HashMap < CharBuffer , String > ( ) ; <nl> protected static final int randomPort _ = 5555 ; <nl> public static EndPoint randomLocalEndPoint _ ; <nl> <nl> static <nl> { <nl> try <nl> { <nl> randomLocalEndPoint _ = new EndPoint ( FBUtilities . getHostName ( ) , EndPoint . randomPort _ ) ; <nl> } <nl> catch ( IOException ex ) <nl> { <nl> logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; <nl> } <nl> } <nl> <nl> 	 private String host _ ; <nl> 	 private int port _ ; <nl> <nl> 	 private transient InetSocketAddress ia _ ; <nl> <nl> 	 / * Ctor for JAXB . DO NOT DELETE * / <nl> 	 private EndPoint ( ) <nl> 	 { <nl> 	 } <nl> <nl> 	 public EndPoint ( String host , int port ) <nl> 	 { <nl> 	 	 / * <nl> 	 	 * Attempts to resolve the host , but does not fail if it cannot . <nl> 	 	 * / <nl> 	 	 host _ = host ; <nl> 	 	 port _ = port ; <nl> 	 } <nl> <nl> 	 / / create a local endpoint id <nl> 	 public EndPoint ( int port ) <nl> 	 { <nl> 	 	 try <nl> 	 	 { <nl> 	 	 	 host _ = FBUtilities . getHostName ( ) ; <nl> 	 	 	 port _ = port ; <nl> 	 	 } <nl> 	 	 catch ( UnknownHostException e ) <nl> 	 	 { <nl> 	 	 	 logger _ . warn ( LogUtil . throwableToString ( e ) ) ; <nl> 	 	 } <nl> 	 } <nl> <nl> 	 public String getHost ( ) <nl> 	 { <nl> 	 	 return host _ ; <nl> 	 } <nl> <nl> 	 public int getPort ( ) <nl> 	 { <nl> 	 	 return port _ ; <nl> 	 } <nl> <nl> 	 public void setPort ( int port ) <nl> 	 { <nl> 	 	 port _ = port ; <nl> 	 } <nl> <nl> 	 public InetSocketAddress getInetAddress ( ) <nl> 	 { <nl> 	 	 if ( ia _ = = null | | ia _ . isUnresolved ( ) ) <nl> 	 	 { <nl> 	 	 	 ia _ = new InetSocketAddress ( host _ , port _ ) ; <nl> 	 	 } <nl> 	 	 return ia _ ; <nl> 	 } <nl> <nl> 	 public boolean equals ( Object o ) <nl> 	 { <nl> 	 	 if ( ! ( o instanceof EndPoint ) ) <nl> 	 	 	 return false ; <nl> <nl> 	 	 EndPoint rhs = ( EndPoint ) o ; <nl> 	 	 return ( host _ . equals ( rhs . host _ ) & & port _ = = rhs . port _ ) ; <nl> 	 } <nl> <nl> 	 public int hashCode ( ) <nl> 	 { <nl> 	 	 return ( host _ + port _ ) . hashCode ( ) ; <nl> 	 } <nl> <nl> 	 public int compareTo ( EndPoint rhs ) <nl> 	 { <nl> 	 	 return host _ . compareTo ( rhs . host _ ) ; <nl> 	 } <nl> <nl> 	 public String toString ( ) <nl> 	 { <nl> 	 	 return ( host _ + " : " + port _ ) ; <nl> 	 } <nl> <nl> 	 public static EndPoint fromString ( String str ) <nl> 	 { <nl> 	 	 String [ ] values = str . split ( " : " ) ; <nl> 	 	 return new EndPoint ( values [ 0 ] , Integer . parseInt ( values [ 1 ] ) ) ; <nl> 	 } <nl> <nl> 	 public static byte [ ] toBytes ( EndPoint ep ) <nl> 	 { <nl> 	 	 ByteBuffer buffer = ByteBuffer . allocate ( 6 ) ; <nl> 	 	 byte [ ] iaBytes = ep . getInetAddress ( ) . getAddress ( ) . getAddress ( ) ; <nl> 	 	 buffer . put ( iaBytes ) ; <nl> 	 	 buffer . put ( MessagingService . toByteArray ( ( short ) ep . getPort ( ) ) ) ; <nl> 	 	 buffer . flip ( ) ; <nl> 	 	 return buffer . array ( ) ; <nl> 	 } <nl> <nl> 	 public static EndPoint fromBytes ( byte [ ] bytes ) <nl> 	 { <nl> 	 	 ByteBuffer buffer = ByteBuffer . allocate ( 4 ) ; <nl> 	 	 System . arraycopy ( bytes , 0 , buffer . array ( ) , 0 , 4 ) ; <nl> 	 	 byte [ ] portBytes = new byte [ 2 ] ; <nl> 	 	 System . arraycopy ( bytes , 4 , portBytes , 0 , portBytes . length ) ; <nl> 	 	 try <nl> 	 	 { <nl> 	 	 	 CharBuffer charBuffer = buffer . asCharBuffer ( ) ; <nl> 	 	 	 String host = hostNames _ . get ( charBuffer ) ; <nl> 	 	 	 if ( host = = null ) <nl> 	 	 	 { 	 	 	 	 <nl> 	 	 	 	 host = InetAddress . getByAddress ( buffer . array ( ) ) . getHostName ( ) ; 	 	 	 	 <nl> 	 	 	 	 hostNames _ . put ( charBuffer , host ) ; <nl> 	 	 	 } <nl> 	 	 	 int port = ( int ) MessagingService . byteArrayToShort ( portBytes ) ; <nl> 	 	 	 return new EndPoint ( host , port ) ; <nl> 	 	 } <nl> 	 	 catch ( UnknownHostException e ) <nl> 	 	 { <nl> 	 	 	 throw new IllegalArgumentException ( e ) ; <nl> 	 	 } <nl> 	 } <nl> } <nl> <nl> \ No newline at end of file <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + <nl> + import java . io . IOException ; <nl> + import java . io . Serializable ; <nl> + import java . net . * ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . nio . CharBuffer ; <nl> + import java . util . HashMap ; <nl> + import java . util . Map ; <nl> + <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . LogUtil ; <nl> + import org . apache . log4j . Logger ; <nl> + <nl> + / * * <nl> + * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) <nl> + * / <nl> + <nl> + public class EndPoint implements Serializable , Comparable < EndPoint > <nl> + { <nl> + / / logging and profiling . <nl> + private static Logger logger _ = Logger . getLogger ( EndPoint . class ) ; <nl> + private static final long serialVersionUID = - 4962625949179835907L ; <nl> + private static Map < CharBuffer , String > hostNames _ = new HashMap < CharBuffer , String > ( ) ; <nl> + protected static final int randomPort _ = 5555 ; <nl> + public static EndPoint randomLocalEndPoint _ ; <nl> + <nl> + static <nl> + { <nl> + try <nl> + { <nl> + randomLocalEndPoint _ = new EndPoint ( FBUtilities . getHostName ( ) , EndPoint . randomPort _ ) ; <nl> + } <nl> + catch ( IOException ex ) <nl> + { <nl> + logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; <nl> + } <nl> + } <nl> + <nl> + private String host _ ; <nl> + private int port _ ; <nl> + <nl> + private transient InetSocketAddress ia _ ; <nl> + <nl> + / * Ctor for JAXB . DO NOT DELETE * / <nl> + private EndPoint ( ) <nl> + { <nl> + } <nl> + <nl> + public EndPoint ( String host , int port ) <nl> + { <nl> + / * <nl> + * Attempts to resolve the host , but does not fail if it cannot . <nl> + * / <nl> + host _ = host ; <nl> + port _ = port ; <nl> + } <nl> + <nl> + / / create a local endpoint id <nl> + public EndPoint ( int port ) <nl> + { <nl> + try <nl> + { <nl> + host _ = FBUtilities . getHostName ( ) ; <nl> + port _ = port ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + logger _ . warn ( LogUtil . throwableToString ( e ) ) ; <nl> + } <nl> + } <nl> + <nl> + public String getHost ( ) <nl> + { <nl> + return host _ ; <nl> + } <nl> + <nl> + public int getPort ( ) <nl> + { <nl> + return port _ ; <nl> + } <nl> + <nl> + public void setPort ( int port ) <nl> + { <nl> + port _ = port ; <nl> + } <nl> + <nl> + public InetSocketAddress getInetAddress ( ) <nl> + { <nl> + if ( ia _ = = null | | ia _ . isUnresolved ( ) ) <nl> + { <nl> + ia _ = new InetSocketAddress ( host _ , port _ ) ; <nl> + } <nl> + return ia _ ; <nl> + } <nl> + <nl> + public boolean equals ( Object o ) <nl> + { <nl> + if ( ! ( o instanceof EndPoint ) ) <nl> + return false ; <nl> + <nl> + EndPoint rhs = ( EndPoint ) o ; <nl> + return ( host _ . equals ( rhs . host _ ) & & port _ = = rhs . port _ ) ; <nl> + } <nl> + <nl> + public int hashCode ( ) <nl> + { <nl> + return ( host _ + port _ ) . hashCode ( ) ; <nl> + } <nl> + <nl> + public int compareTo ( EndPoint rhs ) <nl> + { <nl> + return host _ . compareTo ( rhs . host _ ) ; <nl> + } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + return ( host _ + " : " + port _ ) ; <nl> + } <nl> + <nl> + public static EndPoint fromString ( String str ) <nl> + { <nl> + String [ ] values = str . split ( " : " ) ; <nl> + return new EndPoint ( values [ 0 ] , Integer . parseInt ( values [ 1 ] ) ) ; <nl> + } <nl> + <nl> + public static byte [ ] toBytes ( EndPoint ep ) <nl> + { <nl> + ByteBuffer buffer = ByteBuffer . allocate ( 6 ) ; <nl> + byte [ ] iaBytes = ep . getInetAddress ( ) . getAddress ( ) . getAddress ( ) ; <nl> + buffer . put ( iaBytes ) ; <nl> + buffer . put ( MessagingService . toByteArray ( ( short ) ep . getPort ( ) ) ) ; <nl> + buffer . flip ( ) ; <nl> + return buffer . array ( ) ; <nl> + } <nl> + <nl> + public static EndPoint fromBytes ( byte [ ] bytes ) <nl> + { <nl> + ByteBuffer buffer = ByteBuffer . allocate ( 4 ) ; <nl> + System . arraycopy ( bytes , 0 , buffer . array ( ) , 0 , 4 ) ; <nl> + byte [ ] portBytes = new byte [ 2 ] ; <nl> + System . arraycopy ( bytes , 4 , portBytes , 0 , portBytes . length ) ; <nl> + try <nl> + { <nl> + CharBuffer charBuffer = buffer . asCharBuffer ( ) ; <nl> + String host = hostNames _ . get ( charBuffer ) ; <nl> + if ( host = = null ) <nl> + { <nl> + host = InetAddress . getByAddress ( buffer . array ( ) ) . getHostName ( ) ; <nl> + hostNames _ . put ( charBuffer , host ) ; <nl> + } <nl> + int port = ( int ) MessagingService . byteArrayToShort ( portBytes ) ; <nl> + return new EndPoint ( host , port ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new IllegalArgumentException ( e ) ; <nl> + } <nl> + } <nl> + } <nl> +

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 17c0671 . . 71cfca0 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 10 
 + * ( Hadoop ) fix cluster initialisation for a split fetching ( CASSANDRA - 7774 ) 
 * Configure system . paxos with LeveledCompactionStrategy ( CASSANDRA - 7753 ) 
 * Fix ALTER clustering column type from DateType to TimestampType when 
 using DESC clustering order ( CASSANRDA - 7797 ) 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 index e894996 . . 137bddf 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 @ @ - 288 , 16 + 288 , 22 @ @ public class CqlConfigHelper 
 
 public static Cluster getInputCluster ( String host , Configuration conf ) 
 { 
 + / / this method has been left for backward compatibility 
 + return getInputCluster ( new String [ ] { host } , conf ) ; 
 + } 
 + 
 + public static Cluster getInputCluster ( String [ ] hosts , Configuration conf ) 
 + { 
 int port = getInputNativePort ( conf ) ; 
 Optional < AuthProvider > authProvider = getAuthProvider ( conf ) ; 
 Optional < SSLOptions > sslOptions = getSSLOptions ( conf ) ; 
 - LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , host ) ; 
 + LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , hosts ) ; 
 SocketOptions socketOptions = getReadSocketOptions ( conf ) ; 
 QueryOptions queryOptions = getReadQueryOptions ( conf ) ; 
 PoolingOptions poolingOptions = getReadPoolingOptions ( conf ) ; 
 
 Cluster . Builder builder = Cluster . builder ( ) 
 - . addContactPoint ( host ) 
 + . addContactPoints ( hosts ) 
 . withPort ( port ) 
 . withCompression ( ProtocolOptions . Compression . NONE ) ; 
 
 @ @ - 480 , 84 + 486 , 9 @ @ public class CqlConfigHelper 
 return socketOptions ; 
 } 
 
 - private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String stickHost ) 
 + private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String [ ] stickHosts ) 
 { 
 - return new LoadBalancingPolicy ( ) 
 - { 
 - private Host origHost ; 
 - private Set < Host > liveRemoteHosts = Sets . newHashSet ( ) ; 
 - 
 - @ Override 
 - public void onAdd ( Host host ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - origHost = host ; 
 - } 
 - 
 - @ Override 
 - public void onDown ( Host host ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - origHost = null ; 
 - liveRemoteHosts . remove ( host ) ; 
 - } 
 - 
 - @ Override 
 - public void onRemove ( Host host ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - origHost = null ; 
 - liveRemoteHosts . remove ( host ) ; 
 - } 
 - 
 - @ Override 
 - public void onUp ( Host host ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - origHost = host ; 
 - liveRemoteHosts . add ( host ) ; 
 - } 
 - 
 - @ Override 
 - public void onSuspected ( Host host ) 
 - { 
 - } 
 - 
 - @ Override 
 - public HostDistance distance ( Host host ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - return HostDistance . LOCAL ; 
 - else 
 - return HostDistance . REMOTE ; 
 - } 
 - 
 - @ Override 
 - public void init ( Cluster cluster , Collection < Host > hosts ) 
 - { 
 - for ( Host host : hosts ) 
 - { 
 - if ( host . getAddress ( ) . getHostName ( ) . equals ( stickHost ) ) 
 - { 
 - origHost = host ; 
 - break ; 
 - } 
 - } 
 - } 
 - 
 - @ Override 
 - public Iterator < Host > newQueryPlan ( String loggedKeyspace , Statement statement ) 
 - { 
 - if ( origHost ! = null ) 
 - { 
 - return Iterators . concat ( Collections . singletonList ( origHost ) . iterator ( ) , liveRemoteHosts . iterator ( ) ) ; 
 - } 
 - else 
 - { 
 - return liveRemoteHosts . iterator ( ) ; 
 - } 
 - } 
 - } ; 
 + return new LimitedLocalNodeFirstLocalBalancingPolicy ( stickHosts ) ; 
 } 
 
 private static Optional < AuthProvider > getAuthProvider ( Configuration conf ) 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java 
 index 9167ac3 . . 3eab7c0 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlRecordReader . java 
 @ @ - 124 , 24 + 124 , 9 @ @ public class CqlRecordReader extends RecordReader < Long , Row > 
 if ( cluster ! = null ) 
 return ; 
 
 - / / create connection using thrift 
 + / / create a Cluster instance 
 String [ ] locations = split . getLocations ( ) ; 
 - Exception lastException = null ; 
 - for ( String location : locations ) 
 - { 
 - try 
 - { 
 - cluster = CqlConfigHelper . getInputCluster ( location , conf ) ; 
 - break ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - lastException = e ; 
 - logger . warn ( " Failed to create authenticated client to { } " , location ) ; 
 - } 
 - } 
 - if ( cluster = = null & & lastException ! = null ) 
 - throw lastException ; 
 + cluster = CqlConfigHelper . getInputCluster ( locations , conf ) ; 
 } 
 catch ( Exception e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java b / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java 
 new file mode 100644 
 index 0000000 . . 3aa7df0 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / LimitedLocalNodeFirstLocalBalancingPolicy . java 
 @ @ - 0 , 0 + 1 , 185 @ @ 
 + package org . apache . cassandra . hadoop . cql3 ; 
 + 
 + import com . datastax . driver . core . Cluster ; 
 + import com . datastax . driver . core . Host ; 
 + import com . datastax . driver . core . HostDistance ; 
 + import com . datastax . driver . core . Statement ; 
 + import com . datastax . driver . core . policies . LoadBalancingPolicy ; 
 + import com . google . common . base . Function ; 
 + import com . google . common . collect . Iterators ; 
 + import com . google . common . collect . Sets ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . NetworkInterface ; 
 + import java . net . SocketException ; 
 + import java . net . UnknownHostException ; 
 + import java . util . * ; 
 + import java . util . concurrent . CopyOnWriteArraySet ; 
 + 
 + / * * 
 + * This load balancing policy is intended to be used only for CqlRecordReader when it fetches a particular split . 
 + * < p / > 
 + * It chooses alive hosts only from the set of the given replicas - because the connection is used to load the data from 
 + * the particular split , with a strictly defined list of the replicas , it is pointless to try the other nodes . 
 + * The policy tracks which of the replicas are alive , and when a new query plan is requested , it returns those replicas 
 + * in the following order : 
 + * < ul > 
 + * < li > the local node < / li > 
 + * < li > the collection of the remaining hosts ( which is shuffled on each request ) < / li > 
 + * < / ul > 
 + * / 
 + class LimitedLocalNodeFirstLocalBalancingPolicy implements LoadBalancingPolicy 
 + { 
 + private final static Logger logger = LoggerFactory . getLogger ( LimitedLocalNodeFirstLocalBalancingPolicy . class ) ; 
 + 
 + private final static Set < InetAddress > localAddresses = Collections . unmodifiableSet ( getLocalInetAddresses ( ) ) ; 
 + 
 + private final CopyOnWriteArraySet < Host > liveReplicaHosts = new CopyOnWriteArraySet < > ( ) ; 
 + 
 + private final Set < InetAddress > replicaAddresses = new HashSet < > ( ) ; 
 + 
 + public LimitedLocalNodeFirstLocalBalancingPolicy ( String [ ] replicas ) 
 + { 
 + for ( String replica : replicas ) 
 + { 
 + try 
 + { 
 + InetAddress [ ] addresses = InetAddress . getAllByName ( replica ) ; 
 + Collections . addAll ( replicaAddresses , addresses ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + logger . warn ( " Invalid replica host name : { } , skipping it " , replica ) ; 
 + } 
 + } 
 + logger . debug ( " Created instance with the following replicas : { } " , Arrays . asList ( replicas ) ) ; 
 + } 
 + 
 + @ Override 
 + public void init ( Cluster cluster , Collection < Host > hosts ) 
 + { 
 + List < Host > replicaHosts = new ArrayList < > ( ) ; 
 + for ( Host host : hosts ) 
 + { 
 + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) 
 + { 
 + replicaHosts . add ( host ) ; 
 + } 
 + } 
 + liveReplicaHosts . addAll ( replicaHosts ) ; 
 + logger . debug ( " Initialized with replica hosts : { } " , replicaHosts ) ; 
 + } 
 + 
 + @ Override 
 + public HostDistance distance ( Host host ) 
 + { 
 + if ( isLocalHost ( host ) ) 
 + { 
 + return HostDistance . LOCAL ; 
 + } 
 + else 
 + { 
 + return HostDistance . REMOTE ; 
 + } 
 + } 
 + 
 + @ Override 
 + public Iterator < Host > newQueryPlan ( String keyspace , Statement statement ) 
 + { 
 + List < Host > local = new ArrayList < > ( 1 ) ; 
 + List < Host > remote = new ArrayList < > ( liveReplicaHosts . size ( ) ) ; 
 + for ( Host liveReplicaHost : liveReplicaHosts ) 
 + { 
 + if ( isLocalHost ( liveReplicaHost ) ) 
 + { 
 + local . add ( liveReplicaHost ) ; 
 + } 
 + else 
 + { 
 + remote . add ( liveReplicaHost ) ; 
 + } 
 + } 
 + 
 + Collections . shuffle ( remote ) ; 
 + 
 + logger . debug ( " Using the following hosts order for the new query plan : { } | { } " , local , remote ) ; 
 + 
 + return Iterators . concat ( local . iterator ( ) , remote . iterator ( ) ) ; 
 + } 
 + 
 + @ Override 
 + public void onAdd ( Host host ) 
 + { 
 + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) 
 + { 
 + liveReplicaHosts . add ( host ) ; 
 + logger . debug ( " Added a new host { } " , host ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onUp ( Host host ) 
 + { 
 + if ( replicaAddresses . contains ( host . getAddress ( ) ) ) 
 + { 
 + liveReplicaHosts . add ( host ) ; 
 + logger . debug ( " The host { } is now up " , host ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onDown ( Host host ) 
 + { 
 + if ( liveReplicaHosts . remove ( host ) ) 
 + { 
 + logger . debug ( " The host { } is now down " , host ) ; 
 + } 
 + } 
 + 
 + 
 + @ Override 
 + public void onRemove ( Host host ) 
 + { 
 + if ( liveReplicaHosts . remove ( host ) ) 
 + { 
 + logger . debug ( " Removed the host { } " , host ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void onSuspected ( Host host ) 
 + { 
 + / / not supported by this load balancing policy 
 + } 
 + 
 + private static boolean isLocalHost ( Host host ) 
 + { 
 + InetAddress hostAddress = host . getAddress ( ) ; 
 + return hostAddress . isLoopbackAddress ( ) | | localAddresses . contains ( hostAddress ) ; 
 + } 
 + 
 + private static Set < InetAddress > getLocalInetAddresses ( ) 
 + { 
 + try 
 + { 
 + return Sets . newHashSet ( Iterators . concat ( 
 + Iterators . transform ( 
 + Iterators . forEnumeration ( NetworkInterface . getNetworkInterfaces ( ) ) , 
 + new Function < NetworkInterface , Iterator < InetAddress > > ( ) 
 + { 
 + @ Override 
 + public Iterator < InetAddress > apply ( NetworkInterface netIface ) 
 + { 
 + return Iterators . forEnumeration ( netIface . getInetAddresses ( ) ) ; 
 + } 
 + } ) ) ) ; 
 + } 
 + catch ( SocketException e ) 
 + { 
 + logger . warn ( " Could not retrieve local network interfaces . " , e ) ; 
 + return Collections . emptySet ( ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / org / apache / cassandra / net / EndPoint . java b / src / org / apache / cassandra / net / EndPoint . java 
 index 2dda419 . . 03d9f56 100644 
 - - - a / src / org / apache / cassandra / net / EndPoint . java 
 + + + b / src / org / apache / cassandra / net / EndPoint . java 
 @ @ - 1 + 1 , 180 @ @ 
 - / * * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 * or more contributor license agreements . See the NOTICE file 
 * distributed with this work for additional information 
 * regarding copyright ownership . The ASF licenses this file 
 * to you under the Apache License , Version 2 . 0 ( the 
 * " License " ) ; you may not use this file except in compliance 
 * with the License . You may obtain a copy of the License at 
 * 
 * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 * 
 * Unless required by applicable law or agreed to in writing , software 
 * distributed under the License is distributed on an " AS IS " BASIS , 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 * See the License for the specific language governing permissions and 
 * limitations under the License . 
 * / 
 
 package org . apache . cassandra . net ; 
 
 
 import java . io . IOException ; 
 import java . io . Serializable ; 
 import java . net . * ; 
 import java . nio . ByteBuffer ; 
 import java . nio . CharBuffer ; 
 import java . util . HashMap ; 
 import java . util . Map ; 
 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . LogUtil ; 
 import org . apache . log4j . Logger ; 
 
 / * * 
 * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) 
 * / 
 
 public class EndPoint implements Serializable , Comparable < EndPoint > 
 { 
 	 / / logging and profiling . 
 	 private static Logger logger _ = Logger . getLogger ( EndPoint . class ) ; 
 	 private static final long serialVersionUID = - 4962625949179835907L ; 
 	 private static Map < CharBuffer , String > hostNames _ = new HashMap < CharBuffer , String > ( ) ; 
 protected static final int randomPort _ = 5555 ; 
 public static EndPoint randomLocalEndPoint _ ; 
 
 static 
 { 
 try 
 { 
 randomLocalEndPoint _ = new EndPoint ( FBUtilities . getHostName ( ) , EndPoint . randomPort _ ) ; 
 } 
 catch ( IOException ex ) 
 { 
 logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; 
 } 
 } 
 
 	 private String host _ ; 
 	 private int port _ ; 
 
 	 private transient InetSocketAddress ia _ ; 
 
 	 / * Ctor for JAXB . DO NOT DELETE * / 
 	 private EndPoint ( ) 
 	 { 
 	 } 
 
 	 public EndPoint ( String host , int port ) 
 	 { 
 	 	 / * 
 	 	 * Attempts to resolve the host , but does not fail if it cannot . 
 	 	 * / 
 	 	 host _ = host ; 
 	 	 port _ = port ; 
 	 } 
 
 	 / / create a local endpoint id 
 	 public EndPoint ( int port ) 
 	 { 
 	 	 try 
 	 	 { 
 	 	 	 host _ = FBUtilities . getHostName ( ) ; 
 	 	 	 port _ = port ; 
 	 	 } 
 	 	 catch ( UnknownHostException e ) 
 	 	 { 
 	 	 	 logger _ . warn ( LogUtil . throwableToString ( e ) ) ; 
 	 	 } 
 	 } 
 
 	 public String getHost ( ) 
 	 { 
 	 	 return host _ ; 
 	 } 
 
 	 public int getPort ( ) 
 	 { 
 	 	 return port _ ; 
 	 } 
 
 	 public void setPort ( int port ) 
 	 { 
 	 	 port _ = port ; 
 	 } 
 
 	 public InetSocketAddress getInetAddress ( ) 
 	 { 
 	 	 if ( ia _ = = null | | ia _ . isUnresolved ( ) ) 
 	 	 { 
 	 	 	 ia _ = new InetSocketAddress ( host _ , port _ ) ; 
 	 	 } 
 	 	 return ia _ ; 
 	 } 
 
 	 public boolean equals ( Object o ) 
 	 { 
 	 	 if ( ! ( o instanceof EndPoint ) ) 
 	 	 	 return false ; 
 
 	 	 EndPoint rhs = ( EndPoint ) o ; 
 	 	 return ( host _ . equals ( rhs . host _ ) & & port _ = = rhs . port _ ) ; 
 	 } 
 
 	 public int hashCode ( ) 
 	 { 
 	 	 return ( host _ + port _ ) . hashCode ( ) ; 
 	 } 
 
 	 public int compareTo ( EndPoint rhs ) 
 	 { 
 	 	 return host _ . compareTo ( rhs . host _ ) ; 
 	 } 
 
 	 public String toString ( ) 
 	 { 
 	 	 return ( host _ + " : " + port _ ) ; 
 	 } 
 
 	 public static EndPoint fromString ( String str ) 
 	 { 
 	 	 String [ ] values = str . split ( " : " ) ; 
 	 	 return new EndPoint ( values [ 0 ] , Integer . parseInt ( values [ 1 ] ) ) ; 
 	 } 
 
 	 public static byte [ ] toBytes ( EndPoint ep ) 
 	 { 
 	 	 ByteBuffer buffer = ByteBuffer . allocate ( 6 ) ; 
 	 	 byte [ ] iaBytes = ep . getInetAddress ( ) . getAddress ( ) . getAddress ( ) ; 
 	 	 buffer . put ( iaBytes ) ; 
 	 	 buffer . put ( MessagingService . toByteArray ( ( short ) ep . getPort ( ) ) ) ; 
 	 	 buffer . flip ( ) ; 
 	 	 return buffer . array ( ) ; 
 	 } 
 
 	 public static EndPoint fromBytes ( byte [ ] bytes ) 
 	 { 
 	 	 ByteBuffer buffer = ByteBuffer . allocate ( 4 ) ; 
 	 	 System . arraycopy ( bytes , 0 , buffer . array ( ) , 0 , 4 ) ; 
 	 	 byte [ ] portBytes = new byte [ 2 ] ; 
 	 	 System . arraycopy ( bytes , 4 , portBytes , 0 , portBytes . length ) ; 
 	 	 try 
 	 	 { 
 	 	 	 CharBuffer charBuffer = buffer . asCharBuffer ( ) ; 
 	 	 	 String host = hostNames _ . get ( charBuffer ) ; 
 	 	 	 if ( host = = null ) 
 	 	 	 { 	 	 	 	 
 	 	 	 	 host = InetAddress . getByAddress ( buffer . array ( ) ) . getHostName ( ) ; 	 	 	 	 
 	 	 	 	 hostNames _ . put ( charBuffer , host ) ; 
 	 	 	 } 
 	 	 	 int port = ( int ) MessagingService . byteArrayToShort ( portBytes ) ; 
 	 	 	 return new EndPoint ( host , port ) ; 
 	 	 } 
 	 	 catch ( UnknownHostException e ) 
 	 	 { 
 	 	 	 throw new IllegalArgumentException ( e ) ; 
 	 	 } 
 	 } 
 } 
 
 \ No newline at end of file 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + 
 + import java . io . IOException ; 
 + import java . io . Serializable ; 
 + import java . net . * ; 
 + import java . nio . ByteBuffer ; 
 + import java . nio . CharBuffer ; 
 + import java . util . HashMap ; 
 + import java . util . Map ; 
 + 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . LogUtil ; 
 + import org . apache . log4j . Logger ; 
 + 
 + / * * 
 + * Author : Avinash Lakshman ( alakshman @ facebook . com ) & Prashant Malik ( pmalik @ facebook . com ) 
 + * / 
 + 
 + public class EndPoint implements Serializable , Comparable < EndPoint > 
 + { 
 + / / logging and profiling . 
 + private static Logger logger _ = Logger . getLogger ( EndPoint . class ) ; 
 + private static final long serialVersionUID = - 4962625949179835907L ; 
 + private static Map < CharBuffer , String > hostNames _ = new HashMap < CharBuffer , String > ( ) ; 
 + protected static final int randomPort _ = 5555 ; 
 + public static EndPoint randomLocalEndPoint _ ; 
 + 
 + static 
 + { 
 + try 
 + { 
 + randomLocalEndPoint _ = new EndPoint ( FBUtilities . getHostName ( ) , EndPoint . randomPort _ ) ; 
 + } 
 + catch ( IOException ex ) 
 + { 
 + logger _ . warn ( LogUtil . throwableToString ( ex ) ) ; 
 + } 
 + } 
 + 
 + private String host _ ; 
 + private int port _ ; 
 + 
 + private transient InetSocketAddress ia _ ; 
 + 
 + / * Ctor for JAXB . DO NOT DELETE * / 
 + private EndPoint ( ) 
 + { 
 + } 
 + 
 + public EndPoint ( String host , int port ) 
 + { 
 + / * 
 + * Attempts to resolve the host , but does not fail if it cannot . 
 + * / 
 + host _ = host ; 
 + port _ = port ; 
 + } 
 + 
 + / / create a local endpoint id 
 + public EndPoint ( int port ) 
 + { 
 + try 
 + { 
 + host _ = FBUtilities . getHostName ( ) ; 
 + port _ = port ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + logger _ . warn ( LogUtil . throwableToString ( e ) ) ; 
 + } 
 + } 
 + 
 + public String getHost ( ) 
 + { 
 + return host _ ; 
 + } 
 + 
 + public int getPort ( ) 
 + { 
 + return port _ ; 
 + } 
 + 
 + public void setPort ( int port ) 
 + { 
 + port _ = port ; 
 + } 
 + 
 + public InetSocketAddress getInetAddress ( ) 
 + { 
 + if ( ia _ = = null | | ia _ . isUnresolved ( ) ) 
 + { 
 + ia _ = new InetSocketAddress ( host _ , port _ ) ; 
 + } 
 + return ia _ ; 
 + } 
 + 
 + public boolean equals ( Object o ) 
 + { 
 + if ( ! ( o instanceof EndPoint ) ) 
 + return false ; 
 + 
 + EndPoint rhs = ( EndPoint ) o ; 
 + return ( host _ . equals ( rhs . host _ ) & & port _ = = rhs . port _ ) ; 
 + } 
 + 
 + public int hashCode ( ) 
 + { 
 + return ( host _ + port _ ) . hashCode ( ) ; 
 + } 
 + 
 + public int compareTo ( EndPoint rhs ) 
 + { 
 + return host _ . compareTo ( rhs . host _ ) ; 
 + } 
 + 
 + public String toString ( ) 
 + { 
 + return ( host _ + " : " + port _ ) ; 
 + } 
 + 
 + public static EndPoint fromString ( String str ) 
 + { 
 + String [ ] values = str . split ( " : " ) ; 
 + return new EndPoint ( values [ 0 ] , Integer . parseInt ( values [ 1 ] ) ) ; 
 + } 
 + 
 + public static byte [ ] toBytes ( EndPoint ep ) 
 + { 
 + ByteBuffer buffer = ByteBuffer . allocate ( 6 ) ; 
 + byte [ ] iaBytes = ep . getInetAddress ( ) . getAddress ( ) . getAddress ( ) ; 
 + buffer . put ( iaBytes ) ; 
 + buffer . put ( MessagingService . toByteArray ( ( short ) ep . getPort ( ) ) ) ; 
 + buffer . flip ( ) ; 
 + return buffer . array ( ) ; 
 + } 
 + 
 + public static EndPoint fromBytes ( byte [ ] bytes ) 
 + { 
 + ByteBuffer buffer = ByteBuffer . allocate ( 4 ) ; 
 + System . arraycopy ( bytes , 0 , buffer . array ( ) , 0 , 4 ) ; 
 + byte [ ] portBytes = new byte [ 2 ] ; 
 + System . arraycopy ( bytes , 4 , portBytes , 0 , portBytes . length ) ; 
 + try 
 + { 
 + CharBuffer charBuffer = buffer . asCharBuffer ( ) ; 
 + String host = hostNames _ . get ( charBuffer ) ; 
 + if ( host = = null ) 
 + { 
 + host = InetAddress . getByAddress ( buffer . array ( ) ) . getHostName ( ) ; 
 + hostNames _ . put ( charBuffer , host ) ; 
 + } 
 + int port = ( int ) MessagingService . byteArrayToShort ( portBytes ) ; 
 + return new EndPoint ( host , port ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new IllegalArgumentException ( e ) ; 
 + } 
 + } 
 + } 
 +
