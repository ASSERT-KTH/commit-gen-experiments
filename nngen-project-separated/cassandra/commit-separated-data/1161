BLEU SCORE: 0.004384731028894881

TEST MSG: Fix SELECT statement with IN restrictions on partition key , ORDER BY and LIMIT
GENERATED MSG: clean out unused code from TcpConnectionManager ; split connections to a node into " command " and " ack " , which will allow us to use backpressure on the command socket . patch by gdusbabek ; reviewed by jbellis for CASSANDRA - 488

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index eab04fb . . e1a959a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 3 . 0 . 1 <nl> + * Fix SELECT statement with IN restrictions on partition key , <nl> + ORDER BY and LIMIT ( CASSANDRA - 10729 ) <nl> * Improve stress performance over 1k threads ( CASSANDRA - 7217 ) <nl> * Wait for migration responses to complete before bootstrapping ( CASSANDRA - 10731 ) <nl> * Unable to create a function with argument of type Inet ( CASSANDRA - 10741 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index d971d5e . . 02a9525 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 13 , 6 + 13 , 15 @ @ restore snapshots created with the previous major version using the <nl> ' sstableloader ' tool . You can upgrade the file format of your snapshots <nl> using the provided ' sstableupgrade ' tool . <nl> <nl> + 3 . 0 . 1 <nl> + = = = = = <nl> + <nl> + Upgrading <nl> + - - - - - - - - - <nl> + - The return value of SelectStatement : : getLimit as been changed from DataLimits <nl> + to int . <nl> + <nl> + <nl> 3 . 0 <nl> = = = <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index ab1da45 . . a9bb121 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 202 , 15 + 202 , 16 @ @ public class SelectStatement implements CQLStatement <nl> cl . validateForRead ( keyspace ( ) ) ; <nl> <nl> int nowInSec = FBUtilities . nowInSeconds ( ) ; <nl> - ReadQuery query = getQuery ( options , nowInSec ) ; <nl> + int userLimit = getLimit ( options ) ; <nl> + ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; <nl> <nl> int pageSize = getPageSize ( options ) ; <nl> <nl> if ( pageSize < = 0 | | query . limits ( ) . count ( ) < = pageSize ) <nl> - return execute ( query , options , state , nowInSec ) ; <nl> + return execute ( query , options , state , nowInSec , userLimit ) ; <nl> <nl> QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; <nl> - return execute ( Pager . forDistributedQuery ( pager , cl , state . getClientState ( ) ) , options , pageSize , nowInSec ) ; <nl> + return execute ( Pager . forDistributedQuery ( pager , cl , state . getClientState ( ) ) , options , pageSize , nowInSec , userLimit ) ; <nl> } <nl> <nl> private int getPageSize ( QueryOptions options ) <nl> @ @ - 228 , 18 + 229 , 27 @ @ public class SelectStatement implements CQLStatement <nl> <nl> public ReadQuery getQuery ( QueryOptions options , int nowInSec ) throws RequestValidationException <nl> { <nl> - DataLimits limit = getLimit ( options ) ; <nl> + return getQuery ( options , nowInSec , getLimit ( options ) ) ; <nl> + } <nl> + <nl> + public ReadQuery getQuery ( QueryOptions options , int nowInSec , int userLimit ) throws RequestValidationException <nl> + { <nl> + DataLimits limit = getDataLimits ( userLimit ) ; <nl> if ( restrictions . isKeyRange ( ) | | restrictions . usesSecondaryIndexing ( ) ) <nl> return getRangeCommand ( options , limit , nowInSec ) ; <nl> <nl> return getSliceCommands ( options , limit , nowInSec ) ; <nl> } <nl> <nl> - private ResultMessage . Rows execute ( ReadQuery query , QueryOptions options , QueryState state , int nowInSec ) throws RequestValidationException , RequestExecutionException <nl> + private ResultMessage . Rows execute ( ReadQuery query , <nl> + QueryOptions options , <nl> + QueryState state , <nl> + int nowInSec , <nl> + int userLimit ) throws RequestValidationException , RequestExecutionException <nl> { <nl> try ( PartitionIterator data = query . execute ( options . getConsistency ( ) , state . getClientState ( ) ) ) <nl> { <nl> - return processResults ( data , options , nowInSec ) ; <nl> + return processResults ( data , options , nowInSec , userLimit ) ; <nl> } <nl> } <nl> <nl> @ @ - 310 , 8 + 320 , 11 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> <nl> - private ResultMessage . Rows execute ( Pager pager , QueryOptions options , int pageSize , int nowInSec ) <nl> - throws RequestValidationException , RequestExecutionException <nl> + private ResultMessage . Rows execute ( Pager pager , <nl> + QueryOptions options , <nl> + int pageSize , <nl> + int nowInSec , <nl> + int userLimit ) throws RequestValidationException , RequestExecutionException <nl> { <nl> if ( selection . isAggregate ( ) ) <nl> return pageAggregateQuery ( pager , options , pageSize , nowInSec ) ; <nl> @ @ - 324 , 7 + 337 , 7 @ @ public class SelectStatement implements CQLStatement <nl> ResultMessage . Rows msg ; <nl> try ( PartitionIterator page = pager . fetchPage ( pageSize ) ) <nl> { <nl> - msg = processResults ( page , options , nowInSec ) ; <nl> + msg = processResults ( page , options , nowInSec , userLimit ) ; <nl> } <nl> <nl> / / Please note that the isExhausted state of the pager only gets updated when we ' ve closed the page , so this <nl> @ @ - 366 , 16 + 379 , 20 @ @ public class SelectStatement implements CQLStatement <nl> return new ResultMessage . Rows ( result . build ( options . getProtocolVersion ( ) ) ) ; <nl> } <nl> <nl> - private ResultMessage . Rows processResults ( PartitionIterator partitions , QueryOptions options , int nowInSec ) throws RequestValidationException <nl> + private ResultMessage . Rows processResults ( PartitionIterator partitions , <nl> + QueryOptions options , <nl> + int nowInSec , <nl> + int userLimit ) throws RequestValidationException <nl> { <nl> - ResultSet rset = process ( partitions , options , nowInSec ) ; <nl> + ResultSet rset = process ( partitions , options , nowInSec , userLimit ) ; <nl> return new ResultMessage . Rows ( rset ) ; <nl> } <nl> <nl> public ResultMessage . Rows executeInternal ( QueryState state , QueryOptions options ) throws RequestExecutionException , RequestValidationException <nl> { <nl> int nowInSec = FBUtilities . nowInSeconds ( ) ; <nl> - ReadQuery query = getQuery ( options , nowInSec ) ; <nl> + int userLimit = getLimit ( options ) ; <nl> + ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; <nl> int pageSize = getPageSize ( options ) ; <nl> <nl> try ( ReadOrderGroup orderGroup = query . startOrderGroup ( ) ) <nl> @ @ - 384 , 20 + 401 , 20 @ @ public class SelectStatement implements CQLStatement <nl> { <nl> try ( PartitionIterator data = query . executeInternal ( orderGroup ) ) <nl> { <nl> - return processResults ( data , options , nowInSec ) ; <nl> + return processResults ( data , options , nowInSec , userLimit ) ; <nl> } <nl> } <nl> else <nl> { <nl> QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; <nl> - return execute ( Pager . forInternalQuery ( pager , orderGroup ) , options , pageSize , nowInSec ) ; <nl> + return execute ( Pager . forInternalQuery ( pager , orderGroup ) , options , pageSize , nowInSec , userLimit ) ; <nl> } <nl> } <nl> } <nl> <nl> public ResultSet process ( PartitionIterator partitions , int nowInSec ) throws InvalidRequestException <nl> { <nl> - return process ( partitions , QueryOptions . DEFAULT , nowInSec ) ; <nl> + return process ( partitions , QueryOptions . DEFAULT , nowInSec , getLimit ( QueryOptions . DEFAULT ) ) ; <nl> } <nl> <nl> public String keyspace ( ) <nl> @ @ - 549 , 18 + 566 , 37 @ @ public class SelectStatement implements CQLStatement <nl> return builder . build ( ) ; <nl> } <nl> <nl> - / * * <nl> - * May be used by custom QueryHandler implementations <nl> - * / <nl> - public DataLimits getLimit ( QueryOptions options ) throws InvalidRequestException <nl> + private DataLimits getDataLimits ( int userLimit ) <nl> { <nl> - int userLimit = - 1 ; <nl> + int cqlRowLimit = DataLimits . NO _ LIMIT ; <nl> + <nl> / / If we aggregate , the limit really apply to the number of rows returned to the user , not to what is queried , and <nl> / / since in practice we currently only aggregate at top level ( we have no GROUP BY support yet ) , we ' ll only ever <nl> / / return 1 result and can therefore basically ignore the user LIMIT in this case . <nl> / / Whenever we support GROUP BY , we ' ll have to add a new DataLimits kind that knows how things are grouped and is thus <nl> / / able to apply the user limit properly . <nl> - if ( limit ! = null & & ! selection . isAggregate ( ) ) <nl> + / / If we do post ordering we need to get all the results sorted before we can trim them . <nl> + if ( ! selection . isAggregate ( ) & & ! needsPostQueryOrdering ( ) ) <nl> + cqlRowLimit = userLimit ; <nl> + <nl> + if ( parameters . isDistinct ) <nl> + return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( cqlRowLimit ) ; <nl> + <nl> + return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . NONE : DataLimits . cqlLimits ( cqlRowLimit ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Returns the limit specified by the user . <nl> + * May be used by custom QueryHandler implementations <nl> + * <nl> + * @ return the limit specified by the user or < code > DataLimits . NO _ LIMIT < / code > if no value <nl> + * as been specified . <nl> + * / <nl> + public int getLimit ( QueryOptions options ) <nl> + { <nl> + int userLimit = DataLimits . NO _ LIMIT ; <nl> + <nl> + if ( limit ! = null ) <nl> { <nl> ByteBuffer b = checkNotNull ( limit . bindAndGet ( options ) , " Invalid null value of limit " ) ; <nl> / / treat UNSET limit value as ' unlimited ' <nl> @ @ - 578 , 11 + 614 , 7 @ @ public class SelectStatement implements CQLStatement <nl> } <nl> } <nl> } <nl> - <nl> - if ( parameters . isDistinct ) <nl> - return userLimit < 0 ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( userLimit ) ; <nl> - <nl> - return userLimit < 0 ? DataLimits . NONE : DataLimits . cqlLimits ( userLimit ) ; <nl> + return userLimit ; <nl> } <nl> <nl> private NavigableSet < Clustering > getRequestedRows ( QueryOptions options ) throws InvalidRequestException <nl> @ @ - 604 , 7 + 636 , 10 @ @ public class SelectStatement implements CQLStatement <nl> return filter ; <nl> } <nl> <nl> - private ResultSet process ( PartitionIterator partitions , QueryOptions options , int nowInSec ) throws InvalidRequestException <nl> + private ResultSet process ( PartitionIterator partitions , <nl> + QueryOptions options , <nl> + int nowInSec , <nl> + int userLimit ) throws InvalidRequestException <nl> { <nl> Selection . ResultSetBuilder result = selection . resultSetBuilder ( parameters . isJson ) ; <nl> while ( partitions . hasNext ( ) ) <nl> @ @ - 619 , 6 + 654 , 8 @ @ public class SelectStatement implements CQLStatement <nl> <nl> orderResults ( cqlRows ) ; <nl> <nl> + cqlRows . trim ( userLimit ) ; <nl> + <nl> return cqlRows ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / DataLimits . java b / src / java / org / apache / cassandra / db / filter / DataLimits . java <nl> index 130c6ba . . 19f24ad 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / DataLimits . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / DataLimits . java <nl> @ @ - 41 , 7 + 41 , 9 @ @ public abstract class DataLimits <nl> { <nl> public static final Serializer serializer = new Serializer ( ) ; <nl> <nl> - public static final DataLimits NONE = new CQLLimits ( Integer . MAX _ VALUE ) <nl> + public static final int NO _ LIMIT = Integer . MAX _ VALUE ; <nl> + <nl> + public static final DataLimits NONE = new CQLLimits ( NO _ LIMIT ) <nl> { <nl> @ Override <nl> public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) <nl> @ @ - 64 , 7 + 66 , 7 @ @ public abstract class DataLimits <nl> <nl> / / We currently deal with distinct queries by querying full partitions but limiting the result at 1 row per <nl> / / partition ( see SelectStatement . makeFilter ) . So an " unbounded " distinct is still actually doing some filtering . <nl> - public static final DataLimits DISTINCT _ NONE = new CQLLimits ( Integer . MAX _ VALUE , 1 , true ) ; <nl> + public static final DataLimits DISTINCT _ NONE = new CQLLimits ( NO _ LIMIT , 1 , true ) ; <nl> <nl> public enum Kind { CQL _ LIMIT , CQL _ PAGING _ LIMIT , THRIFT _ LIMIT , SUPER _ COLUMN _ COUNTING _ LIMIT } <nl> <nl> @ @ - 236 , 7 + 238 , 7 @ @ public abstract class DataLimits <nl> <nl> private CQLLimits ( int rowLimit ) <nl> { <nl> - this ( rowLimit , Integer . MAX _ VALUE ) ; <nl> + this ( rowLimit , NO _ LIMIT ) ; <nl> } <nl> <nl> private CQLLimits ( int rowLimit , int perPartitionLimit ) <nl> @ @ - 263 , 7 + 265 , 7 @ @ public abstract class DataLimits <nl> <nl> public boolean isUnlimited ( ) <nl> { <nl> - return rowLimit = = Integer . MAX _ VALUE & & perPartitionLimit = = Integer . MAX _ VALUE ; <nl> + return rowLimit = = NO _ LIMIT & & perPartitionLimit = = NO _ LIMIT ; <nl> } <nl> <nl> public DataLimits forPaging ( int pageSize ) <nl> @ @ - 281 , 7 + 283 , 7 @ @ public abstract class DataLimits <nl> / / When we do a short read retry , we ' re only ever querying the single partition on which we have a short read . So <nl> / / we use toFetch as the row limit and use no perPartitionLimit ( it would be equivalent in practice to use toFetch <nl> / / for both argument or just for perPartitionLimit with no limit on rowLimit ) . <nl> - return new CQLLimits ( toFetch , Integer . MAX _ VALUE , isDistinct ) ; <nl> + return new CQLLimits ( toFetch , NO _ LIMIT , isDistinct ) ; <nl> } <nl> <nl> public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) <nl> @ @ - 410 , 14 + 412 , 14 @ @ public abstract class DataLimits <nl> { <nl> StringBuilder sb = new StringBuilder ( ) ; <nl> <nl> - if ( rowLimit ! = Integer . MAX _ VALUE ) <nl> + if ( rowLimit ! = NO _ LIMIT ) <nl> { <nl> sb . append ( " LIMIT " ) . append ( rowLimit ) ; <nl> - if ( perPartitionLimit ! = Integer . MAX _ VALUE ) <nl> + if ( perPartitionLimit ! = NO _ LIMIT ) <nl> sb . append ( ' ' ) ; <nl> } <nl> <nl> - if ( perPartitionLimit ! = Integer . MAX _ VALUE ) <nl> + if ( perPartitionLimit ! = NO _ LIMIT ) <nl> sb . append ( " PER PARTITION LIMIT " ) . append ( perPartitionLimit ) ; <nl> <nl> return sb . toString ( ) ; <nl> @ @ - 508 , 7 + 510 , 7 @ @ public abstract class DataLimits <nl> <nl> public boolean isUnlimited ( ) <nl> { <nl> - return partitionLimit = = Integer . MAX _ VALUE & & cellPerPartitionLimit = = Integer . MAX _ VALUE ; <nl> + return partitionLimit = = NO _ LIMIT & & cellPerPartitionLimit = = NO _ LIMIT ; <nl> } <nl> <nl> public DataLimits forPaging ( int pageSize ) <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java <nl> index 73bbaca . . ae6f772 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java <nl> @ @ - 333 , 6 + 333 , 12 @ @ public class SelectOrderByTest extends CQLTester <nl> assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 " ) , <nl> row ( 1 ) , row ( 2 ) , row ( 3 ) ) ; <nl> <nl> + assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 LIMIT 2 " ) , <nl> + row ( 1 ) , row ( 2 ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 LIMIT 10 " ) , <nl> + row ( 1 ) , row ( 2 ) , row ( 3 ) ) ; <nl> + <nl> assertRows ( execute ( " SELECT col1 , my _ id FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 " ) , <nl> row ( 1 , " key1 " ) , row ( 2 , " key3 " ) , row ( 3 , " key2 " ) ) ; <nl> <nl> @ @ - 360 , 6 + 366 , 15 @ @ public class SelectOrderByTest extends CQLTester <nl> row ( " A " ) , <nl> row ( " D " ) ) ; <nl> <nl> + assertRows ( execute ( " SELECT v FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c LIMIT 2 ; " , 1 , 1 , 2 ) , <nl> + row ( " B " ) , <nl> + row ( " A " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c LIMIT 10 ; " , 1 , 1 , 2 ) , <nl> + row ( " B " ) , <nl> + row ( " A " ) , <nl> + row ( " D " ) ) ; <nl> + <nl> assertRows ( execute ( " SELECT v as c FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c ; " , 1 , 1 , 2 ) , <nl> row ( " B " ) , <nl> row ( " A " ) , <nl> @ @ - 390 , 6 + 405 , 32 @ @ public class SelectOrderByTest extends CQLTester <nl> row ( " B " ) , <nl> row ( " D " ) , <nl> row ( " A " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 , c2 LIMIT 2 ; " , 1 , 1 , 2 ) , <nl> + row ( " B " ) , <nl> + row ( " D " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 , c2 LIMIT 10 ; " , 1 , 1 , 2 ) , <nl> + row ( " B " ) , <nl> + row ( " D " ) , <nl> + row ( " A " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC ; " , 1 , 1 , 2 ) , <nl> + row ( " A " ) , <nl> + row ( " D " ) , <nl> + row ( " B " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 2 ; " , 1 , 1 , 2 ) , <nl> + row ( " A " ) , <nl> + row ( " D " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 10 ; " , 1 , 1 , 2 ) , <nl> + row ( " A " ) , <nl> + row ( " D " ) , <nl> + row ( " B " ) ) ; <nl> + <nl> + assertInvalidMessage ( " LIMIT must be strictly positive " , <nl> + " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 0 ; " , 1 , 1 , 2 ) ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / net / MessagingConfig . java b / src / java / org / apache / cassandra / net / MessagingConfig . java <nl> deleted file mode 100644 <nl> index 4df69f6 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingConfig . java <nl> + + + / dev / null <nl> @ @ - 1 , 92 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - public class MessagingConfig <nl> - { <nl> - / / The expected time for one message round trip . It does not reflect message processing <nl> - / / time at the receiver . <nl> - private static int expectedRoundTripTime _ = 400 ; <nl> - private static int numberOfPorts _ = 2 ; <nl> - private static int threadCount _ = 4 ; <nl> - <nl> - public static int getMessagingThreadCount ( ) <nl> - { <nl> - return threadCount _ ; <nl> - } <nl> - <nl> - public static void setMessagingThreadCount ( int threadCount ) <nl> - { <nl> - threadCount _ = threadCount ; <nl> - } <nl> - <nl> - public static void setExpectedRoundTripTime ( int roundTripTimeMillis ) { <nl> - 	 if ( roundTripTimeMillis > 0 ) <nl> - 	 	 expectedRoundTripTime _ = roundTripTimeMillis ; <nl> - } <nl> - <nl> - public static int getExpectedRoundTripTime ( ) <nl> - { <nl> - return expectedRoundTripTime _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolInitialSize ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . initialSize _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolGrowthFactor ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . growthFactor _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolMaxSize ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . maxSize _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolWaitTimeout ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . waitTimeout _ ; <nl> - } <nl> - <nl> - public static int getConnectionPoolMonitorInterval ( ) <nl> - { <nl> - return ConnectionPoolConfiguration . monitorInterval _ ; <nl> - } <nl> - <nl> - public static void setNumberOfPorts ( int n ) <nl> - { <nl> - numberOfPorts _ = n ; <nl> - } <nl> - <nl> - public static int getNumberOfPorts ( ) <nl> - { <nl> - return numberOfPorts _ ; <nl> - } <nl> - } <nl> - <nl> - class ConnectionPoolConfiguration <nl> - { <nl> - public static int initialSize _ = 1 ; <nl> - public static int growthFactor _ = 1 ; <nl> - public static int maxSize _ = 1 ; <nl> - public static int waitTimeout _ = 10 ; <nl> - public static int monitorInterval _ = 300 ; <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 20a0d2b . . 6fbe9e0 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 91 , 6 + 91 , 8 @ @ public class MessagingService implements IMessagingService <nl> <nl> private static IMessagingService messagingService _ = new MessagingService ( ) ; <nl> <nl> + private static final int MESSAGE _ DESERIALIZE _ THREADS = 4 ; <nl> + <nl> public static int getVersion ( ) <nl> { <nl> return version _ ; <nl> @ @ - 137 , 7 + 139 , 7 @ @ public class MessagingService implements IMessagingService <nl> * which is the sum of the threads in the pool that adds shit into the table and the <nl> * pool that retrives the callback from here . <nl> * / <nl> - int maxSize = MessagingConfig . getMessagingThreadCount ( ) ; <nl> + int maxSize = MESSAGE _ DESERIALIZE _ THREADS ; <nl> callbackMap _ = new Cachetable < String , IAsyncCallback > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; <nl> taskCompletionMap _ = new Cachetable < String , IAsyncResult > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; <nl> <nl> @ @ - 185 , 7 + 187 , 7 @ @ public class MessagingService implements IMessagingService <nl> public void listen ( InetAddress localEp ) throws IOException <nl> { <nl> ServerSocketChannel serverChannel = ServerSocketChannel . open ( ) ; <nl> - ServerSocket ss = serverChannel . socket ( ) ; <nl> + ServerSocket ss = serverChannel . socket ( ) ; <nl> ss . bind ( new InetSocketAddress ( localEp , DatabaseDescriptor . getStoragePort ( ) ) ) ; <nl> serverChannel . configureBlocking ( false ) ; <nl> <nl> @ @ - 224 , 9 + 226 , 7 @ @ public class MessagingService implements IMessagingService <nl> cp = poolTable _ . get ( key ) ; <nl> if ( cp = = null ) <nl> { <nl> - cp = new TcpConnectionManager ( MessagingConfig . getConnectionPoolInitialSize ( ) , <nl> - MessagingConfig . getConnectionPoolGrowthFactor ( ) , <nl> - MessagingConfig . getConnectionPoolMaxSize ( ) , from , to ) ; <nl> + cp = new TcpConnectionManager ( from , to ) ; <nl> poolTable _ . put ( key , cp ) ; <nl> } <nl> } <nl> @ @ - 238 , 9 + 238 , 9 @ @ public class MessagingService implements IMessagingService <nl> return cp ; <nl> } <nl> <nl> - public static TcpConnection getConnection ( InetAddress from , InetAddress to ) throws IOException <nl> + public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException <nl> { <nl> - return getConnectionPool ( from , to ) . getConnection ( ) ; <nl> + return getConnectionPool ( from , to ) . getConnection ( msg ) ; <nl> } <nl> <nl> private void checkForReservedVerb ( String type ) <nl> @ @ - 324 , 14 + 324 , 14 @ @ public class MessagingService implements IMessagingService <nl> Use this version for fire and forget style messaging . <nl> * / <nl> public void sendOneWay ( Message message , InetAddress to ) <nl> - { <nl> - / / do local deliveries <nl> + { <nl> + / / do local deliveries <nl> if ( message . getFrom ( ) . equals ( to ) ) <nl> - { <nl> + { <nl> MessagingService . receive ( message ) ; <nl> return ; <nl> } <nl> - <nl> + <nl> TcpConnection connection = null ; <nl> try <nl> { <nl> @ @ - 340 , 7 + 340 , 7 @ @ public class MessagingService implements IMessagingService <nl> { <nl> return ; <nl> } <nl> - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; <nl> + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> connection . write ( message ) ; <nl> } <nl> catch ( SocketException se ) <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> index 83c534b . . ea780a9 100644 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnection . java <nl> + + + b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> @ @ - 67 , 14 + 67 , 12 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> private boolean bStream _ = false ; <nl> private Lock lock _ ; <nl> private Condition condition _ ; <nl> - <nl> - / / used from getConnection - outgoing <nl> - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - pool _ = pool ; <nl> - <nl> + <nl> + private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException <nl> + { <nl> + socketChannel _ = SocketChannel . open ( ) ; <nl> + socketChannel _ . configureBlocking ( false ) ; <nl> + <nl> localEp _ = from ; <nl> remoteEp _ = to ; <nl> <nl> @ @ - 86 , 6 + 84 , 24 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> { <nl> key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> } <nl> + <nl> + if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) <nl> + throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; <nl> + <nl> + if ( pool ! = null ) <nl> + pool _ = pool ; <nl> + if ( streaming ) <nl> + { <nl> + bStream _ = true ; <nl> + lock _ = new ReentrantLock ( ) ; <nl> + condition _ = lock _ . newCondition ( ) ; <nl> + } <nl> + } <nl> + <nl> + / / used from getConnection - outgoing <nl> + TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> + { <nl> + this ( from , to , pool , false ) ; <nl> } <nl> <nl> / * <nl> @ @ - 93 , 23 + 109 , 7 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> * / <nl> TcpConnection ( InetAddress from , InetAddress to ) throws IOException <nl> { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - <nl> - localEp _ = from ; <nl> - remoteEp _ = to ; <nl> - <nl> - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; <nl> - } <nl> - else <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> - } <nl> - bStream _ = true ; <nl> - lock _ = new ReentrantLock ( ) ; <nl> - condition _ = lock _ . newCondition ( ) ; <nl> + this ( from , to , null , true ) ; <nl> } <nl> <nl> / * <nl> @ @ - 135 , 27 + 135 , 13 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> isIncoming _ = isIncoming ; <nl> localEp _ = localEp ; <nl> } <nl> - <nl> - InetAddress getLocalEp ( ) <nl> - { <nl> - return localEp _ ; <nl> - } <nl> - <nl> - public void setLocalEp ( InetAddress localEp ) <nl> - { <nl> - localEp _ = localEp ; <nl> - } <nl> + <nl> <nl> public InetAddress getEndPoint ( ) <nl> { <nl> return remoteEp _ ; <nl> } <nl> - <nl> - public boolean isIncoming ( ) <nl> - { <nl> - return isIncoming _ ; <nl> - } <nl> - <nl> + <nl> public SocketChannel getSocketChannel ( ) <nl> { <nl> return socketChannel _ ; <nl> @ @ - 274 , 8 + 260 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> public void close ( ) <nl> { <nl> inUse _ = false ; <nl> - if ( pool _ . contains ( this ) ) <nl> - pool _ . decUsed ( ) ; <nl> } <nl> <nl> public boolean isConnected ( ) <nl> @ @ - 305 , 10 + 289 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> void closeSocket ( ) <nl> { <nl> logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; <nl> - if ( pool _ ! = null ) <nl> - { <nl> - pool _ . removeConnection ( this ) ; <nl> - } <nl> cancel ( key _ ) ; <nl> pendingWrites _ . clear ( ) ; <nl> } <nl> @ @ - 318 , 11 + 298 , 8 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> logger _ . warn ( " Closing down connection " + socketChannel _ ) ; <nl> pendingWrites _ . clear ( ) ; <nl> cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - if ( pool _ ! = null ) <nl> - { <nl> - pool _ . removeConnection ( this ) ; <nl> - } <nl> + pendingWrites _ . clear ( ) ; <nl> + pool _ . destroy ( this ) ; <nl> } <nl> <nl> private void cancel ( SelectionKey key ) <nl> @ @ - 456 , 9 + 433 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> if ( remoteEp _ = = null ) <nl> { <nl> remoteEp _ = socketChannel _ . socket ( ) . getInetAddress ( ) ; <nl> - / / put connection into pool if possible <nl> - pool _ = MessagingService . getConnectionPool ( localEp _ , remoteEp _ ) ; <nl> - pool _ . addToPool ( TcpConnection . this ) ; <nl> } <nl> <nl> / * Deserialize and handle the message * / <nl> @ @ - 497 , 11 + 471 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> } <nl> } <nl> <nl> - public int pending ( ) <nl> - { <nl> - return pendingWrites _ . size ( ) ; <nl> - } <nl> - <nl> public int compareTo ( Object o ) <nl> { <nl> if ( o instanceof TcpConnection ) <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> index 7cbbde3 . . 4485435 100644 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> + + + b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> @ @ - 27 , 205 + 27 , 61 @ @ import org . apache . log4j . Logger ; <nl> <nl> class TcpConnectionManager <nl> { <nl> - private Lock lock _ = new ReentrantLock ( ) ; <nl> - private List < TcpConnection > allConnections _ ; <nl> private InetAddress localEp _ ; <nl> private InetAddress remoteEp _ ; <nl> - private int maxSize _ ; <nl> + private TcpConnection cmdCon ; <nl> + private TcpConnection ackCon ; <nl> <nl> - private int inUse _ ; <nl> - <nl> - / / TODO ! this whole thing is a giant no - op , since " contains " only relies on TcpConnection . equals , which <nl> - / / is true for any ( local , remote ) pairs . So there is only ever at most one TcpConnection per Manager ! <nl> - TcpConnectionManager ( int initialSize , int growthFactor , int maxSize , InetAddress localEp , InetAddress remoteEp ) <nl> + TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) <nl> { <nl> - maxSize _ = maxSize ; <nl> localEp _ = localEp ; <nl> remoteEp _ = remoteEp ; <nl> - allConnections _ = new ArrayList < TcpConnection > ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * returns the least loaded connection to remoteEp , creating a new connection if necessary <nl> - * / <nl> - TcpConnection getConnection ( ) throws IOException <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - if ( allConnections _ . isEmpty ( ) ) <nl> - { <nl> - TcpConnection conn = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - addToPool ( conn ) ; <nl> - conn . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return conn ; <nl> - } <nl> - <nl> - TcpConnection least = getLeastLoaded ( ) ; <nl> - <nl> - if ( ( least ! = null & & least . pending ( ) = = 0 ) | | allConnections _ . size ( ) = = maxSize _ ) <nl> - { <nl> - least . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return least ; <nl> - } <nl> - <nl> - TcpConnection connection = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - if ( ! contains ( connection ) ) <nl> - { <nl> - addToPool ( connection ) ; <nl> - connection . inUse _ = true ; <nl> - incUsed ( ) ; <nl> - return connection ; <nl> - } <nl> - else <nl> - { <nl> - connection . closeSocket ( ) ; <nl> - return getLeastLoaded ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - protected TcpConnection getLeastLoaded ( ) <nl> - { <nl> - TcpConnection connection = null ; <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - Collections . sort ( allConnections _ ) ; <nl> - connection = ( allConnections _ . size ( ) > 0 ) ? allConnections _ . get ( 0 ) : null ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - return connection ; <nl> - } <nl> - <nl> - void removeConnection ( TcpConnection connection ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - allConnections _ . remove ( connection ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - void incUsed ( ) <nl> - { <nl> - inUse _ + + ; <nl> } <nl> <nl> - void decUsed ( ) <nl> + private TcpConnection newCon ( ) throws IOException <nl> { <nl> - inUse _ - - ; <nl> + TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> + con . inUse _ = true ; <nl> + return con ; <nl> } <nl> <nl> - int getConnectionsInUse ( ) <nl> - { <nl> - return inUse _ ; <nl> - } <nl> - <nl> - void addToPool ( TcpConnection connection ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - if ( contains ( connection ) ) <nl> - return ; <nl> - <nl> - if ( allConnections _ . size ( ) < maxSize _ ) <nl> - { <nl> - allConnections _ . add ( connection ) ; <nl> - } <nl> - else <nl> - { <nl> - connection . closeSocket ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - void shutdown ( ) <nl> - { <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - while ( allConnections _ . size ( ) > 0 ) <nl> - { <nl> - TcpConnection connection = allConnections _ . remove ( 0 ) ; <nl> - connection . closeSocket ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - int getPoolSize ( ) <nl> + / * * <nl> + * returns the appropriate connection based on message type . <nl> + * / <nl> + synchronized TcpConnection getConnection ( Message msg ) throws IOException <nl> { <nl> - lock _ . lock ( ) ; <nl> - try <nl> + if ( MessagingService . responseStage _ . equals ( msg . getMessageType ( ) ) ) <nl> { <nl> - return allConnections _ . size ( ) ; <nl> + if ( ackCon = = null ) <nl> + ackCon = newCon ( ) ; <nl> + return ackCon ; <nl> } <nl> - finally <nl> + else <nl> { <nl> - lock _ . unlock ( ) ; <nl> + if ( cmdCon = = null ) <nl> + cmdCon = newCon ( ) ; <nl> + return cmdCon ; <nl> } <nl> } <nl> <nl> - InetAddress getLocalEndPoint ( ) <nl> - { <nl> - return localEp _ ; <nl> - } <nl> - <nl> - InetAddress getRemoteEndPoint ( ) <nl> + synchronized void shutdown ( ) <nl> { <nl> - return remoteEp _ ; <nl> - } <nl> - <nl> - int getPendingWrites ( ) <nl> - { <nl> - int total = 0 ; <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - for ( TcpConnection connection : allConnections _ ) <nl> - { <nl> - total + = connection . pending ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - return total ; <nl> + for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) <nl> + if ( con ! = null ) <nl> + con . closeSocket ( ) ; <nl> } <nl> <nl> - boolean contains ( TcpConnection connection ) <nl> + synchronized void destroy ( TcpConnection con ) <nl> { <nl> - lock _ . lock ( ) ; <nl> - try <nl> + assert con ! = null ; <nl> + if ( cmdCon = = con ) <nl> { <nl> - return allConnections _ . contains ( connection ) ; <nl> + cmdCon = null ; <nl> } <nl> - finally <nl> + else <nl> { <nl> - lock _ . unlock ( ) ; <nl> + assert ackCon = = con ; <nl> + ackCon = null ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index eab04fb . . e1a959a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 3 . 0 . 1 
 + * Fix SELECT statement with IN restrictions on partition key , 
 + ORDER BY and LIMIT ( CASSANDRA - 10729 ) 
 * Improve stress performance over 1k threads ( CASSANDRA - 7217 ) 
 * Wait for migration responses to complete before bootstrapping ( CASSANDRA - 10731 ) 
 * Unable to create a function with argument of type Inet ( CASSANDRA - 10741 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index d971d5e . . 02a9525 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 13 , 6 + 13 , 15 @ @ restore snapshots created with the previous major version using the 
 ' sstableloader ' tool . You can upgrade the file format of your snapshots 
 using the provided ' sstableupgrade ' tool . 
 
 + 3 . 0 . 1 
 + = = = = = 
 + 
 + Upgrading 
 + - - - - - - - - - 
 + - The return value of SelectStatement : : getLimit as been changed from DataLimits 
 + to int . 
 + 
 + 
 3 . 0 
 = = = 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index ab1da45 . . a9bb121 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 202 , 15 + 202 , 16 @ @ public class SelectStatement implements CQLStatement 
 cl . validateForRead ( keyspace ( ) ) ; 
 
 int nowInSec = FBUtilities . nowInSeconds ( ) ; 
 - ReadQuery query = getQuery ( options , nowInSec ) ; 
 + int userLimit = getLimit ( options ) ; 
 + ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; 
 
 int pageSize = getPageSize ( options ) ; 
 
 if ( pageSize < = 0 | | query . limits ( ) . count ( ) < = pageSize ) 
 - return execute ( query , options , state , nowInSec ) ; 
 + return execute ( query , options , state , nowInSec , userLimit ) ; 
 
 QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; 
 - return execute ( Pager . forDistributedQuery ( pager , cl , state . getClientState ( ) ) , options , pageSize , nowInSec ) ; 
 + return execute ( Pager . forDistributedQuery ( pager , cl , state . getClientState ( ) ) , options , pageSize , nowInSec , userLimit ) ; 
 } 
 
 private int getPageSize ( QueryOptions options ) 
 @ @ - 228 , 18 + 229 , 27 @ @ public class SelectStatement implements CQLStatement 
 
 public ReadQuery getQuery ( QueryOptions options , int nowInSec ) throws RequestValidationException 
 { 
 - DataLimits limit = getLimit ( options ) ; 
 + return getQuery ( options , nowInSec , getLimit ( options ) ) ; 
 + } 
 + 
 + public ReadQuery getQuery ( QueryOptions options , int nowInSec , int userLimit ) throws RequestValidationException 
 + { 
 + DataLimits limit = getDataLimits ( userLimit ) ; 
 if ( restrictions . isKeyRange ( ) | | restrictions . usesSecondaryIndexing ( ) ) 
 return getRangeCommand ( options , limit , nowInSec ) ; 
 
 return getSliceCommands ( options , limit , nowInSec ) ; 
 } 
 
 - private ResultMessage . Rows execute ( ReadQuery query , QueryOptions options , QueryState state , int nowInSec ) throws RequestValidationException , RequestExecutionException 
 + private ResultMessage . Rows execute ( ReadQuery query , 
 + QueryOptions options , 
 + QueryState state , 
 + int nowInSec , 
 + int userLimit ) throws RequestValidationException , RequestExecutionException 
 { 
 try ( PartitionIterator data = query . execute ( options . getConsistency ( ) , state . getClientState ( ) ) ) 
 { 
 - return processResults ( data , options , nowInSec ) ; 
 + return processResults ( data , options , nowInSec , userLimit ) ; 
 } 
 } 
 
 @ @ - 310 , 8 + 320 , 11 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 
 - private ResultMessage . Rows execute ( Pager pager , QueryOptions options , int pageSize , int nowInSec ) 
 - throws RequestValidationException , RequestExecutionException 
 + private ResultMessage . Rows execute ( Pager pager , 
 + QueryOptions options , 
 + int pageSize , 
 + int nowInSec , 
 + int userLimit ) throws RequestValidationException , RequestExecutionException 
 { 
 if ( selection . isAggregate ( ) ) 
 return pageAggregateQuery ( pager , options , pageSize , nowInSec ) ; 
 @ @ - 324 , 7 + 337 , 7 @ @ public class SelectStatement implements CQLStatement 
 ResultMessage . Rows msg ; 
 try ( PartitionIterator page = pager . fetchPage ( pageSize ) ) 
 { 
 - msg = processResults ( page , options , nowInSec ) ; 
 + msg = processResults ( page , options , nowInSec , userLimit ) ; 
 } 
 
 / / Please note that the isExhausted state of the pager only gets updated when we ' ve closed the page , so this 
 @ @ - 366 , 16 + 379 , 20 @ @ public class SelectStatement implements CQLStatement 
 return new ResultMessage . Rows ( result . build ( options . getProtocolVersion ( ) ) ) ; 
 } 
 
 - private ResultMessage . Rows processResults ( PartitionIterator partitions , QueryOptions options , int nowInSec ) throws RequestValidationException 
 + private ResultMessage . Rows processResults ( PartitionIterator partitions , 
 + QueryOptions options , 
 + int nowInSec , 
 + int userLimit ) throws RequestValidationException 
 { 
 - ResultSet rset = process ( partitions , options , nowInSec ) ; 
 + ResultSet rset = process ( partitions , options , nowInSec , userLimit ) ; 
 return new ResultMessage . Rows ( rset ) ; 
 } 
 
 public ResultMessage . Rows executeInternal ( QueryState state , QueryOptions options ) throws RequestExecutionException , RequestValidationException 
 { 
 int nowInSec = FBUtilities . nowInSeconds ( ) ; 
 - ReadQuery query = getQuery ( options , nowInSec ) ; 
 + int userLimit = getLimit ( options ) ; 
 + ReadQuery query = getQuery ( options , nowInSec , userLimit ) ; 
 int pageSize = getPageSize ( options ) ; 
 
 try ( ReadOrderGroup orderGroup = query . startOrderGroup ( ) ) 
 @ @ - 384 , 20 + 401 , 20 @ @ public class SelectStatement implements CQLStatement 
 { 
 try ( PartitionIterator data = query . executeInternal ( orderGroup ) ) 
 { 
 - return processResults ( data , options , nowInSec ) ; 
 + return processResults ( data , options , nowInSec , userLimit ) ; 
 } 
 } 
 else 
 { 
 QueryPager pager = query . getPager ( options . getPagingState ( ) , options . getProtocolVersion ( ) ) ; 
 - return execute ( Pager . forInternalQuery ( pager , orderGroup ) , options , pageSize , nowInSec ) ; 
 + return execute ( Pager . forInternalQuery ( pager , orderGroup ) , options , pageSize , nowInSec , userLimit ) ; 
 } 
 } 
 } 
 
 public ResultSet process ( PartitionIterator partitions , int nowInSec ) throws InvalidRequestException 
 { 
 - return process ( partitions , QueryOptions . DEFAULT , nowInSec ) ; 
 + return process ( partitions , QueryOptions . DEFAULT , nowInSec , getLimit ( QueryOptions . DEFAULT ) ) ; 
 } 
 
 public String keyspace ( ) 
 @ @ - 549 , 18 + 566 , 37 @ @ public class SelectStatement implements CQLStatement 
 return builder . build ( ) ; 
 } 
 
 - / * * 
 - * May be used by custom QueryHandler implementations 
 - * / 
 - public DataLimits getLimit ( QueryOptions options ) throws InvalidRequestException 
 + private DataLimits getDataLimits ( int userLimit ) 
 { 
 - int userLimit = - 1 ; 
 + int cqlRowLimit = DataLimits . NO _ LIMIT ; 
 + 
 / / If we aggregate , the limit really apply to the number of rows returned to the user , not to what is queried , and 
 / / since in practice we currently only aggregate at top level ( we have no GROUP BY support yet ) , we ' ll only ever 
 / / return 1 result and can therefore basically ignore the user LIMIT in this case . 
 / / Whenever we support GROUP BY , we ' ll have to add a new DataLimits kind that knows how things are grouped and is thus 
 / / able to apply the user limit properly . 
 - if ( limit ! = null & & ! selection . isAggregate ( ) ) 
 + / / If we do post ordering we need to get all the results sorted before we can trim them . 
 + if ( ! selection . isAggregate ( ) & & ! needsPostQueryOrdering ( ) ) 
 + cqlRowLimit = userLimit ; 
 + 
 + if ( parameters . isDistinct ) 
 + return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( cqlRowLimit ) ; 
 + 
 + return cqlRowLimit = = DataLimits . NO _ LIMIT ? DataLimits . NONE : DataLimits . cqlLimits ( cqlRowLimit ) ; 
 + } 
 + 
 + / * * 
 + * Returns the limit specified by the user . 
 + * May be used by custom QueryHandler implementations 
 + * 
 + * @ return the limit specified by the user or < code > DataLimits . NO _ LIMIT < / code > if no value 
 + * as been specified . 
 + * / 
 + public int getLimit ( QueryOptions options ) 
 + { 
 + int userLimit = DataLimits . NO _ LIMIT ; 
 + 
 + if ( limit ! = null ) 
 { 
 ByteBuffer b = checkNotNull ( limit . bindAndGet ( options ) , " Invalid null value of limit " ) ; 
 / / treat UNSET limit value as ' unlimited ' 
 @ @ - 578 , 11 + 614 , 7 @ @ public class SelectStatement implements CQLStatement 
 } 
 } 
 } 
 - 
 - if ( parameters . isDistinct ) 
 - return userLimit < 0 ? DataLimits . DISTINCT _ NONE : DataLimits . distinctLimits ( userLimit ) ; 
 - 
 - return userLimit < 0 ? DataLimits . NONE : DataLimits . cqlLimits ( userLimit ) ; 
 + return userLimit ; 
 } 
 
 private NavigableSet < Clustering > getRequestedRows ( QueryOptions options ) throws InvalidRequestException 
 @ @ - 604 , 7 + 636 , 10 @ @ public class SelectStatement implements CQLStatement 
 return filter ; 
 } 
 
 - private ResultSet process ( PartitionIterator partitions , QueryOptions options , int nowInSec ) throws InvalidRequestException 
 + private ResultSet process ( PartitionIterator partitions , 
 + QueryOptions options , 
 + int nowInSec , 
 + int userLimit ) throws InvalidRequestException 
 { 
 Selection . ResultSetBuilder result = selection . resultSetBuilder ( parameters . isJson ) ; 
 while ( partitions . hasNext ( ) ) 
 @ @ - 619 , 6 + 654 , 8 @ @ public class SelectStatement implements CQLStatement 
 
 orderResults ( cqlRows ) ; 
 
 + cqlRows . trim ( userLimit ) ; 
 + 
 return cqlRows ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / filter / DataLimits . java b / src / java / org / apache / cassandra / db / filter / DataLimits . java 
 index 130c6ba . . 19f24ad 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / DataLimits . java 
 + + + b / src / java / org / apache / cassandra / db / filter / DataLimits . java 
 @ @ - 41 , 7 + 41 , 9 @ @ public abstract class DataLimits 
 { 
 public static final Serializer serializer = new Serializer ( ) ; 
 
 - public static final DataLimits NONE = new CQLLimits ( Integer . MAX _ VALUE ) 
 + public static final int NO _ LIMIT = Integer . MAX _ VALUE ; 
 + 
 + public static final DataLimits NONE = new CQLLimits ( NO _ LIMIT ) 
 { 
 @ Override 
 public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) 
 @ @ - 64 , 7 + 66 , 7 @ @ public abstract class DataLimits 
 
 / / We currently deal with distinct queries by querying full partitions but limiting the result at 1 row per 
 / / partition ( see SelectStatement . makeFilter ) . So an " unbounded " distinct is still actually doing some filtering . 
 - public static final DataLimits DISTINCT _ NONE = new CQLLimits ( Integer . MAX _ VALUE , 1 , true ) ; 
 + public static final DataLimits DISTINCT _ NONE = new CQLLimits ( NO _ LIMIT , 1 , true ) ; 
 
 public enum Kind { CQL _ LIMIT , CQL _ PAGING _ LIMIT , THRIFT _ LIMIT , SUPER _ COLUMN _ COUNTING _ LIMIT } 
 
 @ @ - 236 , 7 + 238 , 7 @ @ public abstract class DataLimits 
 
 private CQLLimits ( int rowLimit ) 
 { 
 - this ( rowLimit , Integer . MAX _ VALUE ) ; 
 + this ( rowLimit , NO _ LIMIT ) ; 
 } 
 
 private CQLLimits ( int rowLimit , int perPartitionLimit ) 
 @ @ - 263 , 7 + 265 , 7 @ @ public abstract class DataLimits 
 
 public boolean isUnlimited ( ) 
 { 
 - return rowLimit = = Integer . MAX _ VALUE & & perPartitionLimit = = Integer . MAX _ VALUE ; 
 + return rowLimit = = NO _ LIMIT & & perPartitionLimit = = NO _ LIMIT ; 
 } 
 
 public DataLimits forPaging ( int pageSize ) 
 @ @ - 281 , 7 + 283 , 7 @ @ public abstract class DataLimits 
 / / When we do a short read retry , we ' re only ever querying the single partition on which we have a short read . So 
 / / we use toFetch as the row limit and use no perPartitionLimit ( it would be equivalent in practice to use toFetch 
 / / for both argument or just for perPartitionLimit with no limit on rowLimit ) . 
 - return new CQLLimits ( toFetch , Integer . MAX _ VALUE , isDistinct ) ; 
 + return new CQLLimits ( toFetch , NO _ LIMIT , isDistinct ) ; 
 } 
 
 public boolean hasEnoughLiveData ( CachedPartition cached , int nowInSec ) 
 @ @ - 410 , 14 + 412 , 14 @ @ public abstract class DataLimits 
 { 
 StringBuilder sb = new StringBuilder ( ) ; 
 
 - if ( rowLimit ! = Integer . MAX _ VALUE ) 
 + if ( rowLimit ! = NO _ LIMIT ) 
 { 
 sb . append ( " LIMIT " ) . append ( rowLimit ) ; 
 - if ( perPartitionLimit ! = Integer . MAX _ VALUE ) 
 + if ( perPartitionLimit ! = NO _ LIMIT ) 
 sb . append ( ' ' ) ; 
 } 
 
 - if ( perPartitionLimit ! = Integer . MAX _ VALUE ) 
 + if ( perPartitionLimit ! = NO _ LIMIT ) 
 sb . append ( " PER PARTITION LIMIT " ) . append ( perPartitionLimit ) ; 
 
 return sb . toString ( ) ; 
 @ @ - 508 , 7 + 510 , 7 @ @ public abstract class DataLimits 
 
 public boolean isUnlimited ( ) 
 { 
 - return partitionLimit = = Integer . MAX _ VALUE & & cellPerPartitionLimit = = Integer . MAX _ VALUE ; 
 + return partitionLimit = = NO _ LIMIT & & cellPerPartitionLimit = = NO _ LIMIT ; 
 } 
 
 public DataLimits forPaging ( int pageSize ) 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java 
 index 73bbaca . . ae6f772 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / SelectOrderByTest . java 
 @ @ - 333 , 6 + 333 , 12 @ @ public class SelectOrderByTest extends CQLTester 
 assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 " ) , 
 row ( 1 ) , row ( 2 ) , row ( 3 ) ) ; 
 
 + assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 LIMIT 2 " ) , 
 + row ( 1 ) , row ( 2 ) ) ; 
 + 
 + assertRows ( execute ( " SELECT col1 FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 LIMIT 10 " ) , 
 + row ( 1 ) , row ( 2 ) , row ( 3 ) ) ; 
 + 
 assertRows ( execute ( " SELECT col1 , my _ id FROM % s WHERE my _ id in ( ' key1 ' , ' key2 ' , ' key3 ' ) ORDER BY col1 " ) , 
 row ( 1 , " key1 " ) , row ( 2 , " key3 " ) , row ( 3 , " key2 " ) ) ; 
 
 @ @ - 360 , 6 + 366 , 15 @ @ public class SelectOrderByTest extends CQLTester 
 row ( " A " ) , 
 row ( " D " ) ) ; 
 
 + assertRows ( execute ( " SELECT v FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c LIMIT 2 ; " , 1 , 1 , 2 ) , 
 + row ( " B " ) , 
 + row ( " A " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c LIMIT 10 ; " , 1 , 1 , 2 ) , 
 + row ( " B " ) , 
 + row ( " A " ) , 
 + row ( " D " ) ) ; 
 + 
 assertRows ( execute ( " SELECT v as c FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c ; " , 1 , 1 , 2 ) , 
 row ( " B " ) , 
 row ( " A " ) , 
 @ @ - 390 , 6 + 405 , 32 @ @ public class SelectOrderByTest extends CQLTester 
 row ( " B " ) , 
 row ( " D " ) , 
 row ( " A " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 , c2 LIMIT 2 ; " , 1 , 1 , 2 ) , 
 + row ( " B " ) , 
 + row ( " D " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 , c2 LIMIT 10 ; " , 1 , 1 , 2 ) , 
 + row ( " B " ) , 
 + row ( " D " ) , 
 + row ( " A " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC ; " , 1 , 1 , 2 ) , 
 + row ( " A " ) , 
 + row ( " D " ) , 
 + row ( " B " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 2 ; " , 1 , 1 , 2 ) , 
 + row ( " A " ) , 
 + row ( " D " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 10 ; " , 1 , 1 , 2 ) , 
 + row ( " A " ) , 
 + row ( " D " ) , 
 + row ( " B " ) ) ; 
 + 
 + assertInvalidMessage ( " LIMIT must be strictly positive " , 
 + " SELECT v as c2 FROM % s where pk1 = ? AND pk2 IN ( ? , ? ) ORDER BY c1 DESC , c2 DESC LIMIT 0 ; " , 1 , 1 , 2 ) ; 
 } 
 
 / * *

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / net / MessagingConfig . java b / src / java / org / apache / cassandra / net / MessagingConfig . java 
 deleted file mode 100644 
 index 4df69f6 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / MessagingConfig . java 
 + + + / dev / null 
 @ @ - 1 , 92 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - public class MessagingConfig 
 - { 
 - / / The expected time for one message round trip . It does not reflect message processing 
 - / / time at the receiver . 
 - private static int expectedRoundTripTime _ = 400 ; 
 - private static int numberOfPorts _ = 2 ; 
 - private static int threadCount _ = 4 ; 
 - 
 - public static int getMessagingThreadCount ( ) 
 - { 
 - return threadCount _ ; 
 - } 
 - 
 - public static void setMessagingThreadCount ( int threadCount ) 
 - { 
 - threadCount _ = threadCount ; 
 - } 
 - 
 - public static void setExpectedRoundTripTime ( int roundTripTimeMillis ) { 
 - 	 if ( roundTripTimeMillis > 0 ) 
 - 	 	 expectedRoundTripTime _ = roundTripTimeMillis ; 
 - } 
 - 
 - public static int getExpectedRoundTripTime ( ) 
 - { 
 - return expectedRoundTripTime _ ; 
 - } 
 - 
 - public static int getConnectionPoolInitialSize ( ) 
 - { 
 - return ConnectionPoolConfiguration . initialSize _ ; 
 - } 
 - 
 - public static int getConnectionPoolGrowthFactor ( ) 
 - { 
 - return ConnectionPoolConfiguration . growthFactor _ ; 
 - } 
 - 
 - public static int getConnectionPoolMaxSize ( ) 
 - { 
 - return ConnectionPoolConfiguration . maxSize _ ; 
 - } 
 - 
 - public static int getConnectionPoolWaitTimeout ( ) 
 - { 
 - return ConnectionPoolConfiguration . waitTimeout _ ; 
 - } 
 - 
 - public static int getConnectionPoolMonitorInterval ( ) 
 - { 
 - return ConnectionPoolConfiguration . monitorInterval _ ; 
 - } 
 - 
 - public static void setNumberOfPorts ( int n ) 
 - { 
 - numberOfPorts _ = n ; 
 - } 
 - 
 - public static int getNumberOfPorts ( ) 
 - { 
 - return numberOfPorts _ ; 
 - } 
 - } 
 - 
 - class ConnectionPoolConfiguration 
 - { 
 - public static int initialSize _ = 1 ; 
 - public static int growthFactor _ = 1 ; 
 - public static int maxSize _ = 1 ; 
 - public static int waitTimeout _ = 10 ; 
 - public static int monitorInterval _ = 300 ; 
 - } 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 20a0d2b . . 6fbe9e0 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 91 , 6 + 91 , 8 @ @ public class MessagingService implements IMessagingService 
 
 private static IMessagingService messagingService _ = new MessagingService ( ) ; 
 
 + private static final int MESSAGE _ DESERIALIZE _ THREADS = 4 ; 
 + 
 public static int getVersion ( ) 
 { 
 return version _ ; 
 @ @ - 137 , 7 + 139 , 7 @ @ public class MessagingService implements IMessagingService 
 * which is the sum of the threads in the pool that adds shit into the table and the 
 * pool that retrives the callback from here . 
 * / 
 - int maxSize = MessagingConfig . getMessagingThreadCount ( ) ; 
 + int maxSize = MESSAGE _ DESERIALIZE _ THREADS ; 
 callbackMap _ = new Cachetable < String , IAsyncCallback > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; 
 taskCompletionMap _ = new Cachetable < String , IAsyncResult > ( 2 * DatabaseDescriptor . getRpcTimeout ( ) ) ; 
 
 @ @ - 185 , 7 + 187 , 7 @ @ public class MessagingService implements IMessagingService 
 public void listen ( InetAddress localEp ) throws IOException 
 { 
 ServerSocketChannel serverChannel = ServerSocketChannel . open ( ) ; 
 - ServerSocket ss = serverChannel . socket ( ) ; 
 + ServerSocket ss = serverChannel . socket ( ) ; 
 ss . bind ( new InetSocketAddress ( localEp , DatabaseDescriptor . getStoragePort ( ) ) ) ; 
 serverChannel . configureBlocking ( false ) ; 
 
 @ @ - 224 , 9 + 226 , 7 @ @ public class MessagingService implements IMessagingService 
 cp = poolTable _ . get ( key ) ; 
 if ( cp = = null ) 
 { 
 - cp = new TcpConnectionManager ( MessagingConfig . getConnectionPoolInitialSize ( ) , 
 - MessagingConfig . getConnectionPoolGrowthFactor ( ) , 
 - MessagingConfig . getConnectionPoolMaxSize ( ) , from , to ) ; 
 + cp = new TcpConnectionManager ( from , to ) ; 
 poolTable _ . put ( key , cp ) ; 
 } 
 } 
 @ @ - 238 , 9 + 238 , 9 @ @ public class MessagingService implements IMessagingService 
 return cp ; 
 } 
 
 - public static TcpConnection getConnection ( InetAddress from , InetAddress to ) throws IOException 
 + public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException 
 { 
 - return getConnectionPool ( from , to ) . getConnection ( ) ; 
 + return getConnectionPool ( from , to ) . getConnection ( msg ) ; 
 } 
 
 private void checkForReservedVerb ( String type ) 
 @ @ - 324 , 14 + 324 , 14 @ @ public class MessagingService implements IMessagingService 
 Use this version for fire and forget style messaging . 
 * / 
 public void sendOneWay ( Message message , InetAddress to ) 
 - { 
 - / / do local deliveries 
 + { 
 + / / do local deliveries 
 if ( message . getFrom ( ) . equals ( to ) ) 
 - { 
 + { 
 MessagingService . receive ( message ) ; 
 return ; 
 } 
 - 
 + 
 TcpConnection connection = null ; 
 try 
 { 
 @ @ - 340 , 7 + 340 , 7 @ @ public class MessagingService implements IMessagingService 
 { 
 return ; 
 } 
 - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to ) ; 
 + connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 connection . write ( message ) ; 
 } 
 catch ( SocketException se ) 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java 
 index 83c534b . . ea780a9 100644 
 - - - a / src / java / org / apache / cassandra / net / TcpConnection . java 
 + + + b / src / java / org / apache / cassandra / net / TcpConnection . java 
 @ @ - 67 , 14 + 67 , 12 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 private boolean bStream _ = false ; 
 private Lock lock _ ; 
 private Condition condition _ ; 
 - 
 - / / used from getConnection - outgoing 
 - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 - { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - pool _ = pool ; 
 - 
 + 
 + private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException 
 + { 
 + socketChannel _ = SocketChannel . open ( ) ; 
 + socketChannel _ . configureBlocking ( false ) ; 
 + 
 localEp _ = from ; 
 remoteEp _ = to ; 
 
 @ @ - 86 , 6 + 84 , 24 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 { 
 key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 } 
 + 
 + if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) 
 + throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; 
 + 
 + if ( pool ! = null ) 
 + pool _ = pool ; 
 + if ( streaming ) 
 + { 
 + bStream _ = true ; 
 + lock _ = new ReentrantLock ( ) ; 
 + condition _ = lock _ . newCondition ( ) ; 
 + } 
 + } 
 + 
 + / / used from getConnection - outgoing 
 + TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 + { 
 + this ( from , to , pool , false ) ; 
 } 
 
 / * 
 @ @ - 93 , 23 + 109 , 7 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 * / 
 TcpConnection ( InetAddress from , InetAddress to ) throws IOException 
 { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - 
 - localEp _ = from ; 
 - remoteEp _ = to ; 
 - 
 - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; 
 - } 
 - else 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 - } 
 - bStream _ = true ; 
 - lock _ = new ReentrantLock ( ) ; 
 - condition _ = lock _ . newCondition ( ) ; 
 + this ( from , to , null , true ) ; 
 } 
 
 / * 
 @ @ - 135 , 27 + 135 , 13 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 isIncoming _ = isIncoming ; 
 localEp _ = localEp ; 
 } 
 - 
 - InetAddress getLocalEp ( ) 
 - { 
 - return localEp _ ; 
 - } 
 - 
 - public void setLocalEp ( InetAddress localEp ) 
 - { 
 - localEp _ = localEp ; 
 - } 
 + 
 
 public InetAddress getEndPoint ( ) 
 { 
 return remoteEp _ ; 
 } 
 - 
 - public boolean isIncoming ( ) 
 - { 
 - return isIncoming _ ; 
 - } 
 - 
 + 
 public SocketChannel getSocketChannel ( ) 
 { 
 return socketChannel _ ; 
 @ @ - 274 , 8 + 260 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 public void close ( ) 
 { 
 inUse _ = false ; 
 - if ( pool _ . contains ( this ) ) 
 - pool _ . decUsed ( ) ; 
 } 
 
 public boolean isConnected ( ) 
 @ @ - 305 , 10 + 289 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 void closeSocket ( ) 
 { 
 logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; 
 - if ( pool _ ! = null ) 
 - { 
 - pool _ . removeConnection ( this ) ; 
 - } 
 cancel ( key _ ) ; 
 pendingWrites _ . clear ( ) ; 
 } 
 @ @ - 318 , 11 + 298 , 8 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 logger _ . warn ( " Closing down connection " + socketChannel _ ) ; 
 pendingWrites _ . clear ( ) ; 
 cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - if ( pool _ ! = null ) 
 - { 
 - pool _ . removeConnection ( this ) ; 
 - } 
 + pendingWrites _ . clear ( ) ; 
 + pool _ . destroy ( this ) ; 
 } 
 
 private void cancel ( SelectionKey key ) 
 @ @ - 456 , 9 + 433 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 if ( remoteEp _ = = null ) 
 { 
 remoteEp _ = socketChannel _ . socket ( ) . getInetAddress ( ) ; 
 - / / put connection into pool if possible 
 - pool _ = MessagingService . getConnectionPool ( localEp _ , remoteEp _ ) ; 
 - pool _ . addToPool ( TcpConnection . this ) ; 
 } 
 
 / * Deserialize and handle the message * / 
 @ @ - 497 , 11 + 471 , 6 @ @ public class TcpConnection extends SelectionKeyHandler implements Comparable 
 } 
 } 
 
 - public int pending ( ) 
 - { 
 - return pendingWrites _ . size ( ) ; 
 - } 
 - 
 public int compareTo ( Object o ) 
 { 
 if ( o instanceof TcpConnection ) 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 index 7cbbde3 . . 4485435 100644 
 - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 + + + b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 @ @ - 27 , 205 + 27 , 61 @ @ import org . apache . log4j . Logger ; 
 
 class TcpConnectionManager 
 { 
 - private Lock lock _ = new ReentrantLock ( ) ; 
 - private List < TcpConnection > allConnections _ ; 
 private InetAddress localEp _ ; 
 private InetAddress remoteEp _ ; 
 - private int maxSize _ ; 
 + private TcpConnection cmdCon ; 
 + private TcpConnection ackCon ; 
 
 - private int inUse _ ; 
 - 
 - / / TODO ! this whole thing is a giant no - op , since " contains " only relies on TcpConnection . equals , which 
 - / / is true for any ( local , remote ) pairs . So there is only ever at most one TcpConnection per Manager ! 
 - TcpConnectionManager ( int initialSize , int growthFactor , int maxSize , InetAddress localEp , InetAddress remoteEp ) 
 + TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) 
 { 
 - maxSize _ = maxSize ; 
 localEp _ = localEp ; 
 remoteEp _ = remoteEp ; 
 - allConnections _ = new ArrayList < TcpConnection > ( ) ; 
 - } 
 - 
 - / * * 
 - * returns the least loaded connection to remoteEp , creating a new connection if necessary 
 - * / 
 - TcpConnection getConnection ( ) throws IOException 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - if ( allConnections _ . isEmpty ( ) ) 
 - { 
 - TcpConnection conn = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - addToPool ( conn ) ; 
 - conn . inUse _ = true ; 
 - incUsed ( ) ; 
 - return conn ; 
 - } 
 - 
 - TcpConnection least = getLeastLoaded ( ) ; 
 - 
 - if ( ( least ! = null & & least . pending ( ) = = 0 ) | | allConnections _ . size ( ) = = maxSize _ ) 
 - { 
 - least . inUse _ = true ; 
 - incUsed ( ) ; 
 - return least ; 
 - } 
 - 
 - TcpConnection connection = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - if ( ! contains ( connection ) ) 
 - { 
 - addToPool ( connection ) ; 
 - connection . inUse _ = true ; 
 - incUsed ( ) ; 
 - return connection ; 
 - } 
 - else 
 - { 
 - connection . closeSocket ( ) ; 
 - return getLeastLoaded ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - protected TcpConnection getLeastLoaded ( ) 
 - { 
 - TcpConnection connection = null ; 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - Collections . sort ( allConnections _ ) ; 
 - connection = ( allConnections _ . size ( ) > 0 ) ? allConnections _ . get ( 0 ) : null ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - return connection ; 
 - } 
 - 
 - void removeConnection ( TcpConnection connection ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - allConnections _ . remove ( connection ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - void incUsed ( ) 
 - { 
 - inUse _ + + ; 
 } 
 
 - void decUsed ( ) 
 + private TcpConnection newCon ( ) throws IOException 
 { 
 - inUse _ - - ; 
 + TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 + con . inUse _ = true ; 
 + return con ; 
 } 
 
 - int getConnectionsInUse ( ) 
 - { 
 - return inUse _ ; 
 - } 
 - 
 - void addToPool ( TcpConnection connection ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - if ( contains ( connection ) ) 
 - return ; 
 - 
 - if ( allConnections _ . size ( ) < maxSize _ ) 
 - { 
 - allConnections _ . add ( connection ) ; 
 - } 
 - else 
 - { 
 - connection . closeSocket ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - void shutdown ( ) 
 - { 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - while ( allConnections _ . size ( ) > 0 ) 
 - { 
 - TcpConnection connection = allConnections _ . remove ( 0 ) ; 
 - connection . closeSocket ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - int getPoolSize ( ) 
 + / * * 
 + * returns the appropriate connection based on message type . 
 + * / 
 + synchronized TcpConnection getConnection ( Message msg ) throws IOException 
 { 
 - lock _ . lock ( ) ; 
 - try 
 + if ( MessagingService . responseStage _ . equals ( msg . getMessageType ( ) ) ) 
 { 
 - return allConnections _ . size ( ) ; 
 + if ( ackCon = = null ) 
 + ackCon = newCon ( ) ; 
 + return ackCon ; 
 } 
 - finally 
 + else 
 { 
 - lock _ . unlock ( ) ; 
 + if ( cmdCon = = null ) 
 + cmdCon = newCon ( ) ; 
 + return cmdCon ; 
 } 
 } 
 
 - InetAddress getLocalEndPoint ( ) 
 - { 
 - return localEp _ ; 
 - } 
 - 
 - InetAddress getRemoteEndPoint ( ) 
 + synchronized void shutdown ( ) 
 { 
 - return remoteEp _ ; 
 - } 
 - 
 - int getPendingWrites ( ) 
 - { 
 - int total = 0 ; 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - for ( TcpConnection connection : allConnections _ ) 
 - { 
 - total + = connection . pending ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - return total ; 
 + for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) 
 + if ( con ! = null ) 
 + con . closeSocket ( ) ; 
 } 
 
 - boolean contains ( TcpConnection connection ) 
 + synchronized void destroy ( TcpConnection con ) 
 { 
 - lock _ . lock ( ) ; 
 - try 
 + assert con ! = null ; 
 + if ( cmdCon = = con ) 
 { 
 - return allConnections _ . contains ( connection ) ; 
 + cmdCon = null ; 
 } 
 - finally 
 + else 
 { 
 - lock _ . unlock ( ) ; 
 + assert ackCon = = con ; 
 + ackCon = null ; 
 } 
 } 
 }
