BLEU SCORE: 0.020980574531482755

TEST MSG: Unfiltered . isEmpty conflicts with Row extends AbstractCollection . isEmpty
GENERATED MSG: NullPointerExpception when reading / compacting table

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9ba36fa . . 40016a1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 18 <nl> + * Unfiltered . isEmpty conflicts with Row extends AbstractCollection . isEmpty ( CASSANDRA - 14588 ) <nl> * RangeTombstoneList doesn ' t properly clean up mergeable or superseded rts in some cases ( CASSANDRA - 14894 ) <nl> * Fix handling of collection tombstones for dropped columns from legacy sstables ( CASSANDRA - 14912 ) <nl> * Throw exception if Columns serialized subset encode more columns than possible ( CASSANDRA - 14591 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / AbstractRow . java b / src / java / org / apache / cassandra / db / rows / AbstractRow . java <nl> index 67ed219 . . f91126b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / AbstractRow . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / AbstractRow . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . db . rows ; <nl> import java . nio . ByteBuffer ; <nl> import java . security . MessageDigest ; <nl> import java . util . AbstractCollection ; <nl> + import java . util . Collection ; <nl> import java . util . Objects ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> @ @ - 35 , 7 + 36 , 7 @ @ import org . apache . cassandra . utils . FBUtilities ; <nl> * Unless you have a very good reason not to , every row implementation <nl> * should probably extend this class . <nl> * / <nl> - public abstract class AbstractRow extends AbstractCollection < ColumnData > implements Row <nl> + public abstract class AbstractRow implements Row <nl> { <nl> public Unfiltered . Kind kind ( ) <nl> { <nl> @ @ - 87 , 6 + 88 , 11 @ @ public abstract class AbstractRow extends AbstractCollection < ColumnData > impleme <nl> cd . validate ( ) ; <nl> } <nl> <nl> + public String toString ( ) <nl> + { <nl> + return columnData ( ) . toString ( ) ; <nl> + } <nl> + <nl> public String toString ( CFMetaData metadata ) <nl> { <nl> return toString ( metadata , false ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / BTreeRow . java b / src / java / org / apache / cassandra / db / rows / BTreeRow . java <nl> index b07960c . . e46d0cc 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / BTreeRow . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / BTreeRow . java <nl> @ @ - 167 , 7 + 167 , 12 @ @ public class BTreeRow extends AbstractRow <nl> <nl> public Collection < ColumnDefinition > columns ( ) <nl> { <nl> - return Collections2 . transform ( this , ColumnData : : column ) ; <nl> + return Collections2 . transform ( columnData ( ) , ColumnData : : column ) ; <nl> + } <nl> + <nl> + public int columnCount ( ) <nl> + { <nl> + return BTree . size ( btree ) ; <nl> } <nl> <nl> public LivenessInfo primaryKeyLivenessInfo ( ) <nl> @ @ - 208 , 9 + 213 , 14 @ @ public class BTreeRow extends AbstractRow <nl> return ( ComplexColumnData ) BTree . < Object > find ( btree , ColumnDefinition . asymmetricColumnDataComparator , c ) ; <nl> } <nl> <nl> - public int size ( ) <nl> + @ Override <nl> + public Collection < ColumnData > columnData ( ) <nl> { <nl> - return BTree . size ( btree ) ; <nl> + return new AbstractCollection < ColumnData > ( ) <nl> + { <nl> + @ Override public Iterator < ColumnData > iterator ( ) { return BTreeRow . this . iterator ( ) ; } <nl> + @ Override public int size ( ) { return BTree . size ( btree ) ; } <nl> + } ; <nl> } <nl> <nl> public Iterator < ColumnData > iterator ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / Row . java b / src / java / org / apache / cassandra / db / rows / Row . java <nl> index 3c97e09 . . dcb78f3 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / Row . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / Row . java <nl> @ @ - 45 , 7 + 45 , 7 @ @ import org . apache . cassandra . utils . btree . UpdateFunction ; <nl> * it ' s own data . For instance , a { @ code Row } cannot contains a cell that is deleted by its own <nl> * row deletion . <nl> * / <nl> - public interface Row extends Unfiltered , Collection < ColumnData > <nl> + public interface Row extends Unfiltered , Iterable < ColumnData > <nl> { <nl> / * * <nl> * The clustering values for this row . <nl> @ @ - 59 , 6 + 59 , 12 @ @ public interface Row extends Unfiltered , Collection < ColumnData > <nl> * / <nl> public Collection < ColumnDefinition > columns ( ) ; <nl> <nl> + <nl> + / * * <nl> + * The number of columns for which data ( incl . simple tombstones ) is present in this row . <nl> + * / <nl> + public int columnCount ( ) ; <nl> + <nl> / * * <nl> * The row deletion . <nl> * <nl> @ @ - 148 , 6 + 154 , 15 @ @ public interface Row extends Unfiltered , Collection < ColumnData > <nl> public Iterable < Cell > cells ( ) ; <nl> <nl> / * * <nl> + * A collection of the ColumnData representation of this row , for columns with some data ( possibly not live ) present <nl> + * < p > <nl> + * The data is returned in column order . <nl> + * <nl> + * @ return a Collection of the non - empty ColumnData for this row . <nl> + * / <nl> + public Collection < ColumnData > columnData ( ) ; <nl> + <nl> + / * * <nl> * An iterable over the cells of this row that return cells in " legacy order " . <nl> * < p > <nl> * In 3 . 0 + , columns are sorted so that all simple columns are before all complex columns . Previously <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java b / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java <nl> index c4684e1 . . 0342e39 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java <nl> @ @ - 133 , 7 + 133 , 7 @ @ public class UnfilteredSerializer <nl> LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; <nl> Row . Deletion deletion = row . deletion ( ) ; <nl> boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; <nl> - boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; <nl> + boolean hasAllColumns = ( row . columnCount ( ) = = headerColumns . size ( ) ) ; <nl> boolean hasExtendedFlags = hasExtendedFlags ( row ) ; <nl> <nl> if ( isStatic ) <nl> @ @ - 181 , 7 + 181 , 7 @ @ public class UnfilteredSerializer <nl> header . writeDeletionTime ( deletion . time ( ) , out ) ; <nl> <nl> if ( ! hasAllColumns ) <nl> - Columns . serializer . serializeSubset ( Collections2 . transform ( row , ColumnData : : column ) , headerColumns , out ) ; <nl> + Columns . serializer . serializeSubset ( row . columns ( ) , headerColumns , out ) ; <nl> <nl> SearchIterator < ColumnDefinition , ColumnDefinition > si = headerColumns . iterator ( ) ; <nl> for ( ColumnData data : row ) <nl> @ @ - 274 , 7 + 274 , 7 @ @ public class UnfilteredSerializer <nl> LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; <nl> Row . Deletion deletion = row . deletion ( ) ; <nl> boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; <nl> - boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; <nl> + boolean hasAllColumns = ( row . columnCount ( ) = = headerColumns . size ( ) ) ; <nl> <nl> if ( ! pkLiveness . isEmpty ( ) ) <nl> size + = header . timestampSerializedSize ( pkLiveness . timestamp ( ) ) ; <nl> @ @ - 287 , 7 + 287 , 7 @ @ public class UnfilteredSerializer <nl> size + = header . deletionTimeSerializedSize ( deletion . time ( ) ) ; <nl> <nl> if ( ! hasAllColumns ) <nl> - size + = Columns . serializer . serializedSubsetSize ( Collections2 . transform ( row , ColumnData : : column ) , header . columns ( isStatic ) ) ; <nl> + size + = Columns . serializer . serializedSubsetSize ( row . columns ( ) , header . columns ( isStatic ) ) ; <nl> <nl> SearchIterator < ColumnDefinition , ColumnDefinition > si = headerColumns . iterator ( ) ; <nl> for ( ColumnData data : row ) <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> index 0f6cba7 . . c2640a0 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java <nl> @ @ - 918 , 10 + 918 , 10 @ @ public class SecondaryIndexTest extends CQLTester <nl> execute ( " UPDATE % s USING TIMESTAMP 1 SET v1 = 1 WHERE k = 0 AND c = 0 " ) ; <nl> assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; <nl> Row oldRow = index . rowsUpdated . get ( 0 ) . left ; <nl> - assertEquals ( 1 , oldRow . size ( ) ) ; <nl> + assertEquals ( 1 , oldRow . columnCount ( ) ) ; <nl> validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 0 ) , 0 ) ; <nl> Row newRow = index . rowsUpdated . get ( 0 ) . right ; <nl> - assertEquals ( 1 , newRow . size ( ) ) ; <nl> + assertEquals ( 1 , newRow . columnCount ( ) ) ; <nl> validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 1 ) , 1 ) ; <nl> index . reset ( ) ; <nl> <nl> @ @ - 929 , 11 + 929 , 11 @ @ public class SecondaryIndexTest extends CQLTester <nl> execute ( " UPDATE % s USING TIMESTAMP 2 SET v1 = 2 , v2 = 2 WHERE k = 0 AND c = 0 " ) ; <nl> assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; <nl> oldRow = index . rowsUpdated . get ( 0 ) . left ; <nl> - assertEquals ( 2 , oldRow . size ( ) ) ; <nl> + assertEquals ( 2 , oldRow . columnCount ( ) ) ; <nl> validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 1 ) , 1 ) ; <nl> validateCell ( oldRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( 0 ) , 0 ) ; <nl> newRow = index . rowsUpdated . get ( 0 ) . right ; <nl> - assertEquals ( 2 , newRow . size ( ) ) ; <nl> + assertEquals ( 2 , newRow . columnCount ( ) ) ; <nl> validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; <nl> validateCell ( newRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; <nl> index . reset ( ) ; <nl> @ @ - 942 , 10 + 942 , 10 @ @ public class SecondaryIndexTest extends CQLTester <nl> execute ( " DELETE v1 FROM % s USING TIMESTAMP 3 WHERE k = 0 AND c = 0 " ) ; <nl> assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; <nl> oldRow = index . rowsUpdated . get ( 0 ) . left ; <nl> - assertEquals ( 1 , oldRow . size ( ) ) ; <nl> + assertEquals ( 1 , oldRow . columnCount ( ) ) ; <nl> validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; <nl> newRow = index . rowsUpdated . get ( 0 ) . right ; <nl> - assertEquals ( 1 , newRow . size ( ) ) ; <nl> + assertEquals ( 1 , newRow . columnCount ( ) ) ; <nl> Cell newCell = newRow . getCell ( v1 ) ; <nl> assertTrue ( newCell . isTombstone ( ) ) ; <nl> assertEquals ( 3 , newCell . timestamp ( ) ) ; <nl> @ @ - 957 , 10 + 957 , 10 @ @ public class SecondaryIndexTest extends CQLTester <nl> execute ( " INSERT INTO % s ( k , c ) VALUES ( 0 , 0 ) USING TIMESTAMP 4 " ) ; <nl> assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; <nl> oldRow = index . rowsUpdated . get ( 0 ) . left ; <nl> - assertEquals ( 0 , oldRow . size ( ) ) ; <nl> + assertEquals ( 0 , oldRow . columnCount ( ) ) ; <nl> assertEquals ( 0 , oldRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; <nl> newRow = index . rowsUpdated . get ( 0 ) . right ; <nl> - assertEquals ( 0 , newRow . size ( ) ) ; <nl> + assertEquals ( 0 , newRow . columnCount ( ) ) ; <nl> assertEquals ( 4 , newRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> index ca0dfa5 . . 940b4f9 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> @ @ - 282 , 7 + 282 , 7 @ @ public class SinglePartitionSliceCommandTest <nl> assertTrue ( unfiltered . isRow ( ) ) ; <nl> Row row = ( Row ) unfiltered ; <nl> assertEquals ( deletionTime , row . deletion ( ) . time ( ) . markedForDeleteAt ( ) ) ; <nl> - assertEquals ( 0 , row . size ( ) ) ; / / no btree <nl> + assertEquals ( 0 , row . columnCount ( ) ) ; / / no btree <nl> } <nl> count + + ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9ba36fa . . 40016a1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 18 
 + * Unfiltered . isEmpty conflicts with Row extends AbstractCollection . isEmpty ( CASSANDRA - 14588 ) 
 * RangeTombstoneList doesn ' t properly clean up mergeable or superseded rts in some cases ( CASSANDRA - 14894 ) 
 * Fix handling of collection tombstones for dropped columns from legacy sstables ( CASSANDRA - 14912 ) 
 * Throw exception if Columns serialized subset encode more columns than possible ( CASSANDRA - 14591 ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / AbstractRow . java b / src / java / org / apache / cassandra / db / rows / AbstractRow . java 
 index 67ed219 . . f91126b 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / AbstractRow . java 
 + + + b / src / java / org / apache / cassandra / db / rows / AbstractRow . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . db . rows ; 
 import java . nio . ByteBuffer ; 
 import java . security . MessageDigest ; 
 import java . util . AbstractCollection ; 
 + import java . util . Collection ; 
 import java . util . Objects ; 
 
 import com . google . common . collect . Iterables ; 
 @ @ - 35 , 7 + 36 , 7 @ @ import org . apache . cassandra . utils . FBUtilities ; 
 * Unless you have a very good reason not to , every row implementation 
 * should probably extend this class . 
 * / 
 - public abstract class AbstractRow extends AbstractCollection < ColumnData > implements Row 
 + public abstract class AbstractRow implements Row 
 { 
 public Unfiltered . Kind kind ( ) 
 { 
 @ @ - 87 , 6 + 88 , 11 @ @ public abstract class AbstractRow extends AbstractCollection < ColumnData > impleme 
 cd . validate ( ) ; 
 } 
 
 + public String toString ( ) 
 + { 
 + return columnData ( ) . toString ( ) ; 
 + } 
 + 
 public String toString ( CFMetaData metadata ) 
 { 
 return toString ( metadata , false ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / rows / BTreeRow . java b / src / java / org / apache / cassandra / db / rows / BTreeRow . java 
 index b07960c . . e46d0cc 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / BTreeRow . java 
 + + + b / src / java / org / apache / cassandra / db / rows / BTreeRow . java 
 @ @ - 167 , 7 + 167 , 12 @ @ public class BTreeRow extends AbstractRow 
 
 public Collection < ColumnDefinition > columns ( ) 
 { 
 - return Collections2 . transform ( this , ColumnData : : column ) ; 
 + return Collections2 . transform ( columnData ( ) , ColumnData : : column ) ; 
 + } 
 + 
 + public int columnCount ( ) 
 + { 
 + return BTree . size ( btree ) ; 
 } 
 
 public LivenessInfo primaryKeyLivenessInfo ( ) 
 @ @ - 208 , 9 + 213 , 14 @ @ public class BTreeRow extends AbstractRow 
 return ( ComplexColumnData ) BTree . < Object > find ( btree , ColumnDefinition . asymmetricColumnDataComparator , c ) ; 
 } 
 
 - public int size ( ) 
 + @ Override 
 + public Collection < ColumnData > columnData ( ) 
 { 
 - return BTree . size ( btree ) ; 
 + return new AbstractCollection < ColumnData > ( ) 
 + { 
 + @ Override public Iterator < ColumnData > iterator ( ) { return BTreeRow . this . iterator ( ) ; } 
 + @ Override public int size ( ) { return BTree . size ( btree ) ; } 
 + } ; 
 } 
 
 public Iterator < ColumnData > iterator ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / Row . java b / src / java / org / apache / cassandra / db / rows / Row . java 
 index 3c97e09 . . dcb78f3 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / Row . java 
 + + + b / src / java / org / apache / cassandra / db / rows / Row . java 
 @ @ - 45 , 7 + 45 , 7 @ @ import org . apache . cassandra . utils . btree . UpdateFunction ; 
 * it ' s own data . For instance , a { @ code Row } cannot contains a cell that is deleted by its own 
 * row deletion . 
 * / 
 - public interface Row extends Unfiltered , Collection < ColumnData > 
 + public interface Row extends Unfiltered , Iterable < ColumnData > 
 { 
 / * * 
 * The clustering values for this row . 
 @ @ - 59 , 6 + 59 , 12 @ @ public interface Row extends Unfiltered , Collection < ColumnData > 
 * / 
 public Collection < ColumnDefinition > columns ( ) ; 
 
 + 
 + / * * 
 + * The number of columns for which data ( incl . simple tombstones ) is present in this row . 
 + * / 
 + public int columnCount ( ) ; 
 + 
 / * * 
 * The row deletion . 
 * 
 @ @ - 148 , 6 + 154 , 15 @ @ public interface Row extends Unfiltered , Collection < ColumnData > 
 public Iterable < Cell > cells ( ) ; 
 
 / * * 
 + * A collection of the ColumnData representation of this row , for columns with some data ( possibly not live ) present 
 + * < p > 
 + * The data is returned in column order . 
 + * 
 + * @ return a Collection of the non - empty ColumnData for this row . 
 + * / 
 + public Collection < ColumnData > columnData ( ) ; 
 + 
 + / * * 
 * An iterable over the cells of this row that return cells in " legacy order " . 
 * < p > 
 * In 3 . 0 + , columns are sorted so that all simple columns are before all complex columns . Previously 
 diff - - git a / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java b / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java 
 index c4684e1 . . 0342e39 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java 
 + + + b / src / java / org / apache / cassandra / db / rows / UnfilteredSerializer . java 
 @ @ - 133 , 7 + 133 , 7 @ @ public class UnfilteredSerializer 
 LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; 
 Row . Deletion deletion = row . deletion ( ) ; 
 boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; 
 - boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; 
 + boolean hasAllColumns = ( row . columnCount ( ) = = headerColumns . size ( ) ) ; 
 boolean hasExtendedFlags = hasExtendedFlags ( row ) ; 
 
 if ( isStatic ) 
 @ @ - 181 , 7 + 181 , 7 @ @ public class UnfilteredSerializer 
 header . writeDeletionTime ( deletion . time ( ) , out ) ; 
 
 if ( ! hasAllColumns ) 
 - Columns . serializer . serializeSubset ( Collections2 . transform ( row , ColumnData : : column ) , headerColumns , out ) ; 
 + Columns . serializer . serializeSubset ( row . columns ( ) , headerColumns , out ) ; 
 
 SearchIterator < ColumnDefinition , ColumnDefinition > si = headerColumns . iterator ( ) ; 
 for ( ColumnData data : row ) 
 @ @ - 274 , 7 + 274 , 7 @ @ public class UnfilteredSerializer 
 LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; 
 Row . Deletion deletion = row . deletion ( ) ; 
 boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; 
 - boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; 
 + boolean hasAllColumns = ( row . columnCount ( ) = = headerColumns . size ( ) ) ; 
 
 if ( ! pkLiveness . isEmpty ( ) ) 
 size + = header . timestampSerializedSize ( pkLiveness . timestamp ( ) ) ; 
 @ @ - 287 , 7 + 287 , 7 @ @ public class UnfilteredSerializer 
 size + = header . deletionTimeSerializedSize ( deletion . time ( ) ) ; 
 
 if ( ! hasAllColumns ) 
 - size + = Columns . serializer . serializedSubsetSize ( Collections2 . transform ( row , ColumnData : : column ) , header . columns ( isStatic ) ) ; 
 + size + = Columns . serializer . serializedSubsetSize ( row . columns ( ) , header . columns ( isStatic ) ) ; 
 
 SearchIterator < ColumnDefinition , ColumnDefinition > si = headerColumns . iterator ( ) ; 
 for ( ColumnData data : row ) 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 index 0f6cba7 . . c2640a0 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / entities / SecondaryIndexTest . java 
 @ @ - 918 , 10 + 918 , 10 @ @ public class SecondaryIndexTest extends CQLTester 
 execute ( " UPDATE % s USING TIMESTAMP 1 SET v1 = 1 WHERE k = 0 AND c = 0 " ) ; 
 assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; 
 Row oldRow = index . rowsUpdated . get ( 0 ) . left ; 
 - assertEquals ( 1 , oldRow . size ( ) ) ; 
 + assertEquals ( 1 , oldRow . columnCount ( ) ) ; 
 validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 0 ) , 0 ) ; 
 Row newRow = index . rowsUpdated . get ( 0 ) . right ; 
 - assertEquals ( 1 , newRow . size ( ) ) ; 
 + assertEquals ( 1 , newRow . columnCount ( ) ) ; 
 validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 1 ) , 1 ) ; 
 index . reset ( ) ; 
 
 @ @ - 929 , 11 + 929 , 11 @ @ public class SecondaryIndexTest extends CQLTester 
 execute ( " UPDATE % s USING TIMESTAMP 2 SET v1 = 2 , v2 = 2 WHERE k = 0 AND c = 0 " ) ; 
 assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; 
 oldRow = index . rowsUpdated . get ( 0 ) . left ; 
 - assertEquals ( 2 , oldRow . size ( ) ) ; 
 + assertEquals ( 2 , oldRow . columnCount ( ) ) ; 
 validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 1 ) , 1 ) ; 
 validateCell ( oldRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( 0 ) , 0 ) ; 
 newRow = index . rowsUpdated . get ( 0 ) . right ; 
 - assertEquals ( 2 , newRow . size ( ) ) ; 
 + assertEquals ( 2 , newRow . columnCount ( ) ) ; 
 validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; 
 validateCell ( newRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; 
 index . reset ( ) ; 
 @ @ - 942 , 10 + 942 , 10 @ @ public class SecondaryIndexTest extends CQLTester 
 execute ( " DELETE v1 FROM % s USING TIMESTAMP 3 WHERE k = 0 AND c = 0 " ) ; 
 assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; 
 oldRow = index . rowsUpdated . get ( 0 ) . left ; 
 - assertEquals ( 1 , oldRow . size ( ) ) ; 
 + assertEquals ( 1 , oldRow . columnCount ( ) ) ; 
 validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( 2 ) , 2 ) ; 
 newRow = index . rowsUpdated . get ( 0 ) . right ; 
 - assertEquals ( 1 , newRow . size ( ) ) ; 
 + assertEquals ( 1 , newRow . columnCount ( ) ) ; 
 Cell newCell = newRow . getCell ( v1 ) ; 
 assertTrue ( newCell . isTombstone ( ) ) ; 
 assertEquals ( 3 , newCell . timestamp ( ) ) ; 
 @ @ - 957 , 10 + 957 , 10 @ @ public class SecondaryIndexTest extends CQLTester 
 execute ( " INSERT INTO % s ( k , c ) VALUES ( 0 , 0 ) USING TIMESTAMP 4 " ) ; 
 assertEquals ( 1 , index . rowsUpdated . size ( ) ) ; 
 oldRow = index . rowsUpdated . get ( 0 ) . left ; 
 - assertEquals ( 0 , oldRow . size ( ) ) ; 
 + assertEquals ( 0 , oldRow . columnCount ( ) ) ; 
 assertEquals ( 0 , oldRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; 
 newRow = index . rowsUpdated . get ( 0 ) . right ; 
 - assertEquals ( 0 , newRow . size ( ) ) ; 
 + assertEquals ( 0 , newRow . columnCount ( ) ) ; 
 assertEquals ( 4 , newRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 index ca0dfa5 . . 940b4f9 100644 
 - - - a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 @ @ - 282 , 7 + 282 , 7 @ @ public class SinglePartitionSliceCommandTest 
 assertTrue ( unfiltered . isRow ( ) ) ; 
 Row row = ( Row ) unfiltered ; 
 assertEquals ( deletionTime , row . deletion ( ) . time ( ) . markedForDeleteAt ( ) ) ; 
 - assertEquals ( 0 , row . size ( ) ) ; / / no btree 
 + assertEquals ( 0 , row . columnCount ( ) ) ; / / no btree 
 } 
 count + + ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
