BLEU SCORE: 0.04372912656590315

TEST MSG: Change serialization format for UDT
GENERATED MSG: Fix ALTER RENAME post - 5125

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ef678f1 . . e7e7c7f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 16 , 6 + 16 , 7 @ @ <nl> * remove unused classes ( CASSANDRA - 7197 ) <nl> * Limit user types to the keyspace they are defined in ( CASSANDRA - 6643 ) <nl> * Add validate method to CollectionType ( CASSANDRA - 7208 ) <nl> + * New serialization format for UDT values ( CASSANDRA - 7209 ) <nl> Merged from 2 . 0 : <nl> * Always reallocate buffers in HSHA ( CASSANDRA - 6285 ) <nl> * ( Hadoop ) support authentication in CqlRecordReader ( CASSANDRA - 7221 ) <nl> diff - - git a / doc / native _ protocol _ v3 . spec b / doc / native _ protocol _ v3 . spec <nl> index 6662f1c . . 6719838 100644 <nl> - - - a / doc / native _ protocol _ v3 . spec <nl> + + + b / doc / native _ protocol _ v3 . spec <nl> @ @ - 758 , 12 + 758 , 13 @ @ Table of Contents <nl> <nl> 7 . User defined types <nl> <nl> - This section describe the serialization format for User defined types ( UDT ) values . <nl> + This section describes the serialization format for User defined types ( UDT ) values . <nl> UDT values are the values of the User Defined Types as defined in section 4 . 2 . 5 . 2 . <nl> <nl> - A UDT value is a [ short ] n indicating the number of values ( field ) of UDT values <nl> - followed by n elements . Each element is a [ short bytes ] representing the serialized <nl> - field . <nl> + A UDT value is composed of successive [ bytes ] values , one for each field of the UDT <nl> + value ( in the order defined by the type ) . A UDT value will generally have one value <nl> + for each field of the type it represents , but it is allowed to have less values than <nl> + the type has fields . <nl> <nl> <nl> 8 . Result paging <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 2df42ae . . f13b408 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 216 , 8 + 216 , 8 @ @ public final class CFMetaData <nl> public static final CFMetaData SchemaUserTypesCf = compile ( " CREATE TABLE " + SystemKeyspace . SCHEMA _ USER _ TYPES _ CF + " ( " <nl> + " keyspace _ name text , " <nl> + " type _ name text , " <nl> - + " column _ names list < text > , " <nl> - + " column _ types list < text > , " <nl> + + " field _ names list < text > , " <nl> + + " field _ types list < text > , " <nl> + " PRIMARY KEY ( keyspace _ name , type _ name ) " <nl> + " ) WITH COMMENT = ' Defined user types ' AND gc _ grace _ seconds = 8640 " ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / config / UTMetaData . java b / src / java / org / apache / cassandra / config / UTMetaData . java <nl> index b502910 . . 178e653 100644 <nl> - - - a / src / java / org / apache / cassandra / config / UTMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / UTMetaData . java <nl> @ @ - 53 , 8 + 53 , 8 @ @ public final class UTMetaData <nl> { <nl> String keyspace = row . getString ( " keyspace _ name " ) ; <nl> ByteBuffer name = ByteBufferUtil . bytes ( row . getString ( " type _ name " ) ) ; <nl> - List < String > rawColumns = row . getList ( " column _ names " , UTF8Type . instance ) ; <nl> - List < String > rawTypes = row . getList ( " column _ types " , UTF8Type . instance ) ; <nl> + List < String > rawColumns = row . getList ( " field _ names " , UTF8Type . instance ) ; <nl> + List < String > rawTypes = row . getList ( " field _ types " , UTF8Type . instance ) ; <nl> <nl> List < ByteBuffer > columns = new ArrayList < > ( rawColumns . size ( ) ) ; <nl> for ( String rawColumn : rawColumns ) <nl> @ @ - 97 , 13 + 97 , 13 @ @ public final class UTMetaData <nl> Composite prefix = CFMetaData . SchemaUserTypesCf . comparator . make ( newType . name ) ; <nl> CFRowAdder adder = new CFRowAdder ( cf , prefix , timestamp ) ; <nl> <nl> - adder . resetCollection ( " column _ names " ) ; <nl> - adder . resetCollection ( " column _ types " ) ; <nl> + adder . resetCollection ( " field _ names " ) ; <nl> + adder . resetCollection ( " field _ types " ) ; <nl> <nl> - for ( ByteBuffer name : newType . columnNames ) <nl> - adder . addListEntry ( " column _ names " , name ) ; <nl> - for ( AbstractType < ? > type : newType . types ) <nl> - adder . addListEntry ( " column _ types " , type . toString ( ) ) ; <nl> + for ( ByteBuffer name : newType . fieldNames ) <nl> + adder . addListEntry ( " field _ names " , name ) ; <nl> + for ( AbstractType < ? > type : newType . fieldTypes ) <nl> + adder . addListEntry ( " field _ types " , type . toString ( ) ) ; <nl> <nl> return mutation ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / UserTypes . java b / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> index 2faa960 . . 651fa23 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / UserTypes . java <nl> @ @ - 35 , 7 + 35 , 10 @ @ public abstract class UserTypes <nl> <nl> public static ColumnSpecification fieldSpecOf ( ColumnSpecification column , int field ) <nl> { <nl> - return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( column . name + " . " + field , true ) , ( ( UserType ) column . type ) . types . get ( field ) ) ; <nl> + return new ColumnSpecification ( column . ksName , <nl> + column . cfName , <nl> + new ColumnIdentifier ( column . name + " . " + field , true ) , <nl> + ( ( UserType ) column . type ) . fieldTypes . get ( field ) ) ; <nl> } <nl> <nl> public static class Literal implements Term . Raw <nl> @ @ - 54 , 9 + 57 , 9 @ @ public abstract class UserTypes <nl> UserType ut = ( UserType ) receiver . type ; <nl> boolean allTerminal = true ; <nl> List < Term > values = new ArrayList < > ( entries . size ( ) ) ; <nl> - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) <nl> { <nl> - ColumnIdentifier field = new ColumnIdentifier ( ut . columnNames . get ( i ) , UTF8Type . instance ) ; <nl> + ColumnIdentifier field = new ColumnIdentifier ( ut . fieldNames . get ( i ) , UTF8Type . instance ) ; <nl> Term value = entries . get ( field ) . prepare ( keyspace , fieldSpecOf ( receiver , i ) ) ; <nl> <nl> if ( value instanceof Term . NonTerminal ) <nl> @ @ - 74 , 9 + 77 , 9 @ @ public abstract class UserTypes <nl> throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver , receiver . type . asCQL3Type ( ) ) ) ; <nl> <nl> UserType ut = ( UserType ) receiver . type ; <nl> - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) <nl> { <nl> - ColumnIdentifier field = new ColumnIdentifier ( ut . columnNames . get ( i ) , UTF8Type . instance ) ; <nl> + ColumnIdentifier field = new ColumnIdentifier ( ut . fieldNames . get ( i ) , UTF8Type . instance ) ; <nl> Term . Raw value = entries . get ( field ) ; <nl> if ( value = = null ) <nl> throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : missing field % s " , receiver , field ) ) ; <nl> @ @ - 140 , 7 + 143 , 7 @ @ public abstract class UserTypes <nl> <nl> public void collectMarkerSpecification ( VariableSpecifications boundNames ) <nl> { <nl> - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) <nl> values . get ( i ) . collectMarkerSpecification ( boundNames ) ; <nl> } <nl> <nl> @ @ - 151 , 14 + 154 , 14 @ @ public abstract class UserTypes <nl> options = options . withProtocolVersion ( 3 ) ; <nl> <nl> ByteBuffer [ ] buffers = new ByteBuffer [ values . size ( ) ] ; <nl> - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) <nl> { <nl> ByteBuffer buffer = values . get ( i ) . bindAndGet ( options ) ; <nl> if ( buffer = = null ) <nl> throw new InvalidRequestException ( " null is not supported inside user type literals " ) ; <nl> if ( buffer . remaining ( ) > FBUtilities . MAX _ UNSIGNED _ SHORT ) <nl> throw new InvalidRequestException ( String . format ( " Value for field % s is too long . User type fields are limited to % d bytes but % d bytes provided " , <nl> - UTF8Type . instance . getString ( type . columnNames . get ( i ) ) , <nl> + UTF8Type . instance . getString ( type . fieldNames . get ( i ) ) , <nl> FBUtilities . MAX _ UNSIGNED _ SHORT , <nl> buffer . remaining ( ) ) ) ; <nl> <nl> @ @ - 175 , 7 + 178 , 7 @ @ public abstract class UserTypes <nl> @ Override <nl> public ByteBuffer bindAndGet ( QueryOptions options ) throws InvalidRequestException <nl> { <nl> - return CompositeType . build ( bindInternal ( options ) ) ; <nl> + return UserType . buildValue ( bindInternal ( options ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> index 3ea8d63 . . eac936f 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> @ @ - 138 , 8 + 138 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> <nl> private static int getIdxOfField ( UserType type , ColumnIdentifier field ) <nl> { <nl> - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) <nl> - if ( field . bytes . equals ( type . columnNames . get ( i ) ) ) <nl> + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) <nl> + if ( field . bytes . equals ( type . fieldNames . get ( i ) ) ) <nl> return i ; <nl> return - 1 ; <nl> } <nl> @ @ - 183 , 8 + 183 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> return updated ; <nl> <nl> / / Otherwise , check for nesting <nl> - List < AbstractType < ? > > updatedTypes = updateTypes ( ut . types , keyspace , toReplace , updated ) ; <nl> - return updatedTypes = = null ? null : new UserType ( ut . keyspace , ut . name , new ArrayList < > ( ut . columnNames ) , updatedTypes ) ; <nl> + List < AbstractType < ? > > updatedTypes = updateTypes ( ut . fieldTypes , keyspace , toReplace , updated ) ; <nl> + return updatedTypes = = null ? null : new UserType ( ut . keyspace , ut . name , new ArrayList < > ( ut . fieldNames ) , updatedTypes ) ; <nl> } <nl> else if ( type instanceof CompositeType ) <nl> { <nl> @ @ - 275 , 12 + 275 , 12 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> if ( getIdxOfField ( toUpdate , fieldName ) > = 0 ) <nl> throw new InvalidRequestException ( String . format ( " Cannot add new field % s to type % s : a field of the same name already exists " , fieldName , name ) ) ; <nl> <nl> - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames . size ( ) + 1 ) ; <nl> - newNames . addAll ( toUpdate . columnNames ) ; <nl> + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames . size ( ) + 1 ) ; <nl> + newNames . addAll ( toUpdate . fieldNames ) ; <nl> newNames . add ( fieldName . bytes ) ; <nl> <nl> - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types . size ( ) + 1 ) ; <nl> - newTypes . addAll ( toUpdate . types ) ; <nl> + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes . size ( ) + 1 ) ; <nl> + newTypes . addAll ( toUpdate . fieldTypes ) ; <nl> newTypes . add ( type . prepare ( keyspace ( ) ) . getType ( ) ) ; <nl> <nl> return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; <nl> @ @ - 292 , 12 + 292 , 12 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> if ( idx < 0 ) <nl> throw new InvalidRequestException ( String . format ( " Unknown field % s in type % s " , fieldName , name ) ) ; <nl> <nl> - AbstractType < ? > previous = toUpdate . types . get ( idx ) ; <nl> + AbstractType < ? > previous = toUpdate . fieldTypes . get ( idx ) ; <nl> if ( ! type . prepare ( keyspace ( ) ) . getType ( ) . isCompatibleWith ( previous ) ) <nl> throw new InvalidRequestException ( String . format ( " Type % s is incompatible with previous type % s of field % s in user type % s " , type , previous . asCQL3Type ( ) , fieldName , name ) ) ; <nl> <nl> - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames ) ; <nl> - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types ) ; <nl> + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ) ; <nl> + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ) ; <nl> newTypes . set ( idx , type . prepare ( keyspace ( ) ) . getType ( ) ) ; <nl> <nl> return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; <nl> @ @ - 321 , 8 + 321 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> <nl> protected UserType makeUpdatedType ( UserType toUpdate ) throws InvalidRequestException <nl> { <nl> - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames ) ; <nl> - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types ) ; <nl> + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ) ; <nl> + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ) ; <nl> <nl> for ( Map . Entry < ColumnIdentifier , ColumnIdentifier > entry : renames . entrySet ( ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java <nl> index aa8b769 . . cd3e3e5 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java <nl> @ @ - 74 , 12 + 74 , 12 @ @ public class CreateTypeStatement extends SchemaAlteringStatement <nl> <nl> public static void checkForDuplicateNames ( UserType type ) throws InvalidRequestException <nl> { <nl> - for ( int i = 0 ; i < type . types . size ( ) - 1 ; i + + ) <nl> + for ( int i = 0 ; i < type . fieldTypes . size ( ) - 1 ; i + + ) <nl> { <nl> - ByteBuffer fieldName = type . columnNames . get ( i ) ; <nl> - for ( int j = i + 1 ; j < type . types . size ( ) ; j + + ) <nl> + ByteBuffer fieldName = type . fieldNames . get ( i ) ; <nl> + for ( int j = i + 1 ; j < type . fieldTypes . size ( ) ; j + + ) <nl> { <nl> - if ( fieldName . equals ( type . columnNames . get ( j ) ) ) <nl> + if ( fieldName . equals ( type . fieldNames . get ( j ) ) ) <nl> throw new InvalidRequestException ( String . format ( " Duplicate field name % s in type % s " , <nl> UTF8Type . instance . getString ( fieldName ) , <nl> UTF8Type . instance . getString ( type . name ) ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java <nl> index 6521f68 . . 10fc366 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java <nl> @ @ - 91 , 18 + 91 , 19 @ @ public class DropTypeStatement extends SchemaAlteringStatement <nl> <nl> private boolean isUsedBy ( AbstractType < ? > toCheck ) throws RequestValidationException <nl> { <nl> - if ( toCheck instanceof CompositeType ) <nl> + if ( toCheck instanceof UserType ) <nl> { <nl> - CompositeType ct = ( CompositeType ) toCheck ; <nl> + UserType ut = ( UserType ) toCheck ; <nl> + if ( name . getKeyspace ( ) . equals ( ut . keyspace ) & & name . getUserTypeName ( ) . equals ( ut . name ) ) <nl> + return true ; <nl> <nl> - if ( ( ct instanceof UserType ) ) <nl> - { <nl> - UserType ut = ( UserType ) ct ; <nl> - if ( name . getKeyspace ( ) . equals ( ut . keyspace ) & & name . getUserTypeName ( ) . equals ( ut . name ) ) <nl> + for ( AbstractType < ? > subtype : ut . fieldTypes ) <nl> + if ( isUsedBy ( subtype ) ) <nl> return true ; <nl> - } <nl> - <nl> - / / Also reach into subtypes <nl> + } <nl> + else if ( toCheck instanceof CompositeType ) <nl> + { <nl> + CompositeType ct = ( CompositeType ) toCheck ; <nl> for ( AbstractType < ? > subtype : ct . types ) <nl> if ( isUsedBy ( subtype ) ) <nl> return true ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / Selection . java b / src / java / org / apache / cassandra / cql3 / statements / Selection . java <nl> index 3769e97 . . 4990e11 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / Selection . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / Selection . java <nl> @ @ - 142 , 13 + 142 , 13 @ @ public abstract class Selection <nl> throw new InvalidRequestException ( String . format ( " Invalid field selection : % s of type % s is not a user type " , withField . selected , type . asCQL3Type ( ) ) ) ; <nl> <nl> UserType ut = ( UserType ) type ; <nl> - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) <nl> { <nl> - if ( ! ut . columnNames . get ( i ) . equals ( withField . field . bytes ) ) <nl> + if ( ! ut . fieldNames . get ( i ) . equals ( withField . field . bytes ) ) <nl> continue ; <nl> <nl> if ( metadata ! = null ) <nl> - metadata . add ( makeFieldSelectSpec ( cfm , withField , ut . types . get ( i ) , raw . alias ) ) ; <nl> + metadata . add ( makeFieldSelectSpec ( cfm , withField , ut . fieldTypes . get ( i ) , raw . alias ) ) ; <nl> return new FieldSelector ( ut , i , selected ) ; <nl> } <nl> throw new InvalidRequestException ( String . format ( " % s of type % s has no field % s " , withField . selected , type . asCQL3Type ( ) , withField . field ) ) ; <nl> @ @ - 472 , 13 + 472 , 13 @ @ public abstract class Selection <nl> <nl> public AbstractType < ? > getType ( ) <nl> { <nl> - return type . types . get ( field ) ; <nl> + return type . fieldTypes . get ( field ) ; <nl> } <nl> <nl> @ Override <nl> public String toString ( ) <nl> { <nl> - return String . format ( " % s . % s " , selected , UTF8Type . instance . getString ( type . columnNames . get ( field ) ) ) ; <nl> + return String . format ( " % s . % s " , selected , UTF8Type . instance . getString ( type . fieldNames . get ( field ) ) ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / UserType . java b / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> index 973a5be . . 50b3fbb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / UserType . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . db . marshal ; <nl> <nl> import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> import java . util . List ; <nl> <nl> import com . google . common . base . Objects ; <nl> @ @ - 26 , 27 + 27 , 27 @ @ import com . google . common . base . Objects ; <nl> import org . apache . cassandra . cql3 . CQL3Type ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . exceptions . SyntaxException ; <nl> + import org . apache . cassandra . serializers . * ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> / * * <nl> * A user defined type . <nl> - * <nl> - * The serialized format and sorting is exactly the one of CompositeType , but <nl> - * we keep additional metadata ( the name of the type and the names <nl> - * of the columns ) . <nl> * / <nl> - public class UserType extends CompositeType <nl> + public class UserType extends AbstractType < ByteBuffer > <nl> { <nl> public final String keyspace ; <nl> public final ByteBuffer name ; <nl> - public final List < ByteBuffer > columnNames ; <nl> + public final List < ByteBuffer > fieldNames ; <nl> + public final List < AbstractType < ? > > fieldTypes ; <nl> <nl> - public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > columnNames , List < AbstractType < ? > > types ) <nl> + public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > fieldNames , List < AbstractType < ? > > fieldTypes ) <nl> { <nl> - super ( types ) ; <nl> + assert fieldNames . size ( ) = = fieldTypes . size ( ) ; <nl> this . keyspace = keyspace ; <nl> this . name = name ; <nl> - this . columnNames = columnNames ; <nl> + this . fieldNames = fieldNames ; <nl> + this . fieldTypes = fieldTypes ; <nl> } <nl> <nl> public static UserType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException <nl> @ @ - 69 , 10 + 70 , 160 @ @ public class UserType extends CompositeType <nl> return UTF8Type . instance . compose ( name ) ; <nl> } <nl> <nl> + public int compare ( ByteBuffer o1 , ByteBuffer o2 ) <nl> + { <nl> + if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) <nl> + return o1 . hasRemaining ( ) ? 1 : o2 . hasRemaining ( ) ? - 1 : 0 ; <nl> + <nl> + ByteBuffer bb1 = o1 . duplicate ( ) ; <nl> + ByteBuffer bb2 = o2 . duplicate ( ) ; <nl> + <nl> + int i = 0 ; <nl> + while ( bb1 . remaining ( ) > 0 & & bb2 . remaining ( ) > 0 ) <nl> + { <nl> + AbstractType < ? > comparator = fieldTypes . get ( i ) ; <nl> + <nl> + int size1 = bb1 . getInt ( ) ; <nl> + int size2 = bb2 . getInt ( ) ; <nl> + <nl> + / / Handle nulls <nl> + if ( size1 < 0 ) <nl> + { <nl> + if ( size2 < 0 ) <nl> + continue ; <nl> + return - 1 ; <nl> + } <nl> + if ( size2 < 0 ) <nl> + return 1 ; <nl> + <nl> + ByteBuffer value1 = ByteBufferUtil . readBytes ( bb1 , size1 ) ; <nl> + ByteBuffer value2 = ByteBufferUtil . readBytes ( bb2 , size2 ) ; <nl> + int cmp = comparator . compare ( value1 , value2 ) ; <nl> + if ( cmp ! = 0 ) <nl> + return cmp ; <nl> + <nl> + + + i ; <nl> + } <nl> + <nl> + if ( bb1 . remaining ( ) = = 0 ) <nl> + return bb2 . remaining ( ) = = 0 ? 0 : - 1 ; <nl> + <nl> + / / bb1 . remaining ( ) > 0 & & bb2 . remaining ( ) = = 0 <nl> + return 1 ; <nl> + } <nl> + <nl> + @ Override <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + { <nl> + ByteBuffer input = bytes . duplicate ( ) ; <nl> + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) <nl> + { <nl> + / / we allow the input to have less fields than declared so as to support field addition . <nl> + if ( ! input . hasRemaining ( ) ) <nl> + return ; <nl> + <nl> + if ( input . remaining ( ) < 4 ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , fieldNames . get ( i ) ) ) ; <nl> + <nl> + int size = input . getInt ( ) ; <nl> + / / We don ' t handle null just yet , but we should fix that soon ( CASSANDRA - 7206 ) <nl> + if ( size < 0 ) <nl> + throw new MarshalException ( " Nulls are not yet supported inside UDT values " ) ; <nl> + <nl> + if ( input . remaining ( ) < size ) <nl> + throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , fieldNames . get ( i ) ) ) ; <nl> + <nl> + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> + fieldTypes . get ( i ) . validate ( field ) ; <nl> + } <nl> + <nl> + / / We ' re allowed to get less fields than declared , but not more <nl> + if ( input . hasRemaining ( ) ) <nl> + throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Split a UDT value into its fields values . <nl> + * / <nl> + public ByteBuffer [ ] split ( ByteBuffer value ) <nl> + { <nl> + ByteBuffer [ ] fields = new ByteBuffer [ fieldTypes . size ( ) ] ; <nl> + ByteBuffer input = value . duplicate ( ) ; <nl> + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) <nl> + { <nl> + if ( ! input . hasRemaining ( ) ) <nl> + return Arrays . copyOfRange ( fields , 0 , i ) ; <nl> + <nl> + int size = input . getInt ( ) ; <nl> + fields [ i ] = size < 0 ? null : ByteBufferUtil . readBytes ( input , size ) ; <nl> + } <nl> + return fields ; <nl> + } <nl> + <nl> + public static ByteBuffer buildValue ( ByteBuffer [ ] fields ) <nl> + { <nl> + int totalLength = 0 ; <nl> + for ( ByteBuffer field : fields ) <nl> + totalLength + = 4 + field . remaining ( ) ; <nl> + <nl> + ByteBuffer result = ByteBuffer . allocate ( totalLength ) ; <nl> + for ( ByteBuffer field : fields ) <nl> + { <nl> + result . putInt ( field . remaining ( ) ) ; <nl> + result . put ( field . duplicate ( ) ) ; <nl> + } <nl> + result . rewind ( ) ; <nl> + return result ; <nl> + } <nl> + <nl> + @ Override <nl> + public String getString ( ByteBuffer value ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + ByteBuffer input = value . duplicate ( ) ; <nl> + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) <nl> + { <nl> + if ( ! input . hasRemaining ( ) ) <nl> + return sb . toString ( ) ; <nl> + <nl> + if ( i > 0 ) <nl> + sb . append ( " : " ) ; <nl> + <nl> + AbstractType < ? > type = fieldTypes . get ( i ) ; <nl> + int size = input . getInt ( ) ; <nl> + assert size > = 0 ; / / We don ' t support nulls yet , but we will likely do with # 7206 and we ' ll need <nl> + / / a way to represent it as a string ( without it conflicting with a user value ) <nl> + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; <nl> + / / We use ' : ' as delimiter so escape it if it ' s in the generated string <nl> + sb . append ( field = = null ? " null " : type . getString ( value ) . replaceAll ( " : " , " \ \ \ \ : " ) ) ; <nl> + } <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> + public ByteBuffer fromString ( String source ) <nl> + { <nl> + / / Split the input on non - escaped ' : ' characters <nl> + List < String > fieldStrings = AbstractCompositeType . split ( source ) ; <nl> + ByteBuffer [ ] fields = new ByteBuffer [ fieldStrings . size ( ) ] ; <nl> + for ( int i = 0 ; i < fieldStrings . size ( ) ; i + + ) <nl> + { <nl> + AbstractType < ? > type = fieldTypes . get ( i ) ; <nl> + / / TODO : we ' ll need to handle null somehow here once we support them <nl> + String fieldString = fieldStrings . get ( i ) . replaceAll ( " \ \ \ \ : " , " : " ) ; <nl> + fields [ i ] = type . fromString ( fieldString ) ; <nl> + } <nl> + return buildValue ( fields ) ; <nl> + } <nl> + <nl> + public TypeSerializer < ByteBuffer > getSerializer ( ) <nl> + { <nl> + return BytesSerializer . instance ; <nl> + } <nl> + <nl> @ Override <nl> public final int hashCode ( ) <nl> { <nl> - return Objects . hashCode ( keyspace , name , columnNames , types ) ; <nl> + return Objects . hashCode ( keyspace , name , fieldNames , fieldTypes ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 82 , 7 + 233 , 7 @ @ public class UserType extends CompositeType <nl> return false ; <nl> <nl> UserType that = ( UserType ) o ; <nl> - return keyspace . equals ( that . keyspace ) & & name . equals ( that . name ) & & columnNames . equals ( that . columnNames ) & & types . equals ( that . types ) ; <nl> + return keyspace . equals ( that . keyspace ) & & name . equals ( that . name ) & & fieldNames . equals ( that . fieldNames ) & & fieldTypes . equals ( that . fieldTypes ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 94 , 6 + 245 , 6 @ @ public class UserType extends CompositeType <nl> @ Override <nl> public String toString ( ) <nl> { <nl> - return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , columnNames , types ) ; <nl> + return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , fieldNames , fieldTypes ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / transport / DataType . java b / src / java / org / apache / cassandra / transport / DataType . java <nl> index 3cff973 . . 2410378 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / DataType . java <nl> + + + b / src / java / org / apache / cassandra / transport / DataType . java <nl> @ @ - 135 , 11 + 135 , 11 @ @ public enum DataType implements OptionCodec . Codecable < DataType > <nl> UserType udt = ( UserType ) value ; <nl> CBUtil . writeString ( udt . keyspace , cb ) ; <nl> CBUtil . writeString ( UTF8Type . instance . compose ( udt . name ) , cb ) ; <nl> - cb . writeShort ( udt . columnNames . size ( ) ) ; <nl> - for ( int i = 0 ; i < udt . columnNames . size ( ) ; i + + ) <nl> + cb . writeShort ( udt . fieldNames . size ( ) ) ; <nl> + for ( int i = 0 ; i < udt . fieldNames . size ( ) ; i + + ) <nl> { <nl> - CBUtil . writeString ( UTF8Type . instance . compose ( udt . columnNames . get ( i ) ) , cb ) ; <nl> - codec . writeOne ( DataType . fromType ( udt . types . get ( i ) , version ) , cb , version ) ; <nl> + CBUtil . writeString ( UTF8Type . instance . compose ( udt . fieldNames . get ( i ) ) , cb ) ; <nl> + codec . writeOne ( DataType . fromType ( udt . fieldTypes . get ( i ) , version ) , cb , version ) ; <nl> } <nl> break ; <nl> } <nl> @ @ - 166 , 10 + 166 , 10 @ @ public enum DataType implements OptionCodec . Codecable < DataType > <nl> size + = CBUtil . sizeOfString ( udt . keyspace ) ; <nl> size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . name ) ) ; <nl> size + = 2 ; <nl> - for ( int i = 0 ; i < udt . columnNames . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < udt . fieldNames . size ( ) ; i + + ) <nl> { <nl> - size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . columnNames . get ( i ) ) ) ; <nl> - size + = codec . oneSerializedSize ( DataType . fromType ( udt . types . get ( i ) , version ) , version ) ; <nl> + size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . fieldNames . get ( i ) ) ) ; <nl> + size + = codec . oneSerializedSize ( DataType . fromType ( udt . fieldTypes . get ( i ) , version ) , version ) ; <nl> } <nl> return size ; <nl> default :
NEAREST DIFF (one line): diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 958b9ae . . 0e631ea 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 1239 , 6 + 1239 , 8 @ @ syntax _ rules + = r ' ' ' <nl> | " ADD " newcol = < cident > < storageType > <nl> | " DROP " existcol = < cident > <nl> | " WITH " < cfamProperty > ( " AND " < cfamProperty > ) * <nl> + | " RENAME " existcol = < cident > " TO " newcol = < cident > <nl> + ( " AND " existcol = < cident > " TO " newcol = < cident > ) * <nl> ; <nl> ' ' ' <nl> <nl> diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py <nl> index c9dae31 . . cdbb8f4 100644 <nl> - - - a / pylib / cqlshlib / helptopics . py <nl> + + + b / pylib / cqlshlib / helptopics . py <nl> @ @ - 902 , 8 + 902 , 37 @ @ class CQL3HelpTopics ( CQLHelpTopics ) : <nl> print " HELP CREATE _ USER ; " <nl> <nl> def help _ alter ( self ) : <nl> - super ( CQL3HelpTopics , self ) . help _ alter ( ) <nl> - print " HELP ALTER _ USER ; " <nl> + print " " " <nl> + ALTER TABLE < tablename > ALTER < columnname > TYPE < type > ; <nl> + ALTER TABLE < tablename > ADD < columnname > < type > ; <nl> + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > <nl> + [ AND < columnname > TO < columnname > ] <nl> + ALTER TABLE < tablename > WITH < optionname > = < val > [ AND < optionname > = < val > [ . . . ] ] ; <nl> + <nl> + An ALTER statement is used to manipulate table metadata . It allows you <nl> + to add new typed columns , drop existing columns , change the data <nl> + storage type of existing columns , or change table properties . <nl> + No results are returned . <nl> + <nl> + See one of the following for more information : <nl> + <nl> + HELP ALTER _ ALTER ; <nl> + HELP ALTER _ ADD ; <nl> + HELP ALTER _ DROP ; <nl> + HELP ALTER _ RENAME ; <nl> + HELP ALTER _ WITH ; <nl> + " " " <nl> + <nl> + def help _ alter _ rename ( self ) : <nl> + print " " " <nl> + ALTER TABLE : renaming a column <nl> + <nl> + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > <nl> + [ AND < columnname > TO < columnname > ] <nl> + <nl> + The ALTER TABLE . . . RENAME variant renames a typed column in a column <nl> + family . <nl> + " " " <nl> <nl> def help _ drop ( self ) : <nl> super ( CQL3HelpTopics , self ) . help _ drop ( )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ef678f1 . . e7e7c7f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 16 , 6 + 16 , 7 @ @ 
 * remove unused classes ( CASSANDRA - 7197 ) 
 * Limit user types to the keyspace they are defined in ( CASSANDRA - 6643 ) 
 * Add validate method to CollectionType ( CASSANDRA - 7208 ) 
 + * New serialization format for UDT values ( CASSANDRA - 7209 ) 
 Merged from 2 . 0 : 
 * Always reallocate buffers in HSHA ( CASSANDRA - 6285 ) 
 * ( Hadoop ) support authentication in CqlRecordReader ( CASSANDRA - 7221 ) 
 diff - - git a / doc / native _ protocol _ v3 . spec b / doc / native _ protocol _ v3 . spec 
 index 6662f1c . . 6719838 100644 
 - - - a / doc / native _ protocol _ v3 . spec 
 + + + b / doc / native _ protocol _ v3 . spec 
 @ @ - 758 , 12 + 758 , 13 @ @ Table of Contents 
 
 7 . User defined types 
 
 - This section describe the serialization format for User defined types ( UDT ) values . 
 + This section describes the serialization format for User defined types ( UDT ) values . 
 UDT values are the values of the User Defined Types as defined in section 4 . 2 . 5 . 2 . 
 
 - A UDT value is a [ short ] n indicating the number of values ( field ) of UDT values 
 - followed by n elements . Each element is a [ short bytes ] representing the serialized 
 - field . 
 + A UDT value is composed of successive [ bytes ] values , one for each field of the UDT 
 + value ( in the order defined by the type ) . A UDT value will generally have one value 
 + for each field of the type it represents , but it is allowed to have less values than 
 + the type has fields . 
 
 
 8 . Result paging 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 2df42ae . . f13b408 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 216 , 8 + 216 , 8 @ @ public final class CFMetaData 
 public static final CFMetaData SchemaUserTypesCf = compile ( " CREATE TABLE " + SystemKeyspace . SCHEMA _ USER _ TYPES _ CF + " ( " 
 + " keyspace _ name text , " 
 + " type _ name text , " 
 - + " column _ names list < text > , " 
 - + " column _ types list < text > , " 
 + + " field _ names list < text > , " 
 + + " field _ types list < text > , " 
 + " PRIMARY KEY ( keyspace _ name , type _ name ) " 
 + " ) WITH COMMENT = ' Defined user types ' AND gc _ grace _ seconds = 8640 " ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / config / UTMetaData . java b / src / java / org / apache / cassandra / config / UTMetaData . java 
 index b502910 . . 178e653 100644 
 - - - a / src / java / org / apache / cassandra / config / UTMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / UTMetaData . java 
 @ @ - 53 , 8 + 53 , 8 @ @ public final class UTMetaData 
 { 
 String keyspace = row . getString ( " keyspace _ name " ) ; 
 ByteBuffer name = ByteBufferUtil . bytes ( row . getString ( " type _ name " ) ) ; 
 - List < String > rawColumns = row . getList ( " column _ names " , UTF8Type . instance ) ; 
 - List < String > rawTypes = row . getList ( " column _ types " , UTF8Type . instance ) ; 
 + List < String > rawColumns = row . getList ( " field _ names " , UTF8Type . instance ) ; 
 + List < String > rawTypes = row . getList ( " field _ types " , UTF8Type . instance ) ; 
 
 List < ByteBuffer > columns = new ArrayList < > ( rawColumns . size ( ) ) ; 
 for ( String rawColumn : rawColumns ) 
 @ @ - 97 , 13 + 97 , 13 @ @ public final class UTMetaData 
 Composite prefix = CFMetaData . SchemaUserTypesCf . comparator . make ( newType . name ) ; 
 CFRowAdder adder = new CFRowAdder ( cf , prefix , timestamp ) ; 
 
 - adder . resetCollection ( " column _ names " ) ; 
 - adder . resetCollection ( " column _ types " ) ; 
 + adder . resetCollection ( " field _ names " ) ; 
 + adder . resetCollection ( " field _ types " ) ; 
 
 - for ( ByteBuffer name : newType . columnNames ) 
 - adder . addListEntry ( " column _ names " , name ) ; 
 - for ( AbstractType < ? > type : newType . types ) 
 - adder . addListEntry ( " column _ types " , type . toString ( ) ) ; 
 + for ( ByteBuffer name : newType . fieldNames ) 
 + adder . addListEntry ( " field _ names " , name ) ; 
 + for ( AbstractType < ? > type : newType . fieldTypes ) 
 + adder . addListEntry ( " field _ types " , type . toString ( ) ) ; 
 
 return mutation ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / UserTypes . java b / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 index 2faa960 . . 651fa23 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 + + + b / src / java / org / apache / cassandra / cql3 / UserTypes . java 
 @ @ - 35 , 7 + 35 , 10 @ @ public abstract class UserTypes 
 
 public static ColumnSpecification fieldSpecOf ( ColumnSpecification column , int field ) 
 { 
 - return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( column . name + " . " + field , true ) , ( ( UserType ) column . type ) . types . get ( field ) ) ; 
 + return new ColumnSpecification ( column . ksName , 
 + column . cfName , 
 + new ColumnIdentifier ( column . name + " . " + field , true ) , 
 + ( ( UserType ) column . type ) . fieldTypes . get ( field ) ) ; 
 } 
 
 public static class Literal implements Term . Raw 
 @ @ - 54 , 9 + 57 , 9 @ @ public abstract class UserTypes 
 UserType ut = ( UserType ) receiver . type ; 
 boolean allTerminal = true ; 
 List < Term > values = new ArrayList < > ( entries . size ( ) ) ; 
 - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) 
 { 
 - ColumnIdentifier field = new ColumnIdentifier ( ut . columnNames . get ( i ) , UTF8Type . instance ) ; 
 + ColumnIdentifier field = new ColumnIdentifier ( ut . fieldNames . get ( i ) , UTF8Type . instance ) ; 
 Term value = entries . get ( field ) . prepare ( keyspace , fieldSpecOf ( receiver , i ) ) ; 
 
 if ( value instanceof Term . NonTerminal ) 
 @ @ - 74 , 9 + 77 , 9 @ @ public abstract class UserTypes 
 throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s of type % s " , receiver , receiver . type . asCQL3Type ( ) ) ) ; 
 
 UserType ut = ( UserType ) receiver . type ; 
 - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) 
 { 
 - ColumnIdentifier field = new ColumnIdentifier ( ut . columnNames . get ( i ) , UTF8Type . instance ) ; 
 + ColumnIdentifier field = new ColumnIdentifier ( ut . fieldNames . get ( i ) , UTF8Type . instance ) ; 
 Term . Raw value = entries . get ( field ) ; 
 if ( value = = null ) 
 throw new InvalidRequestException ( String . format ( " Invalid user type literal for % s : missing field % s " , receiver , field ) ) ; 
 @ @ - 140 , 7 + 143 , 7 @ @ public abstract class UserTypes 
 
 public void collectMarkerSpecification ( VariableSpecifications boundNames ) 
 { 
 - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) 
 values . get ( i ) . collectMarkerSpecification ( boundNames ) ; 
 } 
 
 @ @ - 151 , 14 + 154 , 14 @ @ public abstract class UserTypes 
 options = options . withProtocolVersion ( 3 ) ; 
 
 ByteBuffer [ ] buffers = new ByteBuffer [ values . size ( ) ] ; 
 - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) 
 { 
 ByteBuffer buffer = values . get ( i ) . bindAndGet ( options ) ; 
 if ( buffer = = null ) 
 throw new InvalidRequestException ( " null is not supported inside user type literals " ) ; 
 if ( buffer . remaining ( ) > FBUtilities . MAX _ UNSIGNED _ SHORT ) 
 throw new InvalidRequestException ( String . format ( " Value for field % s is too long . User type fields are limited to % d bytes but % d bytes provided " , 
 - UTF8Type . instance . getString ( type . columnNames . get ( i ) ) , 
 + UTF8Type . instance . getString ( type . fieldNames . get ( i ) ) , 
 FBUtilities . MAX _ UNSIGNED _ SHORT , 
 buffer . remaining ( ) ) ) ; 
 
 @ @ - 175 , 7 + 178 , 7 @ @ public abstract class UserTypes 
 @ Override 
 public ByteBuffer bindAndGet ( QueryOptions options ) throws InvalidRequestException 
 { 
 - return CompositeType . build ( bindInternal ( options ) ) ; 
 + return UserType . buildValue ( bindInternal ( options ) ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 index 3ea8d63 . . eac936f 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 @ @ - 138 , 8 + 138 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 
 private static int getIdxOfField ( UserType type , ColumnIdentifier field ) 
 { 
 - for ( int i = 0 ; i < type . types . size ( ) ; i + + ) 
 - if ( field . bytes . equals ( type . columnNames . get ( i ) ) ) 
 + for ( int i = 0 ; i < type . fieldTypes . size ( ) ; i + + ) 
 + if ( field . bytes . equals ( type . fieldNames . get ( i ) ) ) 
 return i ; 
 return - 1 ; 
 } 
 @ @ - 183 , 8 + 183 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 return updated ; 
 
 / / Otherwise , check for nesting 
 - List < AbstractType < ? > > updatedTypes = updateTypes ( ut . types , keyspace , toReplace , updated ) ; 
 - return updatedTypes = = null ? null : new UserType ( ut . keyspace , ut . name , new ArrayList < > ( ut . columnNames ) , updatedTypes ) ; 
 + List < AbstractType < ? > > updatedTypes = updateTypes ( ut . fieldTypes , keyspace , toReplace , updated ) ; 
 + return updatedTypes = = null ? null : new UserType ( ut . keyspace , ut . name , new ArrayList < > ( ut . fieldNames ) , updatedTypes ) ; 
 } 
 else if ( type instanceof CompositeType ) 
 { 
 @ @ - 275 , 12 + 275 , 12 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 if ( getIdxOfField ( toUpdate , fieldName ) > = 0 ) 
 throw new InvalidRequestException ( String . format ( " Cannot add new field % s to type % s : a field of the same name already exists " , fieldName , name ) ) ; 
 
 - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames . size ( ) + 1 ) ; 
 - newNames . addAll ( toUpdate . columnNames ) ; 
 + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames . size ( ) + 1 ) ; 
 + newNames . addAll ( toUpdate . fieldNames ) ; 
 newNames . add ( fieldName . bytes ) ; 
 
 - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types . size ( ) + 1 ) ; 
 - newTypes . addAll ( toUpdate . types ) ; 
 + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes . size ( ) + 1 ) ; 
 + newTypes . addAll ( toUpdate . fieldTypes ) ; 
 newTypes . add ( type . prepare ( keyspace ( ) ) . getType ( ) ) ; 
 
 return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; 
 @ @ - 292 , 12 + 292 , 12 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 if ( idx < 0 ) 
 throw new InvalidRequestException ( String . format ( " Unknown field % s in type % s " , fieldName , name ) ) ; 
 
 - AbstractType < ? > previous = toUpdate . types . get ( idx ) ; 
 + AbstractType < ? > previous = toUpdate . fieldTypes . get ( idx ) ; 
 if ( ! type . prepare ( keyspace ( ) ) . getType ( ) . isCompatibleWith ( previous ) ) 
 throw new InvalidRequestException ( String . format ( " Type % s is incompatible with previous type % s of field % s in user type % s " , type , previous . asCQL3Type ( ) , fieldName , name ) ) ; 
 
 - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames ) ; 
 - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types ) ; 
 + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ) ; 
 + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ) ; 
 newTypes . set ( idx , type . prepare ( keyspace ( ) ) . getType ( ) ) ; 
 
 return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; 
 @ @ - 321 , 8 + 321 , 8 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 
 protected UserType makeUpdatedType ( UserType toUpdate ) throws InvalidRequestException 
 { 
 - List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . columnNames ) ; 
 - List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . types ) ; 
 + List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ) ; 
 + List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ) ; 
 
 for ( Map . Entry < ColumnIdentifier , ColumnIdentifier > entry : renames . entrySet ( ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java 
 index aa8b769 . . cd3e3e5 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTypeStatement . java 
 @ @ - 74 , 12 + 74 , 12 @ @ public class CreateTypeStatement extends SchemaAlteringStatement 
 
 public static void checkForDuplicateNames ( UserType type ) throws InvalidRequestException 
 { 
 - for ( int i = 0 ; i < type . types . size ( ) - 1 ; i + + ) 
 + for ( int i = 0 ; i < type . fieldTypes . size ( ) - 1 ; i + + ) 
 { 
 - ByteBuffer fieldName = type . columnNames . get ( i ) ; 
 - for ( int j = i + 1 ; j < type . types . size ( ) ; j + + ) 
 + ByteBuffer fieldName = type . fieldNames . get ( i ) ; 
 + for ( int j = i + 1 ; j < type . fieldTypes . size ( ) ; j + + ) 
 { 
 - if ( fieldName . equals ( type . columnNames . get ( j ) ) ) 
 + if ( fieldName . equals ( type . fieldNames . get ( j ) ) ) 
 throw new InvalidRequestException ( String . format ( " Duplicate field name % s in type % s " , 
 UTF8Type . instance . getString ( fieldName ) , 
 UTF8Type . instance . getString ( type . name ) ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java 
 index 6521f68 . . 10fc366 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / DropTypeStatement . java 
 @ @ - 91 , 18 + 91 , 19 @ @ public class DropTypeStatement extends SchemaAlteringStatement 
 
 private boolean isUsedBy ( AbstractType < ? > toCheck ) throws RequestValidationException 
 { 
 - if ( toCheck instanceof CompositeType ) 
 + if ( toCheck instanceof UserType ) 
 { 
 - CompositeType ct = ( CompositeType ) toCheck ; 
 + UserType ut = ( UserType ) toCheck ; 
 + if ( name . getKeyspace ( ) . equals ( ut . keyspace ) & & name . getUserTypeName ( ) . equals ( ut . name ) ) 
 + return true ; 
 
 - if ( ( ct instanceof UserType ) ) 
 - { 
 - UserType ut = ( UserType ) ct ; 
 - if ( name . getKeyspace ( ) . equals ( ut . keyspace ) & & name . getUserTypeName ( ) . equals ( ut . name ) ) 
 + for ( AbstractType < ? > subtype : ut . fieldTypes ) 
 + if ( isUsedBy ( subtype ) ) 
 return true ; 
 - } 
 - 
 - / / Also reach into subtypes 
 + } 
 + else if ( toCheck instanceof CompositeType ) 
 + { 
 + CompositeType ct = ( CompositeType ) toCheck ; 
 for ( AbstractType < ? > subtype : ct . types ) 
 if ( isUsedBy ( subtype ) ) 
 return true ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / Selection . java b / src / java / org / apache / cassandra / cql3 / statements / Selection . java 
 index 3769e97 . . 4990e11 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / Selection . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / Selection . java 
 @ @ - 142 , 13 + 142 , 13 @ @ public abstract class Selection 
 throw new InvalidRequestException ( String . format ( " Invalid field selection : % s of type % s is not a user type " , withField . selected , type . asCQL3Type ( ) ) ) ; 
 
 UserType ut = ( UserType ) type ; 
 - for ( int i = 0 ; i < ut . types . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < ut . fieldTypes . size ( ) ; i + + ) 
 { 
 - if ( ! ut . columnNames . get ( i ) . equals ( withField . field . bytes ) ) 
 + if ( ! ut . fieldNames . get ( i ) . equals ( withField . field . bytes ) ) 
 continue ; 
 
 if ( metadata ! = null ) 
 - metadata . add ( makeFieldSelectSpec ( cfm , withField , ut . types . get ( i ) , raw . alias ) ) ; 
 + metadata . add ( makeFieldSelectSpec ( cfm , withField , ut . fieldTypes . get ( i ) , raw . alias ) ) ; 
 return new FieldSelector ( ut , i , selected ) ; 
 } 
 throw new InvalidRequestException ( String . format ( " % s of type % s has no field % s " , withField . selected , type . asCQL3Type ( ) , withField . field ) ) ; 
 @ @ - 472 , 13 + 472 , 13 @ @ public abstract class Selection 
 
 public AbstractType < ? > getType ( ) 
 { 
 - return type . types . get ( field ) ; 
 + return type . fieldTypes . get ( field ) ; 
 } 
 
 @ Override 
 public String toString ( ) 
 { 
 - return String . format ( " % s . % s " , selected , UTF8Type . instance . getString ( type . columnNames . get ( field ) ) ) ; 
 + return String . format ( " % s . % s " , selected , UTF8Type . instance . getString ( type . fieldNames . get ( field ) ) ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / UserType . java b / src / java / org / apache / cassandra / db / marshal / UserType . java 
 index 973a5be . . 50b3fbb 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / UserType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / UserType . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . db . marshal ; 
 
 import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 import java . util . List ; 
 
 import com . google . common . base . Objects ; 
 @ @ - 26 , 27 + 27 , 27 @ @ import com . google . common . base . Objects ; 
 import org . apache . cassandra . cql3 . CQL3Type ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . exceptions . SyntaxException ; 
 + import org . apache . cassandra . serializers . * ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . Pair ; 
 
 / * * 
 * A user defined type . 
 - * 
 - * The serialized format and sorting is exactly the one of CompositeType , but 
 - * we keep additional metadata ( the name of the type and the names 
 - * of the columns ) . 
 * / 
 - public class UserType extends CompositeType 
 + public class UserType extends AbstractType < ByteBuffer > 
 { 
 public final String keyspace ; 
 public final ByteBuffer name ; 
 - public final List < ByteBuffer > columnNames ; 
 + public final List < ByteBuffer > fieldNames ; 
 + public final List < AbstractType < ? > > fieldTypes ; 
 
 - public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > columnNames , List < AbstractType < ? > > types ) 
 + public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > fieldNames , List < AbstractType < ? > > fieldTypes ) 
 { 
 - super ( types ) ; 
 + assert fieldNames . size ( ) = = fieldTypes . size ( ) ; 
 this . keyspace = keyspace ; 
 this . name = name ; 
 - this . columnNames = columnNames ; 
 + this . fieldNames = fieldNames ; 
 + this . fieldTypes = fieldTypes ; 
 } 
 
 public static UserType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException 
 @ @ - 69 , 10 + 70 , 160 @ @ public class UserType extends CompositeType 
 return UTF8Type . instance . compose ( name ) ; 
 } 
 
 + public int compare ( ByteBuffer o1 , ByteBuffer o2 ) 
 + { 
 + if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) 
 + return o1 . hasRemaining ( ) ? 1 : o2 . hasRemaining ( ) ? - 1 : 0 ; 
 + 
 + ByteBuffer bb1 = o1 . duplicate ( ) ; 
 + ByteBuffer bb2 = o2 . duplicate ( ) ; 
 + 
 + int i = 0 ; 
 + while ( bb1 . remaining ( ) > 0 & & bb2 . remaining ( ) > 0 ) 
 + { 
 + AbstractType < ? > comparator = fieldTypes . get ( i ) ; 
 + 
 + int size1 = bb1 . getInt ( ) ; 
 + int size2 = bb2 . getInt ( ) ; 
 + 
 + / / Handle nulls 
 + if ( size1 < 0 ) 
 + { 
 + if ( size2 < 0 ) 
 + continue ; 
 + return - 1 ; 
 + } 
 + if ( size2 < 0 ) 
 + return 1 ; 
 + 
 + ByteBuffer value1 = ByteBufferUtil . readBytes ( bb1 , size1 ) ; 
 + ByteBuffer value2 = ByteBufferUtil . readBytes ( bb2 , size2 ) ; 
 + int cmp = comparator . compare ( value1 , value2 ) ; 
 + if ( cmp ! = 0 ) 
 + return cmp ; 
 + 
 + + + i ; 
 + } 
 + 
 + if ( bb1 . remaining ( ) = = 0 ) 
 + return bb2 . remaining ( ) = = 0 ? 0 : - 1 ; 
 + 
 + / / bb1 . remaining ( ) > 0 & & bb2 . remaining ( ) = = 0 
 + return 1 ; 
 + } 
 + 
 + @ Override 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 + { 
 + ByteBuffer input = bytes . duplicate ( ) ; 
 + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) 
 + { 
 + / / we allow the input to have less fields than declared so as to support field addition . 
 + if ( ! input . hasRemaining ( ) ) 
 + return ; 
 + 
 + if ( input . remaining ( ) < 4 ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read size of % dth field % s " , i , fieldNames . get ( i ) ) ) ; 
 + 
 + int size = input . getInt ( ) ; 
 + / / We don ' t handle null just yet , but we should fix that soon ( CASSANDRA - 7206 ) 
 + if ( size < 0 ) 
 + throw new MarshalException ( " Nulls are not yet supported inside UDT values " ) ; 
 + 
 + if ( input . remaining ( ) < size ) 
 + throw new MarshalException ( String . format ( " Not enough bytes to read % dth field % s " , i , fieldNames . get ( i ) ) ) ; 
 + 
 + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 + fieldTypes . get ( i ) . validate ( field ) ; 
 + } 
 + 
 + / / We ' re allowed to get less fields than declared , but not more 
 + if ( input . hasRemaining ( ) ) 
 + throw new MarshalException ( " Invalid remaining data after end of UDT value " ) ; 
 + } 
 + 
 + / * * 
 + * Split a UDT value into its fields values . 
 + * / 
 + public ByteBuffer [ ] split ( ByteBuffer value ) 
 + { 
 + ByteBuffer [ ] fields = new ByteBuffer [ fieldTypes . size ( ) ] ; 
 + ByteBuffer input = value . duplicate ( ) ; 
 + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) 
 + { 
 + if ( ! input . hasRemaining ( ) ) 
 + return Arrays . copyOfRange ( fields , 0 , i ) ; 
 + 
 + int size = input . getInt ( ) ; 
 + fields [ i ] = size < 0 ? null : ByteBufferUtil . readBytes ( input , size ) ; 
 + } 
 + return fields ; 
 + } 
 + 
 + public static ByteBuffer buildValue ( ByteBuffer [ ] fields ) 
 + { 
 + int totalLength = 0 ; 
 + for ( ByteBuffer field : fields ) 
 + totalLength + = 4 + field . remaining ( ) ; 
 + 
 + ByteBuffer result = ByteBuffer . allocate ( totalLength ) ; 
 + for ( ByteBuffer field : fields ) 
 + { 
 + result . putInt ( field . remaining ( ) ) ; 
 + result . put ( field . duplicate ( ) ) ; 
 + } 
 + result . rewind ( ) ; 
 + return result ; 
 + } 
 + 
 + @ Override 
 + public String getString ( ByteBuffer value ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + ByteBuffer input = value . duplicate ( ) ; 
 + for ( int i = 0 ; i < fieldTypes . size ( ) ; i + + ) 
 + { 
 + if ( ! input . hasRemaining ( ) ) 
 + return sb . toString ( ) ; 
 + 
 + if ( i > 0 ) 
 + sb . append ( " : " ) ; 
 + 
 + AbstractType < ? > type = fieldTypes . get ( i ) ; 
 + int size = input . getInt ( ) ; 
 + assert size > = 0 ; / / We don ' t support nulls yet , but we will likely do with # 7206 and we ' ll need 
 + / / a way to represent it as a string ( without it conflicting with a user value ) 
 + ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; 
 + / / We use ' : ' as delimiter so escape it if it ' s in the generated string 
 + sb . append ( field = = null ? " null " : type . getString ( value ) . replaceAll ( " : " , " \ \ \ \ : " ) ) ; 
 + } 
 + return sb . toString ( ) ; 
 + } 
 + 
 + public ByteBuffer fromString ( String source ) 
 + { 
 + / / Split the input on non - escaped ' : ' characters 
 + List < String > fieldStrings = AbstractCompositeType . split ( source ) ; 
 + ByteBuffer [ ] fields = new ByteBuffer [ fieldStrings . size ( ) ] ; 
 + for ( int i = 0 ; i < fieldStrings . size ( ) ; i + + ) 
 + { 
 + AbstractType < ? > type = fieldTypes . get ( i ) ; 
 + / / TODO : we ' ll need to handle null somehow here once we support them 
 + String fieldString = fieldStrings . get ( i ) . replaceAll ( " \ \ \ \ : " , " : " ) ; 
 + fields [ i ] = type . fromString ( fieldString ) ; 
 + } 
 + return buildValue ( fields ) ; 
 + } 
 + 
 + public TypeSerializer < ByteBuffer > getSerializer ( ) 
 + { 
 + return BytesSerializer . instance ; 
 + } 
 + 
 @ Override 
 public final int hashCode ( ) 
 { 
 - return Objects . hashCode ( keyspace , name , columnNames , types ) ; 
 + return Objects . hashCode ( keyspace , name , fieldNames , fieldTypes ) ; 
 } 
 
 @ Override 
 @ @ - 82 , 7 + 233 , 7 @ @ public class UserType extends CompositeType 
 return false ; 
 
 UserType that = ( UserType ) o ; 
 - return keyspace . equals ( that . keyspace ) & & name . equals ( that . name ) & & columnNames . equals ( that . columnNames ) & & types . equals ( that . types ) ; 
 + return keyspace . equals ( that . keyspace ) & & name . equals ( that . name ) & & fieldNames . equals ( that . fieldNames ) & & fieldTypes . equals ( that . fieldTypes ) ; 
 } 
 
 @ Override 
 @ @ - 94 , 6 + 245 , 6 @ @ public class UserType extends CompositeType 
 @ Override 
 public String toString ( ) 
 { 
 - return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , columnNames , types ) ; 
 + return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , fieldNames , fieldTypes ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / transport / DataType . java b / src / java / org / apache / cassandra / transport / DataType . java 
 index 3cff973 . . 2410378 100644 
 - - - a / src / java / org / apache / cassandra / transport / DataType . java 
 + + + b / src / java / org / apache / cassandra / transport / DataType . java 
 @ @ - 135 , 11 + 135 , 11 @ @ public enum DataType implements OptionCodec . Codecable < DataType > 
 UserType udt = ( UserType ) value ; 
 CBUtil . writeString ( udt . keyspace , cb ) ; 
 CBUtil . writeString ( UTF8Type . instance . compose ( udt . name ) , cb ) ; 
 - cb . writeShort ( udt . columnNames . size ( ) ) ; 
 - for ( int i = 0 ; i < udt . columnNames . size ( ) ; i + + ) 
 + cb . writeShort ( udt . fieldNames . size ( ) ) ; 
 + for ( int i = 0 ; i < udt . fieldNames . size ( ) ; i + + ) 
 { 
 - CBUtil . writeString ( UTF8Type . instance . compose ( udt . columnNames . get ( i ) ) , cb ) ; 
 - codec . writeOne ( DataType . fromType ( udt . types . get ( i ) , version ) , cb , version ) ; 
 + CBUtil . writeString ( UTF8Type . instance . compose ( udt . fieldNames . get ( i ) ) , cb ) ; 
 + codec . writeOne ( DataType . fromType ( udt . fieldTypes . get ( i ) , version ) , cb , version ) ; 
 } 
 break ; 
 } 
 @ @ - 166 , 10 + 166 , 10 @ @ public enum DataType implements OptionCodec . Codecable < DataType > 
 size + = CBUtil . sizeOfString ( udt . keyspace ) ; 
 size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . name ) ) ; 
 size + = 2 ; 
 - for ( int i = 0 ; i < udt . columnNames . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < udt . fieldNames . size ( ) ; i + + ) 
 { 
 - size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . columnNames . get ( i ) ) ) ; 
 - size + = codec . oneSerializedSize ( DataType . fromType ( udt . types . get ( i ) , version ) , version ) ; 
 + size + = CBUtil . sizeOfString ( UTF8Type . instance . compose ( udt . fieldNames . get ( i ) ) ) ; 
 + size + = codec . oneSerializedSize ( DataType . fromType ( udt . fieldTypes . get ( i ) , version ) , version ) ; 
 } 
 return size ; 
 default :

NEAREST DIFF:
diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 958b9ae . . 0e631ea 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 1239 , 6 + 1239 , 8 @ @ syntax _ rules + = r ' ' ' 
 | " ADD " newcol = < cident > < storageType > 
 | " DROP " existcol = < cident > 
 | " WITH " < cfamProperty > ( " AND " < cfamProperty > ) * 
 + | " RENAME " existcol = < cident > " TO " newcol = < cident > 
 + ( " AND " existcol = < cident > " TO " newcol = < cident > ) * 
 ; 
 ' ' ' 
 
 diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py 
 index c9dae31 . . cdbb8f4 100644 
 - - - a / pylib / cqlshlib / helptopics . py 
 + + + b / pylib / cqlshlib / helptopics . py 
 @ @ - 902 , 8 + 902 , 37 @ @ class CQL3HelpTopics ( CQLHelpTopics ) : 
 print " HELP CREATE _ USER ; " 
 
 def help _ alter ( self ) : 
 - super ( CQL3HelpTopics , self ) . help _ alter ( ) 
 - print " HELP ALTER _ USER ; " 
 + print " " " 
 + ALTER TABLE < tablename > ALTER < columnname > TYPE < type > ; 
 + ALTER TABLE < tablename > ADD < columnname > < type > ; 
 + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > 
 + [ AND < columnname > TO < columnname > ] 
 + ALTER TABLE < tablename > WITH < optionname > = < val > [ AND < optionname > = < val > [ . . . ] ] ; 
 + 
 + An ALTER statement is used to manipulate table metadata . It allows you 
 + to add new typed columns , drop existing columns , change the data 
 + storage type of existing columns , or change table properties . 
 + No results are returned . 
 + 
 + See one of the following for more information : 
 + 
 + HELP ALTER _ ALTER ; 
 + HELP ALTER _ ADD ; 
 + HELP ALTER _ DROP ; 
 + HELP ALTER _ RENAME ; 
 + HELP ALTER _ WITH ; 
 + " " " 
 + 
 + def help _ alter _ rename ( self ) : 
 + print " " " 
 + ALTER TABLE : renaming a column 
 + 
 + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > 
 + [ AND < columnname > TO < columnname > ] 
 + 
 + The ALTER TABLE . . . RENAME variant renames a typed column in a column 
 + family . 
 + " " " 
 
 def help _ drop ( self ) : 
 super ( CQL3HelpTopics , self ) . help _ drop ( )
