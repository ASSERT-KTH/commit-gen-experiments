BLEU SCORE: 0.05522397783539471

TEST MSG: Add tests for cqlsh ' s CQL parser
GENERATED MSG: cqlsh : format output properly , make prettier

TEST DIFF (one line): diff - - git a / pylib / cqlshlib / test / test _ cql _ parsing . py b / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> index f88b839 . . 717f9b6 100644 <nl> - - - a / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> + + + b / pylib / cqlshlib / test / test _ cql _ parsing . py <nl> @ @ - 17 , 78 + 17 , 698 @ @ <nl> # to configure behavior , define $ CQL _ TEST _ HOST to the destination address <nl> # for Thrift connections , and $ CQL _ TEST _ PORT to the associated port . <nl> <nl> - from . basecase import BaseTestCase , cqlsh <nl> - from . cassconnect import get _ test _ keyspace , testrun _ cqlsh , testcall _ cqlsh <nl> + from unittest import TestCase <nl> + from operator import itemgetter <nl> <nl> - class TestCqlParsing ( BaseTestCase ) : <nl> - def setUp ( self ) : <nl> - self . cqlsh _ runner = testrun _ cqlsh ( cqlver = cqlsh . DEFAULT _ CQLVER , env = { ' COLUMNS ' : ' 100000 ' } ) <nl> - self . cqlsh = self . cqlsh _ runner . _ _ enter _ _ ( ) <nl> + from . . cql3handling import CqlRuleSet <nl> <nl> - def tearDown ( self ) : <nl> - pass <nl> <nl> + class TestCqlParsing ( TestCase ) : <nl> def test _ parse _ string _ literals ( self ) : <nl> - pass <nl> + for n in [ " ' eggs ' " , " ' Sausage 1 ' " , " ' spam \ nspam \ n \ tsausage ' " , " ' ' " ] : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , <nl> + [ ( n , ' quotedStringLiteral ' ) ] ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " ' eggs ' " ) ) , <nl> + [ ( " ' eggs ' " , ' quotedStringLiteral ' ) ] ) <nl> <nl> def test _ parse _ numbers ( self ) : <nl> - pass <nl> + for n in [ ' 6 ' , ' 398 ' , ' 18018 ' ] : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , <nl> + [ ( n , ' wholenumber ' ) ] ) <nl> <nl> def test _ parse _ uuid ( self ) : <nl> - pass <nl> + uuids = [ ' 4feeae80 - e9cc - 11e4 - b571 - 0800200c9a66 ' , <nl> + ' 7142303f - 828f - 4806 - be9e - 7a973da0c3f9 ' , <nl> + ' dff8d435 - 9ca0 - 487c - b5d0 - b0fe5c5768a8 ' ] <nl> + for u in uuids : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( u ) ) , <nl> + [ ( u , ' uuid ' ) ] ) <nl> <nl> def test _ comments _ in _ string _ literals ( self ) : <nl> - pass <nl> + comment _ strings = [ " ' sausage - - comment ' " , <nl> + " ' eggs and spam / / comment string ' " , <nl> + " ' spam eggs sausage and spam / * still in string ' " ] <nl> + for s in comment _ strings : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( s ) ) , <nl> + [ ( s , ' quotedStringLiteral ' ) ] ) <nl> <nl> def test _ colons _ in _ string _ literals ( self ) : <nl> - pass <nl> + comment _ strings = [ " ' Movie Title : The Movie ' " , <nl> + " ' : a : b : c : ' " , <nl> + " ' ( > > = ) : : ( Monad m ) = > m a - > ( a - > m b ) - > m b ' " ] <nl> + for s in comment _ strings : <nl> + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( s ) ) , <nl> + [ ( s , ' quotedStringLiteral ' ) ] ) <nl> <nl> def test _ partial _ parsing ( self ) : <nl> - pass <nl> + [ parsed ] = CqlRuleSet . cql _ parse ( ' INSERT INTO ks . test ' ) <nl> + self . assertSequenceEqual ( parsed . matched , [ ] ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed . remainder ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' test ' , ' identifier ' ) ] ) <nl> <nl> def test _ parse _ select ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( ' SELECT FROM ks . tab ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' SELECT ' , ' K _ SELECT ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( ' SELECT FROM " MyTable " ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' SELECT ' , ' K _ SELECT ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' " MyTable " ' , ' quotedName ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' SELECT FROM tab WHERE foo = 3 ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' SELECT ' , ' K _ SELECT ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' foo ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 3 ' , ' wholenumber ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' SELECT FROM tab ORDER BY event _ id DESC LIMIT 1000 ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' SELECT ' , ' K _ SELECT ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ORDER ' , ' K _ ORDER ' ) , <nl> + ( ' BY ' , ' K _ BY ' ) , <nl> + ( ' event _ id ' , ' identifier ' ) , <nl> + ( ' DESC ' , ' K _ DESC ' ) , <nl> + ( ' LIMIT ' , ' K _ LIMIT ' ) , <nl> + ( ' 1000 ' , ' wholenumber ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' SELECT FROM tab WHERE clustering _ column > 200 ' <nl> + ' AND clustering _ column < 400 ALLOW FILTERING ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' SELECT ' , ' K _ SELECT ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' clustering _ column ' , ' identifier ' ) , <nl> + ( ' > ' , ' cmp ' ) , <nl> + ( ' 200 ' , ' wholenumber ' ) , <nl> + ( ' AND ' , ' K _ AND ' ) , <nl> + ( ' clustering _ column ' , ' identifier ' ) , <nl> + ( ' < ' , ' cmp ' ) , <nl> + ( ' 400 ' , ' wholenumber ' ) , <nl> + # ' allow ' and ' filtering ' are not keywords <nl> + ( ' ALLOW ' , ' identifier ' ) , <nl> + ( ' FILTERING ' , ' identifier ' ) ] ) <nl> <nl> def test _ parse _ insert ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( ' INSERT INTO mytable ( x ) VALUES ( 2 ) ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' mytable ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' VALUES ' , ' K _ VALUES ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' 2 ' , ' wholenumber ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " INSERT INTO mytable ( x , y ) VALUES ( 2 , ' eggs ' ) ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' mytable ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' VALUES ' , ' K _ VALUES ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' 2 ' , ' wholenumber ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " INSERT INTO mytable ( x , y ) VALUES ( 2 , ' eggs ' ) ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' mytable ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' VALUES ' , ' K _ VALUES ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' 2 ' , ' wholenumber ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " INSERT INTO mytable ( ids ) VALUES " <nl> + " ( 7ee251da - af52 - 49a4 - 97f4 - 3f07e406c7a7 ) " <nl> + " USING TTL 86400 ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' mytable ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' ids ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' VALUES ' , ' K _ VALUES ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' 7ee251da - af52 - 49a4 - 97f4 - 3f07e406c7a7 ' , ' uuid ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' USING ' , ' K _ USING ' ) , <nl> + ( ' TTL ' , ' K _ TTL ' ) , <nl> + ( ' 86400 ' , ' wholenumber ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " INSERT INTO test _ table ( username ) VALUES ( ' Albert ' ) " <nl> + " USING TIMESTAMP 1240003134 AND TTL 600 ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' INSERT ' , ' K _ INSERT ' ) , <nl> + ( ' INTO ' , ' K _ INTO ' ) , <nl> + ( ' test _ table ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' username ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' VALUES ' , ' K _ VALUES ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( " ' Albert ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' USING ' , ' K _ USING ' ) , <nl> + ( ' TIMESTAMP ' , ' K _ TIMESTAMP ' ) , <nl> + ( ' 1240003134 ' , ' wholenumber ' ) , <nl> + ( ' AND ' , ' K _ AND ' ) , <nl> + ( ' TTL ' , ' K _ TTL ' ) , <nl> + ( ' 600 ' , ' wholenumber ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> <nl> def test _ parse _ update ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 WHERE y = ' eggs ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab USING TTL 432000 SET x = 15 WHERE y = ' eggs ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' USING ' , ' K _ USING ' ) , <nl> + ( ' TTL ' , ' K _ TTL ' ) , <nl> + ( ' 432000 ' , ' wholenumber ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 , y = ' sausage ' " <nl> + " WHERE y = ' eggs ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' sausage ' " , ' quotedStringLiteral ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 " <nl> + " WHERE y IN ( ' eggs ' , ' sausage ' , ' spam ' ) ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' IN ' , ' K _ IN ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( " ' eggs ' " , ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' sausage ' " , ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' spam ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 " <nl> + " WHERE y = ' spam ' if z = ' sausage ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' spam ' " , ' quotedStringLiteral ' ) , <nl> + ( ' if ' , ' K _ IF ' ) , <nl> + ( ' z ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' sausage ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 WHERE y = ' spam ' " <nl> + " if z = ' sausage ' AND w = ' spam ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' spam ' " , ' quotedStringLiteral ' ) , <nl> + ( ' if ' , ' K _ IF ' ) , <nl> + ( ' z ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' sausage ' " , ' quotedStringLiteral ' ) , <nl> + ( ' AND ' , ' K _ AND ' ) , <nl> + ( ' w ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' spam ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " UPDATE tab SET x = 15 WHERE y = ' spam ' IF EXISTS " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' SET ' , ' K _ SET ' ) , <nl> + ( ' x ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 15 ' , ' wholenumber ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' y ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' spam ' " , ' quotedStringLiteral ' ) , <nl> + ( ' IF ' , ' K _ IF ' ) , <nl> + ( ' EXISTS ' , ' identifier ' ) ] ) <nl> <nl> def test _ parse _ delete ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " DELETE FROM songs WHERE songid = 444 ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DELETE ' , ' K _ DELETE ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' songs ' , ' identifier ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' songid ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' 444 ' , ' wholenumber ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " DELETE FROM songs WHERE name IN " <nl> + " ( ' Yellow Submarine ' , ' Eleanor Rigby ' ) ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DELETE ' , ' K _ DELETE ' ) , <nl> + ( ' FROM ' , ' K _ FROM ' ) , <nl> + ( ' songs ' , ' identifier ' ) , <nl> + ( ' WHERE ' , ' K _ WHERE ' ) , <nl> + ( ' name ' , ' identifier ' ) , <nl> + ( ' IN ' , ' K _ IN ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( " ' Yellow Submarine ' " , ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' Eleanor Rigby ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " DELETE task _ map [ ' 2014 - 12 - 25 ' ] from tasks where user _ id = ' Santa ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DELETE ' , ' K _ DELETE ' ) , <nl> + ( ' task _ map ' , ' identifier ' ) , <nl> + ( ' [ ' , ' brackets ' ) , <nl> + ( " ' 2014 - 12 - 25 ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ] ' , ' brackets ' ) , <nl> + ( ' from ' , ' K _ FROM ' ) , <nl> + ( ' tasks ' , ' identifier ' ) , <nl> + ( ' where ' , ' K _ WHERE ' ) , <nl> + ( ' user _ id ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' Santa ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " DELETE my _ list [ 0 ] from lists where user _ id = ' Jim ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DELETE ' , ' K _ DELETE ' ) , <nl> + ( ' my _ list ' , ' identifier ' ) , <nl> + ( ' [ ' , ' brackets ' ) , <nl> + ( ' 0 ' , ' wholenumber ' ) , <nl> + ( ' ] ' , ' brackets ' ) , <nl> + ( ' from ' , ' K _ FROM ' ) , <nl> + ( ' lists ' , ' identifier ' ) , <nl> + ( ' where ' , ' K _ WHERE ' ) , <nl> + ( ' user _ id ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( " ' Jim ' " , ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> <nl> def test _ parse _ batch ( self ) : <nl> pass <nl> <nl> def test _ parse _ create _ keyspace ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " CREATE KEYSPACE ks WITH REPLICATION = " <nl> + " { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' WITH ' , ' K _ WITH ' ) , <nl> + ( ' REPLICATION ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' { ' , ' brackets ' ) , <nl> + ( " ' class ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( " ' SimpleStrategy ' " , ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' replication _ factor ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( ' 1 ' , ' wholenumber ' ) , <nl> + ( ' } ' , ' brackets ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE KEYSPACE " Cql _ test _ KS " WITH REPLICATION = ' <nl> + " { ' class ' : ' NetworkTopologyStrategy ' , ' dc1 ' : 3 , ' dc2 ' : 2 } ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , <nl> + ( ' " Cql _ test _ KS " ' , ' quotedName ' ) , <nl> + ( ' WITH ' , ' K _ WITH ' ) , <nl> + ( ' REPLICATION ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' { ' , ' brackets ' ) , <nl> + ( " ' class ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( " ' NetworkTopologyStrategy ' " , <nl> + ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' dc1 ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( ' 3 ' , ' wholenumber ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' dc2 ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( ' 2 ' , ' wholenumber ' ) , <nl> + ( ' } ' , ' brackets ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " CREATE KEYSPACE ks WITH REPLICATION = " <nl> + " { ' class ' : ' NetworkTopologyStrategy ' , ' dc1 ' : 3 } AND " <nl> + " DURABLE _ WRITES = false ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' WITH ' , ' K _ WITH ' ) , <nl> + ( ' REPLICATION ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' { ' , ' brackets ' ) , <nl> + ( " ' class ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( " ' NetworkTopologyStrategy ' " , <nl> + ' quotedStringLiteral ' ) , <nl> + ( ' , ' , ' op ' ) , <nl> + ( " ' dc1 ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( ' 3 ' , ' wholenumber ' ) , <nl> + ( ' } ' , ' brackets ' ) , <nl> + ( ' AND ' , ' K _ AND ' ) , <nl> + # ' DURABLE _ WRITES ' is not a keyword <nl> + ( ' DURABLE _ WRITES ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' false ' , ' identifier ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> <nl> def test _ parse _ drop _ keyspace ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' DROP KEYSPACE ks ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DROP ' , ' K _ DROP ' ) , <nl> + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' DROP SCHEMA ks ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DROP ' , ' K _ DROP ' ) , <nl> + ( ' SCHEMA ' , ' K _ SCHEMA ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' DROP KEYSPACE IF EXISTS " My _ ks " ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' DROP ' , ' K _ DROP ' ) , <nl> + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , <nl> + ( ' IF ' , ' K _ IF ' ) , <nl> + ( ' EXISTS ' , ' identifier ' ) , <nl> + ( ' " My _ ks " ' , ' quotedName ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> <nl> - def test _ parse _ create _ columnfamily ( self ) : <nl> + def test _ parse _ create _ table ( self ) : <nl> pass <nl> <nl> - def test _ parse _ drop _ columnfamily ( self ) : <nl> + def test _ parse _ drop _ table ( self ) : <nl> pass <nl> <nl> def test _ parse _ truncate ( self ) : <nl> pass <nl> <nl> - def test _ parse _ alter _ columnfamily ( self ) : <nl> + def test _ parse _ alter _ table ( self ) : <nl> pass <nl> <nl> def test _ parse _ use ( self ) : <nl> pass <nl> <nl> def test _ parse _ create _ index ( self ) : <nl> - pass <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE INDEX idx ON ks . tab ( i ) ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE INDEX idx ON ks . tab ( i ) IF NOT EXISTS ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' IF ' , ' K _ IF ' ) , <nl> + ( ' NOT ' , ' K _ NOT ' ) , <nl> + ( ' EXISTS ' , ' identifier ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE INDEX idx ON tab ( KEYS ( i ) ) ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' KEYS ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE INDEX idx ON ks . tab FULL ( i ) ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' FULL ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + ' CREATE CUSTOM INDEX idx ON ks . tab ( i ) ; ' ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' CUSTOM ' , ' K _ CUSTOM ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " CREATE INDEX idx ON ks . tab ( i ) USING " <nl> + " ' org . custom . index . MyIndexClass ' ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' USING ' , ' K _ USING ' ) , <nl> + ( " ' org . custom . index . MyIndexClass ' " , <nl> + ' quotedStringLiteral ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> + <nl> + parsed = parse _ cqlsh _ statements ( <nl> + " CREATE INDEX idx ON ks . tab ( i ) WITH OPTIONS = " <nl> + " { ' storage ' : ' / mnt / ssd / indexes / ' } ; " ) <nl> + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , <nl> + [ ( ' CREATE ' , ' K _ CREATE ' ) , <nl> + ( ' INDEX ' , ' K _ INDEX ' ) , <nl> + ( ' idx ' , ' identifier ' ) , <nl> + ( ' ON ' , ' K _ ON ' ) , <nl> + ( ' ks ' , ' identifier ' ) , <nl> + ( ' . ' , ' op ' ) , <nl> + ( ' tab ' , ' identifier ' ) , <nl> + ( ' ( ' , ' op ' ) , <nl> + ( ' i ' , ' identifier ' ) , <nl> + ( ' ) ' , ' op ' ) , <nl> + ( ' WITH ' , ' K _ WITH ' ) , <nl> + ( ' OPTIONS ' , ' identifier ' ) , <nl> + ( ' = ' , ' op ' ) , <nl> + ( ' { ' , ' brackets ' ) , <nl> + ( " ' storage ' " , ' quotedStringLiteral ' ) , <nl> + ( ' : ' , ' colon ' ) , <nl> + ( " ' / mnt / ssd / indexes / ' " , ' quotedStringLiteral ' ) , <nl> + ( ' } ' , ' brackets ' ) , <nl> + ( ' ; ' , ' endtoken ' ) ] ) <nl> <nl> def test _ parse _ drop _ index ( self ) : <nl> pass <nl> <nl> def test _ parse _ select _ token ( self ) : <nl> - self . cqlsh . cmd _ and _ response ( ' INSERT INTO has _ all _ types ( num ) VALUES ( 1 ) ; ' ) <nl> - response = self . cqlsh . cmd _ and _ response ( " SELECT token ( num ) from has _ all _ types where num = 1 ; " ) <nl> - self . assertIn ( ' - 4069959284402364209 ' , response ) <nl> + pass <nl> + <nl> + <nl> + def parse _ cqlsh _ statements ( text ) : <nl> + ' ' ' <nl> + Runs its argument through the sequence of parsing steps that cqlsh takes its <nl> + input through . <nl> + <nl> + Currently does not handle batch statements . <nl> + ' ' ' <nl> + # based on onecmd <nl> + statements , _ = CqlRuleSet . cql _ split _ statements ( text ) <nl> + # stops here . For regular cql commands , onecmd just splits it and sends it <nl> + # off to the cql engine ; parsing only happens for cqlsh - specific stmts . <nl> + <nl> + return strip _ final _ empty _ items ( statements ) [ 0 ] <nl> + <nl> + <nl> + def tokens _ with _ types ( lexed ) : <nl> + for x in lexed : <nl> + assert len ( x ) > 2 , lexed <nl> + return tuple ( itemgetter ( 1 , 0 ) ( token ) for token in lexed ) <nl> + <nl> + <nl> + def strip _ final _ empty _ items ( xs ) : <nl> + ' ' ' <nl> + Returns its a copy of argument as a list , but with any terminating <nl> + subsequence of falsey values removed . <nl> + <nl> + > > > strip _ final _ empty _ items ( [ [ 3 , 4 ] , [ 5 , 6 , 7 ] , [ ] , [ ] , [ 1 ] , [ ] ] ) <nl> + [ [ 3 , 4 ] , [ 5 , 6 , 7 ] , [ ] , [ ] , [ 1 ] ] <nl> + ' ' ' <nl> + rv = list ( xs ) <nl> + <nl> + while rv and not rv [ - 1 ] : <nl> + rv = rv [ : - 1 ] <nl> + <nl> + return rv <nl> diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ parsing . py b / pylib / cqlshlib / test / test _ cqlsh _ parsing . py <nl> new file mode 100644 <nl> index 0000000 . . 7e7f08b <nl> - - - / dev / null <nl> + + + b / pylib / cqlshlib / test / test _ cqlsh _ parsing . py <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + # Licensed to the Apache Software Foundation ( ASF ) under one <nl> + # or more contributor license agreements . See the NOTICE file <nl> + # distributed with this work for additional information <nl> + # regarding copyright ownership . The ASF licenses this file <nl> + # to you under the Apache License , Version 2 . 0 ( the <nl> + # " License " ) ; you may not use this file except in compliance <nl> + # with the License . You may obtain a copy of the License at <nl> + # <nl> + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + # <nl> + # Unless required by applicable law or agreed to in writing , software <nl> + # distributed under the License is distributed on an " AS IS " BASIS , <nl> + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + # See the License for the specific language governing permissions and <nl> + # limitations under the License . <nl> + <nl> + # to configure behavior , define $ CQL _ TEST _ HOST to the destination address <nl> + # for Thrift connections , and $ CQL _ TEST _ PORT to the associated port . <nl> + <nl> + from unittest import TestCase <nl> + <nl> + <nl> + class TestCqlshParsing ( TestCase ) : <nl> + def test _ describe ( self ) : <nl> + pass <nl> +
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 14a4efe . . 32b2f4d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 50 , 6 + 50 , 8 @ @ <nl> <nl> 1 . 0 . 8 <nl> * ( cqlsh ) add DESCRIBE COLUMNFAMILIES ( CASSANDRA - 3586 ) <nl> + * ( cqlsh ) format blobs correctly and use colors to improve output <nl> + readability ( CASSANDRA - 3726 ) <nl> <nl> <nl> 1 . 0 . 7 <nl> diff - - git a / bin / cqlsh b / bin / cqlsh <nl> index a179ecb . . fd664ec 100755 <nl> - - - a / bin / cqlsh <nl> + + + b / bin / cqlsh <nl> @ @ - 44 , 6 + 44 , 8 @ @ import string <nl> import time <nl> import optparse <nl> import ConfigParser <nl> + import codecs <nl> + import re <nl> <nl> # cqlsh should run correctly when run out of a Cassandra source tree , <nl> # out of an unpacked Cassandra tarball , and after a proper package install . <nl> @ @ - 51 , 7 + 53 , 7 @ @ cqlshlibdir = os . path . join ( os . path . dirname ( _ _ file _ _ ) , ' . . ' , ' pylib ' ) <nl> if os . path . isdir ( cqlshlibdir ) : <nl> sys . path . insert ( 0 , cqlshlibdir ) <nl> <nl> - from cqlshlib import cqlhandling , pylexotron <nl> + from cqlshlib import cqlhandling , pylexotron , wcwidth <nl> from cqlshlib . cqlhandling import ( token _ dequote , cql _ dequote , cql _ escape , <nl> maybe _ cql _ escape , cql _ typename ) <nl> <nl> @ @ - 94 , 12 + 96 , 14 @ @ parser . add _ option ( ' - - debug ' , action = ' store _ true ' , <nl> help = ' Show additional debugging information ' ) <nl> <nl> <nl> - RED = " \ 033 [ 1 ; 31m % s \ 033 [ 0m " <nl> - GREEN = " \ 033 [ 1 ; 32m % s \ 033 [ 0m " <nl> - BLUE = " \ 033 [ 1 ; 34m % s \ 033 [ 0m " <nl> - YELLOW = " \ 033 [ 1 ; 33m % s \ 033 [ 0m " <nl> - CYAN = " \ 033 [ 1 ; 36m % s \ 033 [ 0m " <nl> - MAGENTA = " \ 033 [ 1 ; 35m % s \ 033 [ 0m " <nl> + RED = ' \ 033 [ 0 ; 1 ; 31m ' <nl> + GREEN = ' \ 033 [ 0 ; 1 ; 32m ' <nl> + YELLOW = ' \ 033 [ 0 ; 1 ; 33m ' <nl> + BLUE = ' \ 033 [ 0 ; 1 ; 34m ' <nl> + MAGENTA = ' \ 033 [ 0 ; 1 ; 35m ' <nl> + CYAN = ' \ 033 [ 0 ; 1 ; 36m ' <nl> + WHITE = ' \ 033 [ 0 ; 1 ; 37m ' <nl> + ANSI _ RESET = ' \ 033 [ 0m ' <nl> <nl> CQL _ ERRORS = ( cql . Error , ) <nl> try : <nl> @ @ - 215 , 16 + 219 , 113 @ @ def trim _ if _ present ( s , prefix ) : <nl> return s [ len ( prefix ) : ] <nl> return s <nl> <nl> + class FormattedValue : <nl> + def _ _ init _ _ ( self , strval , coloredval , displaywidth ) : <nl> + self . strval = strval <nl> + self . coloredval = coloredval <nl> + self . displaywidth = displaywidth <nl> + <nl> + def _ pad ( self , width , fill = ' ' ) : <nl> + if width > self . displaywidth : <nl> + return fill * ( width - self . displaywidth ) <nl> + else : <nl> + return ' ' <nl> + <nl> + def rjust ( self , width , fill = ' ' ) : <nl> + " " " <nl> + Similar to self . strval . rjust ( width ) , but takes expected terminal <nl> + display width into account for special characters , and does not <nl> + take color escape codes into account . <nl> + " " " <nl> + return self . _ pad ( width , fill ) + self . strval <nl> + <nl> + def color _ rjust ( self , width , fill = ' ' ) : <nl> + " " " <nl> + Similar to self . rjust ( width ) , but uses this value ' s colored <nl> + representation , and does not take color escape codes into account <nl> + in determining width . <nl> + " " " <nl> + return self . _ pad ( width , fill ) + self . coloredval <nl> + <nl> + controlchars _ re = re . compile ( r ' [ \ x00 - \ x31 \ x7f - \ xa0 ] ' ) <nl> + <nl> + def _ show _ control _ chars ( match ) : <nl> + txt = repr ( match . group ( 0 ) ) <nl> + if txt . startswith ( ' u ' ) : <nl> + txt = txt [ 2 : - 1 ] <nl> + else : <nl> + txt = txt [ 1 : - 1 ] <nl> + return txt <nl> + <nl> + bits _ to _ turn _ red _ re = re . compile ( r ' \ \ ( [ ^ uUx ] | u [ 0 - 9a - fA - F ] { 4 } | x [ 0 - 9a - fA - F ] { 2 } | U [ 0 - 9a - fA - F ] { 8 } ) ' ) <nl> + <nl> + def _ turn _ bits _ red ( match ) : <nl> + txt = match . group ( 0 ) <nl> + if txt = = ' \ \ \ \ ' : <nl> + return ' \ \ ' <nl> + return RED + txt + YELLOW <nl> + <nl> + def format _ value ( val , casstype , output _ encoding , addcolor = False , time _ format = ' ' , float _ precision = 3 ) : <nl> + color = YELLOW <nl> + coloredval = None <nl> + displaywidth = None <nl> + <nl> + if val is None : <nl> + bval = ' null ' <nl> + color = RED <nl> + elif casstype = = ' UTF8Type ' : <nl> + escapedval = val . replace ( u ' \ \ ' , u ' \ \ \ \ ' ) <nl> + escapedval = controlchars _ re . sub ( _ show _ control _ chars , escapedval ) <nl> + bval = escapedval . encode ( output _ encoding , errors = ' backslashreplace ' ) <nl> + displaywidth = wcwidth . wcswidth ( bval . decode ( output _ encoding ) ) <nl> + if addcolor : <nl> + coloredval = YELLOW + bits _ to _ turn _ red _ re . sub ( _ turn _ bits _ red , bval ) + ANSI _ RESET <nl> + elif casstype = = ' DateType ' : <nl> + timestamp = time . localtime ( val ) <nl> + bval = time . strftime ( time _ format , timestamp ) <nl> + color = GREEN <nl> + elif casstype in ( ' LongType ' , ' Int32Type ' , ' IntegerType ' ) : <nl> + # base - 10 only for now ; support others ? <nl> + bval = str ( val ) <nl> + color = GREEN <nl> + elif casstype in ( ' FloatType ' , ' DoubleType ' ) : <nl> + bval = ' % . * g ' % ( float _ precision , val ) <nl> + color = GREEN <nl> + elif casstype in ( ' DecimalType ' , ' UUIDType ' , ' BooleanType ' ) : <nl> + # let python do these for us <nl> + bval = str ( val ) <nl> + color = GREEN <nl> + elif casstype = = ' BytesType ' : <nl> + bval = ' ' . join ( ' % 02x ' % ord ( c ) for c in val ) <nl> + color = RED <nl> + else : <nl> + # AsciiType is the only other one known right now , but handle others <nl> + escapedval = val . replace ( ' \ \ ' , ' \ \ \ \ ' ) <nl> + bval = controlchars _ re . sub ( _ show _ control _ chars , escapedval ) <nl> + if addcolor : <nl> + coloredval = YELLOW + bits _ to _ turn _ red _ re . sub ( _ turn _ bits _ red , bval ) + ANSI _ RESET <nl> + <nl> + if displaywidth is None : <nl> + displaywidth = len ( bval ) <nl> + if not addcolor : <nl> + coloredval = bval <nl> + elif coloredval is None : <nl> + coloredval = color + bval + ANSI _ RESET <nl> + <nl> + return FormattedValue ( bval , coloredval , displaywidth ) <nl> + <nl> class Shell ( cmd . Cmd ) : <nl> default _ prompt = " cqlsh > " <nl> continue _ prompt = " . . . " <nl> keyspace _ prompt = " cqlsh : % s > " <nl> keyspace _ continue _ prompt = " % s . . . " <nl> + display _ time _ format = ' % Y - % m - % d % H : % M : % S % z ' <nl> + display _ float _ precision = 3 <nl> num _ retries = 4 <nl> debug = False <nl> <nl> def _ _ init _ _ ( self , hostname , port , color = False , username = None , <nl> - password = None , completekey = ' tab ' ) : <nl> + password = None , encoding = None , completekey = ' tab ' ) : <nl> cmd . Cmd . _ _ init _ _ ( self , completekey = completekey ) <nl> self . hostname = hostname <nl> self . port = port <nl> @ @ - 233 , 8 + 334 , 13 @ @ class Shell ( cmd . Cmd ) : <nl> <nl> self . current _ keyspace = None <nl> <nl> - self . statement = StringIO ( ) <nl> self . color = color <nl> + if encoding is None : <nl> + encoding = sys . stdout . encoding <nl> + self . encoding = encoding <nl> + self . output _ codec = codecs . lookup ( encoding ) <nl> + <nl> + self . statement = StringIO ( ) <nl> self . in _ comment = False <nl> self . schema _ overrides = { } <nl> <nl> @ @ - 245 , 6 + 351 , 11 @ @ class Shell ( cmd . Cmd ) : <nl> else : <nl> self . prompt = " " <nl> <nl> + def myformat _ value ( self , val , casstype ) : <nl> + return format _ value ( val , casstype , self . output _ codec . name , <nl> + addcolor = self . color , time _ format = self . display _ time _ format , <nl> + float _ precision = self . display _ float _ precision ) <nl> + <nl> def report _ connection ( self ) : <nl> self . show _ host ( ) <nl> self . show _ version ( ) <nl> @ @ - 562 , 43 + 673 , 32 @ @ class Shell ( cmd . Cmd ) : <nl> self . printout ( " " ) <nl> <nl> def print _ static _ result ( self ) : <nl> - # first pass , get widths <nl> - widths = defaultdict ( lambda : 0 ) <nl> - for row in self . cursor : <nl> - for desc , value in zip ( self . cursor . description , row ) : <nl> - name = desc [ 0 ] <nl> - widths [ name ] = max ( widths [ name ] , len ( str ( name ) ) , len ( str ( value ) ) ) <nl> - self . cursor . _ reset ( ) <nl> + colnames , coltypes = zip ( * self . cursor . description ) [ : 2 ] <nl> + formatted _ data = [ map ( self . myformat _ value , row , coltypes ) for row in self . cursor ] <nl> + <nl> + # determine column widths <nl> + widths = map ( len , colnames ) <nl> + for fmtrow in formatted _ data : <nl> + for num , col in enumerate ( fmtrow ) : <nl> + widths [ num ] = max ( widths [ num ] , len ( col . strval ) ) <nl> <nl> # print header <nl> - for desc in self . cursor . description : <nl> - name = desc [ 0 ] <nl> - width = widths [ name ] <nl> - self . printout ( " " , newline = False ) <nl> - self . printout ( string . rjust ( str ( name ) , width ) , MAGENTA , False ) <nl> - self . printout ( " | " , newline = False ) <nl> - self . printout ( " " ) <nl> + header = ' | ' . join ( self . applycolor ( name . ljust ( w ) , MAGENTA ) for ( name , w ) in zip ( colnames , widths ) ) <nl> + print ' ' + header . rstrip ( ) <nl> + print ' - % s - ' % ' - + - ' . join ( ' - ' * w for w in widths ) <nl> <nl> # print row data <nl> - for row in self . cursor : <nl> - for desc , value in zip ( self . cursor . description , row ) : <nl> - name = desc [ 0 ] <nl> - width = widths [ desc [ 0 ] ] <nl> - self . printout ( " " , newline = False ) <nl> - self . printout ( string . rjust ( str ( value ) , width ) , YELLOW , False ) <nl> - self . printout ( " | " , newline = False ) <nl> - self . printout ( " " ) <nl> + for row in formatted _ data : <nl> + line = ' | ' . join ( col . color _ rjust ( w ) for ( col , w ) in zip ( row , widths ) ) <nl> + print ' ' + line <nl> <nl> def print _ dynamic _ result ( self ) : <nl> for row in self . cursor : <nl> - self . printout ( " " , newline = False ) <nl> - for desc , value in zip ( self . cursor . description , row ) : <nl> - name = desc [ 0 ] <nl> - self . printout ( str ( name ) , MAGENTA , False ) <nl> - self . printout ( " , " , newline = False ) <nl> - self . printout ( str ( value ) , YELLOW , False ) <nl> - self . printout ( " | " , newline = False ) <nl> - self . printout ( " " ) <nl> + colnames , coltypes = zip ( * self . cursor . description ) [ : 2 ] <nl> + colnames = [ self . applycolor ( name , MAGENTA ) for name in colnames ] <nl> + colvals = [ self . myformat _ value ( val , casstype ) for ( val , casstype ) in zip ( row , coltypes ) ] <nl> + line = ' | ' . join ( name + ' , ' + col . coloredval for ( col , name ) in zip ( colvals , colnames ) ) <nl> + print ' ' + line <nl> <nl> def emptyline ( self ) : <nl> pass <nl> @ @ - 946 , 10 + 1046 , 109 @ @ class Shell ( cmd . Cmd ) : <nl> cmd . Cmd . do _ help ( self , cql _ dequote ( t ) . lower ( ) ) <nl> <nl> def help _ types ( self ) : <nl> - self . printout ( " CQL types recognized by this version of cqlsh : \ n " ) <nl> + self . printout ( " \ n CQL types recognized by this version of cqlsh : \ n " ) <nl> for t in cqlhandling . cql _ types : <nl> - self . printout ( ' ' + t ) <nl> - self . printout ( ' ' ) <nl> + self . printout ( ' ' + t ) <nl> + print " " " <nl> + For information on the various recognizable input formats for these <nl> + types , or on controlling the formatting of cqlsh query output , see <nl> + one of the following topics : <nl> + <nl> + HELP TIMESTAMP _ INPUT <nl> + HELP BLOB _ INPUT <nl> + HELP UUID _ INPUT <nl> + HELP BOOLEAN _ INPUT <nl> + <nl> + HELP TEXT _ OUTPUT <nl> + HELP TIMESTAMP _ OUTPUT <nl> + " " " <nl> + <nl> + def help _ timestamp _ input ( self ) : <nl> + print " " " <nl> + Timestamp input <nl> + <nl> + CQL supports any of the following ISO 8601 formats for timestamp <nl> + specification : <nl> + <nl> + yyyy - mm - dd HH : mm <nl> + yyyy - mm - dd HH : mm : ss <nl> + yyyy - mm - dd HH : mmZ <nl> + yyyy - mm - dd HH : mm : ssZ <nl> + yyyy - mm - dd ' T ' HH : mm <nl> + yyyy - mm - dd ' T ' HH : mmZ <nl> + yyyy - mm - dd ' T ' HH : mm : ss <nl> + yyyy - mm - dd ' T ' HH : mm : ssZ <nl> + yyyy - mm - dd <nl> + yyyy - mm - ddZ <nl> + <nl> + The Z in these formats refers to an RFC - 822 4 - digit time zone , <nl> + expressing the time zone ' s difference from UTC . For example , a <nl> + timestamp in Pacific Standard Time might be given thus : <nl> + <nl> + 2012 - 01 - 20 16 : 14 : 12 - 0800 <nl> + <nl> + If no time zone is supplied , the current time zone for the Cassandra <nl> + server node will be used . <nl> + " " " <nl> + <nl> + def help _ blob _ input ( self ) : <nl> + print " " " <nl> + Blob input <nl> + <nl> + CQL blob data must be specified in a string literal as hexidecimal <nl> + data . Example : to store the ASCII values for the characters in the <nl> + string " CQL " , use ' 43514c ' . <nl> + " " " <nl> + <nl> + def help _ uuid _ input ( self ) : <nl> + print " " " <nl> + UUID input <nl> + <nl> + UUIDs may be specified in CQL using 32 hexidecimal characters , <nl> + split up using dashes in the standard UUID format : <nl> + <nl> + XXXXXXXX - XXXX - XXXX - XXXX - XXXXXXXXXXXX <nl> + " " " <nl> + <nl> + def help _ boolean _ input ( self ) : <nl> + print " " " <nl> + Boolean input <nl> + <nl> + CQL accepts the strings ' true ' and ' false ' ( case insensitive ) <nl> + as input for boolean types . <nl> + " " " <nl> + <nl> + def help _ text _ output ( self ) : <nl> + print " " " <nl> + Textual output <nl> + <nl> + When control characters , or other characters which can ' t be encoded <nl> + in your current locale , are found in values of ' text ' or ' ascii ' <nl> + types , it will be shown as a backslash escape . If color is enabled , <nl> + any such backslash escapes will be shown in a different color from <nl> + the surrounding text . <nl> + <nl> + Unicode code points in your data will be output intact , if the <nl> + encoding for your locale is capable of decoding them . If you prefer <nl> + that non - ascii characters be shown with Python - style " \ \ uABCD " <nl> + escape sequences , invoke cqlsh with an ASCII locale ( for example , <nl> + by setting the $ LANG environment variable to " C " ) . <nl> + " " " <nl> + <nl> + help _ ascii _ output = help _ text _ output <nl> + <nl> + def help _ timestamp _ output ( self ) : <nl> + print " " " <nl> + Timestamp output <nl> + <nl> + Cqlsh will display timestamps in this format : <nl> + <nl> + yyyy - mm - dd HH : mm : ssZ <nl> + <nl> + which is a format acceptable as CQL timestamp input as well . It is <nl> + planned that cqlsh should allow the user to change that output format <nl> + if desired , but that feature is not yet available . <nl> + " " " <nl> <nl> def help _ select _ expr ( self ) : <nl> print " " " <nl> @ @ - 1466 , 17 + 1665 , 18 @ @ class Shell ( cmd . Cmd ) : <nl> for information about the supported parameter names and values ) . <nl> " " " <nl> <nl> - def printout ( self , text , color = None , newline = True , out = sys . stdout ) : <nl> + def applycolor ( self , text , color = None ) : <nl> if not color or not self . color : <nl> - out . write ( text ) <nl> - else : <nl> - out . write ( color % text ) <nl> + return text <nl> + return color + text + ANSI _ RESET <nl> <nl> - if newline : <nl> - out . write ( " \ n " ) <nl> + def printout ( self , text , color = None , newline = True , out = None ) : <nl> + if out is None : <nl> + out = sys . stdout <nl> + out . write ( self . applycolor ( str ( text ) , color ) + ( ' \ n ' if newline else ' ' ) ) <nl> <nl> def printerr ( self , text , color = RED , newline = True ) : <nl> - self . printout ( text , color , newline , sys . stderr ) <nl> + self . printout ( text , color , newline = newline , out = sys . stderr ) <nl> <nl> def add _ assumption ( self , ksname , cfname , colname , valtype , valclass ) : <nl> try : <nl> diff - - git a / pylib / cqlshlib / wcwidth . py b / pylib / cqlshlib / wcwidth . py <nl> new file mode 100644 <nl> index 0000000 . . 43a4aca <nl> - - - / dev / null <nl> + + + b / pylib / cqlshlib / wcwidth . py <nl> @ @ - 0 , 0 + 1 , 367 @ @ <nl> + # Licensed to the Apache Software Foundation ( ASF ) under one <nl> + # or more contributor license agreements . See the NOTICE file <nl> + # distributed with this work for additional information <nl> + # regarding copyright ownership . The ASF licenses this file <nl> + # to you under the Apache License , Version 2 . 0 ( the <nl> + # " License " ) ; you may not use this file except in compliance <nl> + # with the License . You may obtain a copy of the License at <nl> + # <nl> + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + # <nl> + # Unless required by applicable law or agreed to in writing , software <nl> + # distributed under the License is distributed on an " AS IS " BASIS , <nl> + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + # See the License for the specific language governing permissions and <nl> + # limitations under the License . <nl> + <nl> + # adapted from http : / / www . cl . cam . ac . uk / ~ mgk25 / ucs / wcwidth . c <nl> + # - thepaul <nl> + <nl> + # This is an implementation of wcwidth ( ) and wcswidth ( ) ( defined in <nl> + # IEEE Std 1002 . 1 - 2001 ) for Unicode . <nl> + # <nl> + # http : / / www . opengroup . org / onlinepubs / 007904975 / functions / wcwidth . html <nl> + # http : / / www . opengroup . org / onlinepubs / 007904975 / functions / wcswidth . html <nl> + # <nl> + # In fixed - width output devices , Latin characters all occupy a single <nl> + # " cell " position of equal width , whereas ideographic CJK characters <nl> + # occupy two such cells . Interoperability between terminal - line <nl> + # applications and ( teletype - style ) character terminals using the <nl> + # UTF - 8 encoding requires agreement on which character should advance <nl> + # the cursor by how many cell positions . No established formal <nl> + # standards exist at present on which Unicode character shall occupy <nl> + # how many cell positions on character terminals . These routines are <nl> + # a first attempt of defining such behavior based on simple rules <nl> + # applied to data provided by the Unicode Consortium . <nl> + # <nl> + # For some graphical characters , the Unicode standard explicitly <nl> + # defines a character - cell width via the definition of the East Asian <nl> + # FullWidth ( F ) , Wide ( W ) , Half - width ( H ) , and Narrow ( Na ) classes . <nl> + # In all these cases , there is no ambiguity about which width a <nl> + # terminal shall use . For characters in the East Asian Ambiguous ( A ) <nl> + # class , the width choice depends purely on a preference of backward <nl> + # compatibility with either historic CJK or Western practice . <nl> + # Choosing single - width for these characters is easy to justify as <nl> + # the appropriate long - term solution , as the CJK practice of <nl> + # displaying these characters as double - width comes from historic <nl> + # implementation simplicity ( 8 - bit encoded characters were displayed <nl> + # single - width and 16 - bit ones double - width , even for Greek , <nl> + # Cyrillic , etc . ) and not any typographic considerations . <nl> + # <nl> + # Much less clear is the choice of width for the Not East Asian <nl> + # ( Neutral ) class . Existing practice does not dictate a width for any <nl> + # of these characters . It would nevertheless make sense <nl> + # typographically to allocate two character cells to characters such <nl> + # as for instance EM SPACE or VOLUME INTEGRAL , which cannot be <nl> + # represented adequately with a single - width glyph . The following <nl> + # routines at present merely assign a single - cell width to all <nl> + # neutral characters , in the interest of simplicity . This is not <nl> + # entirely satisfactory and should be reconsidered before <nl> + # establishing a formal standard in this area . At the moment , the <nl> + # decision which Not East Asian ( Neutral ) characters should be <nl> + # represented by double - width glyphs cannot yet be answered by <nl> + # applying a simple rule from the Unicode database content . Setting <nl> + # up a proper standard for the behavior of UTF - 8 character terminals <nl> + # will require a careful analysis not only of each Unicode character , <nl> + # but also of each presentation form , something the author of these <nl> + # routines has avoided to do so far . <nl> + # <nl> + # http : / / www . unicode . org / unicode / reports / tr11 / <nl> + # <nl> + # Markus Kuhn - - 2007 - 05 - 26 ( Unicode 5 . 0 ) <nl> + # <nl> + # Permission to use , copy , modify , and distribute this software <nl> + # for any purpose and without fee is hereby granted . The author <nl> + # disclaims all warranties with regard to this software . <nl> + # <nl> + # Latest C version : http : / / www . cl . cam . ac . uk / ~ mgk25 / ucs / wcwidth . c <nl> + <nl> + # auxiliary function for binary search in interval table <nl> + def bisearch ( ucs , table ) : <nl> + min = 0 <nl> + max = len ( table ) - 1 <nl> + if ucs < table [ 0 ] [ 0 ] or ucs > table [ max ] [ 1 ] : <nl> + return 0 <nl> + while max > = min : <nl> + mid = ( min + max ) / 2 <nl> + if ucs > table [ mid ] [ 1 ] : <nl> + min = mid + 1 <nl> + elif ucs < table [ mid ] [ 0 ] : <nl> + max = mid - 1 <nl> + else : <nl> + return 1 <nl> + return 0 <nl> + <nl> + # The following two functions define the column width of an ISO 10646 <nl> + # character as follows : <nl> + # <nl> + # - The null character ( U + 0000 ) has a column width of 0 . <nl> + # <nl> + # - Other C0 / C1 control characters and DEL will lead to a return <nl> + # value of - 1 . <nl> + # <nl> + # - Non - spacing and enclosing combining characters ( general <nl> + # category code Mn or Me in the Unicode database ) have a <nl> + # column width of 0 . <nl> + # <nl> + # - SOFT HYPHEN ( U + 00AD ) has a column width of 1 . <nl> + # <nl> + # - Other format characters ( general category code Cf in the Unicode <nl> + # database ) and ZERO WIDTH SPACE ( U + 200B ) have a column width of 0 . <nl> + # <nl> + # - Hangul Jamo medial vowels and final consonants ( U + 1160 - U + 11FF ) <nl> + # have a column width of 0 . <nl> + # <nl> + # - Spacing characters in the East Asian Wide ( W ) or East Asian <nl> + # Full - width ( F ) category as defined in Unicode Technical <nl> + # Report # 11 have a column width of 2 . <nl> + # <nl> + # - All remaining characters ( including all printable <nl> + # ISO 8859 - 1 and WGL4 characters , Unicode control characters , <nl> + # etc . ) have a column width of 1 . <nl> + # <nl> + # This implementation assumes that wchar _ t characters are encoded <nl> + # in ISO 10646 . <nl> + <nl> + # sorted list of non - overlapping intervals of non - spacing characters <nl> + # generated by " uniset + cat = Me + cat = Mn + cat = Cf - 00AD + 1160 - 11FF + 200B c " <nl> + combining = ( <nl> + ( 0x0300 , 0x036F ) , ( 0x0483 , 0x0486 ) , ( 0x0488 , 0x0489 ) , <nl> + ( 0x0591 , 0x05BD ) , ( 0x05BF , 0x05BF ) , ( 0x05C1 , 0x05C2 ) , <nl> + ( 0x05C4 , 0x05C5 ) , ( 0x05C7 , 0x05C7 ) , ( 0x0600 , 0x0603 ) , <nl> + ( 0x0610 , 0x0615 ) , ( 0x064B , 0x065E ) , ( 0x0670 , 0x0670 ) , <nl> + ( 0x06D6 , 0x06E4 ) , ( 0x06E7 , 0x06E8 ) , ( 0x06EA , 0x06ED ) , <nl> + ( 0x070F , 0x070F ) , ( 0x0711 , 0x0711 ) , ( 0x0730 , 0x074A ) , <nl> + ( 0x07A6 , 0x07B0 ) , ( 0x07EB , 0x07F3 ) , ( 0x0901 , 0x0902 ) , <nl> + ( 0x093C , 0x093C ) , ( 0x0941 , 0x0948 ) , ( 0x094D , 0x094D ) , <nl> + ( 0x0951 , 0x0954 ) , ( 0x0962 , 0x0963 ) , ( 0x0981 , 0x0981 ) , <nl> + ( 0x09BC , 0x09BC ) , ( 0x09C1 , 0x09C4 ) , ( 0x09CD , 0x09CD ) , <nl> + ( 0x09E2 , 0x09E3 ) , ( 0x0A01 , 0x0A02 ) , ( 0x0A3C , 0x0A3C ) , <nl> + ( 0x0A41 , 0x0A42 ) , ( 0x0A47 , 0x0A48 ) , ( 0x0A4B , 0x0A4D ) , <nl> + ( 0x0A70 , 0x0A71 ) , ( 0x0A81 , 0x0A82 ) , ( 0x0ABC , 0x0ABC ) , <nl> + ( 0x0AC1 , 0x0AC5 ) , ( 0x0AC7 , 0x0AC8 ) , ( 0x0ACD , 0x0ACD ) , <nl> + ( 0x0AE2 , 0x0AE3 ) , ( 0x0B01 , 0x0B01 ) , ( 0x0B3C , 0x0B3C ) , <nl> + ( 0x0B3F , 0x0B3F ) , ( 0x0B41 , 0x0B43 ) , ( 0x0B4D , 0x0B4D ) , <nl> + ( 0x0B56 , 0x0B56 ) , ( 0x0B82 , 0x0B82 ) , ( 0x0BC0 , 0x0BC0 ) , <nl> + ( 0x0BCD , 0x0BCD ) , ( 0x0C3E , 0x0C40 ) , ( 0x0C46 , 0x0C48 ) , <nl> + ( 0x0C4A , 0x0C4D ) , ( 0x0C55 , 0x0C56 ) , ( 0x0CBC , 0x0CBC ) , <nl> + ( 0x0CBF , 0x0CBF ) , ( 0x0CC6 , 0x0CC6 ) , ( 0x0CCC , 0x0CCD ) , <nl> + ( 0x0CE2 , 0x0CE3 ) , ( 0x0D41 , 0x0D43 ) , ( 0x0D4D , 0x0D4D ) , <nl> + ( 0x0DCA , 0x0DCA ) , ( 0x0DD2 , 0x0DD4 ) , ( 0x0DD6 , 0x0DD6 ) , <nl> + ( 0x0E31 , 0x0E31 ) , ( 0x0E34 , 0x0E3A ) , ( 0x0E47 , 0x0E4E ) , <nl> + ( 0x0EB1 , 0x0EB1 ) , ( 0x0EB4 , 0x0EB9 ) , ( 0x0EBB , 0x0EBC ) , <nl> + ( 0x0EC8 , 0x0ECD ) , ( 0x0F18 , 0x0F19 ) , ( 0x0F35 , 0x0F35 ) , <nl> + ( 0x0F37 , 0x0F37 ) , ( 0x0F39 , 0x0F39 ) , ( 0x0F71 , 0x0F7E ) , <nl> + ( 0x0F80 , 0x0F84 ) , ( 0x0F86 , 0x0F87 ) , ( 0x0F90 , 0x0F97 ) , <nl> + ( 0x0F99 , 0x0FBC ) , ( 0x0FC6 , 0x0FC6 ) , ( 0x102D , 0x1030 ) , <nl> + ( 0x1032 , 0x1032 ) , ( 0x1036 , 0x1037 ) , ( 0x1039 , 0x1039 ) , <nl> + ( 0x1058 , 0x1059 ) , ( 0x1160 , 0x11FF ) , ( 0x135F , 0x135F ) , <nl> + ( 0x1712 , 0x1714 ) , ( 0x1732 , 0x1734 ) , ( 0x1752 , 0x1753 ) , <nl> + ( 0x1772 , 0x1773 ) , ( 0x17B4 , 0x17B5 ) , ( 0x17B7 , 0x17BD ) , <nl> + ( 0x17C6 , 0x17C6 ) , ( 0x17C9 , 0x17D3 ) , ( 0x17DD , 0x17DD ) , <nl> + ( 0x180B , 0x180D ) , ( 0x18A9 , 0x18A9 ) , ( 0x1920 , 0x1922 ) , <nl> + ( 0x1927 , 0x1928 ) , ( 0x1932 , 0x1932 ) , ( 0x1939 , 0x193B ) , <nl> + ( 0x1A17 , 0x1A18 ) , ( 0x1B00 , 0x1B03 ) , ( 0x1B34 , 0x1B34 ) , <nl> + ( 0x1B36 , 0x1B3A ) , ( 0x1B3C , 0x1B3C ) , ( 0x1B42 , 0x1B42 ) , <nl> + ( 0x1B6B , 0x1B73 ) , ( 0x1DC0 , 0x1DCA ) , ( 0x1DFE , 0x1DFF ) , <nl> + ( 0x200B , 0x200F ) , ( 0x202A , 0x202E ) , ( 0x2060 , 0x2063 ) , <nl> + ( 0x206A , 0x206F ) , ( 0x20D0 , 0x20EF ) , ( 0x302A , 0x302F ) , <nl> + ( 0x3099 , 0x309A ) , ( 0xA806 , 0xA806 ) , ( 0xA80B , 0xA80B ) , <nl> + ( 0xA825 , 0xA826 ) , ( 0xFB1E , 0xFB1E ) , ( 0xFE00 , 0xFE0F ) , <nl> + ( 0xFE20 , 0xFE23 ) , ( 0xFEFF , 0xFEFF ) , ( 0xFFF9 , 0xFFFB ) , <nl> + ( 0x10A01 , 0x10A03 ) , ( 0x10A05 , 0x10A06 ) , ( 0x10A0C , 0x10A0F ) , <nl> + ( 0x10A38 , 0x10A3A ) , ( 0x10A3F , 0x10A3F ) , ( 0x1D167 , 0x1D169 ) , <nl> + ( 0x1D173 , 0x1D182 ) , ( 0x1D185 , 0x1D18B ) , ( 0x1D1AA , 0x1D1AD ) , <nl> + ( 0x1D242 , 0x1D244 ) , ( 0xE0001 , 0xE0001 ) , ( 0xE0020 , 0xE007F ) , <nl> + ( 0xE0100 , 0xE01EF ) <nl> + ) <nl> + <nl> + # sorted list of non - overlapping intervals of East Asian Ambiguous <nl> + # characters , generated by " uniset + WIDTH - A - cat = Me - cat = Mn - cat = Cf c " <nl> + ambiguous = ( <nl> + ( 0x00A1 , 0x00A1 ) , ( 0x00A4 , 0x00A4 ) , ( 0x00A7 , 0x00A8 ) , <nl> + ( 0x00AA , 0x00AA ) , ( 0x00AE , 0x00AE ) , ( 0x00B0 , 0x00B4 ) , <nl> + ( 0x00B6 , 0x00BA ) , ( 0x00BC , 0x00BF ) , ( 0x00C6 , 0x00C6 ) , <nl> + ( 0x00D0 , 0x00D0 ) , ( 0x00D7 , 0x00D8 ) , ( 0x00DE , 0x00E1 ) , <nl> + ( 0x00E6 , 0x00E6 ) , ( 0x00E8 , 0x00EA ) , ( 0x00EC , 0x00ED ) , <nl> + ( 0x00F0 , 0x00F0 ) , ( 0x00F2 , 0x00F3 ) , ( 0x00F7 , 0x00FA ) , <nl> + ( 0x00FC , 0x00FC ) , ( 0x00FE , 0x00FE ) , ( 0x0101 , 0x0101 ) , <nl> + ( 0x0111 , 0x0111 ) , ( 0x0113 , 0x0113 ) , ( 0x011B , 0x011B ) , <nl> + ( 0x0126 , 0x0127 ) , ( 0x012B , 0x012B ) , ( 0x0131 , 0x0133 ) , <nl> + ( 0x0138 , 0x0138 ) , ( 0x013F , 0x0142 ) , ( 0x0144 , 0x0144 ) , <nl> + ( 0x0148 , 0x014B ) , ( 0x014D , 0x014D ) , ( 0x0152 , 0x0153 ) , <nl> + ( 0x0166 , 0x0167 ) , ( 0x016B , 0x016B ) , ( 0x01CE , 0x01CE ) , <nl> + ( 0x01D0 , 0x01D0 ) , ( 0x01D2 , 0x01D2 ) , ( 0x01D4 , 0x01D4 ) , <nl> + ( 0x01D6 , 0x01D6 ) , ( 0x01D8 , 0x01D8 ) , ( 0x01DA , 0x01DA ) , <nl> + ( 0x01DC , 0x01DC ) , ( 0x0251 , 0x0251 ) , ( 0x0261 , 0x0261 ) , <nl> + ( 0x02C4 , 0x02C4 ) , ( 0x02C7 , 0x02C7 ) , ( 0x02C9 , 0x02CB ) , <nl> + ( 0x02CD , 0x02CD ) , ( 0x02D0 , 0x02D0 ) , ( 0x02D8 , 0x02DB ) , <nl> + ( 0x02DD , 0x02DD ) , ( 0x02DF , 0x02DF ) , ( 0x0391 , 0x03A1 ) , <nl> + ( 0x03A3 , 0x03A9 ) , ( 0x03B1 , 0x03C1 ) , ( 0x03C3 , 0x03C9 ) , <nl> + ( 0x0401 , 0x0401 ) , ( 0x0410 , 0x044F ) , ( 0x0451 , 0x0451 ) , <nl> + ( 0x2010 , 0x2010 ) , ( 0x2013 , 0x2016 ) , ( 0x2018 , 0x2019 ) , <nl> + ( 0x201C , 0x201D ) , ( 0x2020 , 0x2022 ) , ( 0x2024 , 0x2027 ) , <nl> + ( 0x2030 , 0x2030 ) , ( 0x2032 , 0x2033 ) , ( 0x2035 , 0x2035 ) , <nl> + ( 0x203B , 0x203B ) , ( 0x203E , 0x203E ) , ( 0x2074 , 0x2074 ) , <nl> + ( 0x207F , 0x207F ) , ( 0x2081 , 0x2084 ) , ( 0x20AC , 0x20AC ) , <nl> + ( 0x2103 , 0x2103 ) , ( 0x2105 , 0x2105 ) , ( 0x2109 , 0x2109 ) , <nl> + ( 0x2113 , 0x2113 ) , ( 0x2116 , 0x2116 ) , ( 0x2121 , 0x2122 ) , <nl> + ( 0x2126 , 0x2126 ) , ( 0x212B , 0x212B ) , ( 0x2153 , 0x2154 ) , <nl> + ( 0x215B , 0x215E ) , ( 0x2160 , 0x216B ) , ( 0x2170 , 0x2179 ) , <nl> + ( 0x2190 , 0x2199 ) , ( 0x21B8 , 0x21B9 ) , ( 0x21D2 , 0x21D2 ) , <nl> + ( 0x21D4 , 0x21D4 ) , ( 0x21E7 , 0x21E7 ) , ( 0x2200 , 0x2200 ) , <nl> + ( 0x2202 , 0x2203 ) , ( 0x2207 , 0x2208 ) , ( 0x220B , 0x220B ) , <nl> + ( 0x220F , 0x220F ) , ( 0x2211 , 0x2211 ) , ( 0x2215 , 0x2215 ) , <nl> + ( 0x221A , 0x221A ) , ( 0x221D , 0x2220 ) , ( 0x2223 , 0x2223 ) , <nl> + ( 0x2225 , 0x2225 ) , ( 0x2227 , 0x222C ) , ( 0x222E , 0x222E ) , <nl> + ( 0x2234 , 0x2237 ) , ( 0x223C , 0x223D ) , ( 0x2248 , 0x2248 ) , <nl> + ( 0x224C , 0x224C ) , ( 0x2252 , 0x2252 ) , ( 0x2260 , 0x2261 ) , <nl> + ( 0x2264 , 0x2267 ) , ( 0x226A , 0x226B ) , ( 0x226E , 0x226F ) , <nl> + ( 0x2282 , 0x2283 ) , ( 0x2286 , 0x2287 ) , ( 0x2295 , 0x2295 ) , <nl> + ( 0x2299 , 0x2299 ) , ( 0x22A5 , 0x22A5 ) , ( 0x22BF , 0x22BF ) , <nl> + ( 0x2312 , 0x2312 ) , ( 0x2460 , 0x24E9 ) , ( 0x24EB , 0x254B ) , <nl> + ( 0x2550 , 0x2573 ) , ( 0x2580 , 0x258F ) , ( 0x2592 , 0x2595 ) , <nl> + ( 0x25A0 , 0x25A1 ) , ( 0x25A3 , 0x25A9 ) , ( 0x25B2 , 0x25B3 ) , <nl> + ( 0x25B6 , 0x25B7 ) , ( 0x25BC , 0x25BD ) , ( 0x25C0 , 0x25C1 ) , <nl> + ( 0x25C6 , 0x25C8 ) , ( 0x25CB , 0x25CB ) , ( 0x25CE , 0x25D1 ) , <nl> + ( 0x25E2 , 0x25E5 ) , ( 0x25EF , 0x25EF ) , ( 0x2605 , 0x2606 ) , <nl> + ( 0x2609 , 0x2609 ) , ( 0x260E , 0x260F ) , ( 0x2614 , 0x2615 ) , <nl> + ( 0x261C , 0x261C ) , ( 0x261E , 0x261E ) , ( 0x2640 , 0x2640 ) , <nl> + ( 0x2642 , 0x2642 ) , ( 0x2660 , 0x2661 ) , ( 0x2663 , 0x2665 ) , <nl> + ( 0x2667 , 0x266A ) , ( 0x266C , 0x266D ) , ( 0x266F , 0x266F ) , <nl> + ( 0x273D , 0x273D ) , ( 0x2776 , 0x277F ) , ( 0xE000 , 0xF8FF ) , <nl> + ( 0xFFFD , 0xFFFD ) , ( 0xF0000 , 0xFFFFD ) , ( 0x100000 , 0x10FFFD ) <nl> + ) <nl> + <nl> + def mk _ wcwidth ( ucs ) : <nl> + # test for 8 - bit control characters <nl> + if ucs = = 0 : <nl> + return 0 <nl> + if ucs < 32 or ( ucs > = 0x7f and ucs < 0xa0 ) : <nl> + return - 1 <nl> + <nl> + # binary search in table of non - spacing characters <nl> + if bisearch ( ucs , combining ) : <nl> + return 0 <nl> + <nl> + # if we arrive here , ucs is not a combining or C0 / C1 control character <nl> + <nl> + return 1 + \ <nl> + int ( ucs > = 0x1100 and <nl> + ( ucs < = 0x115f or # Hangul Jamo init . consonants <nl> + ucs = = 0x2329 or ucs = = 0x232a or <nl> + ( ucs > = 0x2e80 and ucs < = 0xa4cf and <nl> + ucs ! = 0x303f ) or # CJK . . . Yi <nl> + ( ucs > = 0xac00 and ucs < = 0xd7a3 ) or # Hangul Syllables <nl> + ( ucs > = 0xf900 and ucs < = 0xfaff ) or # CJK Compatibility Ideographs <nl> + ( ucs > = 0xfe10 and ucs < = 0xfe19 ) or # Vertical forms <nl> + ( ucs > = 0xfe30 and ucs < = 0xfe6f ) or # CJK Compatibility Forms <nl> + ( ucs > = 0xff00 and ucs < = 0xff60 ) or # Fullwidth Forms <nl> + ( ucs > = 0xffe0 and ucs < = 0xffe6 ) or <nl> + ( ucs > = 0x20000 and ucs < = 0x2fffd ) or <nl> + ( ucs > = 0x30000 and ucs < = 0x3fffd ) ) ) <nl> + <nl> + <nl> + def mk _ wcswidth ( pwcs ) : <nl> + width = 0 <nl> + for c in pwcs : <nl> + w = mk _ wcwidth ( c ) <nl> + if w < 0 : <nl> + return - 1 <nl> + else : <nl> + width + = w <nl> + <nl> + return width <nl> + <nl> + <nl> + # The following functions are the same as mk _ wcwidth ( ) and <nl> + # mk _ wcswidth ( ) , except that spacing characters in the East Asian <nl> + # Ambiguous ( A ) category as defined in Unicode Technical Report # 11 <nl> + # have a column width of 2 . This variant might be useful for users of <nl> + # CJK legacy encodings who want to migrate to UCS without changing <nl> + # the traditional terminal character - width behaviour . It is not <nl> + # otherwise recommended for general use . <nl> + def mk _ wcwidth _ cjk ( ucs ) : <nl> + # binary search in table of non - spacing characters <nl> + if bisearch ( ucs , ambiguous ) : <nl> + return 2 <nl> + <nl> + return mk _ wcwidth ( ucs ) <nl> + <nl> + <nl> + def mk _ wcswidth _ cjk ( pwcs ) : <nl> + width = 0 <nl> + <nl> + for c in pwcs : <nl> + w = mk _ wcwidth _ cjk ( c ) <nl> + if w < 0 : <nl> + return - 1 <nl> + width + = w <nl> + <nl> + return width <nl> + <nl> + # python - y versions , dealing with unicode objects <nl> + def wcwidth ( c ) : <nl> + return mk _ wcwidth ( ord ( c ) ) <nl> + <nl> + def wcswidth ( s ) : <nl> + return mk _ wcswidth ( map ( ord , s ) ) <nl> + <nl> + def wcwidth _ cjk ( c ) : <nl> + return mk _ wcwidth _ cjk ( ord ( c ) ) <nl> + <nl> + def wcswidth _ cjk ( s ) : <nl> + return mk _ wcswidth _ cjk ( map ( ord , s ) ) <nl> + <nl> + if _ _ name _ _ = = " _ _ main _ _ " : <nl> + samples = ( <nl> + ( ' MUSIC SHARP SIGN ' , 1 ) , <nl> + ( ' FULLWIDTH POUND SIGN ' , 2 ) , <nl> + ( ' FULLWIDTH LATIN CAPITAL LETTER P ' , 2 ) , <nl> + ( ' CJK RADICAL BOLT OF CLOTH ' , 2 ) , <nl> + ( ' LATIN SMALL LETTER A ' , 1 ) , <nl> + ( ' LATIN SMALL LETTER AE ' , 1 ) , <nl> + ( ' SPACE ' , 1 ) , <nl> + ( ' NO - BREAK SPACE ' , 1 ) , <nl> + ( ' CJK COMPATIBILITY IDEOGRAPH - F920 ' , 2 ) , <nl> + ( ' MALAYALAM VOWEL SIGN UU ' , 0 ) , <nl> + ( ' ZERO WIDTH SPACE ' , 0 ) , <nl> + ( ' ZERO WIDTH NO - BREAK SPACE ' , 0 ) , <nl> + ( ' COMBINING PALATALIZED HOOK BELOW ' , 0 ) , <nl> + ( ' COMBINING GRAVE ACCENT ' , 0 ) , <nl> + ) <nl> + nonprinting = u ' \ r \ n \ t \ a \ b \ f \ v \ x7f ' <nl> + <nl> + import unicodedata <nl> + <nl> + for name , printwidth in samples : <nl> + uchr = unicodedata . lookup ( name ) <nl> + calculatedwidth = wcwidth ( uchr ) <nl> + assert calculatedwidth = = printwidth , \ <nl> + ' width for % r should be % d , but is % d ? ' % ( uchr , printwidth , calculatedwidth ) <nl> + <nl> + for c in nonprinting : <nl> + calculatedwidth = wcwidth ( c ) <nl> + assert calculatedwidth < 0 , \ <nl> + ' % r is a control character , but wcwidth gives % d ' % ( c , calculatedwidth ) <nl> + <nl> + assert wcwidth ( ' \ 0 ' ) = = 0 # special case <nl> + <nl> + # depending on how python is compiled , code points above U + FFFF may not be <nl> + # treated as single characters , so ord ( ) won ' t work . test a few of these <nl> + # manually . <nl> + <nl> + assert mk _ wcwidth ( 0xe01ef ) = = 0 <nl> + assert mk _ wcwidth ( 0x10ffff ) = = 1 <nl> + assert mk _ wcwidth ( 0x3fffd ) = = 2 <nl> + <nl> + teststr = u ' B \ 0ig br \ u00f8wn moose \ ub143 \ u200b ' <nl> + calculatedwidth = wcswidth ( teststr ) <nl> + assert calculatedwidth = = 17 , ' expected 17 , got % d ' % calculatedwidth <nl> + <nl> + calculatedwidth = wcswidth _ cjk ( teststr ) <nl> + assert calculatedwidth = = 18 , ' expected 18 , got % d ' % calculatedwidth <nl> + <nl> + assert wcswidth ( u ' foobar \ u200b \ a ' ) < 0 <nl> + <nl> + print ' tests pass . '

TEST DIFF:
diff - - git a / pylib / cqlshlib / test / test _ cql _ parsing . py b / pylib / cqlshlib / test / test _ cql _ parsing . py 
 index f88b839 . . 717f9b6 100644 
 - - - a / pylib / cqlshlib / test / test _ cql _ parsing . py 
 + + + b / pylib / cqlshlib / test / test _ cql _ parsing . py 
 @ @ - 17 , 78 + 17 , 698 @ @ 
 # to configure behavior , define $ CQL _ TEST _ HOST to the destination address 
 # for Thrift connections , and $ CQL _ TEST _ PORT to the associated port . 
 
 - from . basecase import BaseTestCase , cqlsh 
 - from . cassconnect import get _ test _ keyspace , testrun _ cqlsh , testcall _ cqlsh 
 + from unittest import TestCase 
 + from operator import itemgetter 
 
 - class TestCqlParsing ( BaseTestCase ) : 
 - def setUp ( self ) : 
 - self . cqlsh _ runner = testrun _ cqlsh ( cqlver = cqlsh . DEFAULT _ CQLVER , env = { ' COLUMNS ' : ' 100000 ' } ) 
 - self . cqlsh = self . cqlsh _ runner . _ _ enter _ _ ( ) 
 + from . . cql3handling import CqlRuleSet 
 
 - def tearDown ( self ) : 
 - pass 
 
 + class TestCqlParsing ( TestCase ) : 
 def test _ parse _ string _ literals ( self ) : 
 - pass 
 + for n in [ " ' eggs ' " , " ' Sausage 1 ' " , " ' spam \ nspam \ n \ tsausage ' " , " ' ' " ] : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , 
 + [ ( n , ' quotedStringLiteral ' ) ] ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( " ' eggs ' " ) ) , 
 + [ ( " ' eggs ' " , ' quotedStringLiteral ' ) ] ) 
 
 def test _ parse _ numbers ( self ) : 
 - pass 
 + for n in [ ' 6 ' , ' 398 ' , ' 18018 ' ] : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( n ) ) , 
 + [ ( n , ' wholenumber ' ) ] ) 
 
 def test _ parse _ uuid ( self ) : 
 - pass 
 + uuids = [ ' 4feeae80 - e9cc - 11e4 - b571 - 0800200c9a66 ' , 
 + ' 7142303f - 828f - 4806 - be9e - 7a973da0c3f9 ' , 
 + ' dff8d435 - 9ca0 - 487c - b5d0 - b0fe5c5768a8 ' ] 
 + for u in uuids : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( u ) ) , 
 + [ ( u , ' uuid ' ) ] ) 
 
 def test _ comments _ in _ string _ literals ( self ) : 
 - pass 
 + comment _ strings = [ " ' sausage - - comment ' " , 
 + " ' eggs and spam / / comment string ' " , 
 + " ' spam eggs sausage and spam / * still in string ' " ] 
 + for s in comment _ strings : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( s ) ) , 
 + [ ( s , ' quotedStringLiteral ' ) ] ) 
 
 def test _ colons _ in _ string _ literals ( self ) : 
 - pass 
 + comment _ strings = [ " ' Movie Title : The Movie ' " , 
 + " ' : a : b : c : ' " , 
 + " ' ( > > = ) : : ( Monad m ) = > m a - > ( a - > m b ) - > m b ' " ] 
 + for s in comment _ strings : 
 + self . assertSequenceEqual ( tokens _ with _ types ( CqlRuleSet . lex ( s ) ) , 
 + [ ( s , ' quotedStringLiteral ' ) ] ) 
 
 def test _ partial _ parsing ( self ) : 
 - pass 
 + [ parsed ] = CqlRuleSet . cql _ parse ( ' INSERT INTO ks . test ' ) 
 + self . assertSequenceEqual ( parsed . matched , [ ] ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed . remainder ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' test ' , ' identifier ' ) ] ) 
 
 def test _ parse _ select ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( ' SELECT FROM ks . tab ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' SELECT ' , ' K _ SELECT ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( ' SELECT FROM " MyTable " ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' SELECT ' , ' K _ SELECT ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' " MyTable " ' , ' quotedName ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' SELECT FROM tab WHERE foo = 3 ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' SELECT ' , ' K _ SELECT ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' foo ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 3 ' , ' wholenumber ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' SELECT FROM tab ORDER BY event _ id DESC LIMIT 1000 ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' SELECT ' , ' K _ SELECT ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ORDER ' , ' K _ ORDER ' ) , 
 + ( ' BY ' , ' K _ BY ' ) , 
 + ( ' event _ id ' , ' identifier ' ) , 
 + ( ' DESC ' , ' K _ DESC ' ) , 
 + ( ' LIMIT ' , ' K _ LIMIT ' ) , 
 + ( ' 1000 ' , ' wholenumber ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' SELECT FROM tab WHERE clustering _ column > 200 ' 
 + ' AND clustering _ column < 400 ALLOW FILTERING ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' SELECT ' , ' K _ SELECT ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' clustering _ column ' , ' identifier ' ) , 
 + ( ' > ' , ' cmp ' ) , 
 + ( ' 200 ' , ' wholenumber ' ) , 
 + ( ' AND ' , ' K _ AND ' ) , 
 + ( ' clustering _ column ' , ' identifier ' ) , 
 + ( ' < ' , ' cmp ' ) , 
 + ( ' 400 ' , ' wholenumber ' ) , 
 + # ' allow ' and ' filtering ' are not keywords 
 + ( ' ALLOW ' , ' identifier ' ) , 
 + ( ' FILTERING ' , ' identifier ' ) ] ) 
 
 def test _ parse _ insert ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( ' INSERT INTO mytable ( x ) VALUES ( 2 ) ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' mytable ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' VALUES ' , ' K _ VALUES ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' 2 ' , ' wholenumber ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " INSERT INTO mytable ( x , y ) VALUES ( 2 , ' eggs ' ) ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' mytable ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' VALUES ' , ' K _ VALUES ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' 2 ' , ' wholenumber ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " INSERT INTO mytable ( x , y ) VALUES ( 2 , ' eggs ' ) ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' mytable ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' VALUES ' , ' K _ VALUES ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' 2 ' , ' wholenumber ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " INSERT INTO mytable ( ids ) VALUES " 
 + " ( 7ee251da - af52 - 49a4 - 97f4 - 3f07e406c7a7 ) " 
 + " USING TTL 86400 ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' mytable ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' ids ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' VALUES ' , ' K _ VALUES ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' 7ee251da - af52 - 49a4 - 97f4 - 3f07e406c7a7 ' , ' uuid ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' USING ' , ' K _ USING ' ) , 
 + ( ' TTL ' , ' K _ TTL ' ) , 
 + ( ' 86400 ' , ' wholenumber ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " INSERT INTO test _ table ( username ) VALUES ( ' Albert ' ) " 
 + " USING TIMESTAMP 1240003134 AND TTL 600 ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' INSERT ' , ' K _ INSERT ' ) , 
 + ( ' INTO ' , ' K _ INTO ' ) , 
 + ( ' test _ table ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' username ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' VALUES ' , ' K _ VALUES ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( " ' Albert ' " , ' quotedStringLiteral ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' USING ' , ' K _ USING ' ) , 
 + ( ' TIMESTAMP ' , ' K _ TIMESTAMP ' ) , 
 + ( ' 1240003134 ' , ' wholenumber ' ) , 
 + ( ' AND ' , ' K _ AND ' ) , 
 + ( ' TTL ' , ' K _ TTL ' ) , 
 + ( ' 600 ' , ' wholenumber ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 
 def test _ parse _ update ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 WHERE y = ' eggs ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab USING TTL 432000 SET x = 15 WHERE y = ' eggs ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' USING ' , ' K _ USING ' ) , 
 + ( ' TTL ' , ' K _ TTL ' ) , 
 + ( ' 432000 ' , ' wholenumber ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 , y = ' sausage ' " 
 + " WHERE y = ' eggs ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' sausage ' " , ' quotedStringLiteral ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 " 
 + " WHERE y IN ( ' eggs ' , ' sausage ' , ' spam ' ) ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' IN ' , ' K _ IN ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( " ' eggs ' " , ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' sausage ' " , ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' spam ' " , ' quotedStringLiteral ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 " 
 + " WHERE y = ' spam ' if z = ' sausage ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' spam ' " , ' quotedStringLiteral ' ) , 
 + ( ' if ' , ' K _ IF ' ) , 
 + ( ' z ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' sausage ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 WHERE y = ' spam ' " 
 + " if z = ' sausage ' AND w = ' spam ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' spam ' " , ' quotedStringLiteral ' ) , 
 + ( ' if ' , ' K _ IF ' ) , 
 + ( ' z ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' sausage ' " , ' quotedStringLiteral ' ) , 
 + ( ' AND ' , ' K _ AND ' ) , 
 + ( ' w ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' spam ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " UPDATE tab SET x = 15 WHERE y = ' spam ' IF EXISTS " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' UPDATE ' , ' K _ UPDATE ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' SET ' , ' K _ SET ' ) , 
 + ( ' x ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 15 ' , ' wholenumber ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' y ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' spam ' " , ' quotedStringLiteral ' ) , 
 + ( ' IF ' , ' K _ IF ' ) , 
 + ( ' EXISTS ' , ' identifier ' ) ] ) 
 
 def test _ parse _ delete ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( 
 + " DELETE FROM songs WHERE songid = 444 ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DELETE ' , ' K _ DELETE ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' songs ' , ' identifier ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' songid ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' 444 ' , ' wholenumber ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " DELETE FROM songs WHERE name IN " 
 + " ( ' Yellow Submarine ' , ' Eleanor Rigby ' ) ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DELETE ' , ' K _ DELETE ' ) , 
 + ( ' FROM ' , ' K _ FROM ' ) , 
 + ( ' songs ' , ' identifier ' ) , 
 + ( ' WHERE ' , ' K _ WHERE ' ) , 
 + ( ' name ' , ' identifier ' ) , 
 + ( ' IN ' , ' K _ IN ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( " ' Yellow Submarine ' " , ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' Eleanor Rigby ' " , ' quotedStringLiteral ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " DELETE task _ map [ ' 2014 - 12 - 25 ' ] from tasks where user _ id = ' Santa ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DELETE ' , ' K _ DELETE ' ) , 
 + ( ' task _ map ' , ' identifier ' ) , 
 + ( ' [ ' , ' brackets ' ) , 
 + ( " ' 2014 - 12 - 25 ' " , ' quotedStringLiteral ' ) , 
 + ( ' ] ' , ' brackets ' ) , 
 + ( ' from ' , ' K _ FROM ' ) , 
 + ( ' tasks ' , ' identifier ' ) , 
 + ( ' where ' , ' K _ WHERE ' ) , 
 + ( ' user _ id ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' Santa ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " DELETE my _ list [ 0 ] from lists where user _ id = ' Jim ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DELETE ' , ' K _ DELETE ' ) , 
 + ( ' my _ list ' , ' identifier ' ) , 
 + ( ' [ ' , ' brackets ' ) , 
 + ( ' 0 ' , ' wholenumber ' ) , 
 + ( ' ] ' , ' brackets ' ) , 
 + ( ' from ' , ' K _ FROM ' ) , 
 + ( ' lists ' , ' identifier ' ) , 
 + ( ' where ' , ' K _ WHERE ' ) , 
 + ( ' user _ id ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( " ' Jim ' " , ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 
 def test _ parse _ batch ( self ) : 
 pass 
 
 def test _ parse _ create _ keyspace ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( 
 + " CREATE KEYSPACE ks WITH REPLICATION = " 
 + " { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' WITH ' , ' K _ WITH ' ) , 
 + ( ' REPLICATION ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' { ' , ' brackets ' ) , 
 + ( " ' class ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( " ' SimpleStrategy ' " , ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' replication _ factor ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( ' 1 ' , ' wholenumber ' ) , 
 + ( ' } ' , ' brackets ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE KEYSPACE " Cql _ test _ KS " WITH REPLICATION = ' 
 + " { ' class ' : ' NetworkTopologyStrategy ' , ' dc1 ' : 3 , ' dc2 ' : 2 } ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , 
 + ( ' " Cql _ test _ KS " ' , ' quotedName ' ) , 
 + ( ' WITH ' , ' K _ WITH ' ) , 
 + ( ' REPLICATION ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' { ' , ' brackets ' ) , 
 + ( " ' class ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( " ' NetworkTopologyStrategy ' " , 
 + ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' dc1 ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( ' 3 ' , ' wholenumber ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' dc2 ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( ' 2 ' , ' wholenumber ' ) , 
 + ( ' } ' , ' brackets ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " CREATE KEYSPACE ks WITH REPLICATION = " 
 + " { ' class ' : ' NetworkTopologyStrategy ' , ' dc1 ' : 3 } AND " 
 + " DURABLE _ WRITES = false ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' WITH ' , ' K _ WITH ' ) , 
 + ( ' REPLICATION ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' { ' , ' brackets ' ) , 
 + ( " ' class ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( " ' NetworkTopologyStrategy ' " , 
 + ' quotedStringLiteral ' ) , 
 + ( ' , ' , ' op ' ) , 
 + ( " ' dc1 ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( ' 3 ' , ' wholenumber ' ) , 
 + ( ' } ' , ' brackets ' ) , 
 + ( ' AND ' , ' K _ AND ' ) , 
 + # ' DURABLE _ WRITES ' is not a keyword 
 + ( ' DURABLE _ WRITES ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' false ' , ' identifier ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 
 def test _ parse _ drop _ keyspace ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( 
 + ' DROP KEYSPACE ks ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DROP ' , ' K _ DROP ' ) , 
 + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' DROP SCHEMA ks ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DROP ' , ' K _ DROP ' ) , 
 + ( ' SCHEMA ' , ' K _ SCHEMA ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' DROP KEYSPACE IF EXISTS " My _ ks " ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' DROP ' , ' K _ DROP ' ) , 
 + ( ' KEYSPACE ' , ' K _ KEYSPACE ' ) , 
 + ( ' IF ' , ' K _ IF ' ) , 
 + ( ' EXISTS ' , ' identifier ' ) , 
 + ( ' " My _ ks " ' , ' quotedName ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 
 - def test _ parse _ create _ columnfamily ( self ) : 
 + def test _ parse _ create _ table ( self ) : 
 pass 
 
 - def test _ parse _ drop _ columnfamily ( self ) : 
 + def test _ parse _ drop _ table ( self ) : 
 pass 
 
 def test _ parse _ truncate ( self ) : 
 pass 
 
 - def test _ parse _ alter _ columnfamily ( self ) : 
 + def test _ parse _ alter _ table ( self ) : 
 pass 
 
 def test _ parse _ use ( self ) : 
 pass 
 
 def test _ parse _ create _ index ( self ) : 
 - pass 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE INDEX idx ON ks . tab ( i ) ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE INDEX idx ON ks . tab ( i ) IF NOT EXISTS ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' IF ' , ' K _ IF ' ) , 
 + ( ' NOT ' , ' K _ NOT ' ) , 
 + ( ' EXISTS ' , ' identifier ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE INDEX idx ON tab ( KEYS ( i ) ) ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' KEYS ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE INDEX idx ON ks . tab FULL ( i ) ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' FULL ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + ' CREATE CUSTOM INDEX idx ON ks . tab ( i ) ; ' ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' CUSTOM ' , ' K _ CUSTOM ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " CREATE INDEX idx ON ks . tab ( i ) USING " 
 + " ' org . custom . index . MyIndexClass ' ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' USING ' , ' K _ USING ' ) , 
 + ( " ' org . custom . index . MyIndexClass ' " , 
 + ' quotedStringLiteral ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 + 
 + parsed = parse _ cqlsh _ statements ( 
 + " CREATE INDEX idx ON ks . tab ( i ) WITH OPTIONS = " 
 + " { ' storage ' : ' / mnt / ssd / indexes / ' } ; " ) 
 + self . assertSequenceEqual ( tokens _ with _ types ( parsed ) , 
 + [ ( ' CREATE ' , ' K _ CREATE ' ) , 
 + ( ' INDEX ' , ' K _ INDEX ' ) , 
 + ( ' idx ' , ' identifier ' ) , 
 + ( ' ON ' , ' K _ ON ' ) , 
 + ( ' ks ' , ' identifier ' ) , 
 + ( ' . ' , ' op ' ) , 
 + ( ' tab ' , ' identifier ' ) , 
 + ( ' ( ' , ' op ' ) , 
 + ( ' i ' , ' identifier ' ) , 
 + ( ' ) ' , ' op ' ) , 
 + ( ' WITH ' , ' K _ WITH ' ) , 
 + ( ' OPTIONS ' , ' identifier ' ) , 
 + ( ' = ' , ' op ' ) , 
 + ( ' { ' , ' brackets ' ) , 
 + ( " ' storage ' " , ' quotedStringLiteral ' ) , 
 + ( ' : ' , ' colon ' ) , 
 + ( " ' / mnt / ssd / indexes / ' " , ' quotedStringLiteral ' ) , 
 + ( ' } ' , ' brackets ' ) , 
 + ( ' ; ' , ' endtoken ' ) ] ) 
 
 def test _ parse _ drop _ index ( self ) : 
 pass 
 
 def test _ parse _ select _ token ( self ) : 
 - self . cqlsh . cmd _ and _ response ( ' INSERT INTO has _ all _ types ( num ) VALUES ( 1 ) ; ' ) 
 - response = self . cqlsh . cmd _ and _ response ( " SELECT token ( num ) from has _ all _ types where num = 1 ; " ) 
 - self . assertIn ( ' - 4069959284402364209 ' , response ) 
 + pass 
 + 
 + 
 + def parse _ cqlsh _ statements ( text ) : 
 + ' ' ' 
 + Runs its argument through the sequence of parsing steps that cqlsh takes its 
 + input through . 
 + 
 + Currently does not handle batch statements . 
 + ' ' ' 
 + # based on onecmd 
 + statements , _ = CqlRuleSet . cql _ split _ statements ( text ) 
 + # stops here . For regular cql commands , onecmd just splits it and sends it 
 + # off to the cql engine ; parsing only happens for cqlsh - specific stmts . 
 + 
 + return strip _ final _ empty _ items ( statements ) [ 0 ] 
 + 
 + 
 + def tokens _ with _ types ( lexed ) : 
 + for x in lexed : 
 + assert len ( x ) > 2 , lexed 
 + return tuple ( itemgetter ( 1 , 0 ) ( token ) for token in lexed ) 
 + 
 + 
 + def strip _ final _ empty _ items ( xs ) : 
 + ' ' ' 
 + Returns its a copy of argument as a list , but with any terminating 
 + subsequence of falsey values removed . 
 + 
 + > > > strip _ final _ empty _ items ( [ [ 3 , 4 ] , [ 5 , 6 , 7 ] , [ ] , [ ] , [ 1 ] , [ ] ] ) 
 + [ [ 3 , 4 ] , [ 5 , 6 , 7 ] , [ ] , [ ] , [ 1 ] ] 
 + ' ' ' 
 + rv = list ( xs ) 
 + 
 + while rv and not rv [ - 1 ] : 
 + rv = rv [ : - 1 ] 
 + 
 + return rv 
 diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ parsing . py b / pylib / cqlshlib / test / test _ cqlsh _ parsing . py 
 new file mode 100644 
 index 0000000 . . 7e7f08b 
 - - - / dev / null 
 + + + b / pylib / cqlshlib / test / test _ cqlsh _ parsing . py 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + # Licensed to the Apache Software Foundation ( ASF ) under one 
 + # or more contributor license agreements . See the NOTICE file 
 + # distributed with this work for additional information 
 + # regarding copyright ownership . The ASF licenses this file 
 + # to you under the Apache License , Version 2 . 0 ( the 
 + # " License " ) ; you may not use this file except in compliance 
 + # with the License . You may obtain a copy of the License at 
 + # 
 + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + # 
 + # Unless required by applicable law or agreed to in writing , software 
 + # distributed under the License is distributed on an " AS IS " BASIS , 
 + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + # See the License for the specific language governing permissions and 
 + # limitations under the License . 
 + 
 + # to configure behavior , define $ CQL _ TEST _ HOST to the destination address 
 + # for Thrift connections , and $ CQL _ TEST _ PORT to the associated port . 
 + 
 + from unittest import TestCase 
 + 
 + 
 + class TestCqlshParsing ( TestCase ) : 
 + def test _ describe ( self ) : 
 + pass 
 +

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 14a4efe . . 32b2f4d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 50 , 6 + 50 , 8 @ @ 
 
 1 . 0 . 8 
 * ( cqlsh ) add DESCRIBE COLUMNFAMILIES ( CASSANDRA - 3586 ) 
 + * ( cqlsh ) format blobs correctly and use colors to improve output 
 + readability ( CASSANDRA - 3726 ) 
 
 
 1 . 0 . 7 
 diff - - git a / bin / cqlsh b / bin / cqlsh 
 index a179ecb . . fd664ec 100755 
 - - - a / bin / cqlsh 
 + + + b / bin / cqlsh 
 @ @ - 44 , 6 + 44 , 8 @ @ import string 
 import time 
 import optparse 
 import ConfigParser 
 + import codecs 
 + import re 
 
 # cqlsh should run correctly when run out of a Cassandra source tree , 
 # out of an unpacked Cassandra tarball , and after a proper package install . 
 @ @ - 51 , 7 + 53 , 7 @ @ cqlshlibdir = os . path . join ( os . path . dirname ( _ _ file _ _ ) , ' . . ' , ' pylib ' ) 
 if os . path . isdir ( cqlshlibdir ) : 
 sys . path . insert ( 0 , cqlshlibdir ) 
 
 - from cqlshlib import cqlhandling , pylexotron 
 + from cqlshlib import cqlhandling , pylexotron , wcwidth 
 from cqlshlib . cqlhandling import ( token _ dequote , cql _ dequote , cql _ escape , 
 maybe _ cql _ escape , cql _ typename ) 
 
 @ @ - 94 , 12 + 96 , 14 @ @ parser . add _ option ( ' - - debug ' , action = ' store _ true ' , 
 help = ' Show additional debugging information ' ) 
 
 
 - RED = " \ 033 [ 1 ; 31m % s \ 033 [ 0m " 
 - GREEN = " \ 033 [ 1 ; 32m % s \ 033 [ 0m " 
 - BLUE = " \ 033 [ 1 ; 34m % s \ 033 [ 0m " 
 - YELLOW = " \ 033 [ 1 ; 33m % s \ 033 [ 0m " 
 - CYAN = " \ 033 [ 1 ; 36m % s \ 033 [ 0m " 
 - MAGENTA = " \ 033 [ 1 ; 35m % s \ 033 [ 0m " 
 + RED = ' \ 033 [ 0 ; 1 ; 31m ' 
 + GREEN = ' \ 033 [ 0 ; 1 ; 32m ' 
 + YELLOW = ' \ 033 [ 0 ; 1 ; 33m ' 
 + BLUE = ' \ 033 [ 0 ; 1 ; 34m ' 
 + MAGENTA = ' \ 033 [ 0 ; 1 ; 35m ' 
 + CYAN = ' \ 033 [ 0 ; 1 ; 36m ' 
 + WHITE = ' \ 033 [ 0 ; 1 ; 37m ' 
 + ANSI _ RESET = ' \ 033 [ 0m ' 
 
 CQL _ ERRORS = ( cql . Error , ) 
 try : 
 @ @ - 215 , 16 + 219 , 113 @ @ def trim _ if _ present ( s , prefix ) : 
 return s [ len ( prefix ) : ] 
 return s 
 
 + class FormattedValue : 
 + def _ _ init _ _ ( self , strval , coloredval , displaywidth ) : 
 + self . strval = strval 
 + self . coloredval = coloredval 
 + self . displaywidth = displaywidth 
 + 
 + def _ pad ( self , width , fill = ' ' ) : 
 + if width > self . displaywidth : 
 + return fill * ( width - self . displaywidth ) 
 + else : 
 + return ' ' 
 + 
 + def rjust ( self , width , fill = ' ' ) : 
 + " " " 
 + Similar to self . strval . rjust ( width ) , but takes expected terminal 
 + display width into account for special characters , and does not 
 + take color escape codes into account . 
 + " " " 
 + return self . _ pad ( width , fill ) + self . strval 
 + 
 + def color _ rjust ( self , width , fill = ' ' ) : 
 + " " " 
 + Similar to self . rjust ( width ) , but uses this value ' s colored 
 + representation , and does not take color escape codes into account 
 + in determining width . 
 + " " " 
 + return self . _ pad ( width , fill ) + self . coloredval 
 + 
 + controlchars _ re = re . compile ( r ' [ \ x00 - \ x31 \ x7f - \ xa0 ] ' ) 
 + 
 + def _ show _ control _ chars ( match ) : 
 + txt = repr ( match . group ( 0 ) ) 
 + if txt . startswith ( ' u ' ) : 
 + txt = txt [ 2 : - 1 ] 
 + else : 
 + txt = txt [ 1 : - 1 ] 
 + return txt 
 + 
 + bits _ to _ turn _ red _ re = re . compile ( r ' \ \ ( [ ^ uUx ] | u [ 0 - 9a - fA - F ] { 4 } | x [ 0 - 9a - fA - F ] { 2 } | U [ 0 - 9a - fA - F ] { 8 } ) ' ) 
 + 
 + def _ turn _ bits _ red ( match ) : 
 + txt = match . group ( 0 ) 
 + if txt = = ' \ \ \ \ ' : 
 + return ' \ \ ' 
 + return RED + txt + YELLOW 
 + 
 + def format _ value ( val , casstype , output _ encoding , addcolor = False , time _ format = ' ' , float _ precision = 3 ) : 
 + color = YELLOW 
 + coloredval = None 
 + displaywidth = None 
 + 
 + if val is None : 
 + bval = ' null ' 
 + color = RED 
 + elif casstype = = ' UTF8Type ' : 
 + escapedval = val . replace ( u ' \ \ ' , u ' \ \ \ \ ' ) 
 + escapedval = controlchars _ re . sub ( _ show _ control _ chars , escapedval ) 
 + bval = escapedval . encode ( output _ encoding , errors = ' backslashreplace ' ) 
 + displaywidth = wcwidth . wcswidth ( bval . decode ( output _ encoding ) ) 
 + if addcolor : 
 + coloredval = YELLOW + bits _ to _ turn _ red _ re . sub ( _ turn _ bits _ red , bval ) + ANSI _ RESET 
 + elif casstype = = ' DateType ' : 
 + timestamp = time . localtime ( val ) 
 + bval = time . strftime ( time _ format , timestamp ) 
 + color = GREEN 
 + elif casstype in ( ' LongType ' , ' Int32Type ' , ' IntegerType ' ) : 
 + # base - 10 only for now ; support others ? 
 + bval = str ( val ) 
 + color = GREEN 
 + elif casstype in ( ' FloatType ' , ' DoubleType ' ) : 
 + bval = ' % . * g ' % ( float _ precision , val ) 
 + color = GREEN 
 + elif casstype in ( ' DecimalType ' , ' UUIDType ' , ' BooleanType ' ) : 
 + # let python do these for us 
 + bval = str ( val ) 
 + color = GREEN 
 + elif casstype = = ' BytesType ' : 
 + bval = ' ' . join ( ' % 02x ' % ord ( c ) for c in val ) 
 + color = RED 
 + else : 
 + # AsciiType is the only other one known right now , but handle others 
 + escapedval = val . replace ( ' \ \ ' , ' \ \ \ \ ' ) 
 + bval = controlchars _ re . sub ( _ show _ control _ chars , escapedval ) 
 + if addcolor : 
 + coloredval = YELLOW + bits _ to _ turn _ red _ re . sub ( _ turn _ bits _ red , bval ) + ANSI _ RESET 
 + 
 + if displaywidth is None : 
 + displaywidth = len ( bval ) 
 + if not addcolor : 
 + coloredval = bval 
 + elif coloredval is None : 
 + coloredval = color + bval + ANSI _ RESET 
 + 
 + return FormattedValue ( bval , coloredval , displaywidth ) 
 + 
 class Shell ( cmd . Cmd ) : 
 default _ prompt = " cqlsh > " 
 continue _ prompt = " . . . " 
 keyspace _ prompt = " cqlsh : % s > " 
 keyspace _ continue _ prompt = " % s . . . " 
 + display _ time _ format = ' % Y - % m - % d % H : % M : % S % z ' 
 + display _ float _ precision = 3 
 num _ retries = 4 
 debug = False 
 
 def _ _ init _ _ ( self , hostname , port , color = False , username = None , 
 - password = None , completekey = ' tab ' ) : 
 + password = None , encoding = None , completekey = ' tab ' ) : 
 cmd . Cmd . _ _ init _ _ ( self , completekey = completekey ) 
 self . hostname = hostname 
 self . port = port 
 @ @ - 233 , 8 + 334 , 13 @ @ class Shell ( cmd . Cmd ) : 
 
 self . current _ keyspace = None 
 
 - self . statement = StringIO ( ) 
 self . color = color 
 + if encoding is None : 
 + encoding = sys . stdout . encoding 
 + self . encoding = encoding 
 + self . output _ codec = codecs . lookup ( encoding ) 
 + 
 + self . statement = StringIO ( ) 
 self . in _ comment = False 
 self . schema _ overrides = { } 
 
 @ @ - 245 , 6 + 351 , 11 @ @ class Shell ( cmd . Cmd ) : 
 else : 
 self . prompt = " " 
 
 + def myformat _ value ( self , val , casstype ) : 
 + return format _ value ( val , casstype , self . output _ codec . name , 
 + addcolor = self . color , time _ format = self . display _ time _ format , 
 + float _ precision = self . display _ float _ precision ) 
 + 
 def report _ connection ( self ) : 
 self . show _ host ( ) 
 self . show _ version ( ) 
 @ @ - 562 , 43 + 673 , 32 @ @ class Shell ( cmd . Cmd ) : 
 self . printout ( " " ) 
 
 def print _ static _ result ( self ) : 
 - # first pass , get widths 
 - widths = defaultdict ( lambda : 0 ) 
 - for row in self . cursor : 
 - for desc , value in zip ( self . cursor . description , row ) : 
 - name = desc [ 0 ] 
 - widths [ name ] = max ( widths [ name ] , len ( str ( name ) ) , len ( str ( value ) ) ) 
 - self . cursor . _ reset ( ) 
 + colnames , coltypes = zip ( * self . cursor . description ) [ : 2 ] 
 + formatted _ data = [ map ( self . myformat _ value , row , coltypes ) for row in self . cursor ] 
 + 
 + # determine column widths 
 + widths = map ( len , colnames ) 
 + for fmtrow in formatted _ data : 
 + for num , col in enumerate ( fmtrow ) : 
 + widths [ num ] = max ( widths [ num ] , len ( col . strval ) ) 
 
 # print header 
 - for desc in self . cursor . description : 
 - name = desc [ 0 ] 
 - width = widths [ name ] 
 - self . printout ( " " , newline = False ) 
 - self . printout ( string . rjust ( str ( name ) , width ) , MAGENTA , False ) 
 - self . printout ( " | " , newline = False ) 
 - self . printout ( " " ) 
 + header = ' | ' . join ( self . applycolor ( name . ljust ( w ) , MAGENTA ) for ( name , w ) in zip ( colnames , widths ) ) 
 + print ' ' + header . rstrip ( ) 
 + print ' - % s - ' % ' - + - ' . join ( ' - ' * w for w in widths ) 
 
 # print row data 
 - for row in self . cursor : 
 - for desc , value in zip ( self . cursor . description , row ) : 
 - name = desc [ 0 ] 
 - width = widths [ desc [ 0 ] ] 
 - self . printout ( " " , newline = False ) 
 - self . printout ( string . rjust ( str ( value ) , width ) , YELLOW , False ) 
 - self . printout ( " | " , newline = False ) 
 - self . printout ( " " ) 
 + for row in formatted _ data : 
 + line = ' | ' . join ( col . color _ rjust ( w ) for ( col , w ) in zip ( row , widths ) ) 
 + print ' ' + line 
 
 def print _ dynamic _ result ( self ) : 
 for row in self . cursor : 
 - self . printout ( " " , newline = False ) 
 - for desc , value in zip ( self . cursor . description , row ) : 
 - name = desc [ 0 ] 
 - self . printout ( str ( name ) , MAGENTA , False ) 
 - self . printout ( " , " , newline = False ) 
 - self . printout ( str ( value ) , YELLOW , False ) 
 - self . printout ( " | " , newline = False ) 
 - self . printout ( " " ) 
 + colnames , coltypes = zip ( * self . cursor . description ) [ : 2 ] 
 + colnames = [ self . applycolor ( name , MAGENTA ) for name in colnames ] 
 + colvals = [ self . myformat _ value ( val , casstype ) for ( val , casstype ) in zip ( row , coltypes ) ] 
 + line = ' | ' . join ( name + ' , ' + col . coloredval for ( col , name ) in zip ( colvals , colnames ) ) 
 + print ' ' + line 
 
 def emptyline ( self ) : 
 pass 
 @ @ - 946 , 10 + 1046 , 109 @ @ class Shell ( cmd . Cmd ) : 
 cmd . Cmd . do _ help ( self , cql _ dequote ( t ) . lower ( ) ) 
 
 def help _ types ( self ) : 
 - self . printout ( " CQL types recognized by this version of cqlsh : \ n " ) 
 + self . printout ( " \ n CQL types recognized by this version of cqlsh : \ n " ) 
 for t in cqlhandling . cql _ types : 
 - self . printout ( ' ' + t ) 
 - self . printout ( ' ' ) 
 + self . printout ( ' ' + t ) 
 + print " " " 
 + For information on the various recognizable input formats for these 
 + types , or on controlling the formatting of cqlsh query output , see 
 + one of the following topics : 
 + 
 + HELP TIMESTAMP _ INPUT 
 + HELP BLOB _ INPUT 
 + HELP UUID _ INPUT 
 + HELP BOOLEAN _ INPUT 
 + 
 + HELP TEXT _ OUTPUT 
 + HELP TIMESTAMP _ OUTPUT 
 + " " " 
 + 
 + def help _ timestamp _ input ( self ) : 
 + print " " " 
 + Timestamp input 
 + 
 + CQL supports any of the following ISO 8601 formats for timestamp 
 + specification : 
 + 
 + yyyy - mm - dd HH : mm 
 + yyyy - mm - dd HH : mm : ss 
 + yyyy - mm - dd HH : mmZ 
 + yyyy - mm - dd HH : mm : ssZ 
 + yyyy - mm - dd ' T ' HH : mm 
 + yyyy - mm - dd ' T ' HH : mmZ 
 + yyyy - mm - dd ' T ' HH : mm : ss 
 + yyyy - mm - dd ' T ' HH : mm : ssZ 
 + yyyy - mm - dd 
 + yyyy - mm - ddZ 
 + 
 + The Z in these formats refers to an RFC - 822 4 - digit time zone , 
 + expressing the time zone ' s difference from UTC . For example , a 
 + timestamp in Pacific Standard Time might be given thus : 
 + 
 + 2012 - 01 - 20 16 : 14 : 12 - 0800 
 + 
 + If no time zone is supplied , the current time zone for the Cassandra 
 + server node will be used . 
 + " " " 
 + 
 + def help _ blob _ input ( self ) : 
 + print " " " 
 + Blob input 
 + 
 + CQL blob data must be specified in a string literal as hexidecimal 
 + data . Example : to store the ASCII values for the characters in the 
 + string " CQL " , use ' 43514c ' . 
 + " " " 
 + 
 + def help _ uuid _ input ( self ) : 
 + print " " " 
 + UUID input 
 + 
 + UUIDs may be specified in CQL using 32 hexidecimal characters , 
 + split up using dashes in the standard UUID format : 
 + 
 + XXXXXXXX - XXXX - XXXX - XXXX - XXXXXXXXXXXX 
 + " " " 
 + 
 + def help _ boolean _ input ( self ) : 
 + print " " " 
 + Boolean input 
 + 
 + CQL accepts the strings ' true ' and ' false ' ( case insensitive ) 
 + as input for boolean types . 
 + " " " 
 + 
 + def help _ text _ output ( self ) : 
 + print " " " 
 + Textual output 
 + 
 + When control characters , or other characters which can ' t be encoded 
 + in your current locale , are found in values of ' text ' or ' ascii ' 
 + types , it will be shown as a backslash escape . If color is enabled , 
 + any such backslash escapes will be shown in a different color from 
 + the surrounding text . 
 + 
 + Unicode code points in your data will be output intact , if the 
 + encoding for your locale is capable of decoding them . If you prefer 
 + that non - ascii characters be shown with Python - style " \ \ uABCD " 
 + escape sequences , invoke cqlsh with an ASCII locale ( for example , 
 + by setting the $ LANG environment variable to " C " ) . 
 + " " " 
 + 
 + help _ ascii _ output = help _ text _ output 
 + 
 + def help _ timestamp _ output ( self ) : 
 + print " " " 
 + Timestamp output 
 + 
 + Cqlsh will display timestamps in this format : 
 + 
 + yyyy - mm - dd HH : mm : ssZ 
 + 
 + which is a format acceptable as CQL timestamp input as well . It is 
 + planned that cqlsh should allow the user to change that output format 
 + if desired , but that feature is not yet available . 
 + " " " 
 
 def help _ select _ expr ( self ) : 
 print " " " 
 @ @ - 1466 , 17 + 1665 , 18 @ @ class Shell ( cmd . Cmd ) : 
 for information about the supported parameter names and values ) . 
 " " " 
 
 - def printout ( self , text , color = None , newline = True , out = sys . stdout ) : 
 + def applycolor ( self , text , color = None ) : 
 if not color or not self . color : 
 - out . write ( text ) 
 - else : 
 - out . write ( color % text ) 
 + return text 
 + return color + text + ANSI _ RESET 
 
 - if newline : 
 - out . write ( " \ n " ) 
 + def printout ( self , text , color = None , newline = True , out = None ) : 
 + if out is None : 
 + out = sys . stdout 
 + out . write ( self . applycolor ( str ( text ) , color ) + ( ' \ n ' if newline else ' ' ) ) 
 
 def printerr ( self , text , color = RED , newline = True ) : 
 - self . printout ( text , color , newline , sys . stderr ) 
 + self . printout ( text , color , newline = newline , out = sys . stderr ) 
 
 def add _ assumption ( self , ksname , cfname , colname , valtype , valclass ) : 
 try : 
 diff - - git a / pylib / cqlshlib / wcwidth . py b / pylib / cqlshlib / wcwidth . py 
 new file mode 100644 
 index 0000000 . . 43a4aca 
 - - - / dev / null 
 + + + b / pylib / cqlshlib / wcwidth . py 
 @ @ - 0 , 0 + 1 , 367 @ @ 
 + # Licensed to the Apache Software Foundation ( ASF ) under one 
 + # or more contributor license agreements . See the NOTICE file 
 + # distributed with this work for additional information 
 + # regarding copyright ownership . The ASF licenses this file 
 + # to you under the Apache License , Version 2 . 0 ( the 
 + # " License " ) ; you may not use this file except in compliance 
 + # with the License . You may obtain a copy of the License at 
 + # 
 + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + # 
 + # Unless required by applicable law or agreed to in writing , software 
 + # distributed under the License is distributed on an " AS IS " BASIS , 
 + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + # See the License for the specific language governing permissions and 
 + # limitations under the License . 
 + 
 + # adapted from http : / / www . cl . cam . ac . uk / ~ mgk25 / ucs / wcwidth . c 
 + # - thepaul 
 + 
 + # This is an implementation of wcwidth ( ) and wcswidth ( ) ( defined in 
 + # IEEE Std 1002 . 1 - 2001 ) for Unicode . 
 + # 
 + # http : / / www . opengroup . org / onlinepubs / 007904975 / functions / wcwidth . html 
 + # http : / / www . opengroup . org / onlinepubs / 007904975 / functions / wcswidth . html 
 + # 
 + # In fixed - width output devices , Latin characters all occupy a single 
 + # " cell " position of equal width , whereas ideographic CJK characters 
 + # occupy two such cells . Interoperability between terminal - line 
 + # applications and ( teletype - style ) character terminals using the 
 + # UTF - 8 encoding requires agreement on which character should advance 
 + # the cursor by how many cell positions . No established formal 
 + # standards exist at present on which Unicode character shall occupy 
 + # how many cell positions on character terminals . These routines are 
 + # a first attempt of defining such behavior based on simple rules 
 + # applied to data provided by the Unicode Consortium . 
 + # 
 + # For some graphical characters , the Unicode standard explicitly 
 + # defines a character - cell width via the definition of the East Asian 
 + # FullWidth ( F ) , Wide ( W ) , Half - width ( H ) , and Narrow ( Na ) classes . 
 + # In all these cases , there is no ambiguity about which width a 
 + # terminal shall use . For characters in the East Asian Ambiguous ( A ) 
 + # class , the width choice depends purely on a preference of backward 
 + # compatibility with either historic CJK or Western practice . 
 + # Choosing single - width for these characters is easy to justify as 
 + # the appropriate long - term solution , as the CJK practice of 
 + # displaying these characters as double - width comes from historic 
 + # implementation simplicity ( 8 - bit encoded characters were displayed 
 + # single - width and 16 - bit ones double - width , even for Greek , 
 + # Cyrillic , etc . ) and not any typographic considerations . 
 + # 
 + # Much less clear is the choice of width for the Not East Asian 
 + # ( Neutral ) class . Existing practice does not dictate a width for any 
 + # of these characters . It would nevertheless make sense 
 + # typographically to allocate two character cells to characters such 
 + # as for instance EM SPACE or VOLUME INTEGRAL , which cannot be 
 + # represented adequately with a single - width glyph . The following 
 + # routines at present merely assign a single - cell width to all 
 + # neutral characters , in the interest of simplicity . This is not 
 + # entirely satisfactory and should be reconsidered before 
 + # establishing a formal standard in this area . At the moment , the 
 + # decision which Not East Asian ( Neutral ) characters should be 
 + # represented by double - width glyphs cannot yet be answered by 
 + # applying a simple rule from the Unicode database content . Setting 
 + # up a proper standard for the behavior of UTF - 8 character terminals 
 + # will require a careful analysis not only of each Unicode character , 
 + # but also of each presentation form , something the author of these 
 + # routines has avoided to do so far . 
 + # 
 + # http : / / www . unicode . org / unicode / reports / tr11 / 
 + # 
 + # Markus Kuhn - - 2007 - 05 - 26 ( Unicode 5 . 0 ) 
 + # 
 + # Permission to use , copy , modify , and distribute this software 
 + # for any purpose and without fee is hereby granted . The author 
 + # disclaims all warranties with regard to this software . 
 + # 
 + # Latest C version : http : / / www . cl . cam . ac . uk / ~ mgk25 / ucs / wcwidth . c 
 + 
 + # auxiliary function for binary search in interval table 
 + def bisearch ( ucs , table ) : 
 + min = 0 
 + max = len ( table ) - 1 
 + if ucs < table [ 0 ] [ 0 ] or ucs > table [ max ] [ 1 ] : 
 + return 0 
 + while max > = min : 
 + mid = ( min + max ) / 2 
 + if ucs > table [ mid ] [ 1 ] : 
 + min = mid + 1 
 + elif ucs < table [ mid ] [ 0 ] : 
 + max = mid - 1 
 + else : 
 + return 1 
 + return 0 
 + 
 + # The following two functions define the column width of an ISO 10646 
 + # character as follows : 
 + # 
 + # - The null character ( U + 0000 ) has a column width of 0 . 
 + # 
 + # - Other C0 / C1 control characters and DEL will lead to a return 
 + # value of - 1 . 
 + # 
 + # - Non - spacing and enclosing combining characters ( general 
 + # category code Mn or Me in the Unicode database ) have a 
 + # column width of 0 . 
 + # 
 + # - SOFT HYPHEN ( U + 00AD ) has a column width of 1 . 
 + # 
 + # - Other format characters ( general category code Cf in the Unicode 
 + # database ) and ZERO WIDTH SPACE ( U + 200B ) have a column width of 0 . 
 + # 
 + # - Hangul Jamo medial vowels and final consonants ( U + 1160 - U + 11FF ) 
 + # have a column width of 0 . 
 + # 
 + # - Spacing characters in the East Asian Wide ( W ) or East Asian 
 + # Full - width ( F ) category as defined in Unicode Technical 
 + # Report # 11 have a column width of 2 . 
 + # 
 + # - All remaining characters ( including all printable 
 + # ISO 8859 - 1 and WGL4 characters , Unicode control characters , 
 + # etc . ) have a column width of 1 . 
 + # 
 + # This implementation assumes that wchar _ t characters are encoded 
 + # in ISO 10646 . 
 + 
 + # sorted list of non - overlapping intervals of non - spacing characters 
 + # generated by " uniset + cat = Me + cat = Mn + cat = Cf - 00AD + 1160 - 11FF + 200B c " 
 + combining = ( 
 + ( 0x0300 , 0x036F ) , ( 0x0483 , 0x0486 ) , ( 0x0488 , 0x0489 ) , 
 + ( 0x0591 , 0x05BD ) , ( 0x05BF , 0x05BF ) , ( 0x05C1 , 0x05C2 ) , 
 + ( 0x05C4 , 0x05C5 ) , ( 0x05C7 , 0x05C7 ) , ( 0x0600 , 0x0603 ) , 
 + ( 0x0610 , 0x0615 ) , ( 0x064B , 0x065E ) , ( 0x0670 , 0x0670 ) , 
 + ( 0x06D6 , 0x06E4 ) , ( 0x06E7 , 0x06E8 ) , ( 0x06EA , 0x06ED ) , 
 + ( 0x070F , 0x070F ) , ( 0x0711 , 0x0711 ) , ( 0x0730 , 0x074A ) , 
 + ( 0x07A6 , 0x07B0 ) , ( 0x07EB , 0x07F3 ) , ( 0x0901 , 0x0902 ) , 
 + ( 0x093C , 0x093C ) , ( 0x0941 , 0x0948 ) , ( 0x094D , 0x094D ) , 
 + ( 0x0951 , 0x0954 ) , ( 0x0962 , 0x0963 ) , ( 0x0981 , 0x0981 ) , 
 + ( 0x09BC , 0x09BC ) , ( 0x09C1 , 0x09C4 ) , ( 0x09CD , 0x09CD ) , 
 + ( 0x09E2 , 0x09E3 ) , ( 0x0A01 , 0x0A02 ) , ( 0x0A3C , 0x0A3C ) , 
 + ( 0x0A41 , 0x0A42 ) , ( 0x0A47 , 0x0A48 ) , ( 0x0A4B , 0x0A4D ) , 
 + ( 0x0A70 , 0x0A71 ) , ( 0x0A81 , 0x0A82 ) , ( 0x0ABC , 0x0ABC ) , 
 + ( 0x0AC1 , 0x0AC5 ) , ( 0x0AC7 , 0x0AC8 ) , ( 0x0ACD , 0x0ACD ) , 
 + ( 0x0AE2 , 0x0AE3 ) , ( 0x0B01 , 0x0B01 ) , ( 0x0B3C , 0x0B3C ) , 
 + ( 0x0B3F , 0x0B3F ) , ( 0x0B41 , 0x0B43 ) , ( 0x0B4D , 0x0B4D ) , 
 + ( 0x0B56 , 0x0B56 ) , ( 0x0B82 , 0x0B82 ) , ( 0x0BC0 , 0x0BC0 ) , 
 + ( 0x0BCD , 0x0BCD ) , ( 0x0C3E , 0x0C40 ) , ( 0x0C46 , 0x0C48 ) , 
 + ( 0x0C4A , 0x0C4D ) , ( 0x0C55 , 0x0C56 ) , ( 0x0CBC , 0x0CBC ) , 
 + ( 0x0CBF , 0x0CBF ) , ( 0x0CC6 , 0x0CC6 ) , ( 0x0CCC , 0x0CCD ) , 
 + ( 0x0CE2 , 0x0CE3 ) , ( 0x0D41 , 0x0D43 ) , ( 0x0D4D , 0x0D4D ) , 
 + ( 0x0DCA , 0x0DCA ) , ( 0x0DD2 , 0x0DD4 ) , ( 0x0DD6 , 0x0DD6 ) , 
 + ( 0x0E31 , 0x0E31 ) , ( 0x0E34 , 0x0E3A ) , ( 0x0E47 , 0x0E4E ) , 
 + ( 0x0EB1 , 0x0EB1 ) , ( 0x0EB4 , 0x0EB9 ) , ( 0x0EBB , 0x0EBC ) , 
 + ( 0x0EC8 , 0x0ECD ) , ( 0x0F18 , 0x0F19 ) , ( 0x0F35 , 0x0F35 ) , 
 + ( 0x0F37 , 0x0F37 ) , ( 0x0F39 , 0x0F39 ) , ( 0x0F71 , 0x0F7E ) , 
 + ( 0x0F80 , 0x0F84 ) , ( 0x0F86 , 0x0F87 ) , ( 0x0F90 , 0x0F97 ) , 
 + ( 0x0F99 , 0x0FBC ) , ( 0x0FC6 , 0x0FC6 ) , ( 0x102D , 0x1030 ) , 
 + ( 0x1032 , 0x1032 ) , ( 0x1036 , 0x1037 ) , ( 0x1039 , 0x1039 ) , 
 + ( 0x1058 , 0x1059 ) , ( 0x1160 , 0x11FF ) , ( 0x135F , 0x135F ) , 
 + ( 0x1712 , 0x1714 ) , ( 0x1732 , 0x1734 ) , ( 0x1752 , 0x1753 ) , 
 + ( 0x1772 , 0x1773 ) , ( 0x17B4 , 0x17B5 ) , ( 0x17B7 , 0x17BD ) , 
 + ( 0x17C6 , 0x17C6 ) , ( 0x17C9 , 0x17D3 ) , ( 0x17DD , 0x17DD ) , 
 + ( 0x180B , 0x180D ) , ( 0x18A9 , 0x18A9 ) , ( 0x1920 , 0x1922 ) , 
 + ( 0x1927 , 0x1928 ) , ( 0x1932 , 0x1932 ) , ( 0x1939 , 0x193B ) , 
 + ( 0x1A17 , 0x1A18 ) , ( 0x1B00 , 0x1B03 ) , ( 0x1B34 , 0x1B34 ) , 
 + ( 0x1B36 , 0x1B3A ) , ( 0x1B3C , 0x1B3C ) , ( 0x1B42 , 0x1B42 ) , 
 + ( 0x1B6B , 0x1B73 ) , ( 0x1DC0 , 0x1DCA ) , ( 0x1DFE , 0x1DFF ) , 
 + ( 0x200B , 0x200F ) , ( 0x202A , 0x202E ) , ( 0x2060 , 0x2063 ) , 
 + ( 0x206A , 0x206F ) , ( 0x20D0 , 0x20EF ) , ( 0x302A , 0x302F ) , 
 + ( 0x3099 , 0x309A ) , ( 0xA806 , 0xA806 ) , ( 0xA80B , 0xA80B ) , 
 + ( 0xA825 , 0xA826 ) , ( 0xFB1E , 0xFB1E ) , ( 0xFE00 , 0xFE0F ) , 
 + ( 0xFE20 , 0xFE23 ) , ( 0xFEFF , 0xFEFF ) , ( 0xFFF9 , 0xFFFB ) , 
 + ( 0x10A01 , 0x10A03 ) , ( 0x10A05 , 0x10A06 ) , ( 0x10A0C , 0x10A0F ) , 
 + ( 0x10A38 , 0x10A3A ) , ( 0x10A3F , 0x10A3F ) , ( 0x1D167 , 0x1D169 ) , 
 + ( 0x1D173 , 0x1D182 ) , ( 0x1D185 , 0x1D18B ) , ( 0x1D1AA , 0x1D1AD ) , 
 + ( 0x1D242 , 0x1D244 ) , ( 0xE0001 , 0xE0001 ) , ( 0xE0020 , 0xE007F ) , 
 + ( 0xE0100 , 0xE01EF ) 
 + ) 
 + 
 + # sorted list of non - overlapping intervals of East Asian Ambiguous 
 + # characters , generated by " uniset + WIDTH - A - cat = Me - cat = Mn - cat = Cf c " 
 + ambiguous = ( 
 + ( 0x00A1 , 0x00A1 ) , ( 0x00A4 , 0x00A4 ) , ( 0x00A7 , 0x00A8 ) , 
 + ( 0x00AA , 0x00AA ) , ( 0x00AE , 0x00AE ) , ( 0x00B0 , 0x00B4 ) , 
 + ( 0x00B6 , 0x00BA ) , ( 0x00BC , 0x00BF ) , ( 0x00C6 , 0x00C6 ) , 
 + ( 0x00D0 , 0x00D0 ) , ( 0x00D7 , 0x00D8 ) , ( 0x00DE , 0x00E1 ) , 
 + ( 0x00E6 , 0x00E6 ) , ( 0x00E8 , 0x00EA ) , ( 0x00EC , 0x00ED ) , 
 + ( 0x00F0 , 0x00F0 ) , ( 0x00F2 , 0x00F3 ) , ( 0x00F7 , 0x00FA ) , 
 + ( 0x00FC , 0x00FC ) , ( 0x00FE , 0x00FE ) , ( 0x0101 , 0x0101 ) , 
 + ( 0x0111 , 0x0111 ) , ( 0x0113 , 0x0113 ) , ( 0x011B , 0x011B ) , 
 + ( 0x0126 , 0x0127 ) , ( 0x012B , 0x012B ) , ( 0x0131 , 0x0133 ) , 
 + ( 0x0138 , 0x0138 ) , ( 0x013F , 0x0142 ) , ( 0x0144 , 0x0144 ) , 
 + ( 0x0148 , 0x014B ) , ( 0x014D , 0x014D ) , ( 0x0152 , 0x0153 ) , 
 + ( 0x0166 , 0x0167 ) , ( 0x016B , 0x016B ) , ( 0x01CE , 0x01CE ) , 
 + ( 0x01D0 , 0x01D0 ) , ( 0x01D2 , 0x01D2 ) , ( 0x01D4 , 0x01D4 ) , 
 + ( 0x01D6 , 0x01D6 ) , ( 0x01D8 , 0x01D8 ) , ( 0x01DA , 0x01DA ) , 
 + ( 0x01DC , 0x01DC ) , ( 0x0251 , 0x0251 ) , ( 0x0261 , 0x0261 ) , 
 + ( 0x02C4 , 0x02C4 ) , ( 0x02C7 , 0x02C7 ) , ( 0x02C9 , 0x02CB ) , 
 + ( 0x02CD , 0x02CD ) , ( 0x02D0 , 0x02D0 ) , ( 0x02D8 , 0x02DB ) , 
 + ( 0x02DD , 0x02DD ) , ( 0x02DF , 0x02DF ) , ( 0x0391 , 0x03A1 ) , 
 + ( 0x03A3 , 0x03A9 ) , ( 0x03B1 , 0x03C1 ) , ( 0x03C3 , 0x03C9 ) , 
 + ( 0x0401 , 0x0401 ) , ( 0x0410 , 0x044F ) , ( 0x0451 , 0x0451 ) , 
 + ( 0x2010 , 0x2010 ) , ( 0x2013 , 0x2016 ) , ( 0x2018 , 0x2019 ) , 
 + ( 0x201C , 0x201D ) , ( 0x2020 , 0x2022 ) , ( 0x2024 , 0x2027 ) , 
 + ( 0x2030 , 0x2030 ) , ( 0x2032 , 0x2033 ) , ( 0x2035 , 0x2035 ) , 
 + ( 0x203B , 0x203B ) , ( 0x203E , 0x203E ) , ( 0x2074 , 0x2074 ) , 
 + ( 0x207F , 0x207F ) , ( 0x2081 , 0x2084 ) , ( 0x20AC , 0x20AC ) , 
 + ( 0x2103 , 0x2103 ) , ( 0x2105 , 0x2105 ) , ( 0x2109 , 0x2109 ) , 
 + ( 0x2113 , 0x2113 ) , ( 0x2116 , 0x2116 ) , ( 0x2121 , 0x2122 ) , 
 + ( 0x2126 , 0x2126 ) , ( 0x212B , 0x212B ) , ( 0x2153 , 0x2154 ) , 
 + ( 0x215B , 0x215E ) , ( 0x2160 , 0x216B ) , ( 0x2170 , 0x2179 ) , 
 + ( 0x2190 , 0x2199 ) , ( 0x21B8 , 0x21B9 ) , ( 0x21D2 , 0x21D2 ) , 
 + ( 0x21D4 , 0x21D4 ) , ( 0x21E7 , 0x21E7 ) , ( 0x2200 , 0x2200 ) , 
 + ( 0x2202 , 0x2203 ) , ( 0x2207 , 0x2208 ) , ( 0x220B , 0x220B ) , 
 + ( 0x220F , 0x220F ) , ( 0x2211 , 0x2211 ) , ( 0x2215 , 0x2215 ) , 
 + ( 0x221A , 0x221A ) , ( 0x221D , 0x2220 ) , ( 0x2223 , 0x2223 ) , 
 + ( 0x2225 , 0x2225 ) , ( 0x2227 , 0x222C ) , ( 0x222E , 0x222E ) , 
 + ( 0x2234 , 0x2237 ) , ( 0x223C , 0x223D ) , ( 0x2248 , 0x2248 ) , 
 + ( 0x224C , 0x224C ) , ( 0x2252 , 0x2252 ) , ( 0x2260 , 0x2261 ) , 
 + ( 0x2264 , 0x2267 ) , ( 0x226A , 0x226B ) , ( 0x226E , 0x226F ) , 
 + ( 0x2282 , 0x2283 ) , ( 0x2286 , 0x2287 ) , ( 0x2295 , 0x2295 ) , 
 + ( 0x2299 , 0x2299 ) , ( 0x22A5 , 0x22A5 ) , ( 0x22BF , 0x22BF ) , 
 + ( 0x2312 , 0x2312 ) , ( 0x2460 , 0x24E9 ) , ( 0x24EB , 0x254B ) , 
 + ( 0x2550 , 0x2573 ) , ( 0x2580 , 0x258F ) , ( 0x2592 , 0x2595 ) , 
 + ( 0x25A0 , 0x25A1 ) , ( 0x25A3 , 0x25A9 ) , ( 0x25B2 , 0x25B3 ) , 
 + ( 0x25B6 , 0x25B7 ) , ( 0x25BC , 0x25BD ) , ( 0x25C0 , 0x25C1 ) , 
 + ( 0x25C6 , 0x25C8 ) , ( 0x25CB , 0x25CB ) , ( 0x25CE , 0x25D1 ) , 
 + ( 0x25E2 , 0x25E5 ) , ( 0x25EF , 0x25EF ) , ( 0x2605 , 0x2606 ) , 
 + ( 0x2609 , 0x2609 ) , ( 0x260E , 0x260F ) , ( 0x2614 , 0x2615 ) , 
 + ( 0x261C , 0x261C ) , ( 0x261E , 0x261E ) , ( 0x2640 , 0x2640 ) , 
 + ( 0x2642 , 0x2642 ) , ( 0x2660 , 0x2661 ) , ( 0x2663 , 0x2665 ) , 
 + ( 0x2667 , 0x266A ) , ( 0x266C , 0x266D ) , ( 0x266F , 0x266F ) , 
 + ( 0x273D , 0x273D ) , ( 0x2776 , 0x277F ) , ( 0xE000 , 0xF8FF ) , 
 + ( 0xFFFD , 0xFFFD ) , ( 0xF0000 , 0xFFFFD ) , ( 0x100000 , 0x10FFFD ) 
 + ) 
 + 
 + def mk _ wcwidth ( ucs ) : 
 + # test for 8 - bit control characters 
 + if ucs = = 0 : 
 + return 0 
 + if ucs < 32 or ( ucs > = 0x7f and ucs < 0xa0 ) : 
 + return - 1 
 + 
 + # binary search in table of non - spacing characters 
 + if bisearch ( ucs , combining ) : 
 + return 0 
 + 
 + # if we arrive here , ucs is not a combining or C0 / C1 control character 
 + 
 + return 1 + \ 
 + int ( ucs > = 0x1100 and 
 + ( ucs < = 0x115f or # Hangul Jamo init . consonants 
 + ucs = = 0x2329 or ucs = = 0x232a or 
 + ( ucs > = 0x2e80 and ucs < = 0xa4cf and 
 + ucs ! = 0x303f ) or # CJK . . . Yi 
 + ( ucs > = 0xac00 and ucs < = 0xd7a3 ) or # Hangul Syllables 
 + ( ucs > = 0xf900 and ucs < = 0xfaff ) or # CJK Compatibility Ideographs 
 + ( ucs > = 0xfe10 and ucs < = 0xfe19 ) or # Vertical forms 
 + ( ucs > = 0xfe30 and ucs < = 0xfe6f ) or # CJK Compatibility Forms 
 + ( ucs > = 0xff00 and ucs < = 0xff60 ) or # Fullwidth Forms 
 + ( ucs > = 0xffe0 and ucs < = 0xffe6 ) or 
 + ( ucs > = 0x20000 and ucs < = 0x2fffd ) or 
 + ( ucs > = 0x30000 and ucs < = 0x3fffd ) ) ) 
 + 
 + 
 + def mk _ wcswidth ( pwcs ) : 
 + width = 0 
 + for c in pwcs : 
 + w = mk _ wcwidth ( c ) 
 + if w < 0 : 
 + return - 1 
 + else : 
 + width + = w 
 + 
 + return width 
 + 
 + 
 + # The following functions are the same as mk _ wcwidth ( ) and 
 + # mk _ wcswidth ( ) , except that spacing characters in the East Asian 
 + # Ambiguous ( A ) category as defined in Unicode Technical Report # 11 
 + # have a column width of 2 . This variant might be useful for users of 
 + # CJK legacy encodings who want to migrate to UCS without changing 
 + # the traditional terminal character - width behaviour . It is not 
 + # otherwise recommended for general use . 
 + def mk _ wcwidth _ cjk ( ucs ) : 
 + # binary search in table of non - spacing characters 
 + if bisearch ( ucs , ambiguous ) : 
 + return 2 
 + 
 + return mk _ wcwidth ( ucs ) 
 + 
 + 
 + def mk _ wcswidth _ cjk ( pwcs ) : 
 + width = 0 
 + 
 + for c in pwcs : 
 + w = mk _ wcwidth _ cjk ( c ) 
 + if w < 0 : 
 + return - 1 
 + width + = w 
 + 
 + return width 
 + 
 + # python - y versions , dealing with unicode objects 
 + def wcwidth ( c ) : 
 + return mk _ wcwidth ( ord ( c ) ) 
 + 
 + def wcswidth ( s ) : 
 + return mk _ wcswidth ( map ( ord , s ) ) 
 + 
 + def wcwidth _ cjk ( c ) : 
 + return mk _ wcwidth _ cjk ( ord ( c ) ) 
 + 
 + def wcswidth _ cjk ( s ) : 
 + return mk _ wcswidth _ cjk ( map ( ord , s ) ) 
 + 
 + if _ _ name _ _ = = " _ _ main _ _ " : 
 + samples = ( 
 + ( ' MUSIC SHARP SIGN ' , 1 ) , 
 + ( ' FULLWIDTH POUND SIGN ' , 2 ) , 
 + ( ' FULLWIDTH LATIN CAPITAL LETTER P ' , 2 ) , 
 + ( ' CJK RADICAL BOLT OF CLOTH ' , 2 ) , 
 + ( ' LATIN SMALL LETTER A ' , 1 ) , 
 + ( ' LATIN SMALL LETTER AE ' , 1 ) , 
 + ( ' SPACE ' , 1 ) , 
 + ( ' NO - BREAK SPACE ' , 1 ) , 
 + ( ' CJK COMPATIBILITY IDEOGRAPH - F920 ' , 2 ) , 
 + ( ' MALAYALAM VOWEL SIGN UU ' , 0 ) , 
 + ( ' ZERO WIDTH SPACE ' , 0 ) , 
 + ( ' ZERO WIDTH NO - BREAK SPACE ' , 0 ) , 
 + ( ' COMBINING PALATALIZED HOOK BELOW ' , 0 ) , 
 + ( ' COMBINING GRAVE ACCENT ' , 0 ) , 
 + ) 
 + nonprinting = u ' \ r \ n \ t \ a \ b \ f \ v \ x7f ' 
 + 
 + import unicodedata 
 + 
 + for name , printwidth in samples : 
 + uchr = unicodedata . lookup ( name ) 
 + calculatedwidth = wcwidth ( uchr ) 
 + assert calculatedwidth = = printwidth , \ 
 + ' width for % r should be % d , but is % d ? ' % ( uchr , printwidth , calculatedwidth ) 
 + 
 + for c in nonprinting : 
 + calculatedwidth = wcwidth ( c ) 
 + assert calculatedwidth < 0 , \ 
 + ' % r is a control character , but wcwidth gives % d ' % ( c , calculatedwidth ) 
 + 
 + assert wcwidth ( ' \ 0 ' ) = = 0 # special case 
 + 
 + # depending on how python is compiled , code points above U + FFFF may not be 
 + # treated as single characters , so ord ( ) won ' t work . test a few of these 
 + # manually . 
 + 
 + assert mk _ wcwidth ( 0xe01ef ) = = 0 
 + assert mk _ wcwidth ( 0x10ffff ) = = 1 
 + assert mk _ wcwidth ( 0x3fffd ) = = 2 
 + 
 + teststr = u ' B \ 0ig br \ u00f8wn moose \ ub143 \ u200b ' 
 + calculatedwidth = wcswidth ( teststr ) 
 + assert calculatedwidth = = 17 , ' expected 17 , got % d ' % calculatedwidth 
 + 
 + calculatedwidth = wcswidth _ cjk ( teststr ) 
 + assert calculatedwidth = = 18 , ' expected 18 , got % d ' % calculatedwidth 
 + 
 + assert wcswidth ( u ' foobar \ u200b \ a ' ) < 0 
 + 
 + print ' tests pass . '
