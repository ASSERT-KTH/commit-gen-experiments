BLEU SCORE: 0.04372912656590315

TEST MSG: Warn on unlogged batch misuse
GENERATED MSG: Add support for batchlog in CQL3

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> index c93bf64 . . 6d4d3a1 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java <nl> @ @ - 19 , 10 + 19 , 13 @ @ package org . apache . cassandra . cql3 . statements ; <nl> <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> + import java . util . concurrent . TimeUnit ; <nl> <nl> import com . google . common . base . Function ; <nl> import com . google . common . collect . * ; <nl> + <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 35 , 10 + 38 , 10 @ @ import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> + import org . apache . cassandra . utils . NoSpamLogger ; <nl> <nl> / * * <nl> * A < code > BATCH < / code > statement parsed from a CQL query . <nl> - * <nl> * / <nl> public class BatchStatement implements CQLStatement <nl> { <nl> @ @ - 53 , 14 + 56 , 15 @ @ public class BatchStatement implements CQLStatement <nl> private final Attributes attrs ; <nl> private final boolean hasConditions ; <nl> private static final Logger logger = LoggerFactory . getLogger ( BatchStatement . class ) ; <nl> + private static final String unloggedBatchWarning = " Unlogged batch covering { } partition { } detected against table { } { } . You should use a logged batch for atomicity , or asynchronous writes for performance . " ; <nl> <nl> / * * <nl> * Creates a new BatchStatement from a list of statements and a <nl> * Thrift consistency level . <nl> * <nl> - * @ param type type of the batch <nl> + * @ param type type of the batch <nl> * @ param statements a list of UpdateStatements <nl> - * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) <nl> + * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) <nl> * / <nl> public BatchStatement ( int boundTerms , Type type , List < ModificationStatement > statements , Attributes attrs ) <nl> { <nl> @ @ - 170 , 13 + 174 , 16 @ @ public class BatchStatement implements CQLStatement <nl> <nl> private Collection < ? extends IMutation > unzipMutations ( Map < String , Map < ByteBuffer , IMutation > > mutations ) <nl> { <nl> + <nl> / / The case where all statement where on the same keyspace is pretty common <nl> if ( mutations . size ( ) = = 1 ) <nl> return mutations . values ( ) . iterator ( ) . next ( ) . values ( ) ; <nl> <nl> + <nl> List < IMutation > ms = new ArrayList < > ( ) ; <nl> for ( Map < ByteBuffer , IMutation > ksMap : mutations . values ( ) ) <nl> ms . addAll ( ksMap . values ( ) ) ; <nl> + <nl> return ms ; <nl> } <nl> <nl> @ @ - 214 , 7 + 221 , 7 @ @ public class BatchStatement implements CQLStatement <nl> } <nl> else <nl> { <nl> - mut = statement . cfm . isCounter ( ) ? ( ( CounterMutation ) mutation ) . getMutation ( ) : ( Mutation ) mutation ; <nl> + mut = statement . cfm . isCounter ( ) ? ( ( CounterMutation ) mutation ) . getMutation ( ) : ( Mutation ) mutation ; <nl> } <nl> <nl> statement . addUpdateForKey ( mut . addOrGet ( statement . cfm ) , key , clusteringPrefix , params ) ; <nl> @ @ - 223 , 6 + 230 , 7 @ @ public class BatchStatement implements CQLStatement <nl> <nl> / * * <nl> * Checks batch size to ensure threshold is met . If not , a warning is logged . <nl> + * <nl> * @ param cfs ColumnFamilies that will store the batch ' s mutations . <nl> * / <nl> public static void verifyBatchSize ( Iterable < ColumnFamily > cfs ) <nl> @ @ - 237 , 13 + 245 , 33 @ @ public class BatchStatement implements CQLStatement <nl> { <nl> Set < String > ksCfPairs = new HashSet < > ( ) ; <nl> for ( ColumnFamily cf : cfs ) <nl> - ksCfPairs . add ( cf . metadata ( ) . ksName + " . " + cf . metadata ( ) . cfName ) ; <nl> + ksCfPairs . add ( String . format ( " % s . % s " , cf . metadata ( ) . ksName , cf . metadata ( ) . cfName ) ) ; <nl> <nl> String format = " Batch of prepared statements for { } is of size { } , exceeding specified threshold of { } by { } . " ; <nl> logger . warn ( format , ksCfPairs , size , warnThreshold , size - warnThreshold ) ; <nl> } <nl> } <nl> <nl> + private void verifyBatchType ( Collection < ? extends IMutation > mutations ) <nl> + { <nl> + if ( type ! = Type . LOGGED & & mutations . size ( ) > 1 ) <nl> + { <nl> + Set < String > ksCfPairs = new HashSet < > ( ) ; <nl> + Set < ByteBuffer > keySet = new HashSet < > ( ) ; <nl> + <nl> + for ( IMutation im : mutations ) <nl> + { <nl> + keySet . add ( im . key ( ) ) ; <nl> + for ( ColumnFamily cf : im . getColumnFamilies ( ) ) <nl> + ksCfPairs . add ( String . format ( " % s . % s " , cf . metadata ( ) . ksName , cf . metadata ( ) . cfName ) ) ; <nl> + } <nl> + <nl> + NoSpamLogger . log ( logger , NoSpamLogger . Level . WARN , 1 , TimeUnit . MINUTES , unloggedBatchWarning , <nl> + keySet . size ( ) , keySet . size ( ) = = 1 ? " " : " s " , <nl> + ksCfPairs . size ( ) = = 1 ? " " : " s " , ksCfPairs ) ; <nl> + } <nl> + } <nl> + <nl> public ResultMessage execute ( QueryState queryState , QueryOptions options ) throws RequestExecutionException , RequestValidationException <nl> { <nl> return execute ( queryState , BatchQueryOptions . withoutPerStatementVariables ( options ) ) ; <nl> @ @ - 279 , 7 + 307 , 9 @ @ public class BatchStatement implements CQLStatement <nl> return im . getColumnFamilies ( ) ; <nl> } <nl> } ) ) ; <nl> + <nl> verifyBatchSize ( cfs ) ; <nl> + verifyBatchType ( mutations ) ; <nl> <nl> boolean mutateAtomic = ( type = = Type . LOGGED & & mutations . size ( ) > 1 ) ; <nl> StorageProxy . mutateWithTriggers ( mutations , cl , mutateAtomic ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7425111 . . 89ee88d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 12 , 6 + 12 , 7 @ @ <nl> * ( CQL3 ) Fix validation when using counter and regular columns in the same table <nl> ( CASSANDRA - 4706 ) <nl> * Fix bug starting Cassandra with simple authentication ( CASSANDRA - 4648 ) <nl> + * Add support for batchlog in CQL3 ( CASSANDRA - 4545 ) <nl> <nl> 1 . 2 - beta1 <nl> * add atomic _ batch _ mutate ( CASSANDRA - 4542 , - 4635 )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 index c93bf64 . . 6d4d3a1 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / BatchStatement . java 
 @ @ - 19 , 10 + 19 , 13 @ @ package org . apache . cassandra . cql3 . statements ; 
 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 + import java . util . concurrent . TimeUnit ; 
 
 import com . google . common . base . Function ; 
 import com . google . common . collect . * ; 
 + 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 35 , 10 + 38 , 10 @ @ import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 + import org . apache . cassandra . utils . NoSpamLogger ; 
 
 / * * 
 * A < code > BATCH < / code > statement parsed from a CQL query . 
 - * 
 * / 
 public class BatchStatement implements CQLStatement 
 { 
 @ @ - 53 , 14 + 56 , 15 @ @ public class BatchStatement implements CQLStatement 
 private final Attributes attrs ; 
 private final boolean hasConditions ; 
 private static final Logger logger = LoggerFactory . getLogger ( BatchStatement . class ) ; 
 + private static final String unloggedBatchWarning = " Unlogged batch covering { } partition { } detected against table { } { } . You should use a logged batch for atomicity , or asynchronous writes for performance . " ; 
 
 / * * 
 * Creates a new BatchStatement from a list of statements and a 
 * Thrift consistency level . 
 * 
 - * @ param type type of the batch 
 + * @ param type type of the batch 
 * @ param statements a list of UpdateStatements 
 - * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) 
 + * @ param attrs additional attributes for statement ( CL , timestamp , timeToLive ) 
 * / 
 public BatchStatement ( int boundTerms , Type type , List < ModificationStatement > statements , Attributes attrs ) 
 { 
 @ @ - 170 , 13 + 174 , 16 @ @ public class BatchStatement implements CQLStatement 
 
 private Collection < ? extends IMutation > unzipMutations ( Map < String , Map < ByteBuffer , IMutation > > mutations ) 
 { 
 + 
 / / The case where all statement where on the same keyspace is pretty common 
 if ( mutations . size ( ) = = 1 ) 
 return mutations . values ( ) . iterator ( ) . next ( ) . values ( ) ; 
 
 + 
 List < IMutation > ms = new ArrayList < > ( ) ; 
 for ( Map < ByteBuffer , IMutation > ksMap : mutations . values ( ) ) 
 ms . addAll ( ksMap . values ( ) ) ; 
 + 
 return ms ; 
 } 
 
 @ @ - 214 , 7 + 221 , 7 @ @ public class BatchStatement implements CQLStatement 
 } 
 else 
 { 
 - mut = statement . cfm . isCounter ( ) ? ( ( CounterMutation ) mutation ) . getMutation ( ) : ( Mutation ) mutation ; 
 + mut = statement . cfm . isCounter ( ) ? ( ( CounterMutation ) mutation ) . getMutation ( ) : ( Mutation ) mutation ; 
 } 
 
 statement . addUpdateForKey ( mut . addOrGet ( statement . cfm ) , key , clusteringPrefix , params ) ; 
 @ @ - 223 , 6 + 230 , 7 @ @ public class BatchStatement implements CQLStatement 
 
 / * * 
 * Checks batch size to ensure threshold is met . If not , a warning is logged . 
 + * 
 * @ param cfs ColumnFamilies that will store the batch ' s mutations . 
 * / 
 public static void verifyBatchSize ( Iterable < ColumnFamily > cfs ) 
 @ @ - 237 , 13 + 245 , 33 @ @ public class BatchStatement implements CQLStatement 
 { 
 Set < String > ksCfPairs = new HashSet < > ( ) ; 
 for ( ColumnFamily cf : cfs ) 
 - ksCfPairs . add ( cf . metadata ( ) . ksName + " . " + cf . metadata ( ) . cfName ) ; 
 + ksCfPairs . add ( String . format ( " % s . % s " , cf . metadata ( ) . ksName , cf . metadata ( ) . cfName ) ) ; 
 
 String format = " Batch of prepared statements for { } is of size { } , exceeding specified threshold of { } by { } . " ; 
 logger . warn ( format , ksCfPairs , size , warnThreshold , size - warnThreshold ) ; 
 } 
 } 
 
 + private void verifyBatchType ( Collection < ? extends IMutation > mutations ) 
 + { 
 + if ( type ! = Type . LOGGED & & mutations . size ( ) > 1 ) 
 + { 
 + Set < String > ksCfPairs = new HashSet < > ( ) ; 
 + Set < ByteBuffer > keySet = new HashSet < > ( ) ; 
 + 
 + for ( IMutation im : mutations ) 
 + { 
 + keySet . add ( im . key ( ) ) ; 
 + for ( ColumnFamily cf : im . getColumnFamilies ( ) ) 
 + ksCfPairs . add ( String . format ( " % s . % s " , cf . metadata ( ) . ksName , cf . metadata ( ) . cfName ) ) ; 
 + } 
 + 
 + NoSpamLogger . log ( logger , NoSpamLogger . Level . WARN , 1 , TimeUnit . MINUTES , unloggedBatchWarning , 
 + keySet . size ( ) , keySet . size ( ) = = 1 ? " " : " s " , 
 + ksCfPairs . size ( ) = = 1 ? " " : " s " , ksCfPairs ) ; 
 + } 
 + } 
 + 
 public ResultMessage execute ( QueryState queryState , QueryOptions options ) throws RequestExecutionException , RequestValidationException 
 { 
 return execute ( queryState , BatchQueryOptions . withoutPerStatementVariables ( options ) ) ; 
 @ @ - 279 , 7 + 307 , 9 @ @ public class BatchStatement implements CQLStatement 
 return im . getColumnFamilies ( ) ; 
 } 
 } ) ) ; 
 + 
 verifyBatchSize ( cfs ) ; 
 + verifyBatchType ( mutations ) ; 
 
 boolean mutateAtomic = ( type = = Type . LOGGED & & mutations . size ( ) > 1 ) ; 
 StorageProxy . mutateWithTriggers ( mutations , cl , mutateAtomic ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7425111 . . 89ee88d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 12 , 6 + 12 , 7 @ @ 
 * ( CQL3 ) Fix validation when using counter and regular columns in the same table 
 ( CASSANDRA - 4706 ) 
 * Fix bug starting Cassandra with simple authentication ( CASSANDRA - 4648 ) 
 + * Add support for batchlog in CQL3 ( CASSANDRA - 4545 ) 
 
 1 . 2 - beta1 
 * add atomic _ batch _ mutate ( CASSANDRA - 4542 , - 4635 )
