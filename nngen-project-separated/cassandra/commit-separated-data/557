BLEU SCORE: 0.01222796968620182

TEST MSG: Make sure sstables only get committed when it ' s safe to discard commit log records
GENERATED MSG: Fix out - of - space error treatment in memtable flushing

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5cacdd0 . . 5242adf 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 11 <nl> + * Make sure sstables only get committed when it ' s safe to discard commit log records ( CASSANDRA - 12956 ) <nl> * Reject default _ time _ to _ live option when creating or altering MVs ( CASSANDRA - 12868 ) <nl> * Nodetool should use a more sane max heap size ( CASSANDRA - 12739 ) <nl> * LocalToken ensures token values are cloned on heap ( CASSANDRA - 12651 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index d2a51a9 . . 113e10d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ import org . apache . cassandra . io . FSWriteError ; <nl> import org . apache . cassandra . io . sstable . Component ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . io . sstable . SSTableMultiWriter ; <nl> + import org . apache . cassandra . io . sstable . SSTableTxnWriter ; <nl> import org . apache . cassandra . io . sstable . format . * ; <nl> import org . apache . cassandra . io . sstable . format . big . BigFormat ; <nl> import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; <nl> @ @ - 81 , 6 + 82 , 7 @ @ import org . json . simple . JSONArray ; <nl> import org . json . simple . JSONObject ; <nl> <nl> import static org . apache . cassandra . utils . Throwables . maybeFail ; <nl> + import static org . apache . cassandra . utils . Throwables . merge ; <nl> <nl> public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> @ @ - 124 , 7 + 126 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( ColumnFamilyStore . class ) ; <nl> <nl> - private static final ExecutorService flushExecutor = new JMXEnabledThreadPoolExecutor ( DatabaseDescriptor . getFlushWriters ( ) , <nl> + @ VisibleForTesting <nl> + public static final ExecutorService flushExecutor = new JMXEnabledThreadPoolExecutor ( DatabaseDescriptor . getFlushWriters ( ) , <nl> StageManager . KEEPALIVE , <nl> TimeUnit . SECONDS , <nl> new LinkedBlockingQueue < Runnable > ( ) , <nl> @ @ - 921 , 8 + 924 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> final boolean flushSecondaryIndexes ; <nl> final OpOrder . Barrier writeBarrier ; <nl> - final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> - volatile FSWriteError flushFailure = null ; <nl> + final CountDownLatch memtablesFlushLatch = new CountDownLatch ( 1 ) ; <nl> + final CountDownLatch secondaryIndexFlushLatch = new CountDownLatch ( 1 ) ; <nl> + volatile Throwable flushFailure = null ; <nl> final List < Memtable > memtables ; <nl> <nl> private PostFlush ( boolean flushSecondaryIndexes , OpOrder . Barrier writeBarrier , <nl> @ @ - 943 , 15 + 947 , 27 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> * TODO : SecondaryIndex should support setBarrier ( ) , so custom implementations can co - ordinate exactly <nl> * with CL as we do with memtables / CFS - backed SecondaryIndexes . <nl> * / <nl> - <nl> - if ( flushSecondaryIndexes ) <nl> - indexManager . flushAllNonCFSBackedIndexesBlocking ( ) ; <nl> + try <nl> + { <nl> + if ( flushSecondaryIndexes ) <nl> + { <nl> + indexManager . flushAllNonCFSBackedIndexesBlocking ( ) ; <nl> + } <nl> + } <nl> + catch ( Throwable e ) <nl> + { <nl> + flushFailure = merge ( flushFailure , e ) ; <nl> + } <nl> + finally <nl> + { <nl> + secondaryIndexFlushLatch . countDown ( ) ; <nl> + } <nl> <nl> try <nl> { <nl> / / we wait on the latch for the commitLogUpperBound to be set , and so that waiters <nl> / / on this task can rely on all prior flushes being complete <nl> - latch . await ( ) ; <nl> + memtablesFlushLatch . await ( ) ; <nl> } <nl> catch ( InterruptedException e ) <nl> { <nl> @ @ - 970 , 7 + 986 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> metric . pendingFlushes . dec ( ) ; <nl> <nl> if ( flushFailure ! = null ) <nl> - throw flushFailure ; <nl> + Throwables . propagate ( flushFailure ) ; <nl> <nl> return commitLogUpperBound ; <nl> } <nl> @ @ - 1048 , 15 + 1064 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> try <nl> { <nl> for ( Memtable memtable : memtables ) <nl> - { <nl> - Collection < SSTableReader > readers = Collections . emptyList ( ) ; <nl> - if ( ! memtable . isClean ( ) & & ! truncate ) <nl> - readers = memtable . flush ( ) ; <nl> - memtable . cfs . replaceFlushed ( memtable , readers ) ; <nl> - reclaim ( memtable ) ; <nl> - } <nl> + flushMemtable ( memtable ) ; <nl> } <nl> - catch ( FSWriteError e ) <nl> + catch ( Throwable e ) <nl> { <nl> JVMStabilityInspector . inspectThrowable ( e ) ; <nl> / / If we weren ' t killed , try to continue work but do not allow CommitLog to be discarded . <nl> @ @ - 1064 , 7 + 1074 , 40 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> / / signal the post - flush we ' ve done our work <nl> - postFlush . latch . countDown ( ) ; <nl> + postFlush . memtablesFlushLatch . countDown ( ) ; <nl> + } <nl> + <nl> + public Collection < SSTableReader > flushMemtable ( Memtable memtable ) <nl> + { <nl> + if ( memtable . isClean ( ) | | truncate ) <nl> + { <nl> + memtable . cfs . replaceFlushed ( memtable , Collections . emptyList ( ) ) ; <nl> + reclaim ( memtable ) ; <nl> + return Collections . emptyList ( ) ; <nl> + } <nl> + <nl> + Collection < SSTableReader > readers = Collections . emptyList ( ) ; <nl> + try ( SSTableTxnWriter writer = memtable . flush ( ) ) <nl> + { <nl> + try <nl> + { <nl> + postFlush . secondaryIndexFlushLatch . await ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + postFlush . flushFailure = merge ( postFlush . flushFailure , e ) ; <nl> + } <nl> + <nl> + if ( postFlush . flushFailure = = null & & writer . getFilePointer ( ) > 0 ) <nl> + / / sstables should contain non - repaired data . <nl> + readers = writer . finish ( true ) ; <nl> + else <nl> + maybeFail ( writer . abort ( postFlush . flushFailure ) ) ; <nl> + } <nl> + <nl> + memtable . cfs . replaceFlushed ( memtable , readers ) ; <nl> + reclaim ( memtable ) ; <nl> + return readers ; <nl> } <nl> <nl> private void reclaim ( final Memtable memtable ) <nl> diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java <nl> index 1a7d6cb . . 6404b37 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Memtable . java <nl> + + + b / src / java / org / apache / cassandra / db / Memtable . java <nl> @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . index . transactions . UpdateTransaction ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> import org . apache . cassandra . io . sstable . SSTableTxnWriter ; <nl> import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableWriter ; <nl> import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; <nl> import org . apache . cassandra . io . util . DiskAwareRunnable ; <nl> import org . apache . cassandra . service . ActiveRepairService ; <nl> @ @ - 317 , 7 + 318 , 7 @ @ public class Memtable implements Comparable < Memtable > <nl> return partitions . get ( key ) ; <nl> } <nl> <nl> - public Collection < SSTableReader > flush ( ) <nl> + public SSTableTxnWriter flush ( ) <nl> { <nl> long estimatedSize = estimatedSize ( ) ; <nl> Directories . DataDirectory dataDirectory = cfs . getDirectories ( ) . getWriteableLocation ( estimatedSize ) ; <nl> @ @ - 357 , 64 + 358 , 52 @ @ public class Memtable implements Comparable < Memtable > <nl> * 1 . 2 ) ; / / bloom filter and row index overhead <nl> } <nl> <nl> - private Collection < SSTableReader > writeSortedContents ( File sstableDirectory ) <nl> + private SSTableTxnWriter writeSortedContents ( File sstableDirectory ) <nl> { <nl> boolean isBatchLogTable = cfs . name . equals ( SystemKeyspace . BATCHES ) & & cfs . keyspace . getName ( ) . equals ( SystemKeyspace . NAME ) ; <nl> <nl> logger . debug ( " Writing { } " , Memtable . this . toString ( ) ) ; <nl> <nl> - Collection < SSTableReader > ssTables ; <nl> - try ( SSTableTxnWriter writer = createFlushWriter ( cfs . getSSTablePath ( sstableDirectory ) , columnsCollector . get ( ) , statsCollector . get ( ) ) ) <nl> + SSTableTxnWriter writer = createFlushWriter ( cfs . getSSTablePath ( sstableDirectory ) , columnsCollector . get ( ) , statsCollector . get ( ) ) ; <nl> + boolean trackContention = logger . isTraceEnabled ( ) ; <nl> + int heavilyContendedRowCount = 0 ; <nl> + / / ( we can ' t clear out the map as - we - go to free up memory , <nl> + / / since the memtable is being used for queries in the " pending flush " category ) <nl> + for ( AtomicBTreePartition partition : partitions . values ( ) ) <nl> { <nl> - boolean trackContention = logger . isTraceEnabled ( ) ; <nl> - int heavilyContendedRowCount = 0 ; <nl> - / / ( we can ' t clear out the map as - we - go to free up memory , <nl> - / / since the memtable is being used for queries in the " pending flush " category ) <nl> - for ( AtomicBTreePartition partition : partitions . values ( ) ) <nl> + / / Each batchlog partition is a separate entry in the log . And for an entry , we only do 2 <nl> + / / operations : 1 ) we insert the entry and 2 ) we delete it . Further , BL data is strictly local , <nl> + / / we don ' t need to preserve tombstones for repair . So if both operation are in this <nl> + / / memtable ( which will almost always be the case if there is no ongoing failure ) , we can <nl> + / / just skip the entry ( CASSANDRA - 4667 ) . <nl> + if ( isBatchLogTable & & ! partition . partitionLevelDeletion ( ) . isLive ( ) & & partition . hasRows ( ) ) <nl> + continue ; <nl> + <nl> + if ( trackContention & & partition . usePessimisticLocking ( ) ) <nl> + heavilyContendedRowCount + + ; <nl> + <nl> + if ( ! partition . isEmpty ( ) ) <nl> { <nl> - / / Each batchlog partition is a separate entry in the log . And for an entry , we only do 2 <nl> - / / operations : 1 ) we insert the entry and 2 ) we delete it . Further , BL data is strictly local , <nl> - / / we don ' t need to preserve tombstones for repair . So if both operation are in this <nl> - / / memtable ( which will almost always be the case if there is no ongoing failure ) , we can <nl> - / / just skip the entry ( CASSANDRA - 4667 ) . <nl> - if ( isBatchLogTable & & ! partition . partitionLevelDeletion ( ) . isLive ( ) & & partition . hasRows ( ) ) <nl> - continue ; <nl> - <nl> - if ( trackContention & & partition . usePessimisticLocking ( ) ) <nl> - heavilyContendedRowCount + + ; <nl> - <nl> - if ( ! partition . isEmpty ( ) ) <nl> + try ( UnfilteredRowIterator iter = partition . unfilteredIterator ( ) ) <nl> { <nl> - try ( UnfilteredRowIterator iter = partition . unfilteredIterator ( ) ) <nl> - { <nl> - writer . append ( iter ) ; <nl> - } <nl> + writer . append ( iter ) ; <nl> } <nl> } <nl> + } <nl> <nl> - if ( writer . getFilePointer ( ) > 0 ) <nl> - { <nl> - logger . debug ( String . format ( " Completed flushing % s ( % s ) for commitlog position % s " , <nl> - writer . getFilename ( ) , <nl> - FBUtilities . prettyPrintMemory ( writer . getFilePointer ( ) ) , <nl> - commitLogUpperBound ) ) ; <nl> - <nl> - / / sstables should contain non - repaired data . <nl> - ssTables = writer . finish ( true ) ; <nl> - } <nl> - else <nl> - { <nl> - logger . debug ( " Completed flushing { } ; nothing needed to be retained . Commitlog position was { } " , <nl> - writer . getFilename ( ) , commitLogUpperBound ) ; <nl> - writer . abort ( ) ; <nl> - ssTables = Collections . emptyList ( ) ; <nl> - } <nl> + if ( writer . getFilePointer ( ) > 0 ) <nl> + logger . debug ( String . format ( " Completed flushing % s ( % s ) for commitlog position % s " , <nl> + writer . getFilename ( ) , <nl> + FBUtilities . prettyPrintMemory ( writer . getFilePointer ( ) ) , <nl> + commitLogUpperBound ) ) ; <nl> + else <nl> + logger . debug ( " Completed flushing { } ; nothing needed to be retained . Commitlog position was { } " , <nl> + writer . getFilename ( ) , commitLogUpperBound ) ; <nl> <nl> - if ( heavilyContendedRowCount > 0 ) <nl> - logger . trace ( String . format ( " High update contention in % d / % d partitions of % s " , heavilyContendedRowCount , partitions . size ( ) , Memtable . this . toString ( ) ) ) ; <nl> + if ( heavilyContendedRowCount > 0 ) <nl> + logger . trace ( String . format ( " High update contention in % d / % d partitions of % s " , heavilyContendedRowCount , partitions . size ( ) , Memtable . this . toString ( ) ) ) ; <nl> <nl> - return ssTables ; <nl> - } <nl> + return writer ; <nl> } <nl> <nl> @ SuppressWarnings ( " resource " ) / / log and writer closed by SSTableTxnWriter <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1285392 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java <nl> @ @ - 0 , 0 + 1 , 90 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . cql3 . validation . miscellaneous ; <nl> + <nl> + import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + import java . util . function . Supplier ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . index . StubIndex ; <nl> + import org . apache . cassandra . schema . IndexMetadata ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class ColumnFamilyStoreTest extends CQLTester <nl> + { <nl> + @ Test <nl> + public void testFailing2iFlush ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( pk int PRIMARY KEY , value int ) " ) ; <nl> + createIndex ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s ( value ) USING ' org . apache . cassandra . cql3 . validation . miscellaneous . ColumnFamilyStoreTest $ BrokenCustom2I ' " ) ; <nl> + <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + execute ( " INSERT INTO % s ( pk , value ) VALUES ( ? , ? ) " , i , i ) ; <nl> + <nl> + try <nl> + { <nl> + getCurrentColumnFamilyStore ( ) . forceBlockingFlush ( ) ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + / / ignore <nl> + } <nl> + <nl> + / / Make sure there ' s no flush running <nl> + waitFor ( ( ) - > ( ( JMXEnabledThreadPoolExecutor ) ColumnFamilyStore . flushExecutor ) . getActiveCount ( ) = = 0 , <nl> + TimeUnit . SECONDS . toMillis ( 5 ) ) ; <nl> + <nl> + / / SSTables remain uncommitted . <nl> + assertEquals ( 1 , getCurrentColumnFamilyStore ( ) . getDirectories ( ) . getDirectoryForNewSSTables ( ) . listFiles ( ) . length ) ; <nl> + } <nl> + <nl> + public void waitFor ( Supplier < Boolean > condition , long timeout ) <nl> + { <nl> + long start = System . currentTimeMillis ( ) ; <nl> + while ( true ) <nl> + { <nl> + if ( condition . get ( ) ) <nl> + return ; <nl> + <nl> + assertTrue ( " Timeout ocurred while waiting for condition " , <nl> + System . currentTimeMillis ( ) - start < timeout ) ; <nl> + } <nl> + } <nl> + <nl> + / / Used for index creation above <nl> + public static class BrokenCustom2I extends StubIndex <nl> + { <nl> + public BrokenCustom2I ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) <nl> + { <nl> + super ( baseCfs , metadata ) ; <nl> + } <nl> + <nl> + public Callable < ? > getBlockingFlushTask ( ) <nl> + { <nl> + throw new RuntimeException ( ) ; <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5cacdd0 . . 5242adf 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 11 
 + * Make sure sstables only get committed when it ' s safe to discard commit log records ( CASSANDRA - 12956 ) 
 * Reject default _ time _ to _ live option when creating or altering MVs ( CASSANDRA - 12868 ) 
 * Nodetool should use a more sane max heap size ( CASSANDRA - 12739 ) 
 * LocalToken ensures token values are cloned on heap ( CASSANDRA - 12651 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index d2a51a9 . . 113e10d 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 63 , 6 + 63 , 7 @ @ import org . apache . cassandra . io . FSWriteError ; 
 import org . apache . cassandra . io . sstable . Component ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . io . sstable . SSTableMultiWriter ; 
 + import org . apache . cassandra . io . sstable . SSTableTxnWriter ; 
 import org . apache . cassandra . io . sstable . format . * ; 
 import org . apache . cassandra . io . sstable . format . big . BigFormat ; 
 import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; 
 @ @ - 81 , 6 + 82 , 7 @ @ import org . json . simple . JSONArray ; 
 import org . json . simple . JSONObject ; 
 
 import static org . apache . cassandra . utils . Throwables . maybeFail ; 
 + import static org . apache . cassandra . utils . Throwables . merge ; 
 
 public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 @ @ - 124 , 7 + 126 , 8 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 private static final Logger logger = LoggerFactory . getLogger ( ColumnFamilyStore . class ) ; 
 
 - private static final ExecutorService flushExecutor = new JMXEnabledThreadPoolExecutor ( DatabaseDescriptor . getFlushWriters ( ) , 
 + @ VisibleForTesting 
 + public static final ExecutorService flushExecutor = new JMXEnabledThreadPoolExecutor ( DatabaseDescriptor . getFlushWriters ( ) , 
 StageManager . KEEPALIVE , 
 TimeUnit . SECONDS , 
 new LinkedBlockingQueue < Runnable > ( ) , 
 @ @ - 921 , 8 + 924 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 final boolean flushSecondaryIndexes ; 
 final OpOrder . Barrier writeBarrier ; 
 - final CountDownLatch latch = new CountDownLatch ( 1 ) ; 
 - volatile FSWriteError flushFailure = null ; 
 + final CountDownLatch memtablesFlushLatch = new CountDownLatch ( 1 ) ; 
 + final CountDownLatch secondaryIndexFlushLatch = new CountDownLatch ( 1 ) ; 
 + volatile Throwable flushFailure = null ; 
 final List < Memtable > memtables ; 
 
 private PostFlush ( boolean flushSecondaryIndexes , OpOrder . Barrier writeBarrier , 
 @ @ - 943 , 15 + 947 , 27 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 * TODO : SecondaryIndex should support setBarrier ( ) , so custom implementations can co - ordinate exactly 
 * with CL as we do with memtables / CFS - backed SecondaryIndexes . 
 * / 
 - 
 - if ( flushSecondaryIndexes ) 
 - indexManager . flushAllNonCFSBackedIndexesBlocking ( ) ; 
 + try 
 + { 
 + if ( flushSecondaryIndexes ) 
 + { 
 + indexManager . flushAllNonCFSBackedIndexesBlocking ( ) ; 
 + } 
 + } 
 + catch ( Throwable e ) 
 + { 
 + flushFailure = merge ( flushFailure , e ) ; 
 + } 
 + finally 
 + { 
 + secondaryIndexFlushLatch . countDown ( ) ; 
 + } 
 
 try 
 { 
 / / we wait on the latch for the commitLogUpperBound to be set , and so that waiters 
 / / on this task can rely on all prior flushes being complete 
 - latch . await ( ) ; 
 + memtablesFlushLatch . await ( ) ; 
 } 
 catch ( InterruptedException e ) 
 { 
 @ @ - 970 , 7 + 986 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 metric . pendingFlushes . dec ( ) ; 
 
 if ( flushFailure ! = null ) 
 - throw flushFailure ; 
 + Throwables . propagate ( flushFailure ) ; 
 
 return commitLogUpperBound ; 
 } 
 @ @ - 1048 , 15 + 1064 , 9 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 try 
 { 
 for ( Memtable memtable : memtables ) 
 - { 
 - Collection < SSTableReader > readers = Collections . emptyList ( ) ; 
 - if ( ! memtable . isClean ( ) & & ! truncate ) 
 - readers = memtable . flush ( ) ; 
 - memtable . cfs . replaceFlushed ( memtable , readers ) ; 
 - reclaim ( memtable ) ; 
 - } 
 + flushMemtable ( memtable ) ; 
 } 
 - catch ( FSWriteError e ) 
 + catch ( Throwable e ) 
 { 
 JVMStabilityInspector . inspectThrowable ( e ) ; 
 / / If we weren ' t killed , try to continue work but do not allow CommitLog to be discarded . 
 @ @ - 1064 , 7 + 1074 , 40 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 / / signal the post - flush we ' ve done our work 
 - postFlush . latch . countDown ( ) ; 
 + postFlush . memtablesFlushLatch . countDown ( ) ; 
 + } 
 + 
 + public Collection < SSTableReader > flushMemtable ( Memtable memtable ) 
 + { 
 + if ( memtable . isClean ( ) | | truncate ) 
 + { 
 + memtable . cfs . replaceFlushed ( memtable , Collections . emptyList ( ) ) ; 
 + reclaim ( memtable ) ; 
 + return Collections . emptyList ( ) ; 
 + } 
 + 
 + Collection < SSTableReader > readers = Collections . emptyList ( ) ; 
 + try ( SSTableTxnWriter writer = memtable . flush ( ) ) 
 + { 
 + try 
 + { 
 + postFlush . secondaryIndexFlushLatch . await ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + postFlush . flushFailure = merge ( postFlush . flushFailure , e ) ; 
 + } 
 + 
 + if ( postFlush . flushFailure = = null & & writer . getFilePointer ( ) > 0 ) 
 + / / sstables should contain non - repaired data . 
 + readers = writer . finish ( true ) ; 
 + else 
 + maybeFail ( writer . abort ( postFlush . flushFailure ) ) ; 
 + } 
 + 
 + memtable . cfs . replaceFlushed ( memtable , readers ) ; 
 + reclaim ( memtable ) ; 
 + return readers ; 
 } 
 
 private void reclaim ( final Memtable memtable ) 
 diff - - git a / src / java / org / apache / cassandra / db / Memtable . java b / src / java / org / apache / cassandra / db / Memtable . java 
 index 1a7d6cb . . 6404b37 100644 
 - - - a / src / java / org / apache / cassandra / db / Memtable . java 
 + + + b / src / java / org / apache / cassandra / db / Memtable . java 
 @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . index . transactions . UpdateTransaction ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 import org . apache . cassandra . io . sstable . SSTableTxnWriter ; 
 import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . io . sstable . format . SSTableWriter ; 
 import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; 
 import org . apache . cassandra . io . util . DiskAwareRunnable ; 
 import org . apache . cassandra . service . ActiveRepairService ; 
 @ @ - 317 , 7 + 318 , 7 @ @ public class Memtable implements Comparable < Memtable > 
 return partitions . get ( key ) ; 
 } 
 
 - public Collection < SSTableReader > flush ( ) 
 + public SSTableTxnWriter flush ( ) 
 { 
 long estimatedSize = estimatedSize ( ) ; 
 Directories . DataDirectory dataDirectory = cfs . getDirectories ( ) . getWriteableLocation ( estimatedSize ) ; 
 @ @ - 357 , 64 + 358 , 52 @ @ public class Memtable implements Comparable < Memtable > 
 * 1 . 2 ) ; / / bloom filter and row index overhead 
 } 
 
 - private Collection < SSTableReader > writeSortedContents ( File sstableDirectory ) 
 + private SSTableTxnWriter writeSortedContents ( File sstableDirectory ) 
 { 
 boolean isBatchLogTable = cfs . name . equals ( SystemKeyspace . BATCHES ) & & cfs . keyspace . getName ( ) . equals ( SystemKeyspace . NAME ) ; 
 
 logger . debug ( " Writing { } " , Memtable . this . toString ( ) ) ; 
 
 - Collection < SSTableReader > ssTables ; 
 - try ( SSTableTxnWriter writer = createFlushWriter ( cfs . getSSTablePath ( sstableDirectory ) , columnsCollector . get ( ) , statsCollector . get ( ) ) ) 
 + SSTableTxnWriter writer = createFlushWriter ( cfs . getSSTablePath ( sstableDirectory ) , columnsCollector . get ( ) , statsCollector . get ( ) ) ; 
 + boolean trackContention = logger . isTraceEnabled ( ) ; 
 + int heavilyContendedRowCount = 0 ; 
 + / / ( we can ' t clear out the map as - we - go to free up memory , 
 + / / since the memtable is being used for queries in the " pending flush " category ) 
 + for ( AtomicBTreePartition partition : partitions . values ( ) ) 
 { 
 - boolean trackContention = logger . isTraceEnabled ( ) ; 
 - int heavilyContendedRowCount = 0 ; 
 - / / ( we can ' t clear out the map as - we - go to free up memory , 
 - / / since the memtable is being used for queries in the " pending flush " category ) 
 - for ( AtomicBTreePartition partition : partitions . values ( ) ) 
 + / / Each batchlog partition is a separate entry in the log . And for an entry , we only do 2 
 + / / operations : 1 ) we insert the entry and 2 ) we delete it . Further , BL data is strictly local , 
 + / / we don ' t need to preserve tombstones for repair . So if both operation are in this 
 + / / memtable ( which will almost always be the case if there is no ongoing failure ) , we can 
 + / / just skip the entry ( CASSANDRA - 4667 ) . 
 + if ( isBatchLogTable & & ! partition . partitionLevelDeletion ( ) . isLive ( ) & & partition . hasRows ( ) ) 
 + continue ; 
 + 
 + if ( trackContention & & partition . usePessimisticLocking ( ) ) 
 + heavilyContendedRowCount + + ; 
 + 
 + if ( ! partition . isEmpty ( ) ) 
 { 
 - / / Each batchlog partition is a separate entry in the log . And for an entry , we only do 2 
 - / / operations : 1 ) we insert the entry and 2 ) we delete it . Further , BL data is strictly local , 
 - / / we don ' t need to preserve tombstones for repair . So if both operation are in this 
 - / / memtable ( which will almost always be the case if there is no ongoing failure ) , we can 
 - / / just skip the entry ( CASSANDRA - 4667 ) . 
 - if ( isBatchLogTable & & ! partition . partitionLevelDeletion ( ) . isLive ( ) & & partition . hasRows ( ) ) 
 - continue ; 
 - 
 - if ( trackContention & & partition . usePessimisticLocking ( ) ) 
 - heavilyContendedRowCount + + ; 
 - 
 - if ( ! partition . isEmpty ( ) ) 
 + try ( UnfilteredRowIterator iter = partition . unfilteredIterator ( ) ) 
 { 
 - try ( UnfilteredRowIterator iter = partition . unfilteredIterator ( ) ) 
 - { 
 - writer . append ( iter ) ; 
 - } 
 + writer . append ( iter ) ; 
 } 
 } 
 + } 
 
 - if ( writer . getFilePointer ( ) > 0 ) 
 - { 
 - logger . debug ( String . format ( " Completed flushing % s ( % s ) for commitlog position % s " , 
 - writer . getFilename ( ) , 
 - FBUtilities . prettyPrintMemory ( writer . getFilePointer ( ) ) , 
 - commitLogUpperBound ) ) ; 
 - 
 - / / sstables should contain non - repaired data . 
 - ssTables = writer . finish ( true ) ; 
 - } 
 - else 
 - { 
 - logger . debug ( " Completed flushing { } ; nothing needed to be retained . Commitlog position was { } " , 
 - writer . getFilename ( ) , commitLogUpperBound ) ; 
 - writer . abort ( ) ; 
 - ssTables = Collections . emptyList ( ) ; 
 - } 
 + if ( writer . getFilePointer ( ) > 0 ) 
 + logger . debug ( String . format ( " Completed flushing % s ( % s ) for commitlog position % s " , 
 + writer . getFilename ( ) , 
 + FBUtilities . prettyPrintMemory ( writer . getFilePointer ( ) ) , 
 + commitLogUpperBound ) ) ; 
 + else 
 + logger . debug ( " Completed flushing { } ; nothing needed to be retained . Commitlog position was { } " , 
 + writer . getFilename ( ) , commitLogUpperBound ) ; 
 
 - if ( heavilyContendedRowCount > 0 ) 
 - logger . trace ( String . format ( " High update contention in % d / % d partitions of % s " , heavilyContendedRowCount , partitions . size ( ) , Memtable . this . toString ( ) ) ) ; 
 + if ( heavilyContendedRowCount > 0 ) 
 + logger . trace ( String . format ( " High update contention in % d / % d partitions of % s " , heavilyContendedRowCount , partitions . size ( ) , Memtable . this . toString ( ) ) ) ; 
 
 - return ssTables ; 
 - } 
 + return writer ; 
 } 
 
 @ SuppressWarnings ( " resource " ) / / log and writer closed by SSTableTxnWriter 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java 
 new file mode 100644 
 index 0000000 . . 1285392 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / miscellaneous / ColumnFamilyStoreTest . java 
 @ @ - 0 , 0 + 1 , 90 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . cql3 . validation . miscellaneous ; 
 + 
 + import java . util . concurrent . Callable ; 
 + import java . util . concurrent . TimeUnit ; 
 + import java . util . function . Supplier ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . index . StubIndex ; 
 + import org . apache . cassandra . schema . IndexMetadata ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class ColumnFamilyStoreTest extends CQLTester 
 + { 
 + @ Test 
 + public void testFailing2iFlush ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( pk int PRIMARY KEY , value int ) " ) ; 
 + createIndex ( " CREATE CUSTOM INDEX IF NOT EXISTS ON % s ( value ) USING ' org . apache . cassandra . cql3 . validation . miscellaneous . ColumnFamilyStoreTest $ BrokenCustom2I ' " ) ; 
 + 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + execute ( " INSERT INTO % s ( pk , value ) VALUES ( ? , ? ) " , i , i ) ; 
 + 
 + try 
 + { 
 + getCurrentColumnFamilyStore ( ) . forceBlockingFlush ( ) ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + / / ignore 
 + } 
 + 
 + / / Make sure there ' s no flush running 
 + waitFor ( ( ) - > ( ( JMXEnabledThreadPoolExecutor ) ColumnFamilyStore . flushExecutor ) . getActiveCount ( ) = = 0 , 
 + TimeUnit . SECONDS . toMillis ( 5 ) ) ; 
 + 
 + / / SSTables remain uncommitted . 
 + assertEquals ( 1 , getCurrentColumnFamilyStore ( ) . getDirectories ( ) . getDirectoryForNewSSTables ( ) . listFiles ( ) . length ) ; 
 + } 
 + 
 + public void waitFor ( Supplier < Boolean > condition , long timeout ) 
 + { 
 + long start = System . currentTimeMillis ( ) ; 
 + while ( true ) 
 + { 
 + if ( condition . get ( ) ) 
 + return ; 
 + 
 + assertTrue ( " Timeout ocurred while waiting for condition " , 
 + System . currentTimeMillis ( ) - start < timeout ) ; 
 + } 
 + } 
 + 
 + / / Used for index creation above 
 + public static class BrokenCustom2I extends StubIndex 
 + { 
 + public BrokenCustom2I ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) 
 + { 
 + super ( baseCfs , metadata ) ; 
 + } 
 + 
 + public Callable < ? > getBlockingFlushTask ( ) 
 + { 
 + throw new RuntimeException ( ) ; 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
