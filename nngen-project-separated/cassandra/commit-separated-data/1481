BLEU SCORE: 1.0

TEST MSG: Fix comparison contract violation in the dynamic snitch sorting
GENERATED MSG: Fix comparison contract violation in the dynamic snitch sorting

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a755cb9 . . f20fad8 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 17 <nl> + * Complete CASSANDRA - 8448 fix ( CASSANDRA - 9519 ) <nl> * Don ' t include auth credentials in debug log ( CASSANDRA - 9682 ) <nl> * Can ' t transition from write survey to normal mode ( CASSANDRA - 9740 ) <nl> * Avoid NPE in AuthSuccess # decode ( CASSANDRA - 9727 ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> index 3469847 . . f226989 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> @ @ - 42 , 9 + 42 , 9 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> private static final double ALPHA = 0 . 75 ; / / set to 0 . 75 to make EDS more biased to towards the newer values <nl> private static final int WINDOW _ SIZE = 100 ; <nl> <nl> - private int UPDATE _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicUpdateInterval ( ) ; <nl> - private int RESET _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicResetInterval ( ) ; <nl> - private double BADNESS _ THRESHOLD = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; <nl> + private final int UPDATE _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicUpdateInterval ( ) ; <nl> + private final int RESET _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicResetInterval ( ) ; <nl> + private final double BADNESS _ THRESHOLD = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; <nl> <nl> / / the score for a merged set of endpoints must be this much worse than the score for separate endpoints to <nl> / / warrant not merging two ranges into a single range <nl> @ @ - 154 , 7 + 154 , 18 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> <nl> private void sortByProximityWithScore ( final InetAddress address , List < InetAddress > addresses ) <nl> { <nl> - super . sortByProximity ( address , addresses ) ; <nl> + / / Scores can change concurrently from a call to this method . But Collections . sort ( ) expects <nl> + / / its comparator to be " stable " , that is 2 endpoint should compare the same way for the duration <nl> + / / of the sort ( ) call . As we copy the scores map on write , it is thus enough to alias the current <nl> + / / version of it during this call . <nl> + final HashMap < InetAddress , Double > scores = this . scores ; <nl> + Collections . sort ( addresses , new Comparator < InetAddress > ( ) <nl> + { <nl> + public int compare ( InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return compareEndpoints ( address , a1 , a2 , scores ) ; <nl> + } <nl> + } ) ; <nl> } <nl> <nl> private void sortByProximityWithBadness ( final InetAddress address , List < InetAddress > addresses ) <nl> @ @ - 163 , 6 + 174 , 8 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> return ; <nl> <nl> subsnitch . sortByProximity ( address , addresses ) ; <nl> + HashMap < InetAddress , Double > scores = this . scores ; / / Make sure the score don ' t change in the middle of the loop below <nl> + / / ( which wouldn ' t really matter here but its cleaner that way ) . <nl> ArrayList < Double > subsnitchOrderedScores = new ArrayList < > ( addresses . size ( ) ) ; <nl> for ( InetAddress inet : addresses ) <nl> { <nl> @ @ - 189 , 7 + 202 , 8 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> } <nl> } <nl> <nl> - public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + / / Compare endpoints given an immutable snapshot of the scores <nl> + private int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 , Map < InetAddress , Double > scores ) <nl> { <nl> Double scored1 = scores . get ( a1 ) ; <nl> Double scored2 = scores . get ( a2 ) ; <nl> @ @ - 214 , 6 + 228 , 14 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> return 1 ; <nl> } <nl> <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + / / That function is fundamentally unsafe because the scores can change at any time and so the result of that <nl> + / / method is not stable for identical arguments . This is why we don ' t rely on super . sortByProximity ( ) in <nl> + / / sortByProximityWithScore ( ) . <nl> + throw new UnsupportedOperationException ( " You shouldn ' t wrap the DynamicEndpointSnitch ( within itself or otherwise ) " ) ; <nl> + } <nl> + <nl> public void receiveTiming ( InetAddress host , long latency ) / / this is cheap <nl> { <nl> ExponentiallyDecayingSample sample = samples . get ( host ) ; <nl> @ @ - 263 , 7 + 285 , 6 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> scores = newScores ; <nl> } <nl> <nl> - <nl> private void reset ( ) <nl> { <nl> for ( ExponentiallyDecayingSample sample : samples . values ( ) ) <nl> @ @ - 287 , 6 + 308 , 7 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa <nl> { <nl> return BADNESS _ THRESHOLD ; <nl> } <nl> + <nl> public String getSubsnitchClassName ( ) <nl> { <nl> return subsnitch . getClass ( ) . getName ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> index e23bcfa . . 3f90532 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> @ @ - 21 , 9 + 21 , 9 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> - import java . util . Arrays ; <nl> - import java . util . List ; <nl> + import java . util . * ; <nl> <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . junit . Test ; <nl> @ @ - 90 , 4 + 90 , 67 @ @ public class DynamicEndpointSnitchTest <nl> order = Arrays . asList ( host1 , host3 , host2 ) ; <nl> assertEquals ( order , dsnitch . getSortedListByProximity ( self , Arrays . asList ( host1 , host2 , host3 ) ) ) ; <nl> } <nl> - } <nl> \ No newline at end of file <nl> + <nl> + @ Test <nl> + public void testConcurrency ( ) throws InterruptedException , IOException , ConfigurationException <nl> + { <nl> + / / The goal of this test is to check for CASSANDRA - 8448 / CASSANDRA - 9519 <nl> + double badness = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; <nl> + DatabaseDescriptor . setDynamicBadnessThreshold ( 0 . 0 ) ; <nl> + <nl> + final int ITERATIONS = 10 ; <nl> + <nl> + / / do this because SS needs to be initialized before DES can work properly . <nl> + StorageService . instance . initClient ( 0 ) ; <nl> + SimpleSnitch ss = new SimpleSnitch ( ) ; <nl> + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( ss , String . valueOf ( ss . hashCode ( ) ) ) ; <nl> + InetAddress self = FBUtilities . getBroadcastAddress ( ) ; <nl> + <nl> + List < InetAddress > hosts = new ArrayList < > ( ) ; <nl> + / / We want a giant list of hosts so that sorting it takes time , making it much more likely to reproduce the <nl> + / / problem we ' re looking for . <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + for ( int j = 0 ; j < 256 ; j + + ) <nl> + for ( int k = 0 ; k < 256 ; k + + ) <nl> + hosts . add ( InetAddress . getByAddress ( new byte [ ] { 127 , ( byte ) i , ( byte ) j , ( byte ) k } ) ) ; <nl> + <nl> + ScoreUpdater updater = new ScoreUpdater ( dsnitch , hosts ) ; <nl> + updater . start ( ) ; <nl> + <nl> + List < InetAddress > result = null ; <nl> + for ( int i = 0 ; i < ITERATIONS ; i + + ) <nl> + result = dsnitch . getSortedListByProximity ( self , hosts ) ; <nl> + <nl> + updater . stopped = true ; <nl> + updater . join ( ) ; <nl> + <nl> + DatabaseDescriptor . setDynamicBadnessThreshold ( badness ) ; <nl> + } <nl> + <nl> + public static class ScoreUpdater extends Thread <nl> + { <nl> + private static final int SCORE _ RANGE = 100 ; <nl> + <nl> + public volatile boolean stopped ; <nl> + <nl> + private final DynamicEndpointSnitch dsnitch ; <nl> + private final List < InetAddress > hosts ; <nl> + private final Random random = new Random ( ) ; <nl> + <nl> + public ScoreUpdater ( DynamicEndpointSnitch dsnitch , List < InetAddress > hosts ) <nl> + { <nl> + this . dsnitch = dsnitch ; <nl> + this . hosts = hosts ; <nl> + } <nl> + <nl> + public void run ( ) <nl> + { <nl> + while ( ! stopped ) <nl> + { <nl> + InetAddress host = hosts . get ( random . nextInt ( hosts . size ( ) ) ) ; <nl> + int score = random . nextInt ( SCORE _ RANGE ) ; <nl> + dsnitch . receiveTiming ( host , score ) ; <nl> + } <nl> + } <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a755cb9 . . f20fad8 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 17 
 + * Complete CASSANDRA - 8448 fix ( CASSANDRA - 9519 ) 
 * Don ' t include auth credentials in debug log ( CASSANDRA - 9682 ) 
 * Can ' t transition from write survey to normal mode ( CASSANDRA - 9740 ) 
 * Avoid NPE in AuthSuccess # decode ( CASSANDRA - 9727 ) 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 index 3469847 . . f226989 100644 
 - - - a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 @ @ - 42 , 9 + 42 , 9 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 private static final double ALPHA = 0 . 75 ; / / set to 0 . 75 to make EDS more biased to towards the newer values 
 private static final int WINDOW _ SIZE = 100 ; 
 
 - private int UPDATE _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicUpdateInterval ( ) ; 
 - private int RESET _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicResetInterval ( ) ; 
 - private double BADNESS _ THRESHOLD = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; 
 + private final int UPDATE _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicUpdateInterval ( ) ; 
 + private final int RESET _ INTERVAL _ IN _ MS = DatabaseDescriptor . getDynamicResetInterval ( ) ; 
 + private final double BADNESS _ THRESHOLD = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; 
 
 / / the score for a merged set of endpoints must be this much worse than the score for separate endpoints to 
 / / warrant not merging two ranges into a single range 
 @ @ - 154 , 7 + 154 , 18 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 
 private void sortByProximityWithScore ( final InetAddress address , List < InetAddress > addresses ) 
 { 
 - super . sortByProximity ( address , addresses ) ; 
 + / / Scores can change concurrently from a call to this method . But Collections . sort ( ) expects 
 + / / its comparator to be " stable " , that is 2 endpoint should compare the same way for the duration 
 + / / of the sort ( ) call . As we copy the scores map on write , it is thus enough to alias the current 
 + / / version of it during this call . 
 + final HashMap < InetAddress , Double > scores = this . scores ; 
 + Collections . sort ( addresses , new Comparator < InetAddress > ( ) 
 + { 
 + public int compare ( InetAddress a1 , InetAddress a2 ) 
 + { 
 + return compareEndpoints ( address , a1 , a2 , scores ) ; 
 + } 
 + } ) ; 
 } 
 
 private void sortByProximityWithBadness ( final InetAddress address , List < InetAddress > addresses ) 
 @ @ - 163 , 6 + 174 , 8 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 return ; 
 
 subsnitch . sortByProximity ( address , addresses ) ; 
 + HashMap < InetAddress , Double > scores = this . scores ; / / Make sure the score don ' t change in the middle of the loop below 
 + / / ( which wouldn ' t really matter here but its cleaner that way ) . 
 ArrayList < Double > subsnitchOrderedScores = new ArrayList < > ( addresses . size ( ) ) ; 
 for ( InetAddress inet : addresses ) 
 { 
 @ @ - 189 , 7 + 202 , 8 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 } 
 } 
 
 - public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + / / Compare endpoints given an immutable snapshot of the scores 
 + private int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 , Map < InetAddress , Double > scores ) 
 { 
 Double scored1 = scores . get ( a1 ) ; 
 Double scored2 = scores . get ( a2 ) ; 
 @ @ - 214 , 6 + 228 , 14 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 return 1 ; 
 } 
 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + / / That function is fundamentally unsafe because the scores can change at any time and so the result of that 
 + / / method is not stable for identical arguments . This is why we don ' t rely on super . sortByProximity ( ) in 
 + / / sortByProximityWithScore ( ) . 
 + throw new UnsupportedOperationException ( " You shouldn ' t wrap the DynamicEndpointSnitch ( within itself or otherwise ) " ) ; 
 + } 
 + 
 public void receiveTiming ( InetAddress host , long latency ) / / this is cheap 
 { 
 ExponentiallyDecayingSample sample = samples . get ( host ) ; 
 @ @ - 263 , 7 + 285 , 6 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 scores = newScores ; 
 } 
 
 - 
 private void reset ( ) 
 { 
 for ( ExponentiallyDecayingSample sample : samples . values ( ) ) 
 @ @ - 287 , 6 + 308 , 7 @ @ public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILa 
 { 
 return BADNESS _ THRESHOLD ; 
 } 
 + 
 public String getSubsnitchClassName ( ) 
 { 
 return subsnitch . getClass ( ) . getName ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 index e23bcfa . . 3f90532 100644 
 - - - a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 @ @ - 21 , 9 + 21 , 9 @ @ package org . apache . cassandra . locator ; 
 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 - import java . util . Arrays ; 
 - import java . util . List ; 
 + import java . util . * ; 
 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . junit . Test ; 
 @ @ - 90 , 4 + 90 , 67 @ @ public class DynamicEndpointSnitchTest 
 order = Arrays . asList ( host1 , host3 , host2 ) ; 
 assertEquals ( order , dsnitch . getSortedListByProximity ( self , Arrays . asList ( host1 , host2 , host3 ) ) ) ; 
 } 
 - } 
 \ No newline at end of file 
 + 
 + @ Test 
 + public void testConcurrency ( ) throws InterruptedException , IOException , ConfigurationException 
 + { 
 + / / The goal of this test is to check for CASSANDRA - 8448 / CASSANDRA - 9519 
 + double badness = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; 
 + DatabaseDescriptor . setDynamicBadnessThreshold ( 0 . 0 ) ; 
 + 
 + final int ITERATIONS = 10 ; 
 + 
 + / / do this because SS needs to be initialized before DES can work properly . 
 + StorageService . instance . initClient ( 0 ) ; 
 + SimpleSnitch ss = new SimpleSnitch ( ) ; 
 + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( ss , String . valueOf ( ss . hashCode ( ) ) ) ; 
 + InetAddress self = FBUtilities . getBroadcastAddress ( ) ; 
 + 
 + List < InetAddress > hosts = new ArrayList < > ( ) ; 
 + / / We want a giant list of hosts so that sorting it takes time , making it much more likely to reproduce the 
 + / / problem we ' re looking for . 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + for ( int j = 0 ; j < 256 ; j + + ) 
 + for ( int k = 0 ; k < 256 ; k + + ) 
 + hosts . add ( InetAddress . getByAddress ( new byte [ ] { 127 , ( byte ) i , ( byte ) j , ( byte ) k } ) ) ; 
 + 
 + ScoreUpdater updater = new ScoreUpdater ( dsnitch , hosts ) ; 
 + updater . start ( ) ; 
 + 
 + List < InetAddress > result = null ; 
 + for ( int i = 0 ; i < ITERATIONS ; i + + ) 
 + result = dsnitch . getSortedListByProximity ( self , hosts ) ; 
 + 
 + updater . stopped = true ; 
 + updater . join ( ) ; 
 + 
 + DatabaseDescriptor . setDynamicBadnessThreshold ( badness ) ; 
 + } 
 + 
 + public static class ScoreUpdater extends Thread 
 + { 
 + private static final int SCORE _ RANGE = 100 ; 
 + 
 + public volatile boolean stopped ; 
 + 
 + private final DynamicEndpointSnitch dsnitch ; 
 + private final List < InetAddress > hosts ; 
 + private final Random random = new Random ( ) ; 
 + 
 + public ScoreUpdater ( DynamicEndpointSnitch dsnitch , List < InetAddress > hosts ) 
 + { 
 + this . dsnitch = dsnitch ; 
 + this . hosts = hosts ; 
 + } 
 + 
 + public void run ( ) 
 + { 
 + while ( ! stopped ) 
 + { 
 + InetAddress host = hosts . get ( random . nextInt ( hosts . size ( ) ) ) ; 
 + int score = random . nextInt ( SCORE _ RANGE ) ; 
 + dsnitch . receiveTiming ( host , score ) ; 
 + } 
 + } 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
