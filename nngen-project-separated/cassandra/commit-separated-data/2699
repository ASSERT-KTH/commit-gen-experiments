BLEU SCORE: 0.037954847898457066

TEST MSG: Add stress and deps to debian packaging .
GENERATED MSG: build requires subversion ( line 235 of build . xml )

TEST DIFF (one line): diff - - git a / debian / rules b / debian / rules <nl> index 11b78e7 . . c45bf3e 100755 <nl> - - - a / debian / rules <nl> + + + b / debian / rules <nl> @ @ - 45 , 8 + 45 , 8 @ @ install : build <nl> 	 dh _ install build / apache - cassandra - thrift - $ ( VERSION ) . jar \ <nl> 	 	 usr / share / cassandra <nl> <nl> - 	 # Copy stress jar <nl> - 	 dh _ install build / tools / lib / stress . jar \ <nl> + 	 # Copy stress jars <nl> + 	 dh _ install build / tools / lib / * . jar \ <nl> 	 	 usr / share / cassandra <nl> <nl> 	 dh _ link usr / share / cassandra / apache - cassandra - $ ( VERSION ) . jar \
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6dee284 . . 030f3bb 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 26 , 7 + 26 , 7 @ @ <nl> * fix " short reads " in [ multi ] get ( CASSANDRA - 2643 ) <nl> * add optional compression for sstables ( CASSANDRA - 47 ) <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> - <nl> + * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> <nl> 0 . 8 . 4 <nl> * include files - to - be - streamed in StreamInSession . getSources ( CASSANDRA - 2972 ) <nl> diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java b / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java <nl> index f3aa950 . . 2980be8 100644 <nl> - - - a / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java <nl> + + + b / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java <nl> @ @ - 20 , 7 + 20 , 10 @ @ package org . apache . cassandra . io . compress ; <nl> <nl> import java . io . * ; <nl> import java . nio . ByteBuffer ; <nl> + import java . nio . channels . FileChannel ; <nl> import java . nio . channels . WritableByteChannel ; <nl> + import java . util . zip . CRC32 ; <nl> + import java . util . zip . Checksum ; <nl> <nl> import org . apache . cassandra . io . sstable . Component ; <nl> import org . apache . cassandra . io . sstable . Descriptor ; <nl> @ @ - 28 , 6 + 31 , 7 @ @ import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . io . util . RandomAccessReader ; <nl> import org . apache . cassandra . streaming . FileStreamTask ; <nl> import org . apache . cassandra . streaming . PendingFile ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> import org . slf4j . Logger ; <nl> @ @ - 129 , 7 + 133 , 14 @ @ public class CompressedRandomAccessReader extends RandomAccessReader <nl> / / used by reBuffer ( ) to escape creating lots of temporary buffers <nl> private final byte [ ] compressed ; <nl> <nl> + / / re - use single crc object <nl> + private final Checksum checksum = new CRC32 ( ) ; <nl> + <nl> + / / raw checksum bytes <nl> + private final byte [ ] checksumBytes = new byte [ 4 ] ; <nl> + <nl> private final FileInputStream source ; <nl> + private final FileChannel channel ; <nl> <nl> public CompressedRandomAccessReader ( String dataFilePath , CompressionMetadata metadata , boolean skipIOCache ) throws IOException <nl> { <nl> @ @ - 140 , 6 + 151 , 7 @ @ public class CompressedRandomAccessReader extends RandomAccessReader <nl> / / that is why we are allocating special InputStream to read data from disk <nl> / / from already open file descriptor <nl> source = new FileInputStream ( getFD ( ) ) ; <nl> + channel = source . getChannel ( ) ; / / for position manipulation <nl> } <nl> <nl> @ Override <nl> @ @ - 150 , 18 + 162 , 40 @ @ public class CompressedRandomAccessReader extends RandomAccessReader <nl> <nl> private void decompressChunk ( CompressionMetadata . Chunk chunk ) throws IOException <nl> { <nl> - if ( source . getChannel ( ) . position ( ) ! = chunk . offset ) <nl> - source . getChannel ( ) . position ( chunk . offset ) ; <nl> + if ( channel . position ( ) ! = chunk . offset ) <nl> + channel . position ( chunk . offset ) ; <nl> <nl> if ( source . read ( compressed , 0 , chunk . length ) ! = chunk . length ) <nl> throw new IOException ( String . format ( " ( % s ) failed to read % d bytes from offset % d . " , getPath ( ) , chunk . length , chunk . offset ) ) ; <nl> <nl> validBufferBytes = Snappy . rawUncompress ( compressed , 0 , chunk . length , buffer , 0 ) ; <nl> <nl> + checksum . update ( buffer , 0 , validBufferBytes ) ; <nl> + <nl> + if ( checksum ( chunk ) ! = ( int ) checksum . getValue ( ) ) <nl> + throw new CorruptedBlockException ( getPath ( ) , chunk ) ; <nl> + <nl> + / / reset checksum object back to the original ( blank ) state <nl> + checksum . reset ( ) ; <nl> + <nl> + <nl> / / buffer offset is always aligned <nl> bufferOffset = current & ~ ( buffer . length - 1 ) ; <nl> } <nl> <nl> + private int checksum ( CompressionMetadata . Chunk chunk ) throws IOException <nl> + { <nl> + assert channel . position ( ) = = chunk . offset + chunk . length ; <nl> + <nl> + if ( source . read ( checksumBytes , 0 , checksumBytes . length ) ! = checksumBytes . length ) <nl> + throw new IOException ( String . format ( " ( % s ) failed to read checksum of the chunk at % d of length % d . " , <nl> + getPath ( ) , <nl> + chunk . offset , <nl> + chunk . length ) ) ; <nl> + <nl> + return FBUtilities . byteArrayToInt ( checksumBytes ) ; <nl> + } <nl> + <nl> @ Override <nl> public long length ( ) throws IOException <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> index 64907a8 . . f9af748 100644 <nl> - - - a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> @ @ - 20 , 6 + 20 , 8 @ @ package org . apache . cassandra . io . compress ; <nl> <nl> import java . io . File ; <nl> import java . io . IOException ; <nl> + import java . util . zip . CRC32 ; <nl> + import java . util . zip . Checksum ; <nl> <nl> import org . apache . cassandra . io . util . FileMark ; <nl> import org . apache . cassandra . io . util . SequentialWriter ; <nl> @ @ - 48 , 6 + 50 , 8 @ @ public class CompressedSequentialWriter extends SequentialWriter <nl> / / holds a number of already written chunks <nl> private int chunkCount = 0 ; <nl> <nl> + private final Checksum checksum = new CRC32 ( ) ; <nl> + <nl> public CompressedSequentialWriter ( File file , String indexFilePath , boolean skipIOCache ) throws IOException <nl> { <nl> super ( file , CHUNK _ LENGTH , skipIOCache ) ; <nl> @ @ - 80 , 16 + 84 , 25 @ @ public class CompressedSequentialWriter extends SequentialWriter <nl> / / compressing data with buffer re - use <nl> int compressedLength = Snappy . rawCompress ( buffer , 0 , validBufferBytes , compressed , 0 ) ; <nl> <nl> + / / update checksum <nl> + checksum . update ( buffer , 0 , validBufferBytes ) ; <nl> + <nl> / / write an offset of the newly written chunk to the index file <nl> metadataWriter . writeLong ( chunkOffset ) ; <nl> chunkCount + + ; <nl> <nl> - / / write data itself <nl> assert compressedLength < = compressed . length ; <nl> + <nl> + / / write data itself <nl> out . write ( compressed , 0 , compressedLength ) ; <nl> + / / write corresponding checksum <nl> + out . writeInt ( ( int ) checksum . getValue ( ) ) ; <nl> <nl> - / / next chunk should be written right after current <nl> - chunkOffset + = compressedLength ; <nl> + / / reset checksum object to the blank state for re - use <nl> + checksum . reset ( ) ; <nl> + <nl> + / / next chunk should be written right after current + length of the checksum ( int ) <nl> + chunkOffset + = compressedLength + 4 ; <nl> } <nl> <nl> @ Override <nl> @ @ - 122 , 13 + 135 , 21 @ @ public class CompressedSequentialWriter extends SequentialWriter <nl> / / setting marker as a current offset <nl> chunkOffset = realMark . chunkOffset ; <nl> <nl> - / / compressed chunk size <nl> - int chunkSize = ( int ) ( metadataWriter . chunkOffsetBy ( realMark . nextChunkIndex ) - chunkOffset ) ; <nl> + / / compressed chunk size ( - 4 bytes reserved for checksum ) <nl> + int chunkSize = ( int ) ( metadataWriter . chunkOffsetBy ( realMark . nextChunkIndex ) - chunkOffset - 4 ) ; <nl> <nl> out . seek ( chunkOffset ) ; <nl> out . read ( compressed , 0 , chunkSize ) ; <nl> <nl> - Snappy . rawUncompress ( compressed , 0 , chunkSize , buffer , 0 ) ; <nl> + / / decompress data chunk and store its length <nl> + int validBytes = Snappy . rawUncompress ( compressed , 0 , chunkSize , buffer , 0 ) ; <nl> + <nl> + checksum . update ( buffer , 0 , validBytes ) ; <nl> + <nl> + if ( out . readInt ( ) ! = ( int ) checksum . getValue ( ) ) <nl> + throw new CorruptedBlockException ( getPath ( ) , chunkOffset , chunkSize ) ; <nl> + <nl> + checksum . reset ( ) ; <nl> <nl> / / reset buffer <nl> validBufferBytes = realMark . bufferOffset ; <nl> diff - - git a / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java b / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java <nl> index 85fe165 . . d243356 100644 <nl> - - - a / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java <nl> + + + b / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java <nl> @ @ - 102 , 7 + 102 , 7 @ @ public class CompressionMetadata <nl> ? compressedFileLength <nl> : chunkOffsets [ idx + 1 ] ; <nl> <nl> - return new Chunk ( chunkOffset , ( int ) ( nextChunkOffset - chunkOffset ) ) ; <nl> + return new Chunk ( chunkOffset , ( int ) ( nextChunkOffset - chunkOffset - 4 ) ) ; / / " 4 " bytes reserved for checksum <nl> } <nl> <nl> public static class Writer extends RandomAccessFile <nl> @ @ - 205 , 5 + 205 , 10 @ @ public class CompressionMetadata <nl> this . offset = offset ; <nl> this . length = length ; <nl> } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + return String . format ( " Chunk < offset : % d , length : % d > " , offset , length ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java b / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java <nl> new file mode 100644 <nl> index 0000000 . . 8c3f30c <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java <nl> @ @ - 0 , 0 + 1 , 34 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . io . compress ; <nl> + <nl> + import java . io . IOException ; <nl> + <nl> + public class CorruptedBlockException extends IOException <nl> + { <nl> + public CorruptedBlockException ( String filePath , CompressionMetadata . Chunk chunk ) <nl> + { <nl> + this ( filePath , chunk . offset , chunk . length ) ; <nl> + } <nl> + <nl> + public CorruptedBlockException ( String filePath , long offset , int length ) <nl> + { <nl> + super ( String . format ( " ( % s ) : corruption detected , chunk at % d of length % d . " , filePath , offset , length ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> index 61f51a5 . . 09d7fe7 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> @ @ - 299 , 6 + 299 , 26 @ @ public class FBUtilities <nl> return bytes ; <nl> } <nl> <nl> + / * * <nl> + * Convert the byte array to an int starting from the given offset . <nl> + * <nl> + * @ param b The byte array <nl> + * <nl> + * @ return The integer <nl> + * / <nl> + public static int byteArrayToInt ( byte [ ] b ) <nl> + { <nl> + int value = 0 ; <nl> + <nl> + for ( int i = 0 ; i < 4 ; i + + ) <nl> + { <nl> + int shift = ( 4 - 1 - i ) * 8 ; <nl> + value + = ( b [ i ] & 0x000000FF ) < < shift ; <nl> + } <nl> + <nl> + return value ; <nl> + } <nl> + <nl> public static int compareUnsigned ( byte [ ] bytes1 , byte [ ] bytes2 , int offset1 , int offset2 , int len1 , int len2 ) <nl> { <nl> if ( bytes1 = = null ) <nl> diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java <nl> index 42b0c1f . . 702a2d7 100644 <nl> - - - a / test / unit / org / apache / cassandra / Util . java <nl> + + + b / test / unit / org / apache / cassandra / Util . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra ; <nl> * <nl> * / <nl> <nl> + import java . io . EOFException ; <nl> import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> @ @ - 27 , 6 + 28 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> + import java . util . concurrent . Callable ; <nl> import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . Future ; <nl> <nl> @ @ - 213 , 4 + 215 , 25 @ @ public class Util <nl> task . execute ( null ) ; <nl> } <nl> <nl> + public static void expectEOF ( Callable < ? > callable ) <nl> + { <nl> + expectException ( callable , EOFException . class ) ; <nl> + } <nl> + <nl> + public static void expectException ( Callable < ? > callable , Class < ? > exception ) <nl> + { <nl> + boolean thrown = false ; <nl> + <nl> + try <nl> + { <nl> + callable . call ( ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + assert e . getClass ( ) . equals ( exception ) : e . getClass ( ) . getName ( ) + " is not " + exception . getName ( ) ; <nl> + thrown = true ; <nl> + } <nl> + <nl> + assert thrown : exception . getName ( ) + " not received " ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java b / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java <nl> index bc4a849 . . 7ff9c89 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java <nl> @ @ - 19 , 11 + 19 , 17 @ @ <nl> package org . apache . cassandra . io . compress ; <nl> <nl> import java . io . * ; <nl> + import java . util . Random ; <nl> + import java . util . concurrent . Callable ; <nl> <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . io . util . * ; <nl> <nl> + import static org . junit . Assert . assertEquals ; <nl> + <nl> + import static org . apache . cassandra . Util . expectException ; <nl> + <nl> public class CompressedRandomAccessReaderTest <nl> { <nl> @ Test <nl> @ @ - 87 , 4 + 93 , 87 @ @ public class CompressedRandomAccessReaderTest <nl> metadata . delete ( ) ; <nl> } <nl> } <nl> + <nl> + @ Test <nl> + public void testDataCorruptionDetection ( ) throws IOException <nl> + { <nl> + String CONTENT = " Lorem ipsum dolor sit amet , consectetur adipiscing elit . Etiam vitae . " ; <nl> + <nl> + File file = new File ( " testDataCorruptionDetection " ) ; <nl> + file . deleteOnExit ( ) ; <nl> + <nl> + File metadata = new File ( file . getPath ( ) + " . meta " ) ; <nl> + metadata . deleteOnExit ( ) ; <nl> + <nl> + SequentialWriter writer = new CompressedSequentialWriter ( file , metadata . getPath ( ) , false ) ; <nl> + <nl> + writer . write ( CONTENT . getBytes ( ) ) ; <nl> + writer . close ( ) ; <nl> + <nl> + / / open compression metadata and get chunk information <nl> + CompressionMetadata meta = new CompressionMetadata ( metadata . getPath ( ) , file . length ( ) ) ; <nl> + CompressionMetadata . Chunk chunk = meta . chunkFor ( 0 ) ; <nl> + <nl> + RandomAccessReader reader = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; <nl> + / / read and verify compressed data <nl> + assertEquals ( CONTENT , reader . readLine ( ) ) ; <nl> + / / close reader <nl> + reader . close ( ) ; <nl> + <nl> + Random random = new Random ( ) ; <nl> + RandomAccessFile checksumModifier = null ; <nl> + <nl> + try <nl> + { <nl> + checksumModifier = new RandomAccessFile ( file , " rw " ) ; <nl> + byte [ ] checksum = new byte [ 4 ] ; <nl> + <nl> + / / seek to the end of the compressed chunk <nl> + checksumModifier . seek ( chunk . length ) ; <nl> + / / read checksum bytes <nl> + checksumModifier . read ( checksum ) ; <nl> + / / seek back to the chunk end <nl> + checksumModifier . seek ( chunk . length ) ; <nl> + <nl> + / / lets modify one byte of the checksum on each iteration <nl> + for ( int i = 0 ; i < checksum . length ; i + + ) <nl> + { <nl> + checksumModifier . write ( random . nextInt ( ) ) ; <nl> + checksumModifier . getFD ( ) . sync ( ) ; / / making sure that change was synced with disk <nl> + <nl> + final RandomAccessReader r = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; <nl> + <nl> + expectException ( new Callable < String > ( ) <nl> + { <nl> + public String call ( ) throws Exception <nl> + { <nl> + return r . readLine ( ) ; <nl> + } <nl> + } , CorruptedBlockException . class ) ; <nl> + <nl> + r . close ( ) ; <nl> + } <nl> + <nl> + / / lets write original checksum and check if we can read data <nl> + updateChecksum ( checksumModifier , chunk . length , checksum ) ; <nl> + <nl> + reader = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; <nl> + / / read and verify compressed data <nl> + assertEquals ( CONTENT , reader . readLine ( ) ) ; <nl> + / / close reader <nl> + reader . close ( ) ; <nl> + } <nl> + finally <nl> + { <nl> + if ( checksumModifier ! = null ) <nl> + checksumModifier . close ( ) ; <nl> + } <nl> + } <nl> + <nl> + private void updateChecksum ( RandomAccessFile file , long checksumOffset , byte [ ] checksum ) throws IOException <nl> + { <nl> + file . seek ( checksumOffset ) ; <nl> + file . write ( checksum ) ; <nl> + file . getFD ( ) . sync ( ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> index dda7b88 . . 9eba5be 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java <nl> @ @ - 21 , 7 + 21 , 6 @ @ package org . apache . cassandra . io . util ; <nl> <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> - import java . io . EOFException ; <nl> import java . io . File ; <nl> import java . io . FileOutputStream ; <nl> import java . io . IOException ; <nl> @ @ - 30 , 6 + 29 , 9 @ @ import java . nio . channels . ClosedChannelException ; <nl> import java . util . Arrays ; <nl> import java . util . concurrent . Callable ; <nl> <nl> + import static org . apache . cassandra . Util . expectEOF ; <nl> + import static org . apache . cassandra . Util . expectException ; <nl> + <nl> import static org . junit . Assert . assertTrue ; <nl> import static org . junit . Assert . assertEquals ; <nl> <nl> @ @ - 637 , 26 + 639 , 4 @ @ public class BufferedRandomAccessFileTest <nl> <nl> return arr ; <nl> } <nl> - <nl> - private void expectEOF ( Callable < ? > callable ) <nl> - { <nl> - expectException ( callable , EOFException . class ) ; <nl> - } <nl> - <nl> - private void expectException ( Callable < ? > callable , Class < ? > exception ) <nl> - { <nl> - boolean thrown = false ; <nl> - <nl> - try <nl> - { <nl> - callable . call ( ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - assert e . getClass ( ) . equals ( exception ) : e . getClass ( ) . getName ( ) + " is not " + exception . getName ( ) ; <nl> - thrown = true ; <nl> - } <nl> - <nl> - assert thrown : exception . getName ( ) + " not received " ; <nl> - } <nl> }

TEST DIFF:
diff - - git a / debian / rules b / debian / rules 
 index 11b78e7 . . c45bf3e 100755 
 - - - a / debian / rules 
 + + + b / debian / rules 
 @ @ - 45 , 8 + 45 , 8 @ @ install : build 
 	 dh _ install build / apache - cassandra - thrift - $ ( VERSION ) . jar \ 
 	 	 usr / share / cassandra 
 
 - 	 # Copy stress jar 
 - 	 dh _ install build / tools / lib / stress . jar \ 
 + 	 # Copy stress jars 
 + 	 dh _ install build / tools / lib / * . jar \ 
 	 	 usr / share / cassandra 
 
 	 dh _ link usr / share / cassandra / apache - cassandra - $ ( VERSION ) . jar \

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6dee284 . . 030f3bb 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 26 , 7 + 26 , 7 @ @ 
 * fix " short reads " in [ multi ] get ( CASSANDRA - 2643 ) 
 * add optional compression for sstables ( CASSANDRA - 47 ) 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 - 
 + * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 
 0 . 8 . 4 
 * include files - to - be - streamed in StreamInSession . getSources ( CASSANDRA - 2972 ) 
 diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java b / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java 
 index f3aa950 . . 2980be8 100644 
 - - - a / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java 
 + + + b / src / java / org / apache / cassandra / io / compress / CompressedRandomAccessReader . java 
 @ @ - 20 , 7 + 20 , 10 @ @ package org . apache . cassandra . io . compress ; 
 
 import java . io . * ; 
 import java . nio . ByteBuffer ; 
 + import java . nio . channels . FileChannel ; 
 import java . nio . channels . WritableByteChannel ; 
 + import java . util . zip . CRC32 ; 
 + import java . util . zip . Checksum ; 
 
 import org . apache . cassandra . io . sstable . Component ; 
 import org . apache . cassandra . io . sstable . Descriptor ; 
 @ @ - 28 , 6 + 31 , 7 @ @ import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . io . util . RandomAccessReader ; 
 import org . apache . cassandra . streaming . FileStreamTask ; 
 import org . apache . cassandra . streaming . PendingFile ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . Pair ; 
 
 import org . slf4j . Logger ; 
 @ @ - 129 , 7 + 133 , 14 @ @ public class CompressedRandomAccessReader extends RandomAccessReader 
 / / used by reBuffer ( ) to escape creating lots of temporary buffers 
 private final byte [ ] compressed ; 
 
 + / / re - use single crc object 
 + private final Checksum checksum = new CRC32 ( ) ; 
 + 
 + / / raw checksum bytes 
 + private final byte [ ] checksumBytes = new byte [ 4 ] ; 
 + 
 private final FileInputStream source ; 
 + private final FileChannel channel ; 
 
 public CompressedRandomAccessReader ( String dataFilePath , CompressionMetadata metadata , boolean skipIOCache ) throws IOException 
 { 
 @ @ - 140 , 6 + 151 , 7 @ @ public class CompressedRandomAccessReader extends RandomAccessReader 
 / / that is why we are allocating special InputStream to read data from disk 
 / / from already open file descriptor 
 source = new FileInputStream ( getFD ( ) ) ; 
 + channel = source . getChannel ( ) ; / / for position manipulation 
 } 
 
 @ Override 
 @ @ - 150 , 18 + 162 , 40 @ @ public class CompressedRandomAccessReader extends RandomAccessReader 
 
 private void decompressChunk ( CompressionMetadata . Chunk chunk ) throws IOException 
 { 
 - if ( source . getChannel ( ) . position ( ) ! = chunk . offset ) 
 - source . getChannel ( ) . position ( chunk . offset ) ; 
 + if ( channel . position ( ) ! = chunk . offset ) 
 + channel . position ( chunk . offset ) ; 
 
 if ( source . read ( compressed , 0 , chunk . length ) ! = chunk . length ) 
 throw new IOException ( String . format ( " ( % s ) failed to read % d bytes from offset % d . " , getPath ( ) , chunk . length , chunk . offset ) ) ; 
 
 validBufferBytes = Snappy . rawUncompress ( compressed , 0 , chunk . length , buffer , 0 ) ; 
 
 + checksum . update ( buffer , 0 , validBufferBytes ) ; 
 + 
 + if ( checksum ( chunk ) ! = ( int ) checksum . getValue ( ) ) 
 + throw new CorruptedBlockException ( getPath ( ) , chunk ) ; 
 + 
 + / / reset checksum object back to the original ( blank ) state 
 + checksum . reset ( ) ; 
 + 
 + 
 / / buffer offset is always aligned 
 bufferOffset = current & ~ ( buffer . length - 1 ) ; 
 } 
 
 + private int checksum ( CompressionMetadata . Chunk chunk ) throws IOException 
 + { 
 + assert channel . position ( ) = = chunk . offset + chunk . length ; 
 + 
 + if ( source . read ( checksumBytes , 0 , checksumBytes . length ) ! = checksumBytes . length ) 
 + throw new IOException ( String . format ( " ( % s ) failed to read checksum of the chunk at % d of length % d . " , 
 + getPath ( ) , 
 + chunk . offset , 
 + chunk . length ) ) ; 
 + 
 + return FBUtilities . byteArrayToInt ( checksumBytes ) ; 
 + } 
 + 
 @ Override 
 public long length ( ) throws IOException 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 index 64907a8 . . f9af748 100644 
 - - - a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 + + + b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 @ @ - 20 , 6 + 20 , 8 @ @ package org . apache . cassandra . io . compress ; 
 
 import java . io . File ; 
 import java . io . IOException ; 
 + import java . util . zip . CRC32 ; 
 + import java . util . zip . Checksum ; 
 
 import org . apache . cassandra . io . util . FileMark ; 
 import org . apache . cassandra . io . util . SequentialWriter ; 
 @ @ - 48 , 6 + 50 , 8 @ @ public class CompressedSequentialWriter extends SequentialWriter 
 / / holds a number of already written chunks 
 private int chunkCount = 0 ; 
 
 + private final Checksum checksum = new CRC32 ( ) ; 
 + 
 public CompressedSequentialWriter ( File file , String indexFilePath , boolean skipIOCache ) throws IOException 
 { 
 super ( file , CHUNK _ LENGTH , skipIOCache ) ; 
 @ @ - 80 , 16 + 84 , 25 @ @ public class CompressedSequentialWriter extends SequentialWriter 
 / / compressing data with buffer re - use 
 int compressedLength = Snappy . rawCompress ( buffer , 0 , validBufferBytes , compressed , 0 ) ; 
 
 + / / update checksum 
 + checksum . update ( buffer , 0 , validBufferBytes ) ; 
 + 
 / / write an offset of the newly written chunk to the index file 
 metadataWriter . writeLong ( chunkOffset ) ; 
 chunkCount + + ; 
 
 - / / write data itself 
 assert compressedLength < = compressed . length ; 
 + 
 + / / write data itself 
 out . write ( compressed , 0 , compressedLength ) ; 
 + / / write corresponding checksum 
 + out . writeInt ( ( int ) checksum . getValue ( ) ) ; 
 
 - / / next chunk should be written right after current 
 - chunkOffset + = compressedLength ; 
 + / / reset checksum object to the blank state for re - use 
 + checksum . reset ( ) ; 
 + 
 + / / next chunk should be written right after current + length of the checksum ( int ) 
 + chunkOffset + = compressedLength + 4 ; 
 } 
 
 @ Override 
 @ @ - 122 , 13 + 135 , 21 @ @ public class CompressedSequentialWriter extends SequentialWriter 
 / / setting marker as a current offset 
 chunkOffset = realMark . chunkOffset ; 
 
 - / / compressed chunk size 
 - int chunkSize = ( int ) ( metadataWriter . chunkOffsetBy ( realMark . nextChunkIndex ) - chunkOffset ) ; 
 + / / compressed chunk size ( - 4 bytes reserved for checksum ) 
 + int chunkSize = ( int ) ( metadataWriter . chunkOffsetBy ( realMark . nextChunkIndex ) - chunkOffset - 4 ) ; 
 
 out . seek ( chunkOffset ) ; 
 out . read ( compressed , 0 , chunkSize ) ; 
 
 - Snappy . rawUncompress ( compressed , 0 , chunkSize , buffer , 0 ) ; 
 + / / decompress data chunk and store its length 
 + int validBytes = Snappy . rawUncompress ( compressed , 0 , chunkSize , buffer , 0 ) ; 
 + 
 + checksum . update ( buffer , 0 , validBytes ) ; 
 + 
 + if ( out . readInt ( ) ! = ( int ) checksum . getValue ( ) ) 
 + throw new CorruptedBlockException ( getPath ( ) , chunkOffset , chunkSize ) ; 
 + 
 + checksum . reset ( ) ; 
 
 / / reset buffer 
 validBufferBytes = realMark . bufferOffset ; 
 diff - - git a / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java b / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java 
 index 85fe165 . . d243356 100644 
 - - - a / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java 
 + + + b / src / java / org / apache / cassandra / io / compress / CompressionMetadata . java 
 @ @ - 102 , 7 + 102 , 7 @ @ public class CompressionMetadata 
 ? compressedFileLength 
 : chunkOffsets [ idx + 1 ] ; 
 
 - return new Chunk ( chunkOffset , ( int ) ( nextChunkOffset - chunkOffset ) ) ; 
 + return new Chunk ( chunkOffset , ( int ) ( nextChunkOffset - chunkOffset - 4 ) ) ; / / " 4 " bytes reserved for checksum 
 } 
 
 public static class Writer extends RandomAccessFile 
 @ @ - 205 , 5 + 205 , 10 @ @ public class CompressionMetadata 
 this . offset = offset ; 
 this . length = length ; 
 } 
 + 
 + public String toString ( ) 
 + { 
 + return String . format ( " Chunk < offset : % d , length : % d > " , offset , length ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java b / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java 
 new file mode 100644 
 index 0000000 . . 8c3f30c 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / io / compress / CorruptedBlockException . java 
 @ @ - 0 , 0 + 1 , 34 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . io . compress ; 
 + 
 + import java . io . IOException ; 
 + 
 + public class CorruptedBlockException extends IOException 
 + { 
 + public CorruptedBlockException ( String filePath , CompressionMetadata . Chunk chunk ) 
 + { 
 + this ( filePath , chunk . offset , chunk . length ) ; 
 + } 
 + 
 + public CorruptedBlockException ( String filePath , long offset , int length ) 
 + { 
 + super ( String . format ( " ( % s ) : corruption detected , chunk at % d of length % d . " , filePath , offset , length ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 index 61f51a5 . . 09d7fe7 100644 
 - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java 
 + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 @ @ - 299 , 6 + 299 , 26 @ @ public class FBUtilities 
 return bytes ; 
 } 
 
 + / * * 
 + * Convert the byte array to an int starting from the given offset . 
 + * 
 + * @ param b The byte array 
 + * 
 + * @ return The integer 
 + * / 
 + public static int byteArrayToInt ( byte [ ] b ) 
 + { 
 + int value = 0 ; 
 + 
 + for ( int i = 0 ; i < 4 ; i + + ) 
 + { 
 + int shift = ( 4 - 1 - i ) * 8 ; 
 + value + = ( b [ i ] & 0x000000FF ) < < shift ; 
 + } 
 + 
 + return value ; 
 + } 
 + 
 public static int compareUnsigned ( byte [ ] bytes1 , byte [ ] bytes2 , int offset1 , int offset2 , int len1 , int len2 ) 
 { 
 if ( bytes1 = = null ) 
 diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java 
 index 42b0c1f . . 702a2d7 100644 
 - - - a / test / unit / org / apache / cassandra / Util . java 
 + + + b / test / unit / org / apache / cassandra / Util . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra ; 
 * 
 * / 
 
 + import java . io . EOFException ; 
 import java . io . IOException ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 @ @ - 27 , 6 + 28 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 + import java . util . concurrent . Callable ; 
 import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . Future ; 
 
 @ @ - 213 , 4 + 215 , 25 @ @ public class Util 
 task . execute ( null ) ; 
 } 
 
 + public static void expectEOF ( Callable < ? > callable ) 
 + { 
 + expectException ( callable , EOFException . class ) ; 
 + } 
 + 
 + public static void expectException ( Callable < ? > callable , Class < ? > exception ) 
 + { 
 + boolean thrown = false ; 
 + 
 + try 
 + { 
 + callable . call ( ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + assert e . getClass ( ) . equals ( exception ) : e . getClass ( ) . getName ( ) + " is not " + exception . getName ( ) ; 
 + thrown = true ; 
 + } 
 + 
 + assert thrown : exception . getName ( ) + " not received " ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java b / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java 
 index bc4a849 . . 7ff9c89 100644 
 - - - a / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java 
 + + + b / test / unit / org / apache / cassandra / io / compress / CompressedRandomAccessReaderTest . java 
 @ @ - 19 , 11 + 19 , 17 @ @ 
 package org . apache . cassandra . io . compress ; 
 
 import java . io . * ; 
 + import java . util . Random ; 
 + import java . util . concurrent . Callable ; 
 
 import org . junit . Test ; 
 
 import org . apache . cassandra . io . util . * ; 
 
 + import static org . junit . Assert . assertEquals ; 
 + 
 + import static org . apache . cassandra . Util . expectException ; 
 + 
 public class CompressedRandomAccessReaderTest 
 { 
 @ Test 
 @ @ - 87 , 4 + 93 , 87 @ @ public class CompressedRandomAccessReaderTest 
 metadata . delete ( ) ; 
 } 
 } 
 + 
 + @ Test 
 + public void testDataCorruptionDetection ( ) throws IOException 
 + { 
 + String CONTENT = " Lorem ipsum dolor sit amet , consectetur adipiscing elit . Etiam vitae . " ; 
 + 
 + File file = new File ( " testDataCorruptionDetection " ) ; 
 + file . deleteOnExit ( ) ; 
 + 
 + File metadata = new File ( file . getPath ( ) + " . meta " ) ; 
 + metadata . deleteOnExit ( ) ; 
 + 
 + SequentialWriter writer = new CompressedSequentialWriter ( file , metadata . getPath ( ) , false ) ; 
 + 
 + writer . write ( CONTENT . getBytes ( ) ) ; 
 + writer . close ( ) ; 
 + 
 + / / open compression metadata and get chunk information 
 + CompressionMetadata meta = new CompressionMetadata ( metadata . getPath ( ) , file . length ( ) ) ; 
 + CompressionMetadata . Chunk chunk = meta . chunkFor ( 0 ) ; 
 + 
 + RandomAccessReader reader = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; 
 + / / read and verify compressed data 
 + assertEquals ( CONTENT , reader . readLine ( ) ) ; 
 + / / close reader 
 + reader . close ( ) ; 
 + 
 + Random random = new Random ( ) ; 
 + RandomAccessFile checksumModifier = null ; 
 + 
 + try 
 + { 
 + checksumModifier = new RandomAccessFile ( file , " rw " ) ; 
 + byte [ ] checksum = new byte [ 4 ] ; 
 + 
 + / / seek to the end of the compressed chunk 
 + checksumModifier . seek ( chunk . length ) ; 
 + / / read checksum bytes 
 + checksumModifier . read ( checksum ) ; 
 + / / seek back to the chunk end 
 + checksumModifier . seek ( chunk . length ) ; 
 + 
 + / / lets modify one byte of the checksum on each iteration 
 + for ( int i = 0 ; i < checksum . length ; i + + ) 
 + { 
 + checksumModifier . write ( random . nextInt ( ) ) ; 
 + checksumModifier . getFD ( ) . sync ( ) ; / / making sure that change was synced with disk 
 + 
 + final RandomAccessReader r = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; 
 + 
 + expectException ( new Callable < String > ( ) 
 + { 
 + public String call ( ) throws Exception 
 + { 
 + return r . readLine ( ) ; 
 + } 
 + } , CorruptedBlockException . class ) ; 
 + 
 + r . close ( ) ; 
 + } 
 + 
 + / / lets write original checksum and check if we can read data 
 + updateChecksum ( checksumModifier , chunk . length , checksum ) ; 
 + 
 + reader = CompressedRandomAccessReader . open ( file . getPath ( ) , meta , false ) ; 
 + / / read and verify compressed data 
 + assertEquals ( CONTENT , reader . readLine ( ) ) ; 
 + / / close reader 
 + reader . close ( ) ; 
 + } 
 + finally 
 + { 
 + if ( checksumModifier ! = null ) 
 + checksumModifier . close ( ) ; 
 + } 
 + } 
 + 
 + private void updateChecksum ( RandomAccessFile file , long checksumOffset , byte [ ] checksum ) throws IOException 
 + { 
 + file . seek ( checksumOffset ) ; 
 + file . write ( checksum ) ; 
 + file . getFD ( ) . sync ( ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 index dda7b88 . . 9eba5be 100644 
 - - - a / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 + + + b / test / unit / org / apache / cassandra / io / util / BufferedRandomAccessFileTest . java 
 @ @ - 21 , 7 + 21 , 6 @ @ package org . apache . cassandra . io . util ; 
 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 - import java . io . EOFException ; 
 import java . io . File ; 
 import java . io . FileOutputStream ; 
 import java . io . IOException ; 
 @ @ - 30 , 6 + 29 , 9 @ @ import java . nio . channels . ClosedChannelException ; 
 import java . util . Arrays ; 
 import java . util . concurrent . Callable ; 
 
 + import static org . apache . cassandra . Util . expectEOF ; 
 + import static org . apache . cassandra . Util . expectException ; 
 + 
 import static org . junit . Assert . assertTrue ; 
 import static org . junit . Assert . assertEquals ; 
 
 @ @ - 637 , 26 + 639 , 4 @ @ public class BufferedRandomAccessFileTest 
 
 return arr ; 
 } 
 - 
 - private void expectEOF ( Callable < ? > callable ) 
 - { 
 - expectException ( callable , EOFException . class ) ; 
 - } 
 - 
 - private void expectException ( Callable < ? > callable , Class < ? > exception ) 
 - { 
 - boolean thrown = false ; 
 - 
 - try 
 - { 
 - callable . call ( ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - assert e . getClass ( ) . equals ( exception ) : e . getClass ( ) . getName ( ) + " is not " + exception . getName ( ) ; 
 - thrown = true ; 
 - } 
 - 
 - assert thrown : exception . getName ( ) + " not received " ; 
 - } 
 }
