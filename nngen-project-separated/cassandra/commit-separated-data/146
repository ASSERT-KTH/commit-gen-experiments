BLEU SCORE: 0.027611988917697356

TEST MSG: Improve LatencyMetrics performance by reducing write path processing
GENERATED MSG: Add sstable bulk loading utility

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 784fa2b . . fe03ae1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Improve LatencyMetrics performance by reducing write path processing ( CASSANDRA - 14281 ) <nl> * Add network authz ( CASSANDRA - 13985 ) <nl> * Use the correct IP / Port for Streaming when localAddress is left unbound ( CASSANDAR - 14389 ) <nl> * nodetool listsnapshots is missing local system keyspace snapshots ( CASSANDRA - 14381 ) <nl> diff - - git a / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java b / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java <nl> index 118f062 . . f17de78 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java <nl> + + + b / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java <nl> @ @ - 24 , 8 + 24 , 7 @ @ import java . io . PrintWriter ; <nl> import java . nio . charset . StandardCharsets ; <nl> import java . util . Arrays ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> - import java . util . concurrent . atomic . AtomicLongArray ; <nl> - import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> + import java . util . concurrent . atomic . LongAdder ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> <nl> @ @ - 85 , 8 + 84 , 8 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> private final long [ ] bucketOffsets ; <nl> <nl> / / decayingBuckets and buckets are one element longer than bucketOffsets - - the last element is values greater than the last offset <nl> - private final AtomicLongArray decayingBuckets ; <nl> - private final AtomicLongArray buckets ; <nl> + private final LongAdder [ ] decayingBuckets ; <nl> + private final LongAdder [ ] buckets ; <nl> <nl> public static final long HALF _ TIME _ IN _ S = 60L ; <nl> public static final double MEAN _ LIFETIME _ IN _ S = HALF _ TIME _ IN _ S / Math . log ( 2 . 0 ) ; <nl> @ @ - 95 , 8 + 94 , 6 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> private final AtomicBoolean rescaling = new AtomicBoolean ( false ) ; <nl> private volatile long decayLandmark ; <nl> <nl> - private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock ( ) ; <nl> - <nl> / / Wrapper around System . nanoTime ( ) to simplify unit testing . <nl> private final Clock clock ; <nl> <nl> @ @ - 150 , 8 + 147 , 15 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> { <nl> bucketOffsets = EstimatedHistogram . newOffsets ( bucketCount , considerZeroes ) ; <nl> } <nl> - decayingBuckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; <nl> - buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; <nl> + decayingBuckets = new LongAdder [ bucketOffsets . length + 1 ] ; <nl> + buckets = new LongAdder [ bucketOffsets . length + 1 ] ; <nl> + <nl> + for ( int i = 0 ; i < buckets . length ; i + + ) <nl> + { <nl> + decayingBuckets [ i ] = new LongAdder ( ) ; <nl> + buckets [ i ] = new LongAdder ( ) ; <nl> + } <nl> + <nl> this . clock = clock ; <nl> decayLandmark = clock . getTime ( ) ; <nl> } <nl> @ @ - 174 , 18 + 178 , 8 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> } <nl> / / else exact match ; we ' re good <nl> <nl> - lockForRegularUsage ( ) ; <nl> - <nl> - try <nl> - { <nl> - decayingBuckets . getAndAdd ( index , Math . round ( forwardDecayWeight ( now ) ) ) ; <nl> - } <nl> - finally <nl> - { <nl> - unlockForRegularUsage ( ) ; <nl> - } <nl> - <nl> - buckets . getAndIncrement ( index ) ; <nl> + decayingBuckets [ index ] . add ( Math . round ( forwardDecayWeight ( now ) ) ) ; <nl> + buckets [ index ] . increment ( ) ; <nl> } <nl> <nl> private double forwardDecayWeight ( long now ) <nl> @ @ - 202 , 7 + 196 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> * / <nl> public int size ( ) <nl> { <nl> - return decayingBuckets . length ( ) ; <nl> + return decayingBuckets . length ; <nl> } <nl> <nl> / * * <nl> @ @ - 215 , 17 + 209 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> public Snapshot getSnapshot ( ) <nl> { <nl> rescaleIfNeeded ( ) ; <nl> - <nl> - lockForRegularUsage ( ) ; <nl> - <nl> - try <nl> - { <nl> - return new EstimatedHistogramReservoirSnapshot ( this ) ; <nl> - } <nl> - finally <nl> - { <nl> - unlockForRegularUsage ( ) ; <nl> - } <nl> + return new EstimatedHistogramReservoirSnapshot ( this ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 234 , 7 + 218 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> @ VisibleForTesting <nl> boolean isOverflowed ( ) <nl> { <nl> - return decayingBuckets . get ( decayingBuckets . length ( ) - 1 ) > 0 ; <nl> + return decayingBuckets [ decayingBuckets . length - 1 ] . sum ( ) > 0 ; <nl> } <nl> <nl> private void rescaleIfNeeded ( ) <nl> @ @ - 254 , 6 + 238 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> } <nl> finally <nl> { <nl> + decayLandmark = now ; <nl> rescaling . set ( false ) ; <nl> } <nl> } <nl> @ @ - 262 , 27 + 247 , 14 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> <nl> private void rescale ( long now ) <nl> { <nl> - / / Check again to make sure that another thread didn ' t complete rescale already <nl> - if ( needRescale ( now ) ) <nl> - { <nl> - lockForRescale ( ) ; <nl> - <nl> - try <nl> - { <nl> - final double rescaleFactor = forwardDecayWeight ( now ) ; <nl> - decayLandmark = now ; <nl> + final double rescaleFactor = forwardDecayWeight ( now ) ; <nl> <nl> - final int bucketCount = decayingBuckets . length ( ) ; <nl> - for ( int i = 0 ; i < bucketCount ; i + + ) <nl> - { <nl> - long newValue = Math . round ( ( decayingBuckets . get ( i ) / rescaleFactor ) ) ; <nl> - decayingBuckets . set ( i , newValue ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - unlockForRescale ( ) ; <nl> - } <nl> + final int bucketCount = decayingBuckets . length ; <nl> + for ( int i = 0 ; i < bucketCount ; i + + ) <nl> + { <nl> + long storedValue = decayingBuckets [ i ] . sumThenReset ( ) ; <nl> + storedValue = Math . round ( storedValue / rescaleFactor ) ; <nl> + decayingBuckets [ i ] . add ( storedValue ) ; <nl> } <nl> } <nl> <nl> @ @ - 294 , 41 + 266 , 44 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> @ VisibleForTesting <nl> public void clear ( ) <nl> { <nl> - lockForRescale ( ) ; <nl> - <nl> - try <nl> - { <nl> - final int bucketCount = decayingBuckets . length ( ) ; <nl> - for ( int i = 0 ; i < bucketCount ; i + + ) <nl> - { <nl> - decayingBuckets . set ( i , 0L ) ; <nl> - buckets . set ( i , 0L ) ; <nl> - } <nl> - } <nl> - finally <nl> + final int bucketCount = decayingBuckets . length ; <nl> + for ( int i = 0 ; i < bucketCount ; i + + ) <nl> { <nl> - unlockForRescale ( ) ; <nl> + decayingBuckets [ i ] . reset ( ) ; <nl> + buckets [ i ] . reset ( ) ; <nl> } <nl> } <nl> <nl> - private void lockForRegularUsage ( ) <nl> + / * * <nl> + * Replaces current internal values with the given one from a Snapshot . This method is NOT thread safe , values <nl> + * added at the same time to this reservoir using methods such as update may lose their data <nl> + * / <nl> + public void rebase ( EstimatedHistogramReservoirSnapshot snapshot ) <nl> { <nl> - this . lock . readLock ( ) . lock ( ) ; <nl> - } <nl> + / / Check bucket count <nl> + if ( decayingBuckets . length ! = snapshot . decayingBuckets . length ) <nl> + { <nl> + throw new IllegalStateException ( " Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes " ) ; <nl> + } <nl> <nl> - private void unlockForRegularUsage ( ) <nl> - { <nl> - this . lock . readLock ( ) . unlock ( ) ; <nl> - } <nl> + / / Check bucketOffsets <nl> + for ( int i = 0 ; i < bucketOffsets . length ; i + + ) <nl> + { <nl> + if ( bucketOffsets [ i ] ! = snapshot . bucketOffsets [ i ] ) <nl> + { <nl> + throw new IllegalStateException ( " Merge is only supported with equal bucketOffsets " ) ; <nl> + } <nl> + } <nl> <nl> - private void lockForRescale ( ) <nl> - { <nl> - this . lock . writeLock ( ) . lock ( ) ; <nl> - } <nl> + this . decayLandmark = snapshot . snapshotLandmark ; <nl> + for ( int i = 0 ; i < decayingBuckets . length ; i + + ) <nl> + { <nl> + decayingBuckets [ i ] . reset ( ) ; <nl> + buckets [ i ] . reset ( ) ; <nl> <nl> - private void unlockForRescale ( ) <nl> - { <nl> - this . lock . writeLock ( ) . unlock ( ) ; <nl> + decayingBuckets [ i ] . add ( snapshot . decayingBuckets [ i ] ) ; <nl> + buckets [ i ] . add ( snapshot . values [ i ] ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 341 , 19 + 316 , 32 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> * The decaying buckets will be used for quantile calculations and mean values , but the non decaying buckets will be <nl> * exposed for calls to { @ link Snapshot # getValues ( ) } . <nl> * / <nl> - private class EstimatedHistogramReservoirSnapshot extends Snapshot <nl> + class EstimatedHistogramReservoirSnapshot extends Snapshot <nl> { <nl> private final long [ ] decayingBuckets ; <nl> + private final long [ ] values ; <nl> + private long count ; <nl> + private long snapshotLandmark ; <nl> + private long [ ] bucketOffsets ; <nl> + private DecayingEstimatedHistogramReservoir reservoir ; <nl> <nl> public EstimatedHistogramReservoirSnapshot ( DecayingEstimatedHistogramReservoir reservoir ) <nl> { <nl> - final int length = reservoir . decayingBuckets . length ( ) ; <nl> + final int length = reservoir . decayingBuckets . length ; <nl> final double rescaleFactor = forwardDecayWeight ( clock . getTime ( ) ) ; <nl> <nl> this . decayingBuckets = new long [ length ] ; <nl> + this . values = new long [ length ] ; <nl> + this . count = count ( ) ; <nl> + this . snapshotLandmark = decayLandmark ; <nl> + this . bucketOffsets = reservoir . bucketOffsets ; / / No need to copy , these are immutable <nl> <nl> for ( int i = 0 ; i < length ; i + + ) <nl> - this . decayingBuckets [ i ] = Math . round ( reservoir . decayingBuckets . get ( i ) / rescaleFactor ) ; <nl> + { <nl> + this . decayingBuckets [ i ] = Math . round ( reservoir . decayingBuckets [ i ] . sum ( ) / rescaleFactor ) ; <nl> + this . values [ i ] = buckets [ i ] . sum ( ) ; <nl> + } <nl> + this . reservoir = reservoir ; <nl> } <nl> <nl> / * * <nl> @ @ - 396 , 13 + 384 , 6 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> * / <nl> public long [ ] getValues ( ) <nl> { <nl> - final int length = buckets . length ( ) ; <nl> - <nl> - long [ ] values = new long [ length ] ; <nl> - <nl> - for ( int i = 0 ; i < length ; i + + ) <nl> - values [ i ] = buckets . get ( i ) ; <nl> - <nl> return values ; <nl> } <nl> <nl> @ @ - 418 , 6 + 399 , 12 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> return decayingBuckets . length ; <nl> } <nl> <nl> + @ VisibleForTesting <nl> + public long getSnapshotLandmark ( ) <nl> + { <nl> + return snapshotLandmark ; <nl> + } <nl> + <nl> / * * <nl> * Return the number of registered values taking forward decay into account . <nl> * <nl> @ @ - 547 , 5 + 534 , 68 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir <nl> } <nl> } <nl> } <nl> + <nl> + / * * <nl> + * Adds another DecayingEstimatedHistogramReservoir ' s Snapshot to this one . Both reservoirs must have same bucket definitions . This will rescale both snapshots if needed . <nl> + * <nl> + * @ param other EstimatedHistogramReservoirSnapshot with identical bucket definition ( offsets and length ) <nl> + * / <nl> + public void add ( Snapshot other ) <nl> + { <nl> + if ( ! ( other instanceof EstimatedHistogramReservoirSnapshot ) ) <nl> + { <nl> + throw new IllegalStateException ( " Unable to add other types of Snapshot than another DecayingEstimatedHistogramReservoir " ) ; <nl> + } <nl> + <nl> + EstimatedHistogramReservoirSnapshot snapshot = ( EstimatedHistogramReservoirSnapshot ) other ; <nl> + <nl> + if ( decayingBuckets . length ! = snapshot . decayingBuckets . length ) <nl> + { <nl> + throw new IllegalStateException ( " Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes " ) ; <nl> + } <nl> + <nl> + / / Check bucketOffsets <nl> + for ( int i = 0 ; i < bucketOffsets . length ; i + + ) <nl> + { <nl> + if ( bucketOffsets [ i ] ! = snapshot . bucketOffsets [ i ] ) <nl> + { <nl> + throw new IllegalStateException ( " Merge is only supported with equal bucketOffsets " ) ; <nl> + } <nl> + } <nl> + <nl> + / / We need to rescale the reservoirs to the same landmark <nl> + if ( snapshot . snapshotLandmark < snapshotLandmark ) <nl> + { <nl> + rescaleArray ( snapshot . decayingBuckets , ( snapshotLandmark - snapshot . snapshotLandmark ) ) ; <nl> + } <nl> + else if ( snapshot . snapshotLandmark > snapshotLandmark ) <nl> + { <nl> + rescaleArray ( decayingBuckets , ( snapshot . snapshotLandmark - snapshotLandmark ) ) ; <nl> + this . snapshotLandmark = snapshot . snapshotLandmark ; <nl> + } <nl> + <nl> + / / Now merge the buckets <nl> + for ( int i = 0 ; i < snapshot . decayingBuckets . length ; i + + ) <nl> + { <nl> + decayingBuckets [ i ] + = snapshot . decayingBuckets [ i ] ; <nl> + values [ i ] + = snapshot . values [ i ] ; <nl> + } <nl> + <nl> + this . count + = snapshot . count ; <nl> + } <nl> + <nl> + private void rescaleArray ( long [ ] decayingBuckets , long landMarkDifference ) <nl> + { <nl> + final double rescaleFactor = Math . exp ( ( landMarkDifference / 1000 . 0 ) / MEAN _ LIFETIME _ IN _ S ) ; <nl> + for ( int i = 0 ; i < decayingBuckets . length ; i + + ) <nl> + { <nl> + decayingBuckets [ i ] = Math . round ( decayingBuckets [ i ] / rescaleFactor ) ; <nl> + } <nl> + } <nl> + <nl> + public void rebaseReservoir ( ) <nl> + { <nl> + this . reservoir . rebase ( this ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / metrics / LatencyMetrics . java b / src / java / org / apache / cassandra / metrics / LatencyMetrics . java <nl> index a1915b1 . . 7d5d288 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / LatencyMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / LatencyMetrics . java <nl> @ @ - 17 , 15 + 17 , 17 @ @ <nl> * / <nl> package org . apache . cassandra . metrics ; <nl> <nl> + import java . util . Arrays ; <nl> import java . util . List ; <nl> import java . util . concurrent . TimeUnit ; <nl> <nl> + import com . google . common . collect . Lists ; <nl> + <nl> import com . codahale . metrics . Counter ; <nl> + import com . codahale . metrics . Reservoir ; <nl> + import com . codahale . metrics . Snapshot ; <nl> import com . codahale . metrics . Timer ; <nl> <nl> - import com . google . common . collect . ImmutableList ; <nl> - import com . google . common . collect . Lists ; <nl> - <nl> import static org . apache . cassandra . metrics . CassandraMetricsRegistry . Metrics ; <nl> <nl> <nl> @ @ - 41 , 7 + 43 , 8 @ @ public class LatencyMetrics <nl> <nl> / * * parent metrics to replicate any updates to * * / <nl> private List < LatencyMetrics > parents = Lists . newArrayList ( ) ; <nl> - <nl> + private List < LatencyMetrics > children = Lists . newArrayList ( ) ; <nl> + <nl> protected final MetricNameFactory factory ; <nl> protected final MetricNameFactory aliasFactory ; <nl> protected final String namePrefix ; <nl> @ @ - 86 , 15 + 89 , 18 @ @ public class LatencyMetrics <nl> this . aliasFactory = aliasFactory ; <nl> this . namePrefix = namePrefix ; <nl> <nl> + Timer timer = new LatencyMetrics . LatencyMetricsTimer ( new DecayingEstimatedHistogramReservoir ( ) ) ; <nl> + Counter counter = new LatencyMetricsCounter ( ) ; <nl> + <nl> if ( aliasFactory = = null ) <nl> { <nl> - latency = Metrics . timer ( factory . createMetricName ( namePrefix + " Latency " ) ) ; <nl> - totalLatency = Metrics . counter ( factory . createMetricName ( namePrefix + " TotalLatency " ) ) ; <nl> + latency = Metrics . register ( factory . createMetricName ( namePrefix + " Latency " ) , timer ) ; <nl> + totalLatency = Metrics . register ( factory . createMetricName ( namePrefix + " TotalLatency " ) , counter ) ; <nl> } <nl> else <nl> { <nl> - latency = Metrics . timer ( factory . createMetricName ( namePrefix + " Latency " ) , aliasFactory . createMetricName ( namePrefix + " Latency " ) ) ; <nl> - totalLatency = Metrics . counter ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) ) ; <nl> + latency = Metrics . register ( factory . createMetricName ( namePrefix + " Latency " ) , aliasFactory . createMetricName ( namePrefix + " Latency " ) , timer ) ; <nl> + totalLatency = Metrics . register ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) , counter ) ; <nl> } <nl> } <nl> <nl> @ @ - 109 , 7 + 115 , 38 @ @ public class LatencyMetrics <nl> public LatencyMetrics ( MetricNameFactory factory , String namePrefix , LatencyMetrics . . . parents ) <nl> { <nl> this ( factory , null , namePrefix ) ; <nl> - this . parents . addAll ( ImmutableList . copyOf ( parents ) ) ; <nl> + this . parents = Arrays . asList ( parents ) ; <nl> + for ( LatencyMetrics parent : parents ) <nl> + { <nl> + parent . addChildren ( this ) ; <nl> + } <nl> + } <nl> + <nl> + public void addChildren ( LatencyMetrics latencyMetric ) <nl> + { <nl> + this . children . add ( latencyMetric ) ; <nl> + } <nl> + <nl> + public synchronized void removeChildren ( LatencyMetrics toRelease ) <nl> + { <nl> + / * <nl> + Merge details of removed children metrics and add them to our local copy to prevent metrics from going <nl> + backwards . Synchronized since these methods are not thread safe to prevent multiple simultaneous removals . <nl> + Will not protect against simultaneous updates , but since these methods are used by linked parent instances only , <nl> + they should not receive any updates . <nl> + * / <nl> + ( ( LatencyMetricsTimer ) this . latency ) . releasedLatencyCount + = toRelease . latency . getCount ( ) ; <nl> + <nl> + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot childSnapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) toRelease . latency . getSnapshot ( ) ; <nl> + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot snapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) this . latency . getSnapshot ( ) ; <nl> + <nl> + snapshot . add ( childSnapshot ) ; <nl> + snapshot . rebaseReservoir ( ) ; <nl> + <nl> + this . totalLatency . inc ( toRelease . totalLatency . getCount ( ) ) ; <nl> + <nl> + / / Now we can remove the reference <nl> + this . children . removeIf ( latencyMetrics - > latencyMetrics . equals ( toRelease ) ) ; <nl> } <nl> <nl> / * * takes nanoseconds * * / <nl> @ @ - 118 , 14 + 155 , 15 @ @ public class LatencyMetrics <nl> / / convert to microseconds . 1 millionth <nl> latency . update ( nanos , TimeUnit . NANOSECONDS ) ; <nl> totalLatency . inc ( nanos / 1000 ) ; <nl> - for ( LatencyMetrics parent : parents ) <nl> - { <nl> - parent . addNano ( nanos ) ; <nl> - } <nl> } <nl> <nl> public void release ( ) <nl> { <nl> + / / Notify parent metrics that this metric is being released <nl> + for ( LatencyMetrics parent : this . parents ) <nl> + { <nl> + parent . removeChildren ( this ) ; <nl> + } <nl> if ( aliasFactory = = null ) <nl> { <nl> Metrics . remove ( factory . createMetricName ( namePrefix + " Latency " ) ) ; <nl> @ @ - 137 , 4 + 175 , 98 @ @ public class LatencyMetrics <nl> Metrics . remove ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) ) ; <nl> } <nl> } <nl> + <nl> + class LatencyMetricsTimer extends Timer <nl> + { <nl> + <nl> + long releasedLatencyCount = 0 ; <nl> + <nl> + public LatencyMetricsTimer ( Reservoir reservoir ) <nl> + { <nl> + super ( reservoir ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public long getCount ( ) <nl> + { <nl> + long count = super . getCount ( ) + releasedLatencyCount ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + count + = child . latency . getCount ( ) ; <nl> + } <nl> + <nl> + return count ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getFifteenMinuteRate ( ) <nl> + { <nl> + double rate = super . getFifteenMinuteRate ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + rate + = child . latency . getFifteenMinuteRate ( ) ; <nl> + } <nl> + return rate ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getFiveMinuteRate ( ) <nl> + { <nl> + double rate = super . getFiveMinuteRate ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + rate + = child . latency . getFiveMinuteRate ( ) ; <nl> + } <nl> + return rate ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getMeanRate ( ) <nl> + { <nl> + / / Not necessarily 100 % accurate , but close enough <nl> + double rate = super . getMeanRate ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + rate + = child . latency . getMeanRate ( ) ; <nl> + } <nl> + return rate ; <nl> + } <nl> + <nl> + @ Override <nl> + public double getOneMinuteRate ( ) <nl> + { <nl> + double rate = super . getOneMinuteRate ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + rate + = child . latency . getOneMinuteRate ( ) ; <nl> + } <nl> + return rate ; <nl> + } <nl> + <nl> + @ Override <nl> + public Snapshot getSnapshot ( ) <nl> + { <nl> + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot parent = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) super . getSnapshot ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + parent . add ( child . latency . getSnapshot ( ) ) ; <nl> + } <nl> + <nl> + return parent ; <nl> + } <nl> + } <nl> + <nl> + class LatencyMetricsCounter extends Counter <nl> + { <nl> + @ Override <nl> + public long getCount ( ) <nl> + { <nl> + long count = super . getCount ( ) ; <nl> + for ( LatencyMetrics child : children ) <nl> + { <nl> + count + = child . totalLatency . getCount ( ) ; <nl> + } <nl> + return count ; <nl> + } <nl> + } <nl> } <nl> diff - - git a / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java b / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java <nl> new file mode 100644 <nl> index 0000000 . . 28e0da7 <nl> - - - / dev / null <nl> + + + b / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java <nl> @ @ - 0 , 0 + 1 , 118 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . test . microbench ; <nl> + <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . codahale . metrics . Histogram ; <nl> + import com . codahale . metrics . Timer ; <nl> + import org . apache . cassandra . metrics . CassandraMetricsRegistry ; <nl> + import org . apache . cassandra . metrics . ClearableHistogram ; <nl> + import org . apache . cassandra . metrics . DecayingEstimatedHistogramReservoir ; <nl> + import org . apache . cassandra . metrics . LatencyMetrics ; <nl> + import org . apache . cassandra . metrics . LatencyMetricsTest ; <nl> + import org . apache . cassandra . metrics . MetricNameFactory ; <nl> + import org . apache . cassandra . metrics . TableMetrics ; <nl> + import org . openjdk . jmh . annotations . Benchmark ; <nl> + import org . openjdk . jmh . annotations . BenchmarkMode ; <nl> + import org . openjdk . jmh . annotations . CompilerControl ; <nl> + import org . openjdk . jmh . annotations . Fork ; <nl> + import org . openjdk . jmh . annotations . Level ; <nl> + import org . openjdk . jmh . annotations . Measurement ; <nl> + import org . openjdk . jmh . annotations . Mode ; <nl> + import org . openjdk . jmh . annotations . OperationsPerInvocation ; <nl> + import org . openjdk . jmh . annotations . OutputTimeUnit ; <nl> + import org . openjdk . jmh . annotations . Scope ; <nl> + import org . openjdk . jmh . annotations . Setup ; <nl> + import org . openjdk . jmh . annotations . State ; <nl> + import org . openjdk . jmh . annotations . TearDown ; <nl> + import org . openjdk . jmh . annotations . Threads ; <nl> + import org . openjdk . jmh . annotations . Warmup ; <nl> + import org . openjdk . jmh . infra . Blackhole ; <nl> + <nl> + @ BenchmarkMode ( Mode . Throughput ) <nl> + @ OutputTimeUnit ( TimeUnit . SECONDS ) <nl> + @ Warmup ( iterations = 3 , time = 1 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Measurement ( iterations = 5 , time = 2 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Fork ( value = 1 , jvmArgsAppend = { " - Xmx512M " , " - Djmh . executor = CUSTOM " , " - Djmh . executor . class = org . apache . cassandra . test . microbench . FastThreadExecutor " } ) <nl> + @ Threads ( 4 ) / / make sure this matches the number of _ physical _ cores _ <nl> + @ State ( Scope . Benchmark ) <nl> + public class LatencyTrackingBench <nl> + { <nl> + private LatencyMetrics metrics ; <nl> + private LatencyMetrics parent ; <nl> + private LatencyMetrics grandParent ; <nl> + private DecayingEstimatedHistogramReservoir dehr ; <nl> + private final MetricNameFactory factory = new BenchMetricsNameFactory ( ) ; <nl> + private long [ ] values = new long [ 1024 ] ; <nl> + <nl> + class BenchMetricsNameFactory implements MetricNameFactory <nl> + { <nl> + <nl> + @ Override <nl> + public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) <nl> + { <nl> + return new CassandraMetricsRegistry . MetricName ( BenchMetricsNameFactory . class , metricName ) ; <nl> + } <nl> + } <nl> + <nl> + @ Setup ( Level . Iteration ) <nl> + public void setup ( ) <nl> + { <nl> + parent = new LatencyMetrics ( " test " , " testCF " ) ; <nl> + grandParent = new LatencyMetrics ( " test " , " testCF " ) ; <nl> + <nl> + / / Replicates behavior from ColumnFamilyStore metrics <nl> + metrics = new LatencyMetrics ( factory , " testCF " , parent , grandParent ) ; <nl> + dehr = new DecayingEstimatedHistogramReservoir ( false ) ; <nl> + for ( int i = 0 ; i < 1024 ; i + + ) <nl> + { <nl> + values [ i ] = TimeUnit . MICROSECONDS . toNanos ( ThreadLocalRandom . current ( ) . nextLong ( 346 ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Setup ( Level . Invocation ) <nl> + public void reset ( ) <nl> + { <nl> + dehr = new DecayingEstimatedHistogramReservoir ( false ) ; <nl> + metrics . release ( ) ; <nl> + metrics = new LatencyMetrics ( factory , " testCF " , parent , grandParent ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + @ OperationsPerInvocation ( 1024 ) <nl> + public void benchLatencyMetricsWrite ( ) <nl> + { <nl> + for ( int i = 0 ; i < values . length ; i + + ) <nl> + { <nl> + metrics . addNano ( values [ i ] ) ; <nl> + } <nl> + } <nl> + <nl> + @ Benchmark <nl> + @ OperationsPerInvocation ( 1024 ) <nl> + public void benchInsertToDEHR ( Blackhole bh ) <nl> + { <nl> + for ( int i = 0 ; i < values . length ; i + + ) <nl> + { <nl> + dehr . update ( values [ i ] ) ; <nl> + } <nl> + bh . consume ( dehr ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java b / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java <nl> index ef1fed3 . . 5cfd927 100644 <nl> - - - a / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java <nl> + + + b / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java <nl> @ @ - 380 , 6 + 380 , 41 @ @ public class DecayingEstimatedHistogramReservoirTest <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testAggregation ( ) <nl> + { <nl> + TestClock clock = new TestClock ( ) ; <nl> + <nl> + DecayingEstimatedHistogramReservoir histogram = new DecayingEstimatedHistogramReservoir ( DecayingEstimatedHistogramReservoir . DEFAULT _ ZERO _ CONSIDERATION , DecayingEstimatedHistogramReservoir . DEFAULT _ BUCKET _ COUNT , clock ) ; <nl> + DecayingEstimatedHistogramReservoir another = new DecayingEstimatedHistogramReservoir ( DecayingEstimatedHistogramReservoir . DEFAULT _ ZERO _ CONSIDERATION , DecayingEstimatedHistogramReservoir . DEFAULT _ BUCKET _ COUNT , clock ) ; <nl> + <nl> + clock . addMillis ( DecayingEstimatedHistogramReservoir . LANDMARK _ RESET _ INTERVAL _ IN _ MS - 1 _ 000L ) ; <nl> + <nl> + histogram . update ( 1000 ) ; <nl> + clock . addMillis ( 100 ) ; <nl> + another . update ( 2000 ) ; <nl> + clock . addMillis ( 100 ) ; <nl> + histogram . update ( 2000 ) ; <nl> + clock . addMillis ( 100 ) ; <nl> + another . update ( 3000 ) ; <nl> + clock . addMillis ( 100 ) ; <nl> + histogram . update ( 3000 ) ; <nl> + clock . addMillis ( 100 ) ; <nl> + another . update ( 4000 ) ; <nl> + <nl> + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot snapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) histogram . getSnapshot ( ) ; <nl> + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot anotherSnapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) another . getSnapshot ( ) ; <nl> + <nl> + assertEquals ( 2000 , snapshot . getMean ( ) , 500D ) ; <nl> + assertEquals ( 3000 , anotherSnapshot . getMean ( ) , 500D ) ; <nl> + <nl> + snapshot . add ( anotherSnapshot ) ; <nl> + <nl> + / / Another had newer decayLandmark , the aggregated snapshot should use it <nl> + assertEquals ( anotherSnapshot . getSnapshotLandmark ( ) , snapshot . getSnapshotLandmark ( ) ) ; <nl> + assertEquals ( 2500 , snapshot . getMean ( ) , 500D ) ; <nl> + } <nl> + <nl> private void assertEstimatedQuantile ( long expectedValue , double actualValue ) <nl> { <nl> assertTrue ( " Expected at least [ " + expectedValue + " ] but actual is [ " + actualValue + " ] " , actualValue > = expectedValue ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java b / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java <nl> index 62cb88e . . d61c550 100644 <nl> - - - a / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java <nl> + + + b / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java <nl> @ @ - 18 , 12 + 18 , 27 @ @ <nl> <nl> package org . apache . cassandra . metrics ; <nl> <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> import org . junit . Test ; <nl> <nl> + import static junit . framework . Assert . assertEquals ; <nl> import static junit . framework . Assert . assertFalse ; <nl> <nl> public class LatencyMetricsTest <nl> { <nl> + private final MetricNameFactory factory = new TestMetricsNameFactory ( ) ; <nl> + <nl> + private class TestMetricsNameFactory implements MetricNameFactory <nl> + { <nl> + <nl> + @ Override <nl> + public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) <nl> + { <nl> + return new CassandraMetricsRegistry . MetricName ( TestMetricsNameFactory . class , metricName ) ; <nl> + } <nl> + } <nl> + <nl> / * * <nl> * Test bitsets in a " real - world " environment , i . e . , bloom filters <nl> * / <nl> @ @ - 31 , 14 + 46 , 10 @ @ public class LatencyMetricsTest <nl> public void testGetRecentLatency ( ) <nl> { <nl> final LatencyMetrics l = new LatencyMetrics ( " test " , " test " ) ; <nl> - Runnable r = new Runnable ( ) <nl> - { <nl> - public void run ( ) <nl> + Runnable r = ( ) - > { <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> { <nl> - for ( int i = 0 ; i < 10000 ; i + + ) <nl> - { <nl> - l . addNano ( 1000 ) ; <nl> - } <nl> + l . addNano ( 1000 ) ; <nl> } <nl> } ; <nl> new Thread ( r ) . start ( ) ; <nl> @ @ - 49 , 4 + 60 , 49 @ @ public class LatencyMetricsTest <nl> assertFalse ( recent . equals ( Double . POSITIVE _ INFINITY ) ) ; <nl> } <nl> } <nl> + <nl> + / * * <nl> + * Test that parent LatencyMetrics are receiving updates from child metrics when reading <nl> + * / <nl> + @ Test <nl> + public void testReadMerging ( ) <nl> + { <nl> + final LatencyMetrics parent = new LatencyMetrics ( " testMerge " , " testMerge " ) ; <nl> + final LatencyMetrics child = new LatencyMetrics ( factory , " testChild " , parent ) ; <nl> + <nl> + for ( int i = 0 ; i < 100 ; i + + ) <nl> + { <nl> + child . addNano ( TimeUnit . NANOSECONDS . convert ( i , TimeUnit . MILLISECONDS ) ) ; <nl> + } <nl> + <nl> + assertEquals ( 4950000 , child . totalLatency . getCount ( ) ) ; <nl> + assertEquals ( child . totalLatency . getCount ( ) , parent . totalLatency . getCount ( ) ) ; <nl> + assertEquals ( child . latency . getSnapshot ( ) . getMean ( ) , parent . latency . getSnapshot ( ) . getMean ( ) , 50D ) ; <nl> + <nl> + child . release ( ) ; <nl> + parent . release ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRelease ( ) <nl> + { <nl> + final LatencyMetrics parent = new LatencyMetrics ( " testRelease " , " testRelease " ) ; <nl> + final LatencyMetrics child = new LatencyMetrics ( factory , " testChildRelease " , parent ) ; <nl> + <nl> + for ( int i = 0 ; i < 100 ; i + + ) <nl> + { <nl> + child . addNano ( TimeUnit . NANOSECONDS . convert ( i , TimeUnit . MILLISECONDS ) ) ; <nl> + } <nl> + <nl> + double mean = parent . latency . getSnapshot ( ) . getMean ( ) ; <nl> + long count = parent . totalLatency . getCount ( ) ; <nl> + <nl> + child . release ( ) ; <nl> + <nl> + / / Check that no value was lost with the release <nl> + assertEquals ( count , parent . totalLatency . getCount ( ) ) ; <nl> + assertEquals ( mean , parent . latency . getSnapshot ( ) . getMean ( ) , 50D ) ; <nl> + <nl> + parent . release ( ) ; <nl> + } <nl> } <nl> \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java b / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java <nl> index 6077e38 . . 84b91e9 100644 <nl> - - - a / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java <nl> @ @ - 62 , 7 + 62 , 7 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro <nl> return reply . rows ; <nl> } <nl> <nl> - / / Note : this deserializes the response a 2nd time if getData was called first <nl> + / / Note : this would deserialize the response a 2nd time if getData was called first . <nl> / / ( this is not currently an issue since we don ' t do read repair for range queries . ) <nl> public Iterable < Row > resolve ( ) throws IOException <nl> { <nl> @ @ - 73 , 7 + 73 , 7 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro <nl> return o1 . left . key . compareTo ( o2 . left . key ) ; <nl> } <nl> } ) ; <nl> - <nl> + <nl> int n = 0 ; <nl> for ( Message response : responses ) <nl> { <nl> @ @ - 83 , 7 + 83 , 6 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro <nl> } <nl> <nl> / / for each row , compute the combination of all different versions seen , and repair incomplete versions <nl> - <nl> return new ReducingIterator < Pair < Row , InetAddress > , Row > ( collator ) <nl> { <nl> List < ColumnFamily > versions = new ArrayList < ColumnFamily > ( sources . size ( ) ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 784fa2b . . fe03ae1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Improve LatencyMetrics performance by reducing write path processing ( CASSANDRA - 14281 ) 
 * Add network authz ( CASSANDRA - 13985 ) 
 * Use the correct IP / Port for Streaming when localAddress is left unbound ( CASSANDAR - 14389 ) 
 * nodetool listsnapshots is missing local system keyspace snapshots ( CASSANDRA - 14381 ) 
 diff - - git a / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java b / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java 
 index 118f062 . . f17de78 100644 
 - - - a / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java 
 + + + b / src / java / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoir . java 
 @ @ - 24 , 8 + 24 , 7 @ @ import java . io . PrintWriter ; 
 import java . nio . charset . StandardCharsets ; 
 import java . util . Arrays ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 - import java . util . concurrent . atomic . AtomicLongArray ; 
 - import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 + import java . util . concurrent . atomic . LongAdder ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 
 @ @ - 85 , 8 + 84 , 8 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 private final long [ ] bucketOffsets ; 
 
 / / decayingBuckets and buckets are one element longer than bucketOffsets - - the last element is values greater than the last offset 
 - private final AtomicLongArray decayingBuckets ; 
 - private final AtomicLongArray buckets ; 
 + private final LongAdder [ ] decayingBuckets ; 
 + private final LongAdder [ ] buckets ; 
 
 public static final long HALF _ TIME _ IN _ S = 60L ; 
 public static final double MEAN _ LIFETIME _ IN _ S = HALF _ TIME _ IN _ S / Math . log ( 2 . 0 ) ; 
 @ @ - 95 , 8 + 94 , 6 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 private final AtomicBoolean rescaling = new AtomicBoolean ( false ) ; 
 private volatile long decayLandmark ; 
 
 - private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock ( ) ; 
 - 
 / / Wrapper around System . nanoTime ( ) to simplify unit testing . 
 private final Clock clock ; 
 
 @ @ - 150 , 8 + 147 , 15 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 { 
 bucketOffsets = EstimatedHistogram . newOffsets ( bucketCount , considerZeroes ) ; 
 } 
 - decayingBuckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; 
 - buckets = new AtomicLongArray ( bucketOffsets . length + 1 ) ; 
 + decayingBuckets = new LongAdder [ bucketOffsets . length + 1 ] ; 
 + buckets = new LongAdder [ bucketOffsets . length + 1 ] ; 
 + 
 + for ( int i = 0 ; i < buckets . length ; i + + ) 
 + { 
 + decayingBuckets [ i ] = new LongAdder ( ) ; 
 + buckets [ i ] = new LongAdder ( ) ; 
 + } 
 + 
 this . clock = clock ; 
 decayLandmark = clock . getTime ( ) ; 
 } 
 @ @ - 174 , 18 + 178 , 8 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 } 
 / / else exact match ; we ' re good 
 
 - lockForRegularUsage ( ) ; 
 - 
 - try 
 - { 
 - decayingBuckets . getAndAdd ( index , Math . round ( forwardDecayWeight ( now ) ) ) ; 
 - } 
 - finally 
 - { 
 - unlockForRegularUsage ( ) ; 
 - } 
 - 
 - buckets . getAndIncrement ( index ) ; 
 + decayingBuckets [ index ] . add ( Math . round ( forwardDecayWeight ( now ) ) ) ; 
 + buckets [ index ] . increment ( ) ; 
 } 
 
 private double forwardDecayWeight ( long now ) 
 @ @ - 202 , 7 + 196 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 * / 
 public int size ( ) 
 { 
 - return decayingBuckets . length ( ) ; 
 + return decayingBuckets . length ; 
 } 
 
 / * * 
 @ @ - 215 , 17 + 209 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 public Snapshot getSnapshot ( ) 
 { 
 rescaleIfNeeded ( ) ; 
 - 
 - lockForRegularUsage ( ) ; 
 - 
 - try 
 - { 
 - return new EstimatedHistogramReservoirSnapshot ( this ) ; 
 - } 
 - finally 
 - { 
 - unlockForRegularUsage ( ) ; 
 - } 
 + return new EstimatedHistogramReservoirSnapshot ( this ) ; 
 } 
 
 / * * 
 @ @ - 234 , 7 + 218 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 @ VisibleForTesting 
 boolean isOverflowed ( ) 
 { 
 - return decayingBuckets . get ( decayingBuckets . length ( ) - 1 ) > 0 ; 
 + return decayingBuckets [ decayingBuckets . length - 1 ] . sum ( ) > 0 ; 
 } 
 
 private void rescaleIfNeeded ( ) 
 @ @ - 254 , 6 + 238 , 7 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 } 
 finally 
 { 
 + decayLandmark = now ; 
 rescaling . set ( false ) ; 
 } 
 } 
 @ @ - 262 , 27 + 247 , 14 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 
 private void rescale ( long now ) 
 { 
 - / / Check again to make sure that another thread didn ' t complete rescale already 
 - if ( needRescale ( now ) ) 
 - { 
 - lockForRescale ( ) ; 
 - 
 - try 
 - { 
 - final double rescaleFactor = forwardDecayWeight ( now ) ; 
 - decayLandmark = now ; 
 + final double rescaleFactor = forwardDecayWeight ( now ) ; 
 
 - final int bucketCount = decayingBuckets . length ( ) ; 
 - for ( int i = 0 ; i < bucketCount ; i + + ) 
 - { 
 - long newValue = Math . round ( ( decayingBuckets . get ( i ) / rescaleFactor ) ) ; 
 - decayingBuckets . set ( i , newValue ) ; 
 - } 
 - } 
 - finally 
 - { 
 - unlockForRescale ( ) ; 
 - } 
 + final int bucketCount = decayingBuckets . length ; 
 + for ( int i = 0 ; i < bucketCount ; i + + ) 
 + { 
 + long storedValue = decayingBuckets [ i ] . sumThenReset ( ) ; 
 + storedValue = Math . round ( storedValue / rescaleFactor ) ; 
 + decayingBuckets [ i ] . add ( storedValue ) ; 
 } 
 } 
 
 @ @ - 294 , 41 + 266 , 44 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 @ VisibleForTesting 
 public void clear ( ) 
 { 
 - lockForRescale ( ) ; 
 - 
 - try 
 - { 
 - final int bucketCount = decayingBuckets . length ( ) ; 
 - for ( int i = 0 ; i < bucketCount ; i + + ) 
 - { 
 - decayingBuckets . set ( i , 0L ) ; 
 - buckets . set ( i , 0L ) ; 
 - } 
 - } 
 - finally 
 + final int bucketCount = decayingBuckets . length ; 
 + for ( int i = 0 ; i < bucketCount ; i + + ) 
 { 
 - unlockForRescale ( ) ; 
 + decayingBuckets [ i ] . reset ( ) ; 
 + buckets [ i ] . reset ( ) ; 
 } 
 } 
 
 - private void lockForRegularUsage ( ) 
 + / * * 
 + * Replaces current internal values with the given one from a Snapshot . This method is NOT thread safe , values 
 + * added at the same time to this reservoir using methods such as update may lose their data 
 + * / 
 + public void rebase ( EstimatedHistogramReservoirSnapshot snapshot ) 
 { 
 - this . lock . readLock ( ) . lock ( ) ; 
 - } 
 + / / Check bucket count 
 + if ( decayingBuckets . length ! = snapshot . decayingBuckets . length ) 
 + { 
 + throw new IllegalStateException ( " Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes " ) ; 
 + } 
 
 - private void unlockForRegularUsage ( ) 
 - { 
 - this . lock . readLock ( ) . unlock ( ) ; 
 - } 
 + / / Check bucketOffsets 
 + for ( int i = 0 ; i < bucketOffsets . length ; i + + ) 
 + { 
 + if ( bucketOffsets [ i ] ! = snapshot . bucketOffsets [ i ] ) 
 + { 
 + throw new IllegalStateException ( " Merge is only supported with equal bucketOffsets " ) ; 
 + } 
 + } 
 
 - private void lockForRescale ( ) 
 - { 
 - this . lock . writeLock ( ) . lock ( ) ; 
 - } 
 + this . decayLandmark = snapshot . snapshotLandmark ; 
 + for ( int i = 0 ; i < decayingBuckets . length ; i + + ) 
 + { 
 + decayingBuckets [ i ] . reset ( ) ; 
 + buckets [ i ] . reset ( ) ; 
 
 - private void unlockForRescale ( ) 
 - { 
 - this . lock . writeLock ( ) . unlock ( ) ; 
 + decayingBuckets [ i ] . add ( snapshot . decayingBuckets [ i ] ) ; 
 + buckets [ i ] . add ( snapshot . values [ i ] ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 341 , 19 + 316 , 32 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 * The decaying buckets will be used for quantile calculations and mean values , but the non decaying buckets will be 
 * exposed for calls to { @ link Snapshot # getValues ( ) } . 
 * / 
 - private class EstimatedHistogramReservoirSnapshot extends Snapshot 
 + class EstimatedHistogramReservoirSnapshot extends Snapshot 
 { 
 private final long [ ] decayingBuckets ; 
 + private final long [ ] values ; 
 + private long count ; 
 + private long snapshotLandmark ; 
 + private long [ ] bucketOffsets ; 
 + private DecayingEstimatedHistogramReservoir reservoir ; 
 
 public EstimatedHistogramReservoirSnapshot ( DecayingEstimatedHistogramReservoir reservoir ) 
 { 
 - final int length = reservoir . decayingBuckets . length ( ) ; 
 + final int length = reservoir . decayingBuckets . length ; 
 final double rescaleFactor = forwardDecayWeight ( clock . getTime ( ) ) ; 
 
 this . decayingBuckets = new long [ length ] ; 
 + this . values = new long [ length ] ; 
 + this . count = count ( ) ; 
 + this . snapshotLandmark = decayLandmark ; 
 + this . bucketOffsets = reservoir . bucketOffsets ; / / No need to copy , these are immutable 
 
 for ( int i = 0 ; i < length ; i + + ) 
 - this . decayingBuckets [ i ] = Math . round ( reservoir . decayingBuckets . get ( i ) / rescaleFactor ) ; 
 + { 
 + this . decayingBuckets [ i ] = Math . round ( reservoir . decayingBuckets [ i ] . sum ( ) / rescaleFactor ) ; 
 + this . values [ i ] = buckets [ i ] . sum ( ) ; 
 + } 
 + this . reservoir = reservoir ; 
 } 
 
 / * * 
 @ @ - 396 , 13 + 384 , 6 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 * / 
 public long [ ] getValues ( ) 
 { 
 - final int length = buckets . length ( ) ; 
 - 
 - long [ ] values = new long [ length ] ; 
 - 
 - for ( int i = 0 ; i < length ; i + + ) 
 - values [ i ] = buckets . get ( i ) ; 
 - 
 return values ; 
 } 
 
 @ @ - 418 , 6 + 399 , 12 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 return decayingBuckets . length ; 
 } 
 
 + @ VisibleForTesting 
 + public long getSnapshotLandmark ( ) 
 + { 
 + return snapshotLandmark ; 
 + } 
 + 
 / * * 
 * Return the number of registered values taking forward decay into account . 
 * 
 @ @ - 547 , 5 + 534 , 68 @ @ public class DecayingEstimatedHistogramReservoir implements Reservoir 
 } 
 } 
 } 
 + 
 + / * * 
 + * Adds another DecayingEstimatedHistogramReservoir ' s Snapshot to this one . Both reservoirs must have same bucket definitions . This will rescale both snapshots if needed . 
 + * 
 + * @ param other EstimatedHistogramReservoirSnapshot with identical bucket definition ( offsets and length ) 
 + * / 
 + public void add ( Snapshot other ) 
 + { 
 + if ( ! ( other instanceof EstimatedHistogramReservoirSnapshot ) ) 
 + { 
 + throw new IllegalStateException ( " Unable to add other types of Snapshot than another DecayingEstimatedHistogramReservoir " ) ; 
 + } 
 + 
 + EstimatedHistogramReservoirSnapshot snapshot = ( EstimatedHistogramReservoirSnapshot ) other ; 
 + 
 + if ( decayingBuckets . length ! = snapshot . decayingBuckets . length ) 
 + { 
 + throw new IllegalStateException ( " Unable to merge two DecayingEstimatedHistogramReservoirs with different bucket sizes " ) ; 
 + } 
 + 
 + / / Check bucketOffsets 
 + for ( int i = 0 ; i < bucketOffsets . length ; i + + ) 
 + { 
 + if ( bucketOffsets [ i ] ! = snapshot . bucketOffsets [ i ] ) 
 + { 
 + throw new IllegalStateException ( " Merge is only supported with equal bucketOffsets " ) ; 
 + } 
 + } 
 + 
 + / / We need to rescale the reservoirs to the same landmark 
 + if ( snapshot . snapshotLandmark < snapshotLandmark ) 
 + { 
 + rescaleArray ( snapshot . decayingBuckets , ( snapshotLandmark - snapshot . snapshotLandmark ) ) ; 
 + } 
 + else if ( snapshot . snapshotLandmark > snapshotLandmark ) 
 + { 
 + rescaleArray ( decayingBuckets , ( snapshot . snapshotLandmark - snapshotLandmark ) ) ; 
 + this . snapshotLandmark = snapshot . snapshotLandmark ; 
 + } 
 + 
 + / / Now merge the buckets 
 + for ( int i = 0 ; i < snapshot . decayingBuckets . length ; i + + ) 
 + { 
 + decayingBuckets [ i ] + = snapshot . decayingBuckets [ i ] ; 
 + values [ i ] + = snapshot . values [ i ] ; 
 + } 
 + 
 + this . count + = snapshot . count ; 
 + } 
 + 
 + private void rescaleArray ( long [ ] decayingBuckets , long landMarkDifference ) 
 + { 
 + final double rescaleFactor = Math . exp ( ( landMarkDifference / 1000 . 0 ) / MEAN _ LIFETIME _ IN _ S ) ; 
 + for ( int i = 0 ; i < decayingBuckets . length ; i + + ) 
 + { 
 + decayingBuckets [ i ] = Math . round ( decayingBuckets [ i ] / rescaleFactor ) ; 
 + } 
 + } 
 + 
 + public void rebaseReservoir ( ) 
 + { 
 + this . reservoir . rebase ( this ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / metrics / LatencyMetrics . java b / src / java / org / apache / cassandra / metrics / LatencyMetrics . java 
 index a1915b1 . . 7d5d288 100644 
 - - - a / src / java / org / apache / cassandra / metrics / LatencyMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / LatencyMetrics . java 
 @ @ - 17 , 15 + 17 , 17 @ @ 
 * / 
 package org . apache . cassandra . metrics ; 
 
 + import java . util . Arrays ; 
 import java . util . List ; 
 import java . util . concurrent . TimeUnit ; 
 
 + import com . google . common . collect . Lists ; 
 + 
 import com . codahale . metrics . Counter ; 
 + import com . codahale . metrics . Reservoir ; 
 + import com . codahale . metrics . Snapshot ; 
 import com . codahale . metrics . Timer ; 
 
 - import com . google . common . collect . ImmutableList ; 
 - import com . google . common . collect . Lists ; 
 - 
 import static org . apache . cassandra . metrics . CassandraMetricsRegistry . Metrics ; 
 
 
 @ @ - 41 , 7 + 43 , 8 @ @ public class LatencyMetrics 
 
 / * * parent metrics to replicate any updates to * * / 
 private List < LatencyMetrics > parents = Lists . newArrayList ( ) ; 
 - 
 + private List < LatencyMetrics > children = Lists . newArrayList ( ) ; 
 + 
 protected final MetricNameFactory factory ; 
 protected final MetricNameFactory aliasFactory ; 
 protected final String namePrefix ; 
 @ @ - 86 , 15 + 89 , 18 @ @ public class LatencyMetrics 
 this . aliasFactory = aliasFactory ; 
 this . namePrefix = namePrefix ; 
 
 + Timer timer = new LatencyMetrics . LatencyMetricsTimer ( new DecayingEstimatedHistogramReservoir ( ) ) ; 
 + Counter counter = new LatencyMetricsCounter ( ) ; 
 + 
 if ( aliasFactory = = null ) 
 { 
 - latency = Metrics . timer ( factory . createMetricName ( namePrefix + " Latency " ) ) ; 
 - totalLatency = Metrics . counter ( factory . createMetricName ( namePrefix + " TotalLatency " ) ) ; 
 + latency = Metrics . register ( factory . createMetricName ( namePrefix + " Latency " ) , timer ) ; 
 + totalLatency = Metrics . register ( factory . createMetricName ( namePrefix + " TotalLatency " ) , counter ) ; 
 } 
 else 
 { 
 - latency = Metrics . timer ( factory . createMetricName ( namePrefix + " Latency " ) , aliasFactory . createMetricName ( namePrefix + " Latency " ) ) ; 
 - totalLatency = Metrics . counter ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) ) ; 
 + latency = Metrics . register ( factory . createMetricName ( namePrefix + " Latency " ) , aliasFactory . createMetricName ( namePrefix + " Latency " ) , timer ) ; 
 + totalLatency = Metrics . register ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) , counter ) ; 
 } 
 } 
 
 @ @ - 109 , 7 + 115 , 38 @ @ public class LatencyMetrics 
 public LatencyMetrics ( MetricNameFactory factory , String namePrefix , LatencyMetrics . . . parents ) 
 { 
 this ( factory , null , namePrefix ) ; 
 - this . parents . addAll ( ImmutableList . copyOf ( parents ) ) ; 
 + this . parents = Arrays . asList ( parents ) ; 
 + for ( LatencyMetrics parent : parents ) 
 + { 
 + parent . addChildren ( this ) ; 
 + } 
 + } 
 + 
 + public void addChildren ( LatencyMetrics latencyMetric ) 
 + { 
 + this . children . add ( latencyMetric ) ; 
 + } 
 + 
 + public synchronized void removeChildren ( LatencyMetrics toRelease ) 
 + { 
 + / * 
 + Merge details of removed children metrics and add them to our local copy to prevent metrics from going 
 + backwards . Synchronized since these methods are not thread safe to prevent multiple simultaneous removals . 
 + Will not protect against simultaneous updates , but since these methods are used by linked parent instances only , 
 + they should not receive any updates . 
 + * / 
 + ( ( LatencyMetricsTimer ) this . latency ) . releasedLatencyCount + = toRelease . latency . getCount ( ) ; 
 + 
 + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot childSnapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) toRelease . latency . getSnapshot ( ) ; 
 + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot snapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) this . latency . getSnapshot ( ) ; 
 + 
 + snapshot . add ( childSnapshot ) ; 
 + snapshot . rebaseReservoir ( ) ; 
 + 
 + this . totalLatency . inc ( toRelease . totalLatency . getCount ( ) ) ; 
 + 
 + / / Now we can remove the reference 
 + this . children . removeIf ( latencyMetrics - > latencyMetrics . equals ( toRelease ) ) ; 
 } 
 
 / * * takes nanoseconds * * / 
 @ @ - 118 , 14 + 155 , 15 @ @ public class LatencyMetrics 
 / / convert to microseconds . 1 millionth 
 latency . update ( nanos , TimeUnit . NANOSECONDS ) ; 
 totalLatency . inc ( nanos / 1000 ) ; 
 - for ( LatencyMetrics parent : parents ) 
 - { 
 - parent . addNano ( nanos ) ; 
 - } 
 } 
 
 public void release ( ) 
 { 
 + / / Notify parent metrics that this metric is being released 
 + for ( LatencyMetrics parent : this . parents ) 
 + { 
 + parent . removeChildren ( this ) ; 
 + } 
 if ( aliasFactory = = null ) 
 { 
 Metrics . remove ( factory . createMetricName ( namePrefix + " Latency " ) ) ; 
 @ @ - 137 , 4 + 175 , 98 @ @ public class LatencyMetrics 
 Metrics . remove ( factory . createMetricName ( namePrefix + " TotalLatency " ) , aliasFactory . createMetricName ( namePrefix + " TotalLatency " ) ) ; 
 } 
 } 
 + 
 + class LatencyMetricsTimer extends Timer 
 + { 
 + 
 + long releasedLatencyCount = 0 ; 
 + 
 + public LatencyMetricsTimer ( Reservoir reservoir ) 
 + { 
 + super ( reservoir ) ; 
 + } 
 + 
 + @ Override 
 + public long getCount ( ) 
 + { 
 + long count = super . getCount ( ) + releasedLatencyCount ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + count + = child . latency . getCount ( ) ; 
 + } 
 + 
 + return count ; 
 + } 
 + 
 + @ Override 
 + public double getFifteenMinuteRate ( ) 
 + { 
 + double rate = super . getFifteenMinuteRate ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + rate + = child . latency . getFifteenMinuteRate ( ) ; 
 + } 
 + return rate ; 
 + } 
 + 
 + @ Override 
 + public double getFiveMinuteRate ( ) 
 + { 
 + double rate = super . getFiveMinuteRate ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + rate + = child . latency . getFiveMinuteRate ( ) ; 
 + } 
 + return rate ; 
 + } 
 + 
 + @ Override 
 + public double getMeanRate ( ) 
 + { 
 + / / Not necessarily 100 % accurate , but close enough 
 + double rate = super . getMeanRate ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + rate + = child . latency . getMeanRate ( ) ; 
 + } 
 + return rate ; 
 + } 
 + 
 + @ Override 
 + public double getOneMinuteRate ( ) 
 + { 
 + double rate = super . getOneMinuteRate ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + rate + = child . latency . getOneMinuteRate ( ) ; 
 + } 
 + return rate ; 
 + } 
 + 
 + @ Override 
 + public Snapshot getSnapshot ( ) 
 + { 
 + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot parent = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) super . getSnapshot ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + parent . add ( child . latency . getSnapshot ( ) ) ; 
 + } 
 + 
 + return parent ; 
 + } 
 + } 
 + 
 + class LatencyMetricsCounter extends Counter 
 + { 
 + @ Override 
 + public long getCount ( ) 
 + { 
 + long count = super . getCount ( ) ; 
 + for ( LatencyMetrics child : children ) 
 + { 
 + count + = child . totalLatency . getCount ( ) ; 
 + } 
 + return count ; 
 + } 
 + } 
 } 
 diff - - git a / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java b / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java 
 new file mode 100644 
 index 0000000 . . 28e0da7 
 - - - / dev / null 
 + + + b / test / microbench / org / apache / cassandra / test / microbench / LatencyTrackingBench . java 
 @ @ - 0 , 0 + 1 , 118 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . test . microbench ; 
 + 
 + import java . util . concurrent . ThreadLocalRandom ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . codahale . metrics . Histogram ; 
 + import com . codahale . metrics . Timer ; 
 + import org . apache . cassandra . metrics . CassandraMetricsRegistry ; 
 + import org . apache . cassandra . metrics . ClearableHistogram ; 
 + import org . apache . cassandra . metrics . DecayingEstimatedHistogramReservoir ; 
 + import org . apache . cassandra . metrics . LatencyMetrics ; 
 + import org . apache . cassandra . metrics . LatencyMetricsTest ; 
 + import org . apache . cassandra . metrics . MetricNameFactory ; 
 + import org . apache . cassandra . metrics . TableMetrics ; 
 + import org . openjdk . jmh . annotations . Benchmark ; 
 + import org . openjdk . jmh . annotations . BenchmarkMode ; 
 + import org . openjdk . jmh . annotations . CompilerControl ; 
 + import org . openjdk . jmh . annotations . Fork ; 
 + import org . openjdk . jmh . annotations . Level ; 
 + import org . openjdk . jmh . annotations . Measurement ; 
 + import org . openjdk . jmh . annotations . Mode ; 
 + import org . openjdk . jmh . annotations . OperationsPerInvocation ; 
 + import org . openjdk . jmh . annotations . OutputTimeUnit ; 
 + import org . openjdk . jmh . annotations . Scope ; 
 + import org . openjdk . jmh . annotations . Setup ; 
 + import org . openjdk . jmh . annotations . State ; 
 + import org . openjdk . jmh . annotations . TearDown ; 
 + import org . openjdk . jmh . annotations . Threads ; 
 + import org . openjdk . jmh . annotations . Warmup ; 
 + import org . openjdk . jmh . infra . Blackhole ; 
 + 
 + @ BenchmarkMode ( Mode . Throughput ) 
 + @ OutputTimeUnit ( TimeUnit . SECONDS ) 
 + @ Warmup ( iterations = 3 , time = 1 , timeUnit = TimeUnit . SECONDS ) 
 + @ Measurement ( iterations = 5 , time = 2 , timeUnit = TimeUnit . SECONDS ) 
 + @ Fork ( value = 1 , jvmArgsAppend = { " - Xmx512M " , " - Djmh . executor = CUSTOM " , " - Djmh . executor . class = org . apache . cassandra . test . microbench . FastThreadExecutor " } ) 
 + @ Threads ( 4 ) / / make sure this matches the number of _ physical _ cores _ 
 + @ State ( Scope . Benchmark ) 
 + public class LatencyTrackingBench 
 + { 
 + private LatencyMetrics metrics ; 
 + private LatencyMetrics parent ; 
 + private LatencyMetrics grandParent ; 
 + private DecayingEstimatedHistogramReservoir dehr ; 
 + private final MetricNameFactory factory = new BenchMetricsNameFactory ( ) ; 
 + private long [ ] values = new long [ 1024 ] ; 
 + 
 + class BenchMetricsNameFactory implements MetricNameFactory 
 + { 
 + 
 + @ Override 
 + public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) 
 + { 
 + return new CassandraMetricsRegistry . MetricName ( BenchMetricsNameFactory . class , metricName ) ; 
 + } 
 + } 
 + 
 + @ Setup ( Level . Iteration ) 
 + public void setup ( ) 
 + { 
 + parent = new LatencyMetrics ( " test " , " testCF " ) ; 
 + grandParent = new LatencyMetrics ( " test " , " testCF " ) ; 
 + 
 + / / Replicates behavior from ColumnFamilyStore metrics 
 + metrics = new LatencyMetrics ( factory , " testCF " , parent , grandParent ) ; 
 + dehr = new DecayingEstimatedHistogramReservoir ( false ) ; 
 + for ( int i = 0 ; i < 1024 ; i + + ) 
 + { 
 + values [ i ] = TimeUnit . MICROSECONDS . toNanos ( ThreadLocalRandom . current ( ) . nextLong ( 346 ) ) ; 
 + } 
 + } 
 + 
 + @ Setup ( Level . Invocation ) 
 + public void reset ( ) 
 + { 
 + dehr = new DecayingEstimatedHistogramReservoir ( false ) ; 
 + metrics . release ( ) ; 
 + metrics = new LatencyMetrics ( factory , " testCF " , parent , grandParent ) ; 
 + } 
 + 
 + @ Benchmark 
 + @ OperationsPerInvocation ( 1024 ) 
 + public void benchLatencyMetricsWrite ( ) 
 + { 
 + for ( int i = 0 ; i < values . length ; i + + ) 
 + { 
 + metrics . addNano ( values [ i ] ) ; 
 + } 
 + } 
 + 
 + @ Benchmark 
 + @ OperationsPerInvocation ( 1024 ) 
 + public void benchInsertToDEHR ( Blackhole bh ) 
 + { 
 + for ( int i = 0 ; i < values . length ; i + + ) 
 + { 
 + dehr . update ( values [ i ] ) ; 
 + } 
 + bh . consume ( dehr ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java b / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java 
 index ef1fed3 . . 5cfd927 100644 
 - - - a / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java 
 + + + b / test / unit / org / apache / cassandra / metrics / DecayingEstimatedHistogramReservoirTest . java 
 @ @ - 380 , 6 + 380 , 41 @ @ public class DecayingEstimatedHistogramReservoirTest 
 } 
 } 
 
 + @ Test 
 + public void testAggregation ( ) 
 + { 
 + TestClock clock = new TestClock ( ) ; 
 + 
 + DecayingEstimatedHistogramReservoir histogram = new DecayingEstimatedHistogramReservoir ( DecayingEstimatedHistogramReservoir . DEFAULT _ ZERO _ CONSIDERATION , DecayingEstimatedHistogramReservoir . DEFAULT _ BUCKET _ COUNT , clock ) ; 
 + DecayingEstimatedHistogramReservoir another = new DecayingEstimatedHistogramReservoir ( DecayingEstimatedHistogramReservoir . DEFAULT _ ZERO _ CONSIDERATION , DecayingEstimatedHistogramReservoir . DEFAULT _ BUCKET _ COUNT , clock ) ; 
 + 
 + clock . addMillis ( DecayingEstimatedHistogramReservoir . LANDMARK _ RESET _ INTERVAL _ IN _ MS - 1 _ 000L ) ; 
 + 
 + histogram . update ( 1000 ) ; 
 + clock . addMillis ( 100 ) ; 
 + another . update ( 2000 ) ; 
 + clock . addMillis ( 100 ) ; 
 + histogram . update ( 2000 ) ; 
 + clock . addMillis ( 100 ) ; 
 + another . update ( 3000 ) ; 
 + clock . addMillis ( 100 ) ; 
 + histogram . update ( 3000 ) ; 
 + clock . addMillis ( 100 ) ; 
 + another . update ( 4000 ) ; 
 + 
 + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot snapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) histogram . getSnapshot ( ) ; 
 + DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot anotherSnapshot = ( DecayingEstimatedHistogramReservoir . EstimatedHistogramReservoirSnapshot ) another . getSnapshot ( ) ; 
 + 
 + assertEquals ( 2000 , snapshot . getMean ( ) , 500D ) ; 
 + assertEquals ( 3000 , anotherSnapshot . getMean ( ) , 500D ) ; 
 + 
 + snapshot . add ( anotherSnapshot ) ; 
 + 
 + / / Another had newer decayLandmark , the aggregated snapshot should use it 
 + assertEquals ( anotherSnapshot . getSnapshotLandmark ( ) , snapshot . getSnapshotLandmark ( ) ) ; 
 + assertEquals ( 2500 , snapshot . getMean ( ) , 500D ) ; 
 + } 
 + 
 private void assertEstimatedQuantile ( long expectedValue , double actualValue ) 
 { 
 assertTrue ( " Expected at least [ " + expectedValue + " ] but actual is [ " + actualValue + " ] " , actualValue > = expectedValue ) ; 
 diff - - git a / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java b / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java 
 index 62cb88e . . d61c550 100644 
 - - - a / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java 
 + + + b / test / unit / org / apache / cassandra / metrics / LatencyMetricsTest . java 
 @ @ - 18 , 12 + 18 , 27 @ @ 
 
 package org . apache . cassandra . metrics ; 
 
 + import java . util . concurrent . TimeUnit ; 
 + 
 import org . junit . Test ; 
 
 + import static junit . framework . Assert . assertEquals ; 
 import static junit . framework . Assert . assertFalse ; 
 
 public class LatencyMetricsTest 
 { 
 + private final MetricNameFactory factory = new TestMetricsNameFactory ( ) ; 
 + 
 + private class TestMetricsNameFactory implements MetricNameFactory 
 + { 
 + 
 + @ Override 
 + public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) 
 + { 
 + return new CassandraMetricsRegistry . MetricName ( TestMetricsNameFactory . class , metricName ) ; 
 + } 
 + } 
 + 
 / * * 
 * Test bitsets in a " real - world " environment , i . e . , bloom filters 
 * / 
 @ @ - 31 , 14 + 46 , 10 @ @ public class LatencyMetricsTest 
 public void testGetRecentLatency ( ) 
 { 
 final LatencyMetrics l = new LatencyMetrics ( " test " , " test " ) ; 
 - Runnable r = new Runnable ( ) 
 - { 
 - public void run ( ) 
 + Runnable r = ( ) - > { 
 + for ( int i = 0 ; i < 10000 ; i + + ) 
 { 
 - for ( int i = 0 ; i < 10000 ; i + + ) 
 - { 
 - l . addNano ( 1000 ) ; 
 - } 
 + l . addNano ( 1000 ) ; 
 } 
 } ; 
 new Thread ( r ) . start ( ) ; 
 @ @ - 49 , 4 + 60 , 49 @ @ public class LatencyMetricsTest 
 assertFalse ( recent . equals ( Double . POSITIVE _ INFINITY ) ) ; 
 } 
 } 
 + 
 + / * * 
 + * Test that parent LatencyMetrics are receiving updates from child metrics when reading 
 + * / 
 + @ Test 
 + public void testReadMerging ( ) 
 + { 
 + final LatencyMetrics parent = new LatencyMetrics ( " testMerge " , " testMerge " ) ; 
 + final LatencyMetrics child = new LatencyMetrics ( factory , " testChild " , parent ) ; 
 + 
 + for ( int i = 0 ; i < 100 ; i + + ) 
 + { 
 + child . addNano ( TimeUnit . NANOSECONDS . convert ( i , TimeUnit . MILLISECONDS ) ) ; 
 + } 
 + 
 + assertEquals ( 4950000 , child . totalLatency . getCount ( ) ) ; 
 + assertEquals ( child . totalLatency . getCount ( ) , parent . totalLatency . getCount ( ) ) ; 
 + assertEquals ( child . latency . getSnapshot ( ) . getMean ( ) , parent . latency . getSnapshot ( ) . getMean ( ) , 50D ) ; 
 + 
 + child . release ( ) ; 
 + parent . release ( ) ; 
 + } 
 + 
 + @ Test 
 + public void testRelease ( ) 
 + { 
 + final LatencyMetrics parent = new LatencyMetrics ( " testRelease " , " testRelease " ) ; 
 + final LatencyMetrics child = new LatencyMetrics ( factory , " testChildRelease " , parent ) ; 
 + 
 + for ( int i = 0 ; i < 100 ; i + + ) 
 + { 
 + child . addNano ( TimeUnit . NANOSECONDS . convert ( i , TimeUnit . MILLISECONDS ) ) ; 
 + } 
 + 
 + double mean = parent . latency . getSnapshot ( ) . getMean ( ) ; 
 + long count = parent . totalLatency . getCount ( ) ; 
 + 
 + child . release ( ) ; 
 + 
 + / / Check that no value was lost with the release 
 + assertEquals ( count , parent . totalLatency . getCount ( ) ) ; 
 + assertEquals ( mean , parent . latency . getSnapshot ( ) . getMean ( ) , 50D ) ; 
 + 
 + parent . release ( ) ; 
 + } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java b / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java 
 index 6077e38 . . 84b91e9 100644 
 - - - a / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java 
 + + + b / src / java / org / apache / cassandra / service / RangeSliceResponseResolver . java 
 @ @ - 62 , 7 + 62 , 7 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro 
 return reply . rows ; 
 } 
 
 - / / Note : this deserializes the response a 2nd time if getData was called first 
 + / / Note : this would deserialize the response a 2nd time if getData was called first . 
 / / ( this is not currently an issue since we don ' t do read repair for range queries . ) 
 public Iterable < Row > resolve ( ) throws IOException 
 { 
 @ @ - 73 , 7 + 73 , 7 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro 
 return o1 . left . key . compareTo ( o2 . left . key ) ; 
 } 
 } ) ; 
 - 
 + 
 int n = 0 ; 
 for ( Message response : responses ) 
 { 
 @ @ - 83 , 7 + 83 , 6 @ @ public class RangeSliceResponseResolver implements IResponseResolver < Iterable < Ro 
 } 
 
 / / for each row , compute the combination of all different versions seen , and repair incomplete versions 
 - 
 return new ReducingIterator < Pair < Row , InetAddress > , Row > ( collator ) 
 { 
 List < ColumnFamily > versions = new ArrayList < ColumnFamily > ( sources . size ( ) ) ;
