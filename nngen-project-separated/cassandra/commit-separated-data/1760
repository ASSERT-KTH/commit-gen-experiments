BLEU SCORE: 0.02383853510228548

TEST MSG: Fixes to index summary resampling on old sstable formats
GENERATED MSG: ghetto - merge from cassandra 1 . 2

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9bc314d . . dba397c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 7 @ @ <nl> 2 . 1 . 4 <nl> + * Avoid overwriting index summaries for sstables with an older format that <nl> + does not support downsampling ; rebuild summaries on startup when this <nl> + is detected ( CASSANDRA - 8993 ) <nl> * Fix potential data loss in CompressedSequentialWriter ( CASSANDRA - 8949 ) <nl> * Make PasswordAuthenticator number of hashing rounds configurable ( CASSANDRA - 8085 ) <nl> * Fix AssertionError when binding nested collections in DELETE ( CASSANDRA - 8900 ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / Downsampling . java b / src / java / org / apache / cassandra / io / sstable / Downsampling . java <nl> index 6842b25 . . 8455d0b 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / Downsampling . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / Downsampling . java <nl> @ @ - 79 , 8 + 79 , 8 @ @ public class Downsampling <nl> * Returns a list that can be used to translate current index summary indexes to their original index before <nl> * downsampling . ( This repeats every ` samplingLevel ` , so that ' s how many entries we return . ) <nl> * <nl> - * For example , if [ 7 , 15 ] is returned , the current index summary entry at index 0 was originally <nl> - * at index 7 , and the current index 1 was originally at index 15 . <nl> + * For example , if [ 0 , 64 ] is returned , the current index summary entry at index 0 was originally <nl> + * at index 0 , and the current index 1 was originally at index 64 . <nl> * <nl> * @ param samplingLevel the current sampling level for the index summary <nl> * <nl> @ @ - 115 , 21 + 115 , 11 @ @ public class Downsampling <nl> * / <nl> public static int getEffectiveIndexIntervalAfterIndex ( int index , int samplingLevel , int minIndexInterval ) <nl> { <nl> - assert index > = - 1 ; <nl> - List < Integer > originalIndexes = getOriginalIndexes ( samplingLevel ) ; <nl> - if ( index = = - 1 ) <nl> - return originalIndexes . get ( 0 ) * minIndexInterval ; <nl> - <nl> + assert index > = 0 ; <nl> index % = samplingLevel ; <nl> - if ( index = = originalIndexes . size ( ) - 1 ) <nl> - { <nl> - / / account for partitions after the " last " entry as well as partitions before the " first " entry <nl> - return ( ( BASE _ SAMPLING _ LEVEL - originalIndexes . get ( index ) ) + originalIndexes . get ( 0 ) ) * minIndexInterval ; <nl> - } <nl> - else <nl> - { <nl> - return ( originalIndexes . get ( index + 1 ) - originalIndexes . get ( index ) ) * minIndexInterval ; <nl> - } <nl> + List < Integer > originalIndexes = getOriginalIndexes ( samplingLevel ) ; <nl> + int nextEntryOriginalIndex = ( index = = originalIndexes . size ( ) - 1 ) ? BASE _ SAMPLING _ LEVEL : originalIndexes . get ( index + 1 ) ; <nl> + return ( nextEntryOriginalIndex - originalIndexes . get ( index ) ) * minIndexInterval ; <nl> } <nl> <nl> public static int [ ] getStartPoints ( int currentSamplingLevel , int newSamplingLevel ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummary . java b / src / java / org / apache / cassandra / io / sstable / IndexSummary . java <nl> index bad50b4 . . 0ea0b48 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummary . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummary . java <nl> @ @ - 86 , 6 + 86 , 7 @ @ public class IndexSummary extends WrappedSharedCloseable <nl> this . offsets = offsets ; <nl> this . entries = entries ; <nl> this . samplingLevel = samplingLevel ; <nl> + assert samplingLevel > 0 ; <nl> } <nl> <nl> private IndexSummary ( IndexSummary copy ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java <nl> index 4144c32 . . 0c196ff 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java <nl> @ @ - 259 , 6 + 259 , 17 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean <nl> for ( SSTableReader sstable : Iterables . concat ( compacting , nonCompacting ) ) <nl> total + = sstable . getIndexSummaryOffHeapSize ( ) ; <nl> <nl> + List < SSTableReader > oldFormatSSTables = new ArrayList < > ( ) ; <nl> + for ( SSTableReader sstable : nonCompacting ) <nl> + { <nl> + / / We can ' t change the sampling level of sstables with the old format , because the serialization format <nl> + / / doesn ' t include the sampling level . Leave this one as it is . ( See CASSANDRA - 8993 for details . ) <nl> + logger . trace ( " SSTable { } cannot be re - sampled due to old sstable format " , sstable ) ; <nl> + if ( ! sstable . descriptor . version . hasSamplingLevel ) <nl> + oldFormatSSTables . add ( sstable ) ; <nl> + } <nl> + nonCompacting . removeAll ( oldFormatSSTables ) ; <nl> + <nl> logger . debug ( " Beginning redistribution of index summaries for { } sstables with memory pool size { } MB ; current spaced used is { } MB " , <nl> nonCompacting . size ( ) , memoryPoolBytes / 1024L / 1024L , total / 1024 . 0 / 1024 . 0 ) ; <nl> <nl> @ @ - 280 , 7 + 291 , 7 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean <nl> Collections . sort ( sstablesByHotness , new ReadRateComparator ( readRates ) ) ; <nl> <nl> long remainingBytes = memoryPoolBytes ; <nl> - for ( SSTableReader sstable : compacting ) <nl> + for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables ) ) <nl> remainingBytes - = sstable . getIndexSummaryOffHeapSize ( ) ; <nl> <nl> logger . trace ( " Index summaries for compacting SSTables are using { } MB of space " , <nl> @ @ - 288 , 7 + 299 , 7 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean <nl> List < SSTableReader > newSSTables = adjustSamplingLevels ( sstablesByHotness , totalReadsPerSec , remainingBytes ) ; <nl> <nl> total = 0 ; <nl> - for ( SSTableReader sstable : Iterables . concat ( compacting , newSSTables ) ) <nl> + for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables , newSSTables ) ) <nl> total + = sstable . getIndexSummaryOffHeapSize ( ) ; <nl> logger . debug ( " Completed resizing of index summaries ; current approximate memory used : { } MB " , <nl> total / 1024 . 0 / 1024 . 0 ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index f5eef09 . . 8fd7b85 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 26 , 16 + 26 , 7 @ @ import java . io . FileOutputStream ; <nl> import java . io . IOException ; <nl> import java . io . RandomAccessFile ; <nl> import java . nio . ByteBuffer ; <nl> - import java . util . ArrayList ; <nl> - import java . util . Collection ; <nl> - import java . util . Collections ; <nl> - import java . util . Comparator ; <nl> - import java . util . EnumSet ; <nl> - import java . util . HashSet ; <nl> - import java . util . Iterator ; <nl> - import java . util . List ; <nl> - import java . util . Map ; <nl> - import java . util . Set ; <nl> + import java . util . * ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicBoolean ; <nl> import java . util . concurrent . atomic . AtomicLong ; <nl> @ @ - 708 , 13 + 699 , 39 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead <nl> : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; <nl> <nl> boolean summaryLoaded = loadSummary ( ibuilder , dbuilder ) ; <nl> + boolean builtSummary = false ; <nl> if ( recreateBloomFilter | | ! summaryLoaded ) <nl> + { <nl> buildSummary ( recreateBloomFilter , ibuilder , dbuilder , summaryLoaded , Downsampling . BASE _ SAMPLING _ LEVEL ) ; <nl> + builtSummary = true ; <nl> + } <nl> <nl> ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> - if ( saveSummaryIfCreated & & ( recreateBloomFilter | | ! summaryLoaded ) ) / / save summary information to disk <nl> + <nl> + / / Check for an index summary that was downsampled even though the serialization format doesn ' t support <nl> + / / that . If it was downsampled , rebuild it . See CASSANDRA - 8993 for details . <nl> + if ( ! descriptor . version . hasSamplingLevel & & ! builtSummary & & ! validateSummarySamplingLevel ( ) ) <nl> + { <nl> + indexSummary . close ( ) ; <nl> + ifile . close ( ) ; <nl> + dfile . close ( ) ; <nl> + <nl> + logger . info ( " Detected erroneously downsampled index summary ; will rebuild summary at full sampling " ) ; <nl> + FileUtils . deleteWithConfirm ( new File ( descriptor . filenameFor ( Component . SUMMARY ) ) ) ; <nl> + ibuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getIndexAccessMode ( ) ) ; <nl> + dbuilder = compression <nl> + ? SegmentedFile . getCompressedBuilder ( ) <nl> + : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; <nl> + buildSummary ( false , ibuilder , dbuilder , false , Downsampling . BASE _ SAMPLING _ LEVEL ) ; <nl> + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; <nl> + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; <nl> + saveSummary ( ibuilder , dbuilder ) ; <nl> + } <nl> + else if ( saveSummaryIfCreated & & builtSummary ) <nl> + { <nl> saveSummary ( ibuilder , dbuilder ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> @ @ - 800 , 7 + 817 , 9 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead <nl> try <nl> { <nl> iStream = new DataInputStream ( new FileInputStream ( summariesFile ) ) ; <nl> - indexSummary = IndexSummary . serializer . deserialize ( iStream , partitioner , descriptor . version . hasSamplingLevel , metadata . getMinIndexInterval ( ) , metadata . getMaxIndexInterval ( ) ) ; <nl> + indexSummary = IndexSummary . serializer . deserialize ( <nl> + iStream , partitioner , descriptor . version . hasSamplingLevel , <nl> + metadata . getMinIndexInterval ( ) , metadata . getMaxIndexInterval ( ) ) ; <nl> first = partitioner . decorateKey ( ByteBufferUtil . readWithLength ( iStream ) ) ; <nl> last = partitioner . decorateKey ( ByteBufferUtil . readWithLength ( iStream ) ) ; <nl> ibuilder . deserializeBounds ( iStream ) ; <nl> @ @ - 826 , 6 + 845 , 57 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead <nl> } <nl> <nl> / * * <nl> + * Validates that an index summary has full sampling , as expected when the serialization format does not support <nl> + * persisting the sampling level . <nl> + * @ return true if the summary has full sampling , false otherwise <nl> + * / <nl> + private boolean validateSummarySamplingLevel ( ) <nl> + { <nl> + / / We need to check index summary entries against the index to verify that none of them were dropped due to <nl> + / / downsampling . Downsampling can drop any of the first BASE _ SAMPLING _ LEVEL entries ( repeating that drop pattern <nl> + / / for the remainder of the summary ) . Unfortunately , the first entry to be dropped is the entry at <nl> + / / index ( BASE _ SAMPLING _ LEVEL - 1 ) , so we need to check a full set of BASE _ SAMPLING _ LEVEL entries . <nl> + Iterator < FileDataInput > segments = ifile . iterator ( 0 ) ; <nl> + int i = 0 ; <nl> + int summaryEntriesChecked = 0 ; <nl> + int expectedIndexInterval = getMinIndexInterval ( ) ; <nl> + while ( segments . hasNext ( ) ) <nl> + { <nl> + FileDataInput in = segments . next ( ) ; <nl> + try <nl> + { <nl> + while ( ! in . isEOF ( ) ) <nl> + { <nl> + ByteBuffer indexKey = ByteBufferUtil . readWithShortLength ( in ) ; <nl> + if ( i % expectedIndexInterval = = 0 ) <nl> + { <nl> + ByteBuffer summaryKey = ByteBuffer . wrap ( indexSummary . getKey ( i / expectedIndexInterval ) ) ; <nl> + if ( ! summaryKey . equals ( indexKey ) ) <nl> + return false ; <nl> + summaryEntriesChecked + + ; <nl> + <nl> + if ( summaryEntriesChecked = = Downsampling . BASE _ SAMPLING _ LEVEL ) <nl> + return true ; <nl> + } <nl> + RowIndexEntry . Serializer . skip ( in ) ; <nl> + i + + ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + markSuspect ( ) ; <nl> + throw new CorruptSSTableException ( e , in . getPath ( ) ) ; <nl> + } <nl> + finally <nl> + { <nl> + FileUtils . closeQuietly ( in ) ; <nl> + } <nl> + } <nl> + <nl> + return true ; <nl> + } <nl> + <nl> + / * * <nl> * Save index summary to Summary . db file . <nl> * <nl> * @ param ibuilder <nl> @ @ - 946 , 6 + 1016 , 8 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead <nl> * / <nl> public SSTableReader cloneWithNewSummarySamplingLevel ( ColumnFamilyStore parent , int samplingLevel ) throws IOException <nl> { <nl> + assert descriptor . version . hasSamplingLevel ; <nl> + <nl> synchronized ( tidy . global ) <nl> { <nl> assert openReason ! = OpenReason . EARLY ; <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> index 0760aa3 . . 9ed5b32 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java <nl> @ @ - 257 , 7 + 257 , 7 @ @ public class IndexSummaryTest <nl> assertEquals ( 128 , BASE _ SAMPLING _ LEVEL ) ; <nl> assertEquals ( Arrays . asList ( 0 , 32 , 64 , 96 ) , Downsampling . getOriginalIndexes ( 4 ) ) ; <nl> assertEquals ( Arrays . asList ( 0 , 64 ) , Downsampling . getOriginalIndexes ( 2 ) ) ; <nl> - assertEquals ( Arrays . asList ( ) , Downsampling . getOriginalIndexes ( 0 ) ) ; <nl> + assertEquals ( Arrays . asList ( 0 ) , Downsampling . getOriginalIndexes ( 1 ) ) ; <nl> } <nl> <nl> @ Test
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> new file mode 100644 <nl> index 0000000 . . 12be453 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> @ @ - 0 , 0 + 1 , 76 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . io . sstable ; <nl> + <nl> + import java . util . ArrayList ; <nl> + <nl> + import com . google . common . primitives . Bytes ; <nl> + import com . google . common . primitives . Longs ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + public class IndexSummaryBuilder <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; <nl> + <nl> + private final ArrayList < Long > positions ; <nl> + private final ArrayList < byte [ ] > keys ; <nl> + private long keysWritten = 0 ; <nl> + <nl> + public IndexSummaryBuilder ( long expectedKeys , int indexInterval ) <nl> + { <nl> + long expectedEntries = expectedKeys / indexInterval ; <nl> + if ( expectedEntries > Integer . MAX _ VALUE ) <nl> + { <nl> + / / that ' s a _ lot _ of keys , and a very low interval <nl> + int effectiveInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; <nl> + expectedEntries = expectedKeys / effectiveInterval ; <nl> + assert expectedEntries < = Integer . MAX _ VALUE : expectedEntries ; <nl> + logger . warn ( " Index interval of { } is too low for { } expected keys ; using interval of { } instead " , <nl> + indexInterval , expectedKeys , effectiveInterval ) ; <nl> + } <nl> + positions = new ArrayList < Long > ( ( int ) expectedEntries ) ; <nl> + keys = new ArrayList < byte [ ] > ( ( int ) expectedEntries ) ; <nl> + } <nl> + <nl> + public IndexSummaryBuilder maybeAddEntry ( DecoratedKey decoratedKey , int indexInterval , long indexPosition ) <nl> + { <nl> + if ( keysWritten % indexInterval = = 0 ) <nl> + { <nl> + keys . add ( ByteBufferUtil . getArray ( decoratedKey . key ) ) ; <nl> + positions . add ( indexPosition ) ; <nl> + } <nl> + keysWritten + + ; <nl> + <nl> + return this ; <nl> + } <nl> + <nl> + public IndexSummary build ( IPartitioner partitioner , int indexInterval ) <nl> + { <nl> + byte [ ] [ ] keysArray = new byte [ keys . size ( ) ] [ ] ; <nl> + for ( int i = 0 ; i < keys . size ( ) ; i + + ) <nl> + keysArray [ i ] = keys . get ( i ) ; <nl> + <nl> + return new IndexSummary ( partitioner , keysArray , Longs . toArray ( positions ) , indexInterval ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 2d6c1df . . 27589f5 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 400 , 14 + 400 , 14 @ @ public class SSTableReader extends SSTable <nl> / / if summary was already read from disk we don ' t want to re - populate it using primary index <nl> if ( ! summaryLoaded ) <nl> { <nl> - summaryBuilder . maybeAddEntry ( decoratedKey , indexPosition ) ; <nl> + summaryBuilder . maybeAddEntry ( decoratedKey , metadata . getIndexInterval ( ) , indexPosition ) ; <nl> ibuilder . addPotentialBoundary ( indexPosition ) ; <nl> dbuilder . addPotentialBoundary ( indexEntry . position ) ; <nl> } <nl> } <nl> <nl> if ( ! summaryLoaded ) <nl> - indexSummary = summaryBuilder . build ( partitioner ) ; <nl> + indexSummary = summaryBuilder . build ( partitioner , metadata . getIndexInterval ( ) ) ; <nl> } <nl> finally <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> index 4b0b756 . . c67e868 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> @ @ - 339 , 7 + 339 , 7 @ @ public class SSTableWriter extends SSTable <nl> partitioner , <nl> ifile , <nl> dfile , <nl> - iwriter . summary . build ( partitioner ) , <nl> + iwriter . summary . build ( partitioner , metadata . getIndexInterval ( ) ) , <nl> iwriter . bf , <nl> maxDataAge , <nl> sstableMetadata ) ; <nl> @ @ - 434 , 7 + 434 , 7 @ @ public class SSTableWriter extends SSTable <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " wrote index entry : " + indexEntry + " at " + indexPosition ) ; <nl> <nl> - summary . maybeAddEntry ( key , indexPosition ) ; <nl> + summary . maybeAddEntry ( key , metadata . getIndexInterval ( ) , indexPosition ) ; <nl> builder . addPotentialBoundary ( indexPosition ) ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9bc314d . . dba397c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 7 @ @ 
 2 . 1 . 4 
 + * Avoid overwriting index summaries for sstables with an older format that 
 + does not support downsampling ; rebuild summaries on startup when this 
 + is detected ( CASSANDRA - 8993 ) 
 * Fix potential data loss in CompressedSequentialWriter ( CASSANDRA - 8949 ) 
 * Make PasswordAuthenticator number of hashing rounds configurable ( CASSANDRA - 8085 ) 
 * Fix AssertionError when binding nested collections in DELETE ( CASSANDRA - 8900 ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / Downsampling . java b / src / java / org / apache / cassandra / io / sstable / Downsampling . java 
 index 6842b25 . . 8455d0b 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / Downsampling . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / Downsampling . java 
 @ @ - 79 , 8 + 79 , 8 @ @ public class Downsampling 
 * Returns a list that can be used to translate current index summary indexes to their original index before 
 * downsampling . ( This repeats every ` samplingLevel ` , so that ' s how many entries we return . ) 
 * 
 - * For example , if [ 7 , 15 ] is returned , the current index summary entry at index 0 was originally 
 - * at index 7 , and the current index 1 was originally at index 15 . 
 + * For example , if [ 0 , 64 ] is returned , the current index summary entry at index 0 was originally 
 + * at index 0 , and the current index 1 was originally at index 64 . 
 * 
 * @ param samplingLevel the current sampling level for the index summary 
 * 
 @ @ - 115 , 21 + 115 , 11 @ @ public class Downsampling 
 * / 
 public static int getEffectiveIndexIntervalAfterIndex ( int index , int samplingLevel , int minIndexInterval ) 
 { 
 - assert index > = - 1 ; 
 - List < Integer > originalIndexes = getOriginalIndexes ( samplingLevel ) ; 
 - if ( index = = - 1 ) 
 - return originalIndexes . get ( 0 ) * minIndexInterval ; 
 - 
 + assert index > = 0 ; 
 index % = samplingLevel ; 
 - if ( index = = originalIndexes . size ( ) - 1 ) 
 - { 
 - / / account for partitions after the " last " entry as well as partitions before the " first " entry 
 - return ( ( BASE _ SAMPLING _ LEVEL - originalIndexes . get ( index ) ) + originalIndexes . get ( 0 ) ) * minIndexInterval ; 
 - } 
 - else 
 - { 
 - return ( originalIndexes . get ( index + 1 ) - originalIndexes . get ( index ) ) * minIndexInterval ; 
 - } 
 + List < Integer > originalIndexes = getOriginalIndexes ( samplingLevel ) ; 
 + int nextEntryOriginalIndex = ( index = = originalIndexes . size ( ) - 1 ) ? BASE _ SAMPLING _ LEVEL : originalIndexes . get ( index + 1 ) ; 
 + return ( nextEntryOriginalIndex - originalIndexes . get ( index ) ) * minIndexInterval ; 
 } 
 
 public static int [ ] getStartPoints ( int currentSamplingLevel , int newSamplingLevel ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummary . java b / src / java / org / apache / cassandra / io / sstable / IndexSummary . java 
 index bad50b4 . . 0ea0b48 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummary . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummary . java 
 @ @ - 86 , 6 + 86 , 7 @ @ public class IndexSummary extends WrappedSharedCloseable 
 this . offsets = offsets ; 
 this . entries = entries ; 
 this . samplingLevel = samplingLevel ; 
 + assert samplingLevel > 0 ; 
 } 
 
 private IndexSummary ( IndexSummary copy ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java 
 index 4144c32 . . 0c196ff 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryManager . java 
 @ @ - 259 , 6 + 259 , 17 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean 
 for ( SSTableReader sstable : Iterables . concat ( compacting , nonCompacting ) ) 
 total + = sstable . getIndexSummaryOffHeapSize ( ) ; 
 
 + List < SSTableReader > oldFormatSSTables = new ArrayList < > ( ) ; 
 + for ( SSTableReader sstable : nonCompacting ) 
 + { 
 + / / We can ' t change the sampling level of sstables with the old format , because the serialization format 
 + / / doesn ' t include the sampling level . Leave this one as it is . ( See CASSANDRA - 8993 for details . ) 
 + logger . trace ( " SSTable { } cannot be re - sampled due to old sstable format " , sstable ) ; 
 + if ( ! sstable . descriptor . version . hasSamplingLevel ) 
 + oldFormatSSTables . add ( sstable ) ; 
 + } 
 + nonCompacting . removeAll ( oldFormatSSTables ) ; 
 + 
 logger . debug ( " Beginning redistribution of index summaries for { } sstables with memory pool size { } MB ; current spaced used is { } MB " , 
 nonCompacting . size ( ) , memoryPoolBytes / 1024L / 1024L , total / 1024 . 0 / 1024 . 0 ) ; 
 
 @ @ - 280 , 7 + 291 , 7 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean 
 Collections . sort ( sstablesByHotness , new ReadRateComparator ( readRates ) ) ; 
 
 long remainingBytes = memoryPoolBytes ; 
 - for ( SSTableReader sstable : compacting ) 
 + for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables ) ) 
 remainingBytes - = sstable . getIndexSummaryOffHeapSize ( ) ; 
 
 logger . trace ( " Index summaries for compacting SSTables are using { } MB of space " , 
 @ @ - 288 , 7 + 299 , 7 @ @ public class IndexSummaryManager implements IndexSummaryManagerMBean 
 List < SSTableReader > newSSTables = adjustSamplingLevels ( sstablesByHotness , totalReadsPerSec , remainingBytes ) ; 
 
 total = 0 ; 
 - for ( SSTableReader sstable : Iterables . concat ( compacting , newSSTables ) ) 
 + for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables , newSSTables ) ) 
 total + = sstable . getIndexSummaryOffHeapSize ( ) ; 
 logger . debug ( " Completed resizing of index summaries ; current approximate memory used : { } MB " , 
 total / 1024 . 0 / 1024 . 0 ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index f5eef09 . . 8fd7b85 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 26 , 16 + 26 , 7 @ @ import java . io . FileOutputStream ; 
 import java . io . IOException ; 
 import java . io . RandomAccessFile ; 
 import java . nio . ByteBuffer ; 
 - import java . util . ArrayList ; 
 - import java . util . Collection ; 
 - import java . util . Collections ; 
 - import java . util . Comparator ; 
 - import java . util . EnumSet ; 
 - import java . util . HashSet ; 
 - import java . util . Iterator ; 
 - import java . util . List ; 
 - import java . util . Map ; 
 - import java . util . Set ; 
 + import java . util . * ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicBoolean ; 
 import java . util . concurrent . atomic . AtomicLong ; 
 @ @ - 708 , 13 + 699 , 39 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead 
 : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; 
 
 boolean summaryLoaded = loadSummary ( ibuilder , dbuilder ) ; 
 + boolean builtSummary = false ; 
 if ( recreateBloomFilter | | ! summaryLoaded ) 
 + { 
 buildSummary ( recreateBloomFilter , ibuilder , dbuilder , summaryLoaded , Downsampling . BASE _ SAMPLING _ LEVEL ) ; 
 + builtSummary = true ; 
 + } 
 
 ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 - if ( saveSummaryIfCreated & & ( recreateBloomFilter | | ! summaryLoaded ) ) / / save summary information to disk 
 + 
 + / / Check for an index summary that was downsampled even though the serialization format doesn ' t support 
 + / / that . If it was downsampled , rebuild it . See CASSANDRA - 8993 for details . 
 + if ( ! descriptor . version . hasSamplingLevel & & ! builtSummary & & ! validateSummarySamplingLevel ( ) ) 
 + { 
 + indexSummary . close ( ) ; 
 + ifile . close ( ) ; 
 + dfile . close ( ) ; 
 + 
 + logger . info ( " Detected erroneously downsampled index summary ; will rebuild summary at full sampling " ) ; 
 + FileUtils . deleteWithConfirm ( new File ( descriptor . filenameFor ( Component . SUMMARY ) ) ) ; 
 + ibuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getIndexAccessMode ( ) ) ; 
 + dbuilder = compression 
 + ? SegmentedFile . getCompressedBuilder ( ) 
 + : SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) ) ; 
 + buildSummary ( false , ibuilder , dbuilder , false , Downsampling . BASE _ SAMPLING _ LEVEL ) ; 
 + ifile = ibuilder . complete ( descriptor . filenameFor ( Component . PRIMARY _ INDEX ) ) ; 
 + dfile = dbuilder . complete ( descriptor . filenameFor ( Component . DATA ) ) ; 
 + saveSummary ( ibuilder , dbuilder ) ; 
 + } 
 + else if ( saveSummaryIfCreated & & builtSummary ) 
 + { 
 saveSummary ( ibuilder , dbuilder ) ; 
 + } 
 } 
 
 / * * 
 @ @ - 800 , 7 + 817 , 9 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead 
 try 
 { 
 iStream = new DataInputStream ( new FileInputStream ( summariesFile ) ) ; 
 - indexSummary = IndexSummary . serializer . deserialize ( iStream , partitioner , descriptor . version . hasSamplingLevel , metadata . getMinIndexInterval ( ) , metadata . getMaxIndexInterval ( ) ) ; 
 + indexSummary = IndexSummary . serializer . deserialize ( 
 + iStream , partitioner , descriptor . version . hasSamplingLevel , 
 + metadata . getMinIndexInterval ( ) , metadata . getMaxIndexInterval ( ) ) ; 
 first = partitioner . decorateKey ( ByteBufferUtil . readWithLength ( iStream ) ) ; 
 last = partitioner . decorateKey ( ByteBufferUtil . readWithLength ( iStream ) ) ; 
 ibuilder . deserializeBounds ( iStream ) ; 
 @ @ - 826 , 6 + 845 , 57 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead 
 } 
 
 / * * 
 + * Validates that an index summary has full sampling , as expected when the serialization format does not support 
 + * persisting the sampling level . 
 + * @ return true if the summary has full sampling , false otherwise 
 + * / 
 + private boolean validateSummarySamplingLevel ( ) 
 + { 
 + / / We need to check index summary entries against the index to verify that none of them were dropped due to 
 + / / downsampling . Downsampling can drop any of the first BASE _ SAMPLING _ LEVEL entries ( repeating that drop pattern 
 + / / for the remainder of the summary ) . Unfortunately , the first entry to be dropped is the entry at 
 + / / index ( BASE _ SAMPLING _ LEVEL - 1 ) , so we need to check a full set of BASE _ SAMPLING _ LEVEL entries . 
 + Iterator < FileDataInput > segments = ifile . iterator ( 0 ) ; 
 + int i = 0 ; 
 + int summaryEntriesChecked = 0 ; 
 + int expectedIndexInterval = getMinIndexInterval ( ) ; 
 + while ( segments . hasNext ( ) ) 
 + { 
 + FileDataInput in = segments . next ( ) ; 
 + try 
 + { 
 + while ( ! in . isEOF ( ) ) 
 + { 
 + ByteBuffer indexKey = ByteBufferUtil . readWithShortLength ( in ) ; 
 + if ( i % expectedIndexInterval = = 0 ) 
 + { 
 + ByteBuffer summaryKey = ByteBuffer . wrap ( indexSummary . getKey ( i / expectedIndexInterval ) ) ; 
 + if ( ! summaryKey . equals ( indexKey ) ) 
 + return false ; 
 + summaryEntriesChecked + + ; 
 + 
 + if ( summaryEntriesChecked = = Downsampling . BASE _ SAMPLING _ LEVEL ) 
 + return true ; 
 + } 
 + RowIndexEntry . Serializer . skip ( in ) ; 
 + i + + ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + markSuspect ( ) ; 
 + throw new CorruptSSTableException ( e , in . getPath ( ) ) ; 
 + } 
 + finally 
 + { 
 + FileUtils . closeQuietly ( in ) ; 
 + } 
 + } 
 + 
 + return true ; 
 + } 
 + 
 + / * * 
 * Save index summary to Summary . db file . 
 * 
 * @ param ibuilder 
 @ @ - 946 , 6 + 1016 , 8 @ @ public class SSTableReader extends SSTable implements SelfRefCounted < SSTableRead 
 * / 
 public SSTableReader cloneWithNewSummarySamplingLevel ( ColumnFamilyStore parent , int samplingLevel ) throws IOException 
 { 
 + assert descriptor . version . hasSamplingLevel ; 
 + 
 synchronized ( tidy . global ) 
 { 
 assert openReason ! = OpenReason . EARLY ; 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 index 0760aa3 . . 9ed5b32 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / IndexSummaryTest . java 
 @ @ - 257 , 7 + 257 , 7 @ @ public class IndexSummaryTest 
 assertEquals ( 128 , BASE _ SAMPLING _ LEVEL ) ; 
 assertEquals ( Arrays . asList ( 0 , 32 , 64 , 96 ) , Downsampling . getOriginalIndexes ( 4 ) ) ; 
 assertEquals ( Arrays . asList ( 0 , 64 ) , Downsampling . getOriginalIndexes ( 2 ) ) ; 
 - assertEquals ( Arrays . asList ( ) , Downsampling . getOriginalIndexes ( 0 ) ) ; 
 + assertEquals ( Arrays . asList ( 0 ) , Downsampling . getOriginalIndexes ( 1 ) ) ; 
 } 
 
 @ Test

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 new file mode 100644 
 index 0000000 . . 12be453 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 @ @ - 0 , 0 + 1 , 76 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . io . sstable ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import com . google . common . primitives . Bytes ; 
 + import com . google . common . primitives . Longs ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + public class IndexSummaryBuilder 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; 
 + 
 + private final ArrayList < Long > positions ; 
 + private final ArrayList < byte [ ] > keys ; 
 + private long keysWritten = 0 ; 
 + 
 + public IndexSummaryBuilder ( long expectedKeys , int indexInterval ) 
 + { 
 + long expectedEntries = expectedKeys / indexInterval ; 
 + if ( expectedEntries > Integer . MAX _ VALUE ) 
 + { 
 + / / that ' s a _ lot _ of keys , and a very low interval 
 + int effectiveInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; 
 + expectedEntries = expectedKeys / effectiveInterval ; 
 + assert expectedEntries < = Integer . MAX _ VALUE : expectedEntries ; 
 + logger . warn ( " Index interval of { } is too low for { } expected keys ; using interval of { } instead " , 
 + indexInterval , expectedKeys , effectiveInterval ) ; 
 + } 
 + positions = new ArrayList < Long > ( ( int ) expectedEntries ) ; 
 + keys = new ArrayList < byte [ ] > ( ( int ) expectedEntries ) ; 
 + } 
 + 
 + public IndexSummaryBuilder maybeAddEntry ( DecoratedKey decoratedKey , int indexInterval , long indexPosition ) 
 + { 
 + if ( keysWritten % indexInterval = = 0 ) 
 + { 
 + keys . add ( ByteBufferUtil . getArray ( decoratedKey . key ) ) ; 
 + positions . add ( indexPosition ) ; 
 + } 
 + keysWritten + + ; 
 + 
 + return this ; 
 + } 
 + 
 + public IndexSummary build ( IPartitioner partitioner , int indexInterval ) 
 + { 
 + byte [ ] [ ] keysArray = new byte [ keys . size ( ) ] [ ] ; 
 + for ( int i = 0 ; i < keys . size ( ) ; i + + ) 
 + keysArray [ i ] = keys . get ( i ) ; 
 + 
 + return new IndexSummary ( partitioner , keysArray , Longs . toArray ( positions ) , indexInterval ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 2d6c1df . . 27589f5 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 400 , 14 + 400 , 14 @ @ public class SSTableReader extends SSTable 
 / / if summary was already read from disk we don ' t want to re - populate it using primary index 
 if ( ! summaryLoaded ) 
 { 
 - summaryBuilder . maybeAddEntry ( decoratedKey , indexPosition ) ; 
 + summaryBuilder . maybeAddEntry ( decoratedKey , metadata . getIndexInterval ( ) , indexPosition ) ; 
 ibuilder . addPotentialBoundary ( indexPosition ) ; 
 dbuilder . addPotentialBoundary ( indexEntry . position ) ; 
 } 
 } 
 
 if ( ! summaryLoaded ) 
 - indexSummary = summaryBuilder . build ( partitioner ) ; 
 + indexSummary = summaryBuilder . build ( partitioner , metadata . getIndexInterval ( ) ) ; 
 } 
 finally 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 index 4b0b756 . . c67e868 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 @ @ - 339 , 7 + 339 , 7 @ @ public class SSTableWriter extends SSTable 
 partitioner , 
 ifile , 
 dfile , 
 - iwriter . summary . build ( partitioner ) , 
 + iwriter . summary . build ( partitioner , metadata . getIndexInterval ( ) ) , 
 iwriter . bf , 
 maxDataAge , 
 sstableMetadata ) ; 
 @ @ - 434 , 7 + 434 , 7 @ @ public class SSTableWriter extends SSTable 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " wrote index entry : " + indexEntry + " at " + indexPosition ) ; 
 
 - summary . maybeAddEntry ( key , indexPosition ) ; 
 + summary . maybeAddEntry ( key , metadata . getIndexInterval ( ) , indexPosition ) ; 
 builder . addPotentialBoundary ( indexPosition ) ; 
 } 

