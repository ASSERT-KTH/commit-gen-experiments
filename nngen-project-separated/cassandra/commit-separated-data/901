BLEU SCORE: 0.12605968092174913

TEST MSG: cqlsh COPY FROM fails for null values with non - prepared statements
GENERATED MSG: COPY FROM fails when importing blob

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ff26fde . . 5885a9a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 15 <nl> + * cqlsh COPY FROM fails for null values with non - prepared statements ( CASSANDRA - 11631 ) <nl> * Make cython optional in pylib / setup . py ( CASSANDRA - 11630 ) <nl> * Change order of directory searching for cassandra . in . sh to favor local one ( CASSANDRA - 11628 ) <nl> * cqlsh COPY FROM fails with [ ] { } chars in UDT / tuple fields / values ( CASSANDRA - 11633 ) <nl> diff - - git a / pylib / cqlshlib / copyutil . py b / pylib / cqlshlib / copyutil . py <nl> index e12b72f . . d68812c 100644 <nl> - - - a / pylib / cqlshlib / copyutil . py <nl> + + + b / pylib / cqlshlib / copyutil . py <nl> @ @ - 1634 , 6 + 1634 , 7 @ @ class ImportConversion ( object ) : <nl> self . thousands _ sep = parent . thousands _ sep <nl> self . boolean _ styles = parent . boolean _ styles <nl> self . time _ format = parent . time _ format <nl> + self . debug = parent . debug <nl> <nl> self . table _ meta = table _ meta <nl> self . primary _ key _ indexes = [ self . columns . index ( col . name ) for col in self . table _ meta . primary _ key ] <nl> @ @ - 1682 , 7 + 1683 , 16 @ @ class ImportConversion ( object ) : <nl> return CqlRuleSet . dequote _ value ( v ) <nl> <nl> def convert ( t , v ) : <nl> - return converters . get ( t . typename , convert _ unknown ) ( unprotect ( v ) , ct = t ) <nl> + v = unprotect ( v ) <nl> + if v = = self . nullval : <nl> + return self . get _ null _ val ( ) <nl> + return converters . get ( t . typename , convert _ unknown ) ( v , ct = t ) <nl> + <nl> + def convert _ mandatory ( t , v ) : <nl> + v = unprotect ( v ) <nl> + if v = = self . nullval : <nl> + raise ParseError ( ' Empty values are not allowed ' ) <nl> + return converters . get ( t . typename , convert _ unknown ) ( v , ct = t ) <nl> <nl> def convert _ blob ( v , * * _ ) : <nl> try : <nl> @ @ - 1788 , 13 + 1798 , 13 @ @ class ImportConversion ( object ) : <nl> return Time ( v ) <nl> <nl> def convert _ tuple ( val , ct = cql _ type ) : <nl> - return tuple ( convert ( t , v ) for t , v in zip ( ct . subtypes , split ( val ) ) ) <nl> + return tuple ( convert _ mandatory ( t , v ) for t , v in zip ( ct . subtypes , split ( val ) ) ) <nl> <nl> def convert _ list ( val , ct = cql _ type ) : <nl> - return list ( convert ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) <nl> + return list ( convert _ mandatory ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) <nl> <nl> def convert _ set ( val , ct = cql _ type ) : <nl> - return frozenset ( convert ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) <nl> + return frozenset ( convert _ mandatory ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) <nl> <nl> def convert _ map ( val , ct = cql _ type ) : <nl> " " " <nl> @ @ - 1806 , 7 + 1816 , 7 @ @ class ImportConversion ( object ) : <nl> class ImmutableDict ( frozenset ) : <nl> iteritems = frozenset . _ _ iter _ _ <nl> <nl> - return ImmutableDict ( frozenset ( ( convert ( ct . subtypes [ 0 ] , v [ 0 ] ) , convert ( ct . subtypes [ 1 ] , v [ 1 ] ) ) <nl> + return ImmutableDict ( frozenset ( ( convert _ mandatory ( ct . subtypes [ 0 ] , v [ 0 ] ) , convert ( ct . subtypes [ 1 ] , v [ 1 ] ) ) <nl> for v in [ split ( ' { % s } ' % vv , sep = ' : ' ) for vv in split ( val ) ] ) ) <nl> <nl> def convert _ user _ type ( val , ct = cql _ type ) : <nl> @ @ - 1862 , 6 + 1872 , 9 @ @ class ImportConversion ( object ) : <nl> <nl> return converters . get ( cql _ type . typename , convert _ unknown ) <nl> <nl> + def get _ null _ val ( self ) : <nl> + return None if self . use _ prepared _ statements else " NULL " <nl> + <nl> def convert _ row ( self , row ) : <nl> " " " <nl> Convert the row into a list of parsed values if using prepared statements , else simply apply the <nl> @ @ - 1877 , 10 + 1890 , 15 @ @ class ImportConversion ( object ) : <nl> if row [ i ] = = self . nullval : <nl> raise ParseError ( self . get _ null _ primary _ key _ message ( i ) ) <nl> <nl> - try : <nl> - return [ conv ( val ) if val ! = self . nullval else None for conv , val in zip ( converters , row ) ] <nl> - except Exception , e : <nl> - raise ParseError ( str ( e ) ) <nl> + def convert ( c , v ) : <nl> + try : <nl> + return c ( v ) if v ! = self . nullval else self . get _ null _ val ( ) <nl> + except Exception , e : <nl> + if self . debug : <nl> + traceback . print _ exc ( ) <nl> + raise ParseError ( " Failed to parse % s : % s " % ( val , str ( e ) ) ) <nl> + <nl> + return [ convert ( conv , val ) for conv , val in zip ( converters , row ) ] <nl> <nl> def get _ null _ primary _ key _ message ( self , idx ) : <nl> message = " Cannot insert null value for primary key column ' % s ' . " % ( self . columns [ idx ] , )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ff26fde . . 5885a9a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 15 
 + * cqlsh COPY FROM fails for null values with non - prepared statements ( CASSANDRA - 11631 ) 
 * Make cython optional in pylib / setup . py ( CASSANDRA - 11630 ) 
 * Change order of directory searching for cassandra . in . sh to favor local one ( CASSANDRA - 11628 ) 
 * cqlsh COPY FROM fails with [ ] { } chars in UDT / tuple fields / values ( CASSANDRA - 11633 ) 
 diff - - git a / pylib / cqlshlib / copyutil . py b / pylib / cqlshlib / copyutil . py 
 index e12b72f . . d68812c 100644 
 - - - a / pylib / cqlshlib / copyutil . py 
 + + + b / pylib / cqlshlib / copyutil . py 
 @ @ - 1634 , 6 + 1634 , 7 @ @ class ImportConversion ( object ) : 
 self . thousands _ sep = parent . thousands _ sep 
 self . boolean _ styles = parent . boolean _ styles 
 self . time _ format = parent . time _ format 
 + self . debug = parent . debug 
 
 self . table _ meta = table _ meta 
 self . primary _ key _ indexes = [ self . columns . index ( col . name ) for col in self . table _ meta . primary _ key ] 
 @ @ - 1682 , 7 + 1683 , 16 @ @ class ImportConversion ( object ) : 
 return CqlRuleSet . dequote _ value ( v ) 
 
 def convert ( t , v ) : 
 - return converters . get ( t . typename , convert _ unknown ) ( unprotect ( v ) , ct = t ) 
 + v = unprotect ( v ) 
 + if v = = self . nullval : 
 + return self . get _ null _ val ( ) 
 + return converters . get ( t . typename , convert _ unknown ) ( v , ct = t ) 
 + 
 + def convert _ mandatory ( t , v ) : 
 + v = unprotect ( v ) 
 + if v = = self . nullval : 
 + raise ParseError ( ' Empty values are not allowed ' ) 
 + return converters . get ( t . typename , convert _ unknown ) ( v , ct = t ) 
 
 def convert _ blob ( v , * * _ ) : 
 try : 
 @ @ - 1788 , 13 + 1798 , 13 @ @ class ImportConversion ( object ) : 
 return Time ( v ) 
 
 def convert _ tuple ( val , ct = cql _ type ) : 
 - return tuple ( convert ( t , v ) for t , v in zip ( ct . subtypes , split ( val ) ) ) 
 + return tuple ( convert _ mandatory ( t , v ) for t , v in zip ( ct . subtypes , split ( val ) ) ) 
 
 def convert _ list ( val , ct = cql _ type ) : 
 - return list ( convert ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) 
 + return list ( convert _ mandatory ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) 
 
 def convert _ set ( val , ct = cql _ type ) : 
 - return frozenset ( convert ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) 
 + return frozenset ( convert _ mandatory ( ct . subtypes [ 0 ] , v ) for v in split ( val ) ) 
 
 def convert _ map ( val , ct = cql _ type ) : 
 " " " 
 @ @ - 1806 , 7 + 1816 , 7 @ @ class ImportConversion ( object ) : 
 class ImmutableDict ( frozenset ) : 
 iteritems = frozenset . _ _ iter _ _ 
 
 - return ImmutableDict ( frozenset ( ( convert ( ct . subtypes [ 0 ] , v [ 0 ] ) , convert ( ct . subtypes [ 1 ] , v [ 1 ] ) ) 
 + return ImmutableDict ( frozenset ( ( convert _ mandatory ( ct . subtypes [ 0 ] , v [ 0 ] ) , convert ( ct . subtypes [ 1 ] , v [ 1 ] ) ) 
 for v in [ split ( ' { % s } ' % vv , sep = ' : ' ) for vv in split ( val ) ] ) ) 
 
 def convert _ user _ type ( val , ct = cql _ type ) : 
 @ @ - 1862 , 6 + 1872 , 9 @ @ class ImportConversion ( object ) : 
 
 return converters . get ( cql _ type . typename , convert _ unknown ) 
 
 + def get _ null _ val ( self ) : 
 + return None if self . use _ prepared _ statements else " NULL " 
 + 
 def convert _ row ( self , row ) : 
 " " " 
 Convert the row into a list of parsed values if using prepared statements , else simply apply the 
 @ @ - 1877 , 10 + 1890 , 15 @ @ class ImportConversion ( object ) : 
 if row [ i ] = = self . nullval : 
 raise ParseError ( self . get _ null _ primary _ key _ message ( i ) ) 
 
 - try : 
 - return [ conv ( val ) if val ! = self . nullval else None for conv , val in zip ( converters , row ) ] 
 - except Exception , e : 
 - raise ParseError ( str ( e ) ) 
 + def convert ( c , v ) : 
 + try : 
 + return c ( v ) if v ! = self . nullval else self . get _ null _ val ( ) 
 + except Exception , e : 
 + if self . debug : 
 + traceback . print _ exc ( ) 
 + raise ParseError ( " Failed to parse % s : % s " % ( val , str ( e ) ) ) 
 + 
 + return [ convert ( conv , val ) for conv , val in zip ( converters , row ) ] 
 
 def get _ null _ primary _ key _ message ( self , idx ) : 
 message = " Cannot insert null value for primary key column ' % s ' . " % ( self . columns [ idx ] , )

NEAREST DIFF:
ELIMINATEDSENTENCE
