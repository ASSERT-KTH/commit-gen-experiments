BLEU SCORE: 0.029079340872079116

TEST MSG: Fix repair hang when snapshot failed
GENERATED MSG: reduce memory use during streaming of multiple sstables

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d9f8a50 . . ffff102 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 2 <nl> + * Fix repair hang when snapshot failed ( CASSANDRA - 10057 ) <nl> * Fall back to 1 / 4 commitlog volume for commitlog _ total _ space on small disks <nl> ( CASSANDRA - 10199 ) <nl> Merged from 2 . 1 : <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> index 796f135 . . 41d79aa 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java <nl> @ @ - 88 , 7 + 88 , 7 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > <nl> <nl> case SNAPSHOT : <nl> logger . debug ( " Snapshotting { } " , desc ) ; <nl> - ColumnFamilyStore cfs = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; <nl> + final ColumnFamilyStore cfs = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; <nl> final Range < Token > repairingRange = desc . range ; <nl> Set < SSTableReader > snapshottedSSSTables = cfs . snapshot ( desc . sessionId . toString ( ) , new Predicate < SSTableReader > ( ) <nl> { <nl> @ @ - 103 , 8 + 103 , 13 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > <nl> Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; <nl> if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) <nl> { <nl> + / / clear snapshot that we just created <nl> + cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; <nl> logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> - throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; <nl> + MessageOut reply = new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) <nl> + . withParameter ( MessagingService . FAILURE _ RESPONSE _ PARAM , MessagingService . ONE _ BYTE ) ; <nl> + MessagingService . instance ( ) . sendReply ( reply , id , message . from ) ; <nl> + return ; <nl> } <nl> ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; <nl> logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2953d40 . . 403a154 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 20 , 6 + 20 , 7 @ @ <nl> get synced before server died ( CASSANDRA - 2285 ) <nl> * fix fd leak in sstable2json with non - mmap ' d i / o ( CASSANDRA - 2304 ) <nl> * reduce memory use during streaming of multiple sstables ( CASSANDRA - 2301 ) <nl> + * purge tombstoned rows from cache after GCGraceSeconds ( CASSANDRA - 2305 ) <nl> <nl> <nl> 0 . 7 . 3 <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 75dcf58 . . 5d299a8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1747 , 7 + 1747 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return ssTables . getRowCache ( ) . getCapacity ( ) = = 0 ? null : ssTables . getRowCache ( ) . getInternal ( key ) ; <nl> } <nl> <nl> - void invalidateCachedRow ( DecoratedKey key ) <nl> + public void invalidateCachedRow ( DecoratedKey key ) <nl> { <nl> ssTables . getRowCache ( ) . remove ( key ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / CompactionIterator . java b / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> index 88271e5 . . 128162d 100644 <nl> - - - a / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> + + + b / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> @ @ - 106 , 7 + 106 , 15 @ @ implements Closeable , ICompactionInfo <nl> try <nl> { <nl> AbstractCompactedRow compactedRow = getCompactedRow ( ) ; <nl> - return compactedRow . isEmpty ( ) ? null : compactedRow ; <nl> + if ( compactedRow . isEmpty ( ) ) <nl> + { <nl> + cfs . invalidateCachedRow ( compactedRow . key ) ; <nl> + return null ; <nl> + } <nl> + else <nl> + { <nl> + return compactedRow ; <nl> + } <nl> } <nl> finally <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java b / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java <nl> index 27ca9ad . . c290b87 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java <nl> @ @ - 178 , 4 + 178 , 53 @ @ public class CompactionsPurgeTest extends CleanupHelper <nl> ColumnFamily cf = table . getColumnFamilyStore ( cfName ) . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; <nl> assert cf = = null : cf ; <nl> } <nl> + <nl> + @ Test <nl> + public void testCompactionPurgeTombstonedRow ( ) throws IOException , ExecutionException , InterruptedException <nl> + { <nl> + CompactionManager . instance . disableAutoCompaction ( ) ; <nl> + <nl> + String tableName = " RowCacheSpace " ; <nl> + String cfName = " CachedCF " ; <nl> + Table table = Table . open ( tableName ) ; <nl> + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; <nl> + <nl> + DecoratedKey key = Util . dk ( " key3 " ) ; <nl> + RowMutation rm ; <nl> + <nl> + / / inserts <nl> + rm = new RowMutation ( tableName , key . key ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + rm . add ( new QueryPath ( cfName , null , ByteBuffer . wrap ( String . valueOf ( i ) . getBytes ( ) ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 0 ) ; <nl> + } <nl> + rm . apply ( ) ; <nl> + <nl> + / / move the key up in row cache <nl> + cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; <nl> + <nl> + / / deletes row <nl> + rm = new RowMutation ( tableName , key . key ) ; <nl> + rm . delete ( new QueryPath ( cfName , null , null ) , 1 ) ; <nl> + rm . apply ( ) ; <nl> + <nl> + / / flush and major compact <nl> + cfs . forceBlockingFlush ( ) ; <nl> + CompactionManager . instance . submitMajor ( cfs , 0 , Integer . MAX _ VALUE ) . get ( ) ; <nl> + / / cfs . invalidateCachedRow ( key ) ; <nl> + <nl> + / / re - inserts with timestamp lower than delete <nl> + rm = new RowMutation ( tableName , key . key ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + rm . add ( new QueryPath ( cfName , null , ByteBuffer . wrap ( String . valueOf ( i ) . getBytes ( ) ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 0 ) ; <nl> + } <nl> + rm . apply ( ) ; <nl> + <nl> + / / Check that the second insert did went in <nl> + ColumnFamily cf = cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; <nl> + assert cf . getColumnCount ( ) = = 10 ; <nl> + for ( IColumn c : cf ) <nl> + assert ! c . isMarkedForDelete ( ) ; <nl> + } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d9f8a50 . . ffff102 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 2 
 + * Fix repair hang when snapshot failed ( CASSANDRA - 10057 ) 
 * Fall back to 1 / 4 commitlog volume for commitlog _ total _ space on small disks 
 ( CASSANDRA - 10199 ) 
 Merged from 2 . 1 : 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 index 796f135 . . 41d79aa 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairMessageVerbHandler . java 
 @ @ - 88 , 7 + 88 , 7 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > 
 
 case SNAPSHOT : 
 logger . debug ( " Snapshotting { } " , desc ) ; 
 - ColumnFamilyStore cfs = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; 
 + final ColumnFamilyStore cfs = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; 
 final Range < Token > repairingRange = desc . range ; 
 Set < SSTableReader > snapshottedSSSTables = cfs . snapshot ( desc . sessionId . toString ( ) , new Predicate < SSTableReader > ( ) 
 { 
 @ @ - 103 , 8 + 103 , 13 @ @ public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > 
 Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; 
 if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) 
 { 
 + / / clear snapshot that we just created 
 + cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; 
 logger . error ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 - throw new RuntimeException ( " Cannot start multiple repair sessions over the same sstables " ) ; 
 + MessageOut reply = new MessageOut ( MessagingService . Verb . INTERNAL _ RESPONSE ) 
 + . withParameter ( MessagingService . FAILURE _ RESPONSE _ PARAM , MessagingService . ONE _ BYTE ) ; 
 + MessagingService . instance ( ) . sendReply ( reply , id , message . from ) ; 
 + return ; 
 } 
 ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; 
 logger . debug ( " Enqueuing response to snapshot request { } to { } " , desc . sessionId , message . from ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2953d40 . . 403a154 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 20 , 6 + 20 , 7 @ @ 
 get synced before server died ( CASSANDRA - 2285 ) 
 * fix fd leak in sstable2json with non - mmap ' d i / o ( CASSANDRA - 2304 ) 
 * reduce memory use during streaming of multiple sstables ( CASSANDRA - 2301 ) 
 + * purge tombstoned rows from cache after GCGraceSeconds ( CASSANDRA - 2305 ) 
 
 
 0 . 7 . 3 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 75dcf58 . . 5d299a8 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1747 , 7 + 1747 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return ssTables . getRowCache ( ) . getCapacity ( ) = = 0 ? null : ssTables . getRowCache ( ) . getInternal ( key ) ; 
 } 
 
 - void invalidateCachedRow ( DecoratedKey key ) 
 + public void invalidateCachedRow ( DecoratedKey key ) 
 { 
 ssTables . getRowCache ( ) . remove ( key ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / CompactionIterator . java b / src / java / org / apache / cassandra / io / CompactionIterator . java 
 index 88271e5 . . 128162d 100644 
 - - - a / src / java / org / apache / cassandra / io / CompactionIterator . java 
 + + + b / src / java / org / apache / cassandra / io / CompactionIterator . java 
 @ @ - 106 , 7 + 106 , 15 @ @ implements Closeable , ICompactionInfo 
 try 
 { 
 AbstractCompactedRow compactedRow = getCompactedRow ( ) ; 
 - return compactedRow . isEmpty ( ) ? null : compactedRow ; 
 + if ( compactedRow . isEmpty ( ) ) 
 + { 
 + cfs . invalidateCachedRow ( compactedRow . key ) ; 
 + return null ; 
 + } 
 + else 
 + { 
 + return compactedRow ; 
 + } 
 } 
 finally 
 { 
 diff - - git a / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java b / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java 
 index 27ca9ad . . c290b87 100644 
 - - - a / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java 
 + + + b / test / unit / org / apache / cassandra / db / CompactionsPurgeTest . java 
 @ @ - 178 , 4 + 178 , 53 @ @ public class CompactionsPurgeTest extends CleanupHelper 
 ColumnFamily cf = table . getColumnFamilyStore ( cfName ) . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; 
 assert cf = = null : cf ; 
 } 
 + 
 + @ Test 
 + public void testCompactionPurgeTombstonedRow ( ) throws IOException , ExecutionException , InterruptedException 
 + { 
 + CompactionManager . instance . disableAutoCompaction ( ) ; 
 + 
 + String tableName = " RowCacheSpace " ; 
 + String cfName = " CachedCF " ; 
 + Table table = Table . open ( tableName ) ; 
 + ColumnFamilyStore cfs = table . getColumnFamilyStore ( cfName ) ; 
 + 
 + DecoratedKey key = Util . dk ( " key3 " ) ; 
 + RowMutation rm ; 
 + 
 + / / inserts 
 + rm = new RowMutation ( tableName , key . key ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + rm . add ( new QueryPath ( cfName , null , ByteBuffer . wrap ( String . valueOf ( i ) . getBytes ( ) ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 0 ) ; 
 + } 
 + rm . apply ( ) ; 
 + 
 + / / move the key up in row cache 
 + cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; 
 + 
 + / / deletes row 
 + rm = new RowMutation ( tableName , key . key ) ; 
 + rm . delete ( new QueryPath ( cfName , null , null ) , 1 ) ; 
 + rm . apply ( ) ; 
 + 
 + / / flush and major compact 
 + cfs . forceBlockingFlush ( ) ; 
 + CompactionManager . instance . submitMajor ( cfs , 0 , Integer . MAX _ VALUE ) . get ( ) ; 
 + / / cfs . invalidateCachedRow ( key ) ; 
 + 
 + / / re - inserts with timestamp lower than delete 
 + rm = new RowMutation ( tableName , key . key ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + rm . add ( new QueryPath ( cfName , null , ByteBuffer . wrap ( String . valueOf ( i ) . getBytes ( ) ) ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 0 ) ; 
 + } 
 + rm . apply ( ) ; 
 + 
 + / / Check that the second insert did went in 
 + ColumnFamily cf = cfs . getColumnFamily ( QueryFilter . getIdentityFilter ( key , new QueryPath ( cfName ) ) ) ; 
 + assert cf . getColumnCount ( ) = = 10 ; 
 + for ( IColumn c : cf ) 
 + assert ! c . isMarkedForDelete ( ) ; 
 + } 
 }
