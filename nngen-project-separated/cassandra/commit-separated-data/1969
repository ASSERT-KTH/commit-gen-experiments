BLEU SCORE: 0.027611988917697356

TEST MSG: BTree updates may call provided update function twice
GENERATED MSG: merge from 2 . 1

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7df396d . . c5ac66c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 3 <nl> + * BTree updates may call provided update function twice ( CASSANDRA - 8018 ) <nl> * Release sstable references after anticompaction ( CASSANDRA - 8386 ) <nl> * Handle abort ( ) in SSTableRewriter properly ( CASSANDRA - 8320 ) <nl> * Fix high size calculations for prepared statements ( CASSANDRA - 8231 ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / Builder . java b / src / java / org / apache / cassandra / utils / btree / Builder . java <nl> index f6677d4 . . 0f2fd5b 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / Builder . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / Builder . java <nl> @ @ - 109 , 7 + 109 , 7 @ @ final class Builder <nl> <nl> current . reset ( EMPTY _ LEAF , POSITIVE _ INFINITY , updateF , null ) ; <nl> for ( V key : source ) <nl> - current . addNewKey ( key ) ; <nl> + current . addNewKey ( updateF . apply ( key ) ) ; <nl> <nl> current = current . ascendToRoot ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java b / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java <nl> index 9d57182 . . c715873 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java <nl> @ @ - 133 , 7 + 133 , 7 @ @ final class NodeBuilder <nl> <nl> int i = copyFromKeyPosition ; <nl> boolean found ; / / exact key match ? <nl> - boolean owns = true ; / / true iff this node ( or a child ) should contain the key <nl> + boolean owns = true ; / / true if this node ( or a child ) should contain the key <nl> if ( i = = copyFromKeyEnd ) <nl> { <nl> found = false ; <nl> @ @ - 185 , 7 + 185 , 7 @ @ final class NodeBuilder <nl> } <nl> else <nl> { <nl> - / / if not found , we need to apply updateFunction still <nl> + / / if not found , we still need to apply the update function <nl> key = updateFunction . apply ( key ) ; <nl> addNewKey ( key ) ; / / handles splitting parent if necessary via ensureRoom <nl> } <nl> @ @ - 319 , 7 + 319 , 7 @ @ final class NodeBuilder <nl> void addNewKey ( Object key ) <nl> { <nl> ensureRoom ( buildKeyPosition + 1 ) ; <nl> - buildKeys [ buildKeyPosition + + ] = updateFunction . apply ( key ) ; <nl> + buildKeys [ buildKeyPosition + + ] = key ; <nl> } <nl> <nl> / / copies children from copyf to the builder , up to the provided index in copyf ( exclusive ) <nl> diff - - git a / test / unit / org / apache / cassandra / utils / BTreeTest . java b / test / unit / org / apache / cassandra / utils / BTreeTest . java <nl> index a6d4528 . . e1bf388 100644 <nl> - - - a / test / unit / org / apache / cassandra / utils / BTreeTest . java <nl> + + + b / test / unit / org / apache / cassandra / utils / BTreeTest . java <nl> @ @ - 17 , 22 + 17 , 21 @ @ <nl> * / <nl> package org . apache . cassandra . utils ; <nl> <nl> - import java . util . ArrayList ; <nl> - import java . util . Comparator ; <nl> - import java . util . List ; <nl> - import java . util . Random ; <nl> + import java . util . * ; <nl> import java . util . concurrent . ThreadLocalRandom ; <nl> <nl> import org . junit . Test ; <nl> <nl> - import junit . framework . Assert ; <nl> import org . apache . cassandra . utils . btree . BTree ; <nl> import org . apache . cassandra . utils . btree . BTreeSet ; <nl> import org . apache . cassandra . utils . btree . UpdateFunction ; <nl> <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertArrayEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> public class BTreeTest <nl> { <nl> - <nl> static Integer [ ] ints = new Integer [ 20 ] ; <nl> static <nl> { <nl> @ @ - 114 , 13 + 113 , 78 @ @ public class BTreeTest <nl> } <nl> } <nl> <nl> + / * * <nl> + * Tests that the apply method of the < code > UpdateFunction < / code > is only called once with each key update . <nl> + * ( see CASSANDRA - 8018 ) . <nl> + * / <nl> + @ Test <nl> + public void testUpdate _ UpdateFunctionCallBack ( ) <nl> + { <nl> + Object [ ] btree = new Object [ 0 ] ; <nl> + CallsMonitor monitor = new CallsMonitor ( ) ; <nl> + <nl> + btree = BTree . update ( btree , CMP , Arrays . asList ( 1 ) , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , null } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; <nl> + <nl> + monitor . clear ( ) ; <nl> + btree = BTree . update ( btree , CMP , Arrays . asList ( 2 ) , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; <nl> + <nl> + / / with existing value <nl> + monitor . clear ( ) ; <nl> + btree = BTree . update ( btree , CMP , Arrays . asList ( 1 ) , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; <nl> + <nl> + / / with two non - existing values <nl> + monitor . clear ( ) ; <nl> + btree = BTree . update ( btree , CMP , Arrays . asList ( 3 , 4 ) , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , 2 , 3 , 4 } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 3 ) ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 4 ) ) ; <nl> + <nl> + / / with one existing value and one non existing value in disorder <nl> + monitor . clear ( ) ; <nl> + btree = BTree . update ( btree , CMP , Arrays . asList ( 5 , 2 ) , false , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 3 , new Object [ ] { 1 , 2 } , new Object [ ] { 4 , 5 } } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 5 ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Tests that the apply method of the < code > UpdateFunction < / code > is only called once per value with each build call . <nl> + * / <nl> + @ Test <nl> + public void testBuilding _ UpdateFunctionCallBack ( ) <nl> + { <nl> + CallsMonitor monitor = new CallsMonitor ( ) ; <nl> + Object [ ] btree = BTree . build ( Arrays . asList ( 1 ) , CMP , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , null } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; <nl> + <nl> + monitor . clear ( ) ; <nl> + btree = BTree . build ( Arrays . asList ( 1 , 2 ) , CMP , true , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; <nl> + <nl> + monitor . clear ( ) ; <nl> + btree = BTree . build ( Arrays . asList ( 3 , 1 , 2 ) , CMP , false , monitor ) ; <nl> + assertArrayEquals ( new Object [ ] { 1 , 2 , 3 , null } , btree ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; <nl> + assertEquals ( 1 , monitor . getNumberOfCalls ( 3 ) ) ; <nl> + } <nl> + <nl> private static void checkResult ( int count , Object [ ] btree ) <nl> { <nl> BTreeSet < Integer > vs = new BTreeSet < > ( btree , CMP ) ; <nl> assert vs . size ( ) = = count ; <nl> int i = 0 ; <nl> for ( Integer j : vs ) <nl> - Assert . assertEquals ( j , ints [ i + + ] ) ; <nl> + assertEquals ( j , ints [ i + + ] ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 137 , 7 + 201 , 7 @ @ public class BTreeTest <nl> Object [ ] btree = BTree . build ( ranges ( range ( 0 , 8 ) ) , cmp , true , UpdateFunction . NoOp . < String > instance ( ) ) ; <nl> BTree . update ( btree , cmp , ranges ( range ( 0 , 94 ) ) , false , new AbortAfterX ( 90 ) ) ; <nl> btree = BTree . update ( btree , cmp , ranges ( range ( 0 , 94 ) ) , false , UpdateFunction . NoOp . < String > instance ( ) ) ; <nl> - Assert . assertTrue ( BTree . isWellFormed ( btree , cmp ) ) ; <nl> + assertTrue ( BTree . isWellFormed ( btree , cmp ) ) ; <nl> } <nl> <nl> private static final class AbortAfterX implements UpdateFunction < String > <nl> @ @ - 181 , 4 + 245 , 44 @ @ public class BTreeTest <nl> } <nl> return r ; <nl> } <nl> + <nl> + / * * <nl> + * < code > UpdateFunction < / code > that count the number of call made to apply for each value . <nl> + * / <nl> + public static final class CallsMonitor implements UpdateFunction < Integer > <nl> + { <nl> + private int [ ] numberOfCalls = new int [ 20 ] ; <nl> + <nl> + public Integer apply ( Integer replacing , Integer update ) <nl> + { <nl> + numberOfCalls [ update ] = numberOfCalls [ update ] + 1 ; <nl> + return update ; <nl> + } <nl> + <nl> + public boolean abortEarly ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public void allocated ( long heapSize ) <nl> + { <nl> + <nl> + } <nl> + <nl> + public Integer apply ( Integer integer ) <nl> + { <nl> + numberOfCalls [ integer ] = numberOfCalls [ integer ] + 1 ; <nl> + return integer ; <nl> + } <nl> + <nl> + public int getNumberOfCalls ( Integer key ) <nl> + { <nl> + return numberOfCalls [ key ] ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + Arrays . fill ( numberOfCalls , 0 ) ; <nl> + } <nl> + } ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7df396d . . c5ac66c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 3 
 + * BTree updates may call provided update function twice ( CASSANDRA - 8018 ) 
 * Release sstable references after anticompaction ( CASSANDRA - 8386 ) 
 * Handle abort ( ) in SSTableRewriter properly ( CASSANDRA - 8320 ) 
 * Fix high size calculations for prepared statements ( CASSANDRA - 8231 ) 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / Builder . java b / src / java / org / apache / cassandra / utils / btree / Builder . java 
 index f6677d4 . . 0f2fd5b 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / Builder . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / Builder . java 
 @ @ - 109 , 7 + 109 , 7 @ @ final class Builder 
 
 current . reset ( EMPTY _ LEAF , POSITIVE _ INFINITY , updateF , null ) ; 
 for ( V key : source ) 
 - current . addNewKey ( key ) ; 
 + current . addNewKey ( updateF . apply ( key ) ) ; 
 
 current = current . ascendToRoot ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java b / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java 
 index 9d57182 . . c715873 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / NodeBuilder . java 
 @ @ - 133 , 7 + 133 , 7 @ @ final class NodeBuilder 
 
 int i = copyFromKeyPosition ; 
 boolean found ; / / exact key match ? 
 - boolean owns = true ; / / true iff this node ( or a child ) should contain the key 
 + boolean owns = true ; / / true if this node ( or a child ) should contain the key 
 if ( i = = copyFromKeyEnd ) 
 { 
 found = false ; 
 @ @ - 185 , 7 + 185 , 7 @ @ final class NodeBuilder 
 } 
 else 
 { 
 - / / if not found , we need to apply updateFunction still 
 + / / if not found , we still need to apply the update function 
 key = updateFunction . apply ( key ) ; 
 addNewKey ( key ) ; / / handles splitting parent if necessary via ensureRoom 
 } 
 @ @ - 319 , 7 + 319 , 7 @ @ final class NodeBuilder 
 void addNewKey ( Object key ) 
 { 
 ensureRoom ( buildKeyPosition + 1 ) ; 
 - buildKeys [ buildKeyPosition + + ] = updateFunction . apply ( key ) ; 
 + buildKeys [ buildKeyPosition + + ] = key ; 
 } 
 
 / / copies children from copyf to the builder , up to the provided index in copyf ( exclusive ) 
 diff - - git a / test / unit / org / apache / cassandra / utils / BTreeTest . java b / test / unit / org / apache / cassandra / utils / BTreeTest . java 
 index a6d4528 . . e1bf388 100644 
 - - - a / test / unit / org / apache / cassandra / utils / BTreeTest . java 
 + + + b / test / unit / org / apache / cassandra / utils / BTreeTest . java 
 @ @ - 17 , 22 + 17 , 21 @ @ 
 * / 
 package org . apache . cassandra . utils ; 
 
 - import java . util . ArrayList ; 
 - import java . util . Comparator ; 
 - import java . util . List ; 
 - import java . util . Random ; 
 + import java . util . * ; 
 import java . util . concurrent . ThreadLocalRandom ; 
 
 import org . junit . Test ; 
 
 - import junit . framework . Assert ; 
 import org . apache . cassandra . utils . btree . BTree ; 
 import org . apache . cassandra . utils . btree . BTreeSet ; 
 import org . apache . cassandra . utils . btree . UpdateFunction ; 
 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertArrayEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 public class BTreeTest 
 { 
 - 
 static Integer [ ] ints = new Integer [ 20 ] ; 
 static 
 { 
 @ @ - 114 , 13 + 113 , 78 @ @ public class BTreeTest 
 } 
 } 
 
 + / * * 
 + * Tests that the apply method of the < code > UpdateFunction < / code > is only called once with each key update . 
 + * ( see CASSANDRA - 8018 ) . 
 + * / 
 + @ Test 
 + public void testUpdate _ UpdateFunctionCallBack ( ) 
 + { 
 + Object [ ] btree = new Object [ 0 ] ; 
 + CallsMonitor monitor = new CallsMonitor ( ) ; 
 + 
 + btree = BTree . update ( btree , CMP , Arrays . asList ( 1 ) , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , null } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; 
 + 
 + monitor . clear ( ) ; 
 + btree = BTree . update ( btree , CMP , Arrays . asList ( 2 ) , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; 
 + 
 + / / with existing value 
 + monitor . clear ( ) ; 
 + btree = BTree . update ( btree , CMP , Arrays . asList ( 1 ) , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; 
 + 
 + / / with two non - existing values 
 + monitor . clear ( ) ; 
 + btree = BTree . update ( btree , CMP , Arrays . asList ( 3 , 4 ) , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , 2 , 3 , 4 } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 3 ) ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 4 ) ) ; 
 + 
 + / / with one existing value and one non existing value in disorder 
 + monitor . clear ( ) ; 
 + btree = BTree . update ( btree , CMP , Arrays . asList ( 5 , 2 ) , false , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 3 , new Object [ ] { 1 , 2 } , new Object [ ] { 4 , 5 } } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 5 ) ) ; 
 + } 
 + 
 + / * * 
 + * Tests that the apply method of the < code > UpdateFunction < / code > is only called once per value with each build call . 
 + * / 
 + @ Test 
 + public void testBuilding _ UpdateFunctionCallBack ( ) 
 + { 
 + CallsMonitor monitor = new CallsMonitor ( ) ; 
 + Object [ ] btree = BTree . build ( Arrays . asList ( 1 ) , CMP , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , null } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; 
 + 
 + monitor . clear ( ) ; 
 + btree = BTree . build ( Arrays . asList ( 1 , 2 ) , CMP , true , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , 2 } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; 
 + 
 + monitor . clear ( ) ; 
 + btree = BTree . build ( Arrays . asList ( 3 , 1 , 2 ) , CMP , false , monitor ) ; 
 + assertArrayEquals ( new Object [ ] { 1 , 2 , 3 , null } , btree ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 1 ) ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 2 ) ) ; 
 + assertEquals ( 1 , monitor . getNumberOfCalls ( 3 ) ) ; 
 + } 
 + 
 private static void checkResult ( int count , Object [ ] btree ) 
 { 
 BTreeSet < Integer > vs = new BTreeSet < > ( btree , CMP ) ; 
 assert vs . size ( ) = = count ; 
 int i = 0 ; 
 for ( Integer j : vs ) 
 - Assert . assertEquals ( j , ints [ i + + ] ) ; 
 + assertEquals ( j , ints [ i + + ] ) ; 
 } 
 
 @ Test 
 @ @ - 137 , 7 + 201 , 7 @ @ public class BTreeTest 
 Object [ ] btree = BTree . build ( ranges ( range ( 0 , 8 ) ) , cmp , true , UpdateFunction . NoOp . < String > instance ( ) ) ; 
 BTree . update ( btree , cmp , ranges ( range ( 0 , 94 ) ) , false , new AbortAfterX ( 90 ) ) ; 
 btree = BTree . update ( btree , cmp , ranges ( range ( 0 , 94 ) ) , false , UpdateFunction . NoOp . < String > instance ( ) ) ; 
 - Assert . assertTrue ( BTree . isWellFormed ( btree , cmp ) ) ; 
 + assertTrue ( BTree . isWellFormed ( btree , cmp ) ) ; 
 } 
 
 private static final class AbortAfterX implements UpdateFunction < String > 
 @ @ - 181 , 4 + 245 , 44 @ @ public class BTreeTest 
 } 
 return r ; 
 } 
 + 
 + / * * 
 + * < code > UpdateFunction < / code > that count the number of call made to apply for each value . 
 + * / 
 + public static final class CallsMonitor implements UpdateFunction < Integer > 
 + { 
 + private int [ ] numberOfCalls = new int [ 20 ] ; 
 + 
 + public Integer apply ( Integer replacing , Integer update ) 
 + { 
 + numberOfCalls [ update ] = numberOfCalls [ update ] + 1 ; 
 + return update ; 
 + } 
 + 
 + public boolean abortEarly ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + public void allocated ( long heapSize ) 
 + { 
 + 
 + } 
 + 
 + public Integer apply ( Integer integer ) 
 + { 
 + numberOfCalls [ integer ] = numberOfCalls [ integer ] + 1 ; 
 + return integer ; 
 + } 
 + 
 + public int getNumberOfCalls ( Integer key ) 
 + { 
 + return numberOfCalls [ key ] ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + Arrays . fill ( numberOfCalls , 0 ) ; 
 + } 
 + } ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
