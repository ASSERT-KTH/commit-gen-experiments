BLEU SCORE: 0.029079340872079116

TEST MSG: Fix ReversedType . isCompatibleWith ( )
GENERATED MSG: Prevent users from creating keyspaces with LocalStrategy replication

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fe9f4e0 . . 94bdd89 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 2 . 0 . 10 <nl> + * Fix ALTER clustering column type from DateType to TimestampType when <nl> + using DESC clustering order ( CASSANRDA - 7797 ) <nl> * Stop inheriting liveRatio and liveRatioComputedAt from previous <nl> memtables ( CASSANDRA - 7796 ) <nl> * Throw EOFException if we run out of chunks in compressed datafile <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / ReversedType . java b / src / java / org / apache / cassandra / db / marshal / ReversedType . java <nl> index cd61bbe . . ffb0229 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / ReversedType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / ReversedType . java <nl> @ @ - 84 , 6 + 84 , 15 @ @ public class ReversedType < T > extends AbstractType < T > <nl> } <nl> <nl> @ Override <nl> + public boolean isCompatibleWith ( AbstractType < ? > otherType ) <nl> + { <nl> + if ( ! ( otherType instanceof ReversedType ) ) <nl> + return false ; <nl> + <nl> + return this . baseType . isCompatibleWith ( ( ( ReversedType ) otherType ) . baseType ) ; <nl> + } <nl> + <nl> + @ Override <nl> public boolean isValueCompatibleWith ( AbstractType < ? > otherType ) <nl> { <nl> return this . baseType . isValueCompatibleWith ( otherType ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / TypeTest . java b / test / unit / org / apache / cassandra / cql3 / TypeTest . java <nl> index f911a44 . . b08ca2c 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / TypeTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / TypeTest . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . cql3 ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . exceptions . RequestExecutionException ; <nl> import org . apache . cassandra . exceptions . RequestValidationException ; <nl> import org . apache . cassandra . gms . Gossiper ; <nl> @ @ - 35 , 6 + 36 , 7 @ @ import org . slf4j . LoggerFactory ; <nl> import static org . apache . cassandra . cql3 . QueryProcessor . process ; <nl> import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . fail ; <nl> <nl> public class TypeTest <nl> { <nl> @ @ - 141 , 4 + 143 , 36 @ @ public class TypeTest <nl> results = executePrepared ( prepare ( select ) , QueryOptions . DEFAULT ) ; <nl> assertEquals ( 2 , results . size ( ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + / / tests CASSANDRA - 7797 <nl> + public void testAlterReversedColumn ( ) throws Throwable <nl> + { <nl> + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ alter _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + executeSchemaChange ( " ALTER TABLE % s . test _ alter _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . TimestampType ) ' " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testIncompatibleReversedTypes ( ) throws Throwable <nl> + { <nl> + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ incompatible _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; <nl> + try <nl> + { <nl> + executeSchemaChange ( " ALTER TABLE % s . test _ incompatible _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . TimeUUIDType ) ' " ) ; <nl> + fail ( " Expected error for ALTER statement " ) ; <nl> + } <nl> + catch ( ConfigurationException e ) { } <nl> + } <nl> + <nl> + @ Test <nl> + public void testReversedAndNonReversed ( ) throws Throwable <nl> + { <nl> + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ reversed _ and _ non _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) " ) ; <nl> + try <nl> + { <nl> + executeSchemaChange ( " ALTER TABLE % s . test _ reversed _ and _ non _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . DateType ) ' " ) ; <nl> + fail ( " Expected error for ALTER statement " ) ; <nl> + } <nl> + catch ( ConfigurationException e ) { } <nl> + } <nl> } <nl> \ No newline at end of file
NEAREST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index 6e67d1a . . dcf62eb 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 31 , 6 + 31 , 9 @ @ Features <nl> only replicas known to be down when the write started were hinted . ) <nl> This means that running with read repair completely off is much more <nl> viable than before . <nl> + - A dead node may be replaced in a single step by starting a new node <nl> + with - Dcassandra . replace _ token = < token > . More details can be found at <nl> + http : / / wiki . apache . org / cassandra / Operations # Replacing _ a _ Dead _ Node <nl> <nl> Other <nl> - - - - - <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 5a86c08 . . eeb839c 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 604 , 6 + 604 , 11 @ @ public class DatabaseDescriptor <nl> return System . getProperty ( " cassandra . initial _ token " , conf . initial _ token ) ; <nl> } <nl> <nl> + public static String getReplaceToken ( ) <nl> + { <nl> + return System . getProperty ( " cassandra . replace _ token " , null ) ; <nl> + } <nl> + <nl> public static String getClusterName ( ) <nl> { <nl> return conf . cluster _ name ; <nl> diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> index 50c8057 . . 3ff5d44 100644 <nl> - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java <nl> @ @ - 41 , 6 + 41 , 7 @ @ import org . apache . cassandra . db . filter . QueryFilter ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . gms . ApplicationState ; <nl> import org . apache . cassandra . gms . FailureDetector ; <nl> import org . apache . cassandra . gms . Gossiper ; <nl> @ @ - 134 , 9 + 135 , 9 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> return true ; <nl> } <nl> <nl> - private static void deleteHint ( ByteBuffer endpointAddress , ByteBuffer hintId , long timestamp ) throws IOException <nl> + private static void deleteHint ( ByteBuffer tokenBytes , ByteBuffer hintId , long timestamp ) throws IOException <nl> { <nl> - RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , endpointAddress ) ; <nl> + RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , tokenBytes ) ; <nl> rm . delete ( new QueryPath ( HINTS _ CF , hintId ) , timestamp ) ; <nl> rm . apply ( ) ; <nl> } <nl> @ @ - 158 , 9 + 159 , 12 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> <nl> public void deleteHintsForEndpoint ( final InetAddress endpoint ) <nl> { <nl> - final String ipaddr = endpoint . getHostAddress ( ) ; <nl> + if ( ! StorageService . instance . getTokenMetadata ( ) . isMember ( endpoint ) ) <nl> + return ; <nl> + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( endpoint ) ; <nl> + ByteBuffer tokenBytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; <nl> final ColumnFamilyStore hintStore = Table . open ( Table . SYSTEM _ TABLE ) . getColumnFamilyStore ( HINTS _ CF ) ; <nl> - final RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , ByteBufferUtil . bytes ( ipaddr ) ) ; <nl> + final RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , tokenBytes ) ; <nl> rm . delete ( new QueryPath ( HINTS _ CF ) , System . currentTimeMillis ( ) ) ; <nl> <nl> / / execute asynchronously to avoid blocking caller ( which may be processing gossip ) <nl> @ @ - 170 , 14 + 174 , 14 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> { <nl> try <nl> { <nl> - logger _ . info ( " Deleting any stored hints for " + ipaddr ) ; <nl> + logger _ . info ( " Deleting any stored hints for " + endpoint ) ; <nl> rm . apply ( ) ; <nl> hintStore . forceFlush ( ) ; <nl> CompactionManager . instance . submitMaximal ( hintStore , Integer . MAX _ VALUE ) ; <nl> } <nl> catch ( Exception e ) <nl> { <nl> - logger _ . warn ( " Could not delete hints for " + ipaddr + " : " + e ) ; <nl> + logger _ . warn ( " Could not delete hints for " + endpoint + " : " + e ) ; <nl> } <nl> } <nl> } ; <nl> @ @ - 223 , 7 + 227 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> { <nl> try <nl> { <nl> - logger _ . debug ( " Checking remote schema before delivering hints " ) ; <nl> + logger _ . debug ( " Checking remote ( { } ) schema before delivering hints " , endpoint ) ; <nl> int waited = waitForSchemaAgreement ( endpoint ) ; <nl> / / sleep a random amount to stagger handoff delivery from different replicas . <nl> / / ( if we had to wait , then gossiper randomness took care of that for us already . ) <nl> @ @ - 244 , 15 + 248 , 17 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> queuedDeliveries . remove ( endpoint ) ; <nl> } <nl> <nl> - logger _ . info ( " Started hinted handoff for endpoint " + endpoint ) ; <nl> - <nl> / / 1 . Get the key of the endpoint we need to handoff <nl> / / 2 . For each column , deserialize the mutation and send it to the endpoint <nl> / / 3 . Delete the subcolumn if the write was successful <nl> / / 4 . Force a flush <nl> / / 5 . Do major compaction to clean up all deletes etc . <nl> - ByteBuffer endpointAsUTF8 = ByteBufferUtil . bytes ( endpoint . getHostAddress ( ) ) ; / / keys have to be UTF8 to make OPP happy <nl> - DecoratedKey < ? > epkey = StorageService . getPartitioner ( ) . decorateKey ( endpointAsUTF8 ) ; <nl> + <nl> + / / find the hints for the node using its token . <nl> + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( endpoint ) ; <nl> + logger _ . info ( " Started hinted handoff for token : { } with IP : { } " , token , endpoint ) ; <nl> + ByteBuffer tokenBytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; <nl> + DecoratedKey < ? > epkey = StorageService . getPartitioner ( ) . decorateKey ( tokenBytes ) ; <nl> int rowsReplayed = 0 ; <nl> ColumnFamilyStore hintStore = Table . open ( Table . SYSTEM _ TABLE ) . getColumnFamilyStore ( HINTS _ CF ) ; <nl> ByteBuffer startColumn = ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> @ @ - 282 , 7 + 288 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean <nl> <nl> if ( sendMutation ( endpoint , rm ) ) <nl> { <nl> - deleteHint ( endpointAsUTF8 , hint . name ( ) , versionColumn . timestamp ( ) ) ; <nl> + deleteHint ( tokenBytes , hint . name ( ) , versionColumn . timestamp ( ) ) ; <nl> rowsReplayed + + ; <nl> } <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / db / RowMutation . java b / src / java / org / apache / cassandra / db / RowMutation . java <nl> index bb39ce8 . . 9e180ba 100644 <nl> - - - a / src / java / org / apache / cassandra / db / RowMutation . java <nl> + + + b / src / java / org / apache / cassandra / db / RowMutation . java <nl> @ @ - 120 , 9 + 120 , 9 @ @ public class RowMutation implements IMutation , MessageProducer <nl> * } <nl> * <nl> * / <nl> - public static RowMutation hintFor ( RowMutation mutation , ByteBuffer address ) throws IOException <nl> + public static RowMutation hintFor ( RowMutation mutation , ByteBuffer token ) throws IOException <nl> { <nl> - RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , address ) ; <nl> + RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , token ) ; <nl> ByteBuffer hintId = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ; <nl> <nl> / / determine the TTL for the RowMutation <nl> diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> index 9fcf9e1 . . d957146 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java <nl> @ @ - 61 , 7 + 61 , 7 @ @ public class BootStrapper <nl> / * endpoints that need to be bootstrapped * / <nl> protected final InetAddress address ; <nl> / * tokens of the nodes being bootstrapped . * / <nl> - protected final Token token ; <nl> + protected final Token < ? > token ; <nl> protected final TokenMetadata tokenMetadata ; <nl> private static final long BOOTSTRAP _ TIMEOUT = 30000 ; / / default bootstrap timeout of 30s <nl> <nl> @ @ - 100 , 7 + 100 , 6 @ @ public class BootStrapper <nl> for ( Map . Entry < InetAddress , Collection < Range > > entry : rangesToFetch . get ( table ) ) <nl> { <nl> final InetAddress source = entry . getKey ( ) ; <nl> - Collection < Range > ranges = entry . getValue ( ) ; <nl> final Runnable callback = new Runnable ( ) <nl> { <nl> public void run ( ) <nl> @ @ - 257 , 7 + 256 , 8 @ @ public class BootStrapper <nl> { <nl> for ( InetAddress source : rangesWithSourceTarget . get ( range ) ) <nl> { <nl> - if ( failureDetector . isAlive ( source ) ) <nl> + / / ignore the local IP . . . <nl> + if ( failureDetector . isAlive ( source ) & & ! source . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> { <nl> sources . put ( source , range ) ; <nl> break ; <nl> diff - - git a / src / java / org / apache / cassandra / gms / EndpointState . java b / src / java / org / apache / cassandra / gms / EndpointState . java <nl> index 4d91ed6 . . ded6d69 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / EndpointState . java <nl> + + + b / src / java / org / apache / cassandra / gms / EndpointState . java <nl> @ @ - 98 , 7 + 98 , 7 @ @ public class EndpointState <nl> } <nl> <nl> / * getters and setters * / <nl> - long getUpdateTimestamp ( ) <nl> + public long getUpdateTimestamp ( ) <nl> { <nl> return updateTimestamp ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 79fdcae . . 9d947ea8 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 66 , 7 + 66 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> private static final DebuggableScheduledThreadPoolExecutor executor = new DebuggableScheduledThreadPoolExecutor ( " GossipTasks " ) ; <nl> <nl> static final ApplicationState [ ] STATES = ApplicationState . values ( ) ; <nl> - static final List < String > DEAD _ STATES = Arrays . asList ( VersionedValue . REMOVING _ TOKEN , VersionedValue . REMOVED _ TOKEN , VersionedValue . STATUS _ LEFT ) ; <nl> + static final List < String > DEAD _ STATES = Arrays . asList ( VersionedValue . REMOVING _ TOKEN , VersionedValue . REMOVED _ TOKEN , <nl> + VersionedValue . STATUS _ LEFT , VersionedValue . HIBERNATE ) ; <nl> <nl> private ScheduledFuture < ? > scheduledGossipTask ; <nl> public final static int intervalInMillis = 1000 ; <nl> @ @ - 726 , 10 + 727 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> * / <nl> private void handleMajorStateChange ( InetAddress ep , EndpointState epState ) <nl> { <nl> - if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState . getApplicationState ( ApplicationState . STATUS ) . value ) ) <nl> + if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState ) ) <nl> { <nl> if ( endpointStateMap . get ( ep ) ! = null ) <nl> - logger . info ( " Node { } has restarted , now UP again " , ep ) ; <nl> + logger . info ( " Node { } has restarted , now UP " , ep ) ; <nl> else <nl> logger . info ( " Node { } is now part of the cluster " , ep ) ; <nl> } <nl> @ @ - 741 , 20 + 742 , 21 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> for ( IEndpointStateChangeSubscriber subscriber : subscribers ) <nl> subscriber . onRestart ( ep , epState ) ; <nl> <nl> - if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState . getApplicationState ( ApplicationState . STATUS ) . value ) ) <nl> + if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState ) ) <nl> markAlive ( ep , epState ) ; <nl> else <nl> { <nl> logger . debug ( " Not marking " + ep + " alive due to dead state " ) ; <nl> - epState . markDead ( ) ; <nl> + markDead ( ep , epState ) ; <nl> epState . setHasToken ( true ) ; / / fat clients won ' t have a dead state <nl> } <nl> for ( IEndpointStateChangeSubscriber subscriber : subscribers ) <nl> subscriber . onJoin ( ep , epState ) ; <nl> } <nl> <nl> - private Boolean isDeadState ( String value ) <nl> + public Boolean isDeadState ( EndpointState epState ) <nl> { <nl> + String value = epState . getApplicationState ( ApplicationState . STATUS ) . value ; <nl> String [ ] pieces = value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; <nl> assert ( pieces . length > 0 ) ; <nl> String state = pieces [ 0 ] ; <nl> @ @ - 812 , 7 + 814 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> 	 } <nl> else if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " Ignoring remote version " + remoteMaxVersion + " < = " + localMaxVersion + " for " + ep ) ; <nl> - if ( ! localEpStatePtr . isAlive ( ) ) / / unless of course , it was dead <nl> + if ( ! localEpStatePtr . isAlive ( ) & & ! isDeadState ( localEpStatePtr ) ) / / unless of course , it was dead <nl> markAlive ( ep , localEpStatePtr ) ; <nl> 	 } <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> index 16a0b22 . . 0184f4d 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> @ @ - 60 , 6 + 60 , 8 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> public final static String REMOVING _ TOKEN = " removing " ; <nl> public final static String REMOVED _ TOKEN = " removed " ; <nl> <nl> + public final static String HIBERNATE = " hibernate " ; <nl> + <nl> / / values for ApplicationState . REMOVAL _ COORDINATOR <nl> public final static String REMOVAL _ COORDINATOR = " REMOVER " ; <nl> <nl> @ @ - 148 , 6 + 150 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> return new VersionedValue ( VersionedValue . REMOVAL _ COORDINATOR + VersionedValue . DELIMITER + partitioner . getTokenFactory ( ) . toString ( token ) ) ; <nl> } <nl> <nl> + public VersionedValue hibernate ( boolean value ) <nl> + { <nl> + return new VersionedValue ( VersionedValue . HIBERNATE + VersionedValue . DELIMITER + value ) ; <nl> + } <nl> + <nl> public VersionedValue datacenter ( String dcId ) <nl> { <nl> return new VersionedValue ( dcId ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / LoadBroadcaster . java b / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> index b195e7a . . 74607cd 100644 <nl> - - - a / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> + + + b / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> @ @ - 29 , 7 + 29 , 7 @ @ import org . apache . cassandra . gms . * ; <nl> <nl> public class LoadBroadcaster implements IEndpointStateChangeSubscriber <nl> { <nl> - private static final int BROADCAST _ INTERVAL = 60 * 1000 ; <nl> + static final int BROADCAST _ INTERVAL = 60 * 1000 ; <nl> <nl> public static final LoadBroadcaster instance = new LoadBroadcaster ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> index d6a94a4 . . 9a6b013 100644 <nl> - - - a / src / java / org / apache / cassandra / service / MigrationManager . java <nl> + + + b / src / java / org / apache / cassandra / service / MigrationManager . java <nl> @ @ - 54 , 8 + 54 , 14 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber <nl> / / avoids re - pushing migrations that we ' re waiting on target to apply already <nl> private static Map < InetAddress , UUID > lastPushed = new MapMaker ( ) . expiration ( 1 , TimeUnit . MINUTES ) . makeMap ( ) ; <nl> <nl> - / * * I ' m not going to act here . * / <nl> - public void onJoin ( InetAddress endpoint , EndpointState epState ) { } <nl> + public void onJoin ( InetAddress endpoint , EndpointState epState ) { <nl> + VersionedValue value = epState . getApplicationState ( ApplicationState . SCHEMA ) ; <nl> + if ( value ! = null ) <nl> + { <nl> + UUID theirVersion = UUID . fromString ( value . value ) ; <nl> + rectify ( theirVersion , endpoint ) ; <nl> + } <nl> + } <nl> <nl> public void onChange ( InetAddress endpoint , ApplicationState state , VersionedValue value ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index d7465fb . . 5543577 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 346 , 7 + 346 , 9 @ @ public class StorageProxy implements StorageProxyMBean <nl> <nl> try <nl> { <nl> - RowMutation hintedMutation = RowMutation . hintFor ( mutation , ByteBufferUtil . bytes ( target . getHostAddress ( ) ) ) ; <nl> + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( target ) ; <nl> + ByteBuffer tokenbytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; <nl> + RowMutation hintedMutation = RowMutation . hintFor ( mutation , tokenbytes ) ; <nl> hintedMutation . apply ( ) ; <nl> <nl> totalHints . incrementAndGet ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 79454a1 . . e47921c 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 205 , 9 + 205 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> public void finishBootstrapping ( ) <nl> { <nl> isBootstrapMode = false ; <nl> - SystemTable . setBootstrapped ( true ) ; <nl> - setToken ( getLocalToken ( ) ) ; <nl> - logger _ . info ( " Bootstrap / move completed ! Now serving reads . " ) ; <nl> } <nl> <nl> / * * This method updates the local token on disk * / <nl> @ @ - 471 , 6 + 468 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> Gossiper . instance . start ( SystemTable . incrementAndGetGeneration ( ) ) ; / / needed for node - ring gathering . <nl> / / add rpc listening info <nl> Gossiper . instance . addLocalApplicationState ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; <nl> + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . hibernate ( null ! = DatabaseDescriptor . getReplaceToken ( ) ) ) ; <nl> <nl> MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; <nl> LoadBroadcaster . instance . startBroadcasting ( ) ; <nl> @ @ - 484 , 7 + 482 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> & & ! SystemTable . isBootstrapped ( ) ) <nl> logger _ . info ( " This node will not auto bootstrap because it is configured to be a seed node . " ) ; <nl> <nl> - Token token ; <nl> + / / first startup is only chance to bootstrap <nl> + Token < ? > token ; <nl> if ( DatabaseDescriptor . isAutoBootstrap ( ) <nl> & & ! ( DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) | | SystemTable . isBootstrapped ( ) ) ) <nl> { <nl> @ @ - 499 , 25 + 498 , 42 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " . . . got ring + schema info " ) ; <nl> - if ( tokenMetadata _ . isMember ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> + if ( null ! = DatabaseDescriptor . getReplaceToken ( ) ) <nl> { <nl> - String s = " This node is already a member of the token ring ; bootstrap aborted . ( If replacing a dead node , remove the old one from the ring first . ) " ; <nl> - throw new UnsupportedOperationException ( s ) ; <nl> + try <nl> + { <nl> + / / Sleeping additionally to make sure that the server actually is not alive <nl> + / / and giving it more time to gossip if alive . <nl> + Thread . sleep ( LoadBroadcaster . BROADCAST _ INTERVAL ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + token = StorageService . getPartitioner ( ) . getTokenFactory ( ) . fromString ( DatabaseDescriptor . getReplaceToken ( ) ) ; <nl> + / / check for operator errors . . . <nl> + InetAddress current = tokenMetadata _ . getEndpoint ( token ) ; <nl> + if ( null ! = current & & Gossiper . instance . getEndpointStateForEndpoint ( current ) . getUpdateTimestamp ( ) > ( System . currentTimeMillis ( ) - delay ) ) <nl> + throw new UnsupportedOperationException ( " Cannnot replace a token for a Live node . . . " ) ; <nl> + setMode ( " Joining : Replacing a node with token : " + token , true ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( tokenMetadata _ . isMember ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> + { <nl> + String s = " This node is already a member of the token ring ; bootstrap aborted . ( If replacing a dead node , remove the old one from the ring first . ) " ; <nl> + throw new UnsupportedOperationException ( s ) ; <nl> + } <nl> + setMode ( " Joining : getting bootstrap token " , true ) ; <nl> + token = BootStrapper . getBootstrapToken ( tokenMetadata _ , LoadBroadcaster . instance . getLoadInfo ( ) ) ; <nl> } <nl> - setMode ( " Joining : getting bootstrap token " , true ) ; <nl> - token = BootStrapper . getBootstrapToken ( tokenMetadata _ , LoadBroadcaster . instance . getLoadInfo ( ) ) ; <nl> / / don ' t bootstrap if there are no tables defined . <nl> if ( Schema . instance . getNonSystemTables ( ) . size ( ) > 0 ) <nl> { <nl> bootstrap ( token ) ; <nl> assert ! isBootstrapMode ; / / bootstrap will block until finished <nl> } <nl> - else <nl> - { <nl> - / / nothing to bootstrap , go directly to participating in ring <nl> - SystemTable . setBootstrapped ( true ) ; <nl> - setToken ( token ) ; <nl> - } <nl> + / / Else : nothing to bootstrap , go directly to participating in ring <nl> } <nl> else <nl> { <nl> @ @ - 542 , 8 + 558 , 10 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> } <nl> <nl> - SystemTable . setBootstrapped ( true ) ; / / first startup is only chance to bootstrap <nl> + / / start participating in the ring . <nl> + SystemTable . setBootstrapped ( true ) ; <nl> setToken ( token ) ; <nl> + logger _ . info ( " Bootstrap / Replace / Move completed ! Now serving reads . " ) ; <nl> assert tokenMetadata _ . sortedTokens ( ) . size ( ) > 0 ; <nl> } <nl> <nl> @ @ - 578 , 17 + 596 , 26 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> { <nl> isBootstrapMode = true ; <nl> SystemTable . updateToken ( token ) ; / / DON ' T use setToken , that makes us part of the ring locally which is incorrect until we are done bootstrapping <nl> - Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . bootstrapping ( token ) ) ; <nl> - setMode ( " Joining : sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; <nl> - try <nl> + if ( null = = DatabaseDescriptor . getReplaceToken ( ) ) <nl> { <nl> - Thread . sleep ( RING _ DELAY ) ; <nl> + / / if not an existing token then bootstrap <nl> + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . bootstrapping ( token ) ) ; <nl> + setMode ( " Joining : sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; <nl> + try <nl> + { <nl> + Thread . sleep ( RING _ DELAY ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> } <nl> - catch ( InterruptedException e ) <nl> + else <nl> { <nl> - throw new AssertionError ( e ) ; <nl> + / / Dont set any state for the node which is bootstrapping the existing token . . . <nl> + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> - setMode ( " Bootstrapping " , true ) ; <nl> + setMode ( " Starting to bootstrap . . . " , true ) ; <nl> new BootStrapper ( FBUtilities . getBroadcastAddress ( ) , token , tokenMetadata _ ) . bootstrap ( ) ; / / handles token update <nl> } <nl> <nl> @ @ - 993 , 9 + 1020 , 9 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> <nl> private void excise ( Token token , InetAddress endpoint ) <nl> { <nl> + HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; <nl> Gossiper . instance . removeEndpoint ( endpoint ) ; <nl> tokenMetadata _ . removeEndpoint ( endpoint ) ; <nl> - HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; <nl> tokenMetadata _ . removeBootstrapToken ( token ) ; <nl> calculatePendingRanges ( ) ; <nl> if ( ! isClientMode )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fe9f4e0 . . 94bdd89 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 2 . 0 . 10 
 + * Fix ALTER clustering column type from DateType to TimestampType when 
 + using DESC clustering order ( CASSANRDA - 7797 ) 
 * Stop inheriting liveRatio and liveRatioComputedAt from previous 
 memtables ( CASSANDRA - 7796 ) 
 * Throw EOFException if we run out of chunks in compressed datafile 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / ReversedType . java b / src / java / org / apache / cassandra / db / marshal / ReversedType . java 
 index cd61bbe . . ffb0229 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / ReversedType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / ReversedType . java 
 @ @ - 84 , 6 + 84 , 15 @ @ public class ReversedType < T > extends AbstractType < T > 
 } 
 
 @ Override 
 + public boolean isCompatibleWith ( AbstractType < ? > otherType ) 
 + { 
 + if ( ! ( otherType instanceof ReversedType ) ) 
 + return false ; 
 + 
 + return this . baseType . isCompatibleWith ( ( ( ReversedType ) otherType ) . baseType ) ; 
 + } 
 + 
 + @ Override 
 public boolean isValueCompatibleWith ( AbstractType < ? > otherType ) 
 { 
 return this . baseType . isValueCompatibleWith ( otherType ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / TypeTest . java b / test / unit / org / apache / cassandra / cql3 / TypeTest . java 
 index f911a44 . . b08ca2c 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / TypeTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / TypeTest . java 
 @ @ - 19 , 6 + 19 , 7 @ @ package org . apache . cassandra . cql3 ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . exceptions . RequestExecutionException ; 
 import org . apache . cassandra . exceptions . RequestValidationException ; 
 import org . apache . cassandra . gms . Gossiper ; 
 @ @ - 35 , 6 + 36 , 7 @ @ import org . slf4j . LoggerFactory ; 
 import static org . apache . cassandra . cql3 . QueryProcessor . process ; 
 import static org . apache . cassandra . cql3 . QueryProcessor . processInternal ; 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . fail ; 
 
 public class TypeTest 
 { 
 @ @ - 141 , 4 + 143 , 36 @ @ public class TypeTest 
 results = executePrepared ( prepare ( select ) , QueryOptions . DEFAULT ) ; 
 assertEquals ( 2 , results . size ( ) ) ; 
 } 
 + 
 + @ Test 
 + / / tests CASSANDRA - 7797 
 + public void testAlterReversedColumn ( ) throws Throwable 
 + { 
 + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ alter _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + executeSchemaChange ( " ALTER TABLE % s . test _ alter _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . TimestampType ) ' " ) ; 
 + } 
 + 
 + @ Test 
 + public void testIncompatibleReversedTypes ( ) throws Throwable 
 + { 
 + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ incompatible _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) WITH CLUSTERING ORDER BY ( b DESC ) " ) ; 
 + try 
 + { 
 + executeSchemaChange ( " ALTER TABLE % s . test _ incompatible _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . TimeUUIDType ) ' " ) ; 
 + fail ( " Expected error for ALTER statement " ) ; 
 + } 
 + catch ( ConfigurationException e ) { } 
 + } 
 + 
 + @ Test 
 + public void testReversedAndNonReversed ( ) throws Throwable 
 + { 
 + executeSchemaChange ( " CREATE TABLE IF NOT EXISTS % s . test _ reversed _ and _ non _ reversed ( a int , b ' org . apache . cassandra . db . marshal . DateType ' , PRIMARY KEY ( a , b ) ) " ) ; 
 + try 
 + { 
 + executeSchemaChange ( " ALTER TABLE % s . test _ reversed _ and _ non _ reversed ALTER b TYPE ' org . apache . cassandra . db . marshal . ReversedType ( org . apache . cassandra . db . marshal . DateType ) ' " ) ; 
 + fail ( " Expected error for ALTER statement " ) ; 
 + } 
 + catch ( ConfigurationException e ) { } 
 + } 
 } 
 \ No newline at end of file

NEAREST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index 6e67d1a . . dcf62eb 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 31 , 6 + 31 , 9 @ @ Features 
 only replicas known to be down when the write started were hinted . ) 
 This means that running with read repair completely off is much more 
 viable than before . 
 + - A dead node may be replaced in a single step by starting a new node 
 + with - Dcassandra . replace _ token = < token > . More details can be found at 
 + http : / / wiki . apache . org / cassandra / Operations # Replacing _ a _ Dead _ Node 
 
 Other 
 - - - - - 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 5a86c08 . . eeb839c 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 604 , 6 + 604 , 11 @ @ public class DatabaseDescriptor 
 return System . getProperty ( " cassandra . initial _ token " , conf . initial _ token ) ; 
 } 
 
 + public static String getReplaceToken ( ) 
 + { 
 + return System . getProperty ( " cassandra . replace _ token " , null ) ; 
 + } 
 + 
 public static String getClusterName ( ) 
 { 
 return conf . cluster _ name ; 
 diff - - git a / src / java / org / apache / cassandra / db / HintedHandOffManager . java b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 index 50c8057 . . 3ff5d44 100644 
 - - - a / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 + + + b / src / java / org / apache / cassandra / db / HintedHandOffManager . java 
 @ @ - 41 , 6 + 41 , 7 @ @ import org . apache . cassandra . db . filter . QueryFilter ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . gms . ApplicationState ; 
 import org . apache . cassandra . gms . FailureDetector ; 
 import org . apache . cassandra . gms . Gossiper ; 
 @ @ - 134 , 9 + 135 , 9 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 return true ; 
 } 
 
 - private static void deleteHint ( ByteBuffer endpointAddress , ByteBuffer hintId , long timestamp ) throws IOException 
 + private static void deleteHint ( ByteBuffer tokenBytes , ByteBuffer hintId , long timestamp ) throws IOException 
 { 
 - RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , endpointAddress ) ; 
 + RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , tokenBytes ) ; 
 rm . delete ( new QueryPath ( HINTS _ CF , hintId ) , timestamp ) ; 
 rm . apply ( ) ; 
 } 
 @ @ - 158 , 9 + 159 , 12 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 
 public void deleteHintsForEndpoint ( final InetAddress endpoint ) 
 { 
 - final String ipaddr = endpoint . getHostAddress ( ) ; 
 + if ( ! StorageService . instance . getTokenMetadata ( ) . isMember ( endpoint ) ) 
 + return ; 
 + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( endpoint ) ; 
 + ByteBuffer tokenBytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; 
 final ColumnFamilyStore hintStore = Table . open ( Table . SYSTEM _ TABLE ) . getColumnFamilyStore ( HINTS _ CF ) ; 
 - final RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , ByteBufferUtil . bytes ( ipaddr ) ) ; 
 + final RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , tokenBytes ) ; 
 rm . delete ( new QueryPath ( HINTS _ CF ) , System . currentTimeMillis ( ) ) ; 
 
 / / execute asynchronously to avoid blocking caller ( which may be processing gossip ) 
 @ @ - 170 , 14 + 174 , 14 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 { 
 try 
 { 
 - logger _ . info ( " Deleting any stored hints for " + ipaddr ) ; 
 + logger _ . info ( " Deleting any stored hints for " + endpoint ) ; 
 rm . apply ( ) ; 
 hintStore . forceFlush ( ) ; 
 CompactionManager . instance . submitMaximal ( hintStore , Integer . MAX _ VALUE ) ; 
 } 
 catch ( Exception e ) 
 { 
 - logger _ . warn ( " Could not delete hints for " + ipaddr + " : " + e ) ; 
 + logger _ . warn ( " Could not delete hints for " + endpoint + " : " + e ) ; 
 } 
 } 
 } ; 
 @ @ - 223 , 7 + 227 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 { 
 try 
 { 
 - logger _ . debug ( " Checking remote schema before delivering hints " ) ; 
 + logger _ . debug ( " Checking remote ( { } ) schema before delivering hints " , endpoint ) ; 
 int waited = waitForSchemaAgreement ( endpoint ) ; 
 / / sleep a random amount to stagger handoff delivery from different replicas . 
 / / ( if we had to wait , then gossiper randomness took care of that for us already . ) 
 @ @ - 244 , 15 + 248 , 17 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 queuedDeliveries . remove ( endpoint ) ; 
 } 
 
 - logger _ . info ( " Started hinted handoff for endpoint " + endpoint ) ; 
 - 
 / / 1 . Get the key of the endpoint we need to handoff 
 / / 2 . For each column , deserialize the mutation and send it to the endpoint 
 / / 3 . Delete the subcolumn if the write was successful 
 / / 4 . Force a flush 
 / / 5 . Do major compaction to clean up all deletes etc . 
 - ByteBuffer endpointAsUTF8 = ByteBufferUtil . bytes ( endpoint . getHostAddress ( ) ) ; / / keys have to be UTF8 to make OPP happy 
 - DecoratedKey < ? > epkey = StorageService . getPartitioner ( ) . decorateKey ( endpointAsUTF8 ) ; 
 + 
 + / / find the hints for the node using its token . 
 + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( endpoint ) ; 
 + logger _ . info ( " Started hinted handoff for token : { } with IP : { } " , token , endpoint ) ; 
 + ByteBuffer tokenBytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; 
 + DecoratedKey < ? > epkey = StorageService . getPartitioner ( ) . decorateKey ( tokenBytes ) ; 
 int rowsReplayed = 0 ; 
 ColumnFamilyStore hintStore = Table . open ( Table . SYSTEM _ TABLE ) . getColumnFamilyStore ( HINTS _ CF ) ; 
 ByteBuffer startColumn = ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 @ @ - 282 , 7 + 288 , 7 @ @ public class HintedHandOffManager implements HintedHandOffManagerMBean 
 
 if ( sendMutation ( endpoint , rm ) ) 
 { 
 - deleteHint ( endpointAsUTF8 , hint . name ( ) , versionColumn . timestamp ( ) ) ; 
 + deleteHint ( tokenBytes , hint . name ( ) , versionColumn . timestamp ( ) ) ; 
 rowsReplayed + + ; 
 } 
 else 
 diff - - git a / src / java / org / apache / cassandra / db / RowMutation . java b / src / java / org / apache / cassandra / db / RowMutation . java 
 index bb39ce8 . . 9e180ba 100644 
 - - - a / src / java / org / apache / cassandra / db / RowMutation . java 
 + + + b / src / java / org / apache / cassandra / db / RowMutation . java 
 @ @ - 120 , 9 + 120 , 9 @ @ public class RowMutation implements IMutation , MessageProducer 
 * } 
 * 
 * / 
 - public static RowMutation hintFor ( RowMutation mutation , ByteBuffer address ) throws IOException 
 + public static RowMutation hintFor ( RowMutation mutation , ByteBuffer token ) throws IOException 
 { 
 - RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , address ) ; 
 + RowMutation rm = new RowMutation ( Table . SYSTEM _ TABLE , token ) ; 
 ByteBuffer hintId = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ; 
 
 / / determine the TTL for the RowMutation 
 diff - - git a / src / java / org / apache / cassandra / dht / BootStrapper . java b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 index 9fcf9e1 . . d957146 100644 
 - - - a / src / java / org / apache / cassandra / dht / BootStrapper . java 
 + + + b / src / java / org / apache / cassandra / dht / BootStrapper . java 
 @ @ - 61 , 7 + 61 , 7 @ @ public class BootStrapper 
 / * endpoints that need to be bootstrapped * / 
 protected final InetAddress address ; 
 / * tokens of the nodes being bootstrapped . * / 
 - protected final Token token ; 
 + protected final Token < ? > token ; 
 protected final TokenMetadata tokenMetadata ; 
 private static final long BOOTSTRAP _ TIMEOUT = 30000 ; / / default bootstrap timeout of 30s 
 
 @ @ - 100 , 7 + 100 , 6 @ @ public class BootStrapper 
 for ( Map . Entry < InetAddress , Collection < Range > > entry : rangesToFetch . get ( table ) ) 
 { 
 final InetAddress source = entry . getKey ( ) ; 
 - Collection < Range > ranges = entry . getValue ( ) ; 
 final Runnable callback = new Runnable ( ) 
 { 
 public void run ( ) 
 @ @ - 257 , 7 + 256 , 8 @ @ public class BootStrapper 
 { 
 for ( InetAddress source : rangesWithSourceTarget . get ( range ) ) 
 { 
 - if ( failureDetector . isAlive ( source ) ) 
 + / / ignore the local IP . . . 
 + if ( failureDetector . isAlive ( source ) & & ! source . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 { 
 sources . put ( source , range ) ; 
 break ; 
 diff - - git a / src / java / org / apache / cassandra / gms / EndpointState . java b / src / java / org / apache / cassandra / gms / EndpointState . java 
 index 4d91ed6 . . ded6d69 100644 
 - - - a / src / java / org / apache / cassandra / gms / EndpointState . java 
 + + + b / src / java / org / apache / cassandra / gms / EndpointState . java 
 @ @ - 98 , 7 + 98 , 7 @ @ public class EndpointState 
 } 
 
 / * getters and setters * / 
 - long getUpdateTimestamp ( ) 
 + public long getUpdateTimestamp ( ) 
 { 
 return updateTimestamp ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 79fdcae . . 9d947ea8 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 66 , 7 + 66 , 8 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 private static final DebuggableScheduledThreadPoolExecutor executor = new DebuggableScheduledThreadPoolExecutor ( " GossipTasks " ) ; 
 
 static final ApplicationState [ ] STATES = ApplicationState . values ( ) ; 
 - static final List < String > DEAD _ STATES = Arrays . asList ( VersionedValue . REMOVING _ TOKEN , VersionedValue . REMOVED _ TOKEN , VersionedValue . STATUS _ LEFT ) ; 
 + static final List < String > DEAD _ STATES = Arrays . asList ( VersionedValue . REMOVING _ TOKEN , VersionedValue . REMOVED _ TOKEN , 
 + VersionedValue . STATUS _ LEFT , VersionedValue . HIBERNATE ) ; 
 
 private ScheduledFuture < ? > scheduledGossipTask ; 
 public final static int intervalInMillis = 1000 ; 
 @ @ - 726 , 10 + 727 , 10 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 * / 
 private void handleMajorStateChange ( InetAddress ep , EndpointState epState ) 
 { 
 - if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState . getApplicationState ( ApplicationState . STATUS ) . value ) ) 
 + if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState ) ) 
 { 
 if ( endpointStateMap . get ( ep ) ! = null ) 
 - logger . info ( " Node { } has restarted , now UP again " , ep ) ; 
 + logger . info ( " Node { } has restarted , now UP " , ep ) ; 
 else 
 logger . info ( " Node { } is now part of the cluster " , ep ) ; 
 } 
 @ @ - 741 , 20 + 742 , 21 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 for ( IEndpointStateChangeSubscriber subscriber : subscribers ) 
 subscriber . onRestart ( ep , epState ) ; 
 
 - if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState . getApplicationState ( ApplicationState . STATUS ) . value ) ) 
 + if ( epState . getApplicationState ( ApplicationState . STATUS ) ! = null & & ! isDeadState ( epState ) ) 
 markAlive ( ep , epState ) ; 
 else 
 { 
 logger . debug ( " Not marking " + ep + " alive due to dead state " ) ; 
 - epState . markDead ( ) ; 
 + markDead ( ep , epState ) ; 
 epState . setHasToken ( true ) ; / / fat clients won ' t have a dead state 
 } 
 for ( IEndpointStateChangeSubscriber subscriber : subscribers ) 
 subscriber . onJoin ( ep , epState ) ; 
 } 
 
 - private Boolean isDeadState ( String value ) 
 + public Boolean isDeadState ( EndpointState epState ) 
 { 
 + String value = epState . getApplicationState ( ApplicationState . STATUS ) . value ; 
 String [ ] pieces = value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; 
 assert ( pieces . length > 0 ) ; 
 String state = pieces [ 0 ] ; 
 @ @ - 812 , 7 + 814 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 	 } 
 else if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " Ignoring remote version " + remoteMaxVersion + " < = " + localMaxVersion + " for " + ep ) ; 
 - if ( ! localEpStatePtr . isAlive ( ) ) / / unless of course , it was dead 
 + if ( ! localEpStatePtr . isAlive ( ) & & ! isDeadState ( localEpStatePtr ) ) / / unless of course , it was dead 
 markAlive ( ep , localEpStatePtr ) ; 
 	 } 
 else 
 diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 index 16a0b22 . . 0184f4d 100644 
 - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java 
 + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 @ @ - 60 , 6 + 60 , 8 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 public final static String REMOVING _ TOKEN = " removing " ; 
 public final static String REMOVED _ TOKEN = " removed " ; 
 
 + public final static String HIBERNATE = " hibernate " ; 
 + 
 / / values for ApplicationState . REMOVAL _ COORDINATOR 
 public final static String REMOVAL _ COORDINATOR = " REMOVER " ; 
 
 @ @ - 148 , 6 + 150 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 return new VersionedValue ( VersionedValue . REMOVAL _ COORDINATOR + VersionedValue . DELIMITER + partitioner . getTokenFactory ( ) . toString ( token ) ) ; 
 } 
 
 + public VersionedValue hibernate ( boolean value ) 
 + { 
 + return new VersionedValue ( VersionedValue . HIBERNATE + VersionedValue . DELIMITER + value ) ; 
 + } 
 + 
 public VersionedValue datacenter ( String dcId ) 
 { 
 return new VersionedValue ( dcId ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / LoadBroadcaster . java b / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 index b195e7a . . 74607cd 100644 
 - - - a / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 + + + b / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 @ @ - 29 , 7 + 29 , 7 @ @ import org . apache . cassandra . gms . * ; 
 
 public class LoadBroadcaster implements IEndpointStateChangeSubscriber 
 { 
 - private static final int BROADCAST _ INTERVAL = 60 * 1000 ; 
 + static final int BROADCAST _ INTERVAL = 60 * 1000 ; 
 
 public static final LoadBroadcaster instance = new LoadBroadcaster ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / service / MigrationManager . java b / src / java / org / apache / cassandra / service / MigrationManager . java 
 index d6a94a4 . . 9a6b013 100644 
 - - - a / src / java / org / apache / cassandra / service / MigrationManager . java 
 + + + b / src / java / org / apache / cassandra / service / MigrationManager . java 
 @ @ - 54 , 8 + 54 , 14 @ @ public class MigrationManager implements IEndpointStateChangeSubscriber 
 / / avoids re - pushing migrations that we ' re waiting on target to apply already 
 private static Map < InetAddress , UUID > lastPushed = new MapMaker ( ) . expiration ( 1 , TimeUnit . MINUTES ) . makeMap ( ) ; 
 
 - / * * I ' m not going to act here . * / 
 - public void onJoin ( InetAddress endpoint , EndpointState epState ) { } 
 + public void onJoin ( InetAddress endpoint , EndpointState epState ) { 
 + VersionedValue value = epState . getApplicationState ( ApplicationState . SCHEMA ) ; 
 + if ( value ! = null ) 
 + { 
 + UUID theirVersion = UUID . fromString ( value . value ) ; 
 + rectify ( theirVersion , endpoint ) ; 
 + } 
 + } 
 
 public void onChange ( InetAddress endpoint , ApplicationState state , VersionedValue value ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index d7465fb . . 5543577 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 346 , 7 + 346 , 9 @ @ public class StorageProxy implements StorageProxyMBean 
 
 try 
 { 
 - RowMutation hintedMutation = RowMutation . hintFor ( mutation , ByteBufferUtil . bytes ( target . getHostAddress ( ) ) ) ; 
 + Token < ? > token = StorageService . instance . getTokenMetadata ( ) . getToken ( target ) ; 
 + ByteBuffer tokenbytes = StorageService . getPartitioner ( ) . getTokenFactory ( ) . toByteArray ( token ) ; 
 + RowMutation hintedMutation = RowMutation . hintFor ( mutation , tokenbytes ) ; 
 hintedMutation . apply ( ) ; 
 
 totalHints . incrementAndGet ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 79454a1 . . e47921c 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 205 , 9 + 205 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 public void finishBootstrapping ( ) 
 { 
 isBootstrapMode = false ; 
 - SystemTable . setBootstrapped ( true ) ; 
 - setToken ( getLocalToken ( ) ) ; 
 - logger _ . info ( " Bootstrap / move completed ! Now serving reads . " ) ; 
 } 
 
 / * * This method updates the local token on disk * / 
 @ @ - 471 , 6 + 468 , 7 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 Gossiper . instance . start ( SystemTable . incrementAndGetGeneration ( ) ) ; / / needed for node - ring gathering . 
 / / add rpc listening info 
 Gossiper . instance . addLocalApplicationState ( ApplicationState . RPC _ ADDRESS , valueFactory . rpcaddress ( DatabaseDescriptor . getRpcAddress ( ) ) ) ; 
 + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . hibernate ( null ! = DatabaseDescriptor . getReplaceToken ( ) ) ) ; 
 
 MessagingService . instance ( ) . listen ( FBUtilities . getLocalAddress ( ) ) ; 
 LoadBroadcaster . instance . startBroadcasting ( ) ; 
 @ @ - 484 , 7 + 482 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 & & ! SystemTable . isBootstrapped ( ) ) 
 logger _ . info ( " This node will not auto bootstrap because it is configured to be a seed node . " ) ; 
 
 - Token token ; 
 + / / first startup is only chance to bootstrap 
 + Token < ? > token ; 
 if ( DatabaseDescriptor . isAutoBootstrap ( ) 
 & & ! ( DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) | | SystemTable . isBootstrapped ( ) ) ) 
 { 
 @ @ - 499 , 25 + 498 , 42 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " . . . got ring + schema info " ) ; 
 - if ( tokenMetadata _ . isMember ( FBUtilities . getBroadcastAddress ( ) ) ) 
 + if ( null ! = DatabaseDescriptor . getReplaceToken ( ) ) 
 { 
 - String s = " This node is already a member of the token ring ; bootstrap aborted . ( If replacing a dead node , remove the old one from the ring first . ) " ; 
 - throw new UnsupportedOperationException ( s ) ; 
 + try 
 + { 
 + / / Sleeping additionally to make sure that the server actually is not alive 
 + / / and giving it more time to gossip if alive . 
 + Thread . sleep ( LoadBroadcaster . BROADCAST _ INTERVAL ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + token = StorageService . getPartitioner ( ) . getTokenFactory ( ) . fromString ( DatabaseDescriptor . getReplaceToken ( ) ) ; 
 + / / check for operator errors . . . 
 + InetAddress current = tokenMetadata _ . getEndpoint ( token ) ; 
 + if ( null ! = current & & Gossiper . instance . getEndpointStateForEndpoint ( current ) . getUpdateTimestamp ( ) > ( System . currentTimeMillis ( ) - delay ) ) 
 + throw new UnsupportedOperationException ( " Cannnot replace a token for a Live node . . . " ) ; 
 + setMode ( " Joining : Replacing a node with token : " + token , true ) ; 
 + } 
 + else 
 + { 
 + if ( tokenMetadata _ . isMember ( FBUtilities . getBroadcastAddress ( ) ) ) 
 + { 
 + String s = " This node is already a member of the token ring ; bootstrap aborted . ( If replacing a dead node , remove the old one from the ring first . ) " ; 
 + throw new UnsupportedOperationException ( s ) ; 
 + } 
 + setMode ( " Joining : getting bootstrap token " , true ) ; 
 + token = BootStrapper . getBootstrapToken ( tokenMetadata _ , LoadBroadcaster . instance . getLoadInfo ( ) ) ; 
 } 
 - setMode ( " Joining : getting bootstrap token " , true ) ; 
 - token = BootStrapper . getBootstrapToken ( tokenMetadata _ , LoadBroadcaster . instance . getLoadInfo ( ) ) ; 
 / / don ' t bootstrap if there are no tables defined . 
 if ( Schema . instance . getNonSystemTables ( ) . size ( ) > 0 ) 
 { 
 bootstrap ( token ) ; 
 assert ! isBootstrapMode ; / / bootstrap will block until finished 
 } 
 - else 
 - { 
 - / / nothing to bootstrap , go directly to participating in ring 
 - SystemTable . setBootstrapped ( true ) ; 
 - setToken ( token ) ; 
 - } 
 + / / Else : nothing to bootstrap , go directly to participating in ring 
 } 
 else 
 { 
 @ @ - 542 , 8 + 558 , 10 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 } 
 
 - SystemTable . setBootstrapped ( true ) ; / / first startup is only chance to bootstrap 
 + / / start participating in the ring . 
 + SystemTable . setBootstrapped ( true ) ; 
 setToken ( token ) ; 
 + logger _ . info ( " Bootstrap / Replace / Move completed ! Now serving reads . " ) ; 
 assert tokenMetadata _ . sortedTokens ( ) . size ( ) > 0 ; 
 } 
 
 @ @ - 578 , 17 + 596 , 26 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 { 
 isBootstrapMode = true ; 
 SystemTable . updateToken ( token ) ; / / DON ' T use setToken , that makes us part of the ring locally which is incorrect until we are done bootstrapping 
 - Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . bootstrapping ( token ) ) ; 
 - setMode ( " Joining : sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; 
 - try 
 + if ( null = = DatabaseDescriptor . getReplaceToken ( ) ) 
 { 
 - Thread . sleep ( RING _ DELAY ) ; 
 + / / if not an existing token then bootstrap 
 + Gossiper . instance . addLocalApplicationState ( ApplicationState . STATUS , valueFactory . bootstrapping ( token ) ) ; 
 + setMode ( " Joining : sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; 
 + try 
 + { 
 + Thread . sleep ( RING _ DELAY ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 } 
 - catch ( InterruptedException e ) 
 + else 
 { 
 - throw new AssertionError ( e ) ; 
 + / / Dont set any state for the node which is bootstrapping the existing token . . . 
 + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 - setMode ( " Bootstrapping " , true ) ; 
 + setMode ( " Starting to bootstrap . . . " , true ) ; 
 new BootStrapper ( FBUtilities . getBroadcastAddress ( ) , token , tokenMetadata _ ) . bootstrap ( ) ; / / handles token update 
 } 
 
 @ @ - 993 , 9 + 1020 , 9 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 
 private void excise ( Token token , InetAddress endpoint ) 
 { 
 + HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; 
 Gossiper . instance . removeEndpoint ( endpoint ) ; 
 tokenMetadata _ . removeEndpoint ( endpoint ) ; 
 - HintedHandOffManager . instance . deleteHintsForEndpoint ( endpoint ) ; 
 tokenMetadata _ . removeBootstrapToken ( token ) ; 
 calculatePendingRanges ( ) ; 
 if ( ! isClientMode )
