BLEU SCORE: 1.0

TEST MSG: Improve javadoc around trigger execution
GENERATED MSG: Improve javadoc around trigger execution

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / triggers / ITrigger . java b / src / java / org / apache / cassandra / triggers / ITrigger . java <nl> index 4701b61 . . 21aba05 100644 <nl> - - - a / src / java / org / apache / cassandra / triggers / ITrigger . java <nl> + + + b / src / java / org / apache / cassandra / triggers / ITrigger . java <nl> @ @ - 36 , 7 + 36 , 7 @ @ import org . apache . cassandra . db . Mutation ; <nl> * 2 ) ITrigger implementation can be instantiated multiple times during the server life time . <nl> * ( Depends on the number of times trigger folder is updated . ) < br > <nl> * 3 ) ITrigger implementation should be state - less ( avoid dependency on instance variables ) . < br > <nl> - * <nl> + * <nl> * < br > < b > The API is still beta and can change . < / b > <nl> * / <nl> public interface ITrigger <nl> @ @ - 46 , 7 + 46 , 7 @ @ public interface ITrigger <nl> * <nl> * @ param partitionKey - partition Key for the update . <nl> * @ param update - update received for the CF <nl> - * @ return modifications to be applied , null if no action to be performed . <nl> + * @ return additional modifications to be applied along with the supplied update <nl> * / <nl> public Collection < Mutation > augment ( ByteBuffer partitionKey , ColumnFamily update ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / triggers / TriggerExecutor . java b / src / java / org / apache / cassandra / triggers / TriggerExecutor . java <nl> index 677daad . . bc6f46c 100644 <nl> - - - a / src / java / org / apache / cassandra / triggers / TriggerExecutor . java <nl> + + + b / src / java / org / apache / cassandra / triggers / TriggerExecutor . java <nl> @ @ - 60 , 6 + 60 , 23 @ @ public class TriggerExecutor <nl> cachedTriggers . clear ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Augment a partition update by executing triggers to generate an intermediate <nl> + * set of mutations , then merging the ColumnFamily from each mutation with those <nl> + * supplied . This is called from @ { link org . apache . cassandra . service . StorageProxy # cas } <nl> + * which is scoped for a single partition . For that reason , any mutations generated <nl> + * by triggers are checked to ensure that they are for the same table and partition <nl> + * key as the primary update ; if not , InvalidRequestException is thrown . If no <nl> + * additional mutations are generated , the original updates are returned unmodified . <nl> + * <nl> + * @ param key partition key for the update <nl> + * @ param updates partition update to be applied , contains the merge of the original <nl> + * update and any generated mutations <nl> + * @ return the final update to be applied , the original update merged with any <nl> + * additional mutations generated by configured triggers <nl> + * @ throws InvalidRequestException if any mutation generated by a trigger does not <nl> + * apply to the exact same partition as the initial update <nl> + * / <nl> public ColumnFamily execute ( ByteBuffer key , ColumnFamily updates ) throws InvalidRequestException <nl> { <nl> List < Mutation > intermediate = executeInternal ( key , updates ) ; <nl> @ @ - 78 , 6 + 95 , 21 @ @ public class TriggerExecutor <nl> return updates ; <nl> } <nl> <nl> + / * * <nl> + * Takes a collection of mutations and possibly augments it by adding extra mutations <nl> + * generated by configured triggers . If no additional mutations are created <nl> + * this returns null , signalling to the caller that only the initial set of <nl> + * mutations should be applied . If additional mutations < i > are < / i > generated , <nl> + * the total set ( i . e . the original plus the additional mutations ) are applied <nl> + * together in a logged batch . Should this not be possible because the initial <nl> + * mutations contain counter updates , InvalidRequestException is thrown . <nl> + * <nl> + * @ param mutations initial collection of mutations <nl> + * @ return augmented mutations . Either the union of the initial and additional <nl> + * mutations or null if no additional mutations were generated <nl> + * @ throws InvalidRequestException if additional mutations were generated , but <nl> + * the initial mutations contains counter updates <nl> + * / <nl> public Collection < Mutation > execute ( Collection < ? extends IMutation > mutations ) throws InvalidRequestException <nl> { <nl> boolean hasCounters = false ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / triggers / ITrigger . java b / src / java / org / apache / cassandra / triggers / ITrigger . java 
 index 4701b61 . . 21aba05 100644 
 - - - a / src / java / org / apache / cassandra / triggers / ITrigger . java 
 + + + b / src / java / org / apache / cassandra / triggers / ITrigger . java 
 @ @ - 36 , 7 + 36 , 7 @ @ import org . apache . cassandra . db . Mutation ; 
 * 2 ) ITrigger implementation can be instantiated multiple times during the server life time . 
 * ( Depends on the number of times trigger folder is updated . ) < br > 
 * 3 ) ITrigger implementation should be state - less ( avoid dependency on instance variables ) . < br > 
 - * 
 + * 
 * < br > < b > The API is still beta and can change . < / b > 
 * / 
 public interface ITrigger 
 @ @ - 46 , 7 + 46 , 7 @ @ public interface ITrigger 
 * 
 * @ param partitionKey - partition Key for the update . 
 * @ param update - update received for the CF 
 - * @ return modifications to be applied , null if no action to be performed . 
 + * @ return additional modifications to be applied along with the supplied update 
 * / 
 public Collection < Mutation > augment ( ByteBuffer partitionKey , ColumnFamily update ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / triggers / TriggerExecutor . java b / src / java / org / apache / cassandra / triggers / TriggerExecutor . java 
 index 677daad . . bc6f46c 100644 
 - - - a / src / java / org / apache / cassandra / triggers / TriggerExecutor . java 
 + + + b / src / java / org / apache / cassandra / triggers / TriggerExecutor . java 
 @ @ - 60 , 6 + 60 , 23 @ @ public class TriggerExecutor 
 cachedTriggers . clear ( ) ; 
 } 
 
 + / * * 
 + * Augment a partition update by executing triggers to generate an intermediate 
 + * set of mutations , then merging the ColumnFamily from each mutation with those 
 + * supplied . This is called from @ { link org . apache . cassandra . service . StorageProxy # cas } 
 + * which is scoped for a single partition . For that reason , any mutations generated 
 + * by triggers are checked to ensure that they are for the same table and partition 
 + * key as the primary update ; if not , InvalidRequestException is thrown . If no 
 + * additional mutations are generated , the original updates are returned unmodified . 
 + * 
 + * @ param key partition key for the update 
 + * @ param updates partition update to be applied , contains the merge of the original 
 + * update and any generated mutations 
 + * @ return the final update to be applied , the original update merged with any 
 + * additional mutations generated by configured triggers 
 + * @ throws InvalidRequestException if any mutation generated by a trigger does not 
 + * apply to the exact same partition as the initial update 
 + * / 
 public ColumnFamily execute ( ByteBuffer key , ColumnFamily updates ) throws InvalidRequestException 
 { 
 List < Mutation > intermediate = executeInternal ( key , updates ) ; 
 @ @ - 78 , 6 + 95 , 21 @ @ public class TriggerExecutor 
 return updates ; 
 } 
 
 + / * * 
 + * Takes a collection of mutations and possibly augments it by adding extra mutations 
 + * generated by configured triggers . If no additional mutations are created 
 + * this returns null , signalling to the caller that only the initial set of 
 + * mutations should be applied . If additional mutations < i > are < / i > generated , 
 + * the total set ( i . e . the original plus the additional mutations ) are applied 
 + * together in a logged batch . Should this not be possible because the initial 
 + * mutations contain counter updates , InvalidRequestException is thrown . 
 + * 
 + * @ param mutations initial collection of mutations 
 + * @ return augmented mutations . Either the union of the initial and additional 
 + * mutations or null if no additional mutations were generated 
 + * @ throws InvalidRequestException if additional mutations were generated , but 
 + * the initial mutations contains counter updates 
 + * / 
 public Collection < Mutation > execute ( Collection < ? extends IMutation > mutations ) throws InvalidRequestException 
 { 
 boolean hasCounters = false ;

NEAREST DIFF:
ELIMINATEDSENTENCE
