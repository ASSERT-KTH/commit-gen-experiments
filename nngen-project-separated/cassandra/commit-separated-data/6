BLEU SCORE: 0.024615130620079664

TEST MSG: Fix AbstractBTreePartition locking in java 11
GENERATED MSG: replace tcp writes w / blocking i / o

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1cfbbfc . . 131bcb2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Fix AbstractBTreePartition locking in java 11 ( CASSANDRA - 14607 ) <nl> * SimpleClient should pass connection properties as options ( CASSANDRA - 15056 ) <nl> * Set repaired data tracking flag on range reads if enabled ( CASSANDRA - 15019 ) <nl> * Calculate pending ranges for BOOTSTRAP _ REPLACE correctly ( CASSANDRA - 14802 ) <nl> diff - - git a / build . xml b / build . xml <nl> index 8fcb53e . . 6d79aca 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 35 , 8 + 35 , 6 @ @ <nl> < property name = " build . src " value = " $ { basedir } / src " / > <nl> < property name = " build . src . java " value = " $ { basedir } / src / java " / > <nl> < property name = " build . src . antlr " value = " $ { basedir } / src / antlr " / > <nl> - < property name = " build . src . java8 " value = " $ { basedir } / src / java8 " / > <nl> - < property name = " build . src . java11 " value = " $ { basedir } / src / java11 " / > <nl> < property name = " build . src . resources " value = " $ { basedir } / src / resources " / > <nl> < property name = " build . src . gen - java " value = " $ { basedir } / src / gen - java " / > <nl> < property name = " build . lib " value = " $ { basedir } / lib " / > <nl> @ @ - 811 , 14 + 809 , 13 @ @ <nl> depends = " maven - ant - tasks - retrieve - build , build - project " description = " Compile Cassandra classes " / > <nl> < target name = " codecoverage " depends = " jacoco - run , jacoco - report " description = " Create code coverage report " / > <nl> <nl> - < target name = " _ build _ java8 _ only " if = " java . version . 8 " > <nl> + < target name = " _ build _ java8 " if = " java . version . 8 " > <nl> < echo message = " Compiling only for Java 8 . . . " / > <nl> < javac fork = " true " <nl> debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " <nl> destdir = " $ { build . classes . main } " includeantruntime = " false " source = " 8 " target = " 8 " <nl> memorymaximumsize = " 512M " > <nl> < src path = " $ { build . src . java } " / > <nl> - < src path = " $ { build . src . java8 } " / > <nl> < src path = " $ { build . src . gen - java } " / > <nl> < compilerarg value = " - XDignore . symbol . file " / > <nl> < classpath > <nl> @ @ - 826 , 9 + 823 , 12 @ @ <nl> < / classpath > <nl> < / javac > <nl> < / target > <nl> - < target name = " _ build _ multi _ java " unless = " java . version . 8 " > <nl> + < target name = " _ build _ java11 " unless = " java . version . 8 " > <nl> < ! - - Note : we cannot use javac ' s ' release ' option , as that does not allow accessing sun . misc . Unsafe nor <nl> Nashorn ' s ClassFilter class as any javac modules option is invalid for relase 8 . - - > <nl> + < fail message = " JAVA8 _ HOME env variable must be set when building with java > = 11 " > <nl> + < condition > < not > < isset property = " env . JAVA8 _ HOME " / > < / not > < / condition > <nl> + < / fail > <nl> < echo message = " Compiling for Java 8 ( using $ { env . JAVA8 _ HOME } / bin / javac ) . . . " / > <nl> < javac fork = " true " <nl> debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " <nl> @ @ - 836 , 33 + 836 , 19 @ @ <nl> executable = " $ { env . JAVA8 _ HOME } / bin / javac " <nl> memorymaximumsize = " 512M " > <nl> < src path = " $ { build . src . java } " / > <nl> - < src path = " $ { build . src . java8 } " / > <nl> < src path = " $ { build . src . gen - java } " / > <nl> < compilerarg value = " - XDignore . symbol . file " / > <nl> < classpath > <nl> < path refid = " cassandra . classpath " / > <nl> < / classpath > <nl> < / javac > <nl> - < echo message = " Compiling for current java version . . . " / > <nl> - < javac fork = " true " <nl> - debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " <nl> - destdir = " $ { build . classes . main } / META - INF / versions / 11 " includeantruntime = " false " <nl> - memorymaximumsize = " 512M " > <nl> - < src path = " $ { build . src . java11 } " / > <nl> - < compilerarg value = " - - release " / > <nl> - < compilerarg value = " $ { release . version } " / > <nl> - < compilerarg value = " - XDignore . symbol . file " / > <nl> - < classpath > <nl> - < path refid = " cassandra . classpath " / > <nl> - < / classpath > <nl> - < / javac > <nl> < / target > <nl> < target depends = " init , gen - cql3 - grammar , generate - cql - html , generate - jflex - java " <nl> name = " build - project " > <nl> < echo message = " $ { ant . project . name } : $ { ant . file } " / > <nl> < ! - - Order matters ! - - > <nl> - < antcall target = " _ build _ java8 _ only " / > <nl> - < antcall target = " _ build _ multi _ java " / > <nl> + < antcall target = " _ build _ java8 " / > <nl> + < antcall target = " _ build _ java11 " / > <nl> < antcall target = " createVersionPropFile " / > <nl> < copy todir = " $ { build . classes . main } " > <nl> < fileset dir = " $ { build . src . resources } " / > <nl> @ @ - 1032 , 9 + 1018 , 6 @ @ <nl> < fileset dir = " $ { build . src . java } " defaultexcludes = " yes " > <nl> < include name = " org / apache / * * / * . java " / > <nl> < / fileset > <nl> - < fileset dir = " $ { build . src . java11 } " defaultexcludes = " yes " > <nl> - < include name = " org / apache / * * / * . java " / > <nl> - < / fileset > <nl> < fileset dir = " $ { build . src . gen - java } " defaultexcludes = " yes " > <nl> < include name = " org / apache / * * / * . java " / > <nl> < / fileset > <nl> @ @ - 1056 , 9 + 1039 , 6 @ @ <nl> < fileset dir = " $ { build . src . java } " defaultexcludes = " yes " > <nl> < include name = " org / apache / * * / * . java " / > <nl> < / fileset > <nl> - < fileset dir = " $ { build . src . java11 } " defaultexcludes = " yes " > <nl> - < include name = " org / apache / * * / * . java " / > <nl> - < / fileset > <nl> < fileset dir = " $ { build . src . gen - java } " defaultexcludes = " yes " > <nl> < include name = " org / apache / * * / * . java " / > <nl> < / fileset > <nl> @ @ - 1234 , 11 + 1214 , 11 @ @ <nl> < / target > <nl> <nl> < target name = " build - test " depends = " _ main - jar , stress - build , fqltool - build , write - poms " description = " Compile test classes " > <nl> - < antcall target = " _ build - test _ java8 _ only " / > <nl> - < antcall target = " _ build - test _ multi _ java " / > <nl> + < antcall target = " _ build - test _ java8 " / > <nl> + < antcall target = " _ build - test _ java11 " / > <nl> < / target > <nl> <nl> - < target name = " _ build - test _ java8 _ only " if = " java . version . 8 " > <nl> + < target name = " _ build - test _ java8 " if = " java . version . 8 " > <nl> < javac <nl> fork = " true " <nl> compiler = " modern " <nl> @ @ - 1266 , 7 + 1246 , 7 @ @ <nl> < / copy > <nl> < / target > <nl> <nl> - < target name = " _ build - test _ multi _ java " unless = " java . version . 8 " > <nl> + < target name = " _ build - test _ java11 " unless = " java . version . 8 " > <nl> < javac <nl> fork = " true " <nl> compiler = " modern " <nl> @ @ - 2032 , 7 + 2012 , 6 @ @ <nl> 	 < echo file = " . classpath " > < ! [ CDATA [ < ? xml version = " 1 . 0 " encoding = " UTF - 8 " ? > <nl> < classpath > <nl> < classpathentry kind = " src " path = " src / java " / > <nl> - < classpathentry kind = " src " path = " src / java8 " / > <nl> < classpathentry kind = " src " path = " src / resources " / > <nl> < classpathentry kind = " src " path = " src / gen - java " / > <nl> < classpathentry kind = " src " path = " conf " including = " hotspot _ compiler " / > <nl> diff - - git a / ide / idea - iml - file . xml b / ide / idea - iml - file . xml <nl> index 0045ae6 . . 17d4c5b 100644 <nl> - - - a / ide / idea - iml - file . xml <nl> + + + b / ide / idea - iml - file . xml <nl> @ @ - 24 , 7 + 24 , 6 @ @ <nl> < exclude - output / > <nl> < content url = " file : / / $ MODULE _ DIR $ " > <nl> < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / java " isTestSource = " false " / > <nl> - < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / java8 " isTestSource = " false " / > <nl> < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / gen - java " isTestSource = " false " generated = " true " / > <nl> < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / resources " type = " java - resource " / > <nl> < sourceFolder url = " file : / / $ MODULE _ DIR $ / tools / stress / src " isTestSource = " false " / > <nl> diff - - git a / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java b / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java <nl> index 8c62642 . . ec73814 100644 <nl> - - - a / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java <nl> + + + b / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java <nl> @ @ - 47 , 7 + 47 , 7 @ @ import org . apache . cassandra . utils . memory . MemtableAllocator ; <nl> * other thread can see the state where only parts but not all rows have <nl> * been added . <nl> * / <nl> - public final class AtomicBTreePartition extends AtomicBTreePartitionBase <nl> + public final class AtomicBTreePartition extends AbstractBTreePartition <nl> { <nl> public static final long EMPTY _ SIZE = ObjectSizes . measure ( new AtomicBTreePartition ( null , <nl> DatabaseDescriptor . getPartitioner ( ) . decorateKey ( ByteBuffer . allocate ( 1 ) ) , <nl> @ @ - 108 , 6 + 108 , 50 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase <nl> return true ; <nl> } <nl> <nl> + private long [ ] addAllWithSizeDeltaInternal ( RowUpdater updater , PartitionUpdate update , UpdateTransaction indexer ) <nl> + { <nl> + Holder current = ref ; <nl> + updater . ref = current ; <nl> + updater . reset ( ) ; <nl> + <nl> + if ( ! update . deletionInfo ( ) . getPartitionDeletion ( ) . isLive ( ) ) <nl> + indexer . onPartitionDeletion ( update . deletionInfo ( ) . getPartitionDeletion ( ) ) ; <nl> + <nl> + if ( update . deletionInfo ( ) . hasRanges ( ) ) <nl> + update . deletionInfo ( ) . rangeIterator ( false ) . forEachRemaining ( indexer : : onRangeTombstone ) ; <nl> + <nl> + DeletionInfo deletionInfo ; <nl> + if ( update . deletionInfo ( ) . mayModify ( current . deletionInfo ) ) <nl> + { <nl> + if ( updater . inputDeletionInfoCopy = = null ) <nl> + updater . inputDeletionInfoCopy = update . deletionInfo ( ) . copy ( HeapAllocator . instance ) ; <nl> + <nl> + deletionInfo = current . deletionInfo . mutableCopy ( ) . add ( updater . inputDeletionInfoCopy ) ; <nl> + updater . allocated ( deletionInfo . unsharedHeapSize ( ) - current . deletionInfo . unsharedHeapSize ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + deletionInfo = current . deletionInfo ; <nl> + } <nl> + <nl> + RegularAndStaticColumns columns = update . columns ( ) . mergeTo ( current . columns ) ; <nl> + Row newStatic = update . staticRow ( ) ; <nl> + Row staticRow = newStatic . isEmpty ( ) <nl> + ? current . staticRow <nl> + : ( current . staticRow . isEmpty ( ) ? updater . apply ( newStatic ) : updater . apply ( current . staticRow , newStatic ) ) ; <nl> + Object [ ] tree = BTree . update ( current . tree , update . metadata ( ) . comparator , update , update . rowCount ( ) , updater ) ; <nl> + EncodingStats newStats = current . stats . mergeWith ( update . stats ( ) ) ; <nl> + <nl> + if ( tree ! = null & & refUpdater . compareAndSet ( this , current , new Holder ( columns , tree , deletionInfo , staticRow , newStats ) ) ) <nl> + { <nl> + updater . finish ( ) ; <nl> + return new long [ ] { updater . dataSize , updater . colUpdateTimeDelta } ; <nl> + } <nl> + else <nl> + { <nl> + return null ; <nl> + } <nl> + } <nl> / * * <nl> * Adds a given update to this in - memtable partition . <nl> * <nl> @ @ - 117 , 77 + 161 , 40 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase <nl> public long [ ] addAllWithSizeDelta ( final PartitionUpdate update , OpOrder . Group writeOp , UpdateTransaction indexer ) <nl> { <nl> RowUpdater updater = new RowUpdater ( this , allocator , writeOp , indexer ) ; <nl> - DeletionInfo inputDeletionInfoCopy = null ; <nl> - boolean monitorOwned = false ; <nl> try <nl> { <nl> - if ( usePessimisticLocking ( ) ) <nl> - { <nl> - acquireLock ( ) ; <nl> - monitorOwned = true ; <nl> - } <nl> + boolean shouldLock = usePessimisticLocking ( ) ; <nl> <nl> indexer . start ( ) ; <nl> <nl> while ( true ) <nl> { <nl> - Holder current = ref ; <nl> - updater . ref = current ; <nl> - updater . reset ( ) ; <nl> - <nl> - if ( ! update . deletionInfo ( ) . getPartitionDeletion ( ) . isLive ( ) ) <nl> - indexer . onPartitionDeletion ( update . deletionInfo ( ) . getPartitionDeletion ( ) ) ; <nl> - <nl> - if ( update . deletionInfo ( ) . hasRanges ( ) ) <nl> - update . deletionInfo ( ) . rangeIterator ( false ) . forEachRemaining ( indexer : : onRangeTombstone ) ; <nl> - <nl> - DeletionInfo deletionInfo ; <nl> - if ( update . deletionInfo ( ) . mayModify ( current . deletionInfo ) ) <nl> + if ( shouldLock ) <nl> { <nl> - if ( inputDeletionInfoCopy = = null ) <nl> - inputDeletionInfoCopy = update . deletionInfo ( ) . copy ( HeapAllocator . instance ) ; <nl> - <nl> - deletionInfo = current . deletionInfo . mutableCopy ( ) . add ( inputDeletionInfoCopy ) ; <nl> - updater . allocated ( deletionInfo . unsharedHeapSize ( ) - current . deletionInfo . unsharedHeapSize ( ) ) ; <nl> + synchronized ( this ) <nl> + { <nl> + long [ ] result = addAllWithSizeDeltaInternal ( updater , update , indexer ) ; <nl> + if ( result ! = null ) <nl> + return result ; <nl> + } <nl> } <nl> else <nl> { <nl> - deletionInfo = current . deletionInfo ; <nl> - } <nl> + long [ ] result = addAllWithSizeDeltaInternal ( updater , update , indexer ) ; <nl> + if ( result ! = null ) <nl> + return result ; <nl> <nl> - RegularAndStaticColumns columns = update . columns ( ) . mergeTo ( current . columns ) ; <nl> - Row newStatic = update . staticRow ( ) ; <nl> - Row staticRow = newStatic . isEmpty ( ) <nl> - ? current . staticRow <nl> - : ( current . staticRow . isEmpty ( ) ? updater . apply ( newStatic ) : updater . apply ( current . staticRow , newStatic ) ) ; <nl> - Object [ ] tree = BTree . update ( current . tree , update . metadata ( ) . comparator , update , update . rowCount ( ) , updater ) ; <nl> - EncodingStats newStats = current . stats . mergeWith ( update . stats ( ) ) ; <nl> - <nl> - if ( tree ! = null & & refUpdater . compareAndSet ( this , current , new Holder ( columns , tree , deletionInfo , staticRow , newStats ) ) ) <nl> - { <nl> - updater . finish ( ) ; <nl> - return new long [ ] { updater . dataSize , updater . colUpdateTimeDelta } ; <nl> - } <nl> - else if ( ! monitorOwned ) <nl> - { <nl> - boolean shouldLock = usePessimisticLocking ( ) ; <nl> + shouldLock = usePessimisticLocking ( ) ; <nl> if ( ! shouldLock ) <nl> { <nl> shouldLock = updateWastedAllocationTracker ( updater . heapSize ) ; <nl> } <nl> - if ( shouldLock ) <nl> - { <nl> - acquireLock ( ) ; <nl> - monitorOwned = true ; <nl> - } <nl> } <nl> } <nl> } <nl> finally <nl> { <nl> indexer . commit ( ) ; <nl> - if ( monitorOwned ) <nl> - releaseLock ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 312 , 6 + 319 , 8 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase <nl> long colUpdateTimeDelta = Long . MAX _ VALUE ; <nl> List < Row > inserted ; / / TODO : replace with walk of aborted BTree <nl> <nl> + DeletionInfo inputDeletionInfoCopy = null ; <nl> + <nl> private RowUpdater ( AtomicBTreePartition updating , MemtableAllocator allocator , OpOrder . Group writeOp , UpdateTransaction indexer ) <nl> { <nl> this . updating = updating ; <nl> diff - - git a / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java b / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java <nl> deleted file mode 100644 <nl> index 56359a2 . . 0000000 <nl> - - - a / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java <nl> + + + / dev / null <nl> @ @ - 1 , 65 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . db . partitions ; <nl> - <nl> - import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; <nl> - import java . util . concurrent . locks . ReentrantLock ; <nl> - <nl> - import org . slf4j . Logger ; <nl> - import org . slf4j . LoggerFactory ; <nl> - <nl> - import org . apache . cassandra . db . DecoratedKey ; <nl> - <nl> - / * * <nl> - * Java 11 version for the partition - locks in { @ link AtomicBTreePartition } . <nl> - * / <nl> - public abstract class AtomicBTreePartitionBase extends AbstractBTreePartition <nl> - { <nl> - private static final Logger logger = LoggerFactory . getLogger ( AtomicBTreePartitionBase . class ) ; <nl> - <nl> - protected AtomicBTreePartitionBase ( DecoratedKey partitionKey ) <nl> - { <nl> - super ( partitionKey ) ; <nl> - } <nl> - <nl> - / / Replacement for Unsafe . monitorEnter / monitorExit . <nl> - private volatile ReentrantLock lock ; <nl> - private static final AtomicReferenceFieldUpdater < AtomicBTreePartitionBase , ReentrantLock > lockUpdater = AtomicReferenceFieldUpdater . newUpdater ( AtomicBTreePartitionBase . class , ReentrantLock . class , " lock " ) ; <nl> - <nl> - static <nl> - { <nl> - logger . info ( " Initializing Java 11 support for AtomicBTreePartition " ) ; <nl> - <nl> - if ( Runtime . version ( ) . version ( ) . get ( 0 ) < 11 ) <nl> - throw new RuntimeException ( " Java 11 required , but found " + Runtime . version ( ) ) ; <nl> - } <nl> - <nl> - protected final void acquireLock ( ) <nl> - { <nl> - if ( lock = = null ) <nl> - lockUpdater . compareAndSet ( this , null , new ReentrantLock ( ) ) ; <nl> - <nl> - lock . lock ( ) ; <nl> - } <nl> - <nl> - protected final void releaseLock ( ) <nl> - { <nl> - lock . unlock ( ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java b / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java <nl> deleted file mode 100644 <nl> index 32209e9 . . 0000000 <nl> - - - a / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java <nl> + + + / dev / null <nl> @ @ - 1 , 81 + 0 , 0 @ @ <nl> - / * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . db . partitions ; <nl> - <nl> - import sun . misc . Unsafe ; <nl> - <nl> - import java . lang . reflect . Field ; <nl> - <nl> - import org . slf4j . Logger ; <nl> - import org . slf4j . LoggerFactory ; <nl> - <nl> - import org . apache . cassandra . db . DecoratedKey ; <nl> - <nl> - / * * <nl> - * Java 8 version for the partition - locks in { @ link AtomicBTreePartition } . <nl> - * / <nl> - public abstract class AtomicBTreePartitionBase extends AbstractBTreePartition <nl> - { <nl> - private static final Logger logger = LoggerFactory . getLogger ( AtomicBTreePartitionBase . class ) ; <nl> - private static final Unsafe unsafe ; <nl> - <nl> - static <nl> - { <nl> - logger . info ( " Initializing Java 8 support for AtomicBTreePartition " ) ; <nl> - <nl> - if ( ! System . getProperty ( " java . version " ) . startsWith ( " 1 . 8 . 0 " ) ) <nl> - throw new RuntimeException ( " Java 8 required , but running " + System . getProperty ( " java . version " ) ) ; <nl> - <nl> - try <nl> - { <nl> - / / Safety . . . in case someone builds only on Java 8 but runs on Java 11 . . . <nl> - sun . misc . Unsafe . class . getDeclaredMethod ( " monitorEnter " , Object . class ) ; <nl> - sun . misc . Unsafe . class . getDeclaredMethod ( " monitorExit " , Object . class ) ; <nl> - <nl> - Field field = sun . misc . Unsafe . class . getDeclaredField ( " theUnsafe " ) ; <nl> - field . setAccessible ( true ) ; <nl> - unsafe = ( sun . misc . Unsafe ) field . get ( null ) ; <nl> - } <nl> - catch ( NoSuchFieldException | NoSuchMethodException e ) <nl> - { <nl> - throw new RuntimeException ( " This build of Cassandra has no support for Java 11 as only Java 8 was available during the build . This should never happen . " ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - } <nl> - <nl> - protected AtomicBTreePartitionBase ( DecoratedKey partitionKey ) <nl> - { <nl> - super ( partitionKey ) ; <nl> - } <nl> - <nl> - protected final void acquireLock ( ) <nl> - { <nl> - if ( unsafe ! = null ) <nl> - unsafe . monitorEnter ( this ) ; <nl> - } <nl> - <nl> - protected final void releaseLock ( ) <nl> - { <nl> - if ( unsafe ! = null ) <nl> - unsafe . monitorExit ( this ) ; <nl> - } <nl> - }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> index 724e9ae . . 34619da 100644 <nl> - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java <nl> @ @ - 44 , 6 + 44 , 8 @ @ class FileStreamTask implements Runnable <nl> <nl> public void run ( ) <nl> { <nl> + / * <nl> + TODO <nl> TcpConnection connection = null ; <nl> try <nl> { <nl> @ @ - 61 , 6 + 63 , 6 @ @ class FileStreamTask implements Runnable <nl> } <nl> throw new RuntimeException ( e ) ; <nl> } <nl> + * / <nl> } <nl> - <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 96bad3c . . 11afaae 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 68 , 7 + 68 , 7 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> / * Thread pool to handle messaging write activities * / <nl> private static ExecutorService streamExecutor _ ; <nl> <nl> - private static NonBlockingHashMap < String , TcpConnectionManager > connectionManagers _ = new NonBlockingHashMap < String , TcpConnectionManager > ( ) ; <nl> + private static NonBlockingHashMap < String , OutboundTcpConnectionPool > connectionManagers _ = new NonBlockingHashMap < String , OutboundTcpConnectionPool > ( ) ; <nl> <nl> private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; <nl> <nl> @ @ - 186 , 19 + 186 , 19 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> } <nl> } <nl> <nl> - public static TcpConnectionManager getConnectionPool ( InetAddress from , InetAddress to ) <nl> + public static OutboundTcpConnectionPool getConnectionPool ( InetAddress from , InetAddress to ) <nl> { <nl> String key = from + " : " + to ; <nl> - TcpConnectionManager cp = connectionManagers _ . get ( key ) ; <nl> + OutboundTcpConnectionPool cp = connectionManagers _ . get ( key ) ; <nl> if ( cp = = null ) <nl> { <nl> - connectionManagers _ . putIfAbsent ( key , new TcpConnectionManager ( from , to ) ) ; <nl> + connectionManagers _ . putIfAbsent ( key , new OutboundTcpConnectionPool ( from , to ) ) ; <nl> cp = connectionManagers _ . get ( key ) ; <nl> } <nl> return cp ; <nl> } <nl> <nl> - public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException <nl> + public static OutboundTcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) <nl> { <nl> return getConnectionPool ( from , to ) . getConnection ( msg ) ; <nl> } <nl> @ @ - 331 , 20 + 331 , 9 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> assert data . length > 0 ; <nl> ByteBuffer buffer = packIt ( data , false , false ) ; <nl> <nl> - TcpConnection connection = null ; <nl> - try <nl> - { <nl> - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> - connection . write ( buffer ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - if ( connection ! = null ) <nl> - { <nl> - connection . errorClose ( ) ; <nl> - } <nl> - logger _ . error ( " unexpected error writing " + message , e ) ; <nl> - } <nl> + OutboundTcpConnection connection = null ; <nl> + connection = getConnection ( processedMessage . getFrom ( ) , to , message ) ; <nl> + connection . write ( buffer ) ; <nl> } <nl> <nl> public IAsyncResult sendRR ( Message message , InetAddress to ) <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> new file mode 100644 <nl> index 0000000 . . f2ace82 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java <nl> @ @ - 0 , 0 + 1 , 97 @ @ <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . DataOutputStream ; <nl> + import java . io . IOError ; <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + import java . net . Socket ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . concurrent . BlockingQueue ; <nl> + import java . util . concurrent . LinkedBlockingQueue ; <nl> + <nl> + import org . apache . log4j . Logger ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class OutboundTcpConnection <nl> + { <nl> + private static Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; <nl> + <nl> + public BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; <nl> + public DataOutputStream output ; <nl> + public Socket socket ; <nl> + <nl> + / / TODO localEp is ignored , get rid of it <nl> + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , InetAddress localEp , final InetAddress remoteEp ) <nl> + { <nl> + try <nl> + { <nl> + socket = new Socket ( remoteEp , DatabaseDescriptor . getStoragePort ( ) ) ; <nl> + socket . setTcpNoDelay ( true ) ; <nl> + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> + new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( socket ! = null ) <nl> + { <nl> + ByteBuffer bb ; <nl> + try <nl> + { <nl> + bb = queue . take ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + try <nl> + { <nl> + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; <nl> + if ( queue . peek ( ) = = null ) <nl> + { <nl> + output . flush ( ) ; <nl> + } <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + logger . info ( " error writing to " + remoteEp ) ; <nl> + pool . reset ( ) ; <nl> + break ; <nl> + } <nl> + } <nl> + } <nl> + } , " WRITE - " + remoteEp ) . start ( ) ; <nl> + } <nl> + <nl> + public void write ( ByteBuffer buffer ) <nl> + { <nl> + try <nl> + { <nl> + queue . put ( buffer ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public void closeSocket ( ) <nl> + { <nl> + try <nl> + { <nl> + socket . close ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " error closing socket " , e ) ; <nl> + } <nl> + socket = null ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java <nl> new file mode 100644 <nl> index 0000000 . . 8ad66ca <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java <nl> @ @ - 0 , 0 + 1 , 72 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . net ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . net . InetAddress ; <nl> + <nl> + import org . apache . cassandra . concurrent . StageManager ; <nl> + <nl> + class OutboundTcpConnectionPool <nl> + { <nl> + private InetAddress localEp _ ; <nl> + private InetAddress remoteEp _ ; <nl> + private OutboundTcpConnection cmdCon ; <nl> + private OutboundTcpConnection ackCon ; <nl> + <nl> + / / TODO localEp is ignored , get rid of it <nl> + OutboundTcpConnectionPool ( InetAddress localEp , InetAddress remoteEp ) <nl> + { <nl> + localEp _ = localEp ; <nl> + remoteEp _ = remoteEp ; <nl> + } <nl> + <nl> + private OutboundTcpConnection newCon ( ) <nl> + { <nl> + return new OutboundTcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> + } <nl> + <nl> + / * * <nl> + * returns the appropriate connection based on message type . <nl> + * / <nl> + synchronized OutboundTcpConnection getConnection ( Message msg ) <nl> + { <nl> + if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) <nl> + { <nl> + if ( ackCon = = null ) <nl> + ackCon = newCon ( ) ; <nl> + return ackCon ; <nl> + } <nl> + else <nl> + { <nl> + if ( cmdCon = = null ) <nl> + cmdCon = newCon ( ) ; <nl> + return cmdCon ; <nl> + } <nl> + } <nl> + <nl> + synchronized void reset ( ) <nl> + { <nl> + for ( OutboundTcpConnection con : new OutboundTcpConnection [ ] { cmdCon , ackCon } ) <nl> + if ( con ! = null ) <nl> + con . closeSocket ( ) ; <nl> + cmdCon = null ; <nl> + ackCon = null ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java <nl> deleted file mode 100644 <nl> index 01003d1 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnection . java <nl> + + + / dev / null <nl> @ @ - 1 , 378 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . * ; <nl> - import java . nio . ByteBuffer ; <nl> - import java . nio . channels . FileChannel ; <nl> - import java . nio . channels . SelectionKey ; <nl> - import java . nio . channels . SocketChannel ; <nl> - import java . util . * ; <nl> - import java . util . concurrent . TimeUnit ; <nl> - import java . util . concurrent . ConcurrentLinkedQueue ; <nl> - import java . util . concurrent . locks . Condition ; <nl> - import java . util . concurrent . locks . Lock ; <nl> - import java . util . concurrent . locks . ReentrantLock ; <nl> - import java . net . InetAddress ; <nl> - import java . net . InetSocketAddress ; <nl> - <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - <nl> - import org . apache . log4j . Logger ; <nl> - <nl> - public class TcpConnection extends SelectionKeyHandler implements Comparable <nl> - { <nl> - / / logging and profiling . <nl> - private static Logger logger _ = Logger . getLogger ( TcpConnection . class ) ; <nl> - private SocketChannel socketChannel _ ; <nl> - private SelectionKey key _ ; <nl> - private TcpConnectionManager pool _ ; <nl> - private boolean isIncoming _ = false ; <nl> - private Queue < ByteBuffer > pendingWrites _ = new ConcurrentLinkedQueue < ByteBuffer > ( ) ; <nl> - private InetAddress localEp _ ; <nl> - private InetAddress remoteEp _ ; <nl> - <nl> - / * <nl> - * Added for streaming support . We need the boolean <nl> - * to indicate that this connection is used for <nl> - * streaming . The Condition and the Lock are used <nl> - * to signal the stream ( ) that it can continue <nl> - * streaming when the socket becomes writable . <nl> - * / <nl> - private boolean bStream _ = false ; <nl> - private Lock lock _ ; <nl> - private Condition condition _ ; <nl> - <nl> - private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException <nl> - { <nl> - socketChannel _ = SocketChannel . open ( ) ; <nl> - socketChannel _ . socket ( ) . bind ( new InetSocketAddress ( from , 0 ) ) ; <nl> - socketChannel _ . configureBlocking ( false ) ; <nl> - <nl> - localEp _ = from ; <nl> - remoteEp _ = to ; <nl> - <nl> - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; <nl> - } <nl> - else <nl> - { <nl> - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; <nl> - } <nl> - <nl> - if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) <nl> - throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; <nl> - <nl> - if ( pool ! = null ) <nl> - pool _ = pool ; <nl> - if ( streaming ) <nl> - { <nl> - bStream _ = true ; <nl> - lock _ = new ReentrantLock ( ) ; <nl> - condition _ = lock _ . newCondition ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / used from getConnection - outgoing <nl> - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - this ( from , to , pool , false ) ; <nl> - } <nl> - <nl> - / * <nl> - * Used for streaming purposes has no pooling semantics . <nl> - * / <nl> - TcpConnection ( InetAddress from , InetAddress to ) throws IOException <nl> - { <nl> - this ( from , to , null , true ) ; <nl> - } <nl> - <nl> - public InetAddress getEndPoint ( ) <nl> - { <nl> - return remoteEp _ ; <nl> - } <nl> - <nl> - public SocketChannel getSocketChannel ( ) <nl> - { <nl> - return socketChannel _ ; <nl> - } <nl> - <nl> - public synchronized void write ( ByteBuffer buffer ) throws IOException <nl> - { <nl> - if ( ! pendingWrites _ . isEmpty ( ) | | ! socketChannel _ . isConnected ( ) ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - return ; <nl> - } <nl> - <nl> - socketChannel _ . write ( buffer ) ; <nl> - <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - <nl> - public void stream ( File file , long startPosition , long endPosition ) throws IOException , InterruptedException <nl> - { <nl> - if ( ! bStream _ ) <nl> - throw new IllegalStateException ( " Cannot stream since we are not set up to stream data . " ) ; <nl> - <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - / * transfer 64MB in each attempt * / <nl> - int limit = 64 * 1024 * 1024 ; <nl> - long total = endPosition - startPosition ; <nl> - / * keeps track of total number of bytes transferred * / <nl> - long bytesWritten = 0L ; <nl> - RandomAccessFile raf = new RandomAccessFile ( file , " r " ) ; <nl> - FileChannel fc = raf . getChannel ( ) ; <nl> - <nl> - / * <nl> - * If the connection is not yet established then wait for <nl> - * the timeout period of 2 seconds . Attempt to reconnect 3 times and then <nl> - * bail with an IOException . <nl> - * / <nl> - long waitTime = 2 ; <nl> - int retry = 0 ; <nl> - while ( ! socketChannel _ . isConnected ( ) ) <nl> - { <nl> - if ( retry = = 3 ) <nl> - throw new IOException ( " Unable to connect to " + remoteEp _ + " after " + retry + " attempts . " ) ; <nl> - condition _ . await ( waitTime , TimeUnit . SECONDS ) ; <nl> - + + retry ; <nl> - } <nl> - <nl> - while ( bytesWritten < total ) <nl> - { <nl> - if ( startPosition = = 0 ) <nl> - { <nl> - ByteBuffer buffer = MessagingService . constructStreamHeader ( false , true ) ; <nl> - socketChannel _ . write ( buffer ) ; <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - pendingWrites _ . add ( buffer ) ; <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - condition _ . await ( ) ; <nl> - } <nl> - } <nl> - <nl> - long bytesTransferred ; <nl> - try <nl> - { <nl> - / * returns the number of bytes transferred from file to the socket * / <nl> - bytesTransferred = fc . transferTo ( startPosition , limit , socketChannel _ ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - / / at least jdk1 . 6 . 0 on Linux seems to throw IOException <nl> - / / when the socket is full . ( Bug fixed for 1 . 7 : http : / / bugs . sun . com / view _ bug . do ? bug _ id = 5103988 ) <nl> - / / For now look for a specific string in for the message for the exception . <nl> - if ( ! e . getMessage ( ) . startsWith ( " Resource temporarily unavailable " ) ) <nl> - throw e ; <nl> - Thread . sleep ( 10 ) ; <nl> - continue ; <nl> - } <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Bytes transferred " + bytesTransferred ) ; <nl> - bytesWritten + = bytesTransferred ; <nl> - startPosition + = bytesTransferred ; <nl> - / * <nl> - * If the number of bytes transferred is less than intended <nl> - * then we need to wait till socket becomes writeable again . <nl> - * / <nl> - if ( bytesTransferred < limit & & bytesWritten ! = total ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - condition _ . await ( ) ; <nl> - } <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - private void resumeStreaming ( ) <nl> - { <nl> - / * if not in streaming mode do nothing * / <nl> - if ( ! bStream _ ) <nl> - return ; <nl> - <nl> - lock _ . lock ( ) ; <nl> - try <nl> - { <nl> - condition _ . signal ( ) ; <nl> - } <nl> - finally <nl> - { <nl> - lock _ . unlock ( ) ; <nl> - } <nl> - } <nl> - <nl> - public boolean isConnected ( ) <nl> - { <nl> - return socketChannel _ . isConnected ( ) ; <nl> - } <nl> - <nl> - public boolean equals ( Object o ) <nl> - { <nl> - if ( ! ( o instanceof TcpConnection ) ) <nl> - return false ; <nl> - <nl> - TcpConnection rhs = ( TcpConnection ) o ; <nl> - return localEp _ . equals ( rhs . localEp _ ) & & remoteEp _ . equals ( rhs . remoteEp _ ) ; <nl> - } <nl> - <nl> - public int hashCode ( ) <nl> - { <nl> - return ( localEp _ + " : " + remoteEp _ ) . hashCode ( ) ; <nl> - } <nl> - <nl> - public String toString ( ) <nl> - { <nl> - return socketChannel _ . toString ( ) ; <nl> - } <nl> - <nl> - void closeSocket ( ) <nl> - { <nl> - if ( pendingWrites _ . size ( ) > 0 ) <nl> - logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; <nl> - cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - } <nl> - <nl> - void errorClose ( ) <nl> - { <nl> - logger _ . info ( " Closing errored connection " + socketChannel _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - cancel ( key _ ) ; <nl> - pendingWrites _ . clear ( ) ; <nl> - if ( pool _ ! = null ) <nl> - pool _ . reset ( ) ; <nl> - } <nl> - <nl> - private void cancel ( SelectionKey key ) <nl> - { <nl> - if ( key ! = null ) <nl> - { <nl> - key . cancel ( ) ; <nl> - try <nl> - { <nl> - key . channel ( ) . close ( ) ; <nl> - } <nl> - catch ( IOException e ) { } <nl> - } <nl> - } <nl> - <nl> - / / called in the selector thread <nl> - public void connect ( SelectionKey key ) <nl> - { <nl> - turnOffInterestOps ( key , SelectionKey . OP _ CONNECT ) ; <nl> - try <nl> - { <nl> - if ( socketChannel _ . finishConnect ( ) ) <nl> - { <nl> - turnOnInterestOps ( key , SelectionKey . OP _ READ ) ; <nl> - <nl> - synchronized ( this ) <nl> - { <nl> - / / this will flush the pending <nl> - if ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - resumeStreaming ( ) ; <nl> - } <nl> - else <nl> - { <nl> - logger _ . error ( " Closing connection because socket channel could not finishConnect . " ) ; ; <nl> - errorClose ( ) ; <nl> - } <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> - logger _ . error ( " Encountered IOException on connection : " + socketChannel _ , e ) ; <nl> - errorClose ( ) ; <nl> - } <nl> - } <nl> - <nl> - / / called in the selector thread <nl> - public void write ( SelectionKey key ) <nl> - { <nl> - turnOffInterestOps ( key , SelectionKey . OP _ WRITE ) ; <nl> - doPendingWrites ( ) ; <nl> - / * <nl> - * This is executed only if we are in streaming mode . <nl> - * Idea is that we read a chunk of data from a source <nl> - * and wait to read the next from the source until we <nl> - * are siganlled to do so from here . <nl> - * / <nl> - resumeStreaming ( ) ; <nl> - } <nl> - <nl> - public void doPendingWrites ( ) <nl> - { <nl> - synchronized ( this ) <nl> - { <nl> - try <nl> - { <nl> - while ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - ByteBuffer buffer = pendingWrites _ . peek ( ) ; <nl> - socketChannel _ . write ( buffer ) ; <nl> - if ( buffer . remaining ( ) > 0 ) <nl> - { <nl> - break ; <nl> - } <nl> - pendingWrites _ . remove ( ) ; <nl> - } <nl> - <nl> - } <nl> - catch ( IOException ex ) <nl> - { <nl> - logger _ . error ( ex ) ; <nl> - / / This is to fix the wierd Linux bug with NIO . <nl> - errorClose ( ) ; <nl> - } <nl> - finally <nl> - { <nl> - if ( ! pendingWrites _ . isEmpty ( ) ) <nl> - { <nl> - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> - <nl> - public int compareTo ( Object o ) <nl> - { <nl> - if ( o instanceof TcpConnection ) <nl> - { <nl> - return pendingWrites _ . size ( ) - ( ( TcpConnection ) o ) . pendingWrites _ . size ( ) ; <nl> - } <nl> - <nl> - throw new IllegalArgumentException ( ) ; <nl> - } <nl> - } <nl> diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> deleted file mode 100644 <nl> index 8cdfef2 . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java <nl> + + + / dev / null <nl> @ @ - 1 , 72 + 0 , 0 @ @ <nl> - / * * <nl> - * Licensed to the Apache Software Foundation ( ASF ) under one <nl> - * or more contributor license agreements . See the NOTICE file <nl> - * distributed with this work for additional information <nl> - * regarding copyright ownership . The ASF licenses this file <nl> - * to you under the Apache License , Version 2 . 0 ( the <nl> - * " License " ) ; you may not use this file except in compliance <nl> - * with the License . You may obtain a copy of the License at <nl> - * <nl> - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> - * <nl> - * Unless required by applicable law or agreed to in writing , software <nl> - * distributed under the License is distributed on an " AS IS " BASIS , <nl> - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> - * See the License for the specific language governing permissions and <nl> - * limitations under the License . <nl> - * / <nl> - <nl> - package org . apache . cassandra . net ; <nl> - <nl> - import java . io . IOException ; <nl> - import java . net . InetAddress ; <nl> - <nl> - import org . apache . cassandra . concurrent . StageManager ; <nl> - <nl> - class TcpConnectionManager <nl> - { <nl> - private InetAddress localEp _ ; <nl> - private InetAddress remoteEp _ ; <nl> - private TcpConnection cmdCon ; <nl> - private TcpConnection ackCon ; <nl> - <nl> - TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) <nl> - { <nl> - localEp _ = localEp ; <nl> - remoteEp _ = remoteEp ; <nl> - } <nl> - <nl> - private TcpConnection newCon ( ) throws IOException <nl> - { <nl> - TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; <nl> - return con ; <nl> - } <nl> - <nl> - / * * <nl> - * returns the appropriate connection based on message type . <nl> - * / <nl> - synchronized TcpConnection getConnection ( Message msg ) throws IOException <nl> - { <nl> - if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) <nl> - { <nl> - if ( ackCon = = null ) <nl> - ackCon = newCon ( ) ; <nl> - return ackCon ; <nl> - } <nl> - else <nl> - { <nl> - if ( cmdCon = = null ) <nl> - cmdCon = newCon ( ) ; <nl> - return cmdCon ; <nl> - } <nl> - } <nl> - <nl> - synchronized void reset ( ) <nl> - { <nl> - for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) <nl> - if ( con ! = null ) <nl> - con . closeSocket ( ) ; <nl> - cmdCon = null ; <nl> - ackCon = null ; <nl> - } <nl> - }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1cfbbfc . . 131bcb2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Fix AbstractBTreePartition locking in java 11 ( CASSANDRA - 14607 ) 
 * SimpleClient should pass connection properties as options ( CASSANDRA - 15056 ) 
 * Set repaired data tracking flag on range reads if enabled ( CASSANDRA - 15019 ) 
 * Calculate pending ranges for BOOTSTRAP _ REPLACE correctly ( CASSANDRA - 14802 ) 
 diff - - git a / build . xml b / build . xml 
 index 8fcb53e . . 6d79aca 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 35 , 8 + 35 , 6 @ @ 
 < property name = " build . src " value = " $ { basedir } / src " / > 
 < property name = " build . src . java " value = " $ { basedir } / src / java " / > 
 < property name = " build . src . antlr " value = " $ { basedir } / src / antlr " / > 
 - < property name = " build . src . java8 " value = " $ { basedir } / src / java8 " / > 
 - < property name = " build . src . java11 " value = " $ { basedir } / src / java11 " / > 
 < property name = " build . src . resources " value = " $ { basedir } / src / resources " / > 
 < property name = " build . src . gen - java " value = " $ { basedir } / src / gen - java " / > 
 < property name = " build . lib " value = " $ { basedir } / lib " / > 
 @ @ - 811 , 14 + 809 , 13 @ @ 
 depends = " maven - ant - tasks - retrieve - build , build - project " description = " Compile Cassandra classes " / > 
 < target name = " codecoverage " depends = " jacoco - run , jacoco - report " description = " Create code coverage report " / > 
 
 - < target name = " _ build _ java8 _ only " if = " java . version . 8 " > 
 + < target name = " _ build _ java8 " if = " java . version . 8 " > 
 < echo message = " Compiling only for Java 8 . . . " / > 
 < javac fork = " true " 
 debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " 
 destdir = " $ { build . classes . main } " includeantruntime = " false " source = " 8 " target = " 8 " 
 memorymaximumsize = " 512M " > 
 < src path = " $ { build . src . java } " / > 
 - < src path = " $ { build . src . java8 } " / > 
 < src path = " $ { build . src . gen - java } " / > 
 < compilerarg value = " - XDignore . symbol . file " / > 
 < classpath > 
 @ @ - 826 , 9 + 823 , 12 @ @ 
 < / classpath > 
 < / javac > 
 < / target > 
 - < target name = " _ build _ multi _ java " unless = " java . version . 8 " > 
 + < target name = " _ build _ java11 " unless = " java . version . 8 " > 
 < ! - - Note : we cannot use javac ' s ' release ' option , as that does not allow accessing sun . misc . Unsafe nor 
 Nashorn ' s ClassFilter class as any javac modules option is invalid for relase 8 . - - > 
 + < fail message = " JAVA8 _ HOME env variable must be set when building with java > = 11 " > 
 + < condition > < not > < isset property = " env . JAVA8 _ HOME " / > < / not > < / condition > 
 + < / fail > 
 < echo message = " Compiling for Java 8 ( using $ { env . JAVA8 _ HOME } / bin / javac ) . . . " / > 
 < javac fork = " true " 
 debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " 
 @ @ - 836 , 33 + 836 , 19 @ @ 
 executable = " $ { env . JAVA8 _ HOME } / bin / javac " 
 memorymaximumsize = " 512M " > 
 < src path = " $ { build . src . java } " / > 
 - < src path = " $ { build . src . java8 } " / > 
 < src path = " $ { build . src . gen - java } " / > 
 < compilerarg value = " - XDignore . symbol . file " / > 
 < classpath > 
 < path refid = " cassandra . classpath " / > 
 < / classpath > 
 < / javac > 
 - < echo message = " Compiling for current java version . . . " / > 
 - < javac fork = " true " 
 - debug = " true " debuglevel = " $ { debuglevel } " encoding = " utf - 8 " 
 - destdir = " $ { build . classes . main } / META - INF / versions / 11 " includeantruntime = " false " 
 - memorymaximumsize = " 512M " > 
 - < src path = " $ { build . src . java11 } " / > 
 - < compilerarg value = " - - release " / > 
 - < compilerarg value = " $ { release . version } " / > 
 - < compilerarg value = " - XDignore . symbol . file " / > 
 - < classpath > 
 - < path refid = " cassandra . classpath " / > 
 - < / classpath > 
 - < / javac > 
 < / target > 
 < target depends = " init , gen - cql3 - grammar , generate - cql - html , generate - jflex - java " 
 name = " build - project " > 
 < echo message = " $ { ant . project . name } : $ { ant . file } " / > 
 < ! - - Order matters ! - - > 
 - < antcall target = " _ build _ java8 _ only " / > 
 - < antcall target = " _ build _ multi _ java " / > 
 + < antcall target = " _ build _ java8 " / > 
 + < antcall target = " _ build _ java11 " / > 
 < antcall target = " createVersionPropFile " / > 
 < copy todir = " $ { build . classes . main } " > 
 < fileset dir = " $ { build . src . resources } " / > 
 @ @ - 1032 , 9 + 1018 , 6 @ @ 
 < fileset dir = " $ { build . src . java } " defaultexcludes = " yes " > 
 < include name = " org / apache / * * / * . java " / > 
 < / fileset > 
 - < fileset dir = " $ { build . src . java11 } " defaultexcludes = " yes " > 
 - < include name = " org / apache / * * / * . java " / > 
 - < / fileset > 
 < fileset dir = " $ { build . src . gen - java } " defaultexcludes = " yes " > 
 < include name = " org / apache / * * / * . java " / > 
 < / fileset > 
 @ @ - 1056 , 9 + 1039 , 6 @ @ 
 < fileset dir = " $ { build . src . java } " defaultexcludes = " yes " > 
 < include name = " org / apache / * * / * . java " / > 
 < / fileset > 
 - < fileset dir = " $ { build . src . java11 } " defaultexcludes = " yes " > 
 - < include name = " org / apache / * * / * . java " / > 
 - < / fileset > 
 < fileset dir = " $ { build . src . gen - java } " defaultexcludes = " yes " > 
 < include name = " org / apache / * * / * . java " / > 
 < / fileset > 
 @ @ - 1234 , 11 + 1214 , 11 @ @ 
 < / target > 
 
 < target name = " build - test " depends = " _ main - jar , stress - build , fqltool - build , write - poms " description = " Compile test classes " > 
 - < antcall target = " _ build - test _ java8 _ only " / > 
 - < antcall target = " _ build - test _ multi _ java " / > 
 + < antcall target = " _ build - test _ java8 " / > 
 + < antcall target = " _ build - test _ java11 " / > 
 < / target > 
 
 - < target name = " _ build - test _ java8 _ only " if = " java . version . 8 " > 
 + < target name = " _ build - test _ java8 " if = " java . version . 8 " > 
 < javac 
 fork = " true " 
 compiler = " modern " 
 @ @ - 1266 , 7 + 1246 , 7 @ @ 
 < / copy > 
 < / target > 
 
 - < target name = " _ build - test _ multi _ java " unless = " java . version . 8 " > 
 + < target name = " _ build - test _ java11 " unless = " java . version . 8 " > 
 < javac 
 fork = " true " 
 compiler = " modern " 
 @ @ - 2032 , 7 + 2012 , 6 @ @ 
 	 < echo file = " . classpath " > < ! [ CDATA [ < ? xml version = " 1 . 0 " encoding = " UTF - 8 " ? > 
 < classpath > 
 < classpathentry kind = " src " path = " src / java " / > 
 - < classpathentry kind = " src " path = " src / java8 " / > 
 < classpathentry kind = " src " path = " src / resources " / > 
 < classpathentry kind = " src " path = " src / gen - java " / > 
 < classpathentry kind = " src " path = " conf " including = " hotspot _ compiler " / > 
 diff - - git a / ide / idea - iml - file . xml b / ide / idea - iml - file . xml 
 index 0045ae6 . . 17d4c5b 100644 
 - - - a / ide / idea - iml - file . xml 
 + + + b / ide / idea - iml - file . xml 
 @ @ - 24 , 7 + 24 , 6 @ @ 
 < exclude - output / > 
 < content url = " file : / / $ MODULE _ DIR $ " > 
 < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / java " isTestSource = " false " / > 
 - < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / java8 " isTestSource = " false " / > 
 < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / gen - java " isTestSource = " false " generated = " true " / > 
 < sourceFolder url = " file : / / $ MODULE _ DIR $ / src / resources " type = " java - resource " / > 
 < sourceFolder url = " file : / / $ MODULE _ DIR $ / tools / stress / src " isTestSource = " false " / > 
 diff - - git a / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java b / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java 
 index 8c62642 . . ec73814 100644 
 - - - a / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java 
 + + + b / src / java / org / apache / cassandra / db / partitions / AtomicBTreePartition . java 
 @ @ - 47 , 7 + 47 , 7 @ @ import org . apache . cassandra . utils . memory . MemtableAllocator ; 
 * other thread can see the state where only parts but not all rows have 
 * been added . 
 * / 
 - public final class AtomicBTreePartition extends AtomicBTreePartitionBase 
 + public final class AtomicBTreePartition extends AbstractBTreePartition 
 { 
 public static final long EMPTY _ SIZE = ObjectSizes . measure ( new AtomicBTreePartition ( null , 
 DatabaseDescriptor . getPartitioner ( ) . decorateKey ( ByteBuffer . allocate ( 1 ) ) , 
 @ @ - 108 , 6 + 108 , 50 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase 
 return true ; 
 } 
 
 + private long [ ] addAllWithSizeDeltaInternal ( RowUpdater updater , PartitionUpdate update , UpdateTransaction indexer ) 
 + { 
 + Holder current = ref ; 
 + updater . ref = current ; 
 + updater . reset ( ) ; 
 + 
 + if ( ! update . deletionInfo ( ) . getPartitionDeletion ( ) . isLive ( ) ) 
 + indexer . onPartitionDeletion ( update . deletionInfo ( ) . getPartitionDeletion ( ) ) ; 
 + 
 + if ( update . deletionInfo ( ) . hasRanges ( ) ) 
 + update . deletionInfo ( ) . rangeIterator ( false ) . forEachRemaining ( indexer : : onRangeTombstone ) ; 
 + 
 + DeletionInfo deletionInfo ; 
 + if ( update . deletionInfo ( ) . mayModify ( current . deletionInfo ) ) 
 + { 
 + if ( updater . inputDeletionInfoCopy = = null ) 
 + updater . inputDeletionInfoCopy = update . deletionInfo ( ) . copy ( HeapAllocator . instance ) ; 
 + 
 + deletionInfo = current . deletionInfo . mutableCopy ( ) . add ( updater . inputDeletionInfoCopy ) ; 
 + updater . allocated ( deletionInfo . unsharedHeapSize ( ) - current . deletionInfo . unsharedHeapSize ( ) ) ; 
 + } 
 + else 
 + { 
 + deletionInfo = current . deletionInfo ; 
 + } 
 + 
 + RegularAndStaticColumns columns = update . columns ( ) . mergeTo ( current . columns ) ; 
 + Row newStatic = update . staticRow ( ) ; 
 + Row staticRow = newStatic . isEmpty ( ) 
 + ? current . staticRow 
 + : ( current . staticRow . isEmpty ( ) ? updater . apply ( newStatic ) : updater . apply ( current . staticRow , newStatic ) ) ; 
 + Object [ ] tree = BTree . update ( current . tree , update . metadata ( ) . comparator , update , update . rowCount ( ) , updater ) ; 
 + EncodingStats newStats = current . stats . mergeWith ( update . stats ( ) ) ; 
 + 
 + if ( tree ! = null & & refUpdater . compareAndSet ( this , current , new Holder ( columns , tree , deletionInfo , staticRow , newStats ) ) ) 
 + { 
 + updater . finish ( ) ; 
 + return new long [ ] { updater . dataSize , updater . colUpdateTimeDelta } ; 
 + } 
 + else 
 + { 
 + return null ; 
 + } 
 + } 
 / * * 
 * Adds a given update to this in - memtable partition . 
 * 
 @ @ - 117 , 77 + 161 , 40 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase 
 public long [ ] addAllWithSizeDelta ( final PartitionUpdate update , OpOrder . Group writeOp , UpdateTransaction indexer ) 
 { 
 RowUpdater updater = new RowUpdater ( this , allocator , writeOp , indexer ) ; 
 - DeletionInfo inputDeletionInfoCopy = null ; 
 - boolean monitorOwned = false ; 
 try 
 { 
 - if ( usePessimisticLocking ( ) ) 
 - { 
 - acquireLock ( ) ; 
 - monitorOwned = true ; 
 - } 
 + boolean shouldLock = usePessimisticLocking ( ) ; 
 
 indexer . start ( ) ; 
 
 while ( true ) 
 { 
 - Holder current = ref ; 
 - updater . ref = current ; 
 - updater . reset ( ) ; 
 - 
 - if ( ! update . deletionInfo ( ) . getPartitionDeletion ( ) . isLive ( ) ) 
 - indexer . onPartitionDeletion ( update . deletionInfo ( ) . getPartitionDeletion ( ) ) ; 
 - 
 - if ( update . deletionInfo ( ) . hasRanges ( ) ) 
 - update . deletionInfo ( ) . rangeIterator ( false ) . forEachRemaining ( indexer : : onRangeTombstone ) ; 
 - 
 - DeletionInfo deletionInfo ; 
 - if ( update . deletionInfo ( ) . mayModify ( current . deletionInfo ) ) 
 + if ( shouldLock ) 
 { 
 - if ( inputDeletionInfoCopy = = null ) 
 - inputDeletionInfoCopy = update . deletionInfo ( ) . copy ( HeapAllocator . instance ) ; 
 - 
 - deletionInfo = current . deletionInfo . mutableCopy ( ) . add ( inputDeletionInfoCopy ) ; 
 - updater . allocated ( deletionInfo . unsharedHeapSize ( ) - current . deletionInfo . unsharedHeapSize ( ) ) ; 
 + synchronized ( this ) 
 + { 
 + long [ ] result = addAllWithSizeDeltaInternal ( updater , update , indexer ) ; 
 + if ( result ! = null ) 
 + return result ; 
 + } 
 } 
 else 
 { 
 - deletionInfo = current . deletionInfo ; 
 - } 
 + long [ ] result = addAllWithSizeDeltaInternal ( updater , update , indexer ) ; 
 + if ( result ! = null ) 
 + return result ; 
 
 - RegularAndStaticColumns columns = update . columns ( ) . mergeTo ( current . columns ) ; 
 - Row newStatic = update . staticRow ( ) ; 
 - Row staticRow = newStatic . isEmpty ( ) 
 - ? current . staticRow 
 - : ( current . staticRow . isEmpty ( ) ? updater . apply ( newStatic ) : updater . apply ( current . staticRow , newStatic ) ) ; 
 - Object [ ] tree = BTree . update ( current . tree , update . metadata ( ) . comparator , update , update . rowCount ( ) , updater ) ; 
 - EncodingStats newStats = current . stats . mergeWith ( update . stats ( ) ) ; 
 - 
 - if ( tree ! = null & & refUpdater . compareAndSet ( this , current , new Holder ( columns , tree , deletionInfo , staticRow , newStats ) ) ) 
 - { 
 - updater . finish ( ) ; 
 - return new long [ ] { updater . dataSize , updater . colUpdateTimeDelta } ; 
 - } 
 - else if ( ! monitorOwned ) 
 - { 
 - boolean shouldLock = usePessimisticLocking ( ) ; 
 + shouldLock = usePessimisticLocking ( ) ; 
 if ( ! shouldLock ) 
 { 
 shouldLock = updateWastedAllocationTracker ( updater . heapSize ) ; 
 } 
 - if ( shouldLock ) 
 - { 
 - acquireLock ( ) ; 
 - monitorOwned = true ; 
 - } 
 } 
 } 
 } 
 finally 
 { 
 indexer . commit ( ) ; 
 - if ( monitorOwned ) 
 - releaseLock ( ) ; 
 } 
 } 
 
 @ @ - 312 , 6 + 319 , 8 @ @ public final class AtomicBTreePartition extends AtomicBTreePartitionBase 
 long colUpdateTimeDelta = Long . MAX _ VALUE ; 
 List < Row > inserted ; / / TODO : replace with walk of aborted BTree 
 
 + DeletionInfo inputDeletionInfoCopy = null ; 
 + 
 private RowUpdater ( AtomicBTreePartition updating , MemtableAllocator allocator , OpOrder . Group writeOp , UpdateTransaction indexer ) 
 { 
 this . updating = updating ; 
 diff - - git a / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java b / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java 
 deleted file mode 100644 
 index 56359a2 . . 0000000 
 - - - a / src / java11 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java 
 + + + / dev / null 
 @ @ - 1 , 65 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . db . partitions ; 
 - 
 - import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; 
 - import java . util . concurrent . locks . ReentrantLock ; 
 - 
 - import org . slf4j . Logger ; 
 - import org . slf4j . LoggerFactory ; 
 - 
 - import org . apache . cassandra . db . DecoratedKey ; 
 - 
 - / * * 
 - * Java 11 version for the partition - locks in { @ link AtomicBTreePartition } . 
 - * / 
 - public abstract class AtomicBTreePartitionBase extends AbstractBTreePartition 
 - { 
 - private static final Logger logger = LoggerFactory . getLogger ( AtomicBTreePartitionBase . class ) ; 
 - 
 - protected AtomicBTreePartitionBase ( DecoratedKey partitionKey ) 
 - { 
 - super ( partitionKey ) ; 
 - } 
 - 
 - / / Replacement for Unsafe . monitorEnter / monitorExit . 
 - private volatile ReentrantLock lock ; 
 - private static final AtomicReferenceFieldUpdater < AtomicBTreePartitionBase , ReentrantLock > lockUpdater = AtomicReferenceFieldUpdater . newUpdater ( AtomicBTreePartitionBase . class , ReentrantLock . class , " lock " ) ; 
 - 
 - static 
 - { 
 - logger . info ( " Initializing Java 11 support for AtomicBTreePartition " ) ; 
 - 
 - if ( Runtime . version ( ) . version ( ) . get ( 0 ) < 11 ) 
 - throw new RuntimeException ( " Java 11 required , but found " + Runtime . version ( ) ) ; 
 - } 
 - 
 - protected final void acquireLock ( ) 
 - { 
 - if ( lock = = null ) 
 - lockUpdater . compareAndSet ( this , null , new ReentrantLock ( ) ) ; 
 - 
 - lock . lock ( ) ; 
 - } 
 - 
 - protected final void releaseLock ( ) 
 - { 
 - lock . unlock ( ) ; 
 - } 
 - } 
 diff - - git a / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java b / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java 
 deleted file mode 100644 
 index 32209e9 . . 0000000 
 - - - a / src / java8 / org / apache / cassandra / db / partitions / AtomicBTreePartitionBase . java 
 + + + / dev / null 
 @ @ - 1 , 81 + 0 , 0 @ @ 
 - / * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . db . partitions ; 
 - 
 - import sun . misc . Unsafe ; 
 - 
 - import java . lang . reflect . Field ; 
 - 
 - import org . slf4j . Logger ; 
 - import org . slf4j . LoggerFactory ; 
 - 
 - import org . apache . cassandra . db . DecoratedKey ; 
 - 
 - / * * 
 - * Java 8 version for the partition - locks in { @ link AtomicBTreePartition } . 
 - * / 
 - public abstract class AtomicBTreePartitionBase extends AbstractBTreePartition 
 - { 
 - private static final Logger logger = LoggerFactory . getLogger ( AtomicBTreePartitionBase . class ) ; 
 - private static final Unsafe unsafe ; 
 - 
 - static 
 - { 
 - logger . info ( " Initializing Java 8 support for AtomicBTreePartition " ) ; 
 - 
 - if ( ! System . getProperty ( " java . version " ) . startsWith ( " 1 . 8 . 0 " ) ) 
 - throw new RuntimeException ( " Java 8 required , but running " + System . getProperty ( " java . version " ) ) ; 
 - 
 - try 
 - { 
 - / / Safety . . . in case someone builds only on Java 8 but runs on Java 11 . . . 
 - sun . misc . Unsafe . class . getDeclaredMethod ( " monitorEnter " , Object . class ) ; 
 - sun . misc . Unsafe . class . getDeclaredMethod ( " monitorExit " , Object . class ) ; 
 - 
 - Field field = sun . misc . Unsafe . class . getDeclaredField ( " theUnsafe " ) ; 
 - field . setAccessible ( true ) ; 
 - unsafe = ( sun . misc . Unsafe ) field . get ( null ) ; 
 - } 
 - catch ( NoSuchFieldException | NoSuchMethodException e ) 
 - { 
 - throw new RuntimeException ( " This build of Cassandra has no support for Java 11 as only Java 8 was available during the build . This should never happen . " ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - } 
 - 
 - protected AtomicBTreePartitionBase ( DecoratedKey partitionKey ) 
 - { 
 - super ( partitionKey ) ; 
 - } 
 - 
 - protected final void acquireLock ( ) 
 - { 
 - if ( unsafe ! = null ) 
 - unsafe . monitorEnter ( this ) ; 
 - } 
 - 
 - protected final void releaseLock ( ) 
 - { 
 - if ( unsafe ! = null ) 
 - unsafe . monitorExit ( this ) ; 
 - } 
 - }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / net / FileStreamTask . java b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 index 724e9ae . . 34619da 100644 
 - - - a / src / java / org / apache / cassandra / net / FileStreamTask . java 
 + + + b / src / java / org / apache / cassandra / net / FileStreamTask . java 
 @ @ - 44 , 6 + 44 , 8 @ @ class FileStreamTask implements Runnable 
 
 public void run ( ) 
 { 
 + / * 
 + TODO 
 TcpConnection connection = null ; 
 try 
 { 
 @ @ - 61 , 6 + 63 , 6 @ @ class FileStreamTask implements Runnable 
 } 
 throw new RuntimeException ( e ) ; 
 } 
 + * / 
 } 
 - 
 } 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 96bad3c . . 11afaae 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 68 , 7 + 68 , 7 @ @ public class MessagingService implements IFailureDetectionEventListener 
 / * Thread pool to handle messaging write activities * / 
 private static ExecutorService streamExecutor _ ; 
 
 - private static NonBlockingHashMap < String , TcpConnectionManager > connectionManagers _ = new NonBlockingHashMap < String , TcpConnectionManager > ( ) ; 
 + private static NonBlockingHashMap < String , OutboundTcpConnectionPool > connectionManagers _ = new NonBlockingHashMap < String , OutboundTcpConnectionPool > ( ) ; 
 
 private static Logger logger _ = Logger . getLogger ( MessagingService . class ) ; 
 
 @ @ - 186 , 19 + 186 , 19 @ @ public class MessagingService implements IFailureDetectionEventListener 
 } 
 } 
 
 - public static TcpConnectionManager getConnectionPool ( InetAddress from , InetAddress to ) 
 + public static OutboundTcpConnectionPool getConnectionPool ( InetAddress from , InetAddress to ) 
 { 
 String key = from + " : " + to ; 
 - TcpConnectionManager cp = connectionManagers _ . get ( key ) ; 
 + OutboundTcpConnectionPool cp = connectionManagers _ . get ( key ) ; 
 if ( cp = = null ) 
 { 
 - connectionManagers _ . putIfAbsent ( key , new TcpConnectionManager ( from , to ) ) ; 
 + connectionManagers _ . putIfAbsent ( key , new OutboundTcpConnectionPool ( from , to ) ) ; 
 cp = connectionManagers _ . get ( key ) ; 
 } 
 return cp ; 
 } 
 
 - public static TcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) throws IOException 
 + public static OutboundTcpConnection getConnection ( InetAddress from , InetAddress to , Message msg ) 
 { 
 return getConnectionPool ( from , to ) . getConnection ( msg ) ; 
 } 
 @ @ - 331 , 20 + 331 , 9 @ @ public class MessagingService implements IFailureDetectionEventListener 
 assert data . length > 0 ; 
 ByteBuffer buffer = packIt ( data , false , false ) ; 
 
 - TcpConnection connection = null ; 
 - try 
 - { 
 - connection = MessagingService . getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 - connection . write ( buffer ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - if ( connection ! = null ) 
 - { 
 - connection . errorClose ( ) ; 
 - } 
 - logger _ . error ( " unexpected error writing " + message , e ) ; 
 - } 
 + OutboundTcpConnection connection = null ; 
 + connection = getConnection ( processedMessage . getFrom ( ) , to , message ) ; 
 + connection . write ( buffer ) ; 
 } 
 
 public IAsyncResult sendRR ( Message message , InetAddress to ) 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnection . java b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 new file mode 100644 
 index 0000000 . . f2ace82 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnection . java 
 @ @ - 0 , 0 + 1 , 97 @ @ 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . DataOutputStream ; 
 + import java . io . IOError ; 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + import java . net . Socket ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . concurrent . BlockingQueue ; 
 + import java . util . concurrent . LinkedBlockingQueue ; 
 + 
 + import org . apache . log4j . Logger ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class OutboundTcpConnection 
 + { 
 + private static Logger logger = Logger . getLogger ( OutboundTcpConnection . class ) ; 
 + 
 + public BlockingQueue < ByteBuffer > queue = new LinkedBlockingQueue < ByteBuffer > ( ) ; 
 + public DataOutputStream output ; 
 + public Socket socket ; 
 + 
 + / / TODO localEp is ignored , get rid of it 
 + public OutboundTcpConnection ( final OutboundTcpConnectionPool pool , InetAddress localEp , final InetAddress remoteEp ) 
 + { 
 + try 
 + { 
 + socket = new Socket ( remoteEp , DatabaseDescriptor . getStoragePort ( ) ) ; 
 + socket . setTcpNoDelay ( true ) ; 
 + output = new DataOutputStream ( socket . getOutputStream ( ) ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 + new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( socket ! = null ) 
 + { 
 + ByteBuffer bb ; 
 + try 
 + { 
 + bb = queue . take ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + try 
 + { 
 + output . write ( bb . array ( ) , 0 , bb . limit ( ) ) ; 
 + if ( queue . peek ( ) = = null ) 
 + { 
 + output . flush ( ) ; 
 + } 
 + } 
 + catch ( IOException e ) 
 + { 
 + logger . info ( " error writing to " + remoteEp ) ; 
 + pool . reset ( ) ; 
 + break ; 
 + } 
 + } 
 + } 
 + } , " WRITE - " + remoteEp ) . start ( ) ; 
 + } 
 + 
 + public void write ( ByteBuffer buffer ) 
 + { 
 + try 
 + { 
 + queue . put ( buffer ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + } 
 + 
 + public void closeSocket ( ) 
 + { 
 + try 
 + { 
 + socket . close ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " error closing socket " , e ) ; 
 + } 
 + socket = null ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java 
 new file mode 100644 
 index 0000000 . . 8ad66ca 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / net / OutboundTcpConnectionPool . java 
 @ @ - 0 , 0 + 1 , 72 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . net ; 
 + 
 + import java . io . IOException ; 
 + import java . net . InetAddress ; 
 + 
 + import org . apache . cassandra . concurrent . StageManager ; 
 + 
 + class OutboundTcpConnectionPool 
 + { 
 + private InetAddress localEp _ ; 
 + private InetAddress remoteEp _ ; 
 + private OutboundTcpConnection cmdCon ; 
 + private OutboundTcpConnection ackCon ; 
 + 
 + / / TODO localEp is ignored , get rid of it 
 + OutboundTcpConnectionPool ( InetAddress localEp , InetAddress remoteEp ) 
 + { 
 + localEp _ = localEp ; 
 + remoteEp _ = remoteEp ; 
 + } 
 + 
 + private OutboundTcpConnection newCon ( ) 
 + { 
 + return new OutboundTcpConnection ( this , localEp _ , remoteEp _ ) ; 
 + } 
 + 
 + / * * 
 + * returns the appropriate connection based on message type . 
 + * / 
 + synchronized OutboundTcpConnection getConnection ( Message msg ) 
 + { 
 + if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) 
 + { 
 + if ( ackCon = = null ) 
 + ackCon = newCon ( ) ; 
 + return ackCon ; 
 + } 
 + else 
 + { 
 + if ( cmdCon = = null ) 
 + cmdCon = newCon ( ) ; 
 + return cmdCon ; 
 + } 
 + } 
 + 
 + synchronized void reset ( ) 
 + { 
 + for ( OutboundTcpConnection con : new OutboundTcpConnection [ ] { cmdCon , ackCon } ) 
 + if ( con ! = null ) 
 + con . closeSocket ( ) ; 
 + cmdCon = null ; 
 + ackCon = null ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnection . java b / src / java / org / apache / cassandra / net / TcpConnection . java 
 deleted file mode 100644 
 index 01003d1 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / TcpConnection . java 
 + + + / dev / null 
 @ @ - 1 , 378 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . * ; 
 - import java . nio . ByteBuffer ; 
 - import java . nio . channels . FileChannel ; 
 - import java . nio . channels . SelectionKey ; 
 - import java . nio . channels . SocketChannel ; 
 - import java . util . * ; 
 - import java . util . concurrent . TimeUnit ; 
 - import java . util . concurrent . ConcurrentLinkedQueue ; 
 - import java . util . concurrent . locks . Condition ; 
 - import java . util . concurrent . locks . Lock ; 
 - import java . util . concurrent . locks . ReentrantLock ; 
 - import java . net . InetAddress ; 
 - import java . net . InetSocketAddress ; 
 - 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - 
 - import org . apache . log4j . Logger ; 
 - 
 - public class TcpConnection extends SelectionKeyHandler implements Comparable 
 - { 
 - / / logging and profiling . 
 - private static Logger logger _ = Logger . getLogger ( TcpConnection . class ) ; 
 - private SocketChannel socketChannel _ ; 
 - private SelectionKey key _ ; 
 - private TcpConnectionManager pool _ ; 
 - private boolean isIncoming _ = false ; 
 - private Queue < ByteBuffer > pendingWrites _ = new ConcurrentLinkedQueue < ByteBuffer > ( ) ; 
 - private InetAddress localEp _ ; 
 - private InetAddress remoteEp _ ; 
 - 
 - / * 
 - * Added for streaming support . We need the boolean 
 - * to indicate that this connection is used for 
 - * streaming . The Condition and the Lock are used 
 - * to signal the stream ( ) that it can continue 
 - * streaming when the socket becomes writable . 
 - * / 
 - private boolean bStream _ = false ; 
 - private Lock lock _ ; 
 - private Condition condition _ ; 
 - 
 - private TcpConnection ( InetAddress from , InetAddress to , TcpConnectionManager pool , boolean streaming ) throws IOException 
 - { 
 - socketChannel _ = SocketChannel . open ( ) ; 
 - socketChannel _ . socket ( ) . bind ( new InetSocketAddress ( from , 0 ) ) ; 
 - socketChannel _ . configureBlocking ( false ) ; 
 - 
 - localEp _ = from ; 
 - remoteEp _ = to ; 
 - 
 - if ( ! socketChannel _ . connect ( new InetSocketAddress ( remoteEp _ , DatabaseDescriptor . getStoragePort ( ) ) ) ) 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ CONNECT ) ; 
 - } 
 - else 
 - { 
 - key _ = SelectorManager . getSelectorManager ( ) . register ( socketChannel _ , this , SelectionKey . OP _ READ ) ; 
 - } 
 - 
 - if ( ( pool ! = null & & streaming ) | | ( pool = = null & & ! streaming ) ) 
 - throw new RuntimeException ( " Invalid configuration . You must either specify a pool or streaming , not both or neither . " ) ; 
 - 
 - if ( pool ! = null ) 
 - pool _ = pool ; 
 - if ( streaming ) 
 - { 
 - bStream _ = true ; 
 - lock _ = new ReentrantLock ( ) ; 
 - condition _ = lock _ . newCondition ( ) ; 
 - } 
 - } 
 - 
 - / / used from getConnection - outgoing 
 - TcpConnection ( TcpConnectionManager pool , InetAddress from , InetAddress to ) throws IOException 
 - { 
 - this ( from , to , pool , false ) ; 
 - } 
 - 
 - / * 
 - * Used for streaming purposes has no pooling semantics . 
 - * / 
 - TcpConnection ( InetAddress from , InetAddress to ) throws IOException 
 - { 
 - this ( from , to , null , true ) ; 
 - } 
 - 
 - public InetAddress getEndPoint ( ) 
 - { 
 - return remoteEp _ ; 
 - } 
 - 
 - public SocketChannel getSocketChannel ( ) 
 - { 
 - return socketChannel _ ; 
 - } 
 - 
 - public synchronized void write ( ByteBuffer buffer ) throws IOException 
 - { 
 - if ( ! pendingWrites _ . isEmpty ( ) | | ! socketChannel _ . isConnected ( ) ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - return ; 
 - } 
 - 
 - socketChannel _ . write ( buffer ) ; 
 - 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - 
 - public void stream ( File file , long startPosition , long endPosition ) throws IOException , InterruptedException 
 - { 
 - if ( ! bStream _ ) 
 - throw new IllegalStateException ( " Cannot stream since we are not set up to stream data . " ) ; 
 - 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - / * transfer 64MB in each attempt * / 
 - int limit = 64 * 1024 * 1024 ; 
 - long total = endPosition - startPosition ; 
 - / * keeps track of total number of bytes transferred * / 
 - long bytesWritten = 0L ; 
 - RandomAccessFile raf = new RandomAccessFile ( file , " r " ) ; 
 - FileChannel fc = raf . getChannel ( ) ; 
 - 
 - / * 
 - * If the connection is not yet established then wait for 
 - * the timeout period of 2 seconds . Attempt to reconnect 3 times and then 
 - * bail with an IOException . 
 - * / 
 - long waitTime = 2 ; 
 - int retry = 0 ; 
 - while ( ! socketChannel _ . isConnected ( ) ) 
 - { 
 - if ( retry = = 3 ) 
 - throw new IOException ( " Unable to connect to " + remoteEp _ + " after " + retry + " attempts . " ) ; 
 - condition _ . await ( waitTime , TimeUnit . SECONDS ) ; 
 - + + retry ; 
 - } 
 - 
 - while ( bytesWritten < total ) 
 - { 
 - if ( startPosition = = 0 ) 
 - { 
 - ByteBuffer buffer = MessagingService . constructStreamHeader ( false , true ) ; 
 - socketChannel _ . write ( buffer ) ; 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - pendingWrites _ . add ( buffer ) ; 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - condition _ . await ( ) ; 
 - } 
 - } 
 - 
 - long bytesTransferred ; 
 - try 
 - { 
 - / * returns the number of bytes transferred from file to the socket * / 
 - bytesTransferred = fc . transferTo ( startPosition , limit , socketChannel _ ) ; 
 - } 
 - catch ( IOException e ) 
 - { 
 - / / at least jdk1 . 6 . 0 on Linux seems to throw IOException 
 - / / when the socket is full . ( Bug fixed for 1 . 7 : http : / / bugs . sun . com / view _ bug . do ? bug _ id = 5103988 ) 
 - / / For now look for a specific string in for the message for the exception . 
 - if ( ! e . getMessage ( ) . startsWith ( " Resource temporarily unavailable " ) ) 
 - throw e ; 
 - Thread . sleep ( 10 ) ; 
 - continue ; 
 - } 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Bytes transferred " + bytesTransferred ) ; 
 - bytesWritten + = bytesTransferred ; 
 - startPosition + = bytesTransferred ; 
 - / * 
 - * If the number of bytes transferred is less than intended 
 - * then we need to wait till socket becomes writeable again . 
 - * / 
 - if ( bytesTransferred < limit & & bytesWritten ! = total ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - condition _ . await ( ) ; 
 - } 
 - } 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - private void resumeStreaming ( ) 
 - { 
 - / * if not in streaming mode do nothing * / 
 - if ( ! bStream _ ) 
 - return ; 
 - 
 - lock _ . lock ( ) ; 
 - try 
 - { 
 - condition _ . signal ( ) ; 
 - } 
 - finally 
 - { 
 - lock _ . unlock ( ) ; 
 - } 
 - } 
 - 
 - public boolean isConnected ( ) 
 - { 
 - return socketChannel _ . isConnected ( ) ; 
 - } 
 - 
 - public boolean equals ( Object o ) 
 - { 
 - if ( ! ( o instanceof TcpConnection ) ) 
 - return false ; 
 - 
 - TcpConnection rhs = ( TcpConnection ) o ; 
 - return localEp _ . equals ( rhs . localEp _ ) & & remoteEp _ . equals ( rhs . remoteEp _ ) ; 
 - } 
 - 
 - public int hashCode ( ) 
 - { 
 - return ( localEp _ + " : " + remoteEp _ ) . hashCode ( ) ; 
 - } 
 - 
 - public String toString ( ) 
 - { 
 - return socketChannel _ . toString ( ) ; 
 - } 
 - 
 - void closeSocket ( ) 
 - { 
 - if ( pendingWrites _ . size ( ) > 0 ) 
 - logger _ . warn ( " Closing down connection " + socketChannel _ + " with " + pendingWrites _ . size ( ) + " writes remaining . " ) ; 
 - cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - } 
 - 
 - void errorClose ( ) 
 - { 
 - logger _ . info ( " Closing errored connection " + socketChannel _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - cancel ( key _ ) ; 
 - pendingWrites _ . clear ( ) ; 
 - if ( pool _ ! = null ) 
 - pool _ . reset ( ) ; 
 - } 
 - 
 - private void cancel ( SelectionKey key ) 
 - { 
 - if ( key ! = null ) 
 - { 
 - key . cancel ( ) ; 
 - try 
 - { 
 - key . channel ( ) . close ( ) ; 
 - } 
 - catch ( IOException e ) { } 
 - } 
 - } 
 - 
 - / / called in the selector thread 
 - public void connect ( SelectionKey key ) 
 - { 
 - turnOffInterestOps ( key , SelectionKey . OP _ CONNECT ) ; 
 - try 
 - { 
 - if ( socketChannel _ . finishConnect ( ) ) 
 - { 
 - turnOnInterestOps ( key , SelectionKey . OP _ READ ) ; 
 - 
 - synchronized ( this ) 
 - { 
 - / / this will flush the pending 
 - if ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - resumeStreaming ( ) ; 
 - } 
 - else 
 - { 
 - logger _ . error ( " Closing connection because socket channel could not finishConnect . " ) ; ; 
 - errorClose ( ) ; 
 - } 
 - } 
 - catch ( IOException e ) 
 - { 
 - logger _ . error ( " Encountered IOException on connection : " + socketChannel _ , e ) ; 
 - errorClose ( ) ; 
 - } 
 - } 
 - 
 - / / called in the selector thread 
 - public void write ( SelectionKey key ) 
 - { 
 - turnOffInterestOps ( key , SelectionKey . OP _ WRITE ) ; 
 - doPendingWrites ( ) ; 
 - / * 
 - * This is executed only if we are in streaming mode . 
 - * Idea is that we read a chunk of data from a source 
 - * and wait to read the next from the source until we 
 - * are siganlled to do so from here . 
 - * / 
 - resumeStreaming ( ) ; 
 - } 
 - 
 - public void doPendingWrites ( ) 
 - { 
 - synchronized ( this ) 
 - { 
 - try 
 - { 
 - while ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - ByteBuffer buffer = pendingWrites _ . peek ( ) ; 
 - socketChannel _ . write ( buffer ) ; 
 - if ( buffer . remaining ( ) > 0 ) 
 - { 
 - break ; 
 - } 
 - pendingWrites _ . remove ( ) ; 
 - } 
 - 
 - } 
 - catch ( IOException ex ) 
 - { 
 - logger _ . error ( ex ) ; 
 - / / This is to fix the wierd Linux bug with NIO . 
 - errorClose ( ) ; 
 - } 
 - finally 
 - { 
 - if ( ! pendingWrites _ . isEmpty ( ) ) 
 - { 
 - turnOnInterestOps ( key _ , SelectionKey . OP _ WRITE ) ; 
 - } 
 - } 
 - } 
 - } 
 - 
 - public int compareTo ( Object o ) 
 - { 
 - if ( o instanceof TcpConnection ) 
 - { 
 - return pendingWrites _ . size ( ) - ( ( TcpConnection ) o ) . pendingWrites _ . size ( ) ; 
 - } 
 - 
 - throw new IllegalArgumentException ( ) ; 
 - } 
 - } 
 diff - - git a / src / java / org / apache / cassandra / net / TcpConnectionManager . java b / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 deleted file mode 100644 
 index 8cdfef2 . . 0000000 
 - - - a / src / java / org / apache / cassandra / net / TcpConnectionManager . java 
 + + + / dev / null 
 @ @ - 1 , 72 + 0 , 0 @ @ 
 - / * * 
 - * Licensed to the Apache Software Foundation ( ASF ) under one 
 - * or more contributor license agreements . See the NOTICE file 
 - * distributed with this work for additional information 
 - * regarding copyright ownership . The ASF licenses this file 
 - * to you under the Apache License , Version 2 . 0 ( the 
 - * " License " ) ; you may not use this file except in compliance 
 - * with the License . You may obtain a copy of the License at 
 - * 
 - * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 - * 
 - * Unless required by applicable law or agreed to in writing , software 
 - * distributed under the License is distributed on an " AS IS " BASIS , 
 - * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 - * See the License for the specific language governing permissions and 
 - * limitations under the License . 
 - * / 
 - 
 - package org . apache . cassandra . net ; 
 - 
 - import java . io . IOException ; 
 - import java . net . InetAddress ; 
 - 
 - import org . apache . cassandra . concurrent . StageManager ; 
 - 
 - class TcpConnectionManager 
 - { 
 - private InetAddress localEp _ ; 
 - private InetAddress remoteEp _ ; 
 - private TcpConnection cmdCon ; 
 - private TcpConnection ackCon ; 
 - 
 - TcpConnectionManager ( InetAddress localEp , InetAddress remoteEp ) 
 - { 
 - localEp _ = localEp ; 
 - remoteEp _ = remoteEp ; 
 - } 
 - 
 - private TcpConnection newCon ( ) throws IOException 
 - { 
 - TcpConnection con = new TcpConnection ( this , localEp _ , remoteEp _ ) ; 
 - return con ; 
 - } 
 - 
 - / * * 
 - * returns the appropriate connection based on message type . 
 - * / 
 - synchronized TcpConnection getConnection ( Message msg ) throws IOException 
 - { 
 - if ( StageManager . RESPONSE _ STAGE . equals ( msg . getMessageType ( ) ) ) 
 - { 
 - if ( ackCon = = null ) 
 - ackCon = newCon ( ) ; 
 - return ackCon ; 
 - } 
 - else 
 - { 
 - if ( cmdCon = = null ) 
 - cmdCon = newCon ( ) ; 
 - return cmdCon ; 
 - } 
 - } 
 - 
 - synchronized void reset ( ) 
 - { 
 - for ( TcpConnection con : new TcpConnection [ ] { cmdCon , ackCon } ) 
 - if ( con ! = null ) 
 - con . closeSocket ( ) ; 
 - cmdCon = null ; 
 - ackCon = null ; 
 - } 
 - }
