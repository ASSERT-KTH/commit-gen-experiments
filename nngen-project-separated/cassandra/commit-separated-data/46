BLEU SCORE: 0.04767707020457096

TEST MSG: Differentiate between slices and RTs when decoding legacy bounds
GENERATED MSG: Fix dealing with in - row RTs from thrift

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e349674 . . 4520989 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 18 <nl> + * Differentiate between slices and RTs when decoding legacy bounds ( CASSANDRA - 14919 ) <nl> * CommitLogReplayer . handleReplayError should print stack traces ( CASSANDRA - 14589 ) <nl> * Netty epoll IOExceptions caused by unclean client disconnects being logged at INFO ( CASSANDRA - 14909 ) <nl> * Unfiltered . isEmpty conflicts with Row extends AbstractCollection . isEmpty ( CASSANDRA - 14588 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index c80594c . . 9600355 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 201 , 7 + 201 , 17 @ @ public abstract class LegacyLayout <nl> return new LegacyCellName ( def . isStatic ( ) ? Clustering . STATIC _ CLUSTERING : clustering , def , collectionElement ) ; <nl> } <nl> <nl> - public static LegacyBound decodeBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) <nl> + public static LegacyBound decodeSliceBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) <nl> + { <nl> + return decodeBound ( metadata , bound , isStart , false ) ; <nl> + } <nl> + <nl> + public static LegacyBound decodeTombstoneBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) <nl> + { <nl> + return decodeBound ( metadata , bound , isStart , true ) ; <nl> + } <nl> + <nl> + private static LegacyBound decodeBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart , boolean isDeletion ) <nl> { <nl> if ( ! bound . hasRemaining ( ) ) <nl> return isStart ? LegacyBound . BOTTOM : LegacyBound . TOP ; <nl> @ @ - 223 , 25 + 233 , 35 @ @ public abstract class LegacyLayout <nl> assert ! isStatic | | <nl> ( components . size ( ) > = clusteringSize <nl> & & all ( components . subList ( 0 , clusteringSize ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER : : equals ) ) ; <nl> - / / There can be more components than the clustering size only in the case this is the bound of a collection <nl> - / / range tombstone . In which case , there is exactly one more component , and that component is the name of the <nl> - / / collection being selected / deleted . <nl> ColumnDefinition collectionName = null ; <nl> if ( components . size ( ) > clusteringSize ) <nl> { <nl> + / / For a deletion , there can be more components than the clustering size only in the case this is the <nl> + / / bound of a collection range tombstone . In such a case , there is exactly one more component , and that <nl> + / / component is the name of the collection being selected / deleted . <nl> + / / If the bound is not part of a deletion , it is from slice query filter . In this scnario , the column name <nl> + / / may be a valid , non - collection column or it may be an empty buffer , representing a row marker . In either <nl> + / / case , this needn ' t be included in the returned bound , so we pop the last element from the components <nl> + / / list but ensure that the collection name remains null . <nl> + <nl> assert clusteringSize + 1 = = components . size ( ) & & ! metadata . isCompactTable ( ) ; <nl> - / / pop the collection name from the back of the list of clusterings <nl> - ByteBuffer collectionNameBytes = components . remove ( clusteringSize ) ; <nl> - collectionName = metadata . getColumnDefinition ( collectionNameBytes ) ; <nl> - if ( collectionName = = null | | ! collectionName . isComplex ( ) ) { <nl> - collectionName = metadata . getDroppedColumnDefinition ( collectionNameBytes , isStatic ) ; <nl> - / / if no record of the column having ever existed is found , something is badly wrong <nl> - if ( collectionName = = null ) <nl> - throw new RuntimeException ( " Unknown collection column " + UTF8Type . instance . getString ( collectionNameBytes ) + " during deserialization " ) ; <nl> - / / if we do have a record of dropping this column but it wasn ' t previously complex , use a fake <nl> - / / column definition for safety ( see the comment on the constant declaration for details ) <nl> - if ( ! collectionName . isComplex ( ) ) <nl> - collectionName = INVALID _ DROPPED _ COMPLEX _ SUBSTITUTE _ COLUMN ; <nl> + / / pop the final element from the back of the list of clusterings <nl> + ByteBuffer columnNameBytes = components . remove ( clusteringSize ) ; <nl> + if ( isDeletion ) <nl> + { <nl> + collectionName = metadata . getColumnDefinition ( columnNameBytes ) ; <nl> + if ( collectionName = = null | | ! collectionName . isComplex ( ) ) <nl> + { <nl> + collectionName = metadata . getDroppedColumnDefinition ( columnNameBytes , isStatic ) ; <nl> + / / if no record of the column having ever existed is found , something is badly wrong <nl> + if ( collectionName = = null ) <nl> + throw new RuntimeException ( " Unknown collection column " + UTF8Type . instance . getString ( columnNameBytes ) + " during deserialization " ) ; <nl> + <nl> + / / if we do have a record of dropping this column but it wasn ' t previously complex , use a fake <nl> + / / column definition for safety ( see the comment on the constant declaration for details ) <nl> + if ( ! collectionName . isComplex ( ) ) <nl> + collectionName = INVALID _ DROPPED _ COMPLEX _ SUBSTITUTE _ COLUMN ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 1157 , 8 + 1177 , 8 @ @ public abstract class LegacyLayout <nl> <nl> public static LegacyRangeTombstone readLegacyRangeTombstoneBody ( CFMetaData metadata , DataInputPlus in , ByteBuffer boundname ) throws IOException <nl> { <nl> - LegacyBound min = decodeBound ( metadata , boundname , true ) ; <nl> - LegacyBound max = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; <nl> + LegacyBound min = decodeTombstoneBound ( metadata , boundname , true ) ; <nl> + LegacyBound max = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; <nl> DeletionTime dt = DeletionTime . serializer . deserialize ( in ) ; <nl> return new LegacyRangeTombstone ( min , max , dt ) ; <nl> } <nl> @ @ - 1903 , 8 + 1923 , 8 @ @ public abstract class LegacyLayout <nl> LegacyDeletionInfo delInfo = new LegacyDeletionInfo ( new MutableDeletionInfo ( topLevel ) ) ; <nl> for ( int i = 0 ; i < rangeCount ; i + + ) <nl> { <nl> - LegacyBound start = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; <nl> - LegacyBound end = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; <nl> + LegacyBound start = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; <nl> + LegacyBound end = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; <nl> int delTime = in . readInt ( ) ; <nl> long markedAt = in . readLong ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> index 0135d1e . . fd453ef 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> @ @ - 1090 , 7 + 1090 , 7 @ @ public abstract class ReadCommand implements ReadQuery <nl> int compositesToGroup = in . readInt ( ) ; <nl> <nl> / / command - level Composite " start " and " stop " <nl> - LegacyLayout . LegacyBound startBound = LegacyLayout . decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; <nl> + LegacyLayout . LegacyBound startBound = LegacyLayout . decodeSliceBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; <nl> <nl> ByteBufferUtil . readWithShortLength ( in ) ; / / the composite " stop " , which isn ' t actually needed <nl> <nl> @ @ - 1583 , 8 + 1583 , 8 @ @ public abstract class ReadCommand implements ReadQuery <nl> Slices . Builder slicesBuilder = new Slices . Builder ( metadata . comparator ) ; <nl> for ( int i = 0 ; i < numSlices ; i + + ) <nl> { <nl> - LegacyLayout . LegacyBound start = LegacyLayout . decodeBound ( metadata , startBuffers [ i ] , true ) ; <nl> - LegacyLayout . LegacyBound finish = LegacyLayout . decodeBound ( metadata , finishBuffers [ i ] , false ) ; <nl> + LegacyLayout . LegacyBound start = LegacyLayout . decodeSliceBound ( metadata , startBuffers [ i ] , true ) ; <nl> + LegacyLayout . LegacyBound finish = LegacyLayout . decodeSliceBound ( metadata , finishBuffers [ i ] , false ) ; <nl> <nl> if ( start . isStatic ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> index 256f651 . . 163eb2d 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> @ @ - 371 , 7 + 371 , 7 @ @ public class CassandraServer implements Cassandra . Iface <nl> / / Note that in thrift , the bounds are reversed if the query is reversed , but not internally . <nl> ByteBuffer start = range . reversed ? range . finish : range . start ; <nl> ByteBuffer finish = range . reversed ? range . start : range . finish ; <nl> - return Slices . with ( metadata . comparator , Slice . make ( LegacyLayout . decodeBound ( metadata , start , true ) . bound , LegacyLayout . decodeBound ( metadata , finish , false ) . bound ) ) ; <nl> + return Slices . with ( metadata . comparator , Slice . make ( LegacyLayout . decodeSliceBound ( metadata , start , true ) . bound , LegacyLayout . decodeSliceBound ( metadata , finish , false ) . bound ) ) ; <nl> } <nl> <nl> private ClusteringIndexFilter toInternalFilter ( CFMetaData metadata , ColumnParent parent , SlicePredicate predicate ) <nl> @ @ - 1242 , 8 + 1242 , 8 @ @ public class CassandraServer implements Cassandra . Iface <nl> { <nl> if ( del . super _ column = = null ) <nl> { <nl> - LegacyLayout . LegacyBound start = LegacyLayout . decodeBound ( cfm , del . predicate . getSlice _ range ( ) . start , true ) ; <nl> - LegacyLayout . LegacyBound end = LegacyLayout . decodeBound ( cfm , del . predicate . getSlice _ range ( ) . finish , false ) ; <nl> + LegacyLayout . LegacyBound start = LegacyLayout . decodeTombstoneBound ( cfm , del . predicate . getSlice _ range ( ) . start , true ) ; <nl> + LegacyLayout . LegacyBound end = LegacyLayout . decodeTombstoneBound ( cfm , del . predicate . getSlice _ range ( ) . finish , false ) ; <nl> delInfo . add ( cfm , new LegacyLayout . LegacyRangeTombstone ( start , end , new DeletionTime ( del . timestamp , nowInSec ) ) ) ; <nl> } <nl> else <nl> @ @ - 2426 , 8 + 2426 , 8 @ @ public class CassandraServer implements Cassandra . Iface <nl> for ( int i = 0 ; i < request . getColumn _ slices ( ) . size ( ) ; i + + ) <nl> { <nl> fixOptionalSliceParameters ( request . getColumn _ slices ( ) . get ( i ) ) ; <nl> - Slice . Bound start = LegacyLayout . decodeBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . start , true ) . bound ; <nl> - Slice . Bound finish = LegacyLayout . decodeBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . finish , false ) . bound ; <nl> + Slice . Bound start = LegacyLayout . decodeSliceBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . start , true ) . bound ; <nl> + Slice . Bound finish = LegacyLayout . decodeSliceBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . finish , false ) . bound ; <nl> <nl> int compare = metadata . comparator . compare ( start , finish ) ; <nl> if ( ! request . reversed & & compare > 0 )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e349674 . . 4520989 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 18 
 + * Differentiate between slices and RTs when decoding legacy bounds ( CASSANDRA - 14919 ) 
 * CommitLogReplayer . handleReplayError should print stack traces ( CASSANDRA - 14589 ) 
 * Netty epoll IOExceptions caused by unclean client disconnects being logged at INFO ( CASSANDRA - 14909 ) 
 * Unfiltered . isEmpty conflicts with Row extends AbstractCollection . isEmpty ( CASSANDRA - 14588 ) 
 diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index c80594c . . 9600355 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 201 , 7 + 201 , 17 @ @ public abstract class LegacyLayout 
 return new LegacyCellName ( def . isStatic ( ) ? Clustering . STATIC _ CLUSTERING : clustering , def , collectionElement ) ; 
 } 
 
 - public static LegacyBound decodeBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) 
 + public static LegacyBound decodeSliceBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) 
 + { 
 + return decodeBound ( metadata , bound , isStart , false ) ; 
 + } 
 + 
 + public static LegacyBound decodeTombstoneBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart ) 
 + { 
 + return decodeBound ( metadata , bound , isStart , true ) ; 
 + } 
 + 
 + private static LegacyBound decodeBound ( CFMetaData metadata , ByteBuffer bound , boolean isStart , boolean isDeletion ) 
 { 
 if ( ! bound . hasRemaining ( ) ) 
 return isStart ? LegacyBound . BOTTOM : LegacyBound . TOP ; 
 @ @ - 223 , 25 + 233 , 35 @ @ public abstract class LegacyLayout 
 assert ! isStatic | | 
 ( components . size ( ) > = clusteringSize 
 & & all ( components . subList ( 0 , clusteringSize ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER : : equals ) ) ; 
 - / / There can be more components than the clustering size only in the case this is the bound of a collection 
 - / / range tombstone . In which case , there is exactly one more component , and that component is the name of the 
 - / / collection being selected / deleted . 
 ColumnDefinition collectionName = null ; 
 if ( components . size ( ) > clusteringSize ) 
 { 
 + / / For a deletion , there can be more components than the clustering size only in the case this is the 
 + / / bound of a collection range tombstone . In such a case , there is exactly one more component , and that 
 + / / component is the name of the collection being selected / deleted . 
 + / / If the bound is not part of a deletion , it is from slice query filter . In this scnario , the column name 
 + / / may be a valid , non - collection column or it may be an empty buffer , representing a row marker . In either 
 + / / case , this needn ' t be included in the returned bound , so we pop the last element from the components 
 + / / list but ensure that the collection name remains null . 
 + 
 assert clusteringSize + 1 = = components . size ( ) & & ! metadata . isCompactTable ( ) ; 
 - / / pop the collection name from the back of the list of clusterings 
 - ByteBuffer collectionNameBytes = components . remove ( clusteringSize ) ; 
 - collectionName = metadata . getColumnDefinition ( collectionNameBytes ) ; 
 - if ( collectionName = = null | | ! collectionName . isComplex ( ) ) { 
 - collectionName = metadata . getDroppedColumnDefinition ( collectionNameBytes , isStatic ) ; 
 - / / if no record of the column having ever existed is found , something is badly wrong 
 - if ( collectionName = = null ) 
 - throw new RuntimeException ( " Unknown collection column " + UTF8Type . instance . getString ( collectionNameBytes ) + " during deserialization " ) ; 
 - / / if we do have a record of dropping this column but it wasn ' t previously complex , use a fake 
 - / / column definition for safety ( see the comment on the constant declaration for details ) 
 - if ( ! collectionName . isComplex ( ) ) 
 - collectionName = INVALID _ DROPPED _ COMPLEX _ SUBSTITUTE _ COLUMN ; 
 + / / pop the final element from the back of the list of clusterings 
 + ByteBuffer columnNameBytes = components . remove ( clusteringSize ) ; 
 + if ( isDeletion ) 
 + { 
 + collectionName = metadata . getColumnDefinition ( columnNameBytes ) ; 
 + if ( collectionName = = null | | ! collectionName . isComplex ( ) ) 
 + { 
 + collectionName = metadata . getDroppedColumnDefinition ( columnNameBytes , isStatic ) ; 
 + / / if no record of the column having ever existed is found , something is badly wrong 
 + if ( collectionName = = null ) 
 + throw new RuntimeException ( " Unknown collection column " + UTF8Type . instance . getString ( columnNameBytes ) + " during deserialization " ) ; 
 + 
 + / / if we do have a record of dropping this column but it wasn ' t previously complex , use a fake 
 + / / column definition for safety ( see the comment on the constant declaration for details ) 
 + if ( ! collectionName . isComplex ( ) ) 
 + collectionName = INVALID _ DROPPED _ COMPLEX _ SUBSTITUTE _ COLUMN ; 
 + } 
 } 
 } 
 
 @ @ - 1157 , 8 + 1177 , 8 @ @ public abstract class LegacyLayout 
 
 public static LegacyRangeTombstone readLegacyRangeTombstoneBody ( CFMetaData metadata , DataInputPlus in , ByteBuffer boundname ) throws IOException 
 { 
 - LegacyBound min = decodeBound ( metadata , boundname , true ) ; 
 - LegacyBound max = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; 
 + LegacyBound min = decodeTombstoneBound ( metadata , boundname , true ) ; 
 + LegacyBound max = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; 
 DeletionTime dt = DeletionTime . serializer . deserialize ( in ) ; 
 return new LegacyRangeTombstone ( min , max , dt ) ; 
 } 
 @ @ - 1903 , 8 + 1923 , 8 @ @ public abstract class LegacyLayout 
 LegacyDeletionInfo delInfo = new LegacyDeletionInfo ( new MutableDeletionInfo ( topLevel ) ) ; 
 for ( int i = 0 ; i < rangeCount ; i + + ) 
 { 
 - LegacyBound start = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; 
 - LegacyBound end = decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; 
 + LegacyBound start = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; 
 + LegacyBound end = decodeTombstoneBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , false ) ; 
 int delTime = in . readInt ( ) ; 
 long markedAt = in . readLong ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java 
 index 0135d1e . . fd453ef 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / ReadCommand . java 
 @ @ - 1090 , 7 + 1090 , 7 @ @ public abstract class ReadCommand implements ReadQuery 
 int compositesToGroup = in . readInt ( ) ; 
 
 / / command - level Composite " start " and " stop " 
 - LegacyLayout . LegacyBound startBound = LegacyLayout . decodeBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; 
 + LegacyLayout . LegacyBound startBound = LegacyLayout . decodeSliceBound ( metadata , ByteBufferUtil . readWithShortLength ( in ) , true ) ; 
 
 ByteBufferUtil . readWithShortLength ( in ) ; / / the composite " stop " , which isn ' t actually needed 
 
 @ @ - 1583 , 8 + 1583 , 8 @ @ public abstract class ReadCommand implements ReadQuery 
 Slices . Builder slicesBuilder = new Slices . Builder ( metadata . comparator ) ; 
 for ( int i = 0 ; i < numSlices ; i + + ) 
 { 
 - LegacyLayout . LegacyBound start = LegacyLayout . decodeBound ( metadata , startBuffers [ i ] , true ) ; 
 - LegacyLayout . LegacyBound finish = LegacyLayout . decodeBound ( metadata , finishBuffers [ i ] , false ) ; 
 + LegacyLayout . LegacyBound start = LegacyLayout . decodeSliceBound ( metadata , startBuffers [ i ] , true ) ; 
 + LegacyLayout . LegacyBound finish = LegacyLayout . decodeSliceBound ( metadata , finishBuffers [ i ] , false ) ; 
 
 if ( start . isStatic ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 index 256f651 . . 163eb2d 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 @ @ - 371 , 7 + 371 , 7 @ @ public class CassandraServer implements Cassandra . Iface 
 / / Note that in thrift , the bounds are reversed if the query is reversed , but not internally . 
 ByteBuffer start = range . reversed ? range . finish : range . start ; 
 ByteBuffer finish = range . reversed ? range . start : range . finish ; 
 - return Slices . with ( metadata . comparator , Slice . make ( LegacyLayout . decodeBound ( metadata , start , true ) . bound , LegacyLayout . decodeBound ( metadata , finish , false ) . bound ) ) ; 
 + return Slices . with ( metadata . comparator , Slice . make ( LegacyLayout . decodeSliceBound ( metadata , start , true ) . bound , LegacyLayout . decodeSliceBound ( metadata , finish , false ) . bound ) ) ; 
 } 
 
 private ClusteringIndexFilter toInternalFilter ( CFMetaData metadata , ColumnParent parent , SlicePredicate predicate ) 
 @ @ - 1242 , 8 + 1242 , 8 @ @ public class CassandraServer implements Cassandra . Iface 
 { 
 if ( del . super _ column = = null ) 
 { 
 - LegacyLayout . LegacyBound start = LegacyLayout . decodeBound ( cfm , del . predicate . getSlice _ range ( ) . start , true ) ; 
 - LegacyLayout . LegacyBound end = LegacyLayout . decodeBound ( cfm , del . predicate . getSlice _ range ( ) . finish , false ) ; 
 + LegacyLayout . LegacyBound start = LegacyLayout . decodeTombstoneBound ( cfm , del . predicate . getSlice _ range ( ) . start , true ) ; 
 + LegacyLayout . LegacyBound end = LegacyLayout . decodeTombstoneBound ( cfm , del . predicate . getSlice _ range ( ) . finish , false ) ; 
 delInfo . add ( cfm , new LegacyLayout . LegacyRangeTombstone ( start , end , new DeletionTime ( del . timestamp , nowInSec ) ) ) ; 
 } 
 else 
 @ @ - 2426 , 8 + 2426 , 8 @ @ public class CassandraServer implements Cassandra . Iface 
 for ( int i = 0 ; i < request . getColumn _ slices ( ) . size ( ) ; i + + ) 
 { 
 fixOptionalSliceParameters ( request . getColumn _ slices ( ) . get ( i ) ) ; 
 - Slice . Bound start = LegacyLayout . decodeBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . start , true ) . bound ; 
 - Slice . Bound finish = LegacyLayout . decodeBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . finish , false ) . bound ; 
 + Slice . Bound start = LegacyLayout . decodeSliceBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . start , true ) . bound ; 
 + Slice . Bound finish = LegacyLayout . decodeSliceBound ( metadata , request . getColumn _ slices ( ) . get ( i ) . finish , false ) . bound ; 
 
 int compare = metadata . comparator . compare ( start , finish ) ; 
 if ( ! request . reversed & & compare > 0 )

NEAREST DIFF:
ELIMINATEDSENTENCE
