BLEU SCORE: 0.016932492841722675

TEST MSG: Fix dropping collection column when it ' s the last regular column
GENERATED MSG: Reenable ALTER TABLE DROP with new semantics

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f489702 . . 6b610d7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 10 <nl> + * Fix dropping collection when it ' s the last regular column ( CASSANDRA - 7744 ) <nl> * Properly reject operations on list index with conditions ( CASSANDRA - 7499 ) <nl> * ( Hadoop ) allow ACFRW to limit nodes to local DC ( CASSANDRA - 7252 ) <nl> * ( cqlsh ) Wait up to 10 sec for a tracing session ( CASSANDRA - 7222 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 9db1c75 . . 296ecce 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 114 , 6 + 114 , 7 @ @ public final class CFMetaData <nl> + " keyspace _ name text , " <nl> + " columnfamily _ name text , " <nl> + " type text , " <nl> + + " is _ dense boolean , " <nl> + " comparator text , " <nl> + " subcomparator text , " <nl> + " comment text , " <nl> @ @ - 406 , 6 + 407 , 11 @ @ public final class CFMetaData <nl> public static final String DEFAULT _ COLUMN _ ALIAS = " column " ; <nl> public static final String DEFAULT _ VALUE _ ALIAS = " value " ; <nl> <nl> + / / We call dense a CF for which each component of the comparator is a clustering column , i . e . no <nl> + / / component is used to store a regular column names . In other words , non - composite static " thrift " <nl> + / / and CQL3 CF are * not * dense . <nl> + private volatile Boolean isDense ; / / null means " we don ' t know and need to infer from other data " <nl> + <nl> private volatile Map < ByteBuffer , ColumnDefinition > column _ metadata = new HashMap < > ( ) ; <nl> private volatile List < ColumnDefinition > partitionKeyColumns ; / / Always of size keyValidator . componentsCount , null padded if necessary <nl> private volatile List < ColumnDefinition > clusteringKeyColumns ; / / Of size comparator . componentsCount or comparator . componentsCount - 1 , null padded if necessary <nl> @ @ - 445 , 6 + 451 , 7 @ @ public final class CFMetaData <nl> public CFMetaData populateIoCacheOnFlush ( boolean prop ) { populateIoCacheOnFlush = prop ; return this ; } <nl> public CFMetaData droppedColumns ( Map < ByteBuffer , Long > cols ) { droppedColumns = cols ; return this ; } <nl> public CFMetaData triggers ( Map < String , TriggerDefinition > prop ) { triggers = prop ; return this ; } <nl> + public CFMetaData setDense ( Boolean prop ) { isDense = prop ; return this ; } <nl> <nl> public CFMetaData ( String keyspace , String name , ColumnFamilyType type , AbstractType < ? > comp , AbstractType < ? > subcc ) <nl> { <nl> @ @ - 597 , 6 + 604 , 7 @ @ public final class CFMetaData <nl> . populateIoCacheOnFlush ( oldCFMD . populateIoCacheOnFlush ) <nl> . droppedColumns ( new HashMap < > ( oldCFMD . droppedColumns ) ) <nl> . triggers ( new HashMap < > ( oldCFMD . triggers ) ) <nl> + . setDense ( oldCFMD . isDense ) <nl> . rebuild ( ) ; <nl> } <nl> <nl> @ @ - 817 , 6 + 825 , 7 @ @ public final class CFMetaData <nl> . append ( populateIoCacheOnFlush , rhs . populateIoCacheOnFlush ) <nl> . append ( droppedColumns , rhs . droppedColumns ) <nl> . append ( triggers , rhs . triggers ) <nl> + . append ( isDense , rhs . isDense ) <nl> . isEquals ( ) ; <nl> } <nl> <nl> @ @ - 1106 , 6 + 1115 , 8 @ @ public final class CFMetaData <nl> <nl> triggers = cfm . triggers ; <nl> <nl> + setDense ( cfm . isDense ) ; <nl> + <nl> rebuild ( ) ; <nl> logger . debug ( " application result is { } " , this ) ; <nl> } <nl> @ @ - 1640 , 6 + 1651 , 9 @ @ public final class CFMetaData <nl> for ( Map . Entry < ByteBuffer , Long > entry : droppedColumns . entrySet ( ) ) <nl> cf . addColumn ( new Column ( makeDroppedColumnName ( entry . getKey ( ) ) , LongType . instance . decompose ( entry . getValue ( ) ) , timestamp ) ) ; <nl> <nl> + cf . addColumn ( isDense = = null ? DeletedColumn . create ( ldt , timestamp , cfName , " is _ dense " ) <nl> + : Column . create ( isDense , timestamp , cfName , " is _ dense " ) ) ; <nl> + <nl> / / Save the CQL3 metadata " the old way " for compatibility sake <nl> cf . addColumn ( Column . create ( aliasesToJson ( partitionKeyColumns ) , timestamp , cfName , " key _ aliases " ) ) ; <nl> cf . addColumn ( Column . create ( aliasesToJson ( clusteringKeyColumns ) , timestamp , cfName , " column _ aliases " ) ) ; <nl> @ @ - 1695 , 6 + 1709 , 9 @ @ public final class CFMetaData <nl> if ( result . has ( " populate _ io _ cache _ on _ flush " ) ) <nl> cfm . populateIoCacheOnFlush ( result . getBoolean ( " populate _ io _ cache _ on _ flush " ) ) ; <nl> <nl> + if ( result . has ( " is _ dense " ) ) <nl> + cfm . setDense ( result . getBoolean ( " is _ dense " ) ) ; <nl> + <nl> / * <nl> * The info previously hold by key _ aliases , column _ aliases and value _ alias is now stored in column _ metadata ( because 1 ) this <nl> * make more sense and 2 ) this allow to store indexing information ) . <nl> @ @ - 1944 , 7 + 1961 , 8 @ @ public final class CFMetaData <nl> private void rebuildCQL3Metadata ( ) <nl> { <nl> List < ColumnDefinition > pkCols = nullInitializedList ( keyValidator . componentsCount ( ) ) ; <nl> - boolean isDense = isDense ( comparator , column _ metadata . values ( ) ) ; <nl> + if ( isDense = = null ) <nl> + setDense ( isDense ( comparator , column _ metadata . values ( ) ) ) ; <nl> int nbCkCols = isDense <nl> ? comparator . componentsCount ( ) <nl> : comparator . componentsCount ( ) - ( hasCollection ( ) ? 2 : 1 ) ; <nl> @ @ - 1983 , 7 + 2001 , 7 @ @ public final class CFMetaData <nl> clusteringKeyColumns = addDefaultColumnAliases ( ckCols ) ; <nl> regularColumns = regCols ; <nl> staticColumns = statCols ; <nl> - compactValueColumn = addDefaultValueAlias ( compactCol , isDense ) ; <nl> + compactValueColumn = addDefaultValueAlias ( compactCol ) ; <nl> } <nl> <nl> private List < ColumnDefinition > addDefaultKeyAliases ( List < ColumnDefinition > pkCols ) <nl> @ @ - 2032 , 7 + 2050 , 7 @ @ public final class CFMetaData <nl> return ckCols ; <nl> } <nl> <nl> - private ColumnDefinition addDefaultValueAlias ( ColumnDefinition compactValueDef , boolean isDense ) <nl> + private ColumnDefinition addDefaultValueAlias ( ColumnDefinition compactValueDef ) <nl> { <nl> if ( isDense ) <nl> { <nl> @ @ - 2063 , 19 + 2081 , 19 @ @ public final class CFMetaData <nl> * We call dense a CF for which each component of the comparator is a clustering column , i . e . no <nl> * component is used to store a regular column names . In other words , non - composite static " thrift " <nl> * and CQL3 CF are * not * dense . <nl> - * Note that his method is only used by rebuildCQL3Metadata . Once said metadata are built , finding <nl> - * if a CF is dense amounts more simply to check if clusteringKeyColumns . size ( ) = = comparator . componentsCount ( ) . <nl> + * We save whether the table is dense or not during table creation through CQL , but we don ' t have this <nl> + * information for table just created through thrift , nor for table prior to CASSANDRA - 7744 , so this <nl> + * method does its best to infer whether the table is dense or not based on other elements . <nl> * / <nl> private static boolean isDense ( AbstractType < ? > comparator , Collection < ColumnDefinition > defs ) <nl> { <nl> / * <nl> * As said above , this method is only here because we need to deal with thrift upgrades . <nl> * Once a CF has been " upgraded " , i . e . we ' ve rebuilt and save its CQL3 metadata at least once , <nl> - * then checking for isDense amounts to looking whether the maximum componentIndex for the <nl> - * CLUSTERING _ KEY ColumnDefinitions is equal to comparator . componentsCount ( ) - 1 or not . <nl> + * then we ' ll have saved the " is _ dense " value and will be good to go . <nl> * <nl> - * But non - upgraded thrift CF will have no such CLUSTERING _ KEY column definitions , so we need <nl> - * to infer that information without relying on them in that case . And for the most part this is <nl> + * But non - upgraded thrift CF ( and pre - 7744 CF ) will have no value for " is _ dense " , so we need <nl> + * to infer that information without relying on it in that case . And for the most part this is <nl> * easy , a CF that has at least one REGULAR definition is not dense . But the subtlety is that not <nl> * having a REGULAR definition may not mean dense because of CQL3 definitions that have only the <nl> * PRIMARY KEY defined . <nl> @ @ - 2106 , 7 + 2124 , 6 @ @ public final class CFMetaData <nl> return maxClusteringIdx > = 0 <nl> ? maxClusteringIdx = = comparator . componentsCount ( ) - 1 <nl> : ! hasRegular & & ! isCQL3OnlyPKComparator ( comparator ) ; <nl> - <nl> } <nl> <nl> private static boolean isCQL3OnlyPKComparator ( AbstractType < ? > comparator ) <nl> @ @ - 2197 , 6 + 2214 , 7 @ @ public final class CFMetaData <nl> . append ( " populateIoCacheOnFlush " , populateIoCacheOnFlush ) <nl> . append ( " droppedColumns " , droppedColumns ) <nl> . append ( " triggers " , triggers ) <nl> + . append ( " isDense " , isDense ) <nl> . toString ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> index 28c7fb2 . . 08ad069 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java <nl> @ @ - 51 , 6 + 51 , 8 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> private final List < ByteBuffer > columnAliases = new ArrayList < ByteBuffer > ( ) ; <nl> private ByteBuffer valueAlias ; <nl> <nl> + private boolean isDense ; <nl> + <nl> private final Map < ColumnIdentifier , AbstractType > columns = new HashMap < ColumnIdentifier , AbstractType > ( ) ; <nl> private final Set < ColumnIdentifier > staticColumns ; <nl> private final CFPropDefs properties ; <nl> @ @ - 153 , 7 + 155 , 8 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> { <nl> cfmd . defaultValidator ( defaultValidator ) <nl> . keyValidator ( keyValidator ) <nl> - . columnMetadata ( getColumns ( ) ) ; <nl> + . columnMetadata ( getColumns ( ) ) <nl> + . setDense ( isDense ) ; <nl> <nl> cfmd . addColumnMetadataFromAliases ( keyAliases , keyValidator , ColumnDefinition . Type . PARTITION _ KEY ) ; <nl> cfmd . addColumnMetadataFromAliases ( columnAliases , comparator , ColumnDefinition . Type . CLUSTERING _ KEY ) ; <nl> @ @ - 237 , 6 + 240 , 10 @ @ public class CreateTableStatement extends SchemaAlteringStatement <nl> } <nl> stmt . keyValidator = keyTypes . size ( ) = = 1 ? keyTypes . get ( 0 ) : CompositeType . getInstance ( keyTypes ) ; <nl> <nl> + / / Dense means that no part of the comparator stores a CQL column name . This means <nl> + / / COMPACT STORAGE with at least one columnAliases ( otherwise it ' s a thrift " static " CF ) . <nl> + stmt . isDense = useCompactStorage & & ! columnAliases . isEmpty ( ) ; <nl> + <nl> / / Handle column aliases <nl> if ( columnAliases . isEmpty ( ) ) <nl> {
NEAREST DIFF (one line): diff - - git a / debian / changelog b / debian / changelog <nl> index 739e38a . . 76bac83 100644 <nl> - - - a / debian / changelog <nl> + + + b / debian / changelog <nl> @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low <nl> <nl> * New release <nl> <nl> - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> <nl> cassandra ( 1 . 1 . 10 ) unstable ; urgency = low <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f489702 . . 6b610d7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 10 
 + * Fix dropping collection when it ' s the last regular column ( CASSANDRA - 7744 ) 
 * Properly reject operations on list index with conditions ( CASSANDRA - 7499 ) 
 * ( Hadoop ) allow ACFRW to limit nodes to local DC ( CASSANDRA - 7252 ) 
 * ( cqlsh ) Wait up to 10 sec for a tracing session ( CASSANDRA - 7222 ) 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 9db1c75 . . 296ecce 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 114 , 6 + 114 , 7 @ @ public final class CFMetaData 
 + " keyspace _ name text , " 
 + " columnfamily _ name text , " 
 + " type text , " 
 + + " is _ dense boolean , " 
 + " comparator text , " 
 + " subcomparator text , " 
 + " comment text , " 
 @ @ - 406 , 6 + 407 , 11 @ @ public final class CFMetaData 
 public static final String DEFAULT _ COLUMN _ ALIAS = " column " ; 
 public static final String DEFAULT _ VALUE _ ALIAS = " value " ; 
 
 + / / We call dense a CF for which each component of the comparator is a clustering column , i . e . no 
 + / / component is used to store a regular column names . In other words , non - composite static " thrift " 
 + / / and CQL3 CF are * not * dense . 
 + private volatile Boolean isDense ; / / null means " we don ' t know and need to infer from other data " 
 + 
 private volatile Map < ByteBuffer , ColumnDefinition > column _ metadata = new HashMap < > ( ) ; 
 private volatile List < ColumnDefinition > partitionKeyColumns ; / / Always of size keyValidator . componentsCount , null padded if necessary 
 private volatile List < ColumnDefinition > clusteringKeyColumns ; / / Of size comparator . componentsCount or comparator . componentsCount - 1 , null padded if necessary 
 @ @ - 445 , 6 + 451 , 7 @ @ public final class CFMetaData 
 public CFMetaData populateIoCacheOnFlush ( boolean prop ) { populateIoCacheOnFlush = prop ; return this ; } 
 public CFMetaData droppedColumns ( Map < ByteBuffer , Long > cols ) { droppedColumns = cols ; return this ; } 
 public CFMetaData triggers ( Map < String , TriggerDefinition > prop ) { triggers = prop ; return this ; } 
 + public CFMetaData setDense ( Boolean prop ) { isDense = prop ; return this ; } 
 
 public CFMetaData ( String keyspace , String name , ColumnFamilyType type , AbstractType < ? > comp , AbstractType < ? > subcc ) 
 { 
 @ @ - 597 , 6 + 604 , 7 @ @ public final class CFMetaData 
 . populateIoCacheOnFlush ( oldCFMD . populateIoCacheOnFlush ) 
 . droppedColumns ( new HashMap < > ( oldCFMD . droppedColumns ) ) 
 . triggers ( new HashMap < > ( oldCFMD . triggers ) ) 
 + . setDense ( oldCFMD . isDense ) 
 . rebuild ( ) ; 
 } 
 
 @ @ - 817 , 6 + 825 , 7 @ @ public final class CFMetaData 
 . append ( populateIoCacheOnFlush , rhs . populateIoCacheOnFlush ) 
 . append ( droppedColumns , rhs . droppedColumns ) 
 . append ( triggers , rhs . triggers ) 
 + . append ( isDense , rhs . isDense ) 
 . isEquals ( ) ; 
 } 
 
 @ @ - 1106 , 6 + 1115 , 8 @ @ public final class CFMetaData 
 
 triggers = cfm . triggers ; 
 
 + setDense ( cfm . isDense ) ; 
 + 
 rebuild ( ) ; 
 logger . debug ( " application result is { } " , this ) ; 
 } 
 @ @ - 1640 , 6 + 1651 , 9 @ @ public final class CFMetaData 
 for ( Map . Entry < ByteBuffer , Long > entry : droppedColumns . entrySet ( ) ) 
 cf . addColumn ( new Column ( makeDroppedColumnName ( entry . getKey ( ) ) , LongType . instance . decompose ( entry . getValue ( ) ) , timestamp ) ) ; 
 
 + cf . addColumn ( isDense = = null ? DeletedColumn . create ( ldt , timestamp , cfName , " is _ dense " ) 
 + : Column . create ( isDense , timestamp , cfName , " is _ dense " ) ) ; 
 + 
 / / Save the CQL3 metadata " the old way " for compatibility sake 
 cf . addColumn ( Column . create ( aliasesToJson ( partitionKeyColumns ) , timestamp , cfName , " key _ aliases " ) ) ; 
 cf . addColumn ( Column . create ( aliasesToJson ( clusteringKeyColumns ) , timestamp , cfName , " column _ aliases " ) ) ; 
 @ @ - 1695 , 6 + 1709 , 9 @ @ public final class CFMetaData 
 if ( result . has ( " populate _ io _ cache _ on _ flush " ) ) 
 cfm . populateIoCacheOnFlush ( result . getBoolean ( " populate _ io _ cache _ on _ flush " ) ) ; 
 
 + if ( result . has ( " is _ dense " ) ) 
 + cfm . setDense ( result . getBoolean ( " is _ dense " ) ) ; 
 + 
 / * 
 * The info previously hold by key _ aliases , column _ aliases and value _ alias is now stored in column _ metadata ( because 1 ) this 
 * make more sense and 2 ) this allow to store indexing information ) . 
 @ @ - 1944 , 7 + 1961 , 8 @ @ public final class CFMetaData 
 private void rebuildCQL3Metadata ( ) 
 { 
 List < ColumnDefinition > pkCols = nullInitializedList ( keyValidator . componentsCount ( ) ) ; 
 - boolean isDense = isDense ( comparator , column _ metadata . values ( ) ) ; 
 + if ( isDense = = null ) 
 + setDense ( isDense ( comparator , column _ metadata . values ( ) ) ) ; 
 int nbCkCols = isDense 
 ? comparator . componentsCount ( ) 
 : comparator . componentsCount ( ) - ( hasCollection ( ) ? 2 : 1 ) ; 
 @ @ - 1983 , 7 + 2001 , 7 @ @ public final class CFMetaData 
 clusteringKeyColumns = addDefaultColumnAliases ( ckCols ) ; 
 regularColumns = regCols ; 
 staticColumns = statCols ; 
 - compactValueColumn = addDefaultValueAlias ( compactCol , isDense ) ; 
 + compactValueColumn = addDefaultValueAlias ( compactCol ) ; 
 } 
 
 private List < ColumnDefinition > addDefaultKeyAliases ( List < ColumnDefinition > pkCols ) 
 @ @ - 2032 , 7 + 2050 , 7 @ @ public final class CFMetaData 
 return ckCols ; 
 } 
 
 - private ColumnDefinition addDefaultValueAlias ( ColumnDefinition compactValueDef , boolean isDense ) 
 + private ColumnDefinition addDefaultValueAlias ( ColumnDefinition compactValueDef ) 
 { 
 if ( isDense ) 
 { 
 @ @ - 2063 , 19 + 2081 , 19 @ @ public final class CFMetaData 
 * We call dense a CF for which each component of the comparator is a clustering column , i . e . no 
 * component is used to store a regular column names . In other words , non - composite static " thrift " 
 * and CQL3 CF are * not * dense . 
 - * Note that his method is only used by rebuildCQL3Metadata . Once said metadata are built , finding 
 - * if a CF is dense amounts more simply to check if clusteringKeyColumns . size ( ) = = comparator . componentsCount ( ) . 
 + * We save whether the table is dense or not during table creation through CQL , but we don ' t have this 
 + * information for table just created through thrift , nor for table prior to CASSANDRA - 7744 , so this 
 + * method does its best to infer whether the table is dense or not based on other elements . 
 * / 
 private static boolean isDense ( AbstractType < ? > comparator , Collection < ColumnDefinition > defs ) 
 { 
 / * 
 * As said above , this method is only here because we need to deal with thrift upgrades . 
 * Once a CF has been " upgraded " , i . e . we ' ve rebuilt and save its CQL3 metadata at least once , 
 - * then checking for isDense amounts to looking whether the maximum componentIndex for the 
 - * CLUSTERING _ KEY ColumnDefinitions is equal to comparator . componentsCount ( ) - 1 or not . 
 + * then we ' ll have saved the " is _ dense " value and will be good to go . 
 * 
 - * But non - upgraded thrift CF will have no such CLUSTERING _ KEY column definitions , so we need 
 - * to infer that information without relying on them in that case . And for the most part this is 
 + * But non - upgraded thrift CF ( and pre - 7744 CF ) will have no value for " is _ dense " , so we need 
 + * to infer that information without relying on it in that case . And for the most part this is 
 * easy , a CF that has at least one REGULAR definition is not dense . But the subtlety is that not 
 * having a REGULAR definition may not mean dense because of CQL3 definitions that have only the 
 * PRIMARY KEY defined . 
 @ @ - 2106 , 7 + 2124 , 6 @ @ public final class CFMetaData 
 return maxClusteringIdx > = 0 
 ? maxClusteringIdx = = comparator . componentsCount ( ) - 1 
 : ! hasRegular & & ! isCQL3OnlyPKComparator ( comparator ) ; 
 - 
 } 
 
 private static boolean isCQL3OnlyPKComparator ( AbstractType < ? > comparator ) 
 @ @ - 2197 , 6 + 2214 , 7 @ @ public final class CFMetaData 
 . append ( " populateIoCacheOnFlush " , populateIoCacheOnFlush ) 
 . append ( " droppedColumns " , droppedColumns ) 
 . append ( " triggers " , triggers ) 
 + . append ( " isDense " , isDense ) 
 . toString ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 index 28c7fb2 . . 08ad069 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CreateTableStatement . java 
 @ @ - 51 , 6 + 51 , 8 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 private final List < ByteBuffer > columnAliases = new ArrayList < ByteBuffer > ( ) ; 
 private ByteBuffer valueAlias ; 
 
 + private boolean isDense ; 
 + 
 private final Map < ColumnIdentifier , AbstractType > columns = new HashMap < ColumnIdentifier , AbstractType > ( ) ; 
 private final Set < ColumnIdentifier > staticColumns ; 
 private final CFPropDefs properties ; 
 @ @ - 153 , 7 + 155 , 8 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 { 
 cfmd . defaultValidator ( defaultValidator ) 
 . keyValidator ( keyValidator ) 
 - . columnMetadata ( getColumns ( ) ) ; 
 + . columnMetadata ( getColumns ( ) ) 
 + . setDense ( isDense ) ; 
 
 cfmd . addColumnMetadataFromAliases ( keyAliases , keyValidator , ColumnDefinition . Type . PARTITION _ KEY ) ; 
 cfmd . addColumnMetadataFromAliases ( columnAliases , comparator , ColumnDefinition . Type . CLUSTERING _ KEY ) ; 
 @ @ - 237 , 6 + 240 , 10 @ @ public class CreateTableStatement extends SchemaAlteringStatement 
 } 
 stmt . keyValidator = keyTypes . size ( ) = = 1 ? keyTypes . get ( 0 ) : CompositeType . getInstance ( keyTypes ) ; 
 
 + / / Dense means that no part of the comparator stores a CQL column name . This means 
 + / / COMPACT STORAGE with at least one columnAliases ( otherwise it ' s a thrift " static " CF ) . 
 + stmt . isDense = useCompactStorage & & ! columnAliases . isEmpty ( ) ; 
 + 
 / / Handle column aliases 
 if ( columnAliases . isEmpty ( ) ) 
 {

NEAREST DIFF:
diff - - git a / debian / changelog b / debian / changelog 
 index 739e38a . . 76bac83 100644 
 - - - a / debian / changelog 
 + + + b / debian / changelog 
 @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low 
 
 * New release 
 
 - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 
 + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 
 
 cassandra ( 1 . 1 . 10 ) unstable ; urgency = low 

