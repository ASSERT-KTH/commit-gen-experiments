BLEU SCORE: 0.06567274736060397

TEST MSG: Filter header only commit logs before recovery
GENERATED MSG: Add backpressure to compressed commit log

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a1f49cd . . 7ff61d3 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 15 <nl> + * Filter header only commit logs before recovery ( CASSANDRA - 13918 ) <nl> * AssertionError prepending to a list ( CASSANDRA - 13149 ) <nl> * Fix support for SuperColumn tables ( CASSANDRA - 12373 ) <nl> * Handle limit correctly on tables with strict liveness ( CASSANDRA - 13883 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> index b3b26dd . . 4fd263c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java <nl> @ @ - 25 , 18 + 25 , 15 @ @ import java . io . FileOutputStream ; <nl> import java . io . IOException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . concurrent . ExecutionException ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . zip . CRC32 ; <nl> <nl> import com . google . common . base . Predicate ; <nl> - import com . google . common . base . Throwables ; <nl> import com . google . common . collect . HashMultimap ; <nl> import com . google . common . collect . Iterables ; <nl> import com . google . common . collect . Multimap ; <nl> import com . google . common . collect . Ordering ; <nl> - import com . google . common . util . concurrent . Uninterruptibles ; <nl> <nl> import org . apache . commons . lang3 . StringUtils ; <nl> import org . slf4j . Logger ; <nl> @ @ - 138 , 11 + 135 , 59 @ @ public class CommitLogReplayer <nl> return new CommitLogReplayer ( commitLog , globalPosition , cfPersisted , replayFilter ) ; <nl> } <nl> <nl> + private static boolean shouldSkip ( File file ) throws IOException , ConfigurationException <nl> + { <nl> + CommitLogDescriptor desc = CommitLogDescriptor . fromFileName ( file . getName ( ) ) ; <nl> + if ( desc . version < CommitLogDescriptor . VERSION _ 21 ) <nl> + { <nl> + return false ; <nl> + } <nl> + try ( ChannelProxy channel = new ChannelProxy ( file ) ; <nl> + RandomAccessReader reader = RandomAccessReader . open ( channel ) ) <nl> + { <nl> + CommitLogDescriptor . readHeader ( reader ) ; <nl> + int end = reader . readInt ( ) ; <nl> + long filecrc = reader . readInt ( ) & 0xffffffffL ; <nl> + return end = = 0 & & filecrc = = 0 ; <nl> + } <nl> + } <nl> + <nl> + private static List < File > filterCommitLogFiles ( File [ ] toFilter ) <nl> + { <nl> + List < File > filtered = new ArrayList < > ( toFilter . length ) ; <nl> + for ( File file : toFilter ) <nl> + { <nl> + try <nl> + { <nl> + if ( shouldSkip ( file ) ) <nl> + { <nl> + logger . info ( " Skipping playback of empty log : { } " , file . getName ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + filtered . add ( file ) ; <nl> + } <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + / / let recover deal with it <nl> + filtered . add ( file ) ; <nl> + } <nl> + } <nl> + <nl> + return filtered ; <nl> + } <nl> + <nl> public void recover ( File [ ] clogs ) throws IOException <nl> { <nl> - int i ; <nl> - for ( i = 0 ; i < clogs . length ; + + i ) <nl> - recover ( clogs [ i ] , i + 1 = = clogs . length ) ; <nl> + List < File > filteredLogs = filterCommitLogFiles ( clogs ) ; <nl> + <nl> + int i = 0 ; <nl> + for ( File clog : filteredLogs ) <nl> + { <nl> + i + + ; <nl> + recover ( clog , i = = filteredLogs . size ( ) ) ; <nl> + } <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index f26f0dc . . 236a1b1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 315 , 7 + 315 , 7 @ @ public abstract class CommitLogSegment <nl> syncComplete . signalAll ( ) ; <nl> } <nl> <nl> - protected void writeSyncMarker ( ByteBuffer buffer , int offset , int filePos , int nextMarker ) <nl> + protected static void writeSyncMarker ( long id , ByteBuffer buffer , int offset , int filePos , int nextMarker ) <nl> { <nl> CRC32 crc = new CRC32 ( ) ; <nl> updateChecksumInt ( crc , ( int ) ( id & 0xFFFFFFFFL ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java b / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java <nl> index c73a30a . . c00ce18 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java <nl> @ @ - 134 , 7 + 134 , 7 @ @ public class CompressedSegment extends CommitLogSegment <nl> <nl> / / Only one thread can be here at a given time . <nl> / / Protected by synchronization on CommitLogSegment . sync ( ) . <nl> - writeSyncMarker ( compressedBuffer , 0 , ( int ) channel . position ( ) , ( int ) channel . position ( ) + compressedBuffer . remaining ( ) ) ; <nl> + writeSyncMarker ( id , compressedBuffer , 0 , ( int ) channel . position ( ) , ( int ) channel . position ( ) + compressedBuffer . remaining ( ) ) ; <nl> commitLog . allocator . addSize ( compressedBuffer . limit ( ) ) ; <nl> channel . write ( compressedBuffer ) ; <nl> assert channel . position ( ) - lastWrittenPos = = compressedBuffer . limit ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java b / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java <nl> index 326469f . . 3a16d91 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java <nl> @ @ - 77 , 7 + 77 , 7 @ @ public class MemoryMappedSegment extends CommitLogSegment <nl> <nl> / / write previous sync marker to point to next sync marker <nl> / / we don ' t chain the crcs here to ensure this method is idempotent if it fails <nl> - writeSyncMarker ( buffer , startMarker , startMarker , nextMarker ) ; <nl> + writeSyncMarker ( id , buffer , startMarker , startMarker , nextMarker ) ; <nl> <nl> try { <nl> SyncUtil . force ( ( MappedByteBuffer ) buffer ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java <nl> index 1543415 . . 9e9ee53 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java <nl> @ @ - 30 , 6 + 30 , 7 @ @ import java . util . function . BiConsumer ; <nl> import java . util . zip . CRC32 ; <nl> import java . util . zip . Checksum ; <nl> <nl> + import com . google . common . io . Files ; <nl> import org . junit . Assert ; <nl> import org . junit . Before ; <nl> import org . junit . BeforeClass ; <nl> @ @ - 134 , 6 + 135 , 58 @ @ public class CommitLogTest <nl> CommitLog . instance . recover ( new File [ ] { tmpFile ( CommitLogDescriptor . current _ version ) } ) ; <nl> } <nl> <nl> + / * * <nl> + * Since commit log segments can be allocated before they ' re needed , the commit log file with the highest <nl> + * id isn ' t neccesarily the last log that we wrote to . We should remove header only logs on recover so we <nl> + * can tolerate truncated logs <nl> + * / <nl> + @ Test <nl> + public void testHeaderOnlyFileFiltering ( ) throws Exception <nl> + { <nl> + File directory = Files . createTempDir ( ) ; <nl> + <nl> + CommitLogDescriptor desc1 = new CommitLogDescriptor ( CommitLogDescriptor . current _ version , 1 , null ) ; <nl> + CommitLogDescriptor desc2 = new CommitLogDescriptor ( CommitLogDescriptor . current _ version , 2 , null ) ; <nl> + <nl> + ByteBuffer buffer ; <nl> + <nl> + / / this has a header and malformed data <nl> + File file1 = new File ( directory , desc1 . fileName ( ) ) ; <nl> + buffer = ByteBuffer . allocate ( 1024 ) ; <nl> + CommitLogDescriptor . writeHeader ( buffer , desc1 ) ; <nl> + int pos = buffer . position ( ) ; <nl> + CommitLogSegment . writeSyncMarker ( desc1 . id , buffer , buffer . position ( ) , buffer . position ( ) , buffer . position ( ) + 128 ) ; <nl> + buffer . position ( pos + 8 ) ; <nl> + buffer . putInt ( 5 ) ; <nl> + buffer . putInt ( 6 ) ; <nl> + <nl> + try ( OutputStream lout = new FileOutputStream ( file1 ) ) <nl> + { <nl> + lout . write ( buffer . array ( ) ) ; <nl> + } <nl> + <nl> + / / this has only a header <nl> + File file2 = new File ( directory , desc2 . fileName ( ) ) ; <nl> + buffer = ByteBuffer . allocate ( 1024 ) ; <nl> + CommitLogDescriptor . writeHeader ( buffer , desc2 ) ; <nl> + try ( OutputStream lout = new FileOutputStream ( file2 ) ) <nl> + { <nl> + lout . write ( buffer . array ( ) ) ; <nl> + } <nl> + <nl> + / / one corrupt file and one header only file should be ok <nl> + runExpecting ( ( ) - > { <nl> + CommitLog . instance . recover ( file1 , file2 ) ; <nl> + return null ; <nl> + } , null ) ; <nl> + <nl> + / / 2 corrupt files and one header only file should fail <nl> + runExpecting ( ( ) - > { <nl> + CommitLog . instance . recover ( file1 , file1 , file2 ) ; <nl> + return null ; <nl> + } , CommitLogReplayException . class ) ; <nl> + } <nl> + <nl> @ Test <nl> public void testRecoveryWithEmptyLog20 ( ) throws Exception <nl> {
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a1f49cd . . 7ff61d3 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 15 
 + * Filter header only commit logs before recovery ( CASSANDRA - 13918 ) 
 * AssertionError prepending to a list ( CASSANDRA - 13149 ) 
 * Fix support for SuperColumn tables ( CASSANDRA - 12373 ) 
 * Handle limit correctly on tables with strict liveness ( CASSANDRA - 13883 ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 index b3b26dd . . 4fd263c 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogReplayer . java 
 @ @ - 25 , 18 + 25 , 15 @ @ import java . io . FileOutputStream ; 
 import java . io . IOException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . concurrent . ExecutionException ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . zip . CRC32 ; 
 
 import com . google . common . base . Predicate ; 
 - import com . google . common . base . Throwables ; 
 import com . google . common . collect . HashMultimap ; 
 import com . google . common . collect . Iterables ; 
 import com . google . common . collect . Multimap ; 
 import com . google . common . collect . Ordering ; 
 - import com . google . common . util . concurrent . Uninterruptibles ; 
 
 import org . apache . commons . lang3 . StringUtils ; 
 import org . slf4j . Logger ; 
 @ @ - 138 , 11 + 135 , 59 @ @ public class CommitLogReplayer 
 return new CommitLogReplayer ( commitLog , globalPosition , cfPersisted , replayFilter ) ; 
 } 
 
 + private static boolean shouldSkip ( File file ) throws IOException , ConfigurationException 
 + { 
 + CommitLogDescriptor desc = CommitLogDescriptor . fromFileName ( file . getName ( ) ) ; 
 + if ( desc . version < CommitLogDescriptor . VERSION _ 21 ) 
 + { 
 + return false ; 
 + } 
 + try ( ChannelProxy channel = new ChannelProxy ( file ) ; 
 + RandomAccessReader reader = RandomAccessReader . open ( channel ) ) 
 + { 
 + CommitLogDescriptor . readHeader ( reader ) ; 
 + int end = reader . readInt ( ) ; 
 + long filecrc = reader . readInt ( ) & 0xffffffffL ; 
 + return end = = 0 & & filecrc = = 0 ; 
 + } 
 + } 
 + 
 + private static List < File > filterCommitLogFiles ( File [ ] toFilter ) 
 + { 
 + List < File > filtered = new ArrayList < > ( toFilter . length ) ; 
 + for ( File file : toFilter ) 
 + { 
 + try 
 + { 
 + if ( shouldSkip ( file ) ) 
 + { 
 + logger . info ( " Skipping playback of empty log : { } " , file . getName ( ) ) ; 
 + } 
 + else 
 + { 
 + filtered . add ( file ) ; 
 + } 
 + } 
 + catch ( Exception e ) 
 + { 
 + / / let recover deal with it 
 + filtered . add ( file ) ; 
 + } 
 + } 
 + 
 + return filtered ; 
 + } 
 + 
 public void recover ( File [ ] clogs ) throws IOException 
 { 
 - int i ; 
 - for ( i = 0 ; i < clogs . length ; + + i ) 
 - recover ( clogs [ i ] , i + 1 = = clogs . length ) ; 
 + List < File > filteredLogs = filterCommitLogFiles ( clogs ) ; 
 + 
 + int i = 0 ; 
 + for ( File clog : filteredLogs ) 
 + { 
 + i + + ; 
 + recover ( clog , i = = filteredLogs . size ( ) ) ; 
 + } 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index f26f0dc . . 236a1b1 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 315 , 7 + 315 , 7 @ @ public abstract class CommitLogSegment 
 syncComplete . signalAll ( ) ; 
 } 
 
 - protected void writeSyncMarker ( ByteBuffer buffer , int offset , int filePos , int nextMarker ) 
 + protected static void writeSyncMarker ( long id , ByteBuffer buffer , int offset , int filePos , int nextMarker ) 
 { 
 CRC32 crc = new CRC32 ( ) ; 
 updateChecksumInt ( crc , ( int ) ( id & 0xFFFFFFFFL ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java b / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java 
 index c73a30a . . c00ce18 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CompressedSegment . java 
 @ @ - 134 , 7 + 134 , 7 @ @ public class CompressedSegment extends CommitLogSegment 
 
 / / Only one thread can be here at a given time . 
 / / Protected by synchronization on CommitLogSegment . sync ( ) . 
 - writeSyncMarker ( compressedBuffer , 0 , ( int ) channel . position ( ) , ( int ) channel . position ( ) + compressedBuffer . remaining ( ) ) ; 
 + writeSyncMarker ( id , compressedBuffer , 0 , ( int ) channel . position ( ) , ( int ) channel . position ( ) + compressedBuffer . remaining ( ) ) ; 
 commitLog . allocator . addSize ( compressedBuffer . limit ( ) ) ; 
 channel . write ( compressedBuffer ) ; 
 assert channel . position ( ) - lastWrittenPos = = compressedBuffer . limit ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java b / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java 
 index 326469f . . 3a16d91 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / MemoryMappedSegment . java 
 @ @ - 77 , 7 + 77 , 7 @ @ public class MemoryMappedSegment extends CommitLogSegment 
 
 / / write previous sync marker to point to next sync marker 
 / / we don ' t chain the crcs here to ensure this method is idempotent if it fails 
 - writeSyncMarker ( buffer , startMarker , startMarker , nextMarker ) ; 
 + writeSyncMarker ( id , buffer , startMarker , startMarker , nextMarker ) ; 
 
 try { 
 SyncUtil . force ( ( MappedByteBuffer ) buffer ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java b / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java 
 index 1543415 . . 9e9ee53 100644 
 - - - a / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java 
 + + + b / test / unit / org / apache / cassandra / db / commitlog / CommitLogTest . java 
 @ @ - 30 , 6 + 30 , 7 @ @ import java . util . function . BiConsumer ; 
 import java . util . zip . CRC32 ; 
 import java . util . zip . Checksum ; 
 
 + import com . google . common . io . Files ; 
 import org . junit . Assert ; 
 import org . junit . Before ; 
 import org . junit . BeforeClass ; 
 @ @ - 134 , 6 + 135 , 58 @ @ public class CommitLogTest 
 CommitLog . instance . recover ( new File [ ] { tmpFile ( CommitLogDescriptor . current _ version ) } ) ; 
 } 
 
 + / * * 
 + * Since commit log segments can be allocated before they ' re needed , the commit log file with the highest 
 + * id isn ' t neccesarily the last log that we wrote to . We should remove header only logs on recover so we 
 + * can tolerate truncated logs 
 + * / 
 + @ Test 
 + public void testHeaderOnlyFileFiltering ( ) throws Exception 
 + { 
 + File directory = Files . createTempDir ( ) ; 
 + 
 + CommitLogDescriptor desc1 = new CommitLogDescriptor ( CommitLogDescriptor . current _ version , 1 , null ) ; 
 + CommitLogDescriptor desc2 = new CommitLogDescriptor ( CommitLogDescriptor . current _ version , 2 , null ) ; 
 + 
 + ByteBuffer buffer ; 
 + 
 + / / this has a header and malformed data 
 + File file1 = new File ( directory , desc1 . fileName ( ) ) ; 
 + buffer = ByteBuffer . allocate ( 1024 ) ; 
 + CommitLogDescriptor . writeHeader ( buffer , desc1 ) ; 
 + int pos = buffer . position ( ) ; 
 + CommitLogSegment . writeSyncMarker ( desc1 . id , buffer , buffer . position ( ) , buffer . position ( ) , buffer . position ( ) + 128 ) ; 
 + buffer . position ( pos + 8 ) ; 
 + buffer . putInt ( 5 ) ; 
 + buffer . putInt ( 6 ) ; 
 + 
 + try ( OutputStream lout = new FileOutputStream ( file1 ) ) 
 + { 
 + lout . write ( buffer . array ( ) ) ; 
 + } 
 + 
 + / / this has only a header 
 + File file2 = new File ( directory , desc2 . fileName ( ) ) ; 
 + buffer = ByteBuffer . allocate ( 1024 ) ; 
 + CommitLogDescriptor . writeHeader ( buffer , desc2 ) ; 
 + try ( OutputStream lout = new FileOutputStream ( file2 ) ) 
 + { 
 + lout . write ( buffer . array ( ) ) ; 
 + } 
 + 
 + / / one corrupt file and one header only file should be ok 
 + runExpecting ( ( ) - > { 
 + CommitLog . instance . recover ( file1 , file2 ) ; 
 + return null ; 
 + } , null ) ; 
 + 
 + / / 2 corrupt files and one header only file should fail 
 + runExpecting ( ( ) - > { 
 + CommitLog . instance . recover ( file1 , file1 , file2 ) ; 
 + return null ; 
 + } , CommitLogReplayException . class ) ; 
 + } 
 + 
 @ Test 
 public void testRecoveryWithEmptyLog20 ( ) throws Exception 
 {

NEAREST DIFF:
ELIMINATEDSENTENCE
