BLEU SCORE: 0.041961149062965476

TEST MSG: Report why native _ transport _ port fails to bind
GENERATED MSG: make starting native protocol server idempotent

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e99c9ea . . df2db42 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Report why native _ transport _ port fails to bind ( CASSANDRA - 14544 ) <nl> * Optimize internode messaging protocol ( CASSANDRA - 14485 ) <nl> * Internode messaging handshake sends wrong messaging version number ( CASSANDRA - 14540 ) <nl> * Add a virtual table to expose active client connections ( CASSANDRA - 14458 ) <nl> diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java <nl> index 8ef137c . . 45146c4 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Server . java <nl> + + + b / src / java / org / apache / cassandra / transport / Server . java <nl> @ @ - 161 , 7 + 161 , 8 @ @ public class Server implements CassandraDaemon . Server <nl> <nl> ChannelFuture bindFuture = bootstrap . bind ( socket ) ; <nl> if ( ! bindFuture . awaitUninterruptibly ( ) . isSuccess ( ) ) <nl> - throw new IllegalStateException ( String . format ( " Failed to bind port % d on % s . " , socket . getPort ( ) , socket . getAddress ( ) . getHostAddress ( ) ) ) ; <nl> + throw new IllegalStateException ( String . format ( " Failed to bind port % d on % s . " , socket . getPort ( ) , socket . getAddress ( ) . getHostAddress ( ) ) , <nl> + bindFuture . cause ( ) ) ; <nl> <nl> connectionTracker . allChannels . add ( bindFuture . channel ( ) ) ; <nl> isRunning . set ( true ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index eaa5eea . . 4b7dcc5 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 72 , 6 + 72 , 7 @ @ <nl> * Move resultset type information into prepare , not execute ( CASSANDRA - 5649 ) <nl> * Auto paging in binary protocol ( CASSANDRA - 4415 , 5714 ) <nl> * Don ' t tie client side use of AbstractType to JDBC ( CASSANDRA - 4495 ) <nl> + * Adds new TimestampType to replace DateType ( CASSANDRA - 5723 ) <nl> <nl> <nl> 1 . 2 . 7 <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 7e12e2c . . 652f8c2 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 73 , 6 + 73 , 7 @ @ Features <nl> <nl> 1 . 2 . 7 <nl> = = = = = <nl> + <nl> Upgrading <nl> - - - - - - - - - <nl> - If you have decommissioned a node in the past 72 hours , it is imperative <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CQL3Type . java b / src / java / org / apache / cassandra / cql3 / CQL3Type . java <nl> index d7a4e8e . . aed3165 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CQL3Type . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CQL3Type . java <nl> @ @ - 41 , 7 + 41 , 7 @ @ public interface CQL3Type <nl> INET ( InetAddressType . instance ) , <nl> INT ( Int32Type . instance ) , <nl> TEXT ( UTF8Type . instance ) , <nl> - TIMESTAMP ( DateType . instance ) , <nl> + TIMESTAMP ( TimestampType . instance ) , <nl> UUID ( UUIDType . instance ) , <nl> VARCHAR ( UTF8Type . instance ) , <nl> VARINT ( IntegerType . instance ) , <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java b / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java <nl> index 9bee563 . . 25294d6 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java <nl> @ @ - 128 , 7 + 128 , 7 @ @ public class UntypedResultSet implements Iterable < UntypedResultSet . Row > <nl> <nl> public Date getTimestamp ( String column ) <nl> { <nl> - return DateType . instance . compose ( data . get ( column ) ) ; <nl> + return TimestampType . instance . compose ( data . get ( column ) ) ; <nl> } <nl> <nl> public long getLong ( String column ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java b / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java <nl> index e325e8f . . 18ccd56 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java <nl> @ @ - 21 , 7 + 21 , 7 @ @ import java . nio . ByteBuffer ; <nl> import java . util . Date ; <nl> import java . util . List ; <nl> <nl> - import org . apache . cassandra . db . marshal . DateType ; <nl> + import org . apache . cassandra . db . marshal . TimestampType ; <nl> import org . apache . cassandra . db . marshal . TimeUUIDType ; <nl> import org . apache . cassandra . db . marshal . LongType ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> @ @ - 43 , 27 + 43 , 27 @ @ public abstract class TimeuuidFcts <nl> } <nl> } ; <nl> <nl> - public static final Function minTimeuuidFct = new AbstractFunction ( " mintimeuuid " , TimeUUIDType . instance , DateType . instance ) <nl> + public static final Function minTimeuuidFct = new AbstractFunction ( " mintimeuuid " , TimeUUIDType . instance , TimestampType . instance ) <nl> { <nl> public ByteBuffer execute ( List < ByteBuffer > parameters ) <nl> { <nl> - return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . minTimeUUID ( DateType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; <nl> + return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . minTimeUUID ( TimestampType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; <nl> } <nl> } ; <nl> <nl> - public static final Function maxTimeuuidFct = new AbstractFunction ( " maxtimeuuid " , TimeUUIDType . instance , DateType . instance ) <nl> + public static final Function maxTimeuuidFct = new AbstractFunction ( " maxtimeuuid " , TimeUUIDType . instance , TimestampType . instance ) <nl> { <nl> public ByteBuffer execute ( List < ByteBuffer > parameters ) <nl> { <nl> - return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . maxTimeUUID ( DateType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; <nl> + return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . maxTimeUUID ( TimestampType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; <nl> } <nl> } ; <nl> <nl> - public static final Function dateOfFct = new AbstractFunction ( " dateof " , DateType . instance , TimeUUIDType . instance ) <nl> + public static final Function dateOfFct = new AbstractFunction ( " dateof " , TimestampType . instance , TimeUUIDType . instance ) <nl> { <nl> public ByteBuffer execute ( List < ByteBuffer > parameters ) <nl> { <nl> - return DateType . instance . decompose ( new Date ( UUIDGen . unixTimestamp ( UUIDGen . getUUID ( parameters . get ( 0 ) ) ) ) ) ; <nl> + return TimestampType . instance . decompose ( new Date ( UUIDGen . unixTimestamp ( UUIDGen . getUUID ( parameters . get ( 0 ) ) ) ) ) ; <nl> } <nl> } ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / AbstractType . java b / src / java / org / apache / cassandra / db / marshal / AbstractType . java <nl> index 07bf694 . . c9e94b7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / AbstractType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / AbstractType . java <nl> @ @ - 306 , 4 + 306 , 3 @ @ public abstract class AbstractType < T > implements Comparator < ByteBuffer > <nl> return false ; <nl> } <nl> } <nl> - <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / DateType . java b / src / java / org / apache / cassandra / db / marshal / DateType . java <nl> index dcd8c9f . . 7de69e8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / DateType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / DateType . java <nl> @ @ - 17 , 37 + 17 , 40 @ @ <nl> * / <nl> package org . apache . cassandra . db . marshal ; <nl> <nl> - import static org . apache . cassandra . type . DateSerializer . iso8601Patterns ; <nl> - <nl> import java . nio . ByteBuffer ; <nl> import java . text . ParseException ; <nl> import java . text . SimpleDateFormat ; <nl> import java . util . Date ; <nl> <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> import org . apache . cassandra . cql3 . CQL3Type ; <nl> import org . apache . cassandra . type . AbstractSerializer ; <nl> - import org . apache . cassandra . type . DateSerializer ; <nl> + import org . apache . cassandra . type . TimestampSerializer ; <nl> import org . apache . cassandra . type . MarshalException ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . commons . lang . time . DateUtils ; <nl> <nl> public class DateType extends AbstractType < Date > <nl> { <nl> + private static final Logger logger = LoggerFactory . getLogger ( DateType . class ) ; <nl> + <nl> public static final DateType instance = new DateType ( ) ; <nl> <nl> - static final String DEFAULT _ FORMAT = iso8601Patterns [ 3 ] ; <nl> + static final String DEFAULT _ FORMAT = TimestampSerializer . iso8601Patterns [ 3 ] ; <nl> static final SimpleDateFormat FORMATTER = new SimpleDateFormat ( DEFAULT _ FORMAT ) ; <nl> <nl> DateType ( ) { } / / singleton <nl> <nl> public Date compose ( ByteBuffer bytes ) <nl> { <nl> - return DateSerializer . instance . serialize ( bytes ) ; <nl> + return TimestampSerializer . instance . serialize ( bytes ) ; <nl> } <nl> <nl> public ByteBuffer decompose ( Date value ) <nl> { <nl> - return DateSerializer . instance . deserialize ( value ) ; <nl> + return TimestampSerializer . instance . deserialize ( value ) ; <nl> } <nl> <nl> public int compare ( ByteBuffer o1 , ByteBuffer o2 ) <nl> @ @ - 66 , 7 + 69 , 7 @ @ public class DateType extends AbstractType < Date > <nl> <nl> public String getString ( ByteBuffer bytes ) <nl> { <nl> - return DateSerializer . instance . getString ( bytes ) ; <nl> + return TimestampSerializer . instance . getString ( bytes ) ; <nl> } <nl> <nl> public ByteBuffer fromString ( String source ) throws MarshalException <nl> @ @ - 103 , 7 + 106 , 7 @ @ public class DateType extends AbstractType < Date > <nl> { <nl> try <nl> { <nl> - millis = DateUtils . parseDateStrictly ( source , iso8601Patterns ) . getTime ( ) ; <nl> + millis = DateUtils . parseDateStrictly ( source , TimestampSerializer . iso8601Patterns ) . getTime ( ) ; <nl> } <nl> catch ( ParseException e1 ) <nl> { <nl> @ @ - 114 , 18 + 117 , 31 @ @ public class DateType extends AbstractType < Date > <nl> return millis ; <nl> } <nl> <nl> - public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + @ Override <nl> + public boolean isCompatibleWith ( AbstractType < ? > previous ) <nl> { <nl> - DateSerializer . instance . validate ( bytes ) ; <nl> + if ( super . isCompatibleWith ( previous ) ) <nl> + return true ; <nl> + <nl> + if ( previous instanceof TimestampType ) <nl> + { <nl> + logger . warn ( " Changing from TimestampType to DateType is allowed , but be wary that they sort differently for pre - unix - epoch timestamps " <nl> + + " ( negative timestamp values ) and thus this change will corrupt your data if you have such negative timestamp . There is no " <nl> + + " reason to switch from DateType to TimestampType except if you were using DateType in the first place and switched to " <nl> + + " TimestampType by mistake . " ) ; <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> } <nl> <nl> - public CQL3Type asCQL3Type ( ) <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> { <nl> - return CQL3Type . Native . TIMESTAMP ; <nl> + TimestampSerializer . instance . validate ( bytes ) ; <nl> } <nl> <nl> public AbstractSerializer < Date > asComposer ( ) <nl> { <nl> - return DateSerializer . instance ; <nl> + return TimestampSerializer . instance ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / LongType . java b / src / java / org / apache / cassandra / db / marshal / LongType . java <nl> index 45edc2f . . 2570418 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / LongType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / LongType . java <nl> @ @ - 43 , 6 + 43 , 11 @ @ public class LongType extends AbstractType < Long > <nl> <nl> public int compare ( ByteBuffer o1 , ByteBuffer o2 ) <nl> { <nl> + return compareLongs ( o1 , o2 ) ; <nl> + } <nl> + <nl> + public static int compareLongs ( ByteBuffer o1 , ByteBuffer o2 ) <nl> + { <nl> if ( o1 . remaining ( ) = = 0 ) <nl> { <nl> return o2 . remaining ( ) = = 0 ? 0 : - 1 ; <nl> @ @ - 52 , 11 + 57 , 10 @ @ public class LongType extends AbstractType < Long > <nl> return 1 ; <nl> } <nl> <nl> - int diff = o1 . get ( o1 . position ( ) ) - o2 . get ( o2 . position ( ) ) ; <nl> + int diff = o1 . get ( o1 . position ( ) + o1 . arrayOffset ( ) ) - o2 . get ( o2 . position ( ) + o2 . arrayOffset ( ) ) ; <nl> if ( diff ! = 0 ) <nl> return diff ; <nl> <nl> - <nl> return ByteBufferUtil . compareUnsigned ( o1 , o2 ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / TimestampType . java b / src / java / org / apache / cassandra / db / marshal / TimestampType . java <nl> new file mode 100644 <nl> index 0000000 . . ee2140c <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / db / marshal / TimestampType . java <nl> @ @ - 0 , 0 + 1 , 145 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . db . marshal ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . text . ParseException ; <nl> + import java . util . Date ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . cql3 . CQL3Type ; <nl> + import org . apache . cassandra . type . AbstractSerializer ; <nl> + import org . apache . cassandra . type . MarshalException ; <nl> + import org . apache . cassandra . type . TimestampSerializer ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . commons . lang . time . DateUtils ; <nl> + <nl> + / * * <nl> + * Type for date - time values . <nl> + * <nl> + * This is meant as a replacement for DateType , as DateType wrongly compare <nl> + * pre - unix - epoch dates , sorting them * after * post - unix - epoch ones ( due to it ' s <nl> + * use of unsigned bytes comparison ) . <nl> + * / <nl> + public class TimestampType extends AbstractType < Date > <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( TimestampType . class ) ; <nl> + <nl> + public static final TimestampType instance = new TimestampType ( ) ; <nl> + <nl> + private TimestampType ( ) { } / / singleton <nl> + <nl> + public Date compose ( ByteBuffer bytes ) <nl> + { <nl> + return TimestampSerializer . instance . serialize ( bytes ) ; <nl> + } <nl> + <nl> + public ByteBuffer decompose ( Date value ) <nl> + { <nl> + return TimestampSerializer . instance . deserialize ( value ) ; <nl> + } <nl> + <nl> + public int compare ( ByteBuffer o1 , ByteBuffer o2 ) <nl> + { <nl> + return LongType . compareLongs ( o1 , o2 ) ; <nl> + } <nl> + <nl> + public String getString ( ByteBuffer bytes ) <nl> + { <nl> + return TimestampSerializer . instance . getString ( bytes ) ; <nl> + } <nl> + <nl> + public ByteBuffer fromString ( String source ) throws MarshalException <nl> + { <nl> + / / Return an empty ByteBuffer for an empty string . <nl> + if ( source . isEmpty ( ) ) <nl> + return ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> + <nl> + return ByteBufferUtil . bytes ( dateStringToTimestamp ( source ) ) ; <nl> + } <nl> + <nl> + public static long dateStringToTimestamp ( String source ) throws MarshalException <nl> + { <nl> + long millis ; <nl> + <nl> + if ( source . toLowerCase ( ) . equals ( " now " ) ) <nl> + { <nl> + millis = System . currentTimeMillis ( ) ; <nl> + } <nl> + / / Milliseconds since epoch ? <nl> + else if ( source . matches ( " ^ \ \ d + $ " ) ) <nl> + { <nl> + try <nl> + { <nl> + millis = Long . parseLong ( source ) ; <nl> + } <nl> + catch ( NumberFormatException e ) <nl> + { <nl> + throw new MarshalException ( String . format ( " unable to make long ( for date ) from : ' % s ' " , source ) , e ) ; <nl> + } <nl> + } <nl> + / / Last chance , attempt to parse as date - time string <nl> + else <nl> + { <nl> + try <nl> + { <nl> + millis = DateUtils . parseDateStrictly ( source , TimestampSerializer . iso8601Patterns ) . getTime ( ) ; <nl> + } <nl> + catch ( ParseException e1 ) <nl> + { <nl> + throw new MarshalException ( String . format ( " unable to coerce ' % s ' to a formatted date ( long ) " , source ) , e1 ) ; <nl> + } <nl> + } <nl> + <nl> + return millis ; <nl> + } <nl> + <nl> + public void validate ( ByteBuffer bytes ) throws MarshalException <nl> + { <nl> + TimestampSerializer . instance . validate ( bytes ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public boolean isCompatibleWith ( AbstractType < ? > previous ) <nl> + { <nl> + if ( super . isCompatibleWith ( previous ) ) <nl> + return true ; <nl> + <nl> + if ( previous instanceof DateType ) <nl> + { <nl> + logger . warn ( " Changing from DateType to TimestampType is allowed , but be wary that they sort differently for pre - unix - epoch timestamps " <nl> + + " ( negative timestamp values ) and thus this change will corrupt your data if you have such negative timestamp . So unless you " <nl> + + " know that you don ' t have * any * pre - unix - epoch timestamp you should change back to DateType " ) ; <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + public CQL3Type asCQL3Type ( ) <nl> + { <nl> + return CQL3Type . Native . TIMESTAMP ; <nl> + } <nl> + <nl> + public AbstractSerializer < Date > asComposer ( ) <nl> + { <nl> + return TimestampSerializer . instance ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / UUIDType . java b / src / java / org / apache / cassandra / db / marshal / UUIDType . java <nl> index 159cab3 . . 73021ee 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / UUIDType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / UUIDType . java <nl> @ @ - 30 , 7 + 30 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . UUIDGen ; <nl> import org . apache . commons . lang . time . DateUtils ; <nl> <nl> - import static org . apache . cassandra . type . DateSerializer . iso8601Patterns ; <nl> + import static org . apache . cassandra . type . TimestampSerializer . iso8601Patterns ; <nl> <nl> / * * <nl> * Compares UUIDs using the following criteria : < br > <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java b / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java <nl> index d1bc5e4 . . 9636cea 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java <nl> @ @ - 140 , 7 + 140 , 7 @ @ public abstract class AbstractCassandraStorage extends LoadFunc implements Store <nl> else if ( value instanceof UUID ) <nl> pair . set ( position , new DataByteArray ( UUIDGen . decompose ( ( java . util . UUID ) value ) ) ) ; <nl> else if ( value instanceof Date ) <nl> - pair . set ( position , DateType . instance . decompose ( ( Date ) value ) . getLong ( ) ) ; <nl> + pair . set ( position , TimestampType . instance . decompose ( ( Date ) value ) . getLong ( ) ) ; <nl> else <nl> pair . set ( position , value ) ; <nl> } <nl> @ @ - 299 , 7 + 299 , 7 @ @ public abstract class AbstractCassandraStorage extends LoadFunc implements Store <nl> / * * get pig type for the cassandra data type * / <nl> protected byte getPigType ( AbstractType type ) <nl> { <nl> - if ( type instanceof LongType | | type instanceof DateType ) / / DateType is bad and it should feel bad <nl> + if ( type instanceof LongType | | type instanceof DateType | | type instanceof TimestampType ) / / DateType is bad and it should feel bad <nl> return DataType . LONG ; <nl> else if ( type instanceof IntegerType | | type instanceof Int32Type ) / / IntegerType will overflow at 2 * * 31 , but is kept for compatibility until pig has a BigInteger <nl> return DataType . INTEGER ; <nl> diff - - git a / src / java / org / apache / cassandra / tools / Shuffle . java b / src / java / org / apache / cassandra / tools / Shuffle . java <nl> index 5749a81 . . 0c5c92a 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / Shuffle . java <nl> + + + b / src / java / org / apache / cassandra / tools / Shuffle . java <nl> @ @ - 43 , 7 + 43 , 7 @ @ import javax . management . MBeanServerConnection ; <nl> import javax . management . MalformedObjectNameException ; <nl> import javax . management . ObjectName ; <nl> <nl> - import org . apache . cassandra . type . DateSerializer ; <nl> + import org . apache . cassandra . type . TimestampSerializer ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; <nl> @ @ - 389 , 7 + 389 , 7 @ @ public class Shuffle extends AbstractJmxClient <nl> <nl> ByteBuffer tokenBytes = ByteBuffer . wrap ( row . getColumns ( ) . get ( 0 ) . getValue ( ) ) ; <nl> ByteBuffer requestedAt = ByteBuffer . wrap ( row . getColumns ( ) . get ( 1 ) . getValue ( ) ) ; <nl> - Date time = DateSerializer . instance . serialize ( requestedAt ) ; <nl> + Date time = TimestampSerializer . instance . serialize ( requestedAt ) ; <nl> Token < ? > token = partitioner . getTokenFactory ( ) . fromByteArray ( tokenBytes ) ; <nl> <nl> writeln ( " % - 42s % - 15s % s " , token . toString ( ) , host , time . toString ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / transport / DataType . java b / src / java / org / apache / cassandra / transport / DataType . java <nl> index 21f4d03 . . b590042 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / DataType . java <nl> + + + b / src / java / org / apache / cassandra / transport / DataType . java <nl> @ @ - 43 , 7 + 43 , 7 @ @ public enum DataType implements OptionCodec . Codecable < DataType > <nl> FLOAT ( 8 , FloatType . instance ) , <nl> INT ( 9 , Int32Type . instance ) , <nl> TEXT ( 10 , UTF8Type . instance ) , <nl> - TIMESTAMP ( 11 , DateType . instance ) , <nl> + TIMESTAMP ( 11 , TimestampType . instance ) , <nl> UUID ( 12 , UUIDType . instance ) , <nl> VARCHAR ( 13 , UTF8Type . instance ) , <nl> VARINT ( 14 , IntegerType . instance ) , <nl> @ @ - 146 , 6 + 146 , 9 @ @ public enum DataType implements OptionCodec . Codecable < DataType > <nl> / / shouldn ' t have to care about it . <nl> if ( type instanceof ReversedType ) <nl> type = ( ( ReversedType ) type ) . baseType ; <nl> + / / For compatibility sake , we still return DateType as the timestamp type in resultSet metadata

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e99c9ea . . df2db42 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Report why native _ transport _ port fails to bind ( CASSANDRA - 14544 ) 
 * Optimize internode messaging protocol ( CASSANDRA - 14485 ) 
 * Internode messaging handshake sends wrong messaging version number ( CASSANDRA - 14540 ) 
 * Add a virtual table to expose active client connections ( CASSANDRA - 14458 ) 
 diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java 
 index 8ef137c . . 45146c4 100644 
 - - - a / src / java / org / apache / cassandra / transport / Server . java 
 + + + b / src / java / org / apache / cassandra / transport / Server . java 
 @ @ - 161 , 7 + 161 , 8 @ @ public class Server implements CassandraDaemon . Server 
 
 ChannelFuture bindFuture = bootstrap . bind ( socket ) ; 
 if ( ! bindFuture . awaitUninterruptibly ( ) . isSuccess ( ) ) 
 - throw new IllegalStateException ( String . format ( " Failed to bind port % d on % s . " , socket . getPort ( ) , socket . getAddress ( ) . getHostAddress ( ) ) ) ; 
 + throw new IllegalStateException ( String . format ( " Failed to bind port % d on % s . " , socket . getPort ( ) , socket . getAddress ( ) . getHostAddress ( ) ) , 
 + bindFuture . cause ( ) ) ; 
 
 connectionTracker . allChannels . add ( bindFuture . channel ( ) ) ; 
 isRunning . set ( true ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index eaa5eea . . 4b7dcc5 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 72 , 6 + 72 , 7 @ @ 
 * Move resultset type information into prepare , not execute ( CASSANDRA - 5649 ) 
 * Auto paging in binary protocol ( CASSANDRA - 4415 , 5714 ) 
 * Don ' t tie client side use of AbstractType to JDBC ( CASSANDRA - 4495 ) 
 + * Adds new TimestampType to replace DateType ( CASSANDRA - 5723 ) 
 
 
 1 . 2 . 7 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 7e12e2c . . 652f8c2 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 73 , 6 + 73 , 7 @ @ Features 
 
 1 . 2 . 7 
 = = = = = 
 + 
 Upgrading 
 - - - - - - - - - 
 - If you have decommissioned a node in the past 72 hours , it is imperative 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CQL3Type . java b / src / java / org / apache / cassandra / cql3 / CQL3Type . java 
 index d7a4e8e . . aed3165 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CQL3Type . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CQL3Type . java 
 @ @ - 41 , 7 + 41 , 7 @ @ public interface CQL3Type 
 INET ( InetAddressType . instance ) , 
 INT ( Int32Type . instance ) , 
 TEXT ( UTF8Type . instance ) , 
 - TIMESTAMP ( DateType . instance ) , 
 + TIMESTAMP ( TimestampType . instance ) , 
 UUID ( UUIDType . instance ) , 
 VARCHAR ( UTF8Type . instance ) , 
 VARINT ( IntegerType . instance ) , 
 diff - - git a / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java b / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java 
 index 9bee563 . . 25294d6 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java 
 + + + b / src / java / org / apache / cassandra / cql3 / UntypedResultSet . java 
 @ @ - 128 , 7 + 128 , 7 @ @ public class UntypedResultSet implements Iterable < UntypedResultSet . Row > 
 
 public Date getTimestamp ( String column ) 
 { 
 - return DateType . instance . compose ( data . get ( column ) ) ; 
 + return TimestampType . instance . compose ( data . get ( column ) ) ; 
 } 
 
 public long getLong ( String column ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java b / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java 
 index e325e8f . . 18ccd56 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / TimeuuidFcts . java 
 @ @ - 21 , 7 + 21 , 7 @ @ import java . nio . ByteBuffer ; 
 import java . util . Date ; 
 import java . util . List ; 
 
 - import org . apache . cassandra . db . marshal . DateType ; 
 + import org . apache . cassandra . db . marshal . TimestampType ; 
 import org . apache . cassandra . db . marshal . TimeUUIDType ; 
 import org . apache . cassandra . db . marshal . LongType ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 @ @ - 43 , 27 + 43 , 27 @ @ public abstract class TimeuuidFcts 
 } 
 } ; 
 
 - public static final Function minTimeuuidFct = new AbstractFunction ( " mintimeuuid " , TimeUUIDType . instance , DateType . instance ) 
 + public static final Function minTimeuuidFct = new AbstractFunction ( " mintimeuuid " , TimeUUIDType . instance , TimestampType . instance ) 
 { 
 public ByteBuffer execute ( List < ByteBuffer > parameters ) 
 { 
 - return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . minTimeUUID ( DateType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; 
 + return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . minTimeUUID ( TimestampType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; 
 } 
 } ; 
 
 - public static final Function maxTimeuuidFct = new AbstractFunction ( " maxtimeuuid " , TimeUUIDType . instance , DateType . instance ) 
 + public static final Function maxTimeuuidFct = new AbstractFunction ( " maxtimeuuid " , TimeUUIDType . instance , TimestampType . instance ) 
 { 
 public ByteBuffer execute ( List < ByteBuffer > parameters ) 
 { 
 - return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . maxTimeUUID ( DateType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; 
 + return ByteBuffer . wrap ( UUIDGen . decompose ( UUIDGen . maxTimeUUID ( TimestampType . instance . compose ( parameters . get ( 0 ) ) . getTime ( ) ) ) ) ; 
 } 
 } ; 
 
 - public static final Function dateOfFct = new AbstractFunction ( " dateof " , DateType . instance , TimeUUIDType . instance ) 
 + public static final Function dateOfFct = new AbstractFunction ( " dateof " , TimestampType . instance , TimeUUIDType . instance ) 
 { 
 public ByteBuffer execute ( List < ByteBuffer > parameters ) 
 { 
 - return DateType . instance . decompose ( new Date ( UUIDGen . unixTimestamp ( UUIDGen . getUUID ( parameters . get ( 0 ) ) ) ) ) ; 
 + return TimestampType . instance . decompose ( new Date ( UUIDGen . unixTimestamp ( UUIDGen . getUUID ( parameters . get ( 0 ) ) ) ) ) ; 
 } 
 } ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / AbstractType . java b / src / java / org / apache / cassandra / db / marshal / AbstractType . java 
 index 07bf694 . . c9e94b7 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / AbstractType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / AbstractType . java 
 @ @ - 306 , 4 + 306 , 3 @ @ public abstract class AbstractType < T > implements Comparator < ByteBuffer > 
 return false ; 
 } 
 } 
 - 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / DateType . java b / src / java / org / apache / cassandra / db / marshal / DateType . java 
 index dcd8c9f . . 7de69e8 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / DateType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / DateType . java 
 @ @ - 17 , 37 + 17 , 40 @ @ 
 * / 
 package org . apache . cassandra . db . marshal ; 
 
 - import static org . apache . cassandra . type . DateSerializer . iso8601Patterns ; 
 - 
 import java . nio . ByteBuffer ; 
 import java . text . ParseException ; 
 import java . text . SimpleDateFormat ; 
 import java . util . Date ; 
 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 import org . apache . cassandra . cql3 . CQL3Type ; 
 import org . apache . cassandra . type . AbstractSerializer ; 
 - import org . apache . cassandra . type . DateSerializer ; 
 + import org . apache . cassandra . type . TimestampSerializer ; 
 import org . apache . cassandra . type . MarshalException ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . commons . lang . time . DateUtils ; 
 
 public class DateType extends AbstractType < Date > 
 { 
 + private static final Logger logger = LoggerFactory . getLogger ( DateType . class ) ; 
 + 
 public static final DateType instance = new DateType ( ) ; 
 
 - static final String DEFAULT _ FORMAT = iso8601Patterns [ 3 ] ; 
 + static final String DEFAULT _ FORMAT = TimestampSerializer . iso8601Patterns [ 3 ] ; 
 static final SimpleDateFormat FORMATTER = new SimpleDateFormat ( DEFAULT _ FORMAT ) ; 
 
 DateType ( ) { } / / singleton 
 
 public Date compose ( ByteBuffer bytes ) 
 { 
 - return DateSerializer . instance . serialize ( bytes ) ; 
 + return TimestampSerializer . instance . serialize ( bytes ) ; 
 } 
 
 public ByteBuffer decompose ( Date value ) 
 { 
 - return DateSerializer . instance . deserialize ( value ) ; 
 + return TimestampSerializer . instance . deserialize ( value ) ; 
 } 
 
 public int compare ( ByteBuffer o1 , ByteBuffer o2 ) 
 @ @ - 66 , 7 + 69 , 7 @ @ public class DateType extends AbstractType < Date > 
 
 public String getString ( ByteBuffer bytes ) 
 { 
 - return DateSerializer . instance . getString ( bytes ) ; 
 + return TimestampSerializer . instance . getString ( bytes ) ; 
 } 
 
 public ByteBuffer fromString ( String source ) throws MarshalException 
 @ @ - 103 , 7 + 106 , 7 @ @ public class DateType extends AbstractType < Date > 
 { 
 try 
 { 
 - millis = DateUtils . parseDateStrictly ( source , iso8601Patterns ) . getTime ( ) ; 
 + millis = DateUtils . parseDateStrictly ( source , TimestampSerializer . iso8601Patterns ) . getTime ( ) ; 
 } 
 catch ( ParseException e1 ) 
 { 
 @ @ - 114 , 18 + 117 , 31 @ @ public class DateType extends AbstractType < Date > 
 return millis ; 
 } 
 
 - public void validate ( ByteBuffer bytes ) throws MarshalException 
 + @ Override 
 + public boolean isCompatibleWith ( AbstractType < ? > previous ) 
 { 
 - DateSerializer . instance . validate ( bytes ) ; 
 + if ( super . isCompatibleWith ( previous ) ) 
 + return true ; 
 + 
 + if ( previous instanceof TimestampType ) 
 + { 
 + logger . warn ( " Changing from TimestampType to DateType is allowed , but be wary that they sort differently for pre - unix - epoch timestamps " 
 + + " ( negative timestamp values ) and thus this change will corrupt your data if you have such negative timestamp . There is no " 
 + + " reason to switch from DateType to TimestampType except if you were using DateType in the first place and switched to " 
 + + " TimestampType by mistake . " ) ; 
 + return true ; 
 + } 
 + 
 + return false ; 
 } 
 
 - public CQL3Type asCQL3Type ( ) 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 { 
 - return CQL3Type . Native . TIMESTAMP ; 
 + TimestampSerializer . instance . validate ( bytes ) ; 
 } 
 
 public AbstractSerializer < Date > asComposer ( ) 
 { 
 - return DateSerializer . instance ; 
 + return TimestampSerializer . instance ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / LongType . java b / src / java / org / apache / cassandra / db / marshal / LongType . java 
 index 45edc2f . . 2570418 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / LongType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / LongType . java 
 @ @ - 43 , 6 + 43 , 11 @ @ public class LongType extends AbstractType < Long > 
 
 public int compare ( ByteBuffer o1 , ByteBuffer o2 ) 
 { 
 + return compareLongs ( o1 , o2 ) ; 
 + } 
 + 
 + public static int compareLongs ( ByteBuffer o1 , ByteBuffer o2 ) 
 + { 
 if ( o1 . remaining ( ) = = 0 ) 
 { 
 return o2 . remaining ( ) = = 0 ? 0 : - 1 ; 
 @ @ - 52 , 11 + 57 , 10 @ @ public class LongType extends AbstractType < Long > 
 return 1 ; 
 } 
 
 - int diff = o1 . get ( o1 . position ( ) ) - o2 . get ( o2 . position ( ) ) ; 
 + int diff = o1 . get ( o1 . position ( ) + o1 . arrayOffset ( ) ) - o2 . get ( o2 . position ( ) + o2 . arrayOffset ( ) ) ; 
 if ( diff ! = 0 ) 
 return diff ; 
 
 - 
 return ByteBufferUtil . compareUnsigned ( o1 , o2 ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / TimestampType . java b / src / java / org / apache / cassandra / db / marshal / TimestampType . java 
 new file mode 100644 
 index 0000000 . . ee2140c 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / db / marshal / TimestampType . java 
 @ @ - 0 , 0 + 1 , 145 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . db . marshal ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . text . ParseException ; 
 + import java . util . Date ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . cql3 . CQL3Type ; 
 + import org . apache . cassandra . type . AbstractSerializer ; 
 + import org . apache . cassandra . type . MarshalException ; 
 + import org . apache . cassandra . type . TimestampSerializer ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . commons . lang . time . DateUtils ; 
 + 
 + / * * 
 + * Type for date - time values . 
 + * 
 + * This is meant as a replacement for DateType , as DateType wrongly compare 
 + * pre - unix - epoch dates , sorting them * after * post - unix - epoch ones ( due to it ' s 
 + * use of unsigned bytes comparison ) . 
 + * / 
 + public class TimestampType extends AbstractType < Date > 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( TimestampType . class ) ; 
 + 
 + public static final TimestampType instance = new TimestampType ( ) ; 
 + 
 + private TimestampType ( ) { } / / singleton 
 + 
 + public Date compose ( ByteBuffer bytes ) 
 + { 
 + return TimestampSerializer . instance . serialize ( bytes ) ; 
 + } 
 + 
 + public ByteBuffer decompose ( Date value ) 
 + { 
 + return TimestampSerializer . instance . deserialize ( value ) ; 
 + } 
 + 
 + public int compare ( ByteBuffer o1 , ByteBuffer o2 ) 
 + { 
 + return LongType . compareLongs ( o1 , o2 ) ; 
 + } 
 + 
 + public String getString ( ByteBuffer bytes ) 
 + { 
 + return TimestampSerializer . instance . getString ( bytes ) ; 
 + } 
 + 
 + public ByteBuffer fromString ( String source ) throws MarshalException 
 + { 
 + / / Return an empty ByteBuffer for an empty string . 
 + if ( source . isEmpty ( ) ) 
 + return ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 + 
 + return ByteBufferUtil . bytes ( dateStringToTimestamp ( source ) ) ; 
 + } 
 + 
 + public static long dateStringToTimestamp ( String source ) throws MarshalException 
 + { 
 + long millis ; 
 + 
 + if ( source . toLowerCase ( ) . equals ( " now " ) ) 
 + { 
 + millis = System . currentTimeMillis ( ) ; 
 + } 
 + / / Milliseconds since epoch ? 
 + else if ( source . matches ( " ^ \ \ d + $ " ) ) 
 + { 
 + try 
 + { 
 + millis = Long . parseLong ( source ) ; 
 + } 
 + catch ( NumberFormatException e ) 
 + { 
 + throw new MarshalException ( String . format ( " unable to make long ( for date ) from : ' % s ' " , source ) , e ) ; 
 + } 
 + } 
 + / / Last chance , attempt to parse as date - time string 
 + else 
 + { 
 + try 
 + { 
 + millis = DateUtils . parseDateStrictly ( source , TimestampSerializer . iso8601Patterns ) . getTime ( ) ; 
 + } 
 + catch ( ParseException e1 ) 
 + { 
 + throw new MarshalException ( String . format ( " unable to coerce ' % s ' to a formatted date ( long ) " , source ) , e1 ) ; 
 + } 
 + } 
 + 
 + return millis ; 
 + } 
 + 
 + public void validate ( ByteBuffer bytes ) throws MarshalException 
 + { 
 + TimestampSerializer . instance . validate ( bytes ) ; 
 + } 
 + 
 + @ Override 
 + public boolean isCompatibleWith ( AbstractType < ? > previous ) 
 + { 
 + if ( super . isCompatibleWith ( previous ) ) 
 + return true ; 
 + 
 + if ( previous instanceof DateType ) 
 + { 
 + logger . warn ( " Changing from DateType to TimestampType is allowed , but be wary that they sort differently for pre - unix - epoch timestamps " 
 + + " ( negative timestamp values ) and thus this change will corrupt your data if you have such negative timestamp . So unless you " 
 + + " know that you don ' t have * any * pre - unix - epoch timestamp you should change back to DateType " ) ; 
 + return true ; 
 + } 
 + 
 + return false ; 
 + } 
 + 
 + public CQL3Type asCQL3Type ( ) 
 + { 
 + return CQL3Type . Native . TIMESTAMP ; 
 + } 
 + 
 + public AbstractSerializer < Date > asComposer ( ) 
 + { 
 + return TimestampSerializer . instance ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / UUIDType . java b / src / java / org / apache / cassandra / db / marshal / UUIDType . java 
 index 159cab3 . . 73021ee 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / UUIDType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / UUIDType . java 
 @ @ - 30 , 7 + 30 , 7 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . UUIDGen ; 
 import org . apache . commons . lang . time . DateUtils ; 
 
 - import static org . apache . cassandra . type . DateSerializer . iso8601Patterns ; 
 + import static org . apache . cassandra . type . TimestampSerializer . iso8601Patterns ; 
 
 / * * 
 * Compares UUIDs using the following criteria : < br > 
 diff - - git a / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java b / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java 
 index d1bc5e4 . . 9636cea 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java 
 + + + b / src / java / org / apache / cassandra / hadoop / pig / AbstractCassandraStorage . java 
 @ @ - 140 , 7 + 140 , 7 @ @ public abstract class AbstractCassandraStorage extends LoadFunc implements Store 
 else if ( value instanceof UUID ) 
 pair . set ( position , new DataByteArray ( UUIDGen . decompose ( ( java . util . UUID ) value ) ) ) ; 
 else if ( value instanceof Date ) 
 - pair . set ( position , DateType . instance . decompose ( ( Date ) value ) . getLong ( ) ) ; 
 + pair . set ( position , TimestampType . instance . decompose ( ( Date ) value ) . getLong ( ) ) ; 
 else 
 pair . set ( position , value ) ; 
 } 
 @ @ - 299 , 7 + 299 , 7 @ @ public abstract class AbstractCassandraStorage extends LoadFunc implements Store 
 / * * get pig type for the cassandra data type * / 
 protected byte getPigType ( AbstractType type ) 
 { 
 - if ( type instanceof LongType | | type instanceof DateType ) / / DateType is bad and it should feel bad 
 + if ( type instanceof LongType | | type instanceof DateType | | type instanceof TimestampType ) / / DateType is bad and it should feel bad 
 return DataType . LONG ; 
 else if ( type instanceof IntegerType | | type instanceof Int32Type ) / / IntegerType will overflow at 2 * * 31 , but is kept for compatibility until pig has a BigInteger 
 return DataType . INTEGER ; 
 diff - - git a / src / java / org / apache / cassandra / tools / Shuffle . java b / src / java / org / apache / cassandra / tools / Shuffle . java 
 index 5749a81 . . 0c5c92a 100644 
 - - - a / src / java / org / apache / cassandra / tools / Shuffle . java 
 + + + b / src / java / org / apache / cassandra / tools / Shuffle . java 
 @ @ - 43 , 7 + 43 , 7 @ @ import javax . management . MBeanServerConnection ; 
 import javax . management . MalformedObjectNameException ; 
 import javax . management . ObjectName ; 
 
 - import org . apache . cassandra . type . DateSerializer ; 
 + import org . apache . cassandra . type . TimestampSerializer ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; 
 @ @ - 389 , 7 + 389 , 7 @ @ public class Shuffle extends AbstractJmxClient 
 
 ByteBuffer tokenBytes = ByteBuffer . wrap ( row . getColumns ( ) . get ( 0 ) . getValue ( ) ) ; 
 ByteBuffer requestedAt = ByteBuffer . wrap ( row . getColumns ( ) . get ( 1 ) . getValue ( ) ) ; 
 - Date time = DateSerializer . instance . serialize ( requestedAt ) ; 
 + Date time = TimestampSerializer . instance . serialize ( requestedAt ) ; 
 Token < ? > token = partitioner . getTokenFactory ( ) . fromByteArray ( tokenBytes ) ; 
 
 writeln ( " % - 42s % - 15s % s " , token . toString ( ) , host , time . toString ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / transport / DataType . java b / src / java / org / apache / cassandra / transport / DataType . java 
 index 21f4d03 . . b590042 100644 
 - - - a / src / java / org / apache / cassandra / transport / DataType . java 
 + + + b / src / java / org / apache / cassandra / transport / DataType . java 
 @ @ - 43 , 7 + 43 , 7 @ @ public enum DataType implements OptionCodec . Codecable < DataType > 
 FLOAT ( 8 , FloatType . instance ) , 
 INT ( 9 , Int32Type . instance ) , 
 TEXT ( 10 , UTF8Type . instance ) , 
 - TIMESTAMP ( 11 , DateType . instance ) , 
 + TIMESTAMP ( 11 , TimestampType . instance ) , 
 UUID ( 12 , UUIDType . instance ) , 
 VARCHAR ( 13 , UTF8Type . instance ) , 
 VARINT ( 14 , IntegerType . instance ) , 
 @ @ - 146 , 6 + 146 , 9 @ @ public enum DataType implements OptionCodec . Codecable < DataType > 
 / / shouldn ' t have to care about it . 
 if ( type instanceof ReversedType ) 
 type = ( ( ReversedType ) type ) . baseType ; 
 + / / For compatibility sake , we still return DateType as the timestamp type in resultSet metadata
