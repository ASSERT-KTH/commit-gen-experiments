BLEU SCORE: 0.05341087579952926

TEST MSG: Make CQLSSTableWriter sync within partitions
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2c0cae6 . . 3ee938a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 11 : <nl> + * Make CQLSSTableWriter sync within partitions ( CASSANDRA - 7360 ) <nl> * Potentially use non - local replicas in CqlConfigHelper ( CASSANDRA - 7906 ) <nl> * Explicitly disallowing mixing multi - column and single - column <nl> relations on clustering columns ( CASSANDRA - 7711 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 466833b . . ae6e798 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 49 , 7 + 49 , 7 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn <nl> return ( AbstractType < ? > ) map . comparator ( ) ; <nl> } <nl> <nl> - private TreeMapBackedSortedColumns ( CFMetaData metadata ) <nl> + protected TreeMapBackedSortedColumns ( CFMetaData metadata ) <nl> { <nl> super ( metadata ) ; <nl> this . map = new TreeMap < ByteBuffer , Column > ( metadata . comparator ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java b / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java <nl> index db87226 . . 2c6f82a 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java <nl> @ @ - 111 , 7 + 111 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable <nl> currentSuperColumn = name ; <nl> } <nl> <nl> - private void addColumn ( Column column ) <nl> + protected void addColumn ( Column column ) throws IOException <nl> { <nl> if ( columnFamily . metadata ( ) . isSuper ( ) ) <nl> { <nl> @ @ - 129 , 7 + 129 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable <nl> * @ param value the column value <nl> * @ param timestamp the column timestamp <nl> * / <nl> - public void addColumn ( ByteBuffer name , ByteBuffer value , long timestamp ) <nl> + public void addColumn ( ByteBuffer name , ByteBuffer value , long timestamp ) throws IOException <nl> { <nl> addColumn ( new Column ( name , value , timestamp ) ) ; <nl> } <nl> @ @ - 144 , 7 + 144 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable <nl> * expiring the column , and as a consequence should be synchronized with the cassandra servers time . If { @ code timestamp } represents <nl> * the insertion time in microseconds ( which is not required ) , this should be { @ code ( timestamp / 1000 ) + ( ttl * 1000 ) } . <nl> * / <nl> - public void addExpiringColumn ( ByteBuffer name , ByteBuffer value , long timestamp , int ttl , long expirationTimestampMS ) <nl> + public void addExpiringColumn ( ByteBuffer name , ByteBuffer value , long timestamp , int ttl , long expirationTimestampMS ) throws IOException <nl> { <nl> addColumn ( new ExpiringColumn ( name , value , timestamp , ttl , ( int ) ( expirationTimestampMS / 1000 ) ) ) ; <nl> } <nl> @ @ - 154 , 7 + 154 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable <nl> * @ param name the column name <nl> * @ param value the value of the counter <nl> * / <nl> - public void addCounterColumn ( ByteBuffer name , long value ) <nl> + public void addCounterColumn ( ByteBuffer name , long value ) throws IOException <nl> { <nl> addColumn ( new CounterColumn ( name , <nl> CounterContext . instance ( ) . createRemote ( counterid , 1L , value , HeapAllocator . instance ) , <nl> @ @ - 179 , 8 + 179 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable <nl> return currentKey ; <nl> } <nl> <nl> - <nl> protected abstract void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException ; <nl> <nl> - protected abstract ColumnFamily getColumnFamily ( ) ; <nl> + protected abstract ColumnFamily getColumnFamily ( ) throws IOException ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java <nl> index 61990ec . . 49a1259 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import com . google . common . collect . ImmutableMap ; <nl> import org . apache . cassandra . cql3 . statements . * ; <nl> import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . config . * ; <nl> + import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> @ @ - 40 , 6 + 41 , 7 @ @ import org . apache . cassandra . exceptions . RequestValidationException ; <nl> import org . apache . cassandra . io . compress . CompressionParameters ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . service . ClientState ; <nl> + import org . apache . cassandra . utils . Allocator ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> / * * <nl> @ @ - 206 , 13 + 208 , 22 @ @ public class CQLSSTableWriter implements Closeable <nl> insert . getTimeToLive ( values ) , <nl> Collections . < ByteBuffer , ColumnGroupMap > emptyMap ( ) ) ; <nl> <nl> - for ( ByteBuffer key : keys ) <nl> + try <nl> { <nl> - if ( writer . currentKey ( ) = = null | | ! key . equals ( writer . currentKey ( ) . key ) ) <nl> - writer . newRow ( key ) ; <nl> - insert . addUpdateForKey ( writer . currentColumnFamily ( ) , key , clusteringPrefix , params ) ; <nl> + for ( ByteBuffer key : keys ) <nl> + { <nl> + if ( writer . currentKey ( ) = = null | | ! key . equals ( writer . currentKey ( ) . key ) ) <nl> + writer . newRow ( key ) ; <nl> + insert . addUpdateForKey ( writer . currentColumnFamily ( ) , key , clusteringPrefix , params ) ; <nl> + } <nl> + return this ; <nl> + } <nl> + catch ( BufferedWriter . SyncException e ) <nl> + { <nl> + / / If we use a BufferedWriter and had a problem writing to disk , the IOException has been <nl> + / / wrapped in a SyncException ( see BufferedWriter below ) . We want to extract that IOE . <nl> + throw ( IOException ) e . getCause ( ) ; <nl> } <nl> - return this ; <nl> } <nl> <nl> / * * <nl> @ @ - 463 , 21 + 474 , 58 @ @ public class CQLSSTableWriter implements Closeable <nl> if ( insert = = null ) <nl> throw new IllegalStateException ( " No insert statement specified , you should provide an insert statement through using ( ) " ) ; <nl> <nl> - AbstractSSTableSimpleWriter writer ; <nl> - if ( sorted ) <nl> + AbstractSSTableSimpleWriter writer = sorted <nl> + ? new SSTableSimpleWriter ( directory , schema , partitioner ) <nl> + : new BufferedWriter ( directory , schema , partitioner , bufferSizeInMB ) ; <nl> + return new CQLSSTableWriter ( writer , insert , boundNames ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * CQLSSTableWriter doesn ' t use the method addColumn ( ) from AbstractSSTableSimpleWriter . <nl> + * Instead , it adds cells directly to the ColumnFamily the latter exposes . But this means <nl> + * that the sync ( ) method of SSTableSimpleUnsortedWriter is not called ( at least not for <nl> + * each CQL row , so adding many rows to the same partition can buffer too much data in <nl> + * memory - # 7360 ) . So we create a slightly modified SSTableSimpleUnsortedWriter that uses <nl> + * a tweaked ColumnFamily object that calls back the proper method after each added cell <nl> + * so we sync when we should . <nl> + * / <nl> + private static class BufferedWriter extends SSTableSimpleUnsortedWriter <nl> + { <nl> + public BufferedWriter ( File directory , CFMetaData metadata , IPartitioner partitioner , long bufferSizeInMB ) <nl> + { <nl> + super ( directory , metadata , partitioner , bufferSizeInMB ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected ColumnFamily createColumnFamily ( ) <nl> + { <nl> + return new TreeMapBackedSortedColumns ( metadata ) <nl> { <nl> - writer = new SSTableSimpleWriter ( directory , <nl> - schema , <nl> - partitioner ) ; <nl> - } <nl> - else <nl> + @ Override <nl> + public void addColumn ( Column column , Allocator allocator ) <nl> + { <nl> + super . addColumn ( column , allocator ) ; <nl> + try <nl> + { <nl> + countColumn ( column ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + / / addColumn does not throw IOException but we want to report this to the user , <nl> + / / so wrap it in a temporary RuntimeException that we ' ll catch in rawAddRow above . <nl> + throw new SyncException ( e ) ; <nl> + } <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + static class SyncException extends RuntimeException <nl> + { <nl> + SyncException ( IOException ioe ) <nl> { <nl> - writer = new SSTableSimpleUnsortedWriter ( directory , <nl> - schema , <nl> - partitioner , <nl> - bufferSizeInMB ) ; <nl> + super ( ioe ) ; <nl> } <nl> - return new CQLSSTableWriter ( writer , insert , boundNames ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> index 6b39024 . . 39ec71d 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java <nl> @ @ - 27 , 10 + 27 , 12 @ @ import java . util . concurrent . SynchronousQueue ; <nl> import com . google . common . base . Throwables ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . db . Column ; <nl> import org . apache . cassandra . db . ColumnFamily ; <nl> import org . apache . cassandra . db . ColumnFamilyType ; <nl> import org . apache . cassandra . db . DecoratedKey ; <nl> import org . apache . cassandra . db . TreeMapBackedSortedColumns ; <nl> + import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . io . compress . CompressionParameters ; <nl> @ @ - 100 , 30 + 102 , 48 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter <nl> <nl> protected void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException <nl> { <nl> - currentSize + = key . key . remaining ( ) + ColumnFamily . serializer . serializedSize ( columnFamily , MessagingService . current _ version ) * 1 . 2 ; <nl> + / / Nothing to do since we ' ll sync if needed in addColumn . <nl> + } <nl> + <nl> + @ Override <nl> + protected void addColumn ( Column column ) throws IOException <nl> + { <nl> + super . addColumn ( column ) ; <nl> + countColumn ( column ) ; <nl> + } <nl> + <nl> + protected void countColumn ( Column column ) throws IOException <nl> + { <nl> + currentSize + = column . serializedSize ( TypeSizes . NATIVE ) ; <nl> <nl> + / / We don ' t want to sync in writeRow ( ) only as this might blow up the bufferSize for wide rows . <nl> if ( currentSize > bufferSize ) <nl> sync ( ) ; <nl> } <nl> <nl> - protected ColumnFamily getColumnFamily ( ) <nl> + protected ColumnFamily getColumnFamily ( ) throws IOException <nl> { <nl> ColumnFamily previous = buffer . get ( currentKey ) ; <nl> / / If the CF already exist in memory , we ' ll just continue adding to it <nl> if ( previous = = null ) <nl> { <nl> - previous = TreeMapBackedSortedColumns . factory . create ( metadata ) ; <nl> + previous = createColumnFamily ( ) ; <nl> buffer . put ( currentKey , previous ) ; <nl> - } <nl> - else <nl> - { <nl> - / / We will reuse a CF that we have counted already . But because it will be easier to add the full size <nl> - / / of the CF in the next writeRow call than to find out the delta , we just remove the size until that next call <nl> - currentSize - = currentKey . key . remaining ( ) + ColumnFamily . serializer . serializedSize ( previous , MessagingService . current _ version ) * 1 . 2 ; <nl> + <nl> + / / Since this new CF will be written by the next sync ( ) , count its header . And a CF header <nl> + / / on disk is : <nl> + / / - the row key : 2 bytes size + key size bytes <nl> + / / - the row level deletion infos : 4 + 8 bytes <nl> + currentSize + = 14 + currentKey . key . remaining ( ) ; <nl> } <nl> return previous ; <nl> } <nl> <nl> + protected ColumnFamily createColumnFamily ( ) throws IOException <nl> + { <nl> + return TreeMapBackedSortedColumns . factory . create ( metadata ) ; <nl> + } <nl> + <nl> public void close ( ) throws IOException <nl> { <nl> sync ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java b / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java <nl> index bdc4b94 . . de814e1 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java <nl> @ @ - 18 , 6 + 18 , 9 @ @ <nl> package org . apache . cassandra . io . sstable ; <nl> <nl> import java . io . File ; <nl> + import java . io . FilenameFilter ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Arrays ; <nl> import java . util . Iterator ; <nl> <nl> import com . google . common . collect . ImmutableMap ; <nl> @ @ - 119 , 4 + 122 , 40 @ @ public class CQLSSTableWriterTest <nl> assertEquals ( null , row . getBytes ( " v1 " ) ) ; / / Using getBytes because we know it won ' t NPE <nl> assertEquals ( 12 , row . getInt ( " v2 " ) ) ; <nl> } <nl> + <nl> + @ Test <nl> + public void testSyncWithinPartition ( ) throws Exception <nl> + { <nl> + / / Check that the write respect the buffer size even if we only insert rows withing the same partition
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2c0cae6 . . 3ee938a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 11 : 
 + * Make CQLSSTableWriter sync within partitions ( CASSANDRA - 7360 ) 
 * Potentially use non - local replicas in CqlConfigHelper ( CASSANDRA - 7906 ) 
 * Explicitly disallowing mixing multi - column and single - column 
 relations on clustering columns ( CASSANDRA - 7711 ) 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 466833b . . ae6e798 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 49 , 7 + 49 , 7 @ @ public class TreeMapBackedSortedColumns extends AbstractThreadUnsafeSortedColumn 
 return ( AbstractType < ? > ) map . comparator ( ) ; 
 } 
 
 - private TreeMapBackedSortedColumns ( CFMetaData metadata ) 
 + protected TreeMapBackedSortedColumns ( CFMetaData metadata ) 
 { 
 super ( metadata ) ; 
 this . map = new TreeMap < ByteBuffer , Column > ( metadata . comparator ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java b / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java 
 index db87226 . . 2c6f82a 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / AbstractSSTableSimpleWriter . java 
 @ @ - 111 , 7 + 111 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable 
 currentSuperColumn = name ; 
 } 
 
 - private void addColumn ( Column column ) 
 + protected void addColumn ( Column column ) throws IOException 
 { 
 if ( columnFamily . metadata ( ) . isSuper ( ) ) 
 { 
 @ @ - 129 , 7 + 129 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable 
 * @ param value the column value 
 * @ param timestamp the column timestamp 
 * / 
 - public void addColumn ( ByteBuffer name , ByteBuffer value , long timestamp ) 
 + public void addColumn ( ByteBuffer name , ByteBuffer value , long timestamp ) throws IOException 
 { 
 addColumn ( new Column ( name , value , timestamp ) ) ; 
 } 
 @ @ - 144 , 7 + 144 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable 
 * expiring the column , and as a consequence should be synchronized with the cassandra servers time . If { @ code timestamp } represents 
 * the insertion time in microseconds ( which is not required ) , this should be { @ code ( timestamp / 1000 ) + ( ttl * 1000 ) } . 
 * / 
 - public void addExpiringColumn ( ByteBuffer name , ByteBuffer value , long timestamp , int ttl , long expirationTimestampMS ) 
 + public void addExpiringColumn ( ByteBuffer name , ByteBuffer value , long timestamp , int ttl , long expirationTimestampMS ) throws IOException 
 { 
 addColumn ( new ExpiringColumn ( name , value , timestamp , ttl , ( int ) ( expirationTimestampMS / 1000 ) ) ) ; 
 } 
 @ @ - 154 , 7 + 154 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable 
 * @ param name the column name 
 * @ param value the value of the counter 
 * / 
 - public void addCounterColumn ( ByteBuffer name , long value ) 
 + public void addCounterColumn ( ByteBuffer name , long value ) throws IOException 
 { 
 addColumn ( new CounterColumn ( name , 
 CounterContext . instance ( ) . createRemote ( counterid , 1L , value , HeapAllocator . instance ) , 
 @ @ - 179 , 8 + 179 , 7 @ @ public abstract class AbstractSSTableSimpleWriter implements Closeable 
 return currentKey ; 
 } 
 
 - 
 protected abstract void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException ; 
 
 - protected abstract ColumnFamily getColumnFamily ( ) ; 
 + protected abstract ColumnFamily getColumnFamily ( ) throws IOException ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java 
 index 61990ec . . 49a1259 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / CQLSSTableWriter . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import com . google . common . collect . ImmutableMap ; 
 import org . apache . cassandra . cql3 . statements . * ; 
 import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . config . * ; 
 + import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 @ @ - 40 , 6 + 41 , 7 @ @ import org . apache . cassandra . exceptions . RequestValidationException ; 
 import org . apache . cassandra . io . compress . CompressionParameters ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . service . ClientState ; 
 + import org . apache . cassandra . utils . Allocator ; 
 import org . apache . cassandra . utils . Pair ; 
 
 / * * 
 @ @ - 206 , 13 + 208 , 22 @ @ public class CQLSSTableWriter implements Closeable 
 insert . getTimeToLive ( values ) , 
 Collections . < ByteBuffer , ColumnGroupMap > emptyMap ( ) ) ; 
 
 - for ( ByteBuffer key : keys ) 
 + try 
 { 
 - if ( writer . currentKey ( ) = = null | | ! key . equals ( writer . currentKey ( ) . key ) ) 
 - writer . newRow ( key ) ; 
 - insert . addUpdateForKey ( writer . currentColumnFamily ( ) , key , clusteringPrefix , params ) ; 
 + for ( ByteBuffer key : keys ) 
 + { 
 + if ( writer . currentKey ( ) = = null | | ! key . equals ( writer . currentKey ( ) . key ) ) 
 + writer . newRow ( key ) ; 
 + insert . addUpdateForKey ( writer . currentColumnFamily ( ) , key , clusteringPrefix , params ) ; 
 + } 
 + return this ; 
 + } 
 + catch ( BufferedWriter . SyncException e ) 
 + { 
 + / / If we use a BufferedWriter and had a problem writing to disk , the IOException has been 
 + / / wrapped in a SyncException ( see BufferedWriter below ) . We want to extract that IOE . 
 + throw ( IOException ) e . getCause ( ) ; 
 } 
 - return this ; 
 } 
 
 / * * 
 @ @ - 463 , 21 + 474 , 58 @ @ public class CQLSSTableWriter implements Closeable 
 if ( insert = = null ) 
 throw new IllegalStateException ( " No insert statement specified , you should provide an insert statement through using ( ) " ) ; 
 
 - AbstractSSTableSimpleWriter writer ; 
 - if ( sorted ) 
 + AbstractSSTableSimpleWriter writer = sorted 
 + ? new SSTableSimpleWriter ( directory , schema , partitioner ) 
 + : new BufferedWriter ( directory , schema , partitioner , bufferSizeInMB ) ; 
 + return new CQLSSTableWriter ( writer , insert , boundNames ) ; 
 + } 
 + } 
 + 
 + / * * 
 + * CQLSSTableWriter doesn ' t use the method addColumn ( ) from AbstractSSTableSimpleWriter . 
 + * Instead , it adds cells directly to the ColumnFamily the latter exposes . But this means 
 + * that the sync ( ) method of SSTableSimpleUnsortedWriter is not called ( at least not for 
 + * each CQL row , so adding many rows to the same partition can buffer too much data in 
 + * memory - # 7360 ) . So we create a slightly modified SSTableSimpleUnsortedWriter that uses 
 + * a tweaked ColumnFamily object that calls back the proper method after each added cell 
 + * so we sync when we should . 
 + * / 
 + private static class BufferedWriter extends SSTableSimpleUnsortedWriter 
 + { 
 + public BufferedWriter ( File directory , CFMetaData metadata , IPartitioner partitioner , long bufferSizeInMB ) 
 + { 
 + super ( directory , metadata , partitioner , bufferSizeInMB ) ; 
 + } 
 + 
 + @ Override 
 + protected ColumnFamily createColumnFamily ( ) 
 + { 
 + return new TreeMapBackedSortedColumns ( metadata ) 
 { 
 - writer = new SSTableSimpleWriter ( directory , 
 - schema , 
 - partitioner ) ; 
 - } 
 - else 
 + @ Override 
 + public void addColumn ( Column column , Allocator allocator ) 
 + { 
 + super . addColumn ( column , allocator ) ; 
 + try 
 + { 
 + countColumn ( column ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + / / addColumn does not throw IOException but we want to report this to the user , 
 + / / so wrap it in a temporary RuntimeException that we ' ll catch in rawAddRow above . 
 + throw new SyncException ( e ) ; 
 + } 
 + } 
 + } ; 
 + } 
 + 
 + static class SyncException extends RuntimeException 
 + { 
 + SyncException ( IOException ioe ) 
 { 
 - writer = new SSTableSimpleUnsortedWriter ( directory , 
 - schema , 
 - partitioner , 
 - bufferSizeInMB ) ; 
 + super ( ioe ) ; 
 } 
 - return new CQLSSTableWriter ( writer , insert , boundNames ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 index 6b39024 . . 39ec71d 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableSimpleUnsortedWriter . java 
 @ @ - 27 , 10 + 27 , 12 @ @ import java . util . concurrent . SynchronousQueue ; 
 import com . google . common . base . Throwables ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . db . Column ; 
 import org . apache . cassandra . db . ColumnFamily ; 
 import org . apache . cassandra . db . ColumnFamilyType ; 
 import org . apache . cassandra . db . DecoratedKey ; 
 import org . apache . cassandra . db . TreeMapBackedSortedColumns ; 
 + import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . io . compress . CompressionParameters ; 
 @ @ - 100 , 30 + 102 , 48 @ @ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter 
 
 protected void writeRow ( DecoratedKey key , ColumnFamily columnFamily ) throws IOException 
 { 
 - currentSize + = key . key . remaining ( ) + ColumnFamily . serializer . serializedSize ( columnFamily , MessagingService . current _ version ) * 1 . 2 ; 
 + / / Nothing to do since we ' ll sync if needed in addColumn . 
 + } 
 + 
 + @ Override 
 + protected void addColumn ( Column column ) throws IOException 
 + { 
 + super . addColumn ( column ) ; 
 + countColumn ( column ) ; 
 + } 
 + 
 + protected void countColumn ( Column column ) throws IOException 
 + { 
 + currentSize + = column . serializedSize ( TypeSizes . NATIVE ) ; 
 
 + / / We don ' t want to sync in writeRow ( ) only as this might blow up the bufferSize for wide rows . 
 if ( currentSize > bufferSize ) 
 sync ( ) ; 
 } 
 
 - protected ColumnFamily getColumnFamily ( ) 
 + protected ColumnFamily getColumnFamily ( ) throws IOException 
 { 
 ColumnFamily previous = buffer . get ( currentKey ) ; 
 / / If the CF already exist in memory , we ' ll just continue adding to it 
 if ( previous = = null ) 
 { 
 - previous = TreeMapBackedSortedColumns . factory . create ( metadata ) ; 
 + previous = createColumnFamily ( ) ; 
 buffer . put ( currentKey , previous ) ; 
 - } 
 - else 
 - { 
 - / / We will reuse a CF that we have counted already . But because it will be easier to add the full size 
 - / / of the CF in the next writeRow call than to find out the delta , we just remove the size until that next call 
 - currentSize - = currentKey . key . remaining ( ) + ColumnFamily . serializer . serializedSize ( previous , MessagingService . current _ version ) * 1 . 2 ; 
 + 
 + / / Since this new CF will be written by the next sync ( ) , count its header . And a CF header 
 + / / on disk is : 
 + / / - the row key : 2 bytes size + key size bytes 
 + / / - the row level deletion infos : 4 + 8 bytes 
 + currentSize + = 14 + currentKey . key . remaining ( ) ; 
 } 
 return previous ; 
 } 
 
 + protected ColumnFamily createColumnFamily ( ) throws IOException 
 + { 
 + return TreeMapBackedSortedColumns . factory . create ( metadata ) ; 
 + } 
 + 
 public void close ( ) throws IOException 
 { 
 sync ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java b / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java 
 index bdc4b94 . . de814e1 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / CQLSSTableWriterTest . java 
 @ @ - 18 , 6 + 18 , 9 @ @ 
 package org . apache . cassandra . io . sstable ; 
 
 import java . io . File ; 
 + import java . io . FilenameFilter ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . Arrays ; 
 import java . util . Iterator ; 
 
 import com . google . common . collect . ImmutableMap ; 
 @ @ - 119 , 4 + 122 , 40 @ @ public class CQLSSTableWriterTest 
 assertEquals ( null , row . getBytes ( " v1 " ) ) ; / / Using getBytes because we know it won ' t NPE 
 assertEquals ( 12 , row . getInt ( " v2 " ) ) ; 
 } 
 + 
 + @ Test 
 + public void testSyncWithinPartition ( ) throws Exception 
 + { 
 + / / Check that the write respect the buffer size even if we only insert rows withing the same partition

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
