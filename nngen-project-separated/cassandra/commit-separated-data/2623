BLEU SCORE: 0.05341087579952926

TEST MSG: Fix paging with SELECT DISTINCT
GENERATED MSG: merge from 0 . 6

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 31fd319 . . c5f2666 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 25 , 6 + 25 , 7 @ @ <nl> * Extend triggers to support CAS updates ( CASSANDRA - 6882 ) <nl> * Static columns with IF NOT EXISTS don ' t always work as expected ( CASSANDRA - 6873 ) <nl> * Add CqlRecordReader to take advantage of native CQL pagination ( CASSANDRA - 6311 ) <nl> + * Fix paging with SELECT DISTINCT ( CASSANDRA - 6857 ) <nl> Merged from 1 . 2 : <nl> * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) <nl> * add extra SSL cipher suites ( CASSANDRA - 6613 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 5c3eb19 . . b58329e 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1671 , 10 + 1671 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> ByteBuffer columnStop , <nl> List < IndexExpression > rowFilter , <nl> int maxResults , <nl> + boolean countCQL3Rows , <nl> long now ) <nl> { <nl> DataRange dataRange = new DataRange . Paging ( keyRange , columnRange , columnStart , columnStop , metadata . comparator ) ; <nl> - return ExtendedFilter . create ( this , dataRange , rowFilter , maxResults , true , now ) ; <nl> + return ExtendedFilter . create ( this , dataRange , rowFilter , maxResults , countCQL3Rows , now ) ; <nl> } <nl> <nl> public List < Row > getRangeSlice ( AbstractBounds < RowPosition > range , <nl> diff - - git a / src / java / org / apache / cassandra / db / PagedRangeCommand . java b / src / java / org / apache / cassandra / db / PagedRangeCommand . java <nl> index e152f43 . . d6f3ca1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / PagedRangeCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / PagedRangeCommand . java <nl> @ @ - 97 , 14 + 97 , 22 @ @ public class PagedRangeCommand extends AbstractRangeCommand <nl> <nl> public boolean countCQL3Rows ( ) <nl> { <nl> - return true ; <nl> + / / We only use PagedRangeCommand for CQL3 . However , for SELECT DISTINCT , we want to return false here , because <nl> + / / we just want to pick the first cell of each partition and returning true here would throw off the logic in <nl> + / / ColumnFamilyStore . filter ( ) . <nl> + / / What we do know is that for a SELECT DISTINCT the underlying SliceQueryFilter will have a compositesToGroup = = - 1 <nl> + / / and a count = = 1 . And while it would be possible for a normal SELECT on a COMPACT table to also have such <nl> + / / parameters , it ' s fine returning false since if we do count one cell for each partition , then each partition <nl> + / / will coincide with exactly one CQL3 row . <nl> + SliceQueryFilter filter = ( SliceQueryFilter ) predicate ; <nl> + return filter . compositesToGroup > = 0 | | filter . count ! = 1 ; <nl> } <nl> <nl> public List < Row > executeLocally ( ) <nl> { <nl> ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( columnFamily ) ; <nl> <nl> - ExtendedFilter exFilter = cfs . makeExtendedFilter ( keyRange , ( SliceQueryFilter ) predicate , start , stop , rowFilter , limit , timestamp ) ; <nl> + ExtendedFilter exFilter = cfs . makeExtendedFilter ( keyRange , ( SliceQueryFilter ) predicate , start , stop , rowFilter , limit , countCQL3Rows ( ) , timestamp ) ; <nl> if ( cfs . indexManager . hasIndexFor ( rowFilter ) ) <nl> return cfs . search ( exFilter ) ; <nl> else <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / QueryPagers . java b / src / java / org / apache / cassandra / service / pager / QueryPagers . java <nl> index c353536 . . 65112aa 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / QueryPagers . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / QueryPagers . java <nl> @ @ - 71 , 8 + 71 , 14 @ @ public class QueryPagers <nl> else <nl> { <nl> assert command instanceof RangeSliceCommand ; <nl> - / / We can never be sure a range slice won ' t need paging <nl> - return true ; <nl> + RangeSliceCommand rsc = ( RangeSliceCommand ) command ; <nl> + / / We don ' t support paging for thrift in general because the way thrift RangeSliceCommand count rows <nl> + / / independently of cells makes things harder ( see RangeSliceQueryPager ) . The one case where we do <nl> + / / get a RangeSliceCommand from CQL3 without the countCQL3Rows flag set is for DISTINCT . In that case <nl> + / / however , the underlying sliceQueryFilter count is 1 , so that the RSC limit is still a limit on the <nl> + / / number of CQL3 rows returned . <nl> + assert rsc . countCQL3Rows | | ( rsc . predicate instanceof SliceQueryFilter & & ( ( SliceQueryFilter ) rsc . predicate ) . count = = 1 ) ; <nl> + return rsc . maxResults > pageSize ; <nl> } <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> index 5fc006b . . bc39ad6 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> @ @ - 1198 , 7 + 1198 , 7 @ @ public class ColumnFamilyStoreTest extends SchemaLoader <nl> ByteBufferUtil . bytes ( " c2 " ) , <nl> false , <nl> 0 ) ; <nl> - rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( ka , kc ) , sf , ByteBufferUtil . bytes ( " c2 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 2 , System . currentTimeMillis ( ) ) ) ; <nl> + rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( ka , kc ) , sf , ByteBufferUtil . bytes ( " c2 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 2 , true , System . currentTimeMillis ( ) ) ) ; <nl> assert rows . size ( ) = = 2 : " Expected 2 rows , got " + toString ( rows ) ; <nl> iter = rows . iterator ( ) ; <nl> row1 = iter . next ( ) ; <nl> @ @ - 1206 , 7 + 1206 , 7 @ @ public class ColumnFamilyStoreTest extends SchemaLoader <nl> assertColumnNames ( row1 , " c2 " ) ; <nl> assertColumnNames ( row2 , " c1 " ) ; <nl> <nl> - rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( kb , kc ) , sf , ByteBufferUtil . bytes ( " c1 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 10 , System . currentTimeMillis ( ) ) ) ; <nl> + rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( kb , kc ) , sf , ByteBufferUtil . bytes ( " c1 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 10 , true , System . currentTimeMillis ( ) ) ) ; <nl> assert rows . size ( ) = = 2 : " Expected 2 rows , got " + toString ( rows ) ; <nl> iter = rows . iterator ( ) ; <nl> row1 = iter . next ( ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8d9e2ea . . c97b17f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 7 + 1 , 10 @ @ <nl> dev <nl> * sstable versioning ( CASSANDRA - 389 ) <nl> <nl> - 0 . 6 . 0 - dev <nl> + 0 . 6 . 0 - RC1 <nl> + * fix compaction bucketing bug ( CASSANDRA - 814 ) <nl> + <nl> + 0 . 6 . 0 - beta1 / beta2 <nl> * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) <nl> * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) <nl> * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) <nl> @ @ - 42 , 7 + 45 , 9 @ @ dev <nl> * allow larger numbers of keys ( > 140M ) in a sstable bloom filter <nl> ( CASSANDRA - 790 ) <nl> * include jvm argument improvements from CASSANDRA - 504 in debian package <nl> - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * change streaming chunk size to 32MB to accomodate Windows XP limitations <nl> + ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) <nl> <nl> <nl> 0 . 5 . 0 final <nl> diff - - git a / build . xml b / build . xml <nl> index ea79876 . . 54ef12d 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 314 , 6 + 314 , 7 @ @ <nl> < include name = " * * " / > <nl> < exclude name = " build / * * " / > <nl> < exclude name = " src / gen - java / * * " / > <nl> + < exclude name = " interface / avro / * * " / > <nl> < / tarfileset > <nl> < / tar > <nl> < / target > <nl> diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> index fbd5ebb . . 1b5b6b1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return 0 ; <nl> } <nl> logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; <nl> - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> <nl> for ( List < SSTableReader > sstables : buckets ) <nl> @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> / * <nl> * Group files of similar size into buckets . <nl> * / <nl> - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) <nl> + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) <nl> { <nl> Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; <nl> for ( SSTableReader sstable : files ) <nl> @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> / / remove and re - add because adding changes the hash <nl> buckets . remove ( bucket ) ; <nl> - averageSize = ( averageSize + size ) / 2 ; <nl> + long totalSize = bucket . size ( ) * averageSize ; <nl> + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; <nl> bucket . add ( sstable ) ; <nl> buckets . put ( bucket , averageSize ) ; <nl> bFound = true ; <nl> @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> public void run ( ) <nl> { <nl> logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; <nl> - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> } <nl> } ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 31fd319 . . c5f2666 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 25 , 6 + 25 , 7 @ @ 
 * Extend triggers to support CAS updates ( CASSANDRA - 6882 ) 
 * Static columns with IF NOT EXISTS don ' t always work as expected ( CASSANDRA - 6873 ) 
 * Add CqlRecordReader to take advantage of native CQL pagination ( CASSANDRA - 6311 ) 
 + * Fix paging with SELECT DISTINCT ( CASSANDRA - 6857 ) 
 Merged from 1 . 2 : 
 * Add UNLOGGED , COUNTER options to BATCH documentation ( CASSANDRA - 6816 ) 
 * add extra SSL cipher suites ( CASSANDRA - 6613 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 5c3eb19 . . b58329e 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1671 , 10 + 1671 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 ByteBuffer columnStop , 
 List < IndexExpression > rowFilter , 
 int maxResults , 
 + boolean countCQL3Rows , 
 long now ) 
 { 
 DataRange dataRange = new DataRange . Paging ( keyRange , columnRange , columnStart , columnStop , metadata . comparator ) ; 
 - return ExtendedFilter . create ( this , dataRange , rowFilter , maxResults , true , now ) ; 
 + return ExtendedFilter . create ( this , dataRange , rowFilter , maxResults , countCQL3Rows , now ) ; 
 } 
 
 public List < Row > getRangeSlice ( AbstractBounds < RowPosition > range , 
 diff - - git a / src / java / org / apache / cassandra / db / PagedRangeCommand . java b / src / java / org / apache / cassandra / db / PagedRangeCommand . java 
 index e152f43 . . d6f3ca1 100644 
 - - - a / src / java / org / apache / cassandra / db / PagedRangeCommand . java 
 + + + b / src / java / org / apache / cassandra / db / PagedRangeCommand . java 
 @ @ - 97 , 14 + 97 , 22 @ @ public class PagedRangeCommand extends AbstractRangeCommand 
 
 public boolean countCQL3Rows ( ) 
 { 
 - return true ; 
 + / / We only use PagedRangeCommand for CQL3 . However , for SELECT DISTINCT , we want to return false here , because 
 + / / we just want to pick the first cell of each partition and returning true here would throw off the logic in 
 + / / ColumnFamilyStore . filter ( ) . 
 + / / What we do know is that for a SELECT DISTINCT the underlying SliceQueryFilter will have a compositesToGroup = = - 1 
 + / / and a count = = 1 . And while it would be possible for a normal SELECT on a COMPACT table to also have such 
 + / / parameters , it ' s fine returning false since if we do count one cell for each partition , then each partition 
 + / / will coincide with exactly one CQL3 row . 
 + SliceQueryFilter filter = ( SliceQueryFilter ) predicate ; 
 + return filter . compositesToGroup > = 0 | | filter . count ! = 1 ; 
 } 
 
 public List < Row > executeLocally ( ) 
 { 
 ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( columnFamily ) ; 
 
 - ExtendedFilter exFilter = cfs . makeExtendedFilter ( keyRange , ( SliceQueryFilter ) predicate , start , stop , rowFilter , limit , timestamp ) ; 
 + ExtendedFilter exFilter = cfs . makeExtendedFilter ( keyRange , ( SliceQueryFilter ) predicate , start , stop , rowFilter , limit , countCQL3Rows ( ) , timestamp ) ; 
 if ( cfs . indexManager . hasIndexFor ( rowFilter ) ) 
 return cfs . search ( exFilter ) ; 
 else 
 diff - - git a / src / java / org / apache / cassandra / service / pager / QueryPagers . java b / src / java / org / apache / cassandra / service / pager / QueryPagers . java 
 index c353536 . . 65112aa 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / QueryPagers . java 
 + + + b / src / java / org / apache / cassandra / service / pager / QueryPagers . java 
 @ @ - 71 , 8 + 71 , 14 @ @ public class QueryPagers 
 else 
 { 
 assert command instanceof RangeSliceCommand ; 
 - / / We can never be sure a range slice won ' t need paging 
 - return true ; 
 + RangeSliceCommand rsc = ( RangeSliceCommand ) command ; 
 + / / We don ' t support paging for thrift in general because the way thrift RangeSliceCommand count rows 
 + / / independently of cells makes things harder ( see RangeSliceQueryPager ) . The one case where we do 
 + / / get a RangeSliceCommand from CQL3 without the countCQL3Rows flag set is for DISTINCT . In that case 
 + / / however , the underlying sliceQueryFilter count is 1 , so that the RSC limit is still a limit on the 
 + / / number of CQL3 rows returned . 
 + assert rsc . countCQL3Rows | | ( rsc . predicate instanceof SliceQueryFilter & & ( ( SliceQueryFilter ) rsc . predicate ) . count = = 1 ) ; 
 + return rsc . maxResults > pageSize ; 
 } 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 index 5fc006b . . bc39ad6 100644 
 - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 @ @ - 1198 , 7 + 1198 , 7 @ @ public class ColumnFamilyStoreTest extends SchemaLoader 
 ByteBufferUtil . bytes ( " c2 " ) , 
 false , 
 0 ) ; 
 - rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( ka , kc ) , sf , ByteBufferUtil . bytes ( " c2 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 2 , System . currentTimeMillis ( ) ) ) ; 
 + rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( ka , kc ) , sf , ByteBufferUtil . bytes ( " c2 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 2 , true , System . currentTimeMillis ( ) ) ) ; 
 assert rows . size ( ) = = 2 : " Expected 2 rows , got " + toString ( rows ) ; 
 iter = rows . iterator ( ) ; 
 row1 = iter . next ( ) ; 
 @ @ - 1206 , 7 + 1206 , 7 @ @ public class ColumnFamilyStoreTest extends SchemaLoader 
 assertColumnNames ( row1 , " c2 " ) ; 
 assertColumnNames ( row2 , " c1 " ) ; 
 
 - rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( kb , kc ) , sf , ByteBufferUtil . bytes ( " c1 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 10 , System . currentTimeMillis ( ) ) ) ; 
 + rows = cfs . getRangeSlice ( cfs . makeExtendedFilter ( new Bounds < RowPosition > ( kb , kc ) , sf , ByteBufferUtil . bytes ( " c1 " ) , ByteBufferUtil . bytes ( " c1 " ) , null , 10 , true , System . currentTimeMillis ( ) ) ) ; 
 assert rows . size ( ) = = 2 : " Expected 2 rows , got " + toString ( rows ) ; 
 iter = rows . iterator ( ) ; 
 row1 = iter . next ( ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8d9e2ea . . c97b17f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 7 + 1 , 10 @ @ 
 dev 
 * sstable versioning ( CASSANDRA - 389 ) 
 
 - 0 . 6 . 0 - dev 
 + 0 . 6 . 0 - RC1 
 + * fix compaction bucketing bug ( CASSANDRA - 814 ) 
 + 
 + 0 . 6 . 0 - beta1 / beta2 
 * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) 
 * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) 
 * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) 
 @ @ - 42 , 7 + 45 , 9 @ @ dev 
 * allow larger numbers of keys ( > 140M ) in a sstable bloom filter 
 ( CASSANDRA - 790 ) 
 * include jvm argument improvements from CASSANDRA - 504 in debian package 
 - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) 
 + * change streaming chunk size to 32MB to accomodate Windows XP limitations 
 + ( was 64MB ) ( CASSANDRA - 795 ) 
 + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) 
 
 
 0 . 5 . 0 final 
 diff - - git a / build . xml b / build . xml 
 index ea79876 . . 54ef12d 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 314 , 6 + 314 , 7 @ @ 
 < include name = " * * " / > 
 < exclude name = " build / * * " / > 
 < exclude name = " src / gen - java / * * " / > 
 + < exclude name = " interface / avro / * * " / > 
 < / tarfileset > 
 < / tar > 
 < / target > 
 diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java 
 index fbd5ebb . . 1b5b6b1 100644 
 - - - a / src / java / org / apache / cassandra / db / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / CompactionManager . java 
 @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return 0 ; 
 } 
 logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; 
 - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 
 for ( List < SSTableReader > sstables : buckets ) 
 @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 / * 
 * Group files of similar size into buckets . 
 * / 
 - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) 
 + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) 
 { 
 Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; 
 for ( SSTableReader sstable : files ) 
 @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 / / remove and re - add because adding changes the hash 
 buckets . remove ( bucket ) ; 
 - averageSize = ( averageSize + size ) / 2 ; 
 + long totalSize = bucket . size ( ) * averageSize ; 
 + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; 
 bucket . add ( sstable ) ; 
 buckets . put ( bucket , averageSize ) ; 
 bFound = true ; 
 @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 public void run ( ) 
 { 
 logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; 
 - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 } 
 } ;
