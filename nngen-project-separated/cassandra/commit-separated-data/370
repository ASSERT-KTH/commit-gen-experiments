BLEU SCORE: 0.05341087579952926

TEST MSG: Fix randomness of stress values
GENERATED MSG: undeprecate cache recentHitRate metrics

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f34b325 . . aed0036 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Fix Randomness of stress values ( CASSANDRA - 12744 ) <nl> * Allow selecting Map values and Set elements ( CASSANDRA - 7396 ) <nl> * Fast and garbage - free Streaming Histogram ( CASSANDRA - 13444 ) <nl> * Update repairTime for keyspaces on completion ( CASSANDRA - 13539 ) <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java b / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java <nl> index 5020b45 . . ae442e7 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java <nl> @ @ - 38 , 37 + 38 , 43 @ @ public class SeedManager <nl> final Distribution sample ; <nl> final long sampleOffset ; <nl> final int sampleSize ; <nl> + final long sampleMultiplier ; <nl> final boolean updateSampleImmediately ; <nl> <nl> public SeedManager ( StressSettings settings ) <nl> { <nl> + Distribution sample = settings . insert . revisit . get ( ) ; <nl> + this . sampleOffset = Math . min ( sample . minValue ( ) , sample . maxValue ( ) ) ; <nl> + long sampleSize = 1 + Math . max ( sample . minValue ( ) , sample . maxValue ( ) ) - sampleOffset ; <nl> + if ( sampleOffset < 0 | | sampleSize > Integer . MAX _ VALUE ) <nl> + throw new IllegalArgumentException ( " sample range is invalid " ) ; <nl> + <nl> + / / need to get a big numerical range even if a small number of discrete values <nl> + / / one plus so we still get variation at the low order numbers as well as high <nl> + this . sampleMultiplier = 1 + Math . round ( Math . pow ( 10D , 22 - Math . log10 ( sampleSize ) ) ) ; <nl> + <nl> Generator writes , reads ; <nl> if ( settings . generate . sequence ! = null ) <nl> { <nl> long [ ] seq = settings . generate . sequence ; <nl> if ( settings . generate . readlookback ! = null ) <nl> { <nl> - LookbackableWriteGenerator series = new LookbackableWriteGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , settings . generate . readlookback . get ( ) ) ; <nl> + LookbackableWriteGenerator series = new LookbackableWriteGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , settings . generate . readlookback . get ( ) , sampleMultiplier ) ; <nl> writes = series ; <nl> reads = series . reads ; <nl> } <nl> else <nl> { <nl> - writes = reads = new SeriesGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap ) ; <nl> + writes = reads = new SeriesGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , sampleMultiplier ) ; <nl> } <nl> } <nl> else <nl> { <nl> - writes = reads = new RandomGenerator ( settings . generate . distribution . get ( ) ) ; <nl> + writes = reads = new RandomGenerator ( settings . generate . distribution . get ( ) , sampleMultiplier ) ; <nl> } <nl> this . visits = settings . insert . visits . get ( ) ; <nl> this . writes = writes ; <nl> this . reads = reads ; <nl> - Distribution sample = settings . insert . revisit . get ( ) ; <nl> - this . sampleOffset = Math . min ( sample . minValue ( ) , sample . maxValue ( ) ) ; <nl> - long sampleSize = 1 + Math . max ( sample . minValue ( ) , sample . maxValue ( ) ) - sampleOffset ; <nl> - if ( sampleOffset < 0 | | sampleSize > Integer . MAX _ VALUE ) <nl> - throw new IllegalArgumentException ( " sample range is invalid " ) ; <nl> this . sampleFrom = new LockedDynamicList < > ( ( int ) sampleSize ) ; <nl> this . sample = DistributionInverted . invert ( sample ) ; <nl> this . sampleSize = ( int ) sampleSize ; <nl> @ @ - 132 , 15 + 138 , 18 @ @ public class SeedManager <nl> { <nl> <nl> final Distribution distribution ; <nl> + final long multiplier ; <nl> <nl> - public RandomGenerator ( Distribution distribution ) <nl> + public RandomGenerator ( Distribution distribution , long multiplier ) <nl> { <nl> + <nl> this . distribution = distribution ; <nl> + this . multiplier = multiplier ; <nl> } <nl> <nl> public Seed next ( int visits ) <nl> { <nl> - return new Seed ( distribution . next ( ) , visits ) ; <nl> + return new Seed ( distribution . next ( ) * multiplier , visits ) ; <nl> } <nl> } <nl> <nl> @ @ - 150 , 15 + 159 , 18 @ @ public class SeedManager <nl> final long start ; <nl> final long totalCount ; <nl> final boolean wrap ; <nl> + final long multiplier ; <nl> final AtomicLong next = new AtomicLong ( ) ; <nl> <nl> - public SeriesGenerator ( long start , long end , boolean wrap ) <nl> + public SeriesGenerator ( long start , long end , boolean wrap , long multiplier ) <nl> { <nl> this . wrap = wrap ; <nl> if ( start > end ) <nl> throw new IllegalStateException ( ) ; <nl> this . start = start ; <nl> this . totalCount = 1 + end - start ; <nl> + this . multiplier = multiplier ; <nl> + <nl> } <nl> <nl> public Seed next ( int visits ) <nl> @ @ - 166 , 7 + 178 , 7 @ @ public class SeedManager <nl> long next = this . next . getAndIncrement ( ) ; <nl> if ( ! wrap & & next > = totalCount ) <nl> return null ; <nl> - return new Seed ( start + ( next % totalCount ) , visits ) ; <nl> + return new Seed ( ( start + ( next % totalCount ) ) * multiplier , visits ) ; <nl> } <nl> } <nl> <nl> @ @ - 177 , 9 + 189 , 9 @ @ public class SeedManager <nl> final ConcurrentSkipListMap < Seed , Seed > afterMin = new ConcurrentSkipListMap < > ( ) ; <nl> final LookbackReadGenerator reads ; <nl> <nl> - public LookbackableWriteGenerator ( long start , long end , boolean wrap , Distribution readLookback ) <nl> + public LookbackableWriteGenerator ( long start , long end , boolean wrap , Distribution readLookback , long multiplier ) <nl> { <nl> - super ( start , end , wrap ) ; <nl> + super ( start , end , wrap , multiplier ) ; <nl> this . writeCount . set ( 0 ) ; <nl> reads = new LookbackReadGenerator ( readLookback ) ; <nl> } <nl> @ @ - 189 , 12 + 201 , 12 @ @ public class SeedManager <nl> long next = this . next . getAndIncrement ( ) ; <nl> if ( ! wrap & & next > = totalCount ) <nl> return null ; <nl> - return new Seed ( start + ( next % totalCount ) , visits ) ; <nl> + return new Seed ( ( start + ( next % totalCount ) ) * multiplier , visits ) ; <nl> } <nl> <nl> void finishWrite ( Seed seed ) <nl> { <nl> - if ( seed . seed < = writeCount . get ( ) ) <nl> + if ( seed . seed / multiplier < = writeCount . get ( ) ) <nl> return ; <nl> afterMin . put ( seed , seed ) ; <nl> while ( true )
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f34b325 . . aed0036 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Fix Randomness of stress values ( CASSANDRA - 12744 ) 
 * Allow selecting Map values and Set elements ( CASSANDRA - 7396 ) 
 * Fast and garbage - free Streaming Histogram ( CASSANDRA - 13444 ) 
 * Update repairTime for keyspaces on completion ( CASSANDRA - 13539 ) 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java b / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java 
 index 5020b45 . . ae442e7 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / generate / SeedManager . java 
 @ @ - 38 , 37 + 38 , 43 @ @ public class SeedManager 
 final Distribution sample ; 
 final long sampleOffset ; 
 final int sampleSize ; 
 + final long sampleMultiplier ; 
 final boolean updateSampleImmediately ; 
 
 public SeedManager ( StressSettings settings ) 
 { 
 + Distribution sample = settings . insert . revisit . get ( ) ; 
 + this . sampleOffset = Math . min ( sample . minValue ( ) , sample . maxValue ( ) ) ; 
 + long sampleSize = 1 + Math . max ( sample . minValue ( ) , sample . maxValue ( ) ) - sampleOffset ; 
 + if ( sampleOffset < 0 | | sampleSize > Integer . MAX _ VALUE ) 
 + throw new IllegalArgumentException ( " sample range is invalid " ) ; 
 + 
 + / / need to get a big numerical range even if a small number of discrete values 
 + / / one plus so we still get variation at the low order numbers as well as high 
 + this . sampleMultiplier = 1 + Math . round ( Math . pow ( 10D , 22 - Math . log10 ( sampleSize ) ) ) ; 
 + 
 Generator writes , reads ; 
 if ( settings . generate . sequence ! = null ) 
 { 
 long [ ] seq = settings . generate . sequence ; 
 if ( settings . generate . readlookback ! = null ) 
 { 
 - LookbackableWriteGenerator series = new LookbackableWriteGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , settings . generate . readlookback . get ( ) ) ; 
 + LookbackableWriteGenerator series = new LookbackableWriteGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , settings . generate . readlookback . get ( ) , sampleMultiplier ) ; 
 writes = series ; 
 reads = series . reads ; 
 } 
 else 
 { 
 - writes = reads = new SeriesGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap ) ; 
 + writes = reads = new SeriesGenerator ( seq [ 0 ] , seq [ 1 ] , settings . generate . wrap , sampleMultiplier ) ; 
 } 
 } 
 else 
 { 
 - writes = reads = new RandomGenerator ( settings . generate . distribution . get ( ) ) ; 
 + writes = reads = new RandomGenerator ( settings . generate . distribution . get ( ) , sampleMultiplier ) ; 
 } 
 this . visits = settings . insert . visits . get ( ) ; 
 this . writes = writes ; 
 this . reads = reads ; 
 - Distribution sample = settings . insert . revisit . get ( ) ; 
 - this . sampleOffset = Math . min ( sample . minValue ( ) , sample . maxValue ( ) ) ; 
 - long sampleSize = 1 + Math . max ( sample . minValue ( ) , sample . maxValue ( ) ) - sampleOffset ; 
 - if ( sampleOffset < 0 | | sampleSize > Integer . MAX _ VALUE ) 
 - throw new IllegalArgumentException ( " sample range is invalid " ) ; 
 this . sampleFrom = new LockedDynamicList < > ( ( int ) sampleSize ) ; 
 this . sample = DistributionInverted . invert ( sample ) ; 
 this . sampleSize = ( int ) sampleSize ; 
 @ @ - 132 , 15 + 138 , 18 @ @ public class SeedManager 
 { 
 
 final Distribution distribution ; 
 + final long multiplier ; 
 
 - public RandomGenerator ( Distribution distribution ) 
 + public RandomGenerator ( Distribution distribution , long multiplier ) 
 { 
 + 
 this . distribution = distribution ; 
 + this . multiplier = multiplier ; 
 } 
 
 public Seed next ( int visits ) 
 { 
 - return new Seed ( distribution . next ( ) , visits ) ; 
 + return new Seed ( distribution . next ( ) * multiplier , visits ) ; 
 } 
 } 
 
 @ @ - 150 , 15 + 159 , 18 @ @ public class SeedManager 
 final long start ; 
 final long totalCount ; 
 final boolean wrap ; 
 + final long multiplier ; 
 final AtomicLong next = new AtomicLong ( ) ; 
 
 - public SeriesGenerator ( long start , long end , boolean wrap ) 
 + public SeriesGenerator ( long start , long end , boolean wrap , long multiplier ) 
 { 
 this . wrap = wrap ; 
 if ( start > end ) 
 throw new IllegalStateException ( ) ; 
 this . start = start ; 
 this . totalCount = 1 + end - start ; 
 + this . multiplier = multiplier ; 
 + 
 } 
 
 public Seed next ( int visits ) 
 @ @ - 166 , 7 + 178 , 7 @ @ public class SeedManager 
 long next = this . next . getAndIncrement ( ) ; 
 if ( ! wrap & & next > = totalCount ) 
 return null ; 
 - return new Seed ( start + ( next % totalCount ) , visits ) ; 
 + return new Seed ( ( start + ( next % totalCount ) ) * multiplier , visits ) ; 
 } 
 } 
 
 @ @ - 177 , 9 + 189 , 9 @ @ public class SeedManager 
 final ConcurrentSkipListMap < Seed , Seed > afterMin = new ConcurrentSkipListMap < > ( ) ; 
 final LookbackReadGenerator reads ; 
 
 - public LookbackableWriteGenerator ( long start , long end , boolean wrap , Distribution readLookback ) 
 + public LookbackableWriteGenerator ( long start , long end , boolean wrap , Distribution readLookback , long multiplier ) 
 { 
 - super ( start , end , wrap ) ; 
 + super ( start , end , wrap , multiplier ) ; 
 this . writeCount . set ( 0 ) ; 
 reads = new LookbackReadGenerator ( readLookback ) ; 
 } 
 @ @ - 189 , 12 + 201 , 12 @ @ public class SeedManager 
 long next = this . next . getAndIncrement ( ) ; 
 if ( ! wrap & & next > = totalCount ) 
 return null ; 
 - return new Seed ( start + ( next % totalCount ) , visits ) ; 
 + return new Seed ( ( start + ( next % totalCount ) ) * multiplier , visits ) ; 
 } 
 
 void finishWrite ( Seed seed ) 
 { 
 - if ( seed . seed < = writeCount . get ( ) ) 
 + if ( seed . seed / multiplier < = writeCount . get ( ) ) 
 return ; 
 afterMin . put ( seed , seed ) ; 
 while ( true )

NEAREST DIFF:
ELIMINATEDSENTENCE
