BLEU SCORE: 0.01232213501844496

TEST MSG: Avoid potential race when rebuilding CFMetaData . columnMetadata
GENERATED MSG: fix add / remove index bugs in CFMetadata . patch by gdusbabek , reviewed by tjake . CASSANDRA - 1768

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b3063b4 . . 02786c5 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 9 <nl> + * Avoid potential race when rebuilding CFMetaData ( CASSANDRA - 12098 ) <nl> * Avoid missing sstables when getting the canonical sstables ( CASSANDRA - 11996 ) <nl> * Always select the live sstables when getting sstables in bounds ( CASSANDRA - 11944 ) <nl> * Fix column ordering of results with static columns for Thrift requests in <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index e263697 . . 5678ada 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import java . lang . reflect . Constructor ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . ThreadLocalRandom ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . stream . Collectors ; <nl> @ @ - 53 , 9 + 52 , 6 @ @ import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . schema . * ; <nl> import org . apache . cassandra . utils . * ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . Pair ; <nl> - import org . apache . cassandra . utils . UUIDGen ; <nl> import org . github . jamm . Unmetered ; <nl> <nl> / * * <nl> @ @ - 109 , 7 + 105 , 7 @ @ public final class CFMetaData <nl> * clustering key ones , those list are ordered by the " component index " of the <nl> * elements . <nl> * / <nl> - private final Map < ByteBuffer , ColumnDefinition > columnMetadata = new ConcurrentHashMap < > ( ) ; / / not on any hot path <nl> + private volatile Map < ByteBuffer , ColumnDefinition > columnMetadata = new HashMap < > ( ) ; <nl> private volatile List < ColumnDefinition > partitionKeyColumns ; / / Always of size keyValidator . componentsCount , null padded if necessary <nl> private volatile List < ColumnDefinition > clusteringColumns ; / / Of size comparator . componentsCount or comparator . componentsCount - 1 , null padded if necessary <nl> private volatile PartitionColumns partitionColumns ; / / Always non - PK , non - clustering columns <nl> @ @ - 298 , 16 + 294 , 18 @ @ public final class CFMetaData <nl> { <nl> this . comparator = new ClusteringComparator ( extractTypes ( clusteringColumns ) ) ; <nl> <nl> - this . columnMetadata . clear ( ) ; <nl> + Map < ByteBuffer , ColumnDefinition > newColumnMetadata = new HashMap < > ( ) ; <nl> for ( ColumnDefinition def : partitionKeyColumns ) <nl> - this . columnMetadata . put ( def . name . bytes , def ) ; <nl> + newColumnMetadata . put ( def . name . bytes , def ) ; <nl> for ( ColumnDefinition def : clusteringColumns ) <nl> { <nl> - this . columnMetadata . put ( def . name . bytes , def ) ; <nl> + newColumnMetadata . put ( def . name . bytes , def ) ; <nl> def . type . checkComparable ( ) ; <nl> } <nl> for ( ColumnDefinition def : partitionColumns ) <nl> - this . columnMetadata . put ( def . name . bytes , def ) ; <nl> + newColumnMetadata . put ( def . name . bytes , def ) ; <nl> + <nl> + this . columnMetadata = newColumnMetadata ; <nl> <nl> List < AbstractType < ? > > keyTypes = extractTypes ( partitionKeyColumns ) ; <nl> this . keyValidator = keyTypes . size ( ) = = 1 ? keyTypes . get ( 0 ) : CompositeType . getInstance ( keyTypes ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index c649588 . . 49c926f 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . config ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> import java . util . HashSet ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> @ @ - 215 , 7 + 216 , 7 @ @ public final class CFMetaData <nl> ? DEFAULT _ MEMTABLE _ OPERATIONS _ IN _ MILLIONS <nl> : memtableOperationsInMillions ; <nl> this . cfId = cfId ; <nl> - this . column _ metadata = Collections . unmodifiableMap ( column _ metadata ) ; <nl> + this . column _ metadata = new HashMap < ByteBuffer , ColumnDefinition > ( column _ metadata ) ; <nl> } <nl> <nl> / * * adds this cfm to the map . * / <nl> @ @ - 662 , 6 + 663 , 8 @ @ public final class CFMetaData <nl> / / update the ones staying <nl> for ( org . apache . cassandra . avro . ColumnDef def : cf _ def . column _ metadata ) <nl> { <nl> + if ( ! column _ metadata . containsKey ( def . name ) ) <nl> + continue ; <nl> column _ metadata . get ( def . name ) . setIndexType ( def . index _ type = = null ? null : org . apache . cassandra . thrift . IndexType . valueOf ( def . index _ type . name ( ) ) ) ; <nl> column _ metadata . get ( def . name ) . setIndexName ( def . index _ name = = null ? null : def . index _ name . toString ( ) ) ; <nl> } <nl> @ @ - 734 , 7 + 737 , 7 @ @ public final class CFMetaData <nl> def . key _ cache _ size = cfm . keyCacheSize ; <nl> def . read _ repair _ chance = cfm . readRepairChance ; <nl> def . gc _ grace _ seconds = cfm . gcGraceSeconds ; <nl> - def . default _ validation _ class = cfm . defaultValidator . getClass ( ) . getName ( ) ; <nl> + def . default _ validation _ class = cfm . defaultValidator = = null ? null : cfm . defaultValidator . getClass ( ) . getName ( ) ; <nl> def . min _ compaction _ threshold = cfm . minCompactionThreshold ; <nl> def . max _ compaction _ threshold = cfm . maxCompactionThreshold ; <nl> def . row _ cache _ save _ period _ in _ seconds = cfm . rowCacheSavePeriodInSeconds ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / DefsTest . java b / test / unit / org / apache / cassandra / db / DefsTest . java <nl> index e770833 . . 925f619 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / DefsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / DefsTest . java <nl> @ @ - 26 , 7 + 26 , 9 @ @ import java . nio . ByteBuffer ; <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . Collections ; <nl> + import java . util . HashMap ; <nl> import java . util . List ; <nl> + import java . util . Map ; <nl> import java . util . SortedSet ; <nl> import java . util . TreeSet ; <nl> import java . util . UUID ; <nl> @ @ - 56 , 6 + 58 , 7 @ @ import org . apache . cassandra . locator . OldNetworkTopologyStrategy ; <nl> import org . apache . cassandra . locator . SimpleStrategy ; <nl> import org . apache . cassandra . thrift . CfDef ; <nl> import org . apache . cassandra . thrift . ColumnDef ; <nl> + import org . apache . cassandra . thrift . IndexType ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . UUIDGen ; <nl> import org . junit . Test ; <nl> @ @ - 74 , 6 + 77 , 63 @ @ public class DefsTest extends CleanupHelper <nl> } <nl> <nl> @ Test <nl> + public void testCFMetaDataApply ( ) throws ConfigurationException <nl> + { <nl> + Map < ByteBuffer , ColumnDefinition > indexes = new HashMap < ByteBuffer , ColumnDefinition > ( ) ; <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + ByteBuffer name = ByteBuffer . wrap ( new byte [ ] { ( byte ) i } ) ; <nl> + indexes . put ( name , new ColumnDefinition ( name , null , IndexType . KEYS , Integer . toString ( i ) ) ) ; <nl> + } <nl> + CFMetaData cfm = new CFMetaData ( " Keyspace1 " , <nl> + " TestApplyCFM _ CF " , <nl> + ColumnFamilyType . Standard , <nl> + BytesType . instance , <nl> + null , <nl> + " No comment " , <nl> + 1 . 0 , <nl> + 1 . 0 , <nl> + 0 . 5 , <nl> + 100000 , <nl> + null , <nl> + 500 , <nl> + 500 , <nl> + 500 , <nl> + 500 , <nl> + 500 , <nl> + 500 , <nl> + 500 . 0 , <nl> + indexes ) ; <nl> + <nl> + / / we ' ll be adding this one later . make sure it ' s not already there . <nl> + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 5 } ) ) = = null ; <nl> + org . apache . cassandra . avro . CfDef cfDef = CFMetaData . convertToAvro ( cfm ) ; <nl> + <nl> + / / add one . <nl> + org . apache . cassandra . avro . ColumnDef addIndexDef = new org . apache . cassandra . avro . ColumnDef ( ) ; <nl> + addIndexDef . index _ name = " 5 " ; <nl> + addIndexDef . index _ type = org . apache . cassandra . avro . IndexType . KEYS ; <nl> + addIndexDef . name = ByteBuffer . wrap ( new byte [ ] { 5 } ) ; <nl> + addIndexDef . validation _ class = BytesType . class . getName ( ) ; <nl> + cfDef . column _ metadata . add ( addIndexDef ) ; <nl> + <nl> + / / remove one . <nl> + org . apache . cassandra . avro . ColumnDef removeIndexDef = new org . apache . cassandra . avro . ColumnDef ( ) ; <nl> + removeIndexDef . index _ name = " 0 " ; <nl> + removeIndexDef . index _ type = org . apache . cassandra . avro . IndexType . KEYS ; <nl> + removeIndexDef . name = ByteBuffer . wrap ( new byte [ ] { 0 } ) ; <nl> + removeIndexDef . validation _ class = BytesType . class . getName ( ) ; <nl> + assert cfDef . column _ metadata . remove ( removeIndexDef ) ; <nl> + <nl> + cfm . apply ( cfDef ) ; <nl> + <nl> + for ( int i = 1 ; i < indexes . size ( ) ; i + + ) <nl> + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 1 } ) ) ! = null ; <nl> + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 0 } ) ) = = null ; <nl> + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 5 } ) ) ! = null ; <nl> + } <nl> + <nl> + @ Test <nl> public void testInvalidNames ( ) throws IOException <nl> { <nl> String [ ] valid = { " 1 " , " a " , " _ 1 " , " b _ " , " _ _ " , " 1 _ a " } ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b3063b4 . . 02786c5 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 9 
 + * Avoid potential race when rebuilding CFMetaData ( CASSANDRA - 12098 ) 
 * Avoid missing sstables when getting the canonical sstables ( CASSANDRA - 11996 ) 
 * Always select the live sstables when getting sstables in bounds ( CASSANDRA - 11944 ) 
 * Fix column ordering of results with static columns for Thrift requests in 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index e263697 . . 5678ada 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import java . lang . reflect . Constructor ; 
 import java . lang . reflect . InvocationTargetException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . ThreadLocalRandom ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . stream . Collectors ; 
 @ @ - 53 , 9 + 52 , 6 @ @ import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . schema . * ; 
 import org . apache . cassandra . utils . * ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . Pair ; 
 - import org . apache . cassandra . utils . UUIDGen ; 
 import org . github . jamm . Unmetered ; 
 
 / * * 
 @ @ - 109 , 7 + 105 , 7 @ @ public final class CFMetaData 
 * clustering key ones , those list are ordered by the " component index " of the 
 * elements . 
 * / 
 - private final Map < ByteBuffer , ColumnDefinition > columnMetadata = new ConcurrentHashMap < > ( ) ; / / not on any hot path 
 + private volatile Map < ByteBuffer , ColumnDefinition > columnMetadata = new HashMap < > ( ) ; 
 private volatile List < ColumnDefinition > partitionKeyColumns ; / / Always of size keyValidator . componentsCount , null padded if necessary 
 private volatile List < ColumnDefinition > clusteringColumns ; / / Of size comparator . componentsCount or comparator . componentsCount - 1 , null padded if necessary 
 private volatile PartitionColumns partitionColumns ; / / Always non - PK , non - clustering columns 
 @ @ - 298 , 16 + 294 , 18 @ @ public final class CFMetaData 
 { 
 this . comparator = new ClusteringComparator ( extractTypes ( clusteringColumns ) ) ; 
 
 - this . columnMetadata . clear ( ) ; 
 + Map < ByteBuffer , ColumnDefinition > newColumnMetadata = new HashMap < > ( ) ; 
 for ( ColumnDefinition def : partitionKeyColumns ) 
 - this . columnMetadata . put ( def . name . bytes , def ) ; 
 + newColumnMetadata . put ( def . name . bytes , def ) ; 
 for ( ColumnDefinition def : clusteringColumns ) 
 { 
 - this . columnMetadata . put ( def . name . bytes , def ) ; 
 + newColumnMetadata . put ( def . name . bytes , def ) ; 
 def . type . checkComparable ( ) ; 
 } 
 for ( ColumnDefinition def : partitionColumns ) 
 - this . columnMetadata . put ( def . name . bytes , def ) ; 
 + newColumnMetadata . put ( def . name . bytes , def ) ; 
 + 
 + this . columnMetadata = newColumnMetadata ; 
 
 List < AbstractType < ? > > keyTypes = extractTypes ( partitionKeyColumns ) ; 
 this . keyValidator = keyTypes . size ( ) = = 1 ? keyTypes . get ( 0 ) : CompositeType . getInstance ( keyTypes ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index c649588 . . 49c926f 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . config ; 
 import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . Collections ; 
 + import java . util . HashMap ; 
 import java . util . HashSet ; 
 import java . util . List ; 
 import java . util . Map ; 
 @ @ - 215 , 7 + 216 , 7 @ @ public final class CFMetaData 
 ? DEFAULT _ MEMTABLE _ OPERATIONS _ IN _ MILLIONS 
 : memtableOperationsInMillions ; 
 this . cfId = cfId ; 
 - this . column _ metadata = Collections . unmodifiableMap ( column _ metadata ) ; 
 + this . column _ metadata = new HashMap < ByteBuffer , ColumnDefinition > ( column _ metadata ) ; 
 } 
 
 / * * adds this cfm to the map . * / 
 @ @ - 662 , 6 + 663 , 8 @ @ public final class CFMetaData 
 / / update the ones staying 
 for ( org . apache . cassandra . avro . ColumnDef def : cf _ def . column _ metadata ) 
 { 
 + if ( ! column _ metadata . containsKey ( def . name ) ) 
 + continue ; 
 column _ metadata . get ( def . name ) . setIndexType ( def . index _ type = = null ? null : org . apache . cassandra . thrift . IndexType . valueOf ( def . index _ type . name ( ) ) ) ; 
 column _ metadata . get ( def . name ) . setIndexName ( def . index _ name = = null ? null : def . index _ name . toString ( ) ) ; 
 } 
 @ @ - 734 , 7 + 737 , 7 @ @ public final class CFMetaData 
 def . key _ cache _ size = cfm . keyCacheSize ; 
 def . read _ repair _ chance = cfm . readRepairChance ; 
 def . gc _ grace _ seconds = cfm . gcGraceSeconds ; 
 - def . default _ validation _ class = cfm . defaultValidator . getClass ( ) . getName ( ) ; 
 + def . default _ validation _ class = cfm . defaultValidator = = null ? null : cfm . defaultValidator . getClass ( ) . getName ( ) ; 
 def . min _ compaction _ threshold = cfm . minCompactionThreshold ; 
 def . max _ compaction _ threshold = cfm . maxCompactionThreshold ; 
 def . row _ cache _ save _ period _ in _ seconds = cfm . rowCacheSavePeriodInSeconds ; 
 diff - - git a / test / unit / org / apache / cassandra / db / DefsTest . java b / test / unit / org / apache / cassandra / db / DefsTest . java 
 index e770833 . . 925f619 100644 
 - - - a / test / unit / org / apache / cassandra / db / DefsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / DefsTest . java 
 @ @ - 26 , 7 + 26 , 9 @ @ import java . nio . ByteBuffer ; 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . Collections ; 
 + import java . util . HashMap ; 
 import java . util . List ; 
 + import java . util . Map ; 
 import java . util . SortedSet ; 
 import java . util . TreeSet ; 
 import java . util . UUID ; 
 @ @ - 56 , 6 + 58 , 7 @ @ import org . apache . cassandra . locator . OldNetworkTopologyStrategy ; 
 import org . apache . cassandra . locator . SimpleStrategy ; 
 import org . apache . cassandra . thrift . CfDef ; 
 import org . apache . cassandra . thrift . ColumnDef ; 
 + import org . apache . cassandra . thrift . IndexType ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . UUIDGen ; 
 import org . junit . Test ; 
 @ @ - 74 , 6 + 77 , 63 @ @ public class DefsTest extends CleanupHelper 
 } 
 
 @ Test 
 + public void testCFMetaDataApply ( ) throws ConfigurationException 
 + { 
 + Map < ByteBuffer , ColumnDefinition > indexes = new HashMap < ByteBuffer , ColumnDefinition > ( ) ; 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + { 
 + ByteBuffer name = ByteBuffer . wrap ( new byte [ ] { ( byte ) i } ) ; 
 + indexes . put ( name , new ColumnDefinition ( name , null , IndexType . KEYS , Integer . toString ( i ) ) ) ; 
 + } 
 + CFMetaData cfm = new CFMetaData ( " Keyspace1 " , 
 + " TestApplyCFM _ CF " , 
 + ColumnFamilyType . Standard , 
 + BytesType . instance , 
 + null , 
 + " No comment " , 
 + 1 . 0 , 
 + 1 . 0 , 
 + 0 . 5 , 
 + 100000 , 
 + null , 
 + 500 , 
 + 500 , 
 + 500 , 
 + 500 , 
 + 500 , 
 + 500 , 
 + 500 . 0 , 
 + indexes ) ; 
 + 
 + / / we ' ll be adding this one later . make sure it ' s not already there . 
 + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 5 } ) ) = = null ; 
 + org . apache . cassandra . avro . CfDef cfDef = CFMetaData . convertToAvro ( cfm ) ; 
 + 
 + / / add one . 
 + org . apache . cassandra . avro . ColumnDef addIndexDef = new org . apache . cassandra . avro . ColumnDef ( ) ; 
 + addIndexDef . index _ name = " 5 " ; 
 + addIndexDef . index _ type = org . apache . cassandra . avro . IndexType . KEYS ; 
 + addIndexDef . name = ByteBuffer . wrap ( new byte [ ] { 5 } ) ; 
 + addIndexDef . validation _ class = BytesType . class . getName ( ) ; 
 + cfDef . column _ metadata . add ( addIndexDef ) ; 
 + 
 + / / remove one . 
 + org . apache . cassandra . avro . ColumnDef removeIndexDef = new org . apache . cassandra . avro . ColumnDef ( ) ; 
 + removeIndexDef . index _ name = " 0 " ; 
 + removeIndexDef . index _ type = org . apache . cassandra . avro . IndexType . KEYS ; 
 + removeIndexDef . name = ByteBuffer . wrap ( new byte [ ] { 0 } ) ; 
 + removeIndexDef . validation _ class = BytesType . class . getName ( ) ; 
 + assert cfDef . column _ metadata . remove ( removeIndexDef ) ; 
 + 
 + cfm . apply ( cfDef ) ; 
 + 
 + for ( int i = 1 ; i < indexes . size ( ) ; i + + ) 
 + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 1 } ) ) ! = null ; 
 + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 0 } ) ) = = null ; 
 + assert cfm . getColumn _ metadata ( ) . get ( ByteBuffer . wrap ( new byte [ ] { 5 } ) ) ! = null ; 
 + } 
 + 
 + @ Test 
 public void testInvalidNames ( ) throws IOException 
 { 
 String [ ] valid = { " 1 " , " a " , " _ 1 " , " b _ " , " _ _ " , " 1 _ a " } ;
