BLEU SCORE: 0.01222796968620182

TEST MSG: AbstractReplicaCollection equals and hash code should throw due to conflict between order sensitive / insensitive uses
GENERATED MSG: Add Unittest for schema migration fix

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 5cfc7ab . . 2fd02e2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * AbstractReplicaCollection equals and hash code should throw due to conflict between order sensitive / insensitive uses ( CASSANDRA - 14700 ) <nl> * Detect inconsistencies in repaired data on the read path ( CASSANDRA - 14145 ) <nl> * Add checksumming to the native protocol ( CASSANDRA - 13304 ) <nl> * Make AuthCache more easily extendable ( CASSANDRA - 14662 ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java b / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java <nl> index ecf1296 . . 6a7a4ff 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java <nl> @ @ - 223 , 24 + 223 , 35 @ @ public abstract class AbstractReplicaCollection < C extends AbstractReplicaCollect <nl> <nl> public final Stream < Replica > stream ( ) { return list . stream ( ) ; } <nl> <nl> + / * * <nl> + * < p > <nl> + * It ' s not clear whether { @ link AbstractReplicaCollection } should implement the order sensitive { @ link Object # equals ( Object ) equals } <nl> + * of { @ link java . util . List } or the order oblivious { @ link Object # equals ( Object ) equals } of { @ link java . util . Set } . We never rely on equality <nl> + * in the database so rather then leave in a potentially surprising implementation we have it throw { @ link UnsupportedOperationException } . <nl> + * < / p > <nl> + * < p > <nl> + * Don ' t implement this and pick one behavior over the other . If you want equality you can static import { @ link com . google . common . collect . Iterables # elementsEqual ( Iterable , Iterable ) } <nl> + * and use that to get order sensitive equals . <nl> + * < / p > <nl> + * / <nl> public final boolean equals ( Object o ) <nl> { <nl> - if ( this = = o ) return true ; <nl> - if ( ! ( o instanceof AbstractReplicaCollection < ? > ) ) <nl> - { <nl> - if ( ! ( o instanceof ReplicaCollection < ? > ) ) <nl> - return false ; <nl> - <nl> - ReplicaCollection < ? > that = ( ReplicaCollection < ? > ) o ; <nl> - return Iterables . elementsEqual ( this , that ) ; <nl> - } <nl> - AbstractReplicaCollection < ? > that = ( AbstractReplicaCollection < ? > ) o ; <nl> - return Objects . equals ( list , that . list ) ; <nl> + throw new UnsupportedOperationException ( " AbstractReplicaCollection equals unsupported " ) ; <nl> } <nl> <nl> + / * * <nl> + * < p > <nl> + * It ' s not clear whether { @ link AbstractReplicaCollection } should implement the order sensitive { @ link Object # hashCode ( ) hashCode } <nl> + * of { @ link java . util . List } or the order oblivious { @ link Object # hashCode ( ) equals } of { @ link java . util . Set } . We never rely on hashCode <nl> + * in the database so rather then leave in a potentially surprising implementation we have it throw { @ link UnsupportedOperationException } . <nl> + * < / p > <nl> + * < p > <nl> + * Don ' t implement this and pick one behavior over the other . <nl> + * < / p > <nl> + * / <nl> public final int hashCode ( ) <nl> { <nl> - return list . hashCode ( ) ; <nl> + throw new UnsupportedOperationException ( " AbstractReplicaCollection hashCode unsupported " ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java <nl> index bc2c19c . . d413fd7 100644 <nl> - - - a / test / unit / org / apache / cassandra / Util . java <nl> + + + b / test / unit / org / apache / cassandra / Util . java <nl> @ @ - 41 , 6 + 41 , 7 @ @ import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> + import org . apache . cassandra . locator . ReplicaCollection ; <nl> import org . apache . cassandra . schema . ColumnMetadata ; <nl> import org . apache . cassandra . schema . TableId ; <nl> import org . apache . cassandra . schema . TableMetadata ; <nl> @ @ - 74 , 6 + 75 , 7 @ @ import org . apache . cassandra . utils . CounterId ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> import static org . junit . Assert . assertNotNull ; <nl> import static org . junit . Assert . assertThat ; <nl> import static org . junit . Assert . assertTrue ; <nl> @ @ - 718 , 4 + 720 , 14 @ @ public class Util <nl> PagingState . RowMark mark = PagingState . RowMark . create ( metadata , row , protocolVersion ) ; <nl> return new PagingState ( pk , mark , 10 , 0 ) ; <nl> } <nl> + <nl> + public static void assertRCEquals ( ReplicaCollection < ? > a , ReplicaCollection < ? > b ) <nl> + { <nl> + assertTrue ( a + " not equal to " + b , Iterables . elementsEqual ( a , b ) ) ; <nl> + } <nl> + <nl> + public static void assertNotRCEquals ( ReplicaCollection < ? > a , ReplicaCollection < ? > b ) <nl> + { <nl> + assertFalse ( a + " equal to " + b , Iterables . elementsEqual ( a , b ) ) ; <nl> + } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java b / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java <nl> index 2a6cb65 . . 9f5e656 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import org . junit . Assert ; <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . dht . ByteOrderedPartitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> @ @ - 71 , 8 + 72 , 8 @ @ public class StreamRequestTest <nl> StreamRequest decoded = StreamRequest . serializer . deserialize ( in , version ) ; <nl> <nl> Assert . assertEquals ( orig . keyspace , decoded . keyspace ) ; <nl> - Assert . assertEquals ( orig . full , decoded . full ) ; <nl> - Assert . assertEquals ( orig . transientReplicas , decoded . transientReplicas ) ; <nl> + Util . assertRCEquals ( orig . full , decoded . full ) ; <nl> + Util . assertRCEquals ( orig . transientReplicas , decoded . transientReplicas ) ; <nl> Assert . assertEquals ( orig . columnFamilies , decoded . columnFamilies ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> index bf1d940 . . fbf6e89 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> @ @ - 24 , 13 + 24 , 12 @ @ import java . util . * ; <nl> import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> - import static org . junit . Assert . assertEquals ; <nl> - <nl> public class DynamicEndpointSnitchTest <nl> { <nl> <nl> @ @ - 77 , 40 + 76 , 41 @ @ public class DynamicEndpointSnitchTest <nl> / / first , make all hosts equal <nl> setScores ( dsnitch , 1 , hosts , 10 , 10 , 10 ) ; <nl> EndpointsForRange order = full ( host1 , host2 , host3 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> / / make host1 a little worse <nl> setScores ( dsnitch , 1 , hosts , 20 , 10 , 10 ) ; <nl> order = full ( host2 , host3 , host1 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> / / make host2 as bad as host1 <nl> setScores ( dsnitch , 2 , hosts , 15 , 20 , 10 ) ; <nl> order = full ( host3 , host1 , host2 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> / / make host3 the worst <nl> setScores ( dsnitch , 3 , hosts , 10 , 10 , 30 ) ; <nl> order = full ( host1 , host2 , host3 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> / / make host3 equal to the others <nl> setScores ( dsnitch , 5 , hosts , 10 , 10 , 10 ) ; <nl> order = full ( host1 , host2 , host3 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> / / / Tests CASSANDRA - 6683 improvements <nl> / / make the scores differ enough from the ideal order that we sort by score ; under the old <nl> / / dynamic snitch behavior ( where we only compared neighbors ) , these wouldn ' t get sorted <nl> setScores ( dsnitch , 20 , hosts , 10 , 70 , 20 ) ; <nl> order = full ( host1 , host3 , host2 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; <nl> <nl> order = full ( host4 , host1 , host3 , host2 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; <nl> + <nl> <nl> setScores ( dsnitch , 20 , hosts , 10 , 10 , 10 ) ; <nl> order = full ( host4 , host1 , host2 , host3 ) ; <nl> - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; <nl> + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java b / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java <nl> index 5f6e26f . . 2a97108 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java <nl> @ @ - 35 , 6 + 35 , 7 @ @ import org . junit . Test ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner . LongToken ; <nl> @ @ - 418 , 15 + 419 , 15 @ @ public class NetworkTopologyStrategyTest <nl> <nl> NetworkTopologyStrategy strategy = new NetworkTopologyStrategy ( keyspaceName , metadata , snitch , configOptions ) ; <nl> <nl> - Assert . assertEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 0 ) , range ( 400 , 100 ) ) , <nl> - fullReplica ( endpoints . get ( 1 ) , range ( 400 , 100 ) ) , <nl> - transientReplica ( endpoints . get ( 2 ) , range ( 400 , 100 ) ) ) , <nl> + Util . assertRCEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 0 ) , range ( 400 , 100 ) ) , <nl> + fullReplica ( endpoints . get ( 1 ) , range ( 400 , 100 ) ) , <nl> + transientReplica ( endpoints . get ( 2 ) , range ( 400 , 100 ) ) ) , <nl> strategy . getNaturalReplicasForToken ( tk ( 99 ) ) ) ; <nl> <nl> <nl> - Assert . assertEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 1 ) , range ( 100 , 200 ) ) , <nl> - fullReplica ( endpoints . get ( 2 ) , range ( 100 , 200 ) ) , <nl> - transientReplica ( endpoints . get ( 3 ) , range ( 100 , 200 ) ) ) , <nl> + Util . assertRCEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 1 ) , range ( 100 , 200 ) ) , <nl> + fullReplica ( endpoints . get ( 2 ) , range ( 100 , 200 ) ) , <nl> + transientReplica ( endpoints . get ( 3 ) , range ( 100 , 200 ) ) ) , <nl> strategy . getNaturalReplicasForToken ( tk ( 101 ) ) ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java b / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java <nl> index e6a9365 . . 805532d 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; <nl> import org . apache . cassandra . dht . Token ; <nl> @ @ - 73 , 7 + 74 , 7 @ @ public class ReplicationStrategyEndpointCacheTest <nl> public void runEndpointsWereCachedTest ( Class stratClass , Map < String , String > configOptions ) throws Exception <nl> { <nl> setup ( stratClass , configOptions ) ; <nl> - assert strategy . getNaturalReplicasForToken ( searchToken ) . equals ( strategy . getNaturalReplicasForToken ( searchToken ) ) ; <nl> + Util . assertRCEquals ( strategy . getNaturalReplicasForToken ( searchToken ) , strategy . getNaturalReplicasForToken ( searchToken ) ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 98 , 7 + 99 , 7 @ @ public class ReplicationStrategyEndpointCacheTest <nl> tmd . updateNormalToken ( new BigIntegerToken ( String . valueOf ( 35 ) ) , InetAddressAndPort . getByName ( " 127 . 0 . 0 . 5 " ) ) ; <nl> replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; <nl> assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; <nl> - assert ! replicas . equals ( initial ) ; <nl> + Util . assertNotRCEquals ( replicas , initial ) ; <nl> <nl> / / test token removal , newly created token <nl> initial = strategy . getNaturalReplicasForToken ( searchToken ) ; <nl> @ @ - 106 , 7 + 107 , 7 @ @ public class ReplicationStrategyEndpointCacheTest <nl> replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; <nl> assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; <nl> assert ! replicas . endpoints ( ) . contains ( InetAddressAndPort . getByName ( " 127 . 0 . 0 . 5 " ) ) ; <nl> - assert ! replicas . equals ( initial ) ; <nl> + Util . assertNotRCEquals ( replicas , initial ) ; <nl> <nl> / / test token change <nl> initial = strategy . getNaturalReplicasForToken ( searchToken ) ; <nl> @ @ - 114 , 7 + 115 , 7 @ @ public class ReplicationStrategyEndpointCacheTest <nl> tmd . updateNormalToken ( new BigIntegerToken ( String . valueOf ( 25 ) ) , InetAddressAndPort . getByName ( " 127 . 0 . 0 . 8 " ) ) ; <nl> replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; <nl> assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; <nl> - assert ! replicas . equals ( initial ) ; <nl> + Util . assertNotRCEquals ( replicas , initial ) ; <nl> } <nl> <nl> protected static class FakeSimpleStrategy extends SimpleStrategy <nl> diff - - git a / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java b / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java <nl> index 1e0c152 . . 338e752 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . junit . BeforeClass ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> import org . apache . cassandra . dht . Range ; <nl> @ @ - 222 , 7 + 223 , 7 @ @ public class SimpleStrategyTest <nl> SimpleStrategy strategy = new SimpleStrategy ( " ks " , metadata , snitch , configOptions ) ; <nl> <nl> Range < Token > range1 = range ( 400 , 100 ) ; <nl> - Assert . assertEquals ( EndpointsForToken . of ( range1 . right , <nl> + Util . assertRCEquals ( EndpointsForToken . of ( range1 . right , <nl> Replica . fullReplica ( endpoints . get ( 0 ) , range1 ) , <nl> Replica . fullReplica ( endpoints . get ( 1 ) , range1 ) , <nl> Replica . transientReplica ( endpoints . get ( 2 ) , range1 ) ) , <nl> @ @ - 230 , 7 + 231 , 7 @ @ public class SimpleStrategyTest <nl> <nl> <nl> Range < Token > range2 = range ( 100 , 200 ) ; <nl> - Assert . assertEquals ( EndpointsForToken . of ( range2 . right , <nl> + Util . assertRCEquals ( EndpointsForToken . of ( range2 . right , <nl> Replica . fullReplica ( endpoints . get ( 1 ) , range2 ) , <nl> Replica . fullReplica ( endpoints . get ( 2 ) , range2 ) , <nl> Replica . transientReplica ( endpoints . get ( 3 ) , range2 ) ) ,
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 5cfc7ab . . 2fd02e2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * AbstractReplicaCollection equals and hash code should throw due to conflict between order sensitive / insensitive uses ( CASSANDRA - 14700 ) 
 * Detect inconsistencies in repaired data on the read path ( CASSANDRA - 14145 ) 
 * Add checksumming to the native protocol ( CASSANDRA - 13304 ) 
 * Make AuthCache more easily extendable ( CASSANDRA - 14662 ) 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java b / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java 
 index ecf1296 . . 6a7a4ff 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicaCollection . java 
 @ @ - 223 , 24 + 223 , 35 @ @ public abstract class AbstractReplicaCollection < C extends AbstractReplicaCollect 
 
 public final Stream < Replica > stream ( ) { return list . stream ( ) ; } 
 
 + / * * 
 + * < p > 
 + * It ' s not clear whether { @ link AbstractReplicaCollection } should implement the order sensitive { @ link Object # equals ( Object ) equals } 
 + * of { @ link java . util . List } or the order oblivious { @ link Object # equals ( Object ) equals } of { @ link java . util . Set } . We never rely on equality 
 + * in the database so rather then leave in a potentially surprising implementation we have it throw { @ link UnsupportedOperationException } . 
 + * < / p > 
 + * < p > 
 + * Don ' t implement this and pick one behavior over the other . If you want equality you can static import { @ link com . google . common . collect . Iterables # elementsEqual ( Iterable , Iterable ) } 
 + * and use that to get order sensitive equals . 
 + * < / p > 
 + * / 
 public final boolean equals ( Object o ) 
 { 
 - if ( this = = o ) return true ; 
 - if ( ! ( o instanceof AbstractReplicaCollection < ? > ) ) 
 - { 
 - if ( ! ( o instanceof ReplicaCollection < ? > ) ) 
 - return false ; 
 - 
 - ReplicaCollection < ? > that = ( ReplicaCollection < ? > ) o ; 
 - return Iterables . elementsEqual ( this , that ) ; 
 - } 
 - AbstractReplicaCollection < ? > that = ( AbstractReplicaCollection < ? > ) o ; 
 - return Objects . equals ( list , that . list ) ; 
 + throw new UnsupportedOperationException ( " AbstractReplicaCollection equals unsupported " ) ; 
 } 
 
 + / * * 
 + * < p > 
 + * It ' s not clear whether { @ link AbstractReplicaCollection } should implement the order sensitive { @ link Object # hashCode ( ) hashCode } 
 + * of { @ link java . util . List } or the order oblivious { @ link Object # hashCode ( ) equals } of { @ link java . util . Set } . We never rely on hashCode 
 + * in the database so rather then leave in a potentially surprising implementation we have it throw { @ link UnsupportedOperationException } . 
 + * < / p > 
 + * < p > 
 + * Don ' t implement this and pick one behavior over the other . 
 + * < / p > 
 + * / 
 public final int hashCode ( ) 
 { 
 - return list . hashCode ( ) ; 
 + throw new UnsupportedOperationException ( " AbstractReplicaCollection hashCode unsupported " ) ; 
 } 
 
 @ Override 
 diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java 
 index bc2c19c . . d413fd7 100644 
 - - - a / test / unit / org / apache / cassandra / Util . java 
 + + + b / test / unit / org / apache / cassandra / Util . java 
 @ @ - 41 , 6 + 41 , 7 @ @ import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 + import org . apache . cassandra . locator . ReplicaCollection ; 
 import org . apache . cassandra . schema . ColumnMetadata ; 
 import org . apache . cassandra . schema . TableId ; 
 import org . apache . cassandra . schema . TableMetadata ; 
 @ @ - 74 , 6 + 75 , 7 @ @ import org . apache . cassandra . utils . CounterId ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 import static org . junit . Assert . assertNotNull ; 
 import static org . junit . Assert . assertThat ; 
 import static org . junit . Assert . assertTrue ; 
 @ @ - 718 , 4 + 720 , 14 @ @ public class Util 
 PagingState . RowMark mark = PagingState . RowMark . create ( metadata , row , protocolVersion ) ; 
 return new PagingState ( pk , mark , 10 , 0 ) ; 
 } 
 + 
 + public static void assertRCEquals ( ReplicaCollection < ? > a , ReplicaCollection < ? > b ) 
 + { 
 + assertTrue ( a + " not equal to " + b , Iterables . elementsEqual ( a , b ) ) ; 
 + } 
 + 
 + public static void assertNotRCEquals ( ReplicaCollection < ? > a , ReplicaCollection < ? > b ) 
 + { 
 + assertFalse ( a + " equal to " + b , Iterables . elementsEqual ( a , b ) ) ; 
 + } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java b / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java 
 index 2a6cb65 . . 9f5e656 100644 
 - - - a / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java 
 + + + b / test / unit / org / apache / cassandra / db / streaming / StreamRequestTest . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import org . junit . Assert ; 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . dht . ByteOrderedPartitioner ; 
 import org . apache . cassandra . dht . Range ; 
 @ @ - 71 , 8 + 72 , 8 @ @ public class StreamRequestTest 
 StreamRequest decoded = StreamRequest . serializer . deserialize ( in , version ) ; 
 
 Assert . assertEquals ( orig . keyspace , decoded . keyspace ) ; 
 - Assert . assertEquals ( orig . full , decoded . full ) ; 
 - Assert . assertEquals ( orig . transientReplicas , decoded . transientReplicas ) ; 
 + Util . assertRCEquals ( orig . full , decoded . full ) ; 
 + Util . assertRCEquals ( orig . transientReplicas , decoded . transientReplicas ) ; 
 Assert . assertEquals ( orig . columnFamilies , decoded . columnFamilies ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 index bf1d940 . . fbf6e89 100644 
 - - - a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 @ @ - 24 , 13 + 24 , 12 @ @ import java . util . * ; 
 import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 - import static org . junit . Assert . assertEquals ; 
 - 
 public class DynamicEndpointSnitchTest 
 { 
 
 @ @ - 77 , 40 + 76 , 41 @ @ public class DynamicEndpointSnitchTest 
 / / first , make all hosts equal 
 setScores ( dsnitch , 1 , hosts , 10 , 10 , 10 ) ; 
 EndpointsForRange order = full ( host1 , host2 , host3 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 / / make host1 a little worse 
 setScores ( dsnitch , 1 , hosts , 20 , 10 , 10 ) ; 
 order = full ( host2 , host3 , host1 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 / / make host2 as bad as host1 
 setScores ( dsnitch , 2 , hosts , 15 , 20 , 10 ) ; 
 order = full ( host3 , host1 , host2 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 / / make host3 the worst 
 setScores ( dsnitch , 3 , hosts , 10 , 10 , 30 ) ; 
 order = full ( host1 , host2 , host3 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 / / make host3 equal to the others 
 setScores ( dsnitch , 5 , hosts , 10 , 10 , 10 ) ; 
 order = full ( host1 , host2 , host3 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 / / / Tests CASSANDRA - 6683 improvements 
 / / make the scores differ enough from the ideal order that we sort by score ; under the old 
 / / dynamic snitch behavior ( where we only compared neighbors ) , these wouldn ' t get sorted 
 setScores ( dsnitch , 20 , hosts , 10 , 70 , 20 ) ; 
 order = full ( host1 , host3 , host2 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 ) ) ) ; 
 
 order = full ( host4 , host1 , host3 , host2 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; 
 + 
 
 setScores ( dsnitch , 20 , hosts , 10 , 10 , 10 ) ; 
 order = full ( host4 , host1 , host2 , host3 ) ; 
 - assertEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; 
 + Util . assertRCEquals ( order , dsnitch . sortedByProximity ( self , full ( host1 , host2 , host3 , host4 ) ) ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java b / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java 
 index 5f6e26f . . 2a97108 100644 
 - - - a / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / NetworkTopologyStrategyTest . java 
 @ @ - 35 , 6 + 35 , 7 @ @ import org . junit . Test ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 import org . apache . cassandra . dht . Murmur3Partitioner . LongToken ; 
 @ @ - 418 , 15 + 419 , 15 @ @ public class NetworkTopologyStrategyTest 
 
 NetworkTopologyStrategy strategy = new NetworkTopologyStrategy ( keyspaceName , metadata , snitch , configOptions ) ; 
 
 - Assert . assertEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 0 ) , range ( 400 , 100 ) ) , 
 - fullReplica ( endpoints . get ( 1 ) , range ( 400 , 100 ) ) , 
 - transientReplica ( endpoints . get ( 2 ) , range ( 400 , 100 ) ) ) , 
 + Util . assertRCEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 0 ) , range ( 400 , 100 ) ) , 
 + fullReplica ( endpoints . get ( 1 ) , range ( 400 , 100 ) ) , 
 + transientReplica ( endpoints . get ( 2 ) , range ( 400 , 100 ) ) ) , 
 strategy . getNaturalReplicasForToken ( tk ( 99 ) ) ) ; 
 
 
 - Assert . assertEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 1 ) , range ( 100 , 200 ) ) , 
 - fullReplica ( endpoints . get ( 2 ) , range ( 100 , 200 ) ) , 
 - transientReplica ( endpoints . get ( 3 ) , range ( 100 , 200 ) ) ) , 
 + Util . assertRCEquals ( EndpointsForRange . of ( fullReplica ( endpoints . get ( 1 ) , range ( 100 , 200 ) ) , 
 + fullReplica ( endpoints . get ( 2 ) , range ( 100 , 200 ) ) , 
 + transientReplica ( endpoints . get ( 3 ) , range ( 100 , 200 ) ) ) , 
 strategy . getNaturalReplicasForToken ( tk ( 101 ) ) ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java b / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java 
 index e6a9365 . . 805532d 100644 
 - - - a / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / ReplicationStrategyEndpointCacheTest . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; 
 import org . apache . cassandra . dht . Token ; 
 @ @ - 73 , 7 + 74 , 7 @ @ public class ReplicationStrategyEndpointCacheTest 
 public void runEndpointsWereCachedTest ( Class stratClass , Map < String , String > configOptions ) throws Exception 
 { 
 setup ( stratClass , configOptions ) ; 
 - assert strategy . getNaturalReplicasForToken ( searchToken ) . equals ( strategy . getNaturalReplicasForToken ( searchToken ) ) ; 
 + Util . assertRCEquals ( strategy . getNaturalReplicasForToken ( searchToken ) , strategy . getNaturalReplicasForToken ( searchToken ) ) ; 
 } 
 
 @ Test 
 @ @ - 98 , 7 + 99 , 7 @ @ public class ReplicationStrategyEndpointCacheTest 
 tmd . updateNormalToken ( new BigIntegerToken ( String . valueOf ( 35 ) ) , InetAddressAndPort . getByName ( " 127 . 0 . 0 . 5 " ) ) ; 
 replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; 
 assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; 
 - assert ! replicas . equals ( initial ) ; 
 + Util . assertNotRCEquals ( replicas , initial ) ; 
 
 / / test token removal , newly created token 
 initial = strategy . getNaturalReplicasForToken ( searchToken ) ; 
 @ @ - 106 , 7 + 107 , 7 @ @ public class ReplicationStrategyEndpointCacheTest 
 replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; 
 assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; 
 assert ! replicas . endpoints ( ) . contains ( InetAddressAndPort . getByName ( " 127 . 0 . 0 . 5 " ) ) ; 
 - assert ! replicas . equals ( initial ) ; 
 + Util . assertNotRCEquals ( replicas , initial ) ; 
 
 / / test token change 
 initial = strategy . getNaturalReplicasForToken ( searchToken ) ; 
 @ @ - 114 , 7 + 115 , 7 @ @ public class ReplicationStrategyEndpointCacheTest 
 tmd . updateNormalToken ( new BigIntegerToken ( String . valueOf ( 25 ) ) , InetAddressAndPort . getByName ( " 127 . 0 . 0 . 8 " ) ) ; 
 replicas = strategy . getNaturalReplicasForToken ( searchToken ) ; 
 assert replicas . size ( ) = = 5 : StringUtils . join ( replicas , " , " ) ; 
 - assert ! replicas . equals ( initial ) ; 
 + Util . assertNotRCEquals ( replicas , initial ) ; 
 } 
 
 protected static class FakeSimpleStrategy extends SimpleStrategy 
 diff - - git a / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java b / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java 
 index 1e0c152 . . 338e752 100644 
 - - - a / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / SimpleStrategyTest . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . junit . BeforeClass ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . dht . Murmur3Partitioner ; 
 import org . apache . cassandra . dht . Range ; 
 @ @ - 222 , 7 + 223 , 7 @ @ public class SimpleStrategyTest 
 SimpleStrategy strategy = new SimpleStrategy ( " ks " , metadata , snitch , configOptions ) ; 
 
 Range < Token > range1 = range ( 400 , 100 ) ; 
 - Assert . assertEquals ( EndpointsForToken . of ( range1 . right , 
 + Util . assertRCEquals ( EndpointsForToken . of ( range1 . right , 
 Replica . fullReplica ( endpoints . get ( 0 ) , range1 ) , 
 Replica . fullReplica ( endpoints . get ( 1 ) , range1 ) , 
 Replica . transientReplica ( endpoints . get ( 2 ) , range1 ) ) , 
 @ @ - 230 , 7 + 231 , 7 @ @ public class SimpleStrategyTest 
 
 
 Range < Token > range2 = range ( 100 , 200 ) ; 
 - Assert . assertEquals ( EndpointsForToken . of ( range2 . right , 
 + Util . assertRCEquals ( EndpointsForToken . of ( range2 . right , 
 Replica . fullReplica ( endpoints . get ( 1 ) , range2 ) , 
 Replica . fullReplica ( endpoints . get ( 2 ) , range2 ) , 
 Replica . transientReplica ( endpoints . get ( 3 ) , range2 ) ) ,

NEAREST DIFF:
ELIMINATEDSENTENCE
