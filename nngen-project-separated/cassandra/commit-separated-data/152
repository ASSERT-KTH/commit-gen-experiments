BLEU SCORE: 0.018738883683389617

TEST MSG: Don ' t fail startup if peers aren ' t live
GENERATED MSG: Discard in - flight shadow round responses

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 42ea3b4 . . 39213a1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 11 . 3 <nl> + * Allow existing nodes to use all peers in shadow round ( CASSANDRA - 13851 ) <nl> * Fix cqlsh to read connection . ssl cqlshrc option again ( CASSANDRA - 14299 ) <nl> * Downgrade log level to trace for CommitLogSegmentManager ( CASSANDRA - 14370 ) <nl> * CQL fromJson ( null ) throws NullPointerException ( CASSANDRA - 13891 ) <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 2dac5c2 . . ea05525 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 1361 , 6 + 1361 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> TimeUnit . MILLISECONDS ) ; <nl> } <nl> <nl> + public synchronized Map < InetAddress , EndpointState > doShadowRound ( ) <nl> + { <nl> + return doShadowRound ( Collections . EMPTY _ SET ) ; <nl> + } <nl> + <nl> / * * <nl> * Do a single ' shadow ' round of gossip by retrieving endpoint states that will be stored exclusively in the <nl> * map return value , instead of endpointStateMap . <nl> @ @ - 1376 , 16 + 1381 , 21 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> * caller of { @ link Gossiper # doShadowRound ( ) } . Therefor only a single shadow round execution is permitted at <nl> * the same time . <nl> * <nl> + * @ param peers Additional peers to try gossiping with . <nl> * @ return endpoint states gathered during shadow round or empty map <nl> * / <nl> - public synchronized Map < InetAddress , EndpointState > doShadowRound ( ) <nl> + public synchronized Map < InetAddress , EndpointState > doShadowRound ( Set < InetAddress > peers ) <nl> { <nl> buildSeedsList ( ) ; <nl> - / / it may be that the local address is the only entry in the seed <nl> + / / it may be that the local address is the only entry in the seed + peers <nl> / / list in which case , attempting a shadow round is pointless <nl> - if ( seeds . isEmpty ( ) ) <nl> + if ( seeds . isEmpty ( ) & & peers . isEmpty ( ) ) <nl> return endpointShadowStateMap ; <nl> <nl> + boolean isSeed = DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + / / We double RING _ DELAY if we ' re not a seed to increase chance of successful startup during a full cluster bounce , <nl> + / / giving the seeds a chance to startup before we fail the shadow round <nl> + int shadowRoundDelay = isSeed ? StorageService . RING _ DELAY : StorageService . RING _ DELAY * 2 ; <nl> seedsInShadowRound . clear ( ) ; <nl> endpointShadowStateMap . clear ( ) ; <nl> / / send a completely empty syn <nl> @ @ - 1398 , 6 + 1408 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> GossipDigestSyn . serializer ) ; <nl> <nl> inShadowRound = true ; <nl> + boolean includePeers = false ; <nl> int slept = 0 ; <nl> try <nl> { <nl> @ @ - 1409 , 6 + 1420 , 15 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> <nl> for ( InetAddress seed : seeds ) <nl> MessagingService . instance ( ) . sendOneWay ( message , seed ) ; <nl> + <nl> + / / Send to any peers we already know about , but only if a seed didn ' t respond . <nl> + if ( includePeers ) <nl> + { <nl> + logger . trace ( " Sending shadow round GOSSIP DIGEST SYN to known peers { } " , peers ) ; <nl> + for ( InetAddress peer : peers ) <nl> + MessagingService . instance ( ) . sendOneWay ( message , peer ) ; <nl> + } <nl> + includePeers = true ; <nl> } <nl> <nl> Thread . sleep ( 1000 ) ; <nl> @ @ - 1416 , 13 + 1436 , 12 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> break ; <nl> <nl> slept + = 1000 ; <nl> - if ( slept > StorageService . RING _ DELAY ) <nl> + if ( slept > shadowRoundDelay ) <nl> { <nl> - / / if we don ' t consider ourself to be a seed , fail out <nl> - if ( ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> - throw new RuntimeException ( " Unable to gossip with any seeds " ) ; <nl> + / / if we got here no peers could be gossiped to . If we ' re a seed that ' s OK , but otherwise we stop . See CASSANDRA - 13851 <nl> + if ( ! isSeed ) <nl> + throw new RuntimeException ( " Unable to gossip with any peers " ) ; <nl> <nl> - logger . warn ( " Unable to gossip with any seeds but continuing since node is in its own seed list " ) ; <nl> inShadowRound = false ; <nl> break ; <nl> } <nl> @ @ - 1566 , 6 + 1585 , 9 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> { <nl> if ( ! isInShadowRound ) <nl> { <nl> + if ( ! seeds . contains ( respondent ) ) <nl> + logger . warn ( " Received an ack from { } , who isn ' t a seed . Ensure your seed list includes a live node . Exiting shadow round " , <nl> + respondent ) ; <nl> logger . debug ( " Received a regular ack from { } , can now exit shadow round " , respondent ) ; <nl> / / respondent sent back a full ack , so we can exit our shadow round <nl> endpointShadowStateMap . putAll ( epStateMap ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 6faaa04 . . d262807 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 535 , 7 + 535 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> return localHostId ; <nl> } <nl> <nl> - private synchronized void checkForEndpointCollision ( UUID localHostId ) throws ConfigurationException <nl> + private synchronized void checkForEndpointCollision ( UUID localHostId , Set < InetAddress > peers ) throws ConfigurationException <nl> { <nl> if ( Boolean . getBoolean ( " cassandra . allow _ unsafe _ join " ) ) <nl> { <nl> @ @ - 544 , 7 + 544 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> <nl> logger . debug ( " Starting shadow gossip round to check for endpoint collision " ) ; <nl> - Map < InetAddress , EndpointState > epStates = Gossiper . instance . doShadowRound ( ) ; <nl> + Map < InetAddress , EndpointState > epStates = Gossiper . instance . doShadowRound ( peers ) ; <nl> + <nl> + if ( epStates . isEmpty ( ) & & DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> + logger . info ( " Unable to gossip with any peers but continuing anyway since node is in its own seed list " ) ; <nl> + <nl> / / If bootstrapping , check whether any previously known status for the endpoint makes it unsafe to do so . <nl> / / If not bootstrapping , compare the host id for this endpoint learned from gossip ( if any ) with the local <nl> / / one , which was either read from system . local or generated at startup . If a learned id is present & <nl> @ @ - 797 , 7 + 801 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> else <nl> { <nl> - checkForEndpointCollision ( localHostId ) ; <nl> + checkForEndpointCollision ( localHostId , SystemKeyspace . loadHostIds ( ) . keySet ( ) ) ; <nl> } <nl> <nl> / / have to start the gossip service before we can see any info on other nodes . this is necessary
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 42ea3b4 . . 39213a1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 11 . 3 
 + * Allow existing nodes to use all peers in shadow round ( CASSANDRA - 13851 ) 
 * Fix cqlsh to read connection . ssl cqlshrc option again ( CASSANDRA - 14299 ) 
 * Downgrade log level to trace for CommitLogSegmentManager ( CASSANDRA - 14370 ) 
 * CQL fromJson ( null ) throws NullPointerException ( CASSANDRA - 13891 ) 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 2dac5c2 . . ea05525 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 1361 , 6 + 1361 , 11 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 TimeUnit . MILLISECONDS ) ; 
 } 
 
 + public synchronized Map < InetAddress , EndpointState > doShadowRound ( ) 
 + { 
 + return doShadowRound ( Collections . EMPTY _ SET ) ; 
 + } 
 + 
 / * * 
 * Do a single ' shadow ' round of gossip by retrieving endpoint states that will be stored exclusively in the 
 * map return value , instead of endpointStateMap . 
 @ @ - 1376 , 16 + 1381 , 21 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 * caller of { @ link Gossiper # doShadowRound ( ) } . Therefor only a single shadow round execution is permitted at 
 * the same time . 
 * 
 + * @ param peers Additional peers to try gossiping with . 
 * @ return endpoint states gathered during shadow round or empty map 
 * / 
 - public synchronized Map < InetAddress , EndpointState > doShadowRound ( ) 
 + public synchronized Map < InetAddress , EndpointState > doShadowRound ( Set < InetAddress > peers ) 
 { 
 buildSeedsList ( ) ; 
 - / / it may be that the local address is the only entry in the seed 
 + / / it may be that the local address is the only entry in the seed + peers 
 / / list in which case , attempting a shadow round is pointless 
 - if ( seeds . isEmpty ( ) ) 
 + if ( seeds . isEmpty ( ) & & peers . isEmpty ( ) ) 
 return endpointShadowStateMap ; 
 
 + boolean isSeed = DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + / / We double RING _ DELAY if we ' re not a seed to increase chance of successful startup during a full cluster bounce , 
 + / / giving the seeds a chance to startup before we fail the shadow round 
 + int shadowRoundDelay = isSeed ? StorageService . RING _ DELAY : StorageService . RING _ DELAY * 2 ; 
 seedsInShadowRound . clear ( ) ; 
 endpointShadowStateMap . clear ( ) ; 
 / / send a completely empty syn 
 @ @ - 1398 , 6 + 1408 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 GossipDigestSyn . serializer ) ; 
 
 inShadowRound = true ; 
 + boolean includePeers = false ; 
 int slept = 0 ; 
 try 
 { 
 @ @ - 1409 , 6 + 1420 , 15 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 
 for ( InetAddress seed : seeds ) 
 MessagingService . instance ( ) . sendOneWay ( message , seed ) ; 
 + 
 + / / Send to any peers we already know about , but only if a seed didn ' t respond . 
 + if ( includePeers ) 
 + { 
 + logger . trace ( " Sending shadow round GOSSIP DIGEST SYN to known peers { } " , peers ) ; 
 + for ( InetAddress peer : peers ) 
 + MessagingService . instance ( ) . sendOneWay ( message , peer ) ; 
 + } 
 + includePeers = true ; 
 } 
 
 Thread . sleep ( 1000 ) ; 
 @ @ - 1416 , 13 + 1436 , 12 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 break ; 
 
 slept + = 1000 ; 
 - if ( slept > StorageService . RING _ DELAY ) 
 + if ( slept > shadowRoundDelay ) 
 { 
 - / / if we don ' t consider ourself to be a seed , fail out 
 - if ( ! DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ) 
 - throw new RuntimeException ( " Unable to gossip with any seeds " ) ; 
 + / / if we got here no peers could be gossiped to . If we ' re a seed that ' s OK , but otherwise we stop . See CASSANDRA - 13851 
 + if ( ! isSeed ) 
 + throw new RuntimeException ( " Unable to gossip with any peers " ) ; 
 
 - logger . warn ( " Unable to gossip with any seeds but continuing since node is in its own seed list " ) ; 
 inShadowRound = false ; 
 break ; 
 } 
 @ @ - 1566 , 6 + 1585 , 9 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 { 
 if ( ! isInShadowRound ) 
 { 
 + if ( ! seeds . contains ( respondent ) ) 
 + logger . warn ( " Received an ack from { } , who isn ' t a seed . Ensure your seed list includes a live node . Exiting shadow round " , 
 + respondent ) ; 
 logger . debug ( " Received a regular ack from { } , can now exit shadow round " , respondent ) ; 
 / / respondent sent back a full ack , so we can exit our shadow round 
 endpointShadowStateMap . putAll ( epStateMap ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 6faaa04 . . d262807 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 535 , 7 + 535 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 return localHostId ; 
 } 
 
 - private synchronized void checkForEndpointCollision ( UUID localHostId ) throws ConfigurationException 
 + private synchronized void checkForEndpointCollision ( UUID localHostId , Set < InetAddress > peers ) throws ConfigurationException 
 { 
 if ( Boolean . getBoolean ( " cassandra . allow _ unsafe _ join " ) ) 
 { 
 @ @ - 544 , 7 + 544 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 
 logger . debug ( " Starting shadow gossip round to check for endpoint collision " ) ; 
 - Map < InetAddress , EndpointState > epStates = Gossiper . instance . doShadowRound ( ) ; 
 + Map < InetAddress , EndpointState > epStates = Gossiper . instance . doShadowRound ( peers ) ; 
 + 
 + if ( epStates . isEmpty ( ) & & DatabaseDescriptor . getSeeds ( ) . contains ( FBUtilities . getBroadcastAddress ( ) ) ) 
 + logger . info ( " Unable to gossip with any peers but continuing anyway since node is in its own seed list " ) ; 
 + 
 / / If bootstrapping , check whether any previously known status for the endpoint makes it unsafe to do so . 
 / / If not bootstrapping , compare the host id for this endpoint learned from gossip ( if any ) with the local 
 / / one , which was either read from system . local or generated at startup . If a learned id is present & 
 @ @ - 797 , 7 + 801 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 else 
 { 
 - checkForEndpointCollision ( localHostId ) ; 
 + checkForEndpointCollision ( localHostId , SystemKeyspace . loadHostIds ( ) . keySet ( ) ) ; 
 } 
 
 / / have to start the gossip service before we can see any info on other nodes . this is necessary

NEAREST DIFF:
ELIMINATEDSENTENCE
