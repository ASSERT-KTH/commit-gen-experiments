BLEU SCORE: 0.6389431042462724

TEST MSG: Revert " Allow sending keyspace independent of query string "
GENERATED MSG: Allow sending keyspace independent of query string

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b29912d . . 618446d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 5 + 1 , 4 @ @ <nl> 4 . 0 <nl> - * Allow sending keyspace independent of query string via native protocol ( CASSANDRA - 10145 ) <nl> * Thrift removal ( CASSANDRA - 11115 ) <nl> * Remove pre - 3 . 0 compatibility code for 4 . 0 ( CASSANDRA - 12716 ) <nl> * Add column definition kind to dropped columns in schema ( CASSANDRA - 12705 ) <nl> diff - - git a / doc / native _ protocol _ v5 . spec b / doc / native _ protocol _ v5 . spec <nl> index 3084016 . . 35dd2d7 100644 <nl> - - - a / doc / native _ protocol _ v5 . spec <nl> + + + b / doc / native _ protocol _ v5 . spec <nl> @ @ - 314 , 7 + 314 , 7 @ @ Table of Contents <nl> < query > < query _ parameters > <nl> where < query > is a [ long string ] representing the query and <nl> < query _ parameters > must be <nl> - < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] <nl> + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] <nl> where : <nl> - < consistency > is the [ consistency ] level for the operation . <nl> - < flags > is a [ int ] whose bits define the options for this query and <nl> @ @ - 357 , 9 + 357 , 6 @ @ Table of Contents <nl> since the names for the expected values was returned during preparation , <nl> a client can always provide values in the right order without any names <nl> and using this flag , while supported , is almost surely inefficient . <nl> - 0x80 : With keyspace . If set , < keyspace > should be present . < keyspace > is a <nl> - [ string ] indicating the keyspace that the query should be executed in . <nl> - It supercedes the keyspace that the connection is bound to , if any . <nl> <nl> Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , <nl> TRUNCATE , . . . ) . <nl> @ @ - 370 , 17 + 367 , 8 @ @ Table of Contents <nl> <nl> 4 . 1 . 5 . PREPARE <nl> <nl> - Prepare a query for later execution ( through EXECUTE ) . The body of the message must be : <nl> - < query > < flags > [ < keyspace > ] <nl> - where : <nl> - - < query > is a [ long string ] representing the CQL query . <nl> - - < flags > is a [ int ] whose bits define the options for this statement and in particular <nl> - influence what the remainder of the message contains . <nl> - A flag is set if the bit corresponding to its ` mask ` is set . Supported <nl> - flags are , given their mask : <nl> - 0x01 : With keyspace . If set , < keyspace > should be present . < keyspace > is a <nl> - [ string ] indicating the keyspace that the query should be executed in . <nl> - It supercedes the keyspace that the connection is bound to , if any . <nl> + Prepare a query for later execution ( through EXECUTE ) . The body consists of <nl> + the CQL query to prepare as a [ long string ] . <nl> <nl> The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , <nl> see Section 4 . 2 . 5 ) . <nl> @ @ - 402 , 7 + 390 , 7 @ @ Table of Contents <nl> Allows executing a list of queries ( prepared or not ) as a batch ( note that <nl> only DML statements are accepted in a batch ) . The body of the message must <nl> be : <nl> - < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] <nl> + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] <nl> where : <nl> - < type > is a [ byte ] indicating the type of batch to use : <nl> - If < type > = = 0 , the batch will be " logged " . This is equivalent to a <nl> @ @ - 434 , 9 + 422 , 6 @ @ Table of Contents <nl> to implement . This will be fixed in a future version of the native <nl> protocol . See https : / / issues . apache . org / jira / browse / CASSANDRA - 10246 for <nl> more details ] . <nl> - 0x80 : With keyspace . If set , < keyspace > should be present . < keyspace > is a <nl> - [ string ] indicating the keyspace that the query should be executed in . <nl> - It supercedes the keyspace that the connection is bound to , if any . <nl> - < n > is a [ short ] indicating the number of following queries . <nl> - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the <nl> form : <nl> @ @ - 1197 , 5 + 1182 , 3 @ @ Table of Contents <nl> a failure reason code which indicates why the request failed on that node . <nl> * Enlarged flag ' s bitmaps for QUERY , EXECUTE and BATCH messages from [ byte ] to [ int ] <nl> ( Sections 4 . 1 . 4 , 4 . 1 . 6 and 4 . 1 . 7 ) . <nl> - * Added keyspace field in QUERY , PREPARE , and BATCH messages ( Sections 4 . 1 . 4 , 4 . 1 . 5 , and 4 . 1 . 7 ) . <nl> - * Added [ int ] flags field in PREPARE message ( Section 4 . 1 . 5 ) . <nl> \ No newline at end of file <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> index 3d3cda0 . . db7fa39 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java <nl> @ @ - 62 , 11 + 62 , 6 @ @ public abstract class BatchQueryOptions <nl> return wrapped . getConsistency ( ) ; <nl> } <nl> <nl> - public String getKeyspace ( ) <nl> - { <nl> - return wrapped . getKeyspace ( ) ; <nl> - } <nl> - <nl> public ConsistencyLevel getSerialConsistency ( ) <nl> { <nl> return wrapped . getSerialConsistency ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> index 32cddba . . aa8ca48 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java <nl> @ @ - 22 , 7 + 22 , 6 @ @ import java . util . Map ; <nl> <nl> import org . apache . cassandra . cql3 . statements . BatchStatement ; <nl> import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> - import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> @ @ - 47 , 9 + 46 , 9 @ @ public class CustomPayloadMirroringQueryHandler implements QueryHandler <nl> return result ; <nl> } <nl> <nl> - public ResultMessage . Prepared prepare ( String query , ClientState clientState , Map < String , ByteBuffer > customPayload ) <nl> + public ResultMessage . Prepared prepare ( String query , QueryState state , Map < String , ByteBuffer > customPayload ) <nl> { <nl> - ResultMessage . Prepared prepared = queryProcessor . prepare ( query , clientState , customPayload ) ; <nl> + ResultMessage . Prepared prepared = queryProcessor . prepare ( query , state , customPayload ) ; <nl> prepared . setCustomPayload ( customPayload ) ; <nl> return prepared ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryHandler . java b / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> index d3b41f0 . . 0339d26 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryHandler . java <nl> @ @ - 24 , 7 + 24 , 6 @ @ import org . apache . cassandra . cql3 . statements . BatchStatement ; <nl> import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> import org . apache . cassandra . exceptions . RequestExecutionException ; <nl> import org . apache . cassandra . exceptions . RequestValidationException ; <nl> - import org . apache . cassandra . service . ClientState ; <nl> import org . apache . cassandra . service . QueryState ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> @ @ - 38 , 7 + 37 , 7 @ @ public interface QueryHandler <nl> long queryStartNanoTime ) throws RequestExecutionException , RequestValidationException ; <nl> <nl> ResultMessage . Prepared prepare ( String query , <nl> - ClientState clientState , <nl> + QueryState state , <nl> Map < String , ByteBuffer > customPayload ) throws RequestValidationException ; <nl> <nl> ParsedStatement . Prepared getPrepared ( MD5Digest id ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> index a66a98a . . 57d5eac 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java <nl> @ @ - 67 , 9 + 67 , 9 @ @ public abstract class QueryOptions <nl> return new DefaultQueryOptions ( null , null , true , null , protocolVersion ) ; <nl> } <nl> <nl> - public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version , String keyspace ) <nl> + public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version ) <nl> { <nl> - return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L , keyspace ) , version ) ; <nl> + return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , version ) ; <nl> } <nl> <nl> public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) <nl> @ @ - 86 , 11 + 86 , 11 @ @ public abstract class QueryOptions <nl> * <nl> * This is functionally equivalent to : <nl> * { @ code Json . parseJson ( UTF8Type . instance . getSerializer ( ) . deserialize ( getValues ( ) . get ( bindIndex ) ) , expectedReceivers ) . get ( columnName ) } <nl> - * but this caches the result of parsing the JSON , so that while this might be called for multiple columns on the same { @ code bindIndex } <nl> + * but this cache the result of parsing the JSON so that while this might be called for multiple columns on the same { @ code bindIndex } <nl> * value , the underlying JSON value is only parsed / processed once . <nl> * <nl> - * Note : this is a bit more involved in CQL specifics than this class generally is , but as we need to cache this per - query and in an object <nl> - * that is available when we bind values , this is the easiest place to have this . <nl> + * Note : this is a bit more involved in CQL specifics than this class generally is but we as we need to cache this per - query and in an object <nl> + * that is available when we bind values , this is the easier place to have this . <nl> * <nl> * @ param bindIndex the index of the bind value that should be interpreted as a JSON value . <nl> * @ param columnName the name of the column we want the value of . <nl> @ @ - 136 , 7 + 136 , 7 @ @ public abstract class QueryOptions <nl> * <nl> * < p > The column specifications will be present only for prepared statements . < / p > <nl> * <nl> - * < p > Invoke the { @ link # hasColumnSpecifications } method before invoking this method in order to ensure that this <nl> + * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this <nl> * < code > QueryOptions < / code > contains the column specifications . < / p > <nl> * <nl> * @ return the option names <nl> @ @ - 172 , 9 + 172 , 6 @ @ public abstract class QueryOptions <nl> return tstamp ! = Long . MIN _ VALUE ? tstamp : state . getTimestamp ( ) ; <nl> } <nl> <nl> - / * * The keyspace that this query is bound to , or null if not relevant . * / <nl> - public String getKeyspace ( ) { return getSpecificOptions ( ) . keyspace ; } <nl> - <nl> / * * <nl> * The protocol version for the query . <nl> * / <nl> @ @ - 317 , 7 + 314 , 7 @ @ public abstract class QueryOptions <nl> { <nl> super . prepare ( specs ) ; <nl> <nl> - orderedValues = new ArrayList < > ( specs . size ( ) ) ; <nl> + orderedValues = new ArrayList < ByteBuffer > ( specs . size ( ) ) ; <nl> for ( int i = 0 ; i < specs . size ( ) ; i + + ) <nl> { <nl> String name = specs . get ( i ) . name . toString ( ) ; <nl> @ @ - 344 , 21 + 341 , 19 @ @ public abstract class QueryOptions <nl> / / Options that are likely to not be present in most queries <nl> static class SpecificOptions <nl> { <nl> - private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE , null ) ; <nl> + private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE ) ; <nl> <nl> private final int pageSize ; <nl> private final PagingState state ; <nl> private final ConsistencyLevel serialConsistency ; <nl> private final long timestamp ; <nl> - private final String keyspace ; <nl> <nl> - private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp , String keyspace ) <nl> + private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp ) <nl> { <nl> this . pageSize = pageSize ; <nl> this . state = state ; <nl> this . serialConsistency = serialConsistency = = null ? ConsistencyLevel . SERIAL : serialConsistency ; <nl> this . timestamp = timestamp ; <nl> - this . keyspace = keyspace ; <nl> } <nl> } <nl> <nl> @ @ - 373 , 8 + 368 , 7 @ @ public abstract class QueryOptions <nl> PAGING _ STATE , <nl> SERIAL _ CONSISTENCY , <nl> TIMESTAMP , <nl> - NAMES _ FOR _ VALUES , <nl> - KEYSPACE ; <nl> + NAMES _ FOR _ VALUES ; <nl> <nl> private static final Flag [ ] ALL _ VALUES = values ( ) ; <nl> <nl> @ @ - 439 , 8 + 433 , 8 @ @ public abstract class QueryOptions <nl> throw new ProtocolException ( String . format ( " Out of bound timestamp , must be in [ % d , % d ] ( got % d ) " , Long . MIN _ VALUE + 1 , Long . MAX _ VALUE , ts ) ) ; <nl> timestamp = ts ; <nl> } <nl> - String keyspace = flags . contains ( Flag . KEYSPACE ) ? CBUtil . readString ( body ) : null ; <nl> - options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp , keyspace ) ; <nl> + <nl> + options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp ) ; <nl> } <nl> DefaultQueryOptions opts = new DefaultQueryOptions ( consistency , values , skipMetadata , options , version ) ; <nl> return names = = null ? opts : new OptionsWithNames ( opts , names ) ; <nl> @ @ - 466 , 8 + 460 , 6 @ @ public abstract class QueryOptions <nl> CBUtil . writeConsistencyLevel ( options . getSerialConsistency ( ) , dest ) ; <nl> if ( flags . contains ( Flag . TIMESTAMP ) ) <nl> dest . writeLong ( options . getSpecificOptions ( ) . timestamp ) ; <nl> - if ( flags . contains ( Flag . KEYSPACE ) ) <nl> - CBUtil . writeString ( options . getSpecificOptions ( ) . keyspace , dest ) ; <nl> <nl> / / Note that we don ' t really have to bother with NAMES _ FOR _ VALUES server side , <nl> / / and in fact we never really encode QueryOptions , only decode them , so we <nl> @ @ - 493 , 8 + 485 , 7 @ @ public abstract class QueryOptions <nl> size + = CBUtil . sizeOfConsistencyLevel ( options . getSerialConsistency ( ) ) ; <nl> if ( flags . contains ( Flag . TIMESTAMP ) ) <nl> size + = 8 ; <nl> - if ( flags . contains ( Flag . KEYSPACE ) ) <nl> - size + = CBUtil . sizeOfString ( options . getSpecificOptions ( ) . keyspace ) ; <nl> + <nl> return size ; <nl> } <nl> <nl> @ @ - 513 , 8 + 504 , 6 @ @ public abstract class QueryOptions <nl> flags . add ( Flag . SERIAL _ CONSISTENCY ) ; <nl> if ( options . getSpecificOptions ( ) . timestamp ! = Long . MIN _ VALUE ) <nl> flags . add ( Flag . TIMESTAMP ) ; <nl> - if ( options . getSpecificOptions ( ) . keyspace ! = null ) <nl> - flags . add ( Flag . KEYSPACE ) ; <nl> return flags ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 4f72ab1 . . 354ee72 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 212 , 7 + 212 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> public ResultMessage process ( String queryString , QueryState queryState , QueryOptions options , long queryStartNanoTime ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; <nl> + ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) ) ; <nl> options . prepare ( p . boundNames ) ; <nl> CQLStatement prepared = p . statement ; <nl> if ( prepared . getBoundTerms ( ) ! = options . getValues ( ) . size ( ) ) <nl> @ @ - 224 , 9 + 224 , 9 @ @ public class QueryProcessor implements QueryHandler <nl> return processStatement ( prepared , queryState , options , queryStartNanoTime ) ; <nl> } <nl> <nl> - public static ParsedStatement . Prepared parseStatement ( String queryStr , ClientState clientState ) throws RequestValidationException <nl> + public static ParsedStatement . Prepared parseStatement ( String queryStr , QueryState queryState ) throws RequestValidationException <nl> { <nl> - return getStatement ( queryStr , clientState ) ; <nl> + return getStatement ( queryStr , queryState . getClientState ( ) ) ; <nl> } <nl> <nl> public static UntypedResultSet process ( String query , ConsistencyLevel cl ) throws RequestExecutionException <nl> @ @ - 270 , 7 + 270 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> return prepared ; <nl> <nl> / / Note : if 2 threads prepare the same query , we ' ll live so don ' t bother synchronizing <nl> - prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; <nl> + prepared = parseStatement ( query , internalQueryState ( ) ) ; <nl> prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; <nl> internalStatements . putIfAbsent ( query , prepared ) ; <nl> return prepared ; <nl> @ @ - 327 , 7 + 327 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> * / <nl> public static UntypedResultSet executeOnceInternal ( String query , Object . . . values ) <nl> { <nl> - ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; <nl> + ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) ) ; <nl> prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; <nl> ResultMessage result = prepared . statement . executeInternal ( internalQueryState ( ) , makeInternalOptions ( prepared , values ) ) ; <nl> if ( result instanceof ResultMessage . Rows ) <nl> @ @ - 367 , 10 + 367 , 16 @ @ public class QueryProcessor implements QueryHandler <nl> } <nl> <nl> public ResultMessage . Prepared prepare ( String query , <nl> - ClientState clientState , <nl> + QueryState state , <nl> Map < String , ByteBuffer > customPayload ) throws RequestValidationException <nl> { <nl> - return prepare ( query , clientState ) ; <nl> + return prepare ( query , state ) ; <nl> + } <nl> + <nl> + public ResultMessage . Prepared prepare ( String queryString , QueryState queryState ) <nl> + { <nl> + ClientState cState = queryState . getClientState ( ) ; <nl> + return prepare ( queryString , cState ) ; <nl> } <nl> <nl> public static ResultMessage . Prepared prepare ( String queryString , ClientState clientState ) <nl> @ @ - 472 , 7 + 478 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> public ResultMessage processBatch ( BatchStatement batch , QueryState queryState , BatchQueryOptions options , long queryStartNanoTime ) <nl> throws RequestExecutionException , RequestValidationException <nl> { <nl> - ClientState clientState = queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ; <nl> + ClientState clientState = queryState . getClientState ( ) ; <nl> batch . checkAccess ( clientState ) ; <nl> batch . validate ( ) ; <nl> batch . validate ( clientState ) ; <nl> @ @ - 487 , 7 + 493 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> / / Set keyspace for statement that require login <nl> if ( statement instanceof CFStatement ) <nl> - ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; <nl> + ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; <nl> <nl> Tracing . trace ( " Preparing statement " ) ; <nl> return statement . prepare ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> index 136860e . . 9b2987c 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java <nl> @ @ - 37 , 16 + 37 , 14 @ @ public abstract class CFStatement extends ParsedStatement <nl> { <nl> if ( ! cfName . hasKeyspace ( ) ) <nl> { <nl> - / / XXX : We explicitly only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw <nl> - / / if not logged in any keyspace but a keyspace is explicitly set on the statement . So don ' t move <nl> + / / XXX : We explicitely only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw <nl> + / / if not logged in any keyspace but a keyspace is explicitely set on the statement . So don ' t move <nl> / / the call outside the ' if ' or replace the method by ' prepareKeyspace ( state . getKeyspace ( ) ) ' <nl> cfName . setKeyspace ( state . getKeyspace ( ) , true ) ; <nl> } <nl> } <nl> <nl> - / / Only for internal calls , use the version with ClientState for user queries . In particular , the <nl> - / / version with ClientState throws an exception if the statement does not have keyspace set * and * <nl> - / / ClientState has no keyspace . <nl> + / / Only for internal calls , use the version with ClientState for user queries <nl> public void prepareKeyspace ( String keyspace ) <nl> { <nl> if ( ! cfName . hasKeyspace ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> index ca38d22 . . c7cbb58 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java <nl> @ @ - 51 , 7 + 51 , 7 @ @ public abstract class ParsedStatement <nl> / * * <nl> * Contains the CQL statement source if the statement has been " regularly " perpared via <nl> * { @ link org . apache . cassandra . cql3 . QueryProcessor # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , boolean ) } / <nl> - * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , java . util . Map ) } . <nl> + * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . QueryState , java . util . Map ) } . <nl> * Other usages of this class may or may not contain the CQL statement source . <nl> * / <nl> public String rawCQLStatement ; <nl> diff - - git a / src / java / org / apache / cassandra / service / ClientState . java b / src / java / org / apache / cassandra / service / ClientState . java <nl> index 2edbd6d . . 52e71ae 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ClientState . java <nl> + + + b / src / java / org / apache / cassandra / service / ClientState . java <nl> @ @ - 139 , 14 + 139 , 6 @ @ public class ClientState <nl> this . user = AuthenticatedUser . ANONYMOUS _ USER ; <nl> } <nl> <nl> - protected ClientState ( ClientState source ) <nl> - { <nl> - this . isInternal = source . isInternal ; <nl> - this . remoteAddress = source . remoteAddress ; <nl> - this . user = source . user ; <nl> - this . keyspace = source . keyspace ; <nl> - } <nl> - <nl> / * * <nl> * @ return a ClientState object for internal C * calls ( not limited by any kind of auth ) . <nl> * / <nl> @ @ - 164 , 22 + 156 , 6 @ @ public class ClientState <nl> } <nl> <nl> / * * <nl> - * Clone this ClientState object , but use the provided keyspace instead of the <nl> - * keyspace in this ClientState object . <nl> - * <nl> - * @ return a new ClientState object if the keyspace argument is non - null . Otherwise do not clone <nl> - * and return this ClientState object . <nl> - * / <nl> - public ClientState cloneWithKeyspaceIfSet ( String keyspace ) <nl> - { <nl> - if ( keyspace = = null ) <nl> - return this ; <nl> - ClientState clientState = new ClientState ( this ) ; <nl> - clientState . setKeyspace ( keyspace ) ; <nl> - return clientState ; <nl> - } <nl> - <nl> - / * * <nl> * This clock guarantees that updates for the same ClientState will be ordered <nl> * in the sequence seen , even if multiple updates happen in the same millisecond . <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / transport / Client . java b / src / java / org / apache / cassandra / transport / Client . java <nl> index 9a76e03 . . e428b06 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Client . java <nl> + + + b / src / java / org / apache / cassandra / transport / Client . java <nl> @ @ - 136 , 12 + 136 , 12 @ @ public class Client extends SimpleClient <nl> return null ; <nl> } <nl> } <nl> - return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version , null ) ) ; <nl> + return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version ) ) ; <nl> } <nl> else if ( msgType . equals ( " PREPARE " ) ) <nl> { <nl> String query = line . substring ( 8 ) ; <nl> - return new PrepareMessage ( query , null ) ; <nl> + return new PrepareMessage ( query ) ; <nl> } <nl> else if ( msgType . equals ( " EXECUTE " ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> index 13cd9bd . . 1bb081b 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java <nl> @ @ - 189 , 7 + 189 , 7 @ @ public class SimpleClient implements Closeable <nl> <nl> public ResultMessage . Prepared prepare ( String query ) <nl> { <nl> - Message . Response msg = execute ( new PrepareMessage ( query , null ) ) ; <nl> + Message . Response msg = execute ( new PrepareMessage ( query ) ) ; <nl> assert msg instanceof ResultMessage . Prepared ; <nl> return ( ResultMessage . Prepared ) msg ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> index d9123d4 . . bb6411f 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java <nl> @ @ - 180 , 8 + 180 , 7 @ @ public class BatchMessage extends Message . Request <nl> ParsedStatement . Prepared p ; <nl> if ( query instanceof String ) <nl> { <nl> - p = QueryProcessor . parseStatement ( ( String ) query , <nl> - state . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; <nl> + p = QueryProcessor . parseStatement ( ( String ) query , state ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> index bb0fc3a . . b0c9dbe 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> + + + b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java <nl> @ @ - 36 , 59 + 36 , 26 @ @ public class PrepareMessage extends Message . Request <nl> public PrepareMessage decode ( ByteBuf body , ProtocolVersion version ) <nl> { <nl> String query = CBUtil . readLongString ( body ) ; <nl> - String keyspace = null ; <nl> - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) { <nl> - / / If flags grows , we may want to consider creating a PrepareOptions class with an internal codec <nl> - / / class that handles flags and options of the prepare message . Since there ' s only one right now , <nl> - / / we just take care of business here . <nl> - <nl> - int flags = ( int ) body . readUnsignedInt ( ) ; <nl> - if ( ( flags & 0x1 ) = = 0x1 ) <nl> - keyspace = CBUtil . readString ( body ) ; <nl> - } <nl> - return new PrepareMessage ( query , keyspace ) ; <nl> + return new PrepareMessage ( query ) ; <nl> } <nl> <nl> public void encode ( PrepareMessage msg , ByteBuf dest , ProtocolVersion version ) <nl> { <nl> CBUtil . writeLongString ( msg . query , dest ) ; <nl> - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) <nl> - { <nl> - / / If we have no keyspace , write out a 0 - valued flag field . <nl> - if ( msg . keyspace = = null ) <nl> - dest . writeInt ( 0x0 ) ; <nl> - else { <nl> - dest . writeInt ( 0x1 ) ; <nl> - CBUtil . writeString ( msg . keyspace , dest ) ; <nl> - } <nl> - } <nl> } <nl> <nl> public int encodedSize ( PrepareMessage msg , ProtocolVersion version ) <nl> { <nl> - int size = CBUtil . sizeOfLongString ( msg . query ) ; <nl> - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) <nl> - { <nl> - / / We always emit a flags int <nl> - size + = 4 ; <nl> - <nl> - / / If we have a keyspace , we ' d write it out . Otherwise , we ' d write nothing . <nl> - size + = msg . keyspace = = null <nl> - ? 0 <nl> - : CBUtil . sizeOfString ( msg . keyspace ) ; <nl> - } <nl> - return size ; <nl> + return CBUtil . sizeOfLongString ( msg . query ) ; <nl> } <nl> } ; <nl> <nl> private final String query ; <nl> - private final String keyspace ; <nl> <nl> - public PrepareMessage ( String query , String keyspace ) <nl> + public PrepareMessage ( String query ) <nl> { <nl> super ( Message . Type . PREPARE ) ; <nl> this . query = query ; <nl> - this . keyspace = keyspace ; <nl> } <nl> <nl> public Message . Response execute ( QueryState state , long queryStartNanoTime ) <nl> @ @ - 108 , 9 + 75 , 7 @ @ public class PrepareMessage extends Message . Request <nl> Tracing . instance . begin ( " Preparing CQL3 query " , state . getClientAddress ( ) , ImmutableMap . of ( " query " , query ) ) ; <nl> } <nl> <nl> - Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , <nl> - state . getClientState ( ) . cloneWithKeyspaceIfSet ( keyspace ) , <nl> - getCustomPayload ( ) ) ; <nl> + Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , state , getCustomPayload ( ) ) ; <nl> <nl> if ( tracingId ! = null ) <nl> response . setTracingId ( tracingId ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> index 1ff21ed . . a3e2021 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> @ @ - 711 , 7 + 711 , 7 @ @ public abstract class CQLTester <nl> state . setKeyspace ( SchemaConstants . SYSTEM _ KEYSPACE _ NAME ) ; <nl> QueryState queryState = new QueryState ( state ) ; <nl> <nl> - ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState . getClientState ( ) ) ; <nl> + ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState ) ; <nl> prepared . statement . validate ( state ) ; <nl> <nl> QueryOptions options = QueryOptions . forInternalCalls ( Collections . < ByteBuffer > emptyList ( ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> index c27593b . . cfbfd39 100644 <nl> - - - a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> + + + b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java <nl> @ @ - 48 , 7 + 48 , 6 @ @ import org . apache . cassandra . transport . messages . QueryMessage ; <nl> import org . apache . cassandra . transport . messages . ResultMessage ; <nl> import org . apache . cassandra . utils . MD5Digest ; <nl> <nl> - import static org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; <nl> import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; <nl> <nl> public class MessagePayloadTest extends CQLTester <nl> @ @ - 113 , 86 + 112 , 6 @ @ public class MessagePayloadTest extends CQLTester <nl> } <nl> <nl> @ Test <nl> - public void testMessagePayloadBeta ( ) throws Throwable <nl> - { <nl> - QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; <nl> - cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; <nl> - try <nl> - { <nl> - requireNetwork ( ) ; <nl> - <nl> - Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; <nl> - <nl> - SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , <nl> - nativePort , <nl> - ProtocolVersion . V5 , <nl> - true , <nl> - new ClientEncryptionOptions ( ) ) ; <nl> - try <nl> - { <nl> - client . connect ( false ) ; <nl> - <nl> - Map < String , ByteBuffer > reqMap ; <nl> - Map < String , ByteBuffer > respMap ; <nl> - <nl> - QueryOptions queryOptions = QueryOptions . create ( <nl> - QueryOptions . DEFAULT . getConsistency ( ) , <nl> - QueryOptions . DEFAULT . getValues ( ) , <nl> - QueryOptions . DEFAULT . skipMetadata ( ) , <nl> - QueryOptions . DEFAULT . getPageSize ( ) , <nl> - QueryOptions . DEFAULT . getPagingState ( ) , <nl> - QueryOptions . DEFAULT . getSerialConsistency ( ) , <nl> - ProtocolVersion . V5 , <nl> - KEYSPACE ) ; <nl> - QueryMessage queryMessage = new QueryMessage ( " CREATE TABLE atable ( pk int PRIMARY KEY , v text ) " , <nl> - queryOptions ) ; <nl> - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM atable " , KEYSPACE ) ; <nl> - <nl> - reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> - queryMessage . setCustomPayload ( reqMap ) ; <nl> - Message . Response queryResponse = client . execute ( queryMessage ) ; <nl> - payloadEquals ( reqMap , requestPayload ) ; <nl> - payloadEquals ( respMap , queryResponse . getCustomPayload ( ) ) ; <nl> - <nl> - reqMap = Collections . singletonMap ( " foo " , bytes ( 43 ) ) ; <nl> - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 43 ) ) ; <nl> - prepareMessage . setCustomPayload ( reqMap ) ; <nl> - ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; <nl> - payloadEquals ( reqMap , requestPayload ) ; <nl> - payloadEquals ( respMap , prepareResponse . getCustomPayload ( ) ) ; <nl> - <nl> - ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; <nl> - reqMap = Collections . singletonMap ( " foo " , bytes ( 44 ) ) ; <nl> - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 44 ) ) ; <nl> - executeMessage . setCustomPayload ( reqMap ) ; <nl> - Message . Response executeResponse = client . execute ( executeMessage ) ; <nl> - payloadEquals ( reqMap , requestPayload ) ; <nl> - payloadEquals ( respMap , executeResponse . getCustomPayload ( ) ) ; <nl> - <nl> - BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , <nl> - Collections . < Object > singletonList ( " INSERT INTO atable ( pk , v ) VALUES ( 1 , ' foo ' ) " ) , <nl> - Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , <nl> - queryOptions ) ; <nl> - reqMap = Collections . singletonMap ( " foo " , bytes ( 45 ) ) ; <nl> - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 45 ) ) ; <nl> - batchMessage . setCustomPayload ( reqMap ) ; <nl> - Message . Response batchResponse = client . execute ( batchMessage ) ; <nl> - payloadEquals ( reqMap , requestPayload ) ; <nl> - payloadEquals ( respMap , batchResponse . getCustomPayload ( ) ) ; <nl> - } <nl> - finally <nl> - { <nl> - client . close ( ) ; <nl> - } <nl> - } <nl> - finally <nl> - { <nl> - cqlQueryHandlerField . set ( null , queryHandler ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> public void testMessagePayload ( ) throws Throwable <nl> { <nl> QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; <nl> @ @ - 215 , 7 + 134 , 7 @ @ public class MessagePayloadTest extends CQLTester <nl> " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , <nl> QueryOptions . DEFAULT <nl> ) ; <nl> - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; <nl> + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; <nl> <nl> reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> @ @ - 283 , 7 + 202 , 7 @ @ public class MessagePayloadTest extends CQLTester <nl> " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , <nl> QueryOptions . DEFAULT <nl> ) ; <nl> - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; <nl> + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; <nl> <nl> reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; <nl> responsePayload = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; <nl> @ @ - 374 , 13 + 293 , 13 @ @ public class MessagePayloadTest extends CQLTester <nl> } <nl> <nl> public ResultMessage . Prepared prepare ( String query , <nl> - ClientState clientState , <nl> + QueryState state , <nl> Map < String , ByteBuffer > customPayload ) <nl> throws RequestValidationException <nl> { <nl> if ( customPayload ! = null ) <nl> requestPayload = customPayload ; <nl> - ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , clientState , customPayload ) ; <nl> + ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , state , customPayload ) ; <nl> if ( customPayload ! = null ) <nl> { <nl> result . setCustomPayload ( responsePayload ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / transport / SerDeserTest . java b / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> index cb46e24 . . 1eaa5ac 100644 <nl> - - - a / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> + + + b / test / unit / org / apache / cassandra / transport / SerDeserTest . java <nl> @ @ - 321 , 8 + 321 , 7 @ @ public class SerDeserTest <nl> 5000 , <nl> Util . makeSomePagingState ( version ) , <nl> ConsistencyLevel . SERIAL , <nl> - version , <nl> - null <nl> + version <nl> ) ; <nl> <nl> ByteBuf buf = Unpooled . buffer ( QueryOptions . codec . encodedSize ( options , version ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b29912d . . 618446d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 5 + 1 , 4 @ @ 
 4 . 0 
 - * Allow sending keyspace independent of query string via native protocol ( CASSANDRA - 10145 ) 
 * Thrift removal ( CASSANDRA - 11115 ) 
 * Remove pre - 3 . 0 compatibility code for 4 . 0 ( CASSANDRA - 12716 ) 
 * Add column definition kind to dropped columns in schema ( CASSANDRA - 12705 ) 
 diff - - git a / doc / native _ protocol _ v5 . spec b / doc / native _ protocol _ v5 . spec 
 index 3084016 . . 35dd2d7 100644 
 - - - a / doc / native _ protocol _ v5 . spec 
 + + + b / doc / native _ protocol _ v5 . spec 
 @ @ - 314 , 7 + 314 , 7 @ @ Table of Contents 
 < query > < query _ parameters > 
 where < query > is a [ long string ] representing the query and 
 < query _ parameters > must be 
 - < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] 
 + < consistency > < flags > [ < n > [ name _ 1 ] < value _ 1 > . . . [ name _ n ] < value _ n > ] [ < result _ page _ size > ] [ < paging _ state > ] [ < serial _ consistency > ] [ < timestamp > ] 
 where : 
 - < consistency > is the [ consistency ] level for the operation . 
 - < flags > is a [ int ] whose bits define the options for this query and 
 @ @ - 357 , 9 + 357 , 6 @ @ Table of Contents 
 since the names for the expected values was returned during preparation , 
 a client can always provide values in the right order without any names 
 and using this flag , while supported , is almost surely inefficient . 
 - 0x80 : With keyspace . If set , < keyspace > should be present . < keyspace > is a 
 - [ string ] indicating the keyspace that the query should be executed in . 
 - It supercedes the keyspace that the connection is bound to , if any . 
 
 Note that the consistency is ignored by some queries ( USE , CREATE , ALTER , 
 TRUNCATE , . . . ) . 
 @ @ - 370 , 17 + 367 , 8 @ @ Table of Contents 
 
 4 . 1 . 5 . PREPARE 
 
 - Prepare a query for later execution ( through EXECUTE ) . The body of the message must be : 
 - < query > < flags > [ < keyspace > ] 
 - where : 
 - - < query > is a [ long string ] representing the CQL query . 
 - - < flags > is a [ int ] whose bits define the options for this statement and in particular 
 - influence what the remainder of the message contains . 
 - A flag is set if the bit corresponding to its ` mask ` is set . Supported 
 - flags are , given their mask : 
 - 0x01 : With keyspace . If set , < keyspace > should be present . < keyspace > is a 
 - [ string ] indicating the keyspace that the query should be executed in . 
 - It supercedes the keyspace that the connection is bound to , if any . 
 + Prepare a query for later execution ( through EXECUTE ) . The body consists of 
 + the CQL query to prepare as a [ long string ] . 
 
 The server will respond with a RESULT message with a ` prepared ` kind ( 0x0004 , 
 see Section 4 . 2 . 5 ) . 
 @ @ - 402 , 7 + 390 , 7 @ @ Table of Contents 
 Allows executing a list of queries ( prepared or not ) as a batch ( note that 
 only DML statements are accepted in a batch ) . The body of the message must 
 be : 
 - < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] [ < keyspace > ] 
 + < type > < n > < query _ 1 > . . . < query _ n > < consistency > < flags > [ < serial _ consistency > ] [ < timestamp > ] 
 where : 
 - < type > is a [ byte ] indicating the type of batch to use : 
 - If < type > = = 0 , the batch will be " logged " . This is equivalent to a 
 @ @ - 434 , 9 + 422 , 6 @ @ Table of Contents 
 to implement . This will be fixed in a future version of the native 
 protocol . See https : / / issues . apache . org / jira / browse / CASSANDRA - 10246 for 
 more details ] . 
 - 0x80 : With keyspace . If set , < keyspace > should be present . < keyspace > is a 
 - [ string ] indicating the keyspace that the query should be executed in . 
 - It supercedes the keyspace that the connection is bound to , if any . 
 - < n > is a [ short ] indicating the number of following queries . 
 - < query _ 1 > . . . < query _ n > are the queries to execute . A < query _ i > must be of the 
 form : 
 @ @ - 1197 , 5 + 1182 , 3 @ @ Table of Contents 
 a failure reason code which indicates why the request failed on that node . 
 * Enlarged flag ' s bitmaps for QUERY , EXECUTE and BATCH messages from [ byte ] to [ int ] 
 ( Sections 4 . 1 . 4 , 4 . 1 . 6 and 4 . 1 . 7 ) . 
 - * Added keyspace field in QUERY , PREPARE , and BATCH messages ( Sections 4 . 1 . 4 , 4 . 1 . 5 , and 4 . 1 . 7 ) . 
 - * Added [ int ] flags field in PREPARE message ( Section 4 . 1 . 5 ) . 
 \ No newline at end of file 
 diff - - git a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 index 3d3cda0 . . db7fa39 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / BatchQueryOptions . java 
 @ @ - 62 , 11 + 62 , 6 @ @ public abstract class BatchQueryOptions 
 return wrapped . getConsistency ( ) ; 
 } 
 
 - public String getKeyspace ( ) 
 - { 
 - return wrapped . getKeyspace ( ) ; 
 - } 
 - 
 public ConsistencyLevel getSerialConsistency ( ) 
 { 
 return wrapped . getSerialConsistency ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 index 32cddba . . aa8ca48 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 + + + b / src / java / org / apache / cassandra / cql3 / CustomPayloadMirroringQueryHandler . java 
 @ @ - 22 , 7 + 22 , 6 @ @ import java . util . Map ; 
 
 import org . apache . cassandra . cql3 . statements . BatchStatement ; 
 import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 - import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 @ @ - 47 , 9 + 46 , 9 @ @ public class CustomPayloadMirroringQueryHandler implements QueryHandler 
 return result ; 
 } 
 
 - public ResultMessage . Prepared prepare ( String query , ClientState clientState , Map < String , ByteBuffer > customPayload ) 
 + public ResultMessage . Prepared prepare ( String query , QueryState state , Map < String , ByteBuffer > customPayload ) 
 { 
 - ResultMessage . Prepared prepared = queryProcessor . prepare ( query , clientState , customPayload ) ; 
 + ResultMessage . Prepared prepared = queryProcessor . prepare ( query , state , customPayload ) ; 
 prepared . setCustomPayload ( customPayload ) ; 
 return prepared ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryHandler . java b / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 index d3b41f0 . . 0339d26 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryHandler . java 
 @ @ - 24 , 7 + 24 , 6 @ @ import org . apache . cassandra . cql3 . statements . BatchStatement ; 
 import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 import org . apache . cassandra . exceptions . RequestExecutionException ; 
 import org . apache . cassandra . exceptions . RequestValidationException ; 
 - import org . apache . cassandra . service . ClientState ; 
 import org . apache . cassandra . service . QueryState ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 @ @ - 38 , 7 + 37 , 7 @ @ public interface QueryHandler 
 long queryStartNanoTime ) throws RequestExecutionException , RequestValidationException ; 
 
 ResultMessage . Prepared prepare ( String query , 
 - ClientState clientState , 
 + QueryState state , 
 Map < String , ByteBuffer > customPayload ) throws RequestValidationException ; 
 
 ParsedStatement . Prepared getPrepared ( MD5Digest id ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryOptions . java b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 index a66a98a . . 57d5eac 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryOptions . java 
 @ @ - 67 , 9 + 67 , 9 @ @ public abstract class QueryOptions 
 return new DefaultQueryOptions ( null , null , true , null , protocolVersion ) ; 
 } 
 
 - public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version , String keyspace ) 
 + public static QueryOptions create ( ConsistencyLevel consistency , List < ByteBuffer > values , boolean skipMetadata , int pageSize , PagingState pagingState , ConsistencyLevel serialConsistency , ProtocolVersion version ) 
 { 
 - return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L , keyspace ) , version ) ; 
 + return new DefaultQueryOptions ( consistency , values , skipMetadata , new SpecificOptions ( pageSize , pagingState , serialConsistency , - 1L ) , version ) ; 
 } 
 
 public static QueryOptions addColumnSpecifications ( QueryOptions options , List < ColumnSpecification > columnSpecs ) 
 @ @ - 86 , 11 + 86 , 11 @ @ public abstract class QueryOptions 
 * 
 * This is functionally equivalent to : 
 * { @ code Json . parseJson ( UTF8Type . instance . getSerializer ( ) . deserialize ( getValues ( ) . get ( bindIndex ) ) , expectedReceivers ) . get ( columnName ) } 
 - * but this caches the result of parsing the JSON , so that while this might be called for multiple columns on the same { @ code bindIndex } 
 + * but this cache the result of parsing the JSON so that while this might be called for multiple columns on the same { @ code bindIndex } 
 * value , the underlying JSON value is only parsed / processed once . 
 * 
 - * Note : this is a bit more involved in CQL specifics than this class generally is , but as we need to cache this per - query and in an object 
 - * that is available when we bind values , this is the easiest place to have this . 
 + * Note : this is a bit more involved in CQL specifics than this class generally is but we as we need to cache this per - query and in an object 
 + * that is available when we bind values , this is the easier place to have this . 
 * 
 * @ param bindIndex the index of the bind value that should be interpreted as a JSON value . 
 * @ param columnName the name of the column we want the value of . 
 @ @ - 136 , 7 + 136 , 7 @ @ public abstract class QueryOptions 
 * 
 * < p > The column specifications will be present only for prepared statements . < / p > 
 * 
 - * < p > Invoke the { @ link # hasColumnSpecifications } method before invoking this method in order to ensure that this 
 + * < p > Invoke the { @ link hasColumnSpecifications } method before invoking this method in order to ensure that this 
 * < code > QueryOptions < / code > contains the column specifications . < / p > 
 * 
 * @ return the option names 
 @ @ - 172 , 9 + 172 , 6 @ @ public abstract class QueryOptions 
 return tstamp ! = Long . MIN _ VALUE ? tstamp : state . getTimestamp ( ) ; 
 } 
 
 - / * * The keyspace that this query is bound to , or null if not relevant . * / 
 - public String getKeyspace ( ) { return getSpecificOptions ( ) . keyspace ; } 
 - 
 / * * 
 * The protocol version for the query . 
 * / 
 @ @ - 317 , 7 + 314 , 7 @ @ public abstract class QueryOptions 
 { 
 super . prepare ( specs ) ; 
 
 - orderedValues = new ArrayList < > ( specs . size ( ) ) ; 
 + orderedValues = new ArrayList < ByteBuffer > ( specs . size ( ) ) ; 
 for ( int i = 0 ; i < specs . size ( ) ; i + + ) 
 { 
 String name = specs . get ( i ) . name . toString ( ) ; 
 @ @ - 344 , 21 + 341 , 19 @ @ public abstract class QueryOptions 
 / / Options that are likely to not be present in most queries 
 static class SpecificOptions 
 { 
 - private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE , null ) ; 
 + private static final SpecificOptions DEFAULT = new SpecificOptions ( - 1 , null , null , Long . MIN _ VALUE ) ; 
 
 private final int pageSize ; 
 private final PagingState state ; 
 private final ConsistencyLevel serialConsistency ; 
 private final long timestamp ; 
 - private final String keyspace ; 
 
 - private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp , String keyspace ) 
 + private SpecificOptions ( int pageSize , PagingState state , ConsistencyLevel serialConsistency , long timestamp ) 
 { 
 this . pageSize = pageSize ; 
 this . state = state ; 
 this . serialConsistency = serialConsistency = = null ? ConsistencyLevel . SERIAL : serialConsistency ; 
 this . timestamp = timestamp ; 
 - this . keyspace = keyspace ; 
 } 
 } 
 
 @ @ - 373 , 8 + 368 , 7 @ @ public abstract class QueryOptions 
 PAGING _ STATE , 
 SERIAL _ CONSISTENCY , 
 TIMESTAMP , 
 - NAMES _ FOR _ VALUES , 
 - KEYSPACE ; 
 + NAMES _ FOR _ VALUES ; 
 
 private static final Flag [ ] ALL _ VALUES = values ( ) ; 
 
 @ @ - 439 , 8 + 433 , 8 @ @ public abstract class QueryOptions 
 throw new ProtocolException ( String . format ( " Out of bound timestamp , must be in [ % d , % d ] ( got % d ) " , Long . MIN _ VALUE + 1 , Long . MAX _ VALUE , ts ) ) ; 
 timestamp = ts ; 
 } 
 - String keyspace = flags . contains ( Flag . KEYSPACE ) ? CBUtil . readString ( body ) : null ; 
 - options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp , keyspace ) ; 
 + 
 + options = new SpecificOptions ( pageSize , pagingState , serialConsistency , timestamp ) ; 
 } 
 DefaultQueryOptions opts = new DefaultQueryOptions ( consistency , values , skipMetadata , options , version ) ; 
 return names = = null ? opts : new OptionsWithNames ( opts , names ) ; 
 @ @ - 466 , 8 + 460 , 6 @ @ public abstract class QueryOptions 
 CBUtil . writeConsistencyLevel ( options . getSerialConsistency ( ) , dest ) ; 
 if ( flags . contains ( Flag . TIMESTAMP ) ) 
 dest . writeLong ( options . getSpecificOptions ( ) . timestamp ) ; 
 - if ( flags . contains ( Flag . KEYSPACE ) ) 
 - CBUtil . writeString ( options . getSpecificOptions ( ) . keyspace , dest ) ; 
 
 / / Note that we don ' t really have to bother with NAMES _ FOR _ VALUES server side , 
 / / and in fact we never really encode QueryOptions , only decode them , so we 
 @ @ - 493 , 8 + 485 , 7 @ @ public abstract class QueryOptions 
 size + = CBUtil . sizeOfConsistencyLevel ( options . getSerialConsistency ( ) ) ; 
 if ( flags . contains ( Flag . TIMESTAMP ) ) 
 size + = 8 ; 
 - if ( flags . contains ( Flag . KEYSPACE ) ) 
 - size + = CBUtil . sizeOfString ( options . getSpecificOptions ( ) . keyspace ) ; 
 + 
 return size ; 
 } 
 
 @ @ - 513 , 8 + 504 , 6 @ @ public abstract class QueryOptions 
 flags . add ( Flag . SERIAL _ CONSISTENCY ) ; 
 if ( options . getSpecificOptions ( ) . timestamp ! = Long . MIN _ VALUE ) 
 flags . add ( Flag . TIMESTAMP ) ; 
 - if ( options . getSpecificOptions ( ) . keyspace ! = null ) 
 - flags . add ( Flag . KEYSPACE ) ; 
 return flags ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 4f72ab1 . . 354ee72 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 212 , 7 + 212 , 7 @ @ public class QueryProcessor implements QueryHandler 
 public ResultMessage process ( String queryString , QueryState queryState , QueryOptions options , long queryStartNanoTime ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; 
 + ParsedStatement . Prepared p = getStatement ( queryString , queryState . getClientState ( ) ) ; 
 options . prepare ( p . boundNames ) ; 
 CQLStatement prepared = p . statement ; 
 if ( prepared . getBoundTerms ( ) ! = options . getValues ( ) . size ( ) ) 
 @ @ - 224 , 9 + 224 , 9 @ @ public class QueryProcessor implements QueryHandler 
 return processStatement ( prepared , queryState , options , queryStartNanoTime ) ; 
 } 
 
 - public static ParsedStatement . Prepared parseStatement ( String queryStr , ClientState clientState ) throws RequestValidationException 
 + public static ParsedStatement . Prepared parseStatement ( String queryStr , QueryState queryState ) throws RequestValidationException 
 { 
 - return getStatement ( queryStr , clientState ) ; 
 + return getStatement ( queryStr , queryState . getClientState ( ) ) ; 
 } 
 
 public static UntypedResultSet process ( String query , ConsistencyLevel cl ) throws RequestExecutionException 
 @ @ - 270 , 7 + 270 , 7 @ @ public class QueryProcessor implements QueryHandler 
 return prepared ; 
 
 / / Note : if 2 threads prepare the same query , we ' ll live so don ' t bother synchronizing 
 - prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; 
 + prepared = parseStatement ( query , internalQueryState ( ) ) ; 
 prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; 
 internalStatements . putIfAbsent ( query , prepared ) ; 
 return prepared ; 
 @ @ - 327 , 7 + 327 , 7 @ @ public class QueryProcessor implements QueryHandler 
 * / 
 public static UntypedResultSet executeOnceInternal ( String query , Object . . . values ) 
 { 
 - ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) . getClientState ( ) ) ; 
 + ParsedStatement . Prepared prepared = parseStatement ( query , internalQueryState ( ) ) ; 
 prepared . statement . validate ( internalQueryState ( ) . getClientState ( ) ) ; 
 ResultMessage result = prepared . statement . executeInternal ( internalQueryState ( ) , makeInternalOptions ( prepared , values ) ) ; 
 if ( result instanceof ResultMessage . Rows ) 
 @ @ - 367 , 10 + 367 , 16 @ @ public class QueryProcessor implements QueryHandler 
 } 
 
 public ResultMessage . Prepared prepare ( String query , 
 - ClientState clientState , 
 + QueryState state , 
 Map < String , ByteBuffer > customPayload ) throws RequestValidationException 
 { 
 - return prepare ( query , clientState ) ; 
 + return prepare ( query , state ) ; 
 + } 
 + 
 + public ResultMessage . Prepared prepare ( String queryString , QueryState queryState ) 
 + { 
 + ClientState cState = queryState . getClientState ( ) ; 
 + return prepare ( queryString , cState ) ; 
 } 
 
 public static ResultMessage . Prepared prepare ( String queryString , ClientState clientState ) 
 @ @ - 472 , 7 + 478 , 7 @ @ public class QueryProcessor implements QueryHandler 
 public ResultMessage processBatch ( BatchStatement batch , QueryState queryState , BatchQueryOptions options , long queryStartNanoTime ) 
 throws RequestExecutionException , RequestValidationException 
 { 
 - ClientState clientState = queryState . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ; 
 + ClientState clientState = queryState . getClientState ( ) ; 
 batch . checkAccess ( clientState ) ; 
 batch . validate ( ) ; 
 batch . validate ( clientState ) ; 
 @ @ - 487 , 7 + 493 , 7 @ @ public class QueryProcessor implements QueryHandler 
 
 / / Set keyspace for statement that require login 
 if ( statement instanceof CFStatement ) 
 - ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; 
 + ( ( CFStatement ) statement ) . prepareKeyspace ( clientState ) ; 
 
 Tracing . trace ( " Preparing statement " ) ; 
 return statement . prepare ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 index 136860e . . 9b2987c 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / CFStatement . java 
 @ @ - 37 , 16 + 37 , 14 @ @ public abstract class CFStatement extends ParsedStatement 
 { 
 if ( ! cfName . hasKeyspace ( ) ) 
 { 
 - / / XXX : We explicitly only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw 
 - / / if not logged in any keyspace but a keyspace is explicitly set on the statement . So don ' t move 
 + / / XXX : We explicitely only want to call state . getKeyspace ( ) in this case , as we don ' t want to throw 
 + / / if not logged in any keyspace but a keyspace is explicitely set on the statement . So don ' t move 
 / / the call outside the ' if ' or replace the method by ' prepareKeyspace ( state . getKeyspace ( ) ) ' 
 cfName . setKeyspace ( state . getKeyspace ( ) , true ) ; 
 } 
 } 
 
 - / / Only for internal calls , use the version with ClientState for user queries . In particular , the 
 - / / version with ClientState throws an exception if the statement does not have keyspace set * and * 
 - / / ClientState has no keyspace . 
 + / / Only for internal calls , use the version with ClientState for user queries 
 public void prepareKeyspace ( String keyspace ) 
 { 
 if ( ! cfName . hasKeyspace ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 index ca38d22 . . c7cbb58 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ParsedStatement . java 
 @ @ - 51 , 7 + 51 , 7 @ @ public abstract class ParsedStatement 
 / * * 
 * Contains the CQL statement source if the statement has been " regularly " perpared via 
 * { @ link org . apache . cassandra . cql3 . QueryProcessor # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , boolean ) } / 
 - * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . ClientState , java . util . Map ) } . 
 + * { @ link QueryHandler # prepare ( java . lang . String , org . apache . cassandra . service . QueryState , java . util . Map ) } . 
 * Other usages of this class may or may not contain the CQL statement source . 
 * / 
 public String rawCQLStatement ; 
 diff - - git a / src / java / org / apache / cassandra / service / ClientState . java b / src / java / org / apache / cassandra / service / ClientState . java 
 index 2edbd6d . . 52e71ae 100644 
 - - - a / src / java / org / apache / cassandra / service / ClientState . java 
 + + + b / src / java / org / apache / cassandra / service / ClientState . java 
 @ @ - 139 , 14 + 139 , 6 @ @ public class ClientState 
 this . user = AuthenticatedUser . ANONYMOUS _ USER ; 
 } 
 
 - protected ClientState ( ClientState source ) 
 - { 
 - this . isInternal = source . isInternal ; 
 - this . remoteAddress = source . remoteAddress ; 
 - this . user = source . user ; 
 - this . keyspace = source . keyspace ; 
 - } 
 - 
 / * * 
 * @ return a ClientState object for internal C * calls ( not limited by any kind of auth ) . 
 * / 
 @ @ - 164 , 22 + 156 , 6 @ @ public class ClientState 
 } 
 
 / * * 
 - * Clone this ClientState object , but use the provided keyspace instead of the 
 - * keyspace in this ClientState object . 
 - * 
 - * @ return a new ClientState object if the keyspace argument is non - null . Otherwise do not clone 
 - * and return this ClientState object . 
 - * / 
 - public ClientState cloneWithKeyspaceIfSet ( String keyspace ) 
 - { 
 - if ( keyspace = = null ) 
 - return this ; 
 - ClientState clientState = new ClientState ( this ) ; 
 - clientState . setKeyspace ( keyspace ) ; 
 - return clientState ; 
 - } 
 - 
 - / * * 
 * This clock guarantees that updates for the same ClientState will be ordered 
 * in the sequence seen , even if multiple updates happen in the same millisecond . 
 * / 
 diff - - git a / src / java / org / apache / cassandra / transport / Client . java b / src / java / org / apache / cassandra / transport / Client . java 
 index 9a76e03 . . e428b06 100644 
 - - - a / src / java / org / apache / cassandra / transport / Client . java 
 + + + b / src / java / org / apache / cassandra / transport / Client . java 
 @ @ - 136 , 12 + 136 , 12 @ @ public class Client extends SimpleClient 
 return null ; 
 } 
 } 
 - return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version , null ) ) ; 
 + return new QueryMessage ( query , QueryOptions . create ( ConsistencyLevel . ONE , Collections . < ByteBuffer > emptyList ( ) , false , pageSize , null , null , version ) ) ; 
 } 
 else if ( msgType . equals ( " PREPARE " ) ) 
 { 
 String query = line . substring ( 8 ) ; 
 - return new PrepareMessage ( query , null ) ; 
 + return new PrepareMessage ( query ) ; 
 } 
 else if ( msgType . equals ( " EXECUTE " ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / transport / SimpleClient . java b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 index 13cd9bd . . 1bb081b 100644 
 - - - a / src / java / org / apache / cassandra / transport / SimpleClient . java 
 + + + b / src / java / org / apache / cassandra / transport / SimpleClient . java 
 @ @ - 189 , 7 + 189 , 7 @ @ public class SimpleClient implements Closeable 
 
 public ResultMessage . Prepared prepare ( String query ) 
 { 
 - Message . Response msg = execute ( new PrepareMessage ( query , null ) ) ; 
 + Message . Response msg = execute ( new PrepareMessage ( query ) ) ; 
 assert msg instanceof ResultMessage . Prepared ; 
 return ( ResultMessage . Prepared ) msg ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 index d9123d4 . . bb6411f 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / BatchMessage . java 
 @ @ - 180 , 8 + 180 , 7 @ @ public class BatchMessage extends Message . Request 
 ParsedStatement . Prepared p ; 
 if ( query instanceof String ) 
 { 
 - p = QueryProcessor . parseStatement ( ( String ) query , 
 - state . getClientState ( ) . cloneWithKeyspaceIfSet ( options . getKeyspace ( ) ) ) ; 
 + p = QueryProcessor . parseStatement ( ( String ) query , state ) ; 
 } 
 else 
 { 
 diff - - git a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 index bb0fc3a . . b0c9dbe 100644 
 - - - a / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 + + + b / src / java / org / apache / cassandra / transport / messages / PrepareMessage . java 
 @ @ - 36 , 59 + 36 , 26 @ @ public class PrepareMessage extends Message . Request 
 public PrepareMessage decode ( ByteBuf body , ProtocolVersion version ) 
 { 
 String query = CBUtil . readLongString ( body ) ; 
 - String keyspace = null ; 
 - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) { 
 - / / If flags grows , we may want to consider creating a PrepareOptions class with an internal codec 
 - / / class that handles flags and options of the prepare message . Since there ' s only one right now , 
 - / / we just take care of business here . 
 - 
 - int flags = ( int ) body . readUnsignedInt ( ) ; 
 - if ( ( flags & 0x1 ) = = 0x1 ) 
 - keyspace = CBUtil . readString ( body ) ; 
 - } 
 - return new PrepareMessage ( query , keyspace ) ; 
 + return new PrepareMessage ( query ) ; 
 } 
 
 public void encode ( PrepareMessage msg , ByteBuf dest , ProtocolVersion version ) 
 { 
 CBUtil . writeLongString ( msg . query , dest ) ; 
 - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) 
 - { 
 - / / If we have no keyspace , write out a 0 - valued flag field . 
 - if ( msg . keyspace = = null ) 
 - dest . writeInt ( 0x0 ) ; 
 - else { 
 - dest . writeInt ( 0x1 ) ; 
 - CBUtil . writeString ( msg . keyspace , dest ) ; 
 - } 
 - } 
 } 
 
 public int encodedSize ( PrepareMessage msg , ProtocolVersion version ) 
 { 
 - int size = CBUtil . sizeOfLongString ( msg . query ) ; 
 - if ( version . isGreaterOrEqualTo ( ProtocolVersion . V5 ) ) 
 - { 
 - / / We always emit a flags int 
 - size + = 4 ; 
 - 
 - / / If we have a keyspace , we ' d write it out . Otherwise , we ' d write nothing . 
 - size + = msg . keyspace = = null 
 - ? 0 
 - : CBUtil . sizeOfString ( msg . keyspace ) ; 
 - } 
 - return size ; 
 + return CBUtil . sizeOfLongString ( msg . query ) ; 
 } 
 } ; 
 
 private final String query ; 
 - private final String keyspace ; 
 
 - public PrepareMessage ( String query , String keyspace ) 
 + public PrepareMessage ( String query ) 
 { 
 super ( Message . Type . PREPARE ) ; 
 this . query = query ; 
 - this . keyspace = keyspace ; 
 } 
 
 public Message . Response execute ( QueryState state , long queryStartNanoTime ) 
 @ @ - 108 , 9 + 75 , 7 @ @ public class PrepareMessage extends Message . Request 
 Tracing . instance . begin ( " Preparing CQL3 query " , state . getClientAddress ( ) , ImmutableMap . of ( " query " , query ) ) ; 
 } 
 
 - Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , 
 - state . getClientState ( ) . cloneWithKeyspaceIfSet ( keyspace ) , 
 - getCustomPayload ( ) ) ; 
 + Message . Response response = ClientState . getCQLQueryHandler ( ) . prepare ( query , state , getCustomPayload ( ) ) ; 
 
 if ( tracingId ! = null ) 
 response . setTracingId ( tracingId ) ; 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 index 1ff21ed . . a3e2021 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 @ @ - 711 , 7 + 711 , 7 @ @ public abstract class CQLTester 
 state . setKeyspace ( SchemaConstants . SYSTEM _ KEYSPACE _ NAME ) ; 
 QueryState queryState = new QueryState ( state ) ; 
 
 - ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState . getClientState ( ) ) ; 
 + ParsedStatement . Prepared prepared = QueryProcessor . parseStatement ( query , queryState ) ; 
 prepared . statement . validate ( state ) ; 
 
 QueryOptions options = QueryOptions . forInternalCalls ( Collections . < ByteBuffer > emptyList ( ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 index c27593b . . cfbfd39 100644 
 - - - a / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 + + + b / test / unit / org / apache / cassandra / transport / MessagePayloadTest . java 
 @ @ - 48 , 7 + 48 , 6 @ @ import org . apache . cassandra . transport . messages . QueryMessage ; 
 import org . apache . cassandra . transport . messages . ResultMessage ; 
 import org . apache . cassandra . utils . MD5Digest ; 
 
 - import static org . apache . cassandra . config . EncryptionOptions . ClientEncryptionOptions ; 
 import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; 
 
 public class MessagePayloadTest extends CQLTester 
 @ @ - 113 , 86 + 112 , 6 @ @ public class MessagePayloadTest extends CQLTester 
 } 
 
 @ Test 
 - public void testMessagePayloadBeta ( ) throws Throwable 
 - { 
 - QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; 
 - cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; 
 - try 
 - { 
 - requireNetwork ( ) ; 
 - 
 - Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; 
 - 
 - SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , 
 - nativePort , 
 - ProtocolVersion . V5 , 
 - true , 
 - new ClientEncryptionOptions ( ) ) ; 
 - try 
 - { 
 - client . connect ( false ) ; 
 - 
 - Map < String , ByteBuffer > reqMap ; 
 - Map < String , ByteBuffer > respMap ; 
 - 
 - QueryOptions queryOptions = QueryOptions . create ( 
 - QueryOptions . DEFAULT . getConsistency ( ) , 
 - QueryOptions . DEFAULT . getValues ( ) , 
 - QueryOptions . DEFAULT . skipMetadata ( ) , 
 - QueryOptions . DEFAULT . getPageSize ( ) , 
 - QueryOptions . DEFAULT . getPagingState ( ) , 
 - QueryOptions . DEFAULT . getSerialConsistency ( ) , 
 - ProtocolVersion . V5 , 
 - KEYSPACE ) ; 
 - QueryMessage queryMessage = new QueryMessage ( " CREATE TABLE atable ( pk int PRIMARY KEY , v text ) " , 
 - queryOptions ) ; 
 - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM atable " , KEYSPACE ) ; 
 - 
 - reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 - queryMessage . setCustomPayload ( reqMap ) ; 
 - Message . Response queryResponse = client . execute ( queryMessage ) ; 
 - payloadEquals ( reqMap , requestPayload ) ; 
 - payloadEquals ( respMap , queryResponse . getCustomPayload ( ) ) ; 
 - 
 - reqMap = Collections . singletonMap ( " foo " , bytes ( 43 ) ) ; 
 - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 43 ) ) ; 
 - prepareMessage . setCustomPayload ( reqMap ) ; 
 - ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; 
 - payloadEquals ( reqMap , requestPayload ) ; 
 - payloadEquals ( respMap , prepareResponse . getCustomPayload ( ) ) ; 
 - 
 - ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; 
 - reqMap = Collections . singletonMap ( " foo " , bytes ( 44 ) ) ; 
 - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 44 ) ) ; 
 - executeMessage . setCustomPayload ( reqMap ) ; 
 - Message . Response executeResponse = client . execute ( executeMessage ) ; 
 - payloadEquals ( reqMap , requestPayload ) ; 
 - payloadEquals ( respMap , executeResponse . getCustomPayload ( ) ) ; 
 - 
 - BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , 
 - Collections . < Object > singletonList ( " INSERT INTO atable ( pk , v ) VALUES ( 1 , ' foo ' ) " ) , 
 - Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , 
 - queryOptions ) ; 
 - reqMap = Collections . singletonMap ( " foo " , bytes ( 45 ) ) ; 
 - responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 45 ) ) ; 
 - batchMessage . setCustomPayload ( reqMap ) ; 
 - Message . Response batchResponse = client . execute ( batchMessage ) ; 
 - payloadEquals ( reqMap , requestPayload ) ; 
 - payloadEquals ( respMap , batchResponse . getCustomPayload ( ) ) ; 
 - } 
 - finally 
 - { 
 - client . close ( ) ; 
 - } 
 - } 
 - finally 
 - { 
 - cqlQueryHandlerField . set ( null , queryHandler ) ; 
 - } 
 - } 
 - 
 - @ Test 
 public void testMessagePayload ( ) throws Throwable 
 { 
 QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; 
 @ @ - 215 , 7 + 134 , 7 @ @ public class MessagePayloadTest extends CQLTester 
 " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , 
 QueryOptions . DEFAULT 
 ) ; 
 - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; 
 + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; 
 
 reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 responsePayload = respMap = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 @ @ - 283 , 7 + 202 , 7 @ @ public class MessagePayloadTest extends CQLTester 
 " CREATE TABLE " + KEYSPACE + " . atable ( pk int PRIMARY KEY , v text ) " , 
 QueryOptions . DEFAULT 
 ) ; 
 - PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " , null ) ; 
 + PrepareMessage prepareMessage = new PrepareMessage ( " SELECT * FROM " + KEYSPACE + " . atable " ) ; 
 
 reqMap = Collections . singletonMap ( " foo " , bytes ( 42 ) ) ; 
 responsePayload = Collections . singletonMap ( " bar " , bytes ( 42 ) ) ; 
 @ @ - 374 , 13 + 293 , 13 @ @ public class MessagePayloadTest extends CQLTester 
 } 
 
 public ResultMessage . Prepared prepare ( String query , 
 - ClientState clientState , 
 + QueryState state , 
 Map < String , ByteBuffer > customPayload ) 
 throws RequestValidationException 
 { 
 if ( customPayload ! = null ) 
 requestPayload = customPayload ; 
 - ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , clientState , customPayload ) ; 
 + ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , state , customPayload ) ; 
 if ( customPayload ! = null ) 
 { 
 result . setCustomPayload ( responsePayload ) ; 
 diff - - git a / test / unit / org / apache / cassandra / transport / SerDeserTest . java b / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 index cb46e24 . . 1eaa5ac 100644 
 - - - a / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 + + + b / test / unit / org / apache / cassandra / transport / SerDeserTest . java 
 @ @ - 321 , 8 + 321 , 7 @ @ public class SerDeserTest 
 5000 , 
 Util . makeSomePagingState ( version ) , 
 ConsistencyLevel . SERIAL , 
 - version , 
 - null 
 + version 
 ) ; 
 
 ByteBuf buf = Unpooled . buffer ( QueryOptions . codec . encodedSize ( options , version ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
