BLEU SCORE: 0.02383853510228548

TEST MSG: Back Columns by a BTree , not an array
GENERATED MSG: refactor CQL SELECT to be more SQLish

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / Columns . java b / src / java / org / apache / cassandra / db / Columns . java <nl> index 03d2e14 . . 231b529 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Columns . java <nl> + + + b / src / java / org / apache / cassandra / db / Columns . java <nl> @ @ - 23 , 16 + 23 , 20 @ @ import java . util . function . Predicate ; <nl> import java . nio . ByteBuffer ; <nl> import java . security . MessageDigest ; <nl> <nl> - import com . google . common . collect . AbstractIterator ; <nl> + import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . Iterators ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . db . marshal . SetType ; <nl> import org . apache . cassandra . db . marshal . UTF8Type ; <nl> - import org . apache . cassandra . db . marshal . MapType ; <nl> import org . apache . cassandra . io . util . DataInputPlus ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . SearchIterator ; <nl> + import org . apache . cassandra . utils . btree . BTree ; <nl> + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; <nl> <nl> / * * <nl> * An immutable and sorted list of ( non - PK ) columns for a given table . <nl> @ @ - 43 , 19 + 47 , 21 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; <nl> public class Columns implements Iterable < ColumnDefinition > <nl> { <nl> public static final Serializer serializer = new Serializer ( ) ; <nl> - public static final Columns NONE = new Columns ( new ColumnDefinition [ 0 ] , 0 ) ; <nl> + public static final Columns NONE = new Columns ( BTree . empty ( ) , 0 ) ; <nl> + public static final ColumnDefinition FIRST _ COMPLEX = new ColumnDefinition ( " " , " " , ColumnIdentifier . getInterned ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , UTF8Type . instance ) , <nl> + SetType . getInstance ( UTF8Type . instance , true ) , null , ColumnDefinition . Kind . REGULAR ) ; <nl> <nl> - public final ColumnDefinition [ ] columns ; <nl> - public final int complexIdx ; / / Index of the first complex column <nl> + private final Object [ ] columns ; <nl> + private final int complexIdx ; / / Index of the first complex column <nl> <nl> - private Columns ( ColumnDefinition [ ] columns , int complexIdx ) <nl> + private Columns ( Object [ ] columns , int complexIdx ) <nl> { <nl> - assert complexIdx < = columns . length ; <nl> + assert complexIdx < = BTree . size ( columns ) ; <nl> this . columns = columns ; <nl> this . complexIdx = complexIdx ; <nl> } <nl> <nl> - private Columns ( ColumnDefinition [ ] columns ) <nl> + private Columns ( Object [ ] columns ) <nl> { <nl> this ( columns , findFirstComplexIdx ( columns ) ) ; <nl> } <nl> @ @ - 69 , 30 + 75 , 28 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public static Columns of ( ColumnDefinition c ) <nl> { <nl> - ColumnDefinition [ ] columns = new ColumnDefinition [ ] { c } ; <nl> - return new Columns ( columns , c . isComplex ( ) ? 0 : 1 ) ; <nl> + return new Columns ( BTree . singleton ( c ) , c . isComplex ( ) ? 0 : 1 ) ; <nl> } <nl> <nl> / * * <nl> * Returns a new { @ code Columns } object holing the same columns than the provided set . <nl> * <nl> - * @ param param s the set from which to create the new { @ code Columns } . <nl> - * <nl> + * @ param s the set from which to create the new { @ code Columns } . <nl> * @ return the newly created { @ code Columns } containing the columns from { @ code s } . <nl> * / <nl> public static Columns from ( Set < ColumnDefinition > s ) <nl> { <nl> - ColumnDefinition [ ] columns = s . toArray ( new ColumnDefinition [ s . size ( ) ] ) ; <nl> - Arrays . sort ( columns ) ; <nl> - return new Columns ( columns , findFirstComplexIdx ( columns ) ) ; <nl> + Object [ ] tree = BTree . < ColumnDefinition > builder ( Comparator . naturalOrder ( ) ) . addAll ( s ) . build ( ) ; <nl> + return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; <nl> } <nl> <nl> - private static int findFirstComplexIdx ( ColumnDefinition [ ] columns ) <nl> + private static int findFirstComplexIdx ( Object [ ] tree ) <nl> { <nl> - for ( int i = 0 ; i < columns . length ; i + + ) <nl> - if ( columns [ i ] . isComplex ( ) ) <nl> - return i ; <nl> - return columns . length ; <nl> + / / have fast path for common no - complex case <nl> + int size = BTree . size ( tree ) ; <nl> + if ( ! BTree . isEmpty ( tree ) & & BTree . < ColumnDefinition > findByIndex ( tree , size - 1 ) . isSimple ( ) ) <nl> + return size ; <nl> + return BTree . ceilIndex ( tree , Comparator . naturalOrder ( ) , FIRST _ COMPLEX ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 102 , 7 + 106 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public boolean isEmpty ( ) <nl> { <nl> - return columns . length = = 0 ; <nl> + return BTree . isEmpty ( columns ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 122 , 7 + 126 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public int complexColumnCount ( ) <nl> { <nl> - return columns . length - complexIdx ; <nl> + return BTree . size ( columns ) - complexIdx ; <nl> } <nl> <nl> / * * <nl> @ @ - 132 , 7 + 136 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public int columnCount ( ) <nl> { <nl> - return columns . length ; <nl> + return BTree . size ( columns ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 152 , 7 + 156 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public boolean hasComplex ( ) <nl> { <nl> - return complexIdx < columns . length ; <nl> + return complexIdx < BTree . size ( columns ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 165 , 7 + 169 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public ColumnDefinition getSimple ( int i ) <nl> { <nl> - return columns [ i ] ; <nl> + return BTree . findByIndex ( columns , i ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 178 , 7 + 182 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public ColumnDefinition getComplex ( int i ) <nl> { <nl> - return columns [ complexIdx + i ] ; <nl> + return BTree . findByIndex ( columns , complexIdx + i ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 186 , 19 + 190 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * the provided column ) . <nl> * <nl> * @ param c the simple column for which to return the index of . <nl> - * @ param from the index to start the search from . <nl> * <nl> * @ return the index for simple column { @ code c } if it is contains in this <nl> - * object ( starting from index { @ code from } ) , { @ code - 1 } otherwise . <nl> + * object <nl> * / <nl> - public int simpleIdx ( ColumnDefinition c , int from ) <nl> + public int simpleIdx ( ColumnDefinition c ) <nl> { <nl> - assert ! c . isComplex ( ) ; <nl> - for ( int i = from ; i < complexIdx ; i + + ) <nl> - / / We know we only use " interned " ColumnIdentifier so = = is ok . <nl> - if ( columns [ i ] . name = = c . name ) <nl> - return i ; <nl> - return - 1 ; <nl> + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 206 , 19 + 204 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * the provided column ) . <nl> * <nl> * @ param c the complex column for which to return the index of . <nl> - * @ param from the index to start the search from . <nl> * <nl> * @ return the index for complex column { @ code c } if it is contains in this <nl> - * object ( starting from index { @ code from } ) , { @ code - 1 } otherwise . <nl> + * object <nl> * / <nl> - public int complexIdx ( ColumnDefinition c , int from ) <nl> + public int complexIdx ( ColumnDefinition c ) <nl> { <nl> - assert c . isComplex ( ) ; <nl> - for ( int i = complexIdx + from ; i < columns . length ; i + + ) <nl> - / / We know we only use " interned " ColumnIdentifier so = = is ok . <nl> - if ( columns [ i ] . name = = c . name ) <nl> - return i - complexIdx ; <nl> - return - 1 ; <nl> + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) - complexIdx ; <nl> } <nl> <nl> / * * <nl> @ @ - 230 , 30 + 222 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public boolean contains ( ColumnDefinition c ) <nl> { <nl> - return c . isComplex ( ) ? complexIdx ( c , 0 ) > = 0 : simpleIdx ( c , 0 ) > = 0 ; <nl> - } <nl> - <nl> - / * * <nl> - * Whether or not there is some counter columns within those columns . <nl> - * <nl> - * @ return whether or not there is some counter columns within those columns . <nl> - * / <nl> - public boolean hasCounters ( ) <nl> - { <nl> - for ( int i = 0 ; i < complexIdx ; i + + ) <nl> - { <nl> - if ( columns [ i ] . type . isCounter ( ) ) <nl> - return true ; <nl> - } <nl> - <nl> - for ( int i = complexIdx ; i < columns . length ; i + + ) <nl> - { <nl> - / / We only support counter in maps because that ' s all we need for now ( and we need it for the sake of thrift super columns of counter ) <nl> - if ( columns [ i ] . type instanceof MapType & & ( ( ( MapType ) columns [ i ] . type ) . valueComparator ( ) . isCounter ( ) ) ) <nl> - return true ; <nl> - } <nl> - <nl> - return false ; <nl> + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) > = 0 ; <nl> } <nl> <nl> / * * <nl> @ @ - 273 , 60 + 242 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> if ( this = = NONE ) <nl> return other ; <nl> <nl> - int i = 0 , j = 0 ; <nl> - int size = 0 ; <nl> - while ( i < columns . length & & j < other . columns . length ) <nl> - { <nl> - + + size ; <nl> - int cmp = columns [ i ] . compareTo ( other . columns [ j ] ) ; <nl> - if ( cmp = = 0 ) <nl> - { <nl> - + + i ; <nl> - + + j ; <nl> - } <nl> - else if ( cmp < 0 ) <nl> - { <nl> - + + i ; <nl> - } <nl> - else <nl> - { <nl> - + + j ; <nl> - } <nl> - } <nl> - <nl> - / / If every element was always counted on both array , we have the same <nl> - / / arrays for the first min elements <nl> - if ( i = = size & & j = = size ) <nl> - { <nl> - / / We ' ve exited because of either c1 or c2 ( or both ) . The array that <nl> - / / made us stop is thus a subset of the 2nd one , return that array . <nl> - return i = = columns . length ? other : this ; <nl> - } <nl> + Object [ ] tree = BTree . < ColumnDefinition > merge ( this . columns , other . columns , Comparator . naturalOrder ( ) ) ; <nl> + if ( tree = = this . columns ) <nl> + return this ; <nl> + if ( tree = = other . columns ) <nl> + return other ; <nl> <nl> - size + = i = = columns . length ? other . columns . length - j : columns . length - i ; <nl> - ColumnDefinition [ ] result = new ColumnDefinition [ size ] ; <nl> - i = 0 ; <nl> - j = 0 ; <nl> - for ( int k = 0 ; k < size ; k + + ) <nl> - { <nl> - int cmp = i > = columns . length ? 1 <nl> - : ( j > = other . columns . length ? - 1 : columns [ i ] . compareTo ( other . columns [ j ] ) ) ; <nl> - if ( cmp = = 0 ) <nl> - { <nl> - result [ k ] = columns [ i ] ; <nl> - + + i ; <nl> - + + j ; <nl> - } <nl> - else if ( cmp < 0 ) <nl> - { <nl> - result [ k ] = columns [ i + + ] ; <nl> - } <nl> - else <nl> - { <nl> - result [ k ] = other . columns [ j + + ] ; <nl> - } <nl> - } <nl> - return new Columns ( result , findFirstComplexIdx ( result ) ) ; <nl> + return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 341 , 20 + 263 , 10 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> if ( other . columns . length > columns . length ) <nl> return false ; <nl> <nl> - int j = 0 ; <nl> - int cmp = 0 ; <nl> - for ( ColumnDefinition def : other . columns ) <nl> - { <nl> - while ( j < columns . length & & ( cmp = columns [ j ] . compareTo ( def ) ) < 0 ) <nl> - j + + ; <nl> - <nl> - if ( j > = columns . length | | cmp > 0 ) <nl> + BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; <nl> + for ( ColumnDefinition def : BTree . < ColumnDefinition > iterable ( other . columns ) ) <nl> + if ( iter . next ( def ) = = null ) <nl> return false ; <nl> - <nl> - / / cmp = = 0 , we ' ve found the definition . Ce can bump j once more since <nl> - / / we know we won ' t need to compare that element again <nl> - j + + ; <nl> - } <nl> return true ; <nl> } <nl> <nl> @ @ - 365 , 7 + 277 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public Iterator < ColumnDefinition > simpleColumns ( ) <nl> { <nl> - return new ColumnIterator ( 0 , complexIdx ) ; <nl> + return BTree . iterator ( columns , 0 , complexIdx - 1 , BTree . Dir . ASC ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 375 , 7 + 287 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public Iterator < ColumnDefinition > complexColumns ( ) <nl> { <nl> - return new ColumnIterator ( complexIdx , columns . length ) ; <nl> + return BTree . iterator ( columns , complexIdx , BTree . size ( columns ) - 1 , BTree . Dir . ASC ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 385 , 7 + 297 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public Iterator < ColumnDefinition > iterator ( ) <nl> { <nl> - return Iterators . forArray ( columns ) ; <nl> + return BTree . iterator ( columns ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 399 , 23 + 311 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> { <nl> / / In wildcard selection , we want to return all columns in alphabetical order , <nl> / / irregarding of whether they are complex or not <nl> - return new AbstractIterator < ColumnDefinition > ( ) <nl> - { <nl> - private int regular ; <nl> - private int complex = complexIdx ; <nl> - <nl> - protected ColumnDefinition computeNext ( ) <nl> - { <nl> - if ( complex > = columns . length ) <nl> - return regular > = complexIdx ? endOfData ( ) : columns [ regular + + ] ; <nl> - if ( regular > = complexIdx ) <nl> - return columns [ complex + + ] ; <nl> - <nl> - return columns [ regular ] . name . compareTo ( columns [ complex ] . name ) < 0 <nl> - ? columns [ regular + + ] <nl> - : columns [ complex + + ] ; <nl> - } <nl> - } ; <nl> + return Iterators . < ColumnDefinition > mergeSorted ( ImmutableList . of ( simpleColumns ( ) , complexColumns ( ) ) , <nl> + ( s , c ) - > s . name . compareTo ( c . name ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 428 , 15 + 325 , 10 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public Columns without ( ColumnDefinition column ) <nl> { <nl> - int idx = column . isComplex ( ) ? complexIdx ( column , 0 ) : simpleIdx ( column , 0 ) ; <nl> - if ( idx < 0 ) <nl> + if ( ! contains ( column ) ) <nl> return this ; <nl> <nl> - int realIdx = column . isComplex ( ) ? complexIdx + idx : idx ; <nl> - <nl> - ColumnDefinition [ ] newColumns = new ColumnDefinition [ columns . length - 1 ] ; <nl> - System . arraycopy ( columns , 0 , newColumns , 0 , realIdx ) ; <nl> - System . arraycopy ( columns , realIdx + 1 , newColumns , realIdx , newColumns . length - realIdx ) ; <nl> + Object [ ] newColumns = BTree . < ColumnDefinition > transformAndFilter ( columns , ( c ) - > c . equals ( column ) ? null : c ) ; <nl> return new Columns ( newColumns ) ; <nl> } <nl> <nl> @ @ - 448 , 24 + 340 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> * / <nl> public Predicate < ColumnDefinition > inOrderInclusionTester ( ) <nl> { <nl> - return new Predicate < ColumnDefinition > ( ) <nl> - { <nl> - private int i = 0 ; <nl> - <nl> - public boolean test ( ColumnDefinition column ) <nl> - { <nl> - while ( i < columns . length ) <nl> - { <nl> - int cmp = column . compareTo ( columns [ i ] ) ; <nl> - if ( cmp < 0 ) <nl> - return false ; <nl> - i + + ; <nl> - if ( cmp = = 0 ) <nl> - return true ; <nl> - } <nl> - return false ; <nl> - } <nl> - } ; <nl> + SearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; <nl> + return column - > iter . next ( column ) ! = null ; <nl> } <nl> <nl> public void digest ( MessageDigest digest ) <nl> @ @ - 477 , 17 + 353 , 19 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> @ Override <nl> public boolean equals ( Object other ) <nl> { <nl> + if ( other = = this ) <nl> + return true ; <nl> if ( ! ( other instanceof Columns ) ) <nl> return false ; <nl> <nl> Columns that = ( Columns ) other ; <nl> - return this . complexIdx = = that . complexIdx & & Arrays . equals ( this . columns , that . columns ) ; <nl> + return this . complexIdx = = that . complexIdx & & BTree . equals ( this . columns , that . columns ) ; <nl> } <nl> <nl> @ Override <nl> public int hashCode ( ) <nl> { <nl> - return Objects . hash ( complexIdx , Arrays . hashCode ( columns ) ) ; <nl> + return Objects . hash ( complexIdx , BTree . hashCode ( columns ) ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 503 , 25 + 381 , 6 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> return sb . toString ( ) ; <nl> } <nl> <nl> - private class ColumnIterator extends AbstractIterator < ColumnDefinition > <nl> - { <nl> - private final int to ; <nl> - private int idx ; <nl> - <nl> - private ColumnIterator ( int from , int to ) <nl> - { <nl> - this . idx = from ; <nl> - this . to = to ; <nl> - } <nl> - <nl> - protected ColumnDefinition computeNext ( ) <nl> - { <nl> - if ( idx > = to ) <nl> - return endOfData ( ) ; <nl> - return columns [ idx + + ] ; <nl> - } <nl> - } <nl> - <nl> public static class Serializer <nl> { <nl> public void serialize ( Columns columns , DataOutputPlus out ) throws IOException <nl> @ @ - 542 , 7 + 401 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> public Columns deserialize ( DataInputPlus in , CFMetaData metadata ) throws IOException <nl> { <nl> int length = ( int ) in . readVInt ( ) ; <nl> - ColumnDefinition [ ] columns = new ColumnDefinition [ length ] ; <nl> + BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; <nl> + builder . auto ( false ) ; <nl> for ( int i = 0 ; i < length ; i + + ) <nl> { <nl> ByteBuffer name = ByteBufferUtil . readWithVIntLength ( in ) ; <nl> @ @ - 556 , 9 + 416 , 9 @ @ public class Columns implements Iterable < ColumnDefinition > <nl> if ( column = = null ) <nl> throw new RuntimeException ( " Unknown column " + UTF8Type . instance . getString ( name ) + " during deserialization " ) ; <nl> } <nl> - columns [ i ] = column ; <nl> + builder . add ( column ) ; <nl> } <nl> - return new Columns ( columns ) ; <nl> + return new Columns ( builder . build ( ) ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / view / MaterializedView . java b / src / java / org / apache / cassandra / db / view / MaterializedView . java <nl> index 988bfc5 . . 06c4dc2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / view / MaterializedView . java <nl> + + + b / src / java / org / apache / cassandra / db / view / MaterializedView . java <nl> @ @ - 666 , 7 + 666 , 7 @ @ public class MaterializedView <nl> viewBuilder . addClusteringColumn ( ident , properties . getReversableType ( ident , column . type ) ) ; <nl> } <nl> <nl> - for ( ColumnDefinition column : baseCf . partitionColumns ( ) . regulars . columns ) <nl> + for ( ColumnDefinition column : baseCf . partitionColumns ( ) . regulars ) <nl> { <nl> if ( column ! = nonPkTarget & & ( includeAll | | included . contains ( column ) ) ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / BTree . java b / src / java / org / apache / cassandra / utils / btree / BTree . java <nl> index 62942b4 . . 353e7a5 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / BTree . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / BTree . java <nl> @ @ - 669 , 7 + 669 , 18 @ @ public class BTree <nl> <nl> public static boolean equals ( Object [ ] a , Object [ ] b ) <nl> { <nl> - return Iterators . elementsEqual ( iterator ( a ) , iterator ( b ) ) ; <nl> + return size ( a ) = = size ( b ) & & Iterators . elementsEqual ( iterator ( a ) , iterator ( b ) ) ; <nl> + } <nl> + <nl> + public static int hashCode ( Object [ ] btree ) <nl> + { <nl> + / / we can ' t just delegate to Arrays . deepHashCode ( ) , <nl> + / / because two equivalent trees may be represented by differently shaped trees <nl> + int result = 1 ; <nl> + for ( Object v : iterable ( btree ) ) <nl> + result = 31 * result + Objects . hashCode ( v ) ; <nl> + return result ; <nl> + <nl> } <nl> <nl> / * * <nl> diff - - git a / test / unit / org / apache / cassandra / db / ColumnsTest . java b / test / unit / org / apache / cassandra / db / ColumnsTest . java <nl> new file mode 100644 <nl> index 0000000 . . 5447fcc <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / ColumnsTest . java <nl> @ @ - 0 , 0 + 1 , 244 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . Iterator ; <nl> + import java . util . List ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> + import java . util . function . Predicate ; <nl> + <nl> + import com . google . common . collect . Lists ; <nl> + <nl> + import org . junit . AfterClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . MockSchema ; <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . db . marshal . SetType ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . btree . BTreeSet ; <nl> + <nl> + public class ColumnsTest <nl> + { <nl> + <nl> + private static CFMetaData cfMetaData = MockSchema . newCFS ( ) . metadata ; <nl> + <nl> + @ Test <nl> + public void testContainsWithoutAndMergeTo ( ) <nl> + { <nl> + for ( RandomColumns randomColumns : random ( ) ) <nl> + testContainsWithoutAndMergeTo ( randomColumns . columns , randomColumns . definitions ) ; <nl> + } <nl> + <nl> + private void testContainsWithoutAndMergeTo ( Columns columns , List < ColumnDefinition > definitions ) <nl> + { <nl> + / / pick some arbitrary groupings of columns to remove at - once ( to avoid factorial complexity ) <nl> + / / whatever is left after each removal , we perform this logic on again , recursively <nl> + List < List < ColumnDefinition > > removeGroups = shuffleAndGroup ( Lists . newArrayList ( definitions ) ) ; <nl> + for ( List < ColumnDefinition > defs : removeGroups ) <nl> + { <nl> + Columns subset = columns ; <nl> + for ( ColumnDefinition def : defs ) <nl> + subset = subset . without ( def ) ; <nl> + Assert . assertEquals ( columns . columnCount ( ) - defs . size ( ) , subset . columnCount ( ) ) ; <nl> + List < ColumnDefinition > remainingDefs = Lists . newArrayList ( columns ) ; <nl> + remainingDefs . removeAll ( defs ) ; <nl> + <nl> + / / test contents after . without <nl> + assertContents ( subset , remainingDefs ) ; <nl> + <nl> + / / test . contains <nl> + assertSubset ( columns , subset ) ; <nl> + <nl> + / / test . mergeTo <nl> + Columns otherSubset = columns ; <nl> + for ( ColumnDefinition def : remainingDefs ) <nl> + { <nl> + otherSubset = otherSubset . without ( def ) ; <nl> + assertContents ( otherSubset . mergeTo ( subset ) , definitions ) ; <nl> + } <nl> + <nl> + testContainsWithoutAndMergeTo ( subset , remainingDefs ) ; <nl> + } <nl> + } <nl> + <nl> + private void assertSubset ( Columns superset , Columns subset ) <nl> + { <nl> + Assert . assertTrue ( superset . contains ( superset ) ) ; <nl> + Assert . assertTrue ( superset . contains ( subset ) ) ; <nl> + Assert . assertFalse ( subset . contains ( superset ) ) ; <nl> + } <nl> + <nl> + private static void assertContents ( Columns columns , List < ColumnDefinition > defs ) <nl> + { <nl> + Assert . assertEquals ( defs , Lists . newArrayList ( columns ) ) ; <nl> + boolean hasSimple = false , hasComplex = false ; <nl> + int firstComplexIdx = 0 ; <nl> + int i = 0 ; <nl> + Iterator < ColumnDefinition > simple = columns . simpleColumns ( ) ; <nl> + Iterator < ColumnDefinition > complex = columns . complexColumns ( ) ; <nl> + Iterator < ColumnDefinition > all = columns . iterator ( ) ; <nl> + Predicate < ColumnDefinition > predicate = columns . inOrderInclusionTester ( ) ; <nl> + for ( ColumnDefinition def : defs ) <nl> + { <nl> + Assert . assertEquals ( def , all . next ( ) ) ; <nl> + Assert . assertTrue ( columns . contains ( def ) ) ; <nl> + Assert . assertTrue ( predicate . test ( def ) ) ; <nl> + if ( def . isSimple ( ) ) <nl> + { <nl> + hasSimple = true ; <nl> + Assert . assertEquals ( i , columns . simpleIdx ( def ) ) ; <nl> + Assert . assertEquals ( def , simple . next ( ) ) ; <nl> + + + firstComplexIdx ; <nl> + } <nl> + else <nl> + { <nl> + Assert . assertFalse ( simple . hasNext ( ) ) ; <nl> + hasComplex = true ; <nl> + Assert . assertEquals ( i - firstComplexIdx , columns . complexIdx ( def ) ) ; <nl> + Assert . assertEquals ( def , complex . next ( ) ) ; <nl> + } <nl> + i + + ; <nl> + } <nl> + Assert . assertEquals ( defs . isEmpty ( ) , columns . isEmpty ( ) ) ; <nl> + Assert . assertFalse ( simple . hasNext ( ) ) ; <nl> + Assert . assertFalse ( complex . hasNext ( ) ) ; <nl> + Assert . assertFalse ( all . hasNext ( ) ) ; <nl> + Assert . assertEquals ( hasSimple , columns . hasSimple ( ) ) ; <nl> + Assert . assertEquals ( hasComplex , columns . hasComplex ( ) ) ; <nl> + } <nl> + <nl> + private static < V > List < List < V > > shuffleAndGroup ( List < V > list ) <nl> + { <nl> + / / first shuffle <nl> + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; <nl> + for ( int i = 0 ; i < list . size ( ) - 1 ; i + + ) <nl> + { <nl> + int j = random . nextInt ( i , list . size ( ) ) ; <nl> + V v = list . get ( i ) ; <nl> + list . set ( i , list . get ( j ) ) ; <nl> + list . set ( j , v ) ; <nl> + } <nl> + <nl> + / / then group <nl> + List < List < V > > result = new ArrayList < > ( ) ; <nl> + for ( int i = 0 ; i < list . size ( ) ; ) <nl> + { <nl> + List < V > group = new ArrayList < > ( ) ; <nl> + int maxCount = list . size ( ) - i ; <nl> + int count = maxCount < = 2 ? maxCount : random . nextInt ( 1 , maxCount ) ; <nl> + for ( int j = 0 ; j < count ; j + + ) <nl> + group . add ( list . get ( i + j ) ) ; <nl> + i + = count ; <nl> + result . add ( group ) ; <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void cleanup ( ) <nl> + { <nl> + MockSchema . cleanup ( ) ; <nl> + } <nl> + <nl> + private static class RandomColumns <nl> + { <nl> + final Columns columns ; <nl> + final List < ColumnDefinition > definitions ; <nl> + <nl> + private RandomColumns ( List < ColumnDefinition > definitions ) <nl> + { <nl> + this . columns = Columns . from ( BTreeSet . of ( definitions ) ) ; <nl> + this . definitions = definitions ; <nl> + } <nl> + } <nl> + <nl> + private static List < RandomColumns > random ( ) <nl> + { <nl> + List < RandomColumns > random = new ArrayList < > ( ) ; <nl> + for ( int i = 1 ; i < = 3 ; i + + ) <nl> + { <nl> + random . add ( random ( i , i - 1 , i - 1 , i - 1 ) ) ; <nl> + random . add ( random ( i - 1 , i , i - 1 , i - 1 ) ) ; <nl> + random . add ( random ( i - 1 , i - 1 , i , i - 1 ) ) ; <nl> + random . add ( random ( i - 1 , i - 1 , i - 1 , i ) ) ; <nl> + } <nl> + return random ; <nl> + } <nl> + <nl> + private static RandomColumns random ( int pkCount , int clCount , int regularCount , int complexCount ) <nl> + { <nl> + List < Character > chars = new ArrayList < > ( ) ; <nl> + for ( char c = ' a ' ; c < = ' z ' ; c + + ) <nl> + chars . add ( c ) ; <nl> + <nl> + List < ColumnDefinition > result = new ArrayList < > ( ) ; <nl> + addPartition ( select ( chars , pkCount ) , result ) ; <nl> + addClustering ( select ( chars , clCount ) , result ) ; <nl> + addRegular ( select ( chars , regularCount ) , result ) ; <nl> + addComplex ( select ( chars , complexCount ) , result ) ; <nl> + Collections . sort ( result ) ; <nl> + return new RandomColumns ( result ) ; <nl> + } <nl> + <nl> + private static List < Character > select ( List < Character > chars , int count ) <nl> + { <nl> + List < Character > result = new ArrayList < > ( ) ; <nl> + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; <nl> + for ( int i = 0 ; i < count ; i + + ) <nl> + { <nl> + int v = random . nextInt ( chars . size ( ) ) ; <nl> + result . add ( chars . get ( v ) ) ; <nl> + chars . remove ( v ) ; <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + private static void addPartition ( List < Character > chars , List < ColumnDefinition > results ) <nl> + { <nl> + addSimple ( ColumnDefinition . Kind . PARTITION _ KEY , chars , results ) ; <nl> + } <nl> + <nl> + private static void addClustering ( List < Character > chars , List < ColumnDefinition > results ) <nl> + { <nl> + addSimple ( ColumnDefinition . Kind . CLUSTERING , chars , results ) ; <nl> + } <nl> + <nl> + private static void addRegular ( List < Character > chars , List < ColumnDefinition > results ) <nl> + { <nl> + addSimple ( ColumnDefinition . Kind . REGULAR , chars , results ) ; <nl> + } <nl> + <nl> + private static void addSimple ( ColumnDefinition . Kind kind , List < Character > chars , List < ColumnDefinition > results ) <nl> + { <nl> + for ( Character c : chars ) <nl> + results . add ( new ColumnDefinition ( cfMetaData , ByteBufferUtil . bytes ( c . toString ( ) ) , UTF8Type . instance , null , kind ) ) ; <nl> + } <nl> + <nl> + private static void addComplex ( List < Character > chars , List < ColumnDefinition > results ) <nl> + { <nl> + for ( Character c : chars ) <nl> + results . add ( new ColumnDefinition ( cfMetaData , ByteBufferUtil . bytes ( c . toString ( ) ) , SetType . getInstance ( UTF8Type . instance , true ) , null , ColumnDefinition . Kind . REGULAR ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g <nl> index 7fe56f8 . . 4b9aadc 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql / Cql . g <nl> @ @ - 65 , 30 + 65 , 19 @ @ useStatement returns [ String keyspace ] <nl> selectStatement returns [ SelectStatement expr ] <nl> : { <nl> int numRecords = 10000 ; <nl> - int numColumns = 10000 ; <nl> - boolean reversed = false ; <nl> ConsistencyLevel cLevel = ConsistencyLevel . ONE ; <nl> } <nl> - K _ SELECT K _ FROM ? IDENT <nl> - ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? <nl> - K _ WHERE selectExpression <nl> - ( limit = ( K _ ROWLIMIT | K _ COLLIMIT ) value = INTEGER <nl> - { <nl> - int count = Integer . parseInt ( $ value . text ) ; <nl> - if ( $ limit . type = = K _ ROWLIMIT ) <nl> - numRecords = count ; <nl> - else <nl> - numColumns = count ; <nl> - } <nl> - ) * <nl> - order = ( K _ ASC | K _ DESC { reversed = true ; } ) ? endStmnt <nl> + K _ SELECT selectExpression K _ FROM columnFamily = IDENT <nl> + ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? <nl> + ( K _ WHERE whereClause ) ? <nl> + ( K _ LIMIT rows = INTEGER { numRecords = Integer . parseInt ( $ rows . text ) ; } ) ? <nl> + endStmnt <nl> { <nl> - return new SelectStatement ( $ IDENT . text , <nl> + return new SelectStatement ( $ selectExpression . expr , <nl> + $ columnFamily . text , <nl> cLevel , <nl> - $ selectExpression . expr , <nl> - numRecords , <nl> - numColumns , <nl> - reversed ) ; <nl> + $ whereClause . clause , <nl> + numRecords ) ; <nl> } <nl> ; <nl> <nl> @ @ - 116 , 16 + 105 , 32 @ @ term returns [ Term item ] <nl> { $ item = new Term ( $ t . text , $ t . type ) ; } <nl> ; <nl> <nl> - / / Note : slices are inclusive so > = and > , and < and < = all have the same semantics . <nl> + / / Note : ranges are inclusive so > = and > , and < and < = all have the same semantics . <nl> relation returns [ Relation rel ] <nl> - : kind = ( K _ KEY | K _ COLUMN ) type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term <nl> - { return new Relation ( $ kind . text , $ type . text , $ t . item ) ; } <nl> + : { Term entity = new Term ( " KEY " , STRING _ LITERAL ) ; } <nl> + ( K _ KEY | name = term { entity = $ name . item ; } ) type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term <nl> + { return new Relation ( entity , $ type . text , $ t . item ) ; } <nl> ; <nl> <nl> / / relation [ [ AND relation ] . . . ] <nl> + whereClause returns [ WhereClause clause ] <nl> + : first = relation { $ clause = new WhereClause ( first ) ; } <nl> + ( K _ AND next = relation { $ clause . and ( next ) ; } ) * <nl> + ; <nl> + <nl> + / / [ FIRST n ] [ REVERSED ] name1 [ [ [ , name2 ] , nameN ] , . . . ] <nl> + / / [ FIRST n ] [ REVERSED ] name1 . . nameN <nl> selectExpression returns [ SelectExpression expr ] <nl> - : first = relation { $ expr = new SelectExpression ( first ) ; } <nl> - ( K _ AND next = relation { $ expr . and ( next ) ; } ) * <nl> + : { <nl> + int count = 10000 ; <nl> + boolean reversed = false ; <nl> + } <nl> + ( K _ FIRST cols = INTEGER { count = Integer . parseInt ( $ cols . text ) ; } ) ? <nl> + ( K _ REVERSED { reversed = true ; } ) ? <nl> + ( first = term { $ expr = new SelectExpression ( first , count , reversed ) ; } <nl> + ( ' , ' next = term { $ expr . and ( next ) ; } ) * <nl> + | start = term ' . . ' finish = term { $ expr = new SelectExpression ( start , finish , count , reversed ) ; } <nl> + ) <nl> ; <nl> <nl> columnDef returns [ Column column ] <nl> @ @ - 151 , 14 + 156 , 10 @ @ K _ COLUMN : C O L ( U M N ) ? ; <nl> K _ UPDATE : U P D A T E ; <nl> K _ WITH : W I T H ; <nl> K _ ROW : R O W ; <nl> - K _ ROWLIMIT : R O W L I M I T ; <nl> - K _ COLLIMIT : C O L L I M I T ; <nl> - K _ ASC : A S C ( E N D I N G ) ? ; <nl> - K _ DESC : D E S C ( E N D I N G ) ? ; <nl> + K _ LIMIT : L I M I T ; <nl> K _ USING : U S I N G ; <nl> K _ CONSISTENCY : C O N S I S T E N C Y ; <nl> - K _ LEVEL : ( Z E R O <nl> - | O N E <nl> + K _ LEVEL : ( O N E <nl> | Q U O R U M <nl> | A L L <nl> | D C Q U O R U M <nl> @ @ - 166 , 6 + 167 , 8 @ @ K _ LEVEL : ( Z E R O <nl> ) <nl> ; <nl> K _ USE : U S E ; <nl> + K _ FIRST : F I R S T ; <nl> + K _ REVERSED : R E V E R S E D ; <nl> <nl> / / Case - insensitive alpha characters <nl> fragment A : ( ' a ' | ' A ' ) ; <nl> diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> index 9fabff3 . . bf21098 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java <nl> @ @ - 65 , 38 + 65 , 37 @ @ public class QueryProcessor <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; <nl> <nl> - private static List < org . apache . cassandra . db . Row > multiSlice ( String keyspace , SelectStatement select ) <nl> + private static List < org . apache . cassandra . db . Row > getSlice ( String keyspace , SelectStatement select ) <nl> throws InvalidRequestException , TimedOutException , UnavailableException <nl> { <nl> List < org . apache . cassandra . db . Row > rows = null ; <nl> QueryPath queryPath = new QueryPath ( select . getColumnFamily ( ) ) ; <nl> List < ReadCommand > commands = new ArrayList < ReadCommand > ( ) ; <nl> <nl> - for ( Term keyName : select . getKeyPredicates ( ) . getTerms ( ) ) <nl> + assert select . getKeys ( ) . size ( ) = = 1 ; <nl> + <nl> + ByteBuffer key = select . getKeys ( ) . get ( 0 ) . getByteBuffer ( ) ; <nl> + validateKey ( key ) ; <nl> + <nl> + / / . . . of a list of column names <nl> + if ( ! select . isColumnRange ( ) ) <nl> { <nl> - ByteBuffer key = keyName . getByteBuffer ( ) ; <nl> - validateKey ( key ) ; <nl> + Collection < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; <nl> + for ( Term column : select . getColumnNames ( ) ) <nl> + columnNames . add ( column . getByteBuffer ( ) ) ; <nl> <nl> - / / . . . of a list of column names <nl> - if ( ( ! select . getColumnPredicates ( ) . isRange ( ) ) & & select . getColumnPredicates ( ) . isInitialized ( ) ) <nl> - { <nl> - Collection < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; <nl> - for ( Term column : select . getColumnPredicates ( ) . getTerms ( ) ) <nl> - columnNames . add ( column . getByteBuffer ( ) ) ; <nl> - <nl> - commands . add ( new SliceByNamesReadCommand ( keyspace , key , queryPath , columnNames ) ) ; <nl> - } <nl> - / / . . . a range ( slice ) of column names <nl> - else <nl> - { <nl> - commands . add ( new SliceFromReadCommand ( keyspace , <nl> - key , <nl> - queryPath , <nl> - select . getColumnPredicates ( ) . getStart ( ) . getByteBuffer ( ) , <nl> - select . getColumnPredicates ( ) . getFinish ( ) . getByteBuffer ( ) , <nl> - select . reversed ( ) , <nl> - select . getNumColumns ( ) ) ) ; <nl> - } <nl> + commands . add ( new SliceByNamesReadCommand ( keyspace , key , queryPath , columnNames ) ) ; <nl> + } <nl> + / / . . . a range ( slice ) of column names <nl> + else <nl> + { <nl> + commands . add ( new SliceFromReadCommand ( keyspace , <nl> + key , <nl> + queryPath , <nl> + select . getColumnStart ( ) . getByteBuffer ( ) , <nl> + select . getColumnFinish ( ) . getByteBuffer ( ) , <nl> + select . isColumnsReversed ( ) , <nl> + select . getColumnsLimit ( ) ) ) ; <nl> } <nl> <nl> try <nl> @ @ - 135 , 24 + 134 , 25 @ @ public class QueryProcessor <nl> / / FIXME : ranges can be open - ended , but a start must exist . Assert so here . <nl> <nl> IPartitioner < ? > p = StorageService . getPartitioner ( ) ; <nl> - AbstractBounds bounds = new Bounds ( p . getToken ( select . getKeyPredicates ( ) . getStart ( ) . getByteBuffer ( ) ) , <nl> - p . getToken ( select . getKeyPredicates ( ) . getFinish ( ) . getByteBuffer ( ) ) ) ; <nl> + AbstractBounds bounds = new Bounds ( p . getToken ( select . getKeyStart ( ) . getByteBuffer ( ) ) , <nl> + p . getToken ( select . getKeyFinish ( ) . getByteBuffer ( ) ) ) ; <nl> + <nl> <nl> / / XXX : Our use of Thrift structs internally makes me Sad . : ( <nl> SlicePredicate thriftSlicePredicate = new SlicePredicate ( ) ; <nl> - if ( select . getColumnPredicates ( ) . isRange ( ) | | select . getColumnPredicates ( ) . getTerms ( ) . size ( ) = = 0 ) <nl> + if ( select . isColumnRange ( ) | | select . getColumnNames ( ) . size ( ) = = 0 ) <nl> { <nl> SliceRange sliceRange = new SliceRange ( ) ; <nl> - sliceRange . start = select . getColumnPredicates ( ) . getStart ( ) . getByteBuffer ( ) ; <nl> - sliceRange . finish = select . getColumnPredicates ( ) . getFinish ( ) . getByteBuffer ( ) ; <nl> + sliceRange . start = select . getColumnStart ( ) . getByteBuffer ( ) ; <nl> + sliceRange . finish = select . getColumnFinish ( ) . getByteBuffer ( ) ; <nl> sliceRange . reversed = false ; / / FIXME : hard - coded <nl> - sliceRange . count = select . getNumColumns ( ) ; <nl> + sliceRange . count = select . getColumnsLimit ( ) ; <nl> thriftSlicePredicate . slice _ range = sliceRange ; <nl> } <nl> else <nl> { <nl> List < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; <nl> - for ( Term column : select . getColumnPredicates ( ) . getTerms ( ) ) <nl> + for ( Term column : select . getColumnNames ( ) ) <nl> columnNames . add ( column . getByteBuffer ( ) ) ; <nl> thriftSlicePredicate . column _ names = columnNames ; <nl> } <nl> @ @ - 204 , 10 + 204 , 31 @ @ public class QueryProcessor <nl> avroResult . type = CqlResultType . ROWS ; <nl> List < org . apache . cassandra . db . Row > rows = null ; <nl> <nl> - if ( ! select . getKeyPredicates ( ) . isRange ( ) ) <nl> - rows = multiSlice ( keyspace , select ) ; <nl> + if ( ! select . isKeyRange ( ) & & ( select . getKeys ( ) . size ( ) > 0 ) ) <nl> + { <nl> + / / Multiple keys ( aka " multiget " ) is not allowed ( any longer ) . <nl> + if ( select . getKeys ( ) . size ( ) > 1 ) <nl> + { <nl> + InvalidRequestException invalidRequest = new InvalidRequestException ( ) ; <nl> + invalidRequest . why = " SELECTs can contain only one by - key clause ( i . e . KEY = TERM ) " ; <nl> + throw invalidRequest ; <nl> + } <nl> + <nl> + rows = getSlice ( keyspace , select ) ; <nl> + } <nl> else <nl> + { <nl> + / / Combining key ranges and column index queries is not currently allowed <nl> + if ( select . getColumnRelations ( ) . size ( ) > 0 ) <nl> + { <nl> + InvalidRequestException invalidRequest = new InvalidRequestException ( ) ; <nl> + invalidRequest . why = " You cannot combine key ranges and by - column clauses " + <nl> + 	 	 " ( i . e . \ " name \ " = \ " value \ " ) in a SELECT statement " ; <nl> + throw invalidRequest ; <nl> + } <nl> + <nl> rows = multiRangeSlice ( keyspace , select ) ; <nl> + } <nl> <nl> / / Create the result set <nl> for ( org . apache . cassandra . db . Row row : rows ) <nl> diff - - git a / src / java / org / apache / cassandra / cql / Relation . java b / src / java / org / apache / cassandra / cql / Relation . java <nl> index cd3d234 . . bddd320 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / Relation . java <nl> + + + b / src / java / org / apache / cassandra / cql / Relation . java <nl> @ @ - 22 , 14 + 22 , 15 @ @ package org . apache . cassandra . cql ; <nl> <nl> / * * <nl> * Relations encapsulate the relationship between an entity of some kind , and <nl> - * a value ( term ) . For example , KEY > ' start ' or COLUMN = 1000L . <nl> + * a value ( term ) . For example , KEY > " start " or " colname1 " = " somevalue " . <nl> * <nl> * / <nl> public class Relation <nl> { <nl> - public Entity entity = Entity . COLUMN ; <nl> - public RelationType type ; <nl> - public Term value ; <nl> + public EntityType entityType = EntityType . COLUMN ; <nl> + public Term entity ; <nl> + private RelationType relationType ; <nl> + private Term value ; <nl> <nl> / * * <nl> * Creates a new relation . <nl> @ @ - 38 , 27 + 39 , 38 @ @ public class Relation <nl> * @ param type the type that describes how this entity relates to the value . <nl> * @ param value the value being compared . <nl> * / <nl> - public Relation ( String entity , String type , Term value ) <nl> + public Relation ( Term entity , String type , Term value ) <nl> { <nl> - if ( entity . toUpperCase ( ) . equals ( " KEY " ) ) <nl> - this . entity = Entity . KEY ; <nl> + if ( entity . getText ( ) . toUpperCase ( ) . equals ( " KEY " ) ) <nl> + this . entityType = EntityType . KEY ; <nl> <nl> - this . type = RelationType . forString ( type ) ; <nl> + this . entity = entity ; <nl> + this . relationType = RelationType . forString ( type ) ; <nl> this . value = value ; <nl> } <nl> <nl> public boolean isKey ( ) <nl> { <nl> - return entity . equals ( Entity . KEY ) ; <nl> + return entityType . equals ( EntityType . KEY ) ; <nl> } <nl> <nl> public boolean isColumn ( ) <nl> { <nl> - return entity . equals ( Entity . COLUMN ) ; <nl> + return entityType . equals ( EntityType . COLUMN ) ; <nl> + } <nl> + <nl> + public RelationType operator ( ) <nl> + { <nl> + return relationType ; <nl> + } <nl> + <nl> + public Term getValue ( ) <nl> + { <nl> + return value ; <nl> } <nl> } <nl> <nl> - enum Entity <nl> + enum EntityType <nl> { <nl> KEY , COLUMN ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql / SelectExpression . java b / src / java / org / apache / cassandra / cql / SelectExpression . java <nl> index 8676d48 . . 562d27d 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / SelectExpression . java <nl> + + + b / src / java / org / apache / cassandra / cql / SelectExpression . java <nl> @ @ - 1 , 4 + 1 , 3 @ @ <nl> - package org . apache . cassandra . cql ; <nl> / * <nl> * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> @ @ - 19 , 122 + 18 , 111 @ @ package org . apache . cassandra . cql ; <nl> * under the License . <nl> * <nl> * / <nl> - <nl> + package org . apache . cassandra . cql ; <nl> <nl> import java . util . ArrayList ; <nl> import java . util . List ; <nl> <nl> / * * <nl> - * SelectExpressions encapsulate all of the predicates of a SELECT query . <nl> + * Select expressions are analogous to the projection in a SQL query . They <nl> + * determine which columns will appear in the result set . SelectExpression <nl> + * instances encapsulate a parsed expression from a < code > SELECT < / code > <nl> + * statement . <nl> * <nl> - * @ author eevans <nl> - * <nl> + * See : doc / cql / CQL . html # SpecifyingColumns <nl> * / <nl> public class SelectExpression <nl> { <nl> - private Predicates keys = new Predicates ( ) ; <nl> - private Predicates columns = new Predicates ( ) ; <nl> + public static final int MAX _ COLUMNS _ DEFAULT = 10000 ; <nl> <nl> - public SelectExpression ( Relation firstRelation ) <nl> + private int numColumns = MAX _ COLUMNS _ DEFAULT ; <nl> + private boolean reverseColumns = false ; <nl> + private Term start , finish ; <nl> + private List < Term > columns ; <nl> + <nl> + / * * <nl> + * Create a new SelectExpression for a range ( slice ) of columns . <nl> + * <nl> + * @ param start the starting column name <nl> + * @ param finish the finishing column name <nl> + * @ param count the number of columns to limit the results to <nl> + * @ param reverse true to reverse column order <nl> + * / <nl> + public SelectExpression ( Term start , Term finish , int count , boolean reverse ) <nl> { <nl> - and ( firstRelation ) ; <nl> + this . start = start ; <nl> + this . finish = finish ; <nl> + numColumns = count ; <nl> + reverseColumns = reverse ; <nl> } <nl> <nl> - public void and ( Relation relation ) <nl> + / * * <nl> + * Create a new SelectExpression for a list of columns . <nl> + * <nl> + * @ param first the first ( possibly only ) column name to select on . <nl> + * @ param count the number of columns to limit the results on <nl> + * @ param reverse true to reverse column order <nl> + * / <nl> + public SelectExpression ( Term first , int count , boolean reverse ) <nl> { <nl> - if ( relation . isKey ( ) ) <nl> - { <nl> - if ( relation . type . equals ( RelationType . EQ ) ) <nl> - keys . addTerm ( relation . value ) ; <nl> - else if ( ( relation . type . equals ( RelationType . GT ) | | relation . type . equals ( RelationType . GTE ) ) ) <nl> - keys . setStart ( relation . value ) ; <nl> - else if ( ( relation . type . equals ( RelationType . LT ) | | relation . type . equals ( RelationType . LTE ) ) ) <nl> - keys . setFinish ( relation . value ) ; <nl> - } <nl> - else / / It ' s a column <nl> - { <nl> - if ( relation . type . equals ( RelationType . EQ ) ) <nl> - columns . addTerm ( relation . value ) ; <nl> - else if ( ( relation . type . equals ( RelationType . GT ) | | relation . type . equals ( RelationType . GTE ) ) ) <nl> - columns . setStart ( relation . value ) ; <nl> - else if ( ( relation . type . equals ( RelationType . LT ) | | relation . type . equals ( RelationType . LTE ) ) ) <nl> - columns . setFinish ( relation . value ) ; <nl> - } <nl> + columns = new ArrayList < Term > ( ) ; <nl> + columns . add ( first ) ; <nl> + numColumns = count ; <nl> + reverseColumns = reverse ; <nl> } <nl> <nl> - public Predicates getKeyPredicates ( ) <nl> + / * * <nl> + * Add an additional column name to a SelectExpression . <nl> + * <nl> + * @ param addTerm <nl> + * / <nl> + public void and ( Term addTerm ) <nl> { <nl> - return keys ; <nl> + assert ! isColumnRange ( ) ; / / Not possible when invoked by parser <nl> + columns . add ( addTerm ) ; <nl> } <nl> <nl> - public Predicates getColumnPredicates ( ) <nl> + public boolean isColumnRange ( ) <nl> { <nl> - return columns ; <nl> + return ( start ! = null ) ; <nl> } <nl> - } <nl> - <nl> - class Predicates <nl> - { <nl> - private boolean initialized = false ; <nl> - private List < Term > names = new ArrayList < Term > ( ) ; <nl> - private Term start , finish ; <nl> - private boolean isRange = false ; <nl> <nl> - Term getStart ( ) <nl> + public boolean isColumnList ( ) <nl> { <nl> - return start = = null ? new Term ( ) : start ; <nl> + return ! isColumnRange ( ) ; <nl> } <nl> - <nl> - void setStart ( Term start ) <nl> + public int getColumnsLimit ( ) <nl> { <nl> - / / FIXME : propagate a proper exception <nl> - if ( initialized & & ( ! isRange ( ) ) ) <nl> - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; <nl> - <nl> - initialized = true ; <nl> - isRange = true ; <nl> - this . start = start ; <nl> + return numColumns ; <nl> } <nl> - <nl> - Term getFinish ( ) <nl> + <nl> + public boolean isColumnsReversed ( ) <nl> { <nl> - return finish = = null ? new Term ( ) : finish ; <nl> + return reverseColumns ; <nl> } <nl> <nl> - void setFinish ( Term finish ) <nl> + public void setColumnsReversed ( boolean reversed ) <nl> { <nl> - / / FIXME : propagate a proper exception <nl> - if ( initialized & & ( ! isRange ( ) ) ) <nl> - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; <nl> - <nl> - initialized = true ; <nl> - isRange = true ; <nl> - this . finish = finish ; <nl> + reverseColumns = reversed ; <nl> } <nl> <nl> - List < Term > getTerms ( ) <nl> + public void setColumnsLimit ( int limit ) <nl> { <nl> - return names ; <nl> + numColumns = limit ; <nl> } <nl> - <nl> - void addTerm ( Term name ) <nl> + <nl> + public Term getStart ( ) <nl> { <nl> - / / FIXME : propagate a proper exception <nl> - if ( initialized & & ( isRange ( ) ) ) <nl> - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; <nl> - <nl> - initialized = true ; <nl> - isRange = false ; <nl> - names . add ( name ) ; <nl> + return start ; <nl> } <nl> - <nl> - boolean isRange ( ) <nl> + <nl> + public Term getFinish ( ) <nl> { <nl> - return isRange ; <nl> + return finish ; <nl> } <nl> <nl> - boolean isInitialized ( ) <nl> + public List < Term > getColumns ( ) <nl> { <nl> - return initialized ; <nl> + return columns ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql / SelectStatement . java b / src / java / org / apache / cassandra / cql / SelectStatement . java <nl> index 24cb6bd . . 884f0cb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql / SelectStatement . java <nl> @ @ - 20 , 6 + 20 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . cql ; <nl> <nl> + import java . util . List ; <nl> + <nl> import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> <nl> / * * <nl> @ @ - 29 , 32 + 31 , 65 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> * / <nl> public class SelectStatement <nl> { <nl> + private final SelectExpression expression ; <nl> private final String columnFamily ; <nl> private final ConsistencyLevel cLevel ; <nl> - private final SelectExpression expression ; <nl> + private final WhereClause clause ; <nl> private final int numRecords ; <nl> - private final int numColumns ; <nl> - private final boolean reverse ; <nl> <nl> - public SelectStatement ( String columnFamily , ConsistencyLevel cLevel , SelectExpression expression , <nl> - int numRecords , int numColumns , boolean reverse ) <nl> + public SelectStatement ( SelectExpression expression , String columnFamily , ConsistencyLevel cLevel , <nl> + WhereClause clause , int numRecords ) <nl> { <nl> + this . expression = expression ; <nl> this . columnFamily = columnFamily ; <nl> this . cLevel = cLevel ; <nl> - this . expression = expression ; <nl> + this . clause = clause ; <nl> this . numRecords = numRecords ; <nl> - this . numColumns = numColumns ; <nl> - this . reverse = reverse ; <nl> } <nl> <nl> - public Predicates getKeyPredicates ( ) <nl> + public boolean isKeyRange ( ) <nl> + { <nl> + return clause . isKeyRange ( ) ; <nl> + } <nl> + <nl> + public List < Term > getKeys ( ) <nl> + { <nl> + return clause . getKeys ( ) ; <nl> + } <nl> + <nl> + public Term getKeyStart ( ) <nl> + { <nl> + return clause . getStartKey ( ) ; <nl> + } <nl> + <nl> + public Term getKeyFinish ( ) <nl> + { <nl> + return clause . getFinishKey ( ) ; <nl> + } <nl> + <nl> + public List < Relation > getColumnRelations ( ) <nl> + { <nl> + return clause . getColumnRelations ( ) ; <nl> + } <nl> + <nl> + public boolean isColumnRange ( ) <nl> + { <nl> + return expression . isColumnRange ( ) ; <nl> + } <nl> + <nl> + public List < Term > getColumnNames ( ) <nl> + { <nl> + return expression . getColumns ( ) ; <nl> + } <nl> + <nl> + public Term getColumnStart ( ) <nl> { <nl> - return expression . getKeyPredicates ( ) ; <nl> + return expression . getStart ( ) ; <nl> } <nl> <nl> - public Predicates getColumnPredicates ( ) <nl> + public Term getColumnFinish ( ) <nl> { <nl> - return expression . getColumnPredicates ( ) ; <nl> + return expression . getFinish ( ) ; <nl> } <nl> <nl> public String getColumnFamily ( ) <nl> @ @ - 62 , 9 + 97 , 9 @ @ public class SelectStatement <nl> return columnFamily ; <nl> } <nl> <nl> - public boolean reversed ( ) <nl> + public boolean isColumnsReversed ( ) <nl> { <nl> - return reverse ; <nl> + return expression . isColumnsReversed ( ) ; <nl> } <nl> <nl> public ConsistencyLevel getConsistencyLevel ( ) <nl> @ @ - 77 , 8 + 112 , 8 @ @ public class SelectStatement <nl> return numRecords ; <nl> } <nl> <nl> - public int getNumColumns ( ) <nl> + public int getColumnsLimit ( ) <nl> { <nl> - return numColumns ; <nl> + return expression . getColumnsLimit ( ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql / WhereClause . java b / src / java / org / apache / cassandra / cql / WhereClause . java <nl> new file mode 100644 <nl> index 0000000 . . 75418c3 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql / WhereClause . java <nl> @ @ - 0 , 0 + 1 , 102 @ @ <nl> + package org . apache . cassandra . cql ; <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + <nl> + import java . util . ArrayList ; <nl> + import java . util . List ; <nl> + <nl> + / * * <nl> + * WhereClauses encapsulate all of the predicates of a SELECT query . <nl> + * <nl> + * / <nl> + public class WhereClause <nl> + { <nl> + private List < Term > keys = new ArrayList < Term > ( ) ; <nl> + private Term startKey , finishKey ; <nl> + private List < Relation > columns = new ArrayList < Relation > ( ) ; <nl> + <nl> + / * * <nl> + * Create a new WhereClause with the first parsed relation . <nl> + * <nl> + * @ param firstRelation key or column relation <nl> + * / <nl> + public WhereClause ( Relation firstRelation ) <nl> + { <nl> + and ( firstRelation ) ; <nl> + } <nl> + <nl> + public WhereClause ( ) <nl> + { <nl> + <nl> + } <nl> + <nl> + / * * <nl> + * Add an additional relation to this WHERE clause . <nl> + * <nl> + * @ param relation the relation to add . <nl> + * / <nl> + public void and ( Relation relation ) <nl> + { <nl> + if ( relation . isKey ( ) ) <nl> + { <nl> + if ( relation . operator ( ) . equals ( RelationType . EQ ) ) <nl> + keys . add ( relation . getValue ( ) ) ; <nl> + else if ( ( relation . operator ( ) . equals ( RelationType . GT ) | | relation . operator ( ) . equals ( RelationType . GTE ) ) ) <nl> + startKey = relation . getValue ( ) ; <nl> + else if ( ( relation . operator ( ) . equals ( RelationType . LT ) | | relation . operator ( ) . equals ( RelationType . LTE ) ) ) <nl> + finishKey = relation . getValue ( ) ; <nl> + <nl> + } <nl> + else <nl> + columns . add ( relation ) ; <nl> + } <nl> + <nl> + public List < Relation > getColumnRelations ( ) <nl> + { <nl> + return columns ; <nl> + } <nl> + <nl> + public boolean isKeyRange ( ) <nl> + { <nl> + return startKey ! = null ; <nl> + } <nl> + <nl> + public boolean isKeyList ( ) <nl> + { <nl> + return ! isKeyRange ( ) ; <nl> + } <nl> + <nl> + public Term getStartKey ( ) <nl> + { <nl> + return startKey ; <nl> + } <nl> + <nl> + public Term getFinishKey ( ) <nl> + { <nl> + return finishKey ; <nl> + } <nl> + <nl> + public List < Term > getKeys ( ) <nl> + { <nl> + return keys ; <nl> + } <nl> + } <nl> diff - - git a / test / system / test _ cql . py b / test / system / test _ cql . py <nl> index 04a0ad5 . . d6ffb6d 100644 <nl> - - - a / test / system / test _ cql . py <nl> + + + b / test / system / test _ cql . py <nl> @ @ - 39 , 7 + 39 , 7 @ @ class TestCql ( AvroTester ) : <nl> def test _ select _ simple ( self ) : <nl> " retrieve a column " <nl> conn = init ( ) <nl> - r = conn . execute ( ' SELECT FROM Standard1 WHERE KEY = " ka " AND COL = " ca1 " ' ) <nl> + r = conn . execute ( ' SELECT " ca1 " FROM Standard1 WHERE KEY = " ka " ' ) <nl> assert r [ 0 ] [ ' key ' ] = = ' ka ' <nl> assert r [ 0 ] [ ' columns ' ] [ 0 ] [ ' name ' ] = = ' ca1 ' <nl> assert r [ 0 ] [ ' columns ' ] [ 0 ] [ ' value ' ] = = ' va1 ' <nl> @ @ - 48 , 42 + 48 , 14 @ @ class TestCql ( AvroTester ) : <nl> " retrieve multiple columns " <nl> conn = init ( ) <nl> r = conn . execute ( " " " <nl> - SELECT FROM Standard1 WHERE KEY = " kd " AND COLUMN = " cd1 " <nl> - AND COLUMN = " col " <nl> + SELECT " cd1 " , " col " FROM Standard1 WHERE KEY = " kd " <nl> " " " ) <nl> assert " cd1 " in [ i [ ' name ' ] for i in r [ 0 ] [ ' columns ' ] ] <nl> assert " col " in [ i [ ' name ' ] for i in r [ 0 ] [ ' columns ' ] ] <nl> <nl> - def test _ select _ rows _ columns ( self ) : <nl> - " fetch multiple rows and columns " <nl> - conn = init ( ) <nl> - r = conn . execute ( " " " <nl> - SELECT FROM <nl> - Standard1 <nl> - WHERE <nl> - KEY = " ka " AND KEY = " kd " AND COLUMN = " col " ; <nl> - " " " ) <nl> - for result in r : <nl> - assert result [ ' key ' ] in ( " ka " , " kd " ) <nl> - assert result [ ' columns ' ] [ 0 ] [ ' name ' ] = = " col " <nl> - assert result [ ' columns ' ] [ 0 ] [ ' value ' ] = = " val " <nl> - <nl> - def test _ select _ rows ( self ) : <nl> - " fetch multiple rows , all columns " <nl> - conn = init ( ) <nl> - r = conn . execute ( " " " <nl> - SELECT FROM <nl> - Standard1 <nl> - WHERE <nl> - KEY = " ka " AND KEY = " kd " AND KEY = " kb " <nl> - " " " ) <nl> - for result in r : <nl> - assert result [ ' key ' ] in ( " ka " , " kd " , " kb " ) <nl> - assert len ( result [ ' columns ' ] ) = = 2 <nl> - <nl> def test _ select _ row _ range ( self ) : <nl> " retrieve a range of rows with columns " <nl> conn = init ( ) <nl> r = conn . execute ( " " " <nl> - SELECT FROM StandardLong1 WHERE KEY > " ad " AND KEY < " ag " ; <nl> + SELECT " col1 " FROM StandardLong1 WHERE KEY > " ad " AND KEY < " ag " ; <nl> " " " )

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / Columns . java b / src / java / org / apache / cassandra / db / Columns . java 
 index 03d2e14 . . 231b529 100644 
 - - - a / src / java / org / apache / cassandra / db / Columns . java 
 + + + b / src / java / org / apache / cassandra / db / Columns . java 
 @ @ - 23 , 16 + 23 , 20 @ @ import java . util . function . Predicate ; 
 import java . nio . ByteBuffer ; 
 import java . security . MessageDigest ; 
 
 - import com . google . common . collect . AbstractIterator ; 
 + import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . Iterators ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . db . marshal . SetType ; 
 import org . apache . cassandra . db . marshal . UTF8Type ; 
 - import org . apache . cassandra . db . marshal . MapType ; 
 import org . apache . cassandra . io . util . DataInputPlus ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . SearchIterator ; 
 + import org . apache . cassandra . utils . btree . BTree ; 
 + import org . apache . cassandra . utils . btree . BTreeSearchIterator ; 
 
 / * * 
 * An immutable and sorted list of ( non - PK ) columns for a given table . 
 @ @ - 43 , 19 + 47 , 21 @ @ import org . apache . cassandra . utils . ByteBufferUtil ; 
 public class Columns implements Iterable < ColumnDefinition > 
 { 
 public static final Serializer serializer = new Serializer ( ) ; 
 - public static final Columns NONE = new Columns ( new ColumnDefinition [ 0 ] , 0 ) ; 
 + public static final Columns NONE = new Columns ( BTree . empty ( ) , 0 ) ; 
 + public static final ColumnDefinition FIRST _ COMPLEX = new ColumnDefinition ( " " , " " , ColumnIdentifier . getInterned ( ByteBufferUtil . EMPTY _ BYTE _ BUFFER , UTF8Type . instance ) , 
 + SetType . getInstance ( UTF8Type . instance , true ) , null , ColumnDefinition . Kind . REGULAR ) ; 
 
 - public final ColumnDefinition [ ] columns ; 
 - public final int complexIdx ; / / Index of the first complex column 
 + private final Object [ ] columns ; 
 + private final int complexIdx ; / / Index of the first complex column 
 
 - private Columns ( ColumnDefinition [ ] columns , int complexIdx ) 
 + private Columns ( Object [ ] columns , int complexIdx ) 
 { 
 - assert complexIdx < = columns . length ; 
 + assert complexIdx < = BTree . size ( columns ) ; 
 this . columns = columns ; 
 this . complexIdx = complexIdx ; 
 } 
 
 - private Columns ( ColumnDefinition [ ] columns ) 
 + private Columns ( Object [ ] columns ) 
 { 
 this ( columns , findFirstComplexIdx ( columns ) ) ; 
 } 
 @ @ - 69 , 30 + 75 , 28 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public static Columns of ( ColumnDefinition c ) 
 { 
 - ColumnDefinition [ ] columns = new ColumnDefinition [ ] { c } ; 
 - return new Columns ( columns , c . isComplex ( ) ? 0 : 1 ) ; 
 + return new Columns ( BTree . singleton ( c ) , c . isComplex ( ) ? 0 : 1 ) ; 
 } 
 
 / * * 
 * Returns a new { @ code Columns } object holing the same columns than the provided set . 
 * 
 - * @ param param s the set from which to create the new { @ code Columns } . 
 - * 
 + * @ param s the set from which to create the new { @ code Columns } . 
 * @ return the newly created { @ code Columns } containing the columns from { @ code s } . 
 * / 
 public static Columns from ( Set < ColumnDefinition > s ) 
 { 
 - ColumnDefinition [ ] columns = s . toArray ( new ColumnDefinition [ s . size ( ) ] ) ; 
 - Arrays . sort ( columns ) ; 
 - return new Columns ( columns , findFirstComplexIdx ( columns ) ) ; 
 + Object [ ] tree = BTree . < ColumnDefinition > builder ( Comparator . naturalOrder ( ) ) . addAll ( s ) . build ( ) ; 
 + return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; 
 } 
 
 - private static int findFirstComplexIdx ( ColumnDefinition [ ] columns ) 
 + private static int findFirstComplexIdx ( Object [ ] tree ) 
 { 
 - for ( int i = 0 ; i < columns . length ; i + + ) 
 - if ( columns [ i ] . isComplex ( ) ) 
 - return i ; 
 - return columns . length ; 
 + / / have fast path for common no - complex case 
 + int size = BTree . size ( tree ) ; 
 + if ( ! BTree . isEmpty ( tree ) & & BTree . < ColumnDefinition > findByIndex ( tree , size - 1 ) . isSimple ( ) ) 
 + return size ; 
 + return BTree . ceilIndex ( tree , Comparator . naturalOrder ( ) , FIRST _ COMPLEX ) ; 
 } 
 
 / * * 
 @ @ - 102 , 7 + 106 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public boolean isEmpty ( ) 
 { 
 - return columns . length = = 0 ; 
 + return BTree . isEmpty ( columns ) ; 
 } 
 
 / * * 
 @ @ - 122 , 7 + 126 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public int complexColumnCount ( ) 
 { 
 - return columns . length - complexIdx ; 
 + return BTree . size ( columns ) - complexIdx ; 
 } 
 
 / * * 
 @ @ - 132 , 7 + 136 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public int columnCount ( ) 
 { 
 - return columns . length ; 
 + return BTree . size ( columns ) ; 
 } 
 
 / * * 
 @ @ - 152 , 7 + 156 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public boolean hasComplex ( ) 
 { 
 - return complexIdx < columns . length ; 
 + return complexIdx < BTree . size ( columns ) ; 
 } 
 
 / * * 
 @ @ - 165 , 7 + 169 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public ColumnDefinition getSimple ( int i ) 
 { 
 - return columns [ i ] ; 
 + return BTree . findByIndex ( columns , i ) ; 
 } 
 
 / * * 
 @ @ - 178 , 7 + 182 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public ColumnDefinition getComplex ( int i ) 
 { 
 - return columns [ complexIdx + i ] ; 
 + return BTree . findByIndex ( columns , complexIdx + i ) ; 
 } 
 
 / * * 
 @ @ - 186 , 19 + 190 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * the provided column ) . 
 * 
 * @ param c the simple column for which to return the index of . 
 - * @ param from the index to start the search from . 
 * 
 * @ return the index for simple column { @ code c } if it is contains in this 
 - * object ( starting from index { @ code from } ) , { @ code - 1 } otherwise . 
 + * object 
 * / 
 - public int simpleIdx ( ColumnDefinition c , int from ) 
 + public int simpleIdx ( ColumnDefinition c ) 
 { 
 - assert ! c . isComplex ( ) ; 
 - for ( int i = from ; i < complexIdx ; i + + ) 
 - / / We know we only use " interned " ColumnIdentifier so = = is ok . 
 - if ( columns [ i ] . name = = c . name ) 
 - return i ; 
 - return - 1 ; 
 + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) ; 
 } 
 
 / * * 
 @ @ - 206 , 19 + 204 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * the provided column ) . 
 * 
 * @ param c the complex column for which to return the index of . 
 - * @ param from the index to start the search from . 
 * 
 * @ return the index for complex column { @ code c } if it is contains in this 
 - * object ( starting from index { @ code from } ) , { @ code - 1 } otherwise . 
 + * object 
 * / 
 - public int complexIdx ( ColumnDefinition c , int from ) 
 + public int complexIdx ( ColumnDefinition c ) 
 { 
 - assert c . isComplex ( ) ; 
 - for ( int i = complexIdx + from ; i < columns . length ; i + + ) 
 - / / We know we only use " interned " ColumnIdentifier so = = is ok . 
 - if ( columns [ i ] . name = = c . name ) 
 - return i - complexIdx ; 
 - return - 1 ; 
 + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) - complexIdx ; 
 } 
 
 / * * 
 @ @ - 230 , 30 + 222 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public boolean contains ( ColumnDefinition c ) 
 { 
 - return c . isComplex ( ) ? complexIdx ( c , 0 ) > = 0 : simpleIdx ( c , 0 ) > = 0 ; 
 - } 
 - 
 - / * * 
 - * Whether or not there is some counter columns within those columns . 
 - * 
 - * @ return whether or not there is some counter columns within those columns . 
 - * / 
 - public boolean hasCounters ( ) 
 - { 
 - for ( int i = 0 ; i < complexIdx ; i + + ) 
 - { 
 - if ( columns [ i ] . type . isCounter ( ) ) 
 - return true ; 
 - } 
 - 
 - for ( int i = complexIdx ; i < columns . length ; i + + ) 
 - { 
 - / / We only support counter in maps because that ' s all we need for now ( and we need it for the sake of thrift super columns of counter ) 
 - if ( columns [ i ] . type instanceof MapType & & ( ( ( MapType ) columns [ i ] . type ) . valueComparator ( ) . isCounter ( ) ) ) 
 - return true ; 
 - } 
 - 
 - return false ; 
 + return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) > = 0 ; 
 } 
 
 / * * 
 @ @ - 273 , 60 + 242 , 13 @ @ public class Columns implements Iterable < ColumnDefinition > 
 if ( this = = NONE ) 
 return other ; 
 
 - int i = 0 , j = 0 ; 
 - int size = 0 ; 
 - while ( i < columns . length & & j < other . columns . length ) 
 - { 
 - + + size ; 
 - int cmp = columns [ i ] . compareTo ( other . columns [ j ] ) ; 
 - if ( cmp = = 0 ) 
 - { 
 - + + i ; 
 - + + j ; 
 - } 
 - else if ( cmp < 0 ) 
 - { 
 - + + i ; 
 - } 
 - else 
 - { 
 - + + j ; 
 - } 
 - } 
 - 
 - / / If every element was always counted on both array , we have the same 
 - / / arrays for the first min elements 
 - if ( i = = size & & j = = size ) 
 - { 
 - / / We ' ve exited because of either c1 or c2 ( or both ) . The array that 
 - / / made us stop is thus a subset of the 2nd one , return that array . 
 - return i = = columns . length ? other : this ; 
 - } 
 + Object [ ] tree = BTree . < ColumnDefinition > merge ( this . columns , other . columns , Comparator . naturalOrder ( ) ) ; 
 + if ( tree = = this . columns ) 
 + return this ; 
 + if ( tree = = other . columns ) 
 + return other ; 
 
 - size + = i = = columns . length ? other . columns . length - j : columns . length - i ; 
 - ColumnDefinition [ ] result = new ColumnDefinition [ size ] ; 
 - i = 0 ; 
 - j = 0 ; 
 - for ( int k = 0 ; k < size ; k + + ) 
 - { 
 - int cmp = i > = columns . length ? 1 
 - : ( j > = other . columns . length ? - 1 : columns [ i ] . compareTo ( other . columns [ j ] ) ) ; 
 - if ( cmp = = 0 ) 
 - { 
 - result [ k ] = columns [ i ] ; 
 - + + i ; 
 - + + j ; 
 - } 
 - else if ( cmp < 0 ) 
 - { 
 - result [ k ] = columns [ i + + ] ; 
 - } 
 - else 
 - { 
 - result [ k ] = other . columns [ j + + ] ; 
 - } 
 - } 
 - return new Columns ( result , findFirstComplexIdx ( result ) ) ; 
 + return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; 
 } 
 
 / * * 
 @ @ - 341 , 20 + 263 , 10 @ @ public class Columns implements Iterable < ColumnDefinition > 
 if ( other . columns . length > columns . length ) 
 return false ; 
 
 - int j = 0 ; 
 - int cmp = 0 ; 
 - for ( ColumnDefinition def : other . columns ) 
 - { 
 - while ( j < columns . length & & ( cmp = columns [ j ] . compareTo ( def ) ) < 0 ) 
 - j + + ; 
 - 
 - if ( j > = columns . length | | cmp > 0 ) 
 + BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; 
 + for ( ColumnDefinition def : BTree . < ColumnDefinition > iterable ( other . columns ) ) 
 + if ( iter . next ( def ) = = null ) 
 return false ; 
 - 
 - / / cmp = = 0 , we ' ve found the definition . Ce can bump j once more since 
 - / / we know we won ' t need to compare that element again 
 - j + + ; 
 - } 
 return true ; 
 } 
 
 @ @ - 365 , 7 + 277 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public Iterator < ColumnDefinition > simpleColumns ( ) 
 { 
 - return new ColumnIterator ( 0 , complexIdx ) ; 
 + return BTree . iterator ( columns , 0 , complexIdx - 1 , BTree . Dir . ASC ) ; 
 } 
 
 / * * 
 @ @ - 375 , 7 + 287 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public Iterator < ColumnDefinition > complexColumns ( ) 
 { 
 - return new ColumnIterator ( complexIdx , columns . length ) ; 
 + return BTree . iterator ( columns , complexIdx , BTree . size ( columns ) - 1 , BTree . Dir . ASC ) ; 
 } 
 
 / * * 
 @ @ - 385 , 7 + 297 , 7 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public Iterator < ColumnDefinition > iterator ( ) 
 { 
 - return Iterators . forArray ( columns ) ; 
 + return BTree . iterator ( columns ) ; 
 } 
 
 / * * 
 @ @ - 399 , 23 + 311 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > 
 { 
 / / In wildcard selection , we want to return all columns in alphabetical order , 
 / / irregarding of whether they are complex or not 
 - return new AbstractIterator < ColumnDefinition > ( ) 
 - { 
 - private int regular ; 
 - private int complex = complexIdx ; 
 - 
 - protected ColumnDefinition computeNext ( ) 
 - { 
 - if ( complex > = columns . length ) 
 - return regular > = complexIdx ? endOfData ( ) : columns [ regular + + ] ; 
 - if ( regular > = complexIdx ) 
 - return columns [ complex + + ] ; 
 - 
 - return columns [ regular ] . name . compareTo ( columns [ complex ] . name ) < 0 
 - ? columns [ regular + + ] 
 - : columns [ complex + + ] ; 
 - } 
 - } ; 
 + return Iterators . < ColumnDefinition > mergeSorted ( ImmutableList . of ( simpleColumns ( ) , complexColumns ( ) ) , 
 + ( s , c ) - > s . name . compareTo ( c . name ) ) ; 
 } 
 
 / * * 
 @ @ - 428 , 15 + 325 , 10 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public Columns without ( ColumnDefinition column ) 
 { 
 - int idx = column . isComplex ( ) ? complexIdx ( column , 0 ) : simpleIdx ( column , 0 ) ; 
 - if ( idx < 0 ) 
 + if ( ! contains ( column ) ) 
 return this ; 
 
 - int realIdx = column . isComplex ( ) ? complexIdx + idx : idx ; 
 - 
 - ColumnDefinition [ ] newColumns = new ColumnDefinition [ columns . length - 1 ] ; 
 - System . arraycopy ( columns , 0 , newColumns , 0 , realIdx ) ; 
 - System . arraycopy ( columns , realIdx + 1 , newColumns , realIdx , newColumns . length - realIdx ) ; 
 + Object [ ] newColumns = BTree . < ColumnDefinition > transformAndFilter ( columns , ( c ) - > c . equals ( column ) ? null : c ) ; 
 return new Columns ( newColumns ) ; 
 } 
 
 @ @ - 448 , 24 + 340 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > 
 * / 
 public Predicate < ColumnDefinition > inOrderInclusionTester ( ) 
 { 
 - return new Predicate < ColumnDefinition > ( ) 
 - { 
 - private int i = 0 ; 
 - 
 - public boolean test ( ColumnDefinition column ) 
 - { 
 - while ( i < columns . length ) 
 - { 
 - int cmp = column . compareTo ( columns [ i ] ) ; 
 - if ( cmp < 0 ) 
 - return false ; 
 - i + + ; 
 - if ( cmp = = 0 ) 
 - return true ; 
 - } 
 - return false ; 
 - } 
 - } ; 
 + SearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; 
 + return column - > iter . next ( column ) ! = null ; 
 } 
 
 public void digest ( MessageDigest digest ) 
 @ @ - 477 , 17 + 353 , 19 @ @ public class Columns implements Iterable < ColumnDefinition > 
 @ Override 
 public boolean equals ( Object other ) 
 { 
 + if ( other = = this ) 
 + return true ; 
 if ( ! ( other instanceof Columns ) ) 
 return false ; 
 
 Columns that = ( Columns ) other ; 
 - return this . complexIdx = = that . complexIdx & & Arrays . equals ( this . columns , that . columns ) ; 
 + return this . complexIdx = = that . complexIdx & & BTree . equals ( this . columns , that . columns ) ; 
 } 
 
 @ Override 
 public int hashCode ( ) 
 { 
 - return Objects . hash ( complexIdx , Arrays . hashCode ( columns ) ) ; 
 + return Objects . hash ( complexIdx , BTree . hashCode ( columns ) ) ; 
 } 
 
 @ Override 
 @ @ - 503 , 25 + 381 , 6 @ @ public class Columns implements Iterable < ColumnDefinition > 
 return sb . toString ( ) ; 
 } 
 
 - private class ColumnIterator extends AbstractIterator < ColumnDefinition > 
 - { 
 - private final int to ; 
 - private int idx ; 
 - 
 - private ColumnIterator ( int from , int to ) 
 - { 
 - this . idx = from ; 
 - this . to = to ; 
 - } 
 - 
 - protected ColumnDefinition computeNext ( ) 
 - { 
 - if ( idx > = to ) 
 - return endOfData ( ) ; 
 - return columns [ idx + + ] ; 
 - } 
 - } 
 - 
 public static class Serializer 
 { 
 public void serialize ( Columns columns , DataOutputPlus out ) throws IOException 
 @ @ - 542 , 7 + 401 , 8 @ @ public class Columns implements Iterable < ColumnDefinition > 
 public Columns deserialize ( DataInputPlus in , CFMetaData metadata ) throws IOException 
 { 
 int length = ( int ) in . readVInt ( ) ; 
 - ColumnDefinition [ ] columns = new ColumnDefinition [ length ] ; 
 + BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; 
 + builder . auto ( false ) ; 
 for ( int i = 0 ; i < length ; i + + ) 
 { 
 ByteBuffer name = ByteBufferUtil . readWithVIntLength ( in ) ; 
 @ @ - 556 , 9 + 416 , 9 @ @ public class Columns implements Iterable < ColumnDefinition > 
 if ( column = = null ) 
 throw new RuntimeException ( " Unknown column " + UTF8Type . instance . getString ( name ) + " during deserialization " ) ; 
 } 
 - columns [ i ] = column ; 
 + builder . add ( column ) ; 
 } 
 - return new Columns ( columns ) ; 
 + return new Columns ( builder . build ( ) ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / view / MaterializedView . java b / src / java / org / apache / cassandra / db / view / MaterializedView . java 
 index 988bfc5 . . 06c4dc2 100644 
 - - - a / src / java / org / apache / cassandra / db / view / MaterializedView . java 
 + + + b / src / java / org / apache / cassandra / db / view / MaterializedView . java 
 @ @ - 666 , 7 + 666 , 7 @ @ public class MaterializedView 
 viewBuilder . addClusteringColumn ( ident , properties . getReversableType ( ident , column . type ) ) ; 
 } 
 
 - for ( ColumnDefinition column : baseCf . partitionColumns ( ) . regulars . columns ) 
 + for ( ColumnDefinition column : baseCf . partitionColumns ( ) . regulars ) 
 { 
 if ( column ! = nonPkTarget & & ( includeAll | | included . contains ( column ) ) ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / BTree . java b / src / java / org / apache / cassandra / utils / btree / BTree . java 
 index 62942b4 . . 353e7a5 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / BTree . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / BTree . java 
 @ @ - 669 , 7 + 669 , 18 @ @ public class BTree 
 
 public static boolean equals ( Object [ ] a , Object [ ] b ) 
 { 
 - return Iterators . elementsEqual ( iterator ( a ) , iterator ( b ) ) ; 
 + return size ( a ) = = size ( b ) & & Iterators . elementsEqual ( iterator ( a ) , iterator ( b ) ) ; 
 + } 
 + 
 + public static int hashCode ( Object [ ] btree ) 
 + { 
 + / / we can ' t just delegate to Arrays . deepHashCode ( ) , 
 + / / because two equivalent trees may be represented by differently shaped trees 
 + int result = 1 ; 
 + for ( Object v : iterable ( btree ) ) 
 + result = 31 * result + Objects . hashCode ( v ) ; 
 + return result ; 
 + 
 } 
 
 / * * 
 diff - - git a / test / unit / org / apache / cassandra / db / ColumnsTest . java b / test / unit / org / apache / cassandra / db / ColumnsTest . java 
 new file mode 100644 
 index 0000000 . . 5447fcc 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / ColumnsTest . java 
 @ @ - 0 , 0 + 1 , 244 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + package org . apache . cassandra . db ; 
 + 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . Iterator ; 
 + import java . util . List ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 + import java . util . function . Predicate ; 
 + 
 + import com . google . common . collect . Lists ; 
 + 
 + import org . junit . AfterClass ; 
 + import org . junit . Test ; 
 + 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . MockSchema ; 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . db . marshal . SetType ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . btree . BTreeSet ; 
 + 
 + public class ColumnsTest 
 + { 
 + 
 + private static CFMetaData cfMetaData = MockSchema . newCFS ( ) . metadata ; 
 + 
 + @ Test 
 + public void testContainsWithoutAndMergeTo ( ) 
 + { 
 + for ( RandomColumns randomColumns : random ( ) ) 
 + testContainsWithoutAndMergeTo ( randomColumns . columns , randomColumns . definitions ) ; 
 + } 
 + 
 + private void testContainsWithoutAndMergeTo ( Columns columns , List < ColumnDefinition > definitions ) 
 + { 
 + / / pick some arbitrary groupings of columns to remove at - once ( to avoid factorial complexity ) 
 + / / whatever is left after each removal , we perform this logic on again , recursively 
 + List < List < ColumnDefinition > > removeGroups = shuffleAndGroup ( Lists . newArrayList ( definitions ) ) ; 
 + for ( List < ColumnDefinition > defs : removeGroups ) 
 + { 
 + Columns subset = columns ; 
 + for ( ColumnDefinition def : defs ) 
 + subset = subset . without ( def ) ; 
 + Assert . assertEquals ( columns . columnCount ( ) - defs . size ( ) , subset . columnCount ( ) ) ; 
 + List < ColumnDefinition > remainingDefs = Lists . newArrayList ( columns ) ; 
 + remainingDefs . removeAll ( defs ) ; 
 + 
 + / / test contents after . without 
 + assertContents ( subset , remainingDefs ) ; 
 + 
 + / / test . contains 
 + assertSubset ( columns , subset ) ; 
 + 
 + / / test . mergeTo 
 + Columns otherSubset = columns ; 
 + for ( ColumnDefinition def : remainingDefs ) 
 + { 
 + otherSubset = otherSubset . without ( def ) ; 
 + assertContents ( otherSubset . mergeTo ( subset ) , definitions ) ; 
 + } 
 + 
 + testContainsWithoutAndMergeTo ( subset , remainingDefs ) ; 
 + } 
 + } 
 + 
 + private void assertSubset ( Columns superset , Columns subset ) 
 + { 
 + Assert . assertTrue ( superset . contains ( superset ) ) ; 
 + Assert . assertTrue ( superset . contains ( subset ) ) ; 
 + Assert . assertFalse ( subset . contains ( superset ) ) ; 
 + } 
 + 
 + private static void assertContents ( Columns columns , List < ColumnDefinition > defs ) 
 + { 
 + Assert . assertEquals ( defs , Lists . newArrayList ( columns ) ) ; 
 + boolean hasSimple = false , hasComplex = false ; 
 + int firstComplexIdx = 0 ; 
 + int i = 0 ; 
 + Iterator < ColumnDefinition > simple = columns . simpleColumns ( ) ; 
 + Iterator < ColumnDefinition > complex = columns . complexColumns ( ) ; 
 + Iterator < ColumnDefinition > all = columns . iterator ( ) ; 
 + Predicate < ColumnDefinition > predicate = columns . inOrderInclusionTester ( ) ; 
 + for ( ColumnDefinition def : defs ) 
 + { 
 + Assert . assertEquals ( def , all . next ( ) ) ; 
 + Assert . assertTrue ( columns . contains ( def ) ) ; 
 + Assert . assertTrue ( predicate . test ( def ) ) ; 
 + if ( def . isSimple ( ) ) 
 + { 
 + hasSimple = true ; 
 + Assert . assertEquals ( i , columns . simpleIdx ( def ) ) ; 
 + Assert . assertEquals ( def , simple . next ( ) ) ; 
 + + + firstComplexIdx ; 
 + } 
 + else 
 + { 
 + Assert . assertFalse ( simple . hasNext ( ) ) ; 
 + hasComplex = true ; 
 + Assert . assertEquals ( i - firstComplexIdx , columns . complexIdx ( def ) ) ; 
 + Assert . assertEquals ( def , complex . next ( ) ) ; 
 + } 
 + i + + ; 
 + } 
 + Assert . assertEquals ( defs . isEmpty ( ) , columns . isEmpty ( ) ) ; 
 + Assert . assertFalse ( simple . hasNext ( ) ) ; 
 + Assert . assertFalse ( complex . hasNext ( ) ) ; 
 + Assert . assertFalse ( all . hasNext ( ) ) ; 
 + Assert . assertEquals ( hasSimple , columns . hasSimple ( ) ) ; 
 + Assert . assertEquals ( hasComplex , columns . hasComplex ( ) ) ; 
 + } 
 + 
 + private static < V > List < List < V > > shuffleAndGroup ( List < V > list ) 
 + { 
 + / / first shuffle 
 + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; 
 + for ( int i = 0 ; i < list . size ( ) - 1 ; i + + ) 
 + { 
 + int j = random . nextInt ( i , list . size ( ) ) ; 
 + V v = list . get ( i ) ; 
 + list . set ( i , list . get ( j ) ) ; 
 + list . set ( j , v ) ; 
 + } 
 + 
 + / / then group 
 + List < List < V > > result = new ArrayList < > ( ) ; 
 + for ( int i = 0 ; i < list . size ( ) ; ) 
 + { 
 + List < V > group = new ArrayList < > ( ) ; 
 + int maxCount = list . size ( ) - i ; 
 + int count = maxCount < = 2 ? maxCount : random . nextInt ( 1 , maxCount ) ; 
 + for ( int j = 0 ; j < count ; j + + ) 
 + group . add ( list . get ( i + j ) ) ; 
 + i + = count ; 
 + result . add ( group ) ; 
 + } 
 + return result ; 
 + } 
 + 
 + @ AfterClass 
 + public static void cleanup ( ) 
 + { 
 + MockSchema . cleanup ( ) ; 
 + } 
 + 
 + private static class RandomColumns 
 + { 
 + final Columns columns ; 
 + final List < ColumnDefinition > definitions ; 
 + 
 + private RandomColumns ( List < ColumnDefinition > definitions ) 
 + { 
 + this . columns = Columns . from ( BTreeSet . of ( definitions ) ) ; 
 + this . definitions = definitions ; 
 + } 
 + } 
 + 
 + private static List < RandomColumns > random ( ) 
 + { 
 + List < RandomColumns > random = new ArrayList < > ( ) ; 
 + for ( int i = 1 ; i < = 3 ; i + + ) 
 + { 
 + random . add ( random ( i , i - 1 , i - 1 , i - 1 ) ) ; 
 + random . add ( random ( i - 1 , i , i - 1 , i - 1 ) ) ; 
 + random . add ( random ( i - 1 , i - 1 , i , i - 1 ) ) ; 
 + random . add ( random ( i - 1 , i - 1 , i - 1 , i ) ) ; 
 + } 
 + return random ; 
 + } 
 + 
 + private static RandomColumns random ( int pkCount , int clCount , int regularCount , int complexCount ) 
 + { 
 + List < Character > chars = new ArrayList < > ( ) ; 
 + for ( char c = ' a ' ; c < = ' z ' ; c + + ) 
 + chars . add ( c ) ; 
 + 
 + List < ColumnDefinition > result = new ArrayList < > ( ) ; 
 + addPartition ( select ( chars , pkCount ) , result ) ; 
 + addClustering ( select ( chars , clCount ) , result ) ; 
 + addRegular ( select ( chars , regularCount ) , result ) ; 
 + addComplex ( select ( chars , complexCount ) , result ) ; 
 + Collections . sort ( result ) ; 
 + return new RandomColumns ( result ) ; 
 + } 
 + 
 + private static List < Character > select ( List < Character > chars , int count ) 
 + { 
 + List < Character > result = new ArrayList < > ( ) ; 
 + ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; 
 + for ( int i = 0 ; i < count ; i + + ) 
 + { 
 + int v = random . nextInt ( chars . size ( ) ) ; 
 + result . add ( chars . get ( v ) ) ; 
 + chars . remove ( v ) ; 
 + } 
 + return result ; 
 + } 
 + 
 + private static void addPartition ( List < Character > chars , List < ColumnDefinition > results ) 
 + { 
 + addSimple ( ColumnDefinition . Kind . PARTITION _ KEY , chars , results ) ; 
 + } 
 + 
 + private static void addClustering ( List < Character > chars , List < ColumnDefinition > results ) 
 + { 
 + addSimple ( ColumnDefinition . Kind . CLUSTERING , chars , results ) ; 
 + } 
 + 
 + private static void addRegular ( List < Character > chars , List < ColumnDefinition > results ) 
 + { 
 + addSimple ( ColumnDefinition . Kind . REGULAR , chars , results ) ; 
 + } 
 + 
 + private static void addSimple ( ColumnDefinition . Kind kind , List < Character > chars , List < ColumnDefinition > results ) 
 + { 
 + for ( Character c : chars ) 
 + results . add ( new ColumnDefinition ( cfMetaData , ByteBufferUtil . bytes ( c . toString ( ) ) , UTF8Type . instance , null , kind ) ) ; 
 + } 
 + 
 + private static void addComplex ( List < Character > chars , List < ColumnDefinition > results ) 
 + { 
 + for ( Character c : chars ) 
 + results . add ( new ColumnDefinition ( cfMetaData , ByteBufferUtil . bytes ( c . toString ( ) ) , SetType . getInstance ( UTF8Type . instance , true ) , null , ColumnDefinition . Kind . REGULAR ) ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql / Cql . g b / src / java / org / apache / cassandra / cql / Cql . g 
 index 7fe56f8 . . 4b9aadc 100644 
 - - - a / src / java / org / apache / cassandra / cql / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql / Cql . g 
 @ @ - 65 , 30 + 65 , 19 @ @ useStatement returns [ String keyspace ] 
 selectStatement returns [ SelectStatement expr ] 
 : { 
 int numRecords = 10000 ; 
 - int numColumns = 10000 ; 
 - boolean reversed = false ; 
 ConsistencyLevel cLevel = ConsistencyLevel . ONE ; 
 } 
 - K _ SELECT K _ FROM ? IDENT 
 - ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? 
 - K _ WHERE selectExpression 
 - ( limit = ( K _ ROWLIMIT | K _ COLLIMIT ) value = INTEGER 
 - { 
 - int count = Integer . parseInt ( $ value . text ) ; 
 - if ( $ limit . type = = K _ ROWLIMIT ) 
 - numRecords = count ; 
 - else 
 - numColumns = count ; 
 - } 
 - ) * 
 - order = ( K _ ASC | K _ DESC { reversed = true ; } ) ? endStmnt 
 + K _ SELECT selectExpression K _ FROM columnFamily = IDENT 
 + ( K _ USING K _ CONSISTENCY ' . ' K _ LEVEL { cLevel = ConsistencyLevel . valueOf ( $ K _ LEVEL . text ) ; } ) ? 
 + ( K _ WHERE whereClause ) ? 
 + ( K _ LIMIT rows = INTEGER { numRecords = Integer . parseInt ( $ rows . text ) ; } ) ? 
 + endStmnt 
 { 
 - return new SelectStatement ( $ IDENT . text , 
 + return new SelectStatement ( $ selectExpression . expr , 
 + $ columnFamily . text , 
 cLevel , 
 - $ selectExpression . expr , 
 - numRecords , 
 - numColumns , 
 - reversed ) ; 
 + $ whereClause . clause , 
 + numRecords ) ; 
 } 
 ; 
 
 @ @ - 116 , 16 + 105 , 32 @ @ term returns [ Term item ] 
 { $ item = new Term ( $ t . text , $ t . type ) ; } 
 ; 
 
 - / / Note : slices are inclusive so > = and > , and < and < = all have the same semantics . 
 + / / Note : ranges are inclusive so > = and > , and < and < = all have the same semantics . 
 relation returns [ Relation rel ] 
 - : kind = ( K _ KEY | K _ COLUMN ) type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term 
 - { return new Relation ( $ kind . text , $ type . text , $ t . item ) ; } 
 + : { Term entity = new Term ( " KEY " , STRING _ LITERAL ) ; } 
 + ( K _ KEY | name = term { entity = $ name . item ; } ) type = ( ' = ' | ' < ' | ' < = ' | ' > = ' | ' > ' ) t = term 
 + { return new Relation ( entity , $ type . text , $ t . item ) ; } 
 ; 
 
 / / relation [ [ AND relation ] . . . ] 
 + whereClause returns [ WhereClause clause ] 
 + : first = relation { $ clause = new WhereClause ( first ) ; } 
 + ( K _ AND next = relation { $ clause . and ( next ) ; } ) * 
 + ; 
 + 
 + / / [ FIRST n ] [ REVERSED ] name1 [ [ [ , name2 ] , nameN ] , . . . ] 
 + / / [ FIRST n ] [ REVERSED ] name1 . . nameN 
 selectExpression returns [ SelectExpression expr ] 
 - : first = relation { $ expr = new SelectExpression ( first ) ; } 
 - ( K _ AND next = relation { $ expr . and ( next ) ; } ) * 
 + : { 
 + int count = 10000 ; 
 + boolean reversed = false ; 
 + } 
 + ( K _ FIRST cols = INTEGER { count = Integer . parseInt ( $ cols . text ) ; } ) ? 
 + ( K _ REVERSED { reversed = true ; } ) ? 
 + ( first = term { $ expr = new SelectExpression ( first , count , reversed ) ; } 
 + ( ' , ' next = term { $ expr . and ( next ) ; } ) * 
 + | start = term ' . . ' finish = term { $ expr = new SelectExpression ( start , finish , count , reversed ) ; } 
 + ) 
 ; 
 
 columnDef returns [ Column column ] 
 @ @ - 151 , 14 + 156 , 10 @ @ K _ COLUMN : C O L ( U M N ) ? ; 
 K _ UPDATE : U P D A T E ; 
 K _ WITH : W I T H ; 
 K _ ROW : R O W ; 
 - K _ ROWLIMIT : R O W L I M I T ; 
 - K _ COLLIMIT : C O L L I M I T ; 
 - K _ ASC : A S C ( E N D I N G ) ? ; 
 - K _ DESC : D E S C ( E N D I N G ) ? ; 
 + K _ LIMIT : L I M I T ; 
 K _ USING : U S I N G ; 
 K _ CONSISTENCY : C O N S I S T E N C Y ; 
 - K _ LEVEL : ( Z E R O 
 - | O N E 
 + K _ LEVEL : ( O N E 
 | Q U O R U M 
 | A L L 
 | D C Q U O R U M 
 @ @ - 166 , 6 + 167 , 8 @ @ K _ LEVEL : ( Z E R O 
 ) 
 ; 
 K _ USE : U S E ; 
 + K _ FIRST : F I R S T ; 
 + K _ REVERSED : R E V E R S E D ; 
 
 / / Case - insensitive alpha characters 
 fragment A : ( ' a ' | ' A ' ) ; 
 diff - - git a / src / java / org / apache / cassandra / cql / QueryProcessor . java b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 index 9fabff3 . . bf21098 100644 
 - - - a / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql / QueryProcessor . java 
 @ @ - 65 , 38 + 65 , 37 @ @ public class QueryProcessor 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( QueryProcessor . class ) ; 
 
 - private static List < org . apache . cassandra . db . Row > multiSlice ( String keyspace , SelectStatement select ) 
 + private static List < org . apache . cassandra . db . Row > getSlice ( String keyspace , SelectStatement select ) 
 throws InvalidRequestException , TimedOutException , UnavailableException 
 { 
 List < org . apache . cassandra . db . Row > rows = null ; 
 QueryPath queryPath = new QueryPath ( select . getColumnFamily ( ) ) ; 
 List < ReadCommand > commands = new ArrayList < ReadCommand > ( ) ; 
 
 - for ( Term keyName : select . getKeyPredicates ( ) . getTerms ( ) ) 
 + assert select . getKeys ( ) . size ( ) = = 1 ; 
 + 
 + ByteBuffer key = select . getKeys ( ) . get ( 0 ) . getByteBuffer ( ) ; 
 + validateKey ( key ) ; 
 + 
 + / / . . . of a list of column names 
 + if ( ! select . isColumnRange ( ) ) 
 { 
 - ByteBuffer key = keyName . getByteBuffer ( ) ; 
 - validateKey ( key ) ; 
 + Collection < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; 
 + for ( Term column : select . getColumnNames ( ) ) 
 + columnNames . add ( column . getByteBuffer ( ) ) ; 
 
 - / / . . . of a list of column names 
 - if ( ( ! select . getColumnPredicates ( ) . isRange ( ) ) & & select . getColumnPredicates ( ) . isInitialized ( ) ) 
 - { 
 - Collection < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; 
 - for ( Term column : select . getColumnPredicates ( ) . getTerms ( ) ) 
 - columnNames . add ( column . getByteBuffer ( ) ) ; 
 - 
 - commands . add ( new SliceByNamesReadCommand ( keyspace , key , queryPath , columnNames ) ) ; 
 - } 
 - / / . . . a range ( slice ) of column names 
 - else 
 - { 
 - commands . add ( new SliceFromReadCommand ( keyspace , 
 - key , 
 - queryPath , 
 - select . getColumnPredicates ( ) . getStart ( ) . getByteBuffer ( ) , 
 - select . getColumnPredicates ( ) . getFinish ( ) . getByteBuffer ( ) , 
 - select . reversed ( ) , 
 - select . getNumColumns ( ) ) ) ; 
 - } 
 + commands . add ( new SliceByNamesReadCommand ( keyspace , key , queryPath , columnNames ) ) ; 
 + } 
 + / / . . . a range ( slice ) of column names 
 + else 
 + { 
 + commands . add ( new SliceFromReadCommand ( keyspace , 
 + key , 
 + queryPath , 
 + select . getColumnStart ( ) . getByteBuffer ( ) , 
 + select . getColumnFinish ( ) . getByteBuffer ( ) , 
 + select . isColumnsReversed ( ) , 
 + select . getColumnsLimit ( ) ) ) ; 
 } 
 
 try 
 @ @ - 135 , 24 + 134 , 25 @ @ public class QueryProcessor 
 / / FIXME : ranges can be open - ended , but a start must exist . Assert so here . 
 
 IPartitioner < ? > p = StorageService . getPartitioner ( ) ; 
 - AbstractBounds bounds = new Bounds ( p . getToken ( select . getKeyPredicates ( ) . getStart ( ) . getByteBuffer ( ) ) , 
 - p . getToken ( select . getKeyPredicates ( ) . getFinish ( ) . getByteBuffer ( ) ) ) ; 
 + AbstractBounds bounds = new Bounds ( p . getToken ( select . getKeyStart ( ) . getByteBuffer ( ) ) , 
 + p . getToken ( select . getKeyFinish ( ) . getByteBuffer ( ) ) ) ; 
 + 
 
 / / XXX : Our use of Thrift structs internally makes me Sad . : ( 
 SlicePredicate thriftSlicePredicate = new SlicePredicate ( ) ; 
 - if ( select . getColumnPredicates ( ) . isRange ( ) | | select . getColumnPredicates ( ) . getTerms ( ) . size ( ) = = 0 ) 
 + if ( select . isColumnRange ( ) | | select . getColumnNames ( ) . size ( ) = = 0 ) 
 { 
 SliceRange sliceRange = new SliceRange ( ) ; 
 - sliceRange . start = select . getColumnPredicates ( ) . getStart ( ) . getByteBuffer ( ) ; 
 - sliceRange . finish = select . getColumnPredicates ( ) . getFinish ( ) . getByteBuffer ( ) ; 
 + sliceRange . start = select . getColumnStart ( ) . getByteBuffer ( ) ; 
 + sliceRange . finish = select . getColumnFinish ( ) . getByteBuffer ( ) ; 
 sliceRange . reversed = false ; / / FIXME : hard - coded 
 - sliceRange . count = select . getNumColumns ( ) ; 
 + sliceRange . count = select . getColumnsLimit ( ) ; 
 thriftSlicePredicate . slice _ range = sliceRange ; 
 } 
 else 
 { 
 List < ByteBuffer > columnNames = new ArrayList < ByteBuffer > ( ) ; 
 - for ( Term column : select . getColumnPredicates ( ) . getTerms ( ) ) 
 + for ( Term column : select . getColumnNames ( ) ) 
 columnNames . add ( column . getByteBuffer ( ) ) ; 
 thriftSlicePredicate . column _ names = columnNames ; 
 } 
 @ @ - 204 , 10 + 204 , 31 @ @ public class QueryProcessor 
 avroResult . type = CqlResultType . ROWS ; 
 List < org . apache . cassandra . db . Row > rows = null ; 
 
 - if ( ! select . getKeyPredicates ( ) . isRange ( ) ) 
 - rows = multiSlice ( keyspace , select ) ; 
 + if ( ! select . isKeyRange ( ) & & ( select . getKeys ( ) . size ( ) > 0 ) ) 
 + { 
 + / / Multiple keys ( aka " multiget " ) is not allowed ( any longer ) . 
 + if ( select . getKeys ( ) . size ( ) > 1 ) 
 + { 
 + InvalidRequestException invalidRequest = new InvalidRequestException ( ) ; 
 + invalidRequest . why = " SELECTs can contain only one by - key clause ( i . e . KEY = TERM ) " ; 
 + throw invalidRequest ; 
 + } 
 + 
 + rows = getSlice ( keyspace , select ) ; 
 + } 
 else 
 + { 
 + / / Combining key ranges and column index queries is not currently allowed 
 + if ( select . getColumnRelations ( ) . size ( ) > 0 ) 
 + { 
 + InvalidRequestException invalidRequest = new InvalidRequestException ( ) ; 
 + invalidRequest . why = " You cannot combine key ranges and by - column clauses " + 
 + 	 	 " ( i . e . \ " name \ " = \ " value \ " ) in a SELECT statement " ; 
 + throw invalidRequest ; 
 + } 
 + 
 rows = multiRangeSlice ( keyspace , select ) ; 
 + } 
 
 / / Create the result set 
 for ( org . apache . cassandra . db . Row row : rows ) 
 diff - - git a / src / java / org / apache / cassandra / cql / Relation . java b / src / java / org / apache / cassandra / cql / Relation . java 
 index cd3d234 . . bddd320 100644 
 - - - a / src / java / org / apache / cassandra / cql / Relation . java 
 + + + b / src / java / org / apache / cassandra / cql / Relation . java 
 @ @ - 22 , 14 + 22 , 15 @ @ package org . apache . cassandra . cql ; 
 
 / * * 
 * Relations encapsulate the relationship between an entity of some kind , and 
 - * a value ( term ) . For example , KEY > ' start ' or COLUMN = 1000L . 
 + * a value ( term ) . For example , KEY > " start " or " colname1 " = " somevalue " . 
 * 
 * / 
 public class Relation 
 { 
 - public Entity entity = Entity . COLUMN ; 
 - public RelationType type ; 
 - public Term value ; 
 + public EntityType entityType = EntityType . COLUMN ; 
 + public Term entity ; 
 + private RelationType relationType ; 
 + private Term value ; 
 
 / * * 
 * Creates a new relation . 
 @ @ - 38 , 27 + 39 , 38 @ @ public class Relation 
 * @ param type the type that describes how this entity relates to the value . 
 * @ param value the value being compared . 
 * / 
 - public Relation ( String entity , String type , Term value ) 
 + public Relation ( Term entity , String type , Term value ) 
 { 
 - if ( entity . toUpperCase ( ) . equals ( " KEY " ) ) 
 - this . entity = Entity . KEY ; 
 + if ( entity . getText ( ) . toUpperCase ( ) . equals ( " KEY " ) ) 
 + this . entityType = EntityType . KEY ; 
 
 - this . type = RelationType . forString ( type ) ; 
 + this . entity = entity ; 
 + this . relationType = RelationType . forString ( type ) ; 
 this . value = value ; 
 } 
 
 public boolean isKey ( ) 
 { 
 - return entity . equals ( Entity . KEY ) ; 
 + return entityType . equals ( EntityType . KEY ) ; 
 } 
 
 public boolean isColumn ( ) 
 { 
 - return entity . equals ( Entity . COLUMN ) ; 
 + return entityType . equals ( EntityType . COLUMN ) ; 
 + } 
 + 
 + public RelationType operator ( ) 
 + { 
 + return relationType ; 
 + } 
 + 
 + public Term getValue ( ) 
 + { 
 + return value ; 
 } 
 } 
 
 - enum Entity 
 + enum EntityType 
 { 
 KEY , COLUMN ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql / SelectExpression . java b / src / java / org / apache / cassandra / cql / SelectExpression . java 
 index 8676d48 . . 562d27d 100644 
 - - - a / src / java / org / apache / cassandra / cql / SelectExpression . java 
 + + + b / src / java / org / apache / cassandra / cql / SelectExpression . java 
 @ @ - 1 , 4 + 1 , 3 @ @ 
 - package org . apache . cassandra . cql ; 
 / * 
 * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 @ @ - 19 , 122 + 18 , 111 @ @ package org . apache . cassandra . cql ; 
 * under the License . 
 * 
 * / 
 - 
 + package org . apache . cassandra . cql ; 
 
 import java . util . ArrayList ; 
 import java . util . List ; 
 
 / * * 
 - * SelectExpressions encapsulate all of the predicates of a SELECT query . 
 + * Select expressions are analogous to the projection in a SQL query . They 
 + * determine which columns will appear in the result set . SelectExpression 
 + * instances encapsulate a parsed expression from a < code > SELECT < / code > 
 + * statement . 
 * 
 - * @ author eevans 
 - * 
 + * See : doc / cql / CQL . html # SpecifyingColumns 
 * / 
 public class SelectExpression 
 { 
 - private Predicates keys = new Predicates ( ) ; 
 - private Predicates columns = new Predicates ( ) ; 
 + public static final int MAX _ COLUMNS _ DEFAULT = 10000 ; 
 
 - public SelectExpression ( Relation firstRelation ) 
 + private int numColumns = MAX _ COLUMNS _ DEFAULT ; 
 + private boolean reverseColumns = false ; 
 + private Term start , finish ; 
 + private List < Term > columns ; 
 + 
 + / * * 
 + * Create a new SelectExpression for a range ( slice ) of columns . 
 + * 
 + * @ param start the starting column name 
 + * @ param finish the finishing column name 
 + * @ param count the number of columns to limit the results to 
 + * @ param reverse true to reverse column order 
 + * / 
 + public SelectExpression ( Term start , Term finish , int count , boolean reverse ) 
 { 
 - and ( firstRelation ) ; 
 + this . start = start ; 
 + this . finish = finish ; 
 + numColumns = count ; 
 + reverseColumns = reverse ; 
 } 
 
 - public void and ( Relation relation ) 
 + / * * 
 + * Create a new SelectExpression for a list of columns . 
 + * 
 + * @ param first the first ( possibly only ) column name to select on . 
 + * @ param count the number of columns to limit the results on 
 + * @ param reverse true to reverse column order 
 + * / 
 + public SelectExpression ( Term first , int count , boolean reverse ) 
 { 
 - if ( relation . isKey ( ) ) 
 - { 
 - if ( relation . type . equals ( RelationType . EQ ) ) 
 - keys . addTerm ( relation . value ) ; 
 - else if ( ( relation . type . equals ( RelationType . GT ) | | relation . type . equals ( RelationType . GTE ) ) ) 
 - keys . setStart ( relation . value ) ; 
 - else if ( ( relation . type . equals ( RelationType . LT ) | | relation . type . equals ( RelationType . LTE ) ) ) 
 - keys . setFinish ( relation . value ) ; 
 - } 
 - else / / It ' s a column 
 - { 
 - if ( relation . type . equals ( RelationType . EQ ) ) 
 - columns . addTerm ( relation . value ) ; 
 - else if ( ( relation . type . equals ( RelationType . GT ) | | relation . type . equals ( RelationType . GTE ) ) ) 
 - columns . setStart ( relation . value ) ; 
 - else if ( ( relation . type . equals ( RelationType . LT ) | | relation . type . equals ( RelationType . LTE ) ) ) 
 - columns . setFinish ( relation . value ) ; 
 - } 
 + columns = new ArrayList < Term > ( ) ; 
 + columns . add ( first ) ; 
 + numColumns = count ; 
 + reverseColumns = reverse ; 
 } 
 
 - public Predicates getKeyPredicates ( ) 
 + / * * 
 + * Add an additional column name to a SelectExpression . 
 + * 
 + * @ param addTerm 
 + * / 
 + public void and ( Term addTerm ) 
 { 
 - return keys ; 
 + assert ! isColumnRange ( ) ; / / Not possible when invoked by parser 
 + columns . add ( addTerm ) ; 
 } 
 
 - public Predicates getColumnPredicates ( ) 
 + public boolean isColumnRange ( ) 
 { 
 - return columns ; 
 + return ( start ! = null ) ; 
 } 
 - } 
 - 
 - class Predicates 
 - { 
 - private boolean initialized = false ; 
 - private List < Term > names = new ArrayList < Term > ( ) ; 
 - private Term start , finish ; 
 - private boolean isRange = false ; 
 
 - Term getStart ( ) 
 + public boolean isColumnList ( ) 
 { 
 - return start = = null ? new Term ( ) : start ; 
 + return ! isColumnRange ( ) ; 
 } 
 - 
 - void setStart ( Term start ) 
 + public int getColumnsLimit ( ) 
 { 
 - / / FIXME : propagate a proper exception 
 - if ( initialized & & ( ! isRange ( ) ) ) 
 - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; 
 - 
 - initialized = true ; 
 - isRange = true ; 
 - this . start = start ; 
 + return numColumns ; 
 } 
 - 
 - Term getFinish ( ) 
 + 
 + public boolean isColumnsReversed ( ) 
 { 
 - return finish = = null ? new Term ( ) : finish ; 
 + return reverseColumns ; 
 } 
 
 - void setFinish ( Term finish ) 
 + public void setColumnsReversed ( boolean reversed ) 
 { 
 - / / FIXME : propagate a proper exception 
 - if ( initialized & & ( ! isRange ( ) ) ) 
 - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; 
 - 
 - initialized = true ; 
 - isRange = true ; 
 - this . finish = finish ; 
 + reverseColumns = reversed ; 
 } 
 
 - List < Term > getTerms ( ) 
 + public void setColumnsLimit ( int limit ) 
 { 
 - return names ; 
 + numColumns = limit ; 
 } 
 - 
 - void addTerm ( Term name ) 
 + 
 + public Term getStart ( ) 
 { 
 - / / FIXME : propagate a proper exception 
 - if ( initialized & & ( isRange ( ) ) ) 
 - throw new RuntimeException ( " You cannot combine discreet names and range operators . " ) ; 
 - 
 - initialized = true ; 
 - isRange = false ; 
 - names . add ( name ) ; 
 + return start ; 
 } 
 - 
 - boolean isRange ( ) 
 + 
 + public Term getFinish ( ) 
 { 
 - return isRange ; 
 + return finish ; 
 } 
 
 - boolean isInitialized ( ) 
 + public List < Term > getColumns ( ) 
 { 
 - return initialized ; 
 + return columns ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql / SelectStatement . java b / src / java / org / apache / cassandra / cql / SelectStatement . java 
 index 24cb6bd . . 884f0cb 100644 
 - - - a / src / java / org / apache / cassandra / cql / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql / SelectStatement . java 
 @ @ - 20 , 6 + 20 , 8 @ @ 
 * / 
 package org . apache . cassandra . cql ; 
 
 + import java . util . List ; 
 + 
 import org . apache . cassandra . thrift . ConsistencyLevel ; 
 
 / * * 
 @ @ - 29 , 32 + 31 , 65 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; 
 * / 
 public class SelectStatement 
 { 
 + private final SelectExpression expression ; 
 private final String columnFamily ; 
 private final ConsistencyLevel cLevel ; 
 - private final SelectExpression expression ; 
 + private final WhereClause clause ; 
 private final int numRecords ; 
 - private final int numColumns ; 
 - private final boolean reverse ; 
 
 - public SelectStatement ( String columnFamily , ConsistencyLevel cLevel , SelectExpression expression , 
 - int numRecords , int numColumns , boolean reverse ) 
 + public SelectStatement ( SelectExpression expression , String columnFamily , ConsistencyLevel cLevel , 
 + WhereClause clause , int numRecords ) 
 { 
 + this . expression = expression ; 
 this . columnFamily = columnFamily ; 
 this . cLevel = cLevel ; 
 - this . expression = expression ; 
 + this . clause = clause ; 
 this . numRecords = numRecords ; 
 - this . numColumns = numColumns ; 
 - this . reverse = reverse ; 
 } 
 
 - public Predicates getKeyPredicates ( ) 
 + public boolean isKeyRange ( ) 
 + { 
 + return clause . isKeyRange ( ) ; 
 + } 
 + 
 + public List < Term > getKeys ( ) 
 + { 
 + return clause . getKeys ( ) ; 
 + } 
 + 
 + public Term getKeyStart ( ) 
 + { 
 + return clause . getStartKey ( ) ; 
 + } 
 + 
 + public Term getKeyFinish ( ) 
 + { 
 + return clause . getFinishKey ( ) ; 
 + } 
 + 
 + public List < Relation > getColumnRelations ( ) 
 + { 
 + return clause . getColumnRelations ( ) ; 
 + } 
 + 
 + public boolean isColumnRange ( ) 
 + { 
 + return expression . isColumnRange ( ) ; 
 + } 
 + 
 + public List < Term > getColumnNames ( ) 
 + { 
 + return expression . getColumns ( ) ; 
 + } 
 + 
 + public Term getColumnStart ( ) 
 { 
 - return expression . getKeyPredicates ( ) ; 
 + return expression . getStart ( ) ; 
 } 
 
 - public Predicates getColumnPredicates ( ) 
 + public Term getColumnFinish ( ) 
 { 
 - return expression . getColumnPredicates ( ) ; 
 + return expression . getFinish ( ) ; 
 } 
 
 public String getColumnFamily ( ) 
 @ @ - 62 , 9 + 97 , 9 @ @ public class SelectStatement 
 return columnFamily ; 
 } 
 
 - public boolean reversed ( ) 
 + public boolean isColumnsReversed ( ) 
 { 
 - return reverse ; 
 + return expression . isColumnsReversed ( ) ; 
 } 
 
 public ConsistencyLevel getConsistencyLevel ( ) 
 @ @ - 77 , 8 + 112 , 8 @ @ public class SelectStatement 
 return numRecords ; 
 } 
 
 - public int getNumColumns ( ) 
 + public int getColumnsLimit ( ) 
 { 
 - return numColumns ; 
 + return expression . getColumnsLimit ( ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql / WhereClause . java b / src / java / org / apache / cassandra / cql / WhereClause . java 
 new file mode 100644 
 index 0000000 . . 75418c3 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql / WhereClause . java 
 @ @ - 0 , 0 + 1 , 102 @ @ 
 + package org . apache . cassandra . cql ; 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + 
 + import java . util . ArrayList ; 
 + import java . util . List ; 
 + 
 + / * * 
 + * WhereClauses encapsulate all of the predicates of a SELECT query . 
 + * 
 + * / 
 + public class WhereClause 
 + { 
 + private List < Term > keys = new ArrayList < Term > ( ) ; 
 + private Term startKey , finishKey ; 
 + private List < Relation > columns = new ArrayList < Relation > ( ) ; 
 + 
 + / * * 
 + * Create a new WhereClause with the first parsed relation . 
 + * 
 + * @ param firstRelation key or column relation 
 + * / 
 + public WhereClause ( Relation firstRelation ) 
 + { 
 + and ( firstRelation ) ; 
 + } 
 + 
 + public WhereClause ( ) 
 + { 
 + 
 + } 
 + 
 + / * * 
 + * Add an additional relation to this WHERE clause . 
 + * 
 + * @ param relation the relation to add . 
 + * / 
 + public void and ( Relation relation ) 
 + { 
 + if ( relation . isKey ( ) ) 
 + { 
 + if ( relation . operator ( ) . equals ( RelationType . EQ ) ) 
 + keys . add ( relation . getValue ( ) ) ; 
 + else if ( ( relation . operator ( ) . equals ( RelationType . GT ) | | relation . operator ( ) . equals ( RelationType . GTE ) ) ) 
 + startKey = relation . getValue ( ) ; 
 + else if ( ( relation . operator ( ) . equals ( RelationType . LT ) | | relation . operator ( ) . equals ( RelationType . LTE ) ) ) 
 + finishKey = relation . getValue ( ) ; 
 + 
 + } 
 + else 
 + columns . add ( relation ) ; 
 + } 
 + 
 + public List < Relation > getColumnRelations ( ) 
 + { 
 + return columns ; 
 + } 
 + 
 + public boolean isKeyRange ( ) 
 + { 
 + return startKey ! = null ; 
 + } 
 + 
 + public boolean isKeyList ( ) 
 + { 
 + return ! isKeyRange ( ) ; 
 + } 
 + 
 + public Term getStartKey ( ) 
 + { 
 + return startKey ; 
 + } 
 + 
 + public Term getFinishKey ( ) 
 + { 
 + return finishKey ; 
 + } 
 + 
 + public List < Term > getKeys ( ) 
 + { 
 + return keys ; 
 + } 
 + } 
 diff - - git a / test / system / test _ cql . py b / test / system / test _ cql . py 
 index 04a0ad5 . . d6ffb6d 100644 
 - - - a / test / system / test _ cql . py 
 + + + b / test / system / test _ cql . py 
 @ @ - 39 , 7 + 39 , 7 @ @ class TestCql ( AvroTester ) : 
 def test _ select _ simple ( self ) : 
 " retrieve a column " 
 conn = init ( ) 
 - r = conn . execute ( ' SELECT FROM Standard1 WHERE KEY = " ka " AND COL = " ca1 " ' ) 
 + r = conn . execute ( ' SELECT " ca1 " FROM Standard1 WHERE KEY = " ka " ' ) 
 assert r [ 0 ] [ ' key ' ] = = ' ka ' 
 assert r [ 0 ] [ ' columns ' ] [ 0 ] [ ' name ' ] = = ' ca1 ' 
 assert r [ 0 ] [ ' columns ' ] [ 0 ] [ ' value ' ] = = ' va1 ' 
 @ @ - 48 , 42 + 48 , 14 @ @ class TestCql ( AvroTester ) : 
 " retrieve multiple columns " 
 conn = init ( ) 
 r = conn . execute ( " " " 
 - SELECT FROM Standard1 WHERE KEY = " kd " AND COLUMN = " cd1 " 
 - AND COLUMN = " col " 
 + SELECT " cd1 " , " col " FROM Standard1 WHERE KEY = " kd " 
 " " " ) 
 assert " cd1 " in [ i [ ' name ' ] for i in r [ 0 ] [ ' columns ' ] ] 
 assert " col " in [ i [ ' name ' ] for i in r [ 0 ] [ ' columns ' ] ] 
 
 - def test _ select _ rows _ columns ( self ) : 
 - " fetch multiple rows and columns " 
 - conn = init ( ) 
 - r = conn . execute ( " " " 
 - SELECT FROM 
 - Standard1 
 - WHERE 
 - KEY = " ka " AND KEY = " kd " AND COLUMN = " col " ; 
 - " " " ) 
 - for result in r : 
 - assert result [ ' key ' ] in ( " ka " , " kd " ) 
 - assert result [ ' columns ' ] [ 0 ] [ ' name ' ] = = " col " 
 - assert result [ ' columns ' ] [ 0 ] [ ' value ' ] = = " val " 
 - 
 - def test _ select _ rows ( self ) : 
 - " fetch multiple rows , all columns " 
 - conn = init ( ) 
 - r = conn . execute ( " " " 
 - SELECT FROM 
 - Standard1 
 - WHERE 
 - KEY = " ka " AND KEY = " kd " AND KEY = " kb " 
 - " " " ) 
 - for result in r : 
 - assert result [ ' key ' ] in ( " ka " , " kd " , " kb " ) 
 - assert len ( result [ ' columns ' ] ) = = 2 
 - 
 def test _ select _ row _ range ( self ) : 
 " retrieve a range of rows with columns " 
 conn = init ( ) 
 r = conn . execute ( " " " 
 - SELECT FROM StandardLong1 WHERE KEY > " ad " AND KEY < " ag " ; 
 + SELECT " col1 " FROM StandardLong1 WHERE KEY > " ad " AND KEY < " ag " ; 
 " " " )
