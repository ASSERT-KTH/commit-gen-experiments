BLEU SCORE: 0.029381754016308166

TEST MSG: SSTableScanner enforces its bounds
GENERATED MSG: ghetto - merge from cassandra 1 . 2

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 2af8df6 . . 36bdb39 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 4 <nl> + * SSTableScanner enforces its bounds ( CASSANDRA - 8946 ) <nl> * Cleanup cell equality ( CASSANDRA - 8947 ) <nl> * Introduce intra - cluster message coalescing ( CASSANDRA - 8692 ) <nl> * DatabaseDescriptor throws NPE when rpc _ interface is used ( CASSANDRA - 8839 ) <nl> diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> index 90eb6b5 . . 6d2ee43 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> @ @ - 68 , 6 + 68 , 8 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> * instead . <nl> * / <nl> public abstract Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) ; <nl> + public abstract boolean inclusiveLeft ( ) ; <nl> + public abstract boolean inclusiveRight ( ) ; <nl> <nl> @ Override <nl> public int hashCode ( ) <nl> @ @ - 193 , 4 + 195 , 76 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> return size ; <nl> } <nl> } <nl> + <nl> + public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( Boundary < T > min , Boundary < T > max ) <nl> + { <nl> + return bounds ( min . boundary , min . inclusive , max . boundary , max . inclusive ) ; <nl> + } <nl> + public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( T min , boolean inclusiveMin , T max , boolean inclusiveMax ) <nl> + { <nl> + if ( inclusiveMin & & inclusiveMax ) <nl> + return new Bounds < T > ( min , max ) ; <nl> + else if ( inclusiveMax ) <nl> + return new Range < T > ( min , max ) ; <nl> + else if ( inclusiveMin ) <nl> + return new IncludingExcludingBounds < T > ( min , max ) ; <nl> + else <nl> + return new ExcludingBounds < T > ( min , max ) ; <nl> + } <nl> + <nl> + / / represents one side of a bounds ( which side is not encoded ) <nl> + public static class Boundary < T extends RingPosition < T > > <nl> + { <nl> + public final T boundary ; <nl> + public final boolean inclusive ; <nl> + public Boundary ( T boundary , boolean inclusive ) <nl> + { <nl> + this . boundary = boundary ; <nl> + this . inclusive = inclusive ; <nl> + } <nl> + } <nl> + <nl> + public Boundary < T > leftBoundary ( ) <nl> + { <nl> + return new Boundary < > ( left , inclusiveLeft ( ) ) ; <nl> + } <nl> + <nl> + public Boundary < T > rightBoundary ( ) <nl> + { <nl> + return new Boundary < > ( right , inclusiveRight ( ) ) ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > boolean isEmpty ( Boundary < T > left , Boundary < T > right ) <nl> + { <nl> + int c = left . boundary . compareTo ( right . boundary ) ; <nl> + return c > 0 | | ( c = = 0 & & ! ( left . inclusive & & right . inclusive ) ) ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , T right2 , boolean isInclusiveRight2 ) <nl> + { <nl> + return minRight ( right1 , new Boundary < T > ( right2 , isInclusiveRight2 ) ) ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , Boundary < T > right2 ) <nl> + { <nl> + int c = right1 . boundary . compareTo ( right2 . boundary ) ; <nl> + if ( c ! = 0 ) <nl> + return c < 0 ? right1 : right2 ; <nl> + / / return the exclusive version , if either <nl> + return right2 . inclusive ? right1 : right2 ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , T left2 , boolean isInclusiveLeft2 ) <nl> + { <nl> + return maxLeft ( left1 , new Boundary < T > ( left2 , isInclusiveLeft2 ) ) ; <nl> + } <nl> + <nl> + public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , Boundary < T > left2 ) <nl> + { <nl> + int c = left1 . boundary . compareTo ( left1 . boundary ) ; <nl> + if ( c ! = 0 ) <nl> + return c > 0 ? left1 : left2 ; <nl> + / / return the exclusive version , if either <nl> + return left2 . inclusive ? left1 : left2 ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java <nl> index 396fc30 . . 42eea77 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Bounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / Bounds . java <nl> @ @ - 61 , 6 + 61 , 16 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > <nl> return Pair . create ( lb , rb ) ; <nl> } <nl> <nl> + public boolean inclusiveLeft ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + public boolean inclusiveRight ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> public boolean intersects ( Bounds < T > that ) <nl> { <nl> / / We either contains one of the that bounds , or we are fully contained into that . <nl> diff - - git a / src / java / org / apache / cassandra / dht / ExcludingBounds . java b / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> index 33e48b6 . . 0d09f08 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / ExcludingBounds . java <nl> @ @ - 56 , 6 + 56 , 16 @ @ public class ExcludingBounds < T extends RingPosition < T > > extends AbstractBounds < T <nl> return Pair . create ( lb , rb ) ; <nl> } <nl> <nl> + public boolean inclusiveLeft ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean inclusiveRight ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> public List < ? extends AbstractBounds < T > > unwrap ( ) <nl> { <nl> / / ExcludingBounds objects never wrap <nl> diff - - git a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> index e8e9c74 . . 278a806 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java <nl> @ @ - 55 , 6 + 55 , 16 @ @ public class IncludingExcludingBounds < T extends RingPosition < T > > extends Abstrac <nl> return Pair . create ( lb , rb ) ; <nl> } <nl> <nl> + public boolean inclusiveLeft ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> + public boolean inclusiveRight ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> public List < ? extends AbstractBounds < T > > unwrap ( ) <nl> { <nl> / / IncludingExcludingBounds objects never wrap <nl> diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java <nl> index 44b76d5 . . 505f1f3 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Range . java <nl> + + + b / src / java / org / apache / cassandra / dht / Range . java <nl> @ @ - 230 , 6 + 230 , 16 @ @ public class Range < T extends RingPosition < T > > extends AbstractBounds < T > implemen <nl> return Pair . create ( lb , rb ) ; <nl> } <nl> <nl> + public boolean inclusiveLeft ( ) <nl> + { <nl> + return false ; <nl> + } <nl> + <nl> + public boolean inclusiveRight ( ) <nl> + { <nl> + return true ; <nl> + } <nl> + <nl> public List < Range < T > > unwrap ( ) <nl> { <nl> @ SuppressWarnings ( " unchecked " ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> index c05103b . . 46ddc24 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . db . columniterator . IColumnIteratorFactory ; <nl> import org . apache . cassandra . db . columniterator . LazyColumnIterator ; <nl> import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . dht . AbstractBounds ; <nl> + import org . apache . cassandra . dht . AbstractBounds . Boundary ; <nl> import org . apache . cassandra . dht . Bounds ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . dht . Token ; <nl> @ @ - 40 , 6 + 41 , 10 @ @ import org . apache . cassandra . io . util . RandomAccessReader ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> + import static org . apache . cassandra . dht . AbstractBounds . isEmpty ; <nl> + import static org . apache . cassandra . dht . AbstractBounds . maxLeft ; <nl> + import static org . apache . cassandra . dht . AbstractBounds . minRight ; <nl> + <nl> public class SSTableScanner implements ISSTableScanner <nl> { <nl> protected final RandomAccessReader dfile ; <nl> @ @ - 84 , 28 + 89 , 39 @ @ public class SSTableScanner implements ISSTableScanner <nl> List < AbstractBounds < RowPosition > > boundsList = new ArrayList < > ( 2 ) ; <nl> if ( dataRange . isWrapAround ( ) ) <nl> { <nl> - if ( dataRange . stopKey ( ) . isMinimum ( sstable . partitioner ) <nl> - | | dataRange . stopKey ( ) . compareTo ( sstable . last ) > = 0 <nl> - | | dataRange . startKey ( ) . compareTo ( sstable . first ) < = 0 ) <nl> + if ( dataRange . stopKey ( ) . compareTo ( sstable . first ) > = 0 ) <nl> { <nl> - boundsList . add ( new Bounds < RowPosition > ( sstable . first , sstable . last , sstable . partitioner ) ) ; <nl> + / / since we wrap , we must contain the whole sstable prior to stopKey ( ) <nl> + Boundary < RowPosition > left = new Boundary < RowPosition > ( sstable . first , true ) ; <nl> + Boundary < RowPosition > right ; <nl> + right = dataRange . keyRange ( ) . rightBoundary ( ) ; <nl> + right = minRight ( right , sstable . last , true ) ; <nl> + if ( ! isEmpty ( left , right ) ) <nl> + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; <nl> } <nl> - else <nl> + if ( dataRange . startKey ( ) . compareTo ( sstable . last ) < = 0 ) <nl> { <nl> - if ( dataRange . startKey ( ) . compareTo ( sstable . last ) < = 0 ) <nl> - boundsList . add ( new Bounds < > ( dataRange . startKey ( ) , sstable . last , sstable . partitioner ) ) ; <nl> - if ( dataRange . stopKey ( ) . compareTo ( sstable . first ) > = 0 ) <nl> - boundsList . add ( new Bounds < > ( sstable . first , dataRange . stopKey ( ) , sstable . partitioner ) ) ; <nl> + / / since we wrap , we must contain the whole sstable after dataRange . startKey ( ) <nl> + Boundary < RowPosition > right = new Boundary < RowPosition > ( sstable . last , true ) ; <nl> + Boundary < RowPosition > left ; <nl> + left = dataRange . keyRange ( ) . leftBoundary ( ) ; <nl> + left = maxLeft ( left , sstable . first , true ) ; <nl> + if ( ! isEmpty ( left , right ) ) <nl> + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; <nl> } <nl> } <nl> else <nl> { <nl> assert dataRange . startKey ( ) . compareTo ( dataRange . stopKey ( ) ) < = 0 | | dataRange . stopKey ( ) . isMinimum ( ) ; <nl> - RowPosition left = Ordering . natural ( ) . max ( dataRange . startKey ( ) , sstable . first ) ; <nl> + Boundary < RowPosition > left , right ; <nl> + left = dataRange . keyRange ( ) . leftBoundary ( ) ; <nl> + right = dataRange . keyRange ( ) . rightBoundary ( ) ; <nl> + left = maxLeft ( left , sstable . first , true ) ; <nl> / / apparently isWrapAround ( ) doesn ' t count Bounds that extend to the limit ( min ) as wrapping <nl> - RowPosition right = dataRange . stopKey ( ) . isMinimum ( ) ? sstable . last : Ordering . natural ( ) . min ( dataRange . stopKey ( ) , sstable . last ) ; <nl> - if ( left . compareTo ( right ) < = 0 ) <nl> - boundsList . add ( new Bounds < > ( left , right , sstable . partitioner ) ) ; <nl> + right = dataRange . stopKey ( ) . isMinimum ( ) ? new Boundary < RowPosition > ( sstable . last , true ) <nl> + : minRight ( right , sstable . last , true ) ; <nl> + if ( ! isEmpty ( left , right ) ) <nl> + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; <nl> } <nl> this . rangeIterator = boundsList . iterator ( ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java <nl> index ff60481 . . 91a820c 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java <nl> @ @ - 18 , 21 + 18 , 19 @ @ <nl> * / <nl> package org . apache . cassandra . io . sstable ; <nl> <nl> - import java . util . ArrayList ; <nl> - import java . util . Collection ; <nl> + import java . util . * ; <nl> <nl> + import com . google . common . collect . Iterables ; <nl> import org . junit . Test ; <nl> <nl> import org . apache . cassandra . SchemaLoader ; <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . columniterator . IdentityQueryFilter ; <nl> - import org . apache . cassandra . dht . Bounds ; <nl> - import org . apache . cassandra . dht . BytesToken ; <nl> - import org . apache . cassandra . dht . Range ; <nl> - import org . apache . cassandra . dht . Token ; <nl> + import org . apache . cassandra . dht . * ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> <nl> + import static org . apache . cassandra . dht . AbstractBounds . isEmpty ; <nl> import static org . junit . Assert . * ; <nl> <nl> public class SSTableScannerTest extends SchemaLoader <nl> @ @ - 45 , 17 + 43 , 85 @ @ public class SSTableScannerTest extends SchemaLoader <nl> return String . format ( " % 03d " , key ) ; <nl> } <nl> <nl> - private static Bounds < RowPosition > boundsFor ( int start , int end ) <nl> + / / we produce all DataRange variations that produce an inclusive start and exclusive end range <nl> + private static Iterable < DataRange > dataRanges ( int start , int end ) <nl> { <nl> - return new Bounds < RowPosition > ( new BytesToken ( toKey ( start ) . getBytes ( ) ) . minKeyBound ( ) , <nl> - new BytesToken ( toKey ( end ) . getBytes ( ) ) . maxKeyBound ( ) ) ; <nl> + if ( end < start ) <nl> + return dataRanges ( start , end , false , true ) ; <nl> + return Iterables . concat ( dataRanges ( start , end , false , false ) , <nl> + dataRanges ( start , end , false , true ) , <nl> + dataRanges ( start , end , true , false ) , <nl> + dataRanges ( start , end , true , true ) <nl> + ) ; <nl> } <nl> <nl> + private static Iterable < DataRange > dataRanges ( int start , int end , boolean inclusiveStart , boolean inclusiveEnd ) <nl> + { <nl> + List < DataRange > ranges = new ArrayList < > ( ) ; <nl> + if ( start = = end + 1 ) <nl> + { <nl> + assert ! inclusiveStart & & inclusiveEnd ; <nl> + ranges . add ( dataRange ( min ( start ) , false , max ( end ) , true ) ) ; <nl> + ranges . add ( dataRange ( min ( start ) , false , min ( end + 1 ) , true ) ) ; <nl> + ranges . add ( dataRange ( max ( start - 1 ) , false , max ( end ) , true ) ) ; <nl> + ranges . add ( dataRange ( dk ( start - 1 ) , false , dk ( start - 1 ) , true ) ) ; <nl> + } <nl> + else <nl> + { <nl> + for ( RowPosition s : starts ( start , inclusiveStart ) ) <nl> + { <nl> + for ( RowPosition e : ends ( end , inclusiveEnd ) ) <nl> + { <nl> + if ( end < start & & e . compareTo ( s ) > 0 ) <nl> + continue ; <nl> + if ( ! isEmpty ( new AbstractBounds . Boundary < > ( s , inclusiveStart ) , new AbstractBounds . Boundary < > ( e , inclusiveEnd ) ) ) <nl> + continue ; <nl> + ranges . add ( dataRange ( s , inclusiveStart , e , inclusiveEnd ) ) ; <nl> + } <nl> + } <nl> + } <nl> + return ranges ; <nl> + } <nl> + <nl> + private static Iterable < RowPosition > starts ( int key , boolean inclusive ) <nl> + { <nl> + return Arrays . asList ( min ( key ) , max ( key - 1 ) , dk ( inclusive ? key : key - 1 ) ) ; <nl> + } <nl> + <nl> + private static Iterable < RowPosition > ends ( int key , boolean inclusive ) <nl> + { <nl> + return Arrays . asList ( max ( key ) , min ( key + 1 ) , dk ( inclusive ? key : key + 1 ) ) ; <nl> + } <nl> + <nl> + private static DecoratedKey dk ( int key ) <nl> + { <nl> + return Util . dk ( toKey ( key ) ) ; <nl> + } <nl> + <nl> + private static Token token ( int key ) <nl> + { <nl> + return key = = Integer . MIN _ VALUE ? ByteOrderedPartitioner . MINIMUM : new BytesToken ( toKey ( key ) . getBytes ( ) ) ; <nl> + } <nl> + <nl> + private static RowPosition min ( int key ) <nl> + { <nl> + return token ( key ) . minKeyBound ( ) ; <nl> + } <nl> + <nl> + private static RowPosition max ( int key ) <nl> + { <nl> + return token ( key ) . maxKeyBound ( ) ; <nl> + } <nl> + <nl> + private static DataRange dataRange ( RowPosition start , boolean startInclusive , RowPosition end , boolean endInclusive ) <nl> + { <nl> + return new DataRange ( AbstractBounds . bounds ( start , startInclusive , end , endInclusive ) , new IdentityQueryFilter ( ) ) ; <nl> + } <nl> <nl> private static Range < Token > rangeFor ( int start , int end ) <nl> { <nl> return new Range < Token > ( new BytesToken ( toKey ( start ) . getBytes ( ) ) , <nl> - new BytesToken ( toKey ( end ) . getBytes ( ) ) ) ; <nl> + end = = Integer . MIN _ VALUE ? ByteOrderedPartitioner . MINIMUM : new BytesToken ( toKey ( end ) . getBytes ( ) ) ) ; <nl> } <nl> <nl> private static Collection < Range < Token > > makeRanges ( int . . . keys ) <nl> @ @ - 75 , 18 + 141 , 22 @ @ public class SSTableScannerTest extends SchemaLoader <nl> rm . apply ( ) ; <nl> } <nl> <nl> - private static void assertScanMatches ( SSTableReader sstable , int scanStart , int scanEnd , int expectedStart , int expectedEnd ) <nl> + private static void assertScanMatches ( SSTableReader sstable , int scanStart , int scanEnd , int . . . boundaries ) <nl> { <nl> - ISSTableScanner scanner = sstable . getScanner ( new DataRange ( boundsFor ( scanStart , scanEnd ) , new IdentityQueryFilter ( ) ) ) ; <nl> - for ( int i = expectedStart ; i < = expectedEnd ; i + + ) <nl> - assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . getKey ( ) . getKey ( ) . array ( ) ) ) ; <nl> - assertFalse ( scanner . hasNext ( ) ) ; <nl> + assert boundaries . length % 2 = = 0 ; <nl> + for ( DataRange range : dataRanges ( scanStart , scanEnd ) ) <nl> + { <nl> + ISSTableScanner scanner = sstable . getScanner ( range ) ; <nl> + for ( int b = 0 ; b < boundaries . length ; b + = 2 ) <nl> + for ( int i = boundaries [ b ] ; i < = boundaries [ b + 1 ] ; i + + ) <nl> + assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . getKey ( ) . getKey ( ) . array ( ) ) ) ; <nl> + assertFalse ( scanner . hasNext ( ) ) ; <nl> + } <nl> } <nl> <nl> private static void assertScanEmpty ( SSTableReader sstable , int scanStart , int scanEnd ) <nl> { <nl> - ISSTableScanner scanner = sstable . getScanner ( new DataRange ( boundsFor ( scanStart , scanEnd ) , new IdentityQueryFilter ( ) ) ) ; <nl> - assertFalse ( String . format ( " scan of ( % 03d , % 03d ] should be empty " , scanStart , scanEnd ) , scanner . hasNext ( ) ) ; <nl> + assertScanMatches ( sstable , scanStart , scanEnd ) ; <nl> } <nl> <nl> @ Test <nl> @ @ - 132 , 6 + 202 , 45 @ @ public class SSTableScannerTest extends SchemaLoader <nl> / / empty ranges <nl> assertScanEmpty ( sstable , 0 , 1 ) ; <nl> assertScanEmpty ( sstable , 10 , 11 ) ; <nl> + <nl> + / / wrapping , starts in middle <nl> + assertScanMatches ( sstable , 5 , 3 , 2 , 3 , 5 , 9 ) ; <nl> + assertScanMatches ( sstable , 5 , 2 , 2 , 2 , 5 , 9 ) ; <nl> + assertScanMatches ( sstable , 5 , 1 , 5 , 9 ) ; <nl> + assertScanMatches ( sstable , 5 , Integer . MIN _ VALUE , 5 , 9 ) ; <nl> + / / wrapping , starts at end <nl> + assertScanMatches ( sstable , 9 , 8 , 2 , 8 , 9 , 9 ) ; <nl> + assertScanMatches ( sstable , 9 , 3 , 2 , 3 , 9 , 9 ) ; <nl> + assertScanMatches ( sstable , 9 , 2 , 2 , 2 , 9 , 9 ) ; <nl> + assertScanMatches ( sstable , 9 , 1 , 9 , 9 ) ; <nl> + assertScanMatches ( sstable , 9 , Integer . MIN _ VALUE , 9 , 9 ) ; <nl> + assertScanMatches ( sstable , 8 , 3 , 2 , 3 , 8 , 9 ) ; <nl> + assertScanMatches ( sstable , 8 , 2 , 2 , 2 , 8 , 9 ) ; <nl> + assertScanMatches ( sstable , 8 , 1 , 8 , 9 ) ; <nl> + assertScanMatches ( sstable , 8 , Integer . MIN _ VALUE , 8 , 9 ) ; <nl> + / / wrapping , starts past end <nl> + assertScanMatches ( sstable , 10 , 9 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 10 , 5 , 2 , 5 ) ; <nl> + assertScanMatches ( sstable , 10 , 2 , 2 , 2 ) ; <nl> + assertScanEmpty ( sstable , 10 , 1 ) ; <nl> + assertScanEmpty ( sstable , 10 , Integer . MIN _ VALUE ) ; <nl> + assertScanMatches ( sstable , 11 , 10 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 11 , 9 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 11 , 5 , 2 , 5 ) ; <nl> + assertScanMatches ( sstable , 11 , 2 , 2 , 2 ) ; <nl> + assertScanEmpty ( sstable , 11 , 1 ) ; <nl> + assertScanEmpty ( sstable , 11 , Integer . MIN _ VALUE ) ; <nl> + / / wrapping , starts at start <nl> + assertScanMatches ( sstable , 3 , 1 , 3 , 9 ) ; <nl> + assertScanMatches ( sstable , 3 , Integer . MIN _ VALUE , 3 , 9 ) ; <nl> + assertScanMatches ( sstable , 2 , 1 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 2 , Integer . MIN _ VALUE , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 1 , 0 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 1 , Integer . MIN _ VALUE , 2 , 9 ) ; <nl> + / / wrapping , starts before <nl> + assertScanMatches ( sstable , 1 , - 1 , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 1 , Integer . MIN _ VALUE , 2 , 9 ) ; <nl> + assertScanMatches ( sstable , 1 , 0 , 2 , 9 ) ; <nl> } <nl> <nl> private static void assertScanContainsRanges ( ISSTableScanner scanner , int . . . rangePairs )
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> new file mode 100644 <nl> index 0000000 . . 12be453 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java <nl> @ @ - 0 , 0 + 1 , 76 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . io . sstable ; <nl> + <nl> + import java . util . ArrayList ; <nl> + <nl> + import com . google . common . primitives . Bytes ; <nl> + import com . google . common . primitives . Longs ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . dht . IPartitioner ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + public class IndexSummaryBuilder <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; <nl> + <nl> + private final ArrayList < Long > positions ; <nl> + private final ArrayList < byte [ ] > keys ; <nl> + private long keysWritten = 0 ; <nl> + <nl> + public IndexSummaryBuilder ( long expectedKeys , int indexInterval ) <nl> + { <nl> + long expectedEntries = expectedKeys / indexInterval ; <nl> + if ( expectedEntries > Integer . MAX _ VALUE ) <nl> + { <nl> + / / that ' s a _ lot _ of keys , and a very low interval <nl> + int effectiveInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; <nl> + expectedEntries = expectedKeys / effectiveInterval ; <nl> + assert expectedEntries < = Integer . MAX _ VALUE : expectedEntries ; <nl> + logger . warn ( " Index interval of { } is too low for { } expected keys ; using interval of { } instead " , <nl> + indexInterval , expectedKeys , effectiveInterval ) ; <nl> + } <nl> + positions = new ArrayList < Long > ( ( int ) expectedEntries ) ; <nl> + keys = new ArrayList < byte [ ] > ( ( int ) expectedEntries ) ; <nl> + } <nl> + <nl> + public IndexSummaryBuilder maybeAddEntry ( DecoratedKey decoratedKey , int indexInterval , long indexPosition ) <nl> + { <nl> + if ( keysWritten % indexInterval = = 0 ) <nl> + { <nl> + keys . add ( ByteBufferUtil . getArray ( decoratedKey . key ) ) ; <nl> + positions . add ( indexPosition ) ; <nl> + } <nl> + keysWritten + + ; <nl> + <nl> + return this ; <nl> + } <nl> + <nl> + public IndexSummary build ( IPartitioner partitioner , int indexInterval ) <nl> + { <nl> + byte [ ] [ ] keysArray = new byte [ keys . size ( ) ] [ ] ; <nl> + for ( int i = 0 ; i < keys . size ( ) ; i + + ) <nl> + keysArray [ i ] = keys . get ( i ) ; <nl> + <nl> + return new IndexSummary ( partitioner , keysArray , Longs . toArray ( positions ) , indexInterval ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> index 2d6c1df . . 27589f5 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java <nl> @ @ - 400 , 14 + 400 , 14 @ @ public class SSTableReader extends SSTable <nl> / / if summary was already read from disk we don ' t want to re - populate it using primary index <nl> if ( ! summaryLoaded ) <nl> { <nl> - summaryBuilder . maybeAddEntry ( decoratedKey , indexPosition ) ; <nl> + summaryBuilder . maybeAddEntry ( decoratedKey , metadata . getIndexInterval ( ) , indexPosition ) ; <nl> ibuilder . addPotentialBoundary ( indexPosition ) ; <nl> dbuilder . addPotentialBoundary ( indexEntry . position ) ; <nl> } <nl> } <nl> <nl> if ( ! summaryLoaded ) <nl> - indexSummary = summaryBuilder . build ( partitioner ) ; <nl> + indexSummary = summaryBuilder . build ( partitioner , metadata . getIndexInterval ( ) ) ; <nl> } <nl> finally <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> index 4b0b756 . . c67e868 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java <nl> @ @ - 339 , 7 + 339 , 7 @ @ public class SSTableWriter extends SSTable <nl> partitioner , <nl> ifile , <nl> dfile , <nl> - iwriter . summary . build ( partitioner ) , <nl> + iwriter . summary . build ( partitioner , metadata . getIndexInterval ( ) ) , <nl> iwriter . bf , <nl> maxDataAge , <nl> sstableMetadata ) ; <nl> @ @ - 434 , 7 + 434 , 7 @ @ public class SSTableWriter extends SSTable <nl> if ( logger . isTraceEnabled ( ) ) <nl> logger . trace ( " wrote index entry : " + indexEntry + " at " + indexPosition ) ; <nl> <nl> - summary . maybeAddEntry ( key , indexPosition ) ; <nl> + summary . maybeAddEntry ( key , metadata . getIndexInterval ( ) , indexPosition ) ; <nl> builder . addPotentialBoundary ( indexPosition ) ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 2af8df6 . . 36bdb39 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 4 
 + * SSTableScanner enforces its bounds ( CASSANDRA - 8946 ) 
 * Cleanup cell equality ( CASSANDRA - 8947 ) 
 * Introduce intra - cluster message coalescing ( CASSANDRA - 8692 ) 
 * DatabaseDescriptor throws NPE when rpc _ interface is used ( CASSANDRA - 8839 ) 
 diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 index 90eb6b5 . . 6d2ee43 100644 
 - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 @ @ - 68 , 6 + 68 , 8 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 * instead . 
 * / 
 public abstract Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) ; 
 + public abstract boolean inclusiveLeft ( ) ; 
 + public abstract boolean inclusiveRight ( ) ; 
 
 @ Override 
 public int hashCode ( ) 
 @ @ - 193 , 4 + 195 , 76 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 return size ; 
 } 
 } 
 + 
 + public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( Boundary < T > min , Boundary < T > max ) 
 + { 
 + return bounds ( min . boundary , min . inclusive , max . boundary , max . inclusive ) ; 
 + } 
 + public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( T min , boolean inclusiveMin , T max , boolean inclusiveMax ) 
 + { 
 + if ( inclusiveMin & & inclusiveMax ) 
 + return new Bounds < T > ( min , max ) ; 
 + else if ( inclusiveMax ) 
 + return new Range < T > ( min , max ) ; 
 + else if ( inclusiveMin ) 
 + return new IncludingExcludingBounds < T > ( min , max ) ; 
 + else 
 + return new ExcludingBounds < T > ( min , max ) ; 
 + } 
 + 
 + / / represents one side of a bounds ( which side is not encoded ) 
 + public static class Boundary < T extends RingPosition < T > > 
 + { 
 + public final T boundary ; 
 + public final boolean inclusive ; 
 + public Boundary ( T boundary , boolean inclusive ) 
 + { 
 + this . boundary = boundary ; 
 + this . inclusive = inclusive ; 
 + } 
 + } 
 + 
 + public Boundary < T > leftBoundary ( ) 
 + { 
 + return new Boundary < > ( left , inclusiveLeft ( ) ) ; 
 + } 
 + 
 + public Boundary < T > rightBoundary ( ) 
 + { 
 + return new Boundary < > ( right , inclusiveRight ( ) ) ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > boolean isEmpty ( Boundary < T > left , Boundary < T > right ) 
 + { 
 + int c = left . boundary . compareTo ( right . boundary ) ; 
 + return c > 0 | | ( c = = 0 & & ! ( left . inclusive & & right . inclusive ) ) ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , T right2 , boolean isInclusiveRight2 ) 
 + { 
 + return minRight ( right1 , new Boundary < T > ( right2 , isInclusiveRight2 ) ) ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , Boundary < T > right2 ) 
 + { 
 + int c = right1 . boundary . compareTo ( right2 . boundary ) ; 
 + if ( c ! = 0 ) 
 + return c < 0 ? right1 : right2 ; 
 + / / return the exclusive version , if either 
 + return right2 . inclusive ? right1 : right2 ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , T left2 , boolean isInclusiveLeft2 ) 
 + { 
 + return maxLeft ( left1 , new Boundary < T > ( left2 , isInclusiveLeft2 ) ) ; 
 + } 
 + 
 + public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , Boundary < T > left2 ) 
 + { 
 + int c = left1 . boundary . compareTo ( left1 . boundary ) ; 
 + if ( c ! = 0 ) 
 + return c > 0 ? left1 : left2 ; 
 + / / return the exclusive version , if either 
 + return left2 . inclusive ? left1 : left2 ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java 
 index 396fc30 . . 42eea77 100644 
 - - - a / src / java / org / apache / cassandra / dht / Bounds . java 
 + + + b / src / java / org / apache / cassandra / dht / Bounds . java 
 @ @ - 61 , 6 + 61 , 16 @ @ public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > 
 return Pair . create ( lb , rb ) ; 
 } 
 
 + public boolean inclusiveLeft ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + public boolean inclusiveRight ( ) 
 + { 
 + return true ; 
 + } 
 + 
 public boolean intersects ( Bounds < T > that ) 
 { 
 / / We either contains one of the that bounds , or we are fully contained into that . 
 diff - - git a / src / java / org / apache / cassandra / dht / ExcludingBounds . java b / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 index 33e48b6 . . 0d09f08 100644 
 - - - a / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / ExcludingBounds . java 
 @ @ - 56 , 6 + 56 , 16 @ @ public class ExcludingBounds < T extends RingPosition < T > > extends AbstractBounds < T 
 return Pair . create ( lb , rb ) ; 
 } 
 
 + public boolean inclusiveLeft ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + public boolean inclusiveRight ( ) 
 + { 
 + return false ; 
 + } 
 + 
 public List < ? extends AbstractBounds < T > > unwrap ( ) 
 { 
 / / ExcludingBounds objects never wrap 
 diff - - git a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 index e8e9c74 . . 278a806 100644 
 - - - a / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / IncludingExcludingBounds . java 
 @ @ - 55 , 6 + 55 , 16 @ @ public class IncludingExcludingBounds < T extends RingPosition < T > > extends Abstrac 
 return Pair . create ( lb , rb ) ; 
 } 
 
 + public boolean inclusiveLeft ( ) 
 + { 
 + return true ; 
 + } 
 + 
 + public boolean inclusiveRight ( ) 
 + { 
 + return false ; 
 + } 
 + 
 public List < ? extends AbstractBounds < T > > unwrap ( ) 
 { 
 / / IncludingExcludingBounds objects never wrap 
 diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java 
 index 44b76d5 . . 505f1f3 100644 
 - - - a / src / java / org / apache / cassandra / dht / Range . java 
 + + + b / src / java / org / apache / cassandra / dht / Range . java 
 @ @ - 230 , 6 + 230 , 16 @ @ public class Range < T extends RingPosition < T > > extends AbstractBounds < T > implemen 
 return Pair . create ( lb , rb ) ; 
 } 
 
 + public boolean inclusiveLeft ( ) 
 + { 
 + return false ; 
 + } 
 + 
 + public boolean inclusiveRight ( ) 
 + { 
 + return true ; 
 + } 
 + 
 public List < Range < T > > unwrap ( ) 
 { 
 @ SuppressWarnings ( " unchecked " ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 index c05103b . . 46ddc24 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableScanner . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . apache . cassandra . db . columniterator . IColumnIteratorFactory ; 
 import org . apache . cassandra . db . columniterator . LazyColumnIterator ; 
 import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . dht . AbstractBounds ; 
 + import org . apache . cassandra . dht . AbstractBounds . Boundary ; 
 import org . apache . cassandra . dht . Bounds ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . dht . Token ; 
 @ @ - 40 , 6 + 41 , 10 @ @ import org . apache . cassandra . io . util . RandomAccessReader ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import org . apache . cassandra . utils . Pair ; 
 
 + import static org . apache . cassandra . dht . AbstractBounds . isEmpty ; 
 + import static org . apache . cassandra . dht . AbstractBounds . maxLeft ; 
 + import static org . apache . cassandra . dht . AbstractBounds . minRight ; 
 + 
 public class SSTableScanner implements ISSTableScanner 
 { 
 protected final RandomAccessReader dfile ; 
 @ @ - 84 , 28 + 89 , 39 @ @ public class SSTableScanner implements ISSTableScanner 
 List < AbstractBounds < RowPosition > > boundsList = new ArrayList < > ( 2 ) ; 
 if ( dataRange . isWrapAround ( ) ) 
 { 
 - if ( dataRange . stopKey ( ) . isMinimum ( sstable . partitioner ) 
 - | | dataRange . stopKey ( ) . compareTo ( sstable . last ) > = 0 
 - | | dataRange . startKey ( ) . compareTo ( sstable . first ) < = 0 ) 
 + if ( dataRange . stopKey ( ) . compareTo ( sstable . first ) > = 0 ) 
 { 
 - boundsList . add ( new Bounds < RowPosition > ( sstable . first , sstable . last , sstable . partitioner ) ) ; 
 + / / since we wrap , we must contain the whole sstable prior to stopKey ( ) 
 + Boundary < RowPosition > left = new Boundary < RowPosition > ( sstable . first , true ) ; 
 + Boundary < RowPosition > right ; 
 + right = dataRange . keyRange ( ) . rightBoundary ( ) ; 
 + right = minRight ( right , sstable . last , true ) ; 
 + if ( ! isEmpty ( left , right ) ) 
 + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; 
 } 
 - else 
 + if ( dataRange . startKey ( ) . compareTo ( sstable . last ) < = 0 ) 
 { 
 - if ( dataRange . startKey ( ) . compareTo ( sstable . last ) < = 0 ) 
 - boundsList . add ( new Bounds < > ( dataRange . startKey ( ) , sstable . last , sstable . partitioner ) ) ; 
 - if ( dataRange . stopKey ( ) . compareTo ( sstable . first ) > = 0 ) 
 - boundsList . add ( new Bounds < > ( sstable . first , dataRange . stopKey ( ) , sstable . partitioner ) ) ; 
 + / / since we wrap , we must contain the whole sstable after dataRange . startKey ( ) 
 + Boundary < RowPosition > right = new Boundary < RowPosition > ( sstable . last , true ) ; 
 + Boundary < RowPosition > left ; 
 + left = dataRange . keyRange ( ) . leftBoundary ( ) ; 
 + left = maxLeft ( left , sstable . first , true ) ; 
 + if ( ! isEmpty ( left , right ) ) 
 + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; 
 } 
 } 
 else 
 { 
 assert dataRange . startKey ( ) . compareTo ( dataRange . stopKey ( ) ) < = 0 | | dataRange . stopKey ( ) . isMinimum ( ) ; 
 - RowPosition left = Ordering . natural ( ) . max ( dataRange . startKey ( ) , sstable . first ) ; 
 + Boundary < RowPosition > left , right ; 
 + left = dataRange . keyRange ( ) . leftBoundary ( ) ; 
 + right = dataRange . keyRange ( ) . rightBoundary ( ) ; 
 + left = maxLeft ( left , sstable . first , true ) ; 
 / / apparently isWrapAround ( ) doesn ' t count Bounds that extend to the limit ( min ) as wrapping 
 - RowPosition right = dataRange . stopKey ( ) . isMinimum ( ) ? sstable . last : Ordering . natural ( ) . min ( dataRange . stopKey ( ) , sstable . last ) ; 
 - if ( left . compareTo ( right ) < = 0 ) 
 - boundsList . add ( new Bounds < > ( left , right , sstable . partitioner ) ) ; 
 + right = dataRange . stopKey ( ) . isMinimum ( ) ? new Boundary < RowPosition > ( sstable . last , true ) 
 + : minRight ( right , sstable . last , true ) ; 
 + if ( ! isEmpty ( left , right ) ) 
 + boundsList . add ( AbstractBounds . bounds ( left , right ) ) ; 
 } 
 this . rangeIterator = boundsList . iterator ( ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java 
 index ff60481 . . 91a820c 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableScannerTest . java 
 @ @ - 18 , 21 + 18 , 19 @ @ 
 * / 
 package org . apache . cassandra . io . sstable ; 
 
 - import java . util . ArrayList ; 
 - import java . util . Collection ; 
 + import java . util . * ; 
 
 + import com . google . common . collect . Iterables ; 
 import org . junit . Test ; 
 
 import org . apache . cassandra . SchemaLoader ; 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . columniterator . IdentityQueryFilter ; 
 - import org . apache . cassandra . dht . Bounds ; 
 - import org . apache . cassandra . dht . BytesToken ; 
 - import org . apache . cassandra . dht . Range ; 
 - import org . apache . cassandra . dht . Token ; 
 + import org . apache . cassandra . dht . * ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 
 + import static org . apache . cassandra . dht . AbstractBounds . isEmpty ; 
 import static org . junit . Assert . * ; 
 
 public class SSTableScannerTest extends SchemaLoader 
 @ @ - 45 , 17 + 43 , 85 @ @ public class SSTableScannerTest extends SchemaLoader 
 return String . format ( " % 03d " , key ) ; 
 } 
 
 - private static Bounds < RowPosition > boundsFor ( int start , int end ) 
 + / / we produce all DataRange variations that produce an inclusive start and exclusive end range 
 + private static Iterable < DataRange > dataRanges ( int start , int end ) 
 { 
 - return new Bounds < RowPosition > ( new BytesToken ( toKey ( start ) . getBytes ( ) ) . minKeyBound ( ) , 
 - new BytesToken ( toKey ( end ) . getBytes ( ) ) . maxKeyBound ( ) ) ; 
 + if ( end < start ) 
 + return dataRanges ( start , end , false , true ) ; 
 + return Iterables . concat ( dataRanges ( start , end , false , false ) , 
 + dataRanges ( start , end , false , true ) , 
 + dataRanges ( start , end , true , false ) , 
 + dataRanges ( start , end , true , true ) 
 + ) ; 
 } 
 
 + private static Iterable < DataRange > dataRanges ( int start , int end , boolean inclusiveStart , boolean inclusiveEnd ) 
 + { 
 + List < DataRange > ranges = new ArrayList < > ( ) ; 
 + if ( start = = end + 1 ) 
 + { 
 + assert ! inclusiveStart & & inclusiveEnd ; 
 + ranges . add ( dataRange ( min ( start ) , false , max ( end ) , true ) ) ; 
 + ranges . add ( dataRange ( min ( start ) , false , min ( end + 1 ) , true ) ) ; 
 + ranges . add ( dataRange ( max ( start - 1 ) , false , max ( end ) , true ) ) ; 
 + ranges . add ( dataRange ( dk ( start - 1 ) , false , dk ( start - 1 ) , true ) ) ; 
 + } 
 + else 
 + { 
 + for ( RowPosition s : starts ( start , inclusiveStart ) ) 
 + { 
 + for ( RowPosition e : ends ( end , inclusiveEnd ) ) 
 + { 
 + if ( end < start & & e . compareTo ( s ) > 0 ) 
 + continue ; 
 + if ( ! isEmpty ( new AbstractBounds . Boundary < > ( s , inclusiveStart ) , new AbstractBounds . Boundary < > ( e , inclusiveEnd ) ) ) 
 + continue ; 
 + ranges . add ( dataRange ( s , inclusiveStart , e , inclusiveEnd ) ) ; 
 + } 
 + } 
 + } 
 + return ranges ; 
 + } 
 + 
 + private static Iterable < RowPosition > starts ( int key , boolean inclusive ) 
 + { 
 + return Arrays . asList ( min ( key ) , max ( key - 1 ) , dk ( inclusive ? key : key - 1 ) ) ; 
 + } 
 + 
 + private static Iterable < RowPosition > ends ( int key , boolean inclusive ) 
 + { 
 + return Arrays . asList ( max ( key ) , min ( key + 1 ) , dk ( inclusive ? key : key + 1 ) ) ; 
 + } 
 + 
 + private static DecoratedKey dk ( int key ) 
 + { 
 + return Util . dk ( toKey ( key ) ) ; 
 + } 
 + 
 + private static Token token ( int key ) 
 + { 
 + return key = = Integer . MIN _ VALUE ? ByteOrderedPartitioner . MINIMUM : new BytesToken ( toKey ( key ) . getBytes ( ) ) ; 
 + } 
 + 
 + private static RowPosition min ( int key ) 
 + { 
 + return token ( key ) . minKeyBound ( ) ; 
 + } 
 + 
 + private static RowPosition max ( int key ) 
 + { 
 + return token ( key ) . maxKeyBound ( ) ; 
 + } 
 + 
 + private static DataRange dataRange ( RowPosition start , boolean startInclusive , RowPosition end , boolean endInclusive ) 
 + { 
 + return new DataRange ( AbstractBounds . bounds ( start , startInclusive , end , endInclusive ) , new IdentityQueryFilter ( ) ) ; 
 + } 
 
 private static Range < Token > rangeFor ( int start , int end ) 
 { 
 return new Range < Token > ( new BytesToken ( toKey ( start ) . getBytes ( ) ) , 
 - new BytesToken ( toKey ( end ) . getBytes ( ) ) ) ; 
 + end = = Integer . MIN _ VALUE ? ByteOrderedPartitioner . MINIMUM : new BytesToken ( toKey ( end ) . getBytes ( ) ) ) ; 
 } 
 
 private static Collection < Range < Token > > makeRanges ( int . . . keys ) 
 @ @ - 75 , 18 + 141 , 22 @ @ public class SSTableScannerTest extends SchemaLoader 
 rm . apply ( ) ; 
 } 
 
 - private static void assertScanMatches ( SSTableReader sstable , int scanStart , int scanEnd , int expectedStart , int expectedEnd ) 
 + private static void assertScanMatches ( SSTableReader sstable , int scanStart , int scanEnd , int . . . boundaries ) 
 { 
 - ISSTableScanner scanner = sstable . getScanner ( new DataRange ( boundsFor ( scanStart , scanEnd ) , new IdentityQueryFilter ( ) ) ) ; 
 - for ( int i = expectedStart ; i < = expectedEnd ; i + + ) 
 - assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . getKey ( ) . getKey ( ) . array ( ) ) ) ; 
 - assertFalse ( scanner . hasNext ( ) ) ; 
 + assert boundaries . length % 2 = = 0 ; 
 + for ( DataRange range : dataRanges ( scanStart , scanEnd ) ) 
 + { 
 + ISSTableScanner scanner = sstable . getScanner ( range ) ; 
 + for ( int b = 0 ; b < boundaries . length ; b + = 2 ) 
 + for ( int i = boundaries [ b ] ; i < = boundaries [ b + 1 ] ; i + + ) 
 + assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . getKey ( ) . getKey ( ) . array ( ) ) ) ; 
 + assertFalse ( scanner . hasNext ( ) ) ; 
 + } 
 } 
 
 private static void assertScanEmpty ( SSTableReader sstable , int scanStart , int scanEnd ) 
 { 
 - ISSTableScanner scanner = sstable . getScanner ( new DataRange ( boundsFor ( scanStart , scanEnd ) , new IdentityQueryFilter ( ) ) ) ; 
 - assertFalse ( String . format ( " scan of ( % 03d , % 03d ] should be empty " , scanStart , scanEnd ) , scanner . hasNext ( ) ) ; 
 + assertScanMatches ( sstable , scanStart , scanEnd ) ; 
 } 
 
 @ Test 
 @ @ - 132 , 6 + 202 , 45 @ @ public class SSTableScannerTest extends SchemaLoader 
 / / empty ranges 
 assertScanEmpty ( sstable , 0 , 1 ) ; 
 assertScanEmpty ( sstable , 10 , 11 ) ; 
 + 
 + / / wrapping , starts in middle 
 + assertScanMatches ( sstable , 5 , 3 , 2 , 3 , 5 , 9 ) ; 
 + assertScanMatches ( sstable , 5 , 2 , 2 , 2 , 5 , 9 ) ; 
 + assertScanMatches ( sstable , 5 , 1 , 5 , 9 ) ; 
 + assertScanMatches ( sstable , 5 , Integer . MIN _ VALUE , 5 , 9 ) ; 
 + / / wrapping , starts at end 
 + assertScanMatches ( sstable , 9 , 8 , 2 , 8 , 9 , 9 ) ; 
 + assertScanMatches ( sstable , 9 , 3 , 2 , 3 , 9 , 9 ) ; 
 + assertScanMatches ( sstable , 9 , 2 , 2 , 2 , 9 , 9 ) ; 
 + assertScanMatches ( sstable , 9 , 1 , 9 , 9 ) ; 
 + assertScanMatches ( sstable , 9 , Integer . MIN _ VALUE , 9 , 9 ) ; 
 + assertScanMatches ( sstable , 8 , 3 , 2 , 3 , 8 , 9 ) ; 
 + assertScanMatches ( sstable , 8 , 2 , 2 , 2 , 8 , 9 ) ; 
 + assertScanMatches ( sstable , 8 , 1 , 8 , 9 ) ; 
 + assertScanMatches ( sstable , 8 , Integer . MIN _ VALUE , 8 , 9 ) ; 
 + / / wrapping , starts past end 
 + assertScanMatches ( sstable , 10 , 9 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 10 , 5 , 2 , 5 ) ; 
 + assertScanMatches ( sstable , 10 , 2 , 2 , 2 ) ; 
 + assertScanEmpty ( sstable , 10 , 1 ) ; 
 + assertScanEmpty ( sstable , 10 , Integer . MIN _ VALUE ) ; 
 + assertScanMatches ( sstable , 11 , 10 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 11 , 9 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 11 , 5 , 2 , 5 ) ; 
 + assertScanMatches ( sstable , 11 , 2 , 2 , 2 ) ; 
 + assertScanEmpty ( sstable , 11 , 1 ) ; 
 + assertScanEmpty ( sstable , 11 , Integer . MIN _ VALUE ) ; 
 + / / wrapping , starts at start 
 + assertScanMatches ( sstable , 3 , 1 , 3 , 9 ) ; 
 + assertScanMatches ( sstable , 3 , Integer . MIN _ VALUE , 3 , 9 ) ; 
 + assertScanMatches ( sstable , 2 , 1 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 2 , Integer . MIN _ VALUE , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 1 , 0 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 1 , Integer . MIN _ VALUE , 2 , 9 ) ; 
 + / / wrapping , starts before 
 + assertScanMatches ( sstable , 1 , - 1 , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 1 , Integer . MIN _ VALUE , 2 , 9 ) ; 
 + assertScanMatches ( sstable , 1 , 0 , 2 , 9 ) ; 
 } 
 
 private static void assertScanContainsRanges ( ISSTableScanner scanner , int . . . rangePairs )

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 new file mode 100644 
 index 0000000 . . 12be453 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / io / sstable / IndexSummaryBuilder . java 
 @ @ - 0 , 0 + 1 , 76 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . io . sstable ; 
 + 
 + import java . util . ArrayList ; 
 + 
 + import com . google . common . primitives . Bytes ; 
 + import com . google . common . primitives . Longs ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . dht . IPartitioner ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + public class IndexSummaryBuilder 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryBuilder . class ) ; 
 + 
 + private final ArrayList < Long > positions ; 
 + private final ArrayList < byte [ ] > keys ; 
 + private long keysWritten = 0 ; 
 + 
 + public IndexSummaryBuilder ( long expectedKeys , int indexInterval ) 
 + { 
 + long expectedEntries = expectedKeys / indexInterval ; 
 + if ( expectedEntries > Integer . MAX _ VALUE ) 
 + { 
 + / / that ' s a _ lot _ of keys , and a very low interval 
 + int effectiveInterval = ( int ) Math . ceil ( ( double ) Integer . MAX _ VALUE / expectedKeys ) ; 
 + expectedEntries = expectedKeys / effectiveInterval ; 
 + assert expectedEntries < = Integer . MAX _ VALUE : expectedEntries ; 
 + logger . warn ( " Index interval of { } is too low for { } expected keys ; using interval of { } instead " , 
 + indexInterval , expectedKeys , effectiveInterval ) ; 
 + } 
 + positions = new ArrayList < Long > ( ( int ) expectedEntries ) ; 
 + keys = new ArrayList < byte [ ] > ( ( int ) expectedEntries ) ; 
 + } 
 + 
 + public IndexSummaryBuilder maybeAddEntry ( DecoratedKey decoratedKey , int indexInterval , long indexPosition ) 
 + { 
 + if ( keysWritten % indexInterval = = 0 ) 
 + { 
 + keys . add ( ByteBufferUtil . getArray ( decoratedKey . key ) ) ; 
 + positions . add ( indexPosition ) ; 
 + } 
 + keysWritten + + ; 
 + 
 + return this ; 
 + } 
 + 
 + public IndexSummary build ( IPartitioner partitioner , int indexInterval ) 
 + { 
 + byte [ ] [ ] keysArray = new byte [ keys . size ( ) ] [ ] ; 
 + for ( int i = 0 ; i < keys . size ( ) ; i + + ) 
 + keysArray [ i ] = keys . get ( i ) ; 
 + 
 + return new IndexSummary ( partitioner , keysArray , Longs . toArray ( positions ) , indexInterval ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 index 2d6c1df . . 27589f5 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableReader . java 
 @ @ - 400 , 14 + 400 , 14 @ @ public class SSTableReader extends SSTable 
 / / if summary was already read from disk we don ' t want to re - populate it using primary index 
 if ( ! summaryLoaded ) 
 { 
 - summaryBuilder . maybeAddEntry ( decoratedKey , indexPosition ) ; 
 + summaryBuilder . maybeAddEntry ( decoratedKey , metadata . getIndexInterval ( ) , indexPosition ) ; 
 ibuilder . addPotentialBoundary ( indexPosition ) ; 
 dbuilder . addPotentialBoundary ( indexEntry . position ) ; 
 } 
 } 
 
 if ( ! summaryLoaded ) 
 - indexSummary = summaryBuilder . build ( partitioner ) ; 
 + indexSummary = summaryBuilder . build ( partitioner , metadata . getIndexInterval ( ) ) ; 
 } 
 finally 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 index 4b0b756 . . c67e868 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / SSTableWriter . java 
 @ @ - 339 , 7 + 339 , 7 @ @ public class SSTableWriter extends SSTable 
 partitioner , 
 ifile , 
 dfile , 
 - iwriter . summary . build ( partitioner ) , 
 + iwriter . summary . build ( partitioner , metadata . getIndexInterval ( ) ) , 
 iwriter . bf , 
 maxDataAge , 
 sstableMetadata ) ; 
 @ @ - 434 , 7 + 434 , 7 @ @ public class SSTableWriter extends SSTable 
 if ( logger . isTraceEnabled ( ) ) 
 logger . trace ( " wrote index entry : " + indexEntry + " at " + indexPosition ) ; 
 
 - summary . maybeAddEntry ( key , indexPosition ) ; 
 + summary . maybeAddEntry ( key , metadata . getIndexInterval ( ) , indexPosition ) ; 
 builder . addPotentialBoundary ( indexPosition ) ; 
 } 

