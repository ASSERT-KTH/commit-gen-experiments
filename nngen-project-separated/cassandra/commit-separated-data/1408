BLEU SCORE: 0.018738883683389617

TEST MSG: Add tool to find why expired sstables are not getting dropped
GENERATED MSG: merge from 1 . 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index fe060af . . 7d84538 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 0 . 17 <nl> + * Add tool to find why expired sstables are not getting dropped ( CASSANDRA - 10015 ) <nl> * Remove erroneous pending HH tasks from tpstats / jmx ( CASSANDRA - 9129 ) <nl> * Don ' t cast expected bf size to an int ( CASSANDRA - 9959 ) <nl> * Log when messages are dropped due to cross _ node _ timeout ( CASSANDRA - 9793 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java b / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java <nl> new file mode 100644 <nl> index 0000000 . . b5fa779 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java <nl> @ @ - 0 , 0 + 1 , 135 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . tools ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . io . PrintStream ; <nl> + import java . util . Collections ; <nl> + import java . util . HashSet ; <nl> + import java . util . Map ; <nl> + import java . util . Set ; <nl> + <nl> + import com . google . common . base . Throwables ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> + import com . google . common . collect . Multimap ; <nl> + <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . db . Directories ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . io . sstable . Component ; <nl> + import org . apache . cassandra . io . sstable . Descriptor ; <nl> + import org . apache . cassandra . io . sstable . SSTableReader ; <nl> + <nl> + / * * <nl> + * During compaction we can drop entire sstables if they only contain expired tombstones and if it is guaranteed <nl> + * to not cover anything in other sstables . An expired sstable can be blocked from getting dropped if its newest <nl> + * timestamp is newer than the oldest data in another sstable . <nl> + * <nl> + * This class outputs all sstables that are blocking other sstables from getting dropped so that a user can <nl> + * figure out why certain sstables are still on disk . <nl> + * / <nl> + public class SSTableExpiredBlockers <nl> + { <nl> + public static void main ( String [ ] args ) throws IOException <nl> + { <nl> + PrintStream out = System . out ; <nl> + if ( args . length < 2 ) <nl> + { <nl> + out . println ( " Usage : sstableexpiredblockers < keyspace > < table > " ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + String keyspace = args [ args . length - 2 ] ; <nl> + String columnfamily = args [ args . length - 1 ] ; <nl> + DatabaseDescriptor . loadSchemas ( ) ; <nl> + <nl> + CFMetaData metadata = Schema . instance . getCFMetaData ( keyspace , columnfamily ) ; <nl> + if ( metadata = = null ) <nl> + throw new IllegalArgumentException ( String . format ( " Unknown keyspace / table % s . % s " , <nl> + keyspace , <nl> + columnfamily ) ) ; <nl> + <nl> + Keyspace . openWithoutSSTables ( keyspace ) ; <nl> + Directories directories = Directories . create ( keyspace , columnfamily ) ; <nl> + Set < SSTableReader > sstables = new HashSet < > ( ) ; <nl> + <nl> + for ( Map . Entry < Descriptor , Set < Component > > sstable : directories . sstableLister ( ) . skipTemporary ( true ) . list ( ) . entrySet ( ) ) <nl> + { <nl> + if ( sstable . getKey ( ) ! = null ) <nl> + { <nl> + try <nl> + { <nl> + SSTableReader reader = SSTableReader . open ( sstable . getKey ( ) ) ; <nl> + sstables . add ( reader ) ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + out . println ( " Couldn ' t open sstable : " + sstable . getKey ( ) . filenameFor ( Component . DATA ) ) ; <nl> + Throwables . propagate ( t ) ; <nl> + } <nl> + } <nl> + } <nl> + if ( sstables . isEmpty ( ) ) <nl> + { <nl> + out . println ( " No sstables for " + keyspace + " . " + columnfamily ) ; <nl> + System . exit ( 1 ) ; <nl> + } <nl> + <nl> + int gcBefore = ( int ) ( System . currentTimeMillis ( ) / 1000 ) - metadata . getGcGraceSeconds ( ) ; <nl> + Multimap < SSTableReader , SSTableReader > blockers = checkForExpiredSSTableBlockers ( sstables , gcBefore ) ; <nl> + for ( SSTableReader blocker : blockers . keySet ( ) ) <nl> + { <nl> + out . println ( String . format ( " % s blocks % d expired sstables from getting dropped : % s % n " , <nl> + formatForExpiryTracing ( Collections . singleton ( blocker ) ) , <nl> + blockers . get ( blocker ) . size ( ) , <nl> + formatForExpiryTracing ( blockers . get ( blocker ) ) ) ) ; <nl> + } <nl> + <nl> + System . exit ( 0 ) ; <nl> + } <nl> + <nl> + public static Multimap < SSTableReader , SSTableReader > checkForExpiredSSTableBlockers ( Iterable < SSTableReader > sstables , int gcBefore ) <nl> + { <nl> + Multimap < SSTableReader , SSTableReader > blockers = ArrayListMultimap . create ( ) ; <nl> + for ( SSTableReader sstable : sstables ) <nl> + { <nl> + if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime < gcBefore ) <nl> + { <nl> + for ( SSTableReader potentialBlocker : sstables ) <nl> + { <nl> + if ( ! potentialBlocker . equals ( sstable ) & & <nl> + potentialBlocker . getMinTimestamp ( ) < = sstable . getMaxTimestamp ( ) & & <nl> + potentialBlocker . getSSTableMetadata ( ) . maxLocalDeletionTime > gcBefore ) <nl> + blockers . put ( potentialBlocker , sstable ) ; <nl> + } <nl> + } <nl> + } <nl> + return blockers ; <nl> + } <nl> + <nl> + private static String formatForExpiryTracing ( Iterable < SSTableReader > sstables ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + <nl> + for ( SSTableReader sstable : sstables ) <nl> + sb . append ( String . format ( " [ % s ( minTS = % d , maxTS = % d , maxLDT = % d ) ] " , sstable , sstable . getMinTimestamp ( ) , sstable . getMaxTimestamp ( ) , sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ) ) . append ( " , " ) ; <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> index 3fad0ec . . 5a83c76 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . Collections ; <nl> import java . util . Set ; <nl> import java . util . concurrent . ExecutionException ; <nl> <nl> + import com . google . common . collect . Multimap ; <nl> import com . google . common . collect . Sets ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> @ @ - 41 , 6 + 42 , 7 @ @ import org . apache . cassandra . db . RowMutation ; <nl> import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . sstable . SSTableScanner ; <nl> + import org . apache . cassandra . tools . SSTableExpiredBlockers ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertTrue ; <nl> @ @ - 197 , 4 + 199 , 31 @ @ public class TTLExpiryTest extends SchemaLoader <nl> cfs . clearUnsafe ( ) ; <nl> } <nl> <nl> + @ Test <nl> + public void testCheckForExpiredSSTableBlockers ( ) throws InterruptedException <nl> + { <nl> + String KEYSPACE1 = " Keyspace1 " ; <nl> + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ; <nl> + cfs . truncateBlocking ( ) ; <nl> + cfs . disableAutoCompaction ( ) ; <nl> + cfs . metadata . gcGraceSeconds ( 0 ) ; <nl> + <nl> + RowMutation rm = new RowMutation ( KEYSPACE1 , Util . dk ( " test " ) . key ) ; <nl> + rm . add ( " Standard1 " , ByteBufferUtil . bytes ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , System . currentTimeMillis ( ) ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + SSTableReader blockingSSTable = cfs . getSSTables ( ) . iterator ( ) . next ( ) ; <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + rm = new RowMutation ( KEYSPACE1 , Util . dk ( " test " ) . key ) ; <nl> + rm . delete ( " Standard1 " , System . currentTimeMillis ( ) ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + } <nl> + Multimap < SSTableReader , SSTableReader > blockers = SSTableExpiredBlockers . checkForExpiredSSTableBlockers ( cfs . getSSTables ( ) , ( int ) ( System . currentTimeMillis ( ) / 1000 ) + 100 ) ; <nl> + assertEquals ( 1 , blockers . keySet ( ) . size ( ) ) ; <nl> + assertTrue ( blockers . keySet ( ) . contains ( blockingSSTable ) ) ; <nl> + assertEquals ( 10 , blockers . get ( blockingSSTable ) . size ( ) ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / tools / bin / sstableexpiredblockers b / tools / bin / sstableexpiredblockers <nl> new file mode 100755 <nl> index 0000000 . . 58cefce <nl> - - - / dev / null <nl> + + + b / tools / bin / sstableexpiredblockers <nl> @ @ - 0 , 0 + 1 , 49 @ @ <nl> + # ! / bin / sh <nl> + <nl> + # Licensed to the Apache Software Foundation ( ASF ) under one <nl> + # or more contributor license agreements . See the NOTICE file <nl> + # distributed with this work for additional information <nl> + # regarding copyright ownership . The ASF licenses this file <nl> + # to you under the Apache License , Version 2 . 0 ( the <nl> + # " License " ) ; you may not use this file except in compliance <nl> + # with the License . You may obtain a copy of the License at <nl> + # <nl> + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + # <nl> + # Unless required by applicable law or agreed to in writing , software <nl> + # distributed under the License is distributed on an " AS IS " BASIS , <nl> + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + # See the License for the specific language governing permissions and <nl> + # limitations under the License . <nl> + <nl> + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then <nl> + for include in " ` dirname $ 0 ` / cassandra . in . sh " \ <nl> + " $ HOME / . cassandra . in . sh " \ <nl> + / usr / share / cassandra / cassandra . in . sh \ <nl> + / usr / local / share / cassandra / cassandra . in . sh \ <nl> + / opt / cassandra / cassandra . in . sh ; do <nl> + if [ - r $ include ] ; then <nl> + . $ include <nl> + break <nl> + fi <nl> + done <nl> + elif [ - r $ CASSANDRA _ INCLUDE ] ; then <nl> + . $ CASSANDRA _ INCLUDE <nl> + fi <nl> + <nl> + <nl> + # Use JAVA _ HOME if set , otherwise look for java in PATH <nl> + if [ - x $ JAVA _ HOME / bin / java ] ; then <nl> + JAVA = $ JAVA _ HOME / bin / java <nl> + else <nl> + JAVA = ` which java ` <nl> + fi <nl> + <nl> + if [ - z " $ CLASSPATH " ] ; then <nl> + echo " You must set the CLASSPATH var " > & 2 <nl> + exit 1 <nl> + fi <nl> + <nl> + " $ JAVA " - cp " $ CLASSPATH " - Dstorage - config = $ CASSANDRA _ CONF \ <nl> + - Dlog4j . configuration = log4j - tools . properties \ <nl> + org . apache . cassandra . tools . SSTableExpiredBlockers " $ @ "
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c8ccc24 . . 2cc8c52 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * add a convenient way to reset a node ' s schema ( CASSANDRA - 2963 ) <nl> * fix for intermittent SchemaDisagreementException ( CASSANDRA - 3884 ) <nl> * CLI ` list < CF > ` to limit number of columns and their order ( CASSANDRA - 3012 ) <nl> + * ignore deprecated KsDef / CfDef / ColumnDef fields in native schema ( CASSANDRA - 3963 ) <nl> Merged from 1 . 0 : <nl> * remove the wait on hint future during write ( CASSANDRA - 3870 ) <nl> * ( cqlsh ) ignore missing CfDef opts ( CASSANDRA - 3933 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 5f7d21c . . 230398c 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 1194 , 6 + 1194 , 12 @ @ public final class CFMetaData <nl> assert attr . length = = 2 ; <nl> <nl> CfDef . _ Fields field = CfDef . _ Fields . findByName ( attr [ 1 ] ) ; <nl> + <nl> + / / this means that given field was deprecated <nl> + / / but still exists in the serialized schema <nl> + if ( field = = null ) <nl> + continue ; <nl> + <nl> cfDef . setFieldValue ( field , deserializeValue ( cfAttr . value ( ) , getValueClass ( CfDef . class , field . getFieldName ( ) ) ) ) ; <nl> } <nl> return cfDef ; <nl> diff - - git a / src / java / org / apache / cassandra / config / ColumnDefinition . java b / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> index ec79a72 . . 0ea3d10 100644 <nl> - - - a / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> + + + b / src / java / org / apache / cassandra / config / ColumnDefinition . java <nl> @ @ - 249 , 6 + 249 , 12 @ @ public class ColumnDefinition <nl> } <nl> <nl> ColumnDef . _ Fields field = ColumnDef . _ Fields . findByName ( components [ 2 ] ) ; <nl> + <nl> + / / this means that given field was deprecated <nl> + / / but still exists in the serialized schema <nl> + if ( field = = null ) <nl> + continue ; <nl> + <nl> columnDef . setFieldValue ( field , deserializeValue ( column . value ( ) , getValueClass ( ColumnDef . class , field . getFieldName ( ) ) ) ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> index 816c086 . . fb33974 100644 <nl> - - - a / src / java / org / apache / cassandra / config / KSMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / KSMetaData . java <nl> @ @ - 306 , 6 + 306 , 12 @ @ public final class KSMetaData <nl> continue ; <nl> <nl> KsDef . _ Fields field = KsDef . _ Fields . findByName ( comparator . getString ( ksAttr . name ( ) ) ) ; <nl> + <nl> + / / this means that given field was deprecated <nl> + / / but still exists in the serialized schema <nl> + if ( field = = null ) <nl> + continue ; <nl> + <nl> ksDef . setFieldValue ( field , deserializeValue ( ksAttr . value ( ) , getValueClass ( KsDef . class , field . getFieldName ( ) ) ) ) ; <nl> } <nl> <nl> @ @ - 380 , 6 + 386 , 12 @ @ public final class KSMetaData <nl> } <nl> <nl> CfDef . _ Fields field = CfDef . _ Fields . findByName ( attr [ 1 ] ) ; <nl> + <nl> + / / this means that given field was deprecated <nl> + / / but still exists in the serialized schema <nl> + if ( field = = null ) <nl> + continue ; <nl> + <nl> cfDef . setFieldValue ( field , deserializeValue ( column . value ( ) , getValueClass ( CfDef . class , field . getFieldName ( ) ) ) ) ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index fe060af . . 7d84538 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 0 . 17 
 + * Add tool to find why expired sstables are not getting dropped ( CASSANDRA - 10015 ) 
 * Remove erroneous pending HH tasks from tpstats / jmx ( CASSANDRA - 9129 ) 
 * Don ' t cast expected bf size to an int ( CASSANDRA - 9959 ) 
 * Log when messages are dropped due to cross _ node _ timeout ( CASSANDRA - 9793 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java b / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java 
 new file mode 100644 
 index 0000000 . . b5fa779 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / tools / SSTableExpiredBlockers . java 
 @ @ - 0 , 0 + 1 , 135 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . tools ; 
 + 
 + import java . io . IOException ; 
 + import java . io . PrintStream ; 
 + import java . util . Collections ; 
 + import java . util . HashSet ; 
 + import java . util . Map ; 
 + import java . util . Set ; 
 + 
 + import com . google . common . base . Throwables ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 + import com . google . common . collect . Multimap ; 
 + 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . db . Directories ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . io . sstable . Component ; 
 + import org . apache . cassandra . io . sstable . Descriptor ; 
 + import org . apache . cassandra . io . sstable . SSTableReader ; 
 + 
 + / * * 
 + * During compaction we can drop entire sstables if they only contain expired tombstones and if it is guaranteed 
 + * to not cover anything in other sstables . An expired sstable can be blocked from getting dropped if its newest 
 + * timestamp is newer than the oldest data in another sstable . 
 + * 
 + * This class outputs all sstables that are blocking other sstables from getting dropped so that a user can 
 + * figure out why certain sstables are still on disk . 
 + * / 
 + public class SSTableExpiredBlockers 
 + { 
 + public static void main ( String [ ] args ) throws IOException 
 + { 
 + PrintStream out = System . out ; 
 + if ( args . length < 2 ) 
 + { 
 + out . println ( " Usage : sstableexpiredblockers < keyspace > < table > " ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + String keyspace = args [ args . length - 2 ] ; 
 + String columnfamily = args [ args . length - 1 ] ; 
 + DatabaseDescriptor . loadSchemas ( ) ; 
 + 
 + CFMetaData metadata = Schema . instance . getCFMetaData ( keyspace , columnfamily ) ; 
 + if ( metadata = = null ) 
 + throw new IllegalArgumentException ( String . format ( " Unknown keyspace / table % s . % s " , 
 + keyspace , 
 + columnfamily ) ) ; 
 + 
 + Keyspace . openWithoutSSTables ( keyspace ) ; 
 + Directories directories = Directories . create ( keyspace , columnfamily ) ; 
 + Set < SSTableReader > sstables = new HashSet < > ( ) ; 
 + 
 + for ( Map . Entry < Descriptor , Set < Component > > sstable : directories . sstableLister ( ) . skipTemporary ( true ) . list ( ) . entrySet ( ) ) 
 + { 
 + if ( sstable . getKey ( ) ! = null ) 
 + { 
 + try 
 + { 
 + SSTableReader reader = SSTableReader . open ( sstable . getKey ( ) ) ; 
 + sstables . add ( reader ) ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + out . println ( " Couldn ' t open sstable : " + sstable . getKey ( ) . filenameFor ( Component . DATA ) ) ; 
 + Throwables . propagate ( t ) ; 
 + } 
 + } 
 + } 
 + if ( sstables . isEmpty ( ) ) 
 + { 
 + out . println ( " No sstables for " + keyspace + " . " + columnfamily ) ; 
 + System . exit ( 1 ) ; 
 + } 
 + 
 + int gcBefore = ( int ) ( System . currentTimeMillis ( ) / 1000 ) - metadata . getGcGraceSeconds ( ) ; 
 + Multimap < SSTableReader , SSTableReader > blockers = checkForExpiredSSTableBlockers ( sstables , gcBefore ) ; 
 + for ( SSTableReader blocker : blockers . keySet ( ) ) 
 + { 
 + out . println ( String . format ( " % s blocks % d expired sstables from getting dropped : % s % n " , 
 + formatForExpiryTracing ( Collections . singleton ( blocker ) ) , 
 + blockers . get ( blocker ) . size ( ) , 
 + formatForExpiryTracing ( blockers . get ( blocker ) ) ) ) ; 
 + } 
 + 
 + System . exit ( 0 ) ; 
 + } 
 + 
 + public static Multimap < SSTableReader , SSTableReader > checkForExpiredSSTableBlockers ( Iterable < SSTableReader > sstables , int gcBefore ) 
 + { 
 + Multimap < SSTableReader , SSTableReader > blockers = ArrayListMultimap . create ( ) ; 
 + for ( SSTableReader sstable : sstables ) 
 + { 
 + if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime < gcBefore ) 
 + { 
 + for ( SSTableReader potentialBlocker : sstables ) 
 + { 
 + if ( ! potentialBlocker . equals ( sstable ) & & 
 + potentialBlocker . getMinTimestamp ( ) < = sstable . getMaxTimestamp ( ) & & 
 + potentialBlocker . getSSTableMetadata ( ) . maxLocalDeletionTime > gcBefore ) 
 + blockers . put ( potentialBlocker , sstable ) ; 
 + } 
 + } 
 + } 
 + return blockers ; 
 + } 
 + 
 + private static String formatForExpiryTracing ( Iterable < SSTableReader > sstables ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + 
 + for ( SSTableReader sstable : sstables ) 
 + sb . append ( String . format ( " [ % s ( minTS = % d , maxTS = % d , maxLDT = % d ) ] " , sstable , sstable . getMinTimestamp ( ) , sstable . getMaxTimestamp ( ) , sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ) ) . append ( " , " ) ; 
 + 
 + return sb . toString ( ) ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 index 3fad0ec . . 5a83c76 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . Collections ; 
 import java . util . Set ; 
 import java . util . concurrent . ExecutionException ; 
 
 + import com . google . common . collect . Multimap ; 
 import com . google . common . collect . Sets ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 @ @ - 41 , 6 + 42 , 7 @ @ import org . apache . cassandra . db . RowMutation ; 
 import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . sstable . SSTableScanner ; 
 + import org . apache . cassandra . tools . SSTableExpiredBlockers ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertTrue ; 
 @ @ - 197 , 4 + 199 , 31 @ @ public class TTLExpiryTest extends SchemaLoader 
 cfs . clearUnsafe ( ) ; 
 } 
 
 + @ Test 
 + public void testCheckForExpiredSSTableBlockers ( ) throws InterruptedException 
 + { 
 + String KEYSPACE1 = " Keyspace1 " ; 
 + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ; 
 + cfs . truncateBlocking ( ) ; 
 + cfs . disableAutoCompaction ( ) ; 
 + cfs . metadata . gcGraceSeconds ( 0 ) ; 
 + 
 + RowMutation rm = new RowMutation ( KEYSPACE1 , Util . dk ( " test " ) . key ) ; 
 + rm . add ( " Standard1 " , ByteBufferUtil . bytes ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , System . currentTimeMillis ( ) ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + SSTableReader blockingSSTable = cfs . getSSTables ( ) . iterator ( ) . next ( ) ; 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + rm = new RowMutation ( KEYSPACE1 , Util . dk ( " test " ) . key ) ; 
 + rm . delete ( " Standard1 " , System . currentTimeMillis ( ) ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + } 
 + Multimap < SSTableReader , SSTableReader > blockers = SSTableExpiredBlockers . checkForExpiredSSTableBlockers ( cfs . getSSTables ( ) , ( int ) ( System . currentTimeMillis ( ) / 1000 ) + 100 ) ; 
 + assertEquals ( 1 , blockers . keySet ( ) . size ( ) ) ; 
 + assertTrue ( blockers . keySet ( ) . contains ( blockingSSTable ) ) ; 
 + assertEquals ( 10 , blockers . get ( blockingSSTable ) . size ( ) ) ; 
 + } 
 + 
 } 
 diff - - git a / tools / bin / sstableexpiredblockers b / tools / bin / sstableexpiredblockers 
 new file mode 100755 
 index 0000000 . . 58cefce 
 - - - / dev / null 
 + + + b / tools / bin / sstableexpiredblockers 
 @ @ - 0 , 0 + 1 , 49 @ @ 
 + # ! / bin / sh 
 + 
 + # Licensed to the Apache Software Foundation ( ASF ) under one 
 + # or more contributor license agreements . See the NOTICE file 
 + # distributed with this work for additional information 
 + # regarding copyright ownership . The ASF licenses this file 
 + # to you under the Apache License , Version 2 . 0 ( the 
 + # " License " ) ; you may not use this file except in compliance 
 + # with the License . You may obtain a copy of the License at 
 + # 
 + # http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + # 
 + # Unless required by applicable law or agreed to in writing , software 
 + # distributed under the License is distributed on an " AS IS " BASIS , 
 + # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + # See the License for the specific language governing permissions and 
 + # limitations under the License . 
 + 
 + if [ " x $ CASSANDRA _ INCLUDE " = " x " ] ; then 
 + for include in " ` dirname $ 0 ` / cassandra . in . sh " \ 
 + " $ HOME / . cassandra . in . sh " \ 
 + / usr / share / cassandra / cassandra . in . sh \ 
 + / usr / local / share / cassandra / cassandra . in . sh \ 
 + / opt / cassandra / cassandra . in . sh ; do 
 + if [ - r $ include ] ; then 
 + . $ include 
 + break 
 + fi 
 + done 
 + elif [ - r $ CASSANDRA _ INCLUDE ] ; then 
 + . $ CASSANDRA _ INCLUDE 
 + fi 
 + 
 + 
 + # Use JAVA _ HOME if set , otherwise look for java in PATH 
 + if [ - x $ JAVA _ HOME / bin / java ] ; then 
 + JAVA = $ JAVA _ HOME / bin / java 
 + else 
 + JAVA = ` which java ` 
 + fi 
 + 
 + if [ - z " $ CLASSPATH " ] ; then 
 + echo " You must set the CLASSPATH var " > & 2 
 + exit 1 
 + fi 
 + 
 + " $ JAVA " - cp " $ CLASSPATH " - Dstorage - config = $ CASSANDRA _ CONF \ 
 + - Dlog4j . configuration = log4j - tools . properties \ 
 + org . apache . cassandra . tools . SSTableExpiredBlockers " $ @ "

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c8ccc24 . . 2cc8c52 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * add a convenient way to reset a node ' s schema ( CASSANDRA - 2963 ) 
 * fix for intermittent SchemaDisagreementException ( CASSANDRA - 3884 ) 
 * CLI ` list < CF > ` to limit number of columns and their order ( CASSANDRA - 3012 ) 
 + * ignore deprecated KsDef / CfDef / ColumnDef fields in native schema ( CASSANDRA - 3963 ) 
 Merged from 1 . 0 : 
 * remove the wait on hint future during write ( CASSANDRA - 3870 ) 
 * ( cqlsh ) ignore missing CfDef opts ( CASSANDRA - 3933 ) 
 diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 5f7d21c . . 230398c 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 1194 , 6 + 1194 , 12 @ @ public final class CFMetaData 
 assert attr . length = = 2 ; 
 
 CfDef . _ Fields field = CfDef . _ Fields . findByName ( attr [ 1 ] ) ; 
 + 
 + / / this means that given field was deprecated 
 + / / but still exists in the serialized schema 
 + if ( field = = null ) 
 + continue ; 
 + 
 cfDef . setFieldValue ( field , deserializeValue ( cfAttr . value ( ) , getValueClass ( CfDef . class , field . getFieldName ( ) ) ) ) ; 
 } 
 return cfDef ; 
 diff - - git a / src / java / org / apache / cassandra / config / ColumnDefinition . java b / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 index ec79a72 . . 0ea3d10 100644 
 - - - a / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 + + + b / src / java / org / apache / cassandra / config / ColumnDefinition . java 
 @ @ - 249 , 6 + 249 , 12 @ @ public class ColumnDefinition 
 } 
 
 ColumnDef . _ Fields field = ColumnDef . _ Fields . findByName ( components [ 2 ] ) ; 
 + 
 + / / this means that given field was deprecated 
 + / / but still exists in the serialized schema 
 + if ( field = = null ) 
 + continue ; 
 + 
 columnDef . setFieldValue ( field , deserializeValue ( column . value ( ) , getValueClass ( ColumnDef . class , field . getFieldName ( ) ) ) ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / config / KSMetaData . java b / src / java / org / apache / cassandra / config / KSMetaData . java 
 index 816c086 . . fb33974 100644 
 - - - a / src / java / org / apache / cassandra / config / KSMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / KSMetaData . java 
 @ @ - 306 , 6 + 306 , 12 @ @ public final class KSMetaData 
 continue ; 
 
 KsDef . _ Fields field = KsDef . _ Fields . findByName ( comparator . getString ( ksAttr . name ( ) ) ) ; 
 + 
 + / / this means that given field was deprecated 
 + / / but still exists in the serialized schema 
 + if ( field = = null ) 
 + continue ; 
 + 
 ksDef . setFieldValue ( field , deserializeValue ( ksAttr . value ( ) , getValueClass ( KsDef . class , field . getFieldName ( ) ) ) ) ; 
 } 
 
 @ @ - 380 , 6 + 386 , 12 @ @ public final class KSMetaData 
 } 
 
 CfDef . _ Fields field = CfDef . _ Fields . findByName ( attr [ 1 ] ) ; 
 + 
 + / / this means that given field was deprecated 
 + / / but still exists in the serialized schema 
 + if ( field = = null ) 
 + continue ; 
 + 
 cfDef . setFieldValue ( field , deserializeValue ( column . value ( ) , getValueClass ( CfDef . class , field . getFieldName ( ) ) ) ) ; 
 } 

