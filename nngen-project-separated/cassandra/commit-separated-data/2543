BLEU SCORE: 0.06870636427700047

TEST MSG: Increase default CL space to 8GB
GENERATED MSG: update default commitlog segment and total size

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 07fc3f9 . . 211e55c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - beta2 <nl> + * Increase default CL space to 8GB ( CASSANDRA - 7031 ) <nl> * Add range tombstones to read repair digests ( CASSANDRA - 6863 ) <nl> * Fix BTree . clear for large updates ( CASSANDRA - 6943 ) <nl> * Fail write instead of logging a warning when unable to append to CL <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 20bda79 . . 8ed796b 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 287 , 13 + 287 , 13 @ @ memtable _ allocation _ type : heap _ buffers <nl> <nl> # Total space to use for commitlogs . Since commitlog segments are <nl> # mmapped , and hence use up address space , the default size is 32 <nl> - # on 32 - bit JVMs , and 1024 on 64 - bit JVMs . <nl> + # on 32 - bit JVMs , and 8192 on 64 - bit JVMs . <nl> # <nl> # If space gets above this value ( it will round up to the next nearest <nl> # segment multiple ) , Cassandra will flush every dirty CF in the oldest <nl> # segment and remove it . So a small total commitlog space will tend <nl> # to cause more flush activity on less - active columnfamilies . <nl> - # commitlog _ total _ space _ in _ mb : 4096 <nl> + # commitlog _ total _ space _ in _ mb : 8192 <nl> <nl> # This sets the amount of memtable flush writer threads . These will <nl> # be blocked by disk io , and each one will hold a memtable in memory <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 9f8a0df . . ef2c4fc 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 187 , 7 + 187 , 7 @ @ public class DatabaseDescriptor <nl> } <nl> <nl> if ( conf . commitlog _ total _ space _ in _ mb = = null ) <nl> - conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 1024 : 32 ; <nl> + conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 8192 : 32 ; <nl> <nl> / * evaluate the DiskAccessMode Config directive , which also affects indexAccessMode selection * / <nl> if ( conf . disk _ access _ mode = = Config . DiskAccessMode . auto )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ecda2dc . . 6b3aba2 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 1 . 2 - dev <nl> + * improve " nodetool ring " handling of multi - dc clusters ( CASSANDRA - 3047 ) <nl> * update NTS calculateNaturalEndpoints to be O ( N log N ) ( CASSANDRA - 3881 ) <nl> * add UseCondCardMark XX jvm settings on jdk 1 . 7 ( CASSANDRA - 4366 ) <nl> * split up rpc timeout by operation type ( CASSANDRA - 2819 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 74da07e . . e196f7c 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 25 , 17 + 25 , 13 @ @ import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> - import java . util . Map . Entry ; <nl> import java . util . concurrent . * ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> import javax . management . MBeanServer ; <nl> import javax . management . ObjectName ; <nl> <nl> - import com . google . common . base . Supplier ; <nl> + import com . google . common . base . Function ; <nl> import com . google . common . collect . * ; <nl> - <nl> - import org . apache . cassandra . dht . Range ; <nl> - import org . apache . cassandra . metrics . ClientRequestMetrics ; <nl> import org . apache . log4j . Level ; <nl> import org . apache . commons . lang . StringUtils ; <nl> import org . slf4j . Logger ; <nl> @ @ - 49 , 23 + 45 , 21 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . Table ; <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . dht . * ; <nl> + import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . gms . * ; <nl> import org . apache . cassandra . io . sstable . SSTableDeletingTask ; <nl> import org . apache . cassandra . io . sstable . SSTableLoader ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> - import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> - import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> - import org . apache . cassandra . locator . IEndpointSnitch ; <nl> - import org . apache . cassandra . locator . TokenMetadata ; <nl> - import org . apache . cassandra . net . * ; <nl> + import org . apache . cassandra . locator . * ; <nl> + import org . apache . cassandra . metrics . ClientRequestMetrics ; <nl> + import org . apache . cassandra . net . IAsyncResult ; <nl> + import org . apache . cassandra . net . MessageOut ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . ResponseVerbHandler ; <nl> import org . apache . cassandra . service . AntiEntropyService . TreeRequestVerbHandler ; <nl> import org . apache . cassandra . streaming . * ; <nl> import org . apache . cassandra . thrift . * ; <nl> - import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . NodeId ; <nl> - import org . apache . cassandra . utils . Pair ; <nl> - import org . apache . cassandra . utils . OutputHandler ; <nl> - import org . apache . cassandra . utils . WrappedRunnable ; <nl> + import org . apache . cassandra . utils . * ; <nl> <nl> / * * <nl> * This abstraction contains the token / identifier of this node <nl> @ @ - 958 , 25 + 952 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> return rangeToEndpointMap ; <nl> } <nl> <nl> - private Map < InetAddress , Collection < Range < Token > > > constructEndpointToRangeMap ( String keyspace ) <nl> - { <nl> - Multimap < InetAddress , Range < Token > > endpointToRangeMap = Multimaps . newListMultimap ( new HashMap < InetAddress , Collection < Range < Token > > > ( ) , new Supplier < List < Range < Token > > > ( ) <nl> - { <nl> - public List < Range < Token > > get ( ) <nl> - { <nl> - return Lists . newArrayList ( ) ; <nl> - } <nl> - } ) ; <nl> - <nl> - List < Range < Token > > ranges = getAllRanges ( tokenMetadata . sortedTokens ( ) ) ; <nl> - for ( Range < Token > range : ranges ) <nl> - { <nl> - for ( InetAddress endpoint : Table . open ( keyspace ) . getReplicationStrategy ( ) . getNaturalEndpoints ( range . left ) ) <nl> - endpointToRangeMap . put ( endpoint , range ) ; <nl> - } <nl> - return endpointToRangeMap . asMap ( ) ; <nl> - } <nl> - <nl> / * <nl> * Handle the reception of a new particular ApplicationState for a particular endpoint . Note that the value of the <nl> * ApplicationState has not necessarily " changed " since the last known value , if we already received the same update <nl> @ @ - 2759 , 22 + 2734 , 35 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> StorageProxy . truncateBlocking ( keyspace , columnFamily ) ; <nl> } <nl> <nl> - public Map < String , Float > getOwnership ( ) <nl> + public boolean isDcAwareReplicationStrategy ( String keyspace ) <nl> { <nl> - List < Token > sortedTokens = new ArrayList < Token > ( tokenMetadata . getTokenToEndpointMapForReading ( ) . keySet ( ) ) ; <nl> + return SimpleStrategy . class ! = Table . open ( keyspace ) . getReplicationStrategy ( ) . getClass ( ) ; <nl> + } <nl> + <nl> + public Map < InetAddress , Float > getOwnership ( ) <nl> + { <nl> + Map < Token , InetAddress > tokensToEndpoints = tokenMetadata . getTokenToEndpointMapForReading ( ) ; <nl> + List < Token > sortedTokens = new ArrayList < Token > ( tokensToEndpoints . keySet ( ) ) ; <nl> Collections . sort ( sortedTokens ) ; <nl> - Map < Token , Float > token _ map = getPartitioner ( ) . describeOwnership ( sortedTokens ) ; <nl> - Map < String , Float > string _ map = new HashMap < String , Float > ( ) ; <nl> - for ( Map . Entry < Token , Float > entry : token _ map . entrySet ( ) ) <nl> - { <nl> - string _ map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; <nl> - } <nl> - return string _ map ; <nl> + / / describeOwnership returns tokens in an unspecified order , let ' s re - order them <nl> + Map < Token , Float > tokenMap = new TreeMap < Token , Float > ( getPartitioner ( ) . describeOwnership ( sortedTokens ) ) ; <nl> + Map < InetAddress , Float > stringMap = new LinkedHashMap < InetAddress , Float > ( ) ; <nl> + for ( Map . Entry < Token , Float > entry : tokenMap . entrySet ( ) ) <nl> + stringMap . put ( tokensToEndpoints . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; <nl> + return stringMap ; <nl> } <nl> <nl> - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException <nl> + / * * <nl> + * Calculates ownership . If there are multiple DC ' s and the replication strategy is DC aware then ownership will be <nl> + * calculated per dc , i . e . each DC will have total ring ownership divided amongst its nodes . Without replication <nl> + * total ownership will be a multiple of the number of DC ' s and this value will then go up within each DC depending <nl> + * on the number of replicas within itself . For DC unaware replication strategies , ownership without replication <nl> + * will be 100 % . <nl> + * <nl> + * @ throws ConfigurationException <nl> + * / <nl> + public LinkedHashMap < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException <nl> { <nl> - Map < String , Float > effective = Maps . newHashMap ( ) ; <nl> if ( Schema . instance . getNonSystemTables ( ) . size ( ) < = 0 ) <nl> throw new ConfigurationException ( " Couldn ' t find any Non System Keyspaces to infer replication topology " ) ; <nl> if ( keyspace = = null & & ! hasSameReplication ( Schema . instance . getNonSystemTables ( ) ) ) <nl> @ @ - 2783 , 22 + 2771 , 65 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> if ( keyspace = = null ) <nl> keyspace = Schema . instance . getNonSystemTables ( ) . get ( 0 ) ; <nl> <nl> - List < Token > sortedTokens = new ArrayList < Token > ( tokenMetadata . getTokenToEndpointMapForReading ( ) . keySet ( ) ) ; <nl> - Collections . sort ( sortedTokens ) ; <nl> - Map < Token , Float > ownership = getPartitioner ( ) . describeOwnership ( sortedTokens ) ; <nl> + final BiMap < InetAddress , Token > endpointsToTokens = ImmutableBiMap . copyOf ( tokenMetadata . getTokenToEndpointMapForReading ( ) ) . inverse ( ) ; <nl> <nl> - for ( Entry < InetAddress , Collection < Range < Token > > > ranges : constructEndpointToRangeMap ( keyspace ) . entrySet ( ) ) <nl> + Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < Collection < InetAddress > > ( ) ; <nl> + if ( isDcAwareReplicationStrategy ( keyspace ) ) <nl> + { <nl> + / / mapping of dc ' s to nodes , use sorted map so that we get dcs sorted <nl> + SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < String , Collection < InetAddress > > ( ) ; <nl> + sortedDcsToEndpoints . putAll ( tokenMetadata . getTopology ( ) . getDatacenterEndpoints ( ) . asMap ( ) ) ; <nl> + for ( Collection < InetAddress > endpoints : sortedDcsToEndpoints . values ( ) ) <nl> + endpointsGroupedByDc . add ( endpoints ) ; <nl> + } <nl> + else <nl> { <nl> - Token token = tokenMetadata . getToken ( ranges . getKey ( ) ) ; <nl> - for ( Range < Token > range : ranges . getValue ( ) ) <nl> + endpointsGroupedByDc . add ( endpointsToTokens . keySet ( ) ) ; <nl> + } <nl> + <nl> + LinkedHashMap < InetAddress , Float > finalOwnership = Maps . newLinkedHashMap ( ) ; <nl> + <nl> + / / calculate ownership per dc <nl> + for ( Collection < InetAddress > endpoints : endpointsGroupedByDc ) <nl> + { <nl> + / / sort the endpoints by their tokens <nl> + List < InetAddress > sortedEndpoints = Lists . newArrayListWithExpectedSize ( endpoints . size ( ) ) ; <nl> + sortedEndpoints . addAll ( endpoints ) ; <nl> + <nl> + Collections . sort ( sortedEndpoints , new Comparator < InetAddress > ( ) <nl> { <nl> - float value = effective . get ( token . toString ( ) ) = = null ? 0 . 0F : effective . get ( token . toString ( ) ) ; <nl> - effective . put ( token . toString ( ) , value + ownership . get ( range . left ) ) ; <nl> + public int compare ( InetAddress o1 , InetAddress o2 ) <nl> + { <nl> + return endpointsToTokens . get ( o1 ) . compareTo ( endpointsToTokens . get ( o2 ) ) ; <nl> + } <nl> + } ) ; <nl> + <nl> + / / calculate the ownership without replication <nl> + Function < InetAddress , Token > f = new Function < InetAddress , Token > ( ) <nl> + { <nl> + public Token apply ( InetAddress arg0 ) <nl> + { <nl> + return endpointsToTokens . get ( arg0 ) ; <nl> + } <nl> + } ; <nl> + Map < Token , Float > tokenOwnership = getPartitioner ( ) . describeOwnership ( Lists . transform ( sortedEndpoints , f ) ) ; <nl> + <nl> + / / calculate the ownership with replication and add the endpoint to the final ownership map <nl> + for ( InetAddress endpoint : endpoints ) <nl> + { <nl> + float ownership = 0 . 0f ; <nl> + for ( Range < Token > range : getRangesForEndpoint ( keyspace , endpoint ) ) <nl> + { <nl> + if ( tokenOwnership . containsKey ( range . left ) ) <nl> + ownership + = tokenOwnership . get ( range . left ) ; <nl> + } <nl> + finalOwnership . put ( endpoint , ownership ) ; <nl> } <nl> } <nl> - return effective ; <nl> + return finalOwnership ; <nl> } <nl> <nl> + <nl> private boolean hasSameReplication ( List < String > list ) <nl> { <nl> if ( list . isEmpty ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index ff1ec03 . . 80ba05f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ import java . io . IOException ; <nl> import java . net . InetAddress ; <nl> import java . net . UnknownHostException ; <nl> import java . nio . ByteBuffer ; <nl> + import java . util . LinkedHashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . concurrent . ExecutionException ; <nl> @ @ - 328 , 7 + 329 , 7 @ @ public interface StorageServiceMBean <nl> * given a list of tokens ( representing the nodes in the cluster ) , returns <nl> * a mapping from " token - > % age of cluster owned by that token " <nl> * / <nl> - public Map < String , Float > getOwnership ( ) ; <nl> + public Map < InetAddress , Float > getOwnership ( ) ; <nl> <nl> / * * <nl> * Effective ownership is % of the data each node owns given the keyspace <nl> @ @ - 337 , 7 + 338 , 7 @ @ public interface StorageServiceMBean <nl> * in the cluster have the same replication strategies and if yes then we will <nl> * use the first else a empty Map is returned . <nl> * / <nl> - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException ; <nl> + public Map < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException ; <nl> <nl> public List < String > getKeyspaces ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 315e9c3 . . 808494e 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 28 , 8 + 28 , 8 @ @ import java . util . * ; <nl> import java . util . Map . Entry ; <nl> import java . util . concurrent . ExecutionException ; <nl> <nl> - import org . apache . cassandra . service . CacheServiceMBean ; <nl> - import org . apache . cassandra . service . StorageProxyMBean ; <nl> + import com . google . common . collect . ImmutableBiMap ; <nl> + import com . google . common . collect . Maps ; <nl> import org . apache . commons . cli . * ; <nl> <nl> import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutorMBean ; <nl> @ @ - 38 , 6 + 38 , 8 @ @ import org . apache . cassandra . db . ColumnFamilyStoreMBean ; <nl> import org . apache . cassandra . db . compaction . CompactionManagerMBean ; <nl> import org . apache . cassandra . db . compaction . OperationType ; <nl> import org . apache . cassandra . net . MessagingServiceMBean ; <nl> + import org . apache . cassandra . service . CacheServiceMBean ; <nl> + import org . apache . cassandra . service . StorageProxyMBean ; <nl> import org . apache . cassandra . thrift . InvalidRequestException ; <nl> import org . apache . cassandra . utils . EstimatedHistogram ; <nl> import org . apache . cassandra . utils . Pair ; <nl> @ @ - 208 , 14 + 210 , 53 @ @ public class NodeCmd <nl> <nl> / * * <nl> * Write a textual representation of the Cassandra ring . <nl> - * <nl> - * @ param outs the stream to write to <nl> + * <nl> + * @ param outs <nl> + * the stream to write to <nl> * / <nl> public void printRing ( PrintStream outs , String keyspace ) <nl> { <nl> - Map < String , String > tokenToEndpoint = probe . getTokenToEndpointMap ( ) ; <nl> - List < String > sortedTokens = new ArrayList < String > ( tokenToEndpoint . keySet ( ) ) ; <nl> + Map < String , String > endpointsToTokens = ImmutableBiMap . copyOf ( probe . getTokenToEndpointMap ( ) ) . inverse ( ) ; <nl> + String format = " % - 16s % - 12s % - 7s % - 8s % - 16s % - 20s % - 44s % n " ; <nl> <nl> + / / Calculate per - token ownership of the ring <nl> + Map < InetAddress , Float > ownerships ; <nl> + boolean keyspaceSelected ; <nl> + try <nl> + { <nl> + ownerships = probe . effectiveOwnership ( keyspace ) ; <nl> + keyspaceSelected = true ; <nl> + } <nl> + catch ( ConfigurationException ex ) <nl> + { <nl> + ownerships = probe . getOwnership ( ) ; <nl> + outs . printf ( " Note : Ownership information does not include topology ; for complete information , specify a keyspace % n " ) ; <nl> + keyspaceSelected = false ; <nl> + } <nl> + try <nl> + { <nl> + outs . println ( ) ; <nl> + Map < String , Map < InetAddress , Float > > perDcOwnerships = Maps . newLinkedHashMap ( ) ; <nl> + / / get the different datasets and map to tokens <nl> + for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) <nl> + { <nl> + String dc = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; <nl> + if ( ! perDcOwnerships . containsKey ( dc ) ) <nl> + perDcOwnerships . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; <nl> + perDcOwnerships . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; <nl> + } <nl> + for ( Map . Entry < String , Map < InetAddress , Float > > entry : perDcOwnerships . entrySet ( ) ) <nl> + printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; <nl> + } <nl> + catch ( UnknownHostException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + private void printDc ( PrintStream outs , String format , String dc , Map < String , String > endpointsToTokens , <nl> + boolean keyspaceSelected , Map < InetAddress , Float > filteredOwnerships ) <nl> + { <nl> Collection < String > liveNodes = probe . getLiveNodes ( ) ; <nl> Collection < String > deadNodes = probe . getUnreachableNodes ( ) ; <nl> Collection < String > joiningNodes = probe . getJoiningNodes ( ) ; <nl> @ @ - 223 , 69 + 264 , 64 @ @ public class NodeCmd <nl> Collection < String > movingNodes = probe . getMovingNodes ( ) ; <nl> Map < String , String > loadMap = probe . getLoadMap ( ) ; <nl> <nl> - String format = " % - 16s % - 12s % - 12s % - 7s % - 8s % - 16s % - 20s % - 44s % n " ; <nl> + outs . println ( " Datacenter : " + dc ) ; <nl> + outs . println ( " = = = = = = = = = = " ) ; <nl> <nl> - / / Calculate per - token ownership of the ring <nl> - Map < String , Float > ownerships ; <nl> - try <nl> - { <nl> - ownerships = probe . effectiveOwnership ( keyspace ) ; <nl> - outs . printf ( format , " Address " , " DC " , " Rack " , " Status " , " State " , " Load " , " Effective - Ownership " , " Token " ) ; <nl> - } <nl> - catch ( ConfigurationException ex ) <nl> + / / get the total amount of replicas for this dc and the last token in this dc ' s ring <nl> + float totalReplicas = 0f ; <nl> + String lastToken = " " ; <nl> + for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) <nl> { <nl> - ownerships = probe . getOwnership ( ) ; <nl> - outs . printf ( " Note : Ownership information does not include topology , please specify a keyspace . % n " ) ; <nl> - outs . printf ( format , " Address " , " DC " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; <nl> + lastToken = endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ; <nl> + totalReplicas + = entry . getValue ( ) ; <nl> } <nl> + <nl> + <nl> + if ( keyspaceSelected ) <nl> + outs . print ( " Replicas : " + ( int ) totalReplicas + " \ n \ n " ) ; <nl> <nl> - / / show pre - wrap token twice so you can always read a node ' s range as <nl> - / / ( previous line token , current line token ] <nl> - if ( sortedTokens . size ( ) > 1 ) <nl> - outs . printf ( format , " " , " " , " " , " " , " " , " " , " " , sortedTokens . get ( sortedTokens . size ( ) - 1 ) ) ; <nl> + outs . printf ( format , " Address " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; <nl> <nl> - for ( String token : sortedTokens ) <nl> + if ( filteredOwnerships . size ( ) > 1 ) <nl> + outs . printf ( format , " " , " " , " " , " " , " " , " " , lastToken ) ; <nl> + else <nl> + outs . println ( ) ; <nl> + <nl> + for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) <nl> { <nl> - String primaryEndpoint = tokenToEndpoint . get ( token ) ; <nl> - String dataCenter ; <nl> - try <nl> - { <nl> - dataCenter = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( primaryEndpoint ) ; <nl> - } <nl> - catch ( UnknownHostException e ) <nl> - { <nl> - dataCenter = " Unknown " ; <nl> - } <nl> + String endpoint = entry . getKey ( ) . getHostAddress ( ) ; <nl> + String token = endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ; <nl> String rack ; <nl> try <nl> { <nl> - rack = probe . getEndpointSnitchInfoProxy ( ) . getRack ( primaryEndpoint ) ; <nl> + rack = probe . getEndpointSnitchInfoProxy ( ) . getRack ( endpoint ) ; <nl> } <nl> catch ( UnknownHostException e ) <nl> { <nl> rack = " Unknown " ; <nl> } <nl> - String status = liveNodes . contains ( primaryEndpoint ) <nl> - ? " Up " <nl> - : deadNodes . contains ( primaryEndpoint ) <nl> - ? " Down " <nl> - : " ? " ; <nl> + String status = liveNodes . contains ( endpoint ) <nl> + ? " Up " <nl> + : deadNodes . contains ( endpoint ) <nl> + ? " Down " <nl> + : " ? " ; <nl> <nl> String state = " Normal " ; <nl> <nl> - if ( joiningNodes . contains ( primaryEndpoint ) ) <nl> + if ( joiningNodes . contains ( endpoint ) ) <nl> state = " Joining " ; <nl> - else if ( leavingNodes . contains ( primaryEndpoint ) ) <nl> + else if ( leavingNodes . contains ( endpoint ) ) <nl> state = " Leaving " ; <nl> - else if ( movingNodes . contains ( primaryEndpoint ) ) <nl> + else if ( movingNodes . contains ( endpoint ) ) <nl> state = " Moving " ; <nl> <nl> - String load = loadMap . containsKey ( primaryEndpoint ) <nl> - ? loadMap . get ( primaryEndpoint ) <nl> - : " ? " ; <nl> - String owns = new DecimalFormat ( " # # 0 . 00 % " ) . format ( ownerships . get ( token ) = = null ? 0 . 0F : ownerships . get ( token ) ) ; <nl> - outs . printf ( format , primaryEndpoint , dataCenter , rack , status , state , load , owns , token ) ; <nl> + String load = loadMap . containsKey ( endpoint ) <nl> + ? loadMap . get ( endpoint ) <nl> + : " ? " ; <nl> + String owns = new DecimalFormat ( " # # 0 . 00 % " ) . format ( entry . getValue ( ) ) ; <nl> + outs . printf ( format , entry . getKey ( ) , rack , status , state , load , owns , token ) ; <nl> } <nl> + outs . println ( ) ; <nl> } <nl> <nl> / * * Writes a table of host IDs to a PrintStream * / <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index f6de85b . . 8ad8b92 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 263 , 12 + 263 , 12 @ @ public class NodeProbe <nl> return ssProxy . getLoadMap ( ) ; <nl> } <nl> <nl> - public Map < String , Float > getOwnership ( ) <nl> + public Map < InetAddress , Float > getOwnership ( ) <nl> { <nl> return ssProxy . getOwnership ( ) ; <nl> } <nl> <nl> - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException <nl> + public Map < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException <nl> { <nl> return ssProxy . effectiveOwnership ( keyspace ) ; <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 07fc3f9 . . 211e55c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - beta2 
 + * Increase default CL space to 8GB ( CASSANDRA - 7031 ) 
 * Add range tombstones to read repair digests ( CASSANDRA - 6863 ) 
 * Fix BTree . clear for large updates ( CASSANDRA - 6943 ) 
 * Fail write instead of logging a warning when unable to append to CL 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 20bda79 . . 8ed796b 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 287 , 13 + 287 , 13 @ @ memtable _ allocation _ type : heap _ buffers 
 
 # Total space to use for commitlogs . Since commitlog segments are 
 # mmapped , and hence use up address space , the default size is 32 
 - # on 32 - bit JVMs , and 1024 on 64 - bit JVMs . 
 + # on 32 - bit JVMs , and 8192 on 64 - bit JVMs . 
 # 
 # If space gets above this value ( it will round up to the next nearest 
 # segment multiple ) , Cassandra will flush every dirty CF in the oldest 
 # segment and remove it . So a small total commitlog space will tend 
 # to cause more flush activity on less - active columnfamilies . 
 - # commitlog _ total _ space _ in _ mb : 4096 
 + # commitlog _ total _ space _ in _ mb : 8192 
 
 # This sets the amount of memtable flush writer threads . These will 
 # be blocked by disk io , and each one will hold a memtable in memory 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 9f8a0df . . ef2c4fc 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 187 , 7 + 187 , 7 @ @ public class DatabaseDescriptor 
 } 
 
 if ( conf . commitlog _ total _ space _ in _ mb = = null ) 
 - conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 1024 : 32 ; 
 + conf . commitlog _ total _ space _ in _ mb = hasLargeAddressSpace ( ) ? 8192 : 32 ; 
 
 / * evaluate the DiskAccessMode Config directive , which also affects indexAccessMode selection * / 
 if ( conf . disk _ access _ mode = = Config . DiskAccessMode . auto )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ecda2dc . . 6b3aba2 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 1 . 2 - dev 
 + * improve " nodetool ring " handling of multi - dc clusters ( CASSANDRA - 3047 ) 
 * update NTS calculateNaturalEndpoints to be O ( N log N ) ( CASSANDRA - 3881 ) 
 * add UseCondCardMark XX jvm settings on jdk 1 . 7 ( CASSANDRA - 4366 ) 
 * split up rpc timeout by operation type ( CASSANDRA - 2819 ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 74da07e . . e196f7c 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 25 , 17 + 25 , 13 @ @ import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 - import java . util . Map . Entry ; 
 import java . util . concurrent . * ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 import javax . management . MBeanServer ; 
 import javax . management . ObjectName ; 
 
 - import com . google . common . base . Supplier ; 
 + import com . google . common . base . Function ; 
 import com . google . common . collect . * ; 
 - 
 - import org . apache . cassandra . dht . Range ; 
 - import org . apache . cassandra . metrics . ClientRequestMetrics ; 
 import org . apache . log4j . Level ; 
 import org . apache . commons . lang . StringUtils ; 
 import org . slf4j . Logger ; 
 @ @ - 49 , 23 + 45 , 21 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . Table ; 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . dht . * ; 
 + import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . gms . * ; 
 import org . apache . cassandra . io . sstable . SSTableDeletingTask ; 
 import org . apache . cassandra . io . sstable . SSTableLoader ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 - import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 - import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 - import org . apache . cassandra . locator . IEndpointSnitch ; 
 - import org . apache . cassandra . locator . TokenMetadata ; 
 - import org . apache . cassandra . net . * ; 
 + import org . apache . cassandra . locator . * ; 
 + import org . apache . cassandra . metrics . ClientRequestMetrics ; 
 + import org . apache . cassandra . net . IAsyncResult ; 
 + import org . apache . cassandra . net . MessageOut ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . ResponseVerbHandler ; 
 import org . apache . cassandra . service . AntiEntropyService . TreeRequestVerbHandler ; 
 import org . apache . cassandra . streaming . * ; 
 import org . apache . cassandra . thrift . * ; 
 - import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . NodeId ; 
 - import org . apache . cassandra . utils . Pair ; 
 - import org . apache . cassandra . utils . OutputHandler ; 
 - import org . apache . cassandra . utils . WrappedRunnable ; 
 + import org . apache . cassandra . utils . * ; 
 
 / * * 
 * This abstraction contains the token / identifier of this node 
 @ @ - 958 , 25 + 952 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 return rangeToEndpointMap ; 
 } 
 
 - private Map < InetAddress , Collection < Range < Token > > > constructEndpointToRangeMap ( String keyspace ) 
 - { 
 - Multimap < InetAddress , Range < Token > > endpointToRangeMap = Multimaps . newListMultimap ( new HashMap < InetAddress , Collection < Range < Token > > > ( ) , new Supplier < List < Range < Token > > > ( ) 
 - { 
 - public List < Range < Token > > get ( ) 
 - { 
 - return Lists . newArrayList ( ) ; 
 - } 
 - } ) ; 
 - 
 - List < Range < Token > > ranges = getAllRanges ( tokenMetadata . sortedTokens ( ) ) ; 
 - for ( Range < Token > range : ranges ) 
 - { 
 - for ( InetAddress endpoint : Table . open ( keyspace ) . getReplicationStrategy ( ) . getNaturalEndpoints ( range . left ) ) 
 - endpointToRangeMap . put ( endpoint , range ) ; 
 - } 
 - return endpointToRangeMap . asMap ( ) ; 
 - } 
 - 
 / * 
 * Handle the reception of a new particular ApplicationState for a particular endpoint . Note that the value of the 
 * ApplicationState has not necessarily " changed " since the last known value , if we already received the same update 
 @ @ - 2759 , 22 + 2734 , 35 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 StorageProxy . truncateBlocking ( keyspace , columnFamily ) ; 
 } 
 
 - public Map < String , Float > getOwnership ( ) 
 + public boolean isDcAwareReplicationStrategy ( String keyspace ) 
 { 
 - List < Token > sortedTokens = new ArrayList < Token > ( tokenMetadata . getTokenToEndpointMapForReading ( ) . keySet ( ) ) ; 
 + return SimpleStrategy . class ! = Table . open ( keyspace ) . getReplicationStrategy ( ) . getClass ( ) ; 
 + } 
 + 
 + public Map < InetAddress , Float > getOwnership ( ) 
 + { 
 + Map < Token , InetAddress > tokensToEndpoints = tokenMetadata . getTokenToEndpointMapForReading ( ) ; 
 + List < Token > sortedTokens = new ArrayList < Token > ( tokensToEndpoints . keySet ( ) ) ; 
 Collections . sort ( sortedTokens ) ; 
 - Map < Token , Float > token _ map = getPartitioner ( ) . describeOwnership ( sortedTokens ) ; 
 - Map < String , Float > string _ map = new HashMap < String , Float > ( ) ; 
 - for ( Map . Entry < Token , Float > entry : token _ map . entrySet ( ) ) 
 - { 
 - string _ map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; 
 - } 
 - return string _ map ; 
 + / / describeOwnership returns tokens in an unspecified order , let ' s re - order them 
 + Map < Token , Float > tokenMap = new TreeMap < Token , Float > ( getPartitioner ( ) . describeOwnership ( sortedTokens ) ) ; 
 + Map < InetAddress , Float > stringMap = new LinkedHashMap < InetAddress , Float > ( ) ; 
 + for ( Map . Entry < Token , Float > entry : tokenMap . entrySet ( ) ) 
 + stringMap . put ( tokensToEndpoints . get ( entry . getKey ( ) ) , entry . getValue ( ) ) ; 
 + return stringMap ; 
 } 
 
 - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException 
 + / * * 
 + * Calculates ownership . If there are multiple DC ' s and the replication strategy is DC aware then ownership will be 
 + * calculated per dc , i . e . each DC will have total ring ownership divided amongst its nodes . Without replication 
 + * total ownership will be a multiple of the number of DC ' s and this value will then go up within each DC depending 
 + * on the number of replicas within itself . For DC unaware replication strategies , ownership without replication 
 + * will be 100 % . 
 + * 
 + * @ throws ConfigurationException 
 + * / 
 + public LinkedHashMap < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException 
 { 
 - Map < String , Float > effective = Maps . newHashMap ( ) ; 
 if ( Schema . instance . getNonSystemTables ( ) . size ( ) < = 0 ) 
 throw new ConfigurationException ( " Couldn ' t find any Non System Keyspaces to infer replication topology " ) ; 
 if ( keyspace = = null & & ! hasSameReplication ( Schema . instance . getNonSystemTables ( ) ) ) 
 @ @ - 2783 , 22 + 2771 , 65 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 if ( keyspace = = null ) 
 keyspace = Schema . instance . getNonSystemTables ( ) . get ( 0 ) ; 
 
 - List < Token > sortedTokens = new ArrayList < Token > ( tokenMetadata . getTokenToEndpointMapForReading ( ) . keySet ( ) ) ; 
 - Collections . sort ( sortedTokens ) ; 
 - Map < Token , Float > ownership = getPartitioner ( ) . describeOwnership ( sortedTokens ) ; 
 + final BiMap < InetAddress , Token > endpointsToTokens = ImmutableBiMap . copyOf ( tokenMetadata . getTokenToEndpointMapForReading ( ) ) . inverse ( ) ; 
 
 - for ( Entry < InetAddress , Collection < Range < Token > > > ranges : constructEndpointToRangeMap ( keyspace ) . entrySet ( ) ) 
 + Collection < Collection < InetAddress > > endpointsGroupedByDc = new ArrayList < Collection < InetAddress > > ( ) ; 
 + if ( isDcAwareReplicationStrategy ( keyspace ) ) 
 + { 
 + / / mapping of dc ' s to nodes , use sorted map so that we get dcs sorted 
 + SortedMap < String , Collection < InetAddress > > sortedDcsToEndpoints = new TreeMap < String , Collection < InetAddress > > ( ) ; 
 + sortedDcsToEndpoints . putAll ( tokenMetadata . getTopology ( ) . getDatacenterEndpoints ( ) . asMap ( ) ) ; 
 + for ( Collection < InetAddress > endpoints : sortedDcsToEndpoints . values ( ) ) 
 + endpointsGroupedByDc . add ( endpoints ) ; 
 + } 
 + else 
 { 
 - Token token = tokenMetadata . getToken ( ranges . getKey ( ) ) ; 
 - for ( Range < Token > range : ranges . getValue ( ) ) 
 + endpointsGroupedByDc . add ( endpointsToTokens . keySet ( ) ) ; 
 + } 
 + 
 + LinkedHashMap < InetAddress , Float > finalOwnership = Maps . newLinkedHashMap ( ) ; 
 + 
 + / / calculate ownership per dc 
 + for ( Collection < InetAddress > endpoints : endpointsGroupedByDc ) 
 + { 
 + / / sort the endpoints by their tokens 
 + List < InetAddress > sortedEndpoints = Lists . newArrayListWithExpectedSize ( endpoints . size ( ) ) ; 
 + sortedEndpoints . addAll ( endpoints ) ; 
 + 
 + Collections . sort ( sortedEndpoints , new Comparator < InetAddress > ( ) 
 { 
 - float value = effective . get ( token . toString ( ) ) = = null ? 0 . 0F : effective . get ( token . toString ( ) ) ; 
 - effective . put ( token . toString ( ) , value + ownership . get ( range . left ) ) ; 
 + public int compare ( InetAddress o1 , InetAddress o2 ) 
 + { 
 + return endpointsToTokens . get ( o1 ) . compareTo ( endpointsToTokens . get ( o2 ) ) ; 
 + } 
 + } ) ; 
 + 
 + / / calculate the ownership without replication 
 + Function < InetAddress , Token > f = new Function < InetAddress , Token > ( ) 
 + { 
 + public Token apply ( InetAddress arg0 ) 
 + { 
 + return endpointsToTokens . get ( arg0 ) ; 
 + } 
 + } ; 
 + Map < Token , Float > tokenOwnership = getPartitioner ( ) . describeOwnership ( Lists . transform ( sortedEndpoints , f ) ) ; 
 + 
 + / / calculate the ownership with replication and add the endpoint to the final ownership map 
 + for ( InetAddress endpoint : endpoints ) 
 + { 
 + float ownership = 0 . 0f ; 
 + for ( Range < Token > range : getRangesForEndpoint ( keyspace , endpoint ) ) 
 + { 
 + if ( tokenOwnership . containsKey ( range . left ) ) 
 + ownership + = tokenOwnership . get ( range . left ) ; 
 + } 
 + finalOwnership . put ( endpoint , ownership ) ; 
 } 
 } 
 - return effective ; 
 + return finalOwnership ; 
 } 
 
 + 
 private boolean hasSameReplication ( List < String > list ) 
 { 
 if ( list . isEmpty ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index ff1ec03 . . 80ba05f 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 21 , 6 + 21 , 7 @ @ import java . io . IOException ; 
 import java . net . InetAddress ; 
 import java . net . UnknownHostException ; 
 import java . nio . ByteBuffer ; 
 + import java . util . LinkedHashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . concurrent . ExecutionException ; 
 @ @ - 328 , 7 + 329 , 7 @ @ public interface StorageServiceMBean 
 * given a list of tokens ( representing the nodes in the cluster ) , returns 
 * a mapping from " token - > % age of cluster owned by that token " 
 * / 
 - public Map < String , Float > getOwnership ( ) ; 
 + public Map < InetAddress , Float > getOwnership ( ) ; 
 
 / * * 
 * Effective ownership is % of the data each node owns given the keyspace 
 @ @ - 337 , 7 + 338 , 7 @ @ public interface StorageServiceMBean 
 * in the cluster have the same replication strategies and if yes then we will 
 * use the first else a empty Map is returned . 
 * / 
 - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException ; 
 + public Map < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException ; 
 
 public List < String > getKeyspaces ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 315e9c3 . . 808494e 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 28 , 8 + 28 , 8 @ @ import java . util . * ; 
 import java . util . Map . Entry ; 
 import java . util . concurrent . ExecutionException ; 
 
 - import org . apache . cassandra . service . CacheServiceMBean ; 
 - import org . apache . cassandra . service . StorageProxyMBean ; 
 + import com . google . common . collect . ImmutableBiMap ; 
 + import com . google . common . collect . Maps ; 
 import org . apache . commons . cli . * ; 
 
 import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutorMBean ; 
 @ @ - 38 , 6 + 38 , 8 @ @ import org . apache . cassandra . db . ColumnFamilyStoreMBean ; 
 import org . apache . cassandra . db . compaction . CompactionManagerMBean ; 
 import org . apache . cassandra . db . compaction . OperationType ; 
 import org . apache . cassandra . net . MessagingServiceMBean ; 
 + import org . apache . cassandra . service . CacheServiceMBean ; 
 + import org . apache . cassandra . service . StorageProxyMBean ; 
 import org . apache . cassandra . thrift . InvalidRequestException ; 
 import org . apache . cassandra . utils . EstimatedHistogram ; 
 import org . apache . cassandra . utils . Pair ; 
 @ @ - 208 , 14 + 210 , 53 @ @ public class NodeCmd 
 
 / * * 
 * Write a textual representation of the Cassandra ring . 
 - * 
 - * @ param outs the stream to write to 
 + * 
 + * @ param outs 
 + * the stream to write to 
 * / 
 public void printRing ( PrintStream outs , String keyspace ) 
 { 
 - Map < String , String > tokenToEndpoint = probe . getTokenToEndpointMap ( ) ; 
 - List < String > sortedTokens = new ArrayList < String > ( tokenToEndpoint . keySet ( ) ) ; 
 + Map < String , String > endpointsToTokens = ImmutableBiMap . copyOf ( probe . getTokenToEndpointMap ( ) ) . inverse ( ) ; 
 + String format = " % - 16s % - 12s % - 7s % - 8s % - 16s % - 20s % - 44s % n " ; 
 
 + / / Calculate per - token ownership of the ring 
 + Map < InetAddress , Float > ownerships ; 
 + boolean keyspaceSelected ; 
 + try 
 + { 
 + ownerships = probe . effectiveOwnership ( keyspace ) ; 
 + keyspaceSelected = true ; 
 + } 
 + catch ( ConfigurationException ex ) 
 + { 
 + ownerships = probe . getOwnership ( ) ; 
 + outs . printf ( " Note : Ownership information does not include topology ; for complete information , specify a keyspace % n " ) ; 
 + keyspaceSelected = false ; 
 + } 
 + try 
 + { 
 + outs . println ( ) ; 
 + Map < String , Map < InetAddress , Float > > perDcOwnerships = Maps . newLinkedHashMap ( ) ; 
 + / / get the different datasets and map to tokens 
 + for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) 
 + { 
 + String dc = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; 
 + if ( ! perDcOwnerships . containsKey ( dc ) ) 
 + perDcOwnerships . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; 
 + perDcOwnerships . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; 
 + } 
 + for ( Map . Entry < String , Map < InetAddress , Float > > entry : perDcOwnerships . entrySet ( ) ) 
 + printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; 
 + } 
 + catch ( UnknownHostException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + private void printDc ( PrintStream outs , String format , String dc , Map < String , String > endpointsToTokens , 
 + boolean keyspaceSelected , Map < InetAddress , Float > filteredOwnerships ) 
 + { 
 Collection < String > liveNodes = probe . getLiveNodes ( ) ; 
 Collection < String > deadNodes = probe . getUnreachableNodes ( ) ; 
 Collection < String > joiningNodes = probe . getJoiningNodes ( ) ; 
 @ @ - 223 , 69 + 264 , 64 @ @ public class NodeCmd 
 Collection < String > movingNodes = probe . getMovingNodes ( ) ; 
 Map < String , String > loadMap = probe . getLoadMap ( ) ; 
 
 - String format = " % - 16s % - 12s % - 12s % - 7s % - 8s % - 16s % - 20s % - 44s % n " ; 
 + outs . println ( " Datacenter : " + dc ) ; 
 + outs . println ( " = = = = = = = = = = " ) ; 
 
 - / / Calculate per - token ownership of the ring 
 - Map < String , Float > ownerships ; 
 - try 
 - { 
 - ownerships = probe . effectiveOwnership ( keyspace ) ; 
 - outs . printf ( format , " Address " , " DC " , " Rack " , " Status " , " State " , " Load " , " Effective - Ownership " , " Token " ) ; 
 - } 
 - catch ( ConfigurationException ex ) 
 + / / get the total amount of replicas for this dc and the last token in this dc ' s ring 
 + float totalReplicas = 0f ; 
 + String lastToken = " " ; 
 + for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) 
 { 
 - ownerships = probe . getOwnership ( ) ; 
 - outs . printf ( " Note : Ownership information does not include topology , please specify a keyspace . % n " ) ; 
 - outs . printf ( format , " Address " , " DC " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; 
 + lastToken = endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ; 
 + totalReplicas + = entry . getValue ( ) ; 
 } 
 + 
 + 
 + if ( keyspaceSelected ) 
 + outs . print ( " Replicas : " + ( int ) totalReplicas + " \ n \ n " ) ; 
 
 - / / show pre - wrap token twice so you can always read a node ' s range as 
 - / / ( previous line token , current line token ] 
 - if ( sortedTokens . size ( ) > 1 ) 
 - outs . printf ( format , " " , " " , " " , " " , " " , " " , " " , sortedTokens . get ( sortedTokens . size ( ) - 1 ) ) ; 
 + outs . printf ( format , " Address " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; 
 
 - for ( String token : sortedTokens ) 
 + if ( filteredOwnerships . size ( ) > 1 ) 
 + outs . printf ( format , " " , " " , " " , " " , " " , " " , lastToken ) ; 
 + else 
 + outs . println ( ) ; 
 + 
 + for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) 
 { 
 - String primaryEndpoint = tokenToEndpoint . get ( token ) ; 
 - String dataCenter ; 
 - try 
 - { 
 - dataCenter = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( primaryEndpoint ) ; 
 - } 
 - catch ( UnknownHostException e ) 
 - { 
 - dataCenter = " Unknown " ; 
 - } 
 + String endpoint = entry . getKey ( ) . getHostAddress ( ) ; 
 + String token = endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ; 
 String rack ; 
 try 
 { 
 - rack = probe . getEndpointSnitchInfoProxy ( ) . getRack ( primaryEndpoint ) ; 
 + rack = probe . getEndpointSnitchInfoProxy ( ) . getRack ( endpoint ) ; 
 } 
 catch ( UnknownHostException e ) 
 { 
 rack = " Unknown " ; 
 } 
 - String status = liveNodes . contains ( primaryEndpoint ) 
 - ? " Up " 
 - : deadNodes . contains ( primaryEndpoint ) 
 - ? " Down " 
 - : " ? " ; 
 + String status = liveNodes . contains ( endpoint ) 
 + ? " Up " 
 + : deadNodes . contains ( endpoint ) 
 + ? " Down " 
 + : " ? " ; 
 
 String state = " Normal " ; 
 
 - if ( joiningNodes . contains ( primaryEndpoint ) ) 
 + if ( joiningNodes . contains ( endpoint ) ) 
 state = " Joining " ; 
 - else if ( leavingNodes . contains ( primaryEndpoint ) ) 
 + else if ( leavingNodes . contains ( endpoint ) ) 
 state = " Leaving " ; 
 - else if ( movingNodes . contains ( primaryEndpoint ) ) 
 + else if ( movingNodes . contains ( endpoint ) ) 
 state = " Moving " ; 
 
 - String load = loadMap . containsKey ( primaryEndpoint ) 
 - ? loadMap . get ( primaryEndpoint ) 
 - : " ? " ; 
 - String owns = new DecimalFormat ( " # # 0 . 00 % " ) . format ( ownerships . get ( token ) = = null ? 0 . 0F : ownerships . get ( token ) ) ; 
 - outs . printf ( format , primaryEndpoint , dataCenter , rack , status , state , load , owns , token ) ; 
 + String load = loadMap . containsKey ( endpoint ) 
 + ? loadMap . get ( endpoint ) 
 + : " ? " ; 
 + String owns = new DecimalFormat ( " # # 0 . 00 % " ) . format ( entry . getValue ( ) ) ; 
 + outs . printf ( format , entry . getKey ( ) , rack , status , state , load , owns , token ) ; 
 } 
 + outs . println ( ) ; 
 } 
 
 / * * Writes a table of host IDs to a PrintStream * / 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index f6de85b . . 8ad8b92 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 263 , 12 + 263 , 12 @ @ public class NodeProbe 
 return ssProxy . getLoadMap ( ) ; 
 } 
 
 - public Map < String , Float > getOwnership ( ) 
 + public Map < InetAddress , Float > getOwnership ( ) 
 { 
 return ssProxy . getOwnership ( ) ; 
 } 
 
 - public Map < String , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException 
 + public Map < InetAddress , Float > effectiveOwnership ( String keyspace ) throws ConfigurationException 
 { 
 return ssProxy . effectiveOwnership ( keyspace ) ; 
 }
