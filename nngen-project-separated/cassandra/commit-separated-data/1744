BLEU SCORE: 0.033864985683445356

TEST MSG: Restore performance of writeUTF ; follow up commit to CASSANDRA - 8670
GENERATED MSG: clean up SequentialWriter and friends

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java b / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java <nl> index 6de2879 . . a846384 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java <nl> + + + b / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java <nl> @ @ - 55 , 7 + 55 , 7 @ @ public abstract class DataOutputStreamPlus extends OutputStream implements DataO <nl> protected static byte [ ] retrieveTemporaryBuffer ( int minSize ) <nl> { <nl> byte [ ] bytes = tempBuffer . get ( ) ; <nl> - if ( bytes . length < minSize ) <nl> + if ( bytes . length < Math . min ( minSize , MAX _ BUFFER _ SIZE ) ) <nl> { <nl> / / increase in powers of 2 , to avoid wasted repeat allocations <nl> bytes = new byte [ Math . min ( MAX _ BUFFER _ SIZE , 2 * Integer . highestOneBit ( minSize ) ) ] ; <nl> diff - - git a / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java b / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java <nl> index 31abfa8 . . ac3bae5 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java <nl> + + + b / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java <nl> @ @ - 252 , 81 + 252 , 72 @ @ public abstract class UnbufferedDataOutputStreamPlus extends DataOutputStreamPlu <nl> public static void writeUTF ( String str , DataOutput out ) throws IOException <nl> { <nl> int length = str . length ( ) ; <nl> - int utfCount = calculateUTFLength ( str , length ) ; <nl> + int utfCount = 0 ; <nl> + for ( int i = 0 ; i < length ; i + + ) <nl> + { <nl> + int ch = str . charAt ( i ) ; <nl> + if ( ( ch > 0 ) & ( ch < = 127 ) ) <nl> + utfCount + = 1 ; <nl> + else if ( ch < = 2047 ) <nl> + utfCount + = 2 ; <nl> + else <nl> + utfCount + = 3 ; <nl> + } <nl> <nl> if ( utfCount > 65535 ) <nl> throw new UTFDataFormatException ( ) ; / / $ NON - NLS - 1 $ <nl> <nl> byte [ ] utfBytes = retrieveTemporaryBuffer ( utfCount + 2 ) ; <nl> <nl> - int utfIndex = 2 ; <nl> - utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; <nl> - utfBytes [ 1 ] = ( byte ) utfCount ; <nl> int bufferLength = utfBytes . length ; <nl> - <nl> - if ( utfCount = = length & & utfCount + utfIndex < bufferLength ) <nl> + if ( utfCount = = length ) <nl> { <nl> - for ( int charIndex = 0 ; charIndex < length ; charIndex + + ) <nl> - utfBytes [ utfIndex + + ] = ( byte ) str . charAt ( charIndex ) ; <nl> + utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; <nl> + utfBytes [ 1 ] = ( byte ) utfCount ; <nl> + int firstIndex = 2 ; <nl> + for ( int offset = 0 ; offset < length ; offset + = bufferLength ) <nl> + { <nl> + int runLength = Math . min ( bufferLength - firstIndex , length - offset ) + firstIndex ; <nl> + offset - = firstIndex ; <nl> + for ( int i = firstIndex ; i < runLength ; i + + ) <nl> + utfBytes [ i ] = ( byte ) str . charAt ( offset + i ) ; <nl> + out . write ( utfBytes , 0 , runLength ) ; <nl> + offset + = firstIndex ; <nl> + firstIndex = 0 ; <nl> + } <nl> } <nl> else <nl> { <nl> - int charIndex = 0 ; <nl> - while ( charIndex < length ) <nl> + int utfIndex = 2 ; <nl> + utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; <nl> + utfBytes [ 1 ] = ( byte ) utfCount ; <nl> + for ( int charIndex = 0 ; charIndex < length ; charIndex + + ) <nl> { <nl> - char ch = str . charAt ( charIndex ) ; <nl> - int sizeOfChar = sizeOfChar ( ch ) ; <nl> - if ( utfIndex + sizeOfChar > bufferLength ) <nl> + if ( utfIndex + 3 > bufferLength ) <nl> { <nl> out . write ( utfBytes , 0 , utfIndex ) ; <nl> utfIndex = 0 ; <nl> } <nl> <nl> - switch ( sizeOfChar ) <nl> + char ch = str . charAt ( charIndex ) ; <nl> + if ( ( ch > 0 ) & ( ch < = 127 ) ) <nl> + { <nl> + utfBytes [ utfIndex + + ] = ( byte ) ch ; <nl> + } <nl> + else if ( ch < = 2047 ) <nl> { <nl> - case 3 : <nl> - utfBytes [ utfIndex ] = ( byte ) ( 0xe0 | ( 0x0f & ( ch > > 12 ) ) ) ; <nl> - utfBytes [ utfIndex + 1 ] = ( byte ) ( 0x80 | ( 0x3f & ( ch > > 6 ) ) ) ; <nl> - utfBytes [ utfIndex + 2 ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; <nl> - break ; <nl> - case 2 : <nl> - utfBytes [ utfIndex ] = ( byte ) ( 0xc0 | ( 0x1f & ( ch > > 6 ) ) ) ; <nl> - utfBytes [ utfIndex + 1 ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; <nl> - break ; <nl> - case 1 : <nl> - utfBytes [ utfIndex ] = ( byte ) ch ; <nl> - break ; <nl> - default : <nl> - throw new IllegalStateException ( ) ; <nl> + utfBytes [ utfIndex + + ] = ( byte ) ( 0xc0 | ( 0x1f & ( ch > > 6 ) ) ) ; <nl> + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; <nl> + } <nl> + else <nl> + { <nl> + utfBytes [ utfIndex + + ] = ( byte ) ( 0xe0 | ( 0x0f & ( ch > > 12 ) ) ) ; <nl> + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ( ch > > 6 ) ) ) ; <nl> + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; <nl> } <nl> - utfIndex + = sizeOfChar ; <nl> - charIndex + + ; <nl> } <nl> + out . write ( utfBytes , 0 , utfIndex ) ; <nl> } <nl> - out . write ( utfBytes , 0 , utfIndex ) ; <nl> - } <nl> - <nl> - / * <nl> - * Factored out into separate method to create more flexibility around inlining <nl> - * / <nl> - private static int calculateUTFLength ( String str , int length ) <nl> - { <nl> - int utfCount = 0 ; <nl> - for ( int i = 0 ; i < length ; i + + ) <nl> - utfCount + = sizeOfChar ( str . charAt ( i ) ) ; <nl> - return utfCount ; <nl> - } <nl> - <nl> - private static int sizeOfChar ( int ch ) <nl> - { <nl> - / / wrap 0 around to max , because it requires 3 bytes <nl> - return 1 <nl> - / / if > = 128 , we need an extra byte , so we divide by 128 and check the value is > 0 <nl> - / / ( by negating it and taking the sign bit ) <nl> - + ( - ( ch / 128 ) > > > 31 ) <nl> - / / if > = 2048 , or = = 0 , we need another extra byte ; we subtract one and wrap around , <nl> - / / so we only then need to confirm it is greater than 2047 <nl> - + ( - ( ( ( ch - 1 ) & 0xffff ) / 2047 ) > > > 31 ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java b / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java <nl> new file mode 100644 <nl> index 0000000 . . b8136f7 <nl> - - - / dev / null <nl> + + + b / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java <nl> @ @ - 0 , 0 + 1 , 274 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . test . microbench ; <nl> + <nl> + import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; <nl> + import org . apache . cassandra . io . util . BufferedDataOutputStreamTest ; <nl> + import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; <nl> + import org . openjdk . jmh . annotations . * ; <nl> + <nl> + import java . io . BufferedOutputStream ; <nl> + import java . io . IOException ; <nl> + import java . io . OutputStream ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . nio . channels . WritableByteChannel ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + @ BenchmarkMode ( Mode . AverageTime ) <nl> + @ OutputTimeUnit ( TimeUnit . NANOSECONDS ) <nl> + @ Warmup ( iterations = 5 , time = 1 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Measurement ( iterations = 5 , time = 1 , timeUnit = TimeUnit . SECONDS ) <nl> + @ Fork ( value = 3 , jvmArgsAppend = " - Xmx512M " ) <nl> + @ Threads ( 1 ) <nl> + @ State ( Scope . Benchmark ) <nl> + public class OutputStreamBench <nl> + { <nl> + <nl> + BufferedOutputStream hole = new BufferedOutputStream ( new OutputStream ( ) { <nl> + <nl> + @ Override <nl> + public void write ( int b ) throws IOException <nl> + { <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void write ( byte b [ ] ) throws IOException { <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public void write ( byte b [ ] , int a , int c ) throws IOException { <nl> + <nl> + } <nl> + } ) ; <nl> + <nl> + WrappedDataOutputStreamPlus streamA = new WrappedDataOutputStreamPlus ( hole ) ; <nl> + <nl> + BufferedDataOutputStreamPlus streamB = new BufferedDataOutputStreamPlus ( new WritableByteChannel ( ) { <nl> + <nl> + @ Override <nl> + public boolean isOpen ( ) <nl> + { <nl> + / / TODO Auto - generated method stub <nl> + return true ; <nl> + } <nl> + <nl> + @ Override <nl> + public void close ( ) throws IOException <nl> + { <nl> + / / TODO Auto - generated method stub <nl> + <nl> + } <nl> + <nl> + @ Override <nl> + public int write ( ByteBuffer src ) throws IOException <nl> + { <nl> + int remaining = src . remaining ( ) ; <nl> + src . position ( src . limit ( ) ) ; <nl> + return remaining ; <nl> + } <nl> + <nl> + } , 8192 ) ; <nl> + <nl> + public static byte foo ; <nl> + <nl> + public static int foo1 ; <nl> + <nl> + public static long foo2 ; <nl> + <nl> + public static double foo3 ; <nl> + <nl> + public static float foo4 ; <nl> + <nl> + public static short foo5 ; <nl> + <nl> + public static char foo6 ; <nl> + <nl> + @ Benchmark <nl> + public void testBOSByte ( ) throws IOException <nl> + { <nl> + streamA . write ( foo ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBDOSPByte ( ) throws IOException <nl> + { <nl> + streamB . write ( foo ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBOSInt ( ) throws IOException <nl> + { <nl> + streamA . writeInt ( foo1 ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBDOSPInt ( ) throws IOException <nl> + { <nl> + streamB . writeInt ( foo1 ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBOSLong ( ) throws IOException <nl> + { <nl> + streamA . writeLong ( foo2 ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBDOSPLong ( ) throws IOException <nl> + { <nl> + streamB . writeLong ( foo2 ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBOSMixed ( ) throws IOException <nl> + { <nl> + streamA . write ( foo ) ; <nl> + streamA . writeInt ( foo1 ) ; <nl> + streamA . writeLong ( foo2 ) ; <nl> + streamA . writeDouble ( foo3 ) ; <nl> + streamA . writeFloat ( foo4 ) ; <nl> + streamA . writeShort ( foo5 ) ; <nl> + streamA . writeChar ( foo6 ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testBDOSPMixed ( ) throws IOException <nl> + { <nl> + streamB . write ( foo ) ; <nl> + streamB . writeInt ( foo1 ) ; <nl> + streamB . writeLong ( foo2 ) ; <nl> + streamB . writeDouble ( foo3 ) ; <nl> + streamB . writeFloat ( foo4 ) ; <nl> + streamB . writeShort ( foo5 ) ; <nl> + streamB . writeChar ( foo6 ) ; <nl> + } <nl> + <nl> + public static String tinyM = " ? ? " ; <nl> + public static String smallM = " ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ " ; <nl> + public static String largeM ; <nl> + public static String tiny = " a " ; <nl> + public static String small = " adsjglhnafsjk ; gujfakyhgukafshgjkahfsgjkhafs ; jkhausjkgaksfj ; gafskdghajfsk ; g " ; <nl> + public static String large ; <nl> + <nl> + static { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + while ( sb . length ( ) < 1024 * 12 ) { <nl> + sb . append ( small ) ; <nl> + } <nl> + large = sb . toString ( ) ; <nl> + <nl> + sb = new StringBuilder ( ) ; <nl> + while ( sb . length ( ) < 1024 * 12 ) { <nl> + sb . append ( smallM ) ; <nl> + } <nl> + largeM = sb . toString ( ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMTinyStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( tinyM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMTinyStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( tinyM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMTinyLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( tinyM , hole ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMSmallStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( smallM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMSmallStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( smallM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMSmallLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( smallM , hole ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMLargeStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( largeM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMLargeStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( largeM ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testMLargeLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( largeM , hole ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testTinyStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( tiny ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testTinyStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( tiny ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testTinyLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( tiny , hole ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testSmallStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( small ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testSmallStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( small ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testSmallLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( small , hole ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testRLargeStringBOS ( ) throws IOException { <nl> + streamA . writeUTF ( large ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testRLargeStringBDOSP ( ) throws IOException { <nl> + streamB . writeUTF ( large ) ; <nl> + } <nl> + <nl> + @ Benchmark <nl> + public void testRLargeLegacyWriteUTF ( ) throws IOException { <nl> + BufferedDataOutputStreamTest . writeUTFLegacy ( large , hole ) ; <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java b / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java <nl> index 8ac6d92 . . 8eaea31 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java <nl> @ @ - 3 , 6 + 3 , 7 @ @ package org . apache . cassandra . io . util ; <nl> import java . io . ByteArrayOutputStream ; <nl> import java . io . DataOutput ; <nl> import java . io . IOException ; <nl> + import java . io . OutputStream ; <nl> import java . io . UTFDataFormatException ; <nl> import java . lang . reflect . Field ; <nl> import java . nio . ByteBuffer ; <nl> @ @ - 148 , 7 + 149 , 7 @ @ public class BufferedDataOutputStreamTest <nl> int action = 0 ; <nl> while ( generated . size ( ) < 1024 * 1024 * 8 ) <nl> { <nl> - action = r . nextInt ( 18 ) ; <nl> + action = r . nextInt ( 19 ) ; <nl> <nl> / / System . out . println ( " Action " + action + " iteration " + iteration ) ; <nl> iteration + + ; <nl> @ @ - 258 , 6 + 259 , 9 @ @ public class BufferedDataOutputStreamTest <nl> { <nl> StringBuilder sb = new StringBuilder ( ) ; <nl> int length = r . nextInt ( 500 ) ; <nl> + / / Some times do big strings <nl> + if ( r . nextDouble ( ) > . 95 ) <nl> + length + = 4000 ; <nl> sb . append ( simple + twoByte + threeByte + fourByte ) ; <nl> for ( int ii = 0 ; ii < length ; ii + + ) <nl> { <nl> @ @ - 270 , 6 + 274 , 20 @ @ public class BufferedDataOutputStreamTest <nl> } <nl> case 15 : <nl> { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + int length = r . nextInt ( 500 ) ; <nl> + sb . append ( " the very model of a modern major general familiar with all things animal vegetable and mineral " ) ; <nl> + for ( int ii = 0 ; ii < length ; ii + + ) <nl> + { <nl> + sb . append ( ' ' ) ; <nl> + } <nl> + String str = sb . toString ( ) ; <nl> + writeUTFLegacy ( str , dosp ) ; <nl> + ndosp . writeUTF ( str ) ; <nl> + break ; <nl> + } <nl> + case 16 : <nl> + { <nl> ByteBuffer buf = ByteBuffer . allocate ( r . nextInt ( 1024 * 8 + 1 ) ) ; <nl> r . nextBytes ( buf . array ( ) ) ; <nl> buf . position ( buf . capacity ( ) = = 0 ? 0 : r . nextInt ( buf . capacity ( ) ) ) ; <nl> @ @ - 281 , 7 + 299 , 7 @ @ public class BufferedDataOutputStreamTest <nl> dosp . write ( buf . duplicate ( ) ) ; <nl> break ; <nl> } <nl> - case 16 : <nl> + case 17 : <nl> { <nl> ByteBuffer buf = ByteBuffer . allocateDirect ( r . nextInt ( 1024 * 8 + 1 ) ) ; <nl> while ( buf . hasRemaining ( ) ) <nl> @ @ - 295 , 7 + 313 , 7 @ @ public class BufferedDataOutputStreamTest <nl> dosp . write ( buf . duplicate ( ) ) ; <nl> break ; <nl> } <nl> - case 17 : <nl> + case 18 : <nl> { <nl> try ( Memory buf = Memory . allocate ( r . nextInt ( 1024 * 8 - 1 ) + 1 ) ; ) <nl> { <nl> @ @ - 317 , 7 + 335 , 7 @ @ public class BufferedDataOutputStreamTest <nl> assertSameOutput ( 0 , - 1 , iteration ) ; <nl> } <nl> <nl> - static void writeUTFLegacy ( String str , DataOutput out ) throws IOException <nl> + public static void writeUTFLegacy ( String str , OutputStream out ) throws IOException <nl> { <nl> int utfCount = 0 , length = str . length ( ) ; <nl> for ( int i = 0 ; i < length ; i + + )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 78d7267 . . 7348a99 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 1 . 1 . 3 <nl> + * munmap commitlog segments before rename ( CASSANDRA - 4337 ) <nl> * ( JMX ) rename getRangeKeySample to sampleKeyRange to avoid returning <nl> multi - MB results as an attribute ( CASSANDRA - 4452 ) <nl> * flush based on data size , not throughput ; overwritten columns no <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 8cb2cba . . 54486d0 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 41 , 7 + 41 , 6 @ @ import org . apache . cassandra . db . DefsTable ; <nl> import org . apache . cassandra . db . SystemTable ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> - import org . apache . cassandra . io . util . MmappedSegmentedFile ; <nl> import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> import org . apache . cassandra . locator . EndpointSnitchInfo ; <nl> import org . apache . cassandra . locator . IEndpointSnitch ; <nl> @ @ - 196 , 9 + 195 , 6 @ @ public class DatabaseDescriptor <nl> indexAccessMode = conf . disk _ access _ mode ; <nl> logger . info ( " DiskAccessMode is " + conf . disk _ access _ mode + " , indexAccessMode is " + indexAccessMode ) ; <nl> } <nl> - / / We could enable cleaner for index only mmap but it probably doesn ' t matter much <nl> - if ( conf . disk _ access _ mode = = Config . DiskAccessMode . mmap ) <nl> - MmappedSegmentedFile . initCleaner ( ) ; <nl> <nl> 	 logger . debug ( " page _ cache _ hinting is " + conf . populate _ io _ cache _ on _ flush ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java <nl> index f023c8c . . 9c9f9b8 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Directories . java <nl> + + + b / src / java / org / apache / cassandra / db / Directories . java <nl> @ @ - 117 , 7 + 117 , 7 @ @ public class Directories <nl> / / Requesting GC has a chance to free space only if we ' re using mmap and a non SUN jvm <nl> if ( path = = null <nl> & & ( DatabaseDescriptor . getDiskAccessMode ( ) = = Config . DiskAccessMode . mmap | | DatabaseDescriptor . getIndexAccessMode ( ) = = Config . DiskAccessMode . mmap ) <nl> - & & ! MmappedSegmentedFile . isCleanerAvailable ( ) ) <nl> + & & ! FileUtils . isCleanerAvailable ( ) ) <nl> { <nl> logger . info ( " Forcing GC to free up disk space . Upgrade to the Oracle JVM to avoid this " ) ; <nl> StorageService . instance . requestGC ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index 0449c47 . . fcd4130 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 314 , 6 + 314 , 7 @ @ public class CommitLogSegment <nl> <nl> try <nl> { <nl> + FileUtils . clean ( buffer ) ; <nl> logFileAccessor . close ( ) ; <nl> closed = true ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / util / FileUtils . java b / src / java / org / apache / cassandra / io / util / FileUtils . java <nl> index 4ddf8b6 . . 5ed6276 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / FileUtils . java <nl> + + + b / src / java / org / apache / cassandra / io / util / FileUtils . java <nl> @ @ - 19 , 6 + 19 , 9 @ @ <nl> package org . apache . cassandra . io . util ; <nl> <nl> import java . io . * ; <nl> + import java . lang . reflect . InvocationTargetException ; <nl> + import java . lang . reflect . Method ; <nl> + import java . nio . MappedByteBuffer ; <nl> import java . text . DecimalFormat ; <nl> import java . util . Comparator ; <nl> import java . util . List ; <nl> @ @ - 39 , 6 + 42 , 22 @ @ public class FileUtils <nl> private static final double gb _ = 1024 * 1024 * 1024d ; <nl> private static final double tb _ = 1024 * 1024 * 1024 * 1024d ; <nl> <nl> + private static final Method cleanerMethod = initCleaner ( ) ; <nl> + <nl> + private static Method initCleaner ( ) <nl> + { <nl> + try <nl> + { <nl> + return Class . forName ( " sun . nio . ch . DirectBuffer " ) . getMethod ( " cleaner " ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + / / Perhaps a non - sun - derived JVM - contributions welcome <nl> + logger _ . info ( " Cannot initialize un - mmaper . ( Are you using a non - SUN JVM ? ) Compacted data files will not be removed promptly . Consider using a SUN JVM or using standard disk access mode " ) ; <nl> + return null ; <nl> + } <nl> + } <nl> + <nl> public static void deleteWithConfirm ( String file ) throws IOException <nl> { <nl> deleteWithConfirm ( new File ( file ) ) ; <nl> @ @ - 118 , 6 + 137 , 32 @ @ public class FileUtils <nl> throw e ; <nl> } <nl> <nl> + public static boolean isCleanerAvailable ( ) <nl> + { <nl> + return cleanerMethod ! = null ; <nl> + } <nl> + <nl> + public static void clean ( MappedByteBuffer buffer ) <nl> + { <nl> + try <nl> + { <nl> + Object cleaner = cleanerMethod . invoke ( buffer ) ; <nl> + cleaner . getClass ( ) . getMethod ( " clean " ) . invoke ( cleaner ) ; <nl> + } <nl> + catch ( IllegalAccessException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( InvocationTargetException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( NoSuchMethodException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> public static class FileComparator implements Comparator < File > <nl> { <nl> public int compare ( File f , File f2 ) <nl> diff - - git a / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java b / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java <nl> index a933630 . . 5ebbe24 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java <nl> + + + b / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java <nl> @ @ - 25 , 7 + 25 , 6 @ @ import java . io . File ; <nl> import java . io . IOError ; <nl> import java . io . IOException ; <nl> import java . io . RandomAccessFile ; <nl> - import java . lang . reflect . Method ; <nl> import java . nio . MappedByteBuffer ; <nl> import java . nio . channels . FileChannel ; <nl> import java . util . ArrayList ; <nl> @ @ - 42 , 8 + 41 , 6 @ @ public class MmappedSegmentedFile extends SegmentedFile <nl> / / in a perfect world , MAX _ SEGMENT _ SIZE would be final , but we need to test with a smaller size to stay sane . <nl> public static long MAX _ SEGMENT _ SIZE = Integer . MAX _ VALUE ; <nl> <nl> - private static Method cleanerMethod = null ; <nl> - <nl> / * * <nl> * Sorted array of segment offsets and MappedByteBuffers for segments . If mmap is completely disabled , or if the <nl> * segment would be too long to mmap , the value for an offset will be null , indicating that we need to fall back <nl> @ @ - 98 , 27 + 95 , 9 @ @ public class MmappedSegmentedFile extends SegmentedFile <nl> } <nl> } <nl> <nl> - public static void initCleaner ( ) <nl> - { <nl> - try <nl> - { <nl> - cleanerMethod = Class . forName ( " sun . nio . ch . DirectBuffer " ) . getMethod ( " cleaner " ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - / / Perhaps a non - sun - derived JVM - contributions welcome <nl> - logger . info ( " Cannot initialize un - mmaper . ( Are you using a non - SUN JVM ? ) Compacted data files will not be removed promptly . Consider using a SUN JVM or using standard disk access mode " ) ; <nl> - } <nl> - } <nl> - <nl> - public static boolean isCleanerAvailable ( ) <nl> - { <nl> - return cleanerMethod ! = null ; <nl> - } <nl> - <nl> public void cleanup ( ) <nl> { <nl> - if ( cleanerMethod = = null ) <nl> + if ( ! FileUtils . isCleanerAvailable ( ) ) <nl> return ; <nl> <nl> / * <nl> @ @ - 132 , 9 + 111 , 7 @ @ public class MmappedSegmentedFile extends SegmentedFile <nl> { <nl> if ( segment . right = = null ) <nl> continue ; <nl> - <nl> - Object cleaner = cleanerMethod . invoke ( segment . right ) ; <nl> - cleaner . getClass ( ) . getMethod ( " clean " ) . invoke ( cleaner ) ; <nl> + FileUtils . clean ( segment . right ) ; <nl> } <nl> logger . debug ( " All segments have been unmapped successfully " ) ; <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java b / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java 
 index 6de2879 . . a846384 100644 
 - - - a / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java 
 + + + b / src / java / org / apache / cassandra / io / util / DataOutputStreamPlus . java 
 @ @ - 55 , 7 + 55 , 7 @ @ public abstract class DataOutputStreamPlus extends OutputStream implements DataO 
 protected static byte [ ] retrieveTemporaryBuffer ( int minSize ) 
 { 
 byte [ ] bytes = tempBuffer . get ( ) ; 
 - if ( bytes . length < minSize ) 
 + if ( bytes . length < Math . min ( minSize , MAX _ BUFFER _ SIZE ) ) 
 { 
 / / increase in powers of 2 , to avoid wasted repeat allocations 
 bytes = new byte [ Math . min ( MAX _ BUFFER _ SIZE , 2 * Integer . highestOneBit ( minSize ) ) ] ; 
 diff - - git a / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java b / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java 
 index 31abfa8 . . ac3bae5 100644 
 - - - a / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java 
 + + + b / src / java / org / apache / cassandra / io / util / UnbufferedDataOutputStreamPlus . java 
 @ @ - 252 , 81 + 252 , 72 @ @ public abstract class UnbufferedDataOutputStreamPlus extends DataOutputStreamPlu 
 public static void writeUTF ( String str , DataOutput out ) throws IOException 
 { 
 int length = str . length ( ) ; 
 - int utfCount = calculateUTFLength ( str , length ) ; 
 + int utfCount = 0 ; 
 + for ( int i = 0 ; i < length ; i + + ) 
 + { 
 + int ch = str . charAt ( i ) ; 
 + if ( ( ch > 0 ) & ( ch < = 127 ) ) 
 + utfCount + = 1 ; 
 + else if ( ch < = 2047 ) 
 + utfCount + = 2 ; 
 + else 
 + utfCount + = 3 ; 
 + } 
 
 if ( utfCount > 65535 ) 
 throw new UTFDataFormatException ( ) ; / / $ NON - NLS - 1 $ 
 
 byte [ ] utfBytes = retrieveTemporaryBuffer ( utfCount + 2 ) ; 
 
 - int utfIndex = 2 ; 
 - utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; 
 - utfBytes [ 1 ] = ( byte ) utfCount ; 
 int bufferLength = utfBytes . length ; 
 - 
 - if ( utfCount = = length & & utfCount + utfIndex < bufferLength ) 
 + if ( utfCount = = length ) 
 { 
 - for ( int charIndex = 0 ; charIndex < length ; charIndex + + ) 
 - utfBytes [ utfIndex + + ] = ( byte ) str . charAt ( charIndex ) ; 
 + utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; 
 + utfBytes [ 1 ] = ( byte ) utfCount ; 
 + int firstIndex = 2 ; 
 + for ( int offset = 0 ; offset < length ; offset + = bufferLength ) 
 + { 
 + int runLength = Math . min ( bufferLength - firstIndex , length - offset ) + firstIndex ; 
 + offset - = firstIndex ; 
 + for ( int i = firstIndex ; i < runLength ; i + + ) 
 + utfBytes [ i ] = ( byte ) str . charAt ( offset + i ) ; 
 + out . write ( utfBytes , 0 , runLength ) ; 
 + offset + = firstIndex ; 
 + firstIndex = 0 ; 
 + } 
 } 
 else 
 { 
 - int charIndex = 0 ; 
 - while ( charIndex < length ) 
 + int utfIndex = 2 ; 
 + utfBytes [ 0 ] = ( byte ) ( utfCount > > 8 ) ; 
 + utfBytes [ 1 ] = ( byte ) utfCount ; 
 + for ( int charIndex = 0 ; charIndex < length ; charIndex + + ) 
 { 
 - char ch = str . charAt ( charIndex ) ; 
 - int sizeOfChar = sizeOfChar ( ch ) ; 
 - if ( utfIndex + sizeOfChar > bufferLength ) 
 + if ( utfIndex + 3 > bufferLength ) 
 { 
 out . write ( utfBytes , 0 , utfIndex ) ; 
 utfIndex = 0 ; 
 } 
 
 - switch ( sizeOfChar ) 
 + char ch = str . charAt ( charIndex ) ; 
 + if ( ( ch > 0 ) & ( ch < = 127 ) ) 
 + { 
 + utfBytes [ utfIndex + + ] = ( byte ) ch ; 
 + } 
 + else if ( ch < = 2047 ) 
 { 
 - case 3 : 
 - utfBytes [ utfIndex ] = ( byte ) ( 0xe0 | ( 0x0f & ( ch > > 12 ) ) ) ; 
 - utfBytes [ utfIndex + 1 ] = ( byte ) ( 0x80 | ( 0x3f & ( ch > > 6 ) ) ) ; 
 - utfBytes [ utfIndex + 2 ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; 
 - break ; 
 - case 2 : 
 - utfBytes [ utfIndex ] = ( byte ) ( 0xc0 | ( 0x1f & ( ch > > 6 ) ) ) ; 
 - utfBytes [ utfIndex + 1 ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; 
 - break ; 
 - case 1 : 
 - utfBytes [ utfIndex ] = ( byte ) ch ; 
 - break ; 
 - default : 
 - throw new IllegalStateException ( ) ; 
 + utfBytes [ utfIndex + + ] = ( byte ) ( 0xc0 | ( 0x1f & ( ch > > 6 ) ) ) ; 
 + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; 
 + } 
 + else 
 + { 
 + utfBytes [ utfIndex + + ] = ( byte ) ( 0xe0 | ( 0x0f & ( ch > > 12 ) ) ) ; 
 + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ( ch > > 6 ) ) ) ; 
 + utfBytes [ utfIndex + + ] = ( byte ) ( 0x80 | ( 0x3f & ch ) ) ; 
 } 
 - utfIndex + = sizeOfChar ; 
 - charIndex + + ; 
 } 
 + out . write ( utfBytes , 0 , utfIndex ) ; 
 } 
 - out . write ( utfBytes , 0 , utfIndex ) ; 
 - } 
 - 
 - / * 
 - * Factored out into separate method to create more flexibility around inlining 
 - * / 
 - private static int calculateUTFLength ( String str , int length ) 
 - { 
 - int utfCount = 0 ; 
 - for ( int i = 0 ; i < length ; i + + ) 
 - utfCount + = sizeOfChar ( str . charAt ( i ) ) ; 
 - return utfCount ; 
 - } 
 - 
 - private static int sizeOfChar ( int ch ) 
 - { 
 - / / wrap 0 around to max , because it requires 3 bytes 
 - return 1 
 - / / if > = 128 , we need an extra byte , so we divide by 128 and check the value is > 0 
 - / / ( by negating it and taking the sign bit ) 
 - + ( - ( ch / 128 ) > > > 31 ) 
 - / / if > = 2048 , or = = 0 , we need another extra byte ; we subtract one and wrap around , 
 - / / so we only then need to confirm it is greater than 2047 
 - + ( - ( ( ( ch - 1 ) & 0xffff ) / 2047 ) > > > 31 ) ; 
 } 
 
 / * * 
 diff - - git a / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java b / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java 
 new file mode 100644 
 index 0000000 . . b8136f7 
 - - - / dev / null 
 + + + b / test / microbench / org / apache / cassandra / test / microbench / OutputStreamBench . java 
 @ @ - 0 , 0 + 1 , 274 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . test . microbench ; 
 + 
 + import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; 
 + import org . apache . cassandra . io . util . BufferedDataOutputStreamTest ; 
 + import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; 
 + import org . openjdk . jmh . annotations . * ; 
 + 
 + import java . io . BufferedOutputStream ; 
 + import java . io . IOException ; 
 + import java . io . OutputStream ; 
 + import java . nio . ByteBuffer ; 
 + import java . nio . channels . WritableByteChannel ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + @ BenchmarkMode ( Mode . AverageTime ) 
 + @ OutputTimeUnit ( TimeUnit . NANOSECONDS ) 
 + @ Warmup ( iterations = 5 , time = 1 , timeUnit = TimeUnit . SECONDS ) 
 + @ Measurement ( iterations = 5 , time = 1 , timeUnit = TimeUnit . SECONDS ) 
 + @ Fork ( value = 3 , jvmArgsAppend = " - Xmx512M " ) 
 + @ Threads ( 1 ) 
 + @ State ( Scope . Benchmark ) 
 + public class OutputStreamBench 
 + { 
 + 
 + BufferedOutputStream hole = new BufferedOutputStream ( new OutputStream ( ) { 
 + 
 + @ Override 
 + public void write ( int b ) throws IOException 
 + { 
 + 
 + } 
 + 
 + @ Override 
 + public void write ( byte b [ ] ) throws IOException { 
 + 
 + } 
 + 
 + @ Override 
 + public void write ( byte b [ ] , int a , int c ) throws IOException { 
 + 
 + } 
 + } ) ; 
 + 
 + WrappedDataOutputStreamPlus streamA = new WrappedDataOutputStreamPlus ( hole ) ; 
 + 
 + BufferedDataOutputStreamPlus streamB = new BufferedDataOutputStreamPlus ( new WritableByteChannel ( ) { 
 + 
 + @ Override 
 + public boolean isOpen ( ) 
 + { 
 + / / TODO Auto - generated method stub 
 + return true ; 
 + } 
 + 
 + @ Override 
 + public void close ( ) throws IOException 
 + { 
 + / / TODO Auto - generated method stub 
 + 
 + } 
 + 
 + @ Override 
 + public int write ( ByteBuffer src ) throws IOException 
 + { 
 + int remaining = src . remaining ( ) ; 
 + src . position ( src . limit ( ) ) ; 
 + return remaining ; 
 + } 
 + 
 + } , 8192 ) ; 
 + 
 + public static byte foo ; 
 + 
 + public static int foo1 ; 
 + 
 + public static long foo2 ; 
 + 
 + public static double foo3 ; 
 + 
 + public static float foo4 ; 
 + 
 + public static short foo5 ; 
 + 
 + public static char foo6 ; 
 + 
 + @ Benchmark 
 + public void testBOSByte ( ) throws IOException 
 + { 
 + streamA . write ( foo ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBDOSPByte ( ) throws IOException 
 + { 
 + streamB . write ( foo ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBOSInt ( ) throws IOException 
 + { 
 + streamA . writeInt ( foo1 ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBDOSPInt ( ) throws IOException 
 + { 
 + streamB . writeInt ( foo1 ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBOSLong ( ) throws IOException 
 + { 
 + streamA . writeLong ( foo2 ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBDOSPLong ( ) throws IOException 
 + { 
 + streamB . writeLong ( foo2 ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBOSMixed ( ) throws IOException 
 + { 
 + streamA . write ( foo ) ; 
 + streamA . writeInt ( foo1 ) ; 
 + streamA . writeLong ( foo2 ) ; 
 + streamA . writeDouble ( foo3 ) ; 
 + streamA . writeFloat ( foo4 ) ; 
 + streamA . writeShort ( foo5 ) ; 
 + streamA . writeChar ( foo6 ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testBDOSPMixed ( ) throws IOException 
 + { 
 + streamB . write ( foo ) ; 
 + streamB . writeInt ( foo1 ) ; 
 + streamB . writeLong ( foo2 ) ; 
 + streamB . writeDouble ( foo3 ) ; 
 + streamB . writeFloat ( foo4 ) ; 
 + streamB . writeShort ( foo5 ) ; 
 + streamB . writeChar ( foo6 ) ; 
 + } 
 + 
 + public static String tinyM = " ? ? " ; 
 + public static String smallM = " ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ ? ? 㒨 ƀ " ; 
 + public static String largeM ; 
 + public static String tiny = " a " ; 
 + public static String small = " adsjglhnafsjk ; gujfakyhgukafshgjkahfsgjkhafs ; jkhausjkgaksfj ; gafskdghajfsk ; g " ; 
 + public static String large ; 
 + 
 + static { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + while ( sb . length ( ) < 1024 * 12 ) { 
 + sb . append ( small ) ; 
 + } 
 + large = sb . toString ( ) ; 
 + 
 + sb = new StringBuilder ( ) ; 
 + while ( sb . length ( ) < 1024 * 12 ) { 
 + sb . append ( smallM ) ; 
 + } 
 + largeM = sb . toString ( ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMTinyStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( tinyM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMTinyStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( tinyM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMTinyLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( tinyM , hole ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMSmallStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( smallM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMSmallStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( smallM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMSmallLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( smallM , hole ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMLargeStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( largeM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMLargeStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( largeM ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testMLargeLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( largeM , hole ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testTinyStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( tiny ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testTinyStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( tiny ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testTinyLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( tiny , hole ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testSmallStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( small ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testSmallStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( small ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testSmallLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( small , hole ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testRLargeStringBOS ( ) throws IOException { 
 + streamA . writeUTF ( large ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testRLargeStringBDOSP ( ) throws IOException { 
 + streamB . writeUTF ( large ) ; 
 + } 
 + 
 + @ Benchmark 
 + public void testRLargeLegacyWriteUTF ( ) throws IOException { 
 + BufferedDataOutputStreamTest . writeUTFLegacy ( large , hole ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java b / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java 
 index 8ac6d92 . . 8eaea31 100644 
 - - - a / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java 
 + + + b / test / unit / org / apache / cassandra / io / util / BufferedDataOutputStreamTest . java 
 @ @ - 3 , 6 + 3 , 7 @ @ package org . apache . cassandra . io . util ; 
 import java . io . ByteArrayOutputStream ; 
 import java . io . DataOutput ; 
 import java . io . IOException ; 
 + import java . io . OutputStream ; 
 import java . io . UTFDataFormatException ; 
 import java . lang . reflect . Field ; 
 import java . nio . ByteBuffer ; 
 @ @ - 148 , 7 + 149 , 7 @ @ public class BufferedDataOutputStreamTest 
 int action = 0 ; 
 while ( generated . size ( ) < 1024 * 1024 * 8 ) 
 { 
 - action = r . nextInt ( 18 ) ; 
 + action = r . nextInt ( 19 ) ; 
 
 / / System . out . println ( " Action " + action + " iteration " + iteration ) ; 
 iteration + + ; 
 @ @ - 258 , 6 + 259 , 9 @ @ public class BufferedDataOutputStreamTest 
 { 
 StringBuilder sb = new StringBuilder ( ) ; 
 int length = r . nextInt ( 500 ) ; 
 + / / Some times do big strings 
 + if ( r . nextDouble ( ) > . 95 ) 
 + length + = 4000 ; 
 sb . append ( simple + twoByte + threeByte + fourByte ) ; 
 for ( int ii = 0 ; ii < length ; ii + + ) 
 { 
 @ @ - 270 , 6 + 274 , 20 @ @ public class BufferedDataOutputStreamTest 
 } 
 case 15 : 
 { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + int length = r . nextInt ( 500 ) ; 
 + sb . append ( " the very model of a modern major general familiar with all things animal vegetable and mineral " ) ; 
 + for ( int ii = 0 ; ii < length ; ii + + ) 
 + { 
 + sb . append ( ' ' ) ; 
 + } 
 + String str = sb . toString ( ) ; 
 + writeUTFLegacy ( str , dosp ) ; 
 + ndosp . writeUTF ( str ) ; 
 + break ; 
 + } 
 + case 16 : 
 + { 
 ByteBuffer buf = ByteBuffer . allocate ( r . nextInt ( 1024 * 8 + 1 ) ) ; 
 r . nextBytes ( buf . array ( ) ) ; 
 buf . position ( buf . capacity ( ) = = 0 ? 0 : r . nextInt ( buf . capacity ( ) ) ) ; 
 @ @ - 281 , 7 + 299 , 7 @ @ public class BufferedDataOutputStreamTest 
 dosp . write ( buf . duplicate ( ) ) ; 
 break ; 
 } 
 - case 16 : 
 + case 17 : 
 { 
 ByteBuffer buf = ByteBuffer . allocateDirect ( r . nextInt ( 1024 * 8 + 1 ) ) ; 
 while ( buf . hasRemaining ( ) ) 
 @ @ - 295 , 7 + 313 , 7 @ @ public class BufferedDataOutputStreamTest 
 dosp . write ( buf . duplicate ( ) ) ; 
 break ; 
 } 
 - case 17 : 
 + case 18 : 
 { 
 try ( Memory buf = Memory . allocate ( r . nextInt ( 1024 * 8 - 1 ) + 1 ) ; ) 
 { 
 @ @ - 317 , 7 + 335 , 7 @ @ public class BufferedDataOutputStreamTest 
 assertSameOutput ( 0 , - 1 , iteration ) ; 
 } 
 
 - static void writeUTFLegacy ( String str , DataOutput out ) throws IOException 
 + public static void writeUTFLegacy ( String str , OutputStream out ) throws IOException 
 { 
 int utfCount = 0 , length = str . length ( ) ; 
 for ( int i = 0 ; i < length ; i + + )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 78d7267 . . 7348a99 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 1 . 1 . 3 
 + * munmap commitlog segments before rename ( CASSANDRA - 4337 ) 
 * ( JMX ) rename getRangeKeySample to sampleKeyRange to avoid returning 
 multi - MB results as an attribute ( CASSANDRA - 4452 ) 
 * flush based on data size , not throughput ; overwritten columns no 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 8cb2cba . . 54486d0 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 41 , 7 + 41 , 6 @ @ import org . apache . cassandra . db . DefsTable ; 
 import org . apache . cassandra . db . SystemTable ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 - import org . apache . cassandra . io . util . MmappedSegmentedFile ; 
 import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 import org . apache . cassandra . locator . EndpointSnitchInfo ; 
 import org . apache . cassandra . locator . IEndpointSnitch ; 
 @ @ - 196 , 9 + 195 , 6 @ @ public class DatabaseDescriptor 
 indexAccessMode = conf . disk _ access _ mode ; 
 logger . info ( " DiskAccessMode is " + conf . disk _ access _ mode + " , indexAccessMode is " + indexAccessMode ) ; 
 } 
 - / / We could enable cleaner for index only mmap but it probably doesn ' t matter much 
 - if ( conf . disk _ access _ mode = = Config . DiskAccessMode . mmap ) 
 - MmappedSegmentedFile . initCleaner ( ) ; 
 
 	 logger . debug ( " page _ cache _ hinting is " + conf . populate _ io _ cache _ on _ flush ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / Directories . java b / src / java / org / apache / cassandra / db / Directories . java 
 index f023c8c . . 9c9f9b8 100644 
 - - - a / src / java / org / apache / cassandra / db / Directories . java 
 + + + b / src / java / org / apache / cassandra / db / Directories . java 
 @ @ - 117 , 7 + 117 , 7 @ @ public class Directories 
 / / Requesting GC has a chance to free space only if we ' re using mmap and a non SUN jvm 
 if ( path = = null 
 & & ( DatabaseDescriptor . getDiskAccessMode ( ) = = Config . DiskAccessMode . mmap | | DatabaseDescriptor . getIndexAccessMode ( ) = = Config . DiskAccessMode . mmap ) 
 - & & ! MmappedSegmentedFile . isCleanerAvailable ( ) ) 
 + & & ! FileUtils . isCleanerAvailable ( ) ) 
 { 
 logger . info ( " Forcing GC to free up disk space . Upgrade to the Oracle JVM to avoid this " ) ; 
 StorageService . instance . requestGC ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index 0449c47 . . fcd4130 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 314 , 6 + 314 , 7 @ @ public class CommitLogSegment 
 
 try 
 { 
 + FileUtils . clean ( buffer ) ; 
 logFileAccessor . close ( ) ; 
 closed = true ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / util / FileUtils . java b / src / java / org / apache / cassandra / io / util / FileUtils . java 
 index 4ddf8b6 . . 5ed6276 100644 
 - - - a / src / java / org / apache / cassandra / io / util / FileUtils . java 
 + + + b / src / java / org / apache / cassandra / io / util / FileUtils . java 
 @ @ - 19 , 6 + 19 , 9 @ @ 
 package org . apache . cassandra . io . util ; 
 
 import java . io . * ; 
 + import java . lang . reflect . InvocationTargetException ; 
 + import java . lang . reflect . Method ; 
 + import java . nio . MappedByteBuffer ; 
 import java . text . DecimalFormat ; 
 import java . util . Comparator ; 
 import java . util . List ; 
 @ @ - 39 , 6 + 42 , 22 @ @ public class FileUtils 
 private static final double gb _ = 1024 * 1024 * 1024d ; 
 private static final double tb _ = 1024 * 1024 * 1024 * 1024d ; 
 
 + private static final Method cleanerMethod = initCleaner ( ) ; 
 + 
 + private static Method initCleaner ( ) 
 + { 
 + try 
 + { 
 + return Class . forName ( " sun . nio . ch . DirectBuffer " ) . getMethod ( " cleaner " ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + / / Perhaps a non - sun - derived JVM - contributions welcome 
 + logger _ . info ( " Cannot initialize un - mmaper . ( Are you using a non - SUN JVM ? ) Compacted data files will not be removed promptly . Consider using a SUN JVM or using standard disk access mode " ) ; 
 + return null ; 
 + } 
 + } 
 + 
 public static void deleteWithConfirm ( String file ) throws IOException 
 { 
 deleteWithConfirm ( new File ( file ) ) ; 
 @ @ - 118 , 6 + 137 , 32 @ @ public class FileUtils 
 throw e ; 
 } 
 
 + public static boolean isCleanerAvailable ( ) 
 + { 
 + return cleanerMethod ! = null ; 
 + } 
 + 
 + public static void clean ( MappedByteBuffer buffer ) 
 + { 
 + try 
 + { 
 + Object cleaner = cleanerMethod . invoke ( buffer ) ; 
 + cleaner . getClass ( ) . getMethod ( " clean " ) . invoke ( cleaner ) ; 
 + } 
 + catch ( IllegalAccessException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( InvocationTargetException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( NoSuchMethodException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 public static class FileComparator implements Comparator < File > 
 { 
 public int compare ( File f , File f2 ) 
 diff - - git a / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java b / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java 
 index a933630 . . 5ebbe24 100644 
 - - - a / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java 
 + + + b / src / java / org / apache / cassandra / io / util / MmappedSegmentedFile . java 
 @ @ - 25 , 7 + 25 , 6 @ @ import java . io . File ; 
 import java . io . IOError ; 
 import java . io . IOException ; 
 import java . io . RandomAccessFile ; 
 - import java . lang . reflect . Method ; 
 import java . nio . MappedByteBuffer ; 
 import java . nio . channels . FileChannel ; 
 import java . util . ArrayList ; 
 @ @ - 42 , 8 + 41 , 6 @ @ public class MmappedSegmentedFile extends SegmentedFile 
 / / in a perfect world , MAX _ SEGMENT _ SIZE would be final , but we need to test with a smaller size to stay sane . 
 public static long MAX _ SEGMENT _ SIZE = Integer . MAX _ VALUE ; 
 
 - private static Method cleanerMethod = null ; 
 - 
 / * * 
 * Sorted array of segment offsets and MappedByteBuffers for segments . If mmap is completely disabled , or if the 
 * segment would be too long to mmap , the value for an offset will be null , indicating that we need to fall back 
 @ @ - 98 , 27 + 95 , 9 @ @ public class MmappedSegmentedFile extends SegmentedFile 
 } 
 } 
 
 - public static void initCleaner ( ) 
 - { 
 - try 
 - { 
 - cleanerMethod = Class . forName ( " sun . nio . ch . DirectBuffer " ) . getMethod ( " cleaner " ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - / / Perhaps a non - sun - derived JVM - contributions welcome 
 - logger . info ( " Cannot initialize un - mmaper . ( Are you using a non - SUN JVM ? ) Compacted data files will not be removed promptly . Consider using a SUN JVM or using standard disk access mode " ) ; 
 - } 
 - } 
 - 
 - public static boolean isCleanerAvailable ( ) 
 - { 
 - return cleanerMethod ! = null ; 
 - } 
 - 
 public void cleanup ( ) 
 { 
 - if ( cleanerMethod = = null ) 
 + if ( ! FileUtils . isCleanerAvailable ( ) ) 
 return ; 
 
 / * 
 @ @ - 132 , 9 + 111 , 7 @ @ public class MmappedSegmentedFile extends SegmentedFile 
 { 
 if ( segment . right = = null ) 
 continue ; 
 - 
 - Object cleaner = cleanerMethod . invoke ( segment . right ) ; 
 - cleaner . getClass ( ) . getMethod ( " clean " ) . invoke ( cleaner ) ; 
 + FileUtils . clean ( segment . right ) ; 
 } 
 logger . debug ( " All segments have been unmapped successfully " ) ; 
 }
