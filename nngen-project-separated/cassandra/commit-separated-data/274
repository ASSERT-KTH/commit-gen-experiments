BLEU SCORE: 0.018738883683389617

TEST MSG: Remove non - rpc - ready nodes from counter leader candidates
GENERATED MSG: iterate ranges rather than endpoints , and sort endpoints by proximity

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 07742ef . . 91f5a51 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 15 <nl> + * Remove non - rpc - ready nodes from counter leader candidates ( CASSANDRA - 13043 ) <nl> * Improve short read protection performance ( CASSANDRA - 13794 ) <nl> * Fix sstable reader to support range - tombstone - marker for multi - slices ( CASSANDRA - 13787 ) <nl> * Fix short read protection for tables with no clustering columns ( CASSANDRA - 13880 ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 1ce1bc5 . . 6bf275d 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 1404 , 27 + 1404 , 34 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> Keyspace keyspace = Keyspace . open ( keyspaceName ) ; <nl> IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; <nl> - List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( keyspace , key ) ; <nl> + List < InetAddress > endpoints = new ArrayList < > ( ) ; <nl> + StorageService . instance . getLiveNaturalEndpoints ( keyspace , key , endpoints ) ; <nl> + <nl> + / / CASSANDRA - 13043 : filter out those endpoints not accepting clients yet , maybe because still bootstrapping <nl> + endpoints . removeIf ( endpoint - > ! StorageService . instance . isRpcReady ( endpoint ) ) ; <nl> + <nl> + / / TODO have a way to compute the consistency level <nl> if ( endpoints . isEmpty ( ) ) <nl> - / / TODO have a way to compute the consistency level <nl> throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , 0 ) ; <nl> <nl> - List < InetAddress > localEndpoints = new ArrayList < InetAddress > ( ) ; <nl> + List < InetAddress > localEndpoints = new ArrayList < > ( endpoints . size ( ) ) ; <nl> + <nl> for ( InetAddress endpoint : endpoints ) <nl> - { <nl> if ( snitch . getDatacenter ( endpoint ) . equals ( localDataCenter ) ) <nl> localEndpoints . add ( endpoint ) ; <nl> - } <nl> + <nl> if ( localEndpoints . isEmpty ( ) ) <nl> { <nl> + / / If the consistency required is local then we should not involve other DCs <nl> + if ( cl . isDatacenterLocal ( ) ) <nl> + throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , 0 ) ; <nl> + <nl> / / No endpoint in local DC , pick the closest endpoint according to the snitch <nl> snitch . sortByProximity ( FBUtilities . getBroadcastAddress ( ) , endpoints ) ; <nl> return endpoints . get ( 0 ) ; <nl> } <nl> - else <nl> - { <nl> - return localEndpoints . get ( ThreadLocalRandom . current ( ) . nextInt ( localEndpoints . size ( ) ) ) ; <nl> - } <nl> + <nl> + return localEndpoints . get ( ThreadLocalRandom . current ( ) . nextInt ( localEndpoints . size ( ) ) ) ; <nl> } <nl> <nl> / / Must be called on a replica of the mutation . This replica becomes the <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index a1d1756 . . 52f28d4 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 3415 , 16 + 3415 , 28 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public List < InetAddress > getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos ) <nl> { <nl> + List < InetAddress > liveEps = new ArrayList < > ( ) ; <nl> + getLiveNaturalEndpoints ( keyspace , pos , liveEps ) ; <nl> + return liveEps ; <nl> + } <nl> + <nl> + / * * <nl> + * This method attempts to return N endpoints that are responsible for storing the <nl> + * specified key i . e for replication . <nl> + * <nl> + * @ param keyspace keyspace name also known as keyspace <nl> + * @ param pos position for which we need to find the endpoint <nl> + * @ param liveEps the list of endpoints to mutate <nl> + * / <nl> + public void getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos , List < InetAddress > liveEps ) <nl> + { <nl> List < InetAddress > endpoints = keyspace . getReplicationStrategy ( ) . getNaturalEndpoints ( pos ) ; <nl> - List < InetAddress > liveEps = new ArrayList < > ( endpoints . size ( ) ) ; <nl> <nl> for ( InetAddress endpoint : endpoints ) <nl> { <nl> if ( FailureDetector . instance . isAlive ( endpoint ) ) <nl> liveEps . add ( endpoint ) ; <nl> } <nl> - <nl> - return liveEps ; <nl> } <nl> <nl> public void setLoggingLevel ( String classQualifier , String rawLevel ) throws Exception
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> index cb4ff7c . . b021797 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java <nl> @ @ - 155 , 10 + 155 , 10 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> while ( forloopReturn . size ( ) < replicas _ & & iter . hasNext ( ) ) <nl> { <nl> Token t = iter . next ( ) ; <nl> - InetAddress endPointOfIntrest = metadata . getEndPoint ( t ) ; <nl> + InetAddress endPointOfInterest = metadata . getEndPoint ( t ) ; <nl> if ( forloopReturn . size ( ) < replicas _ - 1 ) <nl> { <nl> - forloopReturn . add ( endPointOfIntrest ) ; <nl> + forloopReturn . add ( endPointOfInterest ) ; <nl> continue ; <nl> } <nl> else <nl> @ @ - 169 , 7 + 169 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy <nl> / / Now try to find one on a different rack <nl> if ( ! bOtherRack ) <nl> { <nl> - if ( ! ( ( DatacenterEndPointSnitch ) snitch _ ) . isOnSameRack ( primaryHost , endPointOfIntrest ) ) <nl> + if ( ! ( ( DatacenterEndPointSnitch ) snitch _ ) . isOnSameRack ( primaryHost , endPointOfInterest ) ) <nl> { <nl> forloopReturn . add ( metadata . getEndPoint ( t ) ) ; <nl> bOtherRack = true ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index cada4f3 . . 3fc4e39 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 535 , 39 + 535 , 47 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> long startTime = System . nanoTime ( ) ; <nl> TokenMetadata tokenMetadata = StorageService . instance . getTokenMetadata ( ) ; <nl> + Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , command . range . left ) ; <nl> <nl> - InetAddress endPoint = StorageService . instance . getPrimary ( command . range . left ) ; <nl> - InetAddress startEndpoint = endPoint ; <nl> final String table = command . keyspace ; <nl> int responseCount = determineBlockFor ( DatabaseDescriptor . getReplicationFactor ( table ) , DatabaseDescriptor . getReplicationFactor ( table ) , consistency _ level ) ; <nl> <nl> - / / starting with the node that is primary for the start key , scan until either we have enough results , <nl> + / / starting with the range containing the start key , scan until either we have enough results , <nl> / / or the node scan reports that it was done ( i . e . , encountered a key outside the desired range ) . <nl> Map < String , ColumnFamily > rows = new HashMap < String , ColumnFamily > ( command . max _ keys ) ; <nl> outer : <nl> - do <nl> + while ( iter . hasNext ( ) ) <nl> { <nl> - Range primaryRange = StorageService . instance . getPrimaryRangeForEndPoint ( endPoint ) ; <nl> - List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( command . keyspace , primaryRange . right ) ; <nl> + Token currentToken = iter . next ( ) ; <nl> + Range currentRange = new Range ( tokenMetadata . getPredecessor ( currentToken ) , currentToken ) ; <nl> + List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( command . keyspace , currentToken ) ; <nl> if ( endpoints . size ( ) < responseCount ) <nl> throw new UnavailableException ( ) ; <nl> + DatabaseDescriptor . getEndPointSnitch ( command . keyspace ) . sortByProximity ( FBUtilities . getLocalAddress ( ) , endpoints ) ; <nl> + <nl> + / / make sure we only get keys from the current range ( and not other replicas that might be on the nodes ) . <nl> + / / usually this will be only one range , but sometimes the intersection of a wrapping Range with a non - wrapping <nl> + / / is two disjoint , non - wrapping Ranges separated by a gap . <nl> + List < AbstractBounds > restricted = command . range . restrictTo ( currentRange ) ; <nl> <nl> - / / to make comparing the results from each node easy , we restrict each scan the primary range for the node in question <nl> - List < AbstractBounds > restricted = command . range . restrictTo ( primaryRange ) ; <nl> for ( AbstractBounds range : restricted ) <nl> { <nl> RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , range , command . max _ keys ) ; <nl> Message message = c2 . getMessage ( ) ; <nl> <nl> / / collect replies and resolve according to consistency level <nl> - RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; <nl> + RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , currentRange , endpoints ) ; <nl> QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; <nl> - for ( InetAddress replicaEndpoint : endpoints ) <nl> + <nl> + Iterator < InetAddress > endpointIter = endpoints . iterator ( ) ; <nl> + for ( int i = 0 ; i < responseCount ; i + + ) <nl> { <nl> - MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; <nl> + InetAddress endpoint = endpointIter . next ( ) ; <nl> + MessagingService . instance . sendRR ( message , endpoint , handler ) ; <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endpoint ) ; <nl> } <nl> + / / TODO read repair on remaining replicas ? <nl> <nl> / / if we ' re done , great , otherwise , move to the next range <nl> try <nl> @ @ - 581 , 10 + 589 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) <nl> break outer ; <nl> } <nl> - <nl> - endPoint = tokenMetadata . getSuccessor ( endPoint ) ; <nl> } <nl> - while ( ! endPoint . equals ( startEndpoint ) ) ; <nl> <nl> List < Pair < String , ColumnFamily > > results = new ArrayList < Pair < String , ColumnFamily > > ( rows . size ( ) ) ; <nl> for ( Map . Entry < String , ColumnFamily > entry : rows . entrySet ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 2748042 . . 1e6606c 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 1095 , 40 + 1095 , 6 @ @ public class StorageService implements IEndPointStateChangeSubscriber , StorageSe <nl> } <nl> <nl> / * * <nl> - * This method returns the endpoint that is responsible for storing the <nl> - * specified key . <nl> - * <nl> - * @ param key - key for which we need to find the endpoint <nl> - * @ return value - the endpoint responsible for this key <nl> - * / <nl> - public InetAddress getPrimary ( String key ) <nl> - { <nl> - return getPrimary ( partitioner _ . getToken ( key ) ) ; <nl> - } <nl> - <nl> - public InetAddress getPrimary ( Token token ) <nl> - { <nl> - List tokens = tokenMetadata _ . sortedTokens ( ) ; <nl> - if ( tokens . size ( ) > 0 ) <nl> - { <nl> - return tokenMetadata _ . getEndPoint ( TokenMetadata . ringIterator ( tokens , token ) . next ( ) ) ; <nl> - } <nl> - return FBUtilities . getLocalAddress ( ) ; <nl> - } <nl> - <nl> - / * * <nl> - * This method determines whether the local endpoint is the <nl> - * primary for the given key . <nl> - * @ param key <nl> - * @ return true if the local endpoint is the primary replica . <nl> - * / <nl> - public boolean isPrimary ( String key ) <nl> - { <nl> - InetAddress endpoint = getPrimary ( key ) ; <nl> - return FBUtilities . getLocalAddress ( ) . equals ( endpoint ) ; <nl> - } <nl> - <nl> - / * * <nl> * This method returns the N endpoints that are responsible for storing the <nl> * specified key i . e for replication . <nl> *

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 07742ef . . 91f5a51 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 15 
 + * Remove non - rpc - ready nodes from counter leader candidates ( CASSANDRA - 13043 ) 
 * Improve short read protection performance ( CASSANDRA - 13794 ) 
 * Fix sstable reader to support range - tombstone - marker for multi - slices ( CASSANDRA - 13787 ) 
 * Fix short read protection for tables with no clustering columns ( CASSANDRA - 13880 ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 1ce1bc5 . . 6bf275d 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 1404 , 27 + 1404 , 34 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 Keyspace keyspace = Keyspace . open ( keyspaceName ) ; 
 IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; 
 - List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( keyspace , key ) ; 
 + List < InetAddress > endpoints = new ArrayList < > ( ) ; 
 + StorageService . instance . getLiveNaturalEndpoints ( keyspace , key , endpoints ) ; 
 + 
 + / / CASSANDRA - 13043 : filter out those endpoints not accepting clients yet , maybe because still bootstrapping 
 + endpoints . removeIf ( endpoint - > ! StorageService . instance . isRpcReady ( endpoint ) ) ; 
 + 
 + / / TODO have a way to compute the consistency level 
 if ( endpoints . isEmpty ( ) ) 
 - / / TODO have a way to compute the consistency level 
 throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , 0 ) ; 
 
 - List < InetAddress > localEndpoints = new ArrayList < InetAddress > ( ) ; 
 + List < InetAddress > localEndpoints = new ArrayList < > ( endpoints . size ( ) ) ; 
 + 
 for ( InetAddress endpoint : endpoints ) 
 - { 
 if ( snitch . getDatacenter ( endpoint ) . equals ( localDataCenter ) ) 
 localEndpoints . add ( endpoint ) ; 
 - } 
 + 
 if ( localEndpoints . isEmpty ( ) ) 
 { 
 + / / If the consistency required is local then we should not involve other DCs 
 + if ( cl . isDatacenterLocal ( ) ) 
 + throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , 0 ) ; 
 + 
 / / No endpoint in local DC , pick the closest endpoint according to the snitch 
 snitch . sortByProximity ( FBUtilities . getBroadcastAddress ( ) , endpoints ) ; 
 return endpoints . get ( 0 ) ; 
 } 
 - else 
 - { 
 - return localEndpoints . get ( ThreadLocalRandom . current ( ) . nextInt ( localEndpoints . size ( ) ) ) ; 
 - } 
 + 
 + return localEndpoints . get ( ThreadLocalRandom . current ( ) . nextInt ( localEndpoints . size ( ) ) ) ; 
 } 
 
 / / Must be called on a replica of the mutation . This replica becomes the 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index a1d1756 . . 52f28d4 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 3415 , 16 + 3415 , 28 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public List < InetAddress > getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos ) 
 { 
 + List < InetAddress > liveEps = new ArrayList < > ( ) ; 
 + getLiveNaturalEndpoints ( keyspace , pos , liveEps ) ; 
 + return liveEps ; 
 + } 
 + 
 + / * * 
 + * This method attempts to return N endpoints that are responsible for storing the 
 + * specified key i . e for replication . 
 + * 
 + * @ param keyspace keyspace name also known as keyspace 
 + * @ param pos position for which we need to find the endpoint 
 + * @ param liveEps the list of endpoints to mutate 
 + * / 
 + public void getLiveNaturalEndpoints ( Keyspace keyspace , RingPosition pos , List < InetAddress > liveEps ) 
 + { 
 List < InetAddress > endpoints = keyspace . getReplicationStrategy ( ) . getNaturalEndpoints ( pos ) ; 
 - List < InetAddress > liveEps = new ArrayList < > ( endpoints . size ( ) ) ; 
 
 for ( InetAddress endpoint : endpoints ) 
 { 
 if ( FailureDetector . instance . isAlive ( endpoint ) ) 
 liveEps . add ( endpoint ) ; 
 } 
 - 
 - return liveEps ; 
 } 
 
 public void setLoggingLevel ( String classQualifier , String rawLevel ) throws Exception

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 index cb4ff7c . . b021797 100644 
 - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStategy . java 
 @ @ - 155 , 10 + 155 , 10 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 while ( forloopReturn . size ( ) < replicas _ & & iter . hasNext ( ) ) 
 { 
 Token t = iter . next ( ) ; 
 - InetAddress endPointOfIntrest = metadata . getEndPoint ( t ) ; 
 + InetAddress endPointOfInterest = metadata . getEndPoint ( t ) ; 
 if ( forloopReturn . size ( ) < replicas _ - 1 ) 
 { 
 - forloopReturn . add ( endPointOfIntrest ) ; 
 + forloopReturn . add ( endPointOfInterest ) ; 
 continue ; 
 } 
 else 
 @ @ - 169 , 7 + 169 , 7 @ @ public class DatacenterShardStategy extends AbstractReplicationStrategy 
 / / Now try to find one on a different rack 
 if ( ! bOtherRack ) 
 { 
 - if ( ! ( ( DatacenterEndPointSnitch ) snitch _ ) . isOnSameRack ( primaryHost , endPointOfIntrest ) ) 
 + if ( ! ( ( DatacenterEndPointSnitch ) snitch _ ) . isOnSameRack ( primaryHost , endPointOfInterest ) ) 
 { 
 forloopReturn . add ( metadata . getEndPoint ( t ) ) ; 
 bOtherRack = true ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index cada4f3 . . 3fc4e39 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 535 , 39 + 535 , 47 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 long startTime = System . nanoTime ( ) ; 
 TokenMetadata tokenMetadata = StorageService . instance . getTokenMetadata ( ) ; 
 + Iterator < Token > iter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , command . range . left ) ; 
 
 - InetAddress endPoint = StorageService . instance . getPrimary ( command . range . left ) ; 
 - InetAddress startEndpoint = endPoint ; 
 final String table = command . keyspace ; 
 int responseCount = determineBlockFor ( DatabaseDescriptor . getReplicationFactor ( table ) , DatabaseDescriptor . getReplicationFactor ( table ) , consistency _ level ) ; 
 
 - / / starting with the node that is primary for the start key , scan until either we have enough results , 
 + / / starting with the range containing the start key , scan until either we have enough results , 
 / / or the node scan reports that it was done ( i . e . , encountered a key outside the desired range ) . 
 Map < String , ColumnFamily > rows = new HashMap < String , ColumnFamily > ( command . max _ keys ) ; 
 outer : 
 - do 
 + while ( iter . hasNext ( ) ) 
 { 
 - Range primaryRange = StorageService . instance . getPrimaryRangeForEndPoint ( endPoint ) ; 
 - List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( command . keyspace , primaryRange . right ) ; 
 + Token currentToken = iter . next ( ) ; 
 + Range currentRange = new Range ( tokenMetadata . getPredecessor ( currentToken ) , currentToken ) ; 
 + List < InetAddress > endpoints = StorageService . instance . getLiveNaturalEndpoints ( command . keyspace , currentToken ) ; 
 if ( endpoints . size ( ) < responseCount ) 
 throw new UnavailableException ( ) ; 
 + DatabaseDescriptor . getEndPointSnitch ( command . keyspace ) . sortByProximity ( FBUtilities . getLocalAddress ( ) , endpoints ) ; 
 + 
 + / / make sure we only get keys from the current range ( and not other replicas that might be on the nodes ) . 
 + / / usually this will be only one range , but sometimes the intersection of a wrapping Range with a non - wrapping 
 + / / is two disjoint , non - wrapping Ranges separated by a gap . 
 + List < AbstractBounds > restricted = command . range . restrictTo ( currentRange ) ; 
 
 - / / to make comparing the results from each node easy , we restrict each scan the primary range for the node in question 
 - List < AbstractBounds > restricted = command . range . restrictTo ( primaryRange ) ; 
 for ( AbstractBounds range : restricted ) 
 { 
 RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , range , command . max _ keys ) ; 
 Message message = c2 . getMessage ( ) ; 
 
 / / collect replies and resolve according to consistency level 
 - RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; 
 + RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , currentRange , endpoints ) ; 
 QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; 
 - for ( InetAddress replicaEndpoint : endpoints ) 
 + 
 + Iterator < InetAddress > endpointIter = endpoints . iterator ( ) ; 
 + for ( int i = 0 ; i < responseCount ; i + + ) 
 { 
 - MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; 
 + InetAddress endpoint = endpointIter . next ( ) ; 
 + MessagingService . instance . sendRR ( message , endpoint , handler ) ; 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endpoint ) ; 
 } 
 + / / TODO read repair on remaining replicas ? 
 
 / / if we ' re done , great , otherwise , move to the next range 
 try 
 @ @ - 581 , 10 + 589 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) 
 break outer ; 
 } 
 - 
 - endPoint = tokenMetadata . getSuccessor ( endPoint ) ; 
 } 
 - while ( ! endPoint . equals ( startEndpoint ) ) ; 
 
 List < Pair < String , ColumnFamily > > results = new ArrayList < Pair < String , ColumnFamily > > ( rows . size ( ) ) ; 
 for ( Map . Entry < String , ColumnFamily > entry : rows . entrySet ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 2748042 . . 1e6606c 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 1095 , 40 + 1095 , 6 @ @ public class StorageService implements IEndPointStateChangeSubscriber , StorageSe 
 } 
 
 / * * 
 - * This method returns the endpoint that is responsible for storing the 
 - * specified key . 
 - * 
 - * @ param key - key for which we need to find the endpoint 
 - * @ return value - the endpoint responsible for this key 
 - * / 
 - public InetAddress getPrimary ( String key ) 
 - { 
 - return getPrimary ( partitioner _ . getToken ( key ) ) ; 
 - } 
 - 
 - public InetAddress getPrimary ( Token token ) 
 - { 
 - List tokens = tokenMetadata _ . sortedTokens ( ) ; 
 - if ( tokens . size ( ) > 0 ) 
 - { 
 - return tokenMetadata _ . getEndPoint ( TokenMetadata . ringIterator ( tokens , token ) . next ( ) ) ; 
 - } 
 - return FBUtilities . getLocalAddress ( ) ; 
 - } 
 - 
 - / * * 
 - * This method determines whether the local endpoint is the 
 - * primary for the given key . 
 - * @ param key 
 - * @ return true if the local endpoint is the primary replica . 
 - * / 
 - public boolean isPrimary ( String key ) 
 - { 
 - InetAddress endpoint = getPrimary ( key ) ; 
 - return FBUtilities . getLocalAddress ( ) . equals ( endpoint ) ; 
 - } 
 - 
 - / * * 
 * This method returns the N endpoints that are responsible for storing the 
 * specified key i . e for replication . 
 *
