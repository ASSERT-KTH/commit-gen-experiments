BLEU SCORE: 0.015445276590783498

TEST MSG: Do more aggressive ttl expiration checks to be able to drop more sstables
GENERATED MSG: revert CASSANDRA - 5151 from 1 . 2

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6228893 . . 2476d25 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 3 <nl> + * Do more aggressive entire - sstable TTL expiry checks ( CASSANDRA - 8243 ) <nl> * Add more log info if readMeter is null ( CASSANDRA - 8238 ) <nl> * add check of the system wall clock time at startup ( CASSANDRA - 8305 ) <nl> * Support for frozen collections ( CASSANDRA - 7859 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> index ef27805 . . f23d39a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java <nl> @ @ - 92 , 12 + 92 , 11 @ @ public class CompactionController implements AutoCloseable <nl> * Finds expired sstables <nl> * <nl> * works something like this ; <nl> - * 1 . find " global " minTimestamp of overlapping sstables ( excluding the possibly droppable ones ) <nl> - * 2 . build a list of candidates to be dropped <nl> - * 3 . sort the candidate list , biggest maxTimestamp first in list <nl> - * 4 . check if the candidates to be dropped actually can be dropped ( maxTimestamp < global minTimestamp ) and it is included in the compaction <nl> - * - if not droppable , update global minTimestamp and remove from candidates <nl> - * 5 . return candidates . <nl> + * 1 . find " global " minTimestamp of overlapping sstables and compacting sstables containing any non - expired data <nl> + * 2 . build a list of fully expired candidates <nl> + * 3 . check if the candidates to be dropped actually can be dropped ( maxTimestamp < global minTimestamp ) <nl> + * - if not droppable , remove from candidates <nl> + * 4 . return candidates . <nl> * <nl> * @ param cfStore <nl> * @ param compacting we take the drop - candidates from this set , it is usually the sstables included in the compaction <nl> @ @ - 127 , 10 + 126 , 10 @ @ public class CompactionController implements AutoCloseable <nl> minTimestamp = Math . min ( minTimestamp , candidate . getMinTimestamp ( ) ) ; <nl> } <nl> <nl> - / / we still need to keep candidates that might shadow something in a <nl> - / / non - candidate sstable . And if we remove a sstable from the candidates , we <nl> - / / must take it ' s timestamp into account ( hence the sorting below ) . <nl> - Collections . sort ( candidates , SSTableReader . maxTimestampComparator ) ; <nl> + / / At this point , minTimestamp denotes the lowest timestamp of any relevant <nl> + / / SSTable that contains a constructive value . candidates contains all the <nl> + / / candidates with no constructive values . The ones out of these that have <nl> + / / ( getMaxTimestamp ( ) < minTimestamp ) serve no purpose anymore . <nl> <nl> Iterator < SSTableReader > iterator = candidates . iterator ( ) ; <nl> while ( iterator . hasNext ( ) ) <nl> @ @ - 138 , 7 + 137 , 6 @ @ public class CompactionController implements AutoCloseable <nl> SSTableReader candidate = iterator . next ( ) ; <nl> if ( candidate . getMaxTimestamp ( ) > = minTimestamp ) <nl> { <nl> - minTimestamp = Math . min ( candidate . getMinTimestamp ( ) , minTimestamp ) ; <nl> iterator . remove ( ) ; <nl> } <nl> else <nl> diff - - git a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> index b98af68 . . 4fe5cfb 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db . compaction ; <nl> * <nl> * / <nl> <nl> + import com . google . common . collect . Sets ; <nl> import org . junit . Test ; <nl> import org . junit . runner . RunWith ; <nl> <nl> @ @ - 31 , 6 + 32 , 10 @ @ import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . io . sstable . SSTableScanner ; <nl> import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + <nl> + import java . util . Collections ; <nl> + import java . util . Set ; <nl> + <nl> import static org . junit . Assert . assertEquals ; <nl> import static org . junit . Assert . assertTrue ; <nl> <nl> @ @ - 38 , 6 + 43 , 51 @ @ import static org . junit . Assert . assertTrue ; <nl> public class TTLExpiryTest extends SchemaLoader <nl> { <nl> @ Test <nl> + public void testAggressiveFullyExpired ( ) <nl> + { <nl> + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ; <nl> + cfs . disableAutoCompaction ( ) ; <nl> + cfs . metadata . gcGraceSeconds ( 0 ) ; <nl> + <nl> + DecoratedKey ttlKey = Util . dk ( " ttl " ) ; <nl> + Mutation rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 1 , 1 ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 3 , 1 ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 2 , 1 ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 5 , 1 ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 4 , 1 ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " shadow " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 7 , 1 ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " shadow " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 6 , 3 ) ; <nl> + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 8 , 1 ) ; <nl> + rm . applyUnsafe ( ) ; <nl> + cfs . forceBlockingFlush ( ) ; <nl> + <nl> + Set < SSTableReader > sstables = Sets . newHashSet ( cfs . getSSTables ( ) ) ; <nl> + int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; <nl> + int gcBefore = now + 2 ; <nl> + Set < SSTableReader > expired = CompactionController . getFullyExpiredSSTables ( <nl> + cfs , <nl> + sstables , <nl> + Collections . EMPTY _ SET , <nl> + gcBefore ) ; <nl> + assertEquals ( 2 , expired . size ( ) ) ; <nl> + <nl> + cfs . clearUnsafe ( ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testSimpleExpire ( ) throws InterruptedException <nl> { <nl> ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> index becbacf . . a413bc5 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> @ @ - 30 , 7 + 30 , 7 @ @ public interface DynamicEndpointSnitchMBean { <nl> public String getSubsnitchClassName ( ) ; <nl> public List < Double > dumpTimings ( String hostname ) throws UnknownHostException ; <nl> / * * <nl> - * Use this if you want to specify a severity it can be - ve <nl> + * Use this if you want to specify a severity ; it can be negative <nl> * Example : Page cache is cold and you want data to be sent <nl> * though it is not preferred one . <nl> * /

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6228893 . . 2476d25 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 3 
 + * Do more aggressive entire - sstable TTL expiry checks ( CASSANDRA - 8243 ) 
 * Add more log info if readMeter is null ( CASSANDRA - 8238 ) 
 * add check of the system wall clock time at startup ( CASSANDRA - 8305 ) 
 * Support for frozen collections ( CASSANDRA - 7859 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / CompactionController . java b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 index ef27805 . . f23d39a 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / CompactionController . java 
 @ @ - 92 , 12 + 92 , 11 @ @ public class CompactionController implements AutoCloseable 
 * Finds expired sstables 
 * 
 * works something like this ; 
 - * 1 . find " global " minTimestamp of overlapping sstables ( excluding the possibly droppable ones ) 
 - * 2 . build a list of candidates to be dropped 
 - * 3 . sort the candidate list , biggest maxTimestamp first in list 
 - * 4 . check if the candidates to be dropped actually can be dropped ( maxTimestamp < global minTimestamp ) and it is included in the compaction 
 - * - if not droppable , update global minTimestamp and remove from candidates 
 - * 5 . return candidates . 
 + * 1 . find " global " minTimestamp of overlapping sstables and compacting sstables containing any non - expired data 
 + * 2 . build a list of fully expired candidates 
 + * 3 . check if the candidates to be dropped actually can be dropped ( maxTimestamp < global minTimestamp ) 
 + * - if not droppable , remove from candidates 
 + * 4 . return candidates . 
 * 
 * @ param cfStore 
 * @ param compacting we take the drop - candidates from this set , it is usually the sstables included in the compaction 
 @ @ - 127 , 10 + 126 , 10 @ @ public class CompactionController implements AutoCloseable 
 minTimestamp = Math . min ( minTimestamp , candidate . getMinTimestamp ( ) ) ; 
 } 
 
 - / / we still need to keep candidates that might shadow something in a 
 - / / non - candidate sstable . And if we remove a sstable from the candidates , we 
 - / / must take it ' s timestamp into account ( hence the sorting below ) . 
 - Collections . sort ( candidates , SSTableReader . maxTimestampComparator ) ; 
 + / / At this point , minTimestamp denotes the lowest timestamp of any relevant 
 + / / SSTable that contains a constructive value . candidates contains all the 
 + / / candidates with no constructive values . The ones out of these that have 
 + / / ( getMaxTimestamp ( ) < minTimestamp ) serve no purpose anymore . 
 
 Iterator < SSTableReader > iterator = candidates . iterator ( ) ; 
 while ( iterator . hasNext ( ) ) 
 @ @ - 138 , 7 + 137 , 6 @ @ public class CompactionController implements AutoCloseable 
 SSTableReader candidate = iterator . next ( ) ; 
 if ( candidate . getMaxTimestamp ( ) > = minTimestamp ) 
 { 
 - minTimestamp = Math . min ( candidate . getMinTimestamp ( ) , minTimestamp ) ; 
 iterator . remove ( ) ; 
 } 
 else 
 diff - - git a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 index b98af68 . . 4fe5cfb 100644 
 - - - a / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 + + + b / test / unit / org / apache / cassandra / db / compaction / TTLExpiryTest . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . db . compaction ; 
 * 
 * / 
 
 + import com . google . common . collect . Sets ; 
 import org . junit . Test ; 
 import org . junit . runner . RunWith ; 
 
 @ @ - 31 , 6 + 32 , 10 @ @ import org . apache . cassandra . db . columniterator . OnDiskAtomIterator ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . io . sstable . SSTableScanner ; 
 import org . apache . cassandra . utils . ByteBufferUtil ; 
 + 
 + import java . util . Collections ; 
 + import java . util . Set ; 
 + 
 import static org . junit . Assert . assertEquals ; 
 import static org . junit . Assert . assertTrue ; 
 
 @ @ - 38 , 6 + 43 , 51 @ @ import static org . junit . Assert . assertTrue ; 
 public class TTLExpiryTest extends SchemaLoader 
 { 
 @ Test 
 + public void testAggressiveFullyExpired ( ) 
 + { 
 + ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ; 
 + cfs . disableAutoCompaction ( ) ; 
 + cfs . metadata . gcGraceSeconds ( 0 ) ; 
 + 
 + DecoratedKey ttlKey = Util . dk ( " ttl " ) ; 
 + Mutation rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 1 , 1 ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 3 , 1 ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 2 , 1 ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 5 , 1 ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col1 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 4 , 1 ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " shadow " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 7 , 1 ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + rm = new Mutation ( " Keyspace1 " , ttlKey . getKey ( ) ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " shadow " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 6 , 3 ) ; 
 + rm . add ( " Standard1 " , Util . cellname ( " col2 " ) , ByteBufferUtil . EMPTY _ BYTE _ BUFFER , 8 , 1 ) ; 
 + rm . applyUnsafe ( ) ; 
 + cfs . forceBlockingFlush ( ) ; 
 + 
 + Set < SSTableReader > sstables = Sets . newHashSet ( cfs . getSSTables ( ) ) ; 
 + int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; 
 + int gcBefore = now + 2 ; 
 + Set < SSTableReader > expired = CompactionController . getFullyExpiredSSTables ( 
 + cfs , 
 + sstables , 
 + Collections . EMPTY _ SET , 
 + gcBefore ) ; 
 + assertEquals ( 2 , expired . size ( ) ) ; 
 + 
 + cfs . clearUnsafe ( ) ; 
 + } 
 + 
 + @ Test 
 public void testSimpleExpire ( ) throws InterruptedException 
 { 
 ColumnFamilyStore cfs = Keyspace . open ( " Keyspace1 " ) . getColumnFamilyStore ( " Standard1 " ) ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 index becbacf . . a413bc5 100644 
 - - - a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 @ @ - 30 , 7 + 30 , 7 @ @ public interface DynamicEndpointSnitchMBean { 
 public String getSubsnitchClassName ( ) ; 
 public List < Double > dumpTimings ( String hostname ) throws UnknownHostException ; 
 / * * 
 - * Use this if you want to specify a severity it can be - ve 
 + * Use this if you want to specify a severity ; it can be negative 
 * Example : Page cache is cold and you want data to be sent 
 * though it is not preferred one . 
 * /
