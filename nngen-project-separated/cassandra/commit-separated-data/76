BLEU SCORE: 0.020980574531482755

TEST MSG: Fix purging semi - expired RT boundaries in reversed iterators
GENERATED MSG: Throttle base partitions during MV repair streaming to prevent OOM

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 43628b2 . . 2c2f4f5 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 18 <nl> + * Fix purging semi - expired RT boundaries in reversed iterators ( CASSANDRA - 14672 ) <nl> * DESC order reads can fail to return the last Unfiltered in the partition ( CASSANDRA - 14766 ) <nl> * Fix corrupted collection deletions for dropped columns in 3 . 0 < - > 2 . { 1 , 2 } messages ( CASSANDRA - 14568 ) <nl> * Fix corrupted static collection deletions in 3 . 0 < - > 2 . { 1 , 2 } messages ( CASSANDRA - 14568 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> index c4bc2f2 . . f0f5421 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> @ @ - 136 , 12 + 136 , 12 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker <nl> <nl> public RangeTombstoneBoundMarker createCorrespondingCloseMarker ( boolean reversed ) <nl> { <nl> - return new RangeTombstoneBoundMarker ( closeBound ( reversed ) , endDeletion ) ; <nl> + return new RangeTombstoneBoundMarker ( closeBound ( reversed ) , closeDeletionTime ( reversed ) ) ; <nl> } <nl> <nl> public RangeTombstoneBoundMarker createCorrespondingOpenMarker ( boolean reversed ) <nl> { <nl> - return new RangeTombstoneBoundMarker ( openBound ( reversed ) , startDeletion ) ; <nl> + return new RangeTombstoneBoundMarker ( openBound ( reversed ) , openDeletionTime ( reversed ) ) ; <nl> } <nl> <nl> public void digest ( MessageDigest digest ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java b / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java <nl> new file mode 100644 <nl> index 0000000 . . 1dea7f3 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java <nl> @ @ - 0 , 0 + 1 , 294 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . db . partitions ; <nl> + <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Iterator ; <nl> + import java . util . function . Predicate ; <nl> + <nl> + import com . google . common . collect . Iterators ; <nl> + import org . junit . Before ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . db . ClusteringPrefix . Kind ; <nl> + import org . apache . cassandra . db . * ; <nl> + import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . db . rows . * ; <nl> + import org . apache . cassandra . db . transform . Transformation ; <nl> + import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; <nl> + <nl> + public final class PurgeFunctionTest <nl> + { <nl> + private static final String KEYSPACE = " PurgeFunctionTest " ; <nl> + private static final String TABLE = " table " ; <nl> + <nl> + private CFMetaData metadata ; <nl> + private DecoratedKey key ; <nl> + <nl> + private static UnfilteredPartitionIterator withoutPurgeableTombstones ( UnfilteredPartitionIterator iterator , int gcBefore ) <nl> + { <nl> + class WithoutPurgeableTombstones extends PurgeFunction <nl> + { <nl> + private WithoutPurgeableTombstones ( ) <nl> + { <nl> + super ( iterator . isForThrift ( ) , FBUtilities . nowInSeconds ( ) , gcBefore , Integer . MAX _ VALUE , false , false ) ; <nl> + } <nl> + <nl> + protected Predicate < Long > getPurgeEvaluator ( ) <nl> + { <nl> + return time - > true ; <nl> + } <nl> + } <nl> + <nl> + return Transformation . apply ( iterator , new WithoutPurgeableTombstones ( ) ) ; <nl> + } <nl> + <nl> + @ Before <nl> + public void setUp ( ) <nl> + { <nl> + metadata = <nl> + CFMetaData . Builder <nl> + . create ( KEYSPACE , TABLE ) <nl> + . addPartitionKey ( " pk " , UTF8Type . instance ) <nl> + . addClusteringColumn ( " ck " , UTF8Type . instance ) <nl> + . build ( ) ; <nl> + key = Murmur3Partitioner . instance . decorateKey ( bytes ( " key " ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNothingIsPurgeableASC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 0 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testNothingIsPurgeableDESC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( true <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 0 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( true <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testEverythingIsPurgeableASC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 2 ) ; <nl> + <nl> + assertTrue ( ! purged . hasNext ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testEverythingIsPurgeableDESC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( false <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 2 ) ; <nl> + <nl> + assertTrue ( ! purged . hasNext ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testFirstHalfIsPurgeableASC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testFirstHalfIsPurgeableDESC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( true <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( false <nl> + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " b " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSecondHalfIsPurgeableASC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 1L , 1 , 0L , 0 , " b " ) <nl> + , bound ( Kind . INCL _ END _ BOUND , 0L , 0 , " c " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( false <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) <nl> + , bound ( Kind . EXCL _ END _ BOUND , 1L , 1 , " b " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSecondHalfIsPurgeableDESC ( ) <nl> + { <nl> + UnfilteredPartitionIterator original = iter ( true <nl> + , bound ( Kind . INCL _ END _ BOUND , 0L , 0 , " c " ) <nl> + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 1L , 1 , 0L , 0 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) <nl> + ) ; <nl> + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; <nl> + <nl> + UnfilteredPartitionIterator expected = iter ( true <nl> + , bound ( Kind . EXCL _ END _ BOUND , 1L , 1 , " b " ) <nl> + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) <nl> + ) ; <nl> + assertIteratorsEqual ( expected , purged ) ; <nl> + } <nl> + <nl> + private UnfilteredPartitionIterator iter ( boolean isReversedOrder , Unfiltered . . . unfiltereds ) <nl> + { <nl> + Iterator < Unfiltered > iterator = Iterators . forArray ( unfiltereds ) ; <nl> + <nl> + UnfilteredRowIterator rowIter = <nl> + new AbstractUnfilteredRowIterator ( metadata , <nl> + key , <nl> + DeletionTime . LIVE , <nl> + metadata . partitionColumns ( ) , <nl> + Rows . EMPTY _ STATIC _ ROW , <nl> + isReversedOrder , <nl> + EncodingStats . NO _ STATS ) <nl> + { <nl> + protected Unfiltered computeNext ( ) <nl> + { <nl> + return iterator . hasNext ( ) ? iterator . next ( ) : endOfData ( ) ; <nl> + } <nl> + } ; <nl> + <nl> + return new SingletonUnfilteredPartitionIterator ( rowIter , false ) ; <nl> + } <nl> + <nl> + private RangeTombstoneBoundMarker bound ( ClusteringPrefix . Kind kind , <nl> + long timestamp , <nl> + int localDeletionTime , <nl> + Object clusteringValue ) <nl> + { <nl> + ByteBuffer [ ] clusteringByteBuffers = <nl> + new ByteBuffer [ ] { decompose ( metadata . clusteringColumns ( ) . get ( 0 ) . type , clusteringValue ) } ; <nl> + <nl> + return new RangeTombstoneBoundMarker ( new RangeTombstone . Bound ( kind , clusteringByteBuffers ) , <nl> + new DeletionTime ( timestamp , localDeletionTime ) ) ; <nl> + } <nl> + <nl> + private RangeTombstoneBoundaryMarker boundary ( ClusteringPrefix . Kind kind , <nl> + long closeTimestamp , <nl> + int closeLocalDeletionTime , <nl> + long openTimestamp , <nl> + int openDeletionTime , <nl> + Object clusteringValue ) <nl> + { <nl> + ByteBuffer [ ] clusteringByteBuffers = <nl> + new ByteBuffer [ ] { decompose ( metadata . clusteringColumns ( ) . get ( 0 ) . type , clusteringValue ) } ; <nl> + <nl> + return new RangeTombstoneBoundaryMarker ( new RangeTombstone . Bound ( kind , clusteringByteBuffers ) , <nl> + new DeletionTime ( closeTimestamp , closeLocalDeletionTime ) , <nl> + new DeletionTime ( openTimestamp , openDeletionTime ) ) ; <nl> + } <nl> + <nl> + @ SuppressWarnings ( " unchecked " ) <nl> + private static < T > ByteBuffer decompose ( AbstractType < ? > type , T value ) <nl> + { <nl> + return ( ( AbstractType < T > ) type ) . decompose ( value ) ; <nl> + } <nl> + <nl> + private void assertIteratorsEqual ( UnfilteredPartitionIterator iter1 , UnfilteredPartitionIterator iter2 ) <nl> + { <nl> + while ( iter1 . hasNext ( ) ) <nl> + { <nl> + assertTrue ( iter2 . hasNext ( ) ) ; <nl> + <nl> + try ( UnfilteredRowIterator partition1 = iter1 . next ( ) ) <nl> + { <nl> + try ( UnfilteredRowIterator partition2 = iter2 . next ( ) ) <nl> + { <nl> + assertIteratorsEqual ( partition1 , partition2 ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + assertTrue ( ! iter2 . hasNext ( ) ) ; <nl> + } <nl> + <nl> + private void assertIteratorsEqual ( UnfilteredRowIterator iter1 , UnfilteredRowIterator iter2 ) <nl> + { <nl> + while ( iter1 . hasNext ( ) ) <nl> + { <nl> + assertTrue ( iter2 . hasNext ( ) ) ; <nl> + <nl> + assertEquals ( iter1 . next ( ) , iter2 . next ( ) ) ; <nl> + } <nl> + assertTrue ( ! iter2 . hasNext ( ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 43628b2 . . 2c2f4f5 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 18 
 + * Fix purging semi - expired RT boundaries in reversed iterators ( CASSANDRA - 14672 ) 
 * DESC order reads can fail to return the last Unfiltered in the partition ( CASSANDRA - 14766 ) 
 * Fix corrupted collection deletions for dropped columns in 3 . 0 < - > 2 . { 1 , 2 } messages ( CASSANDRA - 14568 ) 
 * Fix corrupted static collection deletions in 3 . 0 < - > 2 . { 1 , 2 } messages ( CASSANDRA - 14568 ) 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 index c4bc2f2 . . f0f5421 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 @ @ - 136 , 12 + 136 , 12 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker 
 
 public RangeTombstoneBoundMarker createCorrespondingCloseMarker ( boolean reversed ) 
 { 
 - return new RangeTombstoneBoundMarker ( closeBound ( reversed ) , endDeletion ) ; 
 + return new RangeTombstoneBoundMarker ( closeBound ( reversed ) , closeDeletionTime ( reversed ) ) ; 
 } 
 
 public RangeTombstoneBoundMarker createCorrespondingOpenMarker ( boolean reversed ) 
 { 
 - return new RangeTombstoneBoundMarker ( openBound ( reversed ) , startDeletion ) ; 
 + return new RangeTombstoneBoundMarker ( openBound ( reversed ) , openDeletionTime ( reversed ) ) ; 
 } 
 
 public void digest ( MessageDigest digest ) 
 diff - - git a / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java b / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java 
 new file mode 100644 
 index 0000000 . . 1dea7f3 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / partitions / PurgeFunctionTest . java 
 @ @ - 0 , 0 + 1 , 294 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . db . partitions ; 
 + 
 + import java . nio . ByteBuffer ; 
 + import java . util . Iterator ; 
 + import java . util . function . Predicate ; 
 + 
 + import com . google . common . collect . Iterators ; 
 + import org . junit . Before ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . db . ClusteringPrefix . Kind ; 
 + import org . apache . cassandra . db . * ; 
 + import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . db . rows . * ; 
 + import org . apache . cassandra . db . transform . Transformation ; 
 + import org . apache . cassandra . dht . Murmur3Partitioner ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; 
 + 
 + public final class PurgeFunctionTest 
 + { 
 + private static final String KEYSPACE = " PurgeFunctionTest " ; 
 + private static final String TABLE = " table " ; 
 + 
 + private CFMetaData metadata ; 
 + private DecoratedKey key ; 
 + 
 + private static UnfilteredPartitionIterator withoutPurgeableTombstones ( UnfilteredPartitionIterator iterator , int gcBefore ) 
 + { 
 + class WithoutPurgeableTombstones extends PurgeFunction 
 + { 
 + private WithoutPurgeableTombstones ( ) 
 + { 
 + super ( iterator . isForThrift ( ) , FBUtilities . nowInSeconds ( ) , gcBefore , Integer . MAX _ VALUE , false , false ) ; 
 + } 
 + 
 + protected Predicate < Long > getPurgeEvaluator ( ) 
 + { 
 + return time - > true ; 
 + } 
 + } 
 + 
 + return Transformation . apply ( iterator , new WithoutPurgeableTombstones ( ) ) ; 
 + } 
 + 
 + @ Before 
 + public void setUp ( ) 
 + { 
 + metadata = 
 + CFMetaData . Builder 
 + . create ( KEYSPACE , TABLE ) 
 + . addPartitionKey ( " pk " , UTF8Type . instance ) 
 + . addClusteringColumn ( " ck " , UTF8Type . instance ) 
 + . build ( ) ; 
 + key = Murmur3Partitioner . instance . decorateKey ( bytes ( " key " ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testNothingIsPurgeableASC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 0 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + @ Test 
 + public void testNothingIsPurgeableDESC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( true 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 0 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( true 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + @ Test 
 + public void testEverythingIsPurgeableASC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 2 ) ; 
 + 
 + assertTrue ( ! purged . hasNext ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testEverythingIsPurgeableDESC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( false 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 2 ) ; 
 + 
 + assertTrue ( ! purged . hasNext ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testFirstHalfIsPurgeableASC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + @ Test 
 + public void testFirstHalfIsPurgeableDESC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( true 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 0L , 0 , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 0L , 0 , " a " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( false 
 + , bound ( Kind . INCL _ END _ BOUND , 1L , 1 , " c " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " b " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + @ Test 
 + public void testSecondHalfIsPurgeableASC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 1L , 1 , 0L , 0 , " b " ) 
 + , bound ( Kind . INCL _ END _ BOUND , 0L , 0 , " c " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( false 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) 
 + , bound ( Kind . EXCL _ END _ BOUND , 1L , 1 , " b " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + @ Test 
 + public void testSecondHalfIsPurgeableDESC ( ) 
 + { 
 + UnfilteredPartitionIterator original = iter ( true 
 + , bound ( Kind . INCL _ END _ BOUND , 0L , 0 , " c " ) 
 + , boundary ( Kind . EXCL _ END _ INCL _ START _ BOUNDARY , 1L , 1 , 0L , 0 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) 
 + ) ; 
 + UnfilteredPartitionIterator purged = withoutPurgeableTombstones ( original , 1 ) ; 
 + 
 + UnfilteredPartitionIterator expected = iter ( true 
 + , bound ( Kind . EXCL _ END _ BOUND , 1L , 1 , " b " ) 
 + , bound ( Kind . INCL _ START _ BOUND , 1L , 1 , " a " ) 
 + ) ; 
 + assertIteratorsEqual ( expected , purged ) ; 
 + } 
 + 
 + private UnfilteredPartitionIterator iter ( boolean isReversedOrder , Unfiltered . . . unfiltereds ) 
 + { 
 + Iterator < Unfiltered > iterator = Iterators . forArray ( unfiltereds ) ; 
 + 
 + UnfilteredRowIterator rowIter = 
 + new AbstractUnfilteredRowIterator ( metadata , 
 + key , 
 + DeletionTime . LIVE , 
 + metadata . partitionColumns ( ) , 
 + Rows . EMPTY _ STATIC _ ROW , 
 + isReversedOrder , 
 + EncodingStats . NO _ STATS ) 
 + { 
 + protected Unfiltered computeNext ( ) 
 + { 
 + return iterator . hasNext ( ) ? iterator . next ( ) : endOfData ( ) ; 
 + } 
 + } ; 
 + 
 + return new SingletonUnfilteredPartitionIterator ( rowIter , false ) ; 
 + } 
 + 
 + private RangeTombstoneBoundMarker bound ( ClusteringPrefix . Kind kind , 
 + long timestamp , 
 + int localDeletionTime , 
 + Object clusteringValue ) 
 + { 
 + ByteBuffer [ ] clusteringByteBuffers = 
 + new ByteBuffer [ ] { decompose ( metadata . clusteringColumns ( ) . get ( 0 ) . type , clusteringValue ) } ; 
 + 
 + return new RangeTombstoneBoundMarker ( new RangeTombstone . Bound ( kind , clusteringByteBuffers ) , 
 + new DeletionTime ( timestamp , localDeletionTime ) ) ; 
 + } 
 + 
 + private RangeTombstoneBoundaryMarker boundary ( ClusteringPrefix . Kind kind , 
 + long closeTimestamp , 
 + int closeLocalDeletionTime , 
 + long openTimestamp , 
 + int openDeletionTime , 
 + Object clusteringValue ) 
 + { 
 + ByteBuffer [ ] clusteringByteBuffers = 
 + new ByteBuffer [ ] { decompose ( metadata . clusteringColumns ( ) . get ( 0 ) . type , clusteringValue ) } ; 
 + 
 + return new RangeTombstoneBoundaryMarker ( new RangeTombstone . Bound ( kind , clusteringByteBuffers ) , 
 + new DeletionTime ( closeTimestamp , closeLocalDeletionTime ) , 
 + new DeletionTime ( openTimestamp , openDeletionTime ) ) ; 
 + } 
 + 
 + @ SuppressWarnings ( " unchecked " ) 
 + private static < T > ByteBuffer decompose ( AbstractType < ? > type , T value ) 
 + { 
 + return ( ( AbstractType < T > ) type ) . decompose ( value ) ; 
 + } 
 + 
 + private void assertIteratorsEqual ( UnfilteredPartitionIterator iter1 , UnfilteredPartitionIterator iter2 ) 
 + { 
 + while ( iter1 . hasNext ( ) ) 
 + { 
 + assertTrue ( iter2 . hasNext ( ) ) ; 
 + 
 + try ( UnfilteredRowIterator partition1 = iter1 . next ( ) ) 
 + { 
 + try ( UnfilteredRowIterator partition2 = iter2 . next ( ) ) 
 + { 
 + assertIteratorsEqual ( partition1 , partition2 ) ; 
 + } 
 + } 
 + } 
 + 
 + assertTrue ( ! iter2 . hasNext ( ) ) ; 
 + } 
 + 
 + private void assertIteratorsEqual ( UnfilteredRowIterator iter1 , UnfilteredRowIterator iter2 ) 
 + { 
 + while ( iter1 . hasNext ( ) ) 
 + { 
 + assertTrue ( iter2 . hasNext ( ) ) ; 
 + 
 + assertEquals ( iter1 . next ( ) , iter2 . next ( ) ) ; 
 + } 
 + assertTrue ( ! iter2 . hasNext ( ) ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
