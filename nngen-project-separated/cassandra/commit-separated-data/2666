BLEU SCORE: 0.016932492841722675

TEST MSG: nodetool no longer shows node joining ( Also fix nodetool status )
GENERATED MSG: Fix accounting in FileCacheService to allow re - using RAR

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> index 75af915 . . 85afdc1 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java <nl> @ @ - 29 , 8 + 29 , 10 @ @ import java . util . Map . Entry ; <nl> import java . util . concurrent . ExecutionException ; <nl> <nl> import com . google . common . base . Joiner ; <nl> + import com . google . common . collect . ArrayListMultimap ; <nl> import com . google . common . collect . LinkedHashMultimap ; <nl> import com . google . common . collect . Maps ; <nl> + <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . commons . cli . * ; <nl> @ @ - 38 , 7 + 40 , 6 @ @ import org . yaml . snakeyaml . Loader ; <nl> import org . yaml . snakeyaml . TypeDescription ; <nl> import org . yaml . snakeyaml . Yaml ; <nl> import org . yaml . snakeyaml . constructor . Constructor ; <nl> - <nl> import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutorMBean ; <nl> import org . apache . cassandra . db . ColumnFamilyStoreMBean ; <nl> import org . apache . cassandra . db . Table ; <nl> @ @ - 268 , 16 + 269 , 7 @ @ public class NodeCmd <nl> try <nl> { <nl> outs . println ( ) ; <nl> - Map < String , Map < InetAddress , Float > > perDcOwnerships = Maps . newLinkedHashMap ( ) ; <nl> - / / get the different datasets and map to tokens <nl> - for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) <nl> - { <nl> - String dc = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; <nl> - if ( ! perDcOwnerships . containsKey ( dc ) ) <nl> - perDcOwnerships . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; <nl> - perDcOwnerships . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; <nl> - } <nl> - for ( Map . Entry < String , Map < InetAddress , Float > > entry : perDcOwnerships . entrySet ( ) ) <nl> + for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( false , tokensToEndpoints , ownerships ) . entrySet ( ) ) <nl> printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; <nl> } <nl> catch ( UnknownHostException e ) <nl> @ @ - 293 , 7 + 285 , 7 @ @ public class NodeCmd <nl> } <nl> <nl> private void printDc ( PrintStream outs , String format , String dc , LinkedHashMultimap < String , String > endpointsToTokens , <nl> - boolean keyspaceSelected , Map < InetAddress , Float > filteredOwnerships ) <nl> + boolean keyspaceSelected , SetHostStat hoststats ) <nl> { <nl> Collection < String > liveNodes = probe . getLiveNodes ( ) ; <nl> Collection < String > deadNodes = probe . getUnreachableNodes ( ) ; <nl> @ @ - 310 , 27 + 302 , 27 @ @ public class NodeCmd <nl> float totalReplicas = 0f ; <nl> String lastToken = " " ; <nl> <nl> - for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) <nl> + for ( HostStat stat : hoststats ) <nl> { <nl> - tokens . addAll ( endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ) ; <nl> + tokens . addAll ( endpointsToTokens . get ( stat . ip ) ) ; <nl> lastToken = tokens . get ( tokens . size ( ) - 1 ) ; <nl> - totalReplicas + = entry . getValue ( ) ; <nl> + if ( stat . owns ! = null ) <nl> + totalReplicas + = stat . owns ; <nl> } <nl> <nl> - <nl> if ( keyspaceSelected ) <nl> outs . print ( " Replicas : " + ( int ) totalReplicas + " \ n \ n " ) ; <nl> <nl> outs . printf ( format , " Address " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; <nl> <nl> - if ( filteredOwnerships . size ( ) > 1 ) <nl> + if ( hoststats . size ( ) > 1 ) <nl> outs . printf ( format , " " , " " , " " , " " , " " , " " , lastToken ) ; <nl> else <nl> outs . println ( ) ; <nl> <nl> - for ( Map . Entry < String , String > entry : endpointsToTokens . entries ( ) ) <nl> + for ( HostStat stat : hoststats ) <nl> { <nl> - String endpoint = entry . getKey ( ) ; <nl> + String endpoint = stat . ip ; <nl> String rack ; <nl> try <nl> { <nl> @ @ - 359 , 18 + 351 , 8 @ @ public class NodeCmd <nl> String load = loadMap . containsKey ( endpoint ) <nl> ? loadMap . get ( endpoint ) <nl> : " ? " ; <nl> - String owns ; <nl> - try <nl> - { <nl> - InetAddress ep = InetAddress . getByName ( endpoint ) ; <nl> - Float percent = filteredOwnerships . get ( ep ) ; <nl> - owns = ( percent ! = null ) ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( percent ) : " ? " ; <nl> - } <nl> - catch ( UnknownHostException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - outs . printf ( format , endpoint , rack , status , state , load , owns , entry . getValue ( ) ) ; <nl> + String owns = stat . owns ! = null ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( stat . owns ) : " ? " ; <nl> + outs . printf ( format , endpoint , rack , status , state , load , owns , stat . token ) ; <nl> } <nl> outs . println ( ) ; <nl> } <nl> @ @ - 407 , 63 + 389 , 6 @ @ public class NodeCmd <nl> outs . println ( " | / State = Normal / Leaving / Joining / Moving " ) ; <nl> } <nl> <nl> - class SetHostStat implements Iterable < HostStat > { <nl> - final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; <nl> - <nl> - public SetHostStat ( ) { } <nl> - <nl> - public SetHostStat ( Map < InetAddress , Float > ownerships ) { <nl> - for ( Map . Entry < InetAddress , Float > entry : ownerships . entrySet ( ) ) { <nl> - hostStats . add ( new HostStat ( entry ) ) ; <nl> - } <nl> - } <nl> - <nl> - @ Override <nl> - public Iterator < HostStat > iterator ( ) { <nl> - return hostStats . iterator ( ) ; <nl> - } <nl> - <nl> - public void add ( HostStat entry ) { <nl> - hostStats . add ( entry ) ; <nl> - } <nl> - } <nl> - <nl> - class HostStat { <nl> - public final String ip ; <nl> - public final String dns ; <nl> - public final Float owns ; <nl> - <nl> - public HostStat ( Map . Entry < InetAddress , Float > ownership ) { <nl> - this . ip = ownership . getKey ( ) . getHostAddress ( ) ; <nl> - this . dns = ownership . getKey ( ) . getHostName ( ) ; <nl> - this . owns = ownership . getValue ( ) ; <nl> - } <nl> - <nl> - public String ipOrDns ( ) { <nl> - if ( resolveIp ) { <nl> - return dns ; <nl> - } <nl> - return ip ; <nl> - } <nl> - } <nl> - <nl> - private Map < String , SetHostStat > getOwnershipByDc ( SetHostStat ownerships ) <nl> - throws UnknownHostException <nl> - { <nl> - Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; <nl> - EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; <nl> - <nl> - for ( HostStat ownership : ownerships ) <nl> - { <nl> - String dc = epSnitchInfo . getDatacenter ( ownership . ip ) ; <nl> - if ( ! ownershipByDc . containsKey ( dc ) ) <nl> - ownershipByDc . put ( dc , new SetHostStat ( ) ) ; <nl> - ownershipByDc . get ( dc ) . add ( ownership ) ; <nl> - } <nl> - <nl> - return ownershipByDc ; <nl> - } <nl> - <nl> private String getFormat ( boolean hasEffectiveOwns , boolean isTokenPerNode ) <nl> { <nl> if ( format = = null ) <nl> @ @ - 486 , 12 + 411 , 10 @ @ public class NodeCmd <nl> return format ; <nl> } <nl> <nl> - private void printNode ( HostStat hostStat , <nl> - boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException <nl> + private void printNode ( String endpoint , Float owns , List < String > tokens , boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException <nl> { <nl> String status , state , load , strOwns , hostID , rack , fmt ; <nl> fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; <nl> - String endpoint = hostStat . ip ; <nl> if ( liveNodes . contains ( endpoint ) ) status = " U " ; <nl> else if ( unreachableNodes . contains ( endpoint ) ) status = " D " ; <nl> else status = " ? " ; <nl> @ @ - 501 , 18 + 424 , 17 @ @ public class NodeCmd <nl> else state = " N " ; <nl> <nl> load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : " ? " ; <nl> - strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( hostStat . owns ) ; <nl> + strOwns = owns ! = null ? new DecimalFormat ( " # # 0 . 0 % " ) . format ( owns ) : " ? " ; <nl> hostID = hostIDMap . get ( endpoint ) ; <nl> rack = epSnitchInfo . getRack ( endpoint ) ; <nl> <nl> if ( isTokenPerNode ) <nl> { <nl> - outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; <nl> + outs . printf ( fmt , status , state , endpoint , load , strOwns , hostID , tokens . get ( 0 ) , rack ) ; <nl> } <nl> else <nl> { <nl> - int tokens = probe . getTokens ( endpoint ) . size ( ) ; <nl> - outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , tokens , strOwns , hostID , rack ) ; <nl> + outs . printf ( fmt , status , state , endpoint , load , tokens . size ( ) , strOwns , hostID , rack ) ; <nl> } <nl> } <nl> <nl> @ @ - 539 , 24 + 461 , 24 @ @ public class NodeCmd <nl> <nl> void print ( ) throws UnknownHostException <nl> { <nl> - SetHostStat ownerships ; <nl> + Map < InetAddress , Float > ownerships ; <nl> boolean hasEffectiveOwns = false , isTokenPerNode = true ; <nl> <nl> try <nl> { <nl> - ownerships = new SetHostStat ( probe . effectiveOwnership ( kSpace ) ) ; <nl> + ownerships = probe . effectiveOwnership ( kSpace ) ; <nl> hasEffectiveOwns = true ; <nl> } <nl> catch ( IllegalStateException e ) <nl> { <nl> - ownerships = new SetHostStat ( probe . getOwnership ( ) ) ; <nl> + ownerships = probe . getOwnership ( ) ; <nl> } <nl> <nl> / / More tokens then nodes ( aka vnodes ) ? <nl> - if ( new HashSet < String > ( tokensToEndpoints . values ( ) ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) <nl> + if ( tokensToEndpoints . values ( ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) <nl> isTokenPerNode = false ; <nl> <nl> - Map < String , SetHostStat > dcs = getOwnershipByDc ( ownerships ) ; <nl> + Map < String , SetHostStat > dcs = getOwnershipByDc ( resolveIp , tokensToEndpoints , ownerships ) ; <nl> <nl> findMaxAddressLength ( dcs ) ; <nl> <nl> @ @ - 571 , 13 + 493 , 84 @ @ public class NodeCmd <nl> printStatusLegend ( ) ; <nl> printNodesHeader ( hasEffectiveOwns , isTokenPerNode ) ; <nl> <nl> + ArrayListMultimap < String , String > hostToTokens = ArrayListMultimap . create ( ) ; <nl> + for ( HostStat stat : dc . getValue ( ) ) <nl> + hostToTokens . put ( stat . ipOrDns ( ) , stat . token ) ; <nl> + <nl> / / Nodes <nl> - for ( HostStat entry : dc . getValue ( ) ) <nl> - printNode ( entry , hasEffectiveOwns , isTokenPerNode ) ; <nl> + for ( String endpoint : hostToTokens . keySet ( ) ) <nl> + { <nl> + Float owns = ownerships . get ( InetAddress . getByName ( endpoint ) ) ; <nl> + List < String > tokens = hostToTokens . get ( endpoint ) ; <nl> + printNode ( endpoint , owns , tokens , hasEffectiveOwns , isTokenPerNode ) ; <nl> + } <nl> } <nl> } <nl> } <nl> <nl> + private Map < String , SetHostStat > getOwnershipByDc ( boolean resolveIp , Map < String , String > tokenToEndpoint , <nl> + Map < InetAddress , Float > ownerships ) throws UnknownHostException <nl> + { <nl> + Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; <nl> + EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; <nl> + <nl> + for ( Entry < String , String > tokenAndEndPoint : tokenToEndpoint . entrySet ( ) ) <nl> + { <nl> + String dc = epSnitchInfo . getDatacenter ( tokenAndEndPoint . getValue ( ) ) ; <nl> + if ( ! ownershipByDc . containsKey ( dc ) ) <nl> + ownershipByDc . put ( dc , new SetHostStat ( resolveIp ) ) ; <nl> + ownershipByDc . get ( dc ) . add ( tokenAndEndPoint . getKey ( ) , tokenAndEndPoint . getValue ( ) , ownerships ) ; <nl> + } <nl> + <nl> + return ownershipByDc ; <nl> + } <nl> + <nl> + static class SetHostStat implements Iterable < HostStat > { <nl> + final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; <nl> + final boolean resolveIp ; <nl> + <nl> + public SetHostStat ( boolean resolveIp ) <nl> + { <nl> + this . resolveIp = resolveIp ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return hostStats . size ( ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public Iterator < HostStat > iterator ( ) { <nl> + return hostStats . iterator ( ) ; <nl> + } <nl> + <nl> + public void add ( String token , String host , Map < InetAddress , Float > ownerships ) throws UnknownHostException { <nl> + InetAddress endpoint = InetAddress . getByName ( host ) ; <nl> + Float owns = ownerships . get ( endpoint ) ; <nl> + hostStats . add ( new HostStat ( token , endpoint , resolveIp , owns ) ) ; <nl> + } <nl> + } <nl> + <nl> + static class HostStat { <nl> + public final String ip ; <nl> + public final String dns ; <nl> + public final Float owns ; <nl> + public final String token ; <nl> + <nl> + public HostStat ( String token , InetAddress endPoint , boolean resolveIp , Float owns ) <nl> + { <nl> + this . token = token ; <nl> + this . ip = endPoint . getHostAddress ( ) ; <nl> + this . dns = resolveIp ? endPoint . getHostName ( ) : null ; <nl> + this . owns = owns ; <nl> + } <nl> + <nl> + public String ipOrDns ( ) <nl> + { <nl> + return ( dns ! = null ) ? dns : ip ; <nl> + } <nl> + } <nl> + <nl> / * * Writes a table of cluster - wide node information to a PrintStream <nl> * @ throws UnknownHostException * / <nl> public void printClusterStatus ( PrintStream outs , String keyspace , boolean resolveIp ) throws UnknownHostException
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / tools / NodeCmd . java b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 index 75af915 . . 85afdc1 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeCmd . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeCmd . java 
 @ @ - 29 , 8 + 29 , 10 @ @ import java . util . Map . Entry ; 
 import java . util . concurrent . ExecutionException ; 
 
 import com . google . common . base . Joiner ; 
 + import com . google . common . collect . ArrayListMultimap ; 
 import com . google . common . collect . LinkedHashMultimap ; 
 import com . google . common . collect . Maps ; 
 + 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . commons . cli . * ; 
 @ @ - 38 , 7 + 40 , 6 @ @ import org . yaml . snakeyaml . Loader ; 
 import org . yaml . snakeyaml . TypeDescription ; 
 import org . yaml . snakeyaml . Yaml ; 
 import org . yaml . snakeyaml . constructor . Constructor ; 
 - 
 import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutorMBean ; 
 import org . apache . cassandra . db . ColumnFamilyStoreMBean ; 
 import org . apache . cassandra . db . Table ; 
 @ @ - 268 , 16 + 269 , 7 @ @ public class NodeCmd 
 try 
 { 
 outs . println ( ) ; 
 - Map < String , Map < InetAddress , Float > > perDcOwnerships = Maps . newLinkedHashMap ( ) ; 
 - / / get the different datasets and map to tokens 
 - for ( Map . Entry < InetAddress , Float > ownership : ownerships . entrySet ( ) ) 
 - { 
 - String dc = probe . getEndpointSnitchInfoProxy ( ) . getDatacenter ( ownership . getKey ( ) . getHostAddress ( ) ) ; 
 - if ( ! perDcOwnerships . containsKey ( dc ) ) 
 - perDcOwnerships . put ( dc , new LinkedHashMap < InetAddress , Float > ( ) ) ; 
 - perDcOwnerships . get ( dc ) . put ( ownership . getKey ( ) , ownership . getValue ( ) ) ; 
 - } 
 - for ( Map . Entry < String , Map < InetAddress , Float > > entry : perDcOwnerships . entrySet ( ) ) 
 + for ( Entry < String , SetHostStat > entry : getOwnershipByDc ( false , tokensToEndpoints , ownerships ) . entrySet ( ) ) 
 printDc ( outs , format , entry . getKey ( ) , endpointsToTokens , keyspaceSelected , entry . getValue ( ) ) ; 
 } 
 catch ( UnknownHostException e ) 
 @ @ - 293 , 7 + 285 , 7 @ @ public class NodeCmd 
 } 
 
 private void printDc ( PrintStream outs , String format , String dc , LinkedHashMultimap < String , String > endpointsToTokens , 
 - boolean keyspaceSelected , Map < InetAddress , Float > filteredOwnerships ) 
 + boolean keyspaceSelected , SetHostStat hoststats ) 
 { 
 Collection < String > liveNodes = probe . getLiveNodes ( ) ; 
 Collection < String > deadNodes = probe . getUnreachableNodes ( ) ; 
 @ @ - 310 , 27 + 302 , 27 @ @ public class NodeCmd 
 float totalReplicas = 0f ; 
 String lastToken = " " ; 
 
 - for ( Map . Entry < InetAddress , Float > entry : filteredOwnerships . entrySet ( ) ) 
 + for ( HostStat stat : hoststats ) 
 { 
 - tokens . addAll ( endpointsToTokens . get ( entry . getKey ( ) . getHostAddress ( ) ) ) ; 
 + tokens . addAll ( endpointsToTokens . get ( stat . ip ) ) ; 
 lastToken = tokens . get ( tokens . size ( ) - 1 ) ; 
 - totalReplicas + = entry . getValue ( ) ; 
 + if ( stat . owns ! = null ) 
 + totalReplicas + = stat . owns ; 
 } 
 
 - 
 if ( keyspaceSelected ) 
 outs . print ( " Replicas : " + ( int ) totalReplicas + " \ n \ n " ) ; 
 
 outs . printf ( format , " Address " , " Rack " , " Status " , " State " , " Load " , " Owns " , " Token " ) ; 
 
 - if ( filteredOwnerships . size ( ) > 1 ) 
 + if ( hoststats . size ( ) > 1 ) 
 outs . printf ( format , " " , " " , " " , " " , " " , " " , lastToken ) ; 
 else 
 outs . println ( ) ; 
 
 - for ( Map . Entry < String , String > entry : endpointsToTokens . entries ( ) ) 
 + for ( HostStat stat : hoststats ) 
 { 
 - String endpoint = entry . getKey ( ) ; 
 + String endpoint = stat . ip ; 
 String rack ; 
 try 
 { 
 @ @ - 359 , 18 + 351 , 8 @ @ public class NodeCmd 
 String load = loadMap . containsKey ( endpoint ) 
 ? loadMap . get ( endpoint ) 
 : " ? " ; 
 - String owns ; 
 - try 
 - { 
 - InetAddress ep = InetAddress . getByName ( endpoint ) ; 
 - Float percent = filteredOwnerships . get ( ep ) ; 
 - owns = ( percent ! = null ) ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( percent ) : " ? " ; 
 - } 
 - catch ( UnknownHostException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - outs . printf ( format , endpoint , rack , status , state , load , owns , entry . getValue ( ) ) ; 
 + String owns = stat . owns ! = null ? new DecimalFormat ( " # # 0 . 00 % " ) . format ( stat . owns ) : " ? " ; 
 + outs . printf ( format , endpoint , rack , status , state , load , owns , stat . token ) ; 
 } 
 outs . println ( ) ; 
 } 
 @ @ - 407 , 63 + 389 , 6 @ @ public class NodeCmd 
 outs . println ( " | / State = Normal / Leaving / Joining / Moving " ) ; 
 } 
 
 - class SetHostStat implements Iterable < HostStat > { 
 - final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; 
 - 
 - public SetHostStat ( ) { } 
 - 
 - public SetHostStat ( Map < InetAddress , Float > ownerships ) { 
 - for ( Map . Entry < InetAddress , Float > entry : ownerships . entrySet ( ) ) { 
 - hostStats . add ( new HostStat ( entry ) ) ; 
 - } 
 - } 
 - 
 - @ Override 
 - public Iterator < HostStat > iterator ( ) { 
 - return hostStats . iterator ( ) ; 
 - } 
 - 
 - public void add ( HostStat entry ) { 
 - hostStats . add ( entry ) ; 
 - } 
 - } 
 - 
 - class HostStat { 
 - public final String ip ; 
 - public final String dns ; 
 - public final Float owns ; 
 - 
 - public HostStat ( Map . Entry < InetAddress , Float > ownership ) { 
 - this . ip = ownership . getKey ( ) . getHostAddress ( ) ; 
 - this . dns = ownership . getKey ( ) . getHostName ( ) ; 
 - this . owns = ownership . getValue ( ) ; 
 - } 
 - 
 - public String ipOrDns ( ) { 
 - if ( resolveIp ) { 
 - return dns ; 
 - } 
 - return ip ; 
 - } 
 - } 
 - 
 - private Map < String , SetHostStat > getOwnershipByDc ( SetHostStat ownerships ) 
 - throws UnknownHostException 
 - { 
 - Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; 
 - EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; 
 - 
 - for ( HostStat ownership : ownerships ) 
 - { 
 - String dc = epSnitchInfo . getDatacenter ( ownership . ip ) ; 
 - if ( ! ownershipByDc . containsKey ( dc ) ) 
 - ownershipByDc . put ( dc , new SetHostStat ( ) ) ; 
 - ownershipByDc . get ( dc ) . add ( ownership ) ; 
 - } 
 - 
 - return ownershipByDc ; 
 - } 
 - 
 private String getFormat ( boolean hasEffectiveOwns , boolean isTokenPerNode ) 
 { 
 if ( format = = null ) 
 @ @ - 486 , 12 + 411 , 10 @ @ public class NodeCmd 
 return format ; 
 } 
 
 - private void printNode ( HostStat hostStat , 
 - boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException 
 + private void printNode ( String endpoint , Float owns , List < String > tokens , boolean hasEffectiveOwns , boolean isTokenPerNode ) throws UnknownHostException 
 { 
 String status , state , load , strOwns , hostID , rack , fmt ; 
 fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; 
 - String endpoint = hostStat . ip ; 
 if ( liveNodes . contains ( endpoint ) ) status = " U " ; 
 else if ( unreachableNodes . contains ( endpoint ) ) status = " D " ; 
 else status = " ? " ; 
 @ @ - 501 , 18 + 424 , 17 @ @ public class NodeCmd 
 else state = " N " ; 
 
 load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : " ? " ; 
 - strOwns = new DecimalFormat ( " # # 0 . 0 % " ) . format ( hostStat . owns ) ; 
 + strOwns = owns ! = null ? new DecimalFormat ( " # # 0 . 0 % " ) . format ( owns ) : " ? " ; 
 hostID = hostIDMap . get ( endpoint ) ; 
 rack = epSnitchInfo . getRack ( endpoint ) ; 
 
 if ( isTokenPerNode ) 
 { 
 - outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , strOwns , hostID , probe . getTokens ( endpoint ) . get ( 0 ) , rack ) ; 
 + outs . printf ( fmt , status , state , endpoint , load , strOwns , hostID , tokens . get ( 0 ) , rack ) ; 
 } 
 else 
 { 
 - int tokens = probe . getTokens ( endpoint ) . size ( ) ; 
 - outs . printf ( fmt , status , state , hostStat . ipOrDns ( ) , load , tokens , strOwns , hostID , rack ) ; 
 + outs . printf ( fmt , status , state , endpoint , load , tokens . size ( ) , strOwns , hostID , rack ) ; 
 } 
 } 
 
 @ @ - 539 , 24 + 461 , 24 @ @ public class NodeCmd 
 
 void print ( ) throws UnknownHostException 
 { 
 - SetHostStat ownerships ; 
 + Map < InetAddress , Float > ownerships ; 
 boolean hasEffectiveOwns = false , isTokenPerNode = true ; 
 
 try 
 { 
 - ownerships = new SetHostStat ( probe . effectiveOwnership ( kSpace ) ) ; 
 + ownerships = probe . effectiveOwnership ( kSpace ) ; 
 hasEffectiveOwns = true ; 
 } 
 catch ( IllegalStateException e ) 
 { 
 - ownerships = new SetHostStat ( probe . getOwnership ( ) ) ; 
 + ownerships = probe . getOwnership ( ) ; 
 } 
 
 / / More tokens then nodes ( aka vnodes ) ? 
 - if ( new HashSet < String > ( tokensToEndpoints . values ( ) ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) 
 + if ( tokensToEndpoints . values ( ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) 
 isTokenPerNode = false ; 
 
 - Map < String , SetHostStat > dcs = getOwnershipByDc ( ownerships ) ; 
 + Map < String , SetHostStat > dcs = getOwnershipByDc ( resolveIp , tokensToEndpoints , ownerships ) ; 
 
 findMaxAddressLength ( dcs ) ; 
 
 @ @ - 571 , 13 + 493 , 84 @ @ public class NodeCmd 
 printStatusLegend ( ) ; 
 printNodesHeader ( hasEffectiveOwns , isTokenPerNode ) ; 
 
 + ArrayListMultimap < String , String > hostToTokens = ArrayListMultimap . create ( ) ; 
 + for ( HostStat stat : dc . getValue ( ) ) 
 + hostToTokens . put ( stat . ipOrDns ( ) , stat . token ) ; 
 + 
 / / Nodes 
 - for ( HostStat entry : dc . getValue ( ) ) 
 - printNode ( entry , hasEffectiveOwns , isTokenPerNode ) ; 
 + for ( String endpoint : hostToTokens . keySet ( ) ) 
 + { 
 + Float owns = ownerships . get ( InetAddress . getByName ( endpoint ) ) ; 
 + List < String > tokens = hostToTokens . get ( endpoint ) ; 
 + printNode ( endpoint , owns , tokens , hasEffectiveOwns , isTokenPerNode ) ; 
 + } 
 } 
 } 
 } 
 
 + private Map < String , SetHostStat > getOwnershipByDc ( boolean resolveIp , Map < String , String > tokenToEndpoint , 
 + Map < InetAddress , Float > ownerships ) throws UnknownHostException 
 + { 
 + Map < String , SetHostStat > ownershipByDc = Maps . newLinkedHashMap ( ) ; 
 + EndpointSnitchInfoMBean epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; 
 + 
 + for ( Entry < String , String > tokenAndEndPoint : tokenToEndpoint . entrySet ( ) ) 
 + { 
 + String dc = epSnitchInfo . getDatacenter ( tokenAndEndPoint . getValue ( ) ) ; 
 + if ( ! ownershipByDc . containsKey ( dc ) ) 
 + ownershipByDc . put ( dc , new SetHostStat ( resolveIp ) ) ; 
 + ownershipByDc . get ( dc ) . add ( tokenAndEndPoint . getKey ( ) , tokenAndEndPoint . getValue ( ) , ownerships ) ; 
 + } 
 + 
 + return ownershipByDc ; 
 + } 
 + 
 + static class SetHostStat implements Iterable < HostStat > { 
 + final List < HostStat > hostStats = new ArrayList < HostStat > ( ) ; 
 + final boolean resolveIp ; 
 + 
 + public SetHostStat ( boolean resolveIp ) 
 + { 
 + this . resolveIp = resolveIp ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return hostStats . size ( ) ; 
 + } 
 + 
 + @ Override 
 + public Iterator < HostStat > iterator ( ) { 
 + return hostStats . iterator ( ) ; 
 + } 
 + 
 + public void add ( String token , String host , Map < InetAddress , Float > ownerships ) throws UnknownHostException { 
 + InetAddress endpoint = InetAddress . getByName ( host ) ; 
 + Float owns = ownerships . get ( endpoint ) ; 
 + hostStats . add ( new HostStat ( token , endpoint , resolveIp , owns ) ) ; 
 + } 
 + } 
 + 
 + static class HostStat { 
 + public final String ip ; 
 + public final String dns ; 
 + public final Float owns ; 
 + public final String token ; 
 + 
 + public HostStat ( String token , InetAddress endPoint , boolean resolveIp , Float owns ) 
 + { 
 + this . token = token ; 
 + this . ip = endPoint . getHostAddress ( ) ; 
 + this . dns = resolveIp ? endPoint . getHostName ( ) : null ; 
 + this . owns = owns ; 
 + } 
 + 
 + public String ipOrDns ( ) 
 + { 
 + return ( dns ! = null ) ? dns : ip ; 
 + } 
 + } 
 + 
 / * * Writes a table of cluster - wide node information to a PrintStream 
 * @ throws UnknownHostException * / 
 public void printClusterStatus ( PrintStream outs , String keyspace , boolean resolveIp ) throws UnknownHostException

NEAREST DIFF:
ELIMINATEDSENTENCE
