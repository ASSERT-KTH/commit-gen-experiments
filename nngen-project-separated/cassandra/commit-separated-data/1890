BLEU SCORE: 1.0

TEST MSG: fix ArrayIndexOutOfBoundsException in nodetool cfhistograms
GENERATED MSG: fix ArrayIndexOutOfBoundsException in nodetool cfhistograms

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index cdcb5cc . . 5bfb29c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Fix ArrayIndexOutOfBoundsException in nodetool cfhistograms ( CASSANDRA - 8514 ) <nl> * Serializing Row cache alternative , fully off heap ( CASSANDRA - 7438 ) <nl> * Duplicate rows returned when in clause has repeated values ( CASSANDRA - 6707 ) <nl> * Make CassandraException unchecked , extend RuntimeException ( CASSANDRA - 8560 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeTool . java b / src / java / org / apache / cassandra / tools / NodeTool . java <nl> index 24772d7 . . b67dff9 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeTool . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeTool . java <nl> @ @ - 31 , 7 + 31 , 9 @ @ import javax . management . openmbean . * ; <nl> <nl> import com . google . common . base . Joiner ; <nl> import com . google . common . base . Throwables ; <nl> + <nl> import com . google . common . collect . * ; <nl> + <nl> import com . yammer . metrics . reporting . JmxReporter ; <nl> <nl> import io . airlift . command . * ; <nl> @ @ - 44 , 7 + 46 , 9 @ @ import org . apache . cassandra . db . compaction . CompactionManagerMBean ; <nl> import org . apache . cassandra . db . compaction . OperationType ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; <nl> + <nl> import org . apache . cassandra . metrics . ColumnFamilyMetrics . Sampler ; <nl> + <nl> import org . apache . cassandra . net . MessagingServiceMBean ; <nl> import org . apache . cassandra . repair . messages . RepairOption ; <nl> import org . apache . cassandra . repair . RepairParallelism ; <nl> @ @ - 64 , 6 + 68 , 7 @ @ import static com . google . common . collect . Lists . newArrayList ; <nl> import static java . lang . Integer . parseInt ; <nl> import static java . lang . String . format ; <nl> import static org . apache . commons . lang3 . ArrayUtils . EMPTY _ STRING _ ARRAY ; <nl> + import static org . apache . commons . lang3 . ArrayUtils . isEmpty ; <nl> import static org . apache . commons . lang3 . StringUtils . * ; <nl> <nl> public class NodeTool <nl> @ @ - 1023 , 46 + 1028 , 59 @ @ public class NodeTool <nl> long [ ] estimatedRowSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , cfname , " EstimatedRowSizeHistogram " ) ; <nl> long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , cfname , " EstimatedColumnCountHistogram " ) ; <nl> <nl> - long [ ] rowSizeBucketOffsets = new EstimatedHistogram ( estimatedRowSize . length ) . getBucketOffsets ( ) ; <nl> - long [ ] columnCountBucketOffsets = new EstimatedHistogram ( estimatedColumnCount . length ) . getBucketOffsets ( ) ; <nl> - EstimatedHistogram rowSizeHist = new EstimatedHistogram ( rowSizeBucketOffsets , estimatedRowSize ) ; <nl> - EstimatedHistogram columnCountHist = new EstimatedHistogram ( columnCountBucketOffsets , estimatedColumnCount ) ; <nl> - <nl> / / build arrays to store percentile values <nl> double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; <nl> double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; <nl> double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; <nl> <nl> - if ( rowSizeHist . isOverflowed ( ) ) <nl> + if ( isEmpty ( estimatedRowSize ) | | isEmpty ( estimatedColumnCount ) ) <nl> { <nl> - System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , rowSizeBucketOffsets [ rowSizeBucketOffsets . length - 1 ] ) ) ; <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> - estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> - estimatedRowSizePercentiles [ i ] = rowSizeHist . percentile ( offsetPercentiles [ i ] ) ; <nl> - } <nl> + System . err . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; <nl> <nl> - if ( columnCountHist . isOverflowed ( ) ) <nl> - { <nl> - System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountBucketOffsets [ columnCountBucketOffsets . length - 1 ] ) ) ; <nl> - for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) <nl> + for ( int i = 0 ; i < 7 ; i + + ) <nl> + { <nl> + estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> + } <nl> } <nl> else <nl> { <nl> - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> - estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; <nl> - } <nl> + long [ ] rowSizeBucketOffsets = new EstimatedHistogram ( estimatedRowSize . length ) . getBucketOffsets ( ) ; <nl> + long [ ] columnCountBucketOffsets = new EstimatedHistogram ( estimatedColumnCount . length ) . getBucketOffsets ( ) ; <nl> + EstimatedHistogram rowSizeHist = new EstimatedHistogram ( rowSizeBucketOffsets , estimatedRowSize ) ; <nl> + EstimatedHistogram columnCountHist = new EstimatedHistogram ( columnCountBucketOffsets , estimatedColumnCount ) ; <nl> <nl> - / / min value <nl> - estimatedRowSizePercentiles [ 5 ] = rowSizeHist . min ( ) ; <nl> - estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; <nl> - / / max value <nl> - estimatedRowSizePercentiles [ 6 ] = rowSizeHist . max ( ) ; <nl> - estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; <nl> + if ( rowSizeHist . isOverflowed ( ) ) <nl> + { <nl> + System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , rowSizeBucketOffsets [ rowSizeBucketOffsets . length - 1 ] ) ) ; <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedRowSizePercentiles [ i ] = Double . NaN ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedRowSizePercentiles [ i ] = rowSizeHist . percentile ( offsetPercentiles [ i ] ) ; <nl> + } <nl> + <nl> + if ( columnCountHist . isOverflowed ( ) ) <nl> + { <nl> + System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountBucketOffsets [ columnCountBucketOffsets . length - 1 ] ) ) ; <nl> + for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) <nl> + estimatedColumnCountPercentiles [ i ] = Double . NaN ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) <nl> + estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; <nl> + } <nl> + <nl> + / / min value <nl> + estimatedRowSizePercentiles [ 5 ] = rowSizeHist . min ( ) ; <nl> + estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; <nl> + / / max value <nl> + estimatedRowSizePercentiles [ 6 ] = rowSizeHist . max ( ) ; <nl> + estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; <nl> + } <nl> <nl> String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; <nl> double [ ] readLatency = probe . metricPercentilesAsArray ( ( JmxReporter . HistogramMBean ) probe . getColumnFamilyMetric ( keyspace , cfname , " ReadLatency " ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index cdcb5cc . . 5bfb29c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Fix ArrayIndexOutOfBoundsException in nodetool cfhistograms ( CASSANDRA - 8514 ) 
 * Serializing Row cache alternative , fully off heap ( CASSANDRA - 7438 ) 
 * Duplicate rows returned when in clause has repeated values ( CASSANDRA - 6707 ) 
 * Make CassandraException unchecked , extend RuntimeException ( CASSANDRA - 8560 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeTool . java b / src / java / org / apache / cassandra / tools / NodeTool . java 
 index 24772d7 . . b67dff9 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeTool . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeTool . java 
 @ @ - 31 , 7 + 31 , 9 @ @ import javax . management . openmbean . * ; 
 
 import com . google . common . base . Joiner ; 
 import com . google . common . base . Throwables ; 
 + 
 import com . google . common . collect . * ; 
 + 
 import com . yammer . metrics . reporting . JmxReporter ; 
 
 import io . airlift . command . * ; 
 @ @ - 44 , 7 + 46 , 9 @ @ import org . apache . cassandra . db . compaction . CompactionManagerMBean ; 
 import org . apache . cassandra . db . compaction . OperationType ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; 
 + 
 import org . apache . cassandra . metrics . ColumnFamilyMetrics . Sampler ; 
 + 
 import org . apache . cassandra . net . MessagingServiceMBean ; 
 import org . apache . cassandra . repair . messages . RepairOption ; 
 import org . apache . cassandra . repair . RepairParallelism ; 
 @ @ - 64 , 6 + 68 , 7 @ @ import static com . google . common . collect . Lists . newArrayList ; 
 import static java . lang . Integer . parseInt ; 
 import static java . lang . String . format ; 
 import static org . apache . commons . lang3 . ArrayUtils . EMPTY _ STRING _ ARRAY ; 
 + import static org . apache . commons . lang3 . ArrayUtils . isEmpty ; 
 import static org . apache . commons . lang3 . StringUtils . * ; 
 
 public class NodeTool 
 @ @ - 1023 , 46 + 1028 , 59 @ @ public class NodeTool 
 long [ ] estimatedRowSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , cfname , " EstimatedRowSizeHistogram " ) ; 
 long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , cfname , " EstimatedColumnCountHistogram " ) ; 
 
 - long [ ] rowSizeBucketOffsets = new EstimatedHistogram ( estimatedRowSize . length ) . getBucketOffsets ( ) ; 
 - long [ ] columnCountBucketOffsets = new EstimatedHistogram ( estimatedColumnCount . length ) . getBucketOffsets ( ) ; 
 - EstimatedHistogram rowSizeHist = new EstimatedHistogram ( rowSizeBucketOffsets , estimatedRowSize ) ; 
 - EstimatedHistogram columnCountHist = new EstimatedHistogram ( columnCountBucketOffsets , estimatedColumnCount ) ; 
 - 
 / / build arrays to store percentile values 
 double [ ] estimatedRowSizePercentiles = new double [ 7 ] ; 
 double [ ] estimatedColumnCountPercentiles = new double [ 7 ] ; 
 double [ ] offsetPercentiles = new double [ ] { 0 . 5 , 0 . 75 , 0 . 95 , 0 . 98 , 0 . 99 } ; 
 
 - if ( rowSizeHist . isOverflowed ( ) ) 
 + if ( isEmpty ( estimatedRowSize ) | | isEmpty ( estimatedColumnCount ) ) 
 { 
 - System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , rowSizeBucketOffsets [ rowSizeBucketOffsets . length - 1 ] ) ) ; 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 - estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 - estimatedRowSizePercentiles [ i ] = rowSizeHist . percentile ( offsetPercentiles [ i ] ) ; 
 - } 
 + System . err . println ( " No SSTables exists , unable to calculate ' Partition Size ' and ' Cell Count ' percentiles " ) ; 
 
 - if ( columnCountHist . isOverflowed ( ) ) 
 - { 
 - System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountBucketOffsets [ columnCountBucketOffsets . length - 1 ] ) ) ; 
 - for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) 
 + for ( int i = 0 ; i < 7 ; i + + ) 
 + { 
 + estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 + } 
 } 
 else 
 { 
 - for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 - estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; 
 - } 
 + long [ ] rowSizeBucketOffsets = new EstimatedHistogram ( estimatedRowSize . length ) . getBucketOffsets ( ) ; 
 + long [ ] columnCountBucketOffsets = new EstimatedHistogram ( estimatedColumnCount . length ) . getBucketOffsets ( ) ; 
 + EstimatedHistogram rowSizeHist = new EstimatedHistogram ( rowSizeBucketOffsets , estimatedRowSize ) ; 
 + EstimatedHistogram columnCountHist = new EstimatedHistogram ( columnCountBucketOffsets , estimatedColumnCount ) ; 
 
 - / / min value 
 - estimatedRowSizePercentiles [ 5 ] = rowSizeHist . min ( ) ; 
 - estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; 
 - / / max value 
 - estimatedRowSizePercentiles [ 6 ] = rowSizeHist . max ( ) ; 
 - estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; 
 + if ( rowSizeHist . isOverflowed ( ) ) 
 + { 
 + System . err . println ( String . format ( " Row sizes are larger than % s , unable to calculate percentiles " , rowSizeBucketOffsets [ rowSizeBucketOffsets . length - 1 ] ) ) ; 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedRowSizePercentiles [ i ] = Double . NaN ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedRowSizePercentiles [ i ] = rowSizeHist . percentile ( offsetPercentiles [ i ] ) ; 
 + } 
 + 
 + if ( columnCountHist . isOverflowed ( ) ) 
 + { 
 + System . err . println ( String . format ( " Column counts are larger than % s , unable to calculate percentiles " , columnCountBucketOffsets [ columnCountBucketOffsets . length - 1 ] ) ) ; 
 + for ( int i = 0 ; i < estimatedColumnCountPercentiles . length ; i + + ) 
 + estimatedColumnCountPercentiles [ i ] = Double . NaN ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 ; i < offsetPercentiles . length ; i + + ) 
 + estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; 
 + } 
 + 
 + / / min value 
 + estimatedRowSizePercentiles [ 5 ] = rowSizeHist . min ( ) ; 
 + estimatedColumnCountPercentiles [ 5 ] = columnCountHist . min ( ) ; 
 + / / max value 
 + estimatedRowSizePercentiles [ 6 ] = rowSizeHist . max ( ) ; 
 + estimatedColumnCountPercentiles [ 6 ] = columnCountHist . max ( ) ; 
 + } 
 
 String [ ] percentiles = new String [ ] { " 50 % " , " 75 % " , " 95 % " , " 98 % " , " 99 % " , " Min " , " Max " } ; 
 double [ ] readLatency = probe . metricPercentilesAsArray ( ( JmxReporter . HistogramMBean ) probe . getColumnFamilyMetric ( keyspace , cfname , " ReadLatency " ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
