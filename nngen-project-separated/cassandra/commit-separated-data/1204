BLEU SCORE: 0.016604670898042337

TEST MSG: Fix MV replica filtering for non - NetworkTopologyStrategy
GENERATED MSG: update javadoc for snitch and strategy classes . patch by jhanna ; reviewed by jbellis for CASSANDRA - 1055

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b469594 . . ce24c2b 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 <nl> + * Fix MV replica filtering for non - NetworkTopologyStrategy ( CASSANDRA - 10634 ) <nl> * ( Hadoop ) fix CIF describeSplits ( ) not handling 0 size estimates ( CASSANDRA - 10600 ) <nl> * Fix reading of legacy sstables ( CASSANDRA - 10590 ) <nl> * Use CQL type names in schema metadata tables ( CASSANDRA - 10365 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / view / ViewUtils . java b / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> index ebbae65 . . 089a3b7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> + + + b / src / java / org / apache / cassandra / db / view / ViewUtils . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> + import org . apache . cassandra . locator . NetworkTopologyStrategy ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> @ @ - 38 , 9 + 39 , 10 @ @ public final class ViewUtils <nl> / * * <nl> * Calculate the natural endpoint for the view . <nl> * <nl> - * The view natural endpoint is the endpint which has the same cardinality as this node in the replication factor . <nl> + * The view natural endpoint is the endpoint which has the same cardinality as this node in the replication factor . <nl> * The cardinality is the number at which this node would store a piece of data , given the change in replication <nl> - * factor . <nl> + * factor . If the keyspace ' s replication strategy is a NetworkTopologyStrategy , we filter the ring to contain only <nl> + * nodes in the local datacenter when calculating cardinality . <nl> * <nl> * For example , if we have the following ring : <nl> * A , T1 - > B , T2 - > C , T3 - > A <nl> @ @ - 61 , 12 + 63 , 14 @ @ public final class ViewUtils <nl> AbstractReplicationStrategy replicationStrategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; <nl> <nl> String localDataCenter = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> - List < InetAddress > localBaseEndpoints = new ArrayList < > ( ) ; <nl> - List < InetAddress > localViewEndpoints = new ArrayList < > ( ) ; <nl> + List < InetAddress > baseEndpoints = new ArrayList < > ( ) ; <nl> + List < InetAddress > viewEndpoints = new ArrayList < > ( ) ; <nl> for ( InetAddress baseEndpoint : replicationStrategy . getNaturalEndpoints ( baseToken ) ) <nl> { <nl> - if ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( baseEndpoint ) . equals ( localDataCenter ) ) <nl> - localBaseEndpoints . add ( baseEndpoint ) ; <nl> + / / An endpoint is local if we ' re not using Net <nl> + if ( ! ( replicationStrategy instanceof NetworkTopologyStrategy ) | | <nl> + DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( baseEndpoint ) . equals ( localDataCenter ) ) <nl> + baseEndpoints . add ( baseEndpoint ) ; <nl> } <nl> <nl> for ( InetAddress viewEndpoint : replicationStrategy . getNaturalEndpoints ( viewToken ) ) <nl> @ @ - 77 , 17 + 81 , 18 @ @ public final class ViewUtils <nl> <nl> / / We have to remove any endpoint which is shared between the base and the view , as it will select itself <nl> / / and throw off the counts otherwise . <nl> - if ( localBaseEndpoints . contains ( viewEndpoint ) ) <nl> - localBaseEndpoints . remove ( viewEndpoint ) ; <nl> - else if ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( viewEndpoint ) . equals ( localDataCenter ) ) <nl> - localViewEndpoints . add ( viewEndpoint ) ; <nl> + if ( baseEndpoints . contains ( viewEndpoint ) ) <nl> + baseEndpoints . remove ( viewEndpoint ) ; <nl> + else if ( ! ( replicationStrategy instanceof NetworkTopologyStrategy ) | | <nl> + DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( viewEndpoint ) . equals ( localDataCenter ) ) <nl> + viewEndpoints . add ( viewEndpoint ) ; <nl> } <nl> <nl> / / The replication strategy will be the same for the base and the view , as they must belong to the same keyspace . <nl> / / Since the same replication strategy is used , the same placement should be used and we should get the same <nl> / / number of replicas for all of the tokens in the ring . <nl> - assert localBaseEndpoints . size ( ) = = localViewEndpoints . size ( ) : " Replication strategy should have the same number of endpoints for the base and the view " ; <nl> - int baseIdx = localBaseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + assert baseEndpoints . size ( ) = = viewEndpoints . size ( ) : " Replication strategy should have the same number of endpoints for the base and the view " ; <nl> + int baseIdx = baseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> <nl> if ( baseIdx < 0 ) <nl> { <nl> @ @ - 104 , 6 + 109 , 6 @ @ public final class ViewUtils <nl> } <nl> <nl> <nl> - return localViewEndpoints . get ( baseIdx ) ; <nl> + return viewEndpoints . get ( baseIdx ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / conf / datacenters . properties b / conf / datacenters . properties <nl> index b186cb1 . . 9c4a17c 100644 <nl> - - - a / conf / datacenters . properties <nl> + + + b / conf / datacenters . properties <nl> @ @ - 15 , 6 + 15 , 8 @ @ <nl> # limitations under the License . <nl> <nl> # datacenter = replication factor <nl> + # The sum of all the datacenter replication factor values should equal <nl> + # the replication factor of the keyspace ( i . e . sum ( dc _ rf ) = RF ) <nl> dc1 = 3 <nl> dc2 = 5 <nl> dc3 = 1 <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> index d8af2f7 . . 11d8c25 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> @ @ - 27 , 8 + 27 , 7 @ @ import java . util . * ; <nl> <nl> / * * <nl> * An endpoint snitch tells Cassandra information about network topology that it can use to route <nl> - * requests more efficiently ( with " sortByProximity " ) . Of the abstract methods , isOnSameRack <nl> - * and isInSameDataCenter are always required ; getLocation is only used by DatacenterShardStrategy . <nl> + * requests more efficiently . <nl> * / <nl> public abstract class AbstractRackAwareSnitch implements IEndpointSnitch <nl> { <nl> @ @ - 48 , 13 + 47 , 25 @ @ public abstract class AbstractRackAwareSnitch implements IEndpointSnitch <nl> * / <nl> abstract public String getDatacenter ( InetAddress endpoint ) throws UnknownHostException ; <nl> <nl> - public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > unsortedAddress ) <nl> + / * * <nl> + * Sorts the < tt > Collection < / tt > of node addresses by proximity to the given address <nl> + * @ param address the address to sort by proximity to <nl> + * @ param addresses the nodes to sort <nl> + * @ return a new sorted < tt > List < / tt > <nl> + * / <nl> + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> { <nl> - List < InetAddress > preferred = new ArrayList < InetAddress > ( unsortedAddress ) ; <nl> + List < InetAddress > preferred = new ArrayList < InetAddress > ( addresses ) ; <nl> sortByProximity ( address , preferred ) ; <nl> return preferred ; <nl> } <nl> <nl> + / * * <nl> + * Sorts the < tt > List < / tt > of node addresses by proximity to the given address <nl> + * @ param address the address to sort the proximity by <nl> + * @ param addresses the nodes to sort <nl> + * @ return the sorted < tt > List < / tt > <nl> + * / <nl> public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) <nl> { <nl> Collections . sort ( addresses , new Comparator < InetAddress > ( ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index 78f65d4 . . 2faa062 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 35 , 9 + 35 , 7 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> / * * <nl> - * This class contains a helper method that will be used by <nl> - * all abstraction that implement the IReplicaPlacementStrategy <nl> - * interface . <nl> + * A abstract parent for all replication strategies . <nl> * / <nl> public abstract class AbstractReplicationStrategy <nl> { <nl> @ @ - 58 , 19 + 56 , 19 @ @ public abstract class AbstractReplicationStrategy <nl> * we return a List to avoid an extra allocation when sorting by proximity later . <nl> * / <nl> public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata , String table ) ; <nl> - <nl> - public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) <nl> - { <nl> - return new WriteResponseHandler ( blockFor , table ) ; <nl> - } <nl> <nl> public ArrayList < InetAddress > getNaturalEndpoints ( Token token , String table ) <nl> { <nl> return getNaturalEndpoints ( token , tokenMetadata _ , table ) ; <nl> } <nl> + <nl> + public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) <nl> + { <nl> + return new WriteResponseHandler ( blockFor , table ) ; <nl> + } <nl> <nl> / * * <nl> - * returns multimap of { live destination : ultimate targets } , where if target is not the same <nl> + * returns < tt > Multimap < / tt > of { live destination : ultimate targets } , where if target is not the same <nl> * as the destination , it is a " hinted " write , and will need to be sent to <nl> * the ultimate target when it becomes alive again . <nl> * / <nl> @ @ - 143 , 9 + 141 , 10 @ @ public abstract class AbstractReplicationStrategy <nl> } <nl> <nl> / * <nl> - NOTE : this is pretty inefficient . also the inverse ( getRangeAddresses ) below . <nl> - this is fine as long as we don ' t use this on any critical path . <nl> - ( fixing this would probably require merging tokenmetadata into replicationstrategy , so we could cache / invalidate cleanly . ) <nl> + * NOTE : this is pretty inefficient . also the inverse ( getRangeAddresses ) below . <nl> + * this is fine as long as we don ' t use this on any critical path . <nl> + * ( fixing this would probably require merging tokenmetadata into replicationstrategy , <nl> + * so we could cache / invalidate cleanly . ) <nl> * / <nl> public Multimap < InetAddress , Range > getAddressRanges ( TokenMetadata metadata , String table ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java <nl> index 321f45b . . 4a1130a 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java <nl> @ @ - 36 , 10 + 36 , 14 @ @ import org . apache . cassandra . service . * ; <nl> import org . apache . cassandra . thrift . ConsistencyLevel ; <nl> <nl> / * * <nl> - * This Stategy is little diffrent than the Rack aware Statergy . If there is <nl> - * replication factor is N . We will make sure that ( N - 1 ) % 2 of the nodes are in <nl> - * other Datacenter . . . . For example if we have 5 nodes this stategy will make <nl> - * sure to make 2 copies out of 5 in other dataceneter . <nl> + * This Replication Strategy takes a property file that gives the intended <nl> + * replication factor in each datacenter . The sum total of the datacenter <nl> + * replication factor values should be equal to the keyspace replication <nl> + * factor . <nl> + * < p > <nl> + * So for example , if the keyspace replication factor is 6 , the <nl> + * datacenter replication factors could be 3 , 2 , and 1 - so 3 replicas in <nl> + * one datacenter , 2 in another , and 1 in another - totalling 6 . <nl> * < p / > <nl> * This class also caches the Endpoints and invalidates the cache if there is a <nl> * change in the number of tokens . <nl> @ @ - 65 , 10 + 69 , 6 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy <nl> return new HashMap < String , Integer > ( quorumRepFactor ) ; <nl> } <nl> <nl> - / * * <nl> - * This Method will get the required information of the Endpoint from the <nl> - * DataCenterEndpointSnitch and poopulates this singleton class . <nl> - * / <nl> private synchronized void loadEndpoints ( TokenMetadata metadata ) throws UnknownHostException <nl> { <nl> this . tokens = new ArrayList < Token > ( metadata . sortedTokens ( ) ) ; <nl> @ @ - 206 , 7 + 206 , 7 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy <nl> } <nl> <nl> / * <nl> - * If we found N number of nodes we are good . This loop wil just <nl> + * If we found N number of nodes we are good . This loop will just <nl> * exit . Otherwise just loop through the list and add until we <nl> * have N nodes . <nl> * / <nl> @ @ - 232 , 7 + 232 , 7 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy <nl> * This method will generate the QRH object and returns . If the Consistency <nl> * level is DCQUORUM then it will return a DCQRH with a map of local rep <nl> * factor alone . If the consistency level is DCQUORUMSYNC then it will <nl> - * return a DCQRH with a map of all the DC rep facor . <nl> + * return a DCQRH with a map of all the DC rep factor . <nl> * / <nl> @ Override <nl> public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> index 9084ef3 . . 1bcf4a2 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> @ @ - 30 , 19 + 30 , 17 @ @ import java . util . Collection ; <nl> * This interface helps determine location of node in the data center relative to another node . <nl> * Give a node A and another node B it can tell if A and B are on the same rack or in the same <nl> * data center . <nl> - * <nl> - * Not all methods will be germate to all implementations . Throw UnsupportedOperation as necessary . <nl> * / <nl> <nl> public interface IEndpointSnitch <nl> { <nl> / * * <nl> - * returns a new List < InetAddress > sorted by proximity to the given endpoint <nl> + * returns a new < tt > List < / tt > sorted by proximity to the given endpoint <nl> * / <nl> public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> <nl> / * * <nl> - * This method will sort the List < InetAddress > according to the proximity of the given address . <nl> + * This method will sort the < tt > List < / tt > by proximity to the given address . <nl> * / <nl> public List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> index f1ef16c . . 12ded39 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java <nl> @ @ - 36 , 13 + 36 , 11 @ @ import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> / * * <nl> - * PropertyFileSnitch <nl> - * <nl> - * PropertyFileSnitch is used by Digg to determine if two IP ' s are in the same <nl> - * datacenter or on the same rack . <nl> - * <nl> + * Used to determine if two IP ' s are in the same datacenter or on the same rack . <nl> + * < p / > <nl> + * Based on a properties file configuration . <nl> * / <nl> - public class PropertyFileSnitch extends RackInferringSnitch implements PropertyFileSnitchMBean { <nl> + public class PropertyFileSnitch extends AbstractRackAwareSnitch implements PropertyFileSnitchMBean { <nl> / * * <nl> * A list of properties with keys being host : port and values being datacenter : rack <nl> * / <nl> @ @ - 117 , 6 + 115 , 9 @ @ public class PropertyFileSnitch extends RackInferringSnitch implements PropertyF <nl> return getEndpointInfo ( endpoint ) [ 1 ] ; <nl> } <nl> <nl> + / * * <nl> + * @ return the < tt > String < / tt > representation of the configuration <nl> + * / <nl> public String displayConfiguration ( ) { <nl> StringBuffer configurationString = new StringBuffer ( " Current rack configuration \ n = = = = = = = = = = = = = = = = = \ n " ) ; <nl> for ( Object key : hostProperties . keySet ( ) ) { <nl> @ @ - 127 , 6 + 128 , 9 @ @ public class PropertyFileSnitch extends RackInferringSnitch implements PropertyF <nl> return configurationString . toString ( ) ; <nl> } <nl> <nl> + / * * <nl> + * Reloads the configuration from the file <nl> + * / <nl> public void reloadConfiguration ( ) throws ConfigurationException <nl> { <nl> ClassLoader loader = PropertyFileSnitch . class . getClassLoader ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> index 39ee045 . . 7c2e92f 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java <nl> @ @ - 28 , 11 + 28 , 11 @ @ import org . apache . cassandra . dht . Token ; <nl> import java . net . InetAddress ; <nl> <nl> / * <nl> - * This class returns the nodes responsible for a given <nl> - * key but does respects rack awareness . It makes a best <nl> - * effort to get a node from a different data center and <nl> - * a node in a different rack in the same datacenter as <nl> - * the primary . <nl> + * This Replication Strategy returns the nodes responsible for a given <nl> + * key but respects rack awareness . It places one replica in a <nl> + * different data center from the first ( if there is any such data center ) , <nl> + * and remaining replicas in different racks in the same datacenter as <nl> + * the first . <nl> * / <nl> public class RackAwareStrategy extends AbstractReplicationStrategy <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / locator / RackInferringSnitch . java b / src / java / org / apache / cassandra / locator / RackInferringSnitch . java <nl> index b849b75 . . 337ea08 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / RackInferringSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / RackInferringSnitch . java <nl> @ @ - 23 , 7 + 23 , 7 @ @ import java . net . UnknownHostException ; <nl> import java . util . * ; <nl> <nl> / * * <nl> - * A simple endpoint snitch implementation that assumes rack and dc information is encoded <nl> + * A simple endpoint snitch implementation that assumes datacenter and rack information is encoded <nl> * in the 2nd and 3rd octets of the ip address , respectively . <nl> * / <nl> public class RackInferringSnitch extends AbstractRackAwareSnitch <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index 6537401 . . a4efa85 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 42 , 7 + 42 , 7 @ @ public class TokenMetadata <nl> / / Now suppose node B bootstraps between A and C at the same time . Its pending ranges would be C - E , E - A and A - B . <nl> / / Now both nodes have pending range E - A in their list , which will cause pending range collision <nl> / / even though we ' re only talking about replica range , not even primary range . The same thing happens <nl> - / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a multimap , <nl> + / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a < tt > Multimap < / tt > , <nl> / / since that would make us unable to notice the real problem of two nodes trying to boot using the same token . <nl> / / In order to do this properly , we need to know what tokens are booting at any time . <nl> private BiMap < Token , InetAddress > bootstrapTokens ; <nl> @ @ - 395 , 15 + 395 , 15 @ @ public class TokenMetadata <nl> return bootstrapTokens ; <nl> } <nl> <nl> - / * * caller should not modify leavigEndpoints * / <nl> + / * * caller should not modify leavingEndpoints * / <nl> public Set < InetAddress > getLeavingEndpoints ( ) <nl> { <nl> return leavingEndpoints ; <nl> } <nl> <nl> / * * <nl> - * iterator over the Tokens in the given ring , starting with the token for the node owning start <nl> - * ( which does not have to be a Token in the ring ) <nl> + * < tt > Iterator < / tt > over the < tt > Token < / tt > s in the given ring , starting with the token for the node owning start <nl> + * ( which does not have to be a < tt > Token < / tt > in the ring ) <nl> * / <nl> public static Iterator < Token > ringIterator ( final List ring , Token start ) <nl> {

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b469594 . . ce24c2b 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 
 + * Fix MV replica filtering for non - NetworkTopologyStrategy ( CASSANDRA - 10634 ) 
 * ( Hadoop ) fix CIF describeSplits ( ) not handling 0 size estimates ( CASSANDRA - 10600 ) 
 * Fix reading of legacy sstables ( CASSANDRA - 10590 ) 
 * Use CQL type names in schema metadata tables ( CASSANDRA - 10365 ) 
 diff - - git a / src / java / org / apache / cassandra / db / view / ViewUtils . java b / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 index ebbae65 . . 089a3b7 100644 
 - - - a / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 + + + b / src / java / org / apache / cassandra / db / view / ViewUtils . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 + import org . apache . cassandra . locator . NetworkTopologyStrategy ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 @ @ - 38 , 9 + 39 , 10 @ @ public final class ViewUtils 
 / * * 
 * Calculate the natural endpoint for the view . 
 * 
 - * The view natural endpoint is the endpint which has the same cardinality as this node in the replication factor . 
 + * The view natural endpoint is the endpoint which has the same cardinality as this node in the replication factor . 
 * The cardinality is the number at which this node would store a piece of data , given the change in replication 
 - * factor . 
 + * factor . If the keyspace ' s replication strategy is a NetworkTopologyStrategy , we filter the ring to contain only 
 + * nodes in the local datacenter when calculating cardinality . 
 * 
 * For example , if we have the following ring : 
 * A , T1 - > B , T2 - > C , T3 - > A 
 @ @ - 61 , 12 + 63 , 14 @ @ public final class ViewUtils 
 AbstractReplicationStrategy replicationStrategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; 
 
 String localDataCenter = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ; 
 - List < InetAddress > localBaseEndpoints = new ArrayList < > ( ) ; 
 - List < InetAddress > localViewEndpoints = new ArrayList < > ( ) ; 
 + List < InetAddress > baseEndpoints = new ArrayList < > ( ) ; 
 + List < InetAddress > viewEndpoints = new ArrayList < > ( ) ; 
 for ( InetAddress baseEndpoint : replicationStrategy . getNaturalEndpoints ( baseToken ) ) 
 { 
 - if ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( baseEndpoint ) . equals ( localDataCenter ) ) 
 - localBaseEndpoints . add ( baseEndpoint ) ; 
 + / / An endpoint is local if we ' re not using Net 
 + if ( ! ( replicationStrategy instanceof NetworkTopologyStrategy ) | | 
 + DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( baseEndpoint ) . equals ( localDataCenter ) ) 
 + baseEndpoints . add ( baseEndpoint ) ; 
 } 
 
 for ( InetAddress viewEndpoint : replicationStrategy . getNaturalEndpoints ( viewToken ) ) 
 @ @ - 77 , 17 + 81 , 18 @ @ public final class ViewUtils 
 
 / / We have to remove any endpoint which is shared between the base and the view , as it will select itself 
 / / and throw off the counts otherwise . 
 - if ( localBaseEndpoints . contains ( viewEndpoint ) ) 
 - localBaseEndpoints . remove ( viewEndpoint ) ; 
 - else if ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( viewEndpoint ) . equals ( localDataCenter ) ) 
 - localViewEndpoints . add ( viewEndpoint ) ; 
 + if ( baseEndpoints . contains ( viewEndpoint ) ) 
 + baseEndpoints . remove ( viewEndpoint ) ; 
 + else if ( ! ( replicationStrategy instanceof NetworkTopologyStrategy ) | | 
 + DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( viewEndpoint ) . equals ( localDataCenter ) ) 
 + viewEndpoints . add ( viewEndpoint ) ; 
 } 
 
 / / The replication strategy will be the same for the base and the view , as they must belong to the same keyspace . 
 / / Since the same replication strategy is used , the same placement should be used and we should get the same 
 / / number of replicas for all of the tokens in the ring . 
 - assert localBaseEndpoints . size ( ) = = localViewEndpoints . size ( ) : " Replication strategy should have the same number of endpoints for the base and the view " ; 
 - int baseIdx = localBaseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + assert baseEndpoints . size ( ) = = viewEndpoints . size ( ) : " Replication strategy should have the same number of endpoints for the base and the view " ; 
 + int baseIdx = baseEndpoints . indexOf ( FBUtilities . getBroadcastAddress ( ) ) ; 
 
 if ( baseIdx < 0 ) 
 { 
 @ @ - 104 , 6 + 109 , 6 @ @ public final class ViewUtils 
 } 
 
 
 - return localViewEndpoints . get ( baseIdx ) ; 
 + return viewEndpoints . get ( baseIdx ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / conf / datacenters . properties b / conf / datacenters . properties 
 index b186cb1 . . 9c4a17c 100644 
 - - - a / conf / datacenters . properties 
 + + + b / conf / datacenters . properties 
 @ @ - 15 , 6 + 15 , 8 @ @ 
 # limitations under the License . 
 
 # datacenter = replication factor 
 + # The sum of all the datacenter replication factor values should equal 
 + # the replication factor of the keyspace ( i . e . sum ( dc _ rf ) = RF ) 
 dc1 = 3 
 dc2 = 5 
 dc3 = 1 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 index d8af2f7 . . 11d8c25 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 @ @ - 27 , 8 + 27 , 7 @ @ import java . util . * ; 
 
 / * * 
 * An endpoint snitch tells Cassandra information about network topology that it can use to route 
 - * requests more efficiently ( with " sortByProximity " ) . Of the abstract methods , isOnSameRack 
 - * and isInSameDataCenter are always required ; getLocation is only used by DatacenterShardStrategy . 
 + * requests more efficiently . 
 * / 
 public abstract class AbstractRackAwareSnitch implements IEndpointSnitch 
 { 
 @ @ - 48 , 13 + 47 , 25 @ @ public abstract class AbstractRackAwareSnitch implements IEndpointSnitch 
 * / 
 abstract public String getDatacenter ( InetAddress endpoint ) throws UnknownHostException ; 
 
 - public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > unsortedAddress ) 
 + / * * 
 + * Sorts the < tt > Collection < / tt > of node addresses by proximity to the given address 
 + * @ param address the address to sort by proximity to 
 + * @ param addresses the nodes to sort 
 + * @ return a new sorted < tt > List < / tt > 
 + * / 
 + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 { 
 - List < InetAddress > preferred = new ArrayList < InetAddress > ( unsortedAddress ) ; 
 + List < InetAddress > preferred = new ArrayList < InetAddress > ( addresses ) ; 
 sortByProximity ( address , preferred ) ; 
 return preferred ; 
 } 
 
 + / * * 
 + * Sorts the < tt > List < / tt > of node addresses by proximity to the given address 
 + * @ param address the address to sort the proximity by 
 + * @ param addresses the nodes to sort 
 + * @ return the sorted < tt > List < / tt > 
 + * / 
 public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) 
 { 
 Collections . sort ( addresses , new Comparator < InetAddress > ( ) 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index 78f65d4 . . 2faa062 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 35 , 9 + 35 , 7 @ @ import org . apache . cassandra . thrift . ConsistencyLevel ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 / * * 
 - * This class contains a helper method that will be used by 
 - * all abstraction that implement the IReplicaPlacementStrategy 
 - * interface . 
 + * A abstract parent for all replication strategies . 
 * / 
 public abstract class AbstractReplicationStrategy 
 { 
 @ @ - 58 , 19 + 56 , 19 @ @ public abstract class AbstractReplicationStrategy 
 * we return a List to avoid an extra allocation when sorting by proximity later . 
 * / 
 public abstract ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata , String table ) ; 
 - 
 - public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) 
 - { 
 - return new WriteResponseHandler ( blockFor , table ) ; 
 - } 
 
 public ArrayList < InetAddress > getNaturalEndpoints ( Token token , String table ) 
 { 
 return getNaturalEndpoints ( token , tokenMetadata _ , table ) ; 
 } 
 + 
 + public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) 
 + { 
 + return new WriteResponseHandler ( blockFor , table ) ; 
 + } 
 
 / * * 
 - * returns multimap of { live destination : ultimate targets } , where if target is not the same 
 + * returns < tt > Multimap < / tt > of { live destination : ultimate targets } , where if target is not the same 
 * as the destination , it is a " hinted " write , and will need to be sent to 
 * the ultimate target when it becomes alive again . 
 * / 
 @ @ - 143 , 9 + 141 , 10 @ @ public abstract class AbstractReplicationStrategy 
 } 
 
 / * 
 - NOTE : this is pretty inefficient . also the inverse ( getRangeAddresses ) below . 
 - this is fine as long as we don ' t use this on any critical path . 
 - ( fixing this would probably require merging tokenmetadata into replicationstrategy , so we could cache / invalidate cleanly . ) 
 + * NOTE : this is pretty inefficient . also the inverse ( getRangeAddresses ) below . 
 + * this is fine as long as we don ' t use this on any critical path . 
 + * ( fixing this would probably require merging tokenmetadata into replicationstrategy , 
 + * so we could cache / invalidate cleanly . ) 
 * / 
 public Multimap < InetAddress , Range > getAddressRanges ( TokenMetadata metadata , String table ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java b / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java 
 index 321f45b . . 4a1130a 100644 
 - - - a / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / DatacenterShardStrategy . java 
 @ @ - 36 , 10 + 36 , 14 @ @ import org . apache . cassandra . service . * ; 
 import org . apache . cassandra . thrift . ConsistencyLevel ; 
 
 / * * 
 - * This Stategy is little diffrent than the Rack aware Statergy . If there is 
 - * replication factor is N . We will make sure that ( N - 1 ) % 2 of the nodes are in 
 - * other Datacenter . . . . For example if we have 5 nodes this stategy will make 
 - * sure to make 2 copies out of 5 in other dataceneter . 
 + * This Replication Strategy takes a property file that gives the intended 
 + * replication factor in each datacenter . The sum total of the datacenter 
 + * replication factor values should be equal to the keyspace replication 
 + * factor . 
 + * < p > 
 + * So for example , if the keyspace replication factor is 6 , the 
 + * datacenter replication factors could be 3 , 2 , and 1 - so 3 replicas in 
 + * one datacenter , 2 in another , and 1 in another - totalling 6 . 
 * < p / > 
 * This class also caches the Endpoints and invalidates the cache if there is a 
 * change in the number of tokens . 
 @ @ - 65 , 10 + 69 , 6 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy 
 return new HashMap < String , Integer > ( quorumRepFactor ) ; 
 } 
 
 - / * * 
 - * This Method will get the required information of the Endpoint from the 
 - * DataCenterEndpointSnitch and poopulates this singleton class . 
 - * / 
 private synchronized void loadEndpoints ( TokenMetadata metadata ) throws UnknownHostException 
 { 
 this . tokens = new ArrayList < Token > ( metadata . sortedTokens ( ) ) ; 
 @ @ - 206 , 7 + 206 , 7 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy 
 } 
 
 / * 
 - * If we found N number of nodes we are good . This loop wil just 
 + * If we found N number of nodes we are good . This loop will just 
 * exit . Otherwise just loop through the list and add until we 
 * have N nodes . 
 * / 
 @ @ - 232 , 7 + 232 , 7 @ @ public class DatacenterShardStrategy extends AbstractReplicationStrategy 
 * This method will generate the QRH object and returns . If the Consistency 
 * level is DCQUORUM then it will return a DCQRH with a map of local rep 
 * factor alone . If the consistency level is DCQUORUMSYNC then it will 
 - * return a DCQRH with a map of all the DC rep facor . 
 + * return a DCQRH with a map of all the DC rep factor . 
 * / 
 @ Override 
 public WriteResponseHandler getWriteResponseHandler ( int blockFor , ConsistencyLevel consistency _ level , String table ) 
 diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 index 9084ef3 . . 1bcf4a2 100644 
 - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 @ @ - 30 , 19 + 30 , 17 @ @ import java . util . Collection ; 
 * This interface helps determine location of node in the data center relative to another node . 
 * Give a node A and another node B it can tell if A and B are on the same rack or in the same 
 * data center . 
 - * 
 - * Not all methods will be germate to all implementations . Throw UnsupportedOperation as necessary . 
 * / 
 
 public interface IEndpointSnitch 
 { 
 / * * 
 - * returns a new List < InetAddress > sorted by proximity to the given endpoint 
 + * returns a new < tt > List < / tt > sorted by proximity to the given endpoint 
 * / 
 public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 
 / * * 
 - * This method will sort the List < InetAddress > according to the proximity of the given address . 
 + * This method will sort the < tt > List < / tt > by proximity to the given address . 
 * / 
 public List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 index f1ef16c . . 12ded39 100644 
 - - - a / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / PropertyFileSnitch . java 
 @ @ - 36 , 13 + 36 , 11 @ @ import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 / * * 
 - * PropertyFileSnitch 
 - * 
 - * PropertyFileSnitch is used by Digg to determine if two IP ' s are in the same 
 - * datacenter or on the same rack . 
 - * 
 + * Used to determine if two IP ' s are in the same datacenter or on the same rack . 
 + * < p / > 
 + * Based on a properties file configuration . 
 * / 
 - public class PropertyFileSnitch extends RackInferringSnitch implements PropertyFileSnitchMBean { 
 + public class PropertyFileSnitch extends AbstractRackAwareSnitch implements PropertyFileSnitchMBean { 
 / * * 
 * A list of properties with keys being host : port and values being datacenter : rack 
 * / 
 @ @ - 117 , 6 + 115 , 9 @ @ public class PropertyFileSnitch extends RackInferringSnitch implements PropertyF 
 return getEndpointInfo ( endpoint ) [ 1 ] ; 
 } 
 
 + / * * 
 + * @ return the < tt > String < / tt > representation of the configuration 
 + * / 
 public String displayConfiguration ( ) { 
 StringBuffer configurationString = new StringBuffer ( " Current rack configuration \ n = = = = = = = = = = = = = = = = = \ n " ) ; 
 for ( Object key : hostProperties . keySet ( ) ) { 
 @ @ - 127 , 6 + 128 , 9 @ @ public class PropertyFileSnitch extends RackInferringSnitch implements PropertyF 
 return configurationString . toString ( ) ; 
 } 
 
 + / * * 
 + * Reloads the configuration from the file 
 + * / 
 public void reloadConfiguration ( ) throws ConfigurationException 
 { 
 ClassLoader loader = PropertyFileSnitch . class . getClassLoader ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 index 39ee045 . . 7c2e92f 100644 
 - - - a / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / RackAwareStrategy . java 
 @ @ - 28 , 11 + 28 , 11 @ @ import org . apache . cassandra . dht . Token ; 
 import java . net . InetAddress ; 
 
 / * 
 - * This class returns the nodes responsible for a given 
 - * key but does respects rack awareness . It makes a best 
 - * effort to get a node from a different data center and 
 - * a node in a different rack in the same datacenter as 
 - * the primary . 
 + * This Replication Strategy returns the nodes responsible for a given 
 + * key but respects rack awareness . It places one replica in a 
 + * different data center from the first ( if there is any such data center ) , 
 + * and remaining replicas in different racks in the same datacenter as 
 + * the first . 
 * / 
 public class RackAwareStrategy extends AbstractReplicationStrategy 
 { 
 diff - - git a / src / java / org / apache / cassandra / locator / RackInferringSnitch . java b / src / java / org / apache / cassandra / locator / RackInferringSnitch . java 
 index b849b75 . . 337ea08 100644 
 - - - a / src / java / org / apache / cassandra / locator / RackInferringSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / RackInferringSnitch . java 
 @ @ - 23 , 7 + 23 , 7 @ @ import java . net . UnknownHostException ; 
 import java . util . * ; 
 
 / * * 
 - * A simple endpoint snitch implementation that assumes rack and dc information is encoded 
 + * A simple endpoint snitch implementation that assumes datacenter and rack information is encoded 
 * in the 2nd and 3rd octets of the ip address , respectively . 
 * / 
 public class RackInferringSnitch extends AbstractRackAwareSnitch 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index 6537401 . . a4efa85 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 42 , 7 + 42 , 7 @ @ public class TokenMetadata 
 / / Now suppose node B bootstraps between A and C at the same time . Its pending ranges would be C - E , E - A and A - B . 
 / / Now both nodes have pending range E - A in their list , which will cause pending range collision 
 / / even though we ' re only talking about replica range , not even primary range . The same thing happens 
 - / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a multimap , 
 + / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a < tt > Multimap < / tt > , 
 / / since that would make us unable to notice the real problem of two nodes trying to boot using the same token . 
 / / In order to do this properly , we need to know what tokens are booting at any time . 
 private BiMap < Token , InetAddress > bootstrapTokens ; 
 @ @ - 395 , 15 + 395 , 15 @ @ public class TokenMetadata 
 return bootstrapTokens ; 
 } 
 
 - / * * caller should not modify leavigEndpoints * / 
 + / * * caller should not modify leavingEndpoints * / 
 public Set < InetAddress > getLeavingEndpoints ( ) 
 { 
 return leavingEndpoints ; 
 } 
 
 / * * 
 - * iterator over the Tokens in the given ring , starting with the token for the node owning start 
 - * ( which does not have to be a Token in the ring ) 
 + * < tt > Iterator < / tt > over the < tt > Token < / tt > s in the given ring , starting with the token for the node owning start 
 + * ( which does not have to be a < tt > Token < / tt > in the ring ) 
 * / 
 public static Iterator < Token > ringIterator ( final List ring , Token start ) 
 {
