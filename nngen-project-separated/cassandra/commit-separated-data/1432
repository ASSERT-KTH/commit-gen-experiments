BLEU SCORE: 0.003976388001785548

TEST MSG: Fix paging with static
GENERATED MSG: Introduce new append - only concurrent collection , Accumulator , and use for AbstractRowResolver . replies

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> index 2c16ace . . 9991277 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ <nl> * / <nl> package org . apache . cassandra . service . pager ; <nl> <nl> + import java . util . NoSuchElementException ; <nl> + <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . rows . * ; <nl> @ @ - 79 , 6 + 81 , 9 @ @ abstract class AbstractQueryPager implements QueryPager <nl> <nl> private Row lastRow ; <nl> <nl> + private boolean isFirstPartition = true ; <nl> + private RowIterator nextPartition ; <nl> + <nl> private PagerIterator ( PartitionIterator iter , DataLimits pageLimits , int nowInSec ) <nl> { <nl> super ( iter , pageLimits , nowInSec ) ; <nl> @ @ - 86 , 30 + 91 , 56 @ @ abstract class AbstractQueryPager implements QueryPager <nl> } <nl> <nl> @ Override <nl> - @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result <nl> - public RowIterator next ( ) <nl> + @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result or in close ( ) <nl> + public boolean hasNext ( ) <nl> { <nl> - RowIterator iter = super . next ( ) ; <nl> - try <nl> + while ( nextPartition = = null & & super . hasNext ( ) ) <nl> { <nl> - DecoratedKey key = iter . partitionKey ( ) ; <nl> + if ( nextPartition = = null ) <nl> + nextPartition = super . next ( ) ; <nl> + <nl> + DecoratedKey key = nextPartition . partitionKey ( ) ; <nl> if ( lastKey = = null | | ! lastKey . equals ( key ) ) <nl> remainingInPartition = limits . perPartitionCount ( ) ; <nl> <nl> lastKey = key ; <nl> - return new RowPagerIterator ( iter ) ; <nl> - } <nl> - catch ( RuntimeException e ) <nl> - { <nl> - iter . close ( ) ; <nl> - throw e ; <nl> + <nl> + / / If this is the first partition of this page , this could be the continuation of a partition we ' ve started <nl> + / / on the previous page . In which case , we could have the problem that the partition has no more " regular " <nl> + / / rows ( but the page size is such we didn ' t knew before ) but it does has a static row . We should then skip <nl> + / / the partition as returning it would means to the upper layer that the partition has " only " static columns , <nl> + / / which is not the case ( and we know the static results have been sent on the previous page ) . <nl> + if ( isFirstPartition & & isPreviouslyReturnedPartition ( key ) & & ! nextPartition . hasNext ( ) ) <nl> + { <nl> + nextPartition . close ( ) ; <nl> + nextPartition = null ; <nl> + } <nl> + <nl> + isFirstPartition = false ; <nl> } <nl> + return nextPartition ! = null ; <nl> + } <nl> + <nl> + @ Override <nl> + @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result <nl> + public RowIterator next ( ) <nl> + { <nl> + if ( ! hasNext ( ) ) <nl> + throw new NoSuchElementException ( ) ; <nl> + <nl> + RowIterator toReturn = nextPartition ; <nl> + nextPartition = null ; <nl> + <nl> + return new RowPagerIterator ( toReturn ) ; <nl> } <nl> <nl> @ Override <nl> public void close ( ) <nl> { <nl> super . close ( ) ; <nl> + if ( nextPartition ! = null ) <nl> + nextPartition . close ( ) ; <nl> + <nl> recordLast ( lastKey , lastRow ) ; <nl> <nl> int counted = counter . counted ( ) ; <nl> @ @ - 158 , 4 + 189 , 5 @ @ abstract class AbstractQueryPager implements QueryPager <nl> <nl> protected abstract ReadCommand nextPageReadCommand ( int pageSize ) ; <nl> protected abstract void recordLast ( DecoratedKey key , Row row ) ; <nl> + protected abstract boolean isPreviouslyReturnedPartition ( DecoratedKey key ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> index 4171694 . . e085490 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java <nl> @ @ - 69 , 6 + 69 , 12 @ @ public class RangeNamesQueryPager extends AbstractQueryPager <nl> lastReturnedKey = key ; <nl> } <nl> <nl> + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) <nl> + { <nl> + / / Note that lastReturnedKey can be null , but key cannot . <nl> + return key . equals ( lastReturnedKey ) ; <nl> + } <nl> + <nl> private AbstractBounds < PartitionPosition > makeExcludingKeyBounds ( PartitionPosition lastReturnedKey ) <nl> { <nl> / / We return a range that always exclude lastReturnedKey , since we ' ve already <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> index 0139d9c . . 169944b 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java <nl> @ @ - 99 , 6 + 99 , 12 @ @ public class RangeSliceQueryPager extends AbstractQueryPager <nl> } <nl> } <nl> <nl> + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) <nl> + { <nl> + / / Note that lastReturnedKey can be null , but key cannot . <nl> + return key . equals ( lastReturnedKey ) ; <nl> + } <nl> + <nl> private AbstractBounds < PartitionPosition > makeKeyBounds ( PartitionPosition lastReturnedKey , boolean includeLastKey ) <nl> { <nl> AbstractBounds < PartitionPosition > bounds = ( ( PartitionRangeReadCommand ) command ) . dataRange ( ) . keyRange ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java b / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java <nl> index 223c3fd . . bb223b8 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java <nl> @ @ - 82 , 4 + 82 , 10 @ @ public class SinglePartitionPager extends AbstractQueryPager <nl> if ( last ! = null ) <nl> lastReturned = last . clustering ( ) ; <nl> } <nl> + <nl> + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) <nl> + { <nl> + / / We ' re querying a single partition , so if it ' s not the first page , it is the previously returned one . <nl> + return lastReturned ! = null ; <nl> + } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 index 2c16ace . . 9991277 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 @ @ - 17 , 6 + 17 , 8 @ @ 
 * / 
 package org . apache . cassandra . service . pager ; 
 
 + import java . util . NoSuchElementException ; 
 + 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . rows . * ; 
 @ @ - 79 , 6 + 81 , 9 @ @ abstract class AbstractQueryPager implements QueryPager 
 
 private Row lastRow ; 
 
 + private boolean isFirstPartition = true ; 
 + private RowIterator nextPartition ; 
 + 
 private PagerIterator ( PartitionIterator iter , DataLimits pageLimits , int nowInSec ) 
 { 
 super ( iter , pageLimits , nowInSec ) ; 
 @ @ - 86 , 30 + 91 , 56 @ @ abstract class AbstractQueryPager implements QueryPager 
 } 
 
 @ Override 
 - @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result 
 - public RowIterator next ( ) 
 + @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result or in close ( ) 
 + public boolean hasNext ( ) 
 { 
 - RowIterator iter = super . next ( ) ; 
 - try 
 + while ( nextPartition = = null & & super . hasNext ( ) ) 
 { 
 - DecoratedKey key = iter . partitionKey ( ) ; 
 + if ( nextPartition = = null ) 
 + nextPartition = super . next ( ) ; 
 + 
 + DecoratedKey key = nextPartition . partitionKey ( ) ; 
 if ( lastKey = = null | | ! lastKey . equals ( key ) ) 
 remainingInPartition = limits . perPartitionCount ( ) ; 
 
 lastKey = key ; 
 - return new RowPagerIterator ( iter ) ; 
 - } 
 - catch ( RuntimeException e ) 
 - { 
 - iter . close ( ) ; 
 - throw e ; 
 + 
 + / / If this is the first partition of this page , this could be the continuation of a partition we ' ve started 
 + / / on the previous page . In which case , we could have the problem that the partition has no more " regular " 
 + / / rows ( but the page size is such we didn ' t knew before ) but it does has a static row . We should then skip 
 + / / the partition as returning it would means to the upper layer that the partition has " only " static columns , 
 + / / which is not the case ( and we know the static results have been sent on the previous page ) . 
 + if ( isFirstPartition & & isPreviouslyReturnedPartition ( key ) & & ! nextPartition . hasNext ( ) ) 
 + { 
 + nextPartition . close ( ) ; 
 + nextPartition = null ; 
 + } 
 + 
 + isFirstPartition = false ; 
 } 
 + return nextPartition ! = null ; 
 + } 
 + 
 + @ Override 
 + @ SuppressWarnings ( " resource " ) / / iter is closed by closing the result 
 + public RowIterator next ( ) 
 + { 
 + if ( ! hasNext ( ) ) 
 + throw new NoSuchElementException ( ) ; 
 + 
 + RowIterator toReturn = nextPartition ; 
 + nextPartition = null ; 
 + 
 + return new RowPagerIterator ( toReturn ) ; 
 } 
 
 @ Override 
 public void close ( ) 
 { 
 super . close ( ) ; 
 + if ( nextPartition ! = null ) 
 + nextPartition . close ( ) ; 
 + 
 recordLast ( lastKey , lastRow ) ; 
 
 int counted = counter . counted ( ) ; 
 @ @ - 158 , 4 + 189 , 5 @ @ abstract class AbstractQueryPager implements QueryPager 
 
 protected abstract ReadCommand nextPageReadCommand ( int pageSize ) ; 
 protected abstract void recordLast ( DecoratedKey key , Row row ) ; 
 + protected abstract boolean isPreviouslyReturnedPartition ( DecoratedKey key ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 index 4171694 . . e085490 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / RangeNamesQueryPager . java 
 @ @ - 69 , 6 + 69 , 12 @ @ public class RangeNamesQueryPager extends AbstractQueryPager 
 lastReturnedKey = key ; 
 } 
 
 + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) 
 + { 
 + / / Note that lastReturnedKey can be null , but key cannot . 
 + return key . equals ( lastReturnedKey ) ; 
 + } 
 + 
 private AbstractBounds < PartitionPosition > makeExcludingKeyBounds ( PartitionPosition lastReturnedKey ) 
 { 
 / / We return a range that always exclude lastReturnedKey , since we ' ve already 
 diff - - git a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 index 0139d9c . . 169944b 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / RangeSliceQueryPager . java 
 @ @ - 99 , 6 + 99 , 12 @ @ public class RangeSliceQueryPager extends AbstractQueryPager 
 } 
 } 
 
 + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) 
 + { 
 + / / Note that lastReturnedKey can be null , but key cannot . 
 + return key . equals ( lastReturnedKey ) ; 
 + } 
 + 
 private AbstractBounds < PartitionPosition > makeKeyBounds ( PartitionPosition lastReturnedKey , boolean includeLastKey ) 
 { 
 AbstractBounds < PartitionPosition > bounds = ( ( PartitionRangeReadCommand ) command ) . dataRange ( ) . keyRange ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java b / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java 
 index 223c3fd . . bb223b8 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / SinglePartitionPager . java 
 @ @ - 82 , 4 + 82 , 10 @ @ public class SinglePartitionPager extends AbstractQueryPager 
 if ( last ! = null ) 
 lastReturned = last . clustering ( ) ; 
 } 
 + 
 + protected boolean isPreviouslyReturnedPartition ( DecoratedKey key ) 
 + { 
 + / / We ' re querying a single partition , so if it ' s not the first page , it is the previously returned one . 
 + return lastReturned ! = null ; 
 + } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
