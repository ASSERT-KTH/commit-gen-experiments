BLEU SCORE: 0.03283637368030199

TEST MSG: Optimize MultiCBuilder when there is no IN
GENERATED MSG: Secondary index support for collections

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index a468077 . . dd17f11 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 2 <nl> + * Optimize building of Clustering object when only one is created ( CASSANDRA - 10409 ) <nl> * Make index building pluggable ( CASSANDRA - 10681 ) <nl> * Add sstable flush observer ( CASSANDRA - 10678 ) <nl> * Improve NTS endpoints calculation ( CASSANDRA - 10200 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java b / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java <nl> index 107cbd1 . . 0730593 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java <nl> @ @ - 175 , 10 + 175 , 24 @ @ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions <nl> return new PrimaryKeyRestrictionSet ( this , restriction ) ; <nl> } <nl> <nl> + / / Whether any of the underlying restriction is an IN <nl> + private boolean hasIN ( ) <nl> + { <nl> + if ( isIN ( ) ) <nl> + return true ; <nl> + <nl> + for ( Restriction restriction : restrictions ) <nl> + { <nl> + if ( restriction . isIN ( ) ) <nl> + return true ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> @ Override <nl> public NavigableSet < Clustering > valuesAsClustering ( QueryOptions options ) throws InvalidRequestException <nl> { <nl> - return appendTo ( MultiCBuilder . create ( comparator ) , options ) . build ( ) ; <nl> + return appendTo ( MultiCBuilder . create ( comparator , hasIN ( ) ) , options ) . build ( ) ; <nl> } <nl> <nl> @ Override <nl> @ @ - 202 , 7 + 216 , 7 @ @ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions <nl> @ Override <nl> public NavigableSet < Slice . Bound > boundsAsClustering ( Bound bound , QueryOptions options ) throws InvalidRequestException <nl> { <nl> - MultiCBuilder builder = MultiCBuilder . create ( comparator ) ; <nl> + MultiCBuilder builder = MultiCBuilder . create ( comparator , hasIN ( ) ) ; <nl> int keyPosition = 0 ; <nl> for ( Restriction r : restrictions ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java b / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java <nl> index 700840d . . ccab2dc 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java <nl> @ @ - 96 , 13 + 96 , 13 @ @ final class RestrictionSet implements Restrictions , Iterable < Restriction > <nl> @ Override <nl> public final boolean isEmpty ( ) <nl> { <nl> - return getColumnDefs ( ) . isEmpty ( ) ; <nl> + return restrictions . isEmpty ( ) ; <nl> } <nl> <nl> @ Override <nl> public final int size ( ) <nl> { <nl> - return getColumnDefs ( ) . size ( ) ; <nl> + return restrictions . size ( ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / db / MultiCBuilder . java b / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> index be654fa . . 8353703 100644 <nl> - - - a / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> + + + b / src / java / org / apache / cassandra / db / MultiCBuilder . java <nl> @ @ - 26 , 44 + 26 , 39 @ @ import org . apache . cassandra . utils . btree . BTreeSet ; <nl> / * * <nl> * Builder that allow to build multiple Clustering / Slice . Bound at the same time . <nl> * / <nl> - public class MultiCBuilder <nl> + public abstract class MultiCBuilder <nl> { <nl> / * * <nl> * The table comparator . <nl> * / <nl> - private final ClusteringComparator comparator ; <nl> + protected final ClusteringComparator comparator ; <nl> <nl> / * * <nl> - * The elements of the clusterings <nl> + * The number of clustering elements that have been added . <nl> * / <nl> - private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; <nl> - <nl> - / * * <nl> - * The number of elements that have been added . <nl> - * / <nl> - private int size ; <nl> + protected int size ; <nl> <nl> / * * <nl> * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . <nl> * / <nl> - private boolean built ; <nl> + protected boolean built ; <nl> <nl> / * * <nl> * < code > true < / code > if the clusterings contains some < code > null < / code > elements . <nl> * / <nl> - private boolean containsNull ; <nl> + protected boolean containsNull ; <nl> <nl> / * * <nl> * < code > true < / code > if the composites contains some < code > unset < / code > elements . <nl> * / <nl> - private boolean containsUnset ; <nl> + protected boolean containsUnset ; <nl> <nl> / * * <nl> * < code > true < / code > if some empty collection have been added . <nl> * / <nl> - private boolean hasMissingElements ; <nl> + protected boolean hasMissingElements ; <nl> <nl> - private MultiCBuilder ( ClusteringComparator comparator ) <nl> + protected MultiCBuilder ( ClusteringComparator comparator ) <nl> { <nl> this . comparator = comparator ; <nl> } <nl> @ @ - 71 , 19 + 66 , 11 @ @ public class MultiCBuilder <nl> / * * <nl> * Creates a new empty { @ code MultiCBuilder } . <nl> * / <nl> - public static MultiCBuilder create ( ClusteringComparator comparator ) <nl> - { <nl> - return new MultiCBuilder ( comparator ) ; <nl> - } <nl> - <nl> - / * * <nl> - * Checks if this builder is empty . <nl> - * <nl> - * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . <nl> - * / <nl> - private boolean isEmpty ( ) <nl> + public static MultiCBuilder create ( ClusteringComparator comparator , boolean forMultipleValues ) <nl> { <nl> - return elementsList . isEmpty ( ) ; <nl> + return forMultipleValues <nl> + ? new MultiClusteringBuilder ( comparator ) <nl> + : new OneClusteringBuilder ( comparator ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 96 , 25 + 83 , 7 @ @ public class MultiCBuilder <nl> * @ param value the value of the next element <nl> * @ return this < code > MulitCBuilder < / code > <nl> * / <nl> - public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - if ( value = = null ) <nl> - containsNull = true ; <nl> - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> - containsUnset = true ; <nl> - <nl> - elementsList . get ( i ) . add ( value ) ; <nl> - } <nl> - size + + ; <nl> - return this ; <nl> - } <nl> + public abstract MultiCBuilder addElementToAll ( ByteBuffer value ) ; <nl> <nl> / * * <nl> * Adds individually each of the specified elements to the end of all of the existing clusterings . <nl> @ @ - 126 , 42 + 95 , 7 @ @ public class MultiCBuilder <nl> * @ param values the elements to add <nl> * @ return this < code > CompositeBuilder < / code > <nl> * / <nl> - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> - <nl> - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> - { <nl> - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> - elementsList . add ( newComposite ) ; <nl> - <nl> - ByteBuffer value = values . get ( j ) ; <nl> - <nl> - if ( value = = null ) <nl> - containsNull = true ; <nl> - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> - containsUnset = true ; <nl> - <nl> - newComposite . add ( values . get ( j ) ) ; <nl> - } <nl> - } <nl> - } <nl> - size + + ; <nl> - return this ; <nl> - } <nl> + public abstract MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) ; <nl> <nl> / * * <nl> * Adds individually each of the specified list of elements to the end of all of the existing composites . <nl> @ @ - 173 , 44 + 107 , 12 @ @ public class MultiCBuilder <nl> * @ param values the elements to add <nl> * @ return this < code > CompositeBuilder < / code > <nl> * / <nl> - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> - { <nl> - checkUpdateable ( ) ; <nl> - <nl> - if ( isEmpty ( ) ) <nl> - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> - <nl> - if ( values . isEmpty ( ) ) <nl> - { <nl> - hasMissingElements = true ; <nl> - } <nl> - else <nl> - { <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> - { <nl> - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> + public abstract MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) ; <nl> <nl> - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> - { <nl> - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> - elementsList . add ( newComposite ) ; <nl> - <nl> - List < ByteBuffer > value = values . get ( j ) ; <nl> - <nl> - if ( value . isEmpty ( ) ) <nl> - hasMissingElements = true ; <nl> - <nl> - if ( value . contains ( null ) ) <nl> - containsNull = true ; <nl> - if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) <nl> - containsUnset = true ; <nl> - <nl> - newComposite . addAll ( value ) ; <nl> - } <nl> - } <nl> - size + = values . get ( 0 ) . size ( ) ; <nl> - } <nl> - return this ; <nl> + protected void checkUpdateable ( ) <nl> + { <nl> + if ( ! hasRemaining ( ) | | built ) <nl> + throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 257 , 68 + 159 , 260 @ @ public class MultiCBuilder <nl> * <nl> * @ return the clusterings <nl> * / <nl> - public NavigableSet < Clustering > build ( ) <nl> + public abstract NavigableSet < Clustering > build ( ) ; <nl> + <nl> + / * * <nl> + * Builds the < code > clusterings < / code > with the specified EOC . <nl> + * <nl> + * @ return the clusterings <nl> + * / <nl> + public abstract NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) ; <nl> + <nl> + / * * <nl> + * Checks if some elements can still be added to the clusterings . <nl> + * <nl> + * @ return < code > true < / code > if it is possible to add more elements to the clusterings , < code > false < / code > otherwise . <nl> + * / <nl> + public boolean hasRemaining ( ) <nl> { <nl> - built = true ; <nl> + return remainingCount ( ) > 0 ; <nl> + } <nl> <nl> - if ( hasMissingElements ) <nl> - return BTreeSet . empty ( comparator ) ; <nl> + / * * <nl> + * Specialization of MultiCBuilder when we know only one clustering / bound is created . <nl> + * / <nl> + private static class OneClusteringBuilder extends MultiCBuilder <nl> + { <nl> + / * * <nl> + * The elements of the clusterings <nl> + * / <nl> + private final ByteBuffer [ ] elements ; <nl> + <nl> + public OneClusteringBuilder ( ClusteringComparator comparator ) <nl> + { <nl> + super ( comparator ) ; <nl> + this . elements = new ByteBuffer [ comparator . size ( ) ] ; <nl> + } <nl> + <nl> + public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> <nl> - CBuilder builder = CBuilder . create ( comparator ) ; <nl> + if ( value = = null ) <nl> + containsNull = true ; <nl> + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> + containsUnset = true ; <nl> <nl> - if ( elementsList . isEmpty ( ) ) <nl> - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; <nl> + elements [ size + + ] = value ; <nl> + return this ; <nl> + } <nl> <nl> - BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> { <nl> - List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> - set . add ( builder . buildWith ( elements ) ) ; <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + return this ; <nl> + } <nl> + <nl> + assert values . size ( ) = = 1 ; <nl> + <nl> + return addElementToAll ( values . get ( 0 ) ) ; <nl> } <nl> - return set . build ( ) ; <nl> - } <nl> <nl> - / * * <nl> - * Builds the < code > clusterings < / code > with the specified EOC . <nl> - * <nl> - * @ return the clusterings <nl> - * / <nl> - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> - { <nl> - built = true ; <nl> + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> + { <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + return this ; <nl> + } <nl> <nl> - if ( hasMissingElements ) <nl> - return BTreeSet . empty ( comparator ) ; <nl> + assert values . size ( ) = = 1 ; <nl> + return addEachElementToAll ( values . get ( 0 ) ) ; <nl> + } <nl> <nl> - CBuilder builder = CBuilder . create ( comparator ) ; <nl> + public NavigableSet < Clustering > build ( ) <nl> + { <nl> + built = true ; <nl> <nl> - if ( elementsList . isEmpty ( ) ) <nl> - return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> <nl> - / / Use a TreeSet to sort and eliminate duplicates <nl> - BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; <nl> + return BTreeSet . of ( comparator , size = = 0 ? Clustering . EMPTY : new Clustering ( elements ) ) ; <nl> + } <nl> <nl> - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> { <nl> - List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> - set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; <nl> + built = true ; <nl> + <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> + <nl> + if ( size = = 0 ) <nl> + return BTreeSet . of ( comparator , isStart ? Slice . Bound . BOTTOM : Slice . Bound . TOP ) ; <nl> + <nl> + ByteBuffer [ ] newValues = size = = elements . length <nl> + ? elements <nl> + : Arrays . copyOf ( elements , size ) ; <nl> + <nl> + return BTreeSet . of ( comparator , Slice . Bound . create ( Slice . Bound . boundKind ( isStart , isInclusive ) , newValues ) ) ; <nl> } <nl> - return set . build ( ) ; <nl> } <nl> <nl> / * * <nl> - * Checks if some elements can still be added to the clusterings . <nl> - * <nl> - * @ return < code > true < / code > if it is possible to add more elements to the clusterings , < code > false < / code > otherwise . <nl> + * MultiCBuilder implementation actually supporting the creation of multiple clustering / bound . <nl> * / <nl> - public boolean hasRemaining ( ) <nl> + private static class MultiClusteringBuilder extends MultiCBuilder <nl> { <nl> - return remainingCount ( ) > 0 ; <nl> - } <nl> + / * * <nl> + * The elements of the clusterings <nl> + * / <nl> + private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; <nl> <nl> - private void checkUpdateable ( ) <nl> - { <nl> - if ( ! hasRemaining ( ) | | built ) <nl> - throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; <nl> + public MultiClusteringBuilder ( ClusteringComparator comparator ) <nl> + { <nl> + super ( comparator ) ; <nl> + } <nl> + <nl> + public MultiCBuilder addElementToAll ( ByteBuffer value ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + if ( value = = null ) <nl> + containsNull = true ; <nl> + else if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> + containsUnset = true ; <nl> + <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + elementsList . get ( i ) . add ( value ) ; <nl> + <nl> + size + + ; <nl> + return this ; <nl> + } <nl> + <nl> + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> + <nl> + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> + { <nl> + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> + elementsList . add ( newComposite ) ; <nl> + <nl> + ByteBuffer value = values . get ( j ) ; <nl> + <nl> + if ( value = = null ) <nl> + containsNull = true ; <nl> + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) <nl> + containsUnset = true ; <nl> + <nl> + newComposite . add ( values . get ( j ) ) ; <nl> + } <nl> + } <nl> + } <nl> + size + + ; <nl> + return this ; <nl> + } <nl> + <nl> + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) <nl> + { <nl> + checkUpdateable ( ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; <nl> + <nl> + if ( values . isEmpty ( ) ) <nl> + { <nl> + hasMissingElements = true ; <nl> + } <nl> + else <nl> + { <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; <nl> + <nl> + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) <nl> + { <nl> + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; <nl> + elementsList . add ( newComposite ) ; <nl> + <nl> + List < ByteBuffer > value = values . get ( j ) ; <nl> + <nl> + if ( value . isEmpty ( ) ) <nl> + hasMissingElements = true ; <nl> + <nl> + if ( value . contains ( null ) ) <nl> + containsNull = true ; <nl> + if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) <nl> + containsUnset = true ; <nl> + <nl> + newComposite . addAll ( value ) ; <nl> + } <nl> + } <nl> + size + = values . get ( 0 ) . size ( ) ; <nl> + } <nl> + return this ; <nl> + } <nl> + <nl> + public NavigableSet < Clustering > build ( ) <nl> + { <nl> + built = true ; <nl> + <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> + <nl> + CBuilder builder = CBuilder . create ( comparator ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; <nl> + <nl> + BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> + set . add ( builder . buildWith ( elements ) ) ; <nl> + } <nl> + return set . build ( ) ; <nl> + } <nl> + <nl> + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) <nl> + { <nl> + built = true ; <nl> + <nl> + if ( hasMissingElements ) <nl> + return BTreeSet . empty ( comparator ) ; <nl> + <nl> + CBuilder builder = CBuilder . create ( comparator ) ; <nl> + <nl> + if ( elementsList . isEmpty ( ) ) <nl> + return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; <nl> + <nl> + / / Use a TreeSet to sort and eliminate duplicates <nl> + BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; <nl> + <nl> + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) <nl> + { <nl> + List < ByteBuffer > elements = elementsList . get ( i ) ; <nl> + set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; <nl> + } <nl> + return set . build ( ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> index 03fa1ec . . 9517009 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java <nl> @ @ - 639 , 6 + 639 , 6 @ @ public class BTreeSet < V > implements NavigableSet < V > , List < V > <nl> <nl> public static < V > BTreeSet < V > of ( Comparator < ? super V > comparator , V value ) <nl> { <nl> - return new BTreeSet < > ( BTree . build ( ImmutableList . of ( value ) , UpdateFunction . < V > noOp ( ) ) , comparator ) ; <nl> + return new BTreeSet < > ( BTree . singleton ( value ) , comparator ) ; <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index a468077 . . dd17f11 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 2 
 + * Optimize building of Clustering object when only one is created ( CASSANDRA - 10409 ) 
 * Make index building pluggable ( CASSANDRA - 10681 ) 
 * Add sstable flush observer ( CASSANDRA - 10678 ) 
 * Improve NTS endpoints calculation ( CASSANDRA - 10200 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java b / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java 
 index 107cbd1 . . 0730593 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / PrimaryKeyRestrictionSet . java 
 @ @ - 175 , 10 + 175 , 24 @ @ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions 
 return new PrimaryKeyRestrictionSet ( this , restriction ) ; 
 } 
 
 + / / Whether any of the underlying restriction is an IN 
 + private boolean hasIN ( ) 
 + { 
 + if ( isIN ( ) ) 
 + return true ; 
 + 
 + for ( Restriction restriction : restrictions ) 
 + { 
 + if ( restriction . isIN ( ) ) 
 + return true ; 
 + } 
 + return false ; 
 + } 
 + 
 @ Override 
 public NavigableSet < Clustering > valuesAsClustering ( QueryOptions options ) throws InvalidRequestException 
 { 
 - return appendTo ( MultiCBuilder . create ( comparator ) , options ) . build ( ) ; 
 + return appendTo ( MultiCBuilder . create ( comparator , hasIN ( ) ) , options ) . build ( ) ; 
 } 
 
 @ Override 
 @ @ - 202 , 7 + 216 , 7 @ @ final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions 
 @ Override 
 public NavigableSet < Slice . Bound > boundsAsClustering ( Bound bound , QueryOptions options ) throws InvalidRequestException 
 { 
 - MultiCBuilder builder = MultiCBuilder . create ( comparator ) ; 
 + MultiCBuilder builder = MultiCBuilder . create ( comparator , hasIN ( ) ) ; 
 int keyPosition = 0 ; 
 for ( Restriction r : restrictions ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java b / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java 
 index 700840d . . ccab2dc 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / RestrictionSet . java 
 @ @ - 96 , 13 + 96 , 13 @ @ final class RestrictionSet implements Restrictions , Iterable < Restriction > 
 @ Override 
 public final boolean isEmpty ( ) 
 { 
 - return getColumnDefs ( ) . isEmpty ( ) ; 
 + return restrictions . isEmpty ( ) ; 
 } 
 
 @ Override 
 public final int size ( ) 
 { 
 - return getColumnDefs ( ) . size ( ) ; 
 + return restrictions . size ( ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / db / MultiCBuilder . java b / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 index be654fa . . 8353703 100644 
 - - - a / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 + + + b / src / java / org / apache / cassandra / db / MultiCBuilder . java 
 @ @ - 26 , 44 + 26 , 39 @ @ import org . apache . cassandra . utils . btree . BTreeSet ; 
 / * * 
 * Builder that allow to build multiple Clustering / Slice . Bound at the same time . 
 * / 
 - public class MultiCBuilder 
 + public abstract class MultiCBuilder 
 { 
 / * * 
 * The table comparator . 
 * / 
 - private final ClusteringComparator comparator ; 
 + protected final ClusteringComparator comparator ; 
 
 / * * 
 - * The elements of the clusterings 
 + * The number of clustering elements that have been added . 
 * / 
 - private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; 
 - 
 - / * * 
 - * The number of elements that have been added . 
 - * / 
 - private int size ; 
 + protected int size ; 
 
 / * * 
 * < code > true < / code > if the clusterings have been build , < code > false < / code > otherwise . 
 * / 
 - private boolean built ; 
 + protected boolean built ; 
 
 / * * 
 * < code > true < / code > if the clusterings contains some < code > null < / code > elements . 
 * / 
 - private boolean containsNull ; 
 + protected boolean containsNull ; 
 
 / * * 
 * < code > true < / code > if the composites contains some < code > unset < / code > elements . 
 * / 
 - private boolean containsUnset ; 
 + protected boolean containsUnset ; 
 
 / * * 
 * < code > true < / code > if some empty collection have been added . 
 * / 
 - private boolean hasMissingElements ; 
 + protected boolean hasMissingElements ; 
 
 - private MultiCBuilder ( ClusteringComparator comparator ) 
 + protected MultiCBuilder ( ClusteringComparator comparator ) 
 { 
 this . comparator = comparator ; 
 } 
 @ @ - 71 , 19 + 66 , 11 @ @ public class MultiCBuilder 
 / * * 
 * Creates a new empty { @ code MultiCBuilder } . 
 * / 
 - public static MultiCBuilder create ( ClusteringComparator comparator ) 
 - { 
 - return new MultiCBuilder ( comparator ) ; 
 - } 
 - 
 - / * * 
 - * Checks if this builder is empty . 
 - * 
 - * @ return < code > true < / code > if this builder is empty , < code > false < / code > otherwise . 
 - * / 
 - private boolean isEmpty ( ) 
 + public static MultiCBuilder create ( ClusteringComparator comparator , boolean forMultipleValues ) 
 { 
 - return elementsList . isEmpty ( ) ; 
 + return forMultipleValues 
 + ? new MultiClusteringBuilder ( comparator ) 
 + : new OneClusteringBuilder ( comparator ) ; 
 } 
 
 / * * 
 @ @ - 96 , 25 + 83 , 7 @ @ public class MultiCBuilder 
 * @ param value the value of the next element 
 * @ return this < code > MulitCBuilder < / code > 
 * / 
 - public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - if ( value = = null ) 
 - containsNull = true ; 
 - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 - containsUnset = true ; 
 - 
 - elementsList . get ( i ) . add ( value ) ; 
 - } 
 - size + + ; 
 - return this ; 
 - } 
 + public abstract MultiCBuilder addElementToAll ( ByteBuffer value ) ; 
 
 / * * 
 * Adds individually each of the specified elements to the end of all of the existing clusterings . 
 @ @ - 126 , 42 + 95 , 7 @ @ public class MultiCBuilder 
 * @ param values the elements to add 
 * @ return this < code > CompositeBuilder < / code > 
 * / 
 - public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 - 
 - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 - { 
 - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 - elementsList . add ( newComposite ) ; 
 - 
 - ByteBuffer value = values . get ( j ) ; 
 - 
 - if ( value = = null ) 
 - containsNull = true ; 
 - if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 - containsUnset = true ; 
 - 
 - newComposite . add ( values . get ( j ) ) ; 
 - } 
 - } 
 - } 
 - size + + ; 
 - return this ; 
 - } 
 + public abstract MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) ; 
 
 / * * 
 * Adds individually each of the specified list of elements to the end of all of the existing composites . 
 @ @ - 173 , 44 + 107 , 12 @ @ public class MultiCBuilder 
 * @ param values the elements to add 
 * @ return this < code > CompositeBuilder < / code > 
 * / 
 - public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 - { 
 - checkUpdateable ( ) ; 
 - 
 - if ( isEmpty ( ) ) 
 - elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 - 
 - if ( values . isEmpty ( ) ) 
 - { 
 - hasMissingElements = true ; 
 - } 
 - else 
 - { 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 - { 
 - List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 + public abstract MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) ; 
 
 - for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 - { 
 - List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 - elementsList . add ( newComposite ) ; 
 - 
 - List < ByteBuffer > value = values . get ( j ) ; 
 - 
 - if ( value . isEmpty ( ) ) 
 - hasMissingElements = true ; 
 - 
 - if ( value . contains ( null ) ) 
 - containsNull = true ; 
 - if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) 
 - containsUnset = true ; 
 - 
 - newComposite . addAll ( value ) ; 
 - } 
 - } 
 - size + = values . get ( 0 ) . size ( ) ; 
 - } 
 - return this ; 
 + protected void checkUpdateable ( ) 
 + { 
 + if ( ! hasRemaining ( ) | | built ) 
 + throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; 
 } 
 
 / * * 
 @ @ - 257 , 68 + 159 , 260 @ @ public class MultiCBuilder 
 * 
 * @ return the clusterings 
 * / 
 - public NavigableSet < Clustering > build ( ) 
 + public abstract NavigableSet < Clustering > build ( ) ; 
 + 
 + / * * 
 + * Builds the < code > clusterings < / code > with the specified EOC . 
 + * 
 + * @ return the clusterings 
 + * / 
 + public abstract NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) ; 
 + 
 + / * * 
 + * Checks if some elements can still be added to the clusterings . 
 + * 
 + * @ return < code > true < / code > if it is possible to add more elements to the clusterings , < code > false < / code > otherwise . 
 + * / 
 + public boolean hasRemaining ( ) 
 { 
 - built = true ; 
 + return remainingCount ( ) > 0 ; 
 + } 
 
 - if ( hasMissingElements ) 
 - return BTreeSet . empty ( comparator ) ; 
 + / * * 
 + * Specialization of MultiCBuilder when we know only one clustering / bound is created . 
 + * / 
 + private static class OneClusteringBuilder extends MultiCBuilder 
 + { 
 + / * * 
 + * The elements of the clusterings 
 + * / 
 + private final ByteBuffer [ ] elements ; 
 + 
 + public OneClusteringBuilder ( ClusteringComparator comparator ) 
 + { 
 + super ( comparator ) ; 
 + this . elements = new ByteBuffer [ comparator . size ( ) ] ; 
 + } 
 + 
 + public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 + { 
 + checkUpdateable ( ) ; 
 
 - CBuilder builder = CBuilder . create ( comparator ) ; 
 + if ( value = = null ) 
 + containsNull = true ; 
 + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 + containsUnset = true ; 
 
 - if ( elementsList . isEmpty ( ) ) 
 - return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; 
 + elements [ size + + ] = value ; 
 + return this ; 
 + } 
 
 - BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 { 
 - List < ByteBuffer > elements = elementsList . get ( i ) ; 
 - set . add ( builder . buildWith ( elements ) ) ; 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + return this ; 
 + } 
 + 
 + assert values . size ( ) = = 1 ; 
 + 
 + return addElementToAll ( values . get ( 0 ) ) ; 
 } 
 - return set . build ( ) ; 
 - } 
 
 - / * * 
 - * Builds the < code > clusterings < / code > with the specified EOC . 
 - * 
 - * @ return the clusterings 
 - * / 
 - public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 - { 
 - built = true ; 
 + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 + { 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + return this ; 
 + } 
 
 - if ( hasMissingElements ) 
 - return BTreeSet . empty ( comparator ) ; 
 + assert values . size ( ) = = 1 ; 
 + return addEachElementToAll ( values . get ( 0 ) ) ; 
 + } 
 
 - CBuilder builder = CBuilder . create ( comparator ) ; 
 + public NavigableSet < Clustering > build ( ) 
 + { 
 + built = true ; 
 
 - if ( elementsList . isEmpty ( ) ) 
 - return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 
 - / / Use a TreeSet to sort and eliminate duplicates 
 - BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; 
 + return BTreeSet . of ( comparator , size = = 0 ? Clustering . EMPTY : new Clustering ( elements ) ) ; 
 + } 
 
 - for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 { 
 - List < ByteBuffer > elements = elementsList . get ( i ) ; 
 - set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; 
 + built = true ; 
 + 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 + 
 + if ( size = = 0 ) 
 + return BTreeSet . of ( comparator , isStart ? Slice . Bound . BOTTOM : Slice . Bound . TOP ) ; 
 + 
 + ByteBuffer [ ] newValues = size = = elements . length 
 + ? elements 
 + : Arrays . copyOf ( elements , size ) ; 
 + 
 + return BTreeSet . of ( comparator , Slice . Bound . create ( Slice . Bound . boundKind ( isStart , isInclusive ) , newValues ) ) ; 
 } 
 - return set . build ( ) ; 
 } 
 
 / * * 
 - * Checks if some elements can still be added to the clusterings . 
 - * 
 - * @ return < code > true < / code > if it is possible to add more elements to the clusterings , < code > false < / code > otherwise . 
 + * MultiCBuilder implementation actually supporting the creation of multiple clustering / bound . 
 * / 
 - public boolean hasRemaining ( ) 
 + private static class MultiClusteringBuilder extends MultiCBuilder 
 { 
 - return remainingCount ( ) > 0 ; 
 - } 
 + / * * 
 + * The elements of the clusterings 
 + * / 
 + private final List < List < ByteBuffer > > elementsList = new ArrayList < > ( ) ; 
 
 - private void checkUpdateable ( ) 
 - { 
 - if ( ! hasRemaining ( ) | | built ) 
 - throw new IllegalStateException ( " this builder cannot be updated anymore " ) ; 
 + public MultiClusteringBuilder ( ClusteringComparator comparator ) 
 + { 
 + super ( comparator ) ; 
 + } 
 + 
 + public MultiCBuilder addElementToAll ( ByteBuffer value ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + if ( value = = null ) 
 + containsNull = true ; 
 + else if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 + containsUnset = true ; 
 + 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + elementsList . get ( i ) . add ( value ) ; 
 + 
 + size + + ; 
 + return this ; 
 + } 
 + 
 + public MultiCBuilder addEachElementToAll ( List < ByteBuffer > values ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 + 
 + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 + { 
 + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 + elementsList . add ( newComposite ) ; 
 + 
 + ByteBuffer value = values . get ( j ) ; 
 + 
 + if ( value = = null ) 
 + containsNull = true ; 
 + if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) 
 + containsUnset = true ; 
 + 
 + newComposite . add ( values . get ( j ) ) ; 
 + } 
 + } 
 + } 
 + size + + ; 
 + return this ; 
 + } 
 + 
 + public MultiCBuilder addAllElementsToAll ( List < List < ByteBuffer > > values ) 
 + { 
 + checkUpdateable ( ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + elementsList . add ( new ArrayList < ByteBuffer > ( ) ) ; 
 + 
 + if ( values . isEmpty ( ) ) 
 + { 
 + hasMissingElements = true ; 
 + } 
 + else 
 + { 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > oldComposite = elementsList . remove ( 0 ) ; 
 + 
 + for ( int j = 0 , n = values . size ( ) ; j < n ; j + + ) 
 + { 
 + List < ByteBuffer > newComposite = new ArrayList < > ( oldComposite ) ; 
 + elementsList . add ( newComposite ) ; 
 + 
 + List < ByteBuffer > value = values . get ( j ) ; 
 + 
 + if ( value . isEmpty ( ) ) 
 + hasMissingElements = true ; 
 + 
 + if ( value . contains ( null ) ) 
 + containsNull = true ; 
 + if ( value . contains ( ByteBufferUtil . UNSET _ BYTE _ BUFFER ) ) 
 + containsUnset = true ; 
 + 
 + newComposite . addAll ( value ) ; 
 + } 
 + } 
 + size + = values . get ( 0 ) . size ( ) ; 
 + } 
 + return this ; 
 + } 
 + 
 + public NavigableSet < Clustering > build ( ) 
 + { 
 + built = true ; 
 + 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 + 
 + CBuilder builder = CBuilder . create ( comparator ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + return BTreeSet . of ( builder . comparator ( ) , builder . build ( ) ) ; 
 + 
 + BTreeSet . Builder < Clustering > set = BTreeSet . builder ( builder . comparator ( ) ) ; 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > elements = elementsList . get ( i ) ; 
 + set . add ( builder . buildWith ( elements ) ) ; 
 + } 
 + return set . build ( ) ; 
 + } 
 + 
 + public NavigableSet < Slice . Bound > buildBound ( boolean isStart , boolean isInclusive ) 
 + { 
 + built = true ; 
 + 
 + if ( hasMissingElements ) 
 + return BTreeSet . empty ( comparator ) ; 
 + 
 + CBuilder builder = CBuilder . create ( comparator ) ; 
 + 
 + if ( elementsList . isEmpty ( ) ) 
 + return BTreeSet . of ( comparator , builder . buildBound ( isStart , isInclusive ) ) ; 
 + 
 + / / Use a TreeSet to sort and eliminate duplicates 
 + BTreeSet . Builder < Slice . Bound > set = BTreeSet . builder ( comparator ) ; 
 + 
 + for ( int i = 0 , m = elementsList . size ( ) ; i < m ; i + + ) 
 + { 
 + List < ByteBuffer > elements = elementsList . get ( i ) ; 
 + set . add ( builder . buildBoundWith ( elements , isStart , isInclusive ) ) ; 
 + } 
 + return set . build ( ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 index 03fa1ec . . 9517009 100644 
 - - - a / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 + + + b / src / java / org / apache / cassandra / utils / btree / BTreeSet . java 
 @ @ - 639 , 6 + 639 , 6 @ @ public class BTreeSet < V > implements NavigableSet < V > , List < V > 
 
 public static < V > BTreeSet < V > of ( Comparator < ? super V > comparator , V value ) 
 { 
 - return new BTreeSet < > ( BTree . build ( ImmutableList . of ( value ) , UpdateFunction . < V > noOp ( ) ) , comparator ) ; 
 + return new BTreeSet < > ( BTree . singleton ( value ) , comparator ) ; 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
