BLEU SCORE: 0.028465126651392333

TEST MSG: Reduce heap spent when receiving many SSTables
GENERATED MSG: Make sure unfinished compaction files are removed .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d0f1613 . . ff139c4 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 3 <nl> + * Reduce heap spent when receiving many SSTables ( CASSANDRA - 10797 ) <nl> * Add back support for 3rd party auth providers to bulk loader ( CASSANDRA - 10873 ) <nl> * Eliminate the dependency on jgrapht for UDT resolution ( CASSANDRA - 10653 ) <nl> * ( Hadoop ) Close Clusters and Sessions in Hadoop Input / Output classes ( CASSANDRA - 1837 ) <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> index 0230d14 . . 92a14d1 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java <nl> @ @ - 72 , 7 + 72 , 7 @ @ public class StreamReceiveTask extends StreamTask <nl> private boolean done = false ; <nl> <nl> / / holds references to SSTables received <nl> - protected Collection < SSTableMultiWriter > sstables ; <nl> + protected Collection < SSTableReader > sstables ; <nl> <nl> public StreamReceiveTask ( StreamSession session , UUID cfId , int totalFiles , long totalSize ) <nl> { <nl> @ @ - 97 , 7 + 97 , 10 @ @ public class StreamReceiveTask extends StreamTask <nl> <nl> assert cfId . equals ( sstable . getCfId ( ) ) ; <nl> <nl> - sstables . add ( sstable ) ; <nl> + Collection < SSTableReader > finished = sstable . finish ( true ) ; <nl> + txn . update ( finished , false ) ; <nl> + sstables . addAll ( finished ) ; <nl> + <nl> if ( sstables . size ( ) = = totalFiles ) <nl> { <nl> done = true ; <nl> @ @ - 134 , 7 + 137 , 6 @ @ public class StreamReceiveTask extends StreamTask <nl> if ( kscf = = null ) <nl> { <nl> / / schema was dropped during streaming <nl> - task . sstables . forEach ( SSTableMultiWriter : : abortOrDie ) ; <nl> task . sstables . clear ( ) ; <nl> task . txn . abort ( ) ; <nl> task . session . taskCompleted ( task ) ; <nl> @ @ - 143 , 15 + 145 , 7 @ @ public class StreamReceiveTask extends StreamTask <nl> cfs = Keyspace . open ( kscf . left ) . getColumnFamilyStore ( kscf . right ) ; <nl> hasViews = ! Iterables . isEmpty ( View . findAll ( kscf . left , kscf . right ) ) ; <nl> <nl> - List < SSTableReader > readers = new ArrayList < > ( ) ; <nl> - for ( SSTableMultiWriter writer : task . sstables ) <nl> - { <nl> - Collection < SSTableReader > newReaders = writer . finish ( true ) ; <nl> - readers . addAll ( newReaders ) ; <nl> - task . txn . update ( newReaders , false ) ; <nl> - } <nl> - <nl> - task . sstables . clear ( ) ; <nl> + Collection < SSTableReader > readers = task . sstables ; <nl> <nl> try ( Refs < SSTableReader > refs = Refs . ref ( readers ) ) <nl> { <nl> @ @ - 245 , 7 + 239 , 6 @ @ public class StreamReceiveTask extends StreamTask <nl> return ; <nl> <nl> done = true ; <nl> - sstables . forEach ( SSTableMultiWriter : : abortOrDie ) ; <nl> txn . abort ( ) ; <nl> sstables . clear ( ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> index bfe7b08 . . 008df06 100644 <nl> - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java <nl> @ @ - 69 , 48 + 69 , 8 @ @ import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> import static org . junit . Assert . * ; <nl> <nl> - public class SSTableRewriterTest extends SchemaLoader <nl> + public class SSTableRewriterTest extends SSTableWriterTestBase <nl> { <nl> - private static final String KEYSPACE = " SSTableRewriterTest " ; <nl> - private static final String CF = " Standard1 " ; <nl> - <nl> - private static Config . DiskAccessMode standardMode ; <nl> - private static Config . DiskAccessMode indexMode ; <nl> - <nl> - @ BeforeClass <nl> - public static void defineSchema ( ) throws ConfigurationException <nl> - { <nl> - if ( FBUtilities . isWindows ( ) ) <nl> - { <nl> - standardMode = DatabaseDescriptor . getDiskAccessMode ( ) ; <nl> - indexMode = DatabaseDescriptor . getIndexAccessMode ( ) ; <nl> - <nl> - DatabaseDescriptor . setDiskAccessMode ( Config . DiskAccessMode . standard ) ; <nl> - DatabaseDescriptor . setIndexAccessMode ( Config . DiskAccessMode . standard ) ; <nl> - } <nl> - <nl> - SchemaLoader . prepareServer ( ) ; <nl> - SchemaLoader . createKeyspace ( KEYSPACE , <nl> - KeyspaceParams . simple ( 1 ) , <nl> - SchemaLoader . standardCFMD ( KEYSPACE , CF ) ) ; <nl> - } <nl> - <nl> - @ AfterClass <nl> - public static void revertDiskAccess ( ) <nl> - { <nl> - DatabaseDescriptor . setDiskAccessMode ( standardMode ) ; <nl> - DatabaseDescriptor . setIndexAccessMode ( indexMode ) ; <nl> - } <nl> - <nl> - @ After <nl> - public void truncateCF ( ) <nl> - { <nl> - Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> - ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; <nl> - store . truncateBlocking ( ) ; <nl> - LifecycleTransaction . waitForDeletions ( ) ; <nl> - } <nl> - <nl> @ Test <nl> public void basicTest ( ) throws InterruptedException <nl> { <nl> @ @ - 239 , 56 + 199 , 6 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> } <nl> <nl> @ Test <nl> - public void testFileRemoval ( ) throws InterruptedException <nl> - { <nl> - Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> - ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; <nl> - truncate ( cfs ) ; <nl> - <nl> - File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; <nl> - LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . WRITE ) ; <nl> - try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) <nl> - { <nl> - for ( int i = 0 ; i < 10000 ; i + + ) <nl> - { <nl> - UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> - for ( int j = 0 ; j < 100 ; j + + ) <nl> - builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> - writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> - } <nl> - <nl> - SSTableReader s = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; <nl> - assert s ! = null ; <nl> - assertFileCounts ( dir . list ( ) ) ; <nl> - for ( int i = 10000 ; i < 20000 ; i + + ) <nl> - { <nl> - UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> - for ( int j = 0 ; j < 100 ; j + + ) <nl> - builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> - writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> - } <nl> - SSTableReader s2 = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; <nl> - assertTrue ( s . last . compareTo ( s2 . last ) < 0 ) ; <nl> - assertFileCounts ( dir . list ( ) ) ; <nl> - s . selfRef ( ) . release ( ) ; <nl> - s2 . selfRef ( ) . release ( ) ; <nl> - / / These checks don ' t work on Windows because the writer has the channel still <nl> - / / open till . abort ( ) is called ( via the builder ) <nl> - if ( ! FBUtilities . isWindows ( ) ) <nl> - { <nl> - LifecycleTransaction . waitForDeletions ( ) ; <nl> - assertFileCounts ( dir . list ( ) ) ; <nl> - } <nl> - writer . abort ( ) ; <nl> - txn . abort ( ) ; <nl> - LifecycleTransaction . waitForDeletions ( ) ; <nl> - int datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> - assertEquals ( datafiles , 0 ) ; <nl> - validateCFS ( cfs ) ; <nl> - } <nl> - } <nl> - <nl> - @ Test <nl> public void testNumberOfFilesAndSizes ( ) throws Exception <nl> { <nl> Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> @ @ - 919 , 16 + 829 , 6 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> } <nl> } <nl> <nl> - public static void truncate ( ColumnFamilyStore cfs ) <nl> - { <nl> - cfs . truncateBlocking ( ) ; <nl> - LifecycleTransaction . waitForDeletions ( ) ; <nl> - Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; <nl> - assertEquals ( 0 , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; <nl> - assertEquals ( 0 , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; <nl> - validateCFS ( cfs ) ; <nl> - } <nl> - <nl> public static SSTableReader writeFile ( ColumnFamilyStore cfs , int count ) <nl> { <nl> return Iterables . getFirst ( writeFiles ( cfs , 1 , count * 5 , count / 100 , 1000 ) , null ) ; <nl> @ @ - 959 , 67 + 859 , 4 @ @ public class SSTableRewriterTest extends SchemaLoader <nl> } <nl> return result ; <nl> } <nl> - <nl> - public static void validateCFS ( ColumnFamilyStore cfs ) <nl> - { <nl> - Set < Integer > liveDescriptors = new HashSet < > ( ) ; <nl> - long spaceUsed = 0 ; <nl> - for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) <nl> - { <nl> - assertFalse ( sstable . isMarkedCompacted ( ) ) ; <nl> - assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; <nl> - liveDescriptors . add ( sstable . descriptor . generation ) ; <nl> - spaceUsed + = sstable . bytesOnDisk ( ) ; <nl> - } <nl> - for ( File dir : cfs . getDirectories ( ) . getCFDirectories ( ) ) <nl> - { <nl> - for ( File f : dir . listFiles ( ) ) <nl> - { <nl> - if ( f . getName ( ) . contains ( " Data " ) ) <nl> - { <nl> - Descriptor d = Descriptor . fromFilename ( f . getAbsolutePath ( ) ) ; <nl> - assertTrue ( d . toString ( ) , liveDescriptors . contains ( d . generation ) ) ; <nl> - } <nl> - } <nl> - } <nl> - assertEquals ( spaceUsed , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; <nl> - assertEquals ( spaceUsed , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; <nl> - assertTrue ( cfs . getTracker ( ) . getCompacting ( ) . isEmpty ( ) ) ; <nl> - } <nl> - <nl> - public static int assertFileCounts ( String [ ] files ) <nl> - { <nl> - int tmplinkcount = 0 ; <nl> - int tmpcount = 0 ; <nl> - int datacount = 0 ; <nl> - for ( String f : files ) <nl> - { <nl> - if ( f . endsWith ( " - CRC . db " ) ) <nl> - continue ; <nl> - if ( f . contains ( " tmplink - " ) ) <nl> - tmplinkcount + + ; <nl> - else if ( f . contains ( " tmp - " ) ) <nl> - tmpcount + + ; <nl> - else if ( f . contains ( " Data " ) ) <nl> - datacount + + ; <nl> - } <nl> - assertEquals ( 0 , tmplinkcount ) ; <nl> - assertEquals ( 0 , tmpcount ) ; <nl> - return datacount ; <nl> - } <nl> - <nl> - public static SSTableWriter getWriter ( ColumnFamilyStore cfs , File directory , LifecycleTransaction txn ) <nl> - { <nl> - String filename = cfs . getSSTablePath ( directory ) ; <nl> - return SSTableWriter . create ( filename , 0 , 0 , new SerializationHeader ( true , cfs . metadata , cfs . metadata . partitionColumns ( ) , EncodingStats . NO _ STATS ) , txn ) ; <nl> - } <nl> - <nl> - public static ByteBuffer random ( int i , int size ) <nl> - { <nl> - byte [ ] bytes = new byte [ size + 4 ] ; <nl> - ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; <nl> - ByteBuffer r = ByteBuffer . wrap ( bytes ) ; <nl> - r . putInt ( 0 , i ) ; <nl> - return r ; <nl> - } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java <nl> new file mode 100644 <nl> index 0000000 . . a73a164 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java <nl> @ @ - 0 , 0 + 1 , 200 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . io . sstable ; <nl> + <nl> + import java . io . File ; <nl> + import java . nio . ByteBuffer ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . UpdateBuilder ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . compaction . OperationType ; <nl> + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableWriter ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class SSTableWriterTest extends SSTableWriterTestBase <nl> + { <nl> + @ Test <nl> + public void testAbortTxnWithOpenEarlyShouldRemoveSSTable ( ) throws InterruptedException <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; <nl> + truncate ( cfs ) ; <nl> + <nl> + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; <nl> + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . WRITE ) ; <nl> + try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) <nl> + { <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + <nl> + SSTableReader s = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; <nl> + assert s ! = null ; <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + for ( int i = 10000 ; i < 20000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + SSTableReader s2 = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; <nl> + assertTrue ( s . last . compareTo ( s2 . last ) < 0 ) ; <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + s . selfRef ( ) . release ( ) ; <nl> + s2 . selfRef ( ) . release ( ) ; <nl> + <nl> + int datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 1 ) ; <nl> + <nl> + / / These checks don ' t work on Windows because the writer has the channel still <nl> + / / open till . abort ( ) is called ( via the builder ) <nl> + if ( ! FBUtilities . isWindows ( ) ) <nl> + { <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + } <nl> + writer . abort ( ) ; <nl> + txn . abort ( ) ; <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 0 ) ; <nl> + validateCFS ( cfs ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + @ Test <nl> + public void testAbortTxnWithClosedWriterShouldRemoveSSTable ( ) throws InterruptedException <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; <nl> + truncate ( cfs ) ; <nl> + <nl> + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; <nl> + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . STREAM ) ; <nl> + try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) <nl> + { <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + for ( int i = 10000 ; i < 20000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + SSTableReader sstable = writer . finish ( true ) ; <nl> + int datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 1 ) ; <nl> + <nl> + sstable . selfRef ( ) . release ( ) ; <nl> + / / These checks don ' t work on Windows because the writer has the channel still <nl> + / / open till . abort ( ) is called ( via the builder ) <nl> + if ( ! FBUtilities . isWindows ( ) ) <nl> + { <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + } <nl> + <nl> + txn . abort ( ) ; <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 0 ) ; <nl> + validateCFS ( cfs ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testAbortTxnWithClosedAndOpenWriterShouldRemoveAllSSTables ( ) throws InterruptedException <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; <nl> + truncate ( cfs ) ; <nl> + <nl> + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; <nl> + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . STREAM ) ; <nl> + <nl> + SSTableWriter writer1 = getWriter ( cfs , dir , txn ) ; <nl> + SSTableWriter writer2 = getWriter ( cfs , dir , txn ) ; <nl> + try <nl> + { <nl> + for ( int i = 0 ; i < 10000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer1 . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + for ( int i = 10000 ; i < 20000 ; i + + ) <nl> + { <nl> + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; <nl> + for ( int j = 0 ; j < 100 ; j + + ) <nl> + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; <nl> + writer2 . append ( builder . build ( ) . unfilteredIterator ( ) ) ; <nl> + } <nl> + SSTableReader sstable = writer1 . finish ( true ) ; <nl> + txn . update ( sstable , false ) ; <nl> + <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + <nl> + int datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 2 ) ; <nl> + <nl> + / / These checks don ' t work on Windows because the writer has the channel still <nl> + / / open till . abort ( ) is called ( via the builder ) <nl> + if ( ! FBUtilities . isWindows ( ) ) <nl> + { <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + assertFileCounts ( dir . list ( ) ) ; <nl> + } <nl> + txn . abort ( ) ; <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + datafiles = assertFileCounts ( dir . list ( ) ) ; <nl> + assertEquals ( datafiles , 0 ) ; <nl> + validateCFS ( cfs ) ; <nl> + } <nl> + finally <nl> + { <nl> + writer1 . close ( ) ; <nl> + writer2 . close ( ) ; <nl> + } <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java <nl> new file mode 100644 <nl> index 0000000 . . 0af743d <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java <nl> @ @ - 0 , 0 + 1 , 166 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . io . sstable ; <nl> + <nl> + import java . io . File ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . HashSet ; <nl> + import java . util . Set ; <nl> + import java . util . concurrent . ThreadLocalRandom ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . google . common . util . concurrent . Uninterruptibles ; <nl> + import org . junit . After ; <nl> + import org . junit . AfterClass ; <nl> + import org . junit . BeforeClass ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . Config ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . SerializationHeader ; <nl> + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; <nl> + import org . apache . cassandra . db . rows . EncodingStats ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> + import org . apache . cassandra . io . sstable . format . SSTableWriter ; <nl> + import org . apache . cassandra . schema . KeyspaceParams ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertFalse ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class SSTableWriterTestBase extends SchemaLoader <nl> + { <nl> + <nl> + protected static final String KEYSPACE = " SSTableRewriterTest " ; <nl> + protected static final String CF = " Standard1 " ; <nl> + <nl> + private static Config . DiskAccessMode standardMode ; <nl> + private static Config . DiskAccessMode indexMode ; <nl> + <nl> + @ BeforeClass <nl> + public static void defineSchema ( ) throws ConfigurationException <nl> + { <nl> + if ( FBUtilities . isWindows ( ) ) <nl> + { <nl> + standardMode = DatabaseDescriptor . getDiskAccessMode ( ) ; <nl> + indexMode = DatabaseDescriptor . getIndexAccessMode ( ) ; <nl> + <nl> + DatabaseDescriptor . setDiskAccessMode ( Config . DiskAccessMode . standard ) ; <nl> + DatabaseDescriptor . setIndexAccessMode ( Config . DiskAccessMode . standard ) ; <nl> + } <nl> + <nl> + SchemaLoader . prepareServer ( ) ; <nl> + SchemaLoader . createKeyspace ( KEYSPACE , <nl> + KeyspaceParams . simple ( 1 ) , <nl> + SchemaLoader . standardCFMD ( KEYSPACE , CF ) ) ; <nl> + } <nl> + <nl> + @ AfterClass <nl> + public static void revertDiskAccess ( ) <nl> + { <nl> + DatabaseDescriptor . setDiskAccessMode ( standardMode ) ; <nl> + DatabaseDescriptor . setIndexAccessMode ( indexMode ) ; <nl> + } <nl> + <nl> + @ After <nl> + public void truncateCF ( ) <nl> + { <nl> + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; <nl> + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; <nl> + store . truncateBlocking ( ) ; <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + } <nl> + <nl> + public static void truncate ( ColumnFamilyStore cfs ) <nl> + { <nl> + cfs . truncateBlocking ( ) ; <nl> + LifecycleTransaction . waitForDeletions ( ) ; <nl> + Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; <nl> + assertEquals ( 0 , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; <nl> + assertEquals ( 0 , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; <nl> + validateCFS ( cfs ) ; <nl> + } <nl> + <nl> + public static void validateCFS ( ColumnFamilyStore cfs ) <nl> + { <nl> + Set < Integer > liveDescriptors = new HashSet < > ( ) ; <nl> + long spaceUsed = 0 ; <nl> + for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) <nl> + { <nl> + assertFalse ( sstable . isMarkedCompacted ( ) ) ; <nl> + assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; <nl> + liveDescriptors . add ( sstable . descriptor . generation ) ; <nl> + spaceUsed + = sstable . bytesOnDisk ( ) ; <nl> + } <nl> + for ( File dir : cfs . getDirectories ( ) . getCFDirectories ( ) ) <nl> + { <nl> + for ( File f : dir . listFiles ( ) ) <nl> + { <nl> + if ( f . getName ( ) . contains ( " Data " ) ) <nl> + { <nl> + Descriptor d = Descriptor . fromFilename ( f . getAbsolutePath ( ) ) ; <nl> + assertTrue ( d . toString ( ) , liveDescriptors . contains ( d . generation ) ) ; <nl> + } <nl> + } <nl> + } <nl> + assertEquals ( spaceUsed , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; <nl> + assertEquals ( spaceUsed , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; <nl> + assertTrue ( cfs . getTracker ( ) . getCompacting ( ) . isEmpty ( ) ) ; <nl> + } <nl> + <nl> + public static SSTableWriter getWriter ( ColumnFamilyStore cfs , File directory , LifecycleTransaction txn ) <nl> + { <nl> + String filename = cfs . getSSTablePath ( directory ) ; <nl> + return SSTableWriter . create ( filename , 0 , 0 , new SerializationHeader ( true , cfs . metadata , cfs . metadata . partitionColumns ( ) , EncodingStats . NO _ STATS ) , txn ) ; <nl> + } <nl> + <nl> + public static ByteBuffer random ( int i , int size ) <nl> + { <nl> + byte [ ] bytes = new byte [ size + 4 ] ; <nl> + ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; <nl> + ByteBuffer r = ByteBuffer . wrap ( bytes ) ; <nl> + r . putInt ( 0 , i ) ; <nl> + return r ; <nl> + } <nl> + <nl> + public static int assertFileCounts ( String [ ] files ) <nl> + { <nl> + int tmplinkcount = 0 ; <nl> + int tmpcount = 0 ; <nl> + int datacount = 0 ; <nl> + for ( String f : files ) <nl> + { <nl> + if ( f . endsWith ( " - CRC . db " ) ) <nl> + continue ; <nl> + if ( f . contains ( " tmplink - " ) ) <nl> + tmplinkcount + + ; <nl> + else if ( f . contains ( " tmp - " ) ) <nl> + tmpcount + + ; <nl> + else if ( f . contains ( " Data " ) ) <nl> + datacount + + ; <nl> + } <nl> + assertEquals ( 0 , tmplinkcount ) ; <nl> + assertEquals ( 0 , tmpcount ) ; <nl> + return datacount ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d0f1613 . . ff139c4 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 3 
 + * Reduce heap spent when receiving many SSTables ( CASSANDRA - 10797 ) 
 * Add back support for 3rd party auth providers to bulk loader ( CASSANDRA - 10873 ) 
 * Eliminate the dependency on jgrapht for UDT resolution ( CASSANDRA - 10653 ) 
 * ( Hadoop ) Close Clusters and Sessions in Hadoop Input / Output classes ( CASSANDRA - 1837 ) 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 index 0230d14 . . 92a14d1 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamReceiveTask . java 
 @ @ - 72 , 7 + 72 , 7 @ @ public class StreamReceiveTask extends StreamTask 
 private boolean done = false ; 
 
 / / holds references to SSTables received 
 - protected Collection < SSTableMultiWriter > sstables ; 
 + protected Collection < SSTableReader > sstables ; 
 
 public StreamReceiveTask ( StreamSession session , UUID cfId , int totalFiles , long totalSize ) 
 { 
 @ @ - 97 , 7 + 97 , 10 @ @ public class StreamReceiveTask extends StreamTask 
 
 assert cfId . equals ( sstable . getCfId ( ) ) ; 
 
 - sstables . add ( sstable ) ; 
 + Collection < SSTableReader > finished = sstable . finish ( true ) ; 
 + txn . update ( finished , false ) ; 
 + sstables . addAll ( finished ) ; 
 + 
 if ( sstables . size ( ) = = totalFiles ) 
 { 
 done = true ; 
 @ @ - 134 , 7 + 137 , 6 @ @ public class StreamReceiveTask extends StreamTask 
 if ( kscf = = null ) 
 { 
 / / schema was dropped during streaming 
 - task . sstables . forEach ( SSTableMultiWriter : : abortOrDie ) ; 
 task . sstables . clear ( ) ; 
 task . txn . abort ( ) ; 
 task . session . taskCompleted ( task ) ; 
 @ @ - 143 , 15 + 145 , 7 @ @ public class StreamReceiveTask extends StreamTask 
 cfs = Keyspace . open ( kscf . left ) . getColumnFamilyStore ( kscf . right ) ; 
 hasViews = ! Iterables . isEmpty ( View . findAll ( kscf . left , kscf . right ) ) ; 
 
 - List < SSTableReader > readers = new ArrayList < > ( ) ; 
 - for ( SSTableMultiWriter writer : task . sstables ) 
 - { 
 - Collection < SSTableReader > newReaders = writer . finish ( true ) ; 
 - readers . addAll ( newReaders ) ; 
 - task . txn . update ( newReaders , false ) ; 
 - } 
 - 
 - task . sstables . clear ( ) ; 
 + Collection < SSTableReader > readers = task . sstables ; 
 
 try ( Refs < SSTableReader > refs = Refs . ref ( readers ) ) 
 { 
 @ @ - 245 , 7 + 239 , 6 @ @ public class StreamReceiveTask extends StreamTask 
 return ; 
 
 done = true ; 
 - sstables . forEach ( SSTableMultiWriter : : abortOrDie ) ; 
 txn . abort ( ) ; 
 sstables . clear ( ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 index bfe7b08 . . 008df06 100644 
 - - - a / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableRewriterTest . java 
 @ @ - 69 , 48 + 69 , 8 @ @ import org . apache . cassandra . utils . UUIDGen ; 
 
 import static org . junit . Assert . * ; 
 
 - public class SSTableRewriterTest extends SchemaLoader 
 + public class SSTableRewriterTest extends SSTableWriterTestBase 
 { 
 - private static final String KEYSPACE = " SSTableRewriterTest " ; 
 - private static final String CF = " Standard1 " ; 
 - 
 - private static Config . DiskAccessMode standardMode ; 
 - private static Config . DiskAccessMode indexMode ; 
 - 
 - @ BeforeClass 
 - public static void defineSchema ( ) throws ConfigurationException 
 - { 
 - if ( FBUtilities . isWindows ( ) ) 
 - { 
 - standardMode = DatabaseDescriptor . getDiskAccessMode ( ) ; 
 - indexMode = DatabaseDescriptor . getIndexAccessMode ( ) ; 
 - 
 - DatabaseDescriptor . setDiskAccessMode ( Config . DiskAccessMode . standard ) ; 
 - DatabaseDescriptor . setIndexAccessMode ( Config . DiskAccessMode . standard ) ; 
 - } 
 - 
 - SchemaLoader . prepareServer ( ) ; 
 - SchemaLoader . createKeyspace ( KEYSPACE , 
 - KeyspaceParams . simple ( 1 ) , 
 - SchemaLoader . standardCFMD ( KEYSPACE , CF ) ) ; 
 - } 
 - 
 - @ AfterClass 
 - public static void revertDiskAccess ( ) 
 - { 
 - DatabaseDescriptor . setDiskAccessMode ( standardMode ) ; 
 - DatabaseDescriptor . setIndexAccessMode ( indexMode ) ; 
 - } 
 - 
 - @ After 
 - public void truncateCF ( ) 
 - { 
 - Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 - ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; 
 - store . truncateBlocking ( ) ; 
 - LifecycleTransaction . waitForDeletions ( ) ; 
 - } 
 - 
 @ Test 
 public void basicTest ( ) throws InterruptedException 
 { 
 @ @ - 239 , 56 + 199 , 6 @ @ public class SSTableRewriterTest extends SchemaLoader 
 } 
 
 @ Test 
 - public void testFileRemoval ( ) throws InterruptedException 
 - { 
 - Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 - ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; 
 - truncate ( cfs ) ; 
 - 
 - File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; 
 - LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . WRITE ) ; 
 - try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) 
 - { 
 - for ( int i = 0 ; i < 10000 ; i + + ) 
 - { 
 - UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 - for ( int j = 0 ; j < 100 ; j + + ) 
 - builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 - writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 - } 
 - 
 - SSTableReader s = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; 
 - assert s ! = null ; 
 - assertFileCounts ( dir . list ( ) ) ; 
 - for ( int i = 10000 ; i < 20000 ; i + + ) 
 - { 
 - UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 - for ( int j = 0 ; j < 100 ; j + + ) 
 - builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 - writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 - } 
 - SSTableReader s2 = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; 
 - assertTrue ( s . last . compareTo ( s2 . last ) < 0 ) ; 
 - assertFileCounts ( dir . list ( ) ) ; 
 - s . selfRef ( ) . release ( ) ; 
 - s2 . selfRef ( ) . release ( ) ; 
 - / / These checks don ' t work on Windows because the writer has the channel still 
 - / / open till . abort ( ) is called ( via the builder ) 
 - if ( ! FBUtilities . isWindows ( ) ) 
 - { 
 - LifecycleTransaction . waitForDeletions ( ) ; 
 - assertFileCounts ( dir . list ( ) ) ; 
 - } 
 - writer . abort ( ) ; 
 - txn . abort ( ) ; 
 - LifecycleTransaction . waitForDeletions ( ) ; 
 - int datafiles = assertFileCounts ( dir . list ( ) ) ; 
 - assertEquals ( datafiles , 0 ) ; 
 - validateCFS ( cfs ) ; 
 - } 
 - } 
 - 
 - @ Test 
 public void testNumberOfFilesAndSizes ( ) throws Exception 
 { 
 Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 @ @ - 919 , 16 + 829 , 6 @ @ public class SSTableRewriterTest extends SchemaLoader 
 } 
 } 
 
 - public static void truncate ( ColumnFamilyStore cfs ) 
 - { 
 - cfs . truncateBlocking ( ) ; 
 - LifecycleTransaction . waitForDeletions ( ) ; 
 - Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; 
 - assertEquals ( 0 , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; 
 - assertEquals ( 0 , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; 
 - validateCFS ( cfs ) ; 
 - } 
 - 
 public static SSTableReader writeFile ( ColumnFamilyStore cfs , int count ) 
 { 
 return Iterables . getFirst ( writeFiles ( cfs , 1 , count * 5 , count / 100 , 1000 ) , null ) ; 
 @ @ - 959 , 67 + 859 , 4 @ @ public class SSTableRewriterTest extends SchemaLoader 
 } 
 return result ; 
 } 
 - 
 - public static void validateCFS ( ColumnFamilyStore cfs ) 
 - { 
 - Set < Integer > liveDescriptors = new HashSet < > ( ) ; 
 - long spaceUsed = 0 ; 
 - for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) 
 - { 
 - assertFalse ( sstable . isMarkedCompacted ( ) ) ; 
 - assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; 
 - liveDescriptors . add ( sstable . descriptor . generation ) ; 
 - spaceUsed + = sstable . bytesOnDisk ( ) ; 
 - } 
 - for ( File dir : cfs . getDirectories ( ) . getCFDirectories ( ) ) 
 - { 
 - for ( File f : dir . listFiles ( ) ) 
 - { 
 - if ( f . getName ( ) . contains ( " Data " ) ) 
 - { 
 - Descriptor d = Descriptor . fromFilename ( f . getAbsolutePath ( ) ) ; 
 - assertTrue ( d . toString ( ) , liveDescriptors . contains ( d . generation ) ) ; 
 - } 
 - } 
 - } 
 - assertEquals ( spaceUsed , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; 
 - assertEquals ( spaceUsed , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; 
 - assertTrue ( cfs . getTracker ( ) . getCompacting ( ) . isEmpty ( ) ) ; 
 - } 
 - 
 - public static int assertFileCounts ( String [ ] files ) 
 - { 
 - int tmplinkcount = 0 ; 
 - int tmpcount = 0 ; 
 - int datacount = 0 ; 
 - for ( String f : files ) 
 - { 
 - if ( f . endsWith ( " - CRC . db " ) ) 
 - continue ; 
 - if ( f . contains ( " tmplink - " ) ) 
 - tmplinkcount + + ; 
 - else if ( f . contains ( " tmp - " ) ) 
 - tmpcount + + ; 
 - else if ( f . contains ( " Data " ) ) 
 - datacount + + ; 
 - } 
 - assertEquals ( 0 , tmplinkcount ) ; 
 - assertEquals ( 0 , tmpcount ) ; 
 - return datacount ; 
 - } 
 - 
 - public static SSTableWriter getWriter ( ColumnFamilyStore cfs , File directory , LifecycleTransaction txn ) 
 - { 
 - String filename = cfs . getSSTablePath ( directory ) ; 
 - return SSTableWriter . create ( filename , 0 , 0 , new SerializationHeader ( true , cfs . metadata , cfs . metadata . partitionColumns ( ) , EncodingStats . NO _ STATS ) , txn ) ; 
 - } 
 - 
 - public static ByteBuffer random ( int i , int size ) 
 - { 
 - byte [ ] bytes = new byte [ size + 4 ] ; 
 - ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; 
 - ByteBuffer r = ByteBuffer . wrap ( bytes ) ; 
 - r . putInt ( 0 , i ) ; 
 - return r ; 
 - } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java 
 new file mode 100644 
 index 0000000 . . a73a164 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTest . java 
 @ @ - 0 , 0 + 1 , 200 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . io . sstable ; 
 + 
 + import java . io . File ; 
 + import java . nio . ByteBuffer ; 
 + 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . UpdateBuilder ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . compaction . OperationType ; 
 + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . io . sstable . format . SSTableWriter ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class SSTableWriterTest extends SSTableWriterTestBase 
 + { 
 + @ Test 
 + public void testAbortTxnWithOpenEarlyShouldRemoveSSTable ( ) throws InterruptedException 
 + { 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; 
 + truncate ( cfs ) ; 
 + 
 + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; 
 + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . WRITE ) ; 
 + try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) 
 + { 
 + for ( int i = 0 ; i < 10000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + 
 + SSTableReader s = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; 
 + assert s ! = null ; 
 + assertFileCounts ( dir . list ( ) ) ; 
 + for ( int i = 10000 ; i < 20000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + SSTableReader s2 = writer . setMaxDataAge ( 1000 ) . openEarly ( ) ; 
 + assertTrue ( s . last . compareTo ( s2 . last ) < 0 ) ; 
 + assertFileCounts ( dir . list ( ) ) ; 
 + s . selfRef ( ) . release ( ) ; 
 + s2 . selfRef ( ) . release ( ) ; 
 + 
 + int datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 1 ) ; 
 + 
 + / / These checks don ' t work on Windows because the writer has the channel still 
 + / / open till . abort ( ) is called ( via the builder ) 
 + if ( ! FBUtilities . isWindows ( ) ) 
 + { 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + assertFileCounts ( dir . list ( ) ) ; 
 + } 
 + writer . abort ( ) ; 
 + txn . abort ( ) ; 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 0 ) ; 
 + validateCFS ( cfs ) ; 
 + } 
 + } 
 + 
 + 
 + @ Test 
 + public void testAbortTxnWithClosedWriterShouldRemoveSSTable ( ) throws InterruptedException 
 + { 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; 
 + truncate ( cfs ) ; 
 + 
 + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; 
 + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . STREAM ) ; 
 + try ( SSTableWriter writer = getWriter ( cfs , dir , txn ) ) 
 + { 
 + for ( int i = 0 ; i < 10000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + 
 + assertFileCounts ( dir . list ( ) ) ; 
 + for ( int i = 10000 ; i < 20000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + SSTableReader sstable = writer . finish ( true ) ; 
 + int datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 1 ) ; 
 + 
 + sstable . selfRef ( ) . release ( ) ; 
 + / / These checks don ' t work on Windows because the writer has the channel still 
 + / / open till . abort ( ) is called ( via the builder ) 
 + if ( ! FBUtilities . isWindows ( ) ) 
 + { 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + assertFileCounts ( dir . list ( ) ) ; 
 + } 
 + 
 + txn . abort ( ) ; 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 0 ) ; 
 + validateCFS ( cfs ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testAbortTxnWithClosedAndOpenWriterShouldRemoveAllSSTables ( ) throws InterruptedException 
 + { 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 + ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; 
 + truncate ( cfs ) ; 
 + 
 + File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; 
 + LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . STREAM ) ; 
 + 
 + SSTableWriter writer1 = getWriter ( cfs , dir , txn ) ; 
 + SSTableWriter writer2 = getWriter ( cfs , dir , txn ) ; 
 + try 
 + { 
 + for ( int i = 0 ; i < 10000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer1 . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + 
 + assertFileCounts ( dir . list ( ) ) ; 
 + for ( int i = 10000 ; i < 20000 ; i + + ) 
 + { 
 + UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , random ( i , 10 ) ) . withTimestamp ( 1 ) ; 
 + for ( int j = 0 ; j < 100 ; j + + ) 
 + builder . newRow ( " " + j ) . add ( " val " , ByteBuffer . allocate ( 1000 ) ) ; 
 + writer2 . append ( builder . build ( ) . unfilteredIterator ( ) ) ; 
 + } 
 + SSTableReader sstable = writer1 . finish ( true ) ; 
 + txn . update ( sstable , false ) ; 
 + 
 + assertFileCounts ( dir . list ( ) ) ; 
 + 
 + int datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 2 ) ; 
 + 
 + / / These checks don ' t work on Windows because the writer has the channel still 
 + / / open till . abort ( ) is called ( via the builder ) 
 + if ( ! FBUtilities . isWindows ( ) ) 
 + { 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + assertFileCounts ( dir . list ( ) ) ; 
 + } 
 + txn . abort ( ) ; 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + datafiles = assertFileCounts ( dir . list ( ) ) ; 
 + assertEquals ( datafiles , 0 ) ; 
 + validateCFS ( cfs ) ; 
 + } 
 + finally 
 + { 
 + writer1 . close ( ) ; 
 + writer2 . close ( ) ; 
 + } 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java 
 new file mode 100644 
 index 0000000 . . 0af743d 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / io / sstable / SSTableWriterTestBase . java 
 @ @ - 0 , 0 + 1 , 166 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . io . sstable ; 
 + 
 + import java . io . File ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . HashSet ; 
 + import java . util . Set ; 
 + import java . util . concurrent . ThreadLocalRandom ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . google . common . util . concurrent . Uninterruptibles ; 
 + import org . junit . After ; 
 + import org . junit . AfterClass ; 
 + import org . junit . BeforeClass ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . Config ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . SerializationHeader ; 
 + import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; 
 + import org . apache . cassandra . db . rows . EncodingStats ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 + import org . apache . cassandra . io . sstable . format . SSTableWriter ; 
 + import org . apache . cassandra . schema . KeyspaceParams ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertFalse ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class SSTableWriterTestBase extends SchemaLoader 
 + { 
 + 
 + protected static final String KEYSPACE = " SSTableRewriterTest " ; 
 + protected static final String CF = " Standard1 " ; 
 + 
 + private static Config . DiskAccessMode standardMode ; 
 + private static Config . DiskAccessMode indexMode ; 
 + 
 + @ BeforeClass 
 + public static void defineSchema ( ) throws ConfigurationException 
 + { 
 + if ( FBUtilities . isWindows ( ) ) 
 + { 
 + standardMode = DatabaseDescriptor . getDiskAccessMode ( ) ; 
 + indexMode = DatabaseDescriptor . getIndexAccessMode ( ) ; 
 + 
 + DatabaseDescriptor . setDiskAccessMode ( Config . DiskAccessMode . standard ) ; 
 + DatabaseDescriptor . setIndexAccessMode ( Config . DiskAccessMode . standard ) ; 
 + } 
 + 
 + SchemaLoader . prepareServer ( ) ; 
 + SchemaLoader . createKeyspace ( KEYSPACE , 
 + KeyspaceParams . simple ( 1 ) , 
 + SchemaLoader . standardCFMD ( KEYSPACE , CF ) ) ; 
 + } 
 + 
 + @ AfterClass 
 + public static void revertDiskAccess ( ) 
 + { 
 + DatabaseDescriptor . setDiskAccessMode ( standardMode ) ; 
 + DatabaseDescriptor . setIndexAccessMode ( indexMode ) ; 
 + } 
 + 
 + @ After 
 + public void truncateCF ( ) 
 + { 
 + Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; 
 + ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; 
 + store . truncateBlocking ( ) ; 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + } 
 + 
 + public static void truncate ( ColumnFamilyStore cfs ) 
 + { 
 + cfs . truncateBlocking ( ) ; 
 + LifecycleTransaction . waitForDeletions ( ) ; 
 + Uninterruptibles . sleepUninterruptibly ( 10L , TimeUnit . MILLISECONDS ) ; 
 + assertEquals ( 0 , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; 
 + assertEquals ( 0 , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; 
 + validateCFS ( cfs ) ; 
 + } 
 + 
 + public static void validateCFS ( ColumnFamilyStore cfs ) 
 + { 
 + Set < Integer > liveDescriptors = new HashSet < > ( ) ; 
 + long spaceUsed = 0 ; 
 + for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) 
 + { 
 + assertFalse ( sstable . isMarkedCompacted ( ) ) ; 
 + assertEquals ( 1 , sstable . selfRef ( ) . globalCount ( ) ) ; 
 + liveDescriptors . add ( sstable . descriptor . generation ) ; 
 + spaceUsed + = sstable . bytesOnDisk ( ) ; 
 + } 
 + for ( File dir : cfs . getDirectories ( ) . getCFDirectories ( ) ) 
 + { 
 + for ( File f : dir . listFiles ( ) ) 
 + { 
 + if ( f . getName ( ) . contains ( " Data " ) ) 
 + { 
 + Descriptor d = Descriptor . fromFilename ( f . getAbsolutePath ( ) ) ; 
 + assertTrue ( d . toString ( ) , liveDescriptors . contains ( d . generation ) ) ; 
 + } 
 + } 
 + } 
 + assertEquals ( spaceUsed , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; 
 + assertEquals ( spaceUsed , cfs . metric . totalDiskSpaceUsed . getCount ( ) ) ; 
 + assertTrue ( cfs . getTracker ( ) . getCompacting ( ) . isEmpty ( ) ) ; 
 + } 
 + 
 + public static SSTableWriter getWriter ( ColumnFamilyStore cfs , File directory , LifecycleTransaction txn ) 
 + { 
 + String filename = cfs . getSSTablePath ( directory ) ; 
 + return SSTableWriter . create ( filename , 0 , 0 , new SerializationHeader ( true , cfs . metadata , cfs . metadata . partitionColumns ( ) , EncodingStats . NO _ STATS ) , txn ) ; 
 + } 
 + 
 + public static ByteBuffer random ( int i , int size ) 
 + { 
 + byte [ ] bytes = new byte [ size + 4 ] ; 
 + ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; 
 + ByteBuffer r = ByteBuffer . wrap ( bytes ) ; 
 + r . putInt ( 0 , i ) ; 
 + return r ; 
 + } 
 + 
 + public static int assertFileCounts ( String [ ] files ) 
 + { 
 + int tmplinkcount = 0 ; 
 + int tmpcount = 0 ; 
 + int datacount = 0 ; 
 + for ( String f : files ) 
 + { 
 + if ( f . endsWith ( " - CRC . db " ) ) 
 + continue ; 
 + if ( f . contains ( " tmplink - " ) ) 
 + tmplinkcount + + ; 
 + else if ( f . contains ( " tmp - " ) ) 
 + tmpcount + + ; 
 + else if ( f . contains ( " Data " ) ) 
 + datacount + + ; 
 + } 
 + assertEquals ( 0 , tmplinkcount ) ; 
 + assertEquals ( 0 , tmpcount ) ; 
 + return datacount ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
