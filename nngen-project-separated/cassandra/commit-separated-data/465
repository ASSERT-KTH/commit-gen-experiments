BLEU SCORE: 0.026279617104084448

TEST MSG: Fix " multiple versions of ant detected . . . " when running ant test
GENERATED MSG: exclude * - sources . jar from the classpath

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e7e0367 . . c27c2b1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 10 <nl> + * Fix " multiple versions of ant detected . . . " when running ant test ( CASSANDRA - 13232 ) <nl> * Coalescing strategy sleeps too much ( CASSANDRA - 13090 ) <nl> * Make sure compaction stats are updated when compaction is interrupted ( Backport from 3 . 0 , CASSANDRA - 12100 ) <nl> * Fix flaky LongLeveledCompactionStrategyTest ( CASSANDRA - 12202 ) <nl> diff - - git a / build . xml b / build . xml <nl> index 53a1b27 . . d815ede 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 147 , 10 + 147 , 12 @ @ <nl> < fileset dir = " $ { build . lib } " > <nl> < include name = " * * / * . jar " / > <nl> < exclude name = " * * / * - sources . jar " / > <nl> + < exclude name = " * * / ant - * . jar " / > <nl> < / fileset > <nl> < fileset dir = " $ { build . dir . lib } " > <nl> < include name = " * * / * . jar " / > <nl> < exclude name = " * * / * - sources . jar " / > <nl> + < exclude name = " * * / ant - * . jar " / > <nl> < / fileset > <nl> < / path > <nl> 	 <nl> @ @ - 1179 , 7 + 1181 , 7 @ @ <nl> debug = " true " <nl> debuglevel = " $ { debuglevel } " <nl> destdir = " $ { test . classes } " <nl> - includeantruntime = " false " <nl> + includeantruntime = " true " <nl> source = " $ { source . version } " <nl> target = " $ { target . version } " > <nl> < classpath >
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index 542b6d6 . . 7ca0000 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 476 , 54 + 476 , 56 @ @ public abstract class ModificationStatement implements CQLStatement <nl> <nl> ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; <nl> <nl> - if ( stmt . isCounter ( ) ) <nl> - throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; <nl> - <nl> - if ( ifNotExists ) <nl> - { <nl> - / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . <nl> - / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . <nl> - assert conditions . isEmpty ( ) ; <nl> - stmt . setIfNotExistCondition ( ) ; <nl> - } <nl> - else <nl> + if ( stmt . hasConditions ( ) ) <nl> { <nl> - for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) <nl> - { <nl> - CFDefinition . Name name = cfDef . get ( entry . left ) ; <nl> - if ( name = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; <nl> - <nl> - / * <nl> - * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists <nl> - * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for <nl> - * now , we just refuse lists , which also save use from having to bother about the read that some <nl> - * list operation involve . <nl> - * / <nl> - if ( name . type instanceof ListType ) <nl> - throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; <nl> + if ( stmt . isCounter ( ) ) <nl> + throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; <nl> <nl> - Operation condition = entry . right . prepare ( name ) ; <nl> - assert ! condition . requiresRead ( ) ; <nl> + if ( attrs . timestamp ! = null ) <nl> + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> <nl> - condition . collectMarkerSpecification ( boundNames ) ; <nl> - <nl> - switch ( name . kind ) <nl> + if ( ifNotExists ) <nl> + { <nl> + / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . <nl> + / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . <nl> + assert conditions . isEmpty ( ) ; <nl> + stmt . setIfNotExistCondition ( ) ; <nl> + } <nl> + else <nl> + { <nl> + for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) <nl> { <nl> - case KEY _ ALIAS : <nl> - case COLUMN _ ALIAS : <nl> - throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; <nl> - case VALUE _ ALIAS : <nl> - case COLUMN _ METADATA : <nl> - stmt . addCondition ( condition ) ; <nl> - break ; <nl> + CFDefinition . Name name = cfDef . get ( entry . left ) ; <nl> + if ( name = = null ) <nl> + throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; <nl> + <nl> + / * <nl> + * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists <nl> + * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for <nl> + * now , we just refuse lists , which also save use from having to bother about the read that some <nl> + * list operation involve . <nl> + * / <nl> + if ( name . type instanceof ListType ) <nl> + throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; <nl> + <nl> + Operation condition = entry . right . prepare ( name ) ; <nl> + assert ! condition . requiresRead ( ) ; <nl> + <nl> + condition . collectMarkerSpecification ( boundNames ) ; <nl> + <nl> + switch ( name . kind ) <nl> + { <nl> + case KEY _ ALIAS : <nl> + case COLUMN _ ALIAS : <nl> + throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; <nl> + case VALUE _ ALIAS : <nl> + case COLUMN _ METADATA : <nl> + stmt . addCondition ( condition ) ; <nl> + break ; <nl> + } <nl> } <nl> } <nl> } <nl> - <nl> - if ( stmt . hasConditions ( ) & & attrs . timestamp ! = null ) <nl> - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; <nl> - <nl> return stmt ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e7e0367 . . c27c2b1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 10 
 + * Fix " multiple versions of ant detected . . . " when running ant test ( CASSANDRA - 13232 ) 
 * Coalescing strategy sleeps too much ( CASSANDRA - 13090 ) 
 * Make sure compaction stats are updated when compaction is interrupted ( Backport from 3 . 0 , CASSANDRA - 12100 ) 
 * Fix flaky LongLeveledCompactionStrategyTest ( CASSANDRA - 12202 ) 
 diff - - git a / build . xml b / build . xml 
 index 53a1b27 . . d815ede 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 147 , 10 + 147 , 12 @ @ 
 < fileset dir = " $ { build . lib } " > 
 < include name = " * * / * . jar " / > 
 < exclude name = " * * / * - sources . jar " / > 
 + < exclude name = " * * / ant - * . jar " / > 
 < / fileset > 
 < fileset dir = " $ { build . dir . lib } " > 
 < include name = " * * / * . jar " / > 
 < exclude name = " * * / * - sources . jar " / > 
 + < exclude name = " * * / ant - * . jar " / > 
 < / fileset > 
 < / path > 
 	 
 @ @ - 1179 , 7 + 1181 , 7 @ @ 
 debug = " true " 
 debuglevel = " $ { debuglevel } " 
 destdir = " $ { test . classes } " 
 - includeantruntime = " false " 
 + includeantruntime = " true " 
 source = " $ { source . version } " 
 target = " $ { target . version } " > 
 < classpath >

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index 542b6d6 . . 7ca0000 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 476 , 54 + 476 , 56 @ @ public abstract class ModificationStatement implements CQLStatement 
 
 ModificationStatement stmt = prepareInternal ( cfDef , boundNames ) ; 
 
 - if ( stmt . isCounter ( ) ) 
 - throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; 
 - 
 - if ( ifNotExists ) 
 - { 
 - / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . 
 - / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . 
 - assert conditions . isEmpty ( ) ; 
 - stmt . setIfNotExistCondition ( ) ; 
 - } 
 - else 
 + if ( stmt . hasConditions ( ) ) 
 { 
 - for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) 
 - { 
 - CFDefinition . Name name = cfDef . get ( entry . left ) ; 
 - if ( name = = null ) 
 - throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; 
 - 
 - / * 
 - * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists 
 - * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for 
 - * now , we just refuse lists , which also save use from having to bother about the read that some 
 - * list operation involve . 
 - * / 
 - if ( name . type instanceof ListType ) 
 - throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; 
 + if ( stmt . isCounter ( ) ) 
 + throw new InvalidRequestException ( " Conditional updates are not supported on counter tables " ) ; 
 
 - Operation condition = entry . right . prepare ( name ) ; 
 - assert ! condition . requiresRead ( ) ; 
 + if ( attrs . timestamp ! = null ) 
 + throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 
 - condition . collectMarkerSpecification ( boundNames ) ; 
 - 
 - switch ( name . kind ) 
 + if ( ifNotExists ) 
 + { 
 + / / To have both ' IF NOT EXISTS ' and some other conditions doesn ' t make sense . 
 + / / So far this is enforced by the parser , but let ' s assert it for sanity if ever the parse changes . 
 + assert conditions . isEmpty ( ) ; 
 + stmt . setIfNotExistCondition ( ) ; 
 + } 
 + else 
 + { 
 + for ( Pair < ColumnIdentifier , Operation . RawUpdate > entry : conditions ) 
 { 
 - case KEY _ ALIAS : 
 - case COLUMN _ ALIAS : 
 - throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; 
 - case VALUE _ ALIAS : 
 - case COLUMN _ METADATA : 
 - stmt . addCondition ( condition ) ; 
 - break ; 
 + CFDefinition . Name name = cfDef . get ( entry . left ) ; 
 + if ( name = = null ) 
 + throw new InvalidRequestException ( String . format ( " Unknown identifier % s " , entry . left ) ) ; 
 + 
 + / * 
 + * Lists column names are based on a server - side generated timeuuid . So we can ' t allow lists 
 + * operation or that would yield unexpected results ( update that should apply wouldn ' t ) . So for 
 + * now , we just refuse lists , which also save use from having to bother about the read that some 
 + * list operation involve . 
 + * / 
 + if ( name . type instanceof ListType ) 
 + throw new InvalidRequestException ( String . format ( " List operation ( % s ) are not allowed in conditional updates " , name ) ) ; 
 + 
 + Operation condition = entry . right . prepare ( name ) ; 
 + assert ! condition . requiresRead ( ) ; 
 + 
 + condition . collectMarkerSpecification ( boundNames ) ; 
 + 
 + switch ( name . kind ) 
 + { 
 + case KEY _ ALIAS : 
 + case COLUMN _ ALIAS : 
 + throw new InvalidRequestException ( String . format ( " PRIMARY KEY part % s found in SET part " , entry . left ) ) ; 
 + case VALUE _ ALIAS : 
 + case COLUMN _ METADATA : 
 + stmt . addCondition ( condition ) ; 
 + break ; 
 + } 
 } 
 } 
 } 
 - 
 - if ( stmt . hasConditions ( ) & & attrs . timestamp ! = null ) 
 - throw new InvalidRequestException ( " Cannot provide custom timestamp for conditional update " ) ; 
 - 
 return stmt ; 
 } 

