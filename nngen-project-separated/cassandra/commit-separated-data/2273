BLEU SCORE: 0.02383853510228548

TEST MSG: Tolerate min / max cell names of different lengths
GENERATED MSG: merge from 0 . 6

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 378e812 . . fcccccd 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - final <nl> + * Tolerate min / max cell names of different lengths ( CASSANDRA - 7651 ) <nl> * Filter cached results correctly ( CASSANDRA - 7636 ) <nl> * Fix tracing on the new SEPExecutor ( CASSANDRA - 7644 ) <nl> * Remove shuffle and taketoken ( CASSANDRA - 7601 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> index bca4743 . . b9b248d 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java <nl> @ @ - 65 , 8 + 65 , 6 @ @ public class ColumnSlice <nl> <nl> public boolean intersects ( List < ByteBuffer > minCellNames , List < ByteBuffer > maxCellNames , CellNameType comparator , boolean reversed ) <nl> { <nl> - assert minCellNames . size ( ) = = maxCellNames . size ( ) ; <nl> - <nl> Composite sStart = reversed ? finish : start ; <nl> Composite sEnd = reversed ? start : finish ; <nl> <nl> @ @ - 76 , 7 + 74 , 7 @ @ public class ColumnSlice <nl> / / We could safely return true here , but there ' s a minor optimization : if the first component is restricted <nl> / / to a single value , we can check that the second component falls within the min / max for that component <nl> / / ( and repeat for all components ) . <nl> - for ( int i = 0 ; i < minCellNames . size ( ) ; i + + ) <nl> + for ( int i = 0 ; i < minCellNames . size ( ) & & i < maxCellNames . size ( ) ; i + + ) <nl> { <nl> AbstractType < ? > t = comparator . subtype ( i ) ; <nl> ByteBuffer s = i < sStart . size ( ) ? sStart . get ( i ) : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; <nl> @ @ - 101 , 12 + 99 , 29 @ @ public class ColumnSlice <nl> for ( int i = 0 ; i < sstableBounds . size ( ) ; i + + ) <nl> { <nl> if ( i > = sliceBounds . size ( ) ) <nl> + { <nl> + / / When isSliceStart is true , we ' re comparing the end of the slice against the min cell name for the sstable , <nl> + / / so the slice is something like [ ( 1 , 0 ) , ( 1 , 0 ) ] , and the sstable max is something like ( 1 , 0 , 1 ) . <nl> + / / We want to return - 1 ( slice start is smaller than max column name ) so that we say the slice intersects . <nl> + / / The opposite is true when dealing with the end slice . For example , with the same slice and a min <nl> + / / cell name of ( 1 , 0 , 1 ) , we want to return 1 ( slice end is bigger than min column name ) . <nl> return isSliceStart ? - 1 : 1 ; <nl> + } <nl> <nl> int comparison = comparator . subtype ( i ) . compare ( sliceBounds . get ( i ) , sstableBounds . get ( i ) ) ; <nl> if ( comparison ! = 0 ) <nl> return comparison ; <nl> } <nl> + <nl> + / / the slice bound and sstable bound have been equal in all components so far <nl> + if ( sliceBounds . size ( ) > sstableBounds . size ( ) ) <nl> + { <nl> + / / We have the opposite situation from the one described above . With a slice of [ ( 1 , 0 ) , ( 1 , 0 ) ] , <nl> + / / and a min / max cell name of ( 1 ) , we want to say the slice start is smaller than the max and the slice <nl> + / / end is larger than the min . <nl> + return isSliceStart ? - 1 : 1 ; <nl> + } <nl> + <nl> return 0 ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java b / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java <nl> index e24f68b . . 13c0bd0 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java <nl> @ @ - 344 , 7 + 344 , 6 @ @ public class SliceQueryFilter implements IDiskAtomFilter <nl> { <nl> List < ByteBuffer > minColumnNames = sstable . getSSTableMetadata ( ) . minColumnNames ; <nl> List < ByteBuffer > maxColumnNames = sstable . getSSTableMetadata ( ) . maxColumnNames ; <nl> - assert minColumnNames . size ( ) = = maxColumnNames . size ( ) ; <nl> CellNameType comparator = sstable . metadata . comparator ; <nl> <nl> if ( minColumnNames . isEmpty ( ) | | maxColumnNames . isEmpty ( ) ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> index 2dc3744 . . 25fb942 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java <nl> @ @ - 267 , 6 + 267 , 33 @ @ public class ColumnSliceTest <nl> slice = new ColumnSlice ( composite ( 1 , 1 , 2 ) , composite ( 1 , 1 , 3 ) ) ; <nl> assertFalse ( slice . intersects ( columnNames ( 1 , 1 , 0 ) , columnNames ( 2 , 2 , 1 ) , nameType , false ) ) ; <nl> <nl> + / / empty min / max column names <nl> + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 1 ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 1 ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 2 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( 2 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 2 ) , composite ( 3 ) ) ; <nl> + assertFalse ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> <nl> / / basic check on reversed slices <nl> slice = new ColumnSlice ( composite ( 1 , 0 , 0 ) , composite ( 0 , 0 , 0 ) ) ; <nl> @ @ - 280 , 6 + 307 , 45 @ @ public class ColumnSliceTest <nl> } <nl> <nl> @ Test <nl> + public void testDifferentMinMaxLengths ( ) <nl> + { <nl> + List < AbstractType < ? > > types = new ArrayList < > ( ) ; <nl> + types . add ( Int32Type . instance ) ; <nl> + types . add ( Int32Type . instance ) ; <nl> + types . add ( Int32Type . instance ) ; <nl> + CompoundDenseCellNameType nameType = new CompoundDenseCellNameType ( types ) ; <nl> + <nl> + / / slice does intersect <nl> + ColumnSlice slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( 1 ) , columnNames ( 1 , 2 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 1 ) , composite ( ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 1 ) , composite ( 1 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 0 ) , composite ( 1 , 2 , 3 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 1 , 2 , 3 ) , composite ( 2 ) ) ; <nl> + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + / / slice does not intersect <nl> + slice = new ColumnSlice ( composite ( 2 ) , composite ( 3 , 4 , 5 ) ) ; <nl> + assertFalse ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; <nl> + <nl> + slice = new ColumnSlice ( composite ( 0 ) , composite ( 0 , 1 , 2 ) ) ; <nl> + assertFalse ( slice . intersects ( columnNames ( 1 ) , columnNames ( 1 , 2 ) , nameType , false ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> public void testDeoverlapSlices ( ) <nl> { <nl> ColumnSlice [ ] slices ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8d9e2ea . . c97b17f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 7 + 1 , 10 @ @ <nl> dev <nl> * sstable versioning ( CASSANDRA - 389 ) <nl> <nl> - 0 . 6 . 0 - dev <nl> + 0 . 6 . 0 - RC1 <nl> + * fix compaction bucketing bug ( CASSANDRA - 814 ) <nl> + <nl> + 0 . 6 . 0 - beta1 / beta2 <nl> * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) <nl> * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) <nl> * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) <nl> @ @ - 42 , 7 + 45 , 9 @ @ dev <nl> * allow larger numbers of keys ( > 140M ) in a sstable bloom filter <nl> ( CASSANDRA - 790 ) <nl> * include jvm argument improvements from CASSANDRA - 504 in debian package <nl> - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * change streaming chunk size to 32MB to accomodate Windows XP limitations <nl> + ( was 64MB ) ( CASSANDRA - 795 ) <nl> + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) <nl> <nl> <nl> 0 . 5 . 0 final <nl> diff - - git a / build . xml b / build . xml <nl> index ea79876 . . 54ef12d 100644 <nl> - - - a / build . xml <nl> + + + b / build . xml <nl> @ @ - 314 , 6 + 314 , 7 @ @ <nl> < include name = " * * " / > <nl> < exclude name = " build / * * " / > <nl> < exclude name = " src / gen - java / * * " / > <nl> + < exclude name = " interface / avro / * * " / > <nl> < / tarfileset > <nl> < / tar > <nl> < / target > <nl> diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> index fbd5ebb . . 1b5b6b1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return 0 ; <nl> } <nl> logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; <nl> - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> <nl> for ( List < SSTableReader > sstables : buckets ) <nl> @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> / * <nl> * Group files of similar size into buckets . <nl> * / <nl> - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) <nl> + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) <nl> { <nl> Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; <nl> for ( SSTableReader sstable : files ) <nl> @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> / / remove and re - add because adding changes the hash <nl> buckets . remove ( bucket ) ; <nl> - averageSize = ( averageSize + size ) / 2 ; <nl> + long totalSize = bucket . size ( ) * averageSize ; <nl> + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; <nl> bucket . add ( sstable ) ; <nl> buckets . put ( bucket , averageSize ) ; <nl> bFound = true ; <nl> @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> public void run ( ) <nl> { <nl> logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; <nl> - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> updateEstimateFor ( cfs , buckets ) ; <nl> } <nl> } ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 378e812 . . fcccccd 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - final 
 + * Tolerate min / max cell names of different lengths ( CASSANDRA - 7651 ) 
 * Filter cached results correctly ( CASSANDRA - 7636 ) 
 * Fix tracing on the new SEPExecutor ( CASSANDRA - 7644 ) 
 * Remove shuffle and taketoken ( CASSANDRA - 7601 ) 
 diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 index bca4743 . . b9b248d 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 + + + b / src / java / org / apache / cassandra / db / filter / ColumnSlice . java 
 @ @ - 65 , 8 + 65 , 6 @ @ public class ColumnSlice 
 
 public boolean intersects ( List < ByteBuffer > minCellNames , List < ByteBuffer > maxCellNames , CellNameType comparator , boolean reversed ) 
 { 
 - assert minCellNames . size ( ) = = maxCellNames . size ( ) ; 
 - 
 Composite sStart = reversed ? finish : start ; 
 Composite sEnd = reversed ? start : finish ; 
 
 @ @ - 76 , 7 + 74 , 7 @ @ public class ColumnSlice 
 / / We could safely return true here , but there ' s a minor optimization : if the first component is restricted 
 / / to a single value , we can check that the second component falls within the min / max for that component 
 / / ( and repeat for all components ) . 
 - for ( int i = 0 ; i < minCellNames . size ( ) ; i + + ) 
 + for ( int i = 0 ; i < minCellNames . size ( ) & & i < maxCellNames . size ( ) ; i + + ) 
 { 
 AbstractType < ? > t = comparator . subtype ( i ) ; 
 ByteBuffer s = i < sStart . size ( ) ? sStart . get ( i ) : ByteBufferUtil . EMPTY _ BYTE _ BUFFER ; 
 @ @ - 101 , 12 + 99 , 29 @ @ public class ColumnSlice 
 for ( int i = 0 ; i < sstableBounds . size ( ) ; i + + ) 
 { 
 if ( i > = sliceBounds . size ( ) ) 
 + { 
 + / / When isSliceStart is true , we ' re comparing the end of the slice against the min cell name for the sstable , 
 + / / so the slice is something like [ ( 1 , 0 ) , ( 1 , 0 ) ] , and the sstable max is something like ( 1 , 0 , 1 ) . 
 + / / We want to return - 1 ( slice start is smaller than max column name ) so that we say the slice intersects . 
 + / / The opposite is true when dealing with the end slice . For example , with the same slice and a min 
 + / / cell name of ( 1 , 0 , 1 ) , we want to return 1 ( slice end is bigger than min column name ) . 
 return isSliceStart ? - 1 : 1 ; 
 + } 
 
 int comparison = comparator . subtype ( i ) . compare ( sliceBounds . get ( i ) , sstableBounds . get ( i ) ) ; 
 if ( comparison ! = 0 ) 
 return comparison ; 
 } 
 + 
 + / / the slice bound and sstable bound have been equal in all components so far 
 + if ( sliceBounds . size ( ) > sstableBounds . size ( ) ) 
 + { 
 + / / We have the opposite situation from the one described above . With a slice of [ ( 1 , 0 ) , ( 1 , 0 ) ] , 
 + / / and a min / max cell name of ( 1 ) , we want to say the slice start is smaller than the max and the slice 
 + / / end is larger than the min . 
 + return isSliceStart ? - 1 : 1 ; 
 + } 
 + 
 return 0 ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java b / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java 
 index e24f68b . . 13c0bd0 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / SliceQueryFilter . java 
 @ @ - 344 , 7 + 344 , 6 @ @ public class SliceQueryFilter implements IDiskAtomFilter 
 { 
 List < ByteBuffer > minColumnNames = sstable . getSSTableMetadata ( ) . minColumnNames ; 
 List < ByteBuffer > maxColumnNames = sstable . getSSTableMetadata ( ) . maxColumnNames ; 
 - assert minColumnNames . size ( ) = = maxColumnNames . size ( ) ; 
 CellNameType comparator = sstable . metadata . comparator ; 
 
 if ( minColumnNames . isEmpty ( ) | | maxColumnNames . isEmpty ( ) ) 
 diff - - git a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 index 2dc3744 . . 25fb942 100644 
 - - - a / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 + + + b / test / unit / org / apache / cassandra / db / filter / ColumnSliceTest . java 
 @ @ - 267 , 6 + 267 , 33 @ @ public class ColumnSliceTest 
 slice = new ColumnSlice ( composite ( 1 , 1 , 2 ) , composite ( 1 , 1 , 3 ) ) ; 
 assertFalse ( slice . intersects ( columnNames ( 1 , 1 , 0 ) , columnNames ( 2 , 2 , 1 ) , nameType , false ) ) ; 
 
 + / / empty min / max column names 
 + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 1 ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 1 ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 2 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( 2 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 2 ) , composite ( 3 ) ) ; 
 + assertFalse ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 
 / / basic check on reversed slices 
 slice = new ColumnSlice ( composite ( 1 , 0 , 0 ) , composite ( 0 , 0 , 0 ) ) ; 
 @ @ - 280 , 6 + 307 , 45 @ @ public class ColumnSliceTest 
 } 
 
 @ Test 
 + public void testDifferentMinMaxLengths ( ) 
 + { 
 + List < AbstractType < ? > > types = new ArrayList < > ( ) ; 
 + types . add ( Int32Type . instance ) ; 
 + types . add ( Int32Type . instance ) ; 
 + types . add ( Int32Type . instance ) ; 
 + CompoundDenseCellNameType nameType = new CompoundDenseCellNameType ( types ) ; 
 + 
 + / / slice does intersect 
 + ColumnSlice slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( 1 ) , columnNames ( 1 , 2 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 1 ) , composite ( ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 1 ) , composite ( 1 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 0 ) , composite ( 1 , 2 , 3 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 1 , 2 , 3 ) , composite ( 2 ) ) ; 
 + assertTrue ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + / / slice does not intersect 
 + slice = new ColumnSlice ( composite ( 2 ) , composite ( 3 , 4 , 5 ) ) ; 
 + assertFalse ( slice . intersects ( columnNames ( ) , columnNames ( 1 ) , nameType , false ) ) ; 
 + 
 + slice = new ColumnSlice ( composite ( 0 ) , composite ( 0 , 1 , 2 ) ) ; 
 + assertFalse ( slice . intersects ( columnNames ( 1 ) , columnNames ( 1 , 2 ) , nameType , false ) ) ; 
 + } 
 + 
 + @ Test 
 public void testDeoverlapSlices ( ) 
 { 
 ColumnSlice [ ] slices ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8d9e2ea . . c97b17f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 7 + 1 , 10 @ @ 
 dev 
 * sstable versioning ( CASSANDRA - 389 ) 
 
 - 0 . 6 . 0 - dev 
 + 0 . 6 . 0 - RC1 
 + * fix compaction bucketing bug ( CASSANDRA - 814 ) 
 + 
 + 0 . 6 . 0 - beta1 / beta2 
 * add batch _ mutate thrift command , deprecating batch _ insert ( CASSANDRA - 336 ) 
 * remove get _ key _ range Thrift API , deprecated in 0 . 5 ( CASSANDRA - 710 ) 
 * add optional login ( ) Thrift call for authentication ( CASSANDRA - 547 ) 
 @ @ - 42 , 7 + 45 , 9 @ @ dev 
 * allow larger numbers of keys ( > 140M ) in a sstable bloom filter 
 ( CASSANDRA - 790 ) 
 * include jvm argument improvements from CASSANDRA - 504 in debian package 
 - * change streaming chunk size to 32MB ( was 64MB ) ( CASSANDRA - 795 ) 
 + * change streaming chunk size to 32MB to accomodate Windows XP limitations 
 + ( was 64MB ) ( CASSANDRA - 795 ) 
 + * fix get _ range _ slice returning results in the wrong order ( CASSANDRA - 781 ) 
 
 
 0 . 5 . 0 final 
 diff - - git a / build . xml b / build . xml 
 index ea79876 . . 54ef12d 100644 
 - - - a / build . xml 
 + + + b / build . xml 
 @ @ - 314 , 6 + 314 , 7 @ @ 
 < include name = " * * " / > 
 < exclude name = " build / * * " / > 
 < exclude name = " src / gen - java / * * " / > 
 + < exclude name = " interface / avro / * * " / > 
 < / tarfileset > 
 < / tar > 
 < / target > 
 diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java 
 index fbd5ebb . . 1b5b6b1 100644 
 - - - a / src / java / org / apache / cassandra / db / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / CompactionManager . java 
 @ @ - 89 , 7 + 89 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return 0 ; 
 } 
 logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; 
 - Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 
 for ( List < SSTableReader > sstables : buckets ) 
 @ @ - 441 , 7 + 441 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 / * 
 * Group files of similar size into buckets . 
 * / 
 - static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) 
 + static Set < List < SSTableReader > > getBuckets ( Iterable < SSTableReader > files , long min ) 
 { 
 Map < List < SSTableReader > , Long > buckets = new HashMap < List < SSTableReader > , Long > ( ) ; 
 for ( SSTableReader sstable : files ) 
 @ @ - 461 , 7 + 461 , 8 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 / / remove and re - add because adding changes the hash 
 buckets . remove ( bucket ) ; 
 - averageSize = ( averageSize + size ) / 2 ; 
 + long totalSize = bucket . size ( ) * averageSize ; 
 + averageSize = ( totalSize + size ) / ( bucket . size ( ) + 1 ) ; 
 bucket . add ( sstable ) ; 
 buckets . put ( bucket , averageSize ) ; 
 bFound = true ; 
 @ @ - 538 , 7 + 539 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 public void run ( ) 
 { 
 logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; 
 - final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + final Set < List < SSTableReader > > buckets = getBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 updateEstimateFor ( cfs , buckets ) ; 
 } 
 } ;
