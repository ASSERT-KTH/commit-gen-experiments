BLEU SCORE: 0.04935157841536379

TEST MSG: Support more concurrent requests in native protocol
GENERATED MSG: Binary protocol : handle asynchronous execution ( better )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 8448ea6 . . 2fc6751 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - rc1 <nl> + * Support more concurrent requests in native protocol ( CASSANDRA - 7231 ) <nl> * Add tab - completion to debian nodetool packaging ( CASSANDRA - 6421 ) <nl> * Change concurrent _ compactors defaults ( CASSANDRA - 7139 ) <nl> * Add PowerShell Windows launch scripts ( CASSANDRA - 7001 ) <nl> diff - - git a / doc / native _ protocol _ v3 . spec b / doc / native _ protocol _ v3 . spec <nl> index 400868c . . 5e9f439 100644 <nl> - - - a / doc / native _ protocol _ v3 . spec <nl> + + + b / doc / native _ protocol _ v3 . spec <nl> @ @ - 48 , 10 + 48 , 10 @ @ Table of Contents <nl> <nl> The CQL binary protocol is a frame based protocol . Frames are defined as : <nl> <nl> - 0 8 16 24 32 <nl> - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> - | version | flags | stream | opcode | <nl> - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + 0 8 16 24 32 40 <nl> + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + | version | flags | stream | opcode | <nl> + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> | length | <nl> + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> | | <nl> @ @ - 62 , 7 + 62 , 7 @ @ Table of Contents <nl> <nl> The protocol is big - endian ( network byte order ) . <nl> <nl> - Each frame contains a fixed size header ( 8 bytes ) followed by a variable size <nl> + Each frame contains a fixed size header ( 9 bytes ) followed by a variable size <nl> body . The header is described in Section 2 . The content of the body depends <nl> on the header opcode value ( the body can in particular be empty for some <nl> opcode values ) . The list of allowed opcode is defined Section 2 . 3 and the <nl> @ @ - 129 , 8 + 129 , 8 @ @ Table of Contents <nl> <nl> 2 . 3 . stream <nl> <nl> - A frame has a stream id ( one signed byte ) . When sending request messages , this <nl> - stream id must be set by the client to a positive byte ( negative stream id <nl> + A frame has a stream id ( a [ short ] value ) . When sending request messages , this <nl> + stream id must be set by the client to a non - negative value ( negative stream id <nl> are reserved for streams initiated by the server ; currently all EVENT messages <nl> ( section 4 . 2 . 6 ) have a streamId of - 1 ) . If a client sends a request message <nl> with the stream id X , it is guaranteed that the stream id of the response to <nl> @ @ - 142 , 13 + 142 , 13 @ @ Table of Contents <nl> writes REQ _ 1 , REQ _ 2 , REQ _ 3 on the wire ( in that order ) , the server might <nl> respond to REQ _ 3 ( or REQ _ 2 ) first . Assigning different stream id to these 3 <nl> requests allows the client to distinguish to which request an received answer <nl> - respond to . As there can only be 128 different simultaneous stream , it is up <nl> + respond to . As there can only be 32768 different simultaneous streams , it is up <nl> to the client to reuse stream id . <nl> <nl> Note that clients are free to use the protocol synchronously ( i . e . wait for <nl> the response to REQ _ N before sending REQ _ N + 1 ) . In that case , the stream id <nl> can be safely set to 0 . Clients should also feel free to use only a subset of <nl> - the 128 maximum possible stream ids if it is simpler for those <nl> + the 32768 maximum possible stream ids if it is simpler for those <nl> implementation . <nl> <nl> 2 . 4 . opcode <nl> @ @ - 902 , 6 + 902 , 7 @ @ Table of Contents <nl> bytes ] representing the unknown ID . <nl> <nl> 10 . Changes from v2 <nl> + * stream id is now 2 bytes long ( a [ short ] value ) , so the header is now 1 byte longer ( 9 bytes total ) . <nl> * BATCH messages now have < flags > ( like QUERY and EXECUTE ) and a corresponding optional <nl> < serial _ consistency > parameters ( see Section 4 . 1 . 7 ) . <nl> * User Defined Types and tuple types have to added to ResultSet metadata ( see 4 . 2 . 5 . 2 ) and a <nl> diff - - git a / src / java / org / apache / cassandra / transport / Frame . java b / src / java / org / apache / cassandra / transport / Frame . java <nl> index bec3c96 . . 3e66ff7 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Frame . java <nl> + + + b / src / java / org / apache / cassandra / transport / Frame . java <nl> @ @ - 1 , 4 + 1 , 3 @ @ <nl> - <nl> / * <nl> * Licensed to the Apache Software Foundation ( ASF ) under one <nl> * or more contributor license agreements . See the NOTICE file <nl> @ @ - 39 , 8 + 38 , 19 @ @ public class Frame <nl> public final ByteBuf body ; <nl> <nl> / * * <nl> - * On - wire frame . <nl> - * Frames are defined as : <nl> + * An on - wire frame consists of a header and a body . <nl> + * <nl> + * The header is defined the following way in native protocol version 3 and later : <nl> + * <nl> + * 0 8 16 24 32 40 <nl> + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + * | version | flags | stream | opcode | <nl> + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + * | length | <nl> + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> + * <nl> + * <nl> + * In versions 1 and 2 the header has a smaller ( 1 byte ) stream id , and is thus defined the following way : <nl> * <nl> * 0 8 16 24 32 <nl> * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + <nl> @ @ - 68 , 9 + 78 , 10 @ @ public class Frame <nl> <nl> public static class Header <nl> { <nl> - public static final int LENGTH = 8 ; <nl> + / / 8 bytes in protocol versions 1 and 2 , 8 bytes in protocol version 3 and later <nl> + public static final int MODERN _ LENGTH = 9 ; <nl> + public static final int LEGACY _ LENGTH = 8 ; <nl> <nl> - public static final int BODY _ LENGTH _ OFFSET = 4 ; <nl> public static final int BODY _ LENGTH _ SIZE = 4 ; <nl> <nl> public final int version ; <nl> @ @ - 153 , 34 + 164 , 52 @ @ public class Frame <nl> return ; <nl> } <nl> <nl> - / / Wait until we have read at least the header <nl> - if ( buffer . readableBytes ( ) < Header . LENGTH ) <nl> + / / Wait until we have read at least the short header <nl> + if ( buffer . readableBytes ( ) < Header . LEGACY _ LENGTH ) <nl> return ; <nl> <nl> int idx = buffer . readerIndex ( ) ; <nl> <nl> - int firstByte = buffer . getByte ( idx ) ; <nl> + int firstByte = buffer . getByte ( idx + + ) ; <nl> Message . Direction direction = Message . Direction . extractFromVersion ( firstByte ) ; <nl> int version = firstByte & 0x7F ; <nl> <nl> if ( version > Server . CURRENT _ VERSION ) <nl> throw new ProtocolException ( " Invalid or unsupported protocol version : " + version ) ; <nl> <nl> - int flags = buffer . getByte ( idx + 1 ) ; <nl> - int streamId = buffer . getByte ( idx + 2 ) ; <nl> + / / Wait until we have the complete V3 + header <nl> + if ( version > = Server . VERSION _ 3 & & buffer . readableBytes ( ) < Header . MODERN _ LENGTH ) <nl> + return ; <nl> + <nl> + int flags = buffer . getByte ( idx + + ) ; <nl> + <nl> + int streamId , headerLength ; <nl> + if ( version > = Server . VERSION _ 3 ) <nl> + { <nl> + streamId = buffer . getShort ( idx ) ; <nl> + idx + = 2 ; <nl> + headerLength = Header . MODERN _ LENGTH ; <nl> + } <nl> + else <nl> + { <nl> + streamId = buffer . getByte ( idx ) ; <nl> + idx + + ; <nl> + headerLength = Header . LEGACY _ LENGTH ; <nl> + } <nl> <nl> / / This throws a protocol exceptions if the opcode is unknown <nl> - Message . Type type = Message . Type . fromOpcode ( buffer . getByte ( idx + 3 ) , direction ) ; <nl> + Message . Type type = Message . Type . fromOpcode ( buffer . getByte ( idx + + ) , direction ) ; <nl> <nl> - long bodyLength = buffer . getUnsignedInt ( idx + Header . BODY _ LENGTH _ OFFSET ) ; <nl> + long bodyLength = buffer . getUnsignedInt ( idx ) ; <nl> + idx + = Header . BODY _ LENGTH _ SIZE ; <nl> <nl> if ( bodyLength < 0 ) <nl> { <nl> - buffer . skipBytes ( Header . LENGTH ) ; <nl> + buffer . skipBytes ( headerLength ) ; <nl> throw new ProtocolException ( " Invalid frame body length : " + bodyLength ) ; <nl> } <nl> <nl> - long frameLength = bodyLength + Header . LENGTH ; <nl> + long frameLength = bodyLength + headerLength ; <nl> if ( frameLength > MAX _ FRAME _ LENGTH ) <nl> { <nl> / / Enter the discard mode and discard everything received so far . <nl> @ @ - 193 , 14 + 222 , 13 @ @ public class Frame <nl> return ; <nl> } <nl> <nl> - / / never overflows because it ' s less than the max frame length <nl> - int frameLengthInt = ( int ) frameLength ; <nl> - if ( buffer . readableBytes ( ) < frameLengthInt ) <nl> + if ( buffer . readableBytes ( ) < frameLength ) <nl> return ; <nl> <nl> / / extract body <nl> - ByteBuf body = CBUtil . allocator . buffer ( ( int ) bodyLength ) . writeBytes ( buffer . duplicate ( ) . slice ( idx + Header . LENGTH , ( int ) bodyLength ) ) ; <nl> - buffer . readerIndex ( idx + frameLengthInt ) ; <nl> + ByteBuf body = CBUtil . allocator . buffer ( ( int ) bodyLength ) . writeBytes ( buffer . duplicate ( ) . slice ( idx , ( int ) bodyLength ) ) ; <nl> + idx + = bodyLength ; <nl> + buffer . readerIndex ( idx ) ; <nl> <nl> Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; <nl> if ( connection = = null ) <nl> @ @ - 239 , 14 + 267 , 23 @ @ public class Frame <nl> @ ChannelHandler . Sharable <nl> public static class Encoder extends MessageToMessageEncoder < Frame > <nl> { <nl> - public void encode ( ChannelHandlerContext ctx , Frame frame , List results ) <nl> + public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) <nl> throws IOException <nl> { <nl> - ByteBuf header = CBUtil . allocator . buffer ( Frame . Header . LENGTH ) ; <nl> + int headerLength = frame . header . version > = Server . VERSION _ 3 <nl> + ? Header . MODERN _ LENGTH <nl> + : Header . LEGACY _ LENGTH ; <nl> + ByteBuf header = CBUtil . allocator . buffer ( headerLength ) ; <nl> + <nl> Message . Type type = frame . header . type ; <nl> header . writeByte ( type . direction . addToVersion ( frame . header . version ) ) ; <nl> header . writeByte ( Header . Flag . serialize ( frame . header . flags ) ) ; <nl> - header . writeByte ( frame . header . streamId ) ; <nl> + <nl> + if ( frame . header . version > = Server . VERSION _ 3 ) <nl> + header . writeShort ( frame . header . streamId ) ; <nl> + else <nl> + header . writeByte ( frame . header . streamId ) ; <nl> + <nl> header . writeByte ( type . opcode ) ; <nl> header . writeInt ( frame . body . readableBytes ( ) ) ; <nl> <nl> @ @ - 257 , 7 + 294 , 7 @ @ public class Frame <nl> @ ChannelHandler . Sharable <nl> public static class Decompressor extends MessageToMessageDecoder < Frame > <nl> { <nl> - public void decode ( ChannelHandlerContext ctx , Frame frame , List results ) <nl> + public void decode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) <nl> throws IOException <nl> { <nl> Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; <nl> @ @ - 282 , 7 + 319 , 7 @ @ public class Frame <nl> @ ChannelHandler . Sharable <nl> public static class Compressor extends MessageToMessageEncoder < Frame > <nl> { <nl> - public void encode ( ChannelHandlerContext ctx , Frame frame , List results ) <nl> + public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) <nl> throws IOException <nl> { <nl> Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java <nl> index 9c43f09 . . 2fed889 100644 <nl> - - - a / src / java / org / apache / cassandra / transport / Server . java <nl> + + + b / src / java / org / apache / cassandra / transport / Server . java <nl> @ @ - 62 , 8 + 62 , 8 @ @ public class Server implements CassandraDaemon . Server <nl> <nl> private static final Logger logger = LoggerFactory . getLogger ( Server . class ) ; <nl> <nl> - / * * current version of the native protocol we support * / <nl> - public static final int CURRENT _ VERSION = 2 ; <nl> + public static final int VERSION _ 3 = 3 ; <nl> + public static final int CURRENT _ VERSION = VERSION _ 3 ; <nl> <nl> private final ConnectionTracker connectionTracker = new ConnectionTracker ( ) ; <nl>
NEAREST DIFF (one line): diff - - git a / conf / cassandra - env . sh b / conf / cassandra - env . sh <nl> index 3370a3c . . 2928018 100644 <nl> - - - a / conf / cassandra - env . sh <nl> + + + b / conf / cassandra - env . sh <nl> @ @ - 149 , 7 + 149 , 7 @ @ JMX _ PORT = " 7199 " <nl> JVM _ OPTS = " $ JVM _ OPTS - ea " <nl> <nl> # add the jamm javaagent <nl> - if [ " $ JVM _ VENDOR " ! = " OpenJDK " - o " $ JVM _ VERSION " > " 1 . 6 . 0 " ] \ <nl> + if [ " $ JVM _ VENDOR " ! = " OpenJDK " - o " $ JVM _ VERSION " \ > " 1 . 6 . 0 " ] \ <nl> | | [ " $ JVM _ VERSION " = " 1 . 6 . 0 " - a " $ JVM _ PATCH _ VERSION " - ge 23 ] <nl> then <nl> JVM _ OPTS = " $ JVM _ OPTS - javaagent : $ CASSANDRA _ HOME / lib / jamm - 0 . 2 . 5 . jar "

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 8448ea6 . . 2fc6751 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - rc1 
 + * Support more concurrent requests in native protocol ( CASSANDRA - 7231 ) 
 * Add tab - completion to debian nodetool packaging ( CASSANDRA - 6421 ) 
 * Change concurrent _ compactors defaults ( CASSANDRA - 7139 ) 
 * Add PowerShell Windows launch scripts ( CASSANDRA - 7001 ) 
 diff - - git a / doc / native _ protocol _ v3 . spec b / doc / native _ protocol _ v3 . spec 
 index 400868c . . 5e9f439 100644 
 - - - a / doc / native _ protocol _ v3 . spec 
 + + + b / doc / native _ protocol _ v3 . spec 
 @ @ - 48 , 10 + 48 , 10 @ @ Table of Contents 
 
 The CQL binary protocol is a frame based protocol . Frames are defined as : 
 
 - 0 8 16 24 32 
 - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 - | version | flags | stream | opcode | 
 - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + 0 8 16 24 32 40 
 + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + | version | flags | stream | opcode | 
 + + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 | length | 
 + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 | | 
 @ @ - 62 , 7 + 62 , 7 @ @ Table of Contents 
 
 The protocol is big - endian ( network byte order ) . 
 
 - Each frame contains a fixed size header ( 8 bytes ) followed by a variable size 
 + Each frame contains a fixed size header ( 9 bytes ) followed by a variable size 
 body . The header is described in Section 2 . The content of the body depends 
 on the header opcode value ( the body can in particular be empty for some 
 opcode values ) . The list of allowed opcode is defined Section 2 . 3 and the 
 @ @ - 129 , 8 + 129 , 8 @ @ Table of Contents 
 
 2 . 3 . stream 
 
 - A frame has a stream id ( one signed byte ) . When sending request messages , this 
 - stream id must be set by the client to a positive byte ( negative stream id 
 + A frame has a stream id ( a [ short ] value ) . When sending request messages , this 
 + stream id must be set by the client to a non - negative value ( negative stream id 
 are reserved for streams initiated by the server ; currently all EVENT messages 
 ( section 4 . 2 . 6 ) have a streamId of - 1 ) . If a client sends a request message 
 with the stream id X , it is guaranteed that the stream id of the response to 
 @ @ - 142 , 13 + 142 , 13 @ @ Table of Contents 
 writes REQ _ 1 , REQ _ 2 , REQ _ 3 on the wire ( in that order ) , the server might 
 respond to REQ _ 3 ( or REQ _ 2 ) first . Assigning different stream id to these 3 
 requests allows the client to distinguish to which request an received answer 
 - respond to . As there can only be 128 different simultaneous stream , it is up 
 + respond to . As there can only be 32768 different simultaneous streams , it is up 
 to the client to reuse stream id . 
 
 Note that clients are free to use the protocol synchronously ( i . e . wait for 
 the response to REQ _ N before sending REQ _ N + 1 ) . In that case , the stream id 
 can be safely set to 0 . Clients should also feel free to use only a subset of 
 - the 128 maximum possible stream ids if it is simpler for those 
 + the 32768 maximum possible stream ids if it is simpler for those 
 implementation . 
 
 2 . 4 . opcode 
 @ @ - 902 , 6 + 902 , 7 @ @ Table of Contents 
 bytes ] representing the unknown ID . 
 
 10 . Changes from v2 
 + * stream id is now 2 bytes long ( a [ short ] value ) , so the header is now 1 byte longer ( 9 bytes total ) . 
 * BATCH messages now have < flags > ( like QUERY and EXECUTE ) and a corresponding optional 
 < serial _ consistency > parameters ( see Section 4 . 1 . 7 ) . 
 * User Defined Types and tuple types have to added to ResultSet metadata ( see 4 . 2 . 5 . 2 ) and a 
 diff - - git a / src / java / org / apache / cassandra / transport / Frame . java b / src / java / org / apache / cassandra / transport / Frame . java 
 index bec3c96 . . 3e66ff7 100644 
 - - - a / src / java / org / apache / cassandra / transport / Frame . java 
 + + + b / src / java / org / apache / cassandra / transport / Frame . java 
 @ @ - 1 , 4 + 1 , 3 @ @ 
 - 
 / * 
 * Licensed to the Apache Software Foundation ( ASF ) under one 
 * or more contributor license agreements . See the NOTICE file 
 @ @ - 39 , 8 + 38 , 19 @ @ public class Frame 
 public final ByteBuf body ; 
 
 / * * 
 - * On - wire frame . 
 - * Frames are defined as : 
 + * An on - wire frame consists of a header and a body . 
 + * 
 + * The header is defined the following way in native protocol version 3 and later : 
 + * 
 + * 0 8 16 24 32 40 
 + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + * | version | flags | stream | opcode | 
 + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + * | length | 
 + * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 + * 
 + * 
 + * In versions 1 and 2 the header has a smaller ( 1 byte ) stream id , and is thus defined the following way : 
 * 
 * 0 8 16 24 32 
 * + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + - - - - - - - - - + 
 @ @ - 68 , 9 + 78 , 10 @ @ public class Frame 
 
 public static class Header 
 { 
 - public static final int LENGTH = 8 ; 
 + / / 8 bytes in protocol versions 1 and 2 , 8 bytes in protocol version 3 and later 
 + public static final int MODERN _ LENGTH = 9 ; 
 + public static final int LEGACY _ LENGTH = 8 ; 
 
 - public static final int BODY _ LENGTH _ OFFSET = 4 ; 
 public static final int BODY _ LENGTH _ SIZE = 4 ; 
 
 public final int version ; 
 @ @ - 153 , 34 + 164 , 52 @ @ public class Frame 
 return ; 
 } 
 
 - / / Wait until we have read at least the header 
 - if ( buffer . readableBytes ( ) < Header . LENGTH ) 
 + / / Wait until we have read at least the short header 
 + if ( buffer . readableBytes ( ) < Header . LEGACY _ LENGTH ) 
 return ; 
 
 int idx = buffer . readerIndex ( ) ; 
 
 - int firstByte = buffer . getByte ( idx ) ; 
 + int firstByte = buffer . getByte ( idx + + ) ; 
 Message . Direction direction = Message . Direction . extractFromVersion ( firstByte ) ; 
 int version = firstByte & 0x7F ; 
 
 if ( version > Server . CURRENT _ VERSION ) 
 throw new ProtocolException ( " Invalid or unsupported protocol version : " + version ) ; 
 
 - int flags = buffer . getByte ( idx + 1 ) ; 
 - int streamId = buffer . getByte ( idx + 2 ) ; 
 + / / Wait until we have the complete V3 + header 
 + if ( version > = Server . VERSION _ 3 & & buffer . readableBytes ( ) < Header . MODERN _ LENGTH ) 
 + return ; 
 + 
 + int flags = buffer . getByte ( idx + + ) ; 
 + 
 + int streamId , headerLength ; 
 + if ( version > = Server . VERSION _ 3 ) 
 + { 
 + streamId = buffer . getShort ( idx ) ; 
 + idx + = 2 ; 
 + headerLength = Header . MODERN _ LENGTH ; 
 + } 
 + else 
 + { 
 + streamId = buffer . getByte ( idx ) ; 
 + idx + + ; 
 + headerLength = Header . LEGACY _ LENGTH ; 
 + } 
 
 / / This throws a protocol exceptions if the opcode is unknown 
 - Message . Type type = Message . Type . fromOpcode ( buffer . getByte ( idx + 3 ) , direction ) ; 
 + Message . Type type = Message . Type . fromOpcode ( buffer . getByte ( idx + + ) , direction ) ; 
 
 - long bodyLength = buffer . getUnsignedInt ( idx + Header . BODY _ LENGTH _ OFFSET ) ; 
 + long bodyLength = buffer . getUnsignedInt ( idx ) ; 
 + idx + = Header . BODY _ LENGTH _ SIZE ; 
 
 if ( bodyLength < 0 ) 
 { 
 - buffer . skipBytes ( Header . LENGTH ) ; 
 + buffer . skipBytes ( headerLength ) ; 
 throw new ProtocolException ( " Invalid frame body length : " + bodyLength ) ; 
 } 
 
 - long frameLength = bodyLength + Header . LENGTH ; 
 + long frameLength = bodyLength + headerLength ; 
 if ( frameLength > MAX _ FRAME _ LENGTH ) 
 { 
 / / Enter the discard mode and discard everything received so far . 
 @ @ - 193 , 14 + 222 , 13 @ @ public class Frame 
 return ; 
 } 
 
 - / / never overflows because it ' s less than the max frame length 
 - int frameLengthInt = ( int ) frameLength ; 
 - if ( buffer . readableBytes ( ) < frameLengthInt ) 
 + if ( buffer . readableBytes ( ) < frameLength ) 
 return ; 
 
 / / extract body 
 - ByteBuf body = CBUtil . allocator . buffer ( ( int ) bodyLength ) . writeBytes ( buffer . duplicate ( ) . slice ( idx + Header . LENGTH , ( int ) bodyLength ) ) ; 
 - buffer . readerIndex ( idx + frameLengthInt ) ; 
 + ByteBuf body = CBUtil . allocator . buffer ( ( int ) bodyLength ) . writeBytes ( buffer . duplicate ( ) . slice ( idx , ( int ) bodyLength ) ) ; 
 + idx + = bodyLength ; 
 + buffer . readerIndex ( idx ) ; 
 
 Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; 
 if ( connection = = null ) 
 @ @ - 239 , 14 + 267 , 23 @ @ public class Frame 
 @ ChannelHandler . Sharable 
 public static class Encoder extends MessageToMessageEncoder < Frame > 
 { 
 - public void encode ( ChannelHandlerContext ctx , Frame frame , List results ) 
 + public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) 
 throws IOException 
 { 
 - ByteBuf header = CBUtil . allocator . buffer ( Frame . Header . LENGTH ) ; 
 + int headerLength = frame . header . version > = Server . VERSION _ 3 
 + ? Header . MODERN _ LENGTH 
 + : Header . LEGACY _ LENGTH ; 
 + ByteBuf header = CBUtil . allocator . buffer ( headerLength ) ; 
 + 
 Message . Type type = frame . header . type ; 
 header . writeByte ( type . direction . addToVersion ( frame . header . version ) ) ; 
 header . writeByte ( Header . Flag . serialize ( frame . header . flags ) ) ; 
 - header . writeByte ( frame . header . streamId ) ; 
 + 
 + if ( frame . header . version > = Server . VERSION _ 3 ) 
 + header . writeShort ( frame . header . streamId ) ; 
 + else 
 + header . writeByte ( frame . header . streamId ) ; 
 + 
 header . writeByte ( type . opcode ) ; 
 header . writeInt ( frame . body . readableBytes ( ) ) ; 
 
 @ @ - 257 , 7 + 294 , 7 @ @ public class Frame 
 @ ChannelHandler . Sharable 
 public static class Decompressor extends MessageToMessageDecoder < Frame > 
 { 
 - public void decode ( ChannelHandlerContext ctx , Frame frame , List results ) 
 + public void decode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) 
 throws IOException 
 { 
 Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; 
 @ @ - 282 , 7 + 319 , 7 @ @ public class Frame 
 @ ChannelHandler . Sharable 
 public static class Compressor extends MessageToMessageEncoder < Frame > 
 { 
 - public void encode ( ChannelHandlerContext ctx , Frame frame , List results ) 
 + public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) 
 throws IOException 
 { 
 Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / transport / Server . java b / src / java / org / apache / cassandra / transport / Server . java 
 index 9c43f09 . . 2fed889 100644 
 - - - a / src / java / org / apache / cassandra / transport / Server . java 
 + + + b / src / java / org / apache / cassandra / transport / Server . java 
 @ @ - 62 , 8 + 62 , 8 @ @ public class Server implements CassandraDaemon . Server 
 
 private static final Logger logger = LoggerFactory . getLogger ( Server . class ) ; 
 
 - / * * current version of the native protocol we support * / 
 - public static final int CURRENT _ VERSION = 2 ; 
 + public static final int VERSION _ 3 = 3 ; 
 + public static final int CURRENT _ VERSION = VERSION _ 3 ; 
 
 private final ConnectionTracker connectionTracker = new ConnectionTracker ( ) ; 


NEAREST DIFF:
diff - - git a / conf / cassandra - env . sh b / conf / cassandra - env . sh 
 index 3370a3c . . 2928018 100644 
 - - - a / conf / cassandra - env . sh 
 + + + b / conf / cassandra - env . sh 
 @ @ - 149 , 7 + 149 , 7 @ @ JMX _ PORT = " 7199 " 
 JVM _ OPTS = " $ JVM _ OPTS - ea " 
 
 # add the jamm javaagent 
 - if [ " $ JVM _ VENDOR " ! = " OpenJDK " - o " $ JVM _ VERSION " > " 1 . 6 . 0 " ] \ 
 + if [ " $ JVM _ VENDOR " ! = " OpenJDK " - o " $ JVM _ VERSION " \ > " 1 . 6 . 0 " ] \ 
 | | [ " $ JVM _ VERSION " = " 1 . 6 . 0 " - a " $ JVM _ PATCH _ VERSION " - ge 23 ] 
 then 
 JVM _ OPTS = " $ JVM _ OPTS - javaagent : $ CASSANDRA _ HOME / lib / jamm - 0 . 2 . 5 . jar "
