BLEU SCORE: 0.6553609623522635

TEST MSG: Assert the local node is never hinted and make PAXOS commit not hint ( 2 . 2 version )
GENERATED MSG: Assert the local node is never hinted and make PAXOS commit not hint

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index f895139 . . 21c5b27 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 16 , 6 + 16 , 7 @ @ <nl> * Disable reloading of GossipingPropertyFileSnitch ( CASSANDRA - 9474 ) <nl> * Verify tables in pseudo - system keyspaces at startup ( CASSANDRA - 10761 ) <nl> Merged from 2 . 1 : <nl> + * Avoid AssertionError while submitting hint with LWT ( CASSANDRA - 10477 ) <nl> * If CompactionMetadata is not in stats file , use index summary instead ( CASSANDRA - 10676 ) <nl> * Retry sending gossip syn multiple times during shadow round ( CASSANDRA - 8072 ) <nl> * Fix pending range calculation during moves ( CASSANDRA - 10887 ) <nl> diff - - git a / src / java / org / apache / cassandra / net / WriteCallbackInfo . java b / src / java / org / apache / cassandra / net / WriteCallbackInfo . java <nl> index 582298c . . c1fb98d 100644 <nl> - - - a / src / java / org / apache / cassandra / net / WriteCallbackInfo . java <nl> + + + b / src / java / org / apache / cassandra / net / WriteCallbackInfo . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import org . apache . cassandra . db . Mutation ; <nl> import org . apache . cassandra . io . IVersionedSerializer ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . service . paxos . Commit ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> public class WriteCallbackInfo extends CallbackInfo <nl> { <nl> @ @ - 44 , 6 + 45 , 8 @ @ public class WriteCallbackInfo extends CallbackInfo <nl> this . sentMessage = message ; <nl> this . consistencyLevel = consistencyLevel ; <nl> this . allowHints = allowHints ; <nl> + / / Local writes shouldn ' t go through messaging service ( https : / / issues . apache . org / jira / browse / CASSANDRA - 10477 ) <nl> + assert ( ! target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) ; <nl> } <nl> <nl> Mutation mutation ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / AbstractReadExecutor . java b / src / java / org / apache / cassandra / service / AbstractReadExecutor . java <nl> index 3aab12f . . 2bfd059 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AbstractReadExecutor . java <nl> + + + b / src / java / org / apache / cassandra / service / AbstractReadExecutor . java <nl> @ @ - 77 , 7 + 77 , 7 @ @ public abstract class AbstractReadExecutor <nl> <nl> private static boolean isLocalRequest ( InetAddress replica ) <nl> { <nl> - return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) & & StorageProxy . OPTIMIZE _ LOCAL _ REQUESTS ; <nl> + return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> <nl> protected void makeDataRequests ( Iterable < InetAddress > endpoints ) <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 71a3d6b . . 88253e3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 59 , 6 + 59 , 7 @ @ import org . apache . cassandra . locator . LocalStrategy ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . metrics . * ; <nl> import org . apache . cassandra . net . * ; <nl> + import org . apache . cassandra . net . MessagingService . Verb ; <nl> import org . apache . cassandra . service . paxos . * ; <nl> import org . apache . cassandra . tracing . Tracing ; <nl> import org . apache . cassandra . triggers . TriggerExecutor ; <nl> @ @ - 68 , 7 + 69 , 6 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> public static final String MBEAN _ NAME = " org . apache . cassandra . db : type = StorageProxy " ; <nl> private static final Logger logger = LoggerFactory . getLogger ( StorageProxy . class ) ; <nl> - static final boolean OPTIMIZE _ LOCAL _ REQUESTS = true ; / / set to false to test messagingservice path on single node <nl> <nl> public static final String UNREACHABLE = " UNREACHABLE " ; <nl> <nl> @ @ - 497 , 12 + 497 , 20 @ @ public class StorageProxy implements StorageProxyMBean <nl> MessageOut < Commit > message = new MessageOut < Commit > ( MessagingService . Verb . PAXOS _ COMMIT , proposal , Commit . serializer ) ; <nl> for ( InetAddress destination : Iterables . concat ( naturalEndpoints , pendingEndpoints ) ) <nl> { <nl> + <nl> if ( FailureDetector . instance . isAlive ( destination ) ) <nl> { <nl> if ( shouldBlock ) <nl> - MessagingService . instance ( ) . sendRR ( message , destination , responseHandler , shouldHint ) ; <nl> + { <nl> + if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> + commitPaxosLocal ( message , responseHandler ) ; <nl> + else <nl> + MessagingService . instance ( ) . sendRR ( message , destination , responseHandler , shouldHint ) ; <nl> + } <nl> else <nl> + { <nl> MessagingService . instance ( ) . sendOneWay ( message , destination ) ; <nl> + } <nl> } <nl> else if ( shouldHint ) <nl> { <nl> @ @ - 515 , 6 + 523 , 30 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> <nl> / * * <nl> + * Commit a PAXOS task locally , and if the task times out rather then submitting a real hint <nl> + * submit a fake one that executes immediately on the mutation stage , but generates the necessary backpressure <nl> + * signal for hints <nl> + * / <nl> + private static void commitPaxosLocal ( final MessageOut < Commit > message , final AbstractWriteResponseHandler responseHandler ) <nl> + { <nl> + StageManager . getStage ( MessagingService . verbStages . get ( MessagingService . Verb . PAXOS _ COMMIT ) ) . maybeExecuteImmediately ( new LocalMutationRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) <nl> + { <nl> + PaxosState . commit ( message . payload ) ; <nl> + if ( responseHandler ! = null ) <nl> + responseHandler . response ( null ) ; <nl> + } <nl> + <nl> + @ Override <nl> + protected Verb verb ( ) <nl> + { <nl> + return MessagingService . Verb . PAXOS _ COMMIT ; <nl> + } <nl> + } ) ; <nl> + } <nl> + <nl> + / * * <nl> * Use this method to have these Mutations applied <nl> * across all replicas . This method will take care <nl> * of the possibility of a replica being down and hint <nl> @ @ - 718 , 7 + 750 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> for ( InetAddress target : endpoints ) <nl> { <nl> int targetVersion = MessagingService . instance ( ) . getVersion ( target ) ; <nl> - if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) <nl> + if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> { <nl> insertLocal ( message . payload , handler ) ; <nl> } <nl> @ @ - 752 , 7 + 784 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> MessageOut < Mutation > message = mutation . createMessage ( ) ; <nl> for ( InetAddress target : endpoints ) <nl> { <nl> - if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) <nl> + if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> insertLocal ( message . payload , handler ) ; <nl> else <nl> MessagingService . instance ( ) . sendRR ( message , target , handler , false ) ; <nl> @ @ - 875 , 7 + 907 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> * | off | ANY | - - > DO NOT fire hints . And DO NOT wait for them to complete . <nl> * } <nl> * < / pre > <nl> - * <nl> + * <nl> * @ throws OverloadedException if the hints cannot be written / enqueued <nl> * / <nl> public static void sendToHintedEndpoints ( final Mutation mutation , <nl> @ @ - 894 , 20 + 926 , 11 @ @ public class StorageProxy implements StorageProxyMBean <nl> <nl> for ( InetAddress destination : targets ) <nl> { <nl> - / / avoid OOMing due to excess hints . we need to do this check even for " live " nodes , since we can <nl> - / / still generate hints for those if it ' s overloaded or simply dead but not yet known - to - be - dead . <nl> - / / The idea is that if we have over maxHintsInProgress hints in flight , this is probably due to <nl> - / / a small number of nodes causing problems , so we should avoid shutting down writes completely to <nl> - / / healthy nodes . Any node with no hintsInProgress is considered healthy . <nl> - if ( StorageMetrics . totalHintsInProgress . getCount ( ) > maxHintsInProgress <nl> - & & ( getHintsInProgressFor ( destination ) . get ( ) > 0 & & shouldHint ( destination ) ) ) <nl> - { <nl> - throw new OverloadedException ( " Too many in flight hints : " + StorageMetrics . totalHintsInProgress . getCount ( ) ) ; <nl> - } <nl> + checkHintOverload ( destination ) ; <nl> <nl> if ( FailureDetector . instance . isAlive ( destination ) ) <nl> { <nl> - if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) <nl> + if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> { <nl> insertLocal = true ; <nl> } else <nl> @ @ - 958 , 6 + 981 , 22 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> } <nl> <nl> + private static void checkHintOverload ( InetAddress destination ) throws OverloadedException <nl> + { <nl> + / / avoid OOMing due to excess hints . we need to do this check even for " live " nodes , since we can <nl> + / / still generate hints for those if it ' s overloaded or simply dead but not yet known - to - be - dead . <nl> + / / The idea is that if we have over maxHintsInProgress hints in flight , this is probably due to <nl> + / / a small number of nodes causing problems , so we should avoid shutting down writes completely to <nl> + / / healthy nodes . Any node with no hintsInProgress is considered healthy . <nl> + if ( StorageMetrics . totalHintsInProgress . getCount ( ) > maxHintsInProgress <nl> + & & ( getHintsInProgressFor ( destination ) . get ( ) > 0 & & shouldHint ( destination ) ) ) <nl> + { <nl> + throw new OverloadedException ( " Too many in flight hints : " + StorageMetrics . totalHintsInProgress . getCount ( ) + <nl> + " destination : " + destination + <nl> + " destination hints : " + getHintsInProgressFor ( destination ) . get ( ) ) ; <nl> + } <nl> + } <nl> + <nl> private static AtomicInteger getHintsInProgressFor ( InetAddress destination ) <nl> { <nl> try <nl> @ @ - 1077 , 6 + 1116 , 12 @ @ public class StorageProxy implements StorageProxyMBean <nl> responseHandler . onFailure ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> } <nl> } <nl> + <nl> + @ Override <nl> + protected Verb verb ( ) <nl> + { <nl> + return MessagingService . Verb . MUTATION ; <nl> + } <nl> } ) ; <nl> } <nl> <nl> @ @ - 1795 , 8 + 1840 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> handler . assureSufficientLiveNodes ( ) ; <nl> resolver . setSources ( filteredEndpoints ) ; <nl> if ( filteredEndpoints . size ( ) = = 1 <nl> - & & filteredEndpoints . get ( 0 ) . equals ( FBUtilities . getBroadcastAddress ( ) ) <nl> - & & OPTIMIZE _ LOCAL _ REQUESTS ) <nl> + & & filteredEndpoints . get ( 0 ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> { <nl> StageManager . getStage ( Stage . READ ) . execute ( new LocalRangeSliceRunnable ( nodeCmd , handler ) , Tracing . instance . get ( ) ) ; <nl> } <nl> @ @ - 2206 , 9 + 2250 , 11 @ @ public class StorageProxy implements StorageProxyMBean <nl> <nl> public final void run ( ) <nl> { <nl> - if ( System . currentTimeMillis ( ) > constructionTime + DatabaseDescriptor . getTimeout ( MessagingService . Verb . MUTATION ) ) <nl> + final MessagingService . Verb verb = verb ( ) ; <nl> + if ( System . currentTimeMillis ( ) > constructionTime + DatabaseDescriptor . getTimeout ( verb ) ) <nl> { <nl> - MessagingService . instance ( ) . incrementDroppedMessages ( MessagingService . Verb . MUTATION ) ; <nl> + if ( MessagingService . DROPPABLE _ VERBS . contains ( verb ( ) ) ) <nl> + MessagingService . instance ( ) . incrementDroppedMessages ( verb ) ; <nl> HintRunnable runnable = new HintRunnable ( FBUtilities . getBroadcastAddress ( ) ) <nl> { <nl> protected void runMayThrow ( ) throws Exception <nl> @ @ - 2230 , 6 + 2276 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> } <nl> <nl> + abstract protected MessagingService . Verb verb ( ) ; <nl> abstract protected void runMayThrow ( ) throws Exception ; <nl> } <nl> <nl> @ @ - 2324 , 11 + 2371 , 11 @ @ public class StorageProxy implements StorageProxyMBean <nl> public long getReadRepairAttempted ( ) { <nl> return ReadRepairMetrics . attempted . getCount ( ) ; <nl> } <nl> - <nl> + <nl> public long getReadRepairRepairedBlocking ( ) { <nl> return ReadRepairMetrics . repairedBlocking . getCount ( ) ; <nl> } <nl> - <nl> + <nl> public long getReadRepairRepairedBackground ( ) { <nl> return ReadRepairMetrics . repairedBackground . getCount ( ) ; <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index f895139 . . 21c5b27 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 16 , 6 + 16 , 7 @ @ 
 * Disable reloading of GossipingPropertyFileSnitch ( CASSANDRA - 9474 ) 
 * Verify tables in pseudo - system keyspaces at startup ( CASSANDRA - 10761 ) 
 Merged from 2 . 1 : 
 + * Avoid AssertionError while submitting hint with LWT ( CASSANDRA - 10477 ) 
 * If CompactionMetadata is not in stats file , use index summary instead ( CASSANDRA - 10676 ) 
 * Retry sending gossip syn multiple times during shadow round ( CASSANDRA - 8072 ) 
 * Fix pending range calculation during moves ( CASSANDRA - 10887 ) 
 diff - - git a / src / java / org / apache / cassandra / net / WriteCallbackInfo . java b / src / java / org / apache / cassandra / net / WriteCallbackInfo . java 
 index 582298c . . c1fb98d 100644 
 - - - a / src / java / org / apache / cassandra / net / WriteCallbackInfo . java 
 + + + b / src / java / org / apache / cassandra / net / WriteCallbackInfo . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import org . apache . cassandra . db . Mutation ; 
 import org . apache . cassandra . io . IVersionedSerializer ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . service . paxos . Commit ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 
 public class WriteCallbackInfo extends CallbackInfo 
 { 
 @ @ - 44 , 6 + 45 , 8 @ @ public class WriteCallbackInfo extends CallbackInfo 
 this . sentMessage = message ; 
 this . consistencyLevel = consistencyLevel ; 
 this . allowHints = allowHints ; 
 + / / Local writes shouldn ' t go through messaging service ( https : / / issues . apache . org / jira / browse / CASSANDRA - 10477 ) 
 + assert ( ! target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) ; 
 } 
 
 Mutation mutation ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / AbstractReadExecutor . java b / src / java / org / apache / cassandra / service / AbstractReadExecutor . java 
 index 3aab12f . . 2bfd059 100644 
 - - - a / src / java / org / apache / cassandra / service / AbstractReadExecutor . java 
 + + + b / src / java / org / apache / cassandra / service / AbstractReadExecutor . java 
 @ @ - 77 , 7 + 77 , 7 @ @ public abstract class AbstractReadExecutor 
 
 private static boolean isLocalRequest ( InetAddress replica ) 
 { 
 - return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) & & StorageProxy . OPTIMIZE _ LOCAL _ REQUESTS ; 
 + return replica . equals ( FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 
 protected void makeDataRequests ( Iterable < InetAddress > endpoints ) 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 71a3d6b . . 88253e3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 59 , 6 + 59 , 7 @ @ import org . apache . cassandra . locator . LocalStrategy ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . metrics . * ; 
 import org . apache . cassandra . net . * ; 
 + import org . apache . cassandra . net . MessagingService . Verb ; 
 import org . apache . cassandra . service . paxos . * ; 
 import org . apache . cassandra . tracing . Tracing ; 
 import org . apache . cassandra . triggers . TriggerExecutor ; 
 @ @ - 68 , 7 + 69 , 6 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 public static final String MBEAN _ NAME = " org . apache . cassandra . db : type = StorageProxy " ; 
 private static final Logger logger = LoggerFactory . getLogger ( StorageProxy . class ) ; 
 - static final boolean OPTIMIZE _ LOCAL _ REQUESTS = true ; / / set to false to test messagingservice path on single node 
 
 public static final String UNREACHABLE = " UNREACHABLE " ; 
 
 @ @ - 497 , 12 + 497 , 20 @ @ public class StorageProxy implements StorageProxyMBean 
 MessageOut < Commit > message = new MessageOut < Commit > ( MessagingService . Verb . PAXOS _ COMMIT , proposal , Commit . serializer ) ; 
 for ( InetAddress destination : Iterables . concat ( naturalEndpoints , pendingEndpoints ) ) 
 { 
 + 
 if ( FailureDetector . instance . isAlive ( destination ) ) 
 { 
 if ( shouldBlock ) 
 - MessagingService . instance ( ) . sendRR ( message , destination , responseHandler , shouldHint ) ; 
 + { 
 + if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 + commitPaxosLocal ( message , responseHandler ) ; 
 + else 
 + MessagingService . instance ( ) . sendRR ( message , destination , responseHandler , shouldHint ) ; 
 + } 
 else 
 + { 
 MessagingService . instance ( ) . sendOneWay ( message , destination ) ; 
 + } 
 } 
 else if ( shouldHint ) 
 { 
 @ @ - 515 , 6 + 523 , 30 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 
 / * * 
 + * Commit a PAXOS task locally , and if the task times out rather then submitting a real hint 
 + * submit a fake one that executes immediately on the mutation stage , but generates the necessary backpressure 
 + * signal for hints 
 + * / 
 + private static void commitPaxosLocal ( final MessageOut < Commit > message , final AbstractWriteResponseHandler responseHandler ) 
 + { 
 + StageManager . getStage ( MessagingService . verbStages . get ( MessagingService . Verb . PAXOS _ COMMIT ) ) . maybeExecuteImmediately ( new LocalMutationRunnable ( ) 
 + { 
 + public void runMayThrow ( ) 
 + { 
 + PaxosState . commit ( message . payload ) ; 
 + if ( responseHandler ! = null ) 
 + responseHandler . response ( null ) ; 
 + } 
 + 
 + @ Override 
 + protected Verb verb ( ) 
 + { 
 + return MessagingService . Verb . PAXOS _ COMMIT ; 
 + } 
 + } ) ; 
 + } 
 + 
 + / * * 
 * Use this method to have these Mutations applied 
 * across all replicas . This method will take care 
 * of the possibility of a replica being down and hint 
 @ @ - 718 , 7 + 750 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 for ( InetAddress target : endpoints ) 
 { 
 int targetVersion = MessagingService . instance ( ) . getVersion ( target ) ; 
 - if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) 
 + if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 { 
 insertLocal ( message . payload , handler ) ; 
 } 
 @ @ - 752 , 7 + 784 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 MessageOut < Mutation > message = mutation . createMessage ( ) ; 
 for ( InetAddress target : endpoints ) 
 { 
 - if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) 
 + if ( target . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 insertLocal ( message . payload , handler ) ; 
 else 
 MessagingService . instance ( ) . sendRR ( message , target , handler , false ) ; 
 @ @ - 875 , 7 + 907 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 * | off | ANY | - - > DO NOT fire hints . And DO NOT wait for them to complete . 
 * } 
 * < / pre > 
 - * 
 + * 
 * @ throws OverloadedException if the hints cannot be written / enqueued 
 * / 
 public static void sendToHintedEndpoints ( final Mutation mutation , 
 @ @ - 894 , 20 + 926 , 11 @ @ public class StorageProxy implements StorageProxyMBean 
 
 for ( InetAddress destination : targets ) 
 { 
 - / / avoid OOMing due to excess hints . we need to do this check even for " live " nodes , since we can 
 - / / still generate hints for those if it ' s overloaded or simply dead but not yet known - to - be - dead . 
 - / / The idea is that if we have over maxHintsInProgress hints in flight , this is probably due to 
 - / / a small number of nodes causing problems , so we should avoid shutting down writes completely to 
 - / / healthy nodes . Any node with no hintsInProgress is considered healthy . 
 - if ( StorageMetrics . totalHintsInProgress . getCount ( ) > maxHintsInProgress 
 - & & ( getHintsInProgressFor ( destination ) . get ( ) > 0 & & shouldHint ( destination ) ) ) 
 - { 
 - throw new OverloadedException ( " Too many in flight hints : " + StorageMetrics . totalHintsInProgress . getCount ( ) ) ; 
 - } 
 + checkHintOverload ( destination ) ; 
 
 if ( FailureDetector . instance . isAlive ( destination ) ) 
 { 
 - if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) & & OPTIMIZE _ LOCAL _ REQUESTS ) 
 + if ( destination . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 { 
 insertLocal = true ; 
 } else 
 @ @ - 958 , 6 + 981 , 22 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 } 
 
 + private static void checkHintOverload ( InetAddress destination ) throws OverloadedException 
 + { 
 + / / avoid OOMing due to excess hints . we need to do this check even for " live " nodes , since we can 
 + / / still generate hints for those if it ' s overloaded or simply dead but not yet known - to - be - dead . 
 + / / The idea is that if we have over maxHintsInProgress hints in flight , this is probably due to 
 + / / a small number of nodes causing problems , so we should avoid shutting down writes completely to 
 + / / healthy nodes . Any node with no hintsInProgress is considered healthy . 
 + if ( StorageMetrics . totalHintsInProgress . getCount ( ) > maxHintsInProgress 
 + & & ( getHintsInProgressFor ( destination ) . get ( ) > 0 & & shouldHint ( destination ) ) ) 
 + { 
 + throw new OverloadedException ( " Too many in flight hints : " + StorageMetrics . totalHintsInProgress . getCount ( ) + 
 + " destination : " + destination + 
 + " destination hints : " + getHintsInProgressFor ( destination ) . get ( ) ) ; 
 + } 
 + } 
 + 
 private static AtomicInteger getHintsInProgressFor ( InetAddress destination ) 
 { 
 try 
 @ @ - 1077 , 6 + 1116 , 12 @ @ public class StorageProxy implements StorageProxyMBean 
 responseHandler . onFailure ( FBUtilities . getBroadcastAddress ( ) ) ; 
 } 
 } 
 + 
 + @ Override 
 + protected Verb verb ( ) 
 + { 
 + return MessagingService . Verb . MUTATION ; 
 + } 
 } ) ; 
 } 
 
 @ @ - 1795 , 8 + 1840 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 handler . assureSufficientLiveNodes ( ) ; 
 resolver . setSources ( filteredEndpoints ) ; 
 if ( filteredEndpoints . size ( ) = = 1 
 - & & filteredEndpoints . get ( 0 ) . equals ( FBUtilities . getBroadcastAddress ( ) ) 
 - & & OPTIMIZE _ LOCAL _ REQUESTS ) 
 + & & filteredEndpoints . get ( 0 ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 { 
 StageManager . getStage ( Stage . READ ) . execute ( new LocalRangeSliceRunnable ( nodeCmd , handler ) , Tracing . instance . get ( ) ) ; 
 } 
 @ @ - 2206 , 9 + 2250 , 11 @ @ public class StorageProxy implements StorageProxyMBean 
 
 public final void run ( ) 
 { 
 - if ( System . currentTimeMillis ( ) > constructionTime + DatabaseDescriptor . getTimeout ( MessagingService . Verb . MUTATION ) ) 
 + final MessagingService . Verb verb = verb ( ) ; 
 + if ( System . currentTimeMillis ( ) > constructionTime + DatabaseDescriptor . getTimeout ( verb ) ) 
 { 
 - MessagingService . instance ( ) . incrementDroppedMessages ( MessagingService . Verb . MUTATION ) ; 
 + if ( MessagingService . DROPPABLE _ VERBS . contains ( verb ( ) ) ) 
 + MessagingService . instance ( ) . incrementDroppedMessages ( verb ) ; 
 HintRunnable runnable = new HintRunnable ( FBUtilities . getBroadcastAddress ( ) ) 
 { 
 protected void runMayThrow ( ) throws Exception 
 @ @ - 2230 , 6 + 2276 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 } 
 
 + abstract protected MessagingService . Verb verb ( ) ; 
 abstract protected void runMayThrow ( ) throws Exception ; 
 } 
 
 @ @ - 2324 , 11 + 2371 , 11 @ @ public class StorageProxy implements StorageProxyMBean 
 public long getReadRepairAttempted ( ) { 
 return ReadRepairMetrics . attempted . getCount ( ) ; 
 } 
 - 
 + 
 public long getReadRepairRepairedBlocking ( ) { 
 return ReadRepairMetrics . repairedBlocking . getCount ( ) ; 
 } 
 - 
 + 
 public long getReadRepairRepairedBackground ( ) { 
 return ReadRepairMetrics . repairedBackground . getCount ( ) ; 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
