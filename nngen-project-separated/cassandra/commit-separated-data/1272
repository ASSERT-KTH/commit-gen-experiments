BLEU SCORE: 0.027611988917697356

TEST MSG: Custom index expression in SELECT forces index selection
GENERATED MSG: Give more control over building to 2i impls

TEST DIFF (one line): diff - - git a / NEWS . txt b / NEWS . txt <nl> index e4b8663 . . a7e56ec 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 111 , 7 + 111 , 9 @ @ Upgrading <nl> - SizeTieredCompactionStrategy parameter cold _ reads _ to _ omit has been removed . <nl> - The secondary index API has been comprehensively reworked . This will be a breaking <nl> change for any custom index implementations , which should now look to implement <nl> - the new org . apache . cassandra . index . Index interface . <nl> + the new org . apache . cassandra . index . Index interface . New syntax has been added to create <nl> + and query row - based indexes , which are not explicitly linked to a single column in the <nl> + base table . <nl> <nl> <nl> 2 . 2 . 2 <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java b / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java <nl> index 65c1bb3 . . eb91928 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java <nl> @ @ - 21 , 7 + 21 , 7 @ @ package org . apache . cassandra . cql3 . restrictions ; <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . cql3 . * ; <nl> import org . apache . cassandra . db . filter . RowFilter ; <nl> - import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . db . marshal . AbstractType ; <nl> <nl> public class CustomIndexExpression <nl> { <nl> @ @ - 38 , 9 + 38 , 9 @ @ public class CustomIndexExpression <nl> this . valueRaw = value ; <nl> } <nl> <nl> - public void prepareValue ( CFMetaData cfm , VariableSpecifications boundNames ) <nl> + public void prepareValue ( CFMetaData cfm , AbstractType < ? > expressionType , VariableSpecifications boundNames ) <nl> { <nl> - ColumnSpecification spec = new ColumnSpecification ( cfm . ksName , cfm . ksName , valueColId , UTF8Type . instance ) ; <nl> + ColumnSpecification spec = new ColumnSpecification ( cfm . ksName , cfm . ksName , valueColId , expressionType ) ; <nl> value = valueRaw . prepare ( cfm . ksName , spec ) ; <nl> value . collectMarkerSpecification ( boundNames ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> index 1bd4218 . . 1c7db4e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . cql3 . statements . Bound ; <nl> import org . apache . cassandra . cql3 . statements . StatementType ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . RowFilter ; <nl> + import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . dht . * ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . index . Index ; <nl> @ @ - 503 , 7 + 504 , 6 @ @ public final class StatementRestrictions <nl> throw new InvalidRequestException ( IndexRestrictions . MULTIPLE _ EXPRESSIONS ) ; <nl> <nl> CustomIndexExpression expression = expressions . get ( 0 ) ; <nl> - expression . prepareValue ( cfm , boundNames ) ; <nl> <nl> CFName cfName = expression . targetIndex . getCfName ( ) ; <nl> if ( cfName . hasKeyspace ( ) <nl> @ @ - 521 , 9 + 521 , 12 @ @ public final class StatementRestrictions <nl> if ( ! index . getIndexMetadata ( ) . isCustom ( ) ) <nl> throw IndexRestrictions . nonCustomIndexInExpression ( expression . targetIndex ) ; <nl> <nl> - if ( index . customExpressionValueType ( ) = = null ) <nl> + AbstractType < ? > expressionType = index . customExpressionValueType ( ) ; <nl> + if ( expressionType = = null ) <nl> throw IndexRestrictions . customExpressionNotSupported ( expression . targetIndex ) ; <nl> <nl> + expression . prepareValue ( cfm , expressionType , boundNames ) ; <nl> + <nl> indexRestrictions . add ( expression ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> index b04de2a . . 9b15a3e 100644 <nl> - - - a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> + + + b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java <nl> @ @ - 585 , 8 + 585 , 12 @ @ public class SecondaryIndexManager implements IndexRegistry <nl> { <nl> if ( expression . isCustom ( ) ) <nl> { <nl> + / / Only a single custom expression is allowed per query and , if present , <nl> + / / we want to always favour the index specified in such an expression <nl> RowFilter . CustomExpression customExpression = ( RowFilter . CustomExpression ) expression ; <nl> - searchableIndexes . add ( indexes . get ( customExpression . getTargetIndex ( ) . name ) ) ; <nl> + logger . trace ( " Command contains a custom index expression , using target index { } " , customExpression . getTargetIndex ( ) . name ) ; <nl> + Tracing . trace ( " Command contains a custom index expression , using target index { } " , customExpression . getTargetIndex ( ) . name ) ; <nl> + return indexes . get ( customExpression . getTargetIndex ( ) . name ) ; <nl> } <nl> else <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / index / CustomIndexTest . java b / test / unit / org / apache / cassandra / index / CustomIndexTest . java <nl> index ceff839 . . b2c9257 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / CustomIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / CustomIndexTest . java <nl> @ @ - 17 , 6 + 17 , 8 @ @ import org . apache . cassandra . cql3 . statements . SelectStatement ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . ReadCommand ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> import org . apache . cassandra . schema . Indexes ; <nl> @ @ - 403 , 6 + 405 , 53 @ @ public class CustomIndexTest extends CQLTester <nl> assertEquals ( 1 , lessSelective . searchersProvided ) ; <nl> } <nl> <nl> + @ Test <nl> + public void customExpressionForcesIndexSelection ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a ) ) " ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX more _ selective ON % % s ( b ) USING ' % s ' " , <nl> + SettableSelectivityIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX less _ selective ON % % s ( c ) USING ' % s ' " , <nl> + SettableSelectivityIndex . class . getName ( ) ) ) ; <nl> + SettableSelectivityIndex moreSelective = <nl> + ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( " more _ selective " ) ; <nl> + SettableSelectivityIndex lessSelective = <nl> + ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( " less _ selective " ) ; <nl> + assertEquals ( 0 , moreSelective . searchersProvided ) ; <nl> + assertEquals ( 0 , lessSelective . searchersProvided ) ; <nl> + <nl> + / / without a custom expression , the more selective index should be chosen <nl> + moreSelective . setEstimatedResultRows ( 1 ) ; <nl> + lessSelective . setEstimatedResultRows ( 1000 ) ; <nl> + execute ( " SELECT * FROM % s WHERE b = 0 AND c = 0 ALLOW FILTERING " ) ; <nl> + assertEquals ( 1 , moreSelective . searchersProvided ) ; <nl> + assertEquals ( 0 , lessSelective . searchersProvided ) ; <nl> + <nl> + / / when a custom expression is present , its target index should be preferred <nl> + execute ( " SELECT * FROM % s WHERE b = 0 AND expr ( less _ selective , ' expression ' ) ALLOW FILTERING " ) ; <nl> + assertEquals ( 1 , moreSelective . searchersProvided ) ; <nl> + assertEquals ( 1 , lessSelective . searchersProvided ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testCustomExpressionValueType ( ) throws Throwable <nl> + { <nl> + / / verify that the type of the expression value is determined by Index : : customExpressionValueType <nl> + createTable ( " CREATE TABLE % s ( k int , v1 uuid , v2 blob , PRIMARY KEY ( k ) ) " ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX int _ index ON % % s ( ) USING ' % s ' " , <nl> + Int32ExpressionIndex . class . getName ( ) ) ) ; <nl> + createIndex ( String . format ( " CREATE CUSTOM INDEX text _ index ON % % s ( ) USING ' % s ' " , <nl> + UTF8ExpressionIndex . class . getName ( ) ) ) ; <nl> + <nl> + execute ( " SELECT * FROM % s WHERE expr ( text _ index , ' foo ' ) " ) ; <nl> + assertInvalidMessage ( " Invalid INTEGER constant ( 99 ) for \ " custom index expression \ " of type text " , <nl> + " SELECT * FROM % s WHERE expr ( text _ index , 99 ) " ) ; <nl> + <nl> + execute ( " SELECT * FROM % s WHERE expr ( int _ index , 99 ) " ) ; <nl> + assertInvalidMessage ( " Invalid STRING constant ( foo ) for \ " custom index expression \ " of type int " , <nl> + " SELECT * FROM % s WHERE expr ( int _ index , ' foo ' ) " ) ; <nl> + } <nl> + <nl> private void testCreateIndex ( String indexName , String . . . targetColumnNames ) throws Throwable <nl> { <nl> createIndex ( String . format ( " CREATE CUSTOM INDEX % s ON % % s ( % s ) USING ' % s ' " , <nl> @ @ - 459 , 6 + 508 , 32 @ @ public class CustomIndexTest extends CQLTester <nl> } <nl> } <nl> <nl> + public static final class UTF8ExpressionIndex extends StubIndex <nl> + { <nl> + public UTF8ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) <nl> + { <nl> + super ( baseCfs , metadata ) ; <nl> + } <nl> + <nl> + public AbstractType < ? > customExpressionValueType ( ) <nl> + { <nl> + return UTF8Type . instance ; <nl> + } <nl> + } <nl> + <nl> + public static final class Int32ExpressionIndex extends StubIndex <nl> + { <nl> + public Int32ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) <nl> + { <nl> + super ( baseCfs , metadata ) ; <nl> + } <nl> + <nl> + public AbstractType < ? > customExpressionValueType ( ) <nl> + { <nl> + return Int32Type . instance ; <nl> + } <nl> + } <nl> + <nl> public static final class SettableSelectivityIndex extends StubIndex <nl> { <nl> private int searchersProvided = 0 ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / NEWS . txt b / NEWS . txt 
 index e4b8663 . . a7e56ec 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 111 , 7 + 111 , 9 @ @ Upgrading 
 - SizeTieredCompactionStrategy parameter cold _ reads _ to _ omit has been removed . 
 - The secondary index API has been comprehensively reworked . This will be a breaking 
 change for any custom index implementations , which should now look to implement 
 - the new org . apache . cassandra . index . Index interface . 
 + the new org . apache . cassandra . index . Index interface . New syntax has been added to create 
 + and query row - based indexes , which are not explicitly linked to a single column in the 
 + base table . 
 
 
 2 . 2 . 2 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java b / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java 
 index 65c1bb3 . . eb91928 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / CustomIndexExpression . java 
 @ @ - 21 , 7 + 21 , 7 @ @ package org . apache . cassandra . cql3 . restrictions ; 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . cql3 . * ; 
 import org . apache . cassandra . db . filter . RowFilter ; 
 - import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . db . marshal . AbstractType ; 
 
 public class CustomIndexExpression 
 { 
 @ @ - 38 , 9 + 38 , 9 @ @ public class CustomIndexExpression 
 this . valueRaw = value ; 
 } 
 
 - public void prepareValue ( CFMetaData cfm , VariableSpecifications boundNames ) 
 + public void prepareValue ( CFMetaData cfm , AbstractType < ? > expressionType , VariableSpecifications boundNames ) 
 { 
 - ColumnSpecification spec = new ColumnSpecification ( cfm . ksName , cfm . ksName , valueColId , UTF8Type . instance ) ; 
 + ColumnSpecification spec = new ColumnSpecification ( cfm . ksName , cfm . ksName , valueColId , expressionType ) ; 
 value = valueRaw . prepare ( cfm . ksName , spec ) ; 
 value . collectMarkerSpecification ( boundNames ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 index 1bd4218 . . 1c7db4e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / restrictions / StatementRestrictions . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . cql3 . statements . Bound ; 
 import org . apache . cassandra . cql3 . statements . StatementType ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . RowFilter ; 
 + import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . dht . * ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . index . Index ; 
 @ @ - 503 , 7 + 504 , 6 @ @ public final class StatementRestrictions 
 throw new InvalidRequestException ( IndexRestrictions . MULTIPLE _ EXPRESSIONS ) ; 
 
 CustomIndexExpression expression = expressions . get ( 0 ) ; 
 - expression . prepareValue ( cfm , boundNames ) ; 
 
 CFName cfName = expression . targetIndex . getCfName ( ) ; 
 if ( cfName . hasKeyspace ( ) 
 @ @ - 521 , 9 + 521 , 12 @ @ public final class StatementRestrictions 
 if ( ! index . getIndexMetadata ( ) . isCustom ( ) ) 
 throw IndexRestrictions . nonCustomIndexInExpression ( expression . targetIndex ) ; 
 
 - if ( index . customExpressionValueType ( ) = = null ) 
 + AbstractType < ? > expressionType = index . customExpressionValueType ( ) ; 
 + if ( expressionType = = null ) 
 throw IndexRestrictions . customExpressionNotSupported ( expression . targetIndex ) ; 
 
 + expression . prepareValue ( cfm , expressionType , boundNames ) ; 
 + 
 indexRestrictions . add ( expression ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 index b04de2a . . 9b15a3e 100644 
 - - - a / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 + + + b / src / java / org / apache / cassandra / index / SecondaryIndexManager . java 
 @ @ - 585 , 8 + 585 , 12 @ @ public class SecondaryIndexManager implements IndexRegistry 
 { 
 if ( expression . isCustom ( ) ) 
 { 
 + / / Only a single custom expression is allowed per query and , if present , 
 + / / we want to always favour the index specified in such an expression 
 RowFilter . CustomExpression customExpression = ( RowFilter . CustomExpression ) expression ; 
 - searchableIndexes . add ( indexes . get ( customExpression . getTargetIndex ( ) . name ) ) ; 
 + logger . trace ( " Command contains a custom index expression , using target index { } " , customExpression . getTargetIndex ( ) . name ) ; 
 + Tracing . trace ( " Command contains a custom index expression , using target index { } " , customExpression . getTargetIndex ( ) . name ) ; 
 + return indexes . get ( customExpression . getTargetIndex ( ) . name ) ; 
 } 
 else 
 { 
 diff - - git a / test / unit / org / apache / cassandra / index / CustomIndexTest . java b / test / unit / org / apache / cassandra / index / CustomIndexTest . java 
 index ceff839 . . b2c9257 100644 
 - - - a / test / unit / org / apache / cassandra / index / CustomIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / index / CustomIndexTest . java 
 @ @ - 17 , 6 + 17 , 8 @ @ import org . apache . cassandra . cql3 . statements . SelectStatement ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . ReadCommand ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 import org . apache . cassandra . schema . Indexes ; 
 @ @ - 403 , 6 + 405 , 53 @ @ public class CustomIndexTest extends CQLTester 
 assertEquals ( 1 , lessSelective . searchersProvided ) ; 
 } 
 
 + @ Test 
 + public void customExpressionForcesIndexSelection ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE % s ( a int , b int , c int , PRIMARY KEY ( a ) ) " ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX more _ selective ON % % s ( b ) USING ' % s ' " , 
 + SettableSelectivityIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX less _ selective ON % % s ( c ) USING ' % s ' " , 
 + SettableSelectivityIndex . class . getName ( ) ) ) ; 
 + SettableSelectivityIndex moreSelective = 
 + ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( " more _ selective " ) ; 
 + SettableSelectivityIndex lessSelective = 
 + ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( " less _ selective " ) ; 
 + assertEquals ( 0 , moreSelective . searchersProvided ) ; 
 + assertEquals ( 0 , lessSelective . searchersProvided ) ; 
 + 
 + / / without a custom expression , the more selective index should be chosen 
 + moreSelective . setEstimatedResultRows ( 1 ) ; 
 + lessSelective . setEstimatedResultRows ( 1000 ) ; 
 + execute ( " SELECT * FROM % s WHERE b = 0 AND c = 0 ALLOW FILTERING " ) ; 
 + assertEquals ( 1 , moreSelective . searchersProvided ) ; 
 + assertEquals ( 0 , lessSelective . searchersProvided ) ; 
 + 
 + / / when a custom expression is present , its target index should be preferred 
 + execute ( " SELECT * FROM % s WHERE b = 0 AND expr ( less _ selective , ' expression ' ) ALLOW FILTERING " ) ; 
 + assertEquals ( 1 , moreSelective . searchersProvided ) ; 
 + assertEquals ( 1 , lessSelective . searchersProvided ) ; 
 + } 
 + 
 + @ Test 
 + public void testCustomExpressionValueType ( ) throws Throwable 
 + { 
 + / / verify that the type of the expression value is determined by Index : : customExpressionValueType 
 + createTable ( " CREATE TABLE % s ( k int , v1 uuid , v2 blob , PRIMARY KEY ( k ) ) " ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX int _ index ON % % s ( ) USING ' % s ' " , 
 + Int32ExpressionIndex . class . getName ( ) ) ) ; 
 + createIndex ( String . format ( " CREATE CUSTOM INDEX text _ index ON % % s ( ) USING ' % s ' " , 
 + UTF8ExpressionIndex . class . getName ( ) ) ) ; 
 + 
 + execute ( " SELECT * FROM % s WHERE expr ( text _ index , ' foo ' ) " ) ; 
 + assertInvalidMessage ( " Invalid INTEGER constant ( 99 ) for \ " custom index expression \ " of type text " , 
 + " SELECT * FROM % s WHERE expr ( text _ index , 99 ) " ) ; 
 + 
 + execute ( " SELECT * FROM % s WHERE expr ( int _ index , 99 ) " ) ; 
 + assertInvalidMessage ( " Invalid STRING constant ( foo ) for \ " custom index expression \ " of type int " , 
 + " SELECT * FROM % s WHERE expr ( int _ index , ' foo ' ) " ) ; 
 + } 
 + 
 private void testCreateIndex ( String indexName , String . . . targetColumnNames ) throws Throwable 
 { 
 createIndex ( String . format ( " CREATE CUSTOM INDEX % s ON % % s ( % s ) USING ' % s ' " , 
 @ @ - 459 , 6 + 508 , 32 @ @ public class CustomIndexTest extends CQLTester 
 } 
 } 
 
 + public static final class UTF8ExpressionIndex extends StubIndex 
 + { 
 + public UTF8ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) 
 + { 
 + super ( baseCfs , metadata ) ; 
 + } 
 + 
 + public AbstractType < ? > customExpressionValueType ( ) 
 + { 
 + return UTF8Type . instance ; 
 + } 
 + } 
 + 
 + public static final class Int32ExpressionIndex extends StubIndex 
 + { 
 + public Int32ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) 
 + { 
 + super ( baseCfs , metadata ) ; 
 + } 
 + 
 + public AbstractType < ? > customExpressionValueType ( ) 
 + { 
 + return Int32Type . instance ; 
 + } 
 + } 
 + 
 public static final class SettableSelectivityIndex extends StubIndex 
 { 
 private int searchersProvided = 0 ;

NEAREST DIFF:
ELIMINATEDSENTENCE
