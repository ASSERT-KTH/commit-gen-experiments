BLEU SCORE: 0.027611988917697356

TEST MSG: Make tablehistograms accept the same syntax as tablestats
GENERATED MSG: merge from 0 . 5

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 7d0ca2e . . eadd387 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 2 <nl> + * Make tablehistograms accept the same syntax as tablestats ( CASSANDRA - 10149 ) <nl> * Group pending compactions based on table ( CASSANDRA - 10718 ) <nl> * Add compressor name in sstablemetadata output ( CASSANDRA - 9879 ) <nl> * Fix type casting for counter columns ( CASSANDRA - 10824 ) <nl> diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> index 23f1c43 . . f3f9b8a 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> + + + b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java <nl> @ @ - 34 , 16 + 34 , 29 @ @ import org . apache . commons . lang3 . ArrayUtils ; <nl> @ Command ( name = " tablehistograms " , description = " Print statistic histograms for a given table " ) <nl> public class TableHistograms extends NodeToolCmd <nl> { <nl> - @ Arguments ( usage = " < keyspace > < table > " , description = " The keyspace and table name " ) <nl> + @ Arguments ( usage = " < keyspace > < table > | < keyspace . table > " , description = " The keyspace and table name " ) <nl> private List < String > args = new ArrayList < > ( ) ; <nl> <nl> @ Override <nl> public void execute ( NodeProbe probe ) <nl> { <nl> - checkArgument ( args . size ( ) = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; <nl> - <nl> - String keyspace = args . get ( 0 ) ; <nl> - String table = args . get ( 1 ) ; <nl> + String keyspace = null , table = null ; <nl> + if ( args . size ( ) = = 2 ) <nl> + { <nl> + keyspace = args . get ( 0 ) ; <nl> + table = args . get ( 1 ) ; <nl> + } <nl> + else if ( args . size ( ) = = 1 ) <nl> + { <nl> + String [ ] input = args . get ( 0 ) . split ( " \ \ . " ) ; <nl> + checkArgument ( input . length = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; <nl> + keyspace = input [ 0 ] ; <nl> + table = input [ 1 ] ; <nl> + } <nl> + else <nl> + { <nl> + checkArgument ( false , " tablehistograms requires keyspace and table name arguments " ) ; <nl> + } <nl> <nl> / / calculate percentile of row size and column count <nl> long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 9edb36d . . 73a6717 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 2 , 6 + 2 , 10 @ @ <nl> * Fix potential NPE in get _ range _ slice ( CASSANDRA - 623 ) <nl> * add CRC32 to commitlog entries ( CASSANDRA - 605 ) <nl> * fix data streaming on windows ( CASSANDRA - 630 ) <nl> + * GC compacted sstables after cleanup and compaction ( CASSANDRA - 621 ) <nl> + * Speed up anti - entropy validation ( CASSANDRA - 629 ) <nl> + * Fix pending range conflicts when bootstapping or moving <nl> + multiple nodes at once ( CASSANDRA - 603 ) <nl> <nl> <nl> 0 . 5 . 0 beta 2 <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 108dd5d . . 966c7e9 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 8 , 6 + 8 , 10 @ @ <nl> out ; if that happens , just go back to 0 . 4 and flush again . ) <nl> The format changed twice : from 0 . 4 to beta1 , and from beta2 to RC1 . <nl> <nl> + . 5 The gossip protocol has changed , meaning 0 . 5 nodes cannot coexist <nl> + in a cluster of 0 . 4 nodes or vice versa ; you must upgrade your <nl> + whole cluster at the same time . <nl> + <nl> 1 . Bootstrap , move , load balancing , and active repair have been added . <nl> See http : / / wiki . apache . org / cassandra / Operations . When upgrading <nl> from 0 . 4 , leave autobootstrap set to false for the first restart <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index aa5f8fd . . fb2b480 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 91 , 11 + 91 , 11 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> List < InetAddress > endpoints = new ArrayList < InetAddress > ( naturalEndpoints ) ; <nl> <nl> - for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) <nl> + for ( Map . Entry < Range , Collection < InetAddress > > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) <nl> { <nl> if ( entry . getKey ( ) . contains ( token ) ) <nl> { <nl> - endpoints . add ( entry . getValue ( ) ) ; <nl> + endpoints . addAll ( entry . getValue ( ) ) ; <nl> } <nl> } <nl> <nl> @ @ - 202 , 26 + 202 , 9 @ @ public abstract class AbstractReplicationStrategy <nl> <nl> public Collection < Range > getPendingAddressRanges ( TokenMetadata metadata , Token pendingToken , InetAddress pendingAddress ) <nl> { <nl> - TokenMetadata temp = metadata . cloneWithoutPending ( ) ; <nl> - temp . update ( pendingToken , pendingAddress ) ; <nl> + TokenMetadata temp = metadata . cloneOnlyTokenMap ( ) ; <nl> + temp . updateNormalToken ( pendingToken , pendingAddress ) ; <nl> return getAddressRanges ( temp ) . get ( pendingAddress ) ; <nl> } <nl> <nl> - public void removeObsoletePendingRanges ( ) <nl> - { <nl> - Multimap < InetAddress , Range > ranges = getAddressRanges ( ) ; <nl> - for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) <nl> - { <nl> - for ( Range currentRange : ranges . get ( entry . getValue ( ) ) ) <nl> - { <nl> - if ( currentRange . contains ( entry . getKey ( ) ) ) <nl> - { <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " Removing obsolete pending range " + entry . getKey ( ) + " from " + entry . getValue ( ) ) ; <nl> - tokenMetadata _ . removePendingRange ( entry . getKey ( ) ) ; <nl> - break ; <nl> - } <nl> - } <nl> - } <nl> - } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index 771ce2f . . 924e4d5 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 29 , 15 + 29 , 33 @ @ import java . net . InetAddress ; <nl> <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> - import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> import com . google . common . collect . BiMap ; <nl> import com . google . common . collect . HashBiMap ; <nl> + import com . google . common . collect . Multimap ; <nl> + import com . google . common . collect . HashMultimap ; <nl> <nl> public class TokenMetadata <nl> { <nl> / * Maintains token to endpoint map of every node in the cluster . * / <nl> private BiMap < Token , InetAddress > tokenToEndPointMap ; <nl> - private Map < Range , InetAddress > pendingRanges ; <nl> + <nl> + / / Suppose that there is a ring of nodes A , C and E , with replication factor 3 . <nl> + / / Node D bootstraps between C and E , so its pending ranges will be E - A , A - C and C - D . <nl> + / / Now suppose node B bootstraps between A and C at the same time . Its pending ranges would be C - E , E - A and A - B . <nl> + / / Now both nodes have pending range E - A in their list , which will cause pending range collision <nl> + / / even though we ' re only talking about replica range , not even primary range . The same thing happens <nl> + / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a multimap , <nl> + / / since that would make us unable to notice the real problem of two nodes trying to boot using the same token . <nl> + / / In order to do this properly , we need to know what tokens are booting at any time . <nl> + private Map < Token , InetAddress > bootstrapTokens ; <nl> + <nl> + / / we will need to know at all times what nodes are leaving and calculate ranges accordingly . <nl> + / / An anonymous pending ranges list is not enough , as that does not tell which node is leaving <nl> + / / and / or if the ranges are there because of bootstrap or leave operation . <nl> + / / ( See CASSANDRA - 603 for more detail + examples ) . <nl> + private Set < InetAddress > leavingEndPoints ; <nl> + <nl> + private Multimap < Range , InetAddress > pendingRanges ; <nl> <nl> / * Use this lock for manipulating the token map * / <nl> private final ReadWriteLock lock = new ReentrantReadWriteLock ( true ) ; <nl> @ @ - 53 , 7 + 71 , 9 @ @ public class TokenMetadata <nl> if ( tokenToEndPointMap = = null ) <nl> tokenToEndPointMap = HashBiMap . create ( ) ; <nl> this . tokenToEndPointMap = tokenToEndPointMap ; <nl> - pendingRanges = new NonBlockingHashMap < Range , InetAddress > ( ) ; <nl> + bootstrapTokens = new HashMap < Token , InetAddress > ( ) ; <nl> + leavingEndPoints = new HashSet < InetAddress > ( ) ; <nl> + pendingRanges = HashMultimap . create ( ) ; <nl> sortedTokens = sortTokens ( ) ; <nl> } <nl> <nl> @ @ - 69 , 18 + 89 , 13 @ @ public class TokenMetadata <nl> { <nl> int n = 0 ; <nl> Range sourceRange = getPrimaryRangeFor ( getToken ( source ) ) ; <nl> - for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) <nl> - { <nl> - if ( sourceRange . contains ( entry . getKey ( ) ) | | entry . getValue ( ) . equals ( source ) ) <nl> + for ( Token token : bootstrapTokens . keySet ( ) ) <nl> + if ( sourceRange . contains ( token ) ) <nl> n + + ; <nl> - } <nl> return n ; <nl> } <nl> <nl> - / * * <nl> - * Update the two maps in an safe mode . <nl> - * / <nl> - public void update ( Token token , InetAddress endpoint ) <nl> + public void updateNormalToken ( Token token , InetAddress endpoint ) <nl> { <nl> assert token ! = null ; <nl> assert endpoint ! = null ; <nl> @ @ - 88 , 6 + 103 , 8 @ @ public class TokenMetadata <nl> lock . writeLock ( ) . lock ( ) ; <nl> try <nl> { <nl> + bootstrapTokens . remove ( token ) ; <nl> + <nl> tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; <nl> if ( ! endpoint . equals ( tokenToEndPointMap . put ( token , endpoint ) ) ) <nl> { <nl> @ @ - 100 , 13 + 117 , 49 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> + public void addBootstrapToken ( Token token , InetAddress endpoint ) <nl> + { <nl> + assert token ! = null ; <nl> + assert endpoint ! = null ; <nl> + <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + InetAddress oldEndPoint = bootstrapTokens . get ( token ) ; <nl> + if ( oldEndPoint ! = null & & ! oldEndPoint . equals ( endpoint ) ) <nl> + throw new RuntimeException ( " Bootstrap Token collision between " + oldEndPoint + " and " + endpoint + " ( token " + token ) ; <nl> + bootstrapTokens . put ( token , endpoint ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> + public void addLeavingEndPoint ( InetAddress endpoint ) <nl> + { <nl> + assert endpoint ! = null ; <nl> + <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + leavingEndPoints . add ( endpoint ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> public void removeEndpoint ( InetAddress endpoint ) <nl> { <nl> assert tokenToEndPointMap . containsValue ( endpoint ) ; <nl> lock . writeLock ( ) . lock ( ) ; <nl> try <nl> { <nl> + bootstrapTokens . remove ( getToken ( endpoint ) ) ; <nl> tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; <nl> + leavingEndPoints . remove ( endpoint ) ; <nl> sortedTokens = sortTokens ( ) ; <nl> } <nl> finally <nl> @ @ - 161 , 7 + 214 , 11 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> - public TokenMetadata cloneWithoutPending ( ) <nl> + / * * <nl> + * Create a copy of TokenMetadata with only tokenToEndPointMap . That is , pending ranges , <nl> + * bootstrap tokens and leaving endpoints are not included in the copy . <nl> + * / <nl> + public TokenMetadata cloneOnlyTokenMap ( ) <nl> { <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> @ @ - 174 , 28 + 231 , 24 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> - public String toString ( ) <nl> + / * * <nl> + * Create a copy of TokenMetadata with tokenToEndPointMap reflecting situation after all <nl> + * current leave operations have finished . <nl> + * / <nl> + public TokenMetadata cloneAfterAllLeft ( ) <nl> { <nl> - StringBuilder sb = new StringBuilder ( ) ; <nl> lock . readLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; <nl> - <nl> - for ( InetAddress ep : eps ) <nl> - { <nl> - sb . append ( ep ) ; <nl> - sb . append ( " : " ) ; <nl> - sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; <nl> - sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> - } <nl> + TokenMetadata allLeftMetadata = cloneOnlyTokenMap ( ) ; <nl> + for ( InetAddress endPoint : leavingEndPoints ) <nl> + allLeftMetadata . removeEndpoint ( endPoint ) ; <nl> + return allLeftMetadata ; <nl> } <nl> finally <nl> { <nl> lock . readLock ( ) . unlock ( ) ; <nl> } <nl> - <nl> - return sb . toString ( ) ; <nl> } <nl> <nl> public InetAddress getEndPoint ( Token token ) <nl> @ @ - 211 , 12 + 264 , 6 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> - public void clearUnsafe ( ) <nl> - { <nl> - tokenToEndPointMap . clear ( ) ; <nl> - pendingRanges . clear ( ) ; <nl> - } <nl> - <nl> public Range getPrimaryRangeFor ( Token right ) <nl> { <nl> return new Range ( getPredecessor ( right ) , right ) ; <nl> @ @ - 235 , 29 + 282 , 16 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> - public void addPendingRange ( Range range , InetAddress endpoint ) <nl> - { <nl> - InetAddress oldEndpoint = pendingRanges . get ( range ) ; <nl> - if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) ) <nl> - throw new RuntimeException ( " pending range collision between " + oldEndpoint + " and " + endpoint ) ; <nl> - pendingRanges . put ( range , endpoint ) ; <nl> - } <nl> - <nl> - public void removePendingRange ( Range range ) <nl> - { <nl> - pendingRanges . remove ( range ) ; <nl> - } <nl> - <nl> / * * a mutable map may be returned but caller should not modify it * / <nl> - public Map < Range , InetAddress > getPendingRanges ( ) <nl> + public Map < Range , Collection < InetAddress > > getPendingRanges ( ) <nl> { <nl> - return pendingRanges ; <nl> + return pendingRanges . asMap ( ) ; <nl> } <nl> <nl> public List < Range > getPendingRanges ( InetAddress endpoint ) <nl> { <nl> List < Range > ranges = new ArrayList < Range > ( ) ; <nl> - for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) <nl> + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entries ( ) ) <nl> { <nl> if ( entry . getValue ( ) . equals ( endpoint ) ) <nl> { <nl> @ @ - 267 , 6 + 301 , 11 @ @ public class TokenMetadata <nl> return ranges ; <nl> } <nl> <nl> + public void setPendingRanges ( Multimap < Range , InetAddress > pendingRanges ) <nl> + { <nl> + this . pendingRanges = pendingRanges ; <nl> + } <nl> + <nl> public Token getPredecessor ( Token token ) <nl> { <nl> List tokens = sortedTokens ( ) ; <nl> @ @ - 288 , 8 + 327 , 96 @ @ public class TokenMetadata <nl> return getEndPoint ( getSuccessor ( getToken ( endPoint ) ) ) ; <nl> } <nl> <nl> - public void clearPendingRanges ( ) <nl> + / * * caller should not modify bootstrapTokens * / <nl> + public Map < Token , InetAddress > getBootstrapTokens ( ) <nl> + { <nl> + return bootstrapTokens ; <nl> + } <nl> + <nl> + / * * caller should not modify leavigEndPoints * / <nl> + public Set < InetAddress > getLeavingEndPoints ( ) <nl> { <nl> + return leavingEndPoints ; <nl> + } <nl> + <nl> + / * * used by tests * / <nl> + public void clearUnsafe ( ) <nl> + { <nl> + bootstrapTokens . clear ( ) ; <nl> + tokenToEndPointMap . clear ( ) ; <nl> + leavingEndPoints . clear ( ) ; <nl> pendingRanges . clear ( ) ; <nl> } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + lock . readLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; <nl> + <nl> + if ( ! eps . isEmpty ( ) ) <nl> + { <nl> + sb . append ( " Normal Tokens : " ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + for ( InetAddress ep : eps ) <nl> + { <nl> + sb . append ( ep ) ; <nl> + sb . append ( " : " ) ; <nl> + sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! bootstrapTokens . isEmpty ( ) ) <nl> + { <nl> + sb . append ( " Bootstrapping Tokens : " ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) <nl> + { <nl> + sb . append ( entry . getValue ( ) + " : " + entry . getKey ( ) ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! leavingEndPoints . isEmpty ( ) ) <nl> + { <nl> + sb . append ( " Leaving EndPoints : " ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + for ( InetAddress ep : leavingEndPoints ) <nl> + { <nl> + sb . append ( ep ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + } <nl> + <nl> + if ( ! pendingRanges . isEmpty ( ) ) <nl> + { <nl> + sb . append ( " Pending Ranges : " ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + sb . append ( printPendingRanges ( ) ) ; <nl> + } <nl> + } <nl> + finally <nl> + { <nl> + lock . readLock ( ) . unlock ( ) ; <nl> + } <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> + public String printPendingRanges ( ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + <nl> + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entries ( ) ) <nl> + { <nl> + sb . append ( entry . getValue ( ) + " : " + entry . getKey ( ) ) ; <nl> + sb . append ( System . getProperty ( " line . separator " ) ) ; <nl> + } <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 1dfba20 . . e5f3988 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 183 , 7 + 183 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Setting token to " + token ) ; <nl> SystemTable . updateToken ( token ) ; <nl> - tokenMetadata _ . update ( token , FBUtilities . getLocalAddress ( ) ) ; <nl> + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getLocalAddress ( ) ) ; <nl> } <nl> <nl> public StorageService ( ) <nl> @ @ - 306 , 7 + 306 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> { <nl> SystemTable . setBootstrapped ( true ) ; <nl> Token token = storageMetadata _ . getToken ( ) ; <nl> - tokenMetadata _ . update ( token , FBUtilities . getLocalAddress ( ) ) ; <nl> + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getLocalAddress ( ) ) ; <nl> Gossiper . instance ( ) . addApplicationState ( StorageService . STATE _ NORMAL , new ApplicationState ( partitioner _ . getTokenFactory ( ) . toString ( token ) ) ) ; <nl> } <nl> <nl> @ @ - 407 , 23 + 407 , 25 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( endpoint + " state bootstrapping , token " + token ) ; <nl> - updateBootstrapRanges ( token , endpoint ) ; <nl> + tokenMetadata _ . addBootstrapToken ( token , endpoint ) ; <nl> + calculatePendingRanges ( ) ; <nl> } <nl> else if ( STATE _ NORMAL . equals ( stateName ) ) <nl> { <nl> Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( endpoint + " state normal , token " + token ) ; <nl> - tokenMetadata _ . update ( token , endpoint ) ; <nl> + tokenMetadata _ . updateNormalToken ( token , endpoint ) ; <nl> + calculatePendingRanges ( ) ; <nl> if ( ! isClientMode ) <nl> SystemTable . updateToken ( endpoint , token ) ; <nl> - replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> } <nl> else if ( STATE _ LEAVING . equals ( stateName ) ) <nl> { <nl> Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; <nl> assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; <nl> - updateLeavingRanges ( endpoint ) ; <nl> + tokenMetadata _ . addLeavingEndPoint ( endpoint ) ; <nl> + calculatePendingRanges ( ) ; <nl> } <nl> else if ( STATE _ LEFT . equals ( stateName ) ) <nl> { <nl> @ @ - 442 , 6 + 444 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> logger _ . debug ( endpoint + " state left , token " + token ) ; <nl> assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; <nl> tokenMetadata _ . removeEndpoint ( endpoint ) ; <nl> + calculatePendingRanges ( ) ; <nl> } <nl> } <nl> else <nl> @ @ - 454 , 11 + 457 , 94 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> { <nl> restoreReplicaCount ( endPointThatLeft ) ; <nl> tokenMetadata _ . removeEndpoint ( endPointThatLeft ) ; <nl> + calculatePendingRanges ( ) ; <nl> } <nl> } <nl> + } <nl> + } <nl> + <nl> + / * * <nl> + * Calculate pending ranges according to bootsrapping and leaving nodes . Reasoning is : <nl> + * <nl> + * ( 1 ) When in doubt , it is better to write too much to a node than too little . That is , if <nl> + * there are multiple nodes moving , calculate the biggest ranges a node could have . Cleaning <nl> + * up unneeded data afterwards is better than missing writes during movement . <nl> + * ( 2 ) When a node leaves , ranges for other nodes can only grow ( a node might get additional <nl> + * ranges , but it will not lose any of its current ranges as a result of a leave ) . Therefore <nl> + * we will first remove _ all _ leaving tokens for the sake of calculation and then check what <nl> + * ranges would go where if all nodes are to leave . This way we get the biggest possible <nl> + * ranges with regard current leave operations , covering all subsets of possible final range <nl> + * values . <nl> + * ( 3 ) When a node bootstraps , ranges of other nodes can only get smaller . Without doing <nl> + * complex calculations to see if multiple bootstraps overlap , we simply base calculations <nl> + * on the same token ring used before ( reflecting situation after all leave operations have <nl> + * completed ) . Bootstrapping nodes will be added and removed one by one to that metadata and <nl> + * checked what their ranges would be . This will give us the biggest possible ranges the <nl> + * node could have . It might be that other bootstraps make our actual final ranges smaller , <nl> + * but it does not matter as we can clean up the data afterwards . <nl> + * <nl> + * NOTE : This is heavy and ineffective operation . This will be done only once when a node <nl> + * changes state in the cluster , so it should be manageable . <nl> + * / <nl> + private void calculatePendingRanges ( ) <nl> + { <nl> + calculatePendingRanges ( tokenMetadata _ , replicationStrategy _ ) ; <nl> + } <nl> + <nl> + / / public & static for testing purposes <nl> + public static void calculatePendingRanges ( TokenMetadata tm , AbstractReplicationStrategy strategy ) <nl> + { <nl> + Multimap < Range , InetAddress > pendingRanges = HashMultimap . create ( ) ; <nl> + Map < Token , InetAddress > bootstrapTokens = tm . getBootstrapTokens ( ) ; <nl> + Set < InetAddress > leavingEndPoints = tm . getLeavingEndPoints ( ) ; <nl> + <nl> + if ( bootstrapTokens . isEmpty ( ) & & leavingEndPoints . isEmpty ( ) ) <nl> + { <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " No bootstrapping or leaving nodes - > empty pending ranges " ) ; <nl> + tm . setPendingRanges ( pendingRanges ) ; <nl> + return ; <nl> + } <nl> + <nl> + Multimap < InetAddress , Range > addressRanges = strategy . getAddressRanges ( ) ; <nl> + <nl> + / / Copy of metadata reflecting the situation after all leave operations are finished . <nl> + TokenMetadata allLeftMetadata = tm . cloneAfterAllLeft ( ) ; <nl> + <nl> + / / get all ranges that will be affected by leaving nodes <nl> + Set < Range > affectedRanges = new HashSet < Range > ( ) ; <nl> + for ( InetAddress endPoint : leavingEndPoints ) <nl> + affectedRanges . addAll ( addressRanges . get ( endPoint ) ) ; <nl> + <nl> + / / for each of those ranges , find what new nodes will be responsible for the range when <nl> + / / all leaving nodes are gone . <nl> + for ( Range range : affectedRanges ) <nl> + { <nl> + List < InetAddress > currentEndPoints = strategy . getNaturalEndpoints ( range . right ( ) , tm ) ; <nl> + List < InetAddress > newEndPoints = strategy . getNaturalEndpoints ( range . right ( ) , allLeftMetadata ) ; <nl> + newEndPoints . removeAll ( currentEndPoints ) ; <nl> + pendingRanges . putAll ( range , newEndPoints ) ; <nl> + } <nl> + <nl> + / / At this stage pendingRanges has been updated according to leave operations . We can <nl> + / / now finish the calculation by checking bootstrapping nodes . <nl> + <nl> + / / For each of the bootstrapping nodes , simply add and remove them one by one to <nl> + / / allLeftMetadata and check in between what their ranges would be . <nl> + for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) <nl> + { <nl> + InetAddress endPoint = entry . getValue ( ) ; <nl> <nl> - replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> + allLeftMetadata . updateNormalToken ( entry . getKey ( ) , endPoint ) ; <nl> + for ( Range range : strategy . getAddressRanges ( allLeftMetadata ) . get ( endPoint ) ) <nl> + pendingRanges . put ( range , endPoint ) ; <nl> + allLeftMetadata . removeEndpoint ( endPoint ) ; <nl> } <nl> + <nl> + tm . setPendingRanges ( pendingRanges ) ; <nl> + <nl> + if ( logger _ . isDebugEnabled ( ) ) <nl> + logger _ . debug ( " Pending ranges : \ n " + tm . printPendingRanges ( ) ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 534 , 7 + 620 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> Collection < Range > ranges = getRangesForEndPoint ( endpoint ) ; <nl> <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " leaving node ranges are [ " + StringUtils . join ( ranges , " , " ) + " ] " ) ; <nl> + logger _ . debug ( " Node " + endpoint + " ranges [ " + StringUtils . join ( ranges , " , " ) + " ] " ) ; <nl> <nl> Map < Range , ArrayList < InetAddress > > currentReplicaEndpoints = new HashMap < Range , ArrayList < InetAddress > > ( ) ; <nl> <nl> @ @ - 542 , 7 + 628 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> for ( Range range : ranges ) <nl> currentReplicaEndpoints . put ( range , replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , tokenMetadata _ ) ) ; <nl> <nl> - TokenMetadata temp = tokenMetadata _ . cloneWithoutPending ( ) ; <nl> + TokenMetadata temp = tokenMetadata _ . cloneAfterAllLeft ( ) ; <nl> temp . removeEndpoint ( endpoint ) ; <nl> <nl> Multimap < Range , InetAddress > changedRanges = HashMultimap . create ( ) ; <nl> @ @ - 557 , 43 + 643 , 13 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> ArrayList < InetAddress > newReplicaEndpoints = replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , temp ) ; <nl> newReplicaEndpoints . removeAll ( currentReplicaEndpoints . get ( range ) ) ; <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( " adding pending range " + range + " to endpoints " + StringUtils . join ( newReplicaEndpoints , " , " ) ) ; <nl> + logger _ . debug ( " Range " + range + " will be responsibility of " + StringUtils . join ( newReplicaEndpoints , " , " ) ) ; <nl> changedRanges . putAll ( range , newReplicaEndpoints ) ; <nl> } <nl> <nl> return changedRanges ; <nl> } <nl> <nl> - private void updateLeavingRanges ( final InetAddress endpoint ) <nl> - { <nl> - if ( logger _ . isDebugEnabled ( ) ) <nl> - logger _ . debug ( endpoint + " is leaving ; calculating pendingranges " ) ; <nl> - Multimap < Range , InetAddress > ranges = getChangedRangesForLeaving ( endpoint ) ; <nl> - for ( Range range : ranges . keySet ( ) ) <nl> - { <nl> - for ( InetAddress newEndpoint : ranges . get ( range ) ) <nl> - { <nl> - tokenMetadata _ . addPendingRange ( range , newEndpoint ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - private void updateBootstrapRanges ( Token token , InetAddress endpoint ) <nl> - { <nl> - for ( Range range : replicationStrategy _ . getPendingAddressRanges ( tokenMetadata _ , token , endpoint ) ) <nl> - { <nl> - tokenMetadata _ . addPendingRange ( range , endpoint ) ; <nl> - } <nl> - } <nl> - <nl> - public static void updateBootstrapRanges ( AbstractReplicationStrategy strategy , TokenMetadata metadata , Token token , InetAddress endpoint ) <nl> - { <nl> - for ( Range range : strategy . getPendingAddressRanges ( metadata , token , endpoint ) ) <nl> - { <nl> - metadata . addPendingRange ( range , endpoint ) ; <nl> - } <nl> - } <nl> - <nl> public void onJoin ( InetAddress endpoint , EndPointState epState ) <nl> { <nl> for ( Map . Entry < String , ApplicationState > entry : epState . getSortedApplicationStates ( ) ) <nl> @ @ - 1117 , 7 + 1173 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> { <nl> SystemTable . setBootstrapped ( false ) ; <nl> tokenMetadata _ . removeEndpoint ( FBUtilities . getLocalAddress ( ) ) ; <nl> - replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " " ) ; <nl> @ @ - 1238 , 7 + 1293 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> <nl> restoreReplicaCount ( endPoint ) ; <nl> tokenMetadata _ . removeEndpoint ( endPoint ) ; <nl> - replicationStrategy _ . removeObsoletePendingRanges ( ) ; <nl> } <nl> <nl> / / This is not the cleanest way as we ' re adding STATE _ LEFT for <nl> @ @ - 1261 , 11 + 1315 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto <nl> return replicationStrategy _ ; <nl> } <nl> <nl> - public void cancelPendingRanges ( ) <nl> - { <nl> - tokenMetadata _ . clearPendingRanges ( ) ; <nl> - } <nl> - <nl> public boolean isClientMode ( ) <nl> { <nl> return isClientMode ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> index c09802a . . f4404fb 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java <nl> @ @ - 141 , 13 + 141 , 6 @ @ public interface StorageServiceMBean <nl> public void loadBalance ( ) throws IOException , InterruptedException ; <nl> <nl> / * * <nl> - * cancel writes to nodes that are set to be changing ranges . <nl> - * Only do this if the reason for the range changes no longer exists <nl> - * ( e . g . , a bootstrapping node was killed or crashed . ) <nl> - * / <nl> - public void cancelPendingRanges ( ) ; <nl> - <nl> - / * * <nl> * removeToken removes token ( and all data associated with <nl> * enpoint that had it ) from the ring <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> index cd87901 . . 0135eb7 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java <nl> @ @ - 398 , 11 + 398 , 6 @ @ public class NodeProbe <nl> ssProxy . move ( newToken ) ; <nl> } <nl> <nl> - public void cancelPendingRanges ( ) <nl> - { <nl> - ssProxy . cancelPendingRanges ( ) ; <nl> - } <nl> - <nl> public void removeToken ( String token ) <nl> { <nl> ssProxy . removeToken ( token ) ; <nl> @ @ - 503 , 7 + 498 , 7 @ @ public class NodeProbe <nl> HelpFormatter hf = new HelpFormatter ( ) ; <nl> String header = String . format ( <nl> " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , " + <nl> - " tpstats , flush , repair , decommission , move , loadbalance , cancelpending , removetoken , " + <nl> + " tpstats , flush , repair , decommission , move , loadbalance , removetoken , " + <nl> " getcompactionthreshold , setcompactionthreshold [ minthreshold ] ( [ maxthreshold ] ) " ) ; <nl> String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; <nl> hf . printHelp ( usage , " " , options , header ) ; <nl> @ @ - 578 , 10 + 573 , 6 @ @ public class NodeProbe <nl> } <nl> probe . move ( arguments [ 1 ] ) ; <nl> } <nl> - else if ( cmdName . equals ( " cancelpending " ) ) <nl> - { <nl> - probe . cancelPendingRanges ( ) ; <nl> - } <nl> else if ( cmdName . equals ( " removetoken " ) ) <nl> { <nl> if ( arguments . length < = 1 ) <nl> diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> index b9a5a82 . . c910685 100644 <nl> - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import org . junit . Test ; <nl> import com . google . common . collect . Multimap ; <nl> import org . apache . cassandra . gms . IFailureDetectionEventListener ; <nl> import org . apache . cassandra . gms . IFailureDetector ; <nl> + import org . apache . cassandra . gms . ApplicationState ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> @ @ - 61 , 7 + 62 , 8 @ @ public class BootStrapperTest <nl> Range range3 = ss . getPrimaryRangeForEndPoint ( three ) ; <nl> Token fakeToken = ( ( IPartitioner ) StorageService . getPartitioner ( ) ) . midpoint ( range3 . left ( ) , range3 . right ( ) ) ; <nl> assert range3 . contains ( fakeToken ) ; <nl> - StorageService . updateBootstrapRanges ( StorageService . instance ( ) . getReplicationStrategy ( ) , tmd , fakeToken , myEndpoint ) ; <nl> + ss . onChange ( myEndpoint , StorageService . STATE _ BOOTSTRAPPING , new ApplicationState ( ss . getPartitioner ( ) . getTokenFactory ( ) . toString ( fakeToken ) ) ) ; <nl> + tmd = ss . getTokenMetadata ( ) ; <nl> <nl> InetAddress source2 = BootStrapper . getBootstrapSource ( tmd , load ) ; <nl> assert two . equals ( source2 ) : source2 ; <nl> @ @ - 124 , 7 + 126 , 7 @ @ public class BootStrapperTest <nl> for ( int i = 1 ; i < = numOldNodes ; i + + ) <nl> { <nl> / / leave . 1 for myEndpoint <nl> - tmd . update ( p . getRandomToken ( ) , InetAddress . getByName ( " 127 . 0 . 0 . " + ( i + 1 ) ) ) ; <nl> + tmd . updateNormalToken ( p . getRandomToken ( ) , InetAddress . getByName ( " 127 . 0 . 0 . " + ( i + 1 ) ) ) ; <nl> } <nl> } <nl> } <nl> \ No newline at end of file <nl> diff - - git a / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java b / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java <nl> index 9169f7d . . c0e6cd2 100644 <nl> - - - a / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java <nl> + + + b / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java <nl> @ @ - 79 , 7 + 79 , 7 @ @ public class RackUnawareStrategyTest <nl> for ( int i = 0 ; i < endPointTokens . length ; i + + ) <nl> { <nl> InetAddress ep = InetAddress . getByName ( " 127 . 0 . 0 . " + String . valueOf ( i + 1 ) ) ; <nl> - tmd . update ( endPointTokens [ i ] , ep ) ; <nl> + tmd . updateNormalToken ( endPointTokens [ i ] , ep ) ; <nl> hosts . add ( ep ) ; <nl> } <nl> <nl> @ @ - 114 , 15 + 114 , 16 @ @ public class RackUnawareStrategyTest <nl> for ( int i = 0 ; i < endPointTokens . length ; i + + ) <nl> { <nl> InetAddress ep = InetAddress . getByName ( " 127 . 0 . 0 . " + String . valueOf ( i + 1 ) ) ; <nl> - tmd . update ( endPointTokens [ i ] , ep ) ; <nl> + tmd . updateNormalToken ( endPointTokens [ i ] , ep ) ; <nl> hosts . add ( ep ) ; <nl> } <nl> <nl> / / Add bootstrap node id = 6 <nl> Token bsToken = new BigIntegerToken ( String . valueOf ( 25 ) ) ; <nl> InetAddress bootstrapEndPoint = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; <nl> - StorageService . updateBootstrapRanges ( strategy , tmd , bsToken , bootstrapEndPoint ) ; <nl> - <nl> + tmd . addBootstrapToken ( bsToken , bootstrapEndPoint ) ; <nl> + StorageService . calculatePendingRanges ( tmd , strategy ) ; <nl> + <nl> for ( int i = 0 ; i < keyTokens . length ; i + + ) <nl> { <nl> Collection < InetAddress > endPoints = strategy . getWriteEndpoints ( keyTokens [ i ] , strategy . getNaturalEndpoints ( keyTokens [ i ] ) ) ; <nl> @ @ - 136 , 6 + 137 , 8 @ @ public class RackUnawareStrategyTest <nl> / / for 5 , 15 , 25 this should include bootstrap node <nl> if ( i < 3 ) <nl> assertTrue ( endPoints . contains ( bootstrapEndPoint ) ) ; <nl> + else <nl> + assertFalse ( endPoints . contains ( bootstrapEndPoint ) ) ; <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 7d0ca2e . . eadd387 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 2 
 + * Make tablehistograms accept the same syntax as tablestats ( CASSANDRA - 10149 ) 
 * Group pending compactions based on table ( CASSANDRA - 10718 ) 
 * Add compressor name in sstablemetadata output ( CASSANDRA - 9879 ) 
 * Fix type casting for counter columns ( CASSANDRA - 10824 ) 
 diff - - git a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 index 23f1c43 . . f3f9b8a 100644 
 - - - a / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 + + + b / src / java / org / apache / cassandra / tools / nodetool / TableHistograms . java 
 @ @ - 34 , 16 + 34 , 29 @ @ import org . apache . commons . lang3 . ArrayUtils ; 
 @ Command ( name = " tablehistograms " , description = " Print statistic histograms for a given table " ) 
 public class TableHistograms extends NodeToolCmd 
 { 
 - @ Arguments ( usage = " < keyspace > < table > " , description = " The keyspace and table name " ) 
 + @ Arguments ( usage = " < keyspace > < table > | < keyspace . table > " , description = " The keyspace and table name " ) 
 private List < String > args = new ArrayList < > ( ) ; 
 
 @ Override 
 public void execute ( NodeProbe probe ) 
 { 
 - checkArgument ( args . size ( ) = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; 
 - 
 - String keyspace = args . get ( 0 ) ; 
 - String table = args . get ( 1 ) ; 
 + String keyspace = null , table = null ; 
 + if ( args . size ( ) = = 2 ) 
 + { 
 + keyspace = args . get ( 0 ) ; 
 + table = args . get ( 1 ) ; 
 + } 
 + else if ( args . size ( ) = = 1 ) 
 + { 
 + String [ ] input = args . get ( 0 ) . split ( " \ \ . " ) ; 
 + checkArgument ( input . length = = 2 , " tablehistograms requires keyspace and table name arguments " ) ; 
 + keyspace = input [ 0 ] ; 
 + table = input [ 1 ] ; 
 + } 
 + else 
 + { 
 + checkArgument ( false , " tablehistograms requires keyspace and table name arguments " ) ; 
 + } 
 
 / / calculate percentile of row size and column count 
 long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , " EstimatedPartitionSizeHistogram " ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 9edb36d . . 73a6717 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 2 , 6 + 2 , 10 @ @ 
 * Fix potential NPE in get _ range _ slice ( CASSANDRA - 623 ) 
 * add CRC32 to commitlog entries ( CASSANDRA - 605 ) 
 * fix data streaming on windows ( CASSANDRA - 630 ) 
 + * GC compacted sstables after cleanup and compaction ( CASSANDRA - 621 ) 
 + * Speed up anti - entropy validation ( CASSANDRA - 629 ) 
 + * Fix pending range conflicts when bootstapping or moving 
 + multiple nodes at once ( CASSANDRA - 603 ) 
 
 
 0 . 5 . 0 beta 2 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 108dd5d . . 966c7e9 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 8 , 6 + 8 , 10 @ @ 
 out ; if that happens , just go back to 0 . 4 and flush again . ) 
 The format changed twice : from 0 . 4 to beta1 , and from beta2 to RC1 . 
 
 + . 5 The gossip protocol has changed , meaning 0 . 5 nodes cannot coexist 
 + in a cluster of 0 . 4 nodes or vice versa ; you must upgrade your 
 + whole cluster at the same time . 
 + 
 1 . Bootstrap , move , load balancing , and active repair have been added . 
 See http : / / wiki . apache . org / cassandra / Operations . When upgrading 
 from 0 . 4 , leave autobootstrap set to false for the first restart 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index aa5f8fd . . fb2b480 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 91 , 11 + 91 , 11 @ @ public abstract class AbstractReplicationStrategy 
 
 List < InetAddress > endpoints = new ArrayList < InetAddress > ( naturalEndpoints ) ; 
 
 - for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) 
 + for ( Map . Entry < Range , Collection < InetAddress > > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) 
 { 
 if ( entry . getKey ( ) . contains ( token ) ) 
 { 
 - endpoints . add ( entry . getValue ( ) ) ; 
 + endpoints . addAll ( entry . getValue ( ) ) ; 
 } 
 } 
 
 @ @ - 202 , 26 + 202 , 9 @ @ public abstract class AbstractReplicationStrategy 
 
 public Collection < Range > getPendingAddressRanges ( TokenMetadata metadata , Token pendingToken , InetAddress pendingAddress ) 
 { 
 - TokenMetadata temp = metadata . cloneWithoutPending ( ) ; 
 - temp . update ( pendingToken , pendingAddress ) ; 
 + TokenMetadata temp = metadata . cloneOnlyTokenMap ( ) ; 
 + temp . updateNormalToken ( pendingToken , pendingAddress ) ; 
 return getAddressRanges ( temp ) . get ( pendingAddress ) ; 
 } 
 
 - public void removeObsoletePendingRanges ( ) 
 - { 
 - Multimap < InetAddress , Range > ranges = getAddressRanges ( ) ; 
 - for ( Map . Entry < Range , InetAddress > entry : tokenMetadata _ . getPendingRanges ( ) . entrySet ( ) ) 
 - { 
 - for ( Range currentRange : ranges . get ( entry . getValue ( ) ) ) 
 - { 
 - if ( currentRange . contains ( entry . getKey ( ) ) ) 
 - { 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " Removing obsolete pending range " + entry . getKey ( ) + " from " + entry . getValue ( ) ) ; 
 - tokenMetadata _ . removePendingRange ( entry . getKey ( ) ) ; 
 - break ; 
 - } 
 - } 
 - } 
 - } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index 771ce2f . . 924e4d5 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 29 , 15 + 29 , 33 @ @ import java . net . InetAddress ; 
 
 import org . apache . commons . lang . StringUtils ; 
 
 - import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 import com . google . common . collect . BiMap ; 
 import com . google . common . collect . HashBiMap ; 
 + import com . google . common . collect . Multimap ; 
 + import com . google . common . collect . HashMultimap ; 
 
 public class TokenMetadata 
 { 
 / * Maintains token to endpoint map of every node in the cluster . * / 
 private BiMap < Token , InetAddress > tokenToEndPointMap ; 
 - private Map < Range , InetAddress > pendingRanges ; 
 + 
 + / / Suppose that there is a ring of nodes A , C and E , with replication factor 3 . 
 + / / Node D bootstraps between C and E , so its pending ranges will be E - A , A - C and C - D . 
 + / / Now suppose node B bootstraps between A and C at the same time . Its pending ranges would be C - E , E - A and A - B . 
 + / / Now both nodes have pending range E - A in their list , which will cause pending range collision 
 + / / even though we ' re only talking about replica range , not even primary range . The same thing happens 
 + / / for any nodes that boot simultaneously between same two nodes . For this we cannot simply make pending ranges a multimap , 
 + / / since that would make us unable to notice the real problem of two nodes trying to boot using the same token . 
 + / / In order to do this properly , we need to know what tokens are booting at any time . 
 + private Map < Token , InetAddress > bootstrapTokens ; 
 + 
 + / / we will need to know at all times what nodes are leaving and calculate ranges accordingly . 
 + / / An anonymous pending ranges list is not enough , as that does not tell which node is leaving 
 + / / and / or if the ranges are there because of bootstrap or leave operation . 
 + / / ( See CASSANDRA - 603 for more detail + examples ) . 
 + private Set < InetAddress > leavingEndPoints ; 
 + 
 + private Multimap < Range , InetAddress > pendingRanges ; 
 
 / * Use this lock for manipulating the token map * / 
 private final ReadWriteLock lock = new ReentrantReadWriteLock ( true ) ; 
 @ @ - 53 , 7 + 71 , 9 @ @ public class TokenMetadata 
 if ( tokenToEndPointMap = = null ) 
 tokenToEndPointMap = HashBiMap . create ( ) ; 
 this . tokenToEndPointMap = tokenToEndPointMap ; 
 - pendingRanges = new NonBlockingHashMap < Range , InetAddress > ( ) ; 
 + bootstrapTokens = new HashMap < Token , InetAddress > ( ) ; 
 + leavingEndPoints = new HashSet < InetAddress > ( ) ; 
 + pendingRanges = HashMultimap . create ( ) ; 
 sortedTokens = sortTokens ( ) ; 
 } 
 
 @ @ - 69 , 18 + 89 , 13 @ @ public class TokenMetadata 
 { 
 int n = 0 ; 
 Range sourceRange = getPrimaryRangeFor ( getToken ( source ) ) ; 
 - for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) 
 - { 
 - if ( sourceRange . contains ( entry . getKey ( ) ) | | entry . getValue ( ) . equals ( source ) ) 
 + for ( Token token : bootstrapTokens . keySet ( ) ) 
 + if ( sourceRange . contains ( token ) ) 
 n + + ; 
 - } 
 return n ; 
 } 
 
 - / * * 
 - * Update the two maps in an safe mode . 
 - * / 
 - public void update ( Token token , InetAddress endpoint ) 
 + public void updateNormalToken ( Token token , InetAddress endpoint ) 
 { 
 assert token ! = null ; 
 assert endpoint ! = null ; 
 @ @ - 88 , 6 + 103 , 8 @ @ public class TokenMetadata 
 lock . writeLock ( ) . lock ( ) ; 
 try 
 { 
 + bootstrapTokens . remove ( token ) ; 
 + 
 tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; 
 if ( ! endpoint . equals ( tokenToEndPointMap . put ( token , endpoint ) ) ) 
 { 
 @ @ - 100 , 13 + 117 , 49 @ @ public class TokenMetadata 
 } 
 } 
 
 + public void addBootstrapToken ( Token token , InetAddress endpoint ) 
 + { 
 + assert token ! = null ; 
 + assert endpoint ! = null ; 
 + 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + InetAddress oldEndPoint = bootstrapTokens . get ( token ) ; 
 + if ( oldEndPoint ! = null & & ! oldEndPoint . equals ( endpoint ) ) 
 + throw new RuntimeException ( " Bootstrap Token collision between " + oldEndPoint + " and " + endpoint + " ( token " + token ) ; 
 + bootstrapTokens . put ( token , endpoint ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 + public void addLeavingEndPoint ( InetAddress endpoint ) 
 + { 
 + assert endpoint ! = null ; 
 + 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + leavingEndPoints . add ( endpoint ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 public void removeEndpoint ( InetAddress endpoint ) 
 { 
 assert tokenToEndPointMap . containsValue ( endpoint ) ; 
 lock . writeLock ( ) . lock ( ) ; 
 try 
 { 
 + bootstrapTokens . remove ( getToken ( endpoint ) ) ; 
 tokenToEndPointMap . inverse ( ) . remove ( endpoint ) ; 
 + leavingEndPoints . remove ( endpoint ) ; 
 sortedTokens = sortTokens ( ) ; 
 } 
 finally 
 @ @ - 161 , 7 + 214 , 11 @ @ public class TokenMetadata 
 } 
 } 
 
 - public TokenMetadata cloneWithoutPending ( ) 
 + / * * 
 + * Create a copy of TokenMetadata with only tokenToEndPointMap . That is , pending ranges , 
 + * bootstrap tokens and leaving endpoints are not included in the copy . 
 + * / 
 + public TokenMetadata cloneOnlyTokenMap ( ) 
 { 
 lock . readLock ( ) . lock ( ) ; 
 try 
 @ @ - 174 , 28 + 231 , 24 @ @ public class TokenMetadata 
 } 
 } 
 
 - public String toString ( ) 
 + / * * 
 + * Create a copy of TokenMetadata with tokenToEndPointMap reflecting situation after all 
 + * current leave operations have finished . 
 + * / 
 + public TokenMetadata cloneAfterAllLeft ( ) 
 { 
 - StringBuilder sb = new StringBuilder ( ) ; 
 lock . readLock ( ) . lock ( ) ; 
 try 
 { 
 - Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; 
 - 
 - for ( InetAddress ep : eps ) 
 - { 
 - sb . append ( ep ) ; 
 - sb . append ( " : " ) ; 
 - sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; 
 - sb . append ( System . getProperty ( " line . separator " ) ) ; 
 - } 
 + TokenMetadata allLeftMetadata = cloneOnlyTokenMap ( ) ; 
 + for ( InetAddress endPoint : leavingEndPoints ) 
 + allLeftMetadata . removeEndpoint ( endPoint ) ; 
 + return allLeftMetadata ; 
 } 
 finally 
 { 
 lock . readLock ( ) . unlock ( ) ; 
 } 
 - 
 - return sb . toString ( ) ; 
 } 
 
 public InetAddress getEndPoint ( Token token ) 
 @ @ - 211 , 12 + 264 , 6 @ @ public class TokenMetadata 
 } 
 } 
 
 - public void clearUnsafe ( ) 
 - { 
 - tokenToEndPointMap . clear ( ) ; 
 - pendingRanges . clear ( ) ; 
 - } 
 - 
 public Range getPrimaryRangeFor ( Token right ) 
 { 
 return new Range ( getPredecessor ( right ) , right ) ; 
 @ @ - 235 , 29 + 282 , 16 @ @ public class TokenMetadata 
 } 
 } 
 
 - public void addPendingRange ( Range range , InetAddress endpoint ) 
 - { 
 - InetAddress oldEndpoint = pendingRanges . get ( range ) ; 
 - if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) ) 
 - throw new RuntimeException ( " pending range collision between " + oldEndpoint + " and " + endpoint ) ; 
 - pendingRanges . put ( range , endpoint ) ; 
 - } 
 - 
 - public void removePendingRange ( Range range ) 
 - { 
 - pendingRanges . remove ( range ) ; 
 - } 
 - 
 / * * a mutable map may be returned but caller should not modify it * / 
 - public Map < Range , InetAddress > getPendingRanges ( ) 
 + public Map < Range , Collection < InetAddress > > getPendingRanges ( ) 
 { 
 - return pendingRanges ; 
 + return pendingRanges . asMap ( ) ; 
 } 
 
 public List < Range > getPendingRanges ( InetAddress endpoint ) 
 { 
 List < Range > ranges = new ArrayList < Range > ( ) ; 
 - for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entrySet ( ) ) 
 + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entries ( ) ) 
 { 
 if ( entry . getValue ( ) . equals ( endpoint ) ) 
 { 
 @ @ - 267 , 6 + 301 , 11 @ @ public class TokenMetadata 
 return ranges ; 
 } 
 
 + public void setPendingRanges ( Multimap < Range , InetAddress > pendingRanges ) 
 + { 
 + this . pendingRanges = pendingRanges ; 
 + } 
 + 
 public Token getPredecessor ( Token token ) 
 { 
 List tokens = sortedTokens ( ) ; 
 @ @ - 288 , 8 + 327 , 96 @ @ public class TokenMetadata 
 return getEndPoint ( getSuccessor ( getToken ( endPoint ) ) ) ; 
 } 
 
 - public void clearPendingRanges ( ) 
 + / * * caller should not modify bootstrapTokens * / 
 + public Map < Token , InetAddress > getBootstrapTokens ( ) 
 + { 
 + return bootstrapTokens ; 
 + } 
 + 
 + / * * caller should not modify leavigEndPoints * / 
 + public Set < InetAddress > getLeavingEndPoints ( ) 
 { 
 + return leavingEndPoints ; 
 + } 
 + 
 + / * * used by tests * / 
 + public void clearUnsafe ( ) 
 + { 
 + bootstrapTokens . clear ( ) ; 
 + tokenToEndPointMap . clear ( ) ; 
 + leavingEndPoints . clear ( ) ; 
 pendingRanges . clear ( ) ; 
 } 
 + 
 + public String toString ( ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + lock . readLock ( ) . lock ( ) ; 
 + try 
 + { 
 + Set < InetAddress > eps = tokenToEndPointMap . inverse ( ) . keySet ( ) ; 
 + 
 + if ( ! eps . isEmpty ( ) ) 
 + { 
 + sb . append ( " Normal Tokens : " ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + for ( InetAddress ep : eps ) 
 + { 
 + sb . append ( ep ) ; 
 + sb . append ( " : " ) ; 
 + sb . append ( tokenToEndPointMap . inverse ( ) . get ( ep ) ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 + } 
 + 
 + if ( ! bootstrapTokens . isEmpty ( ) ) 
 + { 
 + sb . append ( " Bootstrapping Tokens : " ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) 
 + { 
 + sb . append ( entry . getValue ( ) + " : " + entry . getKey ( ) ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 + } 
 + 
 + if ( ! leavingEndPoints . isEmpty ( ) ) 
 + { 
 + sb . append ( " Leaving EndPoints : " ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + for ( InetAddress ep : leavingEndPoints ) 
 + { 
 + sb . append ( ep ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 + } 
 + 
 + if ( ! pendingRanges . isEmpty ( ) ) 
 + { 
 + sb . append ( " Pending Ranges : " ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + sb . append ( printPendingRanges ( ) ) ; 
 + } 
 + } 
 + finally 
 + { 
 + lock . readLock ( ) . unlock ( ) ; 
 + } 
 + 
 + return sb . toString ( ) ; 
 + } 
 + 
 + public String printPendingRanges ( ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + 
 + for ( Map . Entry < Range , InetAddress > entry : pendingRanges . entries ( ) ) 
 + { 
 + sb . append ( entry . getValue ( ) + " : " + entry . getKey ( ) ) ; 
 + sb . append ( System . getProperty ( " line . separator " ) ) ; 
 + } 
 + 
 + return sb . toString ( ) ; 
 + } 
 + 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 1dfba20 . . e5f3988 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 183 , 7 + 183 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Setting token to " + token ) ; 
 SystemTable . updateToken ( token ) ; 
 - tokenMetadata _ . update ( token , FBUtilities . getLocalAddress ( ) ) ; 
 + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getLocalAddress ( ) ) ; 
 } 
 
 public StorageService ( ) 
 @ @ - 306 , 7 + 306 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 { 
 SystemTable . setBootstrapped ( true ) ; 
 Token token = storageMetadata _ . getToken ( ) ; 
 - tokenMetadata _ . update ( token , FBUtilities . getLocalAddress ( ) ) ; 
 + tokenMetadata _ . updateNormalToken ( token , FBUtilities . getLocalAddress ( ) ) ; 
 Gossiper . instance ( ) . addApplicationState ( StorageService . STATE _ NORMAL , new ApplicationState ( partitioner _ . getTokenFactory ( ) . toString ( token ) ) ) ; 
 } 
 
 @ @ - 407 , 23 + 407 , 25 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( endpoint + " state bootstrapping , token " + token ) ; 
 - updateBootstrapRanges ( token , endpoint ) ; 
 + tokenMetadata _ . addBootstrapToken ( token , endpoint ) ; 
 + calculatePendingRanges ( ) ; 
 } 
 else if ( STATE _ NORMAL . equals ( stateName ) ) 
 { 
 Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( endpoint + " state normal , token " + token ) ; 
 - tokenMetadata _ . update ( token , endpoint ) ; 
 + tokenMetadata _ . updateNormalToken ( token , endpoint ) ; 
 + calculatePendingRanges ( ) ; 
 if ( ! isClientMode ) 
 SystemTable . updateToken ( endpoint , token ) ; 
 - replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 } 
 else if ( STATE _ LEAVING . equals ( stateName ) ) 
 { 
 Token token = getPartitioner ( ) . getTokenFactory ( ) . fromString ( state . getValue ( ) ) ; 
 assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; 
 - updateLeavingRanges ( endpoint ) ; 
 + tokenMetadata _ . addLeavingEndPoint ( endpoint ) ; 
 + calculatePendingRanges ( ) ; 
 } 
 else if ( STATE _ LEFT . equals ( stateName ) ) 
 { 
 @ @ - 442 , 6 + 444 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 logger _ . debug ( endpoint + " state left , token " + token ) ; 
 assert tokenMetadata _ . getToken ( endpoint ) . equals ( token ) ; 
 tokenMetadata _ . removeEndpoint ( endpoint ) ; 
 + calculatePendingRanges ( ) ; 
 } 
 } 
 else 
 @ @ - 454 , 11 + 457 , 94 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 { 
 restoreReplicaCount ( endPointThatLeft ) ; 
 tokenMetadata _ . removeEndpoint ( endPointThatLeft ) ; 
 + calculatePendingRanges ( ) ; 
 } 
 } 
 + } 
 + } 
 + 
 + / * * 
 + * Calculate pending ranges according to bootsrapping and leaving nodes . Reasoning is : 
 + * 
 + * ( 1 ) When in doubt , it is better to write too much to a node than too little . That is , if 
 + * there are multiple nodes moving , calculate the biggest ranges a node could have . Cleaning 
 + * up unneeded data afterwards is better than missing writes during movement . 
 + * ( 2 ) When a node leaves , ranges for other nodes can only grow ( a node might get additional 
 + * ranges , but it will not lose any of its current ranges as a result of a leave ) . Therefore 
 + * we will first remove _ all _ leaving tokens for the sake of calculation and then check what 
 + * ranges would go where if all nodes are to leave . This way we get the biggest possible 
 + * ranges with regard current leave operations , covering all subsets of possible final range 
 + * values . 
 + * ( 3 ) When a node bootstraps , ranges of other nodes can only get smaller . Without doing 
 + * complex calculations to see if multiple bootstraps overlap , we simply base calculations 
 + * on the same token ring used before ( reflecting situation after all leave operations have 
 + * completed ) . Bootstrapping nodes will be added and removed one by one to that metadata and 
 + * checked what their ranges would be . This will give us the biggest possible ranges the 
 + * node could have . It might be that other bootstraps make our actual final ranges smaller , 
 + * but it does not matter as we can clean up the data afterwards . 
 + * 
 + * NOTE : This is heavy and ineffective operation . This will be done only once when a node 
 + * changes state in the cluster , so it should be manageable . 
 + * / 
 + private void calculatePendingRanges ( ) 
 + { 
 + calculatePendingRanges ( tokenMetadata _ , replicationStrategy _ ) ; 
 + } 
 + 
 + / / public & static for testing purposes 
 + public static void calculatePendingRanges ( TokenMetadata tm , AbstractReplicationStrategy strategy ) 
 + { 
 + Multimap < Range , InetAddress > pendingRanges = HashMultimap . create ( ) ; 
 + Map < Token , InetAddress > bootstrapTokens = tm . getBootstrapTokens ( ) ; 
 + Set < InetAddress > leavingEndPoints = tm . getLeavingEndPoints ( ) ; 
 + 
 + if ( bootstrapTokens . isEmpty ( ) & & leavingEndPoints . isEmpty ( ) ) 
 + { 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " No bootstrapping or leaving nodes - > empty pending ranges " ) ; 
 + tm . setPendingRanges ( pendingRanges ) ; 
 + return ; 
 + } 
 + 
 + Multimap < InetAddress , Range > addressRanges = strategy . getAddressRanges ( ) ; 
 + 
 + / / Copy of metadata reflecting the situation after all leave operations are finished . 
 + TokenMetadata allLeftMetadata = tm . cloneAfterAllLeft ( ) ; 
 + 
 + / / get all ranges that will be affected by leaving nodes 
 + Set < Range > affectedRanges = new HashSet < Range > ( ) ; 
 + for ( InetAddress endPoint : leavingEndPoints ) 
 + affectedRanges . addAll ( addressRanges . get ( endPoint ) ) ; 
 + 
 + / / for each of those ranges , find what new nodes will be responsible for the range when 
 + / / all leaving nodes are gone . 
 + for ( Range range : affectedRanges ) 
 + { 
 + List < InetAddress > currentEndPoints = strategy . getNaturalEndpoints ( range . right ( ) , tm ) ; 
 + List < InetAddress > newEndPoints = strategy . getNaturalEndpoints ( range . right ( ) , allLeftMetadata ) ; 
 + newEndPoints . removeAll ( currentEndPoints ) ; 
 + pendingRanges . putAll ( range , newEndPoints ) ; 
 + } 
 + 
 + / / At this stage pendingRanges has been updated according to leave operations . We can 
 + / / now finish the calculation by checking bootstrapping nodes . 
 + 
 + / / For each of the bootstrapping nodes , simply add and remove them one by one to 
 + / / allLeftMetadata and check in between what their ranges would be . 
 + for ( Map . Entry < Token , InetAddress > entry : bootstrapTokens . entrySet ( ) ) 
 + { 
 + InetAddress endPoint = entry . getValue ( ) ; 
 
 - replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 + allLeftMetadata . updateNormalToken ( entry . getKey ( ) , endPoint ) ; 
 + for ( Range range : strategy . getAddressRanges ( allLeftMetadata ) . get ( endPoint ) ) 
 + pendingRanges . put ( range , endPoint ) ; 
 + allLeftMetadata . removeEndpoint ( endPoint ) ; 
 } 
 + 
 + tm . setPendingRanges ( pendingRanges ) ; 
 + 
 + if ( logger _ . isDebugEnabled ( ) ) 
 + logger _ . debug ( " Pending ranges : \ n " + tm . printPendingRanges ( ) ) ; 
 } 
 
 / * * 
 @ @ - 534 , 7 + 620 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 Collection < Range > ranges = getRangesForEndPoint ( endpoint ) ; 
 
 if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " leaving node ranges are [ " + StringUtils . join ( ranges , " , " ) + " ] " ) ; 
 + logger _ . debug ( " Node " + endpoint + " ranges [ " + StringUtils . join ( ranges , " , " ) + " ] " ) ; 
 
 Map < Range , ArrayList < InetAddress > > currentReplicaEndpoints = new HashMap < Range , ArrayList < InetAddress > > ( ) ; 
 
 @ @ - 542 , 7 + 628 , 7 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 for ( Range range : ranges ) 
 currentReplicaEndpoints . put ( range , replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , tokenMetadata _ ) ) ; 
 
 - TokenMetadata temp = tokenMetadata _ . cloneWithoutPending ( ) ; 
 + TokenMetadata temp = tokenMetadata _ . cloneAfterAllLeft ( ) ; 
 temp . removeEndpoint ( endpoint ) ; 
 
 Multimap < Range , InetAddress > changedRanges = HashMultimap . create ( ) ; 
 @ @ - 557 , 43 + 643 , 13 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 ArrayList < InetAddress > newReplicaEndpoints = replicationStrategy _ . getNaturalEndpoints ( range . right ( ) , temp ) ; 
 newReplicaEndpoints . removeAll ( currentReplicaEndpoints . get ( range ) ) ; 
 if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( " adding pending range " + range + " to endpoints " + StringUtils . join ( newReplicaEndpoints , " , " ) ) ; 
 + logger _ . debug ( " Range " + range + " will be responsibility of " + StringUtils . join ( newReplicaEndpoints , " , " ) ) ; 
 changedRanges . putAll ( range , newReplicaEndpoints ) ; 
 } 
 
 return changedRanges ; 
 } 
 
 - private void updateLeavingRanges ( final InetAddress endpoint ) 
 - { 
 - if ( logger _ . isDebugEnabled ( ) ) 
 - logger _ . debug ( endpoint + " is leaving ; calculating pendingranges " ) ; 
 - Multimap < Range , InetAddress > ranges = getChangedRangesForLeaving ( endpoint ) ; 
 - for ( Range range : ranges . keySet ( ) ) 
 - { 
 - for ( InetAddress newEndpoint : ranges . get ( range ) ) 
 - { 
 - tokenMetadata _ . addPendingRange ( range , newEndpoint ) ; 
 - } 
 - } 
 - } 
 - 
 - private void updateBootstrapRanges ( Token token , InetAddress endpoint ) 
 - { 
 - for ( Range range : replicationStrategy _ . getPendingAddressRanges ( tokenMetadata _ , token , endpoint ) ) 
 - { 
 - tokenMetadata _ . addPendingRange ( range , endpoint ) ; 
 - } 
 - } 
 - 
 - public static void updateBootstrapRanges ( AbstractReplicationStrategy strategy , TokenMetadata metadata , Token token , InetAddress endpoint ) 
 - { 
 - for ( Range range : strategy . getPendingAddressRanges ( metadata , token , endpoint ) ) 
 - { 
 - metadata . addPendingRange ( range , endpoint ) ; 
 - } 
 - } 
 - 
 public void onJoin ( InetAddress endpoint , EndPointState epState ) 
 { 
 for ( Map . Entry < String , ApplicationState > entry : epState . getSortedApplicationStates ( ) ) 
 @ @ - 1117 , 7 + 1173 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 { 
 SystemTable . setBootstrapped ( false ) ; 
 tokenMetadata _ . removeEndpoint ( FBUtilities . getLocalAddress ( ) ) ; 
 - replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " " ) ; 
 @ @ - 1238 , 7 + 1293 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 
 restoreReplicaCount ( endPoint ) ; 
 tokenMetadata _ . removeEndpoint ( endPoint ) ; 
 - replicationStrategy _ . removeObsoletePendingRanges ( ) ; 
 } 
 
 / / This is not the cleanest way as we ' re adding STATE _ LEFT for 
 @ @ - 1261 , 11 + 1315 , 6 @ @ public final class StorageService implements IEndPointStateChangeSubscriber , Sto 
 return replicationStrategy _ ; 
 } 
 
 - public void cancelPendingRanges ( ) 
 - { 
 - tokenMetadata _ . clearPendingRanges ( ) ; 
 - } 
 - 
 public boolean isClientMode ( ) 
 { 
 return isClientMode ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageServiceMBean . java b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 index c09802a . . f4404fb 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageServiceMBean . java 
 @ @ - 141 , 13 + 141 , 6 @ @ public interface StorageServiceMBean 
 public void loadBalance ( ) throws IOException , InterruptedException ; 
 
 / * * 
 - * cancel writes to nodes that are set to be changing ranges . 
 - * Only do this if the reason for the range changes no longer exists 
 - * ( e . g . , a bootstrapping node was killed or crashed . ) 
 - * / 
 - public void cancelPendingRanges ( ) ; 
 - 
 - / * * 
 * removeToken removes token ( and all data associated with 
 * enpoint that had it ) from the ring 
 * / 
 diff - - git a / src / java / org / apache / cassandra / tools / NodeProbe . java b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 index cd87901 . . 0135eb7 100644 
 - - - a / src / java / org / apache / cassandra / tools / NodeProbe . java 
 + + + b / src / java / org / apache / cassandra / tools / NodeProbe . java 
 @ @ - 398 , 11 + 398 , 6 @ @ public class NodeProbe 
 ssProxy . move ( newToken ) ; 
 } 
 
 - public void cancelPendingRanges ( ) 
 - { 
 - ssProxy . cancelPendingRanges ( ) ; 
 - } 
 - 
 public void removeToken ( String token ) 
 { 
 ssProxy . removeToken ( token ) ; 
 @ @ - 503 , 7 + 498 , 7 @ @ public class NodeProbe 
 HelpFormatter hf = new HelpFormatter ( ) ; 
 String header = String . format ( 
 " % nAvailable commands : ring , info , cleanup , compact , cfstats , snapshot [ name ] , clearsnapshot , " + 
 - " tpstats , flush , repair , decommission , move , loadbalance , cancelpending , removetoken , " + 
 + " tpstats , flush , repair , decommission , move , loadbalance , removetoken , " + 
 " getcompactionthreshold , setcompactionthreshold [ minthreshold ] ( [ maxthreshold ] ) " ) ; 
 String usage = String . format ( " java % s - host < arg > < command > % n " , NodeProbe . class . getName ( ) ) ; 
 hf . printHelp ( usage , " " , options , header ) ; 
 @ @ - 578 , 10 + 573 , 6 @ @ public class NodeProbe 
 } 
 probe . move ( arguments [ 1 ] ) ; 
 } 
 - else if ( cmdName . equals ( " cancelpending " ) ) 
 - { 
 - probe . cancelPendingRanges ( ) ; 
 - } 
 else if ( cmdName . equals ( " removetoken " ) ) 
 { 
 if ( arguments . length < = 1 ) 
 diff - - git a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 index b9a5a82 . . c910685 100644 
 - - - a / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 + + + b / test / unit / org / apache / cassandra / dht / BootStrapperTest . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import org . junit . Test ; 
 import com . google . common . collect . Multimap ; 
 import org . apache . cassandra . gms . IFailureDetectionEventListener ; 
 import org . apache . cassandra . gms . IFailureDetector ; 
 + import org . apache . cassandra . gms . ApplicationState ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 @ @ - 61 , 7 + 62 , 8 @ @ public class BootStrapperTest 
 Range range3 = ss . getPrimaryRangeForEndPoint ( three ) ; 
 Token fakeToken = ( ( IPartitioner ) StorageService . getPartitioner ( ) ) . midpoint ( range3 . left ( ) , range3 . right ( ) ) ; 
 assert range3 . contains ( fakeToken ) ; 
 - StorageService . updateBootstrapRanges ( StorageService . instance ( ) . getReplicationStrategy ( ) , tmd , fakeToken , myEndpoint ) ; 
 + ss . onChange ( myEndpoint , StorageService . STATE _ BOOTSTRAPPING , new ApplicationState ( ss . getPartitioner ( ) . getTokenFactory ( ) . toString ( fakeToken ) ) ) ; 
 + tmd = ss . getTokenMetadata ( ) ; 
 
 InetAddress source2 = BootStrapper . getBootstrapSource ( tmd , load ) ; 
 assert two . equals ( source2 ) : source2 ; 
 @ @ - 124 , 7 + 126 , 7 @ @ public class BootStrapperTest 
 for ( int i = 1 ; i < = numOldNodes ; i + + ) 
 { 
 / / leave . 1 for myEndpoint 
 - tmd . update ( p . getRandomToken ( ) , InetAddress . getByName ( " 127 . 0 . 0 . " + ( i + 1 ) ) ) ; 
 + tmd . updateNormalToken ( p . getRandomToken ( ) , InetAddress . getByName ( " 127 . 0 . 0 . " + ( i + 1 ) ) ) ; 
 } 
 } 
 } 
 \ No newline at end of file 
 diff - - git a / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java b / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java 
 index 9169f7d . . c0e6cd2 100644 
 - - - a / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java 
 + + + b / test / unit / org / apache / cassandra / locator / RackUnawareStrategyTest . java 
 @ @ - 79 , 7 + 79 , 7 @ @ public class RackUnawareStrategyTest 
 for ( int i = 0 ; i < endPointTokens . length ; i + + ) 
 { 
 InetAddress ep = InetAddress . getByName ( " 127 . 0 . 0 . " + String . valueOf ( i + 1 ) ) ; 
 - tmd . update ( endPointTokens [ i ] , ep ) ; 
 + tmd . updateNormalToken ( endPointTokens [ i ] , ep ) ; 
 hosts . add ( ep ) ; 
 } 
 
 @ @ - 114 , 15 + 114 , 16 @ @ public class RackUnawareStrategyTest 
 for ( int i = 0 ; i < endPointTokens . length ; i + + ) 
 { 
 InetAddress ep = InetAddress . getByName ( " 127 . 0 . 0 . " + String . valueOf ( i + 1 ) ) ; 
 - tmd . update ( endPointTokens [ i ] , ep ) ; 
 + tmd . updateNormalToken ( endPointTokens [ i ] , ep ) ; 
 hosts . add ( ep ) ; 
 } 
 
 / / Add bootstrap node id = 6 
 Token bsToken = new BigIntegerToken ( String . valueOf ( 25 ) ) ; 
 InetAddress bootstrapEndPoint = InetAddress . getByName ( " 127 . 0 . 0 . 6 " ) ; 
 - StorageService . updateBootstrapRanges ( strategy , tmd , bsToken , bootstrapEndPoint ) ; 
 - 
 + tmd . addBootstrapToken ( bsToken , bootstrapEndPoint ) ; 
 + StorageService . calculatePendingRanges ( tmd , strategy ) ; 
 + 
 for ( int i = 0 ; i < keyTokens . length ; i + + ) 
 { 
 Collection < InetAddress > endPoints = strategy . getWriteEndpoints ( keyTokens [ i ] , strategy . getNaturalEndpoints ( keyTokens [ i ] ) ) ; 
 @ @ - 136 , 6 + 137 , 8 @ @ public class RackUnawareStrategyTest 
 / / for 5 , 15 , 25 this should include bootstrap node 
 if ( i < 3 ) 
 assertTrue ( endPoints . contains ( bootstrapEndPoint ) ) ; 
 + else 
 + assertFalse ( endPoints . contains ( bootstrapEndPoint ) ) ; 
 } 
 } 
 }
