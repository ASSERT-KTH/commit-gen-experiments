BLEU SCORE: 0.11731175160263997

TEST MSG: cqlsh : add tests for CREATE / DROP / DELETE tab completion
GENERATED MSG: cqlsh : Add tests for INSERT , UPDATE tab completion

TEST DIFF (one line): diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ completion . py b / pylib / cqlshlib / test / test _ cqlsh _ completion . py <nl> index 2d22a63 . . 7c2f0cd 100644 <nl> - - - a / pylib / cqlshlib / test / test _ cqlsh _ completion . py <nl> + + + b / pylib / cqlshlib / test / test _ cqlsh _ completion . py <nl> @ @ - 23 , 7 + 23 , 7 @ @ import re <nl> from . basecase import BaseTestCase , cqlsh <nl> from . cassconnect import testrun _ cqlsh <nl> <nl> - BEL = ' \ x07 ' # the terminal - bell character <nl> + BEL = ' \ x07 ' # the terminal - bell character <nl> CTRL _ C = ' \ x03 ' <nl> TAB = ' \ t ' <nl> <nl> @ @ - 35 , 7 + 35 , 9 @ @ COMPLETION _ RESPONSE _ TIME = 0 . 5 <nl> <nl> completion _ separation _ re = re . compile ( r ' \ s + ' ) <nl> <nl> + <nl> class CqlshCompletionCase ( BaseTestCase ) : <nl> + <nl> def setUp ( self ) : <nl> self . cqlsh _ runner = testrun _ cqlsh ( cqlver = cqlsh . DEFAULT _ CQLVER , env = { ' COLUMNS ' : ' 100000 ' } ) <nl> self . cqlsh = self . cqlsh _ runner . _ _ enter _ _ ( ) <nl> @ @ - 67 , 7 + 69 , 7 @ @ class CqlshCompletionCase ( BaseTestCase ) : <nl> if choice _ output = = BEL : <nl> choice _ output = ' ' <nl> <nl> - self . cqlsh . send ( CTRL _ C ) # cancel any current line <nl> + self . cqlsh . send ( CTRL _ C ) # cancel any current line <nl> self . cqlsh . read _ to _ next _ prompt ( ) <nl> <nl> choice _ lines = choice _ output . splitlines ( ) <nl> @ @ - 127 , 12 + 129 , 13 @ @ class CqlshCompletionCase ( BaseTestCase ) : <nl> other _ choices _ ok = other _ choices _ ok , <nl> split _ completed _ lines = split _ completed _ lines ) <nl> finally : <nl> - self . cqlsh . send ( CTRL _ C ) # cancel any current line <nl> + self . cqlsh . send ( CTRL _ C ) # cancel any current line <nl> self . cqlsh . read _ to _ next _ prompt ( ) <nl> <nl> def strategies ( self ) : <nl> return self . module . CqlRuleSet . replication _ strategies <nl> <nl> + <nl> class TestCqlshCompletion ( CqlshCompletionCase ) : <nl> cqlver = ' 3 . 1 . 6 ' <nl> module = cqlsh . cql3handling <nl> @ @ - 301 , 7 + 304 , 6 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : <nl> " VALUES ( ' eggs ' , ' sausage ' , ' spam ' ) USING TTL 0 AND TIMESTAMP 0 AND " ) , <nl> choices = [ ] ) <nl> <nl> - <nl> def test _ complete _ in _ update ( self ) : <nl> self . trycompletions ( " UPD " , immediate = " ATE " ) <nl> self . trycompletions ( " UPDATE " , <nl> @ @ - 312 , 7 + 314 , 7 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : <nl> ' undefined _ values _ table ' , <nl> ' dynamic _ columns ' , <nl> ' twenty _ rows _ composite _ table ' , <nl> - ' utf8 _ with _ special _ chars ' , ' ks . ' , <nl> + ' utf8 _ with _ special _ chars ' , <nl> ' system _ traces . ' , ' songs ' ] , <nl> other _ choices _ ok = True ) <nl> <nl> @ @ - 365 , 7 + 367 , 91 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : <nl> choices = [ ' > = ' , ' ! = ' , ' < = ' , ' IN ' , ' [ ' , ' ; ' , ' = ' , ' < ' , ' > ' ] ) <nl> <nl> def test _ complete _ in _ delete ( self ) : <nl> - pass <nl> + self . trycompletions ( ' DELETE F ' , choices = [ ' FROM ' , ' < identifier > ' , ' < quotedName > ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE a ' , choices = [ ' FROM ' , ' [ ' , ' , ' ] ) <nl> + self . trycompletions ( ' DELETE a [ ' , <nl> + choices = [ ' < wholenumber > ' , ' false ' , ' - ' , ' < uuid > ' , <nl> + ' < pgStringLiteral > ' , ' < float > ' , ' TOKEN ' , <nl> + ' < identifier > ' , ' < quotedStringLiteral > ' , <nl> + ' { ' , ' [ ' , ' NULL ' , ' true ' , ' < blobLiteral > ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE a , ' , <nl> + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE a FROM ' , <nl> + choices = [ ' twenty _ rows _ table ' , <nl> + ' ascii _ with _ special _ chars ' , ' users ' , <nl> + ' has _ all _ types ' , ' system . ' , <nl> + ' empty _ composite _ table ' , ' empty _ table ' , <nl> + ' system _ auth . ' , ' undefined _ values _ table ' , <nl> + ' dynamic _ columns ' , <nl> + ' twenty _ rows _ composite _ table ' , <nl> + ' utf8 _ with _ special _ chars ' , <nl> + ' system _ traces . ' , ' songs ' , <nl> + ' " ' + self . cqlsh . keyspace + ' " . ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE FROM ' , <nl> + choices = [ ' twenty _ rows _ table ' , <nl> + ' ascii _ with _ special _ chars ' , ' users ' , <nl> + ' has _ all _ types ' , ' system . ' , <nl> + ' empty _ composite _ table ' , ' empty _ table ' , <nl> + ' system _ auth . ' , ' undefined _ values _ table ' , <nl> + ' dynamic _ columns ' , <nl> + ' twenty _ rows _ composite _ table ' , <nl> + ' utf8 _ with _ special _ chars ' , <nl> + ' system _ traces . ' , ' songs ' , <nl> + ' " ' + self . cqlsh . keyspace + ' " . ' ] ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table ' , <nl> + choices = [ ' USING ' , ' WHERE ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table U ' , <nl> + immediate = ' SING TIMESTAMP ' ) <nl> + <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP ' , <nl> + choices = [ ' < wholenumber > ' ] ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 ' , <nl> + choices = [ ' < wholenumber > ' ] ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 ' , <nl> + immediate = ' WHERE ' ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' , <nl> + choices = [ ' a ' , ' b ' , ' TOKEN ( ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE a ' , <nl> + choices = [ ' < = ' , ' > = ' , ' CONTAINS ' , ' IN ' , ' [ ' , ' = ' , ' < ' , ' > ' ] ) <nl> + <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( ' , <nl> + immediate = ' a ' ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ' , <nl> + immediate = ' ' ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ' , <nl> + choices = [ ' ) ' , ' , ' ] ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ) ' , <nl> + choices = [ ' > = ' , ' < = ' , ' = ' , ' < ' , ' > ' ] ) <nl> + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ) > = ' , <nl> + choices = [ ' false ' , ' true ' , ' < pgStringLiteral > ' , <nl> + ' token ( ' , ' - ' , ' < float > ' , ' TOKEN ' , <nl> + ' < identifier > ' , ' < uuid > ' , ' { ' , ' [ ' , ' NULL ' , <nl> + ' < quotedStringLiteral > ' , ' < blobLiteral > ' , <nl> + ' < wholenumber > ' ] ) <nl> + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' <nl> + ' TOKEN ( a ) > = TOKEN ( 0 ) ' ) , <nl> + choices = [ ' AND ' , ' IF ' , ' ; ' ] ) <nl> + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' <nl> + ' TOKEN ( a ) > = TOKEN ( 0 ) IF ' ) , <nl> + choices = [ ' EXISTS ' , ' < identifier > ' , ' < quotedName > ' ] ) <nl> + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' <nl> + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b ' ) , <nl> + choices = [ ' > = ' , ' ! = ' , ' < = ' , ' IN ' , ' [ ' , ' = ' , ' < ' , ' > ' ] ) <nl> + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' <nl> + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b < 0 ' ) , <nl> + choices = [ ' AND ' , ' ; ' ] ) <nl> + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' <nl> + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b < 0 AND ' ) , <nl> + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) <nl> + self . trycompletions ( ( " DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE " <nl> + " b = ' eggs ' " ) , <nl> + choices = [ ' AND ' , ' IF ' , ' ; ' ] ) <nl> <nl> def test _ complete _ in _ batch ( self ) : <nl> pass <nl> @ @ - 428 , 11 + 514 , 150 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : <nl> self . trycompletions ( " create keyspace blah with replication = { ' class ' : ' Sim " , <nl> " pleStrategy ' " ) <nl> <nl> + def test _ complete _ in _ drop ( self ) : <nl> + self . trycompletions ( ' DR ' , immediate = ' OP ' ) <nl> + self . trycompletions ( ' DROP ' , <nl> + choices = [ ' AGGREGATE ' , ' COLUMNFAMILY ' , ' FUNCTION ' , <nl> + ' INDEX ' , ' KEYSPACE ' , ' ROLE ' , ' TABLE ' , <nl> + ' TRIGGER ' , ' TYPE ' , ' USER ' ] ) <nl> + <nl> def test _ complete _ in _ drop _ keyspace ( self ) : <nl> - pass <nl> + self . trycompletions ( ' DROP K ' , immediate = ' EYSPACE ' ) <nl> + quoted _ keyspace = ' " ' + self . cqlsh . keyspace + ' " ' <nl> + self . trycompletions ( ' DROP KEYSPACE ' , <nl> + choices = [ ' IF ' , quoted _ keyspace ] ) <nl> + <nl> + self . trycompletions ( ' DROP KEYSPACE ' + quoted _ keyspace , <nl> + choices = [ ' ; ' ] ) <nl> + <nl> + self . trycompletions ( ' DROP KEYSPACE I ' , <nl> + immediate = ' F EXISTS ' + quoted _ keyspace + ' ; ' ) <nl> + <nl> + def create _ columnfamily _ table _ template ( self , name ) : <nl> + " " " Parameterized test for CREATE COLUMNFAMILY and CREATE TABLE . Since <nl> + they ' re synonyms , they should have the same completion behavior , so this <nl> + test avoids duplication between tests for the two statements . " " " <nl> + prefix = ' CREATE ' + name + ' ' <nl> + quoted _ keyspace = ' " ' + self . cqlsh . keyspace + ' " ' <nl> + self . trycompletions ( prefix + ' ' , <nl> + choices = [ ' IF ' , quoted _ keyspace , ' < new _ table _ name > ' ] ) <nl> + self . trycompletions ( prefix + ' IF ' , <nl> + immediate = ' NOT EXISTS ' ) <nl> + self . trycompletions ( prefix + ' IF NOT EXISTS ' , <nl> + choices = [ ' < new _ table _ name > ' , quoted _ keyspace ] ) <nl> + self . trycompletions ( prefix + ' IF NOT EXISTS new _ table ' , <nl> + immediate = ' ( ' ) <nl> + <nl> + self . trycompletions ( prefix + quoted _ keyspace , choices = [ ' . ' , ' ( ' ] ) <nl> + <nl> + self . trycompletions ( prefix + quoted _ keyspace + ' ( ' , <nl> + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , <nl> + ' < quotedName > ' ] ) <nl> + <nl> + self . trycompletions ( prefix + quoted _ keyspace + ' . ' , <nl> + choices = [ ' < new _ table _ name > ' ] ) <nl> + self . trycompletions ( prefix + quoted _ keyspace + ' . new _ table ' , <nl> + immediate = ' ( ' ) <nl> + self . trycompletions ( prefix + quoted _ keyspace + ' . new _ table ( ' , <nl> + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , <nl> + ' < quotedName > ' ] ) <nl> + <nl> + self . trycompletions ( prefix + ' new _ table ( ' , <nl> + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , <nl> + ' < quotedName > ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a ine ' , <nl> + immediate = ' t ' ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int ' , <nl> + choices = [ ' , ' , ' PRIMARY ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int P ' , <nl> + immediate = ' RIMARY KEY ' ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ' , <nl> + choices = [ ' ) ' , ' , ' ] ) <nl> + <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY , ' , <nl> + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) ' , <nl> + immediate = ' ' ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) ' , <nl> + choices = [ ' ; ' , ' WITH ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) W ' , <nl> + immediate = ' ITH ' ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH ' , <nl> + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , <nl> + ' compression ' , <nl> + ' dclocal _ read _ repair _ chance ' , <nl> + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , <nl> + ' max _ index _ interval ' , <nl> + ' memtable _ flush _ period _ in _ ms ' , <nl> + ' read _ repair _ chance ' , ' CLUSTERING ' , <nl> + ' COMPACT ' , ' caching ' , ' comment ' , <nl> + ' min _ index _ interval ' , ' speculative _ retry ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH ' , <nl> + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , <nl> + ' compression ' , <nl> + ' dclocal _ read _ repair _ chance ' , <nl> + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , <nl> + ' max _ index _ interval ' , <nl> + ' memtable _ flush _ period _ in _ ms ' , <nl> + ' read _ repair _ chance ' , ' CLUSTERING ' , <nl> + ' COMPACT ' , ' caching ' , ' comment ' , <nl> + ' min _ index _ interval ' , ' speculative _ retry ' ] ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH bloom _ filter _ fp _ chance ' , <nl> + immediate = ' = ' ) <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH bloom _ filter _ fp _ chance = ' , <nl> + choices = [ ' < float _ between _ 0 _ and _ 1 > ' ] ) <nl> + <nl> + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH compaction ' , <nl> + immediate = " = { ' class ' : ' " ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' " , <nl> + choices = [ ' SizeTieredCompactionStrategy ' , <nl> + ' LeveledCompactionStrategy ' , <nl> + ' DateTieredCompactionStrategy ' ] ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' S " , <nl> + immediate = " izeTieredCompactionStrategy ' " ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy " , <nl> + immediate = " ' " ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy ' " , <nl> + choices = [ ' } ' , ' , ' ] ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy ' , " , <nl> + immediate = " ' " ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy ' , ' " , <nl> + choices = [ ' bucket _ high ' , ' bucket _ low ' , ' class ' , <nl> + ' enabled ' , ' max _ threshold ' , <nl> + ' min _ sstable _ size ' , ' min _ threshold ' , <nl> + ' tombstone _ compaction _ interval ' , <nl> + ' tombstone _ threshold ' , <nl> + ' unchecked _ tombstone _ compaction ' , ] ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy ' } " , <nl> + choices = [ ' ; ' , ' AND ' ] ) <nl> + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " <nl> + + " { ' class ' : ' SizeTieredCompactionStrategy ' } AND " , <nl> + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , <nl> + ' compression ' , <nl> + ' dclocal _ read _ repair _ chance ' , <nl> + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , <nl> + ' max _ index _ interval ' , <nl> + ' memtable _ flush _ period _ in _ ms ' , <nl> + ' read _ repair _ chance ' , ' CLUSTERING ' , <nl> + ' COMPACT ' , ' caching ' , ' comment ' , <nl> + ' min _ index _ interval ' , ' speculative _ retry ' ] ) <nl> <nl> def test _ complete _ in _ create _ columnfamily ( self ) : <nl> - pass <nl> + self . trycompletions ( ' CREATE C ' , choices = [ ' COLUMNFAMILY ' , ' CUSTOM ' ] ) <nl> + self . trycompletions ( ' CREATE CO ' , immediate = ' LUMNFAMILY ' ) <nl> + self . create _ columnfamily _ table _ template ( ' COLUMNFAMILY ' ) <nl> + <nl> + def test _ complete _ in _ create _ table ( self ) : <nl> + self . trycompletions ( ' CREATE T ' , choices = [ ' TRIGGER ' , ' TABLE ' , ' TYPE ' ] ) <nl> + self . trycompletions ( ' CREATE TA ' , immediate = ' BLE ' ) <nl> + self . create _ columnfamily _ table _ template ( ' TABLE ' ) <nl> <nl> def test _ complete _ in _ drop _ columnfamily ( self ) : <nl> pass
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / pylib / cqlshlib / test / test _ cqlsh _ completion . py b / pylib / cqlshlib / test / test _ cqlsh _ completion . py 
 index 2d22a63 . . 7c2f0cd 100644 
 - - - a / pylib / cqlshlib / test / test _ cqlsh _ completion . py 
 + + + b / pylib / cqlshlib / test / test _ cqlsh _ completion . py 
 @ @ - 23 , 7 + 23 , 7 @ @ import re 
 from . basecase import BaseTestCase , cqlsh 
 from . cassconnect import testrun _ cqlsh 
 
 - BEL = ' \ x07 ' # the terminal - bell character 
 + BEL = ' \ x07 ' # the terminal - bell character 
 CTRL _ C = ' \ x03 ' 
 TAB = ' \ t ' 
 
 @ @ - 35 , 7 + 35 , 9 @ @ COMPLETION _ RESPONSE _ TIME = 0 . 5 
 
 completion _ separation _ re = re . compile ( r ' \ s + ' ) 
 
 + 
 class CqlshCompletionCase ( BaseTestCase ) : 
 + 
 def setUp ( self ) : 
 self . cqlsh _ runner = testrun _ cqlsh ( cqlver = cqlsh . DEFAULT _ CQLVER , env = { ' COLUMNS ' : ' 100000 ' } ) 
 self . cqlsh = self . cqlsh _ runner . _ _ enter _ _ ( ) 
 @ @ - 67 , 7 + 69 , 7 @ @ class CqlshCompletionCase ( BaseTestCase ) : 
 if choice _ output = = BEL : 
 choice _ output = ' ' 
 
 - self . cqlsh . send ( CTRL _ C ) # cancel any current line 
 + self . cqlsh . send ( CTRL _ C ) # cancel any current line 
 self . cqlsh . read _ to _ next _ prompt ( ) 
 
 choice _ lines = choice _ output . splitlines ( ) 
 @ @ - 127 , 12 + 129 , 13 @ @ class CqlshCompletionCase ( BaseTestCase ) : 
 other _ choices _ ok = other _ choices _ ok , 
 split _ completed _ lines = split _ completed _ lines ) 
 finally : 
 - self . cqlsh . send ( CTRL _ C ) # cancel any current line 
 + self . cqlsh . send ( CTRL _ C ) # cancel any current line 
 self . cqlsh . read _ to _ next _ prompt ( ) 
 
 def strategies ( self ) : 
 return self . module . CqlRuleSet . replication _ strategies 
 
 + 
 class TestCqlshCompletion ( CqlshCompletionCase ) : 
 cqlver = ' 3 . 1 . 6 ' 
 module = cqlsh . cql3handling 
 @ @ - 301 , 7 + 304 , 6 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : 
 " VALUES ( ' eggs ' , ' sausage ' , ' spam ' ) USING TTL 0 AND TIMESTAMP 0 AND " ) , 
 choices = [ ] ) 
 
 - 
 def test _ complete _ in _ update ( self ) : 
 self . trycompletions ( " UPD " , immediate = " ATE " ) 
 self . trycompletions ( " UPDATE " , 
 @ @ - 312 , 7 + 314 , 7 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : 
 ' undefined _ values _ table ' , 
 ' dynamic _ columns ' , 
 ' twenty _ rows _ composite _ table ' , 
 - ' utf8 _ with _ special _ chars ' , ' ks . ' , 
 + ' utf8 _ with _ special _ chars ' , 
 ' system _ traces . ' , ' songs ' ] , 
 other _ choices _ ok = True ) 
 
 @ @ - 365 , 7 + 367 , 91 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : 
 choices = [ ' > = ' , ' ! = ' , ' < = ' , ' IN ' , ' [ ' , ' ; ' , ' = ' , ' < ' , ' > ' ] ) 
 
 def test _ complete _ in _ delete ( self ) : 
 - pass 
 + self . trycompletions ( ' DELETE F ' , choices = [ ' FROM ' , ' < identifier > ' , ' < quotedName > ' ] ) 
 + 
 + self . trycompletions ( ' DELETE a ' , choices = [ ' FROM ' , ' [ ' , ' , ' ] ) 
 + self . trycompletions ( ' DELETE a [ ' , 
 + choices = [ ' < wholenumber > ' , ' false ' , ' - ' , ' < uuid > ' , 
 + ' < pgStringLiteral > ' , ' < float > ' , ' TOKEN ' , 
 + ' < identifier > ' , ' < quotedStringLiteral > ' , 
 + ' { ' , ' [ ' , ' NULL ' , ' true ' , ' < blobLiteral > ' ] ) 
 + 
 + self . trycompletions ( ' DELETE a , ' , 
 + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) 
 + 
 + self . trycompletions ( ' DELETE a FROM ' , 
 + choices = [ ' twenty _ rows _ table ' , 
 + ' ascii _ with _ special _ chars ' , ' users ' , 
 + ' has _ all _ types ' , ' system . ' , 
 + ' empty _ composite _ table ' , ' empty _ table ' , 
 + ' system _ auth . ' , ' undefined _ values _ table ' , 
 + ' dynamic _ columns ' , 
 + ' twenty _ rows _ composite _ table ' , 
 + ' utf8 _ with _ special _ chars ' , 
 + ' system _ traces . ' , ' songs ' , 
 + ' " ' + self . cqlsh . keyspace + ' " . ' ] ) 
 + 
 + self . trycompletions ( ' DELETE FROM ' , 
 + choices = [ ' twenty _ rows _ table ' , 
 + ' ascii _ with _ special _ chars ' , ' users ' , 
 + ' has _ all _ types ' , ' system . ' , 
 + ' empty _ composite _ table ' , ' empty _ table ' , 
 + ' system _ auth . ' , ' undefined _ values _ table ' , 
 + ' dynamic _ columns ' , 
 + ' twenty _ rows _ composite _ table ' , 
 + ' utf8 _ with _ special _ chars ' , 
 + ' system _ traces . ' , ' songs ' , 
 + ' " ' + self . cqlsh . keyspace + ' " . ' ] ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table ' , 
 + choices = [ ' USING ' , ' WHERE ' ] ) 
 + 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table U ' , 
 + immediate = ' SING TIMESTAMP ' ) 
 + 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP ' , 
 + choices = [ ' < wholenumber > ' ] ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 ' , 
 + choices = [ ' < wholenumber > ' ] ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 ' , 
 + immediate = ' WHERE ' ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' , 
 + choices = [ ' a ' , ' b ' , ' TOKEN ( ' ] ) 
 + 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE a ' , 
 + choices = [ ' < = ' , ' > = ' , ' CONTAINS ' , ' IN ' , ' [ ' , ' = ' , ' < ' , ' > ' ] ) 
 + 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( ' , 
 + immediate = ' a ' ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ' , 
 + immediate = ' ' ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ' , 
 + choices = [ ' ) ' , ' , ' ] ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ) ' , 
 + choices = [ ' > = ' , ' < = ' , ' = ' , ' < ' , ' > ' ] ) 
 + self . trycompletions ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE TOKEN ( a ) > = ' , 
 + choices = [ ' false ' , ' true ' , ' < pgStringLiteral > ' , 
 + ' token ( ' , ' - ' , ' < float > ' , ' TOKEN ' , 
 + ' < identifier > ' , ' < uuid > ' , ' { ' , ' [ ' , ' NULL ' , 
 + ' < quotedStringLiteral > ' , ' < blobLiteral > ' , 
 + ' < wholenumber > ' ] ) 
 + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' 
 + ' TOKEN ( a ) > = TOKEN ( 0 ) ' ) , 
 + choices = [ ' AND ' , ' IF ' , ' ; ' ] ) 
 + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' 
 + ' TOKEN ( a ) > = TOKEN ( 0 ) IF ' ) , 
 + choices = [ ' EXISTS ' , ' < identifier > ' , ' < quotedName > ' ] ) 
 + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' 
 + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b ' ) , 
 + choices = [ ' > = ' , ' ! = ' , ' < = ' , ' IN ' , ' [ ' , ' = ' , ' < ' , ' > ' ] ) 
 + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' 
 + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b < 0 ' ) , 
 + choices = [ ' AND ' , ' ; ' ] ) 
 + self . trycompletions ( ( ' DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE ' 
 + ' TOKEN ( a ) > = TOKEN ( 0 ) IF b < 0 AND ' ) , 
 + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) 
 + self . trycompletions ( ( " DELETE FROM twenty _ rows _ composite _ table USING TIMESTAMP 0 WHERE " 
 + " b = ' eggs ' " ) , 
 + choices = [ ' AND ' , ' IF ' , ' ; ' ] ) 
 
 def test _ complete _ in _ batch ( self ) : 
 pass 
 @ @ - 428 , 11 + 514 , 150 @ @ class TestCqlshCompletion ( CqlshCompletionCase ) : 
 self . trycompletions ( " create keyspace blah with replication = { ' class ' : ' Sim " , 
 " pleStrategy ' " ) 
 
 + def test _ complete _ in _ drop ( self ) : 
 + self . trycompletions ( ' DR ' , immediate = ' OP ' ) 
 + self . trycompletions ( ' DROP ' , 
 + choices = [ ' AGGREGATE ' , ' COLUMNFAMILY ' , ' FUNCTION ' , 
 + ' INDEX ' , ' KEYSPACE ' , ' ROLE ' , ' TABLE ' , 
 + ' TRIGGER ' , ' TYPE ' , ' USER ' ] ) 
 + 
 def test _ complete _ in _ drop _ keyspace ( self ) : 
 - pass 
 + self . trycompletions ( ' DROP K ' , immediate = ' EYSPACE ' ) 
 + quoted _ keyspace = ' " ' + self . cqlsh . keyspace + ' " ' 
 + self . trycompletions ( ' DROP KEYSPACE ' , 
 + choices = [ ' IF ' , quoted _ keyspace ] ) 
 + 
 + self . trycompletions ( ' DROP KEYSPACE ' + quoted _ keyspace , 
 + choices = [ ' ; ' ] ) 
 + 
 + self . trycompletions ( ' DROP KEYSPACE I ' , 
 + immediate = ' F EXISTS ' + quoted _ keyspace + ' ; ' ) 
 + 
 + def create _ columnfamily _ table _ template ( self , name ) : 
 + " " " Parameterized test for CREATE COLUMNFAMILY and CREATE TABLE . Since 
 + they ' re synonyms , they should have the same completion behavior , so this 
 + test avoids duplication between tests for the two statements . " " " 
 + prefix = ' CREATE ' + name + ' ' 
 + quoted _ keyspace = ' " ' + self . cqlsh . keyspace + ' " ' 
 + self . trycompletions ( prefix + ' ' , 
 + choices = [ ' IF ' , quoted _ keyspace , ' < new _ table _ name > ' ] ) 
 + self . trycompletions ( prefix + ' IF ' , 
 + immediate = ' NOT EXISTS ' ) 
 + self . trycompletions ( prefix + ' IF NOT EXISTS ' , 
 + choices = [ ' < new _ table _ name > ' , quoted _ keyspace ] ) 
 + self . trycompletions ( prefix + ' IF NOT EXISTS new _ table ' , 
 + immediate = ' ( ' ) 
 + 
 + self . trycompletions ( prefix + quoted _ keyspace , choices = [ ' . ' , ' ( ' ] ) 
 + 
 + self . trycompletions ( prefix + quoted _ keyspace + ' ( ' , 
 + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , 
 + ' < quotedName > ' ] ) 
 + 
 + self . trycompletions ( prefix + quoted _ keyspace + ' . ' , 
 + choices = [ ' < new _ table _ name > ' ] ) 
 + self . trycompletions ( prefix + quoted _ keyspace + ' . new _ table ' , 
 + immediate = ' ( ' ) 
 + self . trycompletions ( prefix + quoted _ keyspace + ' . new _ table ( ' , 
 + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , 
 + ' < quotedName > ' ] ) 
 + 
 + self . trycompletions ( prefix + ' new _ table ( ' , 
 + choices = [ ' < new _ column _ name > ' , ' < identifier > ' , 
 + ' < quotedName > ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a ine ' , 
 + immediate = ' t ' ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int ' , 
 + choices = [ ' , ' , ' PRIMARY ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int P ' , 
 + immediate = ' RIMARY KEY ' ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ' , 
 + choices = [ ' ) ' , ' , ' ] ) 
 + 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY , ' , 
 + choices = [ ' < identifier > ' , ' < quotedName > ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) ' , 
 + immediate = ' ' ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) ' , 
 + choices = [ ' ; ' , ' WITH ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) W ' , 
 + immediate = ' ITH ' ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH ' , 
 + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , 
 + ' compression ' , 
 + ' dclocal _ read _ repair _ chance ' , 
 + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , 
 + ' max _ index _ interval ' , 
 + ' memtable _ flush _ period _ in _ ms ' , 
 + ' read _ repair _ chance ' , ' CLUSTERING ' , 
 + ' COMPACT ' , ' caching ' , ' comment ' , 
 + ' min _ index _ interval ' , ' speculative _ retry ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH ' , 
 + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , 
 + ' compression ' , 
 + ' dclocal _ read _ repair _ chance ' , 
 + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , 
 + ' max _ index _ interval ' , 
 + ' memtable _ flush _ period _ in _ ms ' , 
 + ' read _ repair _ chance ' , ' CLUSTERING ' , 
 + ' COMPACT ' , ' caching ' , ' comment ' , 
 + ' min _ index _ interval ' , ' speculative _ retry ' ] ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH bloom _ filter _ fp _ chance ' , 
 + immediate = ' = ' ) 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH bloom _ filter _ fp _ chance = ' , 
 + choices = [ ' < float _ between _ 0 _ and _ 1 > ' ] ) 
 + 
 + self . trycompletions ( prefix + ' new _ table ( col _ a int PRIMARY KEY ) WITH compaction ' , 
 + immediate = " = { ' class ' : ' " ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' " , 
 + choices = [ ' SizeTieredCompactionStrategy ' , 
 + ' LeveledCompactionStrategy ' , 
 + ' DateTieredCompactionStrategy ' ] ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' S " , 
 + immediate = " izeTieredCompactionStrategy ' " ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy " , 
 + immediate = " ' " ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy ' " , 
 + choices = [ ' } ' , ' , ' ] ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy ' , " , 
 + immediate = " ' " ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy ' , ' " , 
 + choices = [ ' bucket _ high ' , ' bucket _ low ' , ' class ' , 
 + ' enabled ' , ' max _ threshold ' , 
 + ' min _ sstable _ size ' , ' min _ threshold ' , 
 + ' tombstone _ compaction _ interval ' , 
 + ' tombstone _ threshold ' , 
 + ' unchecked _ tombstone _ compaction ' , ] ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy ' } " , 
 + choices = [ ' ; ' , ' AND ' ] ) 
 + self . trycompletions ( prefix + " new _ table ( col _ a int PRIMARY KEY ) WITH compaction = " 
 + + " { ' class ' : ' SizeTieredCompactionStrategy ' } AND " , 
 + choices = [ ' bloom _ filter _ fp _ chance ' , ' compaction ' , 
 + ' compression ' , 
 + ' dclocal _ read _ repair _ chance ' , 
 + ' default _ time _ to _ live ' , ' gc _ grace _ seconds ' , 
 + ' max _ index _ interval ' , 
 + ' memtable _ flush _ period _ in _ ms ' , 
 + ' read _ repair _ chance ' , ' CLUSTERING ' , 
 + ' COMPACT ' , ' caching ' , ' comment ' , 
 + ' min _ index _ interval ' , ' speculative _ retry ' ] ) 
 
 def test _ complete _ in _ create _ columnfamily ( self ) : 
 - pass 
 + self . trycompletions ( ' CREATE C ' , choices = [ ' COLUMNFAMILY ' , ' CUSTOM ' ] ) 
 + self . trycompletions ( ' CREATE CO ' , immediate = ' LUMNFAMILY ' ) 
 + self . create _ columnfamily _ table _ template ( ' COLUMNFAMILY ' ) 
 + 
 + def test _ complete _ in _ create _ table ( self ) : 
 + self . trycompletions ( ' CREATE T ' , choices = [ ' TRIGGER ' , ' TABLE ' , ' TYPE ' ] ) 
 + self . trycompletions ( ' CREATE TA ' , immediate = ' BLE ' ) 
 + self . create _ columnfamily _ table _ template ( ' TABLE ' ) 
 
 def test _ complete _ in _ drop _ columnfamily ( self ) : 
 pass

NEAREST DIFF:
ELIMINATEDSENTENCE
