BLEU SCORE: 0.056697911109760024

TEST MSG: Fix migration of pk - only compact storage tables
GENERATED MSG: Fix ALTER RENAME post - 5125

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d405a4d . . 7f061c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 4 , 7 + 4 , 7 @ @ <nl> * Change CREATE / ALTER TABLE syntax for compression ( CASSANDRA - 8384 ) <nl> * Cleanup crc and adler code for java 8 ( CASSANDRA - 9650 ) <nl> * Storage engine refactor ( CASSANDRA - 8099 , 9743 , 9746 , 9759 , 9781 , 9808 , 9825 , 9848 , <nl> - 9705 , 9859 , 9867 ) <nl> + 9705 , 9859 , 9867 , 9874 ) <nl> * Update Guava to 18 . 0 ( CASSANDRA - 9653 ) <nl> * Bloom filter false positive ratio is not honoured ( CASSANDRA - 8413 ) <nl> * New option for cassandra - stress to leave a ratio of columns null ( CASSANDRA - 9522 ) <nl> diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> index f554ffb . . 7326fa9 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> @ @ - 296 , 7 + 296 , 16 @ @ public final class LegacySchemaMigrator <nl> needsUpgrade ) ; <nl> <nl> if ( needsUpgrade ) <nl> - addDefinitionForUpgrade ( columnDefs , ksName , cfName , isStaticCompactTable , isSuper , rawComparator , subComparator , defaultValidator ) ; <nl> + { <nl> + addDefinitionForUpgrade ( columnDefs , <nl> + ksName , <nl> + cfName , <nl> + isStaticCompactTable , <nl> + isSuper , <nl> + rawComparator , <nl> + subComparator , <nl> + defaultValidator ) ; <nl> + } <nl> <nl> CFMetaData cfm = CFMetaData . create ( ksName , cfName , cfId , isDense , isCompound , isSuper , isCounter , columnDefs ) ; <nl> <nl> @ @ - 355 , 7 + 364 , 33 @ @ public final class LegacySchemaMigrator <nl> return ! hasKind ( defs , ColumnDefinition . Kind . STATIC ) ; <nl> <nl> / / For dense compact tables , we need to upgrade if we don ' t have a compact value definition <nl> - return ! hasKind ( defs , ColumnDefinition . Kind . REGULAR ) ; <nl> + return ! hasRegularColumns ( defs ) ; <nl> + } <nl> + <nl> + private static boolean hasRegularColumns ( UntypedResultSet columnRows ) <nl> + { <nl> + for ( UntypedResultSet . Row row : columnRows ) <nl> + { <nl> + / * <nl> + * We need to special case and ignore the empty compact column ( pre - 3 . 0 , COMPACT STORAGE , primary - key only tables ) , <nl> + * since deserializeKind ( ) will otherwise just return a REGULAR . <nl> + * We want the proper EmptyType regular column to be added by addDefinitionForUpgrade ( ) , so we need <nl> + * checkNeedsUpgrade ( ) to return true in this case . <nl> + * See CASSANDRA - 9874 . <nl> + * / <nl> + if ( isEmptyCompactValueColumn ( row ) ) <nl> + return false ; <nl> + <nl> + if ( deserializeKind ( row . getString ( " type " ) ) = = ColumnDefinition . Kind . REGULAR ) <nl> + return true ; <nl> + } <nl> + <nl> + return false ; <nl> + } <nl> + <nl> + private static boolean isEmptyCompactValueColumn ( UntypedResultSet . Row row ) <nl> + { <nl> + return " compact _ value " . equals ( row . getString ( " type " ) ) & & row . getString ( " column _ name " ) . isEmpty ( ) ; <nl> } <nl> <nl> private static void addDefinitionForUpgrade ( List < ColumnDefinition > defs , <nl> @ @ - 389 , 10 + 424 , 9 @ @ public final class LegacySchemaMigrator <nl> private static boolean hasKind ( UntypedResultSet defs , ColumnDefinition . Kind kind ) <nl> { <nl> for ( UntypedResultSet . Row row : defs ) <nl> - { <nl> if ( deserializeKind ( row . getString ( " type " ) ) = = kind ) <nl> return true ; <nl> - } <nl> + <nl> return false ; <nl> } <nl> <nl> @ @ - 437 , 62 + 471 , 59 @ @ public final class LegacySchemaMigrator <nl> boolean needsUpgrade ) <nl> { <nl> List < ColumnDefinition > columns = new ArrayList < > ( ) ; <nl> - for ( UntypedResultSet . Row row : rows ) <nl> - columns . add ( createColumnFromColumnRow ( row , keyspace , table , rawComparator , rawSubComparator , isSuper , isCQLTable , isStaticCompactTable , needsUpgrade ) ) ; <nl> - return columns ; <nl> - } <nl> - <nl> - private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row , <nl> - String keyspace , <nl> - String table , <nl> - AbstractType < ? > rawComparator , <nl> - AbstractType < ? > rawSubComparator , <nl> - boolean isSuper , <nl> - boolean isCQLTable , <nl> - boolean isStaticCompactTable , <nl> - boolean needsUpgrade ) <nl> - { <nl> - ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; <nl> - if ( needsUpgrade & & isStaticCompactTable & & kind = = ColumnDefinition . Kind . REGULAR ) <nl> - kind = ColumnDefinition . Kind . STATIC ; <nl> - <nl> - Integer componentIndex = null ; <nl> - / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is <nl> - / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed <nl> - / / anymore ) <nl> - if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) <nl> - componentIndex = row . getInt ( " component _ index " ) ; <nl> - <nl> - / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we <nl> - / / we need to use the comparator fromString method <nl> - AbstractType < ? > comparator = isCQLTable <nl> - ? UTF8Type . instance <nl> - : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; <nl> - ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; <nl> - <nl> - AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; <nl> <nl> - IndexType indexType = null ; <nl> - if ( row . has ( " index _ type " ) ) <nl> - indexType = IndexType . valueOf ( row . getString ( " index _ type " ) ) ; <nl> - <nl> - Map < String , String > indexOptions = null ; <nl> - if ( row . has ( " index _ options " ) ) <nl> - indexOptions = fromJsonMap ( row . getString ( " index _ options " ) ) ; <nl> - <nl> - String indexName = null ; <nl> - if ( row . has ( " index _ name " ) ) <nl> - indexName = row . getString ( " index _ name " ) ; <nl> + for ( UntypedResultSet . Row row : rows ) <nl> + { <nl> + / / Skip the empty compact value column . Make addDefinitionForUpgrade ( ) re - add the proper REGULAR one . <nl> + if ( isEmptyCompactValueColumn ( row ) ) <nl> + continue ; <nl> + <nl> + ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; <nl> + if ( needsUpgrade & & isStaticCompactTable & & kind = = ColumnDefinition . Kind . REGULAR ) <nl> + kind = ColumnDefinition . Kind . STATIC ; <nl> + <nl> + Integer componentIndex = null ; <nl> + / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is <nl> + / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed <nl> + / / anymore ) <nl> + if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) <nl> + componentIndex = row . getInt ( " component _ index " ) ; <nl> + <nl> + / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we <nl> + / / we need to use the comparator fromString method <nl> + AbstractType < ? > comparator = isCQLTable <nl> + ? UTF8Type . instance <nl> + : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; <nl> + ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; <nl> + <nl> + AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; <nl> + <nl> + IndexType indexType = null ; <nl> + if ( row . has ( " index _ type " ) ) <nl> + indexType = IndexType . valueOf ( row . getString ( " index _ type " ) ) ; <nl> + <nl> + Map < String , String > indexOptions = null ; <nl> + if ( row . has ( " index _ options " ) ) <nl> + indexOptions = fromJsonMap ( row . getString ( " index _ options " ) ) ; <nl> + <nl> + String indexName = null ; <nl> + if ( row . has ( " index _ name " ) ) <nl> + indexName = row . getString ( " index _ name " ) ; <nl> + <nl> + columns . add ( new ColumnDefinition ( keyspace , table , name , validator , indexType , indexOptions , indexName , componentIndex , kind ) ) ; <nl> + } <nl> <nl> - return new ColumnDefinition ( keyspace , table , name , validator , indexType , indexOptions , indexName , componentIndex , kind ) ; <nl> + return columns ; <nl> } <nl> <nl> private static ColumnDefinition . Kind deserializeKind ( String kind ) <nl> { <nl> if ( " clustering _ key " . equalsIgnoreCase ( kind ) ) <nl> return ColumnDefinition . Kind . CLUSTERING ; <nl> + <nl> if ( " compact _ value " . equalsIgnoreCase ( kind ) ) <nl> return ColumnDefinition . Kind . REGULAR ; <nl> + <nl> return Enum . valueOf ( ColumnDefinition . Kind . class , kind . toUpperCase ( ) ) ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> index eb5e5f5 . . 82922e6 100644 <nl> - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> @ @ - 232 , 6 + 232 , 13 @ @ public class LegacySchemaMigratorTest <nl> + " PRIMARY KEY ( bar , baz ) ) " <nl> + " WITH COMPACT STORAGE " , ks _ cql ) , <nl> <nl> + CFMetaData . compile ( " CREATE TABLE compact _ pkonly ( " <nl> + + " k int , " <nl> + + " c int , " <nl> + + " PRIMARY KEY ( k , c ) ) " <nl> + + " WITH COMPACT STORAGE " , <nl> + ks _ cql ) , <nl> + <nl> CFMetaData . compile ( " CREATE TABLE foofoo ( " <nl> + " bar text , " <nl> + " baz text , " <nl> @ @ - 459 , 8 + 466 , 12 @ @ public class LegacySchemaMigratorTest <nl> <nl> private static void addColumnToSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) <nl> { <nl> - RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumns , timestamp , mutation ) <nl> - . clustering ( table . cfName , column . name . toString ( ) ) ; <nl> + / / We need to special case pk - only dense tables . See CASSANDRA - 9874 . <nl> + String name = table . isDense ( ) & & column . kind = = ColumnDefinition . Kind . REGULAR & & column . type instanceof EmptyType <nl> + ? " " <nl> + : column . name . toString ( ) ; <nl> + <nl> + RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumns , timestamp , mutation ) . clustering ( table . cfName , name ) ; <nl> <nl> adder . add ( " validator " , column . type . toString ( ) ) <nl> . add ( " type " , serializeKind ( column . kind , table . isDense ( ) ) )
NEAREST DIFF (one line): diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py <nl> index 958b9ae . . 0e631ea 100644 <nl> - - - a / pylib / cqlshlib / cql3handling . py <nl> + + + b / pylib / cqlshlib / cql3handling . py <nl> @ @ - 1239 , 6 + 1239 , 8 @ @ syntax _ rules + = r ' ' ' <nl> | " ADD " newcol = < cident > < storageType > <nl> | " DROP " existcol = < cident > <nl> | " WITH " < cfamProperty > ( " AND " < cfamProperty > ) * <nl> + | " RENAME " existcol = < cident > " TO " newcol = < cident > <nl> + ( " AND " existcol = < cident > " TO " newcol = < cident > ) * <nl> ; <nl> ' ' ' <nl> <nl> diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py <nl> index c9dae31 . . cdbb8f4 100644 <nl> - - - a / pylib / cqlshlib / helptopics . py <nl> + + + b / pylib / cqlshlib / helptopics . py <nl> @ @ - 902 , 8 + 902 , 37 @ @ class CQL3HelpTopics ( CQLHelpTopics ) : <nl> print " HELP CREATE _ USER ; " <nl> <nl> def help _ alter ( self ) : <nl> - super ( CQL3HelpTopics , self ) . help _ alter ( ) <nl> - print " HELP ALTER _ USER ; " <nl> + print " " " <nl> + ALTER TABLE < tablename > ALTER < columnname > TYPE < type > ; <nl> + ALTER TABLE < tablename > ADD < columnname > < type > ; <nl> + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > <nl> + [ AND < columnname > TO < columnname > ] <nl> + ALTER TABLE < tablename > WITH < optionname > = < val > [ AND < optionname > = < val > [ . . . ] ] ; <nl> + <nl> + An ALTER statement is used to manipulate table metadata . It allows you <nl> + to add new typed columns , drop existing columns , change the data <nl> + storage type of existing columns , or change table properties . <nl> + No results are returned . <nl> + <nl> + See one of the following for more information : <nl> + <nl> + HELP ALTER _ ALTER ; <nl> + HELP ALTER _ ADD ; <nl> + HELP ALTER _ DROP ; <nl> + HELP ALTER _ RENAME ; <nl> + HELP ALTER _ WITH ; <nl> + " " " <nl> + <nl> + def help _ alter _ rename ( self ) : <nl> + print " " " <nl> + ALTER TABLE : renaming a column <nl> + <nl> + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > <nl> + [ AND < columnname > TO < columnname > ] <nl> + <nl> + The ALTER TABLE . . . RENAME variant renames a typed column in a column <nl> + family . <nl> + " " " <nl> <nl> def help _ drop ( self ) : <nl> super ( CQL3HelpTopics , self ) . help _ drop ( )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d405a4d . . 7f061c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 4 , 7 + 4 , 7 @ @ 
 * Change CREATE / ALTER TABLE syntax for compression ( CASSANDRA - 8384 ) 
 * Cleanup crc and adler code for java 8 ( CASSANDRA - 9650 ) 
 * Storage engine refactor ( CASSANDRA - 8099 , 9743 , 9746 , 9759 , 9781 , 9808 , 9825 , 9848 , 
 - 9705 , 9859 , 9867 ) 
 + 9705 , 9859 , 9867 , 9874 ) 
 * Update Guava to 18 . 0 ( CASSANDRA - 9653 ) 
 * Bloom filter false positive ratio is not honoured ( CASSANDRA - 8413 ) 
 * New option for cassandra - stress to leave a ratio of columns null ( CASSANDRA - 9522 ) 
 diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 index f554ffb . . 7326fa9 100644 
 - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 @ @ - 296 , 7 + 296 , 16 @ @ public final class LegacySchemaMigrator 
 needsUpgrade ) ; 
 
 if ( needsUpgrade ) 
 - addDefinitionForUpgrade ( columnDefs , ksName , cfName , isStaticCompactTable , isSuper , rawComparator , subComparator , defaultValidator ) ; 
 + { 
 + addDefinitionForUpgrade ( columnDefs , 
 + ksName , 
 + cfName , 
 + isStaticCompactTable , 
 + isSuper , 
 + rawComparator , 
 + subComparator , 
 + defaultValidator ) ; 
 + } 
 
 CFMetaData cfm = CFMetaData . create ( ksName , cfName , cfId , isDense , isCompound , isSuper , isCounter , columnDefs ) ; 
 
 @ @ - 355 , 7 + 364 , 33 @ @ public final class LegacySchemaMigrator 
 return ! hasKind ( defs , ColumnDefinition . Kind . STATIC ) ; 
 
 / / For dense compact tables , we need to upgrade if we don ' t have a compact value definition 
 - return ! hasKind ( defs , ColumnDefinition . Kind . REGULAR ) ; 
 + return ! hasRegularColumns ( defs ) ; 
 + } 
 + 
 + private static boolean hasRegularColumns ( UntypedResultSet columnRows ) 
 + { 
 + for ( UntypedResultSet . Row row : columnRows ) 
 + { 
 + / * 
 + * We need to special case and ignore the empty compact column ( pre - 3 . 0 , COMPACT STORAGE , primary - key only tables ) , 
 + * since deserializeKind ( ) will otherwise just return a REGULAR . 
 + * We want the proper EmptyType regular column to be added by addDefinitionForUpgrade ( ) , so we need 
 + * checkNeedsUpgrade ( ) to return true in this case . 
 + * See CASSANDRA - 9874 . 
 + * / 
 + if ( isEmptyCompactValueColumn ( row ) ) 
 + return false ; 
 + 
 + if ( deserializeKind ( row . getString ( " type " ) ) = = ColumnDefinition . Kind . REGULAR ) 
 + return true ; 
 + } 
 + 
 + return false ; 
 + } 
 + 
 + private static boolean isEmptyCompactValueColumn ( UntypedResultSet . Row row ) 
 + { 
 + return " compact _ value " . equals ( row . getString ( " type " ) ) & & row . getString ( " column _ name " ) . isEmpty ( ) ; 
 } 
 
 private static void addDefinitionForUpgrade ( List < ColumnDefinition > defs , 
 @ @ - 389 , 10 + 424 , 9 @ @ public final class LegacySchemaMigrator 
 private static boolean hasKind ( UntypedResultSet defs , ColumnDefinition . Kind kind ) 
 { 
 for ( UntypedResultSet . Row row : defs ) 
 - { 
 if ( deserializeKind ( row . getString ( " type " ) ) = = kind ) 
 return true ; 
 - } 
 + 
 return false ; 
 } 
 
 @ @ - 437 , 62 + 471 , 59 @ @ public final class LegacySchemaMigrator 
 boolean needsUpgrade ) 
 { 
 List < ColumnDefinition > columns = new ArrayList < > ( ) ; 
 - for ( UntypedResultSet . Row row : rows ) 
 - columns . add ( createColumnFromColumnRow ( row , keyspace , table , rawComparator , rawSubComparator , isSuper , isCQLTable , isStaticCompactTable , needsUpgrade ) ) ; 
 - return columns ; 
 - } 
 - 
 - private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row , 
 - String keyspace , 
 - String table , 
 - AbstractType < ? > rawComparator , 
 - AbstractType < ? > rawSubComparator , 
 - boolean isSuper , 
 - boolean isCQLTable , 
 - boolean isStaticCompactTable , 
 - boolean needsUpgrade ) 
 - { 
 - ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; 
 - if ( needsUpgrade & & isStaticCompactTable & & kind = = ColumnDefinition . Kind . REGULAR ) 
 - kind = ColumnDefinition . Kind . STATIC ; 
 - 
 - Integer componentIndex = null ; 
 - / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is 
 - / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed 
 - / / anymore ) 
 - if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) 
 - componentIndex = row . getInt ( " component _ index " ) ; 
 - 
 - / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we 
 - / / we need to use the comparator fromString method 
 - AbstractType < ? > comparator = isCQLTable 
 - ? UTF8Type . instance 
 - : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; 
 - ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; 
 - 
 - AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; 
 
 - IndexType indexType = null ; 
 - if ( row . has ( " index _ type " ) ) 
 - indexType = IndexType . valueOf ( row . getString ( " index _ type " ) ) ; 
 - 
 - Map < String , String > indexOptions = null ; 
 - if ( row . has ( " index _ options " ) ) 
 - indexOptions = fromJsonMap ( row . getString ( " index _ options " ) ) ; 
 - 
 - String indexName = null ; 
 - if ( row . has ( " index _ name " ) ) 
 - indexName = row . getString ( " index _ name " ) ; 
 + for ( UntypedResultSet . Row row : rows ) 
 + { 
 + / / Skip the empty compact value column . Make addDefinitionForUpgrade ( ) re - add the proper REGULAR one . 
 + if ( isEmptyCompactValueColumn ( row ) ) 
 + continue ; 
 + 
 + ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; 
 + if ( needsUpgrade & & isStaticCompactTable & & kind = = ColumnDefinition . Kind . REGULAR ) 
 + kind = ColumnDefinition . Kind . STATIC ; 
 + 
 + Integer componentIndex = null ; 
 + / / Note that the component _ index is not useful for non - primary key parts ( it never really in fact since there is 
 + / / no particular ordering of non - PK columns , we only used to use it as a simplification but that ' s not needed 
 + / / anymore ) 
 + if ( kind . isPrimaryKeyKind ( ) & & row . has ( " component _ index " ) ) 
 + componentIndex = row . getInt ( " component _ index " ) ; 
 + 
 + / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we 
 + / / we need to use the comparator fromString method 
 + AbstractType < ? > comparator = isCQLTable 
 + ? UTF8Type . instance 
 + : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; 
 + ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; 
 + 
 + AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; 
 + 
 + IndexType indexType = null ; 
 + if ( row . has ( " index _ type " ) ) 
 + indexType = IndexType . valueOf ( row . getString ( " index _ type " ) ) ; 
 + 
 + Map < String , String > indexOptions = null ; 
 + if ( row . has ( " index _ options " ) ) 
 + indexOptions = fromJsonMap ( row . getString ( " index _ options " ) ) ; 
 + 
 + String indexName = null ; 
 + if ( row . has ( " index _ name " ) ) 
 + indexName = row . getString ( " index _ name " ) ; 
 + 
 + columns . add ( new ColumnDefinition ( keyspace , table , name , validator , indexType , indexOptions , indexName , componentIndex , kind ) ) ; 
 + } 
 
 - return new ColumnDefinition ( keyspace , table , name , validator , indexType , indexOptions , indexName , componentIndex , kind ) ; 
 + return columns ; 
 } 
 
 private static ColumnDefinition . Kind deserializeKind ( String kind ) 
 { 
 if ( " clustering _ key " . equalsIgnoreCase ( kind ) ) 
 return ColumnDefinition . Kind . CLUSTERING ; 
 + 
 if ( " compact _ value " . equalsIgnoreCase ( kind ) ) 
 return ColumnDefinition . Kind . REGULAR ; 
 + 
 return Enum . valueOf ( ColumnDefinition . Kind . class , kind . toUpperCase ( ) ) ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 index eb5e5f5 . . 82922e6 100644 
 - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 @ @ - 232 , 6 + 232 , 13 @ @ public class LegacySchemaMigratorTest 
 + " PRIMARY KEY ( bar , baz ) ) " 
 + " WITH COMPACT STORAGE " , ks _ cql ) , 
 
 + CFMetaData . compile ( " CREATE TABLE compact _ pkonly ( " 
 + + " k int , " 
 + + " c int , " 
 + + " PRIMARY KEY ( k , c ) ) " 
 + + " WITH COMPACT STORAGE " , 
 + ks _ cql ) , 
 + 
 CFMetaData . compile ( " CREATE TABLE foofoo ( " 
 + " bar text , " 
 + " baz text , " 
 @ @ - 459 , 8 + 466 , 12 @ @ public class LegacySchemaMigratorTest 
 
 private static void addColumnToSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) 
 { 
 - RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumns , timestamp , mutation ) 
 - . clustering ( table . cfName , column . name . toString ( ) ) ; 
 + / / We need to special case pk - only dense tables . See CASSANDRA - 9874 . 
 + String name = table . isDense ( ) & & column . kind = = ColumnDefinition . Kind . REGULAR & & column . type instanceof EmptyType 
 + ? " " 
 + : column . name . toString ( ) ; 
 + 
 + RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumns , timestamp , mutation ) . clustering ( table . cfName , name ) ; 
 
 adder . add ( " validator " , column . type . toString ( ) ) 
 . add ( " type " , serializeKind ( column . kind , table . isDense ( ) ) )

NEAREST DIFF:
diff - - git a / pylib / cqlshlib / cql3handling . py b / pylib / cqlshlib / cql3handling . py 
 index 958b9ae . . 0e631ea 100644 
 - - - a / pylib / cqlshlib / cql3handling . py 
 + + + b / pylib / cqlshlib / cql3handling . py 
 @ @ - 1239 , 6 + 1239 , 8 @ @ syntax _ rules + = r ' ' ' 
 | " ADD " newcol = < cident > < storageType > 
 | " DROP " existcol = < cident > 
 | " WITH " < cfamProperty > ( " AND " < cfamProperty > ) * 
 + | " RENAME " existcol = < cident > " TO " newcol = < cident > 
 + ( " AND " existcol = < cident > " TO " newcol = < cident > ) * 
 ; 
 ' ' ' 
 
 diff - - git a / pylib / cqlshlib / helptopics . py b / pylib / cqlshlib / helptopics . py 
 index c9dae31 . . cdbb8f4 100644 
 - - - a / pylib / cqlshlib / helptopics . py 
 + + + b / pylib / cqlshlib / helptopics . py 
 @ @ - 902 , 8 + 902 , 37 @ @ class CQL3HelpTopics ( CQLHelpTopics ) : 
 print " HELP CREATE _ USER ; " 
 
 def help _ alter ( self ) : 
 - super ( CQL3HelpTopics , self ) . help _ alter ( ) 
 - print " HELP ALTER _ USER ; " 
 + print " " " 
 + ALTER TABLE < tablename > ALTER < columnname > TYPE < type > ; 
 + ALTER TABLE < tablename > ADD < columnname > < type > ; 
 + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > 
 + [ AND < columnname > TO < columnname > ] 
 + ALTER TABLE < tablename > WITH < optionname > = < val > [ AND < optionname > = < val > [ . . . ] ] ; 
 + 
 + An ALTER statement is used to manipulate table metadata . It allows you 
 + to add new typed columns , drop existing columns , change the data 
 + storage type of existing columns , or change table properties . 
 + No results are returned . 
 + 
 + See one of the following for more information : 
 + 
 + HELP ALTER _ ALTER ; 
 + HELP ALTER _ ADD ; 
 + HELP ALTER _ DROP ; 
 + HELP ALTER _ RENAME ; 
 + HELP ALTER _ WITH ; 
 + " " " 
 + 
 + def help _ alter _ rename ( self ) : 
 + print " " " 
 + ALTER TABLE : renaming a column 
 + 
 + ALTER TABLE < tablename > RENAME < columnname > TO < columnname > 
 + [ AND < columnname > TO < columnname > ] 
 + 
 + The ALTER TABLE . . . RENAME variant renames a typed column in a column 
 + family . 
 + " " " 
 
 def help _ drop ( self ) : 
 super ( CQL3HelpTopics , self ) . help _ drop ( )
