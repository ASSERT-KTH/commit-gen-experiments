BLEU SCORE: 0.0024118012379963885

TEST MSG: Fix serialization of AbstractBounds
GENERATED MSG: have RangeSliceCommand take Range or Bounds ( client bounds , start - inclusive , non - wrapping )

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / DataRange . java b / src / java / org / apache / cassandra / db / DataRange . java <nl> index 023f572 . . 79b2448 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DataRange . java <nl> + + + b / src / java / org / apache / cassandra / db / DataRange . java <nl> @ @ - 42 , 7 + 42 , 7 @ @ public class DataRange <nl> { <nl> public static final Serializer serializer = new Serializer ( ) ; <nl> <nl> - private final AbstractBounds < PartitionPosition > keyRange ; <nl> + protected final AbstractBounds < PartitionPosition > keyRange ; <nl> protected final ClusteringIndexFilter clusteringIndexFilter ; <nl> <nl> / * * <nl> @ @ - 201 , 7 + 201 , 7 @ @ public class DataRange <nl> * @ param range the range of partition keys to query . <nl> * @ param comparator the comparator for the table queried . <nl> * @ param lastReturned the clustering for the last result returned by the previous page , i . e . the result we want to start our new page <nl> - * from . This last returned must < b > must < / b > correspond to left bound of { @ code range } ( in other words , { @ code range . left } must be the <nl> + * from . This last returned < b > must < / b > correspond to left bound of { @ code range } ( in other words , { @ code range . left } must be the <nl> * partition key for that { @ code lastReturned } result ) . <nl> * @ param inclusive whether or not we want to include the { @ code lastReturned } in the newly returned page of results . <nl> * <nl> @ @ - 354 , 6 + 354 , 16 @ @ public class DataRange <nl> { <nl> return false ; <nl> } <nl> + <nl> + @ Override <nl> + public String toString ( CFMetaData metadata ) <nl> + { <nl> + return String . format ( " range = % s pfilter = % s lastReturned = % s ( % s ) " , <nl> + keyRange . getString ( metadata . getKeyValidator ( ) ) , <nl> + clusteringIndexFilter . toString ( metadata ) , <nl> + lastReturned . toString ( metadata ) , <nl> + inclusive ? " included " : " excluded " ) ; <nl> + } <nl> } <nl> <nl> public static class Serializer <nl> diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> index d9a0c62 . . 9e74eb8 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import org . apache . cassandra . db . PartitionPosition ; <nl> import org . apache . cassandra . db . TypeSizes ; <nl> import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . io . util . DataOutputPlus ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . utils . Pair ; <nl> <nl> public abstract class AbstractBounds < T extends RingPosition < T > > implements Serializable <nl> @ @ - 119 , 8 + 120 , 13 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> <nl> public static class AbstractBoundsSerializer < T extends RingPosition < T > > implements IPartitionerDependentSerializer < AbstractBounds < T > > <nl> { <nl> + private static final int IS _ TOKEN _ FLAG = 0x01 ; <nl> + private static final int START _ INCLUSIVE _ FLAG = 0x02 ; <nl> + private static final int END _ INCLUSIVE _ FLAG = 0x04 ; <nl> + <nl> IPartitionerDependentSerializer < T > serializer ; <nl> <nl> + / / Use for pre - 3 . 0 protocol <nl> private static int kindInt ( AbstractBounds < ? > ab ) <nl> { <nl> int kind = ab instanceof Range ? Type . RANGE . ordinal ( ) : Type . BOUNDS . ordinal ( ) ; <nl> @ @ - 129 , 6 + 135 , 19 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> return kind ; <nl> } <nl> <nl> + / / For from 3 . 0 onwards <nl> + private static int kindFlags ( AbstractBounds < ? > ab ) <nl> + { <nl> + int flags = 0 ; <nl> + if ( ab . left instanceof Token ) <nl> + flags | = IS _ TOKEN _ FLAG ; <nl> + if ( ab . isStartInclusive ( ) ) <nl> + flags | = START _ INCLUSIVE _ FLAG ; <nl> + if ( ab . isEndInclusive ( ) ) <nl> + flags | = END _ INCLUSIVE _ FLAG ; <nl> + return flags ; <nl> + } <nl> + <nl> public AbstractBoundsSerializer ( IPartitionerDependentSerializer < T > serializer ) <nl> { <nl> this . serializer = serializer ; <nl> @ @ - 140 , 30 + 159 , 51 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria <nl> * The first int tells us if it ' s a range or bounds ( depending on the value ) _ and _ if it ' s tokens or keys ( depending on the <nl> * sign ) . We use negative kind for keys so as to preserve the serialization of token from older version . <nl> * / <nl> - out . writeInt ( kindInt ( range ) ) ; <nl> + if ( version < MessagingService . VERSION _ 30 ) <nl> + out . writeInt ( kindInt ( range ) ) ; <nl> + else <nl> + out . writeByte ( kindFlags ( range ) ) ; <nl> serializer . serialize ( range . left , out , version ) ; <nl> serializer . serialize ( range . right , out , version ) ; <nl> } <nl> <nl> public AbstractBounds < T > deserialize ( DataInput in , IPartitioner p , int version ) throws IOException <nl> { <nl> - int kind = in . readInt ( ) ; <nl> - boolean isToken = kind > = 0 ; <nl> - if ( ! isToken ) <nl> - kind = - ( kind + 1 ) ; <nl> + boolean isToken , startInclusive , endInclusive ; <nl> + if ( version < MessagingService . VERSION _ 30 ) <nl> + { <nl> + int kind = in . readInt ( ) ; <nl> + isToken = kind > = 0 ; <nl> + if ( ! isToken ) <nl> + kind = - ( kind + 1 ) ; <nl> + <nl> + / / Pre - 3 . 0 , everything that wasa not a Range was ( wrongly ) serialized as a Bound ; <nl> + startInclusive = kind ! = Type . RANGE . ordinal ( ) ; <nl> + endInclusive = true ; <nl> + } <nl> + else <nl> + { <nl> + int flags = in . readUnsignedByte ( ) ; <nl> + isToken = ( flags & IS _ TOKEN _ FLAG ) ! = 0 ; <nl> + startInclusive = ( flags & START _ INCLUSIVE _ FLAG ) ! = 0 ; <nl> + endInclusive = ( flags & END _ INCLUSIVE _ FLAG ) ! = 0 ; <nl> + } <nl> <nl> T left = serializer . deserialize ( in , p , version ) ; <nl> T right = serializer . deserialize ( in , p , version ) ; <nl> assert isToken = = left instanceof Token ; <nl> <nl> - if ( kind = = Type . RANGE . ordinal ( ) ) <nl> - return new Range < T > ( left , right ) ; <nl> - return new Bounds < T > ( left , right ) ; <nl> + if ( startInclusive ) <nl> + return endInclusive ? new Bounds < T > ( left , right ) : new IncludingExcludingBounds < T > ( left , right ) ; <nl> + else <nl> + return endInclusive ? new Range < T > ( left , right ) : new ExcludingBounds < T > ( left , right ) ; <nl> } <nl> <nl> public long serializedSize ( AbstractBounds < T > ab , int version ) <nl> { <nl> - int size = TypeSizes . sizeof ( kindInt ( ab ) ) ; <nl> + int size = version < MessagingService . VERSION _ 30 <nl> + ? TypeSizes . sizeof ( kindInt ( ab ) ) <nl> + : 1 ; <nl> size + = serializer . serializedSize ( ab . left , version ) ; <nl> size + = serializer . serializedSize ( ab . right , version ) ; <nl> return size ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index f1f5793 . . 2f83653 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 39 , 6 + 39 , 9 @ @ import org . apache . cassandra . cache . JMXInstrumentedCache ; <nl> import org . apache . log4j . Logger ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . dht . AbstractBounds ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> + import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . io . * ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> <nl> @ @ - 930 , 24 + 933 , 22 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> / * * <nl> - * @ param startWith key to start with , inclusive . empty string = start at beginning . <nl> - * @ param stopAt key to stop at , inclusive . empty string = stop only when keys are exhausted . <nl> + * @ param range : either a Bounds , which includes start key , or a Range , which does not . <nl> * @ param maxResults <nl> - * @ param includeStartKey <nl> * @ return list of keys between startWith and stopAt <nl> <nl> TODO refactor better . this is just getKeyRange w / o the deletion check , for the benefit of <nl> range _ slice . still opens one randomaccessfile per key , which sucks . something like compactioniterator <nl> would be better . <nl> * / <nl> - private boolean getKeyRange ( List < String > keys , final DecoratedKey startWith , final DecoratedKey stopAt , int maxResults , boolean includeStartKey ) <nl> + private boolean getKeyRange ( List < String > keys , final AbstractBounds range , int maxResults ) <nl> throws IOException , ExecutionException , InterruptedException <nl> { <nl> - / / getKeyRange requires start < = stop . getRangeSlice handles range wrapping if necessary . <nl> - assert stopAt . isEmpty ( ) | | startWith . compareTo ( stopAt ) < = 0 ; <nl> + final DecoratedKey startWith = new DecoratedKey ( range . left , null ) ; <nl> + final DecoratedKey stopAt = new DecoratedKey ( range . right , null ) ; <nl> / / create a CollatedIterator that will return unique keys from different sources <nl> / / ( current memtable , historical memtables , and SSTables ) in the correct order . <nl> - List < Iterator < DecoratedKey > > iterators = new ArrayList < Iterator < DecoratedKey > > ( ) ; <nl> + final List < Iterator < DecoratedKey > > iterators = new ArrayList < Iterator < DecoratedKey > > ( ) ; <nl> <nl> / / we iterate through memtables with a priority queue to avoid more sorting than necessary . <nl> / / this predicate throws out the keys before the start of our range . <nl> @ @ - 1022 , 7 + 1023 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> return true ; <nl> } <nl> <nl> - if ( includeStartKey | | ! first | | ! current . equals ( startWith ) ) <nl> + if ( range instanceof Bounds | | ! first | | ! current . equals ( startWith ) ) <nl> { <nl> keys . add ( current . key ) ; <nl> } <nl> @ @ - 1050 , 33 + 1051 , 32 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> / * * <nl> * <nl> * @ param super _ column <nl> - * @ param startKey key to start at ( inclusive ) . empty string = start at the beginning . <nl> - * @ param finishKey key to stop at ( inclusive ) . empty string = stop at the end . <nl> + * @ param range : either a Bounds , which includes start key , or a Range , which does not . <nl> * @ param keyMax maximum number of keys to process , regardless of startKey / finishKey <nl> * @ param sliceRange may be null if columnNames is specified . specifies contiguous columns to return in what order . <nl> * @ param columnNames may be null if sliceRange is specified . specifies which columns to return in what order . @ return list of key - > list < column > tuples . <nl> - * @ param includeStartKey <nl> * @ throws IOException <nl> * @ throws ExecutionException <nl> * @ throws InterruptedException <nl> * / <nl> - public RangeSliceReply getRangeSlice ( byte [ ] super _ column , final DecoratedKey startKey , final DecoratedKey finishKey , int keyMax , SliceRange sliceRange , List < byte [ ] > columnNames , boolean includeStartKey ) <nl> + public RangeSliceReply getRangeSlice ( byte [ ] super _ column , final AbstractBounds range , int keyMax , SliceRange sliceRange , List < byte [ ] > columnNames ) <nl> throws IOException , ExecutionException , InterruptedException <nl> { <nl> List < String > keys = new ArrayList < String > ( ) ; <nl> boolean completed ; <nl> - if ( finishKey . isEmpty ( ) | | startKey . compareTo ( finishKey ) < = 0 ) <nl> + if ( ( range instanceof Bounds | | ! ( ( Range ) range ) . isWrapAround ( ) ) ) <nl> { <nl> - completed = getKeyRange ( keys , startKey , finishKey , keyMax , includeStartKey ) ; <nl> + completed = getKeyRange ( keys , range , keyMax ) ; <nl> } <nl> else <nl> { <nl> / / wrapped range <nl> - DecoratedKey emptyKey = new DecoratedKey ( StorageService . getPartitioner ( ) . getMinimumToken ( ) , null ) ; <nl> - completed = getKeyRange ( keys , startKey , emptyKey , keyMax , includeStartKey ) ; <nl> + Range first = new Range ( range . left , StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ; <nl> + completed = getKeyRange ( keys , first , keyMax ) ; <nl> if ( ! completed ) <nl> { <nl> - completed = getKeyRange ( keys , emptyKey , finishKey , keyMax , true ) ; <nl> + Range second = new Range ( StorageService . getPartitioner ( ) . getMinimumToken ( ) , range . right ) ; <nl> + completed = getKeyRange ( keys , second , keyMax ) ; <nl> } <nl> } <nl> List < Row > rows = new ArrayList < Row > ( keys . size ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / RangeSliceCommand . java b / src / java / org / apache / cassandra / db / RangeSliceCommand . java <nl> index ab8754d . . 366c602 100644 <nl> - - - a / src / java / org / apache / cassandra / db / RangeSliceCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / RangeSliceCommand . java <nl> @ @ - 38 , 6 + 38 , 8 @ @ package org . apache . cassandra . db ; <nl> <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> <nl> + import org . apache . cassandra . dht . AbstractBounds ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> import org . apache . cassandra . io . util . DataOutputBuffer ; <nl> import org . apache . cassandra . io . ICompactSerializer ; <nl> import org . apache . cassandra . net . Message ; <nl> @ @ - 66 , 26 + 68 , 22 @ @ public class RangeSliceCommand <nl> <nl> public final SlicePredicate predicate ; <nl> <nl> - public final DecoratedKey startKey ; <nl> - public final DecoratedKey finishKey ; <nl> + public final AbstractBounds range ; <nl> public final int max _ keys ; <nl> - public final boolean includeStartKey ; <nl> <nl> - public RangeSliceCommand ( String keyspace , ColumnParent column _ parent , SlicePredicate predicate , DecoratedKey startKey , DecoratedKey finishKey , int max _ keys ) <nl> + public RangeSliceCommand ( String keyspace , ColumnParent column _ parent , SlicePredicate predicate , AbstractBounds range , int max _ keys ) <nl> { <nl> - this ( keyspace , column _ parent . getColumn _ family ( ) , column _ parent . getSuper _ column ( ) , predicate , startKey , finishKey , max _ keys , true ) ; <nl> + this ( keyspace , column _ parent . getColumn _ family ( ) , column _ parent . getSuper _ column ( ) , predicate , range , max _ keys ) ; <nl> } <nl> <nl> - public RangeSliceCommand ( String keyspace , String column _ family , byte [ ] super _ column , SlicePredicate predicate , DecoratedKey startKey , DecoratedKey finishKey , int max _ keys , boolean includeStartKey ) <nl> + public RangeSliceCommand ( String keyspace , String column _ family , byte [ ] super _ column , SlicePredicate predicate , AbstractBounds range , int max _ keys ) <nl> { <nl> this . keyspace = keyspace ; <nl> this . column _ family = column _ family ; <nl> this . super _ column = super _ column ; <nl> this . predicate = predicate ; <nl> - this . startKey = startKey ; <nl> - this . finishKey = finishKey ; <nl> + this . range = range ; <nl> this . max _ keys = max _ keys ; <nl> - this . includeStartKey = includeStartKey ; <nl> } <nl> <nl> public Message getMessage ( ) throws IOException <nl> @ @ - 98 , 6 + 96 , 19 @ @ public class RangeSliceCommand <nl> Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ) ; <nl> } <nl> <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return " RangeSliceCommand { " + <nl> + " keyspace = ' " + keyspace + ' \ ' ' + <nl> + " , column _ family = ' " + column _ family + ' \ ' ' + <nl> + " , super _ column = " + super _ column + <nl> + " , predicate = " + predicate + <nl> + " , range = " + range + <nl> + " , max _ keys = " + max _ keys + <nl> + ' } ' ; <nl> + } <nl> + <nl> public static RangeSliceCommand read ( Message message ) throws IOException <nl> { <nl> byte [ ] bytes = message . getMessageBody ( ) ; <nl> @ @ - 118 , 10 + 129 , 8 @ @ class SliceCommandSerializer implements ICompactSerializer < RangeSliceCommand > <nl> <nl> TSerializer ser = new TSerializer ( new TBinaryProtocol . Factory ( ) ) ; <nl> FBUtilities . serialize ( ser , sliceCommand . predicate , dos ) ; <nl> - DecoratedKey . serializer ( ) . serialize ( sliceCommand . startKey , dos ) ; <nl> - DecoratedKey . serializer ( ) . serialize ( sliceCommand . finishKey , dos ) ; <nl> + Bounds . serializer ( ) . serialize ( sliceCommand . range , dos ) ; <nl> dos . writeInt ( sliceCommand . max _ keys ) ; <nl> - dos . writeBoolean ( sliceCommand . includeStartKey ) ; <nl> } <nl> <nl> public RangeSliceCommand deserialize ( DataInputStream dis ) throws IOException <nl> @ @ - 138 , 11 + 147 , 9 @ @ class SliceCommandSerializer implements ICompactSerializer < RangeSliceCommand > <nl> SlicePredicate pred = new SlicePredicate ( ) ; <nl> FBUtilities . deserialize ( dser , pred , dis ) ; <nl> <nl> - DecoratedKey startKey = DecoratedKey . serializer ( ) . deserialize ( dis ) ; <nl> - DecoratedKey finishKey = DecoratedKey . serializer ( ) . deserialize ( dis ) ; <nl> + AbstractBounds range = AbstractBounds . serializer ( ) . deserialize ( dis ) ; <nl> int max _ keys = dis . readInt ( ) ; <nl> - boolean includeStartKey = dis . readBoolean ( ) ; <nl> - return new RangeSliceCommand ( keyspace , column _ family , super _ column , pred , startKey , finishKey , max _ keys , includeStartKey ) ; <nl> + return new RangeSliceCommand ( keyspace , column _ family , super _ column , pred , range , max _ keys ) ; <nl> } <nl> <nl> static byte [ ] readBuf ( int len , DataInputStream dis ) throws IOException <nl> diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> new file mode 100644 <nl> index 0000000 . . 0acde0d <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java <nl> @ @ - 0 , 0 + 1 , 51 @ @ <nl> + package org . apache . cassandra . dht ; <nl> + <nl> + import java . io . * ; <nl> + import java . util . List ; <nl> + <nl> + import org . apache . cassandra . io . ICompactSerializer2 ; <nl> + <nl> + public abstract class AbstractBounds <nl> + { <nl> + private static BoundsSerializer serializer _ = new BoundsSerializer ( ) ; <nl> + <nl> + private enum Type <nl> + { <nl> + RANGE , <nl> + BOUNDS <nl> + } <nl> + <nl> + public static ICompactSerializer2 < AbstractBounds > serializer ( ) <nl> + { <nl> + return serializer _ ; <nl> + } <nl> + <nl> + public final Token left ; <nl> + public final Token right ; <nl> + <nl> + public AbstractBounds ( Token left , Token right ) <nl> + { <nl> + this . left = left ; <nl> + this . right = right ; <nl> + } <nl> + <nl> + public abstract List < AbstractBounds > restrictTo ( Range range ) ; <nl> + <nl> + private static class BoundsSerializer implements ICompactSerializer2 < AbstractBounds > <nl> + { <nl> + public void serialize ( AbstractBounds range , DataOutput out ) throws IOException <nl> + { <nl> + out . writeInt ( range instanceof Range ? Type . RANGE . ordinal ( ) : Type . BOUNDS . ordinal ( ) ) ; <nl> + Token . serializer ( ) . serialize ( range . left , out ) ; <nl> + Token . serializer ( ) . serialize ( range . right , out ) ; <nl> + } <nl> + <nl> + public AbstractBounds deserialize ( DataInput in ) throws IOException <nl> + { <nl> + if ( in . readInt ( ) = = Type . RANGE . ordinal ( ) ) <nl> + return new Range ( Token . serializer ( ) . deserialize ( in ) , Token . serializer ( ) . deserialize ( in ) ) ; <nl> + return new Bounds ( Token . serializer ( ) . deserialize ( in ) , Token . serializer ( ) . deserialize ( in ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java <nl> new file mode 100644 <nl> index 0000000 . . 113f02e <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / dht / Bounds . java <nl> @ @ - 0 , 0 + 1 , 41 @ @ <nl> + package org . apache . cassandra . dht ; <nl> + <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + <nl> + import org . apache . commons . lang . ObjectUtils ; <nl> + <nl> + import org . apache . cassandra . service . StorageService ; <nl> + <nl> + public class Bounds extends AbstractBounds <nl> + { <nl> + public Bounds ( Token left , Token right ) <nl> + { <nl> + super ( left , right ) ; <nl> + / / unlike a Range , a Bounds may not wrap <nl> + assert left . compareTo ( right ) < = 0 | | right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ; <nl> + } <nl> + <nl> + public List < AbstractBounds > restrictTo ( Range range ) <nl> + { <nl> + Token left , right ; <nl> + if ( range . left . equals ( range . right ) ) <nl> + { <nl> + left = this . left ; <nl> + right = this . right ; <nl> + } <nl> + else <nl> + { <nl> + left = ( Token ) ObjectUtils . max ( this . left , range . left ) ; <nl> + right = this . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) <nl> + ? range . right <nl> + : ( Token ) ObjectUtils . min ( this . right , range . right ) ; <nl> + } <nl> + return ( List ) Arrays . asList ( new Bounds ( left , right ) ) ; <nl> + } <nl> + <nl> + public String toString ( ) <nl> + { <nl> + return " [ " + left + " , " + right + " ] " ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java <nl> index 65eea8f . . 1d325a3 100644 <nl> - - - a / src / java / org / apache / cassandra / dht / Range . java <nl> + + + b / src / java / org / apache / cassandra / dht / Range . java <nl> @ @ - 18 , 9 + 18 , 6 @ @ <nl> <nl> package org . apache . cassandra . dht ; <nl> <nl> - import java . io . DataInputStream ; <nl> - import java . io . DataOutputStream ; <nl> - import java . io . IOException ; <nl> import java . io . Serializable ; <nl> import java . util . ArrayList ; <nl> import java . util . Arrays ; <nl> @ @ - 29 , 37 + 26 , 19 @ @ import java . util . List ; <nl> <nl> import org . apache . commons . lang . ObjectUtils ; <nl> <nl> - import org . apache . cassandra . io . ICompactSerializer ; <nl> - <nl> <nl> / * * <nl> * A representation of the range that a node is responsible for on the DHT ring . <nl> * <nl> * A Range is responsible for the tokens between ( left , right ] . <nl> * / <nl> - public class Range implements Comparable < Range > , Serializable <nl> + public class Range extends AbstractBounds implements Comparable < Range > , Serializable <nl> { <nl> public static final long serialVersionUID = 1L ; <nl> <nl> - private static ICompactSerializer < Range > serializer _ ; <nl> - <nl> - static <nl> - { <nl> - serializer _ = new RangeSerializer ( ) ; <nl> - } <nl> - <nl> - public static ICompactSerializer < Range > serializer ( ) <nl> - { <nl> - return serializer _ ; <nl> - } <nl> - <nl> - public final Token left ; <nl> - public final Token right ; <nl> - <nl> public Range ( Token left , Token right ) <nl> { <nl> - this . left = left ; <nl> - this . right = right ; <nl> + super ( left , right ) ; <nl> } <nl> <nl> public static boolean contains ( Token left , Token right , Token bi ) <nl> @ @ - 146 , 6 + 125 , 11 @ @ public class Range implements Comparable < Range > , Serializable <nl> return intersectionOneWrapping ( that , this ) ; <nl> } <nl> <nl> + public List < AbstractBounds > restrictTo ( Range range ) <nl> + { <nl> + return ( List ) intersectionWith ( range ) ; <nl> + } <nl> + <nl> private static List < Range > intersectionOneWrapping ( Range wrapping , Range other ) <nl> { <nl> List < Range > intersection = new ArrayList < Range > ( 2 ) ; <nl> @ @ - 211 , 23 + 195 , 14 @ @ public class Range implements Comparable < Range > , Serializable <nl> { <nl> return toString ( ) . hashCode ( ) ; <nl> } <nl> - <nl> + <nl> public String toString ( ) <nl> { <nl> return " ( " + left + " , " + right + " ] " ; <nl> } <nl> - } <nl> - <nl> - class RangeSerializer implements ICompactSerializer < Range > <nl> - { <nl> - public void serialize ( Range range , DataOutputStream dos ) throws IOException <nl> - { <nl> - Token . serializer ( ) . serialize ( range . left , dos ) ; <nl> - Token . serializer ( ) . serialize ( range . right , dos ) ; <nl> - } <nl> <nl> - public Range deserialize ( DataInputStream dis ) throws IOException <nl> + public boolean isWrapAround ( ) <nl> { <nl> - return new Range ( Token . serializer ( ) . deserialize ( dis ) , Token . serializer ( ) . deserialize ( dis ) ) ; <nl> + return isWrapAround ( left , right ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java b / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java <nl> index d227f1c . . 2ff2762 100644 <nl> - - - a / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java <nl> @ @ - 39 , 12 + 39 , 10 @ @ public class RangeSliceVerbHandler implements IVerbHandler <nl> RangeSliceCommand command = RangeSliceCommand . read ( message ) ; <nl> ColumnFamilyStore cfs = Table . open ( command . keyspace ) . getColumnFamilyStore ( command . column _ family ) ; <nl> RangeSliceReply reply = cfs . getRangeSlice ( command . super _ column , <nl> - command . startKey , <nl> - command . finishKey , <nl> + command . range , <nl> command . max _ keys , <nl> command . predicate . slice _ range , <nl> - command . predicate . column _ names , <nl> - command . includeStartKey ) ; <nl> + command . predicate . column _ names ) ; <nl> Message response = reply . getReply ( message ) ; <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Sending " + reply + " to " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 71db3ff . . cada4f3 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 27 , 12 + 27 , 13 @ @ import java . util . concurrent . Callable ; <nl> import java . util . concurrent . Future ; <nl> import java . lang . management . ManagementFactory ; <nl> <nl> - import org . apache . commons . lang . ObjectUtils ; <nl> import org . apache . commons . lang . StringUtils ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . * ; <nl> import java . net . InetAddress ; <nl> + <nl> + import org . apache . cassandra . dht . * ; <nl> import org . apache . cassandra . net . IAsyncResult ; <nl> import org . apache . cassandra . net . Message ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> @ @ - 43 , 9 + 44 , 6 @ @ import org . apache . cassandra . utils . FBUtilities ; <nl> import org . apache . cassandra . utils . Pair ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> import org . apache . cassandra . locator . TokenMetadata ; <nl> - import org . apache . cassandra . dht . IPartitioner ; <nl> - import org . apache . cassandra . dht . Range ; <nl> - import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . concurrent . StageManager ; <nl> <nl> import org . apache . log4j . Logger ; <nl> @ @ - 538 , 12 + 536 , 15 @ @ public class StorageProxy implements StorageProxyMBean <nl> long startTime = System . nanoTime ( ) ; <nl> TokenMetadata tokenMetadata = StorageService . instance . getTokenMetadata ( ) ; <nl> <nl> - InetAddress endPoint = StorageService . instance . getPrimary ( command . startKey . token ) ; <nl> + InetAddress endPoint = StorageService . instance . getPrimary ( command . range . left ) ; <nl> InetAddress startEndpoint = endPoint ; <nl> final String table = command . keyspace ; <nl> int responseCount = determineBlockFor ( DatabaseDescriptor . getReplicationFactor ( table ) , DatabaseDescriptor . getReplicationFactor ( table ) , consistency _ level ) ; <nl> <nl> + / / starting with the node that is primary for the start key , scan until either we have enough results , <nl> + / / or the node scan reports that it was done ( i . e . , encountered a key outside the desired range ) . <nl> Map < String , ColumnFamily > rows = new HashMap < String , ColumnFamily > ( command . max _ keys ) ; <nl> + outer : <nl> do <nl> { <nl> Range primaryRange = StorageService . instance . getPrimaryRangeForEndPoint ( endPoint ) ; <nl> @ @ - 551 , 45 + 552 , 35 @ @ public class StorageProxy implements StorageProxyMBean <nl> if ( endpoints . size ( ) < responseCount ) <nl> throw new UnavailableException ( ) ; <nl> <nl> - / / to make comparing the results from each node easy , we restrict each command to the data in the primary range for this iteration <nl> - DecoratedKey < ? > startKey ; <nl> - DecoratedKey < ? > finishKey ; <nl> - if ( primaryRange . left . equals ( primaryRange . right ) ) <nl> + / / to make comparing the results from each node easy , we restrict each scan the primary range for the node in question <nl> + List < AbstractBounds > restricted = command . range . restrictTo ( primaryRange ) ; <nl> + for ( AbstractBounds range : restricted ) <nl> { <nl> - startKey = command . startKey ; <nl> - finishKey = command . finishKey ; <nl> - } <nl> - else <nl> - { <nl> - startKey = ( DecoratedKey < ? > ) ObjectUtils . max ( command . startKey , new DecoratedKey < Token < ? > > ( primaryRange . left , null ) ) ; <nl> - finishKey = command . finishKey . isEmpty ( ) <nl> - ? new DecoratedKey < Token < ? > > ( primaryRange . right , null ) <nl> - : ( DecoratedKey < ? > ) ObjectUtils . min ( command . finishKey , new DecoratedKey < Token < ? > > ( primaryRange . right , null ) ) ; <nl> - } <nl> - RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , startKey , finishKey , command . max _ keys , command . includeStartKey ) ; <nl> - Message message = c2 . getMessage ( ) ; <nl> + RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , range , command . max _ keys ) ; <nl> + Message message = c2 . getMessage ( ) ; <nl> <nl> - / / collect replies and resolve according to consistency level <nl> - RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; <nl> - QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; <nl> - if ( logger . isDebugEnabled ( ) ) <nl> - logger . debug ( " reading " + command + " for " + primaryRange + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; <nl> - for ( InetAddress replicaEndpoint : endpoints ) <nl> - { <nl> - MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; <nl> - } <nl> + / / collect replies and resolve according to consistency level <nl> + RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; <nl> + QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; <nl> + for ( InetAddress replicaEndpoint : endpoints ) <nl> + { <nl> + MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; <nl> + } <nl> <nl> - / / if we ' re done , great , otherwise , move to the next range <nl> - try <nl> - { <nl> - rows . putAll ( handler . get ( ) ) ; <nl> - } <nl> - catch ( DigestMismatchException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; / / no digests in range slices yet <nl> + / / if we ' re done , great , otherwise , move to the next range <nl> + try <nl> + { <nl> + rows . putAll ( handler . get ( ) ) ; <nl> + } <nl> + catch ( DigestMismatchException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; / / no digests in range slices yet <nl> + } <nl> + if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) <nl> + break outer ; <nl> } <nl> - if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) <nl> - break ; <nl> <nl> endPoint = tokenMetadata . getSuccessor ( endPoint ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java b / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java <nl> index a9043ca . . 08427ef 100644 <nl> - - - a / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java <nl> + + + b / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java <nl> @ @ - 8 , 6 + 8 , 7 @ @ import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> + import org . apache . cassandra . dht . AbstractBounds ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . io . ICompactSerializer ; <nl> import org . apache . cassandra . net . CompactEndPointSerializationHelper ; <nl> @ @ - 67 , 7 + 68 , 7 @ @ class StreamRequestMetadataSerializer implements ICompactSerializer < StreamReques <nl> dos . writeInt ( srMetadata . ranges _ . size ( ) ) ; <nl> for ( Range range : srMetadata . ranges _ ) <nl> { <nl> - Range . serializer ( ) . serialize ( range , dos ) ; <nl> + AbstractBounds . serializer ( ) . serialize ( range , dos ) ; <nl> } <nl> } <nl> <nl> @ @ - 79 , 7 + 80 , 7 @ @ class StreamRequestMetadataSerializer implements ICompactSerializer < StreamReques <nl> List < Range > ranges = ( size = = 0 ) ? null : new ArrayList < Range > ( ) ; <nl> for ( int i = 0 ; i < size ; + + i ) <nl> { <nl> - ranges . add ( Range . serializer ( ) . deserialize ( dis ) ) ; <nl> + ranges . add ( ( Range ) AbstractBounds . serializer ( ) . deserialize ( dis ) ) ; <nl> } <nl> return new StreamRequestMetadata ( target , ranges , table ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> index 415086d . . 6de9342 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java <nl> @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . db . filter . QueryPath ; <nl> <nl> import static org . apache . cassandra . thrift . ThriftGlue . * ; <nl> <nl> + import org . apache . cassandra . dht . Bounds ; <nl> import org . apache . cassandra . service . StorageProxy ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . thrift . Cassandra . Iface ; <nl> @ @ - 555 , 9 + 556 , 9 @ @ public class CassandraServer implements Cassandra . Iface <nl> List < Pair < String , ColumnFamily > > rows ; <nl> try <nl> { <nl> - DecoratedKey startKey = StorageService . getPartitioner ( ) . decorateKey ( start _ key ) ; <nl> - DecoratedKey finishKey = StorageService . getPartitioner ( ) . decorateKey ( finish _ key ) ; <nl> - rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , startKey , finishKey , maxRows ) , consistency _ level ) ; <nl> + Bounds bounds = new Bounds ( StorageService . getPartitioner ( ) . decorateKey ( start _ key ) . token , <nl> + StorageService . getPartitioner ( ) . decorateKey ( finish _ key ) . token ) ; <nl> + rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , maxRows ) , consistency _ level ) ; <nl> assert rows ! = null ; <nl> } <nl> catch ( TimeoutException e ) <nl> diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java <nl> index 4c4e52d . . 0ca35e8 100644 <nl> - - - a / test / unit / org / apache / cassandra / Util . java <nl> + + + b / test / unit / org / apache / cassandra / Util . java <nl> @ @ - 31 , 6 + 31 , 9 @ @ import org . apache . commons . lang . ArrayUtils ; <nl> <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . filter . QueryPath ; <nl> + import org . apache . cassandra . dht . Bounds ; <nl> + import org . apache . cassandra . dht . Range ; <nl> + import org . apache . cassandra . dht . Token ; <nl> import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . thrift . SliceRange ; <nl> <nl> @ @ - 63 , 14 + 66 , 12 @ @ public class Util <nl> <nl> public static RangeSliceReply getRangeSlice ( ColumnFamilyStore cfs ) throws IOException , ExecutionException , InterruptedException <nl> { <nl> - DecoratedKey emptyKey = StorageService . getPartitioner ( ) . decorateKey ( " " ) ; <nl> + Token min = StorageService . getPartitioner ( ) . getMinimumToken ( ) ; <nl> return cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , <nl> - emptyKey , <nl> - emptyKey , <nl> + new Bounds ( min , min ) , <nl> 10000 , <nl> new SliceRange ( ArrayUtils . EMPTY _ BYTE _ ARRAY , ArrayUtils . EMPTY _ BYTE _ ARRAY , false , 10000 ) , <nl> - null , <nl> - true ) ; <nl> + null ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> index 79b661c . . 4a4abbb 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java <nl> @ @ - 137 , 12 + 137 , 10 @ @ public class ColumnFamilyStoreTest extends CleanupHelper <nl> <nl> IPartitioner p = StorageService . getPartitioner ( ) ; <nl> RangeSliceReply result = cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , <nl> - p . decorateKey ( " key2 " ) , <nl> - p . decorateKey ( " key1 " ) , <nl> + new Range ( p . getToken ( " key15 " ) , p . getToken ( " key1 " ) ) , <nl> 10 , <nl> null , <nl> - Arrays . asList ( " asdf " . getBytes ( ) ) , <nl> - true ) ; <nl> + Arrays . asList ( " asdf " . getBytes ( ) ) ) ; <nl> assertEquals ( 2 , result . rows . size ( ) ) ; <nl> } <nl> <nl> @ @ - 153 , 12 + 151 , 10 @ @ public class ColumnFamilyStoreTest extends CleanupHelper <nl> <nl> IPartitioner p = StorageService . getPartitioner ( ) ; <nl> RangeSliceReply result = cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , <nl> - p . decorateKey ( " key1 " ) , <nl> - p . decorateKey ( " key2 " ) , <nl> + new Range ( p . getToken ( " key1 " ) , p . getToken ( " key2 " ) ) , <nl> 10 , <nl> null , <nl> - Arrays . asList ( " asdf " . getBytes ( ) ) , <nl> - false ) ; <nl> + Arrays . asList ( " asdf " . getBytes ( ) ) ) ; <nl> assertEquals ( 1 , result . rows . size ( ) ) ; <nl> assert result . rows . get ( 0 ) . key . equals ( " key2 " ) ; <nl> } <nl> @ @ - 175 , 7 + 171 , 6 @ @ public class ColumnFamilyStoreTest extends CleanupHelper <nl> rm = new RowMutation ( " Keyspace2 " , " key2 " ) ; <nl> rm . add ( new QueryPath ( " Standard1 " , null , " Column1 " . getBytes ( ) ) , " asdf " . getBytes ( ) , 0 ) ; <nl> rms . add ( rm ) ; <nl> - ColumnFamilyStore cfs = Util . writeColumnFamily ( rms ) ; <nl> - return cfs ; <nl> + return Util . writeColumnFamily ( rms ) ; <nl> } <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / DataRange . java b / src / java / org / apache / cassandra / db / DataRange . java 
 index 023f572 . . 79b2448 100644 
 - - - a / src / java / org / apache / cassandra / db / DataRange . java 
 + + + b / src / java / org / apache / cassandra / db / DataRange . java 
 @ @ - 42 , 7 + 42 , 7 @ @ public class DataRange 
 { 
 public static final Serializer serializer = new Serializer ( ) ; 
 
 - private final AbstractBounds < PartitionPosition > keyRange ; 
 + protected final AbstractBounds < PartitionPosition > keyRange ; 
 protected final ClusteringIndexFilter clusteringIndexFilter ; 
 
 / * * 
 @ @ - 201 , 7 + 201 , 7 @ @ public class DataRange 
 * @ param range the range of partition keys to query . 
 * @ param comparator the comparator for the table queried . 
 * @ param lastReturned the clustering for the last result returned by the previous page , i . e . the result we want to start our new page 
 - * from . This last returned must < b > must < / b > correspond to left bound of { @ code range } ( in other words , { @ code range . left } must be the 
 + * from . This last returned < b > must < / b > correspond to left bound of { @ code range } ( in other words , { @ code range . left } must be the 
 * partition key for that { @ code lastReturned } result ) . 
 * @ param inclusive whether or not we want to include the { @ code lastReturned } in the newly returned page of results . 
 * 
 @ @ - 354 , 6 + 354 , 16 @ @ public class DataRange 
 { 
 return false ; 
 } 
 + 
 + @ Override 
 + public String toString ( CFMetaData metadata ) 
 + { 
 + return String . format ( " range = % s pfilter = % s lastReturned = % s ( % s ) " , 
 + keyRange . getString ( metadata . getKeyValidator ( ) ) , 
 + clusteringIndexFilter . toString ( metadata ) , 
 + lastReturned . toString ( metadata ) , 
 + inclusive ? " included " : " excluded " ) ; 
 + } 
 } 
 
 public static class Serializer 
 diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 index d9a0c62 . . 9e74eb8 100644 
 - - - a / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import org . apache . cassandra . db . PartitionPosition ; 
 import org . apache . cassandra . db . TypeSizes ; 
 import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . io . util . DataOutputPlus ; 
 + import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . utils . Pair ; 
 
 public abstract class AbstractBounds < T extends RingPosition < T > > implements Serializable 
 @ @ - 119 , 8 + 120 , 13 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 
 public static class AbstractBoundsSerializer < T extends RingPosition < T > > implements IPartitionerDependentSerializer < AbstractBounds < T > > 
 { 
 + private static final int IS _ TOKEN _ FLAG = 0x01 ; 
 + private static final int START _ INCLUSIVE _ FLAG = 0x02 ; 
 + private static final int END _ INCLUSIVE _ FLAG = 0x04 ; 
 + 
 IPartitionerDependentSerializer < T > serializer ; 
 
 + / / Use for pre - 3 . 0 protocol 
 private static int kindInt ( AbstractBounds < ? > ab ) 
 { 
 int kind = ab instanceof Range ? Type . RANGE . ordinal ( ) : Type . BOUNDS . ordinal ( ) ; 
 @ @ - 129 , 6 + 135 , 19 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 return kind ; 
 } 
 
 + / / For from 3 . 0 onwards 
 + private static int kindFlags ( AbstractBounds < ? > ab ) 
 + { 
 + int flags = 0 ; 
 + if ( ab . left instanceof Token ) 
 + flags | = IS _ TOKEN _ FLAG ; 
 + if ( ab . isStartInclusive ( ) ) 
 + flags | = START _ INCLUSIVE _ FLAG ; 
 + if ( ab . isEndInclusive ( ) ) 
 + flags | = END _ INCLUSIVE _ FLAG ; 
 + return flags ; 
 + } 
 + 
 public AbstractBoundsSerializer ( IPartitionerDependentSerializer < T > serializer ) 
 { 
 this . serializer = serializer ; 
 @ @ - 140 , 30 + 159 , 51 @ @ public abstract class AbstractBounds < T extends RingPosition < T > > implements Seria 
 * The first int tells us if it ' s a range or bounds ( depending on the value ) _ and _ if it ' s tokens or keys ( depending on the 
 * sign ) . We use negative kind for keys so as to preserve the serialization of token from older version . 
 * / 
 - out . writeInt ( kindInt ( range ) ) ; 
 + if ( version < MessagingService . VERSION _ 30 ) 
 + out . writeInt ( kindInt ( range ) ) ; 
 + else 
 + out . writeByte ( kindFlags ( range ) ) ; 
 serializer . serialize ( range . left , out , version ) ; 
 serializer . serialize ( range . right , out , version ) ; 
 } 
 
 public AbstractBounds < T > deserialize ( DataInput in , IPartitioner p , int version ) throws IOException 
 { 
 - int kind = in . readInt ( ) ; 
 - boolean isToken = kind > = 0 ; 
 - if ( ! isToken ) 
 - kind = - ( kind + 1 ) ; 
 + boolean isToken , startInclusive , endInclusive ; 
 + if ( version < MessagingService . VERSION _ 30 ) 
 + { 
 + int kind = in . readInt ( ) ; 
 + isToken = kind > = 0 ; 
 + if ( ! isToken ) 
 + kind = - ( kind + 1 ) ; 
 + 
 + / / Pre - 3 . 0 , everything that wasa not a Range was ( wrongly ) serialized as a Bound ; 
 + startInclusive = kind ! = Type . RANGE . ordinal ( ) ; 
 + endInclusive = true ; 
 + } 
 + else 
 + { 
 + int flags = in . readUnsignedByte ( ) ; 
 + isToken = ( flags & IS _ TOKEN _ FLAG ) ! = 0 ; 
 + startInclusive = ( flags & START _ INCLUSIVE _ FLAG ) ! = 0 ; 
 + endInclusive = ( flags & END _ INCLUSIVE _ FLAG ) ! = 0 ; 
 + } 
 
 T left = serializer . deserialize ( in , p , version ) ; 
 T right = serializer . deserialize ( in , p , version ) ; 
 assert isToken = = left instanceof Token ; 
 
 - if ( kind = = Type . RANGE . ordinal ( ) ) 
 - return new Range < T > ( left , right ) ; 
 - return new Bounds < T > ( left , right ) ; 
 + if ( startInclusive ) 
 + return endInclusive ? new Bounds < T > ( left , right ) : new IncludingExcludingBounds < T > ( left , right ) ; 
 + else 
 + return endInclusive ? new Range < T > ( left , right ) : new ExcludingBounds < T > ( left , right ) ; 
 } 
 
 public long serializedSize ( AbstractBounds < T > ab , int version ) 
 { 
 - int size = TypeSizes . sizeof ( kindInt ( ab ) ) ; 
 + int size = version < MessagingService . VERSION _ 30 
 + ? TypeSizes . sizeof ( kindInt ( ab ) ) 
 + : 1 ; 
 size + = serializer . serializedSize ( ab . left , version ) ; 
 size + = serializer . serializedSize ( ab . right , version ) ; 
 return size ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index f1f5793 . . 2f83653 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 39 , 6 + 39 , 9 @ @ import org . apache . cassandra . cache . JMXInstrumentedCache ; 
 import org . apache . log4j . Logger ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . dht . AbstractBounds ; 
 + import org . apache . cassandra . dht . Bounds ; 
 + import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . io . * ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 
 @ @ - 930 , 24 + 933 , 22 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 / * * 
 - * @ param startWith key to start with , inclusive . empty string = start at beginning . 
 - * @ param stopAt key to stop at , inclusive . empty string = stop only when keys are exhausted . 
 + * @ param range : either a Bounds , which includes start key , or a Range , which does not . 
 * @ param maxResults 
 - * @ param includeStartKey 
 * @ return list of keys between startWith and stopAt 
 
 TODO refactor better . this is just getKeyRange w / o the deletion check , for the benefit of 
 range _ slice . still opens one randomaccessfile per key , which sucks . something like compactioniterator 
 would be better . 
 * / 
 - private boolean getKeyRange ( List < String > keys , final DecoratedKey startWith , final DecoratedKey stopAt , int maxResults , boolean includeStartKey ) 
 + private boolean getKeyRange ( List < String > keys , final AbstractBounds range , int maxResults ) 
 throws IOException , ExecutionException , InterruptedException 
 { 
 - / / getKeyRange requires start < = stop . getRangeSlice handles range wrapping if necessary . 
 - assert stopAt . isEmpty ( ) | | startWith . compareTo ( stopAt ) < = 0 ; 
 + final DecoratedKey startWith = new DecoratedKey ( range . left , null ) ; 
 + final DecoratedKey stopAt = new DecoratedKey ( range . right , null ) ; 
 / / create a CollatedIterator that will return unique keys from different sources 
 / / ( current memtable , historical memtables , and SSTables ) in the correct order . 
 - List < Iterator < DecoratedKey > > iterators = new ArrayList < Iterator < DecoratedKey > > ( ) ; 
 + final List < Iterator < DecoratedKey > > iterators = new ArrayList < Iterator < DecoratedKey > > ( ) ; 
 
 / / we iterate through memtables with a priority queue to avoid more sorting than necessary . 
 / / this predicate throws out the keys before the start of our range . 
 @ @ - 1022 , 7 + 1023 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 return true ; 
 } 
 
 - if ( includeStartKey | | ! first | | ! current . equals ( startWith ) ) 
 + if ( range instanceof Bounds | | ! first | | ! current . equals ( startWith ) ) 
 { 
 keys . add ( current . key ) ; 
 } 
 @ @ - 1050 , 33 + 1051 , 32 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 / * * 
 * 
 * @ param super _ column 
 - * @ param startKey key to start at ( inclusive ) . empty string = start at the beginning . 
 - * @ param finishKey key to stop at ( inclusive ) . empty string = stop at the end . 
 + * @ param range : either a Bounds , which includes start key , or a Range , which does not . 
 * @ param keyMax maximum number of keys to process , regardless of startKey / finishKey 
 * @ param sliceRange may be null if columnNames is specified . specifies contiguous columns to return in what order . 
 * @ param columnNames may be null if sliceRange is specified . specifies which columns to return in what order . @ return list of key - > list < column > tuples . 
 - * @ param includeStartKey 
 * @ throws IOException 
 * @ throws ExecutionException 
 * @ throws InterruptedException 
 * / 
 - public RangeSliceReply getRangeSlice ( byte [ ] super _ column , final DecoratedKey startKey , final DecoratedKey finishKey , int keyMax , SliceRange sliceRange , List < byte [ ] > columnNames , boolean includeStartKey ) 
 + public RangeSliceReply getRangeSlice ( byte [ ] super _ column , final AbstractBounds range , int keyMax , SliceRange sliceRange , List < byte [ ] > columnNames ) 
 throws IOException , ExecutionException , InterruptedException 
 { 
 List < String > keys = new ArrayList < String > ( ) ; 
 boolean completed ; 
 - if ( finishKey . isEmpty ( ) | | startKey . compareTo ( finishKey ) < = 0 ) 
 + if ( ( range instanceof Bounds | | ! ( ( Range ) range ) . isWrapAround ( ) ) ) 
 { 
 - completed = getKeyRange ( keys , startKey , finishKey , keyMax , includeStartKey ) ; 
 + completed = getKeyRange ( keys , range , keyMax ) ; 
 } 
 else 
 { 
 / / wrapped range 
 - DecoratedKey emptyKey = new DecoratedKey ( StorageService . getPartitioner ( ) . getMinimumToken ( ) , null ) ; 
 - completed = getKeyRange ( keys , startKey , emptyKey , keyMax , includeStartKey ) ; 
 + Range first = new Range ( range . left , StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ; 
 + completed = getKeyRange ( keys , first , keyMax ) ; 
 if ( ! completed ) 
 { 
 - completed = getKeyRange ( keys , emptyKey , finishKey , keyMax , true ) ; 
 + Range second = new Range ( StorageService . getPartitioner ( ) . getMinimumToken ( ) , range . right ) ; 
 + completed = getKeyRange ( keys , second , keyMax ) ; 
 } 
 } 
 List < Row > rows = new ArrayList < Row > ( keys . size ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / RangeSliceCommand . java b / src / java / org / apache / cassandra / db / RangeSliceCommand . java 
 index ab8754d . . 366c602 100644 
 - - - a / src / java / org / apache / cassandra / db / RangeSliceCommand . java 
 + + + b / src / java / org / apache / cassandra / db / RangeSliceCommand . java 
 @ @ - 38 , 6 + 38 , 8 @ @ package org . apache . cassandra . db ; 
 
 import org . apache . cassandra . concurrent . StageManager ; 
 
 + import org . apache . cassandra . dht . AbstractBounds ; 
 + import org . apache . cassandra . dht . Bounds ; 
 import org . apache . cassandra . io . util . DataOutputBuffer ; 
 import org . apache . cassandra . io . ICompactSerializer ; 
 import org . apache . cassandra . net . Message ; 
 @ @ - 66 , 26 + 68 , 22 @ @ public class RangeSliceCommand 
 
 public final SlicePredicate predicate ; 
 
 - public final DecoratedKey startKey ; 
 - public final DecoratedKey finishKey ; 
 + public final AbstractBounds range ; 
 public final int max _ keys ; 
 - public final boolean includeStartKey ; 
 
 - public RangeSliceCommand ( String keyspace , ColumnParent column _ parent , SlicePredicate predicate , DecoratedKey startKey , DecoratedKey finishKey , int max _ keys ) 
 + public RangeSliceCommand ( String keyspace , ColumnParent column _ parent , SlicePredicate predicate , AbstractBounds range , int max _ keys ) 
 { 
 - this ( keyspace , column _ parent . getColumn _ family ( ) , column _ parent . getSuper _ column ( ) , predicate , startKey , finishKey , max _ keys , true ) ; 
 + this ( keyspace , column _ parent . getColumn _ family ( ) , column _ parent . getSuper _ column ( ) , predicate , range , max _ keys ) ; 
 } 
 
 - public RangeSliceCommand ( String keyspace , String column _ family , byte [ ] super _ column , SlicePredicate predicate , DecoratedKey startKey , DecoratedKey finishKey , int max _ keys , boolean includeStartKey ) 
 + public RangeSliceCommand ( String keyspace , String column _ family , byte [ ] super _ column , SlicePredicate predicate , AbstractBounds range , int max _ keys ) 
 { 
 this . keyspace = keyspace ; 
 this . column _ family = column _ family ; 
 this . super _ column = super _ column ; 
 this . predicate = predicate ; 
 - this . startKey = startKey ; 
 - this . finishKey = finishKey ; 
 + this . range = range ; 
 this . max _ keys = max _ keys ; 
 - this . includeStartKey = includeStartKey ; 
 } 
 
 public Message getMessage ( ) throws IOException 
 @ @ - 98 , 6 + 96 , 19 @ @ public class RangeSliceCommand 
 Arrays . copyOf ( dob . getData ( ) , dob . getLength ( ) ) ) ; 
 } 
 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return " RangeSliceCommand { " + 
 + " keyspace = ' " + keyspace + ' \ ' ' + 
 + " , column _ family = ' " + column _ family + ' \ ' ' + 
 + " , super _ column = " + super _ column + 
 + " , predicate = " + predicate + 
 + " , range = " + range + 
 + " , max _ keys = " + max _ keys + 
 + ' } ' ; 
 + } 
 + 
 public static RangeSliceCommand read ( Message message ) throws IOException 
 { 
 byte [ ] bytes = message . getMessageBody ( ) ; 
 @ @ - 118 , 10 + 129 , 8 @ @ class SliceCommandSerializer implements ICompactSerializer < RangeSliceCommand > 
 
 TSerializer ser = new TSerializer ( new TBinaryProtocol . Factory ( ) ) ; 
 FBUtilities . serialize ( ser , sliceCommand . predicate , dos ) ; 
 - DecoratedKey . serializer ( ) . serialize ( sliceCommand . startKey , dos ) ; 
 - DecoratedKey . serializer ( ) . serialize ( sliceCommand . finishKey , dos ) ; 
 + Bounds . serializer ( ) . serialize ( sliceCommand . range , dos ) ; 
 dos . writeInt ( sliceCommand . max _ keys ) ; 
 - dos . writeBoolean ( sliceCommand . includeStartKey ) ; 
 } 
 
 public RangeSliceCommand deserialize ( DataInputStream dis ) throws IOException 
 @ @ - 138 , 11 + 147 , 9 @ @ class SliceCommandSerializer implements ICompactSerializer < RangeSliceCommand > 
 SlicePredicate pred = new SlicePredicate ( ) ; 
 FBUtilities . deserialize ( dser , pred , dis ) ; 
 
 - DecoratedKey startKey = DecoratedKey . serializer ( ) . deserialize ( dis ) ; 
 - DecoratedKey finishKey = DecoratedKey . serializer ( ) . deserialize ( dis ) ; 
 + AbstractBounds range = AbstractBounds . serializer ( ) . deserialize ( dis ) ; 
 int max _ keys = dis . readInt ( ) ; 
 - boolean includeStartKey = dis . readBoolean ( ) ; 
 - return new RangeSliceCommand ( keyspace , column _ family , super _ column , pred , startKey , finishKey , max _ keys , includeStartKey ) ; 
 + return new RangeSliceCommand ( keyspace , column _ family , super _ column , pred , range , max _ keys ) ; 
 } 
 
 static byte [ ] readBuf ( int len , DataInputStream dis ) throws IOException 
 diff - - git a / src / java / org / apache / cassandra / dht / AbstractBounds . java b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 new file mode 100644 
 index 0000000 . . 0acde0d 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / dht / AbstractBounds . java 
 @ @ - 0 , 0 + 1 , 51 @ @ 
 + package org . apache . cassandra . dht ; 
 + 
 + import java . io . * ; 
 + import java . util . List ; 
 + 
 + import org . apache . cassandra . io . ICompactSerializer2 ; 
 + 
 + public abstract class AbstractBounds 
 + { 
 + private static BoundsSerializer serializer _ = new BoundsSerializer ( ) ; 
 + 
 + private enum Type 
 + { 
 + RANGE , 
 + BOUNDS 
 + } 
 + 
 + public static ICompactSerializer2 < AbstractBounds > serializer ( ) 
 + { 
 + return serializer _ ; 
 + } 
 + 
 + public final Token left ; 
 + public final Token right ; 
 + 
 + public AbstractBounds ( Token left , Token right ) 
 + { 
 + this . left = left ; 
 + this . right = right ; 
 + } 
 + 
 + public abstract List < AbstractBounds > restrictTo ( Range range ) ; 
 + 
 + private static class BoundsSerializer implements ICompactSerializer2 < AbstractBounds > 
 + { 
 + public void serialize ( AbstractBounds range , DataOutput out ) throws IOException 
 + { 
 + out . writeInt ( range instanceof Range ? Type . RANGE . ordinal ( ) : Type . BOUNDS . ordinal ( ) ) ; 
 + Token . serializer ( ) . serialize ( range . left , out ) ; 
 + Token . serializer ( ) . serialize ( range . right , out ) ; 
 + } 
 + 
 + public AbstractBounds deserialize ( DataInput in ) throws IOException 
 + { 
 + if ( in . readInt ( ) = = Type . RANGE . ordinal ( ) ) 
 + return new Range ( Token . serializer ( ) . deserialize ( in ) , Token . serializer ( ) . deserialize ( in ) ) ; 
 + return new Bounds ( Token . serializer ( ) . deserialize ( in ) , Token . serializer ( ) . deserialize ( in ) ) ; 
 + } 
 + } 
 + } 
 + 
 diff - - git a / src / java / org / apache / cassandra / dht / Bounds . java b / src / java / org / apache / cassandra / dht / Bounds . java 
 new file mode 100644 
 index 0000000 . . 113f02e 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / dht / Bounds . java 
 @ @ - 0 , 0 + 1 , 41 @ @ 
 + package org . apache . cassandra . dht ; 
 + 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + 
 + import org . apache . commons . lang . ObjectUtils ; 
 + 
 + import org . apache . cassandra . service . StorageService ; 
 + 
 + public class Bounds extends AbstractBounds 
 + { 
 + public Bounds ( Token left , Token right ) 
 + { 
 + super ( left , right ) ; 
 + / / unlike a Range , a Bounds may not wrap 
 + assert left . compareTo ( right ) < = 0 | | right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ; 
 + } 
 + 
 + public List < AbstractBounds > restrictTo ( Range range ) 
 + { 
 + Token left , right ; 
 + if ( range . left . equals ( range . right ) ) 
 + { 
 + left = this . left ; 
 + right = this . right ; 
 + } 
 + else 
 + { 
 + left = ( Token ) ObjectUtils . max ( this . left , range . left ) ; 
 + right = this . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) 
 + ? range . right 
 + : ( Token ) ObjectUtils . min ( this . right , range . right ) ; 
 + } 
 + return ( List ) Arrays . asList ( new Bounds ( left , right ) ) ; 
 + } 
 + 
 + public String toString ( ) 
 + { 
 + return " [ " + left + " , " + right + " ] " ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / dht / Range . java b / src / java / org / apache / cassandra / dht / Range . java 
 index 65eea8f . . 1d325a3 100644 
 - - - a / src / java / org / apache / cassandra / dht / Range . java 
 + + + b / src / java / org / apache / cassandra / dht / Range . java 
 @ @ - 18 , 9 + 18 , 6 @ @ 
 
 package org . apache . cassandra . dht ; 
 
 - import java . io . DataInputStream ; 
 - import java . io . DataOutputStream ; 
 - import java . io . IOException ; 
 import java . io . Serializable ; 
 import java . util . ArrayList ; 
 import java . util . Arrays ; 
 @ @ - 29 , 37 + 26 , 19 @ @ import java . util . List ; 
 
 import org . apache . commons . lang . ObjectUtils ; 
 
 - import org . apache . cassandra . io . ICompactSerializer ; 
 - 
 
 / * * 
 * A representation of the range that a node is responsible for on the DHT ring . 
 * 
 * A Range is responsible for the tokens between ( left , right ] . 
 * / 
 - public class Range implements Comparable < Range > , Serializable 
 + public class Range extends AbstractBounds implements Comparable < Range > , Serializable 
 { 
 public static final long serialVersionUID = 1L ; 
 
 - private static ICompactSerializer < Range > serializer _ ; 
 - 
 - static 
 - { 
 - serializer _ = new RangeSerializer ( ) ; 
 - } 
 - 
 - public static ICompactSerializer < Range > serializer ( ) 
 - { 
 - return serializer _ ; 
 - } 
 - 
 - public final Token left ; 
 - public final Token right ; 
 - 
 public Range ( Token left , Token right ) 
 { 
 - this . left = left ; 
 - this . right = right ; 
 + super ( left , right ) ; 
 } 
 
 public static boolean contains ( Token left , Token right , Token bi ) 
 @ @ - 146 , 6 + 125 , 11 @ @ public class Range implements Comparable < Range > , Serializable 
 return intersectionOneWrapping ( that , this ) ; 
 } 
 
 + public List < AbstractBounds > restrictTo ( Range range ) 
 + { 
 + return ( List ) intersectionWith ( range ) ; 
 + } 
 + 
 private static List < Range > intersectionOneWrapping ( Range wrapping , Range other ) 
 { 
 List < Range > intersection = new ArrayList < Range > ( 2 ) ; 
 @ @ - 211 , 23 + 195 , 14 @ @ public class Range implements Comparable < Range > , Serializable 
 { 
 return toString ( ) . hashCode ( ) ; 
 } 
 - 
 + 
 public String toString ( ) 
 { 
 return " ( " + left + " , " + right + " ] " ; 
 } 
 - } 
 - 
 - class RangeSerializer implements ICompactSerializer < Range > 
 - { 
 - public void serialize ( Range range , DataOutputStream dos ) throws IOException 
 - { 
 - Token . serializer ( ) . serialize ( range . left , dos ) ; 
 - Token . serializer ( ) . serialize ( range . right , dos ) ; 
 - } 
 
 - public Range deserialize ( DataInputStream dis ) throws IOException 
 + public boolean isWrapAround ( ) 
 { 
 - return new Range ( Token . serializer ( ) . deserialize ( dis ) , Token . serializer ( ) . deserialize ( dis ) ) ; 
 + return isWrapAround ( left , right ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java b / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java 
 index d227f1c . . 2ff2762 100644 
 - - - a / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / service / RangeSliceVerbHandler . java 
 @ @ - 39 , 12 + 39 , 10 @ @ public class RangeSliceVerbHandler implements IVerbHandler 
 RangeSliceCommand command = RangeSliceCommand . read ( message ) ; 
 ColumnFamilyStore cfs = Table . open ( command . keyspace ) . getColumnFamilyStore ( command . column _ family ) ; 
 RangeSliceReply reply = cfs . getRangeSlice ( command . super _ column , 
 - command . startKey , 
 - command . finishKey , 
 + command . range , 
 command . max _ keys , 
 command . predicate . slice _ range , 
 - command . predicate . column _ names , 
 - command . includeStartKey ) ; 
 + command . predicate . column _ names ) ; 
 Message response = reply . getReply ( message ) ; 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Sending " + reply + " to " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 71db3ff . . cada4f3 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 27 , 12 + 27 , 13 @ @ import java . util . concurrent . Callable ; 
 import java . util . concurrent . Future ; 
 import java . lang . management . ManagementFactory ; 
 
 - import org . apache . commons . lang . ObjectUtils ; 
 import org . apache . commons . lang . StringUtils ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . * ; 
 import java . net . InetAddress ; 
 + 
 + import org . apache . cassandra . dht . * ; 
 import org . apache . cassandra . net . IAsyncResult ; 
 import org . apache . cassandra . net . Message ; 
 import org . apache . cassandra . net . MessagingService ; 
 @ @ - 43 , 9 + 44 , 6 @ @ import org . apache . cassandra . utils . FBUtilities ; 
 import org . apache . cassandra . utils . Pair ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 import org . apache . cassandra . locator . TokenMetadata ; 
 - import org . apache . cassandra . dht . IPartitioner ; 
 - import org . apache . cassandra . dht . Range ; 
 - import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . concurrent . StageManager ; 
 
 import org . apache . log4j . Logger ; 
 @ @ - 538 , 12 + 536 , 15 @ @ public class StorageProxy implements StorageProxyMBean 
 long startTime = System . nanoTime ( ) ; 
 TokenMetadata tokenMetadata = StorageService . instance . getTokenMetadata ( ) ; 
 
 - InetAddress endPoint = StorageService . instance . getPrimary ( command . startKey . token ) ; 
 + InetAddress endPoint = StorageService . instance . getPrimary ( command . range . left ) ; 
 InetAddress startEndpoint = endPoint ; 
 final String table = command . keyspace ; 
 int responseCount = determineBlockFor ( DatabaseDescriptor . getReplicationFactor ( table ) , DatabaseDescriptor . getReplicationFactor ( table ) , consistency _ level ) ; 
 
 + / / starting with the node that is primary for the start key , scan until either we have enough results , 
 + / / or the node scan reports that it was done ( i . e . , encountered a key outside the desired range ) . 
 Map < String , ColumnFamily > rows = new HashMap < String , ColumnFamily > ( command . max _ keys ) ; 
 + outer : 
 do 
 { 
 Range primaryRange = StorageService . instance . getPrimaryRangeForEndPoint ( endPoint ) ; 
 @ @ - 551 , 45 + 552 , 35 @ @ public class StorageProxy implements StorageProxyMBean 
 if ( endpoints . size ( ) < responseCount ) 
 throw new UnavailableException ( ) ; 
 
 - / / to make comparing the results from each node easy , we restrict each command to the data in the primary range for this iteration 
 - DecoratedKey < ? > startKey ; 
 - DecoratedKey < ? > finishKey ; 
 - if ( primaryRange . left . equals ( primaryRange . right ) ) 
 + / / to make comparing the results from each node easy , we restrict each scan the primary range for the node in question 
 + List < AbstractBounds > restricted = command . range . restrictTo ( primaryRange ) ; 
 + for ( AbstractBounds range : restricted ) 
 { 
 - startKey = command . startKey ; 
 - finishKey = command . finishKey ; 
 - } 
 - else 
 - { 
 - startKey = ( DecoratedKey < ? > ) ObjectUtils . max ( command . startKey , new DecoratedKey < Token < ? > > ( primaryRange . left , null ) ) ; 
 - finishKey = command . finishKey . isEmpty ( ) 
 - ? new DecoratedKey < Token < ? > > ( primaryRange . right , null ) 
 - : ( DecoratedKey < ? > ) ObjectUtils . min ( command . finishKey , new DecoratedKey < Token < ? > > ( primaryRange . right , null ) ) ; 
 - } 
 - RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , startKey , finishKey , command . max _ keys , command . includeStartKey ) ; 
 - Message message = c2 . getMessage ( ) ; 
 + RangeSliceCommand c2 = new RangeSliceCommand ( command . keyspace , command . column _ family , command . super _ column , command . predicate , range , command . max _ keys ) ; 
 + Message message = c2 . getMessage ( ) ; 
 
 - / / collect replies and resolve according to consistency level 
 - RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; 
 - QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; 
 - if ( logger . isDebugEnabled ( ) ) 
 - logger . debug ( " reading " + command + " for " + primaryRange + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; 
 - for ( InetAddress replicaEndpoint : endpoints ) 
 - { 
 - MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; 
 - } 
 + / / collect replies and resolve according to consistency level 
 + RangeSliceResponseResolver resolver = new RangeSliceResponseResolver ( command . keyspace , primaryRange , endpoints ) ; 
 + QuorumResponseHandler < Map < String , ColumnFamily > > handler = new QuorumResponseHandler < Map < String , ColumnFamily > > ( responseCount , resolver ) ; 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " reading " + c2 + " for " + range + " from " + message . getMessageId ( ) + " @ " + endPoint ) ; 
 + for ( InetAddress replicaEndpoint : endpoints ) 
 + { 
 + MessagingService . instance . sendRR ( message , replicaEndpoint , handler ) ; 
 + } 
 
 - / / if we ' re done , great , otherwise , move to the next range 
 - try 
 - { 
 - rows . putAll ( handler . get ( ) ) ; 
 - } 
 - catch ( DigestMismatchException e ) 
 - { 
 - throw new AssertionError ( e ) ; / / no digests in range slices yet 
 + / / if we ' re done , great , otherwise , move to the next range 
 + try 
 + { 
 + rows . putAll ( handler . get ( ) ) ; 
 + } 
 + catch ( DigestMismatchException e ) 
 + { 
 + throw new AssertionError ( e ) ; / / no digests in range slices yet 
 + } 
 + if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) 
 + break outer ; 
 } 
 - if ( rows . size ( ) > = command . max _ keys | | resolver . completed ( ) ) 
 - break ; 
 
 endPoint = tokenMetadata . getSuccessor ( endPoint ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java b / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java 
 index a9043ca . . 08427ef 100644 
 - - - a / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java 
 + + + b / src / java / org / apache / cassandra / streaming / StreamRequestMetadata . java 
 @ @ - 8 , 6 + 8 , 7 @ @ import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 
 + import org . apache . cassandra . dht . AbstractBounds ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . io . ICompactSerializer ; 
 import org . apache . cassandra . net . CompactEndPointSerializationHelper ; 
 @ @ - 67 , 7 + 68 , 7 @ @ class StreamRequestMetadataSerializer implements ICompactSerializer < StreamReques 
 dos . writeInt ( srMetadata . ranges _ . size ( ) ) ; 
 for ( Range range : srMetadata . ranges _ ) 
 { 
 - Range . serializer ( ) . serialize ( range , dos ) ; 
 + AbstractBounds . serializer ( ) . serialize ( range , dos ) ; 
 } 
 } 
 
 @ @ - 79 , 7 + 80 , 7 @ @ class StreamRequestMetadataSerializer implements ICompactSerializer < StreamReques 
 List < Range > ranges = ( size = = 0 ) ? null : new ArrayList < Range > ( ) ; 
 for ( int i = 0 ; i < size ; + + i ) 
 { 
 - ranges . add ( Range . serializer ( ) . deserialize ( dis ) ) ; 
 + ranges . add ( ( Range ) AbstractBounds . serializer ( ) . deserialize ( dis ) ) ; 
 } 
 return new StreamRequestMetadata ( target , ranges , table ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / thrift / CassandraServer . java b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 index 415086d . . 6de9342 100644 
 - - - a / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 + + + b / src / java / org / apache / cassandra / thrift / CassandraServer . java 
 @ @ - 37 , 6 + 37 , 7 @ @ import org . apache . cassandra . db . filter . QueryPath ; 
 
 import static org . apache . cassandra . thrift . ThriftGlue . * ; 
 
 + import org . apache . cassandra . dht . Bounds ; 
 import org . apache . cassandra . service . StorageProxy ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . thrift . Cassandra . Iface ; 
 @ @ - 555 , 9 + 556 , 9 @ @ public class CassandraServer implements Cassandra . Iface 
 List < Pair < String , ColumnFamily > > rows ; 
 try 
 { 
 - DecoratedKey startKey = StorageService . getPartitioner ( ) . decorateKey ( start _ key ) ; 
 - DecoratedKey finishKey = StorageService . getPartitioner ( ) . decorateKey ( finish _ key ) ; 
 - rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , startKey , finishKey , maxRows ) , consistency _ level ) ; 
 + Bounds bounds = new Bounds ( StorageService . getPartitioner ( ) . decorateKey ( start _ key ) . token , 
 + StorageService . getPartitioner ( ) . decorateKey ( finish _ key ) . token ) ; 
 + rows = StorageProxy . getRangeSlice ( new RangeSliceCommand ( keyspace , column _ parent , predicate , bounds , maxRows ) , consistency _ level ) ; 
 assert rows ! = null ; 
 } 
 catch ( TimeoutException e ) 
 diff - - git a / test / unit / org / apache / cassandra / Util . java b / test / unit / org / apache / cassandra / Util . java 
 index 4c4e52d . . 0ca35e8 100644 
 - - - a / test / unit / org / apache / cassandra / Util . java 
 + + + b / test / unit / org / apache / cassandra / Util . java 
 @ @ - 31 , 6 + 31 , 9 @ @ import org . apache . commons . lang . ArrayUtils ; 
 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . filter . QueryPath ; 
 + import org . apache . cassandra . dht . Bounds ; 
 + import org . apache . cassandra . dht . Range ; 
 + import org . apache . cassandra . dht . Token ; 
 import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . thrift . SliceRange ; 
 
 @ @ - 63 , 14 + 66 , 12 @ @ public class Util 
 
 public static RangeSliceReply getRangeSlice ( ColumnFamilyStore cfs ) throws IOException , ExecutionException , InterruptedException 
 { 
 - DecoratedKey emptyKey = StorageService . getPartitioner ( ) . decorateKey ( " " ) ; 
 + Token min = StorageService . getPartitioner ( ) . getMinimumToken ( ) ; 
 return cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , 
 - emptyKey , 
 - emptyKey , 
 + new Bounds ( min , min ) , 
 10000 , 
 new SliceRange ( ArrayUtils . EMPTY _ BYTE _ ARRAY , ArrayUtils . EMPTY _ BYTE _ ARRAY , false , 10000 ) , 
 - null , 
 - true ) ; 
 + null ) ; 
 } 
 
 / * * 
 diff - - git a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 index 79b661c . . 4a4abbb 100644 
 - - - a / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 + + + b / test / unit / org / apache / cassandra / db / ColumnFamilyStoreTest . java 
 @ @ - 137 , 12 + 137 , 10 @ @ public class ColumnFamilyStoreTest extends CleanupHelper 
 
 IPartitioner p = StorageService . getPartitioner ( ) ; 
 RangeSliceReply result = cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , 
 - p . decorateKey ( " key2 " ) , 
 - p . decorateKey ( " key1 " ) , 
 + new Range ( p . getToken ( " key15 " ) , p . getToken ( " key1 " ) ) , 
 10 , 
 null , 
 - Arrays . asList ( " asdf " . getBytes ( ) ) , 
 - true ) ; 
 + Arrays . asList ( " asdf " . getBytes ( ) ) ) ; 
 assertEquals ( 2 , result . rows . size ( ) ) ; 
 } 
 
 @ @ - 153 , 12 + 151 , 10 @ @ public class ColumnFamilyStoreTest extends CleanupHelper 
 
 IPartitioner p = StorageService . getPartitioner ( ) ; 
 RangeSliceReply result = cfs . getRangeSlice ( ArrayUtils . EMPTY _ BYTE _ ARRAY , 
 - p . decorateKey ( " key1 " ) , 
 - p . decorateKey ( " key2 " ) , 
 + new Range ( p . getToken ( " key1 " ) , p . getToken ( " key2 " ) ) , 
 10 , 
 null , 
 - Arrays . asList ( " asdf " . getBytes ( ) ) , 
 - false ) ; 
 + Arrays . asList ( " asdf " . getBytes ( ) ) ) ; 
 assertEquals ( 1 , result . rows . size ( ) ) ; 
 assert result . rows . get ( 0 ) . key . equals ( " key2 " ) ; 
 } 
 @ @ - 175 , 7 + 171 , 6 @ @ public class ColumnFamilyStoreTest extends CleanupHelper 
 rm = new RowMutation ( " Keyspace2 " , " key2 " ) ; 
 rm . add ( new QueryPath ( " Standard1 " , null , " Column1 " . getBytes ( ) ) , " asdf " . getBytes ( ) , 0 ) ; 
 rms . add ( rm ) ; 
 - ColumnFamilyStore cfs = Util . writeColumnFamily ( rms ) ; 
 - return cfs ; 
 + return Util . writeColumnFamily ( rms ) ; 
 } 
 }
