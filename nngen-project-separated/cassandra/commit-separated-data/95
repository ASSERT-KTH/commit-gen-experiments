BLEU SCORE: 0.03214954573057458

TEST MSG: Add a virtual table to expose settings
GENERATED MSG: Workaround for netty issue causing corrupted data to come off the wire

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index aeaf8ce . . 9fbaf25 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add a virtual table to expose settings ( CASSANDRA - 14573 ) <nl> * Fix up chunk cache handling of metrics ( CASSANDRA - 14628 ) <nl> * Extend IAuthenticator to accept peer SSL certificates ( CASSANDRA - 14652 ) <nl> * Incomplete handling of exceptions when decoding incoming messages ( CASSANDRA - 14574 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / virtual / SettingsTable . java b / src / java / org / apache / cassandra / db / virtual / SettingsTable . java <nl> new file mode 100644 <nl> index 0000000 . . 34debc6 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / db / virtual / SettingsTable . java <nl> @ @ - 0 , 0 + 1 , 189 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . db . virtual ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . util . Arrays ; <nl> + import java . util . Map ; <nl> + import java . util . function . BiConsumer ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . base . Functions ; <nl> + import com . google . common . base . Preconditions ; <nl> + import com . google . common . collect . ImmutableMap ; <nl> + <nl> + import org . apache . cassandra . audit . AuditLogOptions ; <nl> + import org . apache . cassandra . config . * ; <nl> + import org . apache . cassandra . db . DecoratedKey ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . dht . LocalPartitioner ; <nl> + import org . apache . cassandra . schema . TableMetadata ; <nl> + import org . apache . cassandra . transport . ServerError ; <nl> + <nl> + final class SettingsTable extends AbstractVirtualTable <nl> + { <nl> + private static final String NAME = " name " ; <nl> + private static final String VALUE = " value " ; <nl> + <nl> + @ VisibleForTesting <nl> + static final Map < String , Field > FIELDS = <nl> + Arrays . stream ( Config . class . getFields ( ) ) <nl> + . filter ( f - > ! Modifier . isStatic ( f . getModifiers ( ) ) ) <nl> + . collect ( Collectors . toMap ( Field : : getName , Functions . identity ( ) ) ) ; <nl> + <nl> + @ VisibleForTesting <nl> + final Map < String , BiConsumer < SimpleDataSet , Field > > overrides = <nl> + ImmutableMap . < String , BiConsumer < SimpleDataSet , Field > > builder ( ) <nl> + . put ( " audit _ logging _ options " , this : : addAuditLoggingOptions ) <nl> + . put ( " client _ encryption _ options " , this : : addEncryptionOptions ) <nl> + . put ( " server _ encryption _ options " , this : : addEncryptionOptions ) <nl> + . put ( " transparent _ data _ encryption _ options " , this : : addTransparentEncryptionOptions ) <nl> + . build ( ) ; <nl> + <nl> + private final Config config ; <nl> + <nl> + SettingsTable ( String keyspace ) <nl> + { <nl> + this ( keyspace , DatabaseDescriptor . getRawConfig ( ) ) ; <nl> + } <nl> + <nl> + SettingsTable ( String keyspace , Config config ) <nl> + { <nl> + super ( TableMetadata . builder ( keyspace , " settings " ) <nl> + . comment ( " current settings " ) <nl> + . kind ( TableMetadata . Kind . VIRTUAL ) <nl> + . partitioner ( new LocalPartitioner ( UTF8Type . instance ) ) <nl> + . addPartitionKeyColumn ( NAME , UTF8Type . instance ) <nl> + . addRegularColumn ( VALUE , UTF8Type . instance ) <nl> + . build ( ) ) ; <nl> + this . config = config ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + Object getValue ( Field f ) <nl> + { <nl> + Object value ; <nl> + try <nl> + { <nl> + value = f . get ( config ) ; <nl> + } <nl> + catch ( IllegalAccessException | IllegalArgumentException e ) <nl> + { <nl> + throw new ServerError ( e ) ; <nl> + } <nl> + return value ; <nl> + } <nl> + <nl> + private void addValue ( SimpleDataSet result , Field f ) <nl> + { <nl> + Object value = getValue ( f ) ; <nl> + if ( value = = null ) <nl> + { <nl> + result . row ( f . getName ( ) ) ; <nl> + } <nl> + else if ( overrides . containsKey ( f . getName ( ) ) ) <nl> + { <nl> + overrides . get ( f . getName ( ) ) . accept ( result , f ) ; <nl> + } <nl> + else <nl> + { <nl> + if ( value . getClass ( ) . isArray ( ) ) <nl> + value = Arrays . toString ( ( Object [ ] ) value ) ; <nl> + result . row ( f . getName ( ) ) . column ( VALUE , value . toString ( ) ) ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public DataSet data ( DecoratedKey partitionKey ) <nl> + { <nl> + SimpleDataSet result = new SimpleDataSet ( metadata ( ) ) ; <nl> + String name = UTF8Type . instance . compose ( partitionKey . getKey ( ) ) ; <nl> + Field field = FIELDS . get ( name ) ; <nl> + if ( field ! = null ) <nl> + { <nl> + addValue ( result , field ) ; <nl> + } <nl> + else <nl> + { <nl> + / / rows created by overrides might be directly queried so include them in result to be possibly filtered <nl> + for ( String override : overrides . keySet ( ) ) <nl> + if ( name . startsWith ( override ) ) <nl> + addValue ( result , FIELDS . get ( override ) ) ; <nl> + } <nl> + return result ; <nl> + } <nl> + <nl> + @ Override <nl> + public DataSet data ( ) <nl> + { <nl> + SimpleDataSet result = new SimpleDataSet ( metadata ( ) ) ; <nl> + for ( Field setting : FIELDS . values ( ) ) <nl> + addValue ( result , setting ) ; <nl> + return result ; <nl> + } <nl> + <nl> + private void addAuditLoggingOptions ( SimpleDataSet result , Field f ) <nl> + { <nl> + Preconditions . checkArgument ( AuditLogOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; <nl> + <nl> + AuditLogOptions value = ( AuditLogOptions ) getValue ( f ) ; <nl> + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; <nl> + result . row ( f . getName ( ) + " _ logger " ) . column ( VALUE , value . logger ) ; <nl> + result . row ( f . getName ( ) + " _ audit _ logs _ dir " ) . column ( VALUE , value . audit _ logs _ dir ) ; <nl> + result . row ( f . getName ( ) + " _ included _ keyspaces " ) . column ( VALUE , value . included _ keyspaces ) ; <nl> + result . row ( f . getName ( ) + " _ excluded _ keyspaces " ) . column ( VALUE , value . excluded _ keyspaces ) ; <nl> + result . row ( f . getName ( ) + " _ included _ categories " ) . column ( VALUE , value . included _ categories ) ; <nl> + result . row ( f . getName ( ) + " _ excluded _ categories " ) . column ( VALUE , value . excluded _ categories ) ; <nl> + result . row ( f . getName ( ) + " _ included _ users " ) . column ( VALUE , value . included _ users ) ; <nl> + result . row ( f . getName ( ) + " _ excluded _ users " ) . column ( VALUE , value . excluded _ users ) ; <nl> + } <nl> + <nl> + private void addEncryptionOptions ( SimpleDataSet result , Field f ) <nl> + { <nl> + Preconditions . checkArgument ( EncryptionOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; <nl> + <nl> + EncryptionOptions value = ( EncryptionOptions ) getValue ( f ) ; <nl> + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; <nl> + result . row ( f . getName ( ) + " _ algorithm " ) . column ( VALUE , value . algorithm ) ; <nl> + result . row ( f . getName ( ) + " _ protocol " ) . column ( VALUE , value . protocol ) ; <nl> + result . row ( f . getName ( ) + " _ cipher _ suites " ) . column ( VALUE , Arrays . toString ( value . cipher _ suites ) ) ; <nl> + result . row ( f . getName ( ) + " _ client _ auth " ) . column ( VALUE , Boolean . toString ( value . require _ client _ auth ) ) ; <nl> + result . row ( f . getName ( ) + " _ endpoint _ verification " ) . column ( VALUE , Boolean . toString ( value . require _ endpoint _ verification ) ) ; <nl> + result . row ( f . getName ( ) + " _ optional " ) . column ( VALUE , Boolean . toString ( value . optional ) ) ; <nl> + <nl> + if ( value instanceof EncryptionOptions . ServerEncryptionOptions ) <nl> + { <nl> + EncryptionOptions . ServerEncryptionOptions server = ( EncryptionOptions . ServerEncryptionOptions ) value ; <nl> + result . row ( f . getName ( ) + " _ internode _ encryption " ) . column ( VALUE , server . internode _ encryption . toString ( ) ) ; <nl> + result . row ( f . getName ( ) + " _ legacy _ ssl _ storage _ port " ) . column ( VALUE , Boolean . toString ( server . enable _ legacy _ ssl _ storage _ port ) ) ; <nl> + } <nl> + } <nl> + <nl> + private void addTransparentEncryptionOptions ( SimpleDataSet result , Field f ) <nl> + { <nl> + Preconditions . checkArgument ( TransparentDataEncryptionOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; <nl> + <nl> + TransparentDataEncryptionOptions value = ( TransparentDataEncryptionOptions ) getValue ( f ) ; <nl> + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; <nl> + result . row ( f . getName ( ) + " _ cipher " ) . column ( VALUE , value . cipher ) ; <nl> + result . row ( f . getName ( ) + " _ chunk _ length _ kb " ) . column ( VALUE , Integer . toString ( value . chunk _ length _ kb ) ) ; <nl> + result . row ( f . getName ( ) + " _ iv _ length " ) . column ( VALUE , Integer . toString ( value . iv _ length ) ) ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java b / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java <nl> index 3505a30 . . f85991a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java <nl> + + + b / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java <nl> @ @ - 29 , 6 + 29 , 7 @ @ public final class SystemViewsKeyspace extends VirtualKeyspace <nl> { <nl> super ( NAME , ImmutableList . of ( new CachesTable ( NAME ) , <nl> new ClientsTable ( NAME ) , <nl> + new SettingsTable ( NAME ) , <nl> new SSTableTasksTable ( NAME ) , <nl> new ThreadPoolsTable ( NAME ) ) ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java b / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java <nl> new file mode 100644 <nl> index 0000000 . . 927835f <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java <nl> @ @ - 0 , 0 + 1 , 245 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . db . virtual ; <nl> + <nl> + import java . lang . reflect . Field ; <nl> + import java . lang . reflect . Modifier ; <nl> + import java . util . Arrays ; <nl> + import java . util . List ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import org . junit . Assert ; <nl> + import org . junit . Before ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import com . datastax . driver . core . ResultSet ; <nl> + import com . datastax . driver . core . Row ; <nl> + import org . apache . cassandra . config . Config ; <nl> + import org . apache . cassandra . config . EncryptionOptions . ServerEncryptionOptions . InternodeEncryption ; <nl> + import org . apache . cassandra . cql3 . CQLTester ; <nl> + <nl> + public class SettingsTableTest extends CQLTester <nl> + { <nl> + private static final String KS _ NAME = " vts " ; <nl> + <nl> + private Config config ; <nl> + private SettingsTable table ; <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) <nl> + { <nl> + CQLTester . setUpClass ( ) ; <nl> + } <nl> + <nl> + @ Before <nl> + public void config ( ) <nl> + { <nl> + config = new Config ( ) ; <nl> + table = new SettingsTable ( KS _ NAME , config ) ; <nl> + VirtualKeyspaceRegistry . instance . register ( new VirtualKeyspace ( KS _ NAME , ImmutableList . of ( table ) ) ) ; <nl> + } <nl> + <nl> + private String getValue ( Field f ) <nl> + { <nl> + Object untypedValue = table . getValue ( f ) ; <nl> + String value = null ; <nl> + if ( untypedValue ! = null ) <nl> + { <nl> + if ( untypedValue . getClass ( ) . isArray ( ) ) <nl> + { <nl> + value = Arrays . toString ( ( Object [ ] ) untypedValue ) ; <nl> + } <nl> + else <nl> + value = untypedValue . toString ( ) ; <nl> + } <nl> + return value ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSelectAll ( ) throws Throwable <nl> + { <nl> + int paging = ( int ) ( Math . random ( ) * 100 + 1 ) ; <nl> + ResultSet result = executeNetWithPaging ( " SELECT * FROM vts . settings " , paging ) ; <nl> + int i = 0 ; <nl> + for ( Row r : result ) <nl> + { <nl> + i + + ; <nl> + String name = r . getString ( " name " ) ; <nl> + Field f = SettingsTable . FIELDS . get ( name ) ; <nl> + if ( f ! = null ) / / skip overrides <nl> + Assert . assertEquals ( getValue ( f ) , r . getString ( " value " ) ) ; <nl> + } <nl> + Assert . assertTrue ( SettingsTable . FIELDS . size ( ) < = i ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSelectPartition ( ) throws Throwable <nl> + { <nl> + List < Field > fields = Arrays . stream ( Config . class . getFields ( ) ) <nl> + . filter ( f - > ! Modifier . isStatic ( f . getModifiers ( ) ) ) <nl> + . collect ( Collectors . toList ( ) ) ; <nl> + for ( Field f : fields ) <nl> + { <nl> + if ( table . overrides . containsKey ( f . getName ( ) ) ) <nl> + continue ; <nl> + <nl> + String q = " SELECT * FROM vts . settings WHERE name = ' " + f . getName ( ) + ' \ ' ' ; <nl> + assertRowsNet ( executeNet ( q ) , new Object [ ] { f . getName ( ) , getValue ( f ) } ) ; <nl> + } <nl> + } <nl> + <nl> + @ Test <nl> + public void testSelectEmpty ( ) throws Throwable <nl> + { <nl> + String q = " SELECT * FROM vts . settings WHERE name = ' EMPTY ' " ; <nl> + assertRowsNet ( executeNet ( q ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testSelectOverride ( ) throws Throwable <nl> + { <nl> + String q = " SELECT * FROM vts . settings WHERE name = ' server _ encryption _ options _ enabled ' " ; <nl> + assertRowsNet ( executeNet ( q ) , new Object [ ] { " server _ encryption _ options _ enabled " , " false " } ) ; <nl> + q = " SELECT * FROM vts . settings WHERE name = ' server _ encryption _ options _ XYZ ' " ; <nl> + assertRowsNet ( executeNet ( q ) ) ; <nl> + } <nl> + <nl> + private void check ( String setting , String expected ) throws Throwable <nl> + { <nl> + String q = " SELECT * FROM vts . settings WHERE name = ' " + setting + ' \ ' ' ; <nl> + assertRowsNet ( executeNet ( q ) , new Object [ ] { setting , expected } ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testEncryptionOverride ( ) throws Throwable <nl> + { <nl> + String pre = " server _ encryption _ options _ " ; <nl> + check ( pre + " enabled " , " false " ) ; <nl> + String all = " SELECT * FROM vts . settings WHERE " + <nl> + " name > ' server _ encryption ' AND name < ' server _ encryptionz ' ALLOW FILTERING " ; <nl> + <nl> + config . server _ encryption _ options . enabled = true ; <nl> + Assert . assertEquals ( 9 , executeNet ( all ) . all ( ) . size ( ) ) ; <nl> + check ( pre + " enabled " , " true " ) ; <nl> + <nl> + check ( pre + " algorithm " , null ) ; <nl> + config . server _ encryption _ options . algorithm = " SUPERSSL " ; <nl> + check ( pre + " algorithm " , " SUPERSSL " ) ; <nl> + <nl> + check ( pre + " cipher _ suites " , " [ ] " ) ; <nl> + config . server _ encryption _ options . cipher _ suites = new String [ ] { " c1 " , " c2 " } ; <nl> + check ( pre + " cipher _ suites " , " [ c1 , c2 ] " ) ; <nl> + <nl> + check ( pre + " protocol " , config . server _ encryption _ options . protocol ) ; <nl> + config . server _ encryption _ options . protocol = " TLSv5 " ; <nl> + check ( pre + " protocol " , " TLSv5 " ) ; <nl> + <nl> + check ( pre + " optional " , " false " ) ; <nl> + config . server _ encryption _ options . optional = true ; <nl> + check ( pre + " optional " , " true " ) ; <nl> + <nl> + check ( pre + " client _ auth " , " false " ) ; <nl> + config . server _ encryption _ options . require _ client _ auth = true ; <nl> + check ( pre + " client _ auth " , " true " ) ; <nl> + <nl> + check ( pre + " endpoint _ verification " , " false " ) ; <nl> + config . server _ encryption _ options . require _ endpoint _ verification = true ; <nl> + check ( pre + " endpoint _ verification " , " true " ) ; <nl> + <nl> + check ( pre + " internode _ encryption " , " none " ) ; <nl> + config . server _ encryption _ options . internode _ encryption = InternodeEncryption . all ; <nl> + check ( pre + " internode _ encryption " , " all " ) ; <nl> + <nl> + check ( pre + " legacy _ ssl _ storage _ port " , " false " ) ; <nl> + config . server _ encryption _ options . enable _ legacy _ ssl _ storage _ port = true ; <nl> + check ( pre + " legacy _ ssl _ storage _ port " , " true " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testAuditOverride ( ) throws Throwable <nl> + { <nl> + String pre = " audit _ logging _ options _ " ; <nl> + check ( pre + " enabled " , " false " ) ; <nl> + String all = " SELECT * FROM vts . settings WHERE " + <nl> + " name > ' audit _ logging ' AND name < ' audit _ loggingz ' ALLOW FILTERING " ; <nl> + <nl> + config . audit _ logging _ options . enabled = true ; <nl> + Assert . assertEquals ( 9 , executeNet ( all ) . all ( ) . size ( ) ) ; <nl> + check ( pre + " enabled " , " true " ) ; <nl> + <nl> + check ( pre + " logger " , " BinAuditLogger " ) ; <nl> + config . audit _ logging _ options . logger = " logger " ; <nl> + check ( pre + " logger " , " logger " ) ; <nl> + <nl> + config . audit _ logging _ options . audit _ logs _ dir = " dir " ; <nl> + check ( pre + " audit _ logs _ dir " , " dir " ) ; <nl> + <nl> + check ( pre + " included _ keyspaces " , " " ) ; <nl> + config . audit _ logging _ options . included _ keyspaces = " included _ keyspaces " ; <nl> + check ( pre + " included _ keyspaces " , " included _ keyspaces " ) ; <nl> + <nl> + check ( pre + " excluded _ keyspaces " , " " ) ; <nl> + config . audit _ logging _ options . excluded _ keyspaces = " excluded _ keyspaces " ; <nl> + check ( pre + " excluded _ keyspaces " , " excluded _ keyspaces " ) ; <nl> + <nl> + check ( pre + " included _ categories " , " " ) ; <nl> + config . audit _ logging _ options . included _ categories = " included _ categories " ; <nl> + check ( pre + " included _ categories " , " included _ categories " ) ; <nl> + <nl> + check ( pre + " excluded _ categories " , " " ) ; <nl> + config . audit _ logging _ options . excluded _ categories = " excluded _ categories " ; <nl> + check ( pre + " excluded _ categories " , " excluded _ categories " ) ; <nl> + <nl> + check ( pre + " included _ users " , " " ) ; <nl> + config . audit _ logging _ options . included _ users = " included _ users " ; <nl> + check ( pre + " included _ users " , " included _ users " ) ; <nl> + <nl> + check ( pre + " excluded _ users " , " " ) ; <nl> + config . audit _ logging _ options . excluded _ users = " excluded _ users " ; <nl> + check ( pre + " excluded _ users " , " excluded _ users " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testTransparentEncryptionOptionsOverride ( ) throws Throwable <nl> + { <nl> + String pre = " transparent _ data _ encryption _ options _ " ; <nl> + check ( pre + " enabled " , " false " ) ; <nl> + String all = " SELECT * FROM vts . settings WHERE " + <nl> + " name > ' transparent _ data _ encryption _ options ' AND " + <nl> + " name < ' transparent _ data _ encryption _ optionsz ' ALLOW FILTERING " ; <nl> + <nl> + config . transparent _ data _ encryption _ options . enabled = true ; <nl> + Assert . assertEquals ( 4 , executeNet ( all ) . all ( ) . size ( ) ) ; <nl> + check ( pre + " enabled " , " true " ) ; <nl> + <nl> + check ( pre + " cipher " , " AES / CBC / PKCS5Padding " ) ; <nl> + config . transparent _ data _ encryption _ options . cipher = " cipher " ; <nl> + check ( pre + " cipher " , " cipher " ) ; <nl> + <nl> + check ( pre + " chunk _ length _ kb " , " 64 " ) ; <nl> + config . transparent _ data _ encryption _ options . chunk _ length _ kb = 5 ; <nl> + check ( pre + " chunk _ length _ kb " , " 5 " ) ; <nl> + <nl> + check ( pre + " iv _ length " , " 16 " ) ; <nl> + config . transparent _ data _ encryption _ options . iv _ length = 7 ; <nl> + check ( pre + " iv _ length " , " 7 " ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index aeaf8ce . . 9fbaf25 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add a virtual table to expose settings ( CASSANDRA - 14573 ) 
 * Fix up chunk cache handling of metrics ( CASSANDRA - 14628 ) 
 * Extend IAuthenticator to accept peer SSL certificates ( CASSANDRA - 14652 ) 
 * Incomplete handling of exceptions when decoding incoming messages ( CASSANDRA - 14574 ) 
 diff - - git a / src / java / org / apache / cassandra / db / virtual / SettingsTable . java b / src / java / org / apache / cassandra / db / virtual / SettingsTable . java 
 new file mode 100644 
 index 0000000 . . 34debc6 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / db / virtual / SettingsTable . java 
 @ @ - 0 , 0 + 1 , 189 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . db . virtual ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Modifier ; 
 + import java . util . Arrays ; 
 + import java . util . Map ; 
 + import java . util . function . BiConsumer ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . base . Functions ; 
 + import com . google . common . base . Preconditions ; 
 + import com . google . common . collect . ImmutableMap ; 
 + 
 + import org . apache . cassandra . audit . AuditLogOptions ; 
 + import org . apache . cassandra . config . * ; 
 + import org . apache . cassandra . db . DecoratedKey ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . dht . LocalPartitioner ; 
 + import org . apache . cassandra . schema . TableMetadata ; 
 + import org . apache . cassandra . transport . ServerError ; 
 + 
 + final class SettingsTable extends AbstractVirtualTable 
 + { 
 + private static final String NAME = " name " ; 
 + private static final String VALUE = " value " ; 
 + 
 + @ VisibleForTesting 
 + static final Map < String , Field > FIELDS = 
 + Arrays . stream ( Config . class . getFields ( ) ) 
 + . filter ( f - > ! Modifier . isStatic ( f . getModifiers ( ) ) ) 
 + . collect ( Collectors . toMap ( Field : : getName , Functions . identity ( ) ) ) ; 
 + 
 + @ VisibleForTesting 
 + final Map < String , BiConsumer < SimpleDataSet , Field > > overrides = 
 + ImmutableMap . < String , BiConsumer < SimpleDataSet , Field > > builder ( ) 
 + . put ( " audit _ logging _ options " , this : : addAuditLoggingOptions ) 
 + . put ( " client _ encryption _ options " , this : : addEncryptionOptions ) 
 + . put ( " server _ encryption _ options " , this : : addEncryptionOptions ) 
 + . put ( " transparent _ data _ encryption _ options " , this : : addTransparentEncryptionOptions ) 
 + . build ( ) ; 
 + 
 + private final Config config ; 
 + 
 + SettingsTable ( String keyspace ) 
 + { 
 + this ( keyspace , DatabaseDescriptor . getRawConfig ( ) ) ; 
 + } 
 + 
 + SettingsTable ( String keyspace , Config config ) 
 + { 
 + super ( TableMetadata . builder ( keyspace , " settings " ) 
 + . comment ( " current settings " ) 
 + . kind ( TableMetadata . Kind . VIRTUAL ) 
 + . partitioner ( new LocalPartitioner ( UTF8Type . instance ) ) 
 + . addPartitionKeyColumn ( NAME , UTF8Type . instance ) 
 + . addRegularColumn ( VALUE , UTF8Type . instance ) 
 + . build ( ) ) ; 
 + this . config = config ; 
 + } 
 + 
 + @ VisibleForTesting 
 + Object getValue ( Field f ) 
 + { 
 + Object value ; 
 + try 
 + { 
 + value = f . get ( config ) ; 
 + } 
 + catch ( IllegalAccessException | IllegalArgumentException e ) 
 + { 
 + throw new ServerError ( e ) ; 
 + } 
 + return value ; 
 + } 
 + 
 + private void addValue ( SimpleDataSet result , Field f ) 
 + { 
 + Object value = getValue ( f ) ; 
 + if ( value = = null ) 
 + { 
 + result . row ( f . getName ( ) ) ; 
 + } 
 + else if ( overrides . containsKey ( f . getName ( ) ) ) 
 + { 
 + overrides . get ( f . getName ( ) ) . accept ( result , f ) ; 
 + } 
 + else 
 + { 
 + if ( value . getClass ( ) . isArray ( ) ) 
 + value = Arrays . toString ( ( Object [ ] ) value ) ; 
 + result . row ( f . getName ( ) ) . column ( VALUE , value . toString ( ) ) ; 
 + } 
 + } 
 + 
 + @ Override 
 + public DataSet data ( DecoratedKey partitionKey ) 
 + { 
 + SimpleDataSet result = new SimpleDataSet ( metadata ( ) ) ; 
 + String name = UTF8Type . instance . compose ( partitionKey . getKey ( ) ) ; 
 + Field field = FIELDS . get ( name ) ; 
 + if ( field ! = null ) 
 + { 
 + addValue ( result , field ) ; 
 + } 
 + else 
 + { 
 + / / rows created by overrides might be directly queried so include them in result to be possibly filtered 
 + for ( String override : overrides . keySet ( ) ) 
 + if ( name . startsWith ( override ) ) 
 + addValue ( result , FIELDS . get ( override ) ) ; 
 + } 
 + return result ; 
 + } 
 + 
 + @ Override 
 + public DataSet data ( ) 
 + { 
 + SimpleDataSet result = new SimpleDataSet ( metadata ( ) ) ; 
 + for ( Field setting : FIELDS . values ( ) ) 
 + addValue ( result , setting ) ; 
 + return result ; 
 + } 
 + 
 + private void addAuditLoggingOptions ( SimpleDataSet result , Field f ) 
 + { 
 + Preconditions . checkArgument ( AuditLogOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; 
 + 
 + AuditLogOptions value = ( AuditLogOptions ) getValue ( f ) ; 
 + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; 
 + result . row ( f . getName ( ) + " _ logger " ) . column ( VALUE , value . logger ) ; 
 + result . row ( f . getName ( ) + " _ audit _ logs _ dir " ) . column ( VALUE , value . audit _ logs _ dir ) ; 
 + result . row ( f . getName ( ) + " _ included _ keyspaces " ) . column ( VALUE , value . included _ keyspaces ) ; 
 + result . row ( f . getName ( ) + " _ excluded _ keyspaces " ) . column ( VALUE , value . excluded _ keyspaces ) ; 
 + result . row ( f . getName ( ) + " _ included _ categories " ) . column ( VALUE , value . included _ categories ) ; 
 + result . row ( f . getName ( ) + " _ excluded _ categories " ) . column ( VALUE , value . excluded _ categories ) ; 
 + result . row ( f . getName ( ) + " _ included _ users " ) . column ( VALUE , value . included _ users ) ; 
 + result . row ( f . getName ( ) + " _ excluded _ users " ) . column ( VALUE , value . excluded _ users ) ; 
 + } 
 + 
 + private void addEncryptionOptions ( SimpleDataSet result , Field f ) 
 + { 
 + Preconditions . checkArgument ( EncryptionOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; 
 + 
 + EncryptionOptions value = ( EncryptionOptions ) getValue ( f ) ; 
 + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; 
 + result . row ( f . getName ( ) + " _ algorithm " ) . column ( VALUE , value . algorithm ) ; 
 + result . row ( f . getName ( ) + " _ protocol " ) . column ( VALUE , value . protocol ) ; 
 + result . row ( f . getName ( ) + " _ cipher _ suites " ) . column ( VALUE , Arrays . toString ( value . cipher _ suites ) ) ; 
 + result . row ( f . getName ( ) + " _ client _ auth " ) . column ( VALUE , Boolean . toString ( value . require _ client _ auth ) ) ; 
 + result . row ( f . getName ( ) + " _ endpoint _ verification " ) . column ( VALUE , Boolean . toString ( value . require _ endpoint _ verification ) ) ; 
 + result . row ( f . getName ( ) + " _ optional " ) . column ( VALUE , Boolean . toString ( value . optional ) ) ; 
 + 
 + if ( value instanceof EncryptionOptions . ServerEncryptionOptions ) 
 + { 
 + EncryptionOptions . ServerEncryptionOptions server = ( EncryptionOptions . ServerEncryptionOptions ) value ; 
 + result . row ( f . getName ( ) + " _ internode _ encryption " ) . column ( VALUE , server . internode _ encryption . toString ( ) ) ; 
 + result . row ( f . getName ( ) + " _ legacy _ ssl _ storage _ port " ) . column ( VALUE , Boolean . toString ( server . enable _ legacy _ ssl _ storage _ port ) ) ; 
 + } 
 + } 
 + 
 + private void addTransparentEncryptionOptions ( SimpleDataSet result , Field f ) 
 + { 
 + Preconditions . checkArgument ( TransparentDataEncryptionOptions . class . isAssignableFrom ( f . getType ( ) ) ) ; 
 + 
 + TransparentDataEncryptionOptions value = ( TransparentDataEncryptionOptions ) getValue ( f ) ; 
 + result . row ( f . getName ( ) + " _ enabled " ) . column ( VALUE , Boolean . toString ( value . enabled ) ) ; 
 + result . row ( f . getName ( ) + " _ cipher " ) . column ( VALUE , value . cipher ) ; 
 + result . row ( f . getName ( ) + " _ chunk _ length _ kb " ) . column ( VALUE , Integer . toString ( value . chunk _ length _ kb ) ) ; 
 + result . row ( f . getName ( ) + " _ iv _ length " ) . column ( VALUE , Integer . toString ( value . iv _ length ) ) ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java b / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java 
 index 3505a30 . . f85991a 100644 
 - - - a / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java 
 + + + b / src / java / org / apache / cassandra / db / virtual / SystemViewsKeyspace . java 
 @ @ - 29 , 6 + 29 , 7 @ @ public final class SystemViewsKeyspace extends VirtualKeyspace 
 { 
 super ( NAME , ImmutableList . of ( new CachesTable ( NAME ) , 
 new ClientsTable ( NAME ) , 
 + new SettingsTable ( NAME ) , 
 new SSTableTasksTable ( NAME ) , 
 new ThreadPoolsTable ( NAME ) ) ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java b / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java 
 new file mode 100644 
 index 0000000 . . 927835f 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / virtual / SettingsTableTest . java 
 @ @ - 0 , 0 + 1 , 245 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . db . virtual ; 
 + 
 + import java . lang . reflect . Field ; 
 + import java . lang . reflect . Modifier ; 
 + import java . util . Arrays ; 
 + import java . util . List ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import org . junit . Assert ; 
 + import org . junit . Before ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import com . datastax . driver . core . ResultSet ; 
 + import com . datastax . driver . core . Row ; 
 + import org . apache . cassandra . config . Config ; 
 + import org . apache . cassandra . config . EncryptionOptions . ServerEncryptionOptions . InternodeEncryption ; 
 + import org . apache . cassandra . cql3 . CQLTester ; 
 + 
 + public class SettingsTableTest extends CQLTester 
 + { 
 + private static final String KS _ NAME = " vts " ; 
 + 
 + private Config config ; 
 + private SettingsTable table ; 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) 
 + { 
 + CQLTester . setUpClass ( ) ; 
 + } 
 + 
 + @ Before 
 + public void config ( ) 
 + { 
 + config = new Config ( ) ; 
 + table = new SettingsTable ( KS _ NAME , config ) ; 
 + VirtualKeyspaceRegistry . instance . register ( new VirtualKeyspace ( KS _ NAME , ImmutableList . of ( table ) ) ) ; 
 + } 
 + 
 + private String getValue ( Field f ) 
 + { 
 + Object untypedValue = table . getValue ( f ) ; 
 + String value = null ; 
 + if ( untypedValue ! = null ) 
 + { 
 + if ( untypedValue . getClass ( ) . isArray ( ) ) 
 + { 
 + value = Arrays . toString ( ( Object [ ] ) untypedValue ) ; 
 + } 
 + else 
 + value = untypedValue . toString ( ) ; 
 + } 
 + return value ; 
 + } 
 + 
 + @ Test 
 + public void testSelectAll ( ) throws Throwable 
 + { 
 + int paging = ( int ) ( Math . random ( ) * 100 + 1 ) ; 
 + ResultSet result = executeNetWithPaging ( " SELECT * FROM vts . settings " , paging ) ; 
 + int i = 0 ; 
 + for ( Row r : result ) 
 + { 
 + i + + ; 
 + String name = r . getString ( " name " ) ; 
 + Field f = SettingsTable . FIELDS . get ( name ) ; 
 + if ( f ! = null ) / / skip overrides 
 + Assert . assertEquals ( getValue ( f ) , r . getString ( " value " ) ) ; 
 + } 
 + Assert . assertTrue ( SettingsTable . FIELDS . size ( ) < = i ) ; 
 + } 
 + 
 + @ Test 
 + public void testSelectPartition ( ) throws Throwable 
 + { 
 + List < Field > fields = Arrays . stream ( Config . class . getFields ( ) ) 
 + . filter ( f - > ! Modifier . isStatic ( f . getModifiers ( ) ) ) 
 + . collect ( Collectors . toList ( ) ) ; 
 + for ( Field f : fields ) 
 + { 
 + if ( table . overrides . containsKey ( f . getName ( ) ) ) 
 + continue ; 
 + 
 + String q = " SELECT * FROM vts . settings WHERE name = ' " + f . getName ( ) + ' \ ' ' ; 
 + assertRowsNet ( executeNet ( q ) , new Object [ ] { f . getName ( ) , getValue ( f ) } ) ; 
 + } 
 + } 
 + 
 + @ Test 
 + public void testSelectEmpty ( ) throws Throwable 
 + { 
 + String q = " SELECT * FROM vts . settings WHERE name = ' EMPTY ' " ; 
 + assertRowsNet ( executeNet ( q ) ) ; 
 + } 
 + 
 + @ Test 
 + public void testSelectOverride ( ) throws Throwable 
 + { 
 + String q = " SELECT * FROM vts . settings WHERE name = ' server _ encryption _ options _ enabled ' " ; 
 + assertRowsNet ( executeNet ( q ) , new Object [ ] { " server _ encryption _ options _ enabled " , " false " } ) ; 
 + q = " SELECT * FROM vts . settings WHERE name = ' server _ encryption _ options _ XYZ ' " ; 
 + assertRowsNet ( executeNet ( q ) ) ; 
 + } 
 + 
 + private void check ( String setting , String expected ) throws Throwable 
 + { 
 + String q = " SELECT * FROM vts . settings WHERE name = ' " + setting + ' \ ' ' ; 
 + assertRowsNet ( executeNet ( q ) , new Object [ ] { setting , expected } ) ; 
 + } 
 + 
 + @ Test 
 + public void testEncryptionOverride ( ) throws Throwable 
 + { 
 + String pre = " server _ encryption _ options _ " ; 
 + check ( pre + " enabled " , " false " ) ; 
 + String all = " SELECT * FROM vts . settings WHERE " + 
 + " name > ' server _ encryption ' AND name < ' server _ encryptionz ' ALLOW FILTERING " ; 
 + 
 + config . server _ encryption _ options . enabled = true ; 
 + Assert . assertEquals ( 9 , executeNet ( all ) . all ( ) . size ( ) ) ; 
 + check ( pre + " enabled " , " true " ) ; 
 + 
 + check ( pre + " algorithm " , null ) ; 
 + config . server _ encryption _ options . algorithm = " SUPERSSL " ; 
 + check ( pre + " algorithm " , " SUPERSSL " ) ; 
 + 
 + check ( pre + " cipher _ suites " , " [ ] " ) ; 
 + config . server _ encryption _ options . cipher _ suites = new String [ ] { " c1 " , " c2 " } ; 
 + check ( pre + " cipher _ suites " , " [ c1 , c2 ] " ) ; 
 + 
 + check ( pre + " protocol " , config . server _ encryption _ options . protocol ) ; 
 + config . server _ encryption _ options . protocol = " TLSv5 " ; 
 + check ( pre + " protocol " , " TLSv5 " ) ; 
 + 
 + check ( pre + " optional " , " false " ) ; 
 + config . server _ encryption _ options . optional = true ; 
 + check ( pre + " optional " , " true " ) ; 
 + 
 + check ( pre + " client _ auth " , " false " ) ; 
 + config . server _ encryption _ options . require _ client _ auth = true ; 
 + check ( pre + " client _ auth " , " true " ) ; 
 + 
 + check ( pre + " endpoint _ verification " , " false " ) ; 
 + config . server _ encryption _ options . require _ endpoint _ verification = true ; 
 + check ( pre + " endpoint _ verification " , " true " ) ; 
 + 
 + check ( pre + " internode _ encryption " , " none " ) ; 
 + config . server _ encryption _ options . internode _ encryption = InternodeEncryption . all ; 
 + check ( pre + " internode _ encryption " , " all " ) ; 
 + 
 + check ( pre + " legacy _ ssl _ storage _ port " , " false " ) ; 
 + config . server _ encryption _ options . enable _ legacy _ ssl _ storage _ port = true ; 
 + check ( pre + " legacy _ ssl _ storage _ port " , " true " ) ; 
 + } 
 + 
 + @ Test 
 + public void testAuditOverride ( ) throws Throwable 
 + { 
 + String pre = " audit _ logging _ options _ " ; 
 + check ( pre + " enabled " , " false " ) ; 
 + String all = " SELECT * FROM vts . settings WHERE " + 
 + " name > ' audit _ logging ' AND name < ' audit _ loggingz ' ALLOW FILTERING " ; 
 + 
 + config . audit _ logging _ options . enabled = true ; 
 + Assert . assertEquals ( 9 , executeNet ( all ) . all ( ) . size ( ) ) ; 
 + check ( pre + " enabled " , " true " ) ; 
 + 
 + check ( pre + " logger " , " BinAuditLogger " ) ; 
 + config . audit _ logging _ options . logger = " logger " ; 
 + check ( pre + " logger " , " logger " ) ; 
 + 
 + config . audit _ logging _ options . audit _ logs _ dir = " dir " ; 
 + check ( pre + " audit _ logs _ dir " , " dir " ) ; 
 + 
 + check ( pre + " included _ keyspaces " , " " ) ; 
 + config . audit _ logging _ options . included _ keyspaces = " included _ keyspaces " ; 
 + check ( pre + " included _ keyspaces " , " included _ keyspaces " ) ; 
 + 
 + check ( pre + " excluded _ keyspaces " , " " ) ; 
 + config . audit _ logging _ options . excluded _ keyspaces = " excluded _ keyspaces " ; 
 + check ( pre + " excluded _ keyspaces " , " excluded _ keyspaces " ) ; 
 + 
 + check ( pre + " included _ categories " , " " ) ; 
 + config . audit _ logging _ options . included _ categories = " included _ categories " ; 
 + check ( pre + " included _ categories " , " included _ categories " ) ; 
 + 
 + check ( pre + " excluded _ categories " , " " ) ; 
 + config . audit _ logging _ options . excluded _ categories = " excluded _ categories " ; 
 + check ( pre + " excluded _ categories " , " excluded _ categories " ) ; 
 + 
 + check ( pre + " included _ users " , " " ) ; 
 + config . audit _ logging _ options . included _ users = " included _ users " ; 
 + check ( pre + " included _ users " , " included _ users " ) ; 
 + 
 + check ( pre + " excluded _ users " , " " ) ; 
 + config . audit _ logging _ options . excluded _ users = " excluded _ users " ; 
 + check ( pre + " excluded _ users " , " excluded _ users " ) ; 
 + } 
 + 
 + @ Test 
 + public void testTransparentEncryptionOptionsOverride ( ) throws Throwable 
 + { 
 + String pre = " transparent _ data _ encryption _ options _ " ; 
 + check ( pre + " enabled " , " false " ) ; 
 + String all = " SELECT * FROM vts . settings WHERE " + 
 + " name > ' transparent _ data _ encryption _ options ' AND " + 
 + " name < ' transparent _ data _ encryption _ optionsz ' ALLOW FILTERING " ; 
 + 
 + config . transparent _ data _ encryption _ options . enabled = true ; 
 + Assert . assertEquals ( 4 , executeNet ( all ) . all ( ) . size ( ) ) ; 
 + check ( pre + " enabled " , " true " ) ; 
 + 
 + check ( pre + " cipher " , " AES / CBC / PKCS5Padding " ) ; 
 + config . transparent _ data _ encryption _ options . cipher = " cipher " ; 
 + check ( pre + " cipher " , " cipher " ) ; 
 + 
 + check ( pre + " chunk _ length _ kb " , " 64 " ) ; 
 + config . transparent _ data _ encryption _ options . chunk _ length _ kb = 5 ; 
 + check ( pre + " chunk _ length _ kb " , " 5 " ) ; 
 + 
 + check ( pre + " iv _ length " , " 16 " ) ; 
 + config . transparent _ data _ encryption _ options . iv _ length = 7 ; 
 + check ( pre + " iv _ length " , " 7 " ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
