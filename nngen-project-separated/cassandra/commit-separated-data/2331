BLEU SCORE: 0.024675789207681903

TEST MSG: Consider expiry when reconciling otherwise equal cells
GENERATED MSG: Actually remove UnsortedColumns ( CASSANDRA - 6630 followup )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ff2f586 . . 641326e 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 0 - rc3 <nl> + * Consider expiry when reconciling otherwise equal cells ( CASSANDRA - 7403 ) <nl> * Introduce CQL support for stress tool ( CASSANDRA - 6146 ) <nl> * Fix ClassCastException processing expired messages ( CASSANDRA - 7496 ) <nl> * Fix prepared marker for collections inside UDT ( CASSANDRA - 7472 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / AbstractCell . java b / src / java / org / apache / cassandra / db / AbstractCell . java <nl> index 9dad6db . . 82f1989 100644 <nl> - - - a / src / java / org / apache / cassandra / db / AbstractCell . java <nl> + + + b / src / java / org / apache / cassandra / db / AbstractCell . java <nl> @ @ - 120 , 16 + 120 , 12 @ @ public abstract class AbstractCell implements Cell <nl> <nl> public Cell reconcile ( Cell cell ) <nl> { <nl> - / / tombstones take precedence . ( if both are tombstones , then it doesn ' t matter which one we use . ) <nl> - if ( ! isLive ( ) ) <nl> - return timestamp ( ) < cell . timestamp ( ) ? cell : this ; <nl> - if ( ! cell . isLive ( ) ) <nl> - return timestamp ( ) > cell . timestamp ( ) ? this : cell ; <nl> - / / break ties by comparing values . <nl> - if ( timestamp ( ) = = cell . timestamp ( ) ) <nl> - return value ( ) . compareTo ( cell . value ( ) ) < 0 ? cell : this ; <nl> - / / neither is tombstoned and timestamps are different <nl> - return timestamp ( ) < cell . timestamp ( ) ? cell : this ; <nl> + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; <nl> + if ( ts1 ! = ts2 ) <nl> + return ts1 < ts2 ? cell : this ; <nl> + if ( isLive ( ) ! = cell . isLive ( ) ) <nl> + return isLive ( ) ? cell : this ; <nl> + return value ( ) . compareTo ( cell . value ( ) ) < 0 ? cell : this ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / BufferExpiringCell . java b / src / java / org / apache / cassandra / db / BufferExpiringCell . java <nl> index 38d84f4 . . a2b4f19 100644 <nl> - - - a / src / java / org / apache / cassandra / db / BufferExpiringCell . java <nl> + + + b / src / java / org / apache / cassandra / db / BufferExpiringCell . java <nl> @ @ - 142 , 6 + 142 , 28 @ @ public class BufferExpiringCell extends BufferCell implements ExpiringCell <nl> throw new MarshalException ( " The local expiration time should not be negative " ) ; <nl> } <nl> <nl> + public Cell reconcile ( Cell cell ) <nl> + { <nl> + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; <nl> + if ( ts1 ! = ts2 ) <nl> + return ts1 < ts2 ? cell : this ; <nl> + / / we should prefer tombstones <nl> + if ( cell instanceof DeletedCell ) <nl> + return cell ; <nl> + / / however if we ' re both ExpiringCells , we should prefer the one with the longest ttl <nl> + / / ( really in preference _ always _ to the value comparison ) <nl> + int c = value ( ) . compareTo ( cell . value ( ) ) ; <nl> + if ( c ! = 0 ) <nl> + return c < 0 ? cell : this ; <nl> + if ( cell instanceof ExpiringCell ) <nl> + { <nl> + int let1 = localExpirationTime , let2 = cell . getLocalDeletionTime ( ) ; <nl> + if ( let1 < let2 ) <nl> + return cell ; <nl> + } <nl> + return this ; <nl> + } <nl> + <nl> @ Override <nl> public boolean equals ( Cell cell ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / NativeExpiringCell . java b / src / java / org / apache / cassandra / db / NativeExpiringCell . java <nl> index f265511 . . 5648375 100644 <nl> - - - a / src / java / org / apache / cassandra / db / NativeExpiringCell . java <nl> + + + b / src / java / org / apache / cassandra / db / NativeExpiringCell . java <nl> @ @ - 128 , 6 + 128 , 28 @ @ public class NativeExpiringCell extends NativeCell implements ExpiringCell <nl> FBUtilities . updateWithInt ( digest , getTimeToLive ( ) ) ; <nl> } <nl> <nl> + public Cell reconcile ( Cell cell ) <nl> + { <nl> + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; <nl> + if ( ts1 ! = ts2 ) <nl> + return ts1 < ts2 ? cell : this ; <nl> + / / we should prefer tombstones <nl> + if ( cell instanceof DeletedCell ) <nl> + return cell ; <nl> + / / however if we ' re both ExpiringCells , we should prefer the one with the longest ttl <nl> + / / ( really in preference _ always _ to the value comparison ) <nl> + int c = value ( ) . compareTo ( cell . value ( ) ) ; <nl> + if ( c ! = 0 ) <nl> + return c < 0 ? cell : this ; <nl> + if ( cell instanceof ExpiringCell ) <nl> + { <nl> + int let1 = getLocalDeletionTime ( ) , let2 = cell . getLocalDeletionTime ( ) ; <nl> + if ( let1 < let2 ) <nl> + return cell ; <nl> + } <nl> + return this ; <nl> + } <nl> + <nl> public boolean equals ( Cell cell ) <nl> { <nl> return cell instanceof ExpiringCell & & equals ( ( ExpiringCell ) cell ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / CellTest . java b / test / unit / org / apache / cassandra / db / CellTest . java <nl> new file mode 100644 <nl> index 0000000 . . 668bebc <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / CellTest . java <nl> @ @ - 0 , 0 + 1 , 76 @ @ <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . Util ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> + import org . apache . cassandra . utils . memory . NativeAllocator ; <nl> + import org . apache . cassandra . utils . memory . NativePool ; <nl> + <nl> + public class CellTest <nl> + { <nl> + <nl> + private static final OpOrder order = new OpOrder ( ) ; <nl> + private static NativeAllocator allocator = new NativePool ( Integer . MAX _ VALUE , Integer . MAX _ VALUE , 1f , null ) . newAllocator ( ) ; <nl> + <nl> + @ Test <nl> + public void testExpiringCellReconile ( ) <nl> + { <nl> + / / equal <nl> + Assert . assertEquals ( 0 , testExpiring ( " a " , " a " , 1 , 1 , null , null , null , null ) ) ; <nl> + <nl> + / / newer timestamp <nl> + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 2 , 1 , null , null , 1L , null ) ) ; <nl> + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 2 , 1 , null , " b " , 1L , 2 ) ) ; <nl> + <nl> + / / newer TTL <nl> + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 1 , 2 , null , null , null , 1 ) ) ; <nl> + Assert . assertEquals ( 1 , testExpiring ( " a " , " a " , 1 , 2 , null , " b " , null , 1 ) ) ; <nl> + <nl> + / / newer value <nl> + Assert . assertEquals ( - 1 , testExpiring ( " a " , " b " , 2 , 1 , null , " a " , null , null ) ) ; <nl> + Assert . assertEquals ( - 1 , testExpiring ( " a " , " b " , 2 , 1 , null , " a " , null , 2 ) ) ; <nl> + } <nl> + <nl> + private int testExpiring ( String n1 , String v1 , long t1 , int et1 , String n2 , String v2 , Long t2 , Integer et2 ) <nl> + { <nl> + if ( n2 = = null ) <nl> + n2 = n1 ; <nl> + if ( v2 = = null ) <nl> + v2 = v1 ; <nl> + if ( t2 = = null ) <nl> + t2 = t1 ; <nl> + if ( et2 = = null ) <nl> + et2 = et1 ; <nl> + int result = testExpiring ( n1 , v1 , t1 , et1 , false , n2 , v2 , t2 , et2 , false ) ; <nl> + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , false , n2 , v2 , t2 , et2 , true ) ) ; <nl> + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , true , n2 , v2 , t2 , et2 , false ) ) ; <nl> + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , true , n2 , v2 , t2 , et2 , true ) ) ; <nl> + return result ; <nl> + } <nl> + <nl> + private int testExpiring ( String n1 , String v1 , long t1 , int et1 , boolean native1 , String n2 , String v2 , long t2 , int et2 , boolean native2 ) <nl> + { <nl> + Cell c1 = expiring ( n1 , v1 , t1 , et1 , native1 ) ; <nl> + Cell c2 = expiring ( n2 , v2 , t2 , et2 , native2 ) ; <nl> + return reconcile ( c1 , c2 ) ; <nl> + } <nl> + <nl> + int reconcile ( Cell c1 , Cell c2 ) <nl> + { <nl> + if ( c1 . reconcile ( c2 ) = = c1 ) <nl> + return c2 . reconcile ( c1 ) = = c1 ? - 1 : 0 ; <nl> + return c2 . reconcile ( c1 ) = = c2 ? 1 : 0 ; <nl> + } <nl> + <nl> + private Cell expiring ( String name , String value , long timestamp , int expirationTime , boolean nativeCell ) <nl> + { <nl> + ExpiringCell cell = new BufferExpiringCell ( Util . cellname ( name ) , ByteBufferUtil . bytes ( value ) , timestamp , 1 , expirationTime ) ; <nl> + if ( nativeCell ) <nl> + cell = new NativeExpiringCell ( allocator , order . getCurrent ( ) , cell ) ; <nl> + return cell ; <nl> + } <nl> + <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ff2f586 . . 641326e 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 0 - rc3 
 + * Consider expiry when reconciling otherwise equal cells ( CASSANDRA - 7403 ) 
 * Introduce CQL support for stress tool ( CASSANDRA - 6146 ) 
 * Fix ClassCastException processing expired messages ( CASSANDRA - 7496 ) 
 * Fix prepared marker for collections inside UDT ( CASSANDRA - 7472 ) 
 diff - - git a / src / java / org / apache / cassandra / db / AbstractCell . java b / src / java / org / apache / cassandra / db / AbstractCell . java 
 index 9dad6db . . 82f1989 100644 
 - - - a / src / java / org / apache / cassandra / db / AbstractCell . java 
 + + + b / src / java / org / apache / cassandra / db / AbstractCell . java 
 @ @ - 120 , 16 + 120 , 12 @ @ public abstract class AbstractCell implements Cell 
 
 public Cell reconcile ( Cell cell ) 
 { 
 - / / tombstones take precedence . ( if both are tombstones , then it doesn ' t matter which one we use . ) 
 - if ( ! isLive ( ) ) 
 - return timestamp ( ) < cell . timestamp ( ) ? cell : this ; 
 - if ( ! cell . isLive ( ) ) 
 - return timestamp ( ) > cell . timestamp ( ) ? this : cell ; 
 - / / break ties by comparing values . 
 - if ( timestamp ( ) = = cell . timestamp ( ) ) 
 - return value ( ) . compareTo ( cell . value ( ) ) < 0 ? cell : this ; 
 - / / neither is tombstoned and timestamps are different 
 - return timestamp ( ) < cell . timestamp ( ) ? cell : this ; 
 + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; 
 + if ( ts1 ! = ts2 ) 
 + return ts1 < ts2 ? cell : this ; 
 + if ( isLive ( ) ! = cell . isLive ( ) ) 
 + return isLive ( ) ? cell : this ; 
 + return value ( ) . compareTo ( cell . value ( ) ) < 0 ? cell : this ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / BufferExpiringCell . java b / src / java / org / apache / cassandra / db / BufferExpiringCell . java 
 index 38d84f4 . . a2b4f19 100644 
 - - - a / src / java / org / apache / cassandra / db / BufferExpiringCell . java 
 + + + b / src / java / org / apache / cassandra / db / BufferExpiringCell . java 
 @ @ - 142 , 6 + 142 , 28 @ @ public class BufferExpiringCell extends BufferCell implements ExpiringCell 
 throw new MarshalException ( " The local expiration time should not be negative " ) ; 
 } 
 
 + public Cell reconcile ( Cell cell ) 
 + { 
 + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; 
 + if ( ts1 ! = ts2 ) 
 + return ts1 < ts2 ? cell : this ; 
 + / / we should prefer tombstones 
 + if ( cell instanceof DeletedCell ) 
 + return cell ; 
 + / / however if we ' re both ExpiringCells , we should prefer the one with the longest ttl 
 + / / ( really in preference _ always _ to the value comparison ) 
 + int c = value ( ) . compareTo ( cell . value ( ) ) ; 
 + if ( c ! = 0 ) 
 + return c < 0 ? cell : this ; 
 + if ( cell instanceof ExpiringCell ) 
 + { 
 + int let1 = localExpirationTime , let2 = cell . getLocalDeletionTime ( ) ; 
 + if ( let1 < let2 ) 
 + return cell ; 
 + } 
 + return this ; 
 + } 
 + 
 @ Override 
 public boolean equals ( Cell cell ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / NativeExpiringCell . java b / src / java / org / apache / cassandra / db / NativeExpiringCell . java 
 index f265511 . . 5648375 100644 
 - - - a / src / java / org / apache / cassandra / db / NativeExpiringCell . java 
 + + + b / src / java / org / apache / cassandra / db / NativeExpiringCell . java 
 @ @ - 128 , 6 + 128 , 28 @ @ public class NativeExpiringCell extends NativeCell implements ExpiringCell 
 FBUtilities . updateWithInt ( digest , getTimeToLive ( ) ) ; 
 } 
 
 + public Cell reconcile ( Cell cell ) 
 + { 
 + long ts1 = timestamp ( ) , ts2 = cell . timestamp ( ) ; 
 + if ( ts1 ! = ts2 ) 
 + return ts1 < ts2 ? cell : this ; 
 + / / we should prefer tombstones 
 + if ( cell instanceof DeletedCell ) 
 + return cell ; 
 + / / however if we ' re both ExpiringCells , we should prefer the one with the longest ttl 
 + / / ( really in preference _ always _ to the value comparison ) 
 + int c = value ( ) . compareTo ( cell . value ( ) ) ; 
 + if ( c ! = 0 ) 
 + return c < 0 ? cell : this ; 
 + if ( cell instanceof ExpiringCell ) 
 + { 
 + int let1 = getLocalDeletionTime ( ) , let2 = cell . getLocalDeletionTime ( ) ; 
 + if ( let1 < let2 ) 
 + return cell ; 
 + } 
 + return this ; 
 + } 
 + 
 public boolean equals ( Cell cell ) 
 { 
 return cell instanceof ExpiringCell & & equals ( ( ExpiringCell ) cell ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / CellTest . java b / test / unit / org / apache / cassandra / db / CellTest . java 
 new file mode 100644 
 index 0000000 . . 668bebc 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / CellTest . java 
 @ @ - 0 , 0 + 1 , 76 @ @ 
 + package org . apache . cassandra . db ; 
 + 
 + import org . junit . Test ; 
 + 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . Util ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . concurrent . OpOrder ; 
 + import org . apache . cassandra . utils . memory . NativeAllocator ; 
 + import org . apache . cassandra . utils . memory . NativePool ; 
 + 
 + public class CellTest 
 + { 
 + 
 + private static final OpOrder order = new OpOrder ( ) ; 
 + private static NativeAllocator allocator = new NativePool ( Integer . MAX _ VALUE , Integer . MAX _ VALUE , 1f , null ) . newAllocator ( ) ; 
 + 
 + @ Test 
 + public void testExpiringCellReconile ( ) 
 + { 
 + / / equal 
 + Assert . assertEquals ( 0 , testExpiring ( " a " , " a " , 1 , 1 , null , null , null , null ) ) ; 
 + 
 + / / newer timestamp 
 + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 2 , 1 , null , null , 1L , null ) ) ; 
 + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 2 , 1 , null , " b " , 1L , 2 ) ) ; 
 + 
 + / / newer TTL 
 + Assert . assertEquals ( - 1 , testExpiring ( " a " , " a " , 1 , 2 , null , null , null , 1 ) ) ; 
 + Assert . assertEquals ( 1 , testExpiring ( " a " , " a " , 1 , 2 , null , " b " , null , 1 ) ) ; 
 + 
 + / / newer value 
 + Assert . assertEquals ( - 1 , testExpiring ( " a " , " b " , 2 , 1 , null , " a " , null , null ) ) ; 
 + Assert . assertEquals ( - 1 , testExpiring ( " a " , " b " , 2 , 1 , null , " a " , null , 2 ) ) ; 
 + } 
 + 
 + private int testExpiring ( String n1 , String v1 , long t1 , int et1 , String n2 , String v2 , Long t2 , Integer et2 ) 
 + { 
 + if ( n2 = = null ) 
 + n2 = n1 ; 
 + if ( v2 = = null ) 
 + v2 = v1 ; 
 + if ( t2 = = null ) 
 + t2 = t1 ; 
 + if ( et2 = = null ) 
 + et2 = et1 ; 
 + int result = testExpiring ( n1 , v1 , t1 , et1 , false , n2 , v2 , t2 , et2 , false ) ; 
 + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , false , n2 , v2 , t2 , et2 , true ) ) ; 
 + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , true , n2 , v2 , t2 , et2 , false ) ) ; 
 + Assert . assertEquals ( result , testExpiring ( n1 , v1 , t1 , et1 , true , n2 , v2 , t2 , et2 , true ) ) ; 
 + return result ; 
 + } 
 + 
 + private int testExpiring ( String n1 , String v1 , long t1 , int et1 , boolean native1 , String n2 , String v2 , long t2 , int et2 , boolean native2 ) 
 + { 
 + Cell c1 = expiring ( n1 , v1 , t1 , et1 , native1 ) ; 
 + Cell c2 = expiring ( n2 , v2 , t2 , et2 , native2 ) ; 
 + return reconcile ( c1 , c2 ) ; 
 + } 
 + 
 + int reconcile ( Cell c1 , Cell c2 ) 
 + { 
 + if ( c1 . reconcile ( c2 ) = = c1 ) 
 + return c2 . reconcile ( c1 ) = = c1 ? - 1 : 0 ; 
 + return c2 . reconcile ( c1 ) = = c2 ? 1 : 0 ; 
 + } 
 + 
 + private Cell expiring ( String name , String value , long timestamp , int expirationTime , boolean nativeCell ) 
 + { 
 + ExpiringCell cell = new BufferExpiringCell ( Util . cellname ( name ) , ByteBufferUtil . bytes ( value ) , timestamp , 1 , expirationTime ) ; 
 + if ( nativeCell ) 
 + cell = new NativeExpiringCell ( allocator , order . getCurrent ( ) , cell ) ; 
 + return cell ; 
 + } 
 + 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
