BLEU SCORE: 0.008530065048427224

TEST MSG: In JVM dtests need to clean up after instance shutdown
GENERATED MSG: make estimation of pendingtasks for CompactionManager sane . patch by jbellis ; reviewed by eevans for CASSANDRA - 599

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java b / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java <nl> index 4c6763c . . c4abab8 100644 <nl> - - - a / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java <nl> + + + b / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java <nl> @ @ - 30 , 6 + 30 , 8 @ @ public class NamedThreadFactory implements ThreadFactory <nl> { <nl> protected final String id ; <nl> private final int priority ; <nl> + private final ClassLoader contextClassLoader ; <nl> + private final ThreadGroup threadGroup ; <nl> protected final AtomicInteger n = new AtomicInteger ( 1 ) ; <nl> <nl> public NamedThreadFactory ( String id ) <nl> @ @ - 39 , 17 + 41 , 26 @ @ public class NamedThreadFactory implements ThreadFactory <nl> <nl> public NamedThreadFactory ( String id , int priority ) <nl> { <nl> + this ( id , priority , null , null ) ; <nl> + } <nl> <nl> + public NamedThreadFactory ( String id , int priority , ClassLoader contextClassLoader , ThreadGroup threadGroup ) <nl> + { <nl> this . id = id ; <nl> this . priority = priority ; <nl> + this . contextClassLoader = contextClassLoader ; <nl> + this . threadGroup = threadGroup ; <nl> } <nl> <nl> public Thread newThread ( Runnable runnable ) <nl> { <nl> - String name = id + " : " + n . getAndIncrement ( ) ; <nl> - Thread thread = new Thread ( runnable , name ) ; <nl> - thread . setPriority ( priority ) ; <nl> + String name = id + ' : ' + n . getAndIncrement ( ) ; <nl> + Thread thread = new Thread ( threadGroup , runnable , name ) ; <nl> thread . setDaemon ( true ) ; <nl> + thread . setPriority ( priority ) ; <nl> + if ( contextClassLoader ! = null ) <nl> + thread . setContextClassLoader ( contextClassLoader ) ; <nl> return thread ; <nl> } <nl> + <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> index 8492fed . . 14a8d71 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java <nl> @ @ - 378 , 17 + 378 , 41 @ @ public class FBUtilities <nl> <nl> public static < T > List < T > waitOnFutures ( Iterable < ? extends Future < ? extends T > > futures ) <nl> { <nl> + return waitOnFutures ( futures , - 1 , null ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Block for a collection of futures , with optional timeout . <nl> + * <nl> + * @ param futures <nl> + * @ param timeout The number of units to wait in total . If this value is less than or equal to zero , <nl> + * no tiemout value will be passed to { @ link Future # get ( ) } . <nl> + * @ param units The units of timeout . <nl> + * / <nl> + public static < T > List < T > waitOnFutures ( Iterable < ? extends Future < ? extends T > > futures , long timeout , TimeUnit units ) <nl> + { <nl> + long endNanos = 0 ; <nl> + if ( timeout > 0 ) <nl> + endNanos = System . nanoTime ( ) + units . toNanos ( timeout ) ; <nl> List < T > results = new ArrayList < > ( ) ; <nl> Throwable fail = null ; <nl> for ( Future < ? extends T > f : futures ) <nl> { <nl> try <nl> { <nl> - results . add ( f . get ( ) ) ; <nl> + if ( endNanos = = 0 ) <nl> + { <nl> + results . add ( f . get ( ) ) ; <nl> + } <nl> + else <nl> + { <nl> + long waitFor = Math . max ( 1 , endNanos - System . nanoTime ( ) ) ; <nl> + results . add ( f . get ( waitFor , TimeUnit . NANOSECONDS ) ) ; <nl> + } <nl> } <nl> - catch ( InterruptedException | ExecutionException e ) <nl> + catch ( Throwable t ) <nl> { <nl> - fail = Throwables . merge ( fail , e ) ; <nl> + fail = Throwables . merge ( fail , t ) ; <nl> } <nl> } <nl> Throwables . maybeFail ( fail ) ; <nl> diff - - git a / src / java / org / apache / cassandra / utils / memory / MemtablePool . java b / src / java / org / apache / cassandra / utils / memory / MemtablePool . java <nl> index 7663103 . . b4efaa6 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / memory / MemtablePool . java <nl> + + + b / src / java / org / apache / cassandra / utils / memory / MemtablePool . java <nl> @ @ - 60 , 7 + 60 , 7 @ @ public abstract class MemtablePool <nl> } <nl> <nl> public abstract boolean needToCopyOnHeap ( ) ; <nl> - <nl> + <nl> @ VisibleForTesting <nl> public void shutdown ( ) throws InterruptedException <nl> { <nl> diff - - git a / test / conf / logback - dtest . xml b / test / conf / logback - dtest . xml <nl> index b8019f6 . . df8cac8 100644 <nl> - - - a / test / conf / logback - dtest . xml <nl> + + + b / test / conf / logback - dtest . xml <nl> @ @ - 23 , 9 + 23 , 6 @ @ <nl> < ! - - Shutdown hook ensures that async appender flushes - - > <nl> < shutdownHook class = " ch . qos . logback . core . hook . DelayingShutdownHook " / > <nl> <nl> - < ! - - Status listener is used to wrap stdout / stderr and tee to log file - - > <nl> - < statusListener class = " org . apache . cassandra . LogbackStatusListener " / > <nl> - <nl> < appender name = " FILE " class = " ch . qos . logback . core . rolling . RollingFileAppender " > <nl> <nl> < file > . / build / test / logs / $ { cassandra . testtag } / TEST - $ { suitename } . log < / file > <nl> @ @ - 45 , 35 + 42 , 45 @ @ <nl> < / encoder > <nl> < / appender > <nl> <nl> - < appender name = " STDOUT " target = " System . out " class = " org . apache . cassandra . ConsoleAppender " > <nl> + < appender name = " ASYNCFILE " class = " ch . qos . logback . classic . AsyncAppender " > <nl> + < discardingThreshold > 0 < / discardingThreshold > <nl> + < maxFlushTime > 0 < / maxFlushTime > <nl> + < queueSize > 1024 < / queueSize > <nl> + < appender - ref ref = " FILE " / > <nl> + < / appender > <nl> + <nl> + < appender name = " STDERR " target = " System . err " class = " ch . qos . logback . core . ConsoleAppender " > <nl> < encoder > <nl> - < pattern > % - 5level [ % thread ] $ { instance _ id } % date { ISO8601 } % F : % L - % msg % n < / pattern > <nl> + < pattern > % - 5level % date { HH : mm : ss , SSS } % msg % n < / pattern > <nl> < / encoder > <nl> < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > <nl> - < level > DEBUG < / level > <nl> + < level > WARN < / level > <nl> < / filter > <nl> < / appender > <nl> <nl> - < appender name = " TEE " class = " org . apache . cassandra . TeeingAppender " > <nl> - < appender - ref ref = " FILE " / > <nl> - < appender - ref ref = " STDOUT " / > <nl> + < appender name = " STDOUT " target = " System . out " class = " ch . qos . logback . core . ConsoleAppender " > <nl> + < encoder > <nl> + < pattern > % - 5level % date { HH : mm : ss , SSS } % msg % n < / pattern > <nl> + < / encoder > <nl> + < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > <nl> + < level > WARN < / level > <nl> + < / filter > <nl> < / appender > <nl> <nl> - < logger name = " org . apache . hadoop " level = " WARN " / > <nl> - <nl> - < logger name = " org . apache . cassandra . db . monitoring " level = " DEBUG " / > <nl> - <nl> - < ! - - Do not change the name of this appender . LogbackStatusListener uses the thread name <nl> - tied to the appender name to know when to write to real stdout / stderr vs forwarding to logback - - > <nl> - < appender name = " ASYNC " class = " ch . qos . logback . classic . AsyncAppender " > <nl> - < discardingThreshold > 0 < / discardingThreshold > <nl> - < maxFlushTime > 0 < / maxFlushTime > <nl> - < queueSize > 1024 < / queueSize > <nl> - < appender - ref ref = " TEE " / > <nl> - < includeCallerData > true < / includeCallerData > <nl> + < appender name = " STDOUT " target = " System . out " class = " ch . qos . logback . core . ConsoleAppender " > <nl> + < encoder > <nl> + < pattern > % - 5level [ % thread ] $ { instance _ id } % date { ISO8601 } % F : % L - % msg % n < / pattern > <nl> + < / encoder > <nl> + < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > <nl> + < level > DEBUG < / level > <nl> + < / filter > <nl> < / appender > <nl> <nl> + < logger name = " org . apache . hadoop " level = " WARN " / > <nl> + <nl> < root level = " DEBUG " > <nl> - < appender - ref ref = " ASYNC " / > <nl> + < appender - ref ref = " ASYNCFILE " / > <nl> + < appender - ref ref = " STDERR " / > <nl> + < appender - ref ref = " STDOUT " / > <nl> < / root > <nl> < / configuration > <nl> diff - - git a / test / distributed / org / apache / cassandra / distributed / Instance . java b / test / distributed / org / apache / cassandra / distributed / Instance . java <nl> index 37be73c . . c8977d7 100644 <nl> - - - a / test / distributed / org / apache / cassandra / distributed / Instance . java <nl> + + + b / test / distributed / org / apache / cassandra / distributed / Instance . java <nl> @ @ - 30 , 6 + 30 , 8 @ @ import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . UUID ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Future ; <nl> import java . util . function . BiConsumer ; <nl> import java . util . function . Function ; <nl> <nl> @ @ - 83 , 7 + 85 , 7 @ @ public class Instance extends InvokableInstance <nl> <nl> public Instance ( InstanceConfig config , ClassLoader classLoader ) <nl> { <nl> - super ( classLoader ) ; <nl> + super ( " node " + config . num , classLoader ) ; <nl> this . config = config ; <nl> } <nl> <nl> @ @ - 332 , 9 + 334 , 9 @ @ public class Instance extends InvokableInstance <nl> <nl> void shutdown ( ) <nl> { <nl> - runOnInstance ( ( ) - > { <nl> + acceptsOnInstance ( ( ExecutorService executor ) - > { <nl> Throwable error = null ; <nl> - error = runAndMergeThrowable ( error , <nl> + error = parallelRun ( error , executor , <nl> Gossiper . instance : : stop , <nl> CompactionManager . instance : : forceShutdown , <nl> CommitLog . instance : : shutdownBlocking , <nl> @ @ - 345 , 32 + 347 , 54 @ @ public class Instance extends InvokableInstance <nl> StorageService . instance : : shutdownBGMonitor , <nl> Ref : : shutdownReferenceReaper , <nl> Memtable . MEMORY _ POOL : : shutdown , <nl> - StageManager : : shutdownAndWait , <nl> - MessagingService . instance ( ) : : shutdown , <nl> - SharedExecutorPool . SHARED : : shutdown , <nl> ScheduledExecutors : : shutdownAndWait , <nl> - SSTableReader : : shutdownBlocking ) ; <nl> - <nl> + SSTableReader : : shutdownBlocking <nl> + ) ; <nl> + error = parallelRun ( error , executor , <nl> + MessagingService . instance ( ) : : shutdown <nl> + ) ; <nl> + error = parallelRun ( error , executor , <nl> + StageManager : : shutdownAndWait , <nl> + SharedExecutorPool . SHARED : : shutdown <nl> + ) ; <nl> LoggerContext loggerContext = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; <nl> loggerContext . stop ( ) ; <nl> Throwables . maybeFail ( error ) ; <nl> - } ) ; <nl> + } ) . accept ( isolatedExecutor ) ; <nl> + super . shutdown ( ) ; <nl> } <nl> <nl> - private static Throwable runAndMergeThrowable ( Throwable existing , ThrowingRunnable . . . runnables ) <nl> + private static Throwable parallelRun ( Throwable accumulate , ExecutorService runOn , ThrowingRunnable . . . runnables ) <nl> { <nl> + List < Future < Throwable > > results = new ArrayList < > ( ) ; <nl> for ( ThrowingRunnable runnable : runnables ) <nl> { <nl> + results . add ( runOn . submit ( ( ) - > { <nl> + try <nl> + { <nl> + runnable . run ( ) ; <nl> + return null ; <nl> + } <nl> + catch ( Throwable t ) <nl> + { <nl> + return t ; <nl> + } <nl> + } ) ) ; <nl> + } <nl> + for ( Future < Throwable > future : results ) <nl> + { <nl> try <nl> { <nl> - runnable . run ( ) ; <nl> + Throwable t = future . get ( ) ; <nl> + if ( t ! = null ) <nl> + throw t ; <nl> } <nl> catch ( Throwable t ) <nl> { <nl> - existing = Throwables . merge ( existing , t ) ; <nl> + accumulate = Throwables . merge ( accumulate , t ) ; <nl> } <nl> } <nl> - return existing ; <nl> + return accumulate ; <nl> } <nl> <nl> public static interface ThrowingRunnable <nl> diff - - git a / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java b / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java <nl> index 036f6b1 . . 9958fd3 100644 <nl> - - - a / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java <nl> + + + b / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java <nl> @ @ - 98 , 4 + 98 , 12 @ @ public class InstanceClassLoader extends URLClassLoader <nl> return id - > new InstanceClassLoader ( id , urls , commonClassNames : : contains , contextClassLoader ) ; <nl> } <nl> <nl> + / * * <nl> + * @ return true iff this class was loaded by an InstanceClassLoader , and as such is used by a dtest node <nl> + * / <nl> + public static boolean wasLoadedByAnInstanceClassLoader ( Class < ? > clazz ) <nl> + { <nl> + return clazz . getClassLoader ( ) . getClass ( ) . getName ( ) . equals ( InstanceClassLoader . class . getName ( ) ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java b / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java <nl> index f646ae1 . . 9fb543d 100644 <nl> - - - a / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java <nl> + + + b / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . distributed ; <nl> <nl> import java . io . ByteArrayInputStream ; <nl> import java . io . ByteArrayOutputStream ; <nl> + import java . io . Closeable ; <nl> import java . io . IOException ; <nl> import java . io . ObjectInputStream ; <nl> import java . io . ObjectOutputStream ; <nl> @ @ - 27 , 18 + 28 , 26 @ @ import java . io . Serializable ; <nl> import java . lang . reflect . InvocationTargetException ; <nl> import java . lang . reflect . Method ; <nl> import java . util . concurrent . Callable ; <nl> + import java . util . concurrent . ExecutionException ; <nl> + import java . util . concurrent . ExecutorService ; <nl> + import java . util . concurrent . Executors ; <nl> import java . util . function . BiConsumer ; <nl> import java . util . function . BiFunction ; <nl> import java . util . function . Consumer ; <nl> import java . util . function . Function ; <nl> <nl> + import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> + import org . apache . cassandra . utils . Throwables ; <nl> + <nl> public abstract class InvokableInstance <nl> { <nl> + protected final ExecutorService isolatedExecutor ; <nl> private final ClassLoader classLoader ; <nl> private final Method deserializeOnInstance ; <nl> <nl> - public InvokableInstance ( ClassLoader classLoader ) <nl> + public InvokableInstance ( String name , ClassLoader classLoader ) <nl> { <nl> + this . isolatedExecutor = Executors . newCachedThreadPool ( new NamedThreadFactory ( name , Thread . NORM _ PRIORITY , classLoader , new ThreadGroup ( name ) ) ) ; <nl> this . classLoader = classLoader ; <nl> try <nl> { <nl> @ @ - 50 , 31 + 59 , 34 @ @ public abstract class InvokableInstance <nl> } <nl> } <nl> <nl> - public interface SerializableCallable < T > extends Callable < T > , Serializable { public T call ( ) ; } <nl> - public < T > SerializableCallable < T > callsOnInstance ( SerializableCallable < T > call ) { return ( SerializableCallable < T > ) transferOneObject ( call ) ; } <nl> + public interface CallableNoExcept < T > extends Callable < T > { public T call ( ) ; } <nl> + public interface SerializableCallable < T > extends CallableNoExcept < T > , Serializable { } <nl> + public < T > CallableNoExcept < T > callsOnInstance ( SerializableCallable < T > call ) { return invokesOnExecutor ( ( SerializableCallable < T > ) transferOneObject ( call ) , isolatedExecutor ) ; } <nl> public < T > T callOnInstance ( SerializableCallable < T > call ) { return callsOnInstance ( call ) . call ( ) ; } <nl> <nl> public interface SerializableRunnable extends Runnable , Serializable { } <nl> - public SerializableRunnable runsOnInstance ( SerializableRunnable run ) { return ( SerializableRunnable ) transferOneObject ( run ) ; } <nl> + public Runnable runsOnInstance ( SerializableRunnable run ) { return invokesOnExecutor ( ( SerializableRunnable ) transferOneObject ( run ) , isolatedExecutor ) ; } <nl> public void runOnInstance ( SerializableRunnable run ) { runsOnInstance ( run ) . run ( ) ; } <nl> <nl> public interface SerializableConsumer < T > extends Consumer < T > , Serializable { } <nl> - public < T > SerializableConsumer < T > acceptsOnInstance ( SerializableConsumer < T > consumer ) { return ( SerializableConsumer < T > ) transferOneObject ( consumer ) ; } <nl> + public < T > Consumer < T > acceptsOnInstance ( SerializableConsumer < T > consumer ) { return invokesOnExecutor ( ( SerializableConsumer < T > ) transferOneObject ( consumer ) , isolatedExecutor ) ; } <nl> <nl> public interface SerializableBiConsumer < T1 , T2 > extends BiConsumer < T1 , T2 > , Serializable { } <nl> - public < T1 , T2 > SerializableBiConsumer < T1 , T2 > acceptsOnInstance ( SerializableBiConsumer < T1 , T2 > consumer ) { return ( SerializableBiConsumer < T1 , T2 > ) transferOneObject ( consumer ) ; } <nl> + public < T1 , T2 > BiConsumer < T1 , T2 > acceptsOnInstance ( SerializableBiConsumer < T1 , T2 > consumer ) { return invokesOnExecutor ( ( SerializableBiConsumer < T1 , T2 > ) transferOneObject ( consumer ) , isolatedExecutor ) ; } <nl> <nl> public interface SerializableFunction < I , O > extends Function < I , O > , Serializable { } <nl> - public < I , O > SerializableFunction < I , O > appliesOnInstance ( SerializableFunction < I , O > f ) { return ( SerializableFunction < I , O > ) transferOneObject ( f ) ; } <nl> + public < I , O > Function < I , O > appliesOnInstance ( SerializableFunction < I , O > f ) { return invokesOnExecutor ( ( SerializableFunction < I , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } <nl> <nl> public interface SerializableBiFunction < I1 , I2 , O > extends BiFunction < I1 , I2 , O > , Serializable { } <nl> - public < I1 , I2 , O > SerializableBiFunction < I1 , I2 , O > appliesOnInstance ( SerializableBiFunction < I1 , I2 , O > f ) { return ( SerializableBiFunction < I1 , I2 , O > ) transferOneObject ( f ) ; } <nl> + public < I1 , I2 , O > BiFunction < I1 , I2 , O > appliesOnInstance ( SerializableBiFunction < I1 , I2 , O > f ) { return invokesOnExecutor ( ( SerializableBiFunction < I1 , I2 , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } <nl> <nl> - public interface SerializableTriFunction < I1 , I2 , I3 , O > extends Serializable <nl> + public interface TriFunction < I1 , I2 , I3 , O > <nl> { <nl> O apply ( I1 i1 , I2 i2 , I3 i3 ) ; <nl> } <nl> - public < I1 , I2 , I3 , O > SerializableTriFunction < I1 , I2 , I3 , O > appliesOnInstance ( SerializableTriFunction < I1 , I2 , I3 , O > f ) { return ( SerializableTriFunction < I1 , I2 , I3 , O > ) transferOneObject ( f ) ; } <nl> + public interface SerializableTriFunction < I1 , I2 , I3 , O > extends Serializable , TriFunction < I1 , I2 , I3 , O > { } <nl> + <nl> + public < I1 , I2 , I3 , O > TriFunction < I1 , I2 , I3 , O > appliesOnInstance ( SerializableTriFunction < I1 , I2 , I3 , O > f ) { return invokesOnExecutor ( ( SerializableTriFunction < I1 , I2 , I3 , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } <nl> <nl> public interface InstanceFunction < I , O > extends SerializableBiFunction < Instance , I , O > { } <nl> <nl> @ @ - 130 , 4 + 142 , 72 @ @ public abstract class InvokableInstance <nl> } <nl> } <nl> <nl> + private static < V > CallableNoExcept < V > invokesOnExecutor ( SerializableCallable < V > callable , ExecutorService invokeOn ) <nl> + { <nl> + return ( ) - > { <nl> + try <nl> + { <nl> + return invokeOn . submit ( callable ) . get ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + Throwables . maybeFail ( e . getCause ( ) ) ; <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + private static Runnable invokesOnExecutor ( SerializableRunnable runnable , ExecutorService invokeOn ) <nl> + { <nl> + return ( ) - > { <nl> + try <nl> + { <nl> + invokeOn . submit ( runnable ) . get ( ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + Throwables . maybeFail ( e . getCause ( ) ) ; <nl> + throw new AssertionError ( ) ; <nl> + } <nl> + } ; <nl> + } <nl> + <nl> + private static < A > Consumer < A > invokesOnExecutor ( SerializableConsumer < A > consumer , ExecutorService invokeOn ) <nl> + { <nl> + return ( a ) - > invokesOnExecutor ( ( ) - > consumer . accept ( a ) , invokeOn ) . run ( ) ; <nl> + } <nl> + <nl> + private static < A , B > BiConsumer < A , B > invokesOnExecutor ( SerializableBiConsumer < A , B > consumer , ExecutorService invokeOn ) <nl> + { <nl> + return ( a , b ) - > invokesOnExecutor ( ( ) - > consumer . accept ( a , b ) , invokeOn ) . run ( ) ; <nl> + } <nl> + <nl> + private static < A , B > Function < A , B > invokesOnExecutor ( SerializableFunction < A , B > f , ExecutorService invokeOn ) <nl> + { <nl> + return ( a ) - > invokesOnExecutor ( ( ) - > f . apply ( a ) , invokeOn ) . call ( ) ; <nl> + } <nl> + <nl> + private static < A , B , C > BiFunction < A , B , C > invokesOnExecutor ( SerializableBiFunction < A , B , C > f , ExecutorService invokeOn ) <nl> + { <nl> + return ( a , b ) - > invokesOnExecutor ( ( ) - > f . apply ( a , b ) , invokeOn ) . call ( ) ; <nl> + } <nl> + <nl> + private static < A , B , C , D > SerializableTriFunction < A , B , C , D > invokesOnExecutor ( SerializableTriFunction < A , B , C , D > f , ExecutorService invokeOn ) <nl> + { <nl> + return ( a , b , c ) - > invokesOnExecutor ( ( ) - > f . apply ( a , b , c ) , invokeOn ) . call ( ) ; <nl> + } <nl> + <nl> + void shutdown ( ) <nl> + { <nl> + isolatedExecutor . shutdownNow ( ) ; <nl> + } <nl> + <nl> } <nl> diff - - git a / test / distributed / org / apache / cassandra / distributed / TestCluster . java b / test / distributed / org / apache / cassandra / distributed / TestCluster . java <nl> index 82b775a . . 2450306 100644 <nl> - - - a / test / distributed / org / apache / cassandra / distributed / TestCluster . java <nl> + + + b / test / distributed / org / apache / cassandra / distributed / TestCluster . java <nl> @ @ - 31 , 24 + 31 , 19 @ @ import java . util . HashMap ; <nl> import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> - import java . util . concurrent . ExecutionException ; <nl> - import java . util . concurrent . ExecutorService ; <nl> - import java . util . concurrent . Executors ; <nl> import java . util . concurrent . Future ; <nl> import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . locks . LockSupport ; <nl> - import java . util . concurrent . TimeoutException ; <nl> import java . util . function . IntFunction ; <nl> import java . util . stream . Collectors ; <nl> import java . util . stream . Stream ; <nl> <nl> import com . google . common . collect . Sets ; <nl> <nl> - import io . netty . util . concurrent . FastThreadLocal ; <nl> - import io . netty . util . concurrent . FastThreadLocalThread ; <nl> - import io . netty . util . internal . InternalThreadLocalMap ; <nl> - import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> <nl> + import org . apache . cassandra . concurrent . NamedThreadFactory ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> @ @ - 56 , 7 + 51 , 6 @ @ import org . apache . cassandra . io . util . FileUtils ; <nl> import org . apache . cassandra . locator . InetAddressAndPort ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> - import org . apache . cassandra . utils . Throwables ; <nl> <nl> / * * <nl> * TestCluster creates , initializes and manages Cassandra instances ( { @ link Instance } . <nl> @ @ - 84 , 7 + 78 , 10 @ @ import org . apache . cassandra . utils . Throwables ; <nl> * / <nl> public class TestCluster implements AutoCloseable <nl> { <nl> - private final ExecutorService exec = Executors . newCachedThreadPool ( new NamedThreadFactory ( " cluster - async - tasks " ) ) ; <nl> + / / WARNING : we have this logger not ( necessarily ) for logging , but <nl> + / / to ensure we have instantiated the main classloader ' s LoggerFactory ( and any LogbackStatusListener ) <nl> + / / before we instantiate any for a new instance <nl> + private static final Logger logger = LoggerFactory . getLogger ( TestCluster . class ) ; <nl> <nl> private final File root ; <nl> private final List < Instance > instances ; <nl> @ @ - 104 , 7 + 101 , 7 @ @ public class TestCluster implements AutoCloseable <nl> void launch ( ) <nl> { <nl> FBUtilities . waitOnFutures ( instances . stream ( ) <nl> - . map ( i - > exec . submit ( ( ) - > i . launch ( this ) ) ) <nl> + . map ( i - > i . isolatedExecutor . submit ( ( ) - > i . launch ( this ) ) ) <nl> . collect ( Collectors . toList ( ) ) <nl> ) ; <nl> for ( Instance instance : instances ) <nl> @ @ - 247 , 37 + 244 , 17 @ @ public class TestCluster implements AutoCloseable <nl> } <nl> <nl> @ Override <nl> - public void close ( ) throws InterruptedException , TimeoutException , ExecutionException <nl> + public void close ( ) <nl> { <nl> List < Future < ? > > futures = instances . stream ( ) <nl> - . map ( i - > exec . submit ( i : : shutdown ) ) <nl> + . map ( i - > i . isolatedExecutor . submit ( i : : shutdown ) ) <nl> . collect ( Collectors . toList ( ) ) ; <nl> <nl> / / Make sure to only delete directory when threads are stopped <nl> - Future combined = exec . submit ( ( ) - > { <nl> - FBUtilities . waitOnFutures ( futures ) ; <nl> - FileUtils . deleteRecursive ( root ) ; <nl> - } ) ; <nl> - <nl> - combined . get ( 60 , TimeUnit . SECONDS ) ; <nl> - <nl> - exec . shutdownNow ( ) ; <nl> - exec . awaitTermination ( 10 , TimeUnit . SECONDS ) ; <nl> - <nl> - / / withThreadLeakCheck ( futures ) ; <nl> - Set < Thread > threadSet = Thread . getAllStackTraces ( ) . keySet ( ) ; <nl> - for ( Thread thread : threadSet ) <nl> - { <nl> - if ( thread instanceof FastThreadLocalThread ) <nl> - ( ( FastThreadLocalThread ) thread ) . setThreadLocalMap ( null ) ; <nl> - } <nl> - <nl> - InternalThreadLocalMap . remove ( ) ; <nl> - InternalThreadLocalMap . destroy ( ) ; <nl> - <nl> - FastThreadLocal . removeAll ( ) ; <nl> - FastThreadLocal . destroy ( ) ; <nl> + FBUtilities . waitOnFutures ( futures , 60 , TimeUnit . SECONDS ) ; <nl> + FileUtils . deleteRecursive ( root ) ; <nl> <nl> + / / withThreadLeakCheck ( futures ) ; <nl> System . gc ( ) ; <nl> } <nl> <nl> @ @ - 299 , 26 + 276 , 5 @ @ public class TestCluster implements AutoCloseable <nl> } <nl> } <nl> <nl> - public void runAndWait ( Instance . ThrowingRunnable runnable ) <nl> - { <nl> - try <nl> - { <nl> - exec . submit ( ( ) - > { <nl> - try <nl> - { <nl> - runnable . run ( ) ; <nl> - } <nl> - catch ( Throwable throwable ) <nl> - { <nl> - Throwables . maybeFail ( throwable ) ; <nl> - } <nl> - } ) . get ( ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> - Throwables . maybeFail ( e . getCause ( ) ) ; <nl> - } <nl> - } <nl> - <nl> } <nl>
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 06b6ca7 . . 30fdbf7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 559 , 7 + 559 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> public void addSSTable ( SSTableReader sstable ) <nl> { <nl> ssTables _ . add ( sstable ) ; <nl> - CompactionManager . instance . submitMinor ( this ) ; <nl> + CompactionManager . instance . submitMinorIfNeeded ( this ) ; <nl> } <nl> <nl> / * <nl> diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> index 7584e96 . . 9f71364 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CompactionManager . java <nl> + + + b / src / java / org / apache / cassandra / db / CompactionManager . java <nl> @ @ - 23 , 13 + 23 , 12 @ @ import java . io . File ; <nl> import java . lang . management . ManagementFactory ; <nl> import java . util . * ; <nl> import java . util . concurrent . Callable ; <nl> - import java . util . concurrent . ExecutorService ; <nl> import java . util . concurrent . Future ; <nl> import javax . management . * ; <nl> <nl> import org . apache . log4j . Logger ; <nl> <nl> - import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; <nl> + import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; <nl> import org . apache . cassandra . dht . Range ; <nl> import org . apache . cassandra . io . * ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> @ @ - 37 , 6 + 36 , 7 @ @ import org . apache . cassandra . service . StorageService ; <nl> import org . apache . cassandra . service . AntiEntropyService ; <nl> import org . apache . cassandra . utils . FileUtils ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> <nl> import java . net . InetAddress ; <nl> <nl> @ @ - 68 , 44 + 68 , 56 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> - private ExecutorService compactor _ = new JMXEnabledThreadPoolExecutor ( " COMPACTION - POOL " ) ; <nl> + private CompactionExecutor executor = new CompactionExecutor ( ) ; <nl> + private Map < ColumnFamilyStore , Integer > estimatedCompactions = new NonBlockingHashMap < ColumnFamilyStore , Integer > ( ) ; <nl> <nl> / * * <nl> * Call this whenever a compaction might be needed on the given columnfamily . <nl> * It ' s okay to over - call ( within reason ) since the compactions are single - threaded , <nl> * and if a call is unnecessary , it will just be no - oped in the bucketing phase . <nl> * / <nl> - public Future < Integer > submitMinor ( final ColumnFamilyStore cfs ) <nl> + public Future < Integer > submitMinorIfNeeded ( final ColumnFamilyStore cfs ) <nl> { <nl> Callable < Integer > callable = new Callable < Integer > ( ) <nl> { <nl> public Integer call ( ) throws IOException <nl> { <nl> - int filesCompacted = 0 ; <nl> - if ( minimumCompactionThreshold > 0 & & maximumCompactionThreshold > 0 ) <nl> + if ( minimumCompactionThreshold < = 0 | | maximumCompactionThreshold < = 0 ) <nl> { <nl> - logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; <nl> - for ( List < SSTableReader > sstables : getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ) <nl> + logger . debug ( " Compaction is currently disabled . " ) ; <nl> + return 0 ; <nl> + } <nl> + logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; <nl> + Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + updateEstimateFor ( cfs , buckets ) ; <nl> + <nl> + for ( List < SSTableReader > sstables : buckets ) <nl> + { <nl> + if ( sstables . size ( ) > = minimumCompactionThreshold ) <nl> { <nl> - if ( sstables . size ( ) < minimumCompactionThreshold ) <nl> - { <nl> - continue ; <nl> - } <nl> / / if we have too many to compact all at once , compact older ones first - - this avoids <nl> / / re - compacting files we just created . <nl> Collections . sort ( sstables ) ; <nl> - filesCompacted + = doCompaction ( cfs , sstables . subList ( 0 , Math . min ( sstables . size ( ) , maximumCompactionThreshold ) ) , getDefaultGCBefore ( ) ) ; <nl> + return doCompaction ( cfs , sstables . subList ( 0 , Math . min ( sstables . size ( ) , maximumCompactionThreshold ) ) , getDefaultGCBefore ( ) ) ; <nl> } <nl> - logger . debug ( filesCompacted + " files compacted " ) ; <nl> } <nl> - else <nl> - { <nl> - logger . debug ( " Compaction is currently disabled . " ) ; <nl> - } <nl> - return filesCompacted ; <nl> + return 0 ; <nl> } <nl> } ; <nl> - return compactor _ . submit ( callable ) ; <nl> + return executor . submit ( callable ) ; <nl> + } <nl> + <nl> + private void updateEstimateFor ( ColumnFamilyStore cfs , Set < List < SSTableReader > > buckets ) <nl> + { <nl> + int n = 0 ; <nl> + for ( List < SSTableReader > sstables : buckets ) <nl> + { <nl> + if ( sstables . size ( ) > = minimumCompactionThreshold ) <nl> + { <nl> + n + = 1 + sstables . size ( ) / ( maximumCompactionThreshold - minimumCompactionThreshold ) ; <nl> + } <nl> + } <nl> + estimatedCompactions . put ( cfs , n ) ; <nl> } <nl> <nl> public Future < Object > submitCleanup ( final ColumnFamilyStore cfStore ) <nl> @ @ - 118 , 7 + 130 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return this ; <nl> } <nl> } ; <nl> - return compactor _ . submit ( runnable ) ; <nl> + return executor . submit ( runnable ) ; <nl> } <nl> <nl> public Future < List < SSTableReader > > submitAnticompaction ( final ColumnFamilyStore cfStore , final Collection < Range > ranges , final InetAddress target ) <nl> @ @ - 130 , 7 + 142 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return doAntiCompaction ( cfStore , cfStore . getSSTables ( ) , ranges , target ) ; <nl> } <nl> } ; <nl> - return compactor _ . submit ( callable ) ; <nl> + return executor . submit ( callable ) ; <nl> } <nl> <nl> public Future submitMajor ( final ColumnFamilyStore cfStore ) <nl> @ @ - 165 , 7 + 177 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return this ; <nl> } <nl> } ; <nl> - return compactor _ . submit ( callable ) ; <nl> + return executor . submit ( callable ) ; <nl> } <nl> <nl> public Future submitReadonly ( final ColumnFamilyStore cfStore , final InetAddress initiator ) <nl> @ @ - 178 , 7 + 190 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> return this ; <nl> } <nl> } ; <nl> - return compactor _ . submit ( callable ) ; <nl> + return executor . submit ( callable ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 258 , 6 + 270 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> SSTableWriter writer ; <nl> CompactionIterator ci = new CompactionIterator ( sstables , gcBefore , major ) ; / / retain a handle so we can call close ( ) <nl> Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; <nl> + executor . beginCompaction ( cfs , ci ) ; <nl> <nl> try <nl> { <nl> @ @ - 293 , 7 + 306 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> SSTableReader ssTable = writer . closeAndOpenReader ( DatabaseDescriptor . getKeysCachedFraction ( table . name ) ) ; <nl> cfs . replaceCompactedSSTables ( sstables , Arrays . asList ( ssTable ) ) ; <nl> gcAfterRpcTimeout ( ) ; <nl> - instance . submitMinor ( cfs ) ; <nl> + submitMinorIfNeeded ( cfs ) ; <nl> <nl> String format = " Compacted to % s . % d / % d bytes for % d keys . Time : % dms . " ; <nl> long dTime = System . currentTimeMillis ( ) - startTime ; <nl> @ @ - 341 , 6 + 354 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> SSTableWriter writer = null ; <nl> CompactionIterator ci = new AntiCompactionIterator ( sstables , ranges , getDefaultGCBefore ( ) , cfs . isCompleteSSTables ( sstables ) ) ; <nl> Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; <nl> + executor . beginCompaction ( cfs , ci ) ; <nl> <nl> try <nl> { <nl> @ @ - 403 , 6 + 417 , 7 @ @ public class CompactionManager implements CompactionManagerMBean <nl> { <nl> Collection < SSTableReader > sstables = cfs . getSSTables ( ) ; <nl> CompactionIterator ci = new CompactionIterator ( sstables , getDefaultGCBefore ( ) , true ) ; <nl> + executor . beginCompaction ( cfs , ci ) ; <nl> try <nl> { <nl> Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; <nl> @ @ - 528 , 21 + 543 , 99 @ @ public class CompactionManager implements CompactionManagerMBean <nl> } <nl> } <nl> <nl> - public void checkAllColumnFamilies ( ) <nl> + public void checkAllColumnFamilies ( ) throws IOException <nl> { <nl> + / / perform estimates <nl> for ( String tableName : DatabaseDescriptor . getTables ( ) ) <nl> { <nl> - try <nl> + for ( final ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) <nl> { <nl> - for ( ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) <nl> + Runnable runnable = new Runnable ( ) <nl> { <nl> - submitMinor ( cfs ) ; <nl> - } <nl> + public void run ( ) <nl> + { <nl> + logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; <nl> + final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; <nl> + updateEstimateFor ( cfs , buckets ) ; <nl> + } <nl> + } ; <nl> + executor . submit ( runnable ) ; <nl> } <nl> - catch ( IOException e ) <nl> + } <nl> + <nl> + / / actually schedule compactions . done in a second pass so all the estimates occur before we <nl> + / / bog down the executor in actual compactions . <nl> + for ( String tableName : DatabaseDescriptor . getTables ( ) ) <nl> + { <nl> + for ( final ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) <nl> { <nl> - throw new RuntimeException ( e ) ; <nl> + submitMinorIfNeeded ( cfs ) ; <nl> } <nl> } <nl> } <nl> + <nl> + private class CompactionExecutor extends DebuggableThreadPoolExecutor <nl> + { <nl> + private volatile ColumnFamilyStore cfs ; <nl> + private volatile CompactionIterator ci ; <nl> + <nl> + public CompactionExecutor ( ) <nl> + { <nl> + super ( " COMPACTION - POOL " ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public void afterExecute ( Runnable r , Throwable t ) <nl> + { <nl> + super . afterExecute ( r , t ) ; <nl> + cfs = null ; <nl> + ci = null ; <nl> + } <nl> + <nl> + void beginCompaction ( ColumnFamilyStore cfs , CompactionIterator ci ) <nl> + { <nl> + this . cfs = cfs ; <nl> + this . ci = ci ; <nl> + } <nl> + <nl> + public String getColumnFamilyName ( ) <nl> + { <nl> + return cfs = = null ? null : cfs . getColumnFamilyName ( ) ; <nl> + } <nl> + <nl> + public Long getBytesTotal ( ) <nl> + { <nl> + return ci = = null ? null : ci . getTotalBytes ( ) ; <nl> + } <nl> + <nl> + public Long getBytesCompleted ( ) <nl> + { <nl> + return ci = = null ? null : ci . getBytesRead ( ) ; <nl> + } <nl> + } <nl> + <nl> + public String getColumnFamilyInProgress ( ) <nl> + { <nl> + return executor . getColumnFamilyName ( ) ; <nl> + } <nl> + <nl> + public Long getBytesTotalInProgress ( ) <nl> + { <nl> + return executor . getBytesTotal ( ) ; <nl> + } <nl> + <nl> + public Long getBytesCompacted ( ) <nl> + { <nl> + return executor . getBytesCompleted ( ) ; <nl> + } <nl> + <nl> + public int getPendingTasks ( ) <nl> + { <nl> + int n = 0 ; <nl> + for ( Integer i : estimatedCompactions . values ( ) ) <nl> + { <nl> + n + = i ; <nl> + } <nl> + return n ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / CompactionManagerMBean . java b / src / java / org / apache / cassandra / db / CompactionManagerMBean . java <nl> index e11b09f . . 0bb7c3f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / CompactionManagerMBean . java <nl> + + + b / src / java / org / apache / cassandra / db / CompactionManagerMBean . java <nl> @ @ - 39 , 4 + 39 , 24 @ @ public interface CompactionManagerMBean <nl> * Sets the maximum number of sstables in queue before compaction kicks off <nl> * / <nl> public void setMaximumCompactionThreshold ( int threshold ) ; <nl> + <nl> + / * * <nl> + * @ return the columnfamily currently being compacted ; null if none <nl> + * / <nl> + public String getColumnFamilyInProgress ( ) ; <nl> + <nl> + / * * <nl> + * @ return the total ( data , not including index and filter ) bytes being compacted ; null if none <nl> + * / <nl> + public Long getBytesTotalInProgress ( ) ; <nl> + <nl> + / * * <nl> + * @ return the progress on the current compaction ; null if none <nl> + * / <nl> + public Long getBytesCompacted ( ) ; <nl> + <nl> + / * * <nl> + * @ return estimated number of compactions remaining to perform <nl> + * / <nl> + public int getPendingTasks ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / io / CompactionIterator . java b / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> index c085b63 . . 20dfe55 100644 <nl> - - - a / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> + + + b / src / java / org / apache / cassandra / io / CompactionIterator . java <nl> @ @ - 45 , 10 + 45 , 15 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio <nl> <nl> private final List < IteratingRow > rows = new ArrayList < IteratingRow > ( ) ; <nl> private final int gcBefore ; <nl> - private boolean major ; <nl> + private final boolean major ; <nl> + <nl> + private long totalBytes ; <nl> + private long bytesRead ; <nl> + private long row ; <nl> <nl> public CompactionIterator ( Iterable < SSTableReader > sstables , int gcBefore , boolean major ) throws IOException <nl> { <nl> + < < < < < < < HEAD <nl> this ( getCollatingIterator ( sstables ) , gcBefore , major ) ; <nl> } <nl> <nl> @ @ - 56 , 6 + 61 , 15 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio <nl> protected CompactionIterator ( Iterator iter , int gcBefore , boolean major ) <nl> { <nl> super ( iter ) ; <nl> + = = = = = = = <nl> + super ( getCollatingIterator ( sstables ) ) ; <nl> + row = 0 ; <nl> + totalBytes = bytesRead = 0 ; <nl> + for ( SSTableScanner iter : ( List < SSTableScanner > ) ( ( CollatingIterator ) source ) . getIterators ( ) ) <nl> + { <nl> + totalBytes + = iter . getFileLength ( ) ; <nl> + } <nl> + > > > > > > > make estimation of pendingtasks for CompactionManager sane <nl> this . gcBefore = gcBefore ; <nl> this . major = major ; <nl> } <nl> @ @ - 135 , 6 + 149 , 14 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio <nl> finally <nl> { <nl> rows . clear ( ) ; <nl> + if ( ( row + + % 1000 ) = = 0 ) <nl> + { <nl> + bytesRead = 0 ; <nl> + for ( SSTableScanner iter : ( List < SSTableScanner > ) ( ( CollatingIterator ) source ) . getIterators ( ) ) <nl> + { <nl> + bytesRead + = iter . getFilePointer ( ) ; <nl> + } <nl> + } <nl> } <nl> return new CompactedRow ( key , buffer ) ; <nl> } <nl> @ @ - 147 , 6 + 169 , 16 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio <nl> } <nl> } <nl> <nl> + public long getTotalBytes ( ) <nl> + { <nl> + return totalBytes ; <nl> + } <nl> + <nl> + public long getBytesRead ( ) <nl> + { <nl> + return bytesRead ; <nl> + } <nl> + <nl> public static class CompactedRow <nl> { <nl> public final DecoratedKey key ; <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTable . java b / src / java / org / apache / cassandra / io / SSTable . java <nl> index 2c137ef . . e5b0690 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTable . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTable . java <nl> @ @ - 198 , 11 + 198 , 6 @ @ public abstract class SSTable <nl> } <nl> } <nl> <nl> - public long dataBytesOnDisk ( ) <nl> - { <nl> - return new File ( path ) . length ( ) ; <nl> - } <nl> - <nl> public long bytesOnDisk ( ) <nl> { <nl> long bytes = 0 ; <nl> diff - - git a / src / java / org / apache / cassandra / io / SSTableScanner . java b / src / java / org / apache / cassandra / io / SSTableScanner . java <nl> index 9bc1c70 . . 8a99337 100644 <nl> - - - a / src / java / org / apache / cassandra / io / SSTableScanner . java <nl> + + + b / src / java / org / apache / cassandra / io / SSTableScanner . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . io ; <nl> <nl> import java . io . IOException ; <nl> import java . io . Closeable ; <nl> + import java . io . IOError ; <nl> import java . util . Iterator ; <nl> import java . util . Arrays ; <nl> <nl> @ @ - 72 , 6 + 73 , 23 @ @ public class SSTableScanner implements Iterator < IteratingRow > , Closeable <nl> } <nl> } <nl> <nl> + public long getFileLength ( ) <nl> + { <nl> + try <nl> + { <nl> + return file . length ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public long getFilePointer ( ) <nl> + { <nl> + return file . getFilePointer ( ) ; <nl> + } <nl> + <nl> public boolean hasNext ( ) <nl> { <nl> if ( iterator = = null ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / CompactionsTest . java b / test / unit / org / apache / cassandra / db / CompactionsTest . java <nl> index 1fa6b30 . . 52aa04b 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / CompactionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / CompactionsTest . java <nl> @ @ - 66 , 7 + 66 , 7 @ @ public class CompactionsTest extends CleanupHelper <nl> } <nl> while ( true ) <nl> { <nl> - Future < Integer > ft = CompactionManager . instance . submitMinor ( store ) ; <nl> + Future < Integer > ft = CompactionManager . instance . submitMinorIfNeeded ( store ) ; <nl> if ( ft . get ( ) = = 0 ) <nl> break ; <nl> }

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java b / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java 
 index 4c6763c . . c4abab8 100644 
 - - - a / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java 
 + + + b / src / java / org / apache / cassandra / concurrent / NamedThreadFactory . java 
 @ @ - 30 , 6 + 30 , 8 @ @ public class NamedThreadFactory implements ThreadFactory 
 { 
 protected final String id ; 
 private final int priority ; 
 + private final ClassLoader contextClassLoader ; 
 + private final ThreadGroup threadGroup ; 
 protected final AtomicInteger n = new AtomicInteger ( 1 ) ; 
 
 public NamedThreadFactory ( String id ) 
 @ @ - 39 , 17 + 41 , 26 @ @ public class NamedThreadFactory implements ThreadFactory 
 
 public NamedThreadFactory ( String id , int priority ) 
 { 
 + this ( id , priority , null , null ) ; 
 + } 
 
 + public NamedThreadFactory ( String id , int priority , ClassLoader contextClassLoader , ThreadGroup threadGroup ) 
 + { 
 this . id = id ; 
 this . priority = priority ; 
 + this . contextClassLoader = contextClassLoader ; 
 + this . threadGroup = threadGroup ; 
 } 
 
 public Thread newThread ( Runnable runnable ) 
 { 
 - String name = id + " : " + n . getAndIncrement ( ) ; 
 - Thread thread = new Thread ( runnable , name ) ; 
 - thread . setPriority ( priority ) ; 
 + String name = id + ' : ' + n . getAndIncrement ( ) ; 
 + Thread thread = new Thread ( threadGroup , runnable , name ) ; 
 thread . setDaemon ( true ) ; 
 + thread . setPriority ( priority ) ; 
 + if ( contextClassLoader ! = null ) 
 + thread . setContextClassLoader ( contextClassLoader ) ; 
 return thread ; 
 } 
 + 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / FBUtilities . java b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 index 8492fed . . 14a8d71 100644 
 - - - a / src / java / org / apache / cassandra / utils / FBUtilities . java 
 + + + b / src / java / org / apache / cassandra / utils / FBUtilities . java 
 @ @ - 378 , 17 + 378 , 41 @ @ public class FBUtilities 
 
 public static < T > List < T > waitOnFutures ( Iterable < ? extends Future < ? extends T > > futures ) 
 { 
 + return waitOnFutures ( futures , - 1 , null ) ; 
 + } 
 + 
 + / * * 
 + * Block for a collection of futures , with optional timeout . 
 + * 
 + * @ param futures 
 + * @ param timeout The number of units to wait in total . If this value is less than or equal to zero , 
 + * no tiemout value will be passed to { @ link Future # get ( ) } . 
 + * @ param units The units of timeout . 
 + * / 
 + public static < T > List < T > waitOnFutures ( Iterable < ? extends Future < ? extends T > > futures , long timeout , TimeUnit units ) 
 + { 
 + long endNanos = 0 ; 
 + if ( timeout > 0 ) 
 + endNanos = System . nanoTime ( ) + units . toNanos ( timeout ) ; 
 List < T > results = new ArrayList < > ( ) ; 
 Throwable fail = null ; 
 for ( Future < ? extends T > f : futures ) 
 { 
 try 
 { 
 - results . add ( f . get ( ) ) ; 
 + if ( endNanos = = 0 ) 
 + { 
 + results . add ( f . get ( ) ) ; 
 + } 
 + else 
 + { 
 + long waitFor = Math . max ( 1 , endNanos - System . nanoTime ( ) ) ; 
 + results . add ( f . get ( waitFor , TimeUnit . NANOSECONDS ) ) ; 
 + } 
 } 
 - catch ( InterruptedException | ExecutionException e ) 
 + catch ( Throwable t ) 
 { 
 - fail = Throwables . merge ( fail , e ) ; 
 + fail = Throwables . merge ( fail , t ) ; 
 } 
 } 
 Throwables . maybeFail ( fail ) ; 
 diff - - git a / src / java / org / apache / cassandra / utils / memory / MemtablePool . java b / src / java / org / apache / cassandra / utils / memory / MemtablePool . java 
 index 7663103 . . b4efaa6 100644 
 - - - a / src / java / org / apache / cassandra / utils / memory / MemtablePool . java 
 + + + b / src / java / org / apache / cassandra / utils / memory / MemtablePool . java 
 @ @ - 60 , 7 + 60 , 7 @ @ public abstract class MemtablePool 
 } 
 
 public abstract boolean needToCopyOnHeap ( ) ; 
 - 
 + 
 @ VisibleForTesting 
 public void shutdown ( ) throws InterruptedException 
 { 
 diff - - git a / test / conf / logback - dtest . xml b / test / conf / logback - dtest . xml 
 index b8019f6 . . df8cac8 100644 
 - - - a / test / conf / logback - dtest . xml 
 + + + b / test / conf / logback - dtest . xml 
 @ @ - 23 , 9 + 23 , 6 @ @ 
 < ! - - Shutdown hook ensures that async appender flushes - - > 
 < shutdownHook class = " ch . qos . logback . core . hook . DelayingShutdownHook " / > 
 
 - < ! - - Status listener is used to wrap stdout / stderr and tee to log file - - > 
 - < statusListener class = " org . apache . cassandra . LogbackStatusListener " / > 
 - 
 < appender name = " FILE " class = " ch . qos . logback . core . rolling . RollingFileAppender " > 
 
 < file > . / build / test / logs / $ { cassandra . testtag } / TEST - $ { suitename } . log < / file > 
 @ @ - 45 , 35 + 42 , 45 @ @ 
 < / encoder > 
 < / appender > 
 
 - < appender name = " STDOUT " target = " System . out " class = " org . apache . cassandra . ConsoleAppender " > 
 + < appender name = " ASYNCFILE " class = " ch . qos . logback . classic . AsyncAppender " > 
 + < discardingThreshold > 0 < / discardingThreshold > 
 + < maxFlushTime > 0 < / maxFlushTime > 
 + < queueSize > 1024 < / queueSize > 
 + < appender - ref ref = " FILE " / > 
 + < / appender > 
 + 
 + < appender name = " STDERR " target = " System . err " class = " ch . qos . logback . core . ConsoleAppender " > 
 < encoder > 
 - < pattern > % - 5level [ % thread ] $ { instance _ id } % date { ISO8601 } % F : % L - % msg % n < / pattern > 
 + < pattern > % - 5level % date { HH : mm : ss , SSS } % msg % n < / pattern > 
 < / encoder > 
 < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > 
 - < level > DEBUG < / level > 
 + < level > WARN < / level > 
 < / filter > 
 < / appender > 
 
 - < appender name = " TEE " class = " org . apache . cassandra . TeeingAppender " > 
 - < appender - ref ref = " FILE " / > 
 - < appender - ref ref = " STDOUT " / > 
 + < appender name = " STDOUT " target = " System . out " class = " ch . qos . logback . core . ConsoleAppender " > 
 + < encoder > 
 + < pattern > % - 5level % date { HH : mm : ss , SSS } % msg % n < / pattern > 
 + < / encoder > 
 + < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > 
 + < level > WARN < / level > 
 + < / filter > 
 < / appender > 
 
 - < logger name = " org . apache . hadoop " level = " WARN " / > 
 - 
 - < logger name = " org . apache . cassandra . db . monitoring " level = " DEBUG " / > 
 - 
 - < ! - - Do not change the name of this appender . LogbackStatusListener uses the thread name 
 - tied to the appender name to know when to write to real stdout / stderr vs forwarding to logback - - > 
 - < appender name = " ASYNC " class = " ch . qos . logback . classic . AsyncAppender " > 
 - < discardingThreshold > 0 < / discardingThreshold > 
 - < maxFlushTime > 0 < / maxFlushTime > 
 - < queueSize > 1024 < / queueSize > 
 - < appender - ref ref = " TEE " / > 
 - < includeCallerData > true < / includeCallerData > 
 + < appender name = " STDOUT " target = " System . out " class = " ch . qos . logback . core . ConsoleAppender " > 
 + < encoder > 
 + < pattern > % - 5level [ % thread ] $ { instance _ id } % date { ISO8601 } % F : % L - % msg % n < / pattern > 
 + < / encoder > 
 + < filter class = " ch . qos . logback . classic . filter . ThresholdFilter " > 
 + < level > DEBUG < / level > 
 + < / filter > 
 < / appender > 
 
 + < logger name = " org . apache . hadoop " level = " WARN " / > 
 + 
 < root level = " DEBUG " > 
 - < appender - ref ref = " ASYNC " / > 
 + < appender - ref ref = " ASYNCFILE " / > 
 + < appender - ref ref = " STDERR " / > 
 + < appender - ref ref = " STDOUT " / > 
 < / root > 
 < / configuration > 
 diff - - git a / test / distributed / org / apache / cassandra / distributed / Instance . java b / test / distributed / org / apache / cassandra / distributed / Instance . java 
 index 37be73c . . c8977d7 100644 
 - - - a / test / distributed / org / apache / cassandra / distributed / Instance . java 
 + + + b / test / distributed / org / apache / cassandra / distributed / Instance . java 
 @ @ - 30 , 6 + 30 , 8 @ @ import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . UUID ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Future ; 
 import java . util . function . BiConsumer ; 
 import java . util . function . Function ; 
 
 @ @ - 83 , 7 + 85 , 7 @ @ public class Instance extends InvokableInstance 
 
 public Instance ( InstanceConfig config , ClassLoader classLoader ) 
 { 
 - super ( classLoader ) ; 
 + super ( " node " + config . num , classLoader ) ; 
 this . config = config ; 
 } 
 
 @ @ - 332 , 9 + 334 , 9 @ @ public class Instance extends InvokableInstance 
 
 void shutdown ( ) 
 { 
 - runOnInstance ( ( ) - > { 
 + acceptsOnInstance ( ( ExecutorService executor ) - > { 
 Throwable error = null ; 
 - error = runAndMergeThrowable ( error , 
 + error = parallelRun ( error , executor , 
 Gossiper . instance : : stop , 
 CompactionManager . instance : : forceShutdown , 
 CommitLog . instance : : shutdownBlocking , 
 @ @ - 345 , 32 + 347 , 54 @ @ public class Instance extends InvokableInstance 
 StorageService . instance : : shutdownBGMonitor , 
 Ref : : shutdownReferenceReaper , 
 Memtable . MEMORY _ POOL : : shutdown , 
 - StageManager : : shutdownAndWait , 
 - MessagingService . instance ( ) : : shutdown , 
 - SharedExecutorPool . SHARED : : shutdown , 
 ScheduledExecutors : : shutdownAndWait , 
 - SSTableReader : : shutdownBlocking ) ; 
 - 
 + SSTableReader : : shutdownBlocking 
 + ) ; 
 + error = parallelRun ( error , executor , 
 + MessagingService . instance ( ) : : shutdown 
 + ) ; 
 + error = parallelRun ( error , executor , 
 + StageManager : : shutdownAndWait , 
 + SharedExecutorPool . SHARED : : shutdown 
 + ) ; 
 LoggerContext loggerContext = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; 
 loggerContext . stop ( ) ; 
 Throwables . maybeFail ( error ) ; 
 - } ) ; 
 + } ) . accept ( isolatedExecutor ) ; 
 + super . shutdown ( ) ; 
 } 
 
 - private static Throwable runAndMergeThrowable ( Throwable existing , ThrowingRunnable . . . runnables ) 
 + private static Throwable parallelRun ( Throwable accumulate , ExecutorService runOn , ThrowingRunnable . . . runnables ) 
 { 
 + List < Future < Throwable > > results = new ArrayList < > ( ) ; 
 for ( ThrowingRunnable runnable : runnables ) 
 { 
 + results . add ( runOn . submit ( ( ) - > { 
 + try 
 + { 
 + runnable . run ( ) ; 
 + return null ; 
 + } 
 + catch ( Throwable t ) 
 + { 
 + return t ; 
 + } 
 + } ) ) ; 
 + } 
 + for ( Future < Throwable > future : results ) 
 + { 
 try 
 { 
 - runnable . run ( ) ; 
 + Throwable t = future . get ( ) ; 
 + if ( t ! = null ) 
 + throw t ; 
 } 
 catch ( Throwable t ) 
 { 
 - existing = Throwables . merge ( existing , t ) ; 
 + accumulate = Throwables . merge ( accumulate , t ) ; 
 } 
 } 
 - return existing ; 
 + return accumulate ; 
 } 
 
 public static interface ThrowingRunnable 
 diff - - git a / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java b / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java 
 index 036f6b1 . . 9958fd3 100644 
 - - - a / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java 
 + + + b / test / distributed / org / apache / cassandra / distributed / InstanceClassLoader . java 
 @ @ - 98 , 4 + 98 , 12 @ @ public class InstanceClassLoader extends URLClassLoader 
 return id - > new InstanceClassLoader ( id , urls , commonClassNames : : contains , contextClassLoader ) ; 
 } 
 
 + / * * 
 + * @ return true iff this class was loaded by an InstanceClassLoader , and as such is used by a dtest node 
 + * / 
 + public static boolean wasLoadedByAnInstanceClassLoader ( Class < ? > clazz ) 
 + { 
 + return clazz . getClassLoader ( ) . getClass ( ) . getName ( ) . equals ( InstanceClassLoader . class . getName ( ) ) ; 
 + } 
 + 
 } 
 diff - - git a / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java b / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java 
 index f646ae1 . . 9fb543d 100644 
 - - - a / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java 
 + + + b / test / distributed / org / apache / cassandra / distributed / InvokableInstance . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . distributed ; 
 
 import java . io . ByteArrayInputStream ; 
 import java . io . ByteArrayOutputStream ; 
 + import java . io . Closeable ; 
 import java . io . IOException ; 
 import java . io . ObjectInputStream ; 
 import java . io . ObjectOutputStream ; 
 @ @ - 27 , 18 + 28 , 26 @ @ import java . io . Serializable ; 
 import java . lang . reflect . InvocationTargetException ; 
 import java . lang . reflect . Method ; 
 import java . util . concurrent . Callable ; 
 + import java . util . concurrent . ExecutionException ; 
 + import java . util . concurrent . ExecutorService ; 
 + import java . util . concurrent . Executors ; 
 import java . util . function . BiConsumer ; 
 import java . util . function . BiFunction ; 
 import java . util . function . Consumer ; 
 import java . util . function . Function ; 
 
 + import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 + import org . apache . cassandra . utils . Throwables ; 
 + 
 public abstract class InvokableInstance 
 { 
 + protected final ExecutorService isolatedExecutor ; 
 private final ClassLoader classLoader ; 
 private final Method deserializeOnInstance ; 
 
 - public InvokableInstance ( ClassLoader classLoader ) 
 + public InvokableInstance ( String name , ClassLoader classLoader ) 
 { 
 + this . isolatedExecutor = Executors . newCachedThreadPool ( new NamedThreadFactory ( name , Thread . NORM _ PRIORITY , classLoader , new ThreadGroup ( name ) ) ) ; 
 this . classLoader = classLoader ; 
 try 
 { 
 @ @ - 50 , 31 + 59 , 34 @ @ public abstract class InvokableInstance 
 } 
 } 
 
 - public interface SerializableCallable < T > extends Callable < T > , Serializable { public T call ( ) ; } 
 - public < T > SerializableCallable < T > callsOnInstance ( SerializableCallable < T > call ) { return ( SerializableCallable < T > ) transferOneObject ( call ) ; } 
 + public interface CallableNoExcept < T > extends Callable < T > { public T call ( ) ; } 
 + public interface SerializableCallable < T > extends CallableNoExcept < T > , Serializable { } 
 + public < T > CallableNoExcept < T > callsOnInstance ( SerializableCallable < T > call ) { return invokesOnExecutor ( ( SerializableCallable < T > ) transferOneObject ( call ) , isolatedExecutor ) ; } 
 public < T > T callOnInstance ( SerializableCallable < T > call ) { return callsOnInstance ( call ) . call ( ) ; } 
 
 public interface SerializableRunnable extends Runnable , Serializable { } 
 - public SerializableRunnable runsOnInstance ( SerializableRunnable run ) { return ( SerializableRunnable ) transferOneObject ( run ) ; } 
 + public Runnable runsOnInstance ( SerializableRunnable run ) { return invokesOnExecutor ( ( SerializableRunnable ) transferOneObject ( run ) , isolatedExecutor ) ; } 
 public void runOnInstance ( SerializableRunnable run ) { runsOnInstance ( run ) . run ( ) ; } 
 
 public interface SerializableConsumer < T > extends Consumer < T > , Serializable { } 
 - public < T > SerializableConsumer < T > acceptsOnInstance ( SerializableConsumer < T > consumer ) { return ( SerializableConsumer < T > ) transferOneObject ( consumer ) ; } 
 + public < T > Consumer < T > acceptsOnInstance ( SerializableConsumer < T > consumer ) { return invokesOnExecutor ( ( SerializableConsumer < T > ) transferOneObject ( consumer ) , isolatedExecutor ) ; } 
 
 public interface SerializableBiConsumer < T1 , T2 > extends BiConsumer < T1 , T2 > , Serializable { } 
 - public < T1 , T2 > SerializableBiConsumer < T1 , T2 > acceptsOnInstance ( SerializableBiConsumer < T1 , T2 > consumer ) { return ( SerializableBiConsumer < T1 , T2 > ) transferOneObject ( consumer ) ; } 
 + public < T1 , T2 > BiConsumer < T1 , T2 > acceptsOnInstance ( SerializableBiConsumer < T1 , T2 > consumer ) { return invokesOnExecutor ( ( SerializableBiConsumer < T1 , T2 > ) transferOneObject ( consumer ) , isolatedExecutor ) ; } 
 
 public interface SerializableFunction < I , O > extends Function < I , O > , Serializable { } 
 - public < I , O > SerializableFunction < I , O > appliesOnInstance ( SerializableFunction < I , O > f ) { return ( SerializableFunction < I , O > ) transferOneObject ( f ) ; } 
 + public < I , O > Function < I , O > appliesOnInstance ( SerializableFunction < I , O > f ) { return invokesOnExecutor ( ( SerializableFunction < I , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } 
 
 public interface SerializableBiFunction < I1 , I2 , O > extends BiFunction < I1 , I2 , O > , Serializable { } 
 - public < I1 , I2 , O > SerializableBiFunction < I1 , I2 , O > appliesOnInstance ( SerializableBiFunction < I1 , I2 , O > f ) { return ( SerializableBiFunction < I1 , I2 , O > ) transferOneObject ( f ) ; } 
 + public < I1 , I2 , O > BiFunction < I1 , I2 , O > appliesOnInstance ( SerializableBiFunction < I1 , I2 , O > f ) { return invokesOnExecutor ( ( SerializableBiFunction < I1 , I2 , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } 
 
 - public interface SerializableTriFunction < I1 , I2 , I3 , O > extends Serializable 
 + public interface TriFunction < I1 , I2 , I3 , O > 
 { 
 O apply ( I1 i1 , I2 i2 , I3 i3 ) ; 
 } 
 - public < I1 , I2 , I3 , O > SerializableTriFunction < I1 , I2 , I3 , O > appliesOnInstance ( SerializableTriFunction < I1 , I2 , I3 , O > f ) { return ( SerializableTriFunction < I1 , I2 , I3 , O > ) transferOneObject ( f ) ; } 
 + public interface SerializableTriFunction < I1 , I2 , I3 , O > extends Serializable , TriFunction < I1 , I2 , I3 , O > { } 
 + 
 + public < I1 , I2 , I3 , O > TriFunction < I1 , I2 , I3 , O > appliesOnInstance ( SerializableTriFunction < I1 , I2 , I3 , O > f ) { return invokesOnExecutor ( ( SerializableTriFunction < I1 , I2 , I3 , O > ) transferOneObject ( f ) , isolatedExecutor ) ; } 
 
 public interface InstanceFunction < I , O > extends SerializableBiFunction < Instance , I , O > { } 
 
 @ @ - 130 , 4 + 142 , 72 @ @ public abstract class InvokableInstance 
 } 
 } 
 
 + private static < V > CallableNoExcept < V > invokesOnExecutor ( SerializableCallable < V > callable , ExecutorService invokeOn ) 
 + { 
 + return ( ) - > { 
 + try 
 + { 
 + return invokeOn . submit ( callable ) . get ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + Throwables . maybeFail ( e . getCause ( ) ) ; 
 + throw new AssertionError ( ) ; 
 + } 
 + } ; 
 + } 
 + 
 + private static Runnable invokesOnExecutor ( SerializableRunnable runnable , ExecutorService invokeOn ) 
 + { 
 + return ( ) - > { 
 + try 
 + { 
 + invokeOn . submit ( runnable ) . get ( ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + Throwables . maybeFail ( e . getCause ( ) ) ; 
 + throw new AssertionError ( ) ; 
 + } 
 + } ; 
 + } 
 + 
 + private static < A > Consumer < A > invokesOnExecutor ( SerializableConsumer < A > consumer , ExecutorService invokeOn ) 
 + { 
 + return ( a ) - > invokesOnExecutor ( ( ) - > consumer . accept ( a ) , invokeOn ) . run ( ) ; 
 + } 
 + 
 + private static < A , B > BiConsumer < A , B > invokesOnExecutor ( SerializableBiConsumer < A , B > consumer , ExecutorService invokeOn ) 
 + { 
 + return ( a , b ) - > invokesOnExecutor ( ( ) - > consumer . accept ( a , b ) , invokeOn ) . run ( ) ; 
 + } 
 + 
 + private static < A , B > Function < A , B > invokesOnExecutor ( SerializableFunction < A , B > f , ExecutorService invokeOn ) 
 + { 
 + return ( a ) - > invokesOnExecutor ( ( ) - > f . apply ( a ) , invokeOn ) . call ( ) ; 
 + } 
 + 
 + private static < A , B , C > BiFunction < A , B , C > invokesOnExecutor ( SerializableBiFunction < A , B , C > f , ExecutorService invokeOn ) 
 + { 
 + return ( a , b ) - > invokesOnExecutor ( ( ) - > f . apply ( a , b ) , invokeOn ) . call ( ) ; 
 + } 
 + 
 + private static < A , B , C , D > SerializableTriFunction < A , B , C , D > invokesOnExecutor ( SerializableTriFunction < A , B , C , D > f , ExecutorService invokeOn ) 
 + { 
 + return ( a , b , c ) - > invokesOnExecutor ( ( ) - > f . apply ( a , b , c ) , invokeOn ) . call ( ) ; 
 + } 
 + 
 + void shutdown ( ) 
 + { 
 + isolatedExecutor . shutdownNow ( ) ; 
 + } 
 + 
 } 
 diff - - git a / test / distributed / org / apache / cassandra / distributed / TestCluster . java b / test / distributed / org / apache / cassandra / distributed / TestCluster . java 
 index 82b775a . . 2450306 100644 
 - - - a / test / distributed / org / apache / cassandra / distributed / TestCluster . java 
 + + + b / test / distributed / org / apache / cassandra / distributed / TestCluster . java 
 @ @ - 31 , 24 + 31 , 19 @ @ import java . util . HashMap ; 
 import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 - import java . util . concurrent . ExecutionException ; 
 - import java . util . concurrent . ExecutorService ; 
 - import java . util . concurrent . Executors ; 
 import java . util . concurrent . Future ; 
 import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . locks . LockSupport ; 
 - import java . util . concurrent . TimeoutException ; 
 import java . util . function . IntFunction ; 
 import java . util . stream . Collectors ; 
 import java . util . stream . Stream ; 
 
 import com . google . common . collect . Sets ; 
 
 - import io . netty . util . concurrent . FastThreadLocal ; 
 - import io . netty . util . concurrent . FastThreadLocalThread ; 
 - import io . netty . util . internal . InternalThreadLocalMap ; 
 - import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 
 + import org . apache . cassandra . concurrent . NamedThreadFactory ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 import org . apache . cassandra . db . Keyspace ; 
 @ @ - 56 , 7 + 51 , 6 @ @ import org . apache . cassandra . io . util . FileUtils ; 
 import org . apache . cassandra . locator . InetAddressAndPort ; 
 import org . apache . cassandra . net . MessagingService ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 - import org . apache . cassandra . utils . Throwables ; 
 
 / * * 
 * TestCluster creates , initializes and manages Cassandra instances ( { @ link Instance } . 
 @ @ - 84 , 7 + 78 , 10 @ @ import org . apache . cassandra . utils . Throwables ; 
 * / 
 public class TestCluster implements AutoCloseable 
 { 
 - private final ExecutorService exec = Executors . newCachedThreadPool ( new NamedThreadFactory ( " cluster - async - tasks " ) ) ; 
 + / / WARNING : we have this logger not ( necessarily ) for logging , but 
 + / / to ensure we have instantiated the main classloader ' s LoggerFactory ( and any LogbackStatusListener ) 
 + / / before we instantiate any for a new instance 
 + private static final Logger logger = LoggerFactory . getLogger ( TestCluster . class ) ; 
 
 private final File root ; 
 private final List < Instance > instances ; 
 @ @ - 104 , 7 + 101 , 7 @ @ public class TestCluster implements AutoCloseable 
 void launch ( ) 
 { 
 FBUtilities . waitOnFutures ( instances . stream ( ) 
 - . map ( i - > exec . submit ( ( ) - > i . launch ( this ) ) ) 
 + . map ( i - > i . isolatedExecutor . submit ( ( ) - > i . launch ( this ) ) ) 
 . collect ( Collectors . toList ( ) ) 
 ) ; 
 for ( Instance instance : instances ) 
 @ @ - 247 , 37 + 244 , 17 @ @ public class TestCluster implements AutoCloseable 
 } 
 
 @ Override 
 - public void close ( ) throws InterruptedException , TimeoutException , ExecutionException 
 + public void close ( ) 
 { 
 List < Future < ? > > futures = instances . stream ( ) 
 - . map ( i - > exec . submit ( i : : shutdown ) ) 
 + . map ( i - > i . isolatedExecutor . submit ( i : : shutdown ) ) 
 . collect ( Collectors . toList ( ) ) ; 
 
 / / Make sure to only delete directory when threads are stopped 
 - Future combined = exec . submit ( ( ) - > { 
 - FBUtilities . waitOnFutures ( futures ) ; 
 - FileUtils . deleteRecursive ( root ) ; 
 - } ) ; 
 - 
 - combined . get ( 60 , TimeUnit . SECONDS ) ; 
 - 
 - exec . shutdownNow ( ) ; 
 - exec . awaitTermination ( 10 , TimeUnit . SECONDS ) ; 
 - 
 - / / withThreadLeakCheck ( futures ) ; 
 - Set < Thread > threadSet = Thread . getAllStackTraces ( ) . keySet ( ) ; 
 - for ( Thread thread : threadSet ) 
 - { 
 - if ( thread instanceof FastThreadLocalThread ) 
 - ( ( FastThreadLocalThread ) thread ) . setThreadLocalMap ( null ) ; 
 - } 
 - 
 - InternalThreadLocalMap . remove ( ) ; 
 - InternalThreadLocalMap . destroy ( ) ; 
 - 
 - FastThreadLocal . removeAll ( ) ; 
 - FastThreadLocal . destroy ( ) ; 
 + FBUtilities . waitOnFutures ( futures , 60 , TimeUnit . SECONDS ) ; 
 + FileUtils . deleteRecursive ( root ) ; 
 
 + / / withThreadLeakCheck ( futures ) ; 
 System . gc ( ) ; 
 } 
 
 @ @ - 299 , 26 + 276 , 5 @ @ public class TestCluster implements AutoCloseable 
 } 
 } 
 
 - public void runAndWait ( Instance . ThrowingRunnable runnable ) 
 - { 
 - try 
 - { 
 - exec . submit ( ( ) - > { 
 - try 
 - { 
 - runnable . run ( ) ; 
 - } 
 - catch ( Throwable throwable ) 
 - { 
 - Throwables . maybeFail ( throwable ) ; 
 - } 
 - } ) . get ( ) ; 
 - } 
 - catch ( Exception e ) 
 - { 
 - Throwables . maybeFail ( e . getCause ( ) ) ; 
 - } 
 - } 
 - 
 } 


NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 06b6ca7 . . 30fdbf7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 559 , 7 + 559 , 7 @ @ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 public void addSSTable ( SSTableReader sstable ) 
 { 
 ssTables _ . add ( sstable ) ; 
 - CompactionManager . instance . submitMinor ( this ) ; 
 + CompactionManager . instance . submitMinorIfNeeded ( this ) ; 
 } 
 
 / * 
 diff - - git a / src / java / org / apache / cassandra / db / CompactionManager . java b / src / java / org / apache / cassandra / db / CompactionManager . java 
 index 7584e96 . . 9f71364 100644 
 - - - a / src / java / org / apache / cassandra / db / CompactionManager . java 
 + + + b / src / java / org / apache / cassandra / db / CompactionManager . java 
 @ @ - 23 , 13 + 23 , 12 @ @ import java . io . File ; 
 import java . lang . management . ManagementFactory ; 
 import java . util . * ; 
 import java . util . concurrent . Callable ; 
 - import java . util . concurrent . ExecutorService ; 
 import java . util . concurrent . Future ; 
 import javax . management . * ; 
 
 import org . apache . log4j . Logger ; 
 
 - import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; 
 + import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; 
 import org . apache . cassandra . dht . Range ; 
 import org . apache . cassandra . io . * ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 @ @ - 37 , 6 + 36 , 7 @ @ import org . apache . cassandra . service . StorageService ; 
 import org . apache . cassandra . service . AntiEntropyService ; 
 import org . apache . cassandra . utils . FileUtils ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 
 import java . net . InetAddress ; 
 
 @ @ - 68 , 44 + 68 , 56 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 - private ExecutorService compactor _ = new JMXEnabledThreadPoolExecutor ( " COMPACTION - POOL " ) ; 
 + private CompactionExecutor executor = new CompactionExecutor ( ) ; 
 + private Map < ColumnFamilyStore , Integer > estimatedCompactions = new NonBlockingHashMap < ColumnFamilyStore , Integer > ( ) ; 
 
 / * * 
 * Call this whenever a compaction might be needed on the given columnfamily . 
 * It ' s okay to over - call ( within reason ) since the compactions are single - threaded , 
 * and if a call is unnecessary , it will just be no - oped in the bucketing phase . 
 * / 
 - public Future < Integer > submitMinor ( final ColumnFamilyStore cfs ) 
 + public Future < Integer > submitMinorIfNeeded ( final ColumnFamilyStore cfs ) 
 { 
 Callable < Integer > callable = new Callable < Integer > ( ) 
 { 
 public Integer call ( ) throws IOException 
 { 
 - int filesCompacted = 0 ; 
 - if ( minimumCompactionThreshold > 0 & & maximumCompactionThreshold > 0 ) 
 + if ( minimumCompactionThreshold < = 0 | | maximumCompactionThreshold < = 0 ) 
 { 
 - logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; 
 - for ( List < SSTableReader > sstables : getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ) 
 + logger . debug ( " Compaction is currently disabled . " ) ; 
 + return 0 ; 
 + } 
 + logger . debug ( " Checking to see if compaction of " + cfs . columnFamily _ + " would be useful " ) ; 
 + Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + updateEstimateFor ( cfs , buckets ) ; 
 + 
 + for ( List < SSTableReader > sstables : buckets ) 
 + { 
 + if ( sstables . size ( ) > = minimumCompactionThreshold ) 
 { 
 - if ( sstables . size ( ) < minimumCompactionThreshold ) 
 - { 
 - continue ; 
 - } 
 / / if we have too many to compact all at once , compact older ones first - - this avoids 
 / / re - compacting files we just created . 
 Collections . sort ( sstables ) ; 
 - filesCompacted + = doCompaction ( cfs , sstables . subList ( 0 , Math . min ( sstables . size ( ) , maximumCompactionThreshold ) ) , getDefaultGCBefore ( ) ) ; 
 + return doCompaction ( cfs , sstables . subList ( 0 , Math . min ( sstables . size ( ) , maximumCompactionThreshold ) ) , getDefaultGCBefore ( ) ) ; 
 } 
 - logger . debug ( filesCompacted + " files compacted " ) ; 
 } 
 - else 
 - { 
 - logger . debug ( " Compaction is currently disabled . " ) ; 
 - } 
 - return filesCompacted ; 
 + return 0 ; 
 } 
 } ; 
 - return compactor _ . submit ( callable ) ; 
 + return executor . submit ( callable ) ; 
 + } 
 + 
 + private void updateEstimateFor ( ColumnFamilyStore cfs , Set < List < SSTableReader > > buckets ) 
 + { 
 + int n = 0 ; 
 + for ( List < SSTableReader > sstables : buckets ) 
 + { 
 + if ( sstables . size ( ) > = minimumCompactionThreshold ) 
 + { 
 + n + = 1 + sstables . size ( ) / ( maximumCompactionThreshold - minimumCompactionThreshold ) ; 
 + } 
 + } 
 + estimatedCompactions . put ( cfs , n ) ; 
 } 
 
 public Future < Object > submitCleanup ( final ColumnFamilyStore cfStore ) 
 @ @ - 118 , 7 + 130 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return this ; 
 } 
 } ; 
 - return compactor _ . submit ( runnable ) ; 
 + return executor . submit ( runnable ) ; 
 } 
 
 public Future < List < SSTableReader > > submitAnticompaction ( final ColumnFamilyStore cfStore , final Collection < Range > ranges , final InetAddress target ) 
 @ @ - 130 , 7 + 142 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return doAntiCompaction ( cfStore , cfStore . getSSTables ( ) , ranges , target ) ; 
 } 
 } ; 
 - return compactor _ . submit ( callable ) ; 
 + return executor . submit ( callable ) ; 
 } 
 
 public Future submitMajor ( final ColumnFamilyStore cfStore ) 
 @ @ - 165 , 7 + 177 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return this ; 
 } 
 } ; 
 - return compactor _ . submit ( callable ) ; 
 + return executor . submit ( callable ) ; 
 } 
 
 public Future submitReadonly ( final ColumnFamilyStore cfStore , final InetAddress initiator ) 
 @ @ - 178 , 7 + 190 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 return this ; 
 } 
 } ; 
 - return compactor _ . submit ( callable ) ; 
 + return executor . submit ( callable ) ; 
 } 
 
 / * * 
 @ @ - 258 , 6 + 270 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 SSTableWriter writer ; 
 CompactionIterator ci = new CompactionIterator ( sstables , gcBefore , major ) ; / / retain a handle so we can call close ( ) 
 Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; 
 + executor . beginCompaction ( cfs , ci ) ; 
 
 try 
 { 
 @ @ - 293 , 7 + 306 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 SSTableReader ssTable = writer . closeAndOpenReader ( DatabaseDescriptor . getKeysCachedFraction ( table . name ) ) ; 
 cfs . replaceCompactedSSTables ( sstables , Arrays . asList ( ssTable ) ) ; 
 gcAfterRpcTimeout ( ) ; 
 - instance . submitMinor ( cfs ) ; 
 + submitMinorIfNeeded ( cfs ) ; 
 
 String format = " Compacted to % s . % d / % d bytes for % d keys . Time : % dms . " ; 
 long dTime = System . currentTimeMillis ( ) - startTime ; 
 @ @ - 341 , 6 + 354 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 SSTableWriter writer = null ; 
 CompactionIterator ci = new AntiCompactionIterator ( sstables , ranges , getDefaultGCBefore ( ) , cfs . isCompleteSSTables ( sstables ) ) ; 
 Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; 
 + executor . beginCompaction ( cfs , ci ) ; 
 
 try 
 { 
 @ @ - 403 , 6 + 417 , 7 @ @ public class CompactionManager implements CompactionManagerMBean 
 { 
 Collection < SSTableReader > sstables = cfs . getSSTables ( ) ; 
 CompactionIterator ci = new CompactionIterator ( sstables , getDefaultGCBefore ( ) , true ) ; 
 + executor . beginCompaction ( cfs , ci ) ; 
 try 
 { 
 Iterator < CompactionIterator . CompactedRow > nni = new FilterIterator ( ci , PredicateUtils . notNullPredicate ( ) ) ; 
 @ @ - 528 , 21 + 543 , 99 @ @ public class CompactionManager implements CompactionManagerMBean 
 } 
 } 
 
 - public void checkAllColumnFamilies ( ) 
 + public void checkAllColumnFamilies ( ) throws IOException 
 { 
 + / / perform estimates 
 for ( String tableName : DatabaseDescriptor . getTables ( ) ) 
 { 
 - try 
 + for ( final ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) 
 { 
 - for ( ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) 
 + Runnable runnable = new Runnable ( ) 
 { 
 - submitMinor ( cfs ) ; 
 - } 
 + public void run ( ) 
 + { 
 + logger . debug ( " Estimating compactions for " + cfs . columnFamily _ ) ; 
 + final Set < List < SSTableReader > > buckets = getCompactionBuckets ( cfs . getSSTables ( ) , 50L * 1024L * 1024L ) ; 
 + updateEstimateFor ( cfs , buckets ) ; 
 + } 
 + } ; 
 + executor . submit ( runnable ) ; 
 } 
 - catch ( IOException e ) 
 + } 
 + 
 + / / actually schedule compactions . done in a second pass so all the estimates occur before we 
 + / / bog down the executor in actual compactions . 
 + for ( String tableName : DatabaseDescriptor . getTables ( ) ) 
 + { 
 + for ( final ColumnFamilyStore cfs : Table . open ( tableName ) . getColumnFamilyStores ( ) . values ( ) ) 
 { 
 - throw new RuntimeException ( e ) ; 
 + submitMinorIfNeeded ( cfs ) ; 
 } 
 } 
 } 
 + 
 + private class CompactionExecutor extends DebuggableThreadPoolExecutor 
 + { 
 + private volatile ColumnFamilyStore cfs ; 
 + private volatile CompactionIterator ci ; 
 + 
 + public CompactionExecutor ( ) 
 + { 
 + super ( " COMPACTION - POOL " ) ; 
 + } 
 + 
 + @ Override 
 + public void afterExecute ( Runnable r , Throwable t ) 
 + { 
 + super . afterExecute ( r , t ) ; 
 + cfs = null ; 
 + ci = null ; 
 + } 
 + 
 + void beginCompaction ( ColumnFamilyStore cfs , CompactionIterator ci ) 
 + { 
 + this . cfs = cfs ; 
 + this . ci = ci ; 
 + } 
 + 
 + public String getColumnFamilyName ( ) 
 + { 
 + return cfs = = null ? null : cfs . getColumnFamilyName ( ) ; 
 + } 
 + 
 + public Long getBytesTotal ( ) 
 + { 
 + return ci = = null ? null : ci . getTotalBytes ( ) ; 
 + } 
 + 
 + public Long getBytesCompleted ( ) 
 + { 
 + return ci = = null ? null : ci . getBytesRead ( ) ; 
 + } 
 + } 
 + 
 + public String getColumnFamilyInProgress ( ) 
 + { 
 + return executor . getColumnFamilyName ( ) ; 
 + } 
 + 
 + public Long getBytesTotalInProgress ( ) 
 + { 
 + return executor . getBytesTotal ( ) ; 
 + } 
 + 
 + public Long getBytesCompacted ( ) 
 + { 
 + return executor . getBytesCompleted ( ) ; 
 + } 
 + 
 + public int getPendingTasks ( ) 
 + { 
 + int n = 0 ; 
 + for ( Integer i : estimatedCompactions . values ( ) ) 
 + { 
 + n + = i ; 
 + } 
 + return n ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / CompactionManagerMBean . java b / src / java / org / apache / cassandra / db / CompactionManagerMBean . java 
 index e11b09f . . 0bb7c3f 100644 
 - - - a / src / java / org / apache / cassandra / db / CompactionManagerMBean . java 
 + + + b / src / java / org / apache / cassandra / db / CompactionManagerMBean . java 
 @ @ - 39 , 4 + 39 , 24 @ @ public interface CompactionManagerMBean 
 * Sets the maximum number of sstables in queue before compaction kicks off 
 * / 
 public void setMaximumCompactionThreshold ( int threshold ) ; 
 + 
 + / * * 
 + * @ return the columnfamily currently being compacted ; null if none 
 + * / 
 + public String getColumnFamilyInProgress ( ) ; 
 + 
 + / * * 
 + * @ return the total ( data , not including index and filter ) bytes being compacted ; null if none 
 + * / 
 + public Long getBytesTotalInProgress ( ) ; 
 + 
 + / * * 
 + * @ return the progress on the current compaction ; null if none 
 + * / 
 + public Long getBytesCompacted ( ) ; 
 + 
 + / * * 
 + * @ return estimated number of compactions remaining to perform 
 + * / 
 + public int getPendingTasks ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / io / CompactionIterator . java b / src / java / org / apache / cassandra / io / CompactionIterator . java 
 index c085b63 . . 20dfe55 100644 
 - - - a / src / java / org / apache / cassandra / io / CompactionIterator . java 
 + + + b / src / java / org / apache / cassandra / io / CompactionIterator . java 
 @ @ - 45 , 10 + 45 , 15 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio 
 
 private final List < IteratingRow > rows = new ArrayList < IteratingRow > ( ) ; 
 private final int gcBefore ; 
 - private boolean major ; 
 + private final boolean major ; 
 + 
 + private long totalBytes ; 
 + private long bytesRead ; 
 + private long row ; 
 
 public CompactionIterator ( Iterable < SSTableReader > sstables , int gcBefore , boolean major ) throws IOException 
 { 
 + < < < < < < < HEAD 
 this ( getCollatingIterator ( sstables ) , gcBefore , major ) ; 
 } 
 
 @ @ - 56 , 6 + 61 , 15 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio 
 protected CompactionIterator ( Iterator iter , int gcBefore , boolean major ) 
 { 
 super ( iter ) ; 
 + = = = = = = = 
 + super ( getCollatingIterator ( sstables ) ) ; 
 + row = 0 ; 
 + totalBytes = bytesRead = 0 ; 
 + for ( SSTableScanner iter : ( List < SSTableScanner > ) ( ( CollatingIterator ) source ) . getIterators ( ) ) 
 + { 
 + totalBytes + = iter . getFileLength ( ) ; 
 + } 
 + > > > > > > > make estimation of pendingtasks for CompactionManager sane 
 this . gcBefore = gcBefore ; 
 this . major = major ; 
 } 
 @ @ - 135 , 6 + 149 , 14 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio 
 finally 
 { 
 rows . clear ( ) ; 
 + if ( ( row + + % 1000 ) = = 0 ) 
 + { 
 + bytesRead = 0 ; 
 + for ( SSTableScanner iter : ( List < SSTableScanner > ) ( ( CollatingIterator ) source ) . getIterators ( ) ) 
 + { 
 + bytesRead + = iter . getFilePointer ( ) ; 
 + } 
 + } 
 } 
 return new CompactedRow ( key , buffer ) ; 
 } 
 @ @ - 147 , 6 + 169 , 16 @ @ public class CompactionIterator extends ReducingIterator < IteratingRow , Compactio 
 } 
 } 
 
 + public long getTotalBytes ( ) 
 + { 
 + return totalBytes ; 
 + } 
 + 
 + public long getBytesRead ( ) 
 + { 
 + return bytesRead ; 
 + } 
 + 
 public static class CompactedRow 
 { 
 public final DecoratedKey key ; 
 diff - - git a / src / java / org / apache / cassandra / io / SSTable . java b / src / java / org / apache / cassandra / io / SSTable . java 
 index 2c137ef . . e5b0690 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTable . java 
 + + + b / src / java / org / apache / cassandra / io / SSTable . java 
 @ @ - 198 , 11 + 198 , 6 @ @ public abstract class SSTable 
 } 
 } 
 
 - public long dataBytesOnDisk ( ) 
 - { 
 - return new File ( path ) . length ( ) ; 
 - } 
 - 
 public long bytesOnDisk ( ) 
 { 
 long bytes = 0 ; 
 diff - - git a / src / java / org / apache / cassandra / io / SSTableScanner . java b / src / java / org / apache / cassandra / io / SSTableScanner . java 
 index 9bc1c70 . . 8a99337 100644 
 - - - a / src / java / org / apache / cassandra / io / SSTableScanner . java 
 + + + b / src / java / org / apache / cassandra / io / SSTableScanner . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . io ; 
 
 import java . io . IOException ; 
 import java . io . Closeable ; 
 + import java . io . IOError ; 
 import java . util . Iterator ; 
 import java . util . Arrays ; 
 
 @ @ - 72 , 6 + 73 , 23 @ @ public class SSTableScanner implements Iterator < IteratingRow > , Closeable 
 } 
 } 
 
 + public long getFileLength ( ) 
 + { 
 + try 
 + { 
 + return file . length ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 + } 
 + 
 + public long getFilePointer ( ) 
 + { 
 + return file . getFilePointer ( ) ; 
 + } 
 + 
 public boolean hasNext ( ) 
 { 
 if ( iterator = = null ) 
 diff - - git a / test / unit / org / apache / cassandra / db / CompactionsTest . java b / test / unit / org / apache / cassandra / db / CompactionsTest . java 
 index 1fa6b30 . . 52aa04b 100644 
 - - - a / test / unit / org / apache / cassandra / db / CompactionsTest . java 
 + + + b / test / unit / org / apache / cassandra / db / CompactionsTest . java 
 @ @ - 66 , 7 + 66 , 7 @ @ public class CompactionsTest extends CleanupHelper 
 } 
 while ( true ) 
 { 
 - Future < Integer > ft = CompactionManager . instance . submitMinor ( store ) ; 
 + Future < Integer > ft = CompactionManager . instance . submitMinorIfNeeded ( store ) ; 
 if ( ft . get ( ) = = 0 ) 
 break ; 
 }
