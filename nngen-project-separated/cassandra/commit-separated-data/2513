BLEU SCORE: 0.027611988917697356

TEST MSG: Fix writetime / ttl methods for static columns
GENERATED MSG: Don ' t return range ghosts in CQL3

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 827003b . . 0a43f10 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 11 , 6 + 11 , 7 @ @ <nl> * Fix CFMetaData # getColumnDefinitionFromColumnName ( ) ( CASSANDRA - 7074 ) <nl> * Plug holes in resource release when wiring up StreamSession ( CASSANDRA - 7073 ) <nl> * Re - add parameter columns to tracing session ( CASSANDRA - 6942 ) <nl> + * Fix writetime / ttl functions for static columns ( CASSANDRA - 7081 ) <nl> Merged from 1 . 2 : <nl> * Fix nodetool display with vnodes ( CASSANDRA - 7082 ) <nl> * Fix schema concurrency exceptions ( CASSANDRA - 6841 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java b / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java <nl> index 1c9a346 . . 077a034 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java <nl> @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . Pair ; <nl> <nl> public class ColumnGroupMap <nl> { <nl> + public static ColumnGroupMap EMPTY = new ColumnGroupMap ( null , false ) ; <nl> + <nl> private final ByteBuffer [ ] fullPath ; <nl> private final Map < ByteBuffer , Value > map = new HashMap < ByteBuffer , Value > ( ) ; <nl> public final boolean isStatic ; / / Whether or not the group correspond to " static " cells <nl> @ @ - 66 , 7 + 68 , 7 @ @ public class ColumnGroupMap <nl> <nl> public ByteBuffer getKeyComponent ( int pos ) <nl> { <nl> - return fullPath [ pos ] ; <nl> + return fullPath = = null ? null : fullPath [ pos ] ; <nl> } <nl> <nl> public Column getSimple ( ByteBuffer key ) <nl> @ @ - 89 , 6 + 91 , 11 @ @ public class ColumnGroupMap <nl> return ( List < Pair < ByteBuffer , Column > > ) v ; <nl> } <nl> <nl> + public boolean hasValueFor ( ByteBuffer key ) <nl> + { <nl> + return map . containsKey ( key ) ; <nl> + } <nl> + <nl> private interface Value { } ; <nl> <nl> private static class Simple implements Value <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index 60ed763 . . 68adbbd 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 1058 , 35 + 1058 , 25 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> builder . add ( c ) ; <nl> } <nl> <nl> - Map < CFDefinition . Name , ByteBuffer > staticValues = Collections . emptyMap ( ) ; <nl> + ColumnGroupMap staticGroup = null ; <nl> / / Gather up static values first <nl> if ( ! builder . isEmpty ( ) & & builder . firstGroup ( ) . isStatic ) <nl> { <nl> - staticValues = new HashMap < > ( ) ; <nl> - ColumnGroupMap group = builder . firstGroup ( ) ; <nl> - for ( CFDefinition . Name name : Iterables . filter ( selection . getColumnsList ( ) , isStaticFilter ) ) <nl> - staticValues . put ( name , getValue ( name , group ) ) ; <nl> + staticGroup = builder . firstGroup ( ) ; <nl> builder . discardFirst ( ) ; <nl> <nl> / / If there was static columns but there is no actual row , then provided the select was a full <nl> / / partition selection ( i . e . not a 2ndary index search and there was no condition on clustering columns ) <nl> / / then we want to include the static columns in the result set . <nl> - if ( ! staticValues . isEmpty ( ) & & builder . isEmpty ( ) & & ! usesSecondaryIndexing & & hasNoClusteringColumnsRestriction ( ) ) <nl> + if ( builder . isEmpty ( ) & & ! usesSecondaryIndexing & & hasNoClusteringColumnsRestriction ( ) & & hasValueForQuery ( staticGroup ) ) <nl> { <nl> - result . newRow ( ) ; <nl> - for ( CFDefinition . Name name : selection . getColumnsList ( ) ) <nl> - { <nl> - if ( name . kind = = CFDefinition . Name . Kind . KEY _ ALIAS ) <nl> - result . add ( keyComponents [ name . position ] ) ; <nl> - else <nl> - result . add ( name . kind = = CFDefinition . Name . Kind . STATIC ? staticValues . get ( name ) : null ) ; <nl> - } <nl> + handleGroup ( result , keyComponents , ColumnGroupMap . EMPTY , staticGroup ) ; <nl> return ; <nl> } <nl> } <nl> <nl> for ( ColumnGroupMap group : builder . groups ( ) ) <nl> - handleGroup ( selection , result , keyComponents , group , staticValues ) ; <nl> + handleGroup ( result , keyComponents , group , staticGroup ) ; <nl> } <nl> else <nl> { <nl> @ @ - 1105 , 6 + 1095 , 14 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> } <nl> } <nl> <nl> + private boolean hasValueForQuery ( ColumnGroupMap staticGroup ) <nl> + { <nl> + for ( CFDefinition . Name name : Iterables . filter ( selection . getColumnsList ( ) , isStaticFilter ) ) <nl> + if ( staticGroup . hasValueFor ( name . name . key ) ) <nl> + return true ; <nl> + return false ; <nl> + } <nl> + <nl> private boolean hasNoClusteringColumnsRestriction ( ) <nl> { <nl> for ( int i = 0 ; i < columnRestrictions . length ; i + + ) <nl> @ @ - 1155 , 11 + 1153 , 10 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> Collections . sort ( cqlRows . rows , new CompositeComparator ( types , positions ) ) ; <nl> } <nl> <nl> - private void handleGroup ( Selection selection , <nl> - Selection . ResultSetBuilder result , <nl> + private void handleGroup ( Selection . ResultSetBuilder result , <nl> ByteBuffer [ ] keyComponents , <nl> ColumnGroupMap columns , <nl> - Map < CFDefinition . Name , ByteBuffer > staticValues ) throws InvalidRequestException <nl> + ColumnGroupMap staticGroup ) throws InvalidRequestException <nl> { <nl> / / Respect requested order <nl> result . newRow ( ) ; <nl> @ @ - 1177 , 48 + 1174 , 32 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> / / This should not happen for SPARSE <nl> throw new AssertionError ( ) ; <nl> case COLUMN _ METADATA : <nl> - if ( name . type . isCollection ( ) ) <nl> - { <nl> - result . add ( getCollectionValue ( name , columns ) ) ; <nl> - } <nl> - else <nl> - { <nl> - result . add ( columns . getSimple ( name . name . key ) ) ; <nl> - } <nl> + addValue ( result , name , columns ) ; <nl> break ; <nl> case STATIC : <nl> - result . add ( staticValues . get ( name ) ) ; <nl> + addValue ( result , name , staticGroup ) ; <nl> break ; <nl> } <nl> } <nl> } <nl> <nl> - private static ByteBuffer getValue ( CFDefinition . Name name , ColumnGroupMap columns ) <nl> + private static void addValue ( Selection . ResultSetBuilder result , CFDefinition . Name name , ColumnGroupMap group ) <nl> { <nl> - if ( name . type . isCollection ( ) ) <nl> - return getCollectionValue ( name , columns ) ; <nl> - else if ( name . type . isCommutative ( ) ) <nl> - return getCounterValue ( name , columns ) ; <nl> - <nl> - return getSimpleValue ( name , columns ) ; <nl> - } <nl> - <nl> - private static ByteBuffer getCollectionValue ( CFDefinition . Name name , ColumnGroupMap columns ) <nl> - { <nl> - List < Pair < ByteBuffer , Column > > collection = columns . getCollection ( name . name . key ) ; <nl> - return collection = = null ? null : ( ( CollectionType ) name . type ) . serialize ( collection ) ; <nl> - } <nl> - <nl> - private static ByteBuffer getSimpleValue ( CFDefinition . Name name , ColumnGroupMap columns ) <nl> - { <nl> - Column c = columns . getSimple ( name . name . key ) ; <nl> - return c = = null ? null : c . value ( ) ; <nl> - } <nl> + if ( group = = null ) <nl> + { <nl> + result . add ( ( ByteBuffer ) null ) ; <nl> + return ; <nl> + } <nl> <nl> - private static ByteBuffer getCounterValue ( CFDefinition . Name name , ColumnGroupMap columns ) <nl> - { <nl> - Column c = columns . getSimple ( name . name . key ) ; <nl> - return c = = null ? null : CounterColumnType . instance . decompose ( CounterContext . instance ( ) . total ( c . value ( ) ) ) ; <nl> + if ( name . type . isCollection ( ) ) <nl> + { <nl> + List < Pair < ByteBuffer , Column > > collection = group . getCollection ( name . name . key ) ; <nl> + result . add ( collection = = null ? null : ( ( CollectionType ) name . type ) . serialize ( collection ) ) ; <nl> + } <nl> + else <nl> + { <nl> + result . add ( group . getSimple ( name . name . key ) ) ; <nl> + } <nl> } <nl> <nl> private static boolean isReversedType ( CFDefinition . Name name )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1a5a7b7 . . 3e3db3f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 42 , 6 + 42 , 7 @ @ <nl> * ( cql3 ) Allow paging through non - ordered partitioner results ( CASSANDRA - 3771 ) <nl> * ( cql3 ) Fix drop index ( CASSANDRA - 4192 ) <nl> * ( cql3 ) Don ' t return range ghosts anymore ( CASSANDRA - 3982 ) <nl> + * fix the problem re - creating Keyspace / ColumnFamily ( CASSANDRA - 4219 ) <nl> Merged from 1 . 0 : <nl> * Fix super columns bug where cache is not updated ( CASSANDRA - 4190 ) <nl> * fix maxTimestamp to include row tombstones ( CASSANDRA - 4116 ) <nl> diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java <nl> index 245fa5f . . 9501778 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Schema . java <nl> + + + b / src / java / org / apache / cassandra / config / Schema . java <nl> @ @ - 454 , 7 + 454 , 7 @ @ public class Schema <nl> <nl> for ( Row row : SystemTable . serializedSchema ( ) ) <nl> { <nl> - if ( row . cf = = null | | row . cf . isMarkedForDelete ( ) | | row . cf . isEmpty ( ) ) <nl> + if ( row . cf = = null | | ( row . cf . isMarkedForDelete ( ) & & row . cf . isEmpty ( ) ) ) <nl> continue ; <nl> <nl> row . cf . updateDigest ( versionDigest ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / DefsTable . java b / src / java / org / apache / cassandra / db / DefsTable . java <nl> index 28ab4af . . 1b37de1 100644 <nl> - - - a / src / java / org / apache / cassandra / db / DefsTable . java <nl> + + + b / src / java / org / apache / cassandra / db / DefsTable . java <nl> @ @ - 152 , 7 + 152 , 7 @ @ public class DefsTable <nl> <nl> for ( Row row : serializedSchema ) <nl> { <nl> - if ( row . cf = = null | | row . cf . isEmpty ( ) | | row . cf . isMarkedForDelete ( ) ) <nl> + if ( row . cf = = null | | ( row . cf . isMarkedForDelete ( ) & & row . cf . isEmpty ( ) ) ) <nl> continue ; <nl> <nl> keyspaces . add ( KSMetaData . fromSchema ( row , serializedColumnFamilies ( row . key ) ) ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 827003b . . 0a43f10 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 11 , 6 + 11 , 7 @ @ 
 * Fix CFMetaData # getColumnDefinitionFromColumnName ( ) ( CASSANDRA - 7074 ) 
 * Plug holes in resource release when wiring up StreamSession ( CASSANDRA - 7073 ) 
 * Re - add parameter columns to tracing session ( CASSANDRA - 6942 ) 
 + * Fix writetime / ttl functions for static columns ( CASSANDRA - 7081 ) 
 Merged from 1 . 2 : 
 * Fix nodetool display with vnodes ( CASSANDRA - 7082 ) 
 * Fix schema concurrency exceptions ( CASSANDRA - 6841 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java b / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java 
 index 1c9a346 . . 077a034 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ColumnGroupMap . java 
 @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . Pair ; 
 
 public class ColumnGroupMap 
 { 
 + public static ColumnGroupMap EMPTY = new ColumnGroupMap ( null , false ) ; 
 + 
 private final ByteBuffer [ ] fullPath ; 
 private final Map < ByteBuffer , Value > map = new HashMap < ByteBuffer , Value > ( ) ; 
 public final boolean isStatic ; / / Whether or not the group correspond to " static " cells 
 @ @ - 66 , 7 + 68 , 7 @ @ public class ColumnGroupMap 
 
 public ByteBuffer getKeyComponent ( int pos ) 
 { 
 - return fullPath [ pos ] ; 
 + return fullPath = = null ? null : fullPath [ pos ] ; 
 } 
 
 public Column getSimple ( ByteBuffer key ) 
 @ @ - 89 , 6 + 91 , 11 @ @ public class ColumnGroupMap 
 return ( List < Pair < ByteBuffer , Column > > ) v ; 
 } 
 
 + public boolean hasValueFor ( ByteBuffer key ) 
 + { 
 + return map . containsKey ( key ) ; 
 + } 
 + 
 private interface Value { } ; 
 
 private static class Simple implements Value 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index 60ed763 . . 68adbbd 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 1058 , 35 + 1058 , 25 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 builder . add ( c ) ; 
 } 
 
 - Map < CFDefinition . Name , ByteBuffer > staticValues = Collections . emptyMap ( ) ; 
 + ColumnGroupMap staticGroup = null ; 
 / / Gather up static values first 
 if ( ! builder . isEmpty ( ) & & builder . firstGroup ( ) . isStatic ) 
 { 
 - staticValues = new HashMap < > ( ) ; 
 - ColumnGroupMap group = builder . firstGroup ( ) ; 
 - for ( CFDefinition . Name name : Iterables . filter ( selection . getColumnsList ( ) , isStaticFilter ) ) 
 - staticValues . put ( name , getValue ( name , group ) ) ; 
 + staticGroup = builder . firstGroup ( ) ; 
 builder . discardFirst ( ) ; 
 
 / / If there was static columns but there is no actual row , then provided the select was a full 
 / / partition selection ( i . e . not a 2ndary index search and there was no condition on clustering columns ) 
 / / then we want to include the static columns in the result set . 
 - if ( ! staticValues . isEmpty ( ) & & builder . isEmpty ( ) & & ! usesSecondaryIndexing & & hasNoClusteringColumnsRestriction ( ) ) 
 + if ( builder . isEmpty ( ) & & ! usesSecondaryIndexing & & hasNoClusteringColumnsRestriction ( ) & & hasValueForQuery ( staticGroup ) ) 
 { 
 - result . newRow ( ) ; 
 - for ( CFDefinition . Name name : selection . getColumnsList ( ) ) 
 - { 
 - if ( name . kind = = CFDefinition . Name . Kind . KEY _ ALIAS ) 
 - result . add ( keyComponents [ name . position ] ) ; 
 - else 
 - result . add ( name . kind = = CFDefinition . Name . Kind . STATIC ? staticValues . get ( name ) : null ) ; 
 - } 
 + handleGroup ( result , keyComponents , ColumnGroupMap . EMPTY , staticGroup ) ; 
 return ; 
 } 
 } 
 
 for ( ColumnGroupMap group : builder . groups ( ) ) 
 - handleGroup ( selection , result , keyComponents , group , staticValues ) ; 
 + handleGroup ( result , keyComponents , group , staticGroup ) ; 
 } 
 else 
 { 
 @ @ - 1105 , 6 + 1095 , 14 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 } 
 } 
 
 + private boolean hasValueForQuery ( ColumnGroupMap staticGroup ) 
 + { 
 + for ( CFDefinition . Name name : Iterables . filter ( selection . getColumnsList ( ) , isStaticFilter ) ) 
 + if ( staticGroup . hasValueFor ( name . name . key ) ) 
 + return true ; 
 + return false ; 
 + } 
 + 
 private boolean hasNoClusteringColumnsRestriction ( ) 
 { 
 for ( int i = 0 ; i < columnRestrictions . length ; i + + ) 
 @ @ - 1155 , 11 + 1153 , 10 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 Collections . sort ( cqlRows . rows , new CompositeComparator ( types , positions ) ) ; 
 } 
 
 - private void handleGroup ( Selection selection , 
 - Selection . ResultSetBuilder result , 
 + private void handleGroup ( Selection . ResultSetBuilder result , 
 ByteBuffer [ ] keyComponents , 
 ColumnGroupMap columns , 
 - Map < CFDefinition . Name , ByteBuffer > staticValues ) throws InvalidRequestException 
 + ColumnGroupMap staticGroup ) throws InvalidRequestException 
 { 
 / / Respect requested order 
 result . newRow ( ) ; 
 @ @ - 1177 , 48 + 1174 , 32 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 / / This should not happen for SPARSE 
 throw new AssertionError ( ) ; 
 case COLUMN _ METADATA : 
 - if ( name . type . isCollection ( ) ) 
 - { 
 - result . add ( getCollectionValue ( name , columns ) ) ; 
 - } 
 - else 
 - { 
 - result . add ( columns . getSimple ( name . name . key ) ) ; 
 - } 
 + addValue ( result , name , columns ) ; 
 break ; 
 case STATIC : 
 - result . add ( staticValues . get ( name ) ) ; 
 + addValue ( result , name , staticGroup ) ; 
 break ; 
 } 
 } 
 } 
 
 - private static ByteBuffer getValue ( CFDefinition . Name name , ColumnGroupMap columns ) 
 + private static void addValue ( Selection . ResultSetBuilder result , CFDefinition . Name name , ColumnGroupMap group ) 
 { 
 - if ( name . type . isCollection ( ) ) 
 - return getCollectionValue ( name , columns ) ; 
 - else if ( name . type . isCommutative ( ) ) 
 - return getCounterValue ( name , columns ) ; 
 - 
 - return getSimpleValue ( name , columns ) ; 
 - } 
 - 
 - private static ByteBuffer getCollectionValue ( CFDefinition . Name name , ColumnGroupMap columns ) 
 - { 
 - List < Pair < ByteBuffer , Column > > collection = columns . getCollection ( name . name . key ) ; 
 - return collection = = null ? null : ( ( CollectionType ) name . type ) . serialize ( collection ) ; 
 - } 
 - 
 - private static ByteBuffer getSimpleValue ( CFDefinition . Name name , ColumnGroupMap columns ) 
 - { 
 - Column c = columns . getSimple ( name . name . key ) ; 
 - return c = = null ? null : c . value ( ) ; 
 - } 
 + if ( group = = null ) 
 + { 
 + result . add ( ( ByteBuffer ) null ) ; 
 + return ; 
 + } 
 
 - private static ByteBuffer getCounterValue ( CFDefinition . Name name , ColumnGroupMap columns ) 
 - { 
 - Column c = columns . getSimple ( name . name . key ) ; 
 - return c = = null ? null : CounterColumnType . instance . decompose ( CounterContext . instance ( ) . total ( c . value ( ) ) ) ; 
 + if ( name . type . isCollection ( ) ) 
 + { 
 + List < Pair < ByteBuffer , Column > > collection = group . getCollection ( name . name . key ) ; 
 + result . add ( collection = = null ? null : ( ( CollectionType ) name . type ) . serialize ( collection ) ) ; 
 + } 
 + else 
 + { 
 + result . add ( group . getSimple ( name . name . key ) ) ; 
 + } 
 } 
 
 private static boolean isReversedType ( CFDefinition . Name name )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1a5a7b7 . . 3e3db3f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 42 , 6 + 42 , 7 @ @ 
 * ( cql3 ) Allow paging through non - ordered partitioner results ( CASSANDRA - 3771 ) 
 * ( cql3 ) Fix drop index ( CASSANDRA - 4192 ) 
 * ( cql3 ) Don ' t return range ghosts anymore ( CASSANDRA - 3982 ) 
 + * fix the problem re - creating Keyspace / ColumnFamily ( CASSANDRA - 4219 ) 
 Merged from 1 . 0 : 
 * Fix super columns bug where cache is not updated ( CASSANDRA - 4190 ) 
 * fix maxTimestamp to include row tombstones ( CASSANDRA - 4116 ) 
 diff - - git a / src / java / org / apache / cassandra / config / Schema . java b / src / java / org / apache / cassandra / config / Schema . java 
 index 245fa5f . . 9501778 100644 
 - - - a / src / java / org / apache / cassandra / config / Schema . java 
 + + + b / src / java / org / apache / cassandra / config / Schema . java 
 @ @ - 454 , 7 + 454 , 7 @ @ public class Schema 
 
 for ( Row row : SystemTable . serializedSchema ( ) ) 
 { 
 - if ( row . cf = = null | | row . cf . isMarkedForDelete ( ) | | row . cf . isEmpty ( ) ) 
 + if ( row . cf = = null | | ( row . cf . isMarkedForDelete ( ) & & row . cf . isEmpty ( ) ) ) 
 continue ; 
 
 row . cf . updateDigest ( versionDigest ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / DefsTable . java b / src / java / org / apache / cassandra / db / DefsTable . java 
 index 28ab4af . . 1b37de1 100644 
 - - - a / src / java / org / apache / cassandra / db / DefsTable . java 
 + + + b / src / java / org / apache / cassandra / db / DefsTable . java 
 @ @ - 152 , 7 + 152 , 7 @ @ public class DefsTable 
 
 for ( Row row : serializedSchema ) 
 { 
 - if ( row . cf = = null | | row . cf . isEmpty ( ) | | row . cf . isMarkedForDelete ( ) ) 
 + if ( row . cf = = null | | ( row . cf . isMarkedForDelete ( ) & & row . cf . isEmpty ( ) ) ) 
 continue ; 
 
 keyspaces . add ( KSMetaData . fromSchema ( row , serializedColumnFamilies ( row . key ) ) ) ;
