BLEU SCORE: 0.03983253478176823

TEST MSG: Create a system table to expose prepared statements
GENERATED MSG: Add a command to see if a Materialized View has finished building

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 92c6edb . . 287121a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 10 <nl> + * Create a system table to expose prepared statements ( CASSANDRA - 8831 ) <nl> * Reuse DataOutputBuffer from ColumnIndex ( CASSANDRA - 11970 ) <nl> * Remove DatabaseDescriptor dependency from SegmentedFile ( CASSANDRA - 11580 ) <nl> * Add supplied username to authentication error messages ( CASSANDRA - 12076 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index 7418f3a . . 52eee1a 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 14 , 6 + 14 , 21 @ @ restore snapshots created with the previous major version using the <nl> using the provided ' sstableupgrade ' tool . <nl> <nl> <nl> + 3 . 10 <nl> + = = = = <nl> + <nl> + New features <nl> + - - - - - - - - - - - - <nl> + - Prepared statements are now persisted in the table prepared _ statements in <nl> + the system keyspace . Upon startup , this table is used to preload all <nl> + previously prepared statements - i . e . in many cases clients do not need to <nl> + re - prepare statements against restarted nodes . <nl> + <nl> + Upgrading <nl> + - - - - - - - - - <nl> + - Nothing specific to 3 . 10 but please see previous versions upgrading section , <nl> + especially if you are upgrading from 2 . 2 . <nl> + <nl> 3 . 8 <nl> = = = <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> index 222204b . . 4e7323e 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java <nl> @ @ - 33 , 7 + 33 , 6 @ @ import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; <nl> - import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; <nl> import org . antlr . runtime . * ; <nl> import org . apache . cassandra . concurrent . ScheduledExecutors ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> @ @ - 140 , 6 + 139 , 33 @ @ public class QueryProcessor implements QueryHandler <nl> } <nl> } <nl> <nl> + public static void preloadPreparedStatement ( ) <nl> + { <nl> + ClientState clientState = ClientState . forInternalCalls ( ) ; <nl> + int count = 0 ; <nl> + for ( Pair < String , String > useKeyspaceAndCQL : SystemKeyspace . loadPreparedStatements ( ) ) <nl> + { <nl> + try <nl> + { <nl> + clientState . setKeyspace ( useKeyspaceAndCQL . left ) ; <nl> + prepare ( useKeyspaceAndCQL . right , clientState , false ) ; <nl> + count + + ; <nl> + } <nl> + catch ( RequestValidationException e ) <nl> + { <nl> + logger . warn ( " prepared statement recreation error : { } " , useKeyspaceAndCQL . right , e ) ; <nl> + } <nl> + } <nl> + logger . info ( " Preloaded { } prepared statements " , count ) ; <nl> + } <nl> + <nl> + @ VisibleForTesting <nl> + public static void clearPrepraredStatements ( ) <nl> + { <nl> + preparedStatements . clear ( ) ; <nl> + thriftPreparedStatements . clear ( ) ; <nl> + } <nl> + <nl> private static QueryState internalQueryState ( ) <nl> { <nl> return InternalStateInstance . INSTANCE . queryState ; <nl> @ @ - 446 , 6 + 472 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> queryString . substring ( 0 , 200 ) ) ) ; <nl> MD5Digest statementId = computeId ( queryString , keyspace ) ; <nl> preparedStatements . put ( statementId , prepared ) ; <nl> + SystemKeyspace . writePreparedStatement ( keyspace , statementId , queryString ) ; <nl> return new ResultMessage . Prepared ( statementId , prepared ) ; <nl> } <nl> } <nl> @ @ - 555 , 14 + 582 , 50 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> private static class MigrationSubscriber extends MigrationListener <nl> { <nl> - private void removeInvalidPreparedStatements ( String ksName , String cfName ) <nl> + private static void removeInvalidPreparedStatements ( String ksName , String cfName ) <nl> { <nl> removeInvalidPreparedStatements ( internalStatements . values ( ) . iterator ( ) , ksName , cfName ) ; <nl> - removeInvalidPreparedStatements ( preparedStatements . values ( ) . iterator ( ) , ksName , cfName ) ; <nl> + removeInvalidPersistentPreparedStatements ( preparedStatements . entrySet ( ) . iterator ( ) , ksName , cfName ) ; <nl> removeInvalidPreparedStatements ( thriftPreparedStatements . values ( ) . iterator ( ) , ksName , cfName ) ; <nl> } <nl> <nl> - private void removeInvalidPreparedStatements ( Iterator < ParsedStatement . Prepared > iterator , String ksName , String cfName ) <nl> + private static void removeInvalidPreparedStatementsForFunction ( String ksName , String functionName ) <nl> + { <nl> + Predicate < Function > matchesFunction = f - > ksName . equals ( f . name ( ) . keyspace ) & & functionName . equals ( f . name ( ) . name ) ; <nl> + <nl> + for ( Iterator < Map . Entry < MD5Digest , ParsedStatement . Prepared > > iter = preparedStatements . entrySet ( ) . iterator ( ) ; <nl> + iter . hasNext ( ) ; ) <nl> + { <nl> + Map . Entry < MD5Digest , ParsedStatement . Prepared > pstmt = iter . next ( ) ; <nl> + if ( Iterables . any ( pstmt . getValue ( ) . statement . getFunctions ( ) , matchesFunction ) ) <nl> + { <nl> + SystemKeyspace . removePreparedStatement ( pstmt . getKey ( ) ) ; <nl> + iter . remove ( ) ; <nl> + } <nl> + } <nl> + <nl> + <nl> + Iterators . removeIf ( internalStatements . values ( ) . iterator ( ) , <nl> + statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; <nl> + <nl> + Iterators . removeIf ( thriftPreparedStatements . values ( ) . iterator ( ) , <nl> + statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; <nl> + } <nl> + <nl> + private static void removeInvalidPersistentPreparedStatements ( Iterator < Map . Entry < MD5Digest , ParsedStatement . Prepared > > iterator , <nl> + String ksName , String cfName ) <nl> + { <nl> + while ( iterator . hasNext ( ) ) <nl> + { <nl> + Map . Entry < MD5Digest , ParsedStatement . Prepared > entry = iterator . next ( ) ; <nl> + if ( shouldInvalidate ( ksName , cfName , entry . getValue ( ) . statement ) ) { <nl> + SystemKeyspace . removePreparedStatement ( entry . getKey ( ) ) ; <nl> + iterator . remove ( ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + private static void removeInvalidPreparedStatements ( Iterator < ParsedStatement . Prepared > iterator , String ksName , String cfName ) <nl> { <nl> while ( iterator . hasNext ( ) ) <nl> { <nl> @ @ - 571 , 7 + 634 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> } <nl> } <nl> <nl> - private boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) <nl> + private static boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) <nl> { <nl> String statementKsName ; <nl> String statementCfName ; <nl> @ @ - 621 , 7 + 684 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> / / in case there are other overloads , we have to remove all overloads since argument type <nl> / / matching may change ( due to type casting ) <nl> if ( Schema . instance . getKSMetaData ( ksName ) . functions . get ( new FunctionName ( ksName , functionName ) ) . size ( ) > 1 ) <nl> - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> } <nl> <nl> public void onUpdateColumnFamily ( String ksName , String cfName , boolean affectsStatements ) <nl> @ @ - 637 , 7 + 700 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> / / the new definition is picked ( the function is resolved at preparation time ) . <nl> / / TODO : if the function has multiple overload , we could invalidate only the statement refering to the overload <nl> / / that was updated . This requires a few changes however and probably doesn ' t matter much in practice . <nl> - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> } <nl> <nl> public void onUpdateAggregate ( String ksName , String aggregateName , List < AbstractType < ? > > argTypes ) <nl> @ @ - 646 , 7 + 709 , 7 @ @ public class QueryProcessor implements QueryHandler <nl> / / the new definition is picked ( the function is resolved at preparation time ) . <nl> / / TODO : if the function has multiple overload , we could invalidate only the statement refering to the overload <nl> / / that was updated . This requires a few changes however and probably doesn ' t matter much in practice . <nl> - removeAllInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; <nl> + removeInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; <nl> } <nl> <nl> public void onDropKeyspace ( String ksName ) <nl> @ @ - 663 , 27 + 726 , 12 @ @ public class QueryProcessor implements QueryHandler <nl> <nl> public void onDropFunction ( String ksName , String functionName , List < AbstractType < ? > > argTypes ) <nl> { <nl> - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; <nl> } <nl> <nl> public void onDropAggregate ( String ksName , String aggregateName , List < AbstractType < ? > > argTypes ) <nl> { <nl> - removeAllInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; <nl> - } <nl> - <nl> - private static void removeAllInvalidPreparedStatementsForFunction ( String ksName , String functionName ) <nl> - { <nl> - removeInvalidPreparedStatementsForFunction ( internalStatements . values ( ) . iterator ( ) , ksName , functionName ) ; <nl> - removeInvalidPreparedStatementsForFunction ( preparedStatements . values ( ) . iterator ( ) , ksName , functionName ) ; <nl> - removeInvalidPreparedStatementsForFunction ( thriftPreparedStatements . values ( ) . iterator ( ) , ksName , functionName ) ; <nl> - } <nl> - <nl> - private static void removeInvalidPreparedStatementsForFunction ( Iterator < ParsedStatement . Prepared > statements , <nl> - final String ksName , <nl> - final String functionName ) <nl> - { <nl> - Predicate < Function > matchesFunction = f - > ksName . equals ( f . name ( ) . keyspace ) & & functionName . equals ( f . name ( ) . name ) ; <nl> - Iterators . removeIf ( statements , statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; <nl> + removeInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; <nl> } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / SystemKeyspace . java b / src / java / org / apache / cassandra / db / SystemKeyspace . java <nl> index 584279d . . 120125f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SystemKeyspace . java <nl> + + + b / src / java / org / apache / cassandra / db / SystemKeyspace . java <nl> @ @ - 97 , 6 + 97 , 7 @ @ public final class SystemKeyspace <nl> public static final String AVAILABLE _ RANGES = " available _ ranges " ; <nl> public static final String VIEWS _ BUILDS _ IN _ PROGRESS = " views _ builds _ in _ progress " ; <nl> public static final String BUILT _ VIEWS = " built _ views " ; <nl> + public static final String PREPARED _ STATEMENTS = " prepared _ statements " ; <nl> <nl> @ Deprecated public static final String LEGACY _ HINTS = " hints " ; <nl> @ Deprecated public static final String LEGACY _ BATCHLOG = " batchlog " ; <nl> @ @ - 265 , 6 + 266 , 15 @ @ public final class SystemKeyspace <nl> + " status _ replicated boolean , " <nl> + " PRIMARY KEY ( ( keyspace _ name ) , view _ name ) ) " ) ; <nl> <nl> + private static final CFMetaData PreparedStatements = <nl> + compile ( PREPARED _ STATEMENTS , <nl> + " prepared statements " , <nl> + " CREATE TABLE % s ( " <nl> + + " prepared _ id blob , " <nl> + + " logged _ keyspace text , " <nl> + + " query _ string text , " <nl> + + " PRIMARY KEY ( ( prepared _ id ) ) ) " ) ; <nl> + <nl> @ Deprecated <nl> public static final CFMetaData LegacyHints = <nl> compile ( LEGACY _ HINTS , <nl> @ @ - 435 , 6 + 445 , 7 @ @ public final class SystemKeyspace <nl> BuiltViews , <nl> LegacyHints , <nl> LegacyBatchlog , <nl> + PreparedStatements , <nl> LegacyKeyspaces , <nl> LegacyColumnfamilies , <nl> LegacyColumns , <nl> @ @ - 1412 , 4 + 1423 , 31 @ @ public final class SystemKeyspace <nl> } <nl> } <nl> <nl> + public static void writePreparedStatement ( String loggedKeyspace , MD5Digest key , String cql ) <nl> + { <nl> + executeInternal ( String . format ( " INSERT INTO % s . % s " <nl> + + " ( logged _ keyspace , prepared _ id , query _ string ) VALUES ( ? , ? , ? ) " , <nl> + NAME , PREPARED _ STATEMENTS ) , <nl> + loggedKeyspace , key . byteBuffer ( ) , cql ) ; <nl> + logger . debug ( " stored prepared statement for logged keyspace ' { } ' : ' { } ' " , loggedKeyspace , cql ) ; <nl> + } <nl> + <nl> + public static void removePreparedStatement ( MD5Digest key ) <nl> + { <nl> + executeInternal ( String . format ( " DELETE FROM % s . % s " <nl> + + " WHERE prepared _ id = ? " , <nl> + NAME , PREPARED _ STATEMENTS ) , <nl> + key . byteBuffer ( ) ) ; <nl> + } <nl> + <nl> + public static List < Pair < String , String > > loadPreparedStatements ( ) <nl> + { <nl> + String query = String . format ( " SELECT logged _ keyspace , query _ string FROM % s . % s " , NAME , PREPARED _ STATEMENTS ) ; <nl> + UntypedResultSet resultSet = executeOnceInternal ( query ) ; <nl> + List < Pair < String , String > > r = new ArrayList < > ( ) ; <nl> + for ( UntypedResultSet . Row row : resultSet ) <nl> + r . add ( Pair . create ( row . has ( " logged _ keyspace " ) ? row . getString ( " logged _ keyspace " ) : null , <nl> + row . getString ( " query _ string " ) ) ) ; <nl> + return r ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> index 2d21bff . . 0f82974 100644 <nl> - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java <nl> @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . cql3 . functions . ThreadAwareSecurityManager ; <nl> + import org . apache . cassandra . cql3 . QueryProcessor ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> @ @ - 344 , 6 + 345 , 9 @ @ public class CassandraDaemon <nl> <nl> SystemKeyspace . finishStartup ( ) ; <nl> <nl> + / / Prepared statements <nl> + QueryProcessor . preloadPreparedStatement ( ) ; <nl> + <nl> / / Metrics <nl> String metricsReporterConfigFile = System . getProperty ( " cassandra . metricsReporterConfigFile " ) ; <nl> if ( metricsReporterConfigFile ! = null ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / MD5Digest . java b / src / java / org / apache / cassandra / utils / MD5Digest . java <nl> index 2feb09e . . 4e736dc 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / MD5Digest . java <nl> + + + b / src / java / org / apache / cassandra / utils / MD5Digest . java <nl> @ @ - 17 , 6 + 17 , 7 @ @ <nl> * / <nl> package org . apache . cassandra . utils ; <nl> <nl> + import java . nio . ByteBuffer ; <nl> import java . nio . charset . StandardCharsets ; <nl> import java . util . Arrays ; <nl> <nl> @ @ - 55 , 6 + 56 , 11 @ @ public class MD5Digest <nl> return compute ( toHash . getBytes ( StandardCharsets . UTF _ 8 ) ) ; <nl> } <nl> <nl> + public ByteBuffer byteBuffer ( ) <nl> + { <nl> + return ByteBuffer . wrap ( bytes ) ; <nl> + } <nl> + <nl> @ Override <nl> public final int hashCode ( ) <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java b / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java <nl> new file mode 100644 <nl> index 0000000 . . 4ddb797 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java <nl> @ @ - 0 , 0 + 1 , 134 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 ; <nl> + <nl> + import java . net . InetSocketAddress ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> + import java . util . HashSet ; <nl> + import java . util . List ; <nl> + import java . util . Set ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import junit . framework . Assert ; <nl> + import org . apache . cassandra . cql3 . statements . ParsedStatement ; <nl> + import org . apache . cassandra . db . SystemKeyspace ; <nl> + import org . apache . cassandra . db . marshal . Int32Type ; <nl> + import org . apache . cassandra . db . marshal . IntegerType ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . schema . SchemaKeyspace ; <nl> + import org . apache . cassandra . service . ClientState ; <nl> + import org . apache . cassandra . service . QueryState ; <nl> + import org . apache . cassandra . transport . messages . ResultMessage ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . MD5Digest ; <nl> + <nl> + public class PstmtPersistenceTest extends CQLTester <nl> + { <nl> + @ Test <nl> + public void testCachedPreparedStatements ( ) throws Throwable <nl> + { <nl> + / / need this for pstmt execution / validation tests <nl> + requireNetwork ( ) ; <nl> + <nl> + int rows = QueryProcessor . executeOnceInternal ( " SELECT * FROM " + SystemKeyspace . NAME + ' . ' + SystemKeyspace . PREPARED _ STATEMENTS ) . size ( ) ; <nl> + Assert . assertEquals ( 0 , rows ) ; <nl> + <nl> + execute ( " CREATE KEYSPACE IF NOT EXISTS foo WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; <nl> + execute ( " CREATE TABLE foo . bar ( key text PRIMARY KEY , val int ) " ) ; <nl> + <nl> + ClientState clientState = ClientState . forExternalCalls ( InetSocketAddress . createUnresolved ( " 127 . 0 . 0 . 1 " , 1234 ) ) ; <nl> + <nl> + createTable ( " CREATE TABLE % s ( pk int PRIMARY KEY , val text ) " ) ; <nl> + <nl> + List < MD5Digest > stmtIds = new ArrayList < > ( ) ; <nl> + / / # 0 <nl> + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + SchemaKeyspace . NAME + ' . ' + SchemaKeyspace . TABLES + " WHERE keyspace _ name = ? " , clientState , false ) . statementId ) ; <nl> + / / # 1 <nl> + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + KEYSPACE + ' . ' + currentTable ( ) + " WHERE pk = ? " , clientState , false ) . statementId ) ; <nl> + / / # 2 <nl> + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM foo . bar WHERE key = ? " , clientState , false ) . statementId ) ; <nl> + clientState . setKeyspace ( " foo " ) ; <nl> + / / # 3 <nl> + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + KEYSPACE + ' . ' + currentTable ( ) + " WHERE pk = ? " , clientState , false ) . statementId ) ; <nl> + / / # 4 <nl> + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM foo . bar WHERE key = ? " , clientState , false ) . statementId ) ; <nl> + <nl> + Assert . assertEquals ( 5 , stmtIds . size ( ) ) ; <nl> + Assert . assertEquals ( 5 , QueryProcessor . preparedStatementsCount ( ) ) ; <nl> + <nl> + String queryAll = " SELECT * FROM " + SystemKeyspace . NAME + ' . ' + SystemKeyspace . PREPARED _ STATEMENTS ; <nl> + <nl> + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; <nl> + Assert . assertEquals ( 5 , rows ) ; <nl> + <nl> + QueryHandler handler = ClientState . getCQLQueryHandler ( ) ; <nl> + validatePstmts ( stmtIds , handler ) ; <nl> + <nl> + / / clear prepared statements cache <nl> + QueryProcessor . clearPrepraredStatements ( ) ; <nl> + Assert . assertEquals ( 0 , QueryProcessor . preparedStatementsCount ( ) ) ; <nl> + for ( MD5Digest stmtId : stmtIds ) <nl> + Assert . assertNull ( handler . getPrepared ( stmtId ) ) ; <nl> + <nl> + / / load prepared statements and validate that these still execute fine <nl> + QueryProcessor . preloadPreparedStatement ( ) ; <nl> + validatePstmts ( stmtIds , handler ) ; <nl> + <nl> + / / validate that the prepared statements are in the system table <nl> + for ( UntypedResultSet . Row row : QueryProcessor . executeOnceInternal ( queryAll ) ) <nl> + { <nl> + MD5Digest digest = MD5Digest . wrap ( ByteBufferUtil . getArray ( row . getBytes ( " prepared _ id " ) ) ) ; <nl> + ParsedStatement . Prepared prepared = QueryProcessor . instance . getPrepared ( digest ) ; <nl> + Assert . assertNotNull ( prepared ) ; <nl> + } <nl> + <nl> + / / add anther prepared statement and sync it to table <nl> + QueryProcessor . prepare ( " SELECT * FROM bar WHERE key = ? " , clientState , false ) ; <nl> + Assert . assertEquals ( 6 , QueryProcessor . preparedStatementsCount ( ) ) ; <nl> + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; <nl> + Assert . assertEquals ( 6 , rows ) ; <nl> + <nl> + / / drop a keyspace ( prepared statements are removed - syncPreparedStatements ( ) remove should the rows , too ) <nl> + execute ( " DROP KEYSPACE foo " ) ; <nl> + Assert . assertEquals ( 3 , QueryProcessor . preparedStatementsCount ( ) ) ; <nl> + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; <nl> + Assert . assertEquals ( 3 , rows ) ; <nl> + <nl> + } <nl> + <nl> + private void validatePstmts ( List < MD5Digest > stmtIds , QueryHandler handler ) <nl> + { <nl> + Assert . assertEquals ( 5 , QueryProcessor . preparedStatementsCount ( ) ) ; <nl> + QueryOptions optionsStr = QueryOptions . forInternalCalls ( Collections . singletonList ( UTF8Type . instance . fromString ( " foobar " ) ) ) ; <nl> + QueryOptions optionsInt = QueryOptions . forInternalCalls ( Collections . singletonList ( Int32Type . instance . decompose ( 42 ) ) ) ; <nl> + validatePstmt ( handler , stmtIds . get ( 0 ) , optionsStr ) ; <nl> + validatePstmt ( handler , stmtIds . get ( 1 ) , optionsInt ) ; <nl> + validatePstmt ( handler , stmtIds . get ( 2 ) , optionsStr ) ; <nl> + validatePstmt ( handler , stmtIds . get ( 3 ) , optionsInt ) ; <nl> + validatePstmt ( handler , stmtIds . get ( 4 ) , optionsStr ) ; <nl> + } <nl> + <nl> + private static void validatePstmt ( QueryHandler handler , MD5Digest stmtId , QueryOptions options ) <nl> + { <nl> + ParsedStatement . Prepared prepared = handler . getPrepared ( stmtId ) ; <nl> + Assert . assertNotNull ( prepared ) ; <nl> + handler . processPrepared ( prepared . statement , QueryState . forInternalCalls ( ) , options , Collections . emptyMap ( ) ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 92c6edb . . 287121a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 10 
 + * Create a system table to expose prepared statements ( CASSANDRA - 8831 ) 
 * Reuse DataOutputBuffer from ColumnIndex ( CASSANDRA - 11970 ) 
 * Remove DatabaseDescriptor dependency from SegmentedFile ( CASSANDRA - 11580 ) 
 * Add supplied username to authentication error messages ( CASSANDRA - 12076 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index 7418f3a . . 52eee1a 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 14 , 6 + 14 , 21 @ @ restore snapshots created with the previous major version using the 
 using the provided ' sstableupgrade ' tool . 
 
 
 + 3 . 10 
 + = = = = 
 + 
 + New features 
 + - - - - - - - - - - - - 
 + - Prepared statements are now persisted in the table prepared _ statements in 
 + the system keyspace . Upon startup , this table is used to preload all 
 + previously prepared statements - i . e . in many cases clients do not need to 
 + re - prepare statements against restarted nodes . 
 + 
 + Upgrading 
 + - - - - - - - - - 
 + - Nothing specific to 3 . 10 but please see previous versions upgrading section , 
 + especially if you are upgrading from 2 . 2 . 
 + 
 3 . 8 
 = = = 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 index 222204b . . 4e7323e 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 + + + b / src / java / org / apache / cassandra / cql3 / QueryProcessor . java 
 @ @ - 33 , 7 + 33 , 6 @ @ import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; 
 - import com . googlecode . concurrentlinkedhashmap . EntryWeigher ; 
 import org . antlr . runtime . * ; 
 import org . apache . cassandra . concurrent . ScheduledExecutors ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 @ @ - 140 , 6 + 139 , 33 @ @ public class QueryProcessor implements QueryHandler 
 } 
 } 
 
 + public static void preloadPreparedStatement ( ) 
 + { 
 + ClientState clientState = ClientState . forInternalCalls ( ) ; 
 + int count = 0 ; 
 + for ( Pair < String , String > useKeyspaceAndCQL : SystemKeyspace . loadPreparedStatements ( ) ) 
 + { 
 + try 
 + { 
 + clientState . setKeyspace ( useKeyspaceAndCQL . left ) ; 
 + prepare ( useKeyspaceAndCQL . right , clientState , false ) ; 
 + count + + ; 
 + } 
 + catch ( RequestValidationException e ) 
 + { 
 + logger . warn ( " prepared statement recreation error : { } " , useKeyspaceAndCQL . right , e ) ; 
 + } 
 + } 
 + logger . info ( " Preloaded { } prepared statements " , count ) ; 
 + } 
 + 
 + @ VisibleForTesting 
 + public static void clearPrepraredStatements ( ) 
 + { 
 + preparedStatements . clear ( ) ; 
 + thriftPreparedStatements . clear ( ) ; 
 + } 
 + 
 private static QueryState internalQueryState ( ) 
 { 
 return InternalStateInstance . INSTANCE . queryState ; 
 @ @ - 446 , 6 + 472 , 7 @ @ public class QueryProcessor implements QueryHandler 
 queryString . substring ( 0 , 200 ) ) ) ; 
 MD5Digest statementId = computeId ( queryString , keyspace ) ; 
 preparedStatements . put ( statementId , prepared ) ; 
 + SystemKeyspace . writePreparedStatement ( keyspace , statementId , queryString ) ; 
 return new ResultMessage . Prepared ( statementId , prepared ) ; 
 } 
 } 
 @ @ - 555 , 14 + 582 , 50 @ @ public class QueryProcessor implements QueryHandler 
 
 private static class MigrationSubscriber extends MigrationListener 
 { 
 - private void removeInvalidPreparedStatements ( String ksName , String cfName ) 
 + private static void removeInvalidPreparedStatements ( String ksName , String cfName ) 
 { 
 removeInvalidPreparedStatements ( internalStatements . values ( ) . iterator ( ) , ksName , cfName ) ; 
 - removeInvalidPreparedStatements ( preparedStatements . values ( ) . iterator ( ) , ksName , cfName ) ; 
 + removeInvalidPersistentPreparedStatements ( preparedStatements . entrySet ( ) . iterator ( ) , ksName , cfName ) ; 
 removeInvalidPreparedStatements ( thriftPreparedStatements . values ( ) . iterator ( ) , ksName , cfName ) ; 
 } 
 
 - private void removeInvalidPreparedStatements ( Iterator < ParsedStatement . Prepared > iterator , String ksName , String cfName ) 
 + private static void removeInvalidPreparedStatementsForFunction ( String ksName , String functionName ) 
 + { 
 + Predicate < Function > matchesFunction = f - > ksName . equals ( f . name ( ) . keyspace ) & & functionName . equals ( f . name ( ) . name ) ; 
 + 
 + for ( Iterator < Map . Entry < MD5Digest , ParsedStatement . Prepared > > iter = preparedStatements . entrySet ( ) . iterator ( ) ; 
 + iter . hasNext ( ) ; ) 
 + { 
 + Map . Entry < MD5Digest , ParsedStatement . Prepared > pstmt = iter . next ( ) ; 
 + if ( Iterables . any ( pstmt . getValue ( ) . statement . getFunctions ( ) , matchesFunction ) ) 
 + { 
 + SystemKeyspace . removePreparedStatement ( pstmt . getKey ( ) ) ; 
 + iter . remove ( ) ; 
 + } 
 + } 
 + 
 + 
 + Iterators . removeIf ( internalStatements . values ( ) . iterator ( ) , 
 + statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; 
 + 
 + Iterators . removeIf ( thriftPreparedStatements . values ( ) . iterator ( ) , 
 + statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; 
 + } 
 + 
 + private static void removeInvalidPersistentPreparedStatements ( Iterator < Map . Entry < MD5Digest , ParsedStatement . Prepared > > iterator , 
 + String ksName , String cfName ) 
 + { 
 + while ( iterator . hasNext ( ) ) 
 + { 
 + Map . Entry < MD5Digest , ParsedStatement . Prepared > entry = iterator . next ( ) ; 
 + if ( shouldInvalidate ( ksName , cfName , entry . getValue ( ) . statement ) ) { 
 + SystemKeyspace . removePreparedStatement ( entry . getKey ( ) ) ; 
 + iterator . remove ( ) ; 
 + } 
 + } 
 + } 
 + 
 + private static void removeInvalidPreparedStatements ( Iterator < ParsedStatement . Prepared > iterator , String ksName , String cfName ) 
 { 
 while ( iterator . hasNext ( ) ) 
 { 
 @ @ - 571 , 7 + 634 , 7 @ @ public class QueryProcessor implements QueryHandler 
 } 
 } 
 
 - private boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) 
 + private static boolean shouldInvalidate ( String ksName , String cfName , CQLStatement statement ) 
 { 
 String statementKsName ; 
 String statementCfName ; 
 @ @ - 621 , 7 + 684 , 7 @ @ public class QueryProcessor implements QueryHandler 
 / / in case there are other overloads , we have to remove all overloads since argument type 
 / / matching may change ( due to type casting ) 
 if ( Schema . instance . getKSMetaData ( ksName ) . functions . get ( new FunctionName ( ksName , functionName ) ) . size ( ) > 1 ) 
 - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 } 
 
 public void onUpdateColumnFamily ( String ksName , String cfName , boolean affectsStatements ) 
 @ @ - 637 , 7 + 700 , 7 @ @ public class QueryProcessor implements QueryHandler 
 / / the new definition is picked ( the function is resolved at preparation time ) . 
 / / TODO : if the function has multiple overload , we could invalidate only the statement refering to the overload 
 / / that was updated . This requires a few changes however and probably doesn ' t matter much in practice . 
 - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 } 
 
 public void onUpdateAggregate ( String ksName , String aggregateName , List < AbstractType < ? > > argTypes ) 
 @ @ - 646 , 7 + 709 , 7 @ @ public class QueryProcessor implements QueryHandler 
 / / the new definition is picked ( the function is resolved at preparation time ) . 
 / / TODO : if the function has multiple overload , we could invalidate only the statement refering to the overload 
 / / that was updated . This requires a few changes however and probably doesn ' t matter much in practice . 
 - removeAllInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; 
 + removeInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; 
 } 
 
 public void onDropKeyspace ( String ksName ) 
 @ @ - 663 , 27 + 726 , 12 @ @ public class QueryProcessor implements QueryHandler 
 
 public void onDropFunction ( String ksName , String functionName , List < AbstractType < ? > > argTypes ) 
 { 
 - removeAllInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 + removeInvalidPreparedStatementsForFunction ( ksName , functionName ) ; 
 } 
 
 public void onDropAggregate ( String ksName , String aggregateName , List < AbstractType < ? > > argTypes ) 
 { 
 - removeAllInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; 
 - } 
 - 
 - private static void removeAllInvalidPreparedStatementsForFunction ( String ksName , String functionName ) 
 - { 
 - removeInvalidPreparedStatementsForFunction ( internalStatements . values ( ) . iterator ( ) , ksName , functionName ) ; 
 - removeInvalidPreparedStatementsForFunction ( preparedStatements . values ( ) . iterator ( ) , ksName , functionName ) ; 
 - removeInvalidPreparedStatementsForFunction ( thriftPreparedStatements . values ( ) . iterator ( ) , ksName , functionName ) ; 
 - } 
 - 
 - private static void removeInvalidPreparedStatementsForFunction ( Iterator < ParsedStatement . Prepared > statements , 
 - final String ksName , 
 - final String functionName ) 
 - { 
 - Predicate < Function > matchesFunction = f - > ksName . equals ( f . name ( ) . keyspace ) & & functionName . equals ( f . name ( ) . name ) ; 
 - Iterators . removeIf ( statements , statement - > Iterables . any ( statement . statement . getFunctions ( ) , matchesFunction ) ) ; 
 + removeInvalidPreparedStatementsForFunction ( ksName , aggregateName ) ; 
 } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / SystemKeyspace . java b / src / java / org / apache / cassandra / db / SystemKeyspace . java 
 index 584279d . . 120125f 100644 
 - - - a / src / java / org / apache / cassandra / db / SystemKeyspace . java 
 + + + b / src / java / org / apache / cassandra / db / SystemKeyspace . java 
 @ @ - 97 , 6 + 97 , 7 @ @ public final class SystemKeyspace 
 public static final String AVAILABLE _ RANGES = " available _ ranges " ; 
 public static final String VIEWS _ BUILDS _ IN _ PROGRESS = " views _ builds _ in _ progress " ; 
 public static final String BUILT _ VIEWS = " built _ views " ; 
 + public static final String PREPARED _ STATEMENTS = " prepared _ statements " ; 
 
 @ Deprecated public static final String LEGACY _ HINTS = " hints " ; 
 @ Deprecated public static final String LEGACY _ BATCHLOG = " batchlog " ; 
 @ @ - 265 , 6 + 266 , 15 @ @ public final class SystemKeyspace 
 + " status _ replicated boolean , " 
 + " PRIMARY KEY ( ( keyspace _ name ) , view _ name ) ) " ) ; 
 
 + private static final CFMetaData PreparedStatements = 
 + compile ( PREPARED _ STATEMENTS , 
 + " prepared statements " , 
 + " CREATE TABLE % s ( " 
 + + " prepared _ id blob , " 
 + + " logged _ keyspace text , " 
 + + " query _ string text , " 
 + + " PRIMARY KEY ( ( prepared _ id ) ) ) " ) ; 
 + 
 @ Deprecated 
 public static final CFMetaData LegacyHints = 
 compile ( LEGACY _ HINTS , 
 @ @ - 435 , 6 + 445 , 7 @ @ public final class SystemKeyspace 
 BuiltViews , 
 LegacyHints , 
 LegacyBatchlog , 
 + PreparedStatements , 
 LegacyKeyspaces , 
 LegacyColumnfamilies , 
 LegacyColumns , 
 @ @ - 1412 , 4 + 1423 , 31 @ @ public final class SystemKeyspace 
 } 
 } 
 
 + public static void writePreparedStatement ( String loggedKeyspace , MD5Digest key , String cql ) 
 + { 
 + executeInternal ( String . format ( " INSERT INTO % s . % s " 
 + + " ( logged _ keyspace , prepared _ id , query _ string ) VALUES ( ? , ? , ? ) " , 
 + NAME , PREPARED _ STATEMENTS ) , 
 + loggedKeyspace , key . byteBuffer ( ) , cql ) ; 
 + logger . debug ( " stored prepared statement for logged keyspace ' { } ' : ' { } ' " , loggedKeyspace , cql ) ; 
 + } 
 + 
 + public static void removePreparedStatement ( MD5Digest key ) 
 + { 
 + executeInternal ( String . format ( " DELETE FROM % s . % s " 
 + + " WHERE prepared _ id = ? " , 
 + NAME , PREPARED _ STATEMENTS ) , 
 + key . byteBuffer ( ) ) ; 
 + } 
 + 
 + public static List < Pair < String , String > > loadPreparedStatements ( ) 
 + { 
 + String query = String . format ( " SELECT logged _ keyspace , query _ string FROM % s . % s " , NAME , PREPARED _ STATEMENTS ) ; 
 + UntypedResultSet resultSet = executeOnceInternal ( query ) ; 
 + List < Pair < String , String > > r = new ArrayList < > ( ) ; 
 + for ( UntypedResultSet . Row row : resultSet ) 
 + r . add ( Pair . create ( row . has ( " logged _ keyspace " ) ? row . getString ( " logged _ keyspace " ) : null , 
 + row . getString ( " query _ string " ) ) ) ; 
 + return r ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / CassandraDaemon . java b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 index 2d21bff . . 0f82974 100644 
 - - - a / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 + + + b / src / java / org / apache / cassandra / service / CassandraDaemon . java 
 @ @ - 48 , 6 + 48 , 7 @ @ import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . cql3 . functions . ThreadAwareSecurityManager ; 
 + import org . apache . cassandra . cql3 . QueryProcessor ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 @ @ - 344 , 6 + 345 , 9 @ @ public class CassandraDaemon 
 
 SystemKeyspace . finishStartup ( ) ; 
 
 + / / Prepared statements 
 + QueryProcessor . preloadPreparedStatement ( ) ; 
 + 
 / / Metrics 
 String metricsReporterConfigFile = System . getProperty ( " cassandra . metricsReporterConfigFile " ) ; 
 if ( metricsReporterConfigFile ! = null ) 
 diff - - git a / src / java / org / apache / cassandra / utils / MD5Digest . java b / src / java / org / apache / cassandra / utils / MD5Digest . java 
 index 2feb09e . . 4e736dc 100644 
 - - - a / src / java / org / apache / cassandra / utils / MD5Digest . java 
 + + + b / src / java / org / apache / cassandra / utils / MD5Digest . java 
 @ @ - 17 , 6 + 17 , 7 @ @ 
 * / 
 package org . apache . cassandra . utils ; 
 
 + import java . nio . ByteBuffer ; 
 import java . nio . charset . StandardCharsets ; 
 import java . util . Arrays ; 
 
 @ @ - 55 , 6 + 56 , 11 @ @ public class MD5Digest 
 return compute ( toHash . getBytes ( StandardCharsets . UTF _ 8 ) ) ; 
 } 
 
 + public ByteBuffer byteBuffer ( ) 
 + { 
 + return ByteBuffer . wrap ( bytes ) ; 
 + } 
 + 
 @ Override 
 public final int hashCode ( ) 
 { 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java b / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java 
 new file mode 100644 
 index 0000000 . . 4ddb797 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / cql3 / PstmtPersistenceTest . java 
 @ @ - 0 , 0 + 1 , 134 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 ; 
 + 
 + import java . net . InetSocketAddress ; 
 + import java . util . ArrayList ; 
 + import java . util . Collections ; 
 + import java . util . HashSet ; 
 + import java . util . List ; 
 + import java . util . Set ; 
 + 
 + import org . junit . Test ; 
 + 
 + import junit . framework . Assert ; 
 + import org . apache . cassandra . cql3 . statements . ParsedStatement ; 
 + import org . apache . cassandra . db . SystemKeyspace ; 
 + import org . apache . cassandra . db . marshal . Int32Type ; 
 + import org . apache . cassandra . db . marshal . IntegerType ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . schema . SchemaKeyspace ; 
 + import org . apache . cassandra . service . ClientState ; 
 + import org . apache . cassandra . service . QueryState ; 
 + import org . apache . cassandra . transport . messages . ResultMessage ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . MD5Digest ; 
 + 
 + public class PstmtPersistenceTest extends CQLTester 
 + { 
 + @ Test 
 + public void testCachedPreparedStatements ( ) throws Throwable 
 + { 
 + / / need this for pstmt execution / validation tests 
 + requireNetwork ( ) ; 
 + 
 + int rows = QueryProcessor . executeOnceInternal ( " SELECT * FROM " + SystemKeyspace . NAME + ' . ' + SystemKeyspace . PREPARED _ STATEMENTS ) . size ( ) ; 
 + Assert . assertEquals ( 0 , rows ) ; 
 + 
 + execute ( " CREATE KEYSPACE IF NOT EXISTS foo WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : ' 1 ' } " ) ; 
 + execute ( " CREATE TABLE foo . bar ( key text PRIMARY KEY , val int ) " ) ; 
 + 
 + ClientState clientState = ClientState . forExternalCalls ( InetSocketAddress . createUnresolved ( " 127 . 0 . 0 . 1 " , 1234 ) ) ; 
 + 
 + createTable ( " CREATE TABLE % s ( pk int PRIMARY KEY , val text ) " ) ; 
 + 
 + List < MD5Digest > stmtIds = new ArrayList < > ( ) ; 
 + / / # 0 
 + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + SchemaKeyspace . NAME + ' . ' + SchemaKeyspace . TABLES + " WHERE keyspace _ name = ? " , clientState , false ) . statementId ) ; 
 + / / # 1 
 + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + KEYSPACE + ' . ' + currentTable ( ) + " WHERE pk = ? " , clientState , false ) . statementId ) ; 
 + / / # 2 
 + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM foo . bar WHERE key = ? " , clientState , false ) . statementId ) ; 
 + clientState . setKeyspace ( " foo " ) ; 
 + / / # 3 
 + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM " + KEYSPACE + ' . ' + currentTable ( ) + " WHERE pk = ? " , clientState , false ) . statementId ) ; 
 + / / # 4 
 + stmtIds . add ( QueryProcessor . prepare ( " SELECT * FROM foo . bar WHERE key = ? " , clientState , false ) . statementId ) ; 
 + 
 + Assert . assertEquals ( 5 , stmtIds . size ( ) ) ; 
 + Assert . assertEquals ( 5 , QueryProcessor . preparedStatementsCount ( ) ) ; 
 + 
 + String queryAll = " SELECT * FROM " + SystemKeyspace . NAME + ' . ' + SystemKeyspace . PREPARED _ STATEMENTS ; 
 + 
 + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; 
 + Assert . assertEquals ( 5 , rows ) ; 
 + 
 + QueryHandler handler = ClientState . getCQLQueryHandler ( ) ; 
 + validatePstmts ( stmtIds , handler ) ; 
 + 
 + / / clear prepared statements cache 
 + QueryProcessor . clearPrepraredStatements ( ) ; 
 + Assert . assertEquals ( 0 , QueryProcessor . preparedStatementsCount ( ) ) ; 
 + for ( MD5Digest stmtId : stmtIds ) 
 + Assert . assertNull ( handler . getPrepared ( stmtId ) ) ; 
 + 
 + / / load prepared statements and validate that these still execute fine 
 + QueryProcessor . preloadPreparedStatement ( ) ; 
 + validatePstmts ( stmtIds , handler ) ; 
 + 
 + / / validate that the prepared statements are in the system table 
 + for ( UntypedResultSet . Row row : QueryProcessor . executeOnceInternal ( queryAll ) ) 
 + { 
 + MD5Digest digest = MD5Digest . wrap ( ByteBufferUtil . getArray ( row . getBytes ( " prepared _ id " ) ) ) ; 
 + ParsedStatement . Prepared prepared = QueryProcessor . instance . getPrepared ( digest ) ; 
 + Assert . assertNotNull ( prepared ) ; 
 + } 
 + 
 + / / add anther prepared statement and sync it to table 
 + QueryProcessor . prepare ( " SELECT * FROM bar WHERE key = ? " , clientState , false ) ; 
 + Assert . assertEquals ( 6 , QueryProcessor . preparedStatementsCount ( ) ) ; 
 + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; 
 + Assert . assertEquals ( 6 , rows ) ; 
 + 
 + / / drop a keyspace ( prepared statements are removed - syncPreparedStatements ( ) remove should the rows , too ) 
 + execute ( " DROP KEYSPACE foo " ) ; 
 + Assert . assertEquals ( 3 , QueryProcessor . preparedStatementsCount ( ) ) ; 
 + rows = QueryProcessor . executeOnceInternal ( queryAll ) . size ( ) ; 
 + Assert . assertEquals ( 3 , rows ) ; 
 + 
 + } 
 + 
 + private void validatePstmts ( List < MD5Digest > stmtIds , QueryHandler handler ) 
 + { 
 + Assert . assertEquals ( 5 , QueryProcessor . preparedStatementsCount ( ) ) ; 
 + QueryOptions optionsStr = QueryOptions . forInternalCalls ( Collections . singletonList ( UTF8Type . instance . fromString ( " foobar " ) ) ) ; 
 + QueryOptions optionsInt = QueryOptions . forInternalCalls ( Collections . singletonList ( Int32Type . instance . decompose ( 42 ) ) ) ; 
 + validatePstmt ( handler , stmtIds . get ( 0 ) , optionsStr ) ; 
 + validatePstmt ( handler , stmtIds . get ( 1 ) , optionsInt ) ; 
 + validatePstmt ( handler , stmtIds . get ( 2 ) , optionsStr ) ; 
 + validatePstmt ( handler , stmtIds . get ( 3 ) , optionsInt ) ; 
 + validatePstmt ( handler , stmtIds . get ( 4 ) , optionsStr ) ; 
 + } 
 + 
 + private static void validatePstmt ( QueryHandler handler , MD5Digest stmtId , QueryOptions options ) 
 + { 
 + ParsedStatement . Prepared prepared = handler . getPrepared ( stmtId ) ; 
 + Assert . assertNotNull ( prepared ) ; 
 + handler . processPrepared ( prepared . statement , QueryState . forInternalCalls ( ) , options , Collections . emptyMap ( ) ) ; 
 + } 
 + }

NEAREST DIFF:
ELIMINATEDSENTENCE
