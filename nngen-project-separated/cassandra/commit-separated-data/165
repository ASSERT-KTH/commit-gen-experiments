BLEU SCORE: 0.06870636427700047

TEST MSG: Add coordinator write metric per CF
GENERATED MSG: Add additional statistics for speculative retry .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index daafa0a . . 5763720 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Add coordinator write metric per CF ( CASSANDRA - 14232 ) <nl> * Fix scheduling of speculative retry threshold recalculation ( CASSANDRA - 14338 ) <nl> * Add support for hybrid MIN ( ) , MAX ( ) speculative retry policies ( CASSANDRA - 14293 ) <nl> * Correct and clarify SSLFactory . getSslContext method and call sites ( CASSANDRA - 14314 ) <nl> diff - - git a / NEWS . txt b / NEWS . txt <nl> index bcac4ea . . f8e3ca6 100644 <nl> - - - a / NEWS . txt <nl> + + + b / NEWS . txt <nl> @ @ - 68 , 6 + 68 , 7 @ @ New features <nl> See nodetool and fqltool help text for more information . <nl> - SSTableDump now supports the - l option to output each partition as it ' s own json object <nl> See CASSANDRA - 13848 for more detail <nl> + - Metric for coordinator writes per table has been added . See CASSANDRA - 14232 <nl> <nl> Upgrading <nl> - - - - - - - - - <nl> diff - - git a / doc / source / operating / metrics . rst b / doc / source / operating / metrics . rst <nl> index 345fc3e . . 325395c 100644 <nl> - - - a / doc / source / operating / metrics . rst <nl> + + + b / doc / source / operating / metrics . rst <nl> @ @ - 95 , 6 + 95 , 7 @ @ ReadLatency Latency Local read latency for th <nl> RangeLatency Latency Local range scan latency for this table . <nl> WriteLatency Latency Local write latency for this table . <nl> CoordinatorReadLatency Timer Coordinator read latency for this table . <nl> + CoordinatorWriteLatency Timer Coordinator write latency for this table . <nl> CoordinatorScanLatency Timer Coordinator range scan latency for this table . <nl> PendingFlushes Counter Estimated number of flush tasks pending for this table . <nl> BytesFlushed Counter Total number of bytes flushed since server [ re ] start . <nl> diff - - git a / src / java / org / apache / cassandra / metrics / TableMetrics . java b / src / java / org / apache / cassandra / metrics / TableMetrics . java <nl> index 7ce2f16 . . d8cb18e 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / TableMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / TableMetrics . java <nl> @ @ - 184 , 6 + 184 , 7 @ @ public class TableMetrics <nl> <nl> public final Timer coordinatorReadLatency ; <nl> public final Timer coordinatorScanLatency ; <nl> + public final Timer coordinatorWriteLatency ; <nl> <nl> / * * Time spent waiting for free memtable space , either on - or off - heap * / <nl> public final Histogram waitingOnFreeMemtableSpace ; <nl> @ @ - 791 , 6 + 792 , 7 @ @ public class TableMetrics <nl> colUpdateTimeDeltaHistogram = createTableHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram , false ) ; <nl> coordinatorReadLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorReadLatency " ) ) ; <nl> coordinatorScanLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorScanLatency " ) ) ; <nl> + coordinatorWriteLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorWriteLatency " ) ) ; <nl> waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , false ) ; <nl> <nl> / / We do not want to capture view mutation specific metrics for a view <nl> @ @ - 880 , 6 + 882 , 7 @ @ public class TableMetrics <nl> Metrics . remove ( factory . createMetricName ( " KeyCacheHitRate " ) , aliasFactory . createMetricName ( " KeyCacheHitRate " ) ) ; <nl> Metrics . remove ( factory . createMetricName ( " CoordinatorReadLatency " ) , aliasFactory . createMetricName ( " CoordinatorReadLatency " ) ) ; <nl> Metrics . remove ( factory . createMetricName ( " CoordinatorScanLatency " ) , aliasFactory . createMetricName ( " CoordinatorScanLatency " ) ) ; <nl> + Metrics . remove ( factory . createMetricName ( " CoordinatorWriteLatency " ) , aliasFactory . createMetricName ( " CoordinatorWriteLatency " ) ) ; <nl> Metrics . remove ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , aliasFactory . createMetricName ( " WaitingOnFreeMemtableSpace " ) ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index a47c4c6 . . bacc3a8 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 757 , 6 + 757 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> long latency = System . nanoTime ( ) - startTime ; <nl> writeMetrics . addNano ( latency ) ; <nl> writeMetricsMap . get ( consistency _ level ) . addNano ( latency ) ; <nl> + updateCoordinatorWriteLatencyTableMetric ( mutations , latency ) ; <nl> } <nl> } <nl> <nl> @ @ - 1030 , 7 + 1031 , 7 @ @ public class StorageProxy implements StorageProxyMBean <nl> long latency = System . nanoTime ( ) - startTime ; <nl> writeMetrics . addNano ( latency ) ; <nl> writeMetricsMap . get ( consistency _ level ) . addNano ( latency ) ; <nl> - <nl> + updateCoordinatorWriteLatencyTableMetric ( mutations , latency ) ; <nl> } <nl> } <nl> <nl> @ @ - 1039 , 6 + 1040 , 30 @ @ public class StorageProxy implements StorageProxyMBean <nl> return replica . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ; <nl> } <nl> <nl> + private static void updateCoordinatorWriteLatencyTableMetric ( Collection < ? extends IMutation > mutations , long latency ) <nl> + { <nl> + if ( null = = mutations ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / TODO : Avoid giving same latency number for each CF in each mutation in a given set of mutations <nl> + / / We could potentially pass a callback into performWrite . And add callback provision for mutateCounter or mutateAtomically ( sendToHintedEndPoints ) <nl> + / / However , Trade off between write metric per CF accuracy vs performance hit due to callbacks . Similar issue exists with CoordinatorReadLatency metric . <nl> + mutations . forEach ( mutation - > { <nl> + mutation . getTableIds ( ) . forEach ( tableId - > { <nl> + Keyspace . open ( mutation . getKeyspaceName ( ) ) . getColumnFamilyStore ( tableId ) . metric . coordinatorWriteLatency . update ( latency , TimeUnit . NANOSECONDS ) ; <nl> + } ) ; <nl> + } ) ; <nl> + } <nl> + catch ( Exception ex ) <nl> + { <nl> + logger . warn ( " Exception occurred updating coordinatorWriteLatency metric " , ex ) ; <nl> + } <nl> + } <nl> + <nl> private static void syncWriteToBatchlog ( Collection < Mutation > mutations , Collection < InetAddressAndPort > endpoints , UUID uuid , long queryStartNanoTime ) <nl> throws WriteTimeoutException , WriteFailureException <nl> { <nl> diff - - git a / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java b / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java <nl> new file mode 100644 <nl> index 0000000 . . a3ae956 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java <nl> @ @ - 0 , 0 + 1 , 176 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . metrics ; <nl> + <nl> + import java . io . IOException ; <nl> + <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + import org . junit . runner . RunWith ; <nl> + <nl> + import com . datastax . driver . core . BatchStatement ; <nl> + import com . datastax . driver . core . Cluster ; <nl> + import com . datastax . driver . core . PreparedStatement ; <nl> + import com . datastax . driver . core . Session ; <nl> + import org . apache . cassandra . OrderedJUnit4ClassRunner ; <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . schema . Schema ; <nl> + import org . apache . cassandra . service . EmbeddedCassandraService ; <nl> + <nl> + import static junit . framework . Assert . assertEquals ; <nl> + import static junit . framework . Assert . assertTrue ; <nl> + <nl> + @ RunWith ( OrderedJUnit4ClassRunner . class ) <nl> + public class TableMetricsTest extends SchemaLoader <nl> + { <nl> + <nl> + private static Session session ; <nl> + <nl> + private static final String KEYSPACE = " junit " ; <nl> + private static final String TABLE = " tablemetricstest " ; <nl> + private static final String COUNTER _ TABLE = " tablemetricscountertest " ; <nl> + <nl> + @ BeforeClass ( ) <nl> + public static void setup ( ) throws ConfigurationException , IOException <nl> + { <nl> + Schema . instance . clear ( ) ; <nl> + <nl> + EmbeddedCassandraService cassandra = new EmbeddedCassandraService ( ) ; <nl> + cassandra . start ( ) ; <nl> + <nl> + Cluster cluster = Cluster . builder ( ) . addContactPoint ( " 127 . 0 . 0 . 1 " ) . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; <nl> + session = cluster . connect ( ) ; <nl> + <nl> + session . execute ( String . format ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " , KEYSPACE ) ) ; <nl> + session . execute ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( id _ c counter , id int , val text , PRIMARY KEY ( id , val ) ) ; " , KEYSPACE , COUNTER _ TABLE ) ) ; <nl> + } <nl> + <nl> + private ColumnFamilyStore recreateTable ( ) <nl> + { <nl> + session . execute ( String . format ( " DROP TABLE IF EXISTS % s . % s " , KEYSPACE , TABLE ) ) ; <nl> + session . execute ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( id int , val1 text , val2 text , PRIMARY KEY ( id , val1 ) ) ; " , KEYSPACE , TABLE ) ) ; <nl> + return ColumnFamilyStore . getIfExists ( KEYSPACE , TABLE ) ; <nl> + } <nl> + <nl> + private void executeBatch ( boolean isLogged , int distinctPartitions , int statementsPerPartition ) <nl> + { <nl> + BatchStatement . Type batchType ; <nl> + PreparedStatement ps = session . prepare ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( ? , ? , ? ) ; " , KEYSPACE , TABLE ) ) ; <nl> + <nl> + if ( isLogged ) <nl> + { <nl> + batchType = BatchStatement . Type . LOGGED ; <nl> + } <nl> + else <nl> + { <nl> + batchType = BatchStatement . Type . UNLOGGED ; <nl> + } <nl> + <nl> + BatchStatement batch = new BatchStatement ( batchType ) ; <nl> + <nl> + for ( int i = 0 ; i < distinctPartitions ; i + + ) <nl> + { <nl> + for ( int j = 0 ; j < statementsPerPartition ; j + + ) <nl> + { <nl> + batch . add ( ps . bind ( i , j + " a " , " b " ) ) ; <nl> + } <nl> + } <nl> + <nl> + session . execute ( batch ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testRegularStatementsExecuted ( ) <nl> + { <nl> + ColumnFamilyStore cfs = recreateTable ( ) ; <nl> + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; <nl> + <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + session . execute ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( % d , ' % s ' , ' % s ' ) " , KEYSPACE , TABLE , i , " val " + i , " val " + i ) ) ; <nl> + } <nl> + <nl> + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testPreparedStatementsExecuted ( ) <nl> + { <nl> + ColumnFamilyStore cfs = recreateTable ( ) ; <nl> + PreparedStatement metricsStatement = session . prepare ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( ? , ? , ? ) " , KEYSPACE , TABLE ) ) ; <nl> + <nl> + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; <nl> + <nl> + for ( int i = 0 ; i < 10 ; i + + ) <nl> + { <nl> + session . execute ( metricsStatement . bind ( i , " val " + i , " val " + i ) ) ; <nl> + } <nl> + <nl> + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testLoggedPartitionsPerBatch ( ) <nl> + { <nl> + ColumnFamilyStore cfs = recreateTable ( ) ; <nl> + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; <nl> + <nl> + executeBatch ( true , 10 , 2 ) ; <nl> + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + <nl> + executeBatch ( true , 20 , 2 ) ; <nl> + assertEquals ( 30 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void testUnloggedPartitionsPerBatch ( ) <nl> + { <nl> + ColumnFamilyStore cfs = recreateTable ( ) ; <nl> + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; <nl> + <nl> + executeBatch ( false , 5 , 3 ) ; <nl> + assertEquals ( 5 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + <nl> + executeBatch ( false , 25 , 2 ) ; <nl> + assertEquals ( 30 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; <nl> + <nl> + } <nl> + <nl> + @ Test <nl> + public void testCounterStatement ( ) <nl> + { <nl> + ColumnFamilyStore cfs = ColumnFamilyStore . getIfExists ( KEYSPACE , COUNTER _ TABLE ) ; <nl> + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; <nl> + session . execute ( String . format ( " UPDATE % s . % s SET id _ c = id _ c + 1 WHERE id = 1 AND val = ' val1 ' " , KEYSPACE , COUNTER _ TABLE ) ) ; <nl> + assertEquals ( 1 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; <nl> + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; <nl> + } <nl> + } <nl> \ No newline at end of file
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index daafa0a . . 5763720 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Add coordinator write metric per CF ( CASSANDRA - 14232 ) 
 * Fix scheduling of speculative retry threshold recalculation ( CASSANDRA - 14338 ) 
 * Add support for hybrid MIN ( ) , MAX ( ) speculative retry policies ( CASSANDRA - 14293 ) 
 * Correct and clarify SSLFactory . getSslContext method and call sites ( CASSANDRA - 14314 ) 
 diff - - git a / NEWS . txt b / NEWS . txt 
 index bcac4ea . . f8e3ca6 100644 
 - - - a / NEWS . txt 
 + + + b / NEWS . txt 
 @ @ - 68 , 6 + 68 , 7 @ @ New features 
 See nodetool and fqltool help text for more information . 
 - SSTableDump now supports the - l option to output each partition as it ' s own json object 
 See CASSANDRA - 13848 for more detail 
 + - Metric for coordinator writes per table has been added . See CASSANDRA - 14232 
 
 Upgrading 
 - - - - - - - - - 
 diff - - git a / doc / source / operating / metrics . rst b / doc / source / operating / metrics . rst 
 index 345fc3e . . 325395c 100644 
 - - - a / doc / source / operating / metrics . rst 
 + + + b / doc / source / operating / metrics . rst 
 @ @ - 95 , 6 + 95 , 7 @ @ ReadLatency Latency Local read latency for th 
 RangeLatency Latency Local range scan latency for this table . 
 WriteLatency Latency Local write latency for this table . 
 CoordinatorReadLatency Timer Coordinator read latency for this table . 
 + CoordinatorWriteLatency Timer Coordinator write latency for this table . 
 CoordinatorScanLatency Timer Coordinator range scan latency for this table . 
 PendingFlushes Counter Estimated number of flush tasks pending for this table . 
 BytesFlushed Counter Total number of bytes flushed since server [ re ] start . 
 diff - - git a / src / java / org / apache / cassandra / metrics / TableMetrics . java b / src / java / org / apache / cassandra / metrics / TableMetrics . java 
 index 7ce2f16 . . d8cb18e 100644 
 - - - a / src / java / org / apache / cassandra / metrics / TableMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / TableMetrics . java 
 @ @ - 184 , 6 + 184 , 7 @ @ public class TableMetrics 
 
 public final Timer coordinatorReadLatency ; 
 public final Timer coordinatorScanLatency ; 
 + public final Timer coordinatorWriteLatency ; 
 
 / * * Time spent waiting for free memtable space , either on - or off - heap * / 
 public final Histogram waitingOnFreeMemtableSpace ; 
 @ @ - 791 , 6 + 792 , 7 @ @ public class TableMetrics 
 colUpdateTimeDeltaHistogram = createTableHistogram ( " ColUpdateTimeDeltaHistogram " , cfs . keyspace . metric . colUpdateTimeDeltaHistogram , false ) ; 
 coordinatorReadLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorReadLatency " ) ) ; 
 coordinatorScanLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorScanLatency " ) ) ; 
 + coordinatorWriteLatency = Metrics . timer ( factory . createMetricName ( " CoordinatorWriteLatency " ) ) ; 
 waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , false ) ; 
 
 / / We do not want to capture view mutation specific metrics for a view 
 @ @ - 880 , 6 + 882 , 7 @ @ public class TableMetrics 
 Metrics . remove ( factory . createMetricName ( " KeyCacheHitRate " ) , aliasFactory . createMetricName ( " KeyCacheHitRate " ) ) ; 
 Metrics . remove ( factory . createMetricName ( " CoordinatorReadLatency " ) , aliasFactory . createMetricName ( " CoordinatorReadLatency " ) ) ; 
 Metrics . remove ( factory . createMetricName ( " CoordinatorScanLatency " ) , aliasFactory . createMetricName ( " CoordinatorScanLatency " ) ) ; 
 + Metrics . remove ( factory . createMetricName ( " CoordinatorWriteLatency " ) , aliasFactory . createMetricName ( " CoordinatorWriteLatency " ) ) ; 
 Metrics . remove ( factory . createMetricName ( " WaitingOnFreeMemtableSpace " ) , aliasFactory . createMetricName ( " WaitingOnFreeMemtableSpace " ) ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index a47c4c6 . . bacc3a8 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 757 , 6 + 757 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 long latency = System . nanoTime ( ) - startTime ; 
 writeMetrics . addNano ( latency ) ; 
 writeMetricsMap . get ( consistency _ level ) . addNano ( latency ) ; 
 + updateCoordinatorWriteLatencyTableMetric ( mutations , latency ) ; 
 } 
 } 
 
 @ @ - 1030 , 7 + 1031 , 7 @ @ public class StorageProxy implements StorageProxyMBean 
 long latency = System . nanoTime ( ) - startTime ; 
 writeMetrics . addNano ( latency ) ; 
 writeMetricsMap . get ( consistency _ level ) . addNano ( latency ) ; 
 - 
 + updateCoordinatorWriteLatencyTableMetric ( mutations , latency ) ; 
 } 
 } 
 
 @ @ - 1039 , 6 + 1040 , 30 @ @ public class StorageProxy implements StorageProxyMBean 
 return replica . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ; 
 } 
 
 + private static void updateCoordinatorWriteLatencyTableMetric ( Collection < ? extends IMutation > mutations , long latency ) 
 + { 
 + if ( null = = mutations ) 
 + { 
 + return ; 
 + } 
 + 
 + try 
 + { 
 + / / TODO : Avoid giving same latency number for each CF in each mutation in a given set of mutations 
 + / / We could potentially pass a callback into performWrite . And add callback provision for mutateCounter or mutateAtomically ( sendToHintedEndPoints ) 
 + / / However , Trade off between write metric per CF accuracy vs performance hit due to callbacks . Similar issue exists with CoordinatorReadLatency metric . 
 + mutations . forEach ( mutation - > { 
 + mutation . getTableIds ( ) . forEach ( tableId - > { 
 + Keyspace . open ( mutation . getKeyspaceName ( ) ) . getColumnFamilyStore ( tableId ) . metric . coordinatorWriteLatency . update ( latency , TimeUnit . NANOSECONDS ) ; 
 + } ) ; 
 + } ) ; 
 + } 
 + catch ( Exception ex ) 
 + { 
 + logger . warn ( " Exception occurred updating coordinatorWriteLatency metric " , ex ) ; 
 + } 
 + } 
 + 
 private static void syncWriteToBatchlog ( Collection < Mutation > mutations , Collection < InetAddressAndPort > endpoints , UUID uuid , long queryStartNanoTime ) 
 throws WriteTimeoutException , WriteFailureException 
 { 
 diff - - git a / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java b / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java 
 new file mode 100644 
 index 0000000 . . a3ae956 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / metrics / TableMetricsTest . java 
 @ @ - 0 , 0 + 1 , 176 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . metrics ; 
 + 
 + import java . io . IOException ; 
 + 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + import org . junit . runner . RunWith ; 
 + 
 + import com . datastax . driver . core . BatchStatement ; 
 + import com . datastax . driver . core . Cluster ; 
 + import com . datastax . driver . core . PreparedStatement ; 
 + import com . datastax . driver . core . Session ; 
 + import org . apache . cassandra . OrderedJUnit4ClassRunner ; 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . schema . Schema ; 
 + import org . apache . cassandra . service . EmbeddedCassandraService ; 
 + 
 + import static junit . framework . Assert . assertEquals ; 
 + import static junit . framework . Assert . assertTrue ; 
 + 
 + @ RunWith ( OrderedJUnit4ClassRunner . class ) 
 + public class TableMetricsTest extends SchemaLoader 
 + { 
 + 
 + private static Session session ; 
 + 
 + private static final String KEYSPACE = " junit " ; 
 + private static final String TABLE = " tablemetricstest " ; 
 + private static final String COUNTER _ TABLE = " tablemetricscountertest " ; 
 + 
 + @ BeforeClass ( ) 
 + public static void setup ( ) throws ConfigurationException , IOException 
 + { 
 + Schema . instance . clear ( ) ; 
 + 
 + EmbeddedCassandraService cassandra = new EmbeddedCassandraService ( ) ; 
 + cassandra . start ( ) ; 
 + 
 + Cluster cluster = Cluster . builder ( ) . addContactPoint ( " 127 . 0 . 0 . 1 " ) . withPort ( DatabaseDescriptor . getNativeTransportPort ( ) ) . build ( ) ; 
 + session = cluster . connect ( ) ; 
 + 
 + session . execute ( String . format ( " CREATE KEYSPACE IF NOT EXISTS % s WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; " , KEYSPACE ) ) ; 
 + session . execute ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( id _ c counter , id int , val text , PRIMARY KEY ( id , val ) ) ; " , KEYSPACE , COUNTER _ TABLE ) ) ; 
 + } 
 + 
 + private ColumnFamilyStore recreateTable ( ) 
 + { 
 + session . execute ( String . format ( " DROP TABLE IF EXISTS % s . % s " , KEYSPACE , TABLE ) ) ; 
 + session . execute ( String . format ( " CREATE TABLE IF NOT EXISTS % s . % s ( id int , val1 text , val2 text , PRIMARY KEY ( id , val1 ) ) ; " , KEYSPACE , TABLE ) ) ; 
 + return ColumnFamilyStore . getIfExists ( KEYSPACE , TABLE ) ; 
 + } 
 + 
 + private void executeBatch ( boolean isLogged , int distinctPartitions , int statementsPerPartition ) 
 + { 
 + BatchStatement . Type batchType ; 
 + PreparedStatement ps = session . prepare ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( ? , ? , ? ) ; " , KEYSPACE , TABLE ) ) ; 
 + 
 + if ( isLogged ) 
 + { 
 + batchType = BatchStatement . Type . LOGGED ; 
 + } 
 + else 
 + { 
 + batchType = BatchStatement . Type . UNLOGGED ; 
 + } 
 + 
 + BatchStatement batch = new BatchStatement ( batchType ) ; 
 + 
 + for ( int i = 0 ; i < distinctPartitions ; i + + ) 
 + { 
 + for ( int j = 0 ; j < statementsPerPartition ; j + + ) 
 + { 
 + batch . add ( ps . bind ( i , j + " a " , " b " ) ) ; 
 + } 
 + } 
 + 
 + session . execute ( batch ) ; 
 + } 
 + 
 + @ Test 
 + public void testRegularStatementsExecuted ( ) 
 + { 
 + ColumnFamilyStore cfs = recreateTable ( ) ; 
 + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; 
 + 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + session . execute ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( % d , ' % s ' , ' % s ' ) " , KEYSPACE , TABLE , i , " val " + i , " val " + i ) ) ; 
 + } 
 + 
 + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; 
 + } 
 + 
 + @ Test 
 + public void testPreparedStatementsExecuted ( ) 
 + { 
 + ColumnFamilyStore cfs = recreateTable ( ) ; 
 + PreparedStatement metricsStatement = session . prepare ( String . format ( " INSERT INTO % s . % s ( id , val1 , val2 ) VALUES ( ? , ? , ? ) " , KEYSPACE , TABLE ) ) ; 
 + 
 + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; 
 + 
 + for ( int i = 0 ; i < 10 ; i + + ) 
 + { 
 + session . execute ( metricsStatement . bind ( i , " val " + i , " val " + i ) ) ; 
 + } 
 + 
 + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; 
 + } 
 + 
 + @ Test 
 + public void testLoggedPartitionsPerBatch ( ) 
 + { 
 + ColumnFamilyStore cfs = recreateTable ( ) ; 
 + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; 
 + 
 + executeBatch ( true , 10 , 2 ) ; 
 + assertEquals ( 10 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + 
 + executeBatch ( true , 20 , 2 ) ; 
 + assertEquals ( 30 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; 
 + } 
 + 
 + @ Test 
 + public void testUnloggedPartitionsPerBatch ( ) 
 + { 
 + ColumnFamilyStore cfs = recreateTable ( ) ; 
 + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; 
 + 
 + executeBatch ( false , 5 , 3 ) ; 
 + assertEquals ( 5 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + 
 + executeBatch ( false , 25 , 2 ) ; 
 + assertEquals ( 30 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; 
 + 
 + } 
 + 
 + @ Test 
 + public void testCounterStatement ( ) 
 + { 
 + ColumnFamilyStore cfs = ColumnFamilyStore . getIfExists ( KEYSPACE , COUNTER _ TABLE ) ; 
 + assertEquals ( 0 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) = = 0 ) ; 
 + session . execute ( String . format ( " UPDATE % s . % s SET id _ c = id _ c + 1 WHERE id = 1 AND val = ' val1 ' " , KEYSPACE , COUNTER _ TABLE ) ) ; 
 + assertEquals ( 1 , cfs . metric . coordinatorWriteLatency . getCount ( ) ) ; 
 + assertTrue ( cfs . metric . coordinatorWriteLatency . getMeanRate ( ) > 0 ) ; 
 + } 
 + } 
 \ No newline at end of file

NEAREST DIFF:
ELIMINATEDSENTENCE
