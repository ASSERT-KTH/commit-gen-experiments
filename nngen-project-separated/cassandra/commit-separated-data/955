BLEU SCORE: 0.041961149062965476

TEST MSG: Add / drop multiple columns in one ALTER TABLE statement
GENERATED MSG: CQL3 : Allow renaming PK columns

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b80fdf3 . . 8e9cc44 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 6 <nl> + * Add / drop multiple columns in one ALTER TABLE statement ( CASSANDRA - 10411 ) <nl> * Add require _ endpoint _ verification opt for internode encryption ( CASSANDRA - 9220 ) <nl> * Add auto import java . util for UDF code block ( CASSANDRA - 11392 ) <nl> * Add - - hex - format option to nodetool getsstables ( CASSANDRA - 11337 ) <nl> diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile <nl> index 336a64c . . 1ee2537 100644 <nl> - - - a / doc / cql3 / CQL . textile <nl> + + + b / doc / cql3 / CQL . textile <nl> @ @ - 396 , 7 + 396 , 9 @ @ bc ( syntax ) . . <nl> <nl> < instruction > : : = ALTER < identifier > TYPE < type > <nl> | ADD < identifier > < type > <nl> + | ADD ( < identifier > < type > ( , < identifier > < type > ) * ) <nl> | DROP < identifier > <nl> + | DROP ( < identifier > ( , < identifier > ) * ) <nl> | WITH < option > ( AND < option > ) * <nl> p . <nl> _ _ Sample : _ _ <nl> @ @ - 2312 , 6 + 2314 , 7 @ @ The following describes the changes in each version of CQL . <nl> h3 . 3 . 4 . 2 <nl> <nl> * " @ INSERT / UPDATE options @ " : # updateOptions for tables having a default _ time _ to _ live specifying a TTL of 0 will remove the TTL from the inserted or updated values <nl> + * " @ ALTER TABLE @ " : # alterTableStmt @ ADD @ and @ DROP @ now allow mutiple columns to be added / removed <nl> <nl> h3 . 3 . 4 . 1 <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> index 5cb479c . . f7841fd 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / Cql . g <nl> + + + b / src / java / org / apache / cassandra / cql3 / Cql . g <nl> @ @ - 848 , 8 + 848 , 8 @ @ alterKeyspaceStatement returns [ AlterKeyspaceStatement expr ] <nl> <nl> / * * <nl> * ALTER COLUMN FAMILY < CF > ALTER < column > TYPE < newtype > ; <nl> - * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; <nl> - * ALTER COLUMN FAMILY < CF > DROP < column > ; <nl> + * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; | ALTER COLUMN FAMILY < CF > ADD ( < column > < newtype > , < column1 > < newtype1 > . . . . . < column n > < newtype n > ) <nl> + * ALTER COLUMN FAMILY < CF > DROP < column > ; | ALTER COLUMN FAMILY < CF > DROP ( < column > , < column1 > . . . . . < column n > ) <nl> * ALTER COLUMN FAMILY < CF > WITH < property > = < value > ; <nl> * ALTER COLUMN FAMILY < CF > RENAME < column > TO < column > ; <nl> * / <nl> @ @ - 858 , 19 + 858 , 31 @ @ alterTableStatement returns [ AlterTableStatement expr ] <nl> AlterTableStatement . Type type = null ; <nl> TableAttributes attrs = new TableAttributes ( ) ; <nl> Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames = new HashMap < ColumnIdentifier . Raw , ColumnIdentifier . Raw > ( ) ; <nl> - boolean isStatic = false ; <nl> + List < AlterTableStatementColumn > colNameList = new ArrayList < AlterTableStatementColumn > ( ) ; <nl> } <nl> : K _ ALTER K _ COLUMNFAMILY cf = columnFamilyName <nl> - ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } <nl> - | K _ ADD id = cident v = comparatorType ( { isStatic = true ; } K _ STATIC ) ? { type = AlterTableStatement . Type . ADD ; } <nl> - | K _ DROP id = cident { type = AlterTableStatement . Type . DROP ; } <nl> + ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } { colNameList . add ( new AlterTableStatementColumn ( id , v ) ) ; } <nl> + | K _ ADD ( ( id = cident v = comparatorType b1 = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( id , v , b1 ) ) ; } ) <nl> + | ( ' ( ' id1 = cident v1 = comparatorType b1 = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( id1 , v1 , b1 ) ) ; } <nl> + ( ' , ' idn = cident vn = comparatorType bn = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( idn , vn , bn ) ) ; } ) * ' ) ' ) ) { type = AlterTableStatement . Type . ADD ; } <nl> + | K _ DROP ( id = cident { colNameList . add ( new AlterTableStatementColumn ( id ) ) ; } <nl> + | ( ' ( ' id1 = cident { colNameList . add ( new AlterTableStatementColumn ( id1 ) ) ; } <nl> + ( ' , ' idn = cident { colNameList . add ( new AlterTableStatementColumn ( idn ) ) ; } ) * ' ) ' ) ) { type = AlterTableStatement . Type . DROP ; } <nl> | K _ WITH properties [ attrs ] { type = AlterTableStatement . Type . OPTS ; } <nl> | K _ RENAME { type = AlterTableStatement . Type . RENAME ; } <nl> id1 = cident K _ TO toId1 = cident { renames . put ( id1 , toId1 ) ; } <nl> ( K _ AND idn = cident K _ TO toIdn = cident { renames . put ( idn , toIdn ) ; } ) * <nl> ) <nl> { <nl> - $ expr = new AlterTableStatement ( cf , type , id , v , attrs , renames , isStatic ) ; <nl> + $ expr = new AlterTableStatement ( cf , type , colNameList , attrs , renames ) ; <nl> + } <nl> + ; <nl> + <nl> + cfisStatic returns [ boolean isStaticColumn ] <nl> + @ init { <nl> + boolean isStatic = false ; <nl> + } <nl> + : ( K _ STATIC { isStatic = true ; } ) ? { $ isStaticColumn = isStatic ; <nl> } <nl> ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> index 3515c6b . . 8ad3015 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> @ @ - 52 , 27 + 52 , 21 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> } <nl> <nl> public final Type oType ; <nl> - public final CQL3Type . Raw validator ; <nl> - public final ColumnIdentifier . Raw rawColumnName ; <nl> private final TableAttributes attrs ; <nl> private final Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames ; <nl> - private final boolean isStatic ; / / Only for ALTER ADD <nl> + private final List < AlterTableStatementColumn > colNameList ; <nl> <nl> public AlterTableStatement ( CFName name , <nl> Type type , <nl> - ColumnIdentifier . Raw columnName , <nl> - CQL3Type . Raw validator , <nl> + List < AlterTableStatementColumn > colDataList , <nl> TableAttributes attrs , <nl> - Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames , <nl> - boolean isStatic ) <nl> + Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames ) <nl> { <nl> super ( name ) ; <nl> this . oType = type ; <nl> - this . rawColumnName = columnName ; <nl> - this . validator = validator ; / / used only for ADD / ALTER commands <nl> + this . colNameList = colDataList ; <nl> this . attrs = attrs ; <nl> this . renames = renames ; <nl> - this . isStatic = isStatic ; <nl> } <nl> <nl> public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException <nl> @ @ - 92 , 15 + 86 , 12 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> throw new InvalidRequestException ( " Cannot use ALTER TABLE on Materialized View " ) ; <nl> <nl> CFMetaData cfm = meta . copy ( ) ; <nl> - <nl> - CQL3Type validator = this . validator = = null ? null : this . validator . prepare ( keyspace ( ) ) ; <nl> ColumnIdentifier columnName = null ; <nl> ColumnDefinition def = null ; <nl> - if ( rawColumnName ! = null ) <nl> - { <nl> - columnName = rawColumnName . prepare ( cfm ) ; <nl> - def = cfm . getColumnDefinition ( columnName ) ; <nl> - } <nl> + CQL3Type . Raw dataType = null ; <nl> + boolean isStatic = false ; <nl> + CQL3Type validator = null ; <nl> + ColumnIdentifier . Raw rawColumnName = null ; <nl> <nl> List < ViewDefinition > viewUpdates = null ; <nl> Iterable < ViewDefinition > views = View . findAll ( keyspace ( ) , columnFamily ( ) ) ; <nl> @ @ - 108 , 81 + 99 , 104 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> switch ( oType ) <nl> { <nl> case ADD : <nl> - assert columnName ! = null ; <nl> - if ( cfm . isDense ( ) ) <nl> - throw new InvalidRequestException ( " Cannot add new column to a COMPACT STORAGE table " ) ; <nl> - <nl> - if ( isStatic ) <nl> + for ( AlterTableStatementColumn colData : colNameList ) <nl> { <nl> - if ( ! cfm . isCompound ( ) ) <nl> - throw new InvalidRequestException ( " Static columns are not allowed in COMPACT STORAGE tables " ) ; <nl> - if ( cfm . clusteringColumns ( ) . isEmpty ( ) ) <nl> - throw new InvalidRequestException ( " Static columns are only useful ( and thus allowed ) if the table has at least one clustering column " ) ; <nl> - } <nl> + columnName = null ; <nl> + rawColumnName = colData . getColumnName ( ) ; <nl> + if ( rawColumnName ! = null ) <nl> + { <nl> + columnName = rawColumnName . prepare ( cfm ) ; <nl> + def = cfm . getColumnDefinition ( columnName ) ; <nl> + dataType = colData . getColumnType ( ) ; <nl> + isStatic = colData . getStaticType ( ) ; <nl> + validator = dataType = = null ? null : dataType . prepare ( keyspace ( ) ) ; <nl> + } <nl> <nl> - if ( def ! = null ) <nl> - { <nl> - switch ( def . kind ) <nl> + assert columnName ! = null ; <nl> + if ( cfm . isDense ( ) ) <nl> + throw new InvalidRequestException ( " Cannot add new column to a COMPACT STORAGE table " ) ; <nl> + <nl> + if ( isStatic ) <nl> { <nl> - case PARTITION _ KEY : <nl> - case CLUSTERING : <nl> - throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with a PRIMARY KEY part " , columnName ) ) ; <nl> - default : <nl> - throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with an existing column " , columnName ) ) ; <nl> + if ( ! cfm . isCompound ( ) ) <nl> + throw new InvalidRequestException ( " Static columns are not allowed in COMPACT STORAGE tables " ) ; <nl> + if ( cfm . clusteringColumns ( ) . isEmpty ( ) ) <nl> + throw new InvalidRequestException ( " Static columns are only useful ( and thus allowed ) if the table has at least one clustering column " ) ; <nl> } <nl> - } <nl> <nl> - / / Cannot re - add a dropped counter column . See # 7831 . <nl> - if ( meta . isCounter ( ) & & meta . getDroppedColumns ( ) . containsKey ( columnName . bytes ) ) <nl> - throw new InvalidRequestException ( String . format ( " Cannot re - add previously dropped counter column % s " , columnName ) ) ; <nl> + if ( def ! = null ) <nl> + { <nl> + switch ( def . kind ) <nl> + { <nl> + case PARTITION _ KEY : <nl> + case CLUSTERING : <nl> + throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with a PRIMARY KEY part " , columnName ) ) ; <nl> + default : <nl> + throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with an existing column " , columnName ) ) ; <nl> + } <nl> + } <nl> <nl> - AbstractType < ? > type = validator . getType ( ) ; <nl> - if ( type . isCollection ( ) & & type . isMultiCell ( ) ) <nl> - { <nl> - if ( ! cfm . isCompound ( ) ) <nl> - throw new InvalidRequestException ( " Cannot use non - frozen collections in COMPACT STORAGE tables " ) ; <nl> - if ( cfm . isSuper ( ) ) <nl> - throw new InvalidRequestException ( " Cannot use non - frozen collections with super column families " ) ; <nl> - <nl> - / / If there used to be a non - frozen collection column with the same name ( that has been dropped ) , <nl> - / / we could still have some data using the old type , and so we can ' t allow adding a collection <nl> - / / with the same name unless the types are compatible ( see # 6276 ) . <nl> - CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; <nl> - if ( dropped ! = null & & dropped . type instanceof CollectionType <nl> - & & dropped . type . isMultiCell ( ) & & ! type . isCompatibleWith ( dropped . type ) ) <nl> + / / Cannot re - add a dropped counter column . See # 7831 . <nl> + if ( meta . isCounter ( ) & & meta . getDroppedColumns ( ) . containsKey ( columnName . bytes ) ) <nl> + throw new InvalidRequestException ( String . format ( " Cannot re - add previously dropped counter column % s " , columnName ) ) ; <nl> + <nl> + AbstractType < ? > type = validator . getType ( ) ; <nl> + if ( type . isCollection ( ) & & type . isMultiCell ( ) ) <nl> { <nl> - String message = <nl> - String . format ( " Cannot add a collection with the name % s because a collection with the same name " <nl> - + " and a different type ( % s ) has already been used in the past " , <nl> - columnName , <nl> - dropped . type . asCQL3Type ( ) ) ; <nl> - throw new InvalidRequestException ( message ) ; <nl> + if ( ! cfm . isCompound ( ) ) <nl> + throw new InvalidRequestException ( " Cannot use non - frozen collections in COMPACT STORAGE tables " ) ; <nl> + if ( cfm . isSuper ( ) ) <nl> + throw new InvalidRequestException ( " Cannot use non - frozen collections with super column families " ) ; <nl> + <nl> + / / If there used to be a non - frozen collection column with the same name ( that has been dropped ) , <nl> + / / we could still have some data using the old type , and so we can ' t allow adding a collection <nl> + / / with the same name unless the types are compatible ( see # 6276 ) . <nl> + CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; <nl> + if ( dropped ! = null & & dropped . type instanceof CollectionType <nl> + & & dropped . type . isMultiCell ( ) & & ! type . isCompatibleWith ( dropped . type ) ) <nl> + { <nl> + String message = <nl> + String . format ( " Cannot add a collection with the name % s because a collection with the same name " <nl> + + " and a different type ( % s ) has already been used in the past " , <nl> + columnName , <nl> + dropped . type . asCQL3Type ( ) ) ; <nl> + throw new InvalidRequestException ( message ) ; <nl> + } <nl> } <nl> - } <nl> <nl> - cfm . addColumnDefinition ( isStatic <nl> - ? ColumnDefinition . staticDef ( cfm , columnName . bytes , type ) <nl> - : ColumnDefinition . regularDef ( cfm , columnName . bytes , type ) ) ; <nl> + cfm . addColumnDefinition ( isStatic <nl> + ? ColumnDefinition . staticDef ( cfm , columnName . bytes , type ) <nl> + : ColumnDefinition . regularDef ( cfm , columnName . bytes , type ) ) ; <nl> <nl> - / / Adding a column to a table which has an include all view requires the column to be added to the view <nl> - / / as well <nl> - if ( ! isStatic ) <nl> - { <nl> - for ( ViewDefinition view : views ) <nl> + / / Adding a column to a table which has an include all view requires the column to be added to the view <nl> + / / as well <nl> + if ( ! isStatic ) <nl> { <nl> - if ( view . includeAllColumns ) <nl> + for ( ViewDefinition view : views ) <nl> { <nl> - ViewDefinition viewCopy = view . copy ( ) ; <nl> - viewCopy . metadata . addColumnDefinition ( ColumnDefinition . regularDef ( viewCopy . metadata , columnName . bytes , type ) ) ; <nl> - if ( viewUpdates = = null ) <nl> - viewUpdates = new ArrayList < > ( ) ; <nl> - viewUpdates . add ( viewCopy ) ; <nl> + if ( view . includeAllColumns ) <nl> + { <nl> + ViewDefinition viewCopy = view . copy ( ) ; <nl> + viewCopy . metadata . addColumnDefinition ( ColumnDefinition . regularDef ( viewCopy . metadata , columnName . bytes , type ) ) ; <nl> + if ( viewUpdates = = null ) <nl> + viewUpdates = new ArrayList < > ( ) ; <nl> + viewUpdates . add ( viewCopy ) ; <nl> + } <nl> } <nl> } <nl> } <nl> break ; <nl> <nl> case ALTER : <nl> + rawColumnName = colNameList . get ( 0 ) . getColumnName ( ) ; <nl> + if ( rawColumnName ! = null ) <nl> + { <nl> + columnName = rawColumnName . prepare ( cfm ) ; <nl> + def = cfm . getColumnDefinition ( columnName ) ; <nl> + dataType = colNameList . get ( 0 ) . getColumnType ( ) ; <nl> + validator = dataType = = null ? null : dataType . prepare ( keyspace ( ) ) ; <nl> + } <nl> + <nl> assert columnName ! = null ; <nl> if ( def = = null ) <nl> throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; <nl> @ @ - 214 , 66 + 228 , 76 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> break ; <nl> <nl> case DROP : <nl> - assert columnName ! = null ; <nl> - if ( ! cfm . isCQLTable ( ) ) <nl> - throw new InvalidRequestException ( " Cannot drop columns from a non - CQL3 table " ) ; <nl> - if ( def = = null ) <nl> - throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; <nl> - <nl> - switch ( def . kind ) <nl> + for ( AlterTableStatementColumn colData : colNameList ) <nl> { <nl> - case PARTITION _ KEY : <nl> - case CLUSTERING : <nl> - throw new InvalidRequestException ( String . format ( " Cannot drop PRIMARY KEY part % s " , columnName ) ) ; <nl> - case REGULAR : <nl> - case STATIC : <nl> - ColumnDefinition toDelete = null ; <nl> - for ( ColumnDefinition columnDef : cfm . partitionColumns ( ) ) <nl> - { <nl> - if ( columnDef . name . equals ( columnName ) ) <nl> - { <nl> - toDelete = columnDef ; <nl> - break ; <nl> - } <nl> - } <nl> + columnName = null ; <nl> + rawColumnName = colData . getColumnName ( ) ; <nl> + if ( rawColumnName ! = null ) <nl> + { <nl> + columnName = rawColumnName . prepare ( cfm ) ; <nl> + def = cfm . getColumnDefinition ( columnName ) ; <nl> + } <nl> + assert columnName ! = null ; <nl> + if ( ! cfm . isCQLTable ( ) ) <nl> + throw new InvalidRequestException ( " Cannot drop columns from a non - CQL3 table " ) ; <nl> + if ( def = = null ) <nl> + throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; <nl> + <nl> + switch ( def . kind ) <nl> + { <nl> + case PARTITION _ KEY : <nl> + case CLUSTERING : <nl> + throw new InvalidRequestException ( String . format ( " Cannot drop PRIMARY KEY part % s " , columnName ) ) ; <nl> + case REGULAR : <nl> + case STATIC : <nl> + ColumnDefinition toDelete = null ; <nl> + for ( ColumnDefinition columnDef : cfm . partitionColumns ( ) ) <nl> + { <nl> + if ( columnDef . name . equals ( columnName ) ) <nl> + { <nl> + toDelete = columnDef ; <nl> + break ; <nl> + } <nl> + } <nl> assert toDelete ! = null ; <nl> cfm . removeColumnDefinition ( toDelete ) ; <nl> cfm . recordColumnDrop ( toDelete ) ; <nl> break ; <nl> - } <nl> + } <nl> <nl> - / / If the dropped column is required by any secondary indexes <nl> - / / we reject the operation , as the indexes must be dropped first <nl> - Indexes allIndexes = cfm . getIndexes ( ) ; <nl> - if ( ! allIndexes . isEmpty ( ) ) <nl> - { <nl> - ColumnFamilyStore store = Keyspace . openAndGetStore ( cfm ) ; <nl> - Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; <nl> - if ( ! dependentIndexes . isEmpty ( ) ) <nl> - throw new InvalidRequestException ( String . format ( " Cannot drop column % s because it has " + <nl> - " dependent secondary indexes ( % s ) " , <nl> - def , <nl> - dependentIndexes . stream ( ) <nl> - . map ( i - > i . name ) <nl> - . collect ( Collectors . joining ( " , " ) ) ) ) ; <nl> - } <nl> + / / If the dropped column is required by any secondary indexes <nl> + / / we reject the operation , as the indexes must be dropped first <nl> + Indexes allIndexes = cfm . getIndexes ( ) ; <nl> + if ( ! allIndexes . isEmpty ( ) ) <nl> + { <nl> + ColumnFamilyStore store = Keyspace . openAndGetStore ( cfm ) ; <nl> + Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; <nl> + if ( ! dependentIndexes . isEmpty ( ) ) <nl> + throw new InvalidRequestException ( String . format ( " Cannot drop column % s because it has " + <nl> + " dependent secondary indexes ( % s ) " , <nl> + def , <nl> + dependentIndexes . stream ( ) <nl> + . map ( i - > i . name ) <nl> + . collect ( Collectors . joining ( " , " ) ) ) ) ; <nl> + } <nl> <nl> - / / If a column is dropped which is included in a view , we don ' t allow the drop to take place . <nl> - boolean rejectAlter = false ; <nl> - StringBuilder builder = new StringBuilder ( ) ; <nl> - for ( ViewDefinition view : views ) <nl> - { <nl> - if ( ! view . includes ( columnName ) ) continue ; <nl> + / / If a column is dropped which is included in a view , we don ' t allow the drop to take place . <nl> + boolean rejectAlter = false ; <nl> + StringBuilder builder = new StringBuilder ( ) ; <nl> + for ( ViewDefinition view : views ) <nl> + { <nl> + if ( ! view . includes ( columnName ) ) continue ; <nl> + if ( rejectAlter ) <nl> + builder . append ( ' , ' ) ; <nl> + rejectAlter = true ; <nl> + builder . append ( view . viewName ) ; <nl> + } <nl> if ( rejectAlter ) <nl> - builder . append ( ' , ' ) ; <nl> - rejectAlter = true ; <nl> - builder . append ( view . viewName ) ; <nl> + throw new InvalidRequestException ( String . format ( " Cannot drop column % s , depended on by materialized views ( % s . { % s } ) " , <nl> + columnName . toString ( ) , <nl> + keyspace ( ) , <nl> + builder . toString ( ) ) ) ; <nl> } <nl> - if ( rejectAlter ) <nl> - throw new InvalidRequestException ( String . format ( " Cannot drop column % s , depended on by materialized views ( % s . { % s } ) " , <nl> - columnName . toString ( ) , <nl> - keyspace ( ) , <nl> - builder . toString ( ) ) ) ; <nl> break ; <nl> case OPTS : <nl> if ( attrs = = null ) <nl> @ @ - 379 , 12 + 403 , 11 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> } <nl> } <nl> <nl> + @ Override <nl> public String toString ( ) <nl> { <nl> return String . format ( " AlterTableStatement ( name = % s , type = % s , column = % s , validator = % s ) " , <nl> cfName , <nl> - oType , <nl> - rawColumnName , <nl> - validator ) ; <nl> + oType ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java <nl> new file mode 100644 <nl> index 0000000 . . a5d7de7 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java <nl> @ @ - 0 , 0 + 1 , 53 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . cql3 . statements ; <nl> + <nl> + import org . apache . cassandra . cql3 . CQL3Type ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + <nl> + public class AlterTableStatementColumn { <nl> + private final CQL3Type . Raw dataType ; <nl> + private final ColumnIdentifier . Raw colName ; <nl> + private final Boolean isStatic ; <nl> + <nl> + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName , CQL3Type . Raw dataType , boolean isStatic ) { <nl> + this . dataType = dataType ; <nl> + this . colName = colName ; <nl> + this . isStatic = isStatic ; <nl> + } <nl> + <nl> + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName , CQL3Type . Raw dataType ) { <nl> + this ( colName , dataType , false ) ; <nl> + } <nl> + <nl> + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName ) { <nl> + this ( colName , null , false ) ; <nl> + } <nl> + <nl> + public CQL3Type . Raw getColumnType ( ) { <nl> + return dataType ; <nl> + } <nl> + <nl> + public ColumnIdentifier . Raw getColumnName ( ) { <nl> + return colName ; <nl> + } <nl> + <nl> + public Boolean getStaticType ( ) { <nl> + return isStatic ; <nl> + } <nl> + } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> index 9f8bea2 . . 3eb55fd 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java <nl> @ @ - 324 , 4 + 324 , 85 @ @ public class AlterTest extends CQLTester <nl> createTable ( " CREATE TABLE % s ( key blob , column1 blob , value blob , PRIMARY KEY ( ( key ) , column1 ) ) WITH COMPACT STORAGE " ) ; <nl> assertInvalidThrow ( InvalidRequestException . class , " ALTER TABLE % s ALTER column1 TYPE ascii " ) ; <nl> } <nl> + <nl> + / * <nl> + * Test case to check addition of one column <nl> + * / <nl> + @ Test <nl> + public void testAlterAddOneColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id int , name text , PRIMARY KEY ( id ) ) " ) ; <nl> + alterTable ( " ALTER TABLE % s add mail text ; " ) ; <nl> + <nl> + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " mail " , " name " ) ; <nl> + } <nl> + <nl> + / * <nl> + * Test case to check addition of more than one column <nl> + * / <nl> + @ Test <nl> + public void testAlterAddMultiColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; <nl> + alterTable ( " ALTER TABLE % s add ( firstname text , password blob , lastname text , \ " SOME escaped col \ " bigint ) " ) ; <nl> + <nl> + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " SOME escaped col " , " firstname " , " lastname " , " password " , " yearofbirth " ) ; <nl> + } <nl> + <nl> + / * <nl> + * Should throw SyntaxException if multiple columns are added using wrong syntax . <nl> + * Expected Syntax : Alter table T1 add ( C1 datatype , C2 datatype , C3 datatype ) <nl> + * / <nl> + @ Test ( expected = SyntaxException . class ) <nl> + public void testAlterAddMultiColumnWithoutBraces ( ) throws Throwable <nl> + { <nl> + execute ( " ALTER TABLE % s . users add lastname text , password blob , yearofbirth int ; " ) ; <nl> + } <nl> + <nl> + / * <nl> + * Test case to check deletion of one column <nl> + * / <nl> + @ Test <nl> + public void testAlterDropOneColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; <nl> + alterTable ( " ALTER TABLE % s drop telephone " ) ; <nl> + <nl> + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " yearofbirth " ) ; <nl> + } <nl> + <nl> + @ Test <nl> + / * <nl> + * Test case to check deletion of more than one column <nl> + * / <nl> + public void testAlterDropMultiColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , \ " SOME escaped col \ " bigint , PRIMARY KEY ( id ) ) " ) ; <nl> + alterTable ( " ALTER TABLE % s drop ( address , telephone , \ " SOME escaped col \ " ) ; " ) ; <nl> + <nl> + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " yearofbirth " ) ; <nl> + } <nl> + <nl> + / * <nl> + * Should throw SyntaxException if multiple columns are dropped using wrong syntax . <nl> + * / <nl> + @ Test ( expected = SyntaxException . class ) <nl> + public void testAlterDeletionColumnWithoutBraces ( ) throws Throwable <nl> + { <nl> + execute ( " ALTER TABLE % s . users drop name , address ; " ) ; <nl> + } <nl> + <nl> + @ Test ( expected = InvalidRequestException . class ) <nl> + public void testAlterAddDuplicateColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; <nl> + execute ( " ALTER TABLE % s add ( salary int , salary int ) ; " ) ; <nl> + } <nl> + <nl> + @ Test ( expected = InvalidRequestException . class ) <nl> + public void testAlterDropDuplicateColumn ( ) throws Throwable <nl> + { <nl> + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; <nl> + execute ( " ALTER TABLE % s drop ( address , address ) ; " ) ; <nl> + } <nl> }
NEAREST DIFF (one line): diff - - git a / debian / init b / debian / init <nl> index 50fb6fe . . e144dd1 100644 <nl> - - - a / debian / init <nl> + + + b / debian / init <nl> @ @ - 141 , 6 + 141 , 7 @ @ do _ start ( ) <nl> - outfile / var / log / $ NAME / output . log \ <nl> - cp ` classpath ` \ <nl> - Dlog4j . configuration = log4j - server . properties \ <nl> + - Dlog4j . defaultInitOverride = true \ <nl> - XX : HeapDumpPath = " $ cassandra _ home / java _ ` date + % s ` . hprof " \ <nl> - XX : ErrorFile = " $ cassandra _ home / hs _ err _ ` date + % s ` . log " \ <nl> $ JVM _ OPTS \

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b80fdf3 . . 8e9cc44 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 6 
 + * Add / drop multiple columns in one ALTER TABLE statement ( CASSANDRA - 10411 ) 
 * Add require _ endpoint _ verification opt for internode encryption ( CASSANDRA - 9220 ) 
 * Add auto import java . util for UDF code block ( CASSANDRA - 11392 ) 
 * Add - - hex - format option to nodetool getsstables ( CASSANDRA - 11337 ) 
 diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile 
 index 336a64c . . 1ee2537 100644 
 - - - a / doc / cql3 / CQL . textile 
 + + + b / doc / cql3 / CQL . textile 
 @ @ - 396 , 7 + 396 , 9 @ @ bc ( syntax ) . . 
 
 < instruction > : : = ALTER < identifier > TYPE < type > 
 | ADD < identifier > < type > 
 + | ADD ( < identifier > < type > ( , < identifier > < type > ) * ) 
 | DROP < identifier > 
 + | DROP ( < identifier > ( , < identifier > ) * ) 
 | WITH < option > ( AND < option > ) * 
 p . 
 _ _ Sample : _ _ 
 @ @ - 2312 , 6 + 2314 , 7 @ @ The following describes the changes in each version of CQL . 
 h3 . 3 . 4 . 2 
 
 * " @ INSERT / UPDATE options @ " : # updateOptions for tables having a default _ time _ to _ live specifying a TTL of 0 will remove the TTL from the inserted or updated values 
 + * " @ ALTER TABLE @ " : # alterTableStmt @ ADD @ and @ DROP @ now allow mutiple columns to be added / removed 
 
 h3 . 3 . 4 . 1 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / Cql . g b / src / java / org / apache / cassandra / cql3 / Cql . g 
 index 5cb479c . . f7841fd 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / Cql . g 
 + + + b / src / java / org / apache / cassandra / cql3 / Cql . g 
 @ @ - 848 , 8 + 848 , 8 @ @ alterKeyspaceStatement returns [ AlterKeyspaceStatement expr ] 
 
 / * * 
 * ALTER COLUMN FAMILY < CF > ALTER < column > TYPE < newtype > ; 
 - * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; 
 - * ALTER COLUMN FAMILY < CF > DROP < column > ; 
 + * ALTER COLUMN FAMILY < CF > ADD < column > < newtype > ; | ALTER COLUMN FAMILY < CF > ADD ( < column > < newtype > , < column1 > < newtype1 > . . . . . < column n > < newtype n > ) 
 + * ALTER COLUMN FAMILY < CF > DROP < column > ; | ALTER COLUMN FAMILY < CF > DROP ( < column > , < column1 > . . . . . < column n > ) 
 * ALTER COLUMN FAMILY < CF > WITH < property > = < value > ; 
 * ALTER COLUMN FAMILY < CF > RENAME < column > TO < column > ; 
 * / 
 @ @ - 858 , 19 + 858 , 31 @ @ alterTableStatement returns [ AlterTableStatement expr ] 
 AlterTableStatement . Type type = null ; 
 TableAttributes attrs = new TableAttributes ( ) ; 
 Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames = new HashMap < ColumnIdentifier . Raw , ColumnIdentifier . Raw > ( ) ; 
 - boolean isStatic = false ; 
 + List < AlterTableStatementColumn > colNameList = new ArrayList < AlterTableStatementColumn > ( ) ; 
 } 
 : K _ ALTER K _ COLUMNFAMILY cf = columnFamilyName 
 - ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } 
 - | K _ ADD id = cident v = comparatorType ( { isStatic = true ; } K _ STATIC ) ? { type = AlterTableStatement . Type . ADD ; } 
 - | K _ DROP id = cident { type = AlterTableStatement . Type . DROP ; } 
 + ( K _ ALTER id = cident K _ TYPE v = comparatorType { type = AlterTableStatement . Type . ALTER ; } { colNameList . add ( new AlterTableStatementColumn ( id , v ) ) ; } 
 + | K _ ADD ( ( id = cident v = comparatorType b1 = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( id , v , b1 ) ) ; } ) 
 + | ( ' ( ' id1 = cident v1 = comparatorType b1 = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( id1 , v1 , b1 ) ) ; } 
 + ( ' , ' idn = cident vn = comparatorType bn = cfisStatic { colNameList . add ( new AlterTableStatementColumn ( idn , vn , bn ) ) ; } ) * ' ) ' ) ) { type = AlterTableStatement . Type . ADD ; } 
 + | K _ DROP ( id = cident { colNameList . add ( new AlterTableStatementColumn ( id ) ) ; } 
 + | ( ' ( ' id1 = cident { colNameList . add ( new AlterTableStatementColumn ( id1 ) ) ; } 
 + ( ' , ' idn = cident { colNameList . add ( new AlterTableStatementColumn ( idn ) ) ; } ) * ' ) ' ) ) { type = AlterTableStatement . Type . DROP ; } 
 | K _ WITH properties [ attrs ] { type = AlterTableStatement . Type . OPTS ; } 
 | K _ RENAME { type = AlterTableStatement . Type . RENAME ; } 
 id1 = cident K _ TO toId1 = cident { renames . put ( id1 , toId1 ) ; } 
 ( K _ AND idn = cident K _ TO toIdn = cident { renames . put ( idn , toIdn ) ; } ) * 
 ) 
 { 
 - $ expr = new AlterTableStatement ( cf , type , id , v , attrs , renames , isStatic ) ; 
 + $ expr = new AlterTableStatement ( cf , type , colNameList , attrs , renames ) ; 
 + } 
 + ; 
 + 
 + cfisStatic returns [ boolean isStaticColumn ] 
 + @ init { 
 + boolean isStatic = false ; 
 + } 
 + : ( K _ STATIC { isStatic = true ; } ) ? { $ isStaticColumn = isStatic ; 
 } 
 ; 
 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 index 3515c6b . . 8ad3015 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 @ @ - 52 , 27 + 52 , 21 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 } 
 
 public final Type oType ; 
 - public final CQL3Type . Raw validator ; 
 - public final ColumnIdentifier . Raw rawColumnName ; 
 private final TableAttributes attrs ; 
 private final Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames ; 
 - private final boolean isStatic ; / / Only for ALTER ADD 
 + private final List < AlterTableStatementColumn > colNameList ; 
 
 public AlterTableStatement ( CFName name , 
 Type type , 
 - ColumnIdentifier . Raw columnName , 
 - CQL3Type . Raw validator , 
 + List < AlterTableStatementColumn > colDataList , 
 TableAttributes attrs , 
 - Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames , 
 - boolean isStatic ) 
 + Map < ColumnIdentifier . Raw , ColumnIdentifier . Raw > renames ) 
 { 
 super ( name ) ; 
 this . oType = type ; 
 - this . rawColumnName = columnName ; 
 - this . validator = validator ; / / used only for ADD / ALTER commands 
 + this . colNameList = colDataList ; 
 this . attrs = attrs ; 
 this . renames = renames ; 
 - this . isStatic = isStatic ; 
 } 
 
 public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException 
 @ @ - 92 , 15 + 86 , 12 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 throw new InvalidRequestException ( " Cannot use ALTER TABLE on Materialized View " ) ; 
 
 CFMetaData cfm = meta . copy ( ) ; 
 - 
 - CQL3Type validator = this . validator = = null ? null : this . validator . prepare ( keyspace ( ) ) ; 
 ColumnIdentifier columnName = null ; 
 ColumnDefinition def = null ; 
 - if ( rawColumnName ! = null ) 
 - { 
 - columnName = rawColumnName . prepare ( cfm ) ; 
 - def = cfm . getColumnDefinition ( columnName ) ; 
 - } 
 + CQL3Type . Raw dataType = null ; 
 + boolean isStatic = false ; 
 + CQL3Type validator = null ; 
 + ColumnIdentifier . Raw rawColumnName = null ; 
 
 List < ViewDefinition > viewUpdates = null ; 
 Iterable < ViewDefinition > views = View . findAll ( keyspace ( ) , columnFamily ( ) ) ; 
 @ @ - 108 , 81 + 99 , 104 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 switch ( oType ) 
 { 
 case ADD : 
 - assert columnName ! = null ; 
 - if ( cfm . isDense ( ) ) 
 - throw new InvalidRequestException ( " Cannot add new column to a COMPACT STORAGE table " ) ; 
 - 
 - if ( isStatic ) 
 + for ( AlterTableStatementColumn colData : colNameList ) 
 { 
 - if ( ! cfm . isCompound ( ) ) 
 - throw new InvalidRequestException ( " Static columns are not allowed in COMPACT STORAGE tables " ) ; 
 - if ( cfm . clusteringColumns ( ) . isEmpty ( ) ) 
 - throw new InvalidRequestException ( " Static columns are only useful ( and thus allowed ) if the table has at least one clustering column " ) ; 
 - } 
 + columnName = null ; 
 + rawColumnName = colData . getColumnName ( ) ; 
 + if ( rawColumnName ! = null ) 
 + { 
 + columnName = rawColumnName . prepare ( cfm ) ; 
 + def = cfm . getColumnDefinition ( columnName ) ; 
 + dataType = colData . getColumnType ( ) ; 
 + isStatic = colData . getStaticType ( ) ; 
 + validator = dataType = = null ? null : dataType . prepare ( keyspace ( ) ) ; 
 + } 
 
 - if ( def ! = null ) 
 - { 
 - switch ( def . kind ) 
 + assert columnName ! = null ; 
 + if ( cfm . isDense ( ) ) 
 + throw new InvalidRequestException ( " Cannot add new column to a COMPACT STORAGE table " ) ; 
 + 
 + if ( isStatic ) 
 { 
 - case PARTITION _ KEY : 
 - case CLUSTERING : 
 - throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with a PRIMARY KEY part " , columnName ) ) ; 
 - default : 
 - throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with an existing column " , columnName ) ) ; 
 + if ( ! cfm . isCompound ( ) ) 
 + throw new InvalidRequestException ( " Static columns are not allowed in COMPACT STORAGE tables " ) ; 
 + if ( cfm . clusteringColumns ( ) . isEmpty ( ) ) 
 + throw new InvalidRequestException ( " Static columns are only useful ( and thus allowed ) if the table has at least one clustering column " ) ; 
 } 
 - } 
 
 - / / Cannot re - add a dropped counter column . See # 7831 . 
 - if ( meta . isCounter ( ) & & meta . getDroppedColumns ( ) . containsKey ( columnName . bytes ) ) 
 - throw new InvalidRequestException ( String . format ( " Cannot re - add previously dropped counter column % s " , columnName ) ) ; 
 + if ( def ! = null ) 
 + { 
 + switch ( def . kind ) 
 + { 
 + case PARTITION _ KEY : 
 + case CLUSTERING : 
 + throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with a PRIMARY KEY part " , columnName ) ) ; 
 + default : 
 + throw new InvalidRequestException ( String . format ( " Invalid column name % s because it conflicts with an existing column " , columnName ) ) ; 
 + } 
 + } 
 
 - AbstractType < ? > type = validator . getType ( ) ; 
 - if ( type . isCollection ( ) & & type . isMultiCell ( ) ) 
 - { 
 - if ( ! cfm . isCompound ( ) ) 
 - throw new InvalidRequestException ( " Cannot use non - frozen collections in COMPACT STORAGE tables " ) ; 
 - if ( cfm . isSuper ( ) ) 
 - throw new InvalidRequestException ( " Cannot use non - frozen collections with super column families " ) ; 
 - 
 - / / If there used to be a non - frozen collection column with the same name ( that has been dropped ) , 
 - / / we could still have some data using the old type , and so we can ' t allow adding a collection 
 - / / with the same name unless the types are compatible ( see # 6276 ) . 
 - CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; 
 - if ( dropped ! = null & & dropped . type instanceof CollectionType 
 - & & dropped . type . isMultiCell ( ) & & ! type . isCompatibleWith ( dropped . type ) ) 
 + / / Cannot re - add a dropped counter column . See # 7831 . 
 + if ( meta . isCounter ( ) & & meta . getDroppedColumns ( ) . containsKey ( columnName . bytes ) ) 
 + throw new InvalidRequestException ( String . format ( " Cannot re - add previously dropped counter column % s " , columnName ) ) ; 
 + 
 + AbstractType < ? > type = validator . getType ( ) ; 
 + if ( type . isCollection ( ) & & type . isMultiCell ( ) ) 
 { 
 - String message = 
 - String . format ( " Cannot add a collection with the name % s because a collection with the same name " 
 - + " and a different type ( % s ) has already been used in the past " , 
 - columnName , 
 - dropped . type . asCQL3Type ( ) ) ; 
 - throw new InvalidRequestException ( message ) ; 
 + if ( ! cfm . isCompound ( ) ) 
 + throw new InvalidRequestException ( " Cannot use non - frozen collections in COMPACT STORAGE tables " ) ; 
 + if ( cfm . isSuper ( ) ) 
 + throw new InvalidRequestException ( " Cannot use non - frozen collections with super column families " ) ; 
 + 
 + / / If there used to be a non - frozen collection column with the same name ( that has been dropped ) , 
 + / / we could still have some data using the old type , and so we can ' t allow adding a collection 
 + / / with the same name unless the types are compatible ( see # 6276 ) . 
 + CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; 
 + if ( dropped ! = null & & dropped . type instanceof CollectionType 
 + & & dropped . type . isMultiCell ( ) & & ! type . isCompatibleWith ( dropped . type ) ) 
 + { 
 + String message = 
 + String . format ( " Cannot add a collection with the name % s because a collection with the same name " 
 + + " and a different type ( % s ) has already been used in the past " , 
 + columnName , 
 + dropped . type . asCQL3Type ( ) ) ; 
 + throw new InvalidRequestException ( message ) ; 
 + } 
 } 
 - } 
 
 - cfm . addColumnDefinition ( isStatic 
 - ? ColumnDefinition . staticDef ( cfm , columnName . bytes , type ) 
 - : ColumnDefinition . regularDef ( cfm , columnName . bytes , type ) ) ; 
 + cfm . addColumnDefinition ( isStatic 
 + ? ColumnDefinition . staticDef ( cfm , columnName . bytes , type ) 
 + : ColumnDefinition . regularDef ( cfm , columnName . bytes , type ) ) ; 
 
 - / / Adding a column to a table which has an include all view requires the column to be added to the view 
 - / / as well 
 - if ( ! isStatic ) 
 - { 
 - for ( ViewDefinition view : views ) 
 + / / Adding a column to a table which has an include all view requires the column to be added to the view 
 + / / as well 
 + if ( ! isStatic ) 
 { 
 - if ( view . includeAllColumns ) 
 + for ( ViewDefinition view : views ) 
 { 
 - ViewDefinition viewCopy = view . copy ( ) ; 
 - viewCopy . metadata . addColumnDefinition ( ColumnDefinition . regularDef ( viewCopy . metadata , columnName . bytes , type ) ) ; 
 - if ( viewUpdates = = null ) 
 - viewUpdates = new ArrayList < > ( ) ; 
 - viewUpdates . add ( viewCopy ) ; 
 + if ( view . includeAllColumns ) 
 + { 
 + ViewDefinition viewCopy = view . copy ( ) ; 
 + viewCopy . metadata . addColumnDefinition ( ColumnDefinition . regularDef ( viewCopy . metadata , columnName . bytes , type ) ) ; 
 + if ( viewUpdates = = null ) 
 + viewUpdates = new ArrayList < > ( ) ; 
 + viewUpdates . add ( viewCopy ) ; 
 + } 
 } 
 } 
 } 
 break ; 
 
 case ALTER : 
 + rawColumnName = colNameList . get ( 0 ) . getColumnName ( ) ; 
 + if ( rawColumnName ! = null ) 
 + { 
 + columnName = rawColumnName . prepare ( cfm ) ; 
 + def = cfm . getColumnDefinition ( columnName ) ; 
 + dataType = colNameList . get ( 0 ) . getColumnType ( ) ; 
 + validator = dataType = = null ? null : dataType . prepare ( keyspace ( ) ) ; 
 + } 
 + 
 assert columnName ! = null ; 
 if ( def = = null ) 
 throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; 
 @ @ - 214 , 66 + 228 , 76 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 break ; 
 
 case DROP : 
 - assert columnName ! = null ; 
 - if ( ! cfm . isCQLTable ( ) ) 
 - throw new InvalidRequestException ( " Cannot drop columns from a non - CQL3 table " ) ; 
 - if ( def = = null ) 
 - throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; 
 - 
 - switch ( def . kind ) 
 + for ( AlterTableStatementColumn colData : colNameList ) 
 { 
 - case PARTITION _ KEY : 
 - case CLUSTERING : 
 - throw new InvalidRequestException ( String . format ( " Cannot drop PRIMARY KEY part % s " , columnName ) ) ; 
 - case REGULAR : 
 - case STATIC : 
 - ColumnDefinition toDelete = null ; 
 - for ( ColumnDefinition columnDef : cfm . partitionColumns ( ) ) 
 - { 
 - if ( columnDef . name . equals ( columnName ) ) 
 - { 
 - toDelete = columnDef ; 
 - break ; 
 - } 
 - } 
 + columnName = null ; 
 + rawColumnName = colData . getColumnName ( ) ; 
 + if ( rawColumnName ! = null ) 
 + { 
 + columnName = rawColumnName . prepare ( cfm ) ; 
 + def = cfm . getColumnDefinition ( columnName ) ; 
 + } 
 + assert columnName ! = null ; 
 + if ( ! cfm . isCQLTable ( ) ) 
 + throw new InvalidRequestException ( " Cannot drop columns from a non - CQL3 table " ) ; 
 + if ( def = = null ) 
 + throw new InvalidRequestException ( String . format ( " Column % s was not found in table % s " , columnName , columnFamily ( ) ) ) ; 
 + 
 + switch ( def . kind ) 
 + { 
 + case PARTITION _ KEY : 
 + case CLUSTERING : 
 + throw new InvalidRequestException ( String . format ( " Cannot drop PRIMARY KEY part % s " , columnName ) ) ; 
 + case REGULAR : 
 + case STATIC : 
 + ColumnDefinition toDelete = null ; 
 + for ( ColumnDefinition columnDef : cfm . partitionColumns ( ) ) 
 + { 
 + if ( columnDef . name . equals ( columnName ) ) 
 + { 
 + toDelete = columnDef ; 
 + break ; 
 + } 
 + } 
 assert toDelete ! = null ; 
 cfm . removeColumnDefinition ( toDelete ) ; 
 cfm . recordColumnDrop ( toDelete ) ; 
 break ; 
 - } 
 + } 
 
 - / / If the dropped column is required by any secondary indexes 
 - / / we reject the operation , as the indexes must be dropped first 
 - Indexes allIndexes = cfm . getIndexes ( ) ; 
 - if ( ! allIndexes . isEmpty ( ) ) 
 - { 
 - ColumnFamilyStore store = Keyspace . openAndGetStore ( cfm ) ; 
 - Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; 
 - if ( ! dependentIndexes . isEmpty ( ) ) 
 - throw new InvalidRequestException ( String . format ( " Cannot drop column % s because it has " + 
 - " dependent secondary indexes ( % s ) " , 
 - def , 
 - dependentIndexes . stream ( ) 
 - . map ( i - > i . name ) 
 - . collect ( Collectors . joining ( " , " ) ) ) ) ; 
 - } 
 + / / If the dropped column is required by any secondary indexes 
 + / / we reject the operation , as the indexes must be dropped first 
 + Indexes allIndexes = cfm . getIndexes ( ) ; 
 + if ( ! allIndexes . isEmpty ( ) ) 
 + { 
 + ColumnFamilyStore store = Keyspace . openAndGetStore ( cfm ) ; 
 + Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; 
 + if ( ! dependentIndexes . isEmpty ( ) ) 
 + throw new InvalidRequestException ( String . format ( " Cannot drop column % s because it has " + 
 + " dependent secondary indexes ( % s ) " , 
 + def , 
 + dependentIndexes . stream ( ) 
 + . map ( i - > i . name ) 
 + . collect ( Collectors . joining ( " , " ) ) ) ) ; 
 + } 
 
 - / / If a column is dropped which is included in a view , we don ' t allow the drop to take place . 
 - boolean rejectAlter = false ; 
 - StringBuilder builder = new StringBuilder ( ) ; 
 - for ( ViewDefinition view : views ) 
 - { 
 - if ( ! view . includes ( columnName ) ) continue ; 
 + / / If a column is dropped which is included in a view , we don ' t allow the drop to take place . 
 + boolean rejectAlter = false ; 
 + StringBuilder builder = new StringBuilder ( ) ; 
 + for ( ViewDefinition view : views ) 
 + { 
 + if ( ! view . includes ( columnName ) ) continue ; 
 + if ( rejectAlter ) 
 + builder . append ( ' , ' ) ; 
 + rejectAlter = true ; 
 + builder . append ( view . viewName ) ; 
 + } 
 if ( rejectAlter ) 
 - builder . append ( ' , ' ) ; 
 - rejectAlter = true ; 
 - builder . append ( view . viewName ) ; 
 + throw new InvalidRequestException ( String . format ( " Cannot drop column % s , depended on by materialized views ( % s . { % s } ) " , 
 + columnName . toString ( ) , 
 + keyspace ( ) , 
 + builder . toString ( ) ) ) ; 
 } 
 - if ( rejectAlter ) 
 - throw new InvalidRequestException ( String . format ( " Cannot drop column % s , depended on by materialized views ( % s . { % s } ) " , 
 - columnName . toString ( ) , 
 - keyspace ( ) , 
 - builder . toString ( ) ) ) ; 
 break ; 
 case OPTS : 
 if ( attrs = = null ) 
 @ @ - 379 , 12 + 403 , 11 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 } 
 } 
 
 + @ Override 
 public String toString ( ) 
 { 
 return String . format ( " AlterTableStatement ( name = % s , type = % s , column = % s , validator = % s ) " , 
 cfName , 
 - oType , 
 - rawColumnName , 
 - validator ) ; 
 + oType ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java 
 new file mode 100644 
 index 0000000 . . a5d7de7 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatementColumn . java 
 @ @ - 0 , 0 + 1 , 53 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . cql3 . statements ; 
 + 
 + import org . apache . cassandra . cql3 . CQL3Type ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + 
 + public class AlterTableStatementColumn { 
 + private final CQL3Type . Raw dataType ; 
 + private final ColumnIdentifier . Raw colName ; 
 + private final Boolean isStatic ; 
 + 
 + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName , CQL3Type . Raw dataType , boolean isStatic ) { 
 + this . dataType = dataType ; 
 + this . colName = colName ; 
 + this . isStatic = isStatic ; 
 + } 
 + 
 + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName , CQL3Type . Raw dataType ) { 
 + this ( colName , dataType , false ) ; 
 + } 
 + 
 + public AlterTableStatementColumn ( ColumnIdentifier . Raw colName ) { 
 + this ( colName , null , false ) ; 
 + } 
 + 
 + public CQL3Type . Raw getColumnType ( ) { 
 + return dataType ; 
 + } 
 + 
 + public ColumnIdentifier . Raw getColumnName ( ) { 
 + return colName ; 
 + } 
 + 
 + public Boolean getStaticType ( ) { 
 + return isStatic ; 
 + } 
 + } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 index 9f8bea2 . . 3eb55fd 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / validation / operations / AlterTest . java 
 @ @ - 324 , 4 + 324 , 85 @ @ public class AlterTest extends CQLTester 
 createTable ( " CREATE TABLE % s ( key blob , column1 blob , value blob , PRIMARY KEY ( ( key ) , column1 ) ) WITH COMPACT STORAGE " ) ; 
 assertInvalidThrow ( InvalidRequestException . class , " ALTER TABLE % s ALTER column1 TYPE ascii " ) ; 
 } 
 + 
 + / * 
 + * Test case to check addition of one column 
 + * / 
 + @ Test 
 + public void testAlterAddOneColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id int , name text , PRIMARY KEY ( id ) ) " ) ; 
 + alterTable ( " ALTER TABLE % s add mail text ; " ) ; 
 + 
 + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " mail " , " name " ) ; 
 + } 
 + 
 + / * 
 + * Test case to check addition of more than one column 
 + * / 
 + @ Test 
 + public void testAlterAddMultiColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; 
 + alterTable ( " ALTER TABLE % s add ( firstname text , password blob , lastname text , \ " SOME escaped col \ " bigint ) " ) ; 
 + 
 + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " SOME escaped col " , " firstname " , " lastname " , " password " , " yearofbirth " ) ; 
 + } 
 + 
 + / * 
 + * Should throw SyntaxException if multiple columns are added using wrong syntax . 
 + * Expected Syntax : Alter table T1 add ( C1 datatype , C2 datatype , C3 datatype ) 
 + * / 
 + @ Test ( expected = SyntaxException . class ) 
 + public void testAlterAddMultiColumnWithoutBraces ( ) throws Throwable 
 + { 
 + execute ( " ALTER TABLE % s . users add lastname text , password blob , yearofbirth int ; " ) ; 
 + } 
 + 
 + / * 
 + * Test case to check deletion of one column 
 + * / 
 + @ Test 
 + public void testAlterDropOneColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; 
 + alterTable ( " ALTER TABLE % s drop telephone " ) ; 
 + 
 + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " yearofbirth " ) ; 
 + } 
 + 
 + @ Test 
 + / * 
 + * Test case to check deletion of more than one column 
 + * / 
 + public void testAlterDropMultiColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , \ " SOME escaped col \ " bigint , PRIMARY KEY ( id ) ) " ) ; 
 + alterTable ( " ALTER TABLE % s drop ( address , telephone , \ " SOME escaped col \ " ) ; " ) ; 
 + 
 + assertColumnNames ( execute ( " SELECT * FROM % s " ) , " id " , " yearofbirth " ) ; 
 + } 
 + 
 + / * 
 + * Should throw SyntaxException if multiple columns are dropped using wrong syntax . 
 + * / 
 + @ Test ( expected = SyntaxException . class ) 
 + public void testAlterDeletionColumnWithoutBraces ( ) throws Throwable 
 + { 
 + execute ( " ALTER TABLE % s . users drop name , address ; " ) ; 
 + } 
 + 
 + @ Test ( expected = InvalidRequestException . class ) 
 + public void testAlterAddDuplicateColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; 
 + execute ( " ALTER TABLE % s add ( salary int , salary int ) ; " ) ; 
 + } 
 + 
 + @ Test ( expected = InvalidRequestException . class ) 
 + public void testAlterDropDuplicateColumn ( ) throws Throwable 
 + { 
 + createTable ( " CREATE TABLE IF NOT EXISTS % s ( id text , address text , telephone int , yearofbirth int , PRIMARY KEY ( id ) ) " ) ; 
 + execute ( " ALTER TABLE % s drop ( address , address ) ; " ) ; 
 + } 
 }

NEAREST DIFF:
diff - - git a / debian / init b / debian / init 
 index 50fb6fe . . e144dd1 100644 
 - - - a / debian / init 
 + + + b / debian / init 
 @ @ - 141 , 6 + 141 , 7 @ @ do _ start ( ) 
 - outfile / var / log / $ NAME / output . log \ 
 - cp ` classpath ` \ 
 - Dlog4j . configuration = log4j - server . properties \ 
 + - Dlog4j . defaultInitOverride = true \ 
 - XX : HeapDumpPath = " $ cassandra _ home / java _ ` date + % s ` . hprof " \ 
 - XX : ErrorFile = " $ cassandra _ home / hs _ err _ ` date + % s ` . log " \ 
 $ JVM _ OPTS \
