BLEU SCORE: 0.018738883683389617

TEST MSG: Fix and move dropped columns info to a separate schema table
GENERATED MSG: Reenable ALTER TABLE DROP with new semantics

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> index 81ef217 . . 6c53699 100644 <nl> - - - a / src / java / org / apache / cassandra / config / CFMetaData . java <nl> + + + b / src / java / org / apache / cassandra / config / CFMetaData . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . ThreadLocalRandom ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . base . MoreObjects ; <nl> import com . google . common . base . Objects ; <nl> import com . google . common . base . Strings ; <nl> import com . google . common . collect . * ; <nl> @ @ - 1193 , 7 + 1194 , 7 @ @ public final class CFMetaData <nl> <nl> public void recordColumnDrop ( ColumnDefinition def ) <nl> { <nl> - droppedColumns . put ( def . name . bytes , new DroppedColumn ( def . type , FBUtilities . timestampMicros ( ) ) ) ; <nl> + droppedColumns . put ( def . name . bytes , new DroppedColumn ( def . name . toString ( ) , def . type , FBUtilities . timestampMicros ( ) ) ) ; <nl> } <nl> <nl> public void renameColumn ( ColumnIdentifier from , ColumnIdentifier to ) throws InvalidRequestException <nl> @ @ - 1261 , 6 + 1262 , 14 @ @ public final class CFMetaData <nl> return false ; <nl> } <nl> <nl> + public boolean hasDroppedCollectionColumns ( ) <nl> + { <nl> + for ( DroppedColumn def : getDroppedColumns ( ) . values ( ) ) <nl> + if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) <nl> + return true ; <nl> + return false ; <nl> + } <nl> + <nl> public boolean isSuper ( ) <nl> { <nl> return isSuper ; <nl> @ @ - 1536 , 13 + 1545 , 48 @ @ public final class CFMetaData <nl> <nl> public static class DroppedColumn <nl> { <nl> + / / we only allow dropping REGULAR columns , from CQL - native tables , so the names are always of UTF8Type <nl> + public final String name ; <nl> public final AbstractType < ? > type ; <nl> + <nl> + / / drop timestamp , in microseconds , yet with millisecond granularity <nl> public final long droppedTime ; <nl> <nl> - public DroppedColumn ( AbstractType < ? > type , long droppedTime ) <nl> + public DroppedColumn ( String name , AbstractType < ? > type , long droppedTime ) <nl> { <nl> + this . name = name ; <nl> this . type = type ; <nl> this . droppedTime = droppedTime ; <nl> } <nl> + <nl> + @ Override <nl> + public boolean equals ( Object o ) <nl> + { <nl> + if ( this = = o ) <nl> + return true ; <nl> + <nl> + if ( ! ( o instanceof DroppedColumn ) ) <nl> + return false ; <nl> + <nl> + DroppedColumn dc = ( DroppedColumn ) o ; <nl> + <nl> + return name . equals ( dc . name ) & & type . equals ( dc . type ) & & droppedTime = = dc . droppedTime ; <nl> + } <nl> + <nl> + @ Override <nl> + public int hashCode ( ) <nl> + { <nl> + return Objects . hashCode ( name , type , droppedTime ) ; <nl> + } <nl> + <nl> + @ Override <nl> + public String toString ( ) <nl> + { <nl> + return MoreObjects . toStringHelper ( this ) <nl> + . add ( " name " , name ) <nl> + . add ( " type " , type ) <nl> + . add ( " droppedTime " , droppedTime ) <nl> + . toString ( ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> index e0c5f4e . . a247cdb 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> @ @ - 129 , 11 + 129 , 10 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> / / some data using the old type , and so we can ' t allow adding a collection with the same name unless <nl> / / the types are compatible ( see # 6276 ) . <nl> CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; <nl> - / / We could have type = = null for old dropped columns , in which case we play it safe and refuse <nl> - if ( dropped ! = null & & ( dropped . type = = null | | ( dropped . type instanceof CollectionType & & ! type . isCompatibleWith ( dropped . type ) ) ) ) <nl> + if ( dropped ! = null & & dropped . type instanceof CollectionType & & ! type . isCompatibleWith ( dropped . type ) ) <nl> throw new InvalidRequestException ( String . format ( " Cannot add a collection with the name % s " + <nl> " because a collection with the same name and a different type % s has already been used in the past " , <nl> - columnName , dropped . type = = null ? " " : " ( " + dropped . type . asCQL3Type ( ) + " ) " ) ) ; <nl> + columnName , " ( " + dropped . type . asCQL3Type ( ) + ' ) ' ) ) ; <nl> } <nl> <nl> Integer componentIndex = cfm . isCompound ( ) ? cfm . comparator . size ( ) : null ; <nl> diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index 9eb7145 . . f063256 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 41 , 6 + 41 , 8 @ @ import org . apache . cassandra . thrift . ColumnDef ; <nl> import org . apache . cassandra . utils . * ; <nl> import org . apache . hadoop . io . serializer . Serialization ; <nl> <nl> + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; <nl> + <nl> / * * <nl> * Functions to deal with the old format . <nl> * / <nl> @ @ - 67 , 7 + 69 , 7 @ @ public abstract class LegacyLayout <nl> return comparator . subtype ( 0 ) ; <nl> } <nl> <nl> - boolean hasCollections = metadata . hasCollectionColumns ( ) ; <nl> + boolean hasCollections = metadata . hasCollectionColumns ( ) | | metadata . hasDroppedCollectionColumns ( ) ; <nl> List < AbstractType < ? > > types = new ArrayList < > ( comparator . size ( ) + ( metadata . isDense ( ) ? 0 : 1 ) + ( hasCollections ? 1 : 0 ) ) ; <nl> <nl> types . addAll ( comparator . subtypes ( ) ) ; <nl> @ @ - 75 , 14 + 77 , 19 @ @ public abstract class LegacyLayout <nl> if ( ! metadata . isDense ( ) ) <nl> { <nl> types . add ( UTF8Type . instance ) ; <nl> + <nl> if ( hasCollections ) <nl> { <nl> Map < ByteBuffer , CollectionType > defined = new HashMap < > ( ) ; <nl> + <nl> + for ( CFMetaData . DroppedColumn def : metadata . getDroppedColumns ( ) . values ( ) ) <nl> + if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) <nl> + defined . put ( bytes ( def . name ) , ( CollectionType ) def . type ) ; <nl> + <nl> for ( ColumnDefinition def : metadata . partitionColumns ( ) ) <nl> - { <nl> if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) <nl> - defined . put ( def . name . bytes , ( CollectionType ) def . type ) ; <nl> - } <nl> + defined . put ( def . name . bytes , ( CollectionType ) def . type ) ; <nl> + <nl> types . add ( ColumnToCollectionType . getInstance ( defined ) ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> index 159396b . . 879a505 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java <nl> @ @ - 330 , 7 + 330 , 7 @ @ public final class LegacySchemaMigrator <nl> cfm . bloomFilterFpChance ( cfm . getBloomFilterFpChance ( ) ) ; <nl> <nl> if ( tableRow . has ( " dropped _ columns " ) ) <nl> - addDroppedColumns ( cfm , tableRow . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) , Collections . emptyMap ( ) ) ; <nl> + addDroppedColumns ( cfm , rawComparator , tableRow . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) ) ; <nl> <nl> cfm . triggers ( createTriggersFromTriggerRows ( triggerRows ) ) ; <nl> <nl> @ @ - 396 , 14 + 396 , 33 @ @ public final class LegacySchemaMigrator <nl> return false ; <nl> } <nl> <nl> - private static void addDroppedColumns ( CFMetaData cfm , Map < String , Long > droppedTimes , Map < String , String > types ) <nl> + / * <nl> + * Prior to 3 . 0 we used to not store the type of the dropped columns , relying on all collection info being <nl> + * present in the comparator , forever . That allowed us to perform certain validations in AlterTableStatement <nl> + * ( namely not allowing to re - add incompatible collection columns , with the same name , but a different type ) . <nl> + * <nl> + * In 3 . 0 , we no longer preserve the original comparator , and reconstruct it from the columns instead . That means <nl> + * that we should preserve the type of the dropped columns now , and , during migration , fetch the types from <nl> + * the original comparator if necessary . <nl> + * / <nl> + private static void addDroppedColumns ( CFMetaData cfm , AbstractType < ? > comparator , Map < String , Long > droppedTimes ) <nl> { <nl> + AbstractType < ? > last = comparator . getComponents ( ) . get ( comparator . componentsCount ( ) - 1 ) ; <nl> + Map < ByteBuffer , CollectionType > collections = last instanceof ColumnToCollectionType <nl> + ? ( ( ColumnToCollectionType ) last ) . defined <nl> + : Collections . emptyMap ( ) ; <nl> + <nl> for ( Map . Entry < String , Long > entry : droppedTimes . entrySet ( ) ) <nl> { <nl> String name = entry . getKey ( ) ; <nl> + ByteBuffer nameBytes = UTF8Type . instance . decompose ( name ) ; <nl> long time = entry . getValue ( ) ; <nl> - AbstractType < ? > type = types . containsKey ( name ) ? TypeParser . parse ( types . get ( name ) ) : null ; <nl> - cfm . getDroppedColumns ( ) . put ( UTF8Type . instance . decompose ( name ) , new CFMetaData . DroppedColumn ( type , time ) ) ; <nl> + <nl> + AbstractType < ? > type = collections . containsKey ( nameBytes ) <nl> + ? collections . get ( nameBytes ) <nl> + : BytesType . instance ; <nl> + <nl> + cfm . getDroppedColumns ( ) . put ( nameBytes , new CFMetaData . DroppedColumn ( name , type , time ) ) ; <nl> } <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java <nl> index 739d8a3 . . 4228a46 100644 <nl> - - - a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java <nl> + + + b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java <nl> @ @ - 74 , 6 + 74 , 7 @ @ public final class SchemaKeyspace <nl> public static final String KEYSPACES = " keyspaces " ; <nl> public static final String TABLES = " tables " ; <nl> public static final String COLUMNS = " columns " ; <nl> + public static final String DROPPED _ COLUMNS = " dropped _ columns " ; <nl> public static final String TRIGGERS = " triggers " ; <nl> public static final String TYPES = " types " ; <nl> public static final String FUNCTIONS = " functions " ; <nl> @ @ - 97 , 7 + 98 , 6 @ @ public final class SchemaKeyspace <nl> " CREATE TABLE % s ( " <nl> + " keyspace _ name text , " <nl> + " table _ name text , " <nl> - + " id uuid , " <nl> + " bloom _ filter _ fp _ chance double , " <nl> + " caching map < text , text > , " <nl> + " comment text , " <nl> @ @ - 107 , 16 + 107 , 12 @ @ public final class SchemaKeyspace <nl> + " default _ time _ to _ live int , " <nl> + " flags set < text > , " / / SUPER , COUNTER , DENSE , COMPOUND <nl> + " gc _ grace _ seconds int , " <nl> + + " id uuid , " <nl> + " max _ index _ interval int , " <nl> + " memtable _ flush _ period _ in _ ms int , " <nl> + " min _ index _ interval int , " <nl> + " read _ repair _ chance double , " <nl> + " speculative _ retry text , " <nl> - <nl> - / / TODO : move into a separate table <nl> - + " dropped _ columns map < text , bigint > , " <nl> - + " dropped _ columns _ types map < text , text > , " <nl> - <nl> + " PRIMARY KEY ( ( keyspace _ name ) , table _ name ) ) " ) ; <nl> <nl> private static final CFMetaData Columns = <nl> @ @ - 135 , 6 + 131 , 17 @ @ public final class SchemaKeyspace <nl> + " validator text , " <nl> + " PRIMARY KEY ( ( keyspace _ name ) , table _ name , column _ name ) ) " ) ; <nl> <nl> + private static final CFMetaData DroppedColumns = <nl> + compile ( DROPPED _ COLUMNS , <nl> + " dropped column registry " , <nl> + " CREATE TABLE % s ( " <nl> + + " keyspace _ name text , " <nl> + + " table _ name text , " <nl> + + " column _ name text , " <nl> + + " dropped _ time timestamp , " <nl> + + " type text , " <nl> + + " PRIMARY KEY ( ( keyspace _ name ) , table _ name , column _ name ) ) " ) ; <nl> + <nl> private static final CFMetaData Triggers = <nl> compile ( TRIGGERS , <nl> " trigger definitions " , <nl> @ @ - 186 , 7 + 193 , 7 @ @ public final class SchemaKeyspace <nl> + " PRIMARY KEY ( ( keyspace _ name ) , aggregate _ name , signature ) ) " ) ; <nl> <nl> public static final List < CFMetaData > All = <nl> - ImmutableList . of ( Keyspaces , Tables , Columns , Triggers , Types , Functions , Aggregates ) ; <nl> + ImmutableList . of ( Keyspaces , Tables , Columns , DroppedColumns , Triggers , Types , Functions , Aggregates ) ; <nl> <nl> private static CFMetaData compile ( String name , String description , String schema ) <nl> { <nl> @ @ - 810 , 27 + 817 , 20 @ @ public final class SchemaKeyspace <nl> . map ( " caching " , table . getCaching ( ) . asMap ( ) ) <nl> . map ( " compaction " , buildCompactionMap ( table ) ) <nl> . map ( " compression " , table . compressionParameters ( ) . asMap ( ) ) <nl> - . set ( " flags " , flagsToStrings ( table . flags ( ) ) ) ; <nl> - <nl> - for ( Map . Entry < ByteBuffer , CFMetaData . DroppedColumn > entry : table . getDroppedColumns ( ) . entrySet ( ) ) <nl> - { <nl> - String name = UTF8Type . instance . getString ( entry . getKey ( ) ) ; <nl> - CFMetaData . DroppedColumn column = entry . getValue ( ) ; <nl> - adder . addMapEntry ( " dropped _ columns " , name , column . droppedTime ) ; <nl> - if ( column . type ! = null ) <nl> - adder . addMapEntry ( " dropped _ columns _ types " , name , column . type . toString ( ) ) ; <nl> - } <nl> + . set ( " flags " , flagsToStrings ( table . flags ( ) ) ) <nl> + . build ( ) ; <nl> <nl> if ( withColumnsAndTriggers ) <nl> { <nl> for ( ColumnDefinition column : table . allColumns ( ) ) <nl> addColumnToSchemaMutation ( table , column , timestamp , mutation ) ; <nl> <nl> + for ( CFMetaData . DroppedColumn column : table . getDroppedColumns ( ) . values ( ) ) <nl> + addDroppedColumnToSchemaMutation ( table , column , timestamp , mutation ) ; <nl> + <nl> for ( TriggerMetadata trigger : table . getTriggers ( ) ) <nl> addTriggerToSchemaMutation ( table , trigger , timestamp , mutation ) ; <nl> } <nl> - <nl> - adder . build ( ) ; <nl> } <nl> <nl> / * <nl> @ @ - 885 , 7 + 885 , 7 @ @ public final class SchemaKeyspace <nl> { <nl> / / Thrift only knows about the REGULAR ColumnDefinition type , so don ' t consider other type <nl> / / are being deleted just because they are not here . <nl> - if ( fromThrift & & column . kind ! = ColumnDefinition . Kind . REGULAR ) <nl> + if ( fromThrift & & column . kind ! = ColumnDefinition . Kind . REGULAR ) / / TODO FIXME <nl> continue ; <nl> <nl> dropColumnFromSchemaMutation ( oldTable , column , timestamp , mutation ) ; <nl> @ @ - 899 , 6 + 899 , 18 @ @ public final class SchemaKeyspace <nl> for ( ByteBuffer name : columnDiff . entriesDiffering ( ) . keySet ( ) ) <nl> addColumnToSchemaMutation ( newTable , newTable . getColumnDefinition ( name ) , timestamp , mutation ) ; <nl> <nl> + / / dropped columns <nl> + MapDifference < ByteBuffer , CFMetaData . DroppedColumn > droppedColumnDiff = <nl> + Maps . difference ( oldTable . getDroppedColumns ( ) , newTable . getDroppedColumns ( ) ) ; <nl> + <nl> + / / newly dropped columns <nl> + for ( CFMetaData . DroppedColumn column : droppedColumnDiff . entriesOnlyOnRight ( ) . values ( ) ) <nl> + addDroppedColumnToSchemaMutation ( newTable , column , timestamp , mutation ) ; <nl> + <nl> + / / columns added then dropped again <nl> + for ( ByteBuffer name : droppedColumnDiff . entriesDiffering ( ) . keySet ( ) ) <nl> + addDroppedColumnToSchemaMutation ( newTable , newTable . getDroppedColumns ( ) . get ( name ) , timestamp , mutation ) ; <nl> + <nl> MapDifference < String , TriggerMetadata > triggerDiff = triggersDiff ( oldTable . getTriggers ( ) , newTable . getTriggers ( ) ) ; <nl> <nl> / / dropped triggers <nl> @ @ - 994 , 10 + 1006 , 14 @ @ public final class SchemaKeyspace <nl> List < ColumnDefinition > columns = <nl> readSchemaPartitionForTableAndApply ( COLUMNS , keyspace , table , SchemaKeyspace : : createColumnsFromColumnsPartition ) ; <nl> <nl> + Map < ByteBuffer , CFMetaData . DroppedColumn > droppedColumns = <nl> + readSchemaPartitionForTableAndApply ( DROPPED _ COLUMNS , keyspace , table , SchemaKeyspace : : createDroppedColumnsFromDroppedColumnsPartition ) ; <nl> + <nl> Triggers triggers = <nl> readSchemaPartitionForTableAndApply ( TRIGGERS , keyspace , table , SchemaKeyspace : : createTriggersFromTriggersPartition ) ; <nl> <nl> - return createTableFromTableRowAndColumns ( row , columns ) . triggers ( triggers ) ; <nl> + return createTableFromTableRowAndColumns ( row , columns ) . droppedColumns ( droppedColumns ) <nl> + . triggers ( triggers ) ; <nl> } <nl> <nl> public static CFMetaData createTableFromTableRowAndColumns ( UntypedResultSet . Row row , List < ColumnDefinition > columns ) <nl> @ @ - 1046 , 14 + 1062 , 6 @ @ public final class SchemaKeyspace <nl> . readRepairChance ( row . getDouble ( " read _ repair _ chance " ) ) <nl> . speculativeRetry ( CFMetaData . SpeculativeRetry . fromString ( row . getString ( " speculative _ retry " ) ) ) ; <nl> <nl> - if ( row . has ( " dropped _ columns " ) ) <nl> - { <nl> - Map < String , String > types = row . has ( " dropped _ columns _ types " ) <nl> - ? row . getTextMap ( " dropped _ columns _ types " ) <nl> - : Collections . < String , String > emptyMap ( ) ; <nl> - addDroppedColumns ( cfm , row . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) , types ) ; <nl> - } <nl> - <nl> return cfm ; <nl> } <nl> <nl> @ @ - 1073 , 17 + 1081 , 6 @ @ public final class SchemaKeyspace <nl> . collect ( toSet ( ) ) ; <nl> } <nl> <nl> - private static void addDroppedColumns ( CFMetaData cfm , Map < String , Long > droppedTimes , Map < String , String > types ) <nl> - { <nl> - for ( Map . Entry < String , Long > entry : droppedTimes . entrySet ( ) ) <nl> - { <nl> - String name = entry . getKey ( ) ; <nl> - long time = entry . getValue ( ) ; <nl> - AbstractType < ? > type = types . containsKey ( name ) ? TypeParser . parse ( types . get ( name ) ) : null ; <nl> - cfm . getDroppedColumns ( ) . put ( UTF8Type . instance . decompose ( name ) , new CFMetaData . DroppedColumn ( type , time ) ) ; <nl> - } <nl> - } <nl> - <nl> / * <nl> * Column metadata serialization / deserialization . <nl> * / <nl> @ @ - 1146 , 6 + 1143 , 44 @ @ public final class SchemaKeyspace <nl> } <nl> <nl> / * <nl> + * Dropped column metadata serialization / deserialization . <nl> + * / <nl> + <nl> + private static void addDroppedColumnToSchemaMutation ( CFMetaData table , CFMetaData . DroppedColumn column , long timestamp , Mutation mutation ) <nl> + { <nl> + RowUpdateBuilder adder = new RowUpdateBuilder ( DroppedColumns , timestamp , mutation ) . clustering ( table . cfName , column . name ) ; <nl> + <nl> + adder . add ( " dropped _ time " , new Date ( TimeUnit . MICROSECONDS . toMillis ( column . droppedTime ) ) ) <nl> + . add ( " type " , column . type . toString ( ) ) <nl> + . build ( ) ; <nl> + } <nl> + <nl> + private static Map < ByteBuffer , CFMetaData . DroppedColumn > createDroppedColumnsFromDroppedColumnsPartition ( RowIterator serializedColumns ) <nl> + { <nl> + String query = String . format ( " SELECT * FROM % s . % s " , NAME , DROPPED _ COLUMNS ) ; <nl> + Map < ByteBuffer , CFMetaData . DroppedColumn > columns = new HashMap < > ( ) ; <nl> + for ( CFMetaData . DroppedColumn column : createDroppedColumnsFromDroppedColumnRows ( QueryProcessor . resultify ( query , serializedColumns ) ) ) <nl> + columns . put ( UTF8Type . instance . decompose ( column . name ) , column ) ; <nl> + return columns ; <nl> + } <nl> + <nl> + private static List < CFMetaData . DroppedColumn > createDroppedColumnsFromDroppedColumnRows ( UntypedResultSet rows ) <nl> + { <nl> + List < CFMetaData . DroppedColumn > columns = new ArrayList < > ( rows . size ( ) ) ; <nl> + rows . forEach ( row - > columns . add ( createDroppedColumnFromDroppedColumnRow ( row ) ) ) ; <nl> + return columns ; <nl> + } <nl> + <nl> + private static CFMetaData . DroppedColumn createDroppedColumnFromDroppedColumnRow ( UntypedResultSet . Row row ) <nl> + { <nl> + String name = row . getString ( " column _ name " ) ; <nl> + AbstractType type = TypeParser . parse ( row . getString ( " type " ) ) ; <nl> + long droppedTime = TimeUnit . MILLISECONDS . toMicros ( row . getLong ( " dropped _ time " ) ) ; <nl> + <nl> + return new CFMetaData . DroppedColumn ( name , type , droppedTime ) ; <nl> + } <nl> + <nl> + / * <nl> * Trigger metadata serialization / deserialization . <nl> * / <nl> <nl> diff - - git a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej <nl> deleted file mode 100644 <nl> index 460fc3a . . 0000000 <nl> - - - a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej <nl> + + + / dev / null <nl> @ @ - 1 , 80 + 0 , 0 @ @ <nl> - diff a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java 	 ( rejected hunks ) <nl> - @ @ - 1095 , 68 + 1095 , 32 @ @ public final class SchemaKeyspace <nl> - . build ( ) ; <nl> - } <nl> - <nl> - - private static String serializeKind ( ColumnDefinition . Kind kind , boolean isDense ) <nl> - - { <nl> - - / / For backward compatibility , we special case CLUSTERING _ COLUMN and the case where the table is dense . <nl> - - if ( kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) <nl> - - return " clustering _ key " ; <nl> - - <nl> - - if ( kind = = ColumnDefinition . Kind . REGULAR & & isDense ) <nl> - - return " compact _ value " ; <nl> - - <nl> - - return kind . toString ( ) . toLowerCase ( ) ; <nl> - - } <nl> - - <nl> - - public static ColumnDefinition . Kind deserializeKind ( String kind ) <nl> - - { <nl> - - if ( " clustering _ key " . equalsIgnoreCase ( kind ) ) <nl> - - return ColumnDefinition . Kind . CLUSTERING _ COLUMN ; <nl> - - if ( " compact _ value " . equalsIgnoreCase ( kind ) ) <nl> - - return ColumnDefinition . Kind . REGULAR ; <nl> - - return Enum . valueOf ( ColumnDefinition . Kind . class , kind . toUpperCase ( ) ) ; <nl> - - } <nl> - - <nl> - private static void dropColumnFromSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) <nl> - { <nl> - / / Note : we do want to use name . toString ( ) , not name . bytes directly for backward compatibility ( For CQL3 , this won ' t make a difference ) . <nl> - RowUpdateBuilder . deleteRow ( Columns , timestamp , mutation , table . cfName , column . name . toString ( ) ) ; <nl> - } <nl> - <nl> - - private static List < ColumnDefinition > createColumnsFromColumnRows ( UntypedResultSet rows , <nl> - - String keyspace , <nl> - - String table , <nl> - - AbstractType < ? > rawComparator , <nl> - - AbstractType < ? > rawSubComparator , <nl> - - boolean isSuper , <nl> - - boolean isCQLTable ) <nl> - + private static List < ColumnDefinition > createColumnsFromColumnRows ( UntypedResultSet rows ) <nl> - { <nl> - - List < ColumnDefinition > columns = new ArrayList < > ( ) ; <nl> - - for ( UntypedResultSet . Row row : rows ) <nl> - - columns . add ( createColumnFromColumnRow ( row , keyspace , table , rawComparator , rawSubComparator , isSuper , isCQLTable ) ) ; <nl> - + List < ColumnDefinition > columns = new ArrayList < > ( rows . size ( ) ) ; <nl> - + rows . forEach ( row - > columns . add ( createColumnFromColumnRow ( row ) ) ) ; <nl> - return columns ; <nl> - } <nl> - <nl> - - private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row , <nl> - - String keyspace , <nl> - - String table , <nl> - - AbstractType < ? > rawComparator , <nl> - - AbstractType < ? > rawSubComparator , <nl> - - boolean isSuper , <nl> - - boolean isCQLTable ) <nl> - + private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row ) <nl> - { <nl> - - ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; <nl> - + String keyspace = row . getString ( " keyspace _ name " ) ; <nl> - + String table = row . getString ( " table _ name " ) ; <nl> - + <nl> - + ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( " column _ name _ bytes " ) , row . getString ( " column _ name " ) ) ; <nl> - + <nl> - + ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( " type " ) . toUpperCase ( ) ) ; <nl> - <nl> - Integer componentIndex = null ; <nl> - if ( row . has ( " component _ index " ) ) <nl> - componentIndex = row . getInt ( " component _ index " ) ; <nl> - <nl> - - / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we <nl> - - / / we need to use the comparator fromString method <nl> - - AbstractType < ? > comparator = isCQLTable <nl> - - ? UTF8Type . instance <nl> - - : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; <nl> - - ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; <nl> - - <nl> - AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; <nl> - <nl> - IndexType indexType = null ; <nl> diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> index 659b6c6 . . eb5e5f5 100644 <nl> - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> @ @ - 241 , 6 + 241 , 7 @ @ public class LegacySchemaMigratorTest <nl> + " PRIMARY KEY ( ( bar , baz ) , qux , quz ) ) " <nl> + " WITH COMPACT STORAGE " , ks _ cql ) ) ) ) ; <nl> <nl> + keyspaces . add ( keyspaceWithDroppedCollections ( ) ) ; <nl> keyspaces . add ( keyspaceWithTriggers ( ) ) ; <nl> keyspaces . add ( keyspaceWithUDTs ( ) ) ; <nl> keyspaces . add ( keyspaceWithUDFs ( ) ) ; <nl> @ @ - 249 , 6 + 250 , 32 @ @ public class LegacySchemaMigratorTest <nl> return keyspaces ; <nl> } <nl> <nl> + private static KeyspaceMetadata keyspaceWithDroppedCollections ( ) <nl> + { <nl> + String keyspace = KEYSPACE _ PREFIX + " DroppedCollections " ; <nl> + <nl> + CFMetaData table = <nl> + CFMetaData . compile ( " CREATE TABLE dropped _ columns ( " <nl> + + " foo text , " <nl> + + " bar text , " <nl> + + " map1 map < text , text > , " <nl> + + " map2 map < int , int > , " <nl> + + " set1 set < ascii > , " <nl> + + " list1 list < blob > , " <nl> + + " PRIMARY KEY ( ( foo ) , bar ) ) " , <nl> + keyspace ) ; <nl> + <nl> + String [ ] collectionColumnNames = { " map1 " , " map2 " , " set1 " , " list1 " } ; <nl> + for ( String name : collectionColumnNames ) <nl> + { <nl> + ColumnDefinition column = table . getColumnDefinition ( bytes ( name ) ) ; <nl> + table . recordColumnDrop ( column ) ; <nl> + table . removeColumnDefinition ( column ) ; <nl> + } <nl> + <nl> + return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( 1 ) , Tables . of ( table ) ) ; <nl> + } <nl> + <nl> private static KeyspaceMetadata keyspaceWithTriggers ( ) <nl> { <nl> String keyspace = KEYSPACE _ PREFIX + " Triggers " ;
NEAREST DIFF (one line): diff - - git a / debian / changelog b / debian / changelog <nl> index 739e38a . . 76bac83 100644 <nl> - - - a / debian / changelog <nl> + + + b / debian / changelog <nl> @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low <nl> <nl> * New release <nl> <nl> - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 <nl> <nl> cassandra ( 1 . 1 . 10 ) unstable ; urgency = low <nl>

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / config / CFMetaData . java b / src / java / org / apache / cassandra / config / CFMetaData . java 
 index 81ef217 . . 6c53699 100644 
 - - - a / src / java / org / apache / cassandra / config / CFMetaData . java 
 + + + b / src / java / org / apache / cassandra / config / CFMetaData . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . ThreadLocalRandom ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . base . MoreObjects ; 
 import com . google . common . base . Objects ; 
 import com . google . common . base . Strings ; 
 import com . google . common . collect . * ; 
 @ @ - 1193 , 7 + 1194 , 7 @ @ public final class CFMetaData 
 
 public void recordColumnDrop ( ColumnDefinition def ) 
 { 
 - droppedColumns . put ( def . name . bytes , new DroppedColumn ( def . type , FBUtilities . timestampMicros ( ) ) ) ; 
 + droppedColumns . put ( def . name . bytes , new DroppedColumn ( def . name . toString ( ) , def . type , FBUtilities . timestampMicros ( ) ) ) ; 
 } 
 
 public void renameColumn ( ColumnIdentifier from , ColumnIdentifier to ) throws InvalidRequestException 
 @ @ - 1261 , 6 + 1262 , 14 @ @ public final class CFMetaData 
 return false ; 
 } 
 
 + public boolean hasDroppedCollectionColumns ( ) 
 + { 
 + for ( DroppedColumn def : getDroppedColumns ( ) . values ( ) ) 
 + if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) 
 + return true ; 
 + return false ; 
 + } 
 + 
 public boolean isSuper ( ) 
 { 
 return isSuper ; 
 @ @ - 1536 , 13 + 1545 , 48 @ @ public final class CFMetaData 
 
 public static class DroppedColumn 
 { 
 + / / we only allow dropping REGULAR columns , from CQL - native tables , so the names are always of UTF8Type 
 + public final String name ; 
 public final AbstractType < ? > type ; 
 + 
 + / / drop timestamp , in microseconds , yet with millisecond granularity 
 public final long droppedTime ; 
 
 - public DroppedColumn ( AbstractType < ? > type , long droppedTime ) 
 + public DroppedColumn ( String name , AbstractType < ? > type , long droppedTime ) 
 { 
 + this . name = name ; 
 this . type = type ; 
 this . droppedTime = droppedTime ; 
 } 
 + 
 + @ Override 
 + public boolean equals ( Object o ) 
 + { 
 + if ( this = = o ) 
 + return true ; 
 + 
 + if ( ! ( o instanceof DroppedColumn ) ) 
 + return false ; 
 + 
 + DroppedColumn dc = ( DroppedColumn ) o ; 
 + 
 + return name . equals ( dc . name ) & & type . equals ( dc . type ) & & droppedTime = = dc . droppedTime ; 
 + } 
 + 
 + @ Override 
 + public int hashCode ( ) 
 + { 
 + return Objects . hashCode ( name , type , droppedTime ) ; 
 + } 
 + 
 + @ Override 
 + public String toString ( ) 
 + { 
 + return MoreObjects . toStringHelper ( this ) 
 + . add ( " name " , name ) 
 + . add ( " type " , type ) 
 + . add ( " droppedTime " , droppedTime ) 
 + . toString ( ) ; 
 + } 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 index e0c5f4e . . a247cdb 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 @ @ - 129 , 11 + 129 , 10 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 / / some data using the old type , and so we can ' t allow adding a collection with the same name unless 
 / / the types are compatible ( see # 6276 ) . 
 CFMetaData . DroppedColumn dropped = cfm . getDroppedColumns ( ) . get ( columnName . bytes ) ; 
 - / / We could have type = = null for old dropped columns , in which case we play it safe and refuse 
 - if ( dropped ! = null & & ( dropped . type = = null | | ( dropped . type instanceof CollectionType & & ! type . isCompatibleWith ( dropped . type ) ) ) ) 
 + if ( dropped ! = null & & dropped . type instanceof CollectionType & & ! type . isCompatibleWith ( dropped . type ) ) 
 throw new InvalidRequestException ( String . format ( " Cannot add a collection with the name % s " + 
 " because a collection with the same name and a different type % s has already been used in the past " , 
 - columnName , dropped . type = = null ? " " : " ( " + dropped . type . asCQL3Type ( ) + " ) " ) ) ; 
 + columnName , " ( " + dropped . type . asCQL3Type ( ) + ' ) ' ) ) ; 
 } 
 
 Integer componentIndex = cfm . isCompound ( ) ? cfm . comparator . size ( ) : null ; 
 diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index 9eb7145 . . f063256 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 41 , 6 + 41 , 8 @ @ import org . apache . cassandra . thrift . ColumnDef ; 
 import org . apache . cassandra . utils . * ; 
 import org . apache . hadoop . io . serializer . Serialization ; 
 
 + import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; 
 + 
 / * * 
 * Functions to deal with the old format . 
 * / 
 @ @ - 67 , 7 + 69 , 7 @ @ public abstract class LegacyLayout 
 return comparator . subtype ( 0 ) ; 
 } 
 
 - boolean hasCollections = metadata . hasCollectionColumns ( ) ; 
 + boolean hasCollections = metadata . hasCollectionColumns ( ) | | metadata . hasDroppedCollectionColumns ( ) ; 
 List < AbstractType < ? > > types = new ArrayList < > ( comparator . size ( ) + ( metadata . isDense ( ) ? 0 : 1 ) + ( hasCollections ? 1 : 0 ) ) ; 
 
 types . addAll ( comparator . subtypes ( ) ) ; 
 @ @ - 75 , 14 + 77 , 19 @ @ public abstract class LegacyLayout 
 if ( ! metadata . isDense ( ) ) 
 { 
 types . add ( UTF8Type . instance ) ; 
 + 
 if ( hasCollections ) 
 { 
 Map < ByteBuffer , CollectionType > defined = new HashMap < > ( ) ; 
 + 
 + for ( CFMetaData . DroppedColumn def : metadata . getDroppedColumns ( ) . values ( ) ) 
 + if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) 
 + defined . put ( bytes ( def . name ) , ( CollectionType ) def . type ) ; 
 + 
 for ( ColumnDefinition def : metadata . partitionColumns ( ) ) 
 - { 
 if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) 
 - defined . put ( def . name . bytes , ( CollectionType ) def . type ) ; 
 - } 
 + defined . put ( def . name . bytes , ( CollectionType ) def . type ) ; 
 + 
 types . add ( ColumnToCollectionType . getInstance ( defined ) ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 index 159396b . . 879a505 100644 
 - - - a / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 + + + b / src / java / org / apache / cassandra / schema / LegacySchemaMigrator . java 
 @ @ - 330 , 7 + 330 , 7 @ @ public final class LegacySchemaMigrator 
 cfm . bloomFilterFpChance ( cfm . getBloomFilterFpChance ( ) ) ; 
 
 if ( tableRow . has ( " dropped _ columns " ) ) 
 - addDroppedColumns ( cfm , tableRow . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) , Collections . emptyMap ( ) ) ; 
 + addDroppedColumns ( cfm , rawComparator , tableRow . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) ) ; 
 
 cfm . triggers ( createTriggersFromTriggerRows ( triggerRows ) ) ; 
 
 @ @ - 396 , 14 + 396 , 33 @ @ public final class LegacySchemaMigrator 
 return false ; 
 } 
 
 - private static void addDroppedColumns ( CFMetaData cfm , Map < String , Long > droppedTimes , Map < String , String > types ) 
 + / * 
 + * Prior to 3 . 0 we used to not store the type of the dropped columns , relying on all collection info being 
 + * present in the comparator , forever . That allowed us to perform certain validations in AlterTableStatement 
 + * ( namely not allowing to re - add incompatible collection columns , with the same name , but a different type ) . 
 + * 
 + * In 3 . 0 , we no longer preserve the original comparator , and reconstruct it from the columns instead . That means 
 + * that we should preserve the type of the dropped columns now , and , during migration , fetch the types from 
 + * the original comparator if necessary . 
 + * / 
 + private static void addDroppedColumns ( CFMetaData cfm , AbstractType < ? > comparator , Map < String , Long > droppedTimes ) 
 { 
 + AbstractType < ? > last = comparator . getComponents ( ) . get ( comparator . componentsCount ( ) - 1 ) ; 
 + Map < ByteBuffer , CollectionType > collections = last instanceof ColumnToCollectionType 
 + ? ( ( ColumnToCollectionType ) last ) . defined 
 + : Collections . emptyMap ( ) ; 
 + 
 for ( Map . Entry < String , Long > entry : droppedTimes . entrySet ( ) ) 
 { 
 String name = entry . getKey ( ) ; 
 + ByteBuffer nameBytes = UTF8Type . instance . decompose ( name ) ; 
 long time = entry . getValue ( ) ; 
 - AbstractType < ? > type = types . containsKey ( name ) ? TypeParser . parse ( types . get ( name ) ) : null ; 
 - cfm . getDroppedColumns ( ) . put ( UTF8Type . instance . decompose ( name ) , new CFMetaData . DroppedColumn ( type , time ) ) ; 
 + 
 + AbstractType < ? > type = collections . containsKey ( nameBytes ) 
 + ? collections . get ( nameBytes ) 
 + : BytesType . instance ; 
 + 
 + cfm . getDroppedColumns ( ) . put ( nameBytes , new CFMetaData . DroppedColumn ( name , type , time ) ) ; 
 } 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java 
 index 739d8a3 . . 4228a46 100644 
 - - - a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java 
 + + + b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java 
 @ @ - 74 , 6 + 74 , 7 @ @ public final class SchemaKeyspace 
 public static final String KEYSPACES = " keyspaces " ; 
 public static final String TABLES = " tables " ; 
 public static final String COLUMNS = " columns " ; 
 + public static final String DROPPED _ COLUMNS = " dropped _ columns " ; 
 public static final String TRIGGERS = " triggers " ; 
 public static final String TYPES = " types " ; 
 public static final String FUNCTIONS = " functions " ; 
 @ @ - 97 , 7 + 98 , 6 @ @ public final class SchemaKeyspace 
 " CREATE TABLE % s ( " 
 + " keyspace _ name text , " 
 + " table _ name text , " 
 - + " id uuid , " 
 + " bloom _ filter _ fp _ chance double , " 
 + " caching map < text , text > , " 
 + " comment text , " 
 @ @ - 107 , 16 + 107 , 12 @ @ public final class SchemaKeyspace 
 + " default _ time _ to _ live int , " 
 + " flags set < text > , " / / SUPER , COUNTER , DENSE , COMPOUND 
 + " gc _ grace _ seconds int , " 
 + + " id uuid , " 
 + " max _ index _ interval int , " 
 + " memtable _ flush _ period _ in _ ms int , " 
 + " min _ index _ interval int , " 
 + " read _ repair _ chance double , " 
 + " speculative _ retry text , " 
 - 
 - / / TODO : move into a separate table 
 - + " dropped _ columns map < text , bigint > , " 
 - + " dropped _ columns _ types map < text , text > , " 
 - 
 + " PRIMARY KEY ( ( keyspace _ name ) , table _ name ) ) " ) ; 
 
 private static final CFMetaData Columns = 
 @ @ - 135 , 6 + 131 , 17 @ @ public final class SchemaKeyspace 
 + " validator text , " 
 + " PRIMARY KEY ( ( keyspace _ name ) , table _ name , column _ name ) ) " ) ; 
 
 + private static final CFMetaData DroppedColumns = 
 + compile ( DROPPED _ COLUMNS , 
 + " dropped column registry " , 
 + " CREATE TABLE % s ( " 
 + + " keyspace _ name text , " 
 + + " table _ name text , " 
 + + " column _ name text , " 
 + + " dropped _ time timestamp , " 
 + + " type text , " 
 + + " PRIMARY KEY ( ( keyspace _ name ) , table _ name , column _ name ) ) " ) ; 
 + 
 private static final CFMetaData Triggers = 
 compile ( TRIGGERS , 
 " trigger definitions " , 
 @ @ - 186 , 7 + 193 , 7 @ @ public final class SchemaKeyspace 
 + " PRIMARY KEY ( ( keyspace _ name ) , aggregate _ name , signature ) ) " ) ; 
 
 public static final List < CFMetaData > All = 
 - ImmutableList . of ( Keyspaces , Tables , Columns , Triggers , Types , Functions , Aggregates ) ; 
 + ImmutableList . of ( Keyspaces , Tables , Columns , DroppedColumns , Triggers , Types , Functions , Aggregates ) ; 
 
 private static CFMetaData compile ( String name , String description , String schema ) 
 { 
 @ @ - 810 , 27 + 817 , 20 @ @ public final class SchemaKeyspace 
 . map ( " caching " , table . getCaching ( ) . asMap ( ) ) 
 . map ( " compaction " , buildCompactionMap ( table ) ) 
 . map ( " compression " , table . compressionParameters ( ) . asMap ( ) ) 
 - . set ( " flags " , flagsToStrings ( table . flags ( ) ) ) ; 
 - 
 - for ( Map . Entry < ByteBuffer , CFMetaData . DroppedColumn > entry : table . getDroppedColumns ( ) . entrySet ( ) ) 
 - { 
 - String name = UTF8Type . instance . getString ( entry . getKey ( ) ) ; 
 - CFMetaData . DroppedColumn column = entry . getValue ( ) ; 
 - adder . addMapEntry ( " dropped _ columns " , name , column . droppedTime ) ; 
 - if ( column . type ! = null ) 
 - adder . addMapEntry ( " dropped _ columns _ types " , name , column . type . toString ( ) ) ; 
 - } 
 + . set ( " flags " , flagsToStrings ( table . flags ( ) ) ) 
 + . build ( ) ; 
 
 if ( withColumnsAndTriggers ) 
 { 
 for ( ColumnDefinition column : table . allColumns ( ) ) 
 addColumnToSchemaMutation ( table , column , timestamp , mutation ) ; 
 
 + for ( CFMetaData . DroppedColumn column : table . getDroppedColumns ( ) . values ( ) ) 
 + addDroppedColumnToSchemaMutation ( table , column , timestamp , mutation ) ; 
 + 
 for ( TriggerMetadata trigger : table . getTriggers ( ) ) 
 addTriggerToSchemaMutation ( table , trigger , timestamp , mutation ) ; 
 } 
 - 
 - adder . build ( ) ; 
 } 
 
 / * 
 @ @ - 885 , 7 + 885 , 7 @ @ public final class SchemaKeyspace 
 { 
 / / Thrift only knows about the REGULAR ColumnDefinition type , so don ' t consider other type 
 / / are being deleted just because they are not here . 
 - if ( fromThrift & & column . kind ! = ColumnDefinition . Kind . REGULAR ) 
 + if ( fromThrift & & column . kind ! = ColumnDefinition . Kind . REGULAR ) / / TODO FIXME 
 continue ; 
 
 dropColumnFromSchemaMutation ( oldTable , column , timestamp , mutation ) ; 
 @ @ - 899 , 6 + 899 , 18 @ @ public final class SchemaKeyspace 
 for ( ByteBuffer name : columnDiff . entriesDiffering ( ) . keySet ( ) ) 
 addColumnToSchemaMutation ( newTable , newTable . getColumnDefinition ( name ) , timestamp , mutation ) ; 
 
 + / / dropped columns 
 + MapDifference < ByteBuffer , CFMetaData . DroppedColumn > droppedColumnDiff = 
 + Maps . difference ( oldTable . getDroppedColumns ( ) , newTable . getDroppedColumns ( ) ) ; 
 + 
 + / / newly dropped columns 
 + for ( CFMetaData . DroppedColumn column : droppedColumnDiff . entriesOnlyOnRight ( ) . values ( ) ) 
 + addDroppedColumnToSchemaMutation ( newTable , column , timestamp , mutation ) ; 
 + 
 + / / columns added then dropped again 
 + for ( ByteBuffer name : droppedColumnDiff . entriesDiffering ( ) . keySet ( ) ) 
 + addDroppedColumnToSchemaMutation ( newTable , newTable . getDroppedColumns ( ) . get ( name ) , timestamp , mutation ) ; 
 + 
 MapDifference < String , TriggerMetadata > triggerDiff = triggersDiff ( oldTable . getTriggers ( ) , newTable . getTriggers ( ) ) ; 
 
 / / dropped triggers 
 @ @ - 994 , 10 + 1006 , 14 @ @ public final class SchemaKeyspace 
 List < ColumnDefinition > columns = 
 readSchemaPartitionForTableAndApply ( COLUMNS , keyspace , table , SchemaKeyspace : : createColumnsFromColumnsPartition ) ; 
 
 + Map < ByteBuffer , CFMetaData . DroppedColumn > droppedColumns = 
 + readSchemaPartitionForTableAndApply ( DROPPED _ COLUMNS , keyspace , table , SchemaKeyspace : : createDroppedColumnsFromDroppedColumnsPartition ) ; 
 + 
 Triggers triggers = 
 readSchemaPartitionForTableAndApply ( TRIGGERS , keyspace , table , SchemaKeyspace : : createTriggersFromTriggersPartition ) ; 
 
 - return createTableFromTableRowAndColumns ( row , columns ) . triggers ( triggers ) ; 
 + return createTableFromTableRowAndColumns ( row , columns ) . droppedColumns ( droppedColumns ) 
 + . triggers ( triggers ) ; 
 } 
 
 public static CFMetaData createTableFromTableRowAndColumns ( UntypedResultSet . Row row , List < ColumnDefinition > columns ) 
 @ @ - 1046 , 14 + 1062 , 6 @ @ public final class SchemaKeyspace 
 . readRepairChance ( row . getDouble ( " read _ repair _ chance " ) ) 
 . speculativeRetry ( CFMetaData . SpeculativeRetry . fromString ( row . getString ( " speculative _ retry " ) ) ) ; 
 
 - if ( row . has ( " dropped _ columns " ) ) 
 - { 
 - Map < String , String > types = row . has ( " dropped _ columns _ types " ) 
 - ? row . getTextMap ( " dropped _ columns _ types " ) 
 - : Collections . < String , String > emptyMap ( ) ; 
 - addDroppedColumns ( cfm , row . getMap ( " dropped _ columns " , UTF8Type . instance , LongType . instance ) , types ) ; 
 - } 
 - 
 return cfm ; 
 } 
 
 @ @ - 1073 , 17 + 1081 , 6 @ @ public final class SchemaKeyspace 
 . collect ( toSet ( ) ) ; 
 } 
 
 - private static void addDroppedColumns ( CFMetaData cfm , Map < String , Long > droppedTimes , Map < String , String > types ) 
 - { 
 - for ( Map . Entry < String , Long > entry : droppedTimes . entrySet ( ) ) 
 - { 
 - String name = entry . getKey ( ) ; 
 - long time = entry . getValue ( ) ; 
 - AbstractType < ? > type = types . containsKey ( name ) ? TypeParser . parse ( types . get ( name ) ) : null ; 
 - cfm . getDroppedColumns ( ) . put ( UTF8Type . instance . decompose ( name ) , new CFMetaData . DroppedColumn ( type , time ) ) ; 
 - } 
 - } 
 - 
 / * 
 * Column metadata serialization / deserialization . 
 * / 
 @ @ - 1146 , 6 + 1143 , 44 @ @ public final class SchemaKeyspace 
 } 
 
 / * 
 + * Dropped column metadata serialization / deserialization . 
 + * / 
 + 
 + private static void addDroppedColumnToSchemaMutation ( CFMetaData table , CFMetaData . DroppedColumn column , long timestamp , Mutation mutation ) 
 + { 
 + RowUpdateBuilder adder = new RowUpdateBuilder ( DroppedColumns , timestamp , mutation ) . clustering ( table . cfName , column . name ) ; 
 + 
 + adder . add ( " dropped _ time " , new Date ( TimeUnit . MICROSECONDS . toMillis ( column . droppedTime ) ) ) 
 + . add ( " type " , column . type . toString ( ) ) 
 + . build ( ) ; 
 + } 
 + 
 + private static Map < ByteBuffer , CFMetaData . DroppedColumn > createDroppedColumnsFromDroppedColumnsPartition ( RowIterator serializedColumns ) 
 + { 
 + String query = String . format ( " SELECT * FROM % s . % s " , NAME , DROPPED _ COLUMNS ) ; 
 + Map < ByteBuffer , CFMetaData . DroppedColumn > columns = new HashMap < > ( ) ; 
 + for ( CFMetaData . DroppedColumn column : createDroppedColumnsFromDroppedColumnRows ( QueryProcessor . resultify ( query , serializedColumns ) ) ) 
 + columns . put ( UTF8Type . instance . decompose ( column . name ) , column ) ; 
 + return columns ; 
 + } 
 + 
 + private static List < CFMetaData . DroppedColumn > createDroppedColumnsFromDroppedColumnRows ( UntypedResultSet rows ) 
 + { 
 + List < CFMetaData . DroppedColumn > columns = new ArrayList < > ( rows . size ( ) ) ; 
 + rows . forEach ( row - > columns . add ( createDroppedColumnFromDroppedColumnRow ( row ) ) ) ; 
 + return columns ; 
 + } 
 + 
 + private static CFMetaData . DroppedColumn createDroppedColumnFromDroppedColumnRow ( UntypedResultSet . Row row ) 
 + { 
 + String name = row . getString ( " column _ name " ) ; 
 + AbstractType type = TypeParser . parse ( row . getString ( " type " ) ) ; 
 + long droppedTime = TimeUnit . MILLISECONDS . toMicros ( row . getLong ( " dropped _ time " ) ) ; 
 + 
 + return new CFMetaData . DroppedColumn ( name , type , droppedTime ) ; 
 + } 
 + 
 + / * 
 * Trigger metadata serialization / deserialization . 
 * / 
 
 diff - - git a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej 
 deleted file mode 100644 
 index 460fc3a . . 0000000 
 - - - a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java . rej 
 + + + / dev / null 
 @ @ - 1 , 80 + 0 , 0 @ @ 
 - diff a / src / java / org / apache / cassandra / schema / SchemaKeyspace . java b / src / java / org / apache / cassandra / schema / SchemaKeyspace . java 	 ( rejected hunks ) 
 - @ @ - 1095 , 68 + 1095 , 32 @ @ public final class SchemaKeyspace 
 - . build ( ) ; 
 - } 
 - 
 - - private static String serializeKind ( ColumnDefinition . Kind kind , boolean isDense ) 
 - - { 
 - - / / For backward compatibility , we special case CLUSTERING _ COLUMN and the case where the table is dense . 
 - - if ( kind = = ColumnDefinition . Kind . CLUSTERING _ COLUMN ) 
 - - return " clustering _ key " ; 
 - - 
 - - if ( kind = = ColumnDefinition . Kind . REGULAR & & isDense ) 
 - - return " compact _ value " ; 
 - - 
 - - return kind . toString ( ) . toLowerCase ( ) ; 
 - - } 
 - - 
 - - public static ColumnDefinition . Kind deserializeKind ( String kind ) 
 - - { 
 - - if ( " clustering _ key " . equalsIgnoreCase ( kind ) ) 
 - - return ColumnDefinition . Kind . CLUSTERING _ COLUMN ; 
 - - if ( " compact _ value " . equalsIgnoreCase ( kind ) ) 
 - - return ColumnDefinition . Kind . REGULAR ; 
 - - return Enum . valueOf ( ColumnDefinition . Kind . class , kind . toUpperCase ( ) ) ; 
 - - } 
 - - 
 - private static void dropColumnFromSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) 
 - { 
 - / / Note : we do want to use name . toString ( ) , not name . bytes directly for backward compatibility ( For CQL3 , this won ' t make a difference ) . 
 - RowUpdateBuilder . deleteRow ( Columns , timestamp , mutation , table . cfName , column . name . toString ( ) ) ; 
 - } 
 - 
 - - private static List < ColumnDefinition > createColumnsFromColumnRows ( UntypedResultSet rows , 
 - - String keyspace , 
 - - String table , 
 - - AbstractType < ? > rawComparator , 
 - - AbstractType < ? > rawSubComparator , 
 - - boolean isSuper , 
 - - boolean isCQLTable ) 
 - + private static List < ColumnDefinition > createColumnsFromColumnRows ( UntypedResultSet rows ) 
 - { 
 - - List < ColumnDefinition > columns = new ArrayList < > ( ) ; 
 - - for ( UntypedResultSet . Row row : rows ) 
 - - columns . add ( createColumnFromColumnRow ( row , keyspace , table , rawComparator , rawSubComparator , isSuper , isCQLTable ) ) ; 
 - + List < ColumnDefinition > columns = new ArrayList < > ( rows . size ( ) ) ; 
 - + rows . forEach ( row - > columns . add ( createColumnFromColumnRow ( row ) ) ) ; 
 - return columns ; 
 - } 
 - 
 - - private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row , 
 - - String keyspace , 
 - - String table , 
 - - AbstractType < ? > rawComparator , 
 - - AbstractType < ? > rawSubComparator , 
 - - boolean isSuper , 
 - - boolean isCQLTable ) 
 - + private static ColumnDefinition createColumnFromColumnRow ( UntypedResultSet . Row row ) 
 - { 
 - - ColumnDefinition . Kind kind = deserializeKind ( row . getString ( " type " ) ) ; 
 - + String keyspace = row . getString ( " keyspace _ name " ) ; 
 - + String table = row . getString ( " table _ name " ) ; 
 - + 
 - + ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( " column _ name _ bytes " ) , row . getString ( " column _ name " ) ) ; 
 - + 
 - + ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( " type " ) . toUpperCase ( ) ) ; 
 - 
 - Integer componentIndex = null ; 
 - if ( row . has ( " component _ index " ) ) 
 - componentIndex = row . getInt ( " component _ index " ) ; 
 - 
 - - / / Note : we save the column name as string , but we should not assume that it is an UTF8 name , we 
 - - / / we need to use the comparator fromString method 
 - - AbstractType < ? > comparator = isCQLTable 
 - - ? UTF8Type . instance 
 - - : CompactTables . columnDefinitionComparator ( kind , isSuper , rawComparator , rawSubComparator ) ; 
 - - ColumnIdentifier name = ColumnIdentifier . getInterned ( comparator . fromString ( row . getString ( " column _ name " ) ) , comparator ) ; 
 - - 
 - AbstractType < ? > validator = parseType ( row . getString ( " validator " ) ) ; 
 - 
 - IndexType indexType = null ; 
 diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 index 659b6c6 . . eb5e5f5 100644 
 - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 @ @ - 241 , 6 + 241 , 7 @ @ public class LegacySchemaMigratorTest 
 + " PRIMARY KEY ( ( bar , baz ) , qux , quz ) ) " 
 + " WITH COMPACT STORAGE " , ks _ cql ) ) ) ) ; 
 
 + keyspaces . add ( keyspaceWithDroppedCollections ( ) ) ; 
 keyspaces . add ( keyspaceWithTriggers ( ) ) ; 
 keyspaces . add ( keyspaceWithUDTs ( ) ) ; 
 keyspaces . add ( keyspaceWithUDFs ( ) ) ; 
 @ @ - 249 , 6 + 250 , 32 @ @ public class LegacySchemaMigratorTest 
 return keyspaces ; 
 } 
 
 + private static KeyspaceMetadata keyspaceWithDroppedCollections ( ) 
 + { 
 + String keyspace = KEYSPACE _ PREFIX + " DroppedCollections " ; 
 + 
 + CFMetaData table = 
 + CFMetaData . compile ( " CREATE TABLE dropped _ columns ( " 
 + + " foo text , " 
 + + " bar text , " 
 + + " map1 map < text , text > , " 
 + + " map2 map < int , int > , " 
 + + " set1 set < ascii > , " 
 + + " list1 list < blob > , " 
 + + " PRIMARY KEY ( ( foo ) , bar ) ) " , 
 + keyspace ) ; 
 + 
 + String [ ] collectionColumnNames = { " map1 " , " map2 " , " set1 " , " list1 " } ; 
 + for ( String name : collectionColumnNames ) 
 + { 
 + ColumnDefinition column = table . getColumnDefinition ( bytes ( name ) ) ; 
 + table . recordColumnDrop ( column ) ; 
 + table . removeColumnDefinition ( column ) ; 
 + } 
 + 
 + return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( 1 ) , Tables . of ( table ) ) ; 
 + } 
 + 
 private static KeyspaceMetadata keyspaceWithTriggers ( ) 
 { 
 String keyspace = KEYSPACE _ PREFIX + " Triggers " ;

NEAREST DIFF:
diff - - git a / debian / changelog b / debian / changelog 
 index 739e38a . . 76bac83 100644 
 - - - a / debian / changelog 
 + + + b / debian / changelog 
 @ @ - 2 , 7 + 2 , 7 @ @ cassandra ( 1 . 1 . 11 ) unstable ; urgency = low 
 
 * New release 
 
 - - - Eric Evans < eevans @ apache . org > , 16 Apr 2013 18 : 56 : 03 - 0500 
 + - - Eric Evans < eevans @ apache . org > Tue , 16 Apr 2013 18 : 56 : 03 - 0500 
 
 cassandra ( 1 . 1 . 10 ) unstable ; urgency = low 

