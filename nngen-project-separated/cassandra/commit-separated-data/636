BLEU SCORE: 0.028398387225677897

TEST MSG: Fix time - order query check for non - frozen UDTs , frozen collections
GENERATED MSG: Skip sstable base on clustering in names query

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 576dfb5 . . 4280abd 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 6 @ @ <nl> 3 . 0 . 10 <nl> + * Fix potentially incomplete non - frozen UDT values when querying with the <nl> + full primary key specified ( CASSANDRA - 12605 ) <nl> * Skip writing MV mutations to commitlog on mutation . applyUnsafe ( ) ( CASSANDRA - 11670 ) <nl> * Establish consistent distinction between non - existing partition and NULL value for LWTs on static columns ( CASSANDRA - 12060 ) <nl> * Extend ColumnIdentifier . internedInstances key to include the type that generated the byte buffer ( CASSANDRA - 12516 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> index 886a918 . . 23b02f3 100644 <nl> - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java <nl> @ @ - 511 , 11 + 511 , 11 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> * 2 ) If we have a name filter ( so we query specific rows ) , we can make a bet : that all column for all queried row <nl> * will have data in the most recent sstable ( s ) , thus saving us from reading older ones . This does imply we <nl> * have a way to guarantee we have all the data for what is queried , which is only possible for name queries <nl> - * and if we have neither collections nor counters ( indeed , for a collection , we can ' t guarantee an older sstable <nl> - * won ' t have some elements that weren ' t in the most recent sstables , and counters are intrinsically a collection <nl> - * of shards so have the same problem ) . <nl> + * and if we have neither non - frozen collections / UDTs nor counters ( indeed , for a non - frozen collection or UDT , <nl> + * we can ' t guarantee an older sstable won ' t have some elements that weren ' t in the most recent sstables , <nl> + * and counters are intrinsically a collection of shards and so have the same problem ) . <nl> * / <nl> - if ( clusteringIndexFilter ( ) instanceof ClusteringIndexNamesFilter & & queryNeitherCountersNorCollections ( ) ) <nl> + if ( clusteringIndexFilter ( ) instanceof ClusteringIndexNamesFilter & & ! queriesMulticellType ( ) ) <nl> return queryMemtableAndSSTablesInTimestampOrder ( cfs , copyOnHeap , ( ClusteringIndexNamesFilter ) clusteringIndexFilter ( ) ) ; <nl> <nl> Tracing . trace ( " Acquiring sstable references " ) ; <nl> @ @ - 662 , 14 + 662 , 14 @ @ public class SinglePartitionReadCommand extends ReadCommand <nl> return clusteringIndexFilter ( ) . shouldInclude ( sstable ) ; <nl> } <nl> <nl> - private boolean queryNeitherCountersNorCollections ( ) <nl> + private boolean queriesMulticellType ( ) <nl> { <nl> for ( ColumnDefinition column : columnFilter ( ) . fetchedColumns ( ) ) <nl> { <nl> - if ( column . type . isCollection ( ) | | column . type . isCounter ( ) ) <nl> - return false ; <nl> + if ( column . type . isMultiCell ( ) | | column . type . isCounter ( ) ) <nl> + return true ; <nl> } <nl> - return true ; <nl> + return false ; <nl> } <nl> <nl> / * *
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 576dfb5 . . 4280abd 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 6 @ @ 
 3 . 0 . 10 
 + * Fix potentially incomplete non - frozen UDT values when querying with the 
 + full primary key specified ( CASSANDRA - 12605 ) 
 * Skip writing MV mutations to commitlog on mutation . applyUnsafe ( ) ( CASSANDRA - 11670 ) 
 * Establish consistent distinction between non - existing partition and NULL value for LWTs on static columns ( CASSANDRA - 12060 ) 
 * Extend ColumnIdentifier . internedInstances key to include the type that generated the byte buffer ( CASSANDRA - 12516 ) 
 diff - - git a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 index 886a918 . . 23b02f3 100644 
 - - - a / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / SinglePartitionReadCommand . java 
 @ @ - 511 , 11 + 511 , 11 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 * 2 ) If we have a name filter ( so we query specific rows ) , we can make a bet : that all column for all queried row 
 * will have data in the most recent sstable ( s ) , thus saving us from reading older ones . This does imply we 
 * have a way to guarantee we have all the data for what is queried , which is only possible for name queries 
 - * and if we have neither collections nor counters ( indeed , for a collection , we can ' t guarantee an older sstable 
 - * won ' t have some elements that weren ' t in the most recent sstables , and counters are intrinsically a collection 
 - * of shards so have the same problem ) . 
 + * and if we have neither non - frozen collections / UDTs nor counters ( indeed , for a non - frozen collection or UDT , 
 + * we can ' t guarantee an older sstable won ' t have some elements that weren ' t in the most recent sstables , 
 + * and counters are intrinsically a collection of shards and so have the same problem ) . 
 * / 
 - if ( clusteringIndexFilter ( ) instanceof ClusteringIndexNamesFilter & & queryNeitherCountersNorCollections ( ) ) 
 + if ( clusteringIndexFilter ( ) instanceof ClusteringIndexNamesFilter & & ! queriesMulticellType ( ) ) 
 return queryMemtableAndSSTablesInTimestampOrder ( cfs , copyOnHeap , ( ClusteringIndexNamesFilter ) clusteringIndexFilter ( ) ) ; 
 
 Tracing . trace ( " Acquiring sstable references " ) ; 
 @ @ - 662 , 14 + 662 , 14 @ @ public class SinglePartitionReadCommand extends ReadCommand 
 return clusteringIndexFilter ( ) . shouldInclude ( sstable ) ; 
 } 
 
 - private boolean queryNeitherCountersNorCollections ( ) 
 + private boolean queriesMulticellType ( ) 
 { 
 for ( ColumnDefinition column : columnFilter ( ) . fetchedColumns ( ) ) 
 { 
 - if ( column . type . isCollection ( ) | | column . type . isCounter ( ) ) 
 - return false ; 
 + if ( column . type . isMultiCell ( ) | | column . type . isCounter ( ) ) 
 + return true ; 
 } 
 - return true ; 
 + return false ; 
 } 
 
 / * *

NEAREST DIFF:
ELIMINATEDSENTENCE
