BLEU SCORE: 0.0156963464356626

TEST MSG: remove dead params
GENERATED MSG: SSTableExport uses correct validator to create string representation of partition keys

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> index 78b4d5d . . c4c48aa 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java <nl> @ @ - 140 , 10 + 140 , 10 @ @ public final class SingleColumnRelation extends Relation <nl> ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; <nl> if ( mapKey = = null ) <nl> { <nl> - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; <nl> + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; <nl> return new SingleColumnRestriction . EQ ( columnDef , term ) ; <nl> } <nl> - List < ? extends ColumnSpecification > receivers = toReceivers ( cfm , columnDef ) ; <nl> + List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef ) ; <nl> Term entryKey = toTerm ( Collections . singletonList ( receivers . get ( 0 ) ) , mapKey , cfm . ksName , boundNames ) ; <nl> Term entryValue = toTerm ( Collections . singletonList ( receivers . get ( 1 ) ) , value , cfm . ksName , boundNames ) ; <nl> return new SingleColumnRestriction . Contains ( columnDef , entryKey , entryValue ) ; <nl> @ @ - 154 , 7 + 154 , 7 @ @ public final class SingleColumnRelation extends Relation <nl> VariableSpecifications boundNames ) throws InvalidRequestException <nl> { <nl> ColumnDefinition columnDef = cfm . getColumnDefinition ( getEntity ( ) . prepare ( cfm ) ) ; <nl> - List < ? extends ColumnSpecification > receivers = toReceivers ( cfm , columnDef ) ; <nl> + List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef ) ; <nl> List < Term > terms = toTerms ( receivers , inValues , cfm . ksName , boundNames ) ; <nl> if ( terms = = null ) <nl> { <nl> @ @ - 171 , 7 + 171 , 7 @ @ public final class SingleColumnRelation extends Relation <nl> boolean inclusive ) throws InvalidRequestException <nl> { <nl> ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; <nl> - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; <nl> + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; <nl> return new SingleColumnRestriction . Slice ( columnDef , bound , inclusive , term ) ; <nl> } <nl> <nl> @ @ - 181 , 19 + 181 , 18 @ @ public final class SingleColumnRelation extends Relation <nl> boolean isKey ) throws InvalidRequestException <nl> { <nl> ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; <nl> - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; <nl> + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; <nl> return new SingleColumnRestriction . Contains ( columnDef , term , isKey ) ; <nl> } <nl> <nl> / * * <nl> * Returns the receivers for this relation . <nl> - * <nl> - * @ param cfm the Column Family meta data <nl> * @ param columnDef the column definition <nl> + * <nl> * @ return the receivers for the specified relation . <nl> * @ throws InvalidRequestException if the relation is invalid <nl> * / <nl> - private List < ? extends ColumnSpecification > toReceivers ( CFMetaData cfm , ColumnDefinition columnDef ) throws InvalidRequestException <nl> + private List < ? extends ColumnSpecification > toReceivers ( ColumnDefinition columnDef ) throws InvalidRequestException <nl> { <nl> ColumnSpecification receiver = columnDef ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java b / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java <nl> index f908e8c . . 5bc02c5 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java <nl> @ @ - 338 , 7 + 338 , 7 @ @ public abstract class ExtendedFilter <nl> { <nl> if ( def . type . isCollection ( ) & & def . type . isMultiCell ( ) ) <nl> { <nl> - if ( ! collectionSatisfies ( def , data , prefix , expression , collectionElement ) ) <nl> + if ( ! collectionSatisfies ( def , data , prefix , expression ) ) <nl> return false ; <nl> continue ; <nl> } <nl> @ @ - 390 , 7 + 390 , 7 @ @ public abstract class ExtendedFilter <nl> return true ; <nl> } <nl> <nl> - private static boolean collectionSatisfies ( ColumnDefinition def , ColumnFamily data , Composite prefix , IndexExpression expr , ByteBuffer collectionElement ) <nl> + private static boolean collectionSatisfies ( ColumnDefinition def , ColumnFamily data , Composite prefix , IndexExpression expr ) <nl> { <nl> assert def . type . isCollection ( ) & & def . type . isMultiCell ( ) ; <nl> CollectionType type = ( CollectionType ) def . type ; <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> index d06d05f . . ac5a7e5 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java <nl> @ @ - 297 , 7 + 297 , 7 @ @ public class CqlConfigHelper <nl> Optional < AuthProvider > authProvider = getAuthProvider ( conf ) ; <nl> Optional < SSLOptions > sslOptions = getSSLOptions ( conf ) ; <nl> Optional < Integer > protocolVersion = getProtocolVersion ( conf ) ; <nl> - LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , hosts ) ; <nl> + LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( hosts ) ; <nl> SocketOptions socketOptions = getReadSocketOptions ( conf ) ; <nl> QueryOptions queryOptions = getReadQueryOptions ( conf ) ; <nl> PoolingOptions poolingOptions = getReadPoolingOptions ( conf ) ; <nl> @ @ - 488 , 7 + 488 , 7 @ @ public class CqlConfigHelper <nl> return socketOptions ; <nl> } <nl> <nl> - private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String [ ] stickHosts ) <nl> + private static LoadBalancingPolicy getReadLoadBalancingPolicy ( final String [ ] stickHosts ) <nl> { <nl> return new LimitedLocalNodeFirstLocalBalancingPolicy ( stickHosts ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> index bc64582 . . 8195d2e 100644 <nl> - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java <nl> @ @ - 303 , 7 + 303 , 7 @ @ abstract class AbstractQueryPager implements QueryPager <nl> DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; <nl> return isReversed <nl> ? discardTail ( cf , toDiscard , newCf , cf . reverseIterator ( ) , tester ) <nl> - : discardHead ( cf , toDiscard , newCf , cf . iterator ( ) , tester ) ; <nl> + : discardHead ( toDiscard , newCf , cf . iterator ( ) , tester ) ; <nl> } <nl> <nl> private int discardLast ( ColumnFamily cf , int toDiscard , ColumnFamily newCf ) <nl> @ @ - 311 , 11 + 311 , 11 @ @ abstract class AbstractQueryPager implements QueryPager <nl> boolean isReversed = isReversed ( ) ; <nl> DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; <nl> return isReversed <nl> - ? discardHead ( cf , toDiscard , newCf , cf . reverseIterator ( ) , tester ) <nl> + ? discardHead ( toDiscard , newCf , cf . reverseIterator ( ) , tester ) <nl> : discardTail ( cf , toDiscard , newCf , cf . iterator ( ) , tester ) ; <nl> } <nl> <nl> - private int discardHead ( ColumnFamily cf , int toDiscard , ColumnFamily copy , Iterator < Cell > iter , DeletionInfo . InOrderTester tester ) <nl> + private int discardHead ( int toDiscard , ColumnFamily copy , Iterator < Cell > iter , DeletionInfo . InOrderTester tester ) <nl> { <nl> ColumnCounter counter = columnCounter ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / tools / SSTableExport . java b / src / java / org / apache / cassandra / tools / SSTableExport . java <nl> index b62f516 . . 61edad2 100644 <nl> - - - a / src / java / org / apache / cassandra / tools / SSTableExport . java <nl> + + + b / src / java / org / apache / cassandra / tools / SSTableExport . java <nl> @ @ - 313 , 7 + 313 , 7 @ @ public class SSTableExport <nl> <nl> / / This is necessary to accommodate the test suite since you cannot open a Reader more <nl> / / than once from within the same process . <nl> - static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes , CFMetaData metadata ) throws IOException <nl> + static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes ) throws IOException <nl> { <nl> Set < String > excludeSet = new HashSet < String > ( ) ; <nl> <nl> @ @ - 361 , 12 + 361 , 11 @ @ public class SSTableExport <nl> * @ param desc the descriptor of the sstable to read from <nl> * @ param outs PrintStream to write the output to <nl> * @ param excludes keys to exclude from export <nl> - * @ param metadata Metadata to print keys in a proper format <nl> * @ throws IOException on failure to read / write input / output <nl> * / <nl> - public static void export ( Descriptor desc , PrintStream outs , String [ ] excludes , CFMetaData metadata ) throws IOException <nl> + public static void export ( Descriptor desc , PrintStream outs , String [ ] excludes ) throws IOException <nl> { <nl> - export ( SSTableReader . open ( desc ) , outs , excludes , metadata ) ; <nl> + export ( SSTableReader . open ( desc ) , outs , excludes ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 374 , 12 + 373 , 11 @ @ public class SSTableExport <nl> * <nl> * @ param desc the descriptor of the sstable to read from <nl> * @ param excludes keys to exclude from export <nl> - * @ param metadata Metadata to print keys in a proper format <nl> * @ throws IOException on failure to read / write SSTable / standard out <nl> * / <nl> - public static void export ( Descriptor desc , String [ ] excludes , CFMetaData metadata ) throws IOException <nl> + public static void export ( Descriptor desc , String [ ] excludes ) throws IOException <nl> { <nl> - export ( desc , System . out , excludes , metadata ) ; <nl> + export ( desc , System . out , excludes ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 462 , 7 + 460 , 7 @ @ public class SSTableExport <nl> if ( ( keys ! = null ) & & ( keys . length > 0 ) ) <nl> export ( descriptor , System . out , Arrays . asList ( keys ) , excludes , cfStore . metadata ) ; <nl> else <nl> - export ( descriptor , excludes , cfStore . metadata ) ; <nl> + export ( descriptor , excludes ) ; <nl> } <nl> } <nl> catch ( IOException e ) <nl> diff - - git a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> index be78c5d . . 88846c5 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> + + + b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java <nl> @ @ - 102 , 7 + 102 , 7 @ @ public class NativeAllocator extends MemtableAllocator <nl> / / satisfy large allocations directly from JVM since they don ' t cause fragmentation <nl> / / as badly , and fill up our regions quickly <nl> if ( size > MAX _ CLONED _ SIZE ) <nl> - return allocateOversize ( size , opGroup ) ; <nl> + return allocateOversize ( size ) ; <nl> <nl> while ( true ) <nl> { <nl> @ @ - 143 , 7 + 143 , 7 @ @ public class NativeAllocator extends MemtableAllocator <nl> MemoryUtil . free ( next . peer ) ; <nl> } <nl> <nl> - private long allocateOversize ( int size , OpOrder . Group opGroup ) <nl> + private long allocateOversize ( int size ) <nl> { <nl> / / satisfy large allocations directly from JVM since they don ' t cause fragmentation <nl> / / as badly , and fill up our regions quickly <nl> diff - - git a / test / unit / org / apache / cassandra / tools / SSTableExportTest . java b / test / unit / org / apache / cassandra / tools / SSTableExportTest . java <nl> index f13f67d . . 023b5f3 100644 <nl> - - - a / test / unit / org / apache / cassandra / tools / SSTableExportTest . java <nl> + + + b / test / unit / org / apache / cassandra / tools / SSTableExportTest . java <nl> @ @ - 157 , 8 + 157 , 7 @ @ public class SSTableExportTest <nl> <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " Standard1 " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Standard1 " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } ) ; <nl> <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( " unexpected number of rows " , 2 , json . size ( ) ) ; <nl> @ @ - 207 , 8 + 206 , 7 @ @ public class SSTableExportTest <nl> <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " Standard1 " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Standard1 " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } ) ; <nl> <nl> / / Import JSON to another SSTable file <nl> File tempSS2 = tempSSTableFile ( KEYSPACE1 , " Standard1 " ) ; <nl> @ @ - 243 , 8 + 241 , 7 @ @ public class SSTableExportTest <nl> <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " Counter1 " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Counter1 " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; <nl> <nl> @ @ - 275 , 8 + 272 , 7 @ @ public class SSTableExportTest <nl> <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " ValuesWithQuotes " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " ValuesWithQuotes " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; <nl> <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; <nl> @ @ - 307 , 8 + 303 , 7 @ @ public class SSTableExportTest <nl> SSTableReader reader = writer . closeAndOpenReader ( ) ; <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " CFWithDeletionInfo " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Counter1 " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; <nl> <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; <nl> @ @ - 367 , 8 + 362 , 7 @ @ public class SSTableExportTest <nl> SSTableReader reader = writer . closeAndOpenReader ( ) ; <nl> / / Export to JSON and verify <nl> File tempJson = File . createTempFile ( " CFWithColumnNameEqualToDefaultKeyAlias " , " . json " ) ; <nl> - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " UUIDKeys " , BytesType . instance ) ) ; <nl> + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; <nl> <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( 1 , json . size ( ) ) ; <nl> @ @ - 399 , 8 + 393 , 7 @ @ public class SSTableExportTest <nl> File tempJson = File . createTempFile ( " CFWithAsciiKeys " , " . json " ) ; <nl> SSTableExport . export ( reader , <nl> new PrintStream ( tempJson . getPath ( ) ) , <nl> - new String [ 0 ] , <nl> - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " AsciiKeys " , BytesType . instance ) ) ; <nl> + new String [ 0 ] ) ; <nl> <nl> JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; <nl> assertEquals ( 1 , json . size ( ) ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 index 78b4d5d . . c4c48aa 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 + + + b / src / java / org / apache / cassandra / cql3 / SingleColumnRelation . java 
 @ @ - 140 , 10 + 140 , 10 @ @ public final class SingleColumnRelation extends Relation 
 ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; 
 if ( mapKey = = null ) 
 { 
 - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; 
 + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; 
 return new SingleColumnRestriction . EQ ( columnDef , term ) ; 
 } 
 - List < ? extends ColumnSpecification > receivers = toReceivers ( cfm , columnDef ) ; 
 + List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef ) ; 
 Term entryKey = toTerm ( Collections . singletonList ( receivers . get ( 0 ) ) , mapKey , cfm . ksName , boundNames ) ; 
 Term entryValue = toTerm ( Collections . singletonList ( receivers . get ( 1 ) ) , value , cfm . ksName , boundNames ) ; 
 return new SingleColumnRestriction . Contains ( columnDef , entryKey , entryValue ) ; 
 @ @ - 154 , 7 + 154 , 7 @ @ public final class SingleColumnRelation extends Relation 
 VariableSpecifications boundNames ) throws InvalidRequestException 
 { 
 ColumnDefinition columnDef = cfm . getColumnDefinition ( getEntity ( ) . prepare ( cfm ) ) ; 
 - List < ? extends ColumnSpecification > receivers = toReceivers ( cfm , columnDef ) ; 
 + List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef ) ; 
 List < Term > terms = toTerms ( receivers , inValues , cfm . ksName , boundNames ) ; 
 if ( terms = = null ) 
 { 
 @ @ - 171 , 7 + 171 , 7 @ @ public final class SingleColumnRelation extends Relation 
 boolean inclusive ) throws InvalidRequestException 
 { 
 ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; 
 - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; 
 + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; 
 return new SingleColumnRestriction . Slice ( columnDef , bound , inclusive , term ) ; 
 } 
 
 @ @ - 181 , 19 + 181 , 18 @ @ public final class SingleColumnRelation extends Relation 
 boolean isKey ) throws InvalidRequestException 
 { 
 ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; 
 - Term term = toTerm ( toReceivers ( cfm , columnDef ) , value , cfm . ksName , boundNames ) ; 
 + Term term = toTerm ( toReceivers ( columnDef ) , value , cfm . ksName , boundNames ) ; 
 return new SingleColumnRestriction . Contains ( columnDef , term , isKey ) ; 
 } 
 
 / * * 
 * Returns the receivers for this relation . 
 - * 
 - * @ param cfm the Column Family meta data 
 * @ param columnDef the column definition 
 + * 
 * @ return the receivers for the specified relation . 
 * @ throws InvalidRequestException if the relation is invalid 
 * / 
 - private List < ? extends ColumnSpecification > toReceivers ( CFMetaData cfm , ColumnDefinition columnDef ) throws InvalidRequestException 
 + private List < ? extends ColumnSpecification > toReceivers ( ColumnDefinition columnDef ) throws InvalidRequestException 
 { 
 ColumnSpecification receiver = columnDef ; 
 
 diff - - git a / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java b / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java 
 index f908e8c . . 5bc02c5 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / ExtendedFilter . java 
 @ @ - 338 , 7 + 338 , 7 @ @ public abstract class ExtendedFilter 
 { 
 if ( def . type . isCollection ( ) & & def . type . isMultiCell ( ) ) 
 { 
 - if ( ! collectionSatisfies ( def , data , prefix , expression , collectionElement ) ) 
 + if ( ! collectionSatisfies ( def , data , prefix , expression ) ) 
 return false ; 
 continue ; 
 } 
 @ @ - 390 , 7 + 390 , 7 @ @ public abstract class ExtendedFilter 
 return true ; 
 } 
 
 - private static boolean collectionSatisfies ( ColumnDefinition def , ColumnFamily data , Composite prefix , IndexExpression expr , ByteBuffer collectionElement ) 
 + private static boolean collectionSatisfies ( ColumnDefinition def , ColumnFamily data , Composite prefix , IndexExpression expr ) 
 { 
 assert def . type . isCollection ( ) & & def . type . isMultiCell ( ) ; 
 CollectionType type = ( CollectionType ) def . type ; 
 diff - - git a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 index d06d05f . . ac5a7e5 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 + + + b / src / java / org / apache / cassandra / hadoop / cql3 / CqlConfigHelper . java 
 @ @ - 297 , 7 + 297 , 7 @ @ public class CqlConfigHelper 
 Optional < AuthProvider > authProvider = getAuthProvider ( conf ) ; 
 Optional < SSLOptions > sslOptions = getSSLOptions ( conf ) ; 
 Optional < Integer > protocolVersion = getProtocolVersion ( conf ) ; 
 - LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( conf , hosts ) ; 
 + LoadBalancingPolicy loadBalancingPolicy = getReadLoadBalancingPolicy ( hosts ) ; 
 SocketOptions socketOptions = getReadSocketOptions ( conf ) ; 
 QueryOptions queryOptions = getReadQueryOptions ( conf ) ; 
 PoolingOptions poolingOptions = getReadPoolingOptions ( conf ) ; 
 @ @ - 488 , 7 + 488 , 7 @ @ public class CqlConfigHelper 
 return socketOptions ; 
 } 
 
 - private static LoadBalancingPolicy getReadLoadBalancingPolicy ( Configuration conf , final String [ ] stickHosts ) 
 + private static LoadBalancingPolicy getReadLoadBalancingPolicy ( final String [ ] stickHosts ) 
 { 
 return new LimitedLocalNodeFirstLocalBalancingPolicy ( stickHosts ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 index bc64582 . . 8195d2e 100644 
 - - - a / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 + + + b / src / java / org / apache / cassandra / service / pager / AbstractQueryPager . java 
 @ @ - 303 , 7 + 303 , 7 @ @ abstract class AbstractQueryPager implements QueryPager 
 DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; 
 return isReversed 
 ? discardTail ( cf , toDiscard , newCf , cf . reverseIterator ( ) , tester ) 
 - : discardHead ( cf , toDiscard , newCf , cf . iterator ( ) , tester ) ; 
 + : discardHead ( toDiscard , newCf , cf . iterator ( ) , tester ) ; 
 } 
 
 private int discardLast ( ColumnFamily cf , int toDiscard , ColumnFamily newCf ) 
 @ @ - 311 , 11 + 311 , 11 @ @ abstract class AbstractQueryPager implements QueryPager 
 boolean isReversed = isReversed ( ) ; 
 DeletionInfo . InOrderTester tester = cf . deletionInfo ( ) . inOrderTester ( isReversed ) ; 
 return isReversed 
 - ? discardHead ( cf , toDiscard , newCf , cf . reverseIterator ( ) , tester ) 
 + ? discardHead ( toDiscard , newCf , cf . reverseIterator ( ) , tester ) 
 : discardTail ( cf , toDiscard , newCf , cf . iterator ( ) , tester ) ; 
 } 
 
 - private int discardHead ( ColumnFamily cf , int toDiscard , ColumnFamily copy , Iterator < Cell > iter , DeletionInfo . InOrderTester tester ) 
 + private int discardHead ( int toDiscard , ColumnFamily copy , Iterator < Cell > iter , DeletionInfo . InOrderTester tester ) 
 { 
 ColumnCounter counter = columnCounter ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / tools / SSTableExport . java b / src / java / org / apache / cassandra / tools / SSTableExport . java 
 index b62f516 . . 61edad2 100644 
 - - - a / src / java / org / apache / cassandra / tools / SSTableExport . java 
 + + + b / src / java / org / apache / cassandra / tools / SSTableExport . java 
 @ @ - 313 , 7 + 313 , 7 @ @ public class SSTableExport 
 
 / / This is necessary to accommodate the test suite since you cannot open a Reader more 
 / / than once from within the same process . 
 - static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes , CFMetaData metadata ) throws IOException 
 + static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes ) throws IOException 
 { 
 Set < String > excludeSet = new HashSet < String > ( ) ; 
 
 @ @ - 361 , 12 + 361 , 11 @ @ public class SSTableExport 
 * @ param desc the descriptor of the sstable to read from 
 * @ param outs PrintStream to write the output to 
 * @ param excludes keys to exclude from export 
 - * @ param metadata Metadata to print keys in a proper format 
 * @ throws IOException on failure to read / write input / output 
 * / 
 - public static void export ( Descriptor desc , PrintStream outs , String [ ] excludes , CFMetaData metadata ) throws IOException 
 + public static void export ( Descriptor desc , PrintStream outs , String [ ] excludes ) throws IOException 
 { 
 - export ( SSTableReader . open ( desc ) , outs , excludes , metadata ) ; 
 + export ( SSTableReader . open ( desc ) , outs , excludes ) ; 
 } 
 
 / * * 
 @ @ - 374 , 12 + 373 , 11 @ @ public class SSTableExport 
 * 
 * @ param desc the descriptor of the sstable to read from 
 * @ param excludes keys to exclude from export 
 - * @ param metadata Metadata to print keys in a proper format 
 * @ throws IOException on failure to read / write SSTable / standard out 
 * / 
 - public static void export ( Descriptor desc , String [ ] excludes , CFMetaData metadata ) throws IOException 
 + public static void export ( Descriptor desc , String [ ] excludes ) throws IOException 
 { 
 - export ( desc , System . out , excludes , metadata ) ; 
 + export ( desc , System . out , excludes ) ; 
 } 
 
 / * * 
 @ @ - 462 , 7 + 460 , 7 @ @ public class SSTableExport 
 if ( ( keys ! = null ) & & ( keys . length > 0 ) ) 
 export ( descriptor , System . out , Arrays . asList ( keys ) , excludes , cfStore . metadata ) ; 
 else 
 - export ( descriptor , excludes , cfStore . metadata ) ; 
 + export ( descriptor , excludes ) ; 
 } 
 } 
 catch ( IOException e ) 
 diff - - git a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 index be78c5d . . 88846c5 100644 
 - - - a / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 + + + b / src / java / org / apache / cassandra / utils / memory / NativeAllocator . java 
 @ @ - 102 , 7 + 102 , 7 @ @ public class NativeAllocator extends MemtableAllocator 
 / / satisfy large allocations directly from JVM since they don ' t cause fragmentation 
 / / as badly , and fill up our regions quickly 
 if ( size > MAX _ CLONED _ SIZE ) 
 - return allocateOversize ( size , opGroup ) ; 
 + return allocateOversize ( size ) ; 
 
 while ( true ) 
 { 
 @ @ - 143 , 7 + 143 , 7 @ @ public class NativeAllocator extends MemtableAllocator 
 MemoryUtil . free ( next . peer ) ; 
 } 
 
 - private long allocateOversize ( int size , OpOrder . Group opGroup ) 
 + private long allocateOversize ( int size ) 
 { 
 / / satisfy large allocations directly from JVM since they don ' t cause fragmentation 
 / / as badly , and fill up our regions quickly 
 diff - - git a / test / unit / org / apache / cassandra / tools / SSTableExportTest . java b / test / unit / org / apache / cassandra / tools / SSTableExportTest . java 
 index f13f67d . . 023b5f3 100644 
 - - - a / test / unit / org / apache / cassandra / tools / SSTableExportTest . java 
 + + + b / test / unit / org / apache / cassandra / tools / SSTableExportTest . java 
 @ @ - 157 , 8 + 157 , 7 @ @ public class SSTableExportTest 
 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " Standard1 " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Standard1 " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } ) ; 
 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( " unexpected number of rows " , 2 , json . size ( ) ) ; 
 @ @ - 207 , 8 + 206 , 7 @ @ public class SSTableExportTest 
 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " Standard1 " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Standard1 " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ ] { asHex ( " rowExclude " ) } ) ; 
 
 / / Import JSON to another SSTable file 
 File tempSS2 = tempSSTableFile ( KEYSPACE1 , " Standard1 " ) ; 
 @ @ - 243 , 8 + 241 , 7 @ @ public class SSTableExportTest 
 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " Counter1 " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Counter1 " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; 
 
 @ @ - 275 , 8 + 272 , 7 @ @ public class SSTableExportTest 
 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " ValuesWithQuotes " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " ValuesWithQuotes " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; 
 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; 
 @ @ - 307 , 8 + 303 , 7 @ @ public class SSTableExportTest 
 SSTableReader reader = writer . closeAndOpenReader ( ) ; 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " CFWithDeletionInfo " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " Counter1 " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; 
 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( " unexpected number of rows " , 1 , json . size ( ) ) ; 
 @ @ - 367 , 8 + 362 , 7 @ @ public class SSTableExportTest 
 SSTableReader reader = writer . closeAndOpenReader ( ) ; 
 / / Export to JSON and verify 
 File tempJson = File . createTempFile ( " CFWithColumnNameEqualToDefaultKeyAlias " , " . json " ) ; 
 - SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " UUIDKeys " , BytesType . instance ) ) ; 
 + SSTableExport . export ( reader , new PrintStream ( tempJson . getPath ( ) ) , new String [ 0 ] ) ; 
 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( 1 , json . size ( ) ) ; 
 @ @ - 399 , 8 + 393 , 7 @ @ public class SSTableExportTest 
 File tempJson = File . createTempFile ( " CFWithAsciiKeys " , " . json " ) ; 
 SSTableExport . export ( reader , 
 new PrintStream ( tempJson . getPath ( ) ) , 
 - new String [ 0 ] , 
 - CFMetaData . sparseCFMetaData ( KEYSPACE1 , " AsciiKeys " , BytesType . instance ) ) ; 
 + new String [ 0 ] ) ; 
 
 JSONArray json = ( JSONArray ) JSONValue . parseWithException ( new FileReader ( tempJson ) ) ; 
 assertEquals ( 1 , json . size ( ) ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
