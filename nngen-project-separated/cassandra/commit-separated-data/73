BLEU SCORE: 0.01256753925966749

TEST MSG: Transient - > Full movements mishandle consistency level upgrade
GENERATED MSG: Dynamic snitch to adaptively avoid reading from slow nodes . Patch by brandonwilliams ; reviewed by jbellis for CASSANDRA - 981

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 25c2728 . . e1fbb90 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Transient - > Full range movements mishandle consistency level upgrade ( CASSANDRA - 14759 ) <nl> * ReplicaCollection follow - up ( CASSANDRA - 14726 ) <nl> * Transient node receives full data requests ( CASSANDRA - 14762 ) <nl> * Enable snapshot artifacts publish ( CASSANDRA - 12704 ) <nl> diff - - git a / src / java / org / apache / cassandra / locator / Endpoints . java b / src / java / org / apache / cassandra / locator / Endpoints . java <nl> index ee42e36 . . a2bad6c 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / Endpoints . java <nl> + + + b / src / java / org / apache / cassandra / locator / Endpoints . java <nl> @ @ - 60 , 12 + 60 , 6 @ @ public abstract class Endpoints < E extends Endpoints < E > > extends AbstractReplicaC <nl> return map ; <nl> } <nl> <nl> - public boolean contains ( InetAddressAndPort endpoint , boolean isFull ) <nl> - { <nl> - Replica replica = byEndpoint ( ) . get ( endpoint ) ; <nl> - return replica ! = null & & replica . isFull ( ) = = isFull ; <nl> - } <nl> - <nl> @ Override <nl> public boolean contains ( Replica replica ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / locator / Replica . java b / src / java / org / apache / cassandra / locator / Replica . java <nl> index c884f13 . . 4c5f7c6 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / Replica . java <nl> + + + b / src / java / org / apache / cassandra / locator / Replica . java <nl> @ @ - 110 , 7 + 110 , 7 @ @ public final class Replica implements Comparable < Replica > <nl> return range ; <nl> } <nl> <nl> - public boolean isFull ( ) <nl> + public final boolean isFull ( ) <nl> { <nl> return full ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ReplicaLayout . java b / src / java / org / apache / cassandra / locator / ReplicaLayout . java <nl> index cba4f68 . . 54b82f9 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / ReplicaLayout . java <nl> + + + b / src / java / org / apache / cassandra / locator / ReplicaLayout . java <nl> @ @ - 18 , 6 + 18 , 7 @ @ <nl> <nl> package org . apache . cassandra . locator ; <nl> <nl> + import com . google . common . annotations . VisibleForTesting ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . PartitionPosition ; <nl> @ @ - 274 , 9 + 275 , 29 @ @ public abstract class ReplicaLayout < E extends Endpoints < E > > <nl> * See { @ link ReplicaLayout # haveWriteConflicts } <nl> * @ return a ' natural ' replica collection , that has had its conflicts with pending repaired <nl> * / <nl> - private static < E extends Endpoints < E > > E resolveWriteConflictsInNatural ( E natural , E pending ) <nl> + @ VisibleForTesting <nl> + static EndpointsForToken resolveWriteConflictsInNatural ( EndpointsForToken natural , EndpointsForToken pending ) <nl> { <nl> - return natural . filter ( r - > ! r . isTransient ( ) | | ! pending . contains ( r . endpoint ( ) , true ) ) ; <nl> + EndpointsForToken . Mutable resolved = natural . newMutable ( natural . size ( ) ) ; <nl> + for ( Replica replica : natural ) <nl> + { <nl> + / / always prefer the full natural replica , if there is a conflict <nl> + if ( replica . isTransient ( ) ) <nl> + { <nl> + Replica conflict = pending . byEndpoint ( ) . get ( replica . endpoint ( ) ) ; <nl> + if ( conflict ! = null ) <nl> + { <nl> + / / it should not be possible to have conflicts of the same replication type for the same range <nl> + assert conflict . isFull ( ) ; <nl> + / / If we have any pending transient - > full movement , we need to move the full replica to our ' natural ' bucket <nl> + / / to avoid corrupting our count <nl> + resolved . add ( conflict ) ; <nl> + continue ; <nl> + } <nl> + } <nl> + resolved . add ( replica ) ; <nl> + } <nl> + return resolved . asSnapshot ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 284 , 7 + 305 , 8 @ @ public abstract class ReplicaLayout < E extends Endpoints < E > > <nl> * See { @ link ReplicaLayout # haveWriteConflicts } <nl> * @ return a ' pending ' replica collection , that has had its conflicts with natural repaired <nl> * / <nl> - private static < E extends Endpoints < E > > E resolveWriteConflictsInPending ( E natural , E pending ) <nl> + @ VisibleForTesting <nl> + static EndpointsForToken resolveWriteConflictsInPending ( EndpointsForToken natural , EndpointsForToken pending ) <nl> { <nl> return pending . without ( natural . endpoints ( ) ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java b / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java <nl> new file mode 100644 <nl> index 0000000 . . 9f2ac58 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java <nl> @ @ - 0 , 0 + 1 , 73 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import org . apache . cassandra . dht . Murmur3Partitioner ; <nl> + import org . apache . cassandra . dht . Token ; <nl> + import org . junit . Assert ; <nl> + import org . junit . Test ; <nl> + <nl> + import static org . apache . cassandra . locator . ReplicaCollectionTest . * ; <nl> + <nl> + public class ReplicaLayoutTest <nl> + { <nl> + @ Test <nl> + public void testConflictResolution ( ) <nl> + { <nl> + final Token token = new Murmur3Partitioner . LongToken ( 1L ) ; <nl> + final Replica f1 = Replica . fullReplica ( EP1 , R1 ) ; <nl> + final Replica f2 = Replica . fullReplica ( EP2 , R1 ) ; <nl> + final Replica t2 = Replica . transientReplica ( EP2 , R1 ) ; <nl> + final Replica f3 = Replica . fullReplica ( EP3 , R1 ) ; <nl> + final Replica t4 = Replica . transientReplica ( EP4 , R1 ) ; <nl> + <nl> + { <nl> + / / test no conflict <nl> + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , f3 ) ; <nl> + EndpointsForToken pending = EndpointsForToken . of ( token , t2 , t4 ) ; <nl> + Assert . assertFalse ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; <nl> + } <nl> + { <nl> + / / test full in natural , transient in pending <nl> + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , f2 , f3 ) ; <nl> + EndpointsForToken pending = EndpointsForToken . of ( token , t2 , t4 ) ; <nl> + EndpointsForToken expectNatural = natural ; <nl> + EndpointsForToken expectPending = EndpointsForToken . of ( token , t4 ) ; <nl> + Assert . assertTrue ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; <nl> + assertEquals ( expectNatural , ReplicaLayout . resolveWriteConflictsInNatural ( natural , pending ) ) ; <nl> + assertEquals ( expectPending , ReplicaLayout . resolveWriteConflictsInPending ( natural , pending ) ) ; <nl> + } <nl> + { <nl> + / / test transient in natural , full in pending <nl> + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , t2 , f3 ) ; <nl> + EndpointsForToken pending = EndpointsForToken . of ( token , f2 , t4 ) ; <nl> + EndpointsForToken expectNatural = EndpointsForToken . of ( token , f1 , f2 , f3 ) ; <nl> + EndpointsForToken expectPending = EndpointsForToken . of ( token , t4 ) ; <nl> + Assert . assertTrue ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; <nl> + assertEquals ( expectNatural , ReplicaLayout . resolveWriteConflictsInNatural ( natural , pending ) ) ; <nl> + assertEquals ( expectPending , ReplicaLayout . resolveWriteConflictsInPending ( natural , pending ) ) ; <nl> + } <nl> + } <nl> + <nl> + private static void assertEquals ( AbstractReplicaCollection < ? > a , AbstractReplicaCollection < ? > b ) <nl> + { <nl> + Assert . assertEquals ( a . list , b . list ) ; <nl> + } <nl> + <nl> + }
NEAREST DIFF (one line): diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 30f85a4 . . 11499a6 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler <nl> # the request scheduling . The current supported option is " keyspace " <nl> request _ scheduler _ id : keyspace <nl> <nl> + # dynamic _ snitch - - This boolean controls whether the above snitch is <nl> + # wrapped with a dynamic snitch , which will monitor read latencies <nl> + # and avoid reading from hosts that have slowed ( due to compaction , <nl> + # for instance ) <nl> + dynamic _ snitch : false <nl> + <nl> # A ColumnFamily is the Cassandra concept closest to a relational table . <nl> # <nl> # Keyspaces are separate groups of ColumnFamilies . Except in very <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 2a5478e . . 315c9a4 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 71 , 6 + 71 , 7 @ @ public class Config { <nl> public Integer commitlog _ sync _ period _ in _ ms ; <nl> <nl> public String endpoint _ snitch ; <nl> + public Boolean dynamic _ snitch = false ; <nl> <nl> public String request _ scheduler ; <nl> public RequestSchedulerId request _ scheduler _ id ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 0947af0 . . b5f9302 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; <nl> import java . net . UnknownHostException ; <nl> import java . util . * ; <nl> <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor <nl> throw ( ConfigurationException ) e . getCause ( ) ; <nl> throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; <nl> } <nl> - return snitch ; <nl> + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; <nl> } <nl> <nl> - public static void loadSchemas ( ) throws IOException <nl> + public static void loadSchemas ( ) throws IOException <nl> { <nl> / / we can load tables from local storage if a version is set in the system table and that acutally maps to <nl> / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> index 4892281 . . 2ef4980 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . net . InetAddress ; <nl> import java . util . Collection ; <nl> + import java . util . Comparator ; <nl> import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> <nl> @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch <nl> <nl> public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> index acb1d16 . . c40f995 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch <nl> { <nl> public int compare ( InetAddress a1 , InetAddress a2 ) <nl> { <nl> - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> - return - 1 ; <nl> - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> - return 1 ; <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } ; <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> <nl> - String addressRack = getRack ( address ) ; <nl> - String a1Rack = getRack ( a1 ) ; <nl> - String a2Rack = getRack ( a2 ) ; <nl> - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> - return - 1 ; <nl> - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> - return 1 ; <nl> + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> + return - 1 ; <nl> + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> + return 1 ; <nl> <nl> - String addressDatacenter = getDatacenter ( address ) ; <nl> - String a1Datacenter = getDatacenter ( a1 ) ; <nl> - String a2Datacenter = getDatacenter ( a2 ) ; <nl> - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> - return - 1 ; <nl> - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> - return 1 ; <nl> + String addressRack = getRack ( address ) ; <nl> + String a1Rack = getRack ( a1 ) ; <nl> + String a2Rack = getRack ( a2 ) ; <nl> + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> + return - 1 ; <nl> + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> + return 1 ; <nl> <nl> - return 0 ; <nl> - } <nl> - } ) ; <nl> - return addresses ; <nl> + String addressDatacenter = getDatacenter ( address ) ; <nl> + String a1Datacenter = getDatacenter ( a1 ) ; <nl> + String a2Datacenter = getDatacenter ( a2 ) ; <nl> + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> + return - 1 ; <nl> + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> + return 1 ; <nl> + <nl> + return 0 ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> new file mode 100644 <nl> index 0000000 . . cb2f03b <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> @ @ - 0 , 0 + 1 , 238 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . * ; <nl> + import java . util . concurrent . LinkedBlockingDeque ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import java . lang . management . ManagementFactory ; <nl> + import javax . management . MBeanServer ; <nl> + import javax . management . ObjectName ; <nl> + <nl> + import org . apache . cassandra . net . IVerbHandler ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . ResponseVerbHandler ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . utils . AbstractStatsDeque ; <nl> + import org . apache . cassandra . locator . IEndpointSnitch ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + import org . apache . cassandra . locator . AbstractEndpointSnitch ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + / * * <nl> + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector <nl> + * / <nl> + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean <nl> + { <nl> + private static int UPDATES _ PER _ INTERVAL = 100 ; <nl> + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; <nl> + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; <nl> + private static int WINDOW _ SIZE = 100 ; <nl> + private boolean registered = false ; <nl> + <nl> + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; <nl> + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; <nl> + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; <nl> + public IEndpointSnitch subsnitch ; <nl> + <nl> + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) <nl> + { <nl> + subsnitch = snitch ; <nl> + TimerTask update = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + updateScores ( ) ; <nl> + } <nl> + } ; <nl> + TimerTask reset = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try <nl> + / / to read from it , which would cause its score to never change <nl> + reset ( ) ; <nl> + } <nl> + } ; <nl> + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; <nl> + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; <nl> + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; <nl> + <nl> + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> + try <nl> + { <nl> + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getRack ( endpoint ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getDatacenter ( endpoint ) ; <nl> + } <nl> + <nl> + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> + { <nl> + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; <nl> + sortByProximity ( address , list ) ; <nl> + return list ; <nl> + } <nl> + <nl> + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) <nl> + { <nl> + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself <nl> + Collections . sort ( addresses , new Comparator < InetAddress > ( ) <nl> + { <nl> + public int compare ( InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + Double scored1 = scores . get ( a1 ) ; <nl> + Double scored2 = scores . get ( a2 ) ; <nl> + <nl> + if ( scored1 = = null | | scored2 = = null ) <nl> + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; <nl> + if ( scored1 . equals ( scored2 ) ) <nl> + return 0 ; <nl> + if ( scored1 < scored2 ) <nl> + return 1 ; <nl> + else <nl> + return - 1 ; <nl> + } <nl> + <nl> + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap <nl> + { <nl> + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) <nl> + return ; <nl> + AdaptiveLatencyTracker tracker = windows . get ( host ) ; <nl> + if ( tracker = = null ) <nl> + { <nl> + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; <nl> + tracker = windows . putIfAbsent ( host , alt ) ; <nl> + if ( tracker = = null ) <nl> + tracker = alt ; <nl> + } <nl> + tracker . add ( latency ) ; <nl> + intervalupdates . getAndIncrement ( ) ; <nl> + } <nl> + <nl> + private void updateScores ( ) / / this is expensive <nl> + { <nl> + if ( ! registered ) <nl> + { <nl> + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; <nl> + if ( handler ! = null ) <nl> + { <nl> + handler . register ( this ) ; <nl> + registered = true ; <nl> + } <nl> + <nl> + } <nl> + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) <nl> + { <nl> + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; <nl> + } <nl> + intervalupdates . set ( 0 ) ; <nl> + } <nl> + <nl> + private void reset ( ) <nl> + { <nl> + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) <nl> + { <nl> + tracker . clear ( ) ; <nl> + } <nl> + } <nl> + <nl> + public Map < InetAddress , Double > getScores ( ) <nl> + { <nl> + return scores ; <nl> + } <nl> + } <nl> + <nl> + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / <nl> + class AdaptiveLatencyTracker extends AbstractStatsDeque <nl> + { <nl> + private LinkedBlockingDeque latencies ; <nl> + private final int size ; <nl> + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter <nl> + <nl> + AdaptiveLatencyTracker ( int size ) <nl> + { <nl> + this . size = size ; <nl> + latencies = new LinkedBlockingDeque ( size ) ; <nl> + } <nl> + <nl> + public void add ( double i ) <nl> + { <nl> + latencies . offer ( i ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + latencies . clear ( ) ; <nl> + } <nl> + <nl> + public Iterator < Double > iterator ( ) <nl> + { <nl> + return latencies . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return latencies . size ( ) ; <nl> + } <nl> + <nl> + double p ( double t ) <nl> + { <nl> + double mean = mean ( ) ; <nl> + double exponent = ( - 1 ) * ( t ) / mean ; <nl> + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; <nl> + } <nl> + <nl> + double score ( ) <nl> + { <nl> + double log = 0d ; <nl> + if ( latencies . size ( ) > 0 ) <nl> + { <nl> + double probability = p ( SENTINEL _ COMPARE ) ; <nl> + log = ( - 1 ) * Math . log10 ( probability ) ; <nl> + } <nl> + return log ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> new file mode 100644 <nl> index 0000000 . . 26c5799 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> @ @ - 0 , 0 + 1 , 27 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Map ; <nl> + <nl> + public interface DynamicEndpointSnitchMBean { <nl> + public Map < InetAddress , Double > getScores ( ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> index ca451c0 . . 091c4c2 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; <nl> public interface IEndpointSnitch <nl> { <nl> / * * <nl> + * returns a String repesenting the rack this endpoint belongs to <nl> + * / <nl> + public String getRack ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> + * returns a String representing the datacenter this endpoint belongs to <nl> + * / <nl> + public String getDatacenter ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> * returns a new < tt > List < / tt > sorted by proximity to the given endpoint <nl> * / <nl> public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch <nl> * @ param subscriber the subscriber to notify <nl> * / <nl> public void register ( AbstractReplicationStrategy subscriber ) ; <nl> + <nl> + / * * <nl> + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would <nl> + * / <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> new file mode 100644 <nl> index 0000000 . . 0d97e84 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + <nl> + public interface ILatencyPublisher <nl> + { <nl> + public void register ( ILatencySubscriber subcriber ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> new file mode 100644 <nl> index 0000000 . . 6cfcf33 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + <nl> + public interface ILatencySubscriber <nl> + { <nl> + public void receiveTiming ( InetAddress address , Double latency ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> index c2fd8b5 . . dd8fb68 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> + import org . apache . commons . lang . NotImplementedException ; <nl> + <nl> / * * <nl> * A simple endpoint snitch implementation does not sort addresses by <nl> * proximity . <nl> * / <nl> public class SimpleSnitch extends AbstractEndpointSnitch <nl> { <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> { <nl> return new ArrayList < InetAddress > ( addresses ) ; <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 474d7c2 . . efd2545 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> return taskCompletionMap _ . remove ( key ) ; <nl> } <nl> <nl> + public static long getRegisteredCallbackAge ( String key ) <nl> + { <nl> + return callbackMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> + public static long getAsyncResultAge ( String key ) <nl> + { <nl> + return taskCompletionMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> public static ExecutorService getDeserializationExecutor ( ) <nl> { <nl> return messageDeserializerExecutor _ ; <nl> diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> index 020d187 . . cde87b2 100644 <nl> - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> @ @ - 18 , 21 + 18 , 30 @ @ <nl> <nl> package org . apache . cassandra . net ; <nl> <nl> + <nl> + import java . util . * ; <nl> + import java . net . InetAddress ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> <nl> - public class ResponseVerbHandler implements IVerbHandler <nl> + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher <nl> { <nl> private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; <nl> - <nl> + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; <nl> + <nl> + <nl> public void doVerb ( Message message ) <nl> { <nl> String messageId = message . getMessageId ( ) ; <nl> IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; <nl> + double age = 0 ; <nl> if ( cb ! = null ) <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; <nl> cb . response ( message ) ; <nl> } <nl> else <nl> @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; <nl> ar . result ( message ) ; <nl> } <nl> } <nl> + notifySubscribers ( message . getFrom ( ) , age ) ; <nl> + } <nl> + <nl> + private void notifySubscribers ( InetAddress host , double latency ) <nl> + { <nl> + for ( ILatencySubscriber subscriber : subscribers ) <nl> + { <nl> + subscriber . receiveTiming ( host , latency ) ; <nl> + } <nl> + } <nl> + <nl> + public void register ( ILatencySubscriber subscriber ) <nl> + { <nl> + subscribers . add ( subscriber ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> index dfaadf7 . . aa2c7ec 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > <nl> return result ; <nl> } <nl> <nl> + public long getAge ( K key ) <nl> + { <nl> + long age = 0 ; <nl> + CacheableObject < V > co = cache . get ( key ) ; <nl> + if ( co ! = null ) <nl> + { <nl> + age = co . age ; <nl> + } <nl> + return age ; <nl> + } <nl> + <nl> public int size ( ) <nl> { <nl> return cache . size ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> new file mode 100644 <nl> index 0000000 . . 62904b4 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> @ @ - 0 , 0 + 1 , 109 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . ArrayList ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> + import org . apache . cassandra . locator . SimpleSnitch ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class DynamicEndpointSnitchTest <nl> + { <nl> + @ Test <nl> + public void testSnitch ( ) throws UnknownHostException , InterruptedException <nl> + { <nl> + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; <nl> + InetAddress self = FBUtilities . getLocalAddress ( ) ; <nl> + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; <nl> + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; <nl> + <nl> + / / first , make all hosts equal <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + <nl> + Thread . sleep ( 1500 ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host1 a little worse <nl> + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host2 a little worse <nl> + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host3 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host3 the worst <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + / / make host3 equal to the others <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 25c2728 . . e1fbb90 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Transient - > Full range movements mishandle consistency level upgrade ( CASSANDRA - 14759 ) 
 * ReplicaCollection follow - up ( CASSANDRA - 14726 ) 
 * Transient node receives full data requests ( CASSANDRA - 14762 ) 
 * Enable snapshot artifacts publish ( CASSANDRA - 12704 ) 
 diff - - git a / src / java / org / apache / cassandra / locator / Endpoints . java b / src / java / org / apache / cassandra / locator / Endpoints . java 
 index ee42e36 . . a2bad6c 100644 
 - - - a / src / java / org / apache / cassandra / locator / Endpoints . java 
 + + + b / src / java / org / apache / cassandra / locator / Endpoints . java 
 @ @ - 60 , 12 + 60 , 6 @ @ public abstract class Endpoints < E extends Endpoints < E > > extends AbstractReplicaC 
 return map ; 
 } 
 
 - public boolean contains ( InetAddressAndPort endpoint , boolean isFull ) 
 - { 
 - Replica replica = byEndpoint ( ) . get ( endpoint ) ; 
 - return replica ! = null & & replica . isFull ( ) = = isFull ; 
 - } 
 - 
 @ Override 
 public boolean contains ( Replica replica ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / locator / Replica . java b / src / java / org / apache / cassandra / locator / Replica . java 
 index c884f13 . . 4c5f7c6 100644 
 - - - a / src / java / org / apache / cassandra / locator / Replica . java 
 + + + b / src / java / org / apache / cassandra / locator / Replica . java 
 @ @ - 110 , 7 + 110 , 7 @ @ public final class Replica implements Comparable < Replica > 
 return range ; 
 } 
 
 - public boolean isFull ( ) 
 + public final boolean isFull ( ) 
 { 
 return full ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / ReplicaLayout . java b / src / java / org / apache / cassandra / locator / ReplicaLayout . java 
 index cba4f68 . . 54b82f9 100644 
 - - - a / src / java / org / apache / cassandra / locator / ReplicaLayout . java 
 + + + b / src / java / org / apache / cassandra / locator / ReplicaLayout . java 
 @ @ - 18 , 6 + 18 , 7 @ @ 
 
 package org . apache . cassandra . locator ; 
 
 + import com . google . common . annotations . VisibleForTesting ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . PartitionPosition ; 
 @ @ - 274 , 9 + 275 , 29 @ @ public abstract class ReplicaLayout < E extends Endpoints < E > > 
 * See { @ link ReplicaLayout # haveWriteConflicts } 
 * @ return a ' natural ' replica collection , that has had its conflicts with pending repaired 
 * / 
 - private static < E extends Endpoints < E > > E resolveWriteConflictsInNatural ( E natural , E pending ) 
 + @ VisibleForTesting 
 + static EndpointsForToken resolveWriteConflictsInNatural ( EndpointsForToken natural , EndpointsForToken pending ) 
 { 
 - return natural . filter ( r - > ! r . isTransient ( ) | | ! pending . contains ( r . endpoint ( ) , true ) ) ; 
 + EndpointsForToken . Mutable resolved = natural . newMutable ( natural . size ( ) ) ; 
 + for ( Replica replica : natural ) 
 + { 
 + / / always prefer the full natural replica , if there is a conflict 
 + if ( replica . isTransient ( ) ) 
 + { 
 + Replica conflict = pending . byEndpoint ( ) . get ( replica . endpoint ( ) ) ; 
 + if ( conflict ! = null ) 
 + { 
 + / / it should not be possible to have conflicts of the same replication type for the same range 
 + assert conflict . isFull ( ) ; 
 + / / If we have any pending transient - > full movement , we need to move the full replica to our ' natural ' bucket 
 + / / to avoid corrupting our count 
 + resolved . add ( conflict ) ; 
 + continue ; 
 + } 
 + } 
 + resolved . add ( replica ) ; 
 + } 
 + return resolved . asSnapshot ( ) ; 
 } 
 
 / * * 
 @ @ - 284 , 7 + 305 , 8 @ @ public abstract class ReplicaLayout < E extends Endpoints < E > > 
 * See { @ link ReplicaLayout # haveWriteConflicts } 
 * @ return a ' pending ' replica collection , that has had its conflicts with natural repaired 
 * / 
 - private static < E extends Endpoints < E > > E resolveWriteConflictsInPending ( E natural , E pending ) 
 + @ VisibleForTesting 
 + static EndpointsForToken resolveWriteConflictsInPending ( EndpointsForToken natural , EndpointsForToken pending ) 
 { 
 return pending . without ( natural . endpoints ( ) ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java b / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java 
 new file mode 100644 
 index 0000000 . . 9f2ac58 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / locator / ReplicaLayoutTest . java 
 @ @ - 0 , 0 + 1 , 73 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import org . apache . cassandra . dht . Murmur3Partitioner ; 
 + import org . apache . cassandra . dht . Token ; 
 + import org . junit . Assert ; 
 + import org . junit . Test ; 
 + 
 + import static org . apache . cassandra . locator . ReplicaCollectionTest . * ; 
 + 
 + public class ReplicaLayoutTest 
 + { 
 + @ Test 
 + public void testConflictResolution ( ) 
 + { 
 + final Token token = new Murmur3Partitioner . LongToken ( 1L ) ; 
 + final Replica f1 = Replica . fullReplica ( EP1 , R1 ) ; 
 + final Replica f2 = Replica . fullReplica ( EP2 , R1 ) ; 
 + final Replica t2 = Replica . transientReplica ( EP2 , R1 ) ; 
 + final Replica f3 = Replica . fullReplica ( EP3 , R1 ) ; 
 + final Replica t4 = Replica . transientReplica ( EP4 , R1 ) ; 
 + 
 + { 
 + / / test no conflict 
 + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , f3 ) ; 
 + EndpointsForToken pending = EndpointsForToken . of ( token , t2 , t4 ) ; 
 + Assert . assertFalse ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; 
 + } 
 + { 
 + / / test full in natural , transient in pending 
 + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , f2 , f3 ) ; 
 + EndpointsForToken pending = EndpointsForToken . of ( token , t2 , t4 ) ; 
 + EndpointsForToken expectNatural = natural ; 
 + EndpointsForToken expectPending = EndpointsForToken . of ( token , t4 ) ; 
 + Assert . assertTrue ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; 
 + assertEquals ( expectNatural , ReplicaLayout . resolveWriteConflictsInNatural ( natural , pending ) ) ; 
 + assertEquals ( expectPending , ReplicaLayout . resolveWriteConflictsInPending ( natural , pending ) ) ; 
 + } 
 + { 
 + / / test transient in natural , full in pending 
 + EndpointsForToken natural = EndpointsForToken . of ( token , f1 , t2 , f3 ) ; 
 + EndpointsForToken pending = EndpointsForToken . of ( token , f2 , t4 ) ; 
 + EndpointsForToken expectNatural = EndpointsForToken . of ( token , f1 , f2 , f3 ) ; 
 + EndpointsForToken expectPending = EndpointsForToken . of ( token , t4 ) ; 
 + Assert . assertTrue ( ReplicaLayout . haveWriteConflicts ( natural , pending ) ) ; 
 + assertEquals ( expectNatural , ReplicaLayout . resolveWriteConflictsInNatural ( natural , pending ) ) ; 
 + assertEquals ( expectPending , ReplicaLayout . resolveWriteConflictsInPending ( natural , pending ) ) ; 
 + } 
 + } 
 + 
 + private static void assertEquals ( AbstractReplicaCollection < ? > a , AbstractReplicaCollection < ? > b ) 
 + { 
 + Assert . assertEquals ( a . list , b . list ) ; 
 + } 
 + 
 + }

NEAREST DIFF:
diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 30f85a4 . . 11499a6 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler 
 # the request scheduling . The current supported option is " keyspace " 
 request _ scheduler _ id : keyspace 
 
 + # dynamic _ snitch - - This boolean controls whether the above snitch is 
 + # wrapped with a dynamic snitch , which will monitor read latencies 
 + # and avoid reading from hosts that have slowed ( due to compaction , 
 + # for instance ) 
 + dynamic _ snitch : false 
 + 
 # A ColumnFamily is the Cassandra concept closest to a relational table . 
 # 
 # Keyspaces are separate groups of ColumnFamilies . Except in very 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 2a5478e . . 315c9a4 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 71 , 6 + 71 , 7 @ @ public class Config { 
 public Integer commitlog _ sync _ period _ in _ ms ; 
 
 public String endpoint _ snitch ; 
 + public Boolean dynamic _ snitch = false ; 
 
 public String request _ scheduler ; 
 public RequestSchedulerId request _ scheduler _ id ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 0947af0 . . b5f9302 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; 
 import java . net . UnknownHostException ; 
 import java . util . * ; 
 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor 
 throw ( ConfigurationException ) e . getCause ( ) ; 
 throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; 
 } 
 - return snitch ; 
 + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; 
 } 
 
 - public static void loadSchemas ( ) throws IOException 
 + public static void loadSchemas ( ) throws IOException 
 { 
 / / we can load tables from local storage if a version is set in the system table and that acutally maps to 
 / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 index 4892281 . . 2ef4980 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; 
 
 import java . net . InetAddress ; 
 import java . util . Collection ; 
 + import java . util . Comparator ; 
 import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 
 @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch 
 
 public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 index acb1d16 . . c40f995 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch 
 { 
 public int compare ( InetAddress a1 , InetAddress a2 ) 
 { 
 - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 - return - 1 ; 
 - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 - return 1 ; 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } ; 
 + } ) ; 
 + return addresses ; 
 + } 
 
 - String addressRack = getRack ( address ) ; 
 - String a1Rack = getRack ( a1 ) ; 
 - String a2Rack = getRack ( a2 ) ; 
 - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 - return - 1 ; 
 - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 - return 1 ; 
 + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) 
 + { 
 + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 + return - 1 ; 
 + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 + return 1 ; 
 
 - String addressDatacenter = getDatacenter ( address ) ; 
 - String a1Datacenter = getDatacenter ( a1 ) ; 
 - String a2Datacenter = getDatacenter ( a2 ) ; 
 - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 - return - 1 ; 
 - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 - return 1 ; 
 + String addressRack = getRack ( address ) ; 
 + String a1Rack = getRack ( a1 ) ; 
 + String a2Rack = getRack ( a2 ) ; 
 + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 + return - 1 ; 
 + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 + return 1 ; 
 
 - return 0 ; 
 - } 
 - } ) ; 
 - return addresses ; 
 + String addressDatacenter = getDatacenter ( address ) ; 
 + String a1Datacenter = getDatacenter ( a1 ) ; 
 + String a2Datacenter = getDatacenter ( a2 ) ; 
 + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 + return - 1 ; 
 + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 + return 1 ; 
 + 
 + return 0 ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 new file mode 100644 
 index 0000000 . . cb2f03b 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 @ @ - 0 , 0 + 1 , 238 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . * ; 
 + import java . util . concurrent . LinkedBlockingDeque ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import java . lang . management . ManagementFactory ; 
 + import javax . management . MBeanServer ; 
 + import javax . management . ObjectName ; 
 + 
 + import org . apache . cassandra . net . IVerbHandler ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . ResponseVerbHandler ; 
 + import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . utils . AbstractStatsDeque ; 
 + import org . apache . cassandra . locator . IEndpointSnitch ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + import org . apache . cassandra . locator . AbstractEndpointSnitch ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + / * * 
 + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector 
 + * / 
 + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean 
 + { 
 + private static int UPDATES _ PER _ INTERVAL = 100 ; 
 + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; 
 + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; 
 + private static int WINDOW _ SIZE = 100 ; 
 + private boolean registered = false ; 
 + 
 + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; 
 + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; 
 + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; 
 + public IEndpointSnitch subsnitch ; 
 + 
 + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) 
 + { 
 + subsnitch = snitch ; 
 + TimerTask update = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + updateScores ( ) ; 
 + } 
 + } ; 
 + TimerTask reset = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try 
 + / / to read from it , which would cause its score to never change 
 + reset ( ) ; 
 + } 
 + } ; 
 + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; 
 + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; 
 + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; 
 + 
 + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; 
 + try 
 + { 
 + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getRack ( endpoint ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getDatacenter ( endpoint ) ; 
 + } 
 + 
 + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 + { 
 + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; 
 + sortByProximity ( address , list ) ; 
 + return list ; 
 + } 
 + 
 + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) 
 + { 
 + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself 
 + Collections . sort ( addresses , new Comparator < InetAddress > ( ) 
 + { 
 + public int compare ( InetAddress a1 , InetAddress a2 ) 
 + { 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } 
 + } ) ; 
 + return addresses ; 
 + } 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + Double scored1 = scores . get ( a1 ) ; 
 + Double scored2 = scores . get ( a2 ) ; 
 + 
 + if ( scored1 = = null | | scored2 = = null ) 
 + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; 
 + if ( scored1 . equals ( scored2 ) ) 
 + return 0 ; 
 + if ( scored1 < scored2 ) 
 + return 1 ; 
 + else 
 + return - 1 ; 
 + } 
 + 
 + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap 
 + { 
 + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) 
 + return ; 
 + AdaptiveLatencyTracker tracker = windows . get ( host ) ; 
 + if ( tracker = = null ) 
 + { 
 + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; 
 + tracker = windows . putIfAbsent ( host , alt ) ; 
 + if ( tracker = = null ) 
 + tracker = alt ; 
 + } 
 + tracker . add ( latency ) ; 
 + intervalupdates . getAndIncrement ( ) ; 
 + } 
 + 
 + private void updateScores ( ) / / this is expensive 
 + { 
 + if ( ! registered ) 
 + { 
 + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; 
 + if ( handler ! = null ) 
 + { 
 + handler . register ( this ) ; 
 + registered = true ; 
 + } 
 + 
 + } 
 + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) 
 + { 
 + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; 
 + } 
 + intervalupdates . set ( 0 ) ; 
 + } 
 + 
 + private void reset ( ) 
 + { 
 + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) 
 + { 
 + tracker . clear ( ) ; 
 + } 
 + } 
 + 
 + public Map < InetAddress , Double > getScores ( ) 
 + { 
 + return scores ; 
 + } 
 + } 
 + 
 + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / 
 + class AdaptiveLatencyTracker extends AbstractStatsDeque 
 + { 
 + private LinkedBlockingDeque latencies ; 
 + private final int size ; 
 + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter 
 + 
 + AdaptiveLatencyTracker ( int size ) 
 + { 
 + this . size = size ; 
 + latencies = new LinkedBlockingDeque ( size ) ; 
 + } 
 + 
 + public void add ( double i ) 
 + { 
 + latencies . offer ( i ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + latencies . clear ( ) ; 
 + } 
 + 
 + public Iterator < Double > iterator ( ) 
 + { 
 + return latencies . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return latencies . size ( ) ; 
 + } 
 + 
 + double p ( double t ) 
 + { 
 + double mean = mean ( ) ; 
 + double exponent = ( - 1 ) * ( t ) / mean ; 
 + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; 
 + } 
 + 
 + double score ( ) 
 + { 
 + double log = 0d ; 
 + if ( latencies . size ( ) > 0 ) 
 + { 
 + double probability = p ( SENTINEL _ COMPARE ) ; 
 + log = ( - 1 ) * Math . log10 ( probability ) ; 
 + } 
 + return log ; 
 + } 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 new file mode 100644 
 index 0000000 . . 26c5799 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Map ; 
 + 
 + public interface DynamicEndpointSnitchMBean { 
 + public Map < InetAddress , Double > getScores ( ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 index ca451c0 . . 091c4c2 100644 
 - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; 
 public interface IEndpointSnitch 
 { 
 / * * 
 + * returns a String repesenting the rack this endpoint belongs to 
 + * / 
 + public String getRack ( InetAddress endpoint ) ; 
 + 
 + / * * 
 + * returns a String representing the datacenter this endpoint belongs to 
 + * / 
 + public String getDatacenter ( InetAddress endpoint ) ; 
 + 
 + / * * 
 * returns a new < tt > List < / tt > sorted by proximity to the given endpoint 
 * / 
 public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch 
 * @ param subscriber the subscriber to notify 
 * / 
 public void register ( AbstractReplicationStrategy subscriber ) ; 
 + 
 + / * * 
 + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would 
 + * / 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 new file mode 100644 
 index 0000000 . . 0d97e84 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + 
 + public interface ILatencyPublisher 
 + { 
 + public void register ( ILatencySubscriber subcriber ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 new file mode 100644 
 index 0000000 . . 6cfcf33 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + 
 + public interface ILatencySubscriber 
 + { 
 + public void receiveTiming ( InetAddress address , Double latency ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 index c2fd8b5 . . dd8fb68 100644 
 - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 
 + import org . apache . commons . lang . NotImplementedException ; 
 + 
 / * * 
 * A simple endpoint snitch implementation does not sort addresses by 
 * proximity . 
 * / 
 public class SimpleSnitch extends AbstractEndpointSnitch 
 { 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 { 
 return new ArrayList < InetAddress > ( addresses ) ; 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 474d7c2 . . efd2545 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener 
 return taskCompletionMap _ . remove ( key ) ; 
 } 
 
 + public static long getRegisteredCallbackAge ( String key ) 
 + { 
 + return callbackMap _ . getAge ( key ) ; 
 + } 
 + 
 + public static long getAsyncResultAge ( String key ) 
 + { 
 + return taskCompletionMap _ . getAge ( key ) ; 
 + } 
 + 
 public static ExecutorService getDeserializationExecutor ( ) 
 { 
 return messageDeserializerExecutor _ ; 
 diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 index 020d187 . . cde87b2 100644 
 - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 @ @ - 18 , 21 + 18 , 30 @ @ 
 
 package org . apache . cassandra . net ; 
 
 + 
 + import java . util . * ; 
 + import java . net . InetAddress ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 
 - public class ResponseVerbHandler implements IVerbHandler 
 + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher 
 { 
 private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; 
 - 
 + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; 
 + 
 + 
 public void doVerb ( Message message ) 
 { 
 String messageId = message . getMessageId ( ) ; 
 IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; 
 + double age = 0 ; 
 if ( cb ! = null ) 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; 
 cb . response ( message ) ; 
 } 
 else 
 @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; 
 ar . result ( message ) ; 
 } 
 } 
 + notifySubscribers ( message . getFrom ( ) , age ) ; 
 + } 
 + 
 + private void notifySubscribers ( InetAddress host , double latency ) 
 + { 
 + for ( ILatencySubscriber subscriber : subscribers ) 
 + { 
 + subscriber . receiveTiming ( host , latency ) ; 
 + } 
 + } 
 + 
 + public void register ( ILatencySubscriber subscriber ) 
 + { 
 + subscribers . add ( subscriber ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 index dfaadf7 . . aa2c7ec 100644 
 - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > 
 return result ; 
 } 
 
 + public long getAge ( K key ) 
 + { 
 + long age = 0 ; 
 + CacheableObject < V > co = cache . get ( key ) ; 
 + if ( co ! = null ) 
 + { 
 + age = co . age ; 
 + } 
 + return age ; 
 + } 
 + 
 public int size ( ) 
 { 
 return cache . size ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 new file mode 100644 
 index 0000000 . . 62904b4 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . ArrayList ; 
 + 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . * ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 + import org . apache . cassandra . locator . SimpleSnitch ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class DynamicEndpointSnitchTest 
 + { 
 + @ Test 
 + public void testSnitch ( ) throws UnknownHostException , InterruptedException 
 + { 
 + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; 
 + InetAddress self = FBUtilities . getLocalAddress ( ) ; 
 + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; 
 + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; 
 + 
 + / / first , make all hosts equal 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + 
 + Thread . sleep ( 1500 ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host1 a little worse 
 + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host2 a little worse 
 + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host3 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host3 the worst 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + order . add ( host3 ) ; 
 + 
 + / / make host3 equal to the others 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + } 
 + }
