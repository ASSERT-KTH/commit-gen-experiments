BLEU SCORE: 0.033864985683445356

TEST MSG: Estimate compressed on disk size when deciding if sstable size limit reached
GENERATED MSG: Fix LCS splitting sstables based on uncompressed length

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0b70d77 . . a9421b6 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 8 <nl> + * Estimate compressed on disk size when deciding if sstable size limit reached ( CASSANDRA - 11623 ) <nl> * cassandra - stress profiles should support case sensitive schemas ( CASSANDRA - 11546 ) <nl> * Remove DatabaseDescriptor dependency from FileUtils ( CASSANDRA - 11578 ) <nl> * Faster streaming ( CASSANDRA - 9766 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java <nl> index 91a18da . . 6cccfcb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java <nl> @ @ - 17 , 7 + 17 , 6 @ @ <nl> * / <nl> package org . apache . cassandra . db . compaction . writers ; <nl> <nl> - import java . util . List ; <nl> import java . util . Set ; <nl> <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> @ @ - 82 , 12 + 81 , 12 @ @ public class MajorLeveledCompactionWriter extends CompactionAwareWriter <nl> @ SuppressWarnings ( " resource " ) <nl> public boolean realAppend ( UnfilteredRowIterator partition ) <nl> { <nl> - long posBefore = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) ; <nl> RowIndexEntry rie = sstableWriter . append ( partition ) ; <nl> - totalWrittenInLevel + = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) - posBefore ; <nl> partitionsWritten + + ; <nl> - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > maxSSTableSize ) <nl> + long totalWrittenInCurrentWriter = sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) ; <nl> + if ( totalWrittenInCurrentWriter > maxSSTableSize ) <nl> { <nl> + totalWrittenInLevel + = totalWrittenInCurrentWriter ; <nl> if ( totalWrittenInLevel > LeveledManifest . maxBytesForLevel ( currentLevel , maxSSTableSize ) ) <nl> { <nl> totalWrittenInLevel = 0 ; <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java <nl> index 8c3ada7 . . 864185e 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java <nl> @ @ - 96 , 7 + 96 , 7 @ @ public class MaxSSTableSizeWriter extends CompactionAwareWriter <nl> protected boolean realAppend ( UnfilteredRowIterator partition ) <nl> { <nl> RowIndexEntry rie = sstableWriter . append ( partition ) ; <nl> - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > maxSSTableSize ) <nl> + if ( sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) > maxSSTableSize ) <nl> { <nl> switchCompactionLocation ( sstableDirectory ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> index 290e88b . . 46cb891 100644 <nl> - - - a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> + + + b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java <nl> @ @ - 18 , 7 + 18 , 6 @ @ <nl> package org . apache . cassandra . db . compaction . writers ; <nl> <nl> import java . util . Arrays ; <nl> - import java . util . List ; <nl> import java . util . Set ; <nl> <nl> import org . slf4j . Logger ; <nl> @ @ - 89 , 7 + 88 , 7 @ @ public class SplittingSizeTieredCompactionWriter extends CompactionAwareWriter <nl> public boolean realAppend ( UnfilteredRowIterator partition ) <nl> { <nl> RowIndexEntry rie = sstableWriter . append ( partition ) ; <nl> - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > currentBytesToWrite & & currentRatioIndex < ratios . length - 1 ) / / if we underestimate how many keys we have , the last sstable might get more than we expect <nl> + if ( sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) > currentBytesToWrite & & currentRatioIndex < ratios . length - 1 ) / / if we underestimate how many keys we have , the last sstable might get more than we expect <nl> { <nl> currentRatioIndex + + ; <nl> currentBytesToWrite = Math . round ( totalSize * ratios [ currentRatioIndex ] ) ; <nl> diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> index 9bd1145 . . 1f33d53 100644 <nl> - - - a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java <nl> @ @ - 92 , 6 + 92 , 17 @ @ public class CompressedSequentialWriter extends SequentialWriter <nl> } <nl> } <nl> <nl> + / * * <nl> + * Get a quick estimation on how many bytes have been written to disk <nl> + * <nl> + * It should for the most part be exactly the same as getOnDiskFilePointer ( ) <nl> + * / <nl> + @ Override <nl> + public long getEstimatedOnDiskBytesWritten ( ) <nl> + { <nl> + return chunkOffset ; <nl> + } <nl> + <nl> @ Override <nl> public void flush ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java <nl> index 6aaf776 . . 9f2e159 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java <nl> @ @ - 212 , 6 + 212 , 11 @ @ public abstract class SSTableWriter extends SSTable implements Transactional <nl> <nl> public abstract long getOnDiskFilePointer ( ) ; <nl> <nl> + public long getEstimatedOnDiskBytesWritten ( ) <nl> + { <nl> + return getOnDiskFilePointer ( ) ; <nl> + } <nl> + <nl> public abstract void resetAndTruncate ( ) ; <nl> <nl> public SSTableWriter setRepairedAt ( long repairedAt ) <nl> diff - - git a / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java b / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java <nl> index 39dc889 . . 8645158 100644 <nl> - - - a / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java <nl> @ @ - 394 , 6 + 394 , 11 @ @ public class BigTableWriter extends SSTableWriter <nl> return dataFile . getOnDiskFilePointer ( ) ; <nl> } <nl> <nl> + public long getEstimatedOnDiskBytesWritten ( ) <nl> + { <nl> + return dataFile . getEstimatedOnDiskBytesWritten ( ) ; <nl> + } <nl> + <nl> / * * <nl> * Encapsulates writing the index and filter for an SSTable . The state of this object is not valid until it has been closed . <nl> * / <nl> diff - - git a / src / java / org / apache / cassandra / io / util / SequentialWriter . java b / src / java / org / apache / cassandra / io / util / SequentialWriter . java <nl> index f153b4d . . 45e4cfa 100644 <nl> - - - a / src / java / org / apache / cassandra / io / util / SequentialWriter . java <nl> + + + b / src / java / org / apache / cassandra / io / util / SequentialWriter . java <nl> @ @ - 276 , 6 + 276 , 11 @ @ public class SequentialWriter extends BufferedDataOutputStreamPlus implements Tr <nl> return position ( ) ; <nl> } <nl> <nl> + public long getEstimatedOnDiskBytesWritten ( ) <nl> + { <nl> + return getOnDiskFilePointer ( ) ; <nl> + } <nl> + <nl> public long length ( ) <nl> { <nl> try
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1b6f4d1 . . f9b45d6 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 10 , 6 + 10 , 7 @ @ <nl> * ( cql3 ) Support ORDER BY when IN condition is given in WHERE clause ( CASSANDRA - 4327 ) <nl> * ( cql3 ) delete " component _ index " column on DROP TABLE call ( CASSANDRA - 4420 ) <nl> * change nanoTime ( ) to currentTimeInMillis ( ) in schema related code ( CASSANDRA - 4432 ) <nl> + * add a token generation tool ( CASSANDRA - 3709 ) <nl> Merged from 1 . 0 : <nl> * allow dropping columns shadowed by not - yet - expired supercolumn or row <nl> tombstones in PrecompactedRow ( CASSANDRA - 4396 ) <nl> diff - - git a / tools / bin / token - generator b / tools / bin / token - generator <nl> new file mode 100644 <nl> index 0000000 . . 57d7fce <nl> - - - / dev / null <nl> + + + b / tools / bin / token - generator <nl> @ @ - 0 , 0 + 1 , 317 @ @ <nl> + # ! / usr / bin / env python <nl> + <nl> + from _ _ future _ _ import with _ statement <nl> + <nl> + import os <nl> + import sys <nl> + import math <nl> + import optparse <nl> + import webbrowser <nl> + import urllib <nl> + from time import sleep <nl> + from itertools import cycle <nl> + from tempfile import NamedTemporaryFile <nl> + <nl> + description = ' ' ' Given a list of numbers indicating the number of nodes <nl> + in each separate datacenter , outputs a recommended list of tokens to use <nl> + with RandomPartitioner : one for each node in each datacenter . <nl> + ' ' ' <nl> + <nl> + usage = " % prog < nodes _ in _ dc1 > [ < nodes _ in _ dc2 > [ . . . ] ] " <nl> + <nl> + parser = optparse . OptionParser ( description = description , usage = usage ) <nl> + parser . add _ option ( ' - - ringrange ' , type = ' int ' , <nl> + help = ' Specify a numeric maximum token value for your ring , ' <nl> + ' different from the default value of 2 ^ 127 . ' ) <nl> + parser . add _ option ( ' - - graph ' , action = ' store _ true ' , <nl> + help = ' Show a rendering of the generated tokens as line ' <nl> + ' segments in a circle , colored according to datacenter ' ) <nl> + parser . add _ option ( ' - n ' , ' - - nts ' , action = ' store _ const ' , dest = ' strat ' , const = ' nts ' , <nl> + help = ' Optimize multi - cluster distribution for ' <nl> + ' NetworkTopologyStrategy [ default ] ' ) <nl> + parser . add _ option ( ' - o ' , ' - - onts ' , action = ' store _ const ' , dest = ' strat ' , const = ' onts ' , <nl> + help = ' Optimize multi - cluster distribution for ' <nl> + ' OldNetworkTopologyStrategy ' ) <nl> + <nl> + parser . add _ option ( ' - - test ' , action = ' store _ true ' , <nl> + help = ' Run in test mode , outputting an HTML file to display ' <nl> + ' various generated ring arrangements . ' ) <nl> + <nl> + parser . add _ option ( ' - - html - output ' , help = optparse . SUPPRESS _ HELP ) <nl> + parser . add _ option ( ' - - browser - wait - time ' , type = ' float ' , help = optparse . SUPPRESS _ HELP ) <nl> + parser . add _ option ( ' - - test - colors ' , help = optparse . SUPPRESS _ HELP ) <nl> + parser . add _ option ( ' - - test - graphsize ' , type = ' int ' , help = optparse . SUPPRESS _ HELP ) <nl> + <nl> + parser . set _ defaults ( <nl> + ringrange = ( 1 < < 127 ) , <nl> + <nl> + # whether to create ( and try to display ) graph output <nl> + graph = False , <nl> + <nl> + # ' nts ' or ' onts ' ; the replication strategy for which to optimize <nl> + strat = ' nts ' , <nl> + <nl> + # durr <nl> + test = False , <nl> + <nl> + # size of the generated graph <nl> + graphsize = 600 , <nl> + <nl> + # where to write generated graph ( HTML ) output , or ' * tmp * ' to write a <nl> + # temporary file , and remove it after telling a browser to open it . ' - ' <nl> + # to write to stdout . <nl> + html _ output = ' * tmp * ' , <nl> + <nl> + # how long , in seconds , to wait before cleaning up a temporary html file <nl> + # after telling the browser to open it <nl> + browser _ wait _ time = 5 . 0 , <nl> + <nl> + # comma - separated list of HTML color codes , used in order to represent <nl> + # respective datacenter nodes <nl> + test _ colors = ' # 000 , # 00F , # 0F0 , # F00 , # 0FF , # FF0 , # F0F ' , <nl> + <nl> + # size of the per - test graphs <nl> + test _ graphsize = 200 , <nl> + ) <nl> + <nl> + class Ring : <nl> + MIN _ DC _ OFFSET _ DIVIDER = 235 <nl> + offset _ spacer = 2 <nl> + <nl> + def _ _ init _ _ ( self , dc _ counts , ringrange , strategy = ' nts ' ) : <nl> + self . ringrange = ringrange <nl> + self . dc _ counts = dc _ counts <nl> + self . calculate _ offset _ tokens = getattr ( self , ' calc _ offset _ tokens _ ' + strategy ) <nl> + <nl> + def best _ per _ dc _ offset ( self ) : <nl> + " " " <nl> + Calculate a per - dc offset for NTS DC spacing , such that there is a little <nl> + bit of room between nodes which would otherwise have been at the same token ; <nl> + ( hopefully ) large enough that the difference can show when - - graph is used , <nl> + but small enough that it there ' s no chance of the relative ordering changing . <nl> + " " " <nl> + lowest _ division = len ( self . dc _ counts ) * max ( self . dc _ counts ) * self . offset _ spacer <nl> + division = max ( lowest _ division , self . MIN _ DC _ OFFSET _ DIVIDER ) <nl> + return - self . ringrange / / division <nl> + <nl> + def calc _ offset _ tokens _ nts ( self ) : <nl> + dc _ offset = self . best _ per _ dc _ offset ( ) <nl> + dcs = [ ] <nl> + for ( dcnum , dccount ) in enumerate ( self . dc _ counts ) : <nl> + offset = dcnum * dc _ offset <nl> + arcsize = self . ringrange / / ( dccount or 1 ) <nl> + dcs . append ( [ ( n * arcsize + offset ) % self . ringrange for n in xrange ( dccount ) ] ) <nl> + return dcs <nl> + <nl> + def calc _ offset _ tokens _ onts ( self ) : <nl> + dcs _ by _ count = sorted ( enumerate ( self . dc _ counts ) , key = lambda d : d [ 1 ] , reverse = True ) <nl> + biggest = dcs _ by _ count [ 0 ] [ 1 ] <nl> + nodes = [ dcnum for ( dcnum , dccount ) in dcs _ by _ count for x in range ( dccount ) ] <nl> + layout = [ nodes [ n ] for i in range ( biggest ) for n in range ( i , len ( nodes ) , biggest ) ] <nl> + <nl> + final = [ [ ] for x in dcs _ by _ count ] <nl> + for pos , dc in enumerate ( layout ) : <nl> + final [ dc ] . append ( pos * self . ringrange / / len ( layout ) ) <nl> + return final <nl> + <nl> + <nl> + def print _ tokens ( tokens , tokenwidth , indent = 0 ) : <nl> + indentstr = ' ' * indent <nl> + for dcnum , toklist in enumerate ( tokens ) : <nl> + print " % sDC # % d : " % ( indentstr , dcnum + 1 ) <nl> + nwidth = len ( str ( len ( toklist ) ) ) <nl> + for tnum , tok in enumerate ( toklist ) : <nl> + print " % s Node # % 0 * d : % * d " % ( indentstr , nwidth , tnum + 1 , tokenwidth , tok ) <nl> + <nl> + def calculate _ ideal _ tokens ( datacenters , ringrange , strategy ) : <nl> + return Ring ( datacenters , ringrange , strategy ) . calculate _ offset _ tokens ( ) <nl> + <nl> + def file _ to _ url ( path ) : <nl> + path = os . path . abspath ( path ) <nl> + if os . name = = ' nt ' : <nl> + host , path = os . path . splitunc ( path ) <nl> + drive , path = os . path . splitdrive ( path ) <nl> + path = ( host or ( drive + ' | ' ) ) + path . replace ( os . sep , ' / ' ) <nl> + return ' file : / / ' + urllib . quote ( path , safe = ' / ' ) <nl> + <nl> + html _ template = " " " < ! DOCTYPE html > <nl> + < html > <nl> + < body > <nl> + <nl> + % ( generated _ body ) s <nl> + <nl> + < / body > <nl> + < / html > <nl> + " " " <nl> + <nl> + chart _ template = " " " <nl> + < canvas id = " % ( id ) s " width = " % ( size ) s " height = " % ( size ) s " style = " border : 1px solid # c3c3c3 ; " > <nl> + Your browser does not support the canvas element . <nl> + < / canvas > <nl> + < script type = " text / javascript " > <nl> + var c = document . getElementById ( " % ( id ) s " ) ; <nl> + var ctx = c . getContext ( " 2d " ) ; <nl> + % ( generated _ script ) s <nl> + < / script > <nl> + " " " <nl> + <nl> + chart _ js _ template = " " " <nl> + ctx . beginPath ( ) ; <nl> + ctx . strokeStyle = " % ( color ) s " ; <nl> + ctx . moveTo ( % ( center ) s , % ( center ) s ) ; <nl> + ctx . lineTo ( % ( x ) s , % ( y ) s ) ; <nl> + ctx . stroke ( ) ; <nl> + ctx . closePath ( ) ; <nl> + " " " <nl> + <nl> + class RingRenderer : <nl> + border _ fraction = 0 . 08 <nl> + <nl> + def _ _ init _ _ ( self , ringrange , graphsize , colors ) : <nl> + self . ringrange = ringrange <nl> + self . graphsize = graphsize <nl> + self . colors = colors <nl> + self . anglefactor = 2 * math . pi / ringrange <nl> + self . linelength = graphsize * ( 1 - self . border _ fraction ) / 2 <nl> + self . center = graphsize / 2 <nl> + <nl> + def calc _ coords ( self , tokens ) : <nl> + these _ calcs = [ ] <nl> + <nl> + for toklist in tokens : <nl> + coordlist = [ ] <nl> + for tok in toklist : <nl> + angle = tok * self . anglefactor <nl> + x2 = self . center + self . linelength * math . sin ( angle ) <nl> + y2 = self . center - self . linelength * math . cos ( angle ) <nl> + coordlist . append ( ( x2 , y2 ) ) <nl> + these _ calcs . append ( coordlist ) <nl> + <nl> + return these _ calcs <nl> + <nl> + def make _ html ( self , tokensets ) : <nl> + coordinate _ sets = map ( self . calc _ coords , tokensets ) <nl> + all _ charts = [ ] <nl> + for chart _ index , chart _ set in enumerate ( coordinate _ sets ) : <nl> + chart _ code = [ ] <nl> + for coordlist , color in zip ( chart _ set , cycle ( self . colors ) ) : <nl> + for x , y in coordlist : <nl> + chart _ code . append ( chart _ js _ template <nl> + % dict ( color = color , x = x , y = y , <nl> + center = ( self . graphsize / 2 ) ) ) <nl> + this _ chart = chart _ template % dict ( generated _ script = ' ' . join ( chart _ code ) , <nl> + id = chart _ index , size = self . graphsize ) <nl> + all _ charts . append ( this _ chart ) <nl> + return html _ template % dict ( generated _ body = ' ' . join ( all _ charts ) ) <nl> + <nl> + # = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + # Tests <nl> + <nl> + def run _ tests ( opts ) : <nl> + tests = [ <nl> + [ 1 ] , <nl> + [ 1 , 1 ] , <nl> + [ 2 , 2 ] , <nl> + [ 1 , 2 , 2 ] , <nl> + [ 2 , 2 , 2 ] , <nl> + [ 2 , 0 , 0 ] , <nl> + [ 0 , 2 , 0 ] , <nl> + [ 0 , 0 , 2 ] , <nl> + [ 2 , 2 , 0 ] , <nl> + [ 2 , 0 , 2 ] , <nl> + [ 0 , 2 , 2 ] , <nl> + [ 0 , 0 , 1 , 1 , 0 , 1 , 1 ] , <nl> + [ 6 ] , <nl> + [ 3 , 3 , 3 ] , <nl> + [ 9 ] , <nl> + [ 1 , 1 , 1 , 1 ] , <nl> + [ 4 ] , <nl> + [ 3 , 3 , 6 , 4 , 2 ] <nl> + ] <nl> + <nl> + tokensets = [ ] <nl> + for test in tests : <nl> + print " Test % r " % ( test , ) <nl> + tokens = calculate _ ideal _ tokens ( test , opts . ringrange , opts . strat ) <nl> + print _ tokens ( tokens , len ( str ( opts . ringrange ) ) + 1 , indent = 2 ) <nl> + tokensets . append ( tokens ) <nl> + return tokensets <nl> + <nl> + # = = = = = = = = = = = = = = = = = = = = = = = = = = = <nl> + <nl> + def display _ html ( html , wait _ time ) : <nl> + with NamedTemporaryFile ( suffix = ' . html ' ) as f : <nl> + f . write ( html ) <nl> + f . flush ( ) <nl> + webbrowser . open ( file _ to _ url ( f . name ) , new = 2 ) <nl> + # this is stupid . webbrowser . open really can ' t wait until the <nl> + # browser has said " yes I ' ve got it " ? <nl> + sleep ( wait _ time ) <nl> + <nl> + def write _ output ( html , opts ) : <nl> + if opts . html _ output = = ' - ' : <nl> + sys . stdout . write ( html ) <nl> + elif opts . html _ output = = ' * tmp * ' : <nl> + display _ html ( html , opts . browser _ wait _ time ) <nl> + else : <nl> + with open ( opts . html _ output , ' w ' ) as f : <nl> + f . write ( html ) <nl> + <nl> + def readnum ( prompt , min = None , max = None ) : <nl> + while True : <nl> + x = raw _ input ( prompt + ' ' ) <nl> + try : <nl> + val = int ( x ) <nl> + except ValueError : <nl> + print " Oops , % r is not an integer . Try again . \ n " % ( x , ) <nl> + continue <nl> + if min is not None and val < min : <nl> + print " Oops , the answer must be at least % d . Try again . \ n " % ( min , ) <nl> + elif max is not None and val > max : <nl> + print " Oops , the answer must be at most % d . Try again . \ n " % ( max , ) <nl> + else : <nl> + return val <nl> + <nl> + def get _ dc _ sizes _ interactive ( ) : <nl> + print " Token Generator Interactive Mode " <nl> + print " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " <nl> + print <nl> + dcs = readnum ( " How many datacenters will participate in this Cassandra cluster ? " , min = 1 ) <nl> + sizes = [ ] <nl> + for n in xrange ( dcs ) : <nl> + sizes . append ( readnum ( " How many nodes are in datacenter # % d ? " % ( n + 1 ) , min = 0 ) ) <nl> + print <nl> + return sizes <nl> + <nl> + def main ( opts , args ) : <nl> + opts . colorlist = [ s . strip ( ) for s in opts . test _ colors . split ( ' , ' ) ] <nl> + if opts . test : <nl> + opts . graph = True <nl> + tokensets = run _ tests ( opts ) <nl> + renderer = RingRenderer ( ringrange = opts . ringrange , graphsize = opts . test _ graphsize , <nl> + colors = opts . colorlist ) <nl> + else : <nl> + if len ( args ) = = 0 : <nl> + args = get _ dc _ sizes _ interactive ( ) <nl> + try : <nl> + datacenters = map ( int , args ) <nl> + except ValueError , e : <nl> + parser . error ( ' Arguments should be integers . ' ) <nl> + renderer = RingRenderer ( ringrange = opts . ringrange , graphsize = opts . graphsize , <nl> + colors = opts . colorlist ) <nl> + tokens = calculate _ ideal _ tokens ( datacenters , opts . ringrange , opts . strat ) <nl> + print _ tokens ( tokens , len ( str ( opts . ringrange ) ) + 1 ) <nl> + tokensets = [ tokens ] <nl> + <nl> + if opts . graph : <nl> + html = renderer . make _ html ( tokensets ) <nl> + write _ output ( html , opts ) <nl> + return 0 <nl> + <nl> + if _ _ name _ _ = = ' _ _ main _ _ ' : <nl> + opts , args = parser . parse _ args ( ) <nl> + try : <nl> + res = main ( opts , args ) <nl> + except KeyboardInterrupt : <nl> + res = - 128 <nl> + sys . exit ( res )

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0b70d77 . . a9421b6 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 8 
 + * Estimate compressed on disk size when deciding if sstable size limit reached ( CASSANDRA - 11623 ) 
 * cassandra - stress profiles should support case sensitive schemas ( CASSANDRA - 11546 ) 
 * Remove DatabaseDescriptor dependency from FileUtils ( CASSANDRA - 11578 ) 
 * Faster streaming ( CASSANDRA - 9766 ) 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java 
 index 91a18da . . 6cccfcb 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / writers / MajorLeveledCompactionWriter . java 
 @ @ - 17 , 7 + 17 , 6 @ @ 
 * / 
 package org . apache . cassandra . db . compaction . writers ; 
 
 - import java . util . List ; 
 import java . util . Set ; 
 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 @ @ - 82 , 12 + 81 , 12 @ @ public class MajorLeveledCompactionWriter extends CompactionAwareWriter 
 @ SuppressWarnings ( " resource " ) 
 public boolean realAppend ( UnfilteredRowIterator partition ) 
 { 
 - long posBefore = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) ; 
 RowIndexEntry rie = sstableWriter . append ( partition ) ; 
 - totalWrittenInLevel + = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) - posBefore ; 
 partitionsWritten + + ; 
 - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > maxSSTableSize ) 
 + long totalWrittenInCurrentWriter = sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) ; 
 + if ( totalWrittenInCurrentWriter > maxSSTableSize ) 
 { 
 + totalWrittenInLevel + = totalWrittenInCurrentWriter ; 
 if ( totalWrittenInLevel > LeveledManifest . maxBytesForLevel ( currentLevel , maxSSTableSize ) ) 
 { 
 totalWrittenInLevel = 0 ; 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java 
 index 8c3ada7 . . 864185e 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / writers / MaxSSTableSizeWriter . java 
 @ @ - 96 , 7 + 96 , 7 @ @ public class MaxSSTableSizeWriter extends CompactionAwareWriter 
 protected boolean realAppend ( UnfilteredRowIterator partition ) 
 { 
 RowIndexEntry rie = sstableWriter . append ( partition ) ; 
 - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > maxSSTableSize ) 
 + if ( sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) > maxSSTableSize ) 
 { 
 switchCompactionLocation ( sstableDirectory ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 index 290e88b . . 46cb891 100644 
 - - - a / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 + + + b / src / java / org / apache / cassandra / db / compaction / writers / SplittingSizeTieredCompactionWriter . java 
 @ @ - 18 , 7 + 18 , 6 @ @ 
 package org . apache . cassandra . db . compaction . writers ; 
 
 import java . util . Arrays ; 
 - import java . util . List ; 
 import java . util . Set ; 
 
 import org . slf4j . Logger ; 
 @ @ - 89 , 7 + 88 , 7 @ @ public class SplittingSizeTieredCompactionWriter extends CompactionAwareWriter 
 public boolean realAppend ( UnfilteredRowIterator partition ) 
 { 
 RowIndexEntry rie = sstableWriter . append ( partition ) ; 
 - if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > currentBytesToWrite & & currentRatioIndex < ratios . length - 1 ) / / if we underestimate how many keys we have , the last sstable might get more than we expect 
 + if ( sstableWriter . currentWriter ( ) . getEstimatedOnDiskBytesWritten ( ) > currentBytesToWrite & & currentRatioIndex < ratios . length - 1 ) / / if we underestimate how many keys we have , the last sstable might get more than we expect 
 { 
 currentRatioIndex + + ; 
 currentBytesToWrite = Math . round ( totalSize * ratios [ currentRatioIndex ] ) ; 
 diff - - git a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 index 9bd1145 . . 1f33d53 100644 
 - - - a / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 + + + b / src / java / org / apache / cassandra / io / compress / CompressedSequentialWriter . java 
 @ @ - 92 , 6 + 92 , 17 @ @ public class CompressedSequentialWriter extends SequentialWriter 
 } 
 } 
 
 + / * * 
 + * Get a quick estimation on how many bytes have been written to disk 
 + * 
 + * It should for the most part be exactly the same as getOnDiskFilePointer ( ) 
 + * / 
 + @ Override 
 + public long getEstimatedOnDiskBytesWritten ( ) 
 + { 
 + return chunkOffset ; 
 + } 
 + 
 @ Override 
 public void flush ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java b / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java 
 index 6aaf776 . . 9f2e159 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / format / SSTableWriter . java 
 @ @ - 212 , 6 + 212 , 11 @ @ public abstract class SSTableWriter extends SSTable implements Transactional 
 
 public abstract long getOnDiskFilePointer ( ) ; 
 
 + public long getEstimatedOnDiskBytesWritten ( ) 
 + { 
 + return getOnDiskFilePointer ( ) ; 
 + } 
 + 
 public abstract void resetAndTruncate ( ) ; 
 
 public SSTableWriter setRepairedAt ( long repairedAt ) 
 diff - - git a / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java b / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java 
 index 39dc889 . . 8645158 100644 
 - - - a / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java 
 + + + b / src / java / org / apache / cassandra / io / sstable / format / big / BigTableWriter . java 
 @ @ - 394 , 6 + 394 , 11 @ @ public class BigTableWriter extends SSTableWriter 
 return dataFile . getOnDiskFilePointer ( ) ; 
 } 
 
 + public long getEstimatedOnDiskBytesWritten ( ) 
 + { 
 + return dataFile . getEstimatedOnDiskBytesWritten ( ) ; 
 + } 
 + 
 / * * 
 * Encapsulates writing the index and filter for an SSTable . The state of this object is not valid until it has been closed . 
 * / 
 diff - - git a / src / java / org / apache / cassandra / io / util / SequentialWriter . java b / src / java / org / apache / cassandra / io / util / SequentialWriter . java 
 index f153b4d . . 45e4cfa 100644 
 - - - a / src / java / org / apache / cassandra / io / util / SequentialWriter . java 
 + + + b / src / java / org / apache / cassandra / io / util / SequentialWriter . java 
 @ @ - 276 , 6 + 276 , 11 @ @ public class SequentialWriter extends BufferedDataOutputStreamPlus implements Tr 
 return position ( ) ; 
 } 
 
 + public long getEstimatedOnDiskBytesWritten ( ) 
 + { 
 + return getOnDiskFilePointer ( ) ; 
 + } 
 + 
 public long length ( ) 
 { 
 try

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1b6f4d1 . . f9b45d6 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 10 , 6 + 10 , 7 @ @ 
 * ( cql3 ) Support ORDER BY when IN condition is given in WHERE clause ( CASSANDRA - 4327 ) 
 * ( cql3 ) delete " component _ index " column on DROP TABLE call ( CASSANDRA - 4420 ) 
 * change nanoTime ( ) to currentTimeInMillis ( ) in schema related code ( CASSANDRA - 4432 ) 
 + * add a token generation tool ( CASSANDRA - 3709 ) 
 Merged from 1 . 0 : 
 * allow dropping columns shadowed by not - yet - expired supercolumn or row 
 tombstones in PrecompactedRow ( CASSANDRA - 4396 ) 
 diff - - git a / tools / bin / token - generator b / tools / bin / token - generator 
 new file mode 100644 
 index 0000000 . . 57d7fce 
 - - - / dev / null 
 + + + b / tools / bin / token - generator 
 @ @ - 0 , 0 + 1 , 317 @ @ 
 + # ! / usr / bin / env python 
 + 
 + from _ _ future _ _ import with _ statement 
 + 
 + import os 
 + import sys 
 + import math 
 + import optparse 
 + import webbrowser 
 + import urllib 
 + from time import sleep 
 + from itertools import cycle 
 + from tempfile import NamedTemporaryFile 
 + 
 + description = ' ' ' Given a list of numbers indicating the number of nodes 
 + in each separate datacenter , outputs a recommended list of tokens to use 
 + with RandomPartitioner : one for each node in each datacenter . 
 + ' ' ' 
 + 
 + usage = " % prog < nodes _ in _ dc1 > [ < nodes _ in _ dc2 > [ . . . ] ] " 
 + 
 + parser = optparse . OptionParser ( description = description , usage = usage ) 
 + parser . add _ option ( ' - - ringrange ' , type = ' int ' , 
 + help = ' Specify a numeric maximum token value for your ring , ' 
 + ' different from the default value of 2 ^ 127 . ' ) 
 + parser . add _ option ( ' - - graph ' , action = ' store _ true ' , 
 + help = ' Show a rendering of the generated tokens as line ' 
 + ' segments in a circle , colored according to datacenter ' ) 
 + parser . add _ option ( ' - n ' , ' - - nts ' , action = ' store _ const ' , dest = ' strat ' , const = ' nts ' , 
 + help = ' Optimize multi - cluster distribution for ' 
 + ' NetworkTopologyStrategy [ default ] ' ) 
 + parser . add _ option ( ' - o ' , ' - - onts ' , action = ' store _ const ' , dest = ' strat ' , const = ' onts ' , 
 + help = ' Optimize multi - cluster distribution for ' 
 + ' OldNetworkTopologyStrategy ' ) 
 + 
 + parser . add _ option ( ' - - test ' , action = ' store _ true ' , 
 + help = ' Run in test mode , outputting an HTML file to display ' 
 + ' various generated ring arrangements . ' ) 
 + 
 + parser . add _ option ( ' - - html - output ' , help = optparse . SUPPRESS _ HELP ) 
 + parser . add _ option ( ' - - browser - wait - time ' , type = ' float ' , help = optparse . SUPPRESS _ HELP ) 
 + parser . add _ option ( ' - - test - colors ' , help = optparse . SUPPRESS _ HELP ) 
 + parser . add _ option ( ' - - test - graphsize ' , type = ' int ' , help = optparse . SUPPRESS _ HELP ) 
 + 
 + parser . set _ defaults ( 
 + ringrange = ( 1 < < 127 ) , 
 + 
 + # whether to create ( and try to display ) graph output 
 + graph = False , 
 + 
 + # ' nts ' or ' onts ' ; the replication strategy for which to optimize 
 + strat = ' nts ' , 
 + 
 + # durr 
 + test = False , 
 + 
 + # size of the generated graph 
 + graphsize = 600 , 
 + 
 + # where to write generated graph ( HTML ) output , or ' * tmp * ' to write a 
 + # temporary file , and remove it after telling a browser to open it . ' - ' 
 + # to write to stdout . 
 + html _ output = ' * tmp * ' , 
 + 
 + # how long , in seconds , to wait before cleaning up a temporary html file 
 + # after telling the browser to open it 
 + browser _ wait _ time = 5 . 0 , 
 + 
 + # comma - separated list of HTML color codes , used in order to represent 
 + # respective datacenter nodes 
 + test _ colors = ' # 000 , # 00F , # 0F0 , # F00 , # 0FF , # FF0 , # F0F ' , 
 + 
 + # size of the per - test graphs 
 + test _ graphsize = 200 , 
 + ) 
 + 
 + class Ring : 
 + MIN _ DC _ OFFSET _ DIVIDER = 235 
 + offset _ spacer = 2 
 + 
 + def _ _ init _ _ ( self , dc _ counts , ringrange , strategy = ' nts ' ) : 
 + self . ringrange = ringrange 
 + self . dc _ counts = dc _ counts 
 + self . calculate _ offset _ tokens = getattr ( self , ' calc _ offset _ tokens _ ' + strategy ) 
 + 
 + def best _ per _ dc _ offset ( self ) : 
 + " " " 
 + Calculate a per - dc offset for NTS DC spacing , such that there is a little 
 + bit of room between nodes which would otherwise have been at the same token ; 
 + ( hopefully ) large enough that the difference can show when - - graph is used , 
 + but small enough that it there ' s no chance of the relative ordering changing . 
 + " " " 
 + lowest _ division = len ( self . dc _ counts ) * max ( self . dc _ counts ) * self . offset _ spacer 
 + division = max ( lowest _ division , self . MIN _ DC _ OFFSET _ DIVIDER ) 
 + return - self . ringrange / / division 
 + 
 + def calc _ offset _ tokens _ nts ( self ) : 
 + dc _ offset = self . best _ per _ dc _ offset ( ) 
 + dcs = [ ] 
 + for ( dcnum , dccount ) in enumerate ( self . dc _ counts ) : 
 + offset = dcnum * dc _ offset 
 + arcsize = self . ringrange / / ( dccount or 1 ) 
 + dcs . append ( [ ( n * arcsize + offset ) % self . ringrange for n in xrange ( dccount ) ] ) 
 + return dcs 
 + 
 + def calc _ offset _ tokens _ onts ( self ) : 
 + dcs _ by _ count = sorted ( enumerate ( self . dc _ counts ) , key = lambda d : d [ 1 ] , reverse = True ) 
 + biggest = dcs _ by _ count [ 0 ] [ 1 ] 
 + nodes = [ dcnum for ( dcnum , dccount ) in dcs _ by _ count for x in range ( dccount ) ] 
 + layout = [ nodes [ n ] for i in range ( biggest ) for n in range ( i , len ( nodes ) , biggest ) ] 
 + 
 + final = [ [ ] for x in dcs _ by _ count ] 
 + for pos , dc in enumerate ( layout ) : 
 + final [ dc ] . append ( pos * self . ringrange / / len ( layout ) ) 
 + return final 
 + 
 + 
 + def print _ tokens ( tokens , tokenwidth , indent = 0 ) : 
 + indentstr = ' ' * indent 
 + for dcnum , toklist in enumerate ( tokens ) : 
 + print " % sDC # % d : " % ( indentstr , dcnum + 1 ) 
 + nwidth = len ( str ( len ( toklist ) ) ) 
 + for tnum , tok in enumerate ( toklist ) : 
 + print " % s Node # % 0 * d : % * d " % ( indentstr , nwidth , tnum + 1 , tokenwidth , tok ) 
 + 
 + def calculate _ ideal _ tokens ( datacenters , ringrange , strategy ) : 
 + return Ring ( datacenters , ringrange , strategy ) . calculate _ offset _ tokens ( ) 
 + 
 + def file _ to _ url ( path ) : 
 + path = os . path . abspath ( path ) 
 + if os . name = = ' nt ' : 
 + host , path = os . path . splitunc ( path ) 
 + drive , path = os . path . splitdrive ( path ) 
 + path = ( host or ( drive + ' | ' ) ) + path . replace ( os . sep , ' / ' ) 
 + return ' file : / / ' + urllib . quote ( path , safe = ' / ' ) 
 + 
 + html _ template = " " " < ! DOCTYPE html > 
 + < html > 
 + < body > 
 + 
 + % ( generated _ body ) s 
 + 
 + < / body > 
 + < / html > 
 + " " " 
 + 
 + chart _ template = " " " 
 + < canvas id = " % ( id ) s " width = " % ( size ) s " height = " % ( size ) s " style = " border : 1px solid # c3c3c3 ; " > 
 + Your browser does not support the canvas element . 
 + < / canvas > 
 + < script type = " text / javascript " > 
 + var c = document . getElementById ( " % ( id ) s " ) ; 
 + var ctx = c . getContext ( " 2d " ) ; 
 + % ( generated _ script ) s 
 + < / script > 
 + " " " 
 + 
 + chart _ js _ template = " " " 
 + ctx . beginPath ( ) ; 
 + ctx . strokeStyle = " % ( color ) s " ; 
 + ctx . moveTo ( % ( center ) s , % ( center ) s ) ; 
 + ctx . lineTo ( % ( x ) s , % ( y ) s ) ; 
 + ctx . stroke ( ) ; 
 + ctx . closePath ( ) ; 
 + " " " 
 + 
 + class RingRenderer : 
 + border _ fraction = 0 . 08 
 + 
 + def _ _ init _ _ ( self , ringrange , graphsize , colors ) : 
 + self . ringrange = ringrange 
 + self . graphsize = graphsize 
 + self . colors = colors 
 + self . anglefactor = 2 * math . pi / ringrange 
 + self . linelength = graphsize * ( 1 - self . border _ fraction ) / 2 
 + self . center = graphsize / 2 
 + 
 + def calc _ coords ( self , tokens ) : 
 + these _ calcs = [ ] 
 + 
 + for toklist in tokens : 
 + coordlist = [ ] 
 + for tok in toklist : 
 + angle = tok * self . anglefactor 
 + x2 = self . center + self . linelength * math . sin ( angle ) 
 + y2 = self . center - self . linelength * math . cos ( angle ) 
 + coordlist . append ( ( x2 , y2 ) ) 
 + these _ calcs . append ( coordlist ) 
 + 
 + return these _ calcs 
 + 
 + def make _ html ( self , tokensets ) : 
 + coordinate _ sets = map ( self . calc _ coords , tokensets ) 
 + all _ charts = [ ] 
 + for chart _ index , chart _ set in enumerate ( coordinate _ sets ) : 
 + chart _ code = [ ] 
 + for coordlist , color in zip ( chart _ set , cycle ( self . colors ) ) : 
 + for x , y in coordlist : 
 + chart _ code . append ( chart _ js _ template 
 + % dict ( color = color , x = x , y = y , 
 + center = ( self . graphsize / 2 ) ) ) 
 + this _ chart = chart _ template % dict ( generated _ script = ' ' . join ( chart _ code ) , 
 + id = chart _ index , size = self . graphsize ) 
 + all _ charts . append ( this _ chart ) 
 + return html _ template % dict ( generated _ body = ' ' . join ( all _ charts ) ) 
 + 
 + # = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 + # Tests 
 + 
 + def run _ tests ( opts ) : 
 + tests = [ 
 + [ 1 ] , 
 + [ 1 , 1 ] , 
 + [ 2 , 2 ] , 
 + [ 1 , 2 , 2 ] , 
 + [ 2 , 2 , 2 ] , 
 + [ 2 , 0 , 0 ] , 
 + [ 0 , 2 , 0 ] , 
 + [ 0 , 0 , 2 ] , 
 + [ 2 , 2 , 0 ] , 
 + [ 2 , 0 , 2 ] , 
 + [ 0 , 2 , 2 ] , 
 + [ 0 , 0 , 1 , 1 , 0 , 1 , 1 ] , 
 + [ 6 ] , 
 + [ 3 , 3 , 3 ] , 
 + [ 9 ] , 
 + [ 1 , 1 , 1 , 1 ] , 
 + [ 4 ] , 
 + [ 3 , 3 , 6 , 4 , 2 ] 
 + ] 
 + 
 + tokensets = [ ] 
 + for test in tests : 
 + print " Test % r " % ( test , ) 
 + tokens = calculate _ ideal _ tokens ( test , opts . ringrange , opts . strat ) 
 + print _ tokens ( tokens , len ( str ( opts . ringrange ) ) + 1 , indent = 2 ) 
 + tokensets . append ( tokens ) 
 + return tokensets 
 + 
 + # = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 + 
 + def display _ html ( html , wait _ time ) : 
 + with NamedTemporaryFile ( suffix = ' . html ' ) as f : 
 + f . write ( html ) 
 + f . flush ( ) 
 + webbrowser . open ( file _ to _ url ( f . name ) , new = 2 ) 
 + # this is stupid . webbrowser . open really can ' t wait until the 
 + # browser has said " yes I ' ve got it " ? 
 + sleep ( wait _ time ) 
 + 
 + def write _ output ( html , opts ) : 
 + if opts . html _ output = = ' - ' : 
 + sys . stdout . write ( html ) 
 + elif opts . html _ output = = ' * tmp * ' : 
 + display _ html ( html , opts . browser _ wait _ time ) 
 + else : 
 + with open ( opts . html _ output , ' w ' ) as f : 
 + f . write ( html ) 
 + 
 + def readnum ( prompt , min = None , max = None ) : 
 + while True : 
 + x = raw _ input ( prompt + ' ' ) 
 + try : 
 + val = int ( x ) 
 + except ValueError : 
 + print " Oops , % r is not an integer . Try again . \ n " % ( x , ) 
 + continue 
 + if min is not None and val < min : 
 + print " Oops , the answer must be at least % d . Try again . \ n " % ( min , ) 
 + elif max is not None and val > max : 
 + print " Oops , the answer must be at most % d . Try again . \ n " % ( max , ) 
 + else : 
 + return val 
 + 
 + def get _ dc _ sizes _ interactive ( ) : 
 + print " Token Generator Interactive Mode " 
 + print " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " 
 + print 
 + dcs = readnum ( " How many datacenters will participate in this Cassandra cluster ? " , min = 1 ) 
 + sizes = [ ] 
 + for n in xrange ( dcs ) : 
 + sizes . append ( readnum ( " How many nodes are in datacenter # % d ? " % ( n + 1 ) , min = 0 ) ) 
 + print 
 + return sizes 
 + 
 + def main ( opts , args ) : 
 + opts . colorlist = [ s . strip ( ) for s in opts . test _ colors . split ( ' , ' ) ] 
 + if opts . test : 
 + opts . graph = True 
 + tokensets = run _ tests ( opts ) 
 + renderer = RingRenderer ( ringrange = opts . ringrange , graphsize = opts . test _ graphsize , 
 + colors = opts . colorlist ) 
 + else : 
 + if len ( args ) = = 0 : 
 + args = get _ dc _ sizes _ interactive ( ) 
 + try : 
 + datacenters = map ( int , args ) 
 + except ValueError , e : 
 + parser . error ( ' Arguments should be integers . ' ) 
 + renderer = RingRenderer ( ringrange = opts . ringrange , graphsize = opts . graphsize , 
 + colors = opts . colorlist ) 
 + tokens = calculate _ ideal _ tokens ( datacenters , opts . ringrange , opts . strat ) 
 + print _ tokens ( tokens , len ( str ( opts . ringrange ) ) + 1 ) 
 + tokensets = [ tokens ] 
 + 
 + if opts . graph : 
 + html = renderer . make _ html ( tokensets ) 
 + write _ output ( html , opts ) 
 + return 0 
 + 
 + if _ _ name _ _ = = ' _ _ main _ _ ' : 
 + opts , args = parser . parse _ args ( ) 
 + try : 
 + res = main ( opts , args ) 
 + except KeyboardInterrupt : 
 + res = - 128 
 + sys . exit ( res )
