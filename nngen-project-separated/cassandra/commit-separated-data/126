BLEU SCORE: 0.02383853510228548

TEST MSG: Support light - weight transactions in cassandra - stress
GENERATED MSG: optional CQL query support

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6819711 . . 629df0c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Support light - weight transactions in cassandra - stress ( CASSANDRA - 13529 ) <nl> * Make AsyncOneResponse use the correct timeout ( CASSANDRA - 14509 ) <nl> * Add option to sanity check tombstones on reads / compactions ( CASSANDRA - 14467 ) <nl> * Add a virtual table to expose all running sstable tasks ( CASSANDRA - 14457 ) <nl> diff - - git a / doc / source / tools / cassandra _ stress . rst b / doc / source / tools / cassandra _ stress . rst <nl> index 322a981 . . bcac54e 100644 <nl> - - - a / doc / source / tools / cassandra _ stress . rst <nl> + + + b / doc / source / tools / cassandra _ stress . rst <nl> @ @ - 220 , 6 + 220 , 24 @ @ Running a user mode test with multiple yaml files : : <nl> This will run operations as specified in both the example . yaml and example2 . yaml files . example . yaml and example2 . yaml can reference the same table <nl> although care must be taken that the table definition is identical ( data generation specs can be different ) . <nl> <nl> + Lightweight transaction support <nl> + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + <nl> + <nl> + cassandra - stress supports lightweight transactions . In this it will first read current data from Cassandra and then uses read value ( s ) <nl> + to fulfill lightweight transaction condition ( s ) . <nl> + <nl> + Lightweight transaction update query : : <nl> + <nl> + queries : <nl> + regularupdate : <nl> + cql : update blogposts set author = ? where domain = ? and published _ date = ? <nl> + fields : samerow <nl> + updatewithlwt : <nl> + cql : update blogposts set author = ? where domain = ? and published _ date = ? IF body = ? AND url = ? <nl> + fields : samerow <nl> + <nl> + The full example can be found here : download : ` yaml < . / stress - lwt - example . yaml > ` <nl> + <nl> Graphing <nl> ^ ^ ^ ^ ^ ^ ^ ^ <nl> <nl> diff - - git a / doc / source / tools / stress - lwt - example . yaml b / doc / source / tools / stress - lwt - example . yaml <nl> new file mode 100644 <nl> index 0000000 . . fc5db08 <nl> - - - / dev / null <nl> + + + b / doc / source / tools / stress - lwt - example . yaml <nl> @ @ - 0 , 0 + 1 , 70 @ @ <nl> + # Keyspace Name <nl> + keyspace : stresscql <nl> + <nl> + # The CQL for creating a keyspace ( optional if it already exists ) <nl> + # Would almost always be network topology unless running something locall <nl> + keyspace _ definition : | <nl> + CREATE KEYSPACE stresscql WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; <nl> + <nl> + # Table name <nl> + table : blogposts <nl> + <nl> + # The CQL for creating a table you wish to stress ( optional if it already exists ) <nl> + table _ definition : | <nl> + CREATE TABLE blogposts ( <nl> + domain text , <nl> + published _ date timeuuid , <nl> + url text , <nl> + author text , <nl> + title text , <nl> + body text , <nl> + PRIMARY KEY ( domain , published _ date ) <nl> + ) WITH CLUSTERING ORDER BY ( published _ date DESC ) <nl> + AND compaction = { ' class ' : ' LeveledCompactionStrategy ' } <nl> + AND comment = ' A table to hold blog posts ' <nl> + <nl> + # # # Column Distribution Specifications # # # <nl> + <nl> + columnspec : <nl> + - name : domain <nl> + size : gaussian ( 5 . . 100 ) # domain names are relatively short <nl> + population : uniform ( 1 . . 10M ) # 10M possible domains to pick from <nl> + <nl> + - name : published _ date <nl> + cluster : fixed ( 1000 ) # under each domain we will have max 1000 posts <nl> + <nl> + - name : url <nl> + size : uniform ( 30 . . 300 ) <nl> + <nl> + - name : title # titles shouldn ' t go beyond 200 chars <nl> + size : gaussian ( 10 . . 200 ) <nl> + <nl> + - name : author <nl> + size : uniform ( 5 . . 20 ) # author names should be short <nl> + <nl> + - name : body <nl> + size : gaussian ( 100 . . 5000 ) # the body of the blog post can be long <nl> + <nl> + # # # Batch Ratio Distribution Specifications # # # <nl> + <nl> + insert : <nl> + partitions : fixed ( 1 ) # Our partition key is the domain so only insert one per batch <nl> + <nl> + select : fixed ( 1 ) / 1000 # We have 1000 posts per domain so 1 / 1000 will allow 1 post per batch <nl> + <nl> + batchtype : UNLOGGED # Unlogged batches <nl> + <nl> + <nl> + # <nl> + # A list of queries you wish to run against the schema <nl> + # <nl> + queries : <nl> + singlepost : <nl> + cql : select * from blogposts where domain = ? LIMIT 1 <nl> + fields : samerow <nl> + regularupdate : <nl> + cql : update blogposts set author = ? where domain = ? and published _ date = ? <nl> + fields : samerow <nl> + updatewithlwt : <nl> + cql : update blogposts set author = ? where domain = ? and published _ date = ? IF body = ? AND url = ? <nl> + fields : samerow <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java b / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java <nl> index c9d7fe8 . . aa5c10d 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java <nl> @ @ - 849 , 7 + 849 , 12 @ @ public abstract class ColumnCondition <nl> throw invalidRequest ( " Slice conditions ( % s ) are not supported on durations " , operator ) ; <nl> } <nl> } <nl> - <nl> + <nl> + public Term . Raw getValue ( ) <nl> + { <nl> + return value ; <nl> + } <nl> + <nl> @ Override <nl> public String toString ( ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> index e02fd41 . . 65e1e2d 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java <nl> @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . cql3 . statements ; <nl> import java . nio . ByteBuffer ; <nl> import java . util . * ; <nl> <nl> + import com . google . common . collect . ImmutableList ; <nl> import com . google . common . collect . Iterables ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> @ @ - 936 , 5 + 937 , 15 @ @ public abstract class ModificationStatement implements CQLStatement <nl> { <nl> return rawId . prepare ( metadata ) ; <nl> } <nl> + <nl> + public List < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > getConditions ( ) <nl> + { <nl> + ImmutableList . Builder < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > builder = ImmutableList . builderWithExpectedSize ( conditions . size ( ) ) ; <nl> + <nl> + for ( Pair < Raw , ColumnCondition . Raw > condition : conditions ) <nl> + builder . add ( Pair . create ( condition . left , condition . right ) ) ; <nl> + <nl> + return builder . build ( ) ; <nl> + } <nl> } <nl> } <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> index 2338873 . . cda9c58 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java <nl> @ @ - 42 , 14 + 42 , 17 @ @ import org . apache . cassandra . cql3 . CQLFragmentParser ; <nl> import org . apache . cassandra . cql3 . CqlParser ; <nl> import org . apache . cassandra . cql3 . QueryProcessor ; <nl> import org . apache . cassandra . cql3 . statements . CreateTableStatement ; <nl> + import org . apache . cassandra . cql3 . statements . ModificationStatement ; <nl> import org . apache . cassandra . exceptions . RequestValidationException ; <nl> import org . apache . cassandra . exceptions . SyntaxException ; <nl> import org . apache . cassandra . schema . ColumnMetadata ; <nl> import org . apache . cassandra . stress . generate . * ; <nl> import org . apache . cassandra . stress . generate . values . * ; <nl> - import org . apache . cassandra . stress . operations . userdefined . TokenRangeQuery ; <nl> + import org . apache . cassandra . stress . operations . userdefined . CASQuery ; <nl> import org . apache . cassandra . stress . operations . userdefined . SchemaInsert ; <nl> import org . apache . cassandra . stress . operations . userdefined . SchemaQuery ; <nl> + import org . apache . cassandra . stress . operations . userdefined . SchemaStatement ; <nl> + import org . apache . cassandra . stress . operations . userdefined . TokenRangeQuery ; <nl> import org . apache . cassandra . stress . operations . userdefined . ValidatingSchemaQuery ; <nl> import org . apache . cassandra . stress . report . Timer ; <nl> import org . apache . cassandra . stress . settings . * ; <nl> @ @ - 87 , 7 + 90 , 7 @ @ public class StressProfile implements Serializable <nl> transient volatile PreparedStatement insertStatement ; <nl> transient volatile List < ValidatingSchemaQuery . Factory > validationFactories ; <nl> <nl> - transient volatile Map < String , SchemaQuery . ArgSelect > argSelects ; <nl> + transient volatile Map < String , SchemaStatement . ArgSelect > argSelects ; <nl> transient volatile Map < String , PreparedStatement > queryStatements ; <nl> <nl> private static final Pattern lowercaseAlphanumeric = Pattern . compile ( " [ a - z0 - 9 _ ] + " ) ; <nl> @ @ - 367 , 13 + 370 , 13 @ @ public class StressProfile implements Serializable <nl> JavaDriverClient jclient = settings . getJavaDriverClient ( keyspaceName ) ; <nl> <nl> Map < String , PreparedStatement > stmts = new HashMap < > ( ) ; <nl> - Map < String , SchemaQuery . ArgSelect > args = new HashMap < > ( ) ; <nl> + Map < String , SchemaStatement . ArgSelect > args = new HashMap < > ( ) ; <nl> for ( Map . Entry < String , StressYaml . QueryDef > e : queries . entrySet ( ) ) <nl> { <nl> stmts . put ( e . getKey ( ) . toLowerCase ( ) , jclient . prepare ( e . getValue ( ) . cql ) ) ; <nl> args . put ( e . getKey ( ) . toLowerCase ( ) , e . getValue ( ) . fields = = null <nl> - ? SchemaQuery . ArgSelect . MULTIROW <nl> - : SchemaQuery . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; <nl> + ? SchemaStatement . ArgSelect . MULTIROW <nl> + : SchemaStatement . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; <nl> } <nl> queryStatements = stmts ; <nl> argSelects = args ; <nl> @ @ - 381 , 9 + 384 , 42 @ @ public class StressProfile implements Serializable <nl> } <nl> } <nl> <nl> + if ( dynamicConditionExists ( queryStatements . get ( name ) ) ) <nl> + return new CASQuery ( timer , settings , generator , seeds , queryStatements . get ( name ) , settings . command . consistencyLevel , argSelects . get ( name ) , tableName ) ; <nl> + <nl> return new SchemaQuery ( timer , settings , generator , seeds , queryStatements . get ( name ) , settings . command . consistencyLevel , argSelects . get ( name ) ) ; <nl> } <nl> <nl> + static boolean dynamicConditionExists ( PreparedStatement statement ) throws IllegalArgumentException <nl> + { <nl> + if ( statement = = null ) <nl> + return false ; <nl> + <nl> + if ( ! statement . getQueryString ( ) . toUpperCase ( ) . startsWith ( " UPDATE " ) ) <nl> + return false ; <nl> + <nl> + ModificationStatement . Parsed modificationStatement ; <nl> + try <nl> + { <nl> + modificationStatement = CQLFragmentParser . parseAnyUnhandled ( CqlParser : : updateStatement , <nl> + statement . getQueryString ( ) ) ; <nl> + } <nl> + catch ( RecognitionException e ) <nl> + { <nl> + throw new IllegalArgumentException ( " could not parse update query : " + statement . getQueryString ( ) , e ) ; <nl> + } <nl> + <nl> + / * <nl> + * here we differentiate between static vs dynamic conditions : <nl> + * - static condition example : if col1 = NULL <nl> + * - dynamic condition example : if col1 = ? <nl> + * for static condition we don ' t have to replace value , no extra work involved . <nl> + * for dynamic condition we have to read existing db value and then <nl> + * use current db values during the update . <nl> + * / <nl> + return modificationStatement . getConditions ( ) . stream ( ) . anyMatch ( condition - > condition . right . getValue ( ) . getText ( ) . equals ( " ? " ) ) ; <nl> + } <nl> + <nl> public Operation getBulkReadQueries ( String name , Timer timer , StressSettings settings , TokenRangeIterator tokenRangeIterator , boolean isWarmup ) <nl> { <nl> StressYaml . TokenRangeQueryDef def = tokenRangeQueries . get ( name ) ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java b / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java <nl> index 1230065 . . 882b8b4 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java <nl> @ @ - 83 , 6 + 83 , 16 @ @ public class PartitionGenerator <nl> return ! ( index < 0 | | index < clusteringComponents . size ( ) ) ; <nl> } <nl> <nl> + public List < Generator > getPartitionKey ( ) <nl> + { <nl> + return Collections . unmodifiableList ( partitionKey ) ; <nl> + } <nl> + <nl> + public List < Generator > getClusteringComponents ( ) <nl> + { <nl> + return Collections . unmodifiableList ( clusteringComponents ) ; <nl> + } <nl> + <nl> public int indexOf ( String name ) <nl> { <nl> Integer i = indexMap . get ( name ) ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java b / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java <nl> index bad0a94 . . 55c6872 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java <nl> @ @ - 19 , 6 + 19 , 7 @ @ <nl> package org . apache . cassandra . stress . operations ; <nl> <nl> import java . util . ArrayList ; <nl> + import java . util . Collections ; <nl> import java . util . List ; <nl> <nl> import org . apache . cassandra . stress . Operation ; <nl> @ @ - 75 , 6 + 76 , 16 @ @ public abstract class PartitionOperation extends Operation <nl> this . spec = spec ; <nl> } <nl> <nl> + public DataSpec getDataSpecification ( ) <nl> + { <nl> + return spec ; <nl> + } <nl> + <nl> + public List < PartitionIterator > getPartitions ( ) <nl> + { <nl> + return Collections . unmodifiableList ( partitions ) ; <nl> + } <nl> + <nl> public int ready ( WorkManager permits ) <nl> { <nl> int partitionCount = ( int ) spec . partitionCount . next ( ) ; <nl> @ @ - 86 , 7 + 97 , 7 @ @ public abstract class PartitionOperation extends Operation <nl> <nl> int i = 0 ; <nl> boolean success = true ; <nl> - for ( ; i < partitionCount & & success ; i + + ) <nl> + for ( ; i < partitionCount & & success ; i + + ) <nl> { <nl> if ( i > = partitionCache . size ( ) ) <nl> partitionCache . add ( PartitionIterator . get ( spec . partitionGenerator , spec . seedManager ) ) ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java <nl> new file mode 100644 <nl> index 0000000 . . e7d0fe3 <nl> - - - / dev / null <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java <nl> @ @ - 0 , 0 + 1 , 227 @ @ <nl> + package org . apache . cassandra . stress . operations . userdefined ; <nl> + / * <nl> + * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * <nl> + * / <nl> + <nl> + import com . datastax . driver . core . BoundStatement ; <nl> + import com . datastax . driver . core . ColumnDefinitions ; <nl> + import com . datastax . driver . core . DataType ; <nl> + import com . datastax . driver . core . LocalDate ; <nl> + import com . datastax . driver . core . PreparedStatement ; <nl> + import com . datastax . driver . core . ResultSet ; <nl> + import org . antlr . runtime . RecognitionException ; <nl> + import org . apache . cassandra . cql3 . CQLFragmentParser ; <nl> + import org . apache . cassandra . cql3 . CqlParser ; <nl> + import org . apache . cassandra . cql3 . conditions . ColumnCondition ; <nl> + import org . apache . cassandra . cql3 . statements . ModificationStatement ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . schema . ColumnMetadata ; <nl> + import org . apache . cassandra . stress . generate . DistributionFixed ; <nl> + import org . apache . cassandra . stress . generate . PartitionGenerator ; <nl> + import org . apache . cassandra . stress . generate . Row ; <nl> + import org . apache . cassandra . stress . generate . SeedManager ; <nl> + import org . apache . cassandra . stress . generate . values . Generator ; <nl> + import org . apache . cassandra . stress . report . Timer ; <nl> + import org . apache . cassandra . stress . settings . StressSettings ; <nl> + import org . apache . cassandra . stress . util . JavaDriverClient ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . util . ArrayList ; <nl> + import java . util . Arrays ; <nl> + import java . util . HashMap ; <nl> + import java . util . List ; <nl> + import java . util . Map ; <nl> + import java . util . stream . Collectors ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import com . google . common . collect . ImmutableMap ; <nl> + <nl> + public class CASQuery extends SchemaStatement <nl> + { <nl> + private final ImmutableList < Integer > keysIndex ; <nl> + private final ImmutableMap < Integer , Integer > casConditionArgFreqMap ; <nl> + private final String readQuery ; <nl> + <nl> + private PreparedStatement casReadConditionStatement ; <nl> + <nl> + public CASQuery ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , PreparedStatement statement , ConsistencyLevel cl , ArgSelect argSelect , final String tableName ) <nl> + { <nl> + super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = SchemaStatement . ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , <nl> + statement . getVariables ( ) . asList ( ) . stream ( ) . map ( ColumnDefinitions . Definition : : getName ) . collect ( Collectors . toList ( ) ) , cl ) ; <nl> + <nl> + if ( argSelect ! = SchemaStatement . ArgSelect . SAMEROW ) <nl> + throw new IllegalArgumentException ( " CAS is supported only for type ' samerow ' " ) ; <nl> + <nl> + ModificationStatement . Parsed modificationStatement ; <nl> + try <nl> + { <nl> + modificationStatement = CQLFragmentParser . parseAnyUnhandled ( CqlParser : : updateStatement , <nl> + statement . getQueryString ( ) ) ; <nl> + } <nl> + catch ( RecognitionException e ) <nl> + { <nl> + throw new IllegalArgumentException ( " could not parse update query : " + statement . getQueryString ( ) , e ) ; <nl> + } <nl> + <nl> + final List < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > casConditionList = modificationStatement . getConditions ( ) ; <nl> + List < Integer > casConditionIndex = new ArrayList < > ( ) ; <nl> + <nl> + boolean first = true ; <nl> + StringBuilder casReadConditionQuery = new StringBuilder ( ) ; <nl> + casReadConditionQuery . append ( " SELECT " ) ; <nl> + for ( final Pair < ColumnMetadata . Raw , ColumnCondition . Raw > condition : casConditionList ) <nl> + { <nl> + if ( ! condition . right . getValue ( ) . getText ( ) . equals ( " ? " ) ) <nl> + { <nl> + / / condition uses static value , ignore it <nl> + continue ; <nl> + } <nl> + if ( ! first ) <nl> + { <nl> + casReadConditionQuery . append ( " , " ) ; <nl> + } <nl> + casReadConditionQuery . append ( condition . left . rawText ( ) ) ; <nl> + casConditionIndex . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( condition . left . rawText ( ) ) ) ; <nl> + first = false ; <nl> + } <nl> + casReadConditionQuery . append ( " FROM " ) . append ( tableName ) . append ( " WHERE " ) ; <nl> + <nl> + first = true ; <nl> + ImmutableList . Builder < Integer > keysBuilder = ImmutableList . builder ( ) ; <nl> + for ( final Generator key : getDataSpecification ( ) . partitionGenerator . getPartitionKey ( ) ) <nl> + { <nl> + if ( ! first ) <nl> + { <nl> + casReadConditionQuery . append ( " AND " ) ; <nl> + } <nl> + casReadConditionQuery . append ( key . name ) . append ( " = ? " ) ; <nl> + keysBuilder . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( key . name ) ) ; <nl> + first = false ; <nl> + } <nl> + for ( final Generator clusteringKey : getDataSpecification ( ) . partitionGenerator . getClusteringComponents ( ) ) <nl> + { <nl> + casReadConditionQuery . append ( " AND " ) . append ( clusteringKey . name ) . append ( " = ? " ) ; <nl> + keysBuilder . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( clusteringKey . name ) ) ; <nl> + } <nl> + keysIndex = keysBuilder . build ( ) ; <nl> + readQuery = casReadConditionQuery . toString ( ) ; <nl> + <nl> + ImmutableMap . Builder < Integer , Integer > builder = ImmutableMap . builderWithExpectedSize ( casConditionIndex . size ( ) ) ; <nl> + for ( final Integer oneConditionIndex : casConditionIndex ) <nl> + { <nl> + builder . put ( oneConditionIndex , Math . toIntExact ( Arrays . stream ( argumentIndex ) . filter ( ( x ) - > x = = oneConditionIndex ) . count ( ) ) ) ; <nl> + } <nl> + casConditionArgFreqMap = builder . build ( ) ; <nl> + } <nl> + <nl> + private class JavaDriverRun extends Runner <nl> + { <nl> + final JavaDriverClient client ; <nl> + <nl> + private JavaDriverRun ( JavaDriverClient client ) <nl> + { <nl> + this . client = client ; <nl> + casReadConditionStatement = client . prepare ( readQuery ) ; <nl> + } <nl> + <nl> + public boolean run ( ) <nl> + { <nl> + ResultSet rs = client . getSession ( ) . execute ( bind ( client ) ) ; <nl> + rowCount = rs . all ( ) . size ( ) ; <nl> + partitionCount = Math . min ( 1 , rowCount ) ; <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + @ Override <nl> + public void run ( JavaDriverClient client ) throws IOException <nl> + { <nl> + timeWithRetry ( new JavaDriverRun ( client ) ) ; <nl> + } <nl> + <nl> + private BoundStatement bind ( JavaDriverClient client ) <nl> + { <nl> + final Object keys [ ] = new Object [ keysIndex . size ( ) ] ; <nl> + final Row row = getPartitions ( ) . get ( 0 ) . next ( ) ; <nl> + <nl> + for ( int i = 0 ; i < keysIndex . size ( ) ; i + + ) <nl> + { <nl> + keys [ i ] = row . get ( keysIndex . get ( i ) ) ; <nl> + } <nl> + <nl> + / / get current db values for all the coluns which are part of dynamic conditions <nl> + ResultSet rs = client . getSession ( ) . execute ( casReadConditionStatement . bind ( keys ) ) ; <nl> + final Object casDbValues [ ] = new Object [ casConditionArgFreqMap . size ( ) ] ; <nl> + <nl> + final com . datastax . driver . core . Row casDbValue = rs . one ( ) ; <nl> + if ( casDbValue ! = null ) <nl> + { <nl> + for ( int i = 0 ; i < casConditionArgFreqMap . size ( ) ; i + + ) <nl> + { <nl> + casDbValues [ i ] = casDbValue . getObject ( i ) ; <nl> + } <nl> + } <nl> + / / now bind db values for dynamic conditions in actual CAS update operation <nl> + return prepare ( row , casDbValues ) ; <nl> + } <nl> + <nl> + private BoundStatement prepare ( final Row row , final Object [ ] casDbValues ) <nl> + { <nl> + final Map < Integer , Integer > localMapping = new HashMap < > ( casConditionArgFreqMap ) ; <nl> + int conditionIndexTracker = 0 ; <nl> + for ( int i = 0 ; i < argumentIndex . length ; i + + ) <nl> + { <nl> + boolean replace = false ; <nl> + Integer count = localMapping . get ( argumentIndex [ i ] ) ; <nl> + if ( count ! = null ) <nl> + { <nl> + count - - ; <nl> + localMapping . put ( argumentIndex [ i ] , count ) ; <nl> + if ( count = = 0 ) <nl> + { <nl> + replace = true ; <nl> + } <nl> + } <nl> + <nl> + if ( replace ) <nl> + { <nl> + bindBuffer [ i ] = casDbValues [ conditionIndexTracker + + ] ; <nl> + } <nl> + else <nl> + { <nl> + Object value = row . get ( argumentIndex [ i ] ) ; <nl> + if ( definitions . getType ( i ) . getName ( ) = = DataType . date ( ) . getName ( ) ) <nl> + { <nl> + / / the java driver only accepts com . datastax . driver . core . LocalDate for CQL type " DATE " <nl> + value = LocalDate . fromDaysSinceEpoch ( ( Integer ) value ) ; <nl> + } <nl> + <nl> + bindBuffer [ i ] = value ; <nl> + } <nl> + <nl> + if ( bindBuffer [ i ] = = null & & ! getDataSpecification ( ) . partitionGenerator . permitNulls ( argumentIndex [ i ] ) ) <nl> + { <nl> + throw new IllegalStateException ( ) ; <nl> + } <nl> + } <nl> + return statement . bind ( bindBuffer ) ; <nl> + } <nl> + } <nl> \ No newline at end of file <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java <nl> index f0b332c . . cba9ce4 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java <nl> @ @ - 22 , 9 + 22 , 6 @ @ package org . apache . cassandra . stress . operations . userdefined ; <nl> <nl> <nl> import java . io . IOException ; <nl> - import java . nio . ByteBuffer ; <nl> - import java . util . ArrayList ; <nl> - import java . util . List ; <nl> import java . util . Random ; <nl> import java . util . stream . Collectors ; <nl> <nl> @ @ - 39 , 19 + 36 , 13 @ @ import org . apache . cassandra . stress . util . JavaDriverClient ; <nl> <nl> public class SchemaQuery extends SchemaStatement <nl> { <nl> - public static enum ArgSelect <nl> - { <nl> - MULTIROW , SAMEROW ; <nl> - / / TODO : FIRSTROW , LASTROW <nl> - } <nl> - <nl> final ArgSelect argSelect ; <nl> final Object [ ] [ ] randomBuffer ; <nl> final Random random = new Random ( ) ; <nl> <nl> public SchemaQuery ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , PreparedStatement statement , ConsistencyLevel cl , ArgSelect argSelect ) <nl> { <nl> - super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , <nl> + super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = SchemaStatement . ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , <nl> statement . getVariables ( ) . asList ( ) . stream ( ) . map ( d - > d . getName ( ) ) . collect ( Collectors . toList ( ) ) , cl ) ; <nl> this . argSelect = argSelect ; <nl> randomBuffer = new Object [ argumentIndex . length ] [ argumentIndex . length ] ; <nl> diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java <nl> index 6bd3fd5 . . 334e6c5 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java <nl> @ @ - 38 , 6 + 38 , 12 @ @ import org . apache . cassandra . stress . util . JavaDriverClient ; <nl> <nl> public abstract class SchemaStatement extends PartitionOperation <nl> { <nl> + public enum ArgSelect <nl> + { <nl> + MULTIROW , SAMEROW ; <nl> + / / TODO : FIRSTROW , LASTROW <nl> + } <nl> + <nl> final PreparedStatement statement ; <nl> final ConsistencyLevel cl ; <nl> final int [ ] argumentIndex ;
NEAREST DIFF (one line): diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java <nl> index 264f4b1 . . 57c7419 100644 <nl> - - - a / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java <nl> + + + b / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java <nl> @ @ - 30 , 6 + 30 , 7 @ @ import org . apache . cassandra . stress . Session ; <nl> import org . apache . cassandra . stress . util . Operation ; <nl> import org . apache . cassandra . thrift . Cassandra ; <nl> import org . apache . cassandra . thrift . Compression ; <nl> + import org . apache . cassandra . utils . UUIDGen ; <nl> <nl> public class CqlInserter extends Operation <nl> { <nl> @ @ - 55 , 8 + 56 , 15 @ @ public class CqlInserter extends Operation <nl> { <nl> if ( i > 0 ) <nl> query . append ( ' , ' ) ; <nl> - query . append ( ' C ' ) . append ( i ) . append ( ' = ' ) ; <nl> - query . append ( getQuotedCqlBlob ( values . get ( i % values . size ( ) ) . array ( ) ) ) ; <nl> + <nl> + / / Column name <nl> + if ( session . timeUUIDComparator ) <nl> + query . append ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) . toString ( ) ) ; <nl> + else <nl> + query . append ( ' C ' ) . append ( i ) ; <nl> + <nl> + / / Column value <nl> + query . append ( ' = ' ) . append ( getQuotedCqlBlob ( values . get ( i % values . size ( ) ) . array ( ) ) ) ; <nl> } <nl> <nl> String key = String . format ( " % 0 " + session . getTotalKeysLength ( ) + " d " , index ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6819711 . . 629df0c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Support light - weight transactions in cassandra - stress ( CASSANDRA - 13529 ) 
 * Make AsyncOneResponse use the correct timeout ( CASSANDRA - 14509 ) 
 * Add option to sanity check tombstones on reads / compactions ( CASSANDRA - 14467 ) 
 * Add a virtual table to expose all running sstable tasks ( CASSANDRA - 14457 ) 
 diff - - git a / doc / source / tools / cassandra _ stress . rst b / doc / source / tools / cassandra _ stress . rst 
 index 322a981 . . bcac54e 100644 
 - - - a / doc / source / tools / cassandra _ stress . rst 
 + + + b / doc / source / tools / cassandra _ stress . rst 
 @ @ - 220 , 6 + 220 , 24 @ @ Running a user mode test with multiple yaml files : : 
 This will run operations as specified in both the example . yaml and example2 . yaml files . example . yaml and example2 . yaml can reference the same table 
 although care must be taken that the table definition is identical ( data generation specs can be different ) . 
 
 + Lightweight transaction support 
 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + 
 + 
 + cassandra - stress supports lightweight transactions . In this it will first read current data from Cassandra and then uses read value ( s ) 
 + to fulfill lightweight transaction condition ( s ) . 
 + 
 + Lightweight transaction update query : : 
 + 
 + queries : 
 + regularupdate : 
 + cql : update blogposts set author = ? where domain = ? and published _ date = ? 
 + fields : samerow 
 + updatewithlwt : 
 + cql : update blogposts set author = ? where domain = ? and published _ date = ? IF body = ? AND url = ? 
 + fields : samerow 
 + 
 + The full example can be found here : download : ` yaml < . / stress - lwt - example . yaml > ` 
 + 
 Graphing 
 ^ ^ ^ ^ ^ ^ ^ ^ 
 
 diff - - git a / doc / source / tools / stress - lwt - example . yaml b / doc / source / tools / stress - lwt - example . yaml 
 new file mode 100644 
 index 0000000 . . fc5db08 
 - - - / dev / null 
 + + + b / doc / source / tools / stress - lwt - example . yaml 
 @ @ - 0 , 0 + 1 , 70 @ @ 
 + # Keyspace Name 
 + keyspace : stresscql 
 + 
 + # The CQL for creating a keyspace ( optional if it already exists ) 
 + # Would almost always be network topology unless running something locall 
 + keyspace _ definition : | 
 + CREATE KEYSPACE stresscql WITH replication = { ' class ' : ' SimpleStrategy ' , ' replication _ factor ' : 1 } ; 
 + 
 + # Table name 
 + table : blogposts 
 + 
 + # The CQL for creating a table you wish to stress ( optional if it already exists ) 
 + table _ definition : | 
 + CREATE TABLE blogposts ( 
 + domain text , 
 + published _ date timeuuid , 
 + url text , 
 + author text , 
 + title text , 
 + body text , 
 + PRIMARY KEY ( domain , published _ date ) 
 + ) WITH CLUSTERING ORDER BY ( published _ date DESC ) 
 + AND compaction = { ' class ' : ' LeveledCompactionStrategy ' } 
 + AND comment = ' A table to hold blog posts ' 
 + 
 + # # # Column Distribution Specifications # # # 
 + 
 + columnspec : 
 + - name : domain 
 + size : gaussian ( 5 . . 100 ) # domain names are relatively short 
 + population : uniform ( 1 . . 10M ) # 10M possible domains to pick from 
 + 
 + - name : published _ date 
 + cluster : fixed ( 1000 ) # under each domain we will have max 1000 posts 
 + 
 + - name : url 
 + size : uniform ( 30 . . 300 ) 
 + 
 + - name : title # titles shouldn ' t go beyond 200 chars 
 + size : gaussian ( 10 . . 200 ) 
 + 
 + - name : author 
 + size : uniform ( 5 . . 20 ) # author names should be short 
 + 
 + - name : body 
 + size : gaussian ( 100 . . 5000 ) # the body of the blog post can be long 
 + 
 + # # # Batch Ratio Distribution Specifications # # # 
 + 
 + insert : 
 + partitions : fixed ( 1 ) # Our partition key is the domain so only insert one per batch 
 + 
 + select : fixed ( 1 ) / 1000 # We have 1000 posts per domain so 1 / 1000 will allow 1 post per batch 
 + 
 + batchtype : UNLOGGED # Unlogged batches 
 + 
 + 
 + # 
 + # A list of queries you wish to run against the schema 
 + # 
 + queries : 
 + singlepost : 
 + cql : select * from blogposts where domain = ? LIMIT 1 
 + fields : samerow 
 + regularupdate : 
 + cql : update blogposts set author = ? where domain = ? and published _ date = ? 
 + fields : samerow 
 + updatewithlwt : 
 + cql : update blogposts set author = ? where domain = ? and published _ date = ? IF body = ? AND url = ? 
 + fields : samerow 
 diff - - git a / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java b / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java 
 index c9d7fe8 . . aa5c10d 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java 
 + + + b / src / java / org / apache / cassandra / cql3 / conditions / ColumnCondition . java 
 @ @ - 849 , 7 + 849 , 12 @ @ public abstract class ColumnCondition 
 throw invalidRequest ( " Slice conditions ( % s ) are not supported on durations " , operator ) ; 
 } 
 } 
 - 
 + 
 + public Term . Raw getValue ( ) 
 + { 
 + return value ; 
 + } 
 + 
 @ Override 
 public String toString ( ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 index e02fd41 . . 65e1e2d 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / ModificationStatement . java 
 @ @ - 20 , 6 + 20 , 7 @ @ package org . apache . cassandra . cql3 . statements ; 
 import java . nio . ByteBuffer ; 
 import java . util . * ; 
 
 + import com . google . common . collect . ImmutableList ; 
 import com . google . common . collect . Iterables ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 @ @ - 936 , 5 + 937 , 15 @ @ public abstract class ModificationStatement implements CQLStatement 
 { 
 return rawId . prepare ( metadata ) ; 
 } 
 + 
 + public List < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > getConditions ( ) 
 + { 
 + ImmutableList . Builder < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > builder = ImmutableList . builderWithExpectedSize ( conditions . size ( ) ) ; 
 + 
 + for ( Pair < Raw , ColumnCondition . Raw > condition : conditions ) 
 + builder . add ( Pair . create ( condition . left , condition . right ) ) ; 
 + 
 + return builder . build ( ) ; 
 + } 
 } 
 } 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 index 2338873 . . cda9c58 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / StressProfile . java 
 @ @ - 42 , 14 + 42 , 17 @ @ import org . apache . cassandra . cql3 . CQLFragmentParser ; 
 import org . apache . cassandra . cql3 . CqlParser ; 
 import org . apache . cassandra . cql3 . QueryProcessor ; 
 import org . apache . cassandra . cql3 . statements . CreateTableStatement ; 
 + import org . apache . cassandra . cql3 . statements . ModificationStatement ; 
 import org . apache . cassandra . exceptions . RequestValidationException ; 
 import org . apache . cassandra . exceptions . SyntaxException ; 
 import org . apache . cassandra . schema . ColumnMetadata ; 
 import org . apache . cassandra . stress . generate . * ; 
 import org . apache . cassandra . stress . generate . values . * ; 
 - import org . apache . cassandra . stress . operations . userdefined . TokenRangeQuery ; 
 + import org . apache . cassandra . stress . operations . userdefined . CASQuery ; 
 import org . apache . cassandra . stress . operations . userdefined . SchemaInsert ; 
 import org . apache . cassandra . stress . operations . userdefined . SchemaQuery ; 
 + import org . apache . cassandra . stress . operations . userdefined . SchemaStatement ; 
 + import org . apache . cassandra . stress . operations . userdefined . TokenRangeQuery ; 
 import org . apache . cassandra . stress . operations . userdefined . ValidatingSchemaQuery ; 
 import org . apache . cassandra . stress . report . Timer ; 
 import org . apache . cassandra . stress . settings . * ; 
 @ @ - 87 , 7 + 90 , 7 @ @ public class StressProfile implements Serializable 
 transient volatile PreparedStatement insertStatement ; 
 transient volatile List < ValidatingSchemaQuery . Factory > validationFactories ; 
 
 - transient volatile Map < String , SchemaQuery . ArgSelect > argSelects ; 
 + transient volatile Map < String , SchemaStatement . ArgSelect > argSelects ; 
 transient volatile Map < String , PreparedStatement > queryStatements ; 
 
 private static final Pattern lowercaseAlphanumeric = Pattern . compile ( " [ a - z0 - 9 _ ] + " ) ; 
 @ @ - 367 , 13 + 370 , 13 @ @ public class StressProfile implements Serializable 
 JavaDriverClient jclient = settings . getJavaDriverClient ( keyspaceName ) ; 
 
 Map < String , PreparedStatement > stmts = new HashMap < > ( ) ; 
 - Map < String , SchemaQuery . ArgSelect > args = new HashMap < > ( ) ; 
 + Map < String , SchemaStatement . ArgSelect > args = new HashMap < > ( ) ; 
 for ( Map . Entry < String , StressYaml . QueryDef > e : queries . entrySet ( ) ) 
 { 
 stmts . put ( e . getKey ( ) . toLowerCase ( ) , jclient . prepare ( e . getValue ( ) . cql ) ) ; 
 args . put ( e . getKey ( ) . toLowerCase ( ) , e . getValue ( ) . fields = = null 
 - ? SchemaQuery . ArgSelect . MULTIROW 
 - : SchemaQuery . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; 
 + ? SchemaStatement . ArgSelect . MULTIROW 
 + : SchemaStatement . ArgSelect . valueOf ( e . getValue ( ) . fields . toUpperCase ( ) ) ) ; 
 } 
 queryStatements = stmts ; 
 argSelects = args ; 
 @ @ - 381 , 9 + 384 , 42 @ @ public class StressProfile implements Serializable 
 } 
 } 
 
 + if ( dynamicConditionExists ( queryStatements . get ( name ) ) ) 
 + return new CASQuery ( timer , settings , generator , seeds , queryStatements . get ( name ) , settings . command . consistencyLevel , argSelects . get ( name ) , tableName ) ; 
 + 
 return new SchemaQuery ( timer , settings , generator , seeds , queryStatements . get ( name ) , settings . command . consistencyLevel , argSelects . get ( name ) ) ; 
 } 
 
 + static boolean dynamicConditionExists ( PreparedStatement statement ) throws IllegalArgumentException 
 + { 
 + if ( statement = = null ) 
 + return false ; 
 + 
 + if ( ! statement . getQueryString ( ) . toUpperCase ( ) . startsWith ( " UPDATE " ) ) 
 + return false ; 
 + 
 + ModificationStatement . Parsed modificationStatement ; 
 + try 
 + { 
 + modificationStatement = CQLFragmentParser . parseAnyUnhandled ( CqlParser : : updateStatement , 
 + statement . getQueryString ( ) ) ; 
 + } 
 + catch ( RecognitionException e ) 
 + { 
 + throw new IllegalArgumentException ( " could not parse update query : " + statement . getQueryString ( ) , e ) ; 
 + } 
 + 
 + / * 
 + * here we differentiate between static vs dynamic conditions : 
 + * - static condition example : if col1 = NULL 
 + * - dynamic condition example : if col1 = ? 
 + * for static condition we don ' t have to replace value , no extra work involved . 
 + * for dynamic condition we have to read existing db value and then 
 + * use current db values during the update . 
 + * / 
 + return modificationStatement . getConditions ( ) . stream ( ) . anyMatch ( condition - > condition . right . getValue ( ) . getText ( ) . equals ( " ? " ) ) ; 
 + } 
 + 
 public Operation getBulkReadQueries ( String name , Timer timer , StressSettings settings , TokenRangeIterator tokenRangeIterator , boolean isWarmup ) 
 { 
 StressYaml . TokenRangeQueryDef def = tokenRangeQueries . get ( name ) ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java b / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java 
 index 1230065 . . 882b8b4 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / generate / PartitionGenerator . java 
 @ @ - 83 , 6 + 83 , 16 @ @ public class PartitionGenerator 
 return ! ( index < 0 | | index < clusteringComponents . size ( ) ) ; 
 } 
 
 + public List < Generator > getPartitionKey ( ) 
 + { 
 + return Collections . unmodifiableList ( partitionKey ) ; 
 + } 
 + 
 + public List < Generator > getClusteringComponents ( ) 
 + { 
 + return Collections . unmodifiableList ( clusteringComponents ) ; 
 + } 
 + 
 public int indexOf ( String name ) 
 { 
 Integer i = indexMap . get ( name ) ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java b / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java 
 index bad0a94 . . 55c6872 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / PartitionOperation . java 
 @ @ - 19 , 6 + 19 , 7 @ @ 
 package org . apache . cassandra . stress . operations ; 
 
 import java . util . ArrayList ; 
 + import java . util . Collections ; 
 import java . util . List ; 
 
 import org . apache . cassandra . stress . Operation ; 
 @ @ - 75 , 6 + 76 , 16 @ @ public abstract class PartitionOperation extends Operation 
 this . spec = spec ; 
 } 
 
 + public DataSpec getDataSpecification ( ) 
 + { 
 + return spec ; 
 + } 
 + 
 + public List < PartitionIterator > getPartitions ( ) 
 + { 
 + return Collections . unmodifiableList ( partitions ) ; 
 + } 
 + 
 public int ready ( WorkManager permits ) 
 { 
 int partitionCount = ( int ) spec . partitionCount . next ( ) ; 
 @ @ - 86 , 7 + 97 , 7 @ @ public abstract class PartitionOperation extends Operation 
 
 int i = 0 ; 
 boolean success = true ; 
 - for ( ; i < partitionCount & & success ; i + + ) 
 + for ( ; i < partitionCount & & success ; i + + ) 
 { 
 if ( i > = partitionCache . size ( ) ) 
 partitionCache . add ( PartitionIterator . get ( spec . partitionGenerator , spec . seedManager ) ) ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java 
 new file mode 100644 
 index 0000000 . . e7d0fe3 
 - - - / dev / null 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / CASQuery . java 
 @ @ - 0 , 0 + 1 , 227 @ @ 
 + package org . apache . cassandra . stress . operations . userdefined ; 
 + / * 
 + * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * 
 + * / 
 + 
 + import com . datastax . driver . core . BoundStatement ; 
 + import com . datastax . driver . core . ColumnDefinitions ; 
 + import com . datastax . driver . core . DataType ; 
 + import com . datastax . driver . core . LocalDate ; 
 + import com . datastax . driver . core . PreparedStatement ; 
 + import com . datastax . driver . core . ResultSet ; 
 + import org . antlr . runtime . RecognitionException ; 
 + import org . apache . cassandra . cql3 . CQLFragmentParser ; 
 + import org . apache . cassandra . cql3 . CqlParser ; 
 + import org . apache . cassandra . cql3 . conditions . ColumnCondition ; 
 + import org . apache . cassandra . cql3 . statements . ModificationStatement ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . schema . ColumnMetadata ; 
 + import org . apache . cassandra . stress . generate . DistributionFixed ; 
 + import org . apache . cassandra . stress . generate . PartitionGenerator ; 
 + import org . apache . cassandra . stress . generate . Row ; 
 + import org . apache . cassandra . stress . generate . SeedManager ; 
 + import org . apache . cassandra . stress . generate . values . Generator ; 
 + import org . apache . cassandra . stress . report . Timer ; 
 + import org . apache . cassandra . stress . settings . StressSettings ; 
 + import org . apache . cassandra . stress . util . JavaDriverClient ; 
 + import org . apache . cassandra . utils . Pair ; 
 + 
 + import java . io . IOException ; 
 + import java . util . ArrayList ; 
 + import java . util . Arrays ; 
 + import java . util . HashMap ; 
 + import java . util . List ; 
 + import java . util . Map ; 
 + import java . util . stream . Collectors ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import com . google . common . collect . ImmutableMap ; 
 + 
 + public class CASQuery extends SchemaStatement 
 + { 
 + private final ImmutableList < Integer > keysIndex ; 
 + private final ImmutableMap < Integer , Integer > casConditionArgFreqMap ; 
 + private final String readQuery ; 
 + 
 + private PreparedStatement casReadConditionStatement ; 
 + 
 + public CASQuery ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , PreparedStatement statement , ConsistencyLevel cl , ArgSelect argSelect , final String tableName ) 
 + { 
 + super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = SchemaStatement . ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , 
 + statement . getVariables ( ) . asList ( ) . stream ( ) . map ( ColumnDefinitions . Definition : : getName ) . collect ( Collectors . toList ( ) ) , cl ) ; 
 + 
 + if ( argSelect ! = SchemaStatement . ArgSelect . SAMEROW ) 
 + throw new IllegalArgumentException ( " CAS is supported only for type ' samerow ' " ) ; 
 + 
 + ModificationStatement . Parsed modificationStatement ; 
 + try 
 + { 
 + modificationStatement = CQLFragmentParser . parseAnyUnhandled ( CqlParser : : updateStatement , 
 + statement . getQueryString ( ) ) ; 
 + } 
 + catch ( RecognitionException e ) 
 + { 
 + throw new IllegalArgumentException ( " could not parse update query : " + statement . getQueryString ( ) , e ) ; 
 + } 
 + 
 + final List < Pair < ColumnMetadata . Raw , ColumnCondition . Raw > > casConditionList = modificationStatement . getConditions ( ) ; 
 + List < Integer > casConditionIndex = new ArrayList < > ( ) ; 
 + 
 + boolean first = true ; 
 + StringBuilder casReadConditionQuery = new StringBuilder ( ) ; 
 + casReadConditionQuery . append ( " SELECT " ) ; 
 + for ( final Pair < ColumnMetadata . Raw , ColumnCondition . Raw > condition : casConditionList ) 
 + { 
 + if ( ! condition . right . getValue ( ) . getText ( ) . equals ( " ? " ) ) 
 + { 
 + / / condition uses static value , ignore it 
 + continue ; 
 + } 
 + if ( ! first ) 
 + { 
 + casReadConditionQuery . append ( " , " ) ; 
 + } 
 + casReadConditionQuery . append ( condition . left . rawText ( ) ) ; 
 + casConditionIndex . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( condition . left . rawText ( ) ) ) ; 
 + first = false ; 
 + } 
 + casReadConditionQuery . append ( " FROM " ) . append ( tableName ) . append ( " WHERE " ) ; 
 + 
 + first = true ; 
 + ImmutableList . Builder < Integer > keysBuilder = ImmutableList . builder ( ) ; 
 + for ( final Generator key : getDataSpecification ( ) . partitionGenerator . getPartitionKey ( ) ) 
 + { 
 + if ( ! first ) 
 + { 
 + casReadConditionQuery . append ( " AND " ) ; 
 + } 
 + casReadConditionQuery . append ( key . name ) . append ( " = ? " ) ; 
 + keysBuilder . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( key . name ) ) ; 
 + first = false ; 
 + } 
 + for ( final Generator clusteringKey : getDataSpecification ( ) . partitionGenerator . getClusteringComponents ( ) ) 
 + { 
 + casReadConditionQuery . append ( " AND " ) . append ( clusteringKey . name ) . append ( " = ? " ) ; 
 + keysBuilder . add ( getDataSpecification ( ) . partitionGenerator . indexOf ( clusteringKey . name ) ) ; 
 + } 
 + keysIndex = keysBuilder . build ( ) ; 
 + readQuery = casReadConditionQuery . toString ( ) ; 
 + 
 + ImmutableMap . Builder < Integer , Integer > builder = ImmutableMap . builderWithExpectedSize ( casConditionIndex . size ( ) ) ; 
 + for ( final Integer oneConditionIndex : casConditionIndex ) 
 + { 
 + builder . put ( oneConditionIndex , Math . toIntExact ( Arrays . stream ( argumentIndex ) . filter ( ( x ) - > x = = oneConditionIndex ) . count ( ) ) ) ; 
 + } 
 + casConditionArgFreqMap = builder . build ( ) ; 
 + } 
 + 
 + private class JavaDriverRun extends Runner 
 + { 
 + final JavaDriverClient client ; 
 + 
 + private JavaDriverRun ( JavaDriverClient client ) 
 + { 
 + this . client = client ; 
 + casReadConditionStatement = client . prepare ( readQuery ) ; 
 + } 
 + 
 + public boolean run ( ) 
 + { 
 + ResultSet rs = client . getSession ( ) . execute ( bind ( client ) ) ; 
 + rowCount = rs . all ( ) . size ( ) ; 
 + partitionCount = Math . min ( 1 , rowCount ) ; 
 + return true ; 
 + } 
 + } 
 + 
 + @ Override 
 + public void run ( JavaDriverClient client ) throws IOException 
 + { 
 + timeWithRetry ( new JavaDriverRun ( client ) ) ; 
 + } 
 + 
 + private BoundStatement bind ( JavaDriverClient client ) 
 + { 
 + final Object keys [ ] = new Object [ keysIndex . size ( ) ] ; 
 + final Row row = getPartitions ( ) . get ( 0 ) . next ( ) ; 
 + 
 + for ( int i = 0 ; i < keysIndex . size ( ) ; i + + ) 
 + { 
 + keys [ i ] = row . get ( keysIndex . get ( i ) ) ; 
 + } 
 + 
 + / / get current db values for all the coluns which are part of dynamic conditions 
 + ResultSet rs = client . getSession ( ) . execute ( casReadConditionStatement . bind ( keys ) ) ; 
 + final Object casDbValues [ ] = new Object [ casConditionArgFreqMap . size ( ) ] ; 
 + 
 + final com . datastax . driver . core . Row casDbValue = rs . one ( ) ; 
 + if ( casDbValue ! = null ) 
 + { 
 + for ( int i = 0 ; i < casConditionArgFreqMap . size ( ) ; i + + ) 
 + { 
 + casDbValues [ i ] = casDbValue . getObject ( i ) ; 
 + } 
 + } 
 + / / now bind db values for dynamic conditions in actual CAS update operation 
 + return prepare ( row , casDbValues ) ; 
 + } 
 + 
 + private BoundStatement prepare ( final Row row , final Object [ ] casDbValues ) 
 + { 
 + final Map < Integer , Integer > localMapping = new HashMap < > ( casConditionArgFreqMap ) ; 
 + int conditionIndexTracker = 0 ; 
 + for ( int i = 0 ; i < argumentIndex . length ; i + + ) 
 + { 
 + boolean replace = false ; 
 + Integer count = localMapping . get ( argumentIndex [ i ] ) ; 
 + if ( count ! = null ) 
 + { 
 + count - - ; 
 + localMapping . put ( argumentIndex [ i ] , count ) ; 
 + if ( count = = 0 ) 
 + { 
 + replace = true ; 
 + } 
 + } 
 + 
 + if ( replace ) 
 + { 
 + bindBuffer [ i ] = casDbValues [ conditionIndexTracker + + ] ; 
 + } 
 + else 
 + { 
 + Object value = row . get ( argumentIndex [ i ] ) ; 
 + if ( definitions . getType ( i ) . getName ( ) = = DataType . date ( ) . getName ( ) ) 
 + { 
 + / / the java driver only accepts com . datastax . driver . core . LocalDate for CQL type " DATE " 
 + value = LocalDate . fromDaysSinceEpoch ( ( Integer ) value ) ; 
 + } 
 + 
 + bindBuffer [ i ] = value ; 
 + } 
 + 
 + if ( bindBuffer [ i ] = = null & & ! getDataSpecification ( ) . partitionGenerator . permitNulls ( argumentIndex [ i ] ) ) 
 + { 
 + throw new IllegalStateException ( ) ; 
 + } 
 + } 
 + return statement . bind ( bindBuffer ) ; 
 + } 
 + } 
 \ No newline at end of file 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java 
 index f0b332c . . cba9ce4 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaQuery . java 
 @ @ - 22 , 9 + 22 , 6 @ @ package org . apache . cassandra . stress . operations . userdefined ; 
 
 
 import java . io . IOException ; 
 - import java . nio . ByteBuffer ; 
 - import java . util . ArrayList ; 
 - import java . util . List ; 
 import java . util . Random ; 
 import java . util . stream . Collectors ; 
 
 @ @ - 39 , 19 + 36 , 13 @ @ import org . apache . cassandra . stress . util . JavaDriverClient ; 
 
 public class SchemaQuery extends SchemaStatement 
 { 
 - public static enum ArgSelect 
 - { 
 - MULTIROW , SAMEROW ; 
 - / / TODO : FIRSTROW , LASTROW 
 - } 
 - 
 final ArgSelect argSelect ; 
 final Object [ ] [ ] randomBuffer ; 
 final Random random = new Random ( ) ; 
 
 public SchemaQuery ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , PreparedStatement statement , ConsistencyLevel cl , ArgSelect argSelect ) 
 { 
 - super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , 
 + super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( 1 ) , settings . insert . rowPopulationRatio . get ( ) , argSelect = = SchemaStatement . ArgSelect . MULTIROW ? statement . getVariables ( ) . size ( ) : 1 ) , statement , 
 statement . getVariables ( ) . asList ( ) . stream ( ) . map ( d - > d . getName ( ) ) . collect ( Collectors . toList ( ) ) , cl ) ; 
 this . argSelect = argSelect ; 
 randomBuffer = new Object [ argumentIndex . length ] [ argumentIndex . length ] ; 
 diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java 
 index 6bd3fd5 . . 334e6c5 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / userdefined / SchemaStatement . java 
 @ @ - 38 , 6 + 38 , 12 @ @ import org . apache . cassandra . stress . util . JavaDriverClient ; 
 
 public abstract class SchemaStatement extends PartitionOperation 
 { 
 + public enum ArgSelect 
 + { 
 + MULTIROW , SAMEROW ; 
 + / / TODO : FIRSTROW , LASTROW 
 + } 
 + 
 final PreparedStatement statement ; 
 final ConsistencyLevel cl ; 
 final int [ ] argumentIndex ;

NEAREST DIFF:
diff - - git a / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java b / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java 
 index 264f4b1 . . 57c7419 100644 
 - - - a / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java 
 + + + b / tools / stress / src / org / apache / cassandra / stress / operations / CqlInserter . java 
 @ @ - 30 , 6 + 30 , 7 @ @ import org . apache . cassandra . stress . Session ; 
 import org . apache . cassandra . stress . util . Operation ; 
 import org . apache . cassandra . thrift . Cassandra ; 
 import org . apache . cassandra . thrift . Compression ; 
 + import org . apache . cassandra . utils . UUIDGen ; 
 
 public class CqlInserter extends Operation 
 { 
 @ @ - 55 , 8 + 56 , 15 @ @ public class CqlInserter extends Operation 
 { 
 if ( i > 0 ) 
 query . append ( ' , ' ) ; 
 - query . append ( ' C ' ) . append ( i ) . append ( ' = ' ) ; 
 - query . append ( getQuotedCqlBlob ( values . get ( i % values . size ( ) ) . array ( ) ) ) ; 
 + 
 + / / Column name 
 + if ( session . timeUUIDComparator ) 
 + query . append ( UUIDGen . makeType1UUIDFromHost ( Session . getLocalAddress ( ) ) . toString ( ) ) ; 
 + else 
 + query . append ( ' C ' ) . append ( i ) ; 
 + 
 + / / Column value 
 + query . append ( ' = ' ) . append ( getQuotedCqlBlob ( values . get ( i % values . size ( ) ) . array ( ) ) ) ; 
 } 
 
 String key = String . format ( " % 0 " + session . getTotalKeysLength ( ) + " d " , index ) ;
