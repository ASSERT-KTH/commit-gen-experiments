BLEU SCORE: 0.027611988917697356

TEST MSG: Add warning on collection limitations in CQL doc
GENERATED MSG: add toString

TEST DIFF (one line): diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile <nl> index 507ad13 . . b02d24a 100644 <nl> - - - a / doc / cql3 / CQL . textile <nl> + + + b / doc / cql3 / CQL . textile <nl> @ @ - 807 , 6 + 807 , 16 @ @ The use of the counter type is limited in the following way : <nl> <nl> h3 ( # collections ) . Working with collections <nl> <nl> + h4 . Noteworthy characteristics <nl> + <nl> + Collections are meant for storing / denormalizing relatively small amount of data . They work well for things like " the phone numbers of a given user " , " labels applied to an email " , etc . But when items are expected to grow unbounded ( " all the messages sent by a given user " , " events registered by a sensor " , . . . ) , then collections are not appropriate anymore and a specific table ( with clustering columns ) should be used . Concretely , collections have the following limitations : <nl> + * Collections are always read in their entirety ( and reading one is not paged internally ) . <nl> + * Collections cannot have more than 65535 elements . More precisely , while it may be possible to insert more than 65535 elements , it is not possible to read more than the 65535 first elements ( see " CASSANDRA - 5428 " : https : / / issues . apache . org / jira / browse / CASSANDRA - 5428 for details ) . <nl> + * While insertion operations on sets and maps never incur a read - before - write internally , some operations on lists do ( see the section on lists below for details ) . It is thus advised to prefer sets over lists when possible . <nl> + <nl> + Please note that while some of those limitations may or may not be loosen in the future , the general rule that collections are for denormalizing small amount of data is meant to stay . <nl> + <nl> + <nl> h4 ( # map ) . Maps <nl> <nl> A @ map @ is a " typed " : # types set of key - value pairs , where keys are unique . Furthermore , note that the map are internally sorted by their keys and will thus always be returned in that order . To create a column of type @ map @ , use the @ map @ keyword suffixed with comma - separated key and value types , enclosed in angle brackets . For example :
NEAREST DIFF (one line): diff - - git a / drivers / py / cql / connection . py b / drivers / py / cql / connection . py <nl> index 2f7a69c . . d9bf3ab 100644 <nl> - - - a / drivers / py / cql / connection . py <nl> + + + b / drivers / py / cql / connection . py <nl> @ @ - 47 , 7 + 47 , 7 @ @ class Connection ( object ) : <nl> . . . print " % s is % s years of age " % ( r . key , column . age ) <nl> " " " <nl> _ keyspace _ re = re . compile ( " USE ( \ w + ) ; ? " , re . I | re . M ) <nl> - _ cfamily _ re = re . compile ( " SELECT \ s + . + \ s + FROM \ s + ( \ w + ) " , re . I | re . M ) <nl> + _ cfamily _ re = re . compile ( " \ s + SELECT \ s + . + \ s + FROM \ s + ( \ w + ) " , re . I | re . M ) <nl> <nl> def _ _ init _ _ ( self , host , port = 9160 , keyspace = None , username = None , <nl> password = None , decoder = None ) :

TEST DIFF:
diff - - git a / doc / cql3 / CQL . textile b / doc / cql3 / CQL . textile 
 index 507ad13 . . b02d24a 100644 
 - - - a / doc / cql3 / CQL . textile 
 + + + b / doc / cql3 / CQL . textile 
 @ @ - 807 , 6 + 807 , 16 @ @ The use of the counter type is limited in the following way : 
 
 h3 ( # collections ) . Working with collections 
 
 + h4 . Noteworthy characteristics 
 + 
 + Collections are meant for storing / denormalizing relatively small amount of data . They work well for things like " the phone numbers of a given user " , " labels applied to an email " , etc . But when items are expected to grow unbounded ( " all the messages sent by a given user " , " events registered by a sensor " , . . . ) , then collections are not appropriate anymore and a specific table ( with clustering columns ) should be used . Concretely , collections have the following limitations : 
 + * Collections are always read in their entirety ( and reading one is not paged internally ) . 
 + * Collections cannot have more than 65535 elements . More precisely , while it may be possible to insert more than 65535 elements , it is not possible to read more than the 65535 first elements ( see " CASSANDRA - 5428 " : https : / / issues . apache . org / jira / browse / CASSANDRA - 5428 for details ) . 
 + * While insertion operations on sets and maps never incur a read - before - write internally , some operations on lists do ( see the section on lists below for details ) . It is thus advised to prefer sets over lists when possible . 
 + 
 + Please note that while some of those limitations may or may not be loosen in the future , the general rule that collections are for denormalizing small amount of data is meant to stay . 
 + 
 + 
 h4 ( # map ) . Maps 
 
 A @ map @ is a " typed " : # types set of key - value pairs , where keys are unique . Furthermore , note that the map are internally sorted by their keys and will thus always be returned in that order . To create a column of type @ map @ , use the @ map @ keyword suffixed with comma - separated key and value types , enclosed in angle brackets . For example :

NEAREST DIFF:
diff - - git a / drivers / py / cql / connection . py b / drivers / py / cql / connection . py 
 index 2f7a69c . . d9bf3ab 100644 
 - - - a / drivers / py / cql / connection . py 
 + + + b / drivers / py / cql / connection . py 
 @ @ - 47 , 7 + 47 , 7 @ @ class Connection ( object ) : 
 . . . print " % s is % s years of age " % ( r . key , column . age ) 
 " " " 
 _ keyspace _ re = re . compile ( " USE ( \ w + ) ; ? " , re . I | re . M ) 
 - _ cfamily _ re = re . compile ( " SELECT \ s + . + \ s + FROM \ s + ( \ w + ) " , re . I | re . M ) 
 + _ cfamily _ re = re . compile ( " \ s + SELECT \ s + . + \ s + FROM \ s + ( \ w + ) " , re . I | re . M ) 
 
 def _ _ init _ _ ( self , host , port = 9160 , keyspace = None , username = None , 
 password = None , decoder = None ) :
