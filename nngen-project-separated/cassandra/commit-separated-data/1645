BLEU SCORE: 0.024893534183931972

TEST MSG: Fix LongLeveledCompactionStrategyTest
GENERATED MSG: move long LCS test to long - test

TEST DIFF (one line): diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> index b071001 . . 0eb769f 100644 <nl> - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java <nl> @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . io . sstable . SSTableReader ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> { <nl> @ Test <nl> @ @ - 42 , 7 + 44 , 8 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; <nl> store . disableAutoCompaction ( ) ; <nl> <nl> - LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) store . getCompactionStrategy ( ) ; <nl> + WrappingCompactionStrategy strategy = ( ( WrappingCompactionStrategy ) store . getCompactionStrategy ( ) ) ; <nl> + LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) strategy . getWrappedStrategies ( ) . get ( 1 ) ; <nl> <nl> ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files <nl> <nl> @ @ - 63 , 26 + 66 , 30 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> store . forceBlockingFlush ( ) ; <nl> } <nl> <nl> + <nl> / / Execute LCS in parallel <nl> ExecutorService executor = new ThreadPoolExecutor ( 4 , 4 , <nl> Long . MAX _ VALUE , TimeUnit . SECONDS , <nl> new LinkedBlockingDeque < Runnable > ( ) ) ; <nl> + <nl> List < Runnable > tasks = new ArrayList < Runnable > ( ) ; <nl> while ( true ) <nl> { <nl> while ( true ) <nl> { <nl> - final AbstractCompactionTask t = lcs . getMaximalTask ( Integer . MIN _ VALUE ) . iterator ( ) . next ( ) ; <nl> - if ( t = = null ) <nl> + final AbstractCompactionTask nextTask = lcs . getNextBackgroundTask ( Integer . MIN _ VALUE ) ; <nl> + if ( nextTask = = null ) <nl> break ; <nl> + <nl> tasks . add ( new Runnable ( ) <nl> { <nl> public void run ( ) <nl> { <nl> - t . execute ( null ) ; <nl> + nextTask . execute ( null ) ; <nl> } <nl> } ) ; <nl> } <nl> + <nl> if ( tasks . isEmpty ( ) ) <nl> break ; <nl> <nl> @ @ - 94 , 27 + 101 , 28 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader <nl> tasks . clear ( ) ; <nl> } <nl> <nl> + <nl> / / Assert all SSTables are lined up correctly . <nl> LeveledManifest manifest = lcs . manifest ; <nl> int levels = manifest . getLevelCount ( ) ; <nl> for ( int level = 0 ; level < levels ; level + + ) <nl> { <nl> List < SSTableReader > sstables = manifest . getLevel ( level ) ; <nl> + <nl> / / score check <nl> assert ( double ) SSTableReader . getTotalBytes ( sstables ) / manifest . maxBytesForLevel ( level ) < 1 . 00 ; <nl> - / / overlap check for levels greater than 0 <nl> - if ( level > 0 ) <nl> + <nl> + for ( SSTableReader sstable : sstables ) <nl> { <nl> - for ( SSTableReader sstable : sstables ) <nl> - { <nl> - Set < SSTableReader > overlaps = LeveledManifest . overlapping ( sstable , sstables ) ; <nl> - assert overlaps . size ( ) = = 1 & & overlaps . contains ( sstable ) ; <nl> - } <nl> + / / level check <nl> + assert level = = sstable . getSSTableLevel ( ) ; <nl> + <nl> + if ( level > 0 ) <nl> + { / / overlap check for levels greater than 0 <nl> + Set < SSTableReader > overlaps = LeveledManifest . overlapping ( sstable , sstables ) ; <nl> + assert overlaps . size ( ) = = 1 & & overlaps . contains ( sstable ) ; <nl> + } <nl> } <nl> } <nl> - for ( SSTableReader sstable : store . getSSTables ( ) ) <nl> - { <nl> - assert sstable . getSSTableLevel ( ) = = sstable . getSSTableLevel ( ) ; <nl> - } <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index ba146e5 . . d004f8f 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 100 , 6 + 100 , 7 @ @ <nl> 1 . 1 . 6 <nl> * fix commitlog replay for nanotime - infected sstables ( CASSANDRA - 4782 ) <nl> * preflight check ttl for maximum of 20 years ( CASSANDRA - 4771 ) <nl> + * ( Pig ) fix widerow input with single column rows ( CASSANDRA - 4789 ) <nl> * Fix HH to compact with correct gcBefore , which avoids wiping out <nl> undelivered hints ( CASSANDRA - 4772 ) <nl> * LCS will merge up to 32 L0 sstables as intended ( CASSANDRA - 4778 ) <nl> diff - - git a / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java b / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> index 687af5f . . 1ea5382 100644 <nl> - - - a / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> + + + b / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java <nl> @ @ - 111 , 10 + 111 , 10 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo <nl> private boolean widerows ; <nl> private boolean usePartitionFilter ; <nl> / / wide row hacks <nl> + private ByteBuffer lastKey ; <nl> private Map < ByteBuffer , IColumn > lastRow ; <nl> private boolean hasNext = true ; <nl> <nl> - <nl> public CassandraStorage ( ) <nl> { <nl> this ( 1024 ) ; <nl> @ @ - 158 , 6 + 158 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo <nl> { <nl> bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; <nl> } <nl> + lastKey = null ; <nl> lastRow = null ; <nl> tuple . append ( bag ) ; <nl> return tuple ; <nl> @ @ - 176 , 6 + 177 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo <nl> if ( key ! = null & & ! ( ( ByteBuffer ) reader . getCurrentKey ( ) ) . equals ( key ) ) / / key changed <nl> { <nl> / / read too much , hold on to it for next time <nl> + lastKey = ( ByteBuffer ) reader . getCurrentKey ( ) ; <nl> lastRow = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; <nl> / / but return what we have so far <nl> tuple . append ( bag ) ; <nl> @ @ - 184 , 6 + 186 , 18 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo <nl> if ( key = = null ) / / only set the key on the first iteration <nl> { <nl> key = ( ByteBuffer ) reader . getCurrentKey ( ) ; <nl> + if ( lastKey ! = null & & ! ( key . equals ( lastKey ) ) ) / / last key only had one value <nl> + { <nl> + tuple . append ( new DataByteArray ( lastKey . array ( ) , lastKey . position ( ) + lastKey . arrayOffset ( ) , lastKey . limit ( ) + lastKey . arrayOffset ( ) ) ) ; <nl> + for ( Map . Entry < ByteBuffer , IColumn > entry : lastRow . entrySet ( ) ) <nl> + { <nl> + bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; <nl> + } <nl> + tuple . append ( bag ) ; <nl> + lastKey = key ; <nl> + lastRow = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; <nl> + return tuple ; <nl> + } <nl> tuple . append ( new DataByteArray ( key . array ( ) , key . position ( ) + key . arrayOffset ( ) , key . limit ( ) + key . arrayOffset ( ) ) ) ; <nl> } <nl> SortedMap < ByteBuffer , IColumn > row = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; <nl> @ @ - 193 , 6 + 207 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo <nl> { <nl> bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; <nl> } <nl> + lastKey = null ; <nl> lastRow = null ; <nl> } <nl> for ( Map . Entry < ByteBuffer , IColumn > entry : row . entrySet ( ) )

TEST DIFF:
diff - - git a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 index b071001 . . 0eb769f 100644 
 - - - a / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 + + + b / test / long / org / apache / cassandra / db / compaction / LongLeveledCompactionStrategyTest . java 
 @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . io . sstable . SSTableReader ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 
 + import static org . junit . Assert . assertTrue ; 
 + 
 public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 { 
 @ Test 
 @ @ - 42 , 7 + 44 , 8 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; 
 store . disableAutoCompaction ( ) ; 
 
 - LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) store . getCompactionStrategy ( ) ; 
 + WrappingCompactionStrategy strategy = ( ( WrappingCompactionStrategy ) store . getCompactionStrategy ( ) ) ; 
 + LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) strategy . getWrappedStrategies ( ) . get ( 1 ) ; 
 
 ByteBuffer value = ByteBuffer . wrap ( new byte [ 100 * 1024 ] ) ; / / 100 KB value , make it easy to have multiple files 
 
 @ @ - 63 , 26 + 66 , 30 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 store . forceBlockingFlush ( ) ; 
 } 
 
 + 
 / / Execute LCS in parallel 
 ExecutorService executor = new ThreadPoolExecutor ( 4 , 4 , 
 Long . MAX _ VALUE , TimeUnit . SECONDS , 
 new LinkedBlockingDeque < Runnable > ( ) ) ; 
 + 
 List < Runnable > tasks = new ArrayList < Runnable > ( ) ; 
 while ( true ) 
 { 
 while ( true ) 
 { 
 - final AbstractCompactionTask t = lcs . getMaximalTask ( Integer . MIN _ VALUE ) . iterator ( ) . next ( ) ; 
 - if ( t = = null ) 
 + final AbstractCompactionTask nextTask = lcs . getNextBackgroundTask ( Integer . MIN _ VALUE ) ; 
 + if ( nextTask = = null ) 
 break ; 
 + 
 tasks . add ( new Runnable ( ) 
 { 
 public void run ( ) 
 { 
 - t . execute ( null ) ; 
 + nextTask . execute ( null ) ; 
 } 
 } ) ; 
 } 
 + 
 if ( tasks . isEmpty ( ) ) 
 break ; 
 
 @ @ - 94 , 27 + 101 , 28 @ @ public class LongLeveledCompactionStrategyTest extends SchemaLoader 
 tasks . clear ( ) ; 
 } 
 
 + 
 / / Assert all SSTables are lined up correctly . 
 LeveledManifest manifest = lcs . manifest ; 
 int levels = manifest . getLevelCount ( ) ; 
 for ( int level = 0 ; level < levels ; level + + ) 
 { 
 List < SSTableReader > sstables = manifest . getLevel ( level ) ; 
 + 
 / / score check 
 assert ( double ) SSTableReader . getTotalBytes ( sstables ) / manifest . maxBytesForLevel ( level ) < 1 . 00 ; 
 - / / overlap check for levels greater than 0 
 - if ( level > 0 ) 
 + 
 + for ( SSTableReader sstable : sstables ) 
 { 
 - for ( SSTableReader sstable : sstables ) 
 - { 
 - Set < SSTableReader > overlaps = LeveledManifest . overlapping ( sstable , sstables ) ; 
 - assert overlaps . size ( ) = = 1 & & overlaps . contains ( sstable ) ; 
 - } 
 + / / level check 
 + assert level = = sstable . getSSTableLevel ( ) ; 
 + 
 + if ( level > 0 ) 
 + { / / overlap check for levels greater than 0 
 + Set < SSTableReader > overlaps = LeveledManifest . overlapping ( sstable , sstables ) ; 
 + assert overlaps . size ( ) = = 1 & & overlaps . contains ( sstable ) ; 
 + } 
 } 
 } 
 - for ( SSTableReader sstable : store . getSSTables ( ) ) 
 - { 
 - assert sstable . getSSTableLevel ( ) = = sstable . getSSTableLevel ( ) ; 
 - } 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index ba146e5 . . d004f8f 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 100 , 6 + 100 , 7 @ @ 
 1 . 1 . 6 
 * fix commitlog replay for nanotime - infected sstables ( CASSANDRA - 4782 ) 
 * preflight check ttl for maximum of 20 years ( CASSANDRA - 4771 ) 
 + * ( Pig ) fix widerow input with single column rows ( CASSANDRA - 4789 ) 
 * Fix HH to compact with correct gcBefore , which avoids wiping out 
 undelivered hints ( CASSANDRA - 4772 ) 
 * LCS will merge up to 32 L0 sstables as intended ( CASSANDRA - 4778 ) 
 diff - - git a / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java b / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 index 687af5f . . 1ea5382 100644 
 - - - a / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 + + + b / src / java / org / apache / cassandra / hadoop / pig / CassandraStorage . java 
 @ @ - 111 , 10 + 111 , 10 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo 
 private boolean widerows ; 
 private boolean usePartitionFilter ; 
 / / wide row hacks 
 + private ByteBuffer lastKey ; 
 private Map < ByteBuffer , IColumn > lastRow ; 
 private boolean hasNext = true ; 
 
 - 
 public CassandraStorage ( ) 
 { 
 this ( 1024 ) ; 
 @ @ - 158 , 6 + 158 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo 
 { 
 bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; 
 } 
 + lastKey = null ; 
 lastRow = null ; 
 tuple . append ( bag ) ; 
 return tuple ; 
 @ @ - 176 , 6 + 177 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo 
 if ( key ! = null & & ! ( ( ByteBuffer ) reader . getCurrentKey ( ) ) . equals ( key ) ) / / key changed 
 { 
 / / read too much , hold on to it for next time 
 + lastKey = ( ByteBuffer ) reader . getCurrentKey ( ) ; 
 lastRow = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; 
 / / but return what we have so far 
 tuple . append ( bag ) ; 
 @ @ - 184 , 6 + 186 , 18 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo 
 if ( key = = null ) / / only set the key on the first iteration 
 { 
 key = ( ByteBuffer ) reader . getCurrentKey ( ) ; 
 + if ( lastKey ! = null & & ! ( key . equals ( lastKey ) ) ) / / last key only had one value 
 + { 
 + tuple . append ( new DataByteArray ( lastKey . array ( ) , lastKey . position ( ) + lastKey . arrayOffset ( ) , lastKey . limit ( ) + lastKey . arrayOffset ( ) ) ) ; 
 + for ( Map . Entry < ByteBuffer , IColumn > entry : lastRow . entrySet ( ) ) 
 + { 
 + bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; 
 + } 
 + tuple . append ( bag ) ; 
 + lastKey = key ; 
 + lastRow = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; 
 + return tuple ; 
 + } 
 tuple . append ( new DataByteArray ( key . array ( ) , key . position ( ) + key . arrayOffset ( ) , key . limit ( ) + key . arrayOffset ( ) ) ) ; 
 } 
 SortedMap < ByteBuffer , IColumn > row = ( SortedMap < ByteBuffer , IColumn > ) reader . getCurrentValue ( ) ; 
 @ @ - 193 , 6 + 207 , 7 @ @ public class CassandraStorage extends LoadFunc implements StoreFuncInterface , Lo 
 { 
 bag . add ( columnToTuple ( entry . getValue ( ) , cfDef , parseType ( cfDef . getComparator _ type ( ) ) ) ) ; 
 } 
 + lastKey = null ; 
 lastRow = null ; 
 } 
 for ( Map . Entry < ByteBuffer , IColumn > entry : row . entrySet ( ) )
