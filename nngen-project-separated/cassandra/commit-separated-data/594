BLEU SCORE: 0.0254507234234606

TEST MSG: Fix RecoveryManagerTruncateTest , includes a backport of CASSANDRA - 11743
GENERATED MSG: fix commitlog recovery deleting the newly - created segment as well as the old ones

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e922635 . . 792d6f8 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 1 . 17 <nl> + * Fix RecoveryManagerTruncateTest ( CASSANDRA - 12802 ) <nl> * Don ' t skip sstables based on maxLocalDeletionTime ( CASSANDRA - 12765 ) <nl> <nl> <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 502e704 . . 2484e9b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 35 , 6 + 35 , 7 @ @ import org . apache . cassandra . config . Config ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . io . FSWriteError ; <nl> + import org . apache . cassandra . io . sstable . SSTableDeletingTask ; <nl> import org . apache . cassandra . io . util . DataOutputByteBuffer ; <nl> import org . apache . cassandra . metrics . CommitLogMetrics ; <nl> import org . apache . cassandra . net . MessagingService ; <nl> @ @ - 101 , 7 + 102 , 7 @ @ public class CommitLog implements CommitLogMBean <nl> / / we used to try to avoid instantiating commitlog ( thus creating an empty segment ready for writes ) <nl> / / until after recover was finished . this turns out to be fragile ; it is less error - prone to go <nl> / / ahead and allow writes before recover ( ) , and just skip active segments when we do . <nl> - return CommitLogDescriptor . isValid ( name ) & & ! instance . allocator . manages ( name ) ; <nl> + return CommitLogDescriptor . isValid ( name ) & & CommitLogSegment . shouldReplay ( name ) ; <nl> } <nl> } ; <nl> <nl> @ @ - 367 , 11 + 368 , 21 @ @ public class CommitLog implements CommitLogMBean <nl> <nl> / * * <nl> * FOR TESTING PURPOSES . See CommitLogAllocator . <nl> + * <nl> + * There is a race at the moment , even if this method <nl> + * is synchronized we can still create an allocation <nl> + * on a segment that will be closed in this method , <nl> + * therefore causing { @ link Allocation # awaitDiskSync ( ) } to hang <nl> + * forever . This typically happens because of the mutations created <nl> + * by { @ link org . apache . cassandra . io . sstable . SSTableReader . GlobalTidy } , <nl> + * that ' s why we wait for all deletions to complete firtst . <nl> * / <nl> - public void resetUnsafe ( ) <nl> + public synchronized void resetUnsafe ( ) <nl> { <nl> + SSTableDeletingTask . waitForDeletions ( ) ; <nl> sync ( true ) ; <nl> allocator . resetUnsafe ( ) ; <nl> + CommitLogSegment . resetReplayLimit ( ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> index 2ea8701 . . 1093f87 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java <nl> @ @ - 61 , 6 + 61 , 7 @ @ public class CommitLogSegment <nl> <nl> private final static long idBase ; <nl> private final static AtomicInteger nextId = new AtomicInteger ( 1 ) ; <nl> + private static long replayLimitId ; <nl> static <nl> { <nl> long maxId = Long . MIN _ VALUE ; <nl> @ @ - 69 , 7 + 70 , 7 @ @ public class CommitLogSegment <nl> if ( CommitLogDescriptor . isValid ( file . getName ( ) ) ) <nl> maxId = Math . max ( CommitLogDescriptor . fromFileName ( file . getName ( ) ) . id , maxId ) ; <nl> } <nl> - idBase = Math . max ( System . currentTimeMillis ( ) , maxId + 1 ) ; <nl> + replayLimitId = idBase = Math . max ( System . currentTimeMillis ( ) , maxId + 1 ) ; <nl> } <nl> <nl> / / The commit log entry overhead in bytes ( int : length + int : head checksum + int : tail checksum ) <nl> @ @ - 203 , 6 + 204 , 19 @ @ public class CommitLogSegment <nl> } <nl> } <nl> <nl> + static boolean shouldReplay ( String name ) <nl> + { <nl> + return CommitLogDescriptor . fromFileName ( name ) . id < replayLimitId ; <nl> + } <nl> + <nl> + / * * <nl> + * FOR TESTING PURPOSES . <nl> + * / <nl> + static void resetReplayLimit ( ) <nl> + { <nl> + replayLimitId = getNextId ( ) ; <nl> + } <nl> + <nl> / / allocate bytes in the segment , or return - 1 if not enough space <nl> private int allocate ( int size ) <nl> {
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 1cb58ed . . 7142055 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 54 , 6 + 54 , 8 @ @ dev <nl> * cli - - file option ( CASSANDRA - 1616 ) <nl> * reduce automatically chosen memtable sizes by 50 % ( CASSANDRA - 1641 ) <nl> * move endpoint cache from snitch to strategy ( CASSANDRA - 1643 ) <nl> + * fix commitlog recovery deleting the newly - created segment as well as <nl> + the old ones ( CASSANDRA - 1644 ) <nl> <nl> <nl> 0 . 7 - beta2 <nl> @ @ - 95 , 8 + 97 , 6 @ @ dev <nl> * Add CfDef . default _ validation _ class ( CASSANDRA - 891 ) <nl> * fix EstimatedHistogram . max ( CASSANDRA - 1413 ) <nl> * quorum read optimization ( CASSANDRA - 1622 ) <nl> - <nl> - <nl> * handle zero - length ( or missing ) rows during HH paging ( CASSANDRA - 1432 ) <nl> * include secondary indexes during schema migrations ( CASSANDRA - 1406 ) <nl> * fix commitlog header race during schema change ( CASSANDRA - 1435 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 895331a . . 9b045c2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 575 , 7 + 575 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> <nl> assert memtable = = oldMemtable ; <nl> memtable . freeze ( ) ; <nl> - final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance ( ) . getContext ( ) : null ; <nl> + final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance . getContext ( ) : null ; <nl> logger . info ( " switching in a fresh Memtable for " + columnFamily + " at " + ctx ) ; <nl> <nl> / / submit the memtable for any indexed sub - cfses , and our own . <nl> @ @ - 605 , 7 + 605 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> { <nl> / / if we ' re not writing to the commit log , we are replaying the log , so marking <nl> / / the log header with " you can discard anything written before the context " is not valid <nl> - CommitLog . instance ( ) . discardCompletedSegments ( metadata . cfId , ctx ) ; <nl> + CommitLog . instance . discardCompletedSegments ( metadata . cfId , ctx ) ; <nl> } <nl> } <nl> } ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java <nl> index 0f5d4e6 . . 637f502 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Table . java <nl> + + + b / src / java / org / apache / cassandra / db / Table . java <nl> @ @ - 62 , 9 + 62 , 8 @ @ public class Table <nl> * / <nl> static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock ( true ) ; <nl> <nl> - / / This is a result of pushing down the point in time when storage directories get created . It used to happen in <nl> - / / CassandraDaemon , but it is possible to call Table . open without a running daemon , so it made sense to ensure <nl> - / / proper directories here . <nl> + / / It is possible to call Table . open without a running daemon , so it makes sense to ensure <nl> + / / proper directories here as well as in CassandraDaemon . <nl> static <nl> { <nl> try <nl> @ @ - 73 , 7 + 72 , 7 @ @ public class Table <nl> } <nl> catch ( IOException ex ) <nl> { <nl> - throw new RuntimeException ( ex ) ; <nl> + throw new IOError ( ex ) ; <nl> } <nl> } <nl> <nl> @ @ - 350 , 7 + 349 , 7 @ @ public class Table <nl> try <nl> { <nl> if ( writeCommitLog ) <nl> - CommitLog . instance ( ) . add ( mutation , serializedMutation ) ; <nl> + CommitLog . instance . add ( mutation , serializedMutation ) ; <nl> <nl> DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( mutation . key ( ) ) ; <nl> for ( ColumnFamily cf : mutation . getColumnFamilies ( ) ) <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> index a544857 . . 588c4e6 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> @ @ - 95 , 7 + 95 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> / / now sync and set the tasks ' values ( which allows thread calling get ( ) to proceed ) <nl> try <nl> { <nl> - CommitLog . instance ( ) . sync ( ) ; <nl> + CommitLog . instance . sync ( ) ; <nl> } <nl> catch ( IOException e ) <nl> { <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index cab9f3f . . 1932ee5 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 80 , 15 + 80 , 7 @ @ public class CommitLog <nl> <nl> static final Logger logger = LoggerFactory . getLogger ( CommitLog . class ) ; <nl> <nl> - public static CommitLog instance ( ) <nl> - { <nl> - return CLHandle . instance ; <nl> - } <nl> - <nl> - private static class CLHandle <nl> - { <nl> - public static final CommitLog instance = new CommitLog ( ) ; <nl> - } <nl> + public static final CommitLog instance = new CommitLog ( ) ; <nl> <nl> private final Deque < CommitLogSegment > segments = new ArrayDeque < CommitLogSegment > ( ) ; <nl> <nl> @ @ - 97 , 11 + 89 , 6 @ @ public class CommitLog <nl> SEGMENT _ SIZE = size ; <nl> } <nl> <nl> - public int getSegmentCount ( ) <nl> - { <nl> - return segments . size ( ) ; <nl> - } <nl> - <nl> private final ICommitLogExecutorService executor ; <nl> <nl> / * * <nl> @ @ - 112 , 10 + 99 , 19 @ @ public class CommitLog <nl> * / <nl> private CommitLog ( ) <nl> { <nl> + try <nl> + { <nl> + DatabaseDescriptor . createAllDirectories ( ) ; <nl> + } <nl> + catch ( IOException e ) <nl> + { <nl> + throw new IOError ( e ) ; <nl> + } <nl> + <nl> / / all old segments are recovered and deleted before CommitLog is instantiated . <nl> / / All we need to do is create a new one . <nl> segments . add ( new CommitLogSegment ( ) ) ; <nl> - <nl> + <nl> if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . periodic ) <nl> { <nl> executor = new PeriodicCommitLogExecutorService ( ) ; <nl> @ @ - 157 , 6 + 153 , 22 @ @ public class CommitLog <nl> } <nl> } <nl> <nl> + public void resetUnsafe ( ) <nl> + { <nl> + segments . clear ( ) ; <nl> + segments . add ( new CommitLogSegment ( ) ) ; <nl> + } <nl> + <nl> + private boolean manages ( String name ) <nl> + { <nl> + for ( CommitLogSegment segment : segments ) <nl> + { <nl> + if ( segment . getPath ( ) . endsWith ( name ) ) <nl> + return true ; <nl> + } <nl> + return false ; <nl> + } <nl> + <nl> public static void recover ( ) throws IOException <nl> { <nl> String directory = DatabaseDescriptor . getCommitLogLocation ( ) ; <nl> @ @ - 164 , 11 + 176 , 17 @ @ public class CommitLog <nl> { <nl> public boolean accept ( File dir , String name ) <nl> { <nl> - return CommitLogSegment . possibleCommitLogFile ( name ) ; <nl> + / / we used to try to avoid instantiating commitlog ( thus creating an empty segment ready for writes ) <nl> + / / until after recover was finished . this turns out to be fragile ; it is less error - prone to go <nl> + / / ahead and allow writes before recover ( ) , and just skip active segments when we do . <nl> + return CommitLogSegment . possibleCommitLogFile ( name ) & & ! instance . manages ( name ) ; <nl> } <nl> } ) ; <nl> if ( files . length = = 0 ) <nl> + { <nl> + logger . info ( " No commitlog files found ; skipping replay " ) ; <nl> return ; <nl> + } <nl> <nl> Arrays . sort ( files , new FileUtils . FileComparator ( ) ) ; <nl> logger . info ( " Replaying " + StringUtils . join ( files , " , " ) ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 7f3caa0 . . bf56ecb 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 339 , 8 + 339 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> initialized = true ; <nl> isClientMode = false ; <nl> <nl> - DatabaseDescriptor . createAllDirectories ( ) ; <nl> - <nl> try <nl> { <nl> GCInspector . instance . start ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / CleanupHelper . java b / test / unit / org / apache / cassandra / CleanupHelper . java <nl> index a908c28 . . f817e33 100644 <nl> - - - a / test / unit / org / apache / cassandra / CleanupHelper . java <nl> + + + b / test / unit / org / apache / cassandra / CleanupHelper . java <nl> @ @ - 24 , 6 + 24 , 7 @ @ import java . io . IOException ; <nl> import org . junit . BeforeClass ; <nl> <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . io . util . FileUtils ; <nl> <nl> import org . slf4j . Logger ; <nl> @ @ - 39 , 6 + 40 , 7 @ @ public class CleanupHelper extends SchemaLoader <nl> mkdirs ( ) ; <nl> cleanup ( ) ; <nl> mkdirs ( ) ; <nl> + CommitLog . instance . resetUnsafe ( ) ; / / cleanup screws w / CommitLog , this brings it back to safe state <nl> } <nl> <nl> public static void cleanup ( ) throws IOException <nl> diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java b / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java <nl> index d2cb559 . . 8c0f2e2 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java <nl> + + + b / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java <nl> @ @ - 62 , 6 + 62 , 7 @ @ public class RecoveryManager2Test extends CleanupHelper <nl> <nl> logger . debug ( " begin manual replay " ) ; <nl> / / replay the commit log ( nothing should be replayed since everything was flushed ) <nl> + CommitLog . instance . resetUnsafe ( ) ; <nl> CommitLog . recover ( ) ; <nl> <nl> / / since everything that was flushed was removed ( i . e . clearUnsafe ) <nl> diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java b / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java <nl> index d229436 . . 5b235cd 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java <nl> + + + b / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java <nl> @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . CleanupHelper ; <nl> import org . apache . cassandra . Util ; <nl> import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . commitlog . CommitLog ; <nl> + import org . apache . cassandra . io . util . FileUtils ; <nl> <nl> import static org . apache . cassandra . Util . column ; <nl> import static org . apache . cassandra . db . TableTest . assertColumns ; <nl> @ @ - 66 , 10 + 67 , 10 @ @ public class RecoveryManager3Test extends CleanupHelper <nl> for ( File file : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( ) ) <nl> { <nl> if ( file . getName ( ) . endsWith ( " . header " ) ) <nl> - if ( ! file . delete ( ) ) <nl> - throw new AssertionError ( ) ; <nl> + FileUtils . deleteWithConfirm ( file ) ; <nl> } <nl> <nl> + CommitLog . instance . resetUnsafe ( ) ; / / disassociate segments from live CL <nl> CommitLog . recover ( ) ; <nl> <nl> assertColumns ( Util . getColumnFamily ( table1 , dk , " Standard1 " ) , " col1 " ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java b / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java <nl> index 94dc771 . . 9fda65b 100644 <nl> - - - a / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java <nl> + + + b / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java <nl> @ @ - 63 , 6 + 63 , 7 @ @ public class RecoveryManagerTest extends CleanupHelper <nl> table1 . getColumnFamilyStore ( " Standard1 " ) . clearUnsafe ( ) ; <nl> table2 . getColumnFamilyStore ( " Standard3 " ) . clearUnsafe ( ) ; <nl> <nl> + CommitLog . instance . resetUnsafe ( ) ; / / disassociate segments from live CL <nl> CommitLog . recover ( ) ; <nl> <nl> assertColumns ( Util . getColumnFamily ( table1 , dk , " Standard1 " ) , " col1 " ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e922635 . . 792d6f8 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 1 . 17 
 + * Fix RecoveryManagerTruncateTest ( CASSANDRA - 12802 ) 
 * Don ' t skip sstables based on maxLocalDeletionTime ( CASSANDRA - 12765 ) 
 
 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 502e704 . . 2484e9b 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 35 , 6 + 35 , 7 @ @ import org . apache . cassandra . config . Config ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . io . FSWriteError ; 
 + import org . apache . cassandra . io . sstable . SSTableDeletingTask ; 
 import org . apache . cassandra . io . util . DataOutputByteBuffer ; 
 import org . apache . cassandra . metrics . CommitLogMetrics ; 
 import org . apache . cassandra . net . MessagingService ; 
 @ @ - 101 , 7 + 102 , 7 @ @ public class CommitLog implements CommitLogMBean 
 / / we used to try to avoid instantiating commitlog ( thus creating an empty segment ready for writes ) 
 / / until after recover was finished . this turns out to be fragile ; it is less error - prone to go 
 / / ahead and allow writes before recover ( ) , and just skip active segments when we do . 
 - return CommitLogDescriptor . isValid ( name ) & & ! instance . allocator . manages ( name ) ; 
 + return CommitLogDescriptor . isValid ( name ) & & CommitLogSegment . shouldReplay ( name ) ; 
 } 
 } ; 
 
 @ @ - 367 , 11 + 368 , 21 @ @ public class CommitLog implements CommitLogMBean 
 
 / * * 
 * FOR TESTING PURPOSES . See CommitLogAllocator . 
 + * 
 + * There is a race at the moment , even if this method 
 + * is synchronized we can still create an allocation 
 + * on a segment that will be closed in this method , 
 + * therefore causing { @ link Allocation # awaitDiskSync ( ) } to hang 
 + * forever . This typically happens because of the mutations created 
 + * by { @ link org . apache . cassandra . io . sstable . SSTableReader . GlobalTidy } , 
 + * that ' s why we wait for all deletions to complete firtst . 
 * / 
 - public void resetUnsafe ( ) 
 + public synchronized void resetUnsafe ( ) 
 { 
 + SSTableDeletingTask . waitForDeletions ( ) ; 
 sync ( true ) ; 
 allocator . resetUnsafe ( ) ; 
 + CommitLogSegment . resetReplayLimit ( ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 index 2ea8701 . . 1093f87 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLogSegment . java 
 @ @ - 61 , 6 + 61 , 7 @ @ public class CommitLogSegment 
 
 private final static long idBase ; 
 private final static AtomicInteger nextId = new AtomicInteger ( 1 ) ; 
 + private static long replayLimitId ; 
 static 
 { 
 long maxId = Long . MIN _ VALUE ; 
 @ @ - 69 , 7 + 70 , 7 @ @ public class CommitLogSegment 
 if ( CommitLogDescriptor . isValid ( file . getName ( ) ) ) 
 maxId = Math . max ( CommitLogDescriptor . fromFileName ( file . getName ( ) ) . id , maxId ) ; 
 } 
 - idBase = Math . max ( System . currentTimeMillis ( ) , maxId + 1 ) ; 
 + replayLimitId = idBase = Math . max ( System . currentTimeMillis ( ) , maxId + 1 ) ; 
 } 
 
 / / The commit log entry overhead in bytes ( int : length + int : head checksum + int : tail checksum ) 
 @ @ - 203 , 6 + 204 , 19 @ @ public class CommitLogSegment 
 } 
 } 
 
 + static boolean shouldReplay ( String name ) 
 + { 
 + return CommitLogDescriptor . fromFileName ( name ) . id < replayLimitId ; 
 + } 
 + 
 + / * * 
 + * FOR TESTING PURPOSES . 
 + * / 
 + static void resetReplayLimit ( ) 
 + { 
 + replayLimitId = getNextId ( ) ; 
 + } 
 + 
 / / allocate bytes in the segment , or return - 1 if not enough space 
 private int allocate ( int size ) 
 {

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 1cb58ed . . 7142055 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 54 , 6 + 54 , 8 @ @ dev 
 * cli - - file option ( CASSANDRA - 1616 ) 
 * reduce automatically chosen memtable sizes by 50 % ( CASSANDRA - 1641 ) 
 * move endpoint cache from snitch to strategy ( CASSANDRA - 1643 ) 
 + * fix commitlog recovery deleting the newly - created segment as well as 
 + the old ones ( CASSANDRA - 1644 ) 
 
 
 0 . 7 - beta2 
 @ @ - 95 , 8 + 97 , 6 @ @ dev 
 * Add CfDef . default _ validation _ class ( CASSANDRA - 891 ) 
 * fix EstimatedHistogram . max ( CASSANDRA - 1413 ) 
 * quorum read optimization ( CASSANDRA - 1622 ) 
 - 
 - 
 * handle zero - length ( or missing ) rows during HH paging ( CASSANDRA - 1432 ) 
 * include secondary indexes during schema migrations ( CASSANDRA - 1406 ) 
 * fix commitlog header race during schema change ( CASSANDRA - 1435 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 895331a . . 9b045c2 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 575 , 7 + 575 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 
 assert memtable = = oldMemtable ; 
 memtable . freeze ( ) ; 
 - final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance ( ) . getContext ( ) : null ; 
 + final CommitLogSegment . CommitLogContext ctx = writeCommitLog ? CommitLog . instance . getContext ( ) : null ; 
 logger . info ( " switching in a fresh Memtable for " + columnFamily + " at " + ctx ) ; 
 
 / / submit the memtable for any indexed sub - cfses , and our own . 
 @ @ - 605 , 7 + 605 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 { 
 / / if we ' re not writing to the commit log , we are replaying the log , so marking 
 / / the log header with " you can discard anything written before the context " is not valid 
 - CommitLog . instance ( ) . discardCompletedSegments ( metadata . cfId , ctx ) ; 
 + CommitLog . instance . discardCompletedSegments ( metadata . cfId , ctx ) ; 
 } 
 } 
 } ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / Table . java b / src / java / org / apache / cassandra / db / Table . java 
 index 0f5d4e6 . . 637f502 100644 
 - - - a / src / java / org / apache / cassandra / db / Table . java 
 + + + b / src / java / org / apache / cassandra / db / Table . java 
 @ @ - 62 , 9 + 62 , 8 @ @ public class Table 
 * / 
 static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock ( true ) ; 
 
 - / / This is a result of pushing down the point in time when storage directories get created . It used to happen in 
 - / / CassandraDaemon , but it is possible to call Table . open without a running daemon , so it made sense to ensure 
 - / / proper directories here . 
 + / / It is possible to call Table . open without a running daemon , so it makes sense to ensure 
 + / / proper directories here as well as in CassandraDaemon . 
 static 
 { 
 try 
 @ @ - 73 , 7 + 72 , 7 @ @ public class Table 
 } 
 catch ( IOException ex ) 
 { 
 - throw new RuntimeException ( ex ) ; 
 + throw new IOError ( ex ) ; 
 } 
 } 
 
 @ @ - 350 , 7 + 349 , 7 @ @ public class Table 
 try 
 { 
 if ( writeCommitLog ) 
 - CommitLog . instance ( ) . add ( mutation , serializedMutation ) ; 
 + CommitLog . instance . add ( mutation , serializedMutation ) ; 
 
 DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( mutation . key ( ) ) ; 
 for ( ColumnFamily cf : mutation . getColumnFamilies ( ) ) 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 index a544857 . . 588c4e6 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 @ @ - 95 , 7 + 95 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 / / now sync and set the tasks ' values ( which allows thread calling get ( ) to proceed ) 
 try 
 { 
 - CommitLog . instance ( ) . sync ( ) ; 
 + CommitLog . instance . sync ( ) ; 
 } 
 catch ( IOException e ) 
 { 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index cab9f3f . . 1932ee5 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 80 , 15 + 80 , 7 @ @ public class CommitLog 
 
 static final Logger logger = LoggerFactory . getLogger ( CommitLog . class ) ; 
 
 - public static CommitLog instance ( ) 
 - { 
 - return CLHandle . instance ; 
 - } 
 - 
 - private static class CLHandle 
 - { 
 - public static final CommitLog instance = new CommitLog ( ) ; 
 - } 
 + public static final CommitLog instance = new CommitLog ( ) ; 
 
 private final Deque < CommitLogSegment > segments = new ArrayDeque < CommitLogSegment > ( ) ; 
 
 @ @ - 97 , 11 + 89 , 6 @ @ public class CommitLog 
 SEGMENT _ SIZE = size ; 
 } 
 
 - public int getSegmentCount ( ) 
 - { 
 - return segments . size ( ) ; 
 - } 
 - 
 private final ICommitLogExecutorService executor ; 
 
 / * * 
 @ @ - 112 , 10 + 99 , 19 @ @ public class CommitLog 
 * / 
 private CommitLog ( ) 
 { 
 + try 
 + { 
 + DatabaseDescriptor . createAllDirectories ( ) ; 
 + } 
 + catch ( IOException e ) 
 + { 
 + throw new IOError ( e ) ; 
 + } 
 + 
 / / all old segments are recovered and deleted before CommitLog is instantiated . 
 / / All we need to do is create a new one . 
 segments . add ( new CommitLogSegment ( ) ) ; 
 - 
 + 
 if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . periodic ) 
 { 
 executor = new PeriodicCommitLogExecutorService ( ) ; 
 @ @ - 157 , 6 + 153 , 22 @ @ public class CommitLog 
 } 
 } 
 
 + public void resetUnsafe ( ) 
 + { 
 + segments . clear ( ) ; 
 + segments . add ( new CommitLogSegment ( ) ) ; 
 + } 
 + 
 + private boolean manages ( String name ) 
 + { 
 + for ( CommitLogSegment segment : segments ) 
 + { 
 + if ( segment . getPath ( ) . endsWith ( name ) ) 
 + return true ; 
 + } 
 + return false ; 
 + } 
 + 
 public static void recover ( ) throws IOException 
 { 
 String directory = DatabaseDescriptor . getCommitLogLocation ( ) ; 
 @ @ - 164 , 11 + 176 , 17 @ @ public class CommitLog 
 { 
 public boolean accept ( File dir , String name ) 
 { 
 - return CommitLogSegment . possibleCommitLogFile ( name ) ; 
 + / / we used to try to avoid instantiating commitlog ( thus creating an empty segment ready for writes ) 
 + / / until after recover was finished . this turns out to be fragile ; it is less error - prone to go 
 + / / ahead and allow writes before recover ( ) , and just skip active segments when we do . 
 + return CommitLogSegment . possibleCommitLogFile ( name ) & & ! instance . manages ( name ) ; 
 } 
 } ) ; 
 if ( files . length = = 0 ) 
 + { 
 + logger . info ( " No commitlog files found ; skipping replay " ) ; 
 return ; 
 + } 
 
 Arrays . sort ( files , new FileUtils . FileComparator ( ) ) ; 
 logger . info ( " Replaying " + StringUtils . join ( files , " , " ) ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 7f3caa0 . . bf56ecb 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 339 , 8 + 339 , 6 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 initialized = true ; 
 isClientMode = false ; 
 
 - DatabaseDescriptor . createAllDirectories ( ) ; 
 - 
 try 
 { 
 GCInspector . instance . start ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / CleanupHelper . java b / test / unit / org / apache / cassandra / CleanupHelper . java 
 index a908c28 . . f817e33 100644 
 - - - a / test / unit / org / apache / cassandra / CleanupHelper . java 
 + + + b / test / unit / org / apache / cassandra / CleanupHelper . java 
 @ @ - 24 , 6 + 24 , 7 @ @ import java . io . IOException ; 
 import org . junit . BeforeClass ; 
 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . io . util . FileUtils ; 
 
 import org . slf4j . Logger ; 
 @ @ - 39 , 6 + 40 , 7 @ @ public class CleanupHelper extends SchemaLoader 
 mkdirs ( ) ; 
 cleanup ( ) ; 
 mkdirs ( ) ; 
 + CommitLog . instance . resetUnsafe ( ) ; / / cleanup screws w / CommitLog , this brings it back to safe state 
 } 
 
 public static void cleanup ( ) throws IOException 
 diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java b / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java 
 index d2cb559 . . 8c0f2e2 100644 
 - - - a / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java 
 + + + b / test / unit / org / apache / cassandra / db / RecoveryManager2Test . java 
 @ @ - 62 , 6 + 62 , 7 @ @ public class RecoveryManager2Test extends CleanupHelper 
 
 logger . debug ( " begin manual replay " ) ; 
 / / replay the commit log ( nothing should be replayed since everything was flushed ) 
 + CommitLog . instance . resetUnsafe ( ) ; 
 CommitLog . recover ( ) ; 
 
 / / since everything that was flushed was removed ( i . e . clearUnsafe ) 
 diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java b / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java 
 index d229436 . . 5b235cd 100644 
 - - - a / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java 
 + + + b / test / unit / org / apache / cassandra / db / RecoveryManager3Test . java 
 @ @ - 31 , 6 + 31 , 7 @ @ import org . apache . cassandra . CleanupHelper ; 
 import org . apache . cassandra . Util ; 
 import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . commitlog . CommitLog ; 
 + import org . apache . cassandra . io . util . FileUtils ; 
 
 import static org . apache . cassandra . Util . column ; 
 import static org . apache . cassandra . db . TableTest . assertColumns ; 
 @ @ - 66 , 10 + 67 , 10 @ @ public class RecoveryManager3Test extends CleanupHelper 
 for ( File file : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( ) ) 
 { 
 if ( file . getName ( ) . endsWith ( " . header " ) ) 
 - if ( ! file . delete ( ) ) 
 - throw new AssertionError ( ) ; 
 + FileUtils . deleteWithConfirm ( file ) ; 
 } 
 
 + CommitLog . instance . resetUnsafe ( ) ; / / disassociate segments from live CL 
 CommitLog . recover ( ) ; 
 
 assertColumns ( Util . getColumnFamily ( table1 , dk , " Standard1 " ) , " col1 " ) ; 
 diff - - git a / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java b / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java 
 index 94dc771 . . 9fda65b 100644 
 - - - a / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java 
 + + + b / test / unit / org / apache / cassandra / db / RecoveryManagerTest . java 
 @ @ - 63 , 6 + 63 , 7 @ @ public class RecoveryManagerTest extends CleanupHelper 
 table1 . getColumnFamilyStore ( " Standard1 " ) . clearUnsafe ( ) ; 
 table2 . getColumnFamilyStore ( " Standard3 " ) . clearUnsafe ( ) ; 
 
 + CommitLog . instance . resetUnsafe ( ) ; / / disassociate segments from live CL 
 CommitLog . recover ( ) ; 
 
 assertColumns ( Util . getColumnFamily ( table1 , dk , " Standard1 " ) , " col1 " ) ;
