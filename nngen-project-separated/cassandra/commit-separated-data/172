BLEU SCORE: 0.02133165846478451

TEST MSG: Forced incremental repairs should promote sstables if they can
GENERATED MSG: merge from 0 . 7 ( CASSANDRA - 1951 )

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index c7517d7 . . f2b9f7c 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Forced incremental repairs should promote sstables if they can ( CASSANDRA - 14294 ) <nl> * Use Murmur3 for validation compactions ( CASSANDRA - 14002 ) <nl> * Comma at the end of the seed list is interpretated as localhost ( CASSANDRA - 14285 ) <nl> * Refactor read executor and response resolver , abstract read repair ( CASSANDRA - 14058 ) <nl> diff - - git a / src / java / org / apache / cassandra / repair / RepairRunnable . java b / src / java / org / apache / cassandra / repair / RepairRunnable . java <nl> index 89177ee . . 4097715 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / RepairRunnable . java <nl> + + + b / src / java / org / apache / cassandra / repair / RepairRunnable . java <nl> @ @ - 234 , 7 + 234 , 7 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti <nl> traceState = null ; <nl> } <nl> <nl> - final Set < InetAddressAndPort > allNeighbors = new HashSet < > ( ) ; <nl> + Set < InetAddressAndPort > allNeighbors = new HashSet < > ( ) ; <nl> List < CommonRange > commonRanges = new ArrayList < > ( ) ; <nl> <nl> / / pre - calculate output of getLocalRanges and pass it to getNeighbors to increase performance and prevent <nl> @ @ - 286 , 9 + 286 , 18 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti <nl> SystemDistributedKeyspace . startParentRepair ( parentSession , keyspace , cfnames , options ) ; <nl> } <nl> <nl> + boolean force = options . isForcedRepair ( ) ; <nl> + <nl> + if ( force & & options . isIncremental ( ) ) <nl> + { <nl> + Set < InetAddressAndPort > actualNeighbors = Sets . newHashSet ( Iterables . filter ( allNeighbors , FailureDetector . instance : : isAlive ) ) ; <nl> + force = ! allNeighbors . equals ( actualNeighbors ) ; <nl> + allNeighbors = actualNeighbors ; <nl> + } <nl> + <nl> try ( Timer . Context ctx = Keyspace . open ( keyspace ) . metric . repairPrepareTime . time ( ) ) <nl> { <nl> - ActiveRepairService . instance . prepareForRepair ( parentSession , FBUtilities . getBroadcastAddressAndPort ( ) , allNeighbors , options , columnFamilyStores ) ; <nl> + ActiveRepairService . instance . prepareForRepair ( parentSession , FBUtilities . getBroadcastAddressAndPort ( ) , allNeighbors , options , force , columnFamilyStores ) ; <nl> progress . incrementAndGet ( ) ; <nl> } <nl> catch ( Throwable t ) <nl> @ @ - 307 , 7 + 316 , 7 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti <nl> } <nl> else if ( options . isIncremental ( ) ) <nl> { <nl> - incrementalRepair ( parentSession , startTime , options . isForcedRepair ( ) , traceState , allNeighbors , commonRanges , cfnames ) ; <nl> + incrementalRepair ( parentSession , startTime , force , traceState , allNeighbors , commonRanges , cfnames ) ; <nl> } <nl> else <nl> { <nl> @ @ - 398 , 15 + 407 , 14 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti <nl> String . . . cfnames ) <nl> { <nl> / / the local node also needs to be included in the set of participants , since coordinator sessions aren ' t persisted <nl> - Predicate < InetAddressAndPort > isAlive = FailureDetector . instance : : isAlive ; <nl> Set < InetAddressAndPort > allParticipants = ImmutableSet . < InetAddressAndPort > builder ( ) <nl> - . addAll ( forceRepair ? Iterables . filter ( allNeighbors , isAlive ) : allNeighbors ) <nl> + . addAll ( allNeighbors ) <nl> . add ( FBUtilities . getBroadcastAddressAndPort ( ) ) <nl> . build ( ) ; <nl> <nl> List < CommonRange > allRanges = filterCommonRanges ( commonRanges , allParticipants , forceRepair ) ; <nl> <nl> - CoordinatorSession coordinatorSession = ActiveRepairService . instance . consistent . coordinated . registerSession ( parentSession , allParticipants ) ; <nl> + CoordinatorSession coordinatorSession = ActiveRepairService . instance . consistent . coordinated . registerSession ( parentSession , allParticipants , forceRepair ) ; <nl> ListeningExecutorService executor = createExecutor ( ) ; <nl> AtomicBoolean hasFailure = new AtomicBoolean ( false ) ; <nl> ListenableFuture repairResult = coordinatorSession . execute ( ( ) - > submitRepairSessions ( parentSession , true , executor , allRanges , cfnames ) , <nl> diff - - git a / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java b / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java <nl> index bb84d0a . . b87a2c0 100644 <nl> - - - a / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java <nl> + + + b / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java <nl> @ @ - 43 , 10 + 43 , 15 @ @ public class CoordinatorSessions <nl> return new CoordinatorSession ( builder ) ; <nl> } <nl> <nl> - public synchronized CoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > participants ) <nl> + public synchronized CoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > participants , boolean isForced ) <nl> { <nl> - Preconditions . checkArgument ( ! sessions . containsKey ( sessionId ) , " A coordinator already exists for session % s " , sessionId ) ; <nl> ActiveRepairService . ParentRepairSession prs = ActiveRepairService . instance . getParentRepairSession ( sessionId ) ; <nl> + <nl> + Preconditions . checkArgument ( ! sessions . containsKey ( sessionId ) , <nl> + " A coordinator already exists for session % s " , sessionId ) ; <nl> + Preconditions . checkArgument ( ! isForced | | prs . repairedAt = = ActiveRepairService . UNREPAIRED _ SSTABLE , <nl> + " cannot promote data for forced incremental repairs " ) ; <nl> + <nl> CoordinatorSession . Builder builder = CoordinatorSession . builder ( ) ; <nl> builder . withState ( ConsistentSession . State . PREPARING ) ; <nl> builder . withSessionID ( sessionId ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> index c600789 . . 950966f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java <nl> @ @ - 379 , 11 + 379 , 12 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai <nl> * incremental repairs , forced incremental repairs , and full repairs , the UNREPAIRED _ SSTABLE value will prevent <nl> * sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . <nl> * / <nl> - static long getRepairedAt ( RepairOption options ) <nl> + static long getRepairedAt ( RepairOption options , boolean force ) <nl> { <nl> - / / we only want to set repairedAt for incremental repairs including all replicas for a token range . For non - global incremental repairs , forced incremental repairs , and <nl> - / / full repairs , the UNREPAIRED _ SSTABLE value will prevent sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . <nl> - if ( options . isIncremental ( ) & & options . isGlobal ( ) & & ! options . isForcedRepair ( ) ) <nl> + / / we only want to set repairedAt for incremental repairs including all replicas for a token range . For non - global incremental repairs , full repairs , the UNREPAIRED _ SSTABLE value will prevent <nl> + / / sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . For forced repairs , repairedAt time is only set to UNREPAIRED _ SSTABLE if we actually <nl> + / / end up skipping replicas <nl> + if ( options . isIncremental ( ) & & options . isGlobal ( ) & & ! force ) <nl> { <nl> return Clock . instance . currentTimeMillis ( ) ; <nl> } <nl> @ @ - 393 , 9 + 394 , 9 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai <nl> } <nl> } <nl> <nl> - public UUID prepareForRepair ( UUID parentRepairSession , InetAddressAndPort coordinator , Set < InetAddressAndPort > endpoints , RepairOption options , List < ColumnFamilyStore > columnFamilyStores ) <nl> + public UUID prepareForRepair ( UUID parentRepairSession , InetAddressAndPort coordinator , Set < InetAddressAndPort > endpoints , RepairOption options , boolean isForcedRepair , List < ColumnFamilyStore > columnFamilyStores ) <nl> { <nl> - long repairedAt = getRepairedAt ( options ) ; <nl> + long repairedAt = getRepairedAt ( options , isForcedRepair ) ; <nl> registerParentRepairSession ( parentRepairSession , coordinator , columnFamilyStores , options . getRanges ( ) , options . isIncremental ( ) , repairedAt , options . isGlobal ( ) , options . getPreviewKind ( ) ) ; <nl> final CountDownLatch prepareLatch = new CountDownLatch ( endpoints . size ( ) ) ; <nl> final AtomicBoolean status = new AtomicBoolean ( true ) ; <nl> @ @ - 434 , 7 + 435 , 9 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai <nl> } <nl> else <nl> { <nl> - if ( options . isForcedRepair ( ) ) <nl> + / / we pre - filter the endpoints we want to repair for forced incremental repairs . So if any of the <nl> + / / remaining ones go down , we still want to fail so we don ' t create repair sessions that can ' t complete <nl> + if ( isForcedRepair & & ! options . isIncremental ( ) ) <nl> { <nl> prepareLatch . countDown ( ) ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java b / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java <nl> index 9bf4270 . . bc90e9b 100644 <nl> - - - a / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java <nl> + + + b / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java <nl> @ @ - 93 , 9 + 93 , 9 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest <nl> return ( InstrumentedCoordinatorSession ) super . getSession ( sessionId ) ; <nl> } <nl> <nl> - public InstrumentedCoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > peers ) <nl> + public InstrumentedCoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > peers , boolean isForced ) <nl> { <nl> - return ( InstrumentedCoordinatorSession ) super . registerSession ( sessionId , peers ) ; <nl> + return ( InstrumentedCoordinatorSession ) super . registerSession ( sessionId , peers , isForced ) ; <nl> } <nl> } <nl> <nl> @ @ - 118 , 7 + 118 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest <nl> { <nl> CoordinatorSessions sessions = new CoordinatorSessions ( ) ; <nl> UUID sessionID = registerSession ( ) ; <nl> - CoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; <nl> + CoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; <nl> <nl> Assert . assertEquals ( ConsistentSession . State . PREPARING , session . getState ( ) ) ; <nl> Assert . assertEquals ( sessionID , session . sessionID ) ; <nl> @ @ - 139 , 7 + 139 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest <nl> InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; <nl> UUID sessionID = registerSession ( ) ; <nl> <nl> - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; <nl> + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; <nl> Assert . assertEquals ( 0 , session . prepareResponseCalls ) ; <nl> <nl> sessions . handlePrepareResponse ( new PrepareConsistentResponse ( sessionID , PARTICIPANT1 , true ) ) ; <nl> @ @ - 164 , 7 + 164 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest <nl> InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; <nl> UUID sessionID = registerSession ( ) ; <nl> <nl> - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; <nl> + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; <nl> Assert . assertEquals ( 0 , session . finalizePromiseCalls ) ; <nl> <nl> sessions . handleFinalizePromiseMessage ( new FinalizePromise ( sessionID , PARTICIPANT1 , true ) ) ; <nl> @ @ - 189 , 7 + 189 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest <nl> InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; <nl> UUID sessionID = registerSession ( ) ; <nl> <nl> - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; <nl> + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; <nl> Assert . assertEquals ( 0 , session . failCalls ) ; <nl> <nl> sessions . handleFailSessionMessage ( new FailSession ( sessionID ) ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java <nl> index 76f915e . . c4b0a9c 100644 <nl> - - - a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java <nl> + + + b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java <nl> @ @ - 336 , 22 + 336 , 24 @ @ public class ActiveRepairServiceTest <nl> public void repairedAt ( ) throws Exception <nl> { <nl> / / regular incremental repair <nl> - Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) ) ) ) ; <nl> + Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) ) , false ) ) ; <nl> / / subrange incremental repair <nl> Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , <nl> - RANGES _ KEY , " 1 : 2 " ) ) ) ; <nl> + RANGES _ KEY , " 1 : 2 " ) , false ) ) ; <nl> <nl> / / hosts incremental repair <nl> Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , <nl> - HOSTS _ KEY , " 127 . 0 . 0 . 1 " ) ) ) ; <nl> + HOSTS _ KEY , " 127 . 0 . 0 . 1 " ) , false ) ) ; <nl> / / dc incremental repair <nl> Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , <nl> - DATACENTERS _ KEY , " DC2 " ) ) ) ; <nl> + DATACENTERS _ KEY , " DC2 " ) , false ) ) ; <nl> / / forced incremental repair <nl> + Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , <nl> + FORCE _ REPAIR _ KEY , b2s ( true ) ) , false ) ) ; <nl> Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , <nl> - FORCE _ REPAIR _ KEY , b2s ( true ) ) ) ) ; <nl> + FORCE _ REPAIR _ KEY , b2s ( true ) ) , true ) ) ; <nl> <nl> / / full repair <nl> - Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( false ) ) ) ) ; <nl> + Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( false ) ) , false ) ) ; <nl> } <nl> }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 54112fd . . 62def25 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 8 , 8 + 8 , 9 @ @ <nl> <nl> <nl> 0 . 7 . 2 - dev <nl> - * fix potential overflow in nodetool cfstats <nl> - * offline nodes ( CASSANDRA - 1951 ) <nl> + * fix potential overflow in nodetool cfstats ( CASSANDRA - 2057 ) <nl> + * add JVM shutdownhook to sync commitlog ( CASSANDRA - 1919 ) <nl> + * allow nodes to be up without being part of normal traffic ( CASSANDRA - 1951 ) <nl> <nl> <nl> 0 . 7 . 1 <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> index 483e93f . . 71e18f4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java <nl> @ @ - 61 , 19 + 61 , 12 @ @ public abstract class AbstractCommitLogExecutorService extends AbstractExecutorS <nl> return completedTaskCount ; <nl> } <nl> <nl> - / / cassandra is crash - only so there ' s no need to implement the shutdown methods <nl> - <nl> - public boolean isShutdown ( ) <nl> - { <nl> - return false ; <nl> - } <nl> - <nl> public boolean isTerminated ( ) <nl> { <nl> - return false ; <nl> + throw new UnsupportedOperationException ( ) ; <nl> } <nl> <nl> - public void shutdown ( ) <nl> + public boolean isShutdown ( ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> index 588c4e6 . . bc67476 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java <nl> @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . WrappedRunnable ; <nl> class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService implements ICommitLogExecutorService , BatchCommitLogExecutorServiceMBean <nl> { <nl> private final BlockingQueue < CheaterFutureTask > queue ; <nl> + private final Thread appendingThread ; <nl> + private volatile boolean run = true ; <nl> <nl> public BatchCommitLogExecutorService ( ) <nl> { <nl> @ @ - 44 , 14 + 46 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> { <nl> public void runMayThrow ( ) throws Exception <nl> { <nl> - while ( true ) <nl> + while ( run ) <nl> { <nl> - processWithSyncBatch ( ) ; <nl> - completedTaskCount + + ; <nl> + if ( processWithSyncBatch ( ) ) <nl> + completedTaskCount + + ; <nl> } <nl> } <nl> } ; <nl> - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; <nl> + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; <nl> + appendingThread . start ( ) ; <nl> <nl> registerMBean ( this ) ; <nl> } <nl> @ @ - 63 , 13 + 66 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> <nl> private final ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; <nl> private final ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this <nl> - private void processWithSyncBatch ( ) throws Exception <nl> + private boolean processWithSyncBatch ( ) throws Exception <nl> { <nl> - CheaterFutureTask firstTask = queue . take ( ) ; <nl> + CheaterFutureTask firstTask = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + if ( firstTask = = null ) <nl> + return false ; <nl> if ( ! ( firstTask . getRawCallable ( ) instanceof CommitLog . LogRecordAdder ) ) <nl> { <nl> firstTask . run ( ) ; <nl> - return ; <nl> + return true ; <nl> } <nl> <nl> / / attempt to do a bunch of LogRecordAdder ops before syncing <nl> @ @ - 105 , 6 + 110 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> { <nl> incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; <nl> } <nl> + return true ; <nl> } <nl> <nl> <nl> @ @ - 148 , 6 + 154 , 25 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp <nl> } <nl> } <nl> <nl> + public void shutdown ( ) <nl> + { <nl> + new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws InterruptedException , IOException <nl> + { <nl> + while ( ! queue . isEmpty ( ) ) <nl> + Thread . sleep ( 100 ) ; <nl> + run = false ; <nl> + appendingThread . join ( ) ; <nl> + } <nl> + } , " Commitlog Shutdown " ) . start ( ) ; <nl> + } <nl> + <nl> + public void awaitTermination ( ) throws InterruptedException <nl> + { <nl> + appendingThread . join ( ) ; <nl> + } <nl> + <nl> private static class CheaterFutureTask < V > extends FutureTask < V > <nl> { <nl> private final Callable rawCallable ; <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> index 7ebda3b . . 0e1aa7a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java <nl> @ @ - 114 , 45 + 114 , 9 @ @ public class CommitLog <nl> / / All we need to do is create a new one . <nl> segments . add ( new CommitLogSegment ( ) ) ; <nl> <nl> - if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch ) <nl> - { <nl> - executor = new BatchCommitLogExecutorService ( ) ; <nl> - } <nl> - else <nl> - { <nl> - executor = new PeriodicCommitLogExecutorService ( ) ; <nl> - final Callable syncer = new Callable ( ) <nl> - { <nl> - public Object call ( ) throws Exception <nl> - { <nl> - sync ( ) ; <nl> - return null ; <nl> - } <nl> - } ; <nl> - <nl> - new Thread ( new Runnable ( ) <nl> - { <nl> - public void run ( ) <nl> - { <nl> - while ( true ) <nl> - { <nl> - try <nl> - { <nl> - executor . submit ( syncer ) . get ( ) ; <nl> - Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; <nl> - } <nl> - catch ( InterruptedException e ) <nl> - { <nl> - throw new AssertionError ( e ) ; <nl> - } <nl> - catch ( ExecutionException e ) <nl> - { <nl> - throw new RuntimeException ( e ) ; <nl> - } <nl> - } <nl> - } <nl> - } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; <nl> - } <nl> + executor = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch <nl> + ? new BatchCommitLogExecutorService ( ) <nl> + : new PeriodicCommitLogExecutorService ( this ) ; <nl> } <nl> <nl> public void resetUnsafe ( ) <nl> @ @ - 525 , 4 + 489 , 10 @ @ public class CommitLog <nl> return null ; <nl> } <nl> } <nl> + <nl> + public void shutdownBlocking ( ) throws InterruptedException <nl> + { <nl> + executor . shutdown ( ) ; <nl> + executor . awaitTermination ( ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> index 7acecf2 . . 20e471f 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java <nl> @ @ - 38 , 4 + 38 , 9 @ @ public interface ICommitLogExecutorService extends IExecutorMBean <nl> * / <nl> public void add ( CommitLog . LogRecordAdder adder ) ; <nl> <nl> + / * * shuts down the CommitLogExecutor in an orderly fashion * / <nl> + public void shutdown ( ) ; <nl> + <nl> + / * * Blocks until shutdown is complete . * / <nl> + public void awaitTermination ( ) throws InterruptedException ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> index f44bf5e . . 228be2c 100644 <nl> - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java <nl> @ @ - 21 , 35 + 21 , 71 @ @ package org . apache . cassandra . db . commitlog ; <nl> * / <nl> <nl> <nl> + import java . io . IOException ; <nl> import java . util . concurrent . * ; <nl> <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . utils . WrappedRunnable ; <nl> <nl> class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , PeriodicCommitLogExecutorServiceMBean <nl> { <nl> private final BlockingQueue < Runnable > queue ; <nl> protected volatile long completedTaskCount = 0 ; <nl> + private final Thread appendingThread ; <nl> + private volatile boolean run = true ; <nl> <nl> - public PeriodicCommitLogExecutorService ( ) <nl> + public PeriodicCommitLogExecutorService ( final CommitLog commitLog ) <nl> { <nl> - this ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; <nl> - } <nl> - <nl> - public PeriodicCommitLogExecutorService ( int queueSize ) <nl> - { <nl> - queue = new LinkedBlockingQueue < Runnable > ( queueSize ) ; <nl> + queue = new LinkedBlockingQueue < Runnable > ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; <nl> Runnable runnable = new WrappedRunnable ( ) <nl> { <nl> public void runMayThrow ( ) throws Exception <nl> { <nl> - while ( true ) <nl> + while ( run ) <nl> { <nl> - queue . take ( ) . run ( ) ; <nl> + Runnable r = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + if ( r = = null ) <nl> + continue ; <nl> + r . run ( ) ; <nl> completedTaskCount + + ; <nl> } <nl> + commitLog . sync ( ) ; <nl> + } <nl> + } ; <nl> + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; <nl> + appendingThread . start ( ) ; <nl> + <nl> + final Callable syncer = new Callable ( ) <nl> + { <nl> + public Object call ( ) throws Exception <nl> + { <nl> + commitLog . sync ( ) ; <nl> + return null ; <nl> } <nl> } ; <nl> - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; <nl> + <nl> + new Thread ( new Runnable ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + while ( run ) <nl> + { <nl> + try <nl> + { <nl> + submit ( syncer ) . get ( ) ; <nl> + Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; <nl> + } <nl> + catch ( InterruptedException e ) <nl> + { <nl> + throw new AssertionError ( e ) ; <nl> + } <nl> + catch ( ExecutionException e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + } <nl> + } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; <nl> <nl> AbstractCommitLogExecutorService . registerMBean ( this ) ; <nl> } <nl> @ @ - 80 , 6 + 116 , 25 @ @ class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , Per <nl> return ft ; <nl> } <nl> <nl> + public void shutdown ( ) <nl> + { <nl> + new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws InterruptedException , IOException <nl> + { <nl> + while ( ! queue . isEmpty ( ) ) <nl> + Thread . sleep ( 100 ) ; <nl> + run = false ; <nl> + appendingThread . join ( ) ; <nl> + } <nl> + } , " Commitlog Shutdown " ) . start ( ) ; <nl> + } <nl> + <nl> + public void awaitTermination ( ) throws InterruptedException <nl> + { <nl> + appendingThread . join ( ) ; <nl> + } <nl> + <nl> public long getPendingTasks ( ) <nl> { <nl> return queue . size ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 56ffbbf . . 7ee262f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 33 , 6 + 33 , 8 @ @ import javax . management . ObjectName ; <nl> import com . google . common . base . Charsets ; <nl> import com . google . common . collect . HashMultimap ; <nl> import com . google . common . collect . Multimap ; <nl> + <nl> + import org . apache . cassandra . db . commitlog . CommitLog ; <nl> import org . apache . cassandra . locator . * ; <nl> import org . apache . log4j . Level ; <nl> import org . apache . commons . lang . StringUtils ; <nl> @ @ - 381 , 6 + 383 , 22 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> } <nl> } <nl> <nl> + / / daemon threads , like our executors ' , continue to run while shutdown hooks are invoked <nl> + Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) <nl> + { <nl> + public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException <nl> + { <nl> + ThreadPoolExecutor mutationStage = StageManager . getStage ( Stage . MUTATION ) ; <nl> + if ( ! mutationStage . isShutdown ( ) ) <nl> + { <nl> + mutationStage . shutdown ( ) ; <nl> + mutationStage . awaitTermination ( 1 , TimeUnit . SECONDS ) ; <nl> + CommitLog . instance . shutdownBlocking ( ) ; <nl> + } <nl> + } <nl> + } ) ; <nl> + Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; <nl> + <nl> if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) <nl> { <nl> joinTokenRing ( ) ; <nl> @ @ - 1899 , 6 + 1917 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe <nl> ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; <nl> ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; <nl> <nl> + CommitLog . instance . shutdownBlocking ( ) ; <nl> + <nl> / / want to make sure that any segments deleted as a result of flushing are gone . <nl> DeletionService . waitFor ( ) ; <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index c7517d7 . . f2b9f7c 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Forced incremental repairs should promote sstables if they can ( CASSANDRA - 14294 ) 
 * Use Murmur3 for validation compactions ( CASSANDRA - 14002 ) 
 * Comma at the end of the seed list is interpretated as localhost ( CASSANDRA - 14285 ) 
 * Refactor read executor and response resolver , abstract read repair ( CASSANDRA - 14058 ) 
 diff - - git a / src / java / org / apache / cassandra / repair / RepairRunnable . java b / src / java / org / apache / cassandra / repair / RepairRunnable . java 
 index 89177ee . . 4097715 100644 
 - - - a / src / java / org / apache / cassandra / repair / RepairRunnable . java 
 + + + b / src / java / org / apache / cassandra / repair / RepairRunnable . java 
 @ @ - 234 , 7 + 234 , 7 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti 
 traceState = null ; 
 } 
 
 - final Set < InetAddressAndPort > allNeighbors = new HashSet < > ( ) ; 
 + Set < InetAddressAndPort > allNeighbors = new HashSet < > ( ) ; 
 List < CommonRange > commonRanges = new ArrayList < > ( ) ; 
 
 / / pre - calculate output of getLocalRanges and pass it to getNeighbors to increase performance and prevent 
 @ @ - 286 , 9 + 286 , 18 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti 
 SystemDistributedKeyspace . startParentRepair ( parentSession , keyspace , cfnames , options ) ; 
 } 
 
 + boolean force = options . isForcedRepair ( ) ; 
 + 
 + if ( force & & options . isIncremental ( ) ) 
 + { 
 + Set < InetAddressAndPort > actualNeighbors = Sets . newHashSet ( Iterables . filter ( allNeighbors , FailureDetector . instance : : isAlive ) ) ; 
 + force = ! allNeighbors . equals ( actualNeighbors ) ; 
 + allNeighbors = actualNeighbors ; 
 + } 
 + 
 try ( Timer . Context ctx = Keyspace . open ( keyspace ) . metric . repairPrepareTime . time ( ) ) 
 { 
 - ActiveRepairService . instance . prepareForRepair ( parentSession , FBUtilities . getBroadcastAddressAndPort ( ) , allNeighbors , options , columnFamilyStores ) ; 
 + ActiveRepairService . instance . prepareForRepair ( parentSession , FBUtilities . getBroadcastAddressAndPort ( ) , allNeighbors , options , force , columnFamilyStores ) ; 
 progress . incrementAndGet ( ) ; 
 } 
 catch ( Throwable t ) 
 @ @ - 307 , 7 + 316 , 7 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti 
 } 
 else if ( options . isIncremental ( ) ) 
 { 
 - incrementalRepair ( parentSession , startTime , options . isForcedRepair ( ) , traceState , allNeighbors , commonRanges , cfnames ) ; 
 + incrementalRepair ( parentSession , startTime , force , traceState , allNeighbors , commonRanges , cfnames ) ; 
 } 
 else 
 { 
 @ @ - 398 , 15 + 407 , 14 @ @ public class RepairRunnable extends WrappedRunnable implements ProgressEventNoti 
 String . . . cfnames ) 
 { 
 / / the local node also needs to be included in the set of participants , since coordinator sessions aren ' t persisted 
 - Predicate < InetAddressAndPort > isAlive = FailureDetector . instance : : isAlive ; 
 Set < InetAddressAndPort > allParticipants = ImmutableSet . < InetAddressAndPort > builder ( ) 
 - . addAll ( forceRepair ? Iterables . filter ( allNeighbors , isAlive ) : allNeighbors ) 
 + . addAll ( allNeighbors ) 
 . add ( FBUtilities . getBroadcastAddressAndPort ( ) ) 
 . build ( ) ; 
 
 List < CommonRange > allRanges = filterCommonRanges ( commonRanges , allParticipants , forceRepair ) ; 
 
 - CoordinatorSession coordinatorSession = ActiveRepairService . instance . consistent . coordinated . registerSession ( parentSession , allParticipants ) ; 
 + CoordinatorSession coordinatorSession = ActiveRepairService . instance . consistent . coordinated . registerSession ( parentSession , allParticipants , forceRepair ) ; 
 ListeningExecutorService executor = createExecutor ( ) ; 
 AtomicBoolean hasFailure = new AtomicBoolean ( false ) ; 
 ListenableFuture repairResult = coordinatorSession . execute ( ( ) - > submitRepairSessions ( parentSession , true , executor , allRanges , cfnames ) , 
 diff - - git a / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java b / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java 
 index bb84d0a . . b87a2c0 100644 
 - - - a / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java 
 + + + b / src / java / org / apache / cassandra / repair / consistent / CoordinatorSessions . java 
 @ @ - 43 , 10 + 43 , 15 @ @ public class CoordinatorSessions 
 return new CoordinatorSession ( builder ) ; 
 } 
 
 - public synchronized CoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > participants ) 
 + public synchronized CoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > participants , boolean isForced ) 
 { 
 - Preconditions . checkArgument ( ! sessions . containsKey ( sessionId ) , " A coordinator already exists for session % s " , sessionId ) ; 
 ActiveRepairService . ParentRepairSession prs = ActiveRepairService . instance . getParentRepairSession ( sessionId ) ; 
 + 
 + Preconditions . checkArgument ( ! sessions . containsKey ( sessionId ) , 
 + " A coordinator already exists for session % s " , sessionId ) ; 
 + Preconditions . checkArgument ( ! isForced | | prs . repairedAt = = ActiveRepairService . UNREPAIRED _ SSTABLE , 
 + " cannot promote data for forced incremental repairs " ) ; 
 + 
 CoordinatorSession . Builder builder = CoordinatorSession . builder ( ) ; 
 builder . withState ( ConsistentSession . State . PREPARING ) ; 
 builder . withSessionID ( sessionId ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / ActiveRepairService . java b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 index c600789 . . 950966f 100644 
 - - - a / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 + + + b / src / java / org / apache / cassandra / service / ActiveRepairService . java 
 @ @ - 379 , 11 + 379 , 12 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai 
 * incremental repairs , forced incremental repairs , and full repairs , the UNREPAIRED _ SSTABLE value will prevent 
 * sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . 
 * / 
 - static long getRepairedAt ( RepairOption options ) 
 + static long getRepairedAt ( RepairOption options , boolean force ) 
 { 
 - / / we only want to set repairedAt for incremental repairs including all replicas for a token range . For non - global incremental repairs , forced incremental repairs , and 
 - / / full repairs , the UNREPAIRED _ SSTABLE value will prevent sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . 
 - if ( options . isIncremental ( ) & & options . isGlobal ( ) & & ! options . isForcedRepair ( ) ) 
 + / / we only want to set repairedAt for incremental repairs including all replicas for a token range . For non - global incremental repairs , full repairs , the UNREPAIRED _ SSTABLE value will prevent 
 + / / sstables from being promoted to repaired or preserve the repairedAt / pendingRepair values , respectively . For forced repairs , repairedAt time is only set to UNREPAIRED _ SSTABLE if we actually 
 + / / end up skipping replicas 
 + if ( options . isIncremental ( ) & & options . isGlobal ( ) & & ! force ) 
 { 
 return Clock . instance . currentTimeMillis ( ) ; 
 } 
 @ @ - 393 , 9 + 394 , 9 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai 
 } 
 } 
 
 - public UUID prepareForRepair ( UUID parentRepairSession , InetAddressAndPort coordinator , Set < InetAddressAndPort > endpoints , RepairOption options , List < ColumnFamilyStore > columnFamilyStores ) 
 + public UUID prepareForRepair ( UUID parentRepairSession , InetAddressAndPort coordinator , Set < InetAddressAndPort > endpoints , RepairOption options , boolean isForcedRepair , List < ColumnFamilyStore > columnFamilyStores ) 
 { 
 - long repairedAt = getRepairedAt ( options ) ; 
 + long repairedAt = getRepairedAt ( options , isForcedRepair ) ; 
 registerParentRepairSession ( parentRepairSession , coordinator , columnFamilyStores , options . getRanges ( ) , options . isIncremental ( ) , repairedAt , options . isGlobal ( ) , options . getPreviewKind ( ) ) ; 
 final CountDownLatch prepareLatch = new CountDownLatch ( endpoints . size ( ) ) ; 
 final AtomicBoolean status = new AtomicBoolean ( true ) ; 
 @ @ - 434 , 7 + 435 , 9 @ @ public class ActiveRepairService implements IEndpointStateChangeSubscriber , IFai 
 } 
 else 
 { 
 - if ( options . isForcedRepair ( ) ) 
 + / / we pre - filter the endpoints we want to repair for forced incremental repairs . So if any of the 
 + / / remaining ones go down , we still want to fail so we don ' t create repair sessions that can ' t complete 
 + if ( isForcedRepair & & ! options . isIncremental ( ) ) 
 { 
 prepareLatch . countDown ( ) ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java b / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java 
 index 9bf4270 . . bc90e9b 100644 
 - - - a / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java 
 + + + b / test / unit / org / apache / cassandra / repair / consistent / CoordinatorSessionsTest . java 
 @ @ - 93 , 9 + 93 , 9 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest 
 return ( InstrumentedCoordinatorSession ) super . getSession ( sessionId ) ; 
 } 
 
 - public InstrumentedCoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > peers ) 
 + public InstrumentedCoordinatorSession registerSession ( UUID sessionId , Set < InetAddressAndPort > peers , boolean isForced ) 
 { 
 - return ( InstrumentedCoordinatorSession ) super . registerSession ( sessionId , peers ) ; 
 + return ( InstrumentedCoordinatorSession ) super . registerSession ( sessionId , peers , isForced ) ; 
 } 
 } 
 
 @ @ - 118 , 7 + 118 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest 
 { 
 CoordinatorSessions sessions = new CoordinatorSessions ( ) ; 
 UUID sessionID = registerSession ( ) ; 
 - CoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; 
 + CoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; 
 
 Assert . assertEquals ( ConsistentSession . State . PREPARING , session . getState ( ) ) ; 
 Assert . assertEquals ( sessionID , session . sessionID ) ; 
 @ @ - 139 , 7 + 139 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest 
 InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; 
 UUID sessionID = registerSession ( ) ; 
 
 - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; 
 + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; 
 Assert . assertEquals ( 0 , session . prepareResponseCalls ) ; 
 
 sessions . handlePrepareResponse ( new PrepareConsistentResponse ( sessionID , PARTICIPANT1 , true ) ) ; 
 @ @ - 164 , 7 + 164 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest 
 InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; 
 UUID sessionID = registerSession ( ) ; 
 
 - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; 
 + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; 
 Assert . assertEquals ( 0 , session . finalizePromiseCalls ) ; 
 
 sessions . handleFinalizePromiseMessage ( new FinalizePromise ( sessionID , PARTICIPANT1 , true ) ) ; 
 @ @ - 189 , 7 + 189 , 7 @ @ public class CoordinatorSessionsTest extends AbstractRepairTest 
 InstrumentedCoordinatorSessions sessions = new InstrumentedCoordinatorSessions ( ) ; 
 UUID sessionID = registerSession ( ) ; 
 
 - InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS ) ; 
 + InstrumentedCoordinatorSession session = sessions . registerSession ( sessionID , PARTICIPANTS , false ) ; 
 Assert . assertEquals ( 0 , session . failCalls ) ; 
 
 sessions . handleFailSessionMessage ( new FailSession ( sessionID ) ) ; 
 diff - - git a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java 
 index 76f915e . . c4b0a9c 100644 
 - - - a / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java 
 + + + b / test / unit / org / apache / cassandra / service / ActiveRepairServiceTest . java 
 @ @ - 336 , 22 + 336 , 24 @ @ public class ActiveRepairServiceTest 
 public void repairedAt ( ) throws Exception 
 { 
 / / regular incremental repair 
 - Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) ) ) ) ; 
 + Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) ) , false ) ) ; 
 / / subrange incremental repair 
 Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , 
 - RANGES _ KEY , " 1 : 2 " ) ) ) ; 
 + RANGES _ KEY , " 1 : 2 " ) , false ) ) ; 
 
 / / hosts incremental repair 
 Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , 
 - HOSTS _ KEY , " 127 . 0 . 0 . 1 " ) ) ) ; 
 + HOSTS _ KEY , " 127 . 0 . 0 . 1 " ) , false ) ) ; 
 / / dc incremental repair 
 Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , 
 - DATACENTERS _ KEY , " DC2 " ) ) ) ; 
 + DATACENTERS _ KEY , " DC2 " ) , false ) ) ; 
 / / forced incremental repair 
 + Assert . assertNotEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , 
 + FORCE _ REPAIR _ KEY , b2s ( true ) ) , false ) ) ; 
 Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( true ) , 
 - FORCE _ REPAIR _ KEY , b2s ( true ) ) ) ) ; 
 + FORCE _ REPAIR _ KEY , b2s ( true ) ) , true ) ) ; 
 
 / / full repair 
 - Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( false ) ) ) ) ; 
 + Assert . assertEquals ( UNREPAIRED _ SSTABLE , getRepairedAt ( opts ( INCREMENTAL _ KEY , b2s ( false ) ) , false ) ) ; 
 } 
 }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 54112fd . . 62def25 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 8 , 8 + 8 , 9 @ @ 
 
 
 0 . 7 . 2 - dev 
 - * fix potential overflow in nodetool cfstats 
 - * offline nodes ( CASSANDRA - 1951 ) 
 + * fix potential overflow in nodetool cfstats ( CASSANDRA - 2057 ) 
 + * add JVM shutdownhook to sync commitlog ( CASSANDRA - 1919 ) 
 + * allow nodes to be up without being part of normal traffic ( CASSANDRA - 1951 ) 
 
 
 0 . 7 . 1 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 index 483e93f . . 71e18f4 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / AbstractCommitLogExecutorService . java 
 @ @ - 61 , 19 + 61 , 12 @ @ public abstract class AbstractCommitLogExecutorService extends AbstractExecutorS 
 return completedTaskCount ; 
 } 
 
 - / / cassandra is crash - only so there ' s no need to implement the shutdown methods 
 - 
 - public boolean isShutdown ( ) 
 - { 
 - return false ; 
 - } 
 - 
 public boolean isTerminated ( ) 
 { 
 - return false ; 
 + throw new UnsupportedOperationException ( ) ; 
 } 
 
 - public void shutdown ( ) 
 + public boolean isShutdown ( ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 index 588c4e6 . . bc67476 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / BatchCommitLogExecutorService . java 
 @ @ - 31 , 6 + 31 , 8 @ @ import org . apache . cassandra . utils . WrappedRunnable ; 
 class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService implements ICommitLogExecutorService , BatchCommitLogExecutorServiceMBean 
 { 
 private final BlockingQueue < CheaterFutureTask > queue ; 
 + private final Thread appendingThread ; 
 + private volatile boolean run = true ; 
 
 public BatchCommitLogExecutorService ( ) 
 { 
 @ @ - 44 , 14 + 46 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 { 
 public void runMayThrow ( ) throws Exception 
 { 
 - while ( true ) 
 + while ( run ) 
 { 
 - processWithSyncBatch ( ) ; 
 - completedTaskCount + + ; 
 + if ( processWithSyncBatch ( ) ) 
 + completedTaskCount + + ; 
 } 
 } 
 } ; 
 - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; 
 + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; 
 + appendingThread . start ( ) ; 
 
 registerMBean ( this ) ; 
 } 
 @ @ - 63 , 13 + 66 , 15 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 
 private final ArrayList < CheaterFutureTask > incompleteTasks = new ArrayList < CheaterFutureTask > ( ) ; 
 private final ArrayList taskValues = new ArrayList ( ) ; / / TODO not sure how to generify this 
 - private void processWithSyncBatch ( ) throws Exception 
 + private boolean processWithSyncBatch ( ) throws Exception 
 { 
 - CheaterFutureTask firstTask = queue . take ( ) ; 
 + CheaterFutureTask firstTask = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; 
 + if ( firstTask = = null ) 
 + return false ; 
 if ( ! ( firstTask . getRawCallable ( ) instanceof CommitLog . LogRecordAdder ) ) 
 { 
 firstTask . run ( ) ; 
 - return ; 
 + return true ; 
 } 
 
 / / attempt to do a bunch of LogRecordAdder ops before syncing 
 @ @ - 105 , 6 + 110 , 7 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 { 
 incompleteTasks . get ( i ) . set ( taskValues . get ( i ) ) ; 
 } 
 + return true ; 
 } 
 
 
 @ @ - 148 , 6 + 154 , 25 @ @ class BatchCommitLogExecutorService extends AbstractCommitLogExecutorService imp 
 } 
 } 
 
 + public void shutdown ( ) 
 + { 
 + new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws InterruptedException , IOException 
 + { 
 + while ( ! queue . isEmpty ( ) ) 
 + Thread . sleep ( 100 ) ; 
 + run = false ; 
 + appendingThread . join ( ) ; 
 + } 
 + } , " Commitlog Shutdown " ) . start ( ) ; 
 + } 
 + 
 + public void awaitTermination ( ) throws InterruptedException 
 + { 
 + appendingThread . join ( ) ; 
 + } 
 + 
 private static class CheaterFutureTask < V > extends FutureTask < V > 
 { 
 private final Callable rawCallable ; 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 index 7ebda3b . . 0e1aa7a 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / CommitLog . java 
 @ @ - 114 , 45 + 114 , 9 @ @ public class CommitLog 
 / / All we need to do is create a new one . 
 segments . add ( new CommitLogSegment ( ) ) ; 
 
 - if ( DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch ) 
 - { 
 - executor = new BatchCommitLogExecutorService ( ) ; 
 - } 
 - else 
 - { 
 - executor = new PeriodicCommitLogExecutorService ( ) ; 
 - final Callable syncer = new Callable ( ) 
 - { 
 - public Object call ( ) throws Exception 
 - { 
 - sync ( ) ; 
 - return null ; 
 - } 
 - } ; 
 - 
 - new Thread ( new Runnable ( ) 
 - { 
 - public void run ( ) 
 - { 
 - while ( true ) 
 - { 
 - try 
 - { 
 - executor . submit ( syncer ) . get ( ) ; 
 - Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; 
 - } 
 - catch ( InterruptedException e ) 
 - { 
 - throw new AssertionError ( e ) ; 
 - } 
 - catch ( ExecutionException e ) 
 - { 
 - throw new RuntimeException ( e ) ; 
 - } 
 - } 
 - } 
 - } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; 
 - } 
 + executor = DatabaseDescriptor . getCommitLogSync ( ) = = Config . CommitLogSync . batch 
 + ? new BatchCommitLogExecutorService ( ) 
 + : new PeriodicCommitLogExecutorService ( this ) ; 
 } 
 
 public void resetUnsafe ( ) 
 @ @ - 525 , 4 + 489 , 10 @ @ public class CommitLog 
 return null ; 
 } 
 } 
 + 
 + public void shutdownBlocking ( ) throws InterruptedException 
 + { 
 + executor . shutdown ( ) ; 
 + executor . awaitTermination ( ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 index 7acecf2 . . 20e471f 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / ICommitLogExecutorService . java 
 @ @ - 38 , 4 + 38 , 9 @ @ public interface ICommitLogExecutorService extends IExecutorMBean 
 * / 
 public void add ( CommitLog . LogRecordAdder adder ) ; 
 
 + / * * shuts down the CommitLogExecutor in an orderly fashion * / 
 + public void shutdown ( ) ; 
 + 
 + / * * Blocks until shutdown is complete . * / 
 + public void awaitTermination ( ) throws InterruptedException ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 index f44bf5e . . 228be2c 100644 
 - - - a / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 + + + b / src / java / org / apache / cassandra / db / commitlog / PeriodicCommitLogExecutorService . java 
 @ @ - 21 , 35 + 21 , 71 @ @ package org . apache . cassandra . db . commitlog ; 
 * / 
 
 
 + import java . io . IOException ; 
 import java . util . concurrent . * ; 
 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . utils . WrappedRunnable ; 
 
 class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , PeriodicCommitLogExecutorServiceMBean 
 { 
 private final BlockingQueue < Runnable > queue ; 
 protected volatile long completedTaskCount = 0 ; 
 + private final Thread appendingThread ; 
 + private volatile boolean run = true ; 
 
 - public PeriodicCommitLogExecutorService ( ) 
 + public PeriodicCommitLogExecutorService ( final CommitLog commitLog ) 
 { 
 - this ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
 - } 
 - 
 - public PeriodicCommitLogExecutorService ( int queueSize ) 
 - { 
 - queue = new LinkedBlockingQueue < Runnable > ( queueSize ) ; 
 + queue = new LinkedBlockingQueue < Runnable > ( 1024 * Runtime . getRuntime ( ) . availableProcessors ( ) ) ; 
 Runnable runnable = new WrappedRunnable ( ) 
 { 
 public void runMayThrow ( ) throws Exception 
 { 
 - while ( true ) 
 + while ( run ) 
 { 
 - queue . take ( ) . run ( ) ; 
 + Runnable r = queue . poll ( 100 , TimeUnit . MILLISECONDS ) ; 
 + if ( r = = null ) 
 + continue ; 
 + r . run ( ) ; 
 completedTaskCount + + ; 
 } 
 + commitLog . sync ( ) ; 
 + } 
 + } ; 
 + appendingThread = new Thread ( runnable , " COMMIT - LOG - WRITER " ) ; 
 + appendingThread . start ( ) ; 
 + 
 + final Callable syncer = new Callable ( ) 
 + { 
 + public Object call ( ) throws Exception 
 + { 
 + commitLog . sync ( ) ; 
 + return null ; 
 } 
 } ; 
 - new Thread ( runnable , " COMMIT - LOG - WRITER " ) . start ( ) ; 
 + 
 + new Thread ( new Runnable ( ) 
 + { 
 + public void run ( ) 
 + { 
 + while ( run ) 
 + { 
 + try 
 + { 
 + submit ( syncer ) . get ( ) ; 
 + Thread . sleep ( DatabaseDescriptor . getCommitLogSyncPeriod ( ) ) ; 
 + } 
 + catch ( InterruptedException e ) 
 + { 
 + throw new AssertionError ( e ) ; 
 + } 
 + catch ( ExecutionException e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + } 
 + } , " PERIODIC - COMMIT - LOG - SYNCER " ) . start ( ) ; 
 
 AbstractCommitLogExecutorService . registerMBean ( this ) ; 
 } 
 @ @ - 80 , 6 + 116 , 25 @ @ class PeriodicCommitLogExecutorService implements ICommitLogExecutorService , Per 
 return ft ; 
 } 
 
 + public void shutdown ( ) 
 + { 
 + new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws InterruptedException , IOException 
 + { 
 + while ( ! queue . isEmpty ( ) ) 
 + Thread . sleep ( 100 ) ; 
 + run = false ; 
 + appendingThread . join ( ) ; 
 + } 
 + } , " Commitlog Shutdown " ) . start ( ) ; 
 + } 
 + 
 + public void awaitTermination ( ) throws InterruptedException 
 + { 
 + appendingThread . join ( ) ; 
 + } 
 + 
 public long getPendingTasks ( ) 
 { 
 return queue . size ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 56ffbbf . . 7ee262f 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 33 , 6 + 33 , 8 @ @ import javax . management . ObjectName ; 
 import com . google . common . base . Charsets ; 
 import com . google . common . collect . HashMultimap ; 
 import com . google . common . collect . Multimap ; 
 + 
 + import org . apache . cassandra . db . commitlog . CommitLog ; 
 import org . apache . cassandra . locator . * ; 
 import org . apache . log4j . Level ; 
 import org . apache . commons . lang . StringUtils ; 
 @ @ - 381 , 6 + 383 , 22 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 } 
 } 
 
 + / / daemon threads , like our executors ' , continue to run while shutdown hooks are invoked 
 + Thread drainOnShutdown = new Thread ( new WrappedRunnable ( ) 
 + { 
 + public void runMayThrow ( ) throws ExecutionException , InterruptedException , IOException 
 + { 
 + ThreadPoolExecutor mutationStage = StageManager . getStage ( Stage . MUTATION ) ; 
 + if ( ! mutationStage . isShutdown ( ) ) 
 + { 
 + mutationStage . shutdown ( ) ; 
 + mutationStage . awaitTermination ( 1 , TimeUnit . SECONDS ) ; 
 + CommitLog . instance . shutdownBlocking ( ) ; 
 + } 
 + } 
 + } ) ; 
 + Runtime . getRuntime ( ) . addShutdownHook ( drainOnShutdown ) ; 
 + 
 if ( Boolean . parseBoolean ( System . getProperty ( " cassandra . join _ ring " , " true " ) ) ) 
 { 
 joinTokenRing ( ) ; 
 @ @ - 1899 , 6 + 1917 , 8 @ @ public class StorageService implements IEndpointStateChangeSubscriber , StorageSe 
 ColumnFamilyStore . postFlushExecutor . shutdown ( ) ; 
 ColumnFamilyStore . postFlushExecutor . awaitTermination ( 60 , TimeUnit . SECONDS ) ; 
 
 + CommitLog . instance . shutdownBlocking ( ) ; 
 + 
 / / want to make sure that any segments deleted as a result of flushing are gone . 
 DeletionService . waitFor ( ) ; 

