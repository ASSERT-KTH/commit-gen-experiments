BLEU SCORE: 0.041961149062965476

TEST MSG: Fix error when CONTAINS is used with a bind marker
GENERATED MSG: Handle SliceQueryFilter with empty bounds in CompositesSearcher

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b609795 . . 095624d 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 4 @ @ <nl> - 2 . 1 . 0 <nl> + 2 . 1 . 0 - rc3 <nl> * Fix ClassCastException processing expired messages ( CASSANDRA - 7496 ) <nl> * Fix prepared marker for collections inside UDT ( CASSANDRA - 7472 ) <nl> * Remove left - over populate _ io _ cache _ on _ flush and replicate _ on _ write <nl> @ @ - 7 , 6 + 7 , 7 @ @ <nl> * Ensure writes have completed after dropping a table , before recycling <nl> commit log segments ( CASSANDRA - 7437 ) <nl> * Remove left - over rows _ per _ partition _ to _ cache ( CASSANDRA - 7493 ) <nl> + * Fix error when CONTAINS is used with a bind marker ( CASSANDRA - 7502 ) <nl> Merged from 2 . 0 : <nl> * Fix CC # collectTimeOrderedData ( ) tombstone optimisations ( CASSANDRA - 7394 ) <nl> * Support DISTINCT for static columns and fix behaviour when DISTINC is <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index b454ece . . c9572c2 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 1697 , 6 + 1697 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache <nl> boolean isKey = newRel . operator ( ) = = Relation . Type . CONTAINS _ KEY ; <nl> receiver = makeCollectionReceiver ( receiver , isKey ) ; <nl> Term t = newRel . getValue ( ) . prepare ( keyspace ( ) , receiver ) ; <nl> + t . collectMarkerSpecification ( boundNames ) ; <nl> ( ( SingleColumnRestriction . Contains ) existingRestriction ) . add ( t , isKey ) ; <nl> } <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> index b8912e7 . . b861d49 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java <nl> @ @ - 25 , 6 + 25 , 7 @ @ import java . util . concurrent . TimeUnit ; <nl> import java . util . concurrent . atomic . AtomicInteger ; <nl> <nl> import com . google . common . base . Objects ; <nl> + import com . google . common . collect . ImmutableSet ; <nl> import org . junit . AfterClass ; <nl> import org . junit . After ; <nl> import org . junit . Assert ; <nl> @ @ - 60 , 6 + 61 , 8 @ @ public abstract class CQLTester <nl> <nl> private String currentTable ; <nl> <nl> + private final Set < String > currentTypes = new HashSet < > ( ) ; <nl> + <nl> @ BeforeClass <nl> public static void setUpClass ( ) throws Throwable <nl> { <nl> @ @ - 132 , 6 + 135 , 13 @ @ public abstract class CQLTester <nl> schemaChange ( fullQuery ) ; <nl> } <nl> <nl> + protected void createIndex ( String query ) <nl> + { <nl> + String fullQuery = String . format ( query , KEYSPACE + " . " + currentTable ) ; <nl> + logger . info ( fullQuery ) ; <nl> + schemaChange ( fullQuery ) ; <nl> + } <nl> + <nl> private static void schemaChange ( String query ) <nl> { <nl> try <nl> @ @ - 466 , 6 + 476 , 23 @ @ public abstract class CQLTester <nl> return Arrays . asList ( values ) ; <nl> } <nl> <nl> + protected Object set ( Object . . . values ) <nl> + { <nl> + return ImmutableSet . copyOf ( values ) ; <nl> + } <nl> + <nl> + protected Object map ( Object . . . values ) <nl> + { <nl> + if ( values . length % 2 ! = 0 ) <nl> + throw new IllegalArgumentException ( ) ; <nl> + <nl> + int size = values . length / 2 ; <nl> + Map m = new HashMap ( size ) ; <nl> + for ( int i = 0 ; i < size ; i + + ) <nl> + m . put ( values [ 2 * i ] , values [ ( 2 * i ) + 1 ] ) ; <nl> + return m ; <nl> + } <nl> + <nl> / / Attempt to find an AbstracType from a value ( for serialization / printing sake ) . <nl> / / Will work as long as we use types we know of , which is good enough for testing <nl> private static AbstractType typeFor ( Object value ) <nl> @ @ - 495 , 6 + 522 , 31 @ @ public abstract class CQLTester <nl> return ListType . getInstance ( elt ) ; <nl> } <nl> <nl> + if ( value instanceof Set ) <nl> + { <nl> + Set s = ( Set ) value ; <nl> + AbstractType elt = s . isEmpty ( ) ? BytesType . instance : typeFor ( s . iterator ( ) . next ( ) ) ; <nl> + return SetType . getInstance ( elt ) ; <nl> + } <nl> + <nl> + if ( value instanceof Map ) <nl> + { <nl> + Map m = ( Map ) value ; <nl> + AbstractType keys , values ; <nl> + if ( m . isEmpty ( ) ) <nl> + { <nl> + keys = BytesType . instance ; <nl> + values = BytesType . instance ; <nl> + } <nl> + else <nl> + { <nl> + Map . Entry entry = ( Map . Entry ) m . entrySet ( ) . iterator ( ) . next ( ) ; <nl> + keys = typeFor ( entry . getKey ( ) ) ; <nl> + values = typeFor ( entry . getValue ( ) ) ; <nl> + } <nl> + return MapType . getInstance ( keys , values ) ; <nl> + } <nl> + <nl> throw new IllegalArgumentException ( " Unsupported value type ( value is " + value + " ) " ) ; <nl> } <nl> <nl> diff - - git a / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java b / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java <nl> index eae9b9f . . 0c6cfe1 100644 <nl> - - - a / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java <nl> + + + b / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java <nl> @ @ - 17 , 64 + 17 , 82 @ @ <nl> * / <nl> package org . apache . cassandra . cql3 ; <nl> <nl> - import static com . google . common . collect . Lists . newArrayList ; <nl> - import static com . google . common . collect . Sets . newHashSet ; <nl> - <nl> import org . junit . Test ; <nl> <nl> - import com . google . common . collect . ImmutableMap ; <nl> - <nl> public class ContainsRelationTest extends CQLTester <nl> { <nl> @ Test <nl> - public void testSetContains ( ) throws Throwable <nl> + public void testSetContains ( ) throws Throwable <nl> { <nl> - createTable ( " CREATE TABLE % s ( account text , id int , categories set < text > , PRIMARY KEY ( account , id ) ) ; " ) ; <nl> - execute ( " CREATE INDEX cat _ index _ set ON % s ( categories ) ; " ) ; <nl> - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' } ) ; " ) ; <nl> - <nl> - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' lmn ' ; " ) ) ; <nl> - <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newHashSet ( " lmn " ) ) ) ; <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newHashSet ( " lmn " ) ) ) ; <nl> + createTable ( " CREATE TABLE % s ( account text , id int , categories set < text > , PRIMARY KEY ( account , id ) ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , set ( " lmn " ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " lmn " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " lmn " ) , <nl> + row ( " test " , 5 , set ( " lmn " ) ) <nl> + ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " test " , " lmn " ) , <nl> + row ( " test " , 5 , set ( " lmn " ) ) <nl> + ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> - public void testListContains ( ) throws Throwable <nl> + public void testListContains ( ) throws Throwable <nl> { <nl> - createTable ( " CREATE TABLE % s ( account text , id int , categories list < text > , PRIMARY KEY ( account , id ) ) ; " ) ; <nl> - execute ( " CREATE INDEX cat _ index _ list ON % s ( categories ) ; " ) ; <nl> - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , [ ' lmn ' ] ) ; " ) ; <nl> - <nl> - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' lmn ' ; " ) ) ; <nl> - <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newArrayList ( " lmn " ) ) ) ; <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newArrayList ( " lmn " ) ) ) ; <nl> + createTable ( " CREATE TABLE % s ( account text , id int , categories list < text > , PRIMARY KEY ( account , id ) ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , list ( " lmn " ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " lmn " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? ; " , " test " , " lmn " ) , <nl> + row ( " test " , 5 , list ( " lmn " ) ) <nl> + ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " lmn " ) , <nl> + row ( " test " , 5 , list ( " lmn " ) ) <nl> + ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> - public void testMapKeyContains ( ) throws Throwable <nl> + public void testMapKeyContains ( ) throws Throwable <nl> { <nl> - createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) ; " ) ; <nl> - execute ( " CREATE INDEX cat _ index _ map _ key ON % s ( keys ( categories ) ) ; " ) ; <nl> - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' : ' foo ' } ) ; " ) ; <nl> - <nl> - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS KEY ' lmn ' ; " ) ) ; <nl> - <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS KEY ' lmn ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS KEY ' lmn ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; <nl> + createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( keys ( categories ) ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , map ( " lmn " , " foo " ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS KEY ? " , " xyz " , " lmn " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS KEY ? " , " test " , " lmn " ) , <nl> + row ( " test " , 5 , map ( " lmn " , " foo " ) ) <nl> + ) ; <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS KEY ? " , " lmn " ) , <nl> + row ( " test " , 5 , map ( " lmn " , " foo " ) ) <nl> + ) ; <nl> } <nl> - <nl> + <nl> @ Test <nl> - public void testMapValueContains ( ) throws Throwable <nl> + public void testMapValueContains ( ) throws Throwable <nl> { <nl> - createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) ; " ) ; <nl> - execute ( " CREATE INDEX cat _ index _ map _ value ON % s ( categories ) ; " ) ; <nl> - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' : ' foo ' } ) ; " ) ; <nl> - <nl> - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' foo ' ; " ) ) ; <nl> - <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' foo ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; <nl> - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' foo ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; <nl> + createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) " ) ; <nl> + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; <nl> + <nl> + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , map ( " lmn " , " foo " ) ) ; <nl> + <nl> + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " foo " ) ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " test " , " foo " ) , <nl> + row ( " test " , 5 , map ( " lmn " , " foo " ) ) <nl> + ) ; <nl> + <nl> + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " foo " ) , <nl> + row ( " test " , 5 , map ( " lmn " , " foo " ) ) <nl> + ) ; <nl> } <nl> }
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b609795 . . 095624d 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 4 @ @ 
 - 2 . 1 . 0 
 + 2 . 1 . 0 - rc3 
 * Fix ClassCastException processing expired messages ( CASSANDRA - 7496 ) 
 * Fix prepared marker for collections inside UDT ( CASSANDRA - 7472 ) 
 * Remove left - over populate _ io _ cache _ on _ flush and replicate _ on _ write 
 @ @ - 7 , 6 + 7 , 7 @ @ 
 * Ensure writes have completed after dropping a table , before recycling 
 commit log segments ( CASSANDRA - 7437 ) 
 * Remove left - over rows _ per _ partition _ to _ cache ( CASSANDRA - 7493 ) 
 + * Fix error when CONTAINS is used with a bind marker ( CASSANDRA - 7502 ) 
 Merged from 2 . 0 : 
 * Fix CC # collectTimeOrderedData ( ) tombstone optimisations ( CASSANDRA - 7394 ) 
 * Support DISTINCT for static columns and fix behaviour when DISTINC is 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index b454ece . . c9572c2 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 1697 , 6 + 1697 , 7 @ @ public class SelectStatement implements CQLStatement , MeasurableForPreparedCache 
 boolean isKey = newRel . operator ( ) = = Relation . Type . CONTAINS _ KEY ; 
 receiver = makeCollectionReceiver ( receiver , isKey ) ; 
 Term t = newRel . getValue ( ) . prepare ( keyspace ( ) , receiver ) ; 
 + t . collectMarkerSpecification ( boundNames ) ; 
 ( ( SingleColumnRestriction . Contains ) existingRestriction ) . add ( t , isKey ) ; 
 } 
 } 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / CQLTester . java b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 index b8912e7 . . b861d49 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / CQLTester . java 
 @ @ - 25 , 6 + 25 , 7 @ @ import java . util . concurrent . TimeUnit ; 
 import java . util . concurrent . atomic . AtomicInteger ; 
 
 import com . google . common . base . Objects ; 
 + import com . google . common . collect . ImmutableSet ; 
 import org . junit . AfterClass ; 
 import org . junit . After ; 
 import org . junit . Assert ; 
 @ @ - 60 , 6 + 61 , 8 @ @ public abstract class CQLTester 
 
 private String currentTable ; 
 
 + private final Set < String > currentTypes = new HashSet < > ( ) ; 
 + 
 @ BeforeClass 
 public static void setUpClass ( ) throws Throwable 
 { 
 @ @ - 132 , 6 + 135 , 13 @ @ public abstract class CQLTester 
 schemaChange ( fullQuery ) ; 
 } 
 
 + protected void createIndex ( String query ) 
 + { 
 + String fullQuery = String . format ( query , KEYSPACE + " . " + currentTable ) ; 
 + logger . info ( fullQuery ) ; 
 + schemaChange ( fullQuery ) ; 
 + } 
 + 
 private static void schemaChange ( String query ) 
 { 
 try 
 @ @ - 466 , 6 + 476 , 23 @ @ public abstract class CQLTester 
 return Arrays . asList ( values ) ; 
 } 
 
 + protected Object set ( Object . . . values ) 
 + { 
 + return ImmutableSet . copyOf ( values ) ; 
 + } 
 + 
 + protected Object map ( Object . . . values ) 
 + { 
 + if ( values . length % 2 ! = 0 ) 
 + throw new IllegalArgumentException ( ) ; 
 + 
 + int size = values . length / 2 ; 
 + Map m = new HashMap ( size ) ; 
 + for ( int i = 0 ; i < size ; i + + ) 
 + m . put ( values [ 2 * i ] , values [ ( 2 * i ) + 1 ] ) ; 
 + return m ; 
 + } 
 + 
 / / Attempt to find an AbstracType from a value ( for serialization / printing sake ) . 
 / / Will work as long as we use types we know of , which is good enough for testing 
 private static AbstractType typeFor ( Object value ) 
 @ @ - 495 , 6 + 522 , 31 @ @ public abstract class CQLTester 
 return ListType . getInstance ( elt ) ; 
 } 
 
 + if ( value instanceof Set ) 
 + { 
 + Set s = ( Set ) value ; 
 + AbstractType elt = s . isEmpty ( ) ? BytesType . instance : typeFor ( s . iterator ( ) . next ( ) ) ; 
 + return SetType . getInstance ( elt ) ; 
 + } 
 + 
 + if ( value instanceof Map ) 
 + { 
 + Map m = ( Map ) value ; 
 + AbstractType keys , values ; 
 + if ( m . isEmpty ( ) ) 
 + { 
 + keys = BytesType . instance ; 
 + values = BytesType . instance ; 
 + } 
 + else 
 + { 
 + Map . Entry entry = ( Map . Entry ) m . entrySet ( ) . iterator ( ) . next ( ) ; 
 + keys = typeFor ( entry . getKey ( ) ) ; 
 + values = typeFor ( entry . getValue ( ) ) ; 
 + } 
 + return MapType . getInstance ( keys , values ) ; 
 + } 
 + 
 throw new IllegalArgumentException ( " Unsupported value type ( value is " + value + " ) " ) ; 
 } 
 
 diff - - git a / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java b / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java 
 index eae9b9f . . 0c6cfe1 100644 
 - - - a / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java 
 + + + b / test / unit / org / apache / cassandra / cql3 / ContainsRelationTest . java 
 @ @ - 17 , 64 + 17 , 82 @ @ 
 * / 
 package org . apache . cassandra . cql3 ; 
 
 - import static com . google . common . collect . Lists . newArrayList ; 
 - import static com . google . common . collect . Sets . newHashSet ; 
 - 
 import org . junit . Test ; 
 
 - import com . google . common . collect . ImmutableMap ; 
 - 
 public class ContainsRelationTest extends CQLTester 
 { 
 @ Test 
 - public void testSetContains ( ) throws Throwable 
 + public void testSetContains ( ) throws Throwable 
 { 
 - createTable ( " CREATE TABLE % s ( account text , id int , categories set < text > , PRIMARY KEY ( account , id ) ) ; " ) ; 
 - execute ( " CREATE INDEX cat _ index _ set ON % s ( categories ) ; " ) ; 
 - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' } ) ; " ) ; 
 - 
 - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' lmn ' ; " ) ) ; 
 - 
 - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newHashSet ( " lmn " ) ) ) ; 
 - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newHashSet ( " lmn " ) ) ) ; 
 + createTable ( " CREATE TABLE % s ( account text , id int , categories set < text > , PRIMARY KEY ( account , id ) ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , set ( " lmn " ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " lmn " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " lmn " ) , 
 + row ( " test " , 5 , set ( " lmn " ) ) 
 + ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " test " , " lmn " ) , 
 + row ( " test " , 5 , set ( " lmn " ) ) 
 + ) ; 
 } 
 - 
 + 
 @ Test 
 - public void testListContains ( ) throws Throwable 
 + public void testListContains ( ) throws Throwable 
 { 
 - createTable ( " CREATE TABLE % s ( account text , id int , categories list < text > , PRIMARY KEY ( account , id ) ) ; " ) ; 
 - execute ( " CREATE INDEX cat _ index _ list ON % s ( categories ) ; " ) ; 
 - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , [ ' lmn ' ] ) ; " ) ; 
 - 
 - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' lmn ' ; " ) ) ; 
 - 
 - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newArrayList ( " lmn " ) ) ) ; 
 - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' lmn ' ; " ) , row ( " test " , 5 , newArrayList ( " lmn " ) ) ) ; 
 + createTable ( " CREATE TABLE % s ( account text , id int , categories list < text > , PRIMARY KEY ( account , id ) ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , list ( " lmn " ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " lmn " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? ; " , " test " , " lmn " ) , 
 + row ( " test " , 5 , list ( " lmn " ) ) 
 + ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " lmn " ) , 
 + row ( " test " , 5 , list ( " lmn " ) ) 
 + ) ; 
 } 
 - 
 + 
 @ Test 
 - public void testMapKeyContains ( ) throws Throwable 
 + public void testMapKeyContains ( ) throws Throwable 
 { 
 - createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) ; " ) ; 
 - execute ( " CREATE INDEX cat _ index _ map _ key ON % s ( keys ( categories ) ) ; " ) ; 
 - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' : ' foo ' } ) ; " ) ; 
 - 
 - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS KEY ' lmn ' ; " ) ) ; 
 - 
 - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS KEY ' lmn ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; 
 - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS KEY ' lmn ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; 
 + createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( keys ( categories ) ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , map ( " lmn " , " foo " ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS KEY ? " , " xyz " , " lmn " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS KEY ? " , " test " , " lmn " ) , 
 + row ( " test " , 5 , map ( " lmn " , " foo " ) ) 
 + ) ; 
 + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS KEY ? " , " lmn " ) , 
 + row ( " test " , 5 , map ( " lmn " , " foo " ) ) 
 + ) ; 
 } 
 - 
 + 
 @ Test 
 - public void testMapValueContains ( ) throws Throwable 
 + public void testMapValueContains ( ) throws Throwable 
 { 
 - createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) ; " ) ; 
 - execute ( " CREATE INDEX cat _ index _ map _ value ON % s ( categories ) ; " ) ; 
 - execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ' test ' , 5 , { ' lmn ' : ' foo ' } ) ; " ) ; 
 - 
 - assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ' xyz ' AND categories CONTAINS ' foo ' ; " ) ) ; 
 - 
 - assertRows ( execute ( " SELECT * FROM % s WHERE account = ' test ' AND categories CONTAINS ' foo ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; 
 - assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ' foo ' ; " ) , row ( " test " , 5 , ImmutableMap . of ( " lmn " , " foo " ) ) ) ; 
 + createTable ( " CREATE TABLE % s ( account text , id int , categories map < text , text > , PRIMARY KEY ( account , id ) ) " ) ; 
 + createIndex ( " CREATE INDEX ON % s ( categories ) " ) ; 
 + 
 + execute ( " INSERT INTO % s ( account , id , categories ) VALUES ( ? , ? , ? ) " , " test " , 5 , map ( " lmn " , " foo " ) ) ; 
 + 
 + assertEmpty ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " xyz " , " foo " ) ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE account = ? AND categories CONTAINS ? " , " test " , " foo " ) , 
 + row ( " test " , 5 , map ( " lmn " , " foo " ) ) 
 + ) ; 
 + 
 + assertRows ( execute ( " SELECT * FROM % s WHERE categories CONTAINS ? " , " foo " ) , 
 + row ( " test " , 5 , map ( " lmn " , " foo " ) ) 
 + ) ; 
 } 
 }

NEAREST DIFF:
ELIMINATEDSENTENCE
