BLEU SCORE: 0.020980574531482755

TEST MSG: Fix some tests failure for CASSANDRA - 9704 upgrade tests
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> index b6f6657 . . d73d9cb 100644 <nl> - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java <nl> @ @ - 853 , 6 + 853 , 17 @ @ public abstract class LegacyLayout <nl> } ; <nl> } <nl> <nl> + private static boolean equalValues ( ClusteringPrefix c1 , ClusteringPrefix c2 , ClusteringComparator comparator ) <nl> + { <nl> + assert c1 . size ( ) = = c2 . size ( ) ; <nl> + for ( int i = 0 ; i < c1 . size ( ) ; i + + ) <nl> + { <nl> + if ( comparator . compareComponent ( i , c1 . get ( i ) , c2 . get ( i ) ) ! = 0 ) <nl> + return false ; <nl> + } <nl> + return true ; <nl> + } <nl> + <nl> private static Comparator < LegacyAtom > legacyAtomComparator ( CFMetaData metadata ) <nl> { <nl> return ( o1 , o2 ) - > <nl> @ @ - 864 , 7 + 875 , 7 @ @ public abstract class LegacyLayout <nl> ClusteringPrefix c2 = o2 . clustering ( ) ; <nl> <nl> int clusteringComparison ; <nl> - if ( c1 . size ( ) ! = c2 . size ( ) | | ( o1 . isCell ( ) = = o2 . isCell ( ) ) ) <nl> + if ( c1 . size ( ) ! = c2 . size ( ) | | ( o1 . isCell ( ) = = o2 . isCell ( ) ) | | ! equalValues ( c1 , c2 , metadata . comparator ) ) <nl> { <nl> clusteringComparison = metadata . comparator . compare ( c1 , c2 ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> index 0ccd229 . . 5a10716 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadCommand . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadCommand . java <nl> @ @ - 863 , 7 + 863 , 7 @ @ public abstract class ReadCommand implements ReadQuery <nl> PartitionColumns columns = filter . selects ( Clustering . STATIC _ CLUSTERING ) <nl> ? metadata . partitionColumns ( ) <nl> : metadata . partitionColumns ( ) . withoutStatics ( ) ; <nl> - return new ColumnFilter . Builder ( metadata ) . addAll ( columns ) . build ( ) ; <nl> + return ColumnFilter . selectionBuilder ( ) . addAll ( columns ) . build ( ) ; <nl> } <nl> } <nl> <nl> @ @ - 1208 , 7 + 1208 , 7 @ @ public abstract class ReadCommand implements ReadQuery <nl> / / fully specified . We need to handle those cases differently in 3 . 0 . <nl> NavigableSet < Clustering > clusterings = new TreeSet < > ( metadata . comparator ) ; <nl> <nl> - ColumnFilter . Builder selectionBuilder = new ColumnFilter . Builder ( metadata ) ; <nl> + ColumnFilter . Builder selectionBuilder = ColumnFilter . selectionBuilder ( ) ; <nl> for ( int i = 0 ; i < numCellNames ; i + + ) <nl> { <nl> ByteBuffer buffer = ByteBufferUtil . readWithShortLength ( in ) ; <nl> @ @ - 1287 , 7 + 1287 , 7 @ @ public abstract class ReadCommand implements ReadQuery <nl> PartitionColumns columns = selectsStatics <nl> ? metadata . partitionColumns ( ) <nl> : metadata . partitionColumns ( ) . withoutStatics ( ) ; <nl> - ColumnFilter columnFilter = new ColumnFilter . Builder ( metadata ) . addAll ( columns ) . build ( ) ; <nl> + ColumnFilter columnFilter = ColumnFilter . selectionBuilder ( ) . addAll ( columns ) . build ( ) ; <nl> <nl> boolean isDistinct = compositesToGroup = = - 2 | | ( count = = 1 & & selectsStatics ) ; <nl> DataLimits limits ; <nl> diff - - git a / src / java / org / apache / cassandra / db / Slices . java b / src / java / org / apache / cassandra / db / Slices . java <nl> index 9dd4a48 . . bde9d96 100644 <nl> - - - a / src / java / org / apache / cassandra / db / Slices . java <nl> + + + b / src / java / org / apache / cassandra / db / Slices . java <nl> @ @ - 876 , 7 + 876 , 8 @ @ public abstract class Slices implements Iterable < Slice > <nl> <nl> public UnfilteredRowIterator makeSliceIterator ( SliceableUnfilteredRowIterator iter ) <nl> { <nl> - return UnfilteredRowIterators . emptyIterator ( iter . metadata ( ) , iter . partitionKey ( ) , iter . isReverseOrder ( ) ) ; <nl> + return UnfilteredRowIterators . noRowsIterator ( iter . metadata ( ) , iter . partitionKey ( ) , iter . staticRow ( ) , <nl> + iter . partitionLevelDeletion ( ) , iter . isReverseOrder ( ) ) ; <nl> } <nl> <nl> public Iterator < Slice > iterator ( ) <nl> diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnFilter . java b / src / java / org / apache / cassandra / db / filter / ColumnFilter . java <nl> index 9205ff9 . . 29b3164 100644 <nl> - - - a / src / java / org / apache / cassandra / db / filter / ColumnFilter . java <nl> + + + b / src / java / org / apache / cassandra / db / filter / ColumnFilter . java <nl> @ @ - 246 , 7 + 246 , 7 @ @ public class ColumnFilter <nl> private PartitionColumns . Builder selection ; <nl> private List < ColumnSubselection > subSelections ; <nl> <nl> - public Builder ( CFMetaData metadata ) <nl> + private Builder ( CFMetaData metadata ) <nl> { <nl> this . metadata = metadata ; <nl> } <nl> diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> new file mode 100644 <nl> index 0000000 . . 15b566e <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java <nl> @ @ - 0 , 0 + 1 , 182 @ @ <nl> + package org . apache . cassandra . db ; <nl> + <nl> + import java . io . IOException ; <nl> + import java . nio . ByteBuffer ; <nl> + import java . util . Collections ; <nl> + import java . util . Iterator ; <nl> + <nl> + import org . junit . Assert ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . slf4j . Logger ; <nl> + import org . slf4j . LoggerFactory ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . config . Schema ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . cql3 . QueryProcessor ; <nl> + import org . apache . cassandra . cql3 . UntypedResultSet ; <nl> + import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; <nl> + import org . apache . cassandra . db . filter . ColumnFilter ; <nl> + import org . apache . cassandra . db . filter . DataLimits ; <nl> + import org . apache . cassandra . db . filter . RowFilter ; <nl> + import org . apache . cassandra . db . marshal . IntegerType ; <nl> + import org . apache . cassandra . db . marshal . UTF8Type ; <nl> + import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; <nl> + import org . apache . cassandra . db . rows . Cell ; <nl> + import org . apache . cassandra . db . rows . Row ; <nl> + import org . apache . cassandra . db . rows . UnfilteredRowIterator ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . io . util . ByteBufferDataInput ; <nl> + import org . apache . cassandra . io . util . DataInputPlus ; <nl> + import org . apache . cassandra . io . util . DataOutputBuffer ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . schema . KeyspaceParams ; <nl> + import org . apache . cassandra . utils . ByteBufferUtil ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class SinglePartitionSliceCommandTest <nl> + { <nl> + private static final Logger logger = LoggerFactory . getLogger ( SinglePartitionSliceCommandTest . class ) ; <nl> + <nl> + private static final String KEYSPACE = " ks " ; <nl> + private static final String TABLE = " tbl " ; <nl> + <nl> + private static CFMetaData cfm ; <nl> + private static ColumnDefinition v ; <nl> + private static ColumnDefinition s ; <nl> + <nl> + @ BeforeClass <nl> + public static void defineSchema ( ) throws ConfigurationException <nl> + { <nl> + cfm = CFMetaData . Builder . create ( KEYSPACE , TABLE ) <nl> + . addPartitionKey ( " k " , UTF8Type . instance ) <nl> + . addStaticColumn ( " s " , UTF8Type . instance ) <nl> + . addClusteringColumn ( " i " , IntegerType . instance ) <nl> + . addRegularColumn ( " v " , UTF8Type . instance ) <nl> + . build ( ) ; <nl> + <nl> + SchemaLoader . prepareServer ( ) ; <nl> + SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( 1 ) , cfm ) ; <nl> + cfm = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; <nl> + v = cfm . getColumnDefinition ( new ColumnIdentifier ( " v " , true ) ) ; <nl> + s = cfm . getColumnDefinition ( new ColumnIdentifier ( " s " , true ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void staticColumnsAreFiltered ( ) throws IOException <nl> + { <nl> + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k " ) ) ; <nl> + <nl> + UntypedResultSet rows ; <nl> + <nl> + QueryProcessor . executeInternal ( " INSERT INTO ks . tbl ( k , s , i , v ) VALUES ( ' k ' , ' s ' , 0 , ' v ' ) " ) ; <nl> + QueryProcessor . executeInternal ( " DELETE v FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; <nl> + QueryProcessor . executeInternal ( " DELETE FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; <nl> + rows = QueryProcessor . executeInternal ( " SELECT * FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; <nl> + <nl> + for ( UntypedResultSet . Row row : rows ) <nl> + { <nl> + logger . debug ( " Current : k = { } , s = { } , v = { } " , ( row . has ( " k " ) ? row . getString ( " k " ) : null ) , ( row . has ( " s " ) ? row . getString ( " s " ) : null ) , ( row . has ( " v " ) ? row . getString ( " v " ) : null ) ) ; <nl> + } <nl> + <nl> + assert rows . isEmpty ( ) ; <nl> + <nl> + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( v ) ) ; <nl> + ByteBuffer zero = ByteBufferUtil . bytes ( 0 ) ; <nl> + Slices slices = Slices . with ( cfm . comparator , Slice . make ( Slice . Bound . inclusiveStartOf ( zero ) , Slice . Bound . inclusiveEndOf ( zero ) ) ) ; <nl> + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( slices , false ) ; <nl> + ReadCommand cmd = new SinglePartitionSliceCommand ( false , MessagingService . VERSION _ 30 , true , cfm , <nl> + FBUtilities . nowInSeconds ( ) , <nl> + columnFilter , <nl> + RowFilter . NONE , <nl> + DataLimits . NONE , <nl> + key , <nl> + sliceFilter ) ; <nl> + <nl> + DataOutputBuffer out = new DataOutputBuffer ( ( int ) ReadCommand . legacyReadCommandSerializer . serializedSize ( cmd , MessagingService . VERSION _ 21 ) ) ; <nl> + ReadCommand . legacyReadCommandSerializer . serialize ( cmd , out , MessagingService . VERSION _ 21 ) ; <nl> + DataInputPlus in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; <nl> + cmd = ReadCommand . legacyReadCommandSerializer . deserialize ( in , MessagingService . VERSION _ 21 ) ; <nl> + <nl> + logger . debug ( " ReadCommand : { } " , cmd ) ; <nl> + UnfilteredPartitionIterator partitionIterator = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; <nl> + ReadResponse response = ReadResponse . createDataResponse ( partitionIterator , cmd . columnFilter ( ) ) ; <nl> + <nl> + logger . debug ( " creating response : { } " , response ) ; <nl> + partitionIterator = response . makeIterator ( cfm , null ) ; / / < - cmd is null <nl> + assert partitionIterator . hasNext ( ) ; <nl> + UnfilteredRowIterator partition = partitionIterator . next ( ) ; <nl> + <nl> + LegacyLayout . LegacyUnfilteredPartition rowIter = LegacyLayout . fromUnfilteredRowIterator ( partition ) ; <nl> + Assert . assertEquals ( Collections . emptyList ( ) , rowIter . cells ) ; <nl> + } <nl> + <nl> + private void checkForS ( UnfilteredPartitionIterator pi ) <nl> + { <nl> + Assert . assertTrue ( pi . toString ( ) , pi . hasNext ( ) ) ; <nl> + UnfilteredRowIterator ri = pi . next ( ) ; <nl> + Assert . assertTrue ( ri . columns ( ) . contains ( s ) ) ; <nl> + Row staticRow = ri . staticRow ( ) ; <nl> + Iterator < Cell > cellIterator = staticRow . cells ( ) . iterator ( ) ; <nl> + Assert . assertTrue ( staticRow . toString ( cfm , true ) , cellIterator . hasNext ( ) ) ; <nl> + Cell cell = cellIterator . next ( ) ; <nl> + Assert . assertEquals ( s , cell . column ( ) ) ; <nl> + Assert . assertEquals ( ByteBufferUtil . bytesToHex ( cell . value ( ) ) , ByteBufferUtil . bytes ( " s " ) , cell . value ( ) ) ; <nl> + Assert . assertFalse ( cellIterator . hasNext ( ) ) ; <nl> + } <nl> + <nl> + @ Test <nl> + public void staticColumnsAreReturned ( ) throws IOException <nl> + { <nl> + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k " ) ) ; <nl> + <nl> + QueryProcessor . executeInternal ( " INSERT INTO ks . tbl ( k , s ) VALUES ( ' k ' , ' s ' ) " ) ; <nl> + Assert . assertFalse ( QueryProcessor . executeInternal ( " SELECT s FROM ks . tbl WHERE k = ' k ' " ) . isEmpty ( ) ) ; <nl> + <nl> + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( s ) ) ; <nl> + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( Slices . NONE , false ) ; <nl> + ReadCommand cmd = new SinglePartitionSliceCommand ( false , MessagingService . VERSION _ 30 , true , cfm , <nl> + FBUtilities . nowInSeconds ( ) , <nl> + columnFilter , <nl> + RowFilter . NONE , <nl> + DataLimits . NONE , <nl> + key , <nl> + sliceFilter ) ; <nl> + <nl> + UnfilteredPartitionIterator pi ; <nl> + <nl> + / / check raw iterator for static cell <nl> + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; <nl> + checkForS ( pi ) ; <nl> + <nl> + ReadResponse response ; <nl> + DataOutputBuffer out ; <nl> + DataInputPlus in ; <nl> + ReadResponse dst ; <nl> + <nl> + / / check ( de ) serialized iterator for memtable static cell <nl> + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; <nl> + response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; <nl> + out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION _ 30 ) ) ; <nl> + ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION _ 30 ) ; <nl> + in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; <nl> + dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION _ 30 ) ; <nl> + pi = dst . makeIterator ( cfm , cmd ) ; <nl> + checkForS ( pi ) ; <nl> + <nl> + / / check ( de ) serialized iterator for sstable static cell <nl> + Schema . instance . getColumnFamilyStoreInstance ( cfm . cfId ) . forceBlockingFlush ( ) ; <nl> + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; <nl> + response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; <nl> + out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION _ 30 ) ) ; <nl> + ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION _ 30 ) ; <nl> + in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; <nl> + dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION _ 30 ) ; <nl> + pi = dst . makeIterator ( cfm , cmd ) ; <nl> + checkForS ( pi ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / LegacyLayout . java b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 index b6f6657 . . d73d9cb 100644 
 - - - a / src / java / org / apache / cassandra / db / LegacyLayout . java 
 + + + b / src / java / org / apache / cassandra / db / LegacyLayout . java 
 @ @ - 853 , 6 + 853 , 17 @ @ public abstract class LegacyLayout 
 } ; 
 } 
 
 + private static boolean equalValues ( ClusteringPrefix c1 , ClusteringPrefix c2 , ClusteringComparator comparator ) 
 + { 
 + assert c1 . size ( ) = = c2 . size ( ) ; 
 + for ( int i = 0 ; i < c1 . size ( ) ; i + + ) 
 + { 
 + if ( comparator . compareComponent ( i , c1 . get ( i ) , c2 . get ( i ) ) ! = 0 ) 
 + return false ; 
 + } 
 + return true ; 
 + } 
 + 
 private static Comparator < LegacyAtom > legacyAtomComparator ( CFMetaData metadata ) 
 { 
 return ( o1 , o2 ) - > 
 @ @ - 864 , 7 + 875 , 7 @ @ public abstract class LegacyLayout 
 ClusteringPrefix c2 = o2 . clustering ( ) ; 
 
 int clusteringComparison ; 
 - if ( c1 . size ( ) ! = c2 . size ( ) | | ( o1 . isCell ( ) = = o2 . isCell ( ) ) ) 
 + if ( c1 . size ( ) ! = c2 . size ( ) | | ( o1 . isCell ( ) = = o2 . isCell ( ) ) | | ! equalValues ( c1 , c2 , metadata . comparator ) ) 
 { 
 clusteringComparison = metadata . comparator . compare ( c1 , c2 ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / ReadCommand . java b / src / java / org / apache / cassandra / db / ReadCommand . java 
 index 0ccd229 . . 5a10716 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadCommand . java 
 + + + b / src / java / org / apache / cassandra / db / ReadCommand . java 
 @ @ - 863 , 7 + 863 , 7 @ @ public abstract class ReadCommand implements ReadQuery 
 PartitionColumns columns = filter . selects ( Clustering . STATIC _ CLUSTERING ) 
 ? metadata . partitionColumns ( ) 
 : metadata . partitionColumns ( ) . withoutStatics ( ) ; 
 - return new ColumnFilter . Builder ( metadata ) . addAll ( columns ) . build ( ) ; 
 + return ColumnFilter . selectionBuilder ( ) . addAll ( columns ) . build ( ) ; 
 } 
 } 
 
 @ @ - 1208 , 7 + 1208 , 7 @ @ public abstract class ReadCommand implements ReadQuery 
 / / fully specified . We need to handle those cases differently in 3 . 0 . 
 NavigableSet < Clustering > clusterings = new TreeSet < > ( metadata . comparator ) ; 
 
 - ColumnFilter . Builder selectionBuilder = new ColumnFilter . Builder ( metadata ) ; 
 + ColumnFilter . Builder selectionBuilder = ColumnFilter . selectionBuilder ( ) ; 
 for ( int i = 0 ; i < numCellNames ; i + + ) 
 { 
 ByteBuffer buffer = ByteBufferUtil . readWithShortLength ( in ) ; 
 @ @ - 1287 , 7 + 1287 , 7 @ @ public abstract class ReadCommand implements ReadQuery 
 PartitionColumns columns = selectsStatics 
 ? metadata . partitionColumns ( ) 
 : metadata . partitionColumns ( ) . withoutStatics ( ) ; 
 - ColumnFilter columnFilter = new ColumnFilter . Builder ( metadata ) . addAll ( columns ) . build ( ) ; 
 + ColumnFilter columnFilter = ColumnFilter . selectionBuilder ( ) . addAll ( columns ) . build ( ) ; 
 
 boolean isDistinct = compositesToGroup = = - 2 | | ( count = = 1 & & selectsStatics ) ; 
 DataLimits limits ; 
 diff - - git a / src / java / org / apache / cassandra / db / Slices . java b / src / java / org / apache / cassandra / db / Slices . java 
 index 9dd4a48 . . bde9d96 100644 
 - - - a / src / java / org / apache / cassandra / db / Slices . java 
 + + + b / src / java / org / apache / cassandra / db / Slices . java 
 @ @ - 876 , 7 + 876 , 8 @ @ public abstract class Slices implements Iterable < Slice > 
 
 public UnfilteredRowIterator makeSliceIterator ( SliceableUnfilteredRowIterator iter ) 
 { 
 - return UnfilteredRowIterators . emptyIterator ( iter . metadata ( ) , iter . partitionKey ( ) , iter . isReverseOrder ( ) ) ; 
 + return UnfilteredRowIterators . noRowsIterator ( iter . metadata ( ) , iter . partitionKey ( ) , iter . staticRow ( ) , 
 + iter . partitionLevelDeletion ( ) , iter . isReverseOrder ( ) ) ; 
 } 
 
 public Iterator < Slice > iterator ( ) 
 diff - - git a / src / java / org / apache / cassandra / db / filter / ColumnFilter . java b / src / java / org / apache / cassandra / db / filter / ColumnFilter . java 
 index 9205ff9 . . 29b3164 100644 
 - - - a / src / java / org / apache / cassandra / db / filter / ColumnFilter . java 
 + + + b / src / java / org / apache / cassandra / db / filter / ColumnFilter . java 
 @ @ - 246 , 7 + 246 , 7 @ @ public class ColumnFilter 
 private PartitionColumns . Builder selection ; 
 private List < ColumnSubselection > subSelections ; 
 
 - public Builder ( CFMetaData metadata ) 
 + private Builder ( CFMetaData metadata ) 
 { 
 this . metadata = metadata ; 
 } 
 diff - - git a / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 new file mode 100644 
 index 0000000 . . 15b566e 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / db / SinglePartitionSliceCommandTest . java 
 @ @ - 0 , 0 + 1 , 182 @ @ 
 + package org . apache . cassandra . db ; 
 + 
 + import java . io . IOException ; 
 + import java . nio . ByteBuffer ; 
 + import java . util . Collections ; 
 + import java . util . Iterator ; 
 + 
 + import org . junit . Assert ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import org . slf4j . Logger ; 
 + import org . slf4j . LoggerFactory ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . config . Schema ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . cql3 . QueryProcessor ; 
 + import org . apache . cassandra . cql3 . UntypedResultSet ; 
 + import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; 
 + import org . apache . cassandra . db . filter . ColumnFilter ; 
 + import org . apache . cassandra . db . filter . DataLimits ; 
 + import org . apache . cassandra . db . filter . RowFilter ; 
 + import org . apache . cassandra . db . marshal . IntegerType ; 
 + import org . apache . cassandra . db . marshal . UTF8Type ; 
 + import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; 
 + import org . apache . cassandra . db . rows . Cell ; 
 + import org . apache . cassandra . db . rows . Row ; 
 + import org . apache . cassandra . db . rows . UnfilteredRowIterator ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . io . util . ByteBufferDataInput ; 
 + import org . apache . cassandra . io . util . DataInputPlus ; 
 + import org . apache . cassandra . io . util . DataOutputBuffer ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . schema . KeyspaceParams ; 
 + import org . apache . cassandra . utils . ByteBufferUtil ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class SinglePartitionSliceCommandTest 
 + { 
 + private static final Logger logger = LoggerFactory . getLogger ( SinglePartitionSliceCommandTest . class ) ; 
 + 
 + private static final String KEYSPACE = " ks " ; 
 + private static final String TABLE = " tbl " ; 
 + 
 + private static CFMetaData cfm ; 
 + private static ColumnDefinition v ; 
 + private static ColumnDefinition s ; 
 + 
 + @ BeforeClass 
 + public static void defineSchema ( ) throws ConfigurationException 
 + { 
 + cfm = CFMetaData . Builder . create ( KEYSPACE , TABLE ) 
 + . addPartitionKey ( " k " , UTF8Type . instance ) 
 + . addStaticColumn ( " s " , UTF8Type . instance ) 
 + . addClusteringColumn ( " i " , IntegerType . instance ) 
 + . addRegularColumn ( " v " , UTF8Type . instance ) 
 + . build ( ) ; 
 + 
 + SchemaLoader . prepareServer ( ) ; 
 + SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( 1 ) , cfm ) ; 
 + cfm = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; 
 + v = cfm . getColumnDefinition ( new ColumnIdentifier ( " v " , true ) ) ; 
 + s = cfm . getColumnDefinition ( new ColumnIdentifier ( " s " , true ) ) ; 
 + } 
 + 
 + @ Test 
 + public void staticColumnsAreFiltered ( ) throws IOException 
 + { 
 + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k " ) ) ; 
 + 
 + UntypedResultSet rows ; 
 + 
 + QueryProcessor . executeInternal ( " INSERT INTO ks . tbl ( k , s , i , v ) VALUES ( ' k ' , ' s ' , 0 , ' v ' ) " ) ; 
 + QueryProcessor . executeInternal ( " DELETE v FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; 
 + QueryProcessor . executeInternal ( " DELETE FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; 
 + rows = QueryProcessor . executeInternal ( " SELECT * FROM ks . tbl WHERE k = ' k ' AND i = 0 " ) ; 
 + 
 + for ( UntypedResultSet . Row row : rows ) 
 + { 
 + logger . debug ( " Current : k = { } , s = { } , v = { } " , ( row . has ( " k " ) ? row . getString ( " k " ) : null ) , ( row . has ( " s " ) ? row . getString ( " s " ) : null ) , ( row . has ( " v " ) ? row . getString ( " v " ) : null ) ) ; 
 + } 
 + 
 + assert rows . isEmpty ( ) ; 
 + 
 + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( v ) ) ; 
 + ByteBuffer zero = ByteBufferUtil . bytes ( 0 ) ; 
 + Slices slices = Slices . with ( cfm . comparator , Slice . make ( Slice . Bound . inclusiveStartOf ( zero ) , Slice . Bound . inclusiveEndOf ( zero ) ) ) ; 
 + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( slices , false ) ; 
 + ReadCommand cmd = new SinglePartitionSliceCommand ( false , MessagingService . VERSION _ 30 , true , cfm , 
 + FBUtilities . nowInSeconds ( ) , 
 + columnFilter , 
 + RowFilter . NONE , 
 + DataLimits . NONE , 
 + key , 
 + sliceFilter ) ; 
 + 
 + DataOutputBuffer out = new DataOutputBuffer ( ( int ) ReadCommand . legacyReadCommandSerializer . serializedSize ( cmd , MessagingService . VERSION _ 21 ) ) ; 
 + ReadCommand . legacyReadCommandSerializer . serialize ( cmd , out , MessagingService . VERSION _ 21 ) ; 
 + DataInputPlus in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; 
 + cmd = ReadCommand . legacyReadCommandSerializer . deserialize ( in , MessagingService . VERSION _ 21 ) ; 
 + 
 + logger . debug ( " ReadCommand : { } " , cmd ) ; 
 + UnfilteredPartitionIterator partitionIterator = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; 
 + ReadResponse response = ReadResponse . createDataResponse ( partitionIterator , cmd . columnFilter ( ) ) ; 
 + 
 + logger . debug ( " creating response : { } " , response ) ; 
 + partitionIterator = response . makeIterator ( cfm , null ) ; / / < - cmd is null 
 + assert partitionIterator . hasNext ( ) ; 
 + UnfilteredRowIterator partition = partitionIterator . next ( ) ; 
 + 
 + LegacyLayout . LegacyUnfilteredPartition rowIter = LegacyLayout . fromUnfilteredRowIterator ( partition ) ; 
 + Assert . assertEquals ( Collections . emptyList ( ) , rowIter . cells ) ; 
 + } 
 + 
 + private void checkForS ( UnfilteredPartitionIterator pi ) 
 + { 
 + Assert . assertTrue ( pi . toString ( ) , pi . hasNext ( ) ) ; 
 + UnfilteredRowIterator ri = pi . next ( ) ; 
 + Assert . assertTrue ( ri . columns ( ) . contains ( s ) ) ; 
 + Row staticRow = ri . staticRow ( ) ; 
 + Iterator < Cell > cellIterator = staticRow . cells ( ) . iterator ( ) ; 
 + Assert . assertTrue ( staticRow . toString ( cfm , true ) , cellIterator . hasNext ( ) ) ; 
 + Cell cell = cellIterator . next ( ) ; 
 + Assert . assertEquals ( s , cell . column ( ) ) ; 
 + Assert . assertEquals ( ByteBufferUtil . bytesToHex ( cell . value ( ) ) , ByteBufferUtil . bytes ( " s " ) , cell . value ( ) ) ; 
 + Assert . assertFalse ( cellIterator . hasNext ( ) ) ; 
 + } 
 + 
 + @ Test 
 + public void staticColumnsAreReturned ( ) throws IOException 
 + { 
 + DecoratedKey key = cfm . decorateKey ( ByteBufferUtil . bytes ( " k " ) ) ; 
 + 
 + QueryProcessor . executeInternal ( " INSERT INTO ks . tbl ( k , s ) VALUES ( ' k ' , ' s ' ) " ) ; 
 + Assert . assertFalse ( QueryProcessor . executeInternal ( " SELECT s FROM ks . tbl WHERE k = ' k ' " ) . isEmpty ( ) ) ; 
 + 
 + ColumnFilter columnFilter = ColumnFilter . selection ( PartitionColumns . of ( s ) ) ; 
 + ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter ( Slices . NONE , false ) ; 
 + ReadCommand cmd = new SinglePartitionSliceCommand ( false , MessagingService . VERSION _ 30 , true , cfm , 
 + FBUtilities . nowInSeconds ( ) , 
 + columnFilter , 
 + RowFilter . NONE , 
 + DataLimits . NONE , 
 + key , 
 + sliceFilter ) ; 
 + 
 + UnfilteredPartitionIterator pi ; 
 + 
 + / / check raw iterator for static cell 
 + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; 
 + checkForS ( pi ) ; 
 + 
 + ReadResponse response ; 
 + DataOutputBuffer out ; 
 + DataInputPlus in ; 
 + ReadResponse dst ; 
 + 
 + / / check ( de ) serialized iterator for memtable static cell 
 + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; 
 + response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; 
 + out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION _ 30 ) ) ; 
 + ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION _ 30 ) ; 
 + in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; 
 + dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION _ 30 ) ; 
 + pi = dst . makeIterator ( cfm , cmd ) ; 
 + checkForS ( pi ) ; 
 + 
 + / / check ( de ) serialized iterator for sstable static cell 
 + Schema . instance . getColumnFamilyStoreInstance ( cfm . cfId ) . forceBlockingFlush ( ) ; 
 + pi = cmd . executeLocally ( ReadOrderGroup . emptyGroup ( ) ) ; 
 + response = ReadResponse . createDataResponse ( pi , cmd . columnFilter ( ) ) ; 
 + out = new DataOutputBuffer ( ( int ) ReadResponse . serializer . serializedSize ( response , MessagingService . VERSION _ 30 ) ) ; 
 + ReadResponse . serializer . serialize ( response , out , MessagingService . VERSION _ 30 ) ; 
 + in = new ByteBufferDataInput ( out . buffer ( ) , null , 0 , 0 ) ; 
 + dst = ReadResponse . serializer . deserialize ( in , MessagingService . VERSION _ 30 ) ; 
 + pi = dst . makeIterator ( cfm , cmd ) ; 
 + checkForS ( pi ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
