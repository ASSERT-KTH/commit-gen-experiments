BLEU SCORE: 0.05876350803261633

TEST MSG: SASI index options validation
GENERATED MSG: Reject index queries while the index is building

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index e6067a6 . . 04ce8d7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 4 <nl> + * SASI index options validation ( CASSANDRA - 11136 ) <nl> * Optimize disk seek using min / max column name meta data when the LIMIT clause is used <nl> ( CASSANDRA - 8180 ) <nl> * Add LIKE support to CQL3 ( CASSANDRA - 11067 ) <nl> diff - - git a / doc / SASI . md b / doc / SASI . md <nl> index 90fcf65 . . a4762c9 100644 <nl> - - - a / doc / SASI . md <nl> + + + b / doc / SASI . md <nl> @ @ - 70 , 12 + 70 , 12 @ @ first being the default . The ` last _ name ` index is created with the <nl> mode ` CONTAINS ` which matches terms on suffixes instead of prefix <nl> only . Examples of this are available below and more detail can be <nl> found in the section on <nl> - [ OnDiskIndex ] ( https : / / github . com / xedin / sasi # ondiskindexbuilder ) . The <nl> + [ OnDiskIndex ] ( # ondiskindexbuilder ) . The <nl> ` created _ at ` column is created with its mode set to ` SPARSE ` , which is <nl> meant to improve performance of querying large , dense number ranges <nl> like timestamps for data inserted every millisecond . Details of the <nl> ` SPARSE ` implementation can also be found in the section on the <nl> - [ OnDiskIndex ] ( https : / / github . com / xedin / sasi # ondiskindexbuilder ) . The ` age ` <nl> + [ OnDiskIndex ] ( # ondiskindexbuilder ) . The ` age ` <nl> index is created with the default ` PREFIX ` mode and no <nl> case - sensitivity or text analysis options are specified since the <nl> field is numeric . <nl> @ @ - 186 , 7 + 186 , 7 @ @ pitfalls of such a query . With SASI , while the requirement to include <nl> performance pitfalls do not exist because filtering is not <nl> performed . Details on how SASI joins data from multiple predicates is <nl> available below in the <nl> - [ Implementation Details ] ( https : / / github . com / xedin / sasi # implementation - details ) <nl> + [ Implementation Details ] ( # implementation - details ) <nl> section . <nl> <nl> ` ` ` <nl> @ @ - 507 , 7 + 507 , 7 @ @ converts from Cassandra ' s internal representation of <nl> ` IndexExpression ` s , which has also been modified to support encoding <nl> queries that contain ORs and groupings of expressions using <nl> parentheses ( see the <nl> - [ Cassandra Internal Changes ] ( https : / / github . com / xedin / sasi # cassandra - internal - changes ) <nl> + [ Cassandra Internal Changes ] ( # cassandra - internal - changes ) <nl> section below for more details ) . This process produces a tree of <nl> [ ` Operation ` ] ( https : / / github . com / apache / cassandra / blob / trunk / src / java / org / apache / cassandra / index / sasi / plan / Operation . java ) s , which in turn may contain [ ` Expression ` ] ( https : / / github . com / apache / cassandra / blob / trunk / src / java / org / apache / cassandra / index / sasi / plan / Expression . java ) s , all of which <nl> provide an alternative , more efficient , representation of the query . <nl> diff - - git a / src / java / org / apache / cassandra / index / TargetParser . java b / src / java / org / apache / cassandra / index / TargetParser . java <nl> new file mode 100644 <nl> index 0000000 . . 849ad16 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / index / TargetParser . java <nl> @ @ - 0 , 0 + 1 , 90 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + package org . apache . cassandra . index ; <nl> + <nl> + import java . util . regex . Matcher ; <nl> + import java . util . regex . Pattern ; <nl> + <nl> + import org . apache . commons . lang3 . StringUtils ; <nl> + <nl> + import org . apache . cassandra . config . CFMetaData ; <nl> + import org . apache . cassandra . config . ColumnDefinition ; <nl> + import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> + import org . apache . cassandra . cql3 . statements . IndexTarget ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> + import org . apache . cassandra . schema . IndexMetadata ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> + <nl> + public class TargetParser <nl> + { <nl> + private static final Pattern TARGET _ REGEX = Pattern . compile ( " ^ ( keys | entries | values | full ) \ \ ( ( . + ) \ \ ) $ " ) ; <nl> + private static final Pattern TWO _ QUOTES = Pattern . compile ( " \ " \ " " ) ; <nl> + private static final String QUOTE = " \ " " ; <nl> + <nl> + public static Pair < ColumnDefinition , IndexTarget . Type > parse ( CFMetaData cfm , IndexMetadata indexDef ) <nl> + { <nl> + String target = indexDef . options . get ( " target " ) ; <nl> + assert target ! = null : String . format ( " No target definition found for index % s " , indexDef . name ) ; <nl> + Pair < ColumnDefinition , IndexTarget . Type > result = parse ( cfm , target ) ; <nl> + if ( result = = null ) <nl> + throw new ConfigurationException ( String . format ( " Unable to parse targets for index % s ( % s ) " , indexDef . name , target ) ) ; <nl> + return result ; <nl> + } <nl> + <nl> + public static Pair < ColumnDefinition , IndexTarget . Type > parse ( CFMetaData cfm , String target ) <nl> + { <nl> + / / if the regex matches then the target is in the form " keys ( foo ) " , " entries ( bar ) " etc <nl> + / / if not , then it must be a simple column name and implictly its type is VALUES <nl> + Matcher matcher = TARGET _ REGEX . matcher ( target ) ; <nl> + String columnName ; <nl> + IndexTarget . Type targetType ; <nl> + if ( matcher . matches ( ) ) <nl> + { <nl> + targetType = IndexTarget . Type . fromString ( matcher . group ( 1 ) ) ; <nl> + columnName = matcher . group ( 2 ) ; <nl> + } <nl> + else <nl> + { <nl> + columnName = target ; <nl> + targetType = IndexTarget . Type . VALUES ; <nl> + } <nl> + <nl> + / / in the case of a quoted column name the name in the target string <nl> + / / will be enclosed in quotes , which we need to unwrap . It may also <nl> + / / include quote characters internally , escaped like so : <nl> + / / abc " def - > abc " " def . <nl> + / / Because the target string is stored in a CQL compatible form , we <nl> + / / need to un - escape any such quotes to get the actual column name <nl> + if ( columnName . startsWith ( QUOTE ) ) <nl> + { <nl> + columnName = StringUtils . substring ( StringUtils . substring ( columnName , 1 ) , 0 , - 1 ) ; <nl> + columnName = TWO _ QUOTES . matcher ( columnName ) . replaceAll ( QUOTE ) ; <nl> + } <nl> + <nl> + / / if it ' s not a CQL table , we can ' t assume that the column name is utf8 , so <nl> + / / in that case we have to do a linear scan of the cfm ' s columns to get the matching one <nl> + if ( cfm . isCQLTable ( ) ) <nl> + return Pair . create ( cfm . getColumnDefinition ( new ColumnIdentifier ( columnName , true ) ) , targetType ) ; <nl> + else <nl> + for ( ColumnDefinition column : cfm . allColumns ( ) ) <nl> + if ( column . name . toString ( ) . equals ( columnName ) ) <nl> + return Pair . create ( column , targetType ) ; <nl> + <nl> + return null ; <nl> + } <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> index 030abf5 . . f503e59 100644 <nl> - - - a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java <nl> @ @ - 5 , 19 + 5 , 17 @ @ import java . util . * ; <nl> import java . util . concurrent . Callable ; <nl> import java . util . concurrent . Future ; <nl> import java . util . function . BiFunction ; <nl> - import java . util . regex . Matcher ; <nl> import java . util . regex . Pattern ; <nl> import java . util . stream . Collectors ; <nl> import java . util . stream . StreamSupport ; <nl> <nl> import com . google . common . collect . ImmutableSet ; <nl> - import org . apache . commons . lang3 . StringUtils ; <nl> + import org . apache . cassandra . index . TargetParser ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> import org . apache . cassandra . config . CFMetaData ; <nl> import org . apache . cassandra . config . ColumnDefinition ; <nl> - import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> import org . apache . cassandra . cql3 . Operator ; <nl> import org . apache . cassandra . cql3 . statements . IndexTarget ; <nl> import org . apache . cassandra . db . * ; <nl> @ @ - 56 , 8 + 54 , 6 @ @ public abstract class CassandraIndex implements Index <nl> { <nl> private static final Logger logger = LoggerFactory . getLogger ( CassandraIndex . class ) ; <nl> <nl> - public static final Pattern TARGET _ REGEX = Pattern . compile ( " ^ ( keys | entries | values | full ) \ \ ( ( . + ) \ \ ) $ " ) ; <nl> - <nl> public final ColumnFamilyStore baseCfs ; <nl> protected IndexMetadata metadata ; <nl> protected ColumnFamilyStore indexCfs ; <nl> @ @ - 195 , 7 + 191 , 7 @ @ public abstract class CassandraIndex implements Index <nl> private void setMetadata ( IndexMetadata indexDef ) <nl> { <nl> metadata = indexDef ; <nl> - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfs . metadata , indexDef ) ; <nl> + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfs . metadata , indexDef ) ; <nl> functions = getFunctions ( indexDef , target ) ; <nl> CFMetaData cfm = indexCfsMetadata ( baseCfs . metadata , indexDef ) ; <nl> indexCfs = ColumnFamilyStore . createColumnFamilyStore ( baseCfs . keyspace , <nl> @ @ - 708 , 7 + 704 , 7 @ @ public abstract class CassandraIndex implements Index <nl> * / <nl> public static final CFMetaData indexCfsMetadata ( CFMetaData baseCfsMetadata , IndexMetadata indexMetadata ) <nl> { <nl> - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfsMetadata , indexMetadata ) ; <nl> + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfsMetadata , indexMetadata ) ; <nl> CassandraIndexFunctions utils = getFunctions ( indexMetadata , target ) ; <nl> ColumnDefinition indexedColumn = target . left ; <nl> AbstractType < ? > indexedValueType = utils . getIndexedValueType ( indexedColumn ) ; <nl> @ @ - 752 , 57 + 748 , 7 @ @ public abstract class CassandraIndex implements Index <nl> * / <nl> public static CassandraIndex newIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexMetadata ) <nl> { <nl> - return getFunctions ( indexMetadata , parseTarget ( baseCfs . metadata , indexMetadata ) ) . newIndexInstance ( baseCfs , indexMetadata ) ; <nl> - } <nl> - <nl> - private static final Pattern TWO _ QUOTES = Pattern . compile ( " \ " \ " " ) ; <nl> - private static final String QUOTE = " \ " " ; <nl> - <nl> - / / Public because it ' s also used to convert index metadata into a thrift - compatible format <nl> - public static Pair < ColumnDefinition , IndexTarget . Type > parseTarget ( CFMetaData cfm , <nl> - IndexMetadata indexDef ) <nl> - { <nl> - String target = indexDef . options . get ( " target " ) ; <nl> - assert target ! = null : String . format ( " No target definition found for index % s " , indexDef . name ) ; <nl> - <nl> - / / if the regex matches then the target is in the form " keys ( foo ) " , " entries ( bar ) " etc <nl> - / / if not , then it must be a simple column name and implictly its type is VALUES <nl> - Matcher matcher = TARGET _ REGEX . matcher ( target ) ; <nl> - String columnName ; <nl> - IndexTarget . Type targetType ; <nl> - if ( matcher . matches ( ) ) <nl> - { <nl> - targetType = IndexTarget . Type . fromString ( matcher . group ( 1 ) ) ; <nl> - columnName = matcher . group ( 2 ) ; <nl> - } <nl> - else <nl> - { <nl> - columnName = target ; <nl> - targetType = IndexTarget . Type . VALUES ; <nl> - } <nl> - <nl> - / / in the case of a quoted column name the name in the target string <nl> - / / will be enclosed in quotes , which we need to unwrap . It may also <nl> - / / include quote characters internally , escaped like so : <nl> - / / abc " def - > abc " " def . <nl> - / / Because the target string is stored in a CQL compatible form , we <nl> - / / need to un - escape any such quotes to get the actual column name <nl> - if ( columnName . startsWith ( QUOTE ) ) <nl> - { <nl> - columnName = StringUtils . substring ( StringUtils . substring ( columnName , 1 ) , 0 , - 1 ) ; <nl> - columnName = TWO _ QUOTES . matcher ( columnName ) . replaceAll ( QUOTE ) ; <nl> - } <nl> - <nl> - / / if it ' s not a CQL table , we can ' t assume that the column name is utf8 , so <nl> - / / in that case we have to do a linear scan of the cfm ' s columns to get the matching one <nl> - if ( cfm . isCQLTable ( ) ) <nl> - return Pair . create ( cfm . getColumnDefinition ( new ColumnIdentifier ( columnName , true ) ) , targetType ) ; <nl> - else <nl> - for ( ColumnDefinition column : cfm . allColumns ( ) ) <nl> - if ( column . name . toString ( ) . equals ( columnName ) ) <nl> - return Pair . create ( column , targetType ) ; <nl> - <nl> - throw new RuntimeException ( String . format ( " Unable to parse targets for index % s ( % s ) " , indexDef . name , target ) ) ; <nl> + return getFunctions ( indexMetadata , TargetParser . parse ( baseCfs . metadata , indexMetadata ) ) . newIndexInstance ( baseCfs , indexMetadata ) ; <nl> } <nl> <nl> static CassandraIndexFunctions getFunctions ( IndexMetadata indexDef , <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / SASIIndex . java b / src / java / org / apache / cassandra / index / sasi / SASIIndex . java <nl> index 012d923 . . b460910 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / SASIIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / SASIIndex . java <nl> @ @ - 22 , 11 + 22 , 10 @ @ import java . util . concurrent . Callable ; <nl> import java . util . function . BiFunction ; <nl> <nl> import com . googlecode . concurrenttrees . common . Iterables ; <nl> - import org . apache . cassandra . config . CFMetaData ; <nl> - import org . apache . cassandra . config . ColumnDefinition ; <nl> - import org . apache . cassandra . config . DatabaseDescriptor ; <nl> - import org . apache . cassandra . config . Schema ; <nl> + <nl> + import org . apache . cassandra . config . * ; <nl> import org . apache . cassandra . cql3 . Operator ; <nl> + import org . apache . cassandra . cql3 . statements . IndexTarget ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . compaction . CompactionManager ; <nl> import org . apache . cassandra . db . compaction . OperationType ; <nl> @ @ - 36 , 12 + 35 , 15 @ @ import org . apache . cassandra . db . marshal . AbstractType ; <nl> import org . apache . cassandra . db . partitions . PartitionIterator ; <nl> import org . apache . cassandra . db . partitions . PartitionUpdate ; <nl> import org . apache . cassandra . db . rows . Row ; <nl> + import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . exceptions . InvalidRequestException ; <nl> import org . apache . cassandra . index . Index ; <nl> import org . apache . cassandra . index . IndexRegistry ; <nl> import org . apache . cassandra . index . SecondaryIndexBuilder ; <nl> - import org . apache . cassandra . index . internal . CassandraIndex ; <nl> + import org . apache . cassandra . index . TargetParser ; <nl> import org . apache . cassandra . index . sasi . conf . ColumnIndex ; <nl> + import org . apache . cassandra . index . sasi . conf . IndexMode ; <nl> + import org . apache . cassandra . index . sasi . disk . OnDiskIndexBuilder . Mode ; <nl> import org . apache . cassandra . index . sasi . disk . PerSSTableIndexWriter ; <nl> import org . apache . cassandra . index . sasi . plan . QueryPlan ; <nl> import org . apache . cassandra . index . transactions . IndexTransaction ; <nl> @ @ - 51 , 6 + 53 , 7 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; <nl> import org . apache . cassandra . notifications . * ; <nl> import org . apache . cassandra . schema . IndexMetadata ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + import org . apache . cassandra . utils . Pair ; <nl> import org . apache . cassandra . utils . concurrent . OpOrder ; <nl> <nl> public class SASIIndex implements Index , INotificationConsumer <nl> @ @ - 95 , 7 + 98 , 7 @ @ public class SASIIndex implements Index , INotificationConsumer <nl> this . baseCfs = baseCfs ; <nl> this . config = config ; <nl> <nl> - ColumnDefinition column = CassandraIndex . parseTarget ( baseCfs . metadata , config ) . left ; <nl> + ColumnDefinition column = TargetParser . parse ( baseCfs . metadata , config ) . left ; <nl> this . index = new ColumnIndex ( baseCfs . metadata . getKeyValidator ( ) , column , config ) ; <nl> <nl> Tracker tracker = baseCfs . getTracker ( ) ; <nl> @ @ - 116 , 8 + 119 , 36 @ @ public class SASIIndex implements Index , INotificationConsumer <nl> CompactionManager . instance . submitIndexBuild ( new SASIIndexBuilder ( baseCfs , toRebuild ) ) ; <nl> } <nl> <nl> - public static Map < String , String > validateOptions ( Map < String , String > options ) <nl> + public static Map < String , String > validateOptions ( Map < String , String > options , CFMetaData cfm ) <nl> { <nl> + String targetColumn = options . get ( " target " ) ; <nl> + if ( targetColumn = = null ) <nl> + throw new ConfigurationException ( " unknown target column " ) ; <nl> + <nl> + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( cfm , targetColumn ) ; <nl> + if ( target = = null ) <nl> + throw new ConfigurationException ( " failed to retrieve target column for : " + targetColumn ) ; <nl> + <nl> + IndexMode . validateAnalyzer ( options ) ; <nl> + <nl> + IndexMode mode = IndexMode . getMode ( target . left , options ) ; <nl> + if ( mode . mode = = Mode . SPARSE ) <nl> + { <nl> + if ( mode . isLiteral ) <nl> + throw new ConfigurationException ( " SPARSE mode is only supported on non - literal columns . " ) ; <nl> + <nl> + if ( mode . isAnalyzed ) <nl> + throw new ConfigurationException ( " SPARSE mode doesn ' t support analyzers . " ) ; <nl> + } <nl> + <nl> + ColumnFamilyStore store = Schema . instance . getColumnFamilyStoreIncludingIndexes ( Pair . create ( cfm . ksName , cfm . cfName ) ) ; <nl> + if ( store ! = null & & store . indexManager . listIndexes ( ) <nl> + . stream ( ) <nl> + . filter ( ( index ) - > index . dependsOn ( target . left ) <nl> + & & index . getClass ( ) . isAssignableFrom ( SASIIndex . class ) ) <nl> + . findFirst ( ) . isPresent ( ) ) <nl> + throw new ConfigurationException ( " Index on ' " + targetColumn + " ' already exists , SASI doesn ' t support multiple indexes per column . " ) ; <nl> + <nl> return Collections . emptyMap ( ) ; <nl> } <nl> <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> index 3363d21 . . 29e7c28 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java <nl> @ @ - 32 , 7 + 32 , 6 @ @ import org . apache . cassandra . db . marshal . AsciiType ; <nl> import org . apache . cassandra . db . marshal . UTF8Type ; <nl> import org . apache . cassandra . db . rows . Cell ; <nl> import org . apache . cassandra . db . rows . Row ; <nl> - import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . index . sasi . analyzer . AbstractAnalyzer ; <nl> import org . apache . cassandra . index . sasi . conf . view . View ; <nl> import org . apache . cassandra . index . sasi . disk . Token ; <nl> @ @ - 70 , 11 + 69 , 6 @ @ public class ColumnIndex <nl> this . component = new Component ( Component . Type . SECONDARY _ INDEX , String . format ( FILE _ NAME _ FORMAT , getIndexName ( ) ) ) ; <nl> } <nl> <nl> - public void validate ( ) throws ConfigurationException <nl> - { <nl> - mode . validate ( config ) ; <nl> - } <nl> - <nl> / * * <nl> * Initialize this column index with specific set of SSTables . <nl> * <nl> diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> index 41ed718 . . b9c5653 100644 <nl> - - - a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> + + + b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java <nl> @ @ - 71 , 27 + 71 , 6 @ @ public class IndexMode <nl> this . maxCompactionFlushMemoryInMb = maxFlushMemMb ; <nl> } <nl> <nl> - public void validate ( Optional < IndexMetadata > config ) throws ConfigurationException <nl> - { <nl> - if ( ! config . isPresent ( ) ) <nl> - return ; <nl> - <nl> - Map < String , String > indexOptions = config . get ( ) . options ; <nl> - / / validate that a valid analyzer class was provided if specified <nl> - if ( indexOptions . containsKey ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) <nl> - { <nl> - try <nl> - { <nl> - Class . forName ( indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; <nl> - } <nl> - catch ( ClassNotFoundException e ) <nl> - { <nl> - throw new ConfigurationException ( String . format ( " Invalid analyzer class option specified [ % s ] " , <nl> - indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> public AbstractAnalyzer getAnalyzer ( AbstractType < ? > validator ) <nl> { <nl> AbstractAnalyzer analyzer = new NoOpAnalyzer ( ) ; <nl> @ @ - 114 , 15 + 93 , 45 @ @ public class IndexMode <nl> return analyzer ; <nl> } <nl> <nl> - public static IndexMode getMode ( ColumnDefinition column , Optional < IndexMetadata > config ) <nl> + public static void validateAnalyzer ( Map < String , String > indexOptions ) throws ConfigurationException <nl> + { <nl> + / / validate that a valid analyzer class was provided if specified <nl> + if ( indexOptions . containsKey ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) <nl> + { <nl> + try <nl> + { <nl> + Class . forName ( indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; <nl> + } <nl> + catch ( ClassNotFoundException e ) <nl> + { <nl> + throw new ConfigurationException ( String . format ( " Invalid analyzer class option specified [ % s ] " , <nl> + indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ) ; <nl> + } <nl> + } <nl> + } <nl> + <nl> + public static IndexMode getMode ( ColumnDefinition column , Optional < IndexMetadata > config ) throws ConfigurationException <nl> + { <nl> + return getMode ( column , config . isPresent ( ) ? config . get ( ) . options : null ) ; <nl> + } <nl> + <nl> + public static IndexMode getMode ( ColumnDefinition column , Map < String , String > indexOptions ) throws ConfigurationException <nl> { <nl> - Map < String , String > indexOptions = config . isPresent ( ) ? config . get ( ) . options : null ; <nl> if ( indexOptions = = null | | indexOptions . isEmpty ( ) ) <nl> return IndexMode . NOT _ INDEXED ; <nl> <nl> - Mode mode = indexOptions . get ( INDEX _ MODE _ OPTION ) = = null <nl> - ? Mode . PREFIX <nl> - : Mode . mode ( indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; <nl> + Mode mode ; <nl> + <nl> + try <nl> + { <nl> + mode = indexOptions . get ( INDEX _ MODE _ OPTION ) = = null <nl> + ? Mode . PREFIX <nl> + : Mode . mode ( indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; <nl> + } <nl> + catch ( IllegalArgumentException e ) <nl> + { <nl> + throw new ConfigurationException ( " Incorrect index mode : " + indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; <nl> + } <nl> <nl> boolean isAnalyzed = false ; <nl> Class analyzerClass = null ; <nl> @ @ - 141 , 7 + 150 , 7 @ @ public class IndexMode <nl> } <nl> catch ( ClassNotFoundException e ) <nl> { <nl> - / / should not happen as we already validated we could instantiate an instance in validateOptions ( ) <nl> + / / should not happen as we already validated we could instantiate an instance in validateAnalyzer ( ) <nl> logger . error ( " Failed to find specified analyzer class [ { } ] . Falling back to default analyzer " , <nl> indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; <nl> } <nl> @ @ - 158 , 7 + 167 , 7 @ @ public class IndexMode <nl> } <nl> catch ( Exception e ) <nl> { <nl> - logger . error ( " failed to parse { } option , defaulting to ' false ' for { } index . " , INDEX _ IS _ LITERAL _ OPTION , config . get ( ) . name ) ; <nl> + logger . error ( " failed to parse { } option , defaulting to ' false ' . " , INDEX _ IS _ LITERAL _ OPTION ) ; <nl> } <nl> <nl> Long maxMemMb = indexOptions . get ( INDEX _ MAX _ FLUSH _ MEMORY _ OPTION ) = = null <nl> diff - - git a / src / java / org / apache / cassandra / thrift / ThriftConversion . java b / src / java / org / apache / cassandra / thrift / ThriftConversion . java <nl> index 3443b6e . . 35adddf 100644 <nl> - - - a / src / java / org / apache / cassandra / thrift / ThriftConversion . java <nl> + + + b / src / java / org / apache / cassandra / thrift / ThriftConversion . java <nl> @ @ - 18 , 7 + 18 , 6 @ @ <nl> package org . apache . cassandra . thrift ; <nl> <nl> import java . util . * ; <nl> - import java . util . regex . Matcher ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> import com . google . common . base . Strings ; <nl> @ @ - 35 , 7 + 34 , 7 @ @ import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; <nl> import org . apache . cassandra . db . filter . RowFilter ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> import org . apache . cassandra . exceptions . * ; <nl> - import org . apache . cassandra . index . internal . CassandraIndex ; <nl> + import org . apache . cassandra . index . TargetParser ; <nl> import org . apache . cassandra . io . compress . ICompressor ; <nl> import org . apache . cassandra . locator . AbstractReplicationStrategy ; <nl> import org . apache . cassandra . locator . LocalStrategy ; <nl> @ @ - 591 , 7 + 590 , 7 @ @ public class ThriftConversion <nl> IndexMetadata matchedIndex = null ; <nl> for ( IndexMetadata index : cfMetaData . getIndexes ( ) ) <nl> { <nl> - Pair < ColumnDefinition , IndexTarget . Type > target = CassandraIndex . parseTarget ( cfMetaData , index ) ; <nl> + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( cfMetaData , index ) ; <nl> if ( target . left . equals ( column ) ) <nl> { <nl> / / we already found an index for this column , we ' ve no option but to <nl> diff - - git a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> index 4045b6a . . 9cb2460 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> + + + b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java <nl> @ @ - 8 , 6 + 8 , 7 @ @ import java . util . function . BiFunction ; <nl> import java . util . stream . Collectors ; <nl> import java . util . stream . StreamSupport ; <nl> <nl> + import org . apache . cassandra . index . TargetParser ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 40 , 7 + 41 , 6 @ @ import org . apache . cassandra . utils . concurrent . Refs ; <nl> <nl> import static org . apache . cassandra . index . internal . CassandraIndex . getFunctions ; <nl> import static org . apache . cassandra . index . internal . CassandraIndex . indexCfsMetadata ; <nl> - import static org . apache . cassandra . index . internal . CassandraIndex . parseTarget ; <nl> <nl> / * * <nl> * Clone of KeysIndex used in CassandraIndexTest # testCustomIndexWithCFS to verify <nl> @ @ - 139 , 7 + 139 , 7 @ @ public class CustomCassandraIndex implements Index <nl> private void setMetadata ( IndexMetadata indexDef ) <nl> { <nl> metadata = indexDef ; <nl> - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfs . metadata , indexDef ) ; <nl> + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfs . metadata , indexDef ) ; <nl> functions = getFunctions ( indexDef , target ) ; <nl> CFMetaData cfm = indexCfsMetadata ( baseCfs . metadata , indexDef ) ; <nl> indexCfs = ColumnFamilyStore . createColumnFamilyStore ( baseCfs . keyspace , <nl> diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> index b32bfc5 . . bd3bb0c 100644 <nl> - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java <nl> @ @ - 1688 , 6 + 1688 , 77 @ @ public class SASIIndexTest <nl> } <nl> } <nl> <nl> + @ Test <nl> + public void testInvalidIndexOptions ( ) <nl> + { <nl> + ColumnFamilyStore store = Keyspace . open ( KS _ NAME ) . getColumnFamilyStore ( CF _ NAME ) ; <nl> + <nl> + try <nl> + { <nl> + / / invalid index mode <nl> + SASIIndex . validateOptions ( new HashMap < String , String > ( ) <nl> + { { put ( " target " , " address " ) ; put ( " mode " , " NORMAL " ) ; } } , <nl> + store . metadata ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + Assert . assertTrue ( e . getMessage ( ) . contains ( " Incorrect index mode " ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / invalid SPARSE on the literal index <nl> + SASIIndex . validateOptions ( new HashMap < String , String > ( ) <nl> + { { put ( " target " , " address " ) ; put ( " mode " , " SPARSE " ) ; } } , <nl> + store . metadata ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + Assert . assertTrue ( e . getMessage ( ) . contains ( " non - literal " ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / invalid SPARSE on the explicitly literal index <nl> + SASIIndex . validateOptions ( new HashMap < String , String > ( ) <nl> + { { put ( " target " , " height " ) ; put ( " mode " , " SPARSE " ) ; put ( " is _ literal " , " true " ) ; } } , <nl> + store . metadata ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + Assert . assertTrue ( e . getMessage ( ) . contains ( " non - literal " ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / SPARSE with analyzer <nl> + SASIIndex . validateOptions ( new HashMap < String , String > ( ) <nl> + { { put ( " target " , " height " ) ; put ( " mode " , " SPARSE " ) ; put ( " analyzed " , " true " ) ; } } , <nl> + store . metadata ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + Assert . assertTrue ( e . getMessage ( ) . contains ( " doesn ' t support analyzers " ) ) ; <nl> + } <nl> + <nl> + try <nl> + { <nl> + / / new index for column which already has a SASI index <nl> + SASIIndex . validateOptions ( new HashMap < String , String > ( ) <nl> + { { put ( " target " , " first _ name " ) ; put ( " mode " , " PREFIX " ) ; } } , <nl> + store . metadata ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( ConfigurationException e ) <nl> + { <nl> + Assert . assertTrue ( e . getMessage ( ) . contains ( " already exists " ) ) ; <nl> + } <nl> + } <nl> + <nl> private static ColumnFamilyStore loadData ( Map < String , Pair < String , Integer > > data , boolean forceFlush ) <nl> { <nl> return loadData ( data , System . currentTimeMillis ( ) , forceFlush ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> index feb2778 . . 0340fd3 100644 <nl> - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java <nl> @ @ - 34 , 7 + 34 , 7 @ @ import org . apache . cassandra . cql3 . ColumnIdentifier ; <nl> import org . apache . cassandra . cql3 . functions . * ; <nl> import org . apache . cassandra . db . * ; <nl> import org . apache . cassandra . db . marshal . * ; <nl> - import org . apache . cassandra . index . internal . CassandraIndex ; <nl> + import org . apache . cassandra . index . TargetParser ; <nl> import org . apache . cassandra . thrift . ThriftConversion ; <nl> <nl> import static java . lang . String . format ; <nl> @ @ - 681 , 7 + 681 , 7 @ @ public class LegacySchemaMigratorTest <nl> / / index targets can be parsed by CassandraIndex . parseTarget <nl> / / which should be true for any pre - 3 . 0 index <nl> for ( IndexMetadata index : indexes ) <nl> - if ( CassandraIndex . parseTarget ( table , index ) . left . equals ( column ) ) <nl> + if ( TargetParser . parse ( table , index ) . left . equals ( column ) ) <nl> return Optional . of ( index ) ; <nl> <nl> return Optional . empty ( ) ;
NEAREST DIFF (one line): ELIMINATEDSENTENCE

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index e6067a6 . . 04ce8d7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 4 
 + * SASI index options validation ( CASSANDRA - 11136 ) 
 * Optimize disk seek using min / max column name meta data when the LIMIT clause is used 
 ( CASSANDRA - 8180 ) 
 * Add LIKE support to CQL3 ( CASSANDRA - 11067 ) 
 diff - - git a / doc / SASI . md b / doc / SASI . md 
 index 90fcf65 . . a4762c9 100644 
 - - - a / doc / SASI . md 
 + + + b / doc / SASI . md 
 @ @ - 70 , 12 + 70 , 12 @ @ first being the default . The ` last _ name ` index is created with the 
 mode ` CONTAINS ` which matches terms on suffixes instead of prefix 
 only . Examples of this are available below and more detail can be 
 found in the section on 
 - [ OnDiskIndex ] ( https : / / github . com / xedin / sasi # ondiskindexbuilder ) . The 
 + [ OnDiskIndex ] ( # ondiskindexbuilder ) . The 
 ` created _ at ` column is created with its mode set to ` SPARSE ` , which is 
 meant to improve performance of querying large , dense number ranges 
 like timestamps for data inserted every millisecond . Details of the 
 ` SPARSE ` implementation can also be found in the section on the 
 - [ OnDiskIndex ] ( https : / / github . com / xedin / sasi # ondiskindexbuilder ) . The ` age ` 
 + [ OnDiskIndex ] ( # ondiskindexbuilder ) . The ` age ` 
 index is created with the default ` PREFIX ` mode and no 
 case - sensitivity or text analysis options are specified since the 
 field is numeric . 
 @ @ - 186 , 7 + 186 , 7 @ @ pitfalls of such a query . With SASI , while the requirement to include 
 performance pitfalls do not exist because filtering is not 
 performed . Details on how SASI joins data from multiple predicates is 
 available below in the 
 - [ Implementation Details ] ( https : / / github . com / xedin / sasi # implementation - details ) 
 + [ Implementation Details ] ( # implementation - details ) 
 section . 
 
 ` ` ` 
 @ @ - 507 , 7 + 507 , 7 @ @ converts from Cassandra ' s internal representation of 
 ` IndexExpression ` s , which has also been modified to support encoding 
 queries that contain ORs and groupings of expressions using 
 parentheses ( see the 
 - [ Cassandra Internal Changes ] ( https : / / github . com / xedin / sasi # cassandra - internal - changes ) 
 + [ Cassandra Internal Changes ] ( # cassandra - internal - changes ) 
 section below for more details ) . This process produces a tree of 
 [ ` Operation ` ] ( https : / / github . com / apache / cassandra / blob / trunk / src / java / org / apache / cassandra / index / sasi / plan / Operation . java ) s , which in turn may contain [ ` Expression ` ] ( https : / / github . com / apache / cassandra / blob / trunk / src / java / org / apache / cassandra / index / sasi / plan / Expression . java ) s , all of which 
 provide an alternative , more efficient , representation of the query . 
 diff - - git a / src / java / org / apache / cassandra / index / TargetParser . java b / src / java / org / apache / cassandra / index / TargetParser . java 
 new file mode 100644 
 index 0000000 . . 849ad16 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / index / TargetParser . java 
 @ @ - 0 , 0 + 1 , 90 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + package org . apache . cassandra . index ; 
 + 
 + import java . util . regex . Matcher ; 
 + import java . util . regex . Pattern ; 
 + 
 + import org . apache . commons . lang3 . StringUtils ; 
 + 
 + import org . apache . cassandra . config . CFMetaData ; 
 + import org . apache . cassandra . config . ColumnDefinition ; 
 + import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 + import org . apache . cassandra . cql3 . statements . IndexTarget ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 + import org . apache . cassandra . schema . IndexMetadata ; 
 + import org . apache . cassandra . utils . Pair ; 
 + 
 + public class TargetParser 
 + { 
 + private static final Pattern TARGET _ REGEX = Pattern . compile ( " ^ ( keys | entries | values | full ) \ \ ( ( . + ) \ \ ) $ " ) ; 
 + private static final Pattern TWO _ QUOTES = Pattern . compile ( " \ " \ " " ) ; 
 + private static final String QUOTE = " \ " " ; 
 + 
 + public static Pair < ColumnDefinition , IndexTarget . Type > parse ( CFMetaData cfm , IndexMetadata indexDef ) 
 + { 
 + String target = indexDef . options . get ( " target " ) ; 
 + assert target ! = null : String . format ( " No target definition found for index % s " , indexDef . name ) ; 
 + Pair < ColumnDefinition , IndexTarget . Type > result = parse ( cfm , target ) ; 
 + if ( result = = null ) 
 + throw new ConfigurationException ( String . format ( " Unable to parse targets for index % s ( % s ) " , indexDef . name , target ) ) ; 
 + return result ; 
 + } 
 + 
 + public static Pair < ColumnDefinition , IndexTarget . Type > parse ( CFMetaData cfm , String target ) 
 + { 
 + / / if the regex matches then the target is in the form " keys ( foo ) " , " entries ( bar ) " etc 
 + / / if not , then it must be a simple column name and implictly its type is VALUES 
 + Matcher matcher = TARGET _ REGEX . matcher ( target ) ; 
 + String columnName ; 
 + IndexTarget . Type targetType ; 
 + if ( matcher . matches ( ) ) 
 + { 
 + targetType = IndexTarget . Type . fromString ( matcher . group ( 1 ) ) ; 
 + columnName = matcher . group ( 2 ) ; 
 + } 
 + else 
 + { 
 + columnName = target ; 
 + targetType = IndexTarget . Type . VALUES ; 
 + } 
 + 
 + / / in the case of a quoted column name the name in the target string 
 + / / will be enclosed in quotes , which we need to unwrap . It may also 
 + / / include quote characters internally , escaped like so : 
 + / / abc " def - > abc " " def . 
 + / / Because the target string is stored in a CQL compatible form , we 
 + / / need to un - escape any such quotes to get the actual column name 
 + if ( columnName . startsWith ( QUOTE ) ) 
 + { 
 + columnName = StringUtils . substring ( StringUtils . substring ( columnName , 1 ) , 0 , - 1 ) ; 
 + columnName = TWO _ QUOTES . matcher ( columnName ) . replaceAll ( QUOTE ) ; 
 + } 
 + 
 + / / if it ' s not a CQL table , we can ' t assume that the column name is utf8 , so 
 + / / in that case we have to do a linear scan of the cfm ' s columns to get the matching one 
 + if ( cfm . isCQLTable ( ) ) 
 + return Pair . create ( cfm . getColumnDefinition ( new ColumnIdentifier ( columnName , true ) ) , targetType ) ; 
 + else 
 + for ( ColumnDefinition column : cfm . allColumns ( ) ) 
 + if ( column . name . toString ( ) . equals ( columnName ) ) 
 + return Pair . create ( column , targetType ) ; 
 + 
 + return null ; 
 + } 
 + } 
 diff - - git a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 index 030abf5 . . f503e59 100644 
 - - - a / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 + + + b / src / java / org / apache / cassandra / index / internal / CassandraIndex . java 
 @ @ - 5 , 19 + 5 , 17 @ @ import java . util . * ; 
 import java . util . concurrent . Callable ; 
 import java . util . concurrent . Future ; 
 import java . util . function . BiFunction ; 
 - import java . util . regex . Matcher ; 
 import java . util . regex . Pattern ; 
 import java . util . stream . Collectors ; 
 import java . util . stream . StreamSupport ; 
 
 import com . google . common . collect . ImmutableSet ; 
 - import org . apache . commons . lang3 . StringUtils ; 
 + import org . apache . cassandra . index . TargetParser ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 import org . apache . cassandra . config . CFMetaData ; 
 import org . apache . cassandra . config . ColumnDefinition ; 
 - import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 import org . apache . cassandra . cql3 . Operator ; 
 import org . apache . cassandra . cql3 . statements . IndexTarget ; 
 import org . apache . cassandra . db . * ; 
 @ @ - 56 , 8 + 54 , 6 @ @ public abstract class CassandraIndex implements Index 
 { 
 private static final Logger logger = LoggerFactory . getLogger ( CassandraIndex . class ) ; 
 
 - public static final Pattern TARGET _ REGEX = Pattern . compile ( " ^ ( keys | entries | values | full ) \ \ ( ( . + ) \ \ ) $ " ) ; 
 - 
 public final ColumnFamilyStore baseCfs ; 
 protected IndexMetadata metadata ; 
 protected ColumnFamilyStore indexCfs ; 
 @ @ - 195 , 7 + 191 , 7 @ @ public abstract class CassandraIndex implements Index 
 private void setMetadata ( IndexMetadata indexDef ) 
 { 
 metadata = indexDef ; 
 - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfs . metadata , indexDef ) ; 
 + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfs . metadata , indexDef ) ; 
 functions = getFunctions ( indexDef , target ) ; 
 CFMetaData cfm = indexCfsMetadata ( baseCfs . metadata , indexDef ) ; 
 indexCfs = ColumnFamilyStore . createColumnFamilyStore ( baseCfs . keyspace , 
 @ @ - 708 , 7 + 704 , 7 @ @ public abstract class CassandraIndex implements Index 
 * / 
 public static final CFMetaData indexCfsMetadata ( CFMetaData baseCfsMetadata , IndexMetadata indexMetadata ) 
 { 
 - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfsMetadata , indexMetadata ) ; 
 + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfsMetadata , indexMetadata ) ; 
 CassandraIndexFunctions utils = getFunctions ( indexMetadata , target ) ; 
 ColumnDefinition indexedColumn = target . left ; 
 AbstractType < ? > indexedValueType = utils . getIndexedValueType ( indexedColumn ) ; 
 @ @ - 752 , 57 + 748 , 7 @ @ public abstract class CassandraIndex implements Index 
 * / 
 public static CassandraIndex newIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexMetadata ) 
 { 
 - return getFunctions ( indexMetadata , parseTarget ( baseCfs . metadata , indexMetadata ) ) . newIndexInstance ( baseCfs , indexMetadata ) ; 
 - } 
 - 
 - private static final Pattern TWO _ QUOTES = Pattern . compile ( " \ " \ " " ) ; 
 - private static final String QUOTE = " \ " " ; 
 - 
 - / / Public because it ' s also used to convert index metadata into a thrift - compatible format 
 - public static Pair < ColumnDefinition , IndexTarget . Type > parseTarget ( CFMetaData cfm , 
 - IndexMetadata indexDef ) 
 - { 
 - String target = indexDef . options . get ( " target " ) ; 
 - assert target ! = null : String . format ( " No target definition found for index % s " , indexDef . name ) ; 
 - 
 - / / if the regex matches then the target is in the form " keys ( foo ) " , " entries ( bar ) " etc 
 - / / if not , then it must be a simple column name and implictly its type is VALUES 
 - Matcher matcher = TARGET _ REGEX . matcher ( target ) ; 
 - String columnName ; 
 - IndexTarget . Type targetType ; 
 - if ( matcher . matches ( ) ) 
 - { 
 - targetType = IndexTarget . Type . fromString ( matcher . group ( 1 ) ) ; 
 - columnName = matcher . group ( 2 ) ; 
 - } 
 - else 
 - { 
 - columnName = target ; 
 - targetType = IndexTarget . Type . VALUES ; 
 - } 
 - 
 - / / in the case of a quoted column name the name in the target string 
 - / / will be enclosed in quotes , which we need to unwrap . It may also 
 - / / include quote characters internally , escaped like so : 
 - / / abc " def - > abc " " def . 
 - / / Because the target string is stored in a CQL compatible form , we 
 - / / need to un - escape any such quotes to get the actual column name 
 - if ( columnName . startsWith ( QUOTE ) ) 
 - { 
 - columnName = StringUtils . substring ( StringUtils . substring ( columnName , 1 ) , 0 , - 1 ) ; 
 - columnName = TWO _ QUOTES . matcher ( columnName ) . replaceAll ( QUOTE ) ; 
 - } 
 - 
 - / / if it ' s not a CQL table , we can ' t assume that the column name is utf8 , so 
 - / / in that case we have to do a linear scan of the cfm ' s columns to get the matching one 
 - if ( cfm . isCQLTable ( ) ) 
 - return Pair . create ( cfm . getColumnDefinition ( new ColumnIdentifier ( columnName , true ) ) , targetType ) ; 
 - else 
 - for ( ColumnDefinition column : cfm . allColumns ( ) ) 
 - if ( column . name . toString ( ) . equals ( columnName ) ) 
 - return Pair . create ( column , targetType ) ; 
 - 
 - throw new RuntimeException ( String . format ( " Unable to parse targets for index % s ( % s ) " , indexDef . name , target ) ) ; 
 + return getFunctions ( indexMetadata , TargetParser . parse ( baseCfs . metadata , indexMetadata ) ) . newIndexInstance ( baseCfs , indexMetadata ) ; 
 } 
 
 static CassandraIndexFunctions getFunctions ( IndexMetadata indexDef , 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / SASIIndex . java b / src / java / org / apache / cassandra / index / sasi / SASIIndex . java 
 index 012d923 . . b460910 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / SASIIndex . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / SASIIndex . java 
 @ @ - 22 , 11 + 22 , 10 @ @ import java . util . concurrent . Callable ; 
 import java . util . function . BiFunction ; 
 
 import com . googlecode . concurrenttrees . common . Iterables ; 
 - import org . apache . cassandra . config . CFMetaData ; 
 - import org . apache . cassandra . config . ColumnDefinition ; 
 - import org . apache . cassandra . config . DatabaseDescriptor ; 
 - import org . apache . cassandra . config . Schema ; 
 + 
 + import org . apache . cassandra . config . * ; 
 import org . apache . cassandra . cql3 . Operator ; 
 + import org . apache . cassandra . cql3 . statements . IndexTarget ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . compaction . CompactionManager ; 
 import org . apache . cassandra . db . compaction . OperationType ; 
 @ @ - 36 , 12 + 35 , 15 @ @ import org . apache . cassandra . db . marshal . AbstractType ; 
 import org . apache . cassandra . db . partitions . PartitionIterator ; 
 import org . apache . cassandra . db . partitions . PartitionUpdate ; 
 import org . apache . cassandra . db . rows . Row ; 
 + import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . exceptions . InvalidRequestException ; 
 import org . apache . cassandra . index . Index ; 
 import org . apache . cassandra . index . IndexRegistry ; 
 import org . apache . cassandra . index . SecondaryIndexBuilder ; 
 - import org . apache . cassandra . index . internal . CassandraIndex ; 
 + import org . apache . cassandra . index . TargetParser ; 
 import org . apache . cassandra . index . sasi . conf . ColumnIndex ; 
 + import org . apache . cassandra . index . sasi . conf . IndexMode ; 
 + import org . apache . cassandra . index . sasi . disk . OnDiskIndexBuilder . Mode ; 
 import org . apache . cassandra . index . sasi . disk . PerSSTableIndexWriter ; 
 import org . apache . cassandra . index . sasi . plan . QueryPlan ; 
 import org . apache . cassandra . index . transactions . IndexTransaction ; 
 @ @ - 51 , 6 + 53 , 7 @ @ import org . apache . cassandra . io . sstable . format . SSTableReader ; 
 import org . apache . cassandra . notifications . * ; 
 import org . apache . cassandra . schema . IndexMetadata ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + import org . apache . cassandra . utils . Pair ; 
 import org . apache . cassandra . utils . concurrent . OpOrder ; 
 
 public class SASIIndex implements Index , INotificationConsumer 
 @ @ - 95 , 7 + 98 , 7 @ @ public class SASIIndex implements Index , INotificationConsumer 
 this . baseCfs = baseCfs ; 
 this . config = config ; 
 
 - ColumnDefinition column = CassandraIndex . parseTarget ( baseCfs . metadata , config ) . left ; 
 + ColumnDefinition column = TargetParser . parse ( baseCfs . metadata , config ) . left ; 
 this . index = new ColumnIndex ( baseCfs . metadata . getKeyValidator ( ) , column , config ) ; 
 
 Tracker tracker = baseCfs . getTracker ( ) ; 
 @ @ - 116 , 8 + 119 , 36 @ @ public class SASIIndex implements Index , INotificationConsumer 
 CompactionManager . instance . submitIndexBuild ( new SASIIndexBuilder ( baseCfs , toRebuild ) ) ; 
 } 
 
 - public static Map < String , String > validateOptions ( Map < String , String > options ) 
 + public static Map < String , String > validateOptions ( Map < String , String > options , CFMetaData cfm ) 
 { 
 + String targetColumn = options . get ( " target " ) ; 
 + if ( targetColumn = = null ) 
 + throw new ConfigurationException ( " unknown target column " ) ; 
 + 
 + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( cfm , targetColumn ) ; 
 + if ( target = = null ) 
 + throw new ConfigurationException ( " failed to retrieve target column for : " + targetColumn ) ; 
 + 
 + IndexMode . validateAnalyzer ( options ) ; 
 + 
 + IndexMode mode = IndexMode . getMode ( target . left , options ) ; 
 + if ( mode . mode = = Mode . SPARSE ) 
 + { 
 + if ( mode . isLiteral ) 
 + throw new ConfigurationException ( " SPARSE mode is only supported on non - literal columns . " ) ; 
 + 
 + if ( mode . isAnalyzed ) 
 + throw new ConfigurationException ( " SPARSE mode doesn ' t support analyzers . " ) ; 
 + } 
 + 
 + ColumnFamilyStore store = Schema . instance . getColumnFamilyStoreIncludingIndexes ( Pair . create ( cfm . ksName , cfm . cfName ) ) ; 
 + if ( store ! = null & & store . indexManager . listIndexes ( ) 
 + . stream ( ) 
 + . filter ( ( index ) - > index . dependsOn ( target . left ) 
 + & & index . getClass ( ) . isAssignableFrom ( SASIIndex . class ) ) 
 + . findFirst ( ) . isPresent ( ) ) 
 + throw new ConfigurationException ( " Index on ' " + targetColumn + " ' already exists , SASI doesn ' t support multiple indexes per column . " ) ; 
 + 
 return Collections . emptyMap ( ) ; 
 } 
 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 index 3363d21 . . 29e7c28 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / ColumnIndex . java 
 @ @ - 32 , 7 + 32 , 6 @ @ import org . apache . cassandra . db . marshal . AsciiType ; 
 import org . apache . cassandra . db . marshal . UTF8Type ; 
 import org . apache . cassandra . db . rows . Cell ; 
 import org . apache . cassandra . db . rows . Row ; 
 - import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . index . sasi . analyzer . AbstractAnalyzer ; 
 import org . apache . cassandra . index . sasi . conf . view . View ; 
 import org . apache . cassandra . index . sasi . disk . Token ; 
 @ @ - 70 , 11 + 69 , 6 @ @ public class ColumnIndex 
 this . component = new Component ( Component . Type . SECONDARY _ INDEX , String . format ( FILE _ NAME _ FORMAT , getIndexName ( ) ) ) ; 
 } 
 
 - public void validate ( ) throws ConfigurationException 
 - { 
 - mode . validate ( config ) ; 
 - } 
 - 
 / * * 
 * Initialize this column index with specific set of SSTables . 
 * 
 diff - - git a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 index 41ed718 . . b9c5653 100644 
 - - - a / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 + + + b / src / java / org / apache / cassandra / index / sasi / conf / IndexMode . java 
 @ @ - 71 , 27 + 71 , 6 @ @ public class IndexMode 
 this . maxCompactionFlushMemoryInMb = maxFlushMemMb ; 
 } 
 
 - public void validate ( Optional < IndexMetadata > config ) throws ConfigurationException 
 - { 
 - if ( ! config . isPresent ( ) ) 
 - return ; 
 - 
 - Map < String , String > indexOptions = config . get ( ) . options ; 
 - / / validate that a valid analyzer class was provided if specified 
 - if ( indexOptions . containsKey ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) 
 - { 
 - try 
 - { 
 - Class . forName ( indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; 
 - } 
 - catch ( ClassNotFoundException e ) 
 - { 
 - throw new ConfigurationException ( String . format ( " Invalid analyzer class option specified [ % s ] " , 
 - indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ) ; 
 - } 
 - } 
 - } 
 - 
 public AbstractAnalyzer getAnalyzer ( AbstractType < ? > validator ) 
 { 
 AbstractAnalyzer analyzer = new NoOpAnalyzer ( ) ; 
 @ @ - 114 , 15 + 93 , 45 @ @ public class IndexMode 
 return analyzer ; 
 } 
 
 - public static IndexMode getMode ( ColumnDefinition column , Optional < IndexMetadata > config ) 
 + public static void validateAnalyzer ( Map < String , String > indexOptions ) throws ConfigurationException 
 + { 
 + / / validate that a valid analyzer class was provided if specified 
 + if ( indexOptions . containsKey ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) 
 + { 
 + try 
 + { 
 + Class . forName ( indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; 
 + } 
 + catch ( ClassNotFoundException e ) 
 + { 
 + throw new ConfigurationException ( String . format ( " Invalid analyzer class option specified [ % s ] " , 
 + indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ) ; 
 + } 
 + } 
 + } 
 + 
 + public static IndexMode getMode ( ColumnDefinition column , Optional < IndexMetadata > config ) throws ConfigurationException 
 + { 
 + return getMode ( column , config . isPresent ( ) ? config . get ( ) . options : null ) ; 
 + } 
 + 
 + public static IndexMode getMode ( ColumnDefinition column , Map < String , String > indexOptions ) throws ConfigurationException 
 { 
 - Map < String , String > indexOptions = config . isPresent ( ) ? config . get ( ) . options : null ; 
 if ( indexOptions = = null | | indexOptions . isEmpty ( ) ) 
 return IndexMode . NOT _ INDEXED ; 
 
 - Mode mode = indexOptions . get ( INDEX _ MODE _ OPTION ) = = null 
 - ? Mode . PREFIX 
 - : Mode . mode ( indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; 
 + Mode mode ; 
 + 
 + try 
 + { 
 + mode = indexOptions . get ( INDEX _ MODE _ OPTION ) = = null 
 + ? Mode . PREFIX 
 + : Mode . mode ( indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; 
 + } 
 + catch ( IllegalArgumentException e ) 
 + { 
 + throw new ConfigurationException ( " Incorrect index mode : " + indexOptions . get ( INDEX _ MODE _ OPTION ) ) ; 
 + } 
 
 boolean isAnalyzed = false ; 
 Class analyzerClass = null ; 
 @ @ - 141 , 7 + 150 , 7 @ @ public class IndexMode 
 } 
 catch ( ClassNotFoundException e ) 
 { 
 - / / should not happen as we already validated we could instantiate an instance in validateOptions ( ) 
 + / / should not happen as we already validated we could instantiate an instance in validateAnalyzer ( ) 
 logger . error ( " Failed to find specified analyzer class [ { } ] . Falling back to default analyzer " , 
 indexOptions . get ( INDEX _ ANALYZER _ CLASS _ OPTION ) ) ; 
 } 
 @ @ - 158 , 7 + 167 , 7 @ @ public class IndexMode 
 } 
 catch ( Exception e ) 
 { 
 - logger . error ( " failed to parse { } option , defaulting to ' false ' for { } index . " , INDEX _ IS _ LITERAL _ OPTION , config . get ( ) . name ) ; 
 + logger . error ( " failed to parse { } option , defaulting to ' false ' . " , INDEX _ IS _ LITERAL _ OPTION ) ; 
 } 
 
 Long maxMemMb = indexOptions . get ( INDEX _ MAX _ FLUSH _ MEMORY _ OPTION ) = = null 
 diff - - git a / src / java / org / apache / cassandra / thrift / ThriftConversion . java b / src / java / org / apache / cassandra / thrift / ThriftConversion . java 
 index 3443b6e . . 35adddf 100644 
 - - - a / src / java / org / apache / cassandra / thrift / ThriftConversion . java 
 + + + b / src / java / org / apache / cassandra / thrift / ThriftConversion . java 
 @ @ - 18 , 7 + 18 , 6 @ @ 
 package org . apache . cassandra . thrift ; 
 
 import java . util . * ; 
 - import java . util . regex . Matcher ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 import com . google . common . base . Strings ; 
 @ @ - 35 , 7 + 34 , 7 @ @ import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; 
 import org . apache . cassandra . db . filter . RowFilter ; 
 import org . apache . cassandra . db . marshal . * ; 
 import org . apache . cassandra . exceptions . * ; 
 - import org . apache . cassandra . index . internal . CassandraIndex ; 
 + import org . apache . cassandra . index . TargetParser ; 
 import org . apache . cassandra . io . compress . ICompressor ; 
 import org . apache . cassandra . locator . AbstractReplicationStrategy ; 
 import org . apache . cassandra . locator . LocalStrategy ; 
 @ @ - 591 , 7 + 590 , 7 @ @ public class ThriftConversion 
 IndexMetadata matchedIndex = null ; 
 for ( IndexMetadata index : cfMetaData . getIndexes ( ) ) 
 { 
 - Pair < ColumnDefinition , IndexTarget . Type > target = CassandraIndex . parseTarget ( cfMetaData , index ) ; 
 + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( cfMetaData , index ) ; 
 if ( target . left . equals ( column ) ) 
 { 
 / / we already found an index for this column , we ' ve no option but to 
 diff - - git a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 index 4045b6a . . 9cb2460 100644 
 - - - a / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 + + + b / test / unit / org / apache / cassandra / index / internal / CustomCassandraIndex . java 
 @ @ - 8 , 6 + 8 , 7 @ @ import java . util . function . BiFunction ; 
 import java . util . stream . Collectors ; 
 import java . util . stream . StreamSupport ; 
 
 + import org . apache . cassandra . index . TargetParser ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 40 , 7 + 41 , 6 @ @ import org . apache . cassandra . utils . concurrent . Refs ; 
 
 import static org . apache . cassandra . index . internal . CassandraIndex . getFunctions ; 
 import static org . apache . cassandra . index . internal . CassandraIndex . indexCfsMetadata ; 
 - import static org . apache . cassandra . index . internal . CassandraIndex . parseTarget ; 
 
 / * * 
 * Clone of KeysIndex used in CassandraIndexTest # testCustomIndexWithCFS to verify 
 @ @ - 139 , 7 + 139 , 7 @ @ public class CustomCassandraIndex implements Index 
 private void setMetadata ( IndexMetadata indexDef ) 
 { 
 metadata = indexDef ; 
 - Pair < ColumnDefinition , IndexTarget . Type > target = parseTarget ( baseCfs . metadata , indexDef ) ; 
 + Pair < ColumnDefinition , IndexTarget . Type > target = TargetParser . parse ( baseCfs . metadata , indexDef ) ; 
 functions = getFunctions ( indexDef , target ) ; 
 CFMetaData cfm = indexCfsMetadata ( baseCfs . metadata , indexDef ) ; 
 indexCfs = ColumnFamilyStore . createColumnFamilyStore ( baseCfs . keyspace , 
 diff - - git a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 index b32bfc5 . . bd3bb0c 100644 
 - - - a / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 + + + b / test / unit / org / apache / cassandra / index / sasi / SASIIndexTest . java 
 @ @ - 1688 , 6 + 1688 , 77 @ @ public class SASIIndexTest 
 } 
 } 
 
 + @ Test 
 + public void testInvalidIndexOptions ( ) 
 + { 
 + ColumnFamilyStore store = Keyspace . open ( KS _ NAME ) . getColumnFamilyStore ( CF _ NAME ) ; 
 + 
 + try 
 + { 
 + / / invalid index mode 
 + SASIIndex . validateOptions ( new HashMap < String , String > ( ) 
 + { { put ( " target " , " address " ) ; put ( " mode " , " NORMAL " ) ; } } , 
 + store . metadata ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + Assert . assertTrue ( e . getMessage ( ) . contains ( " Incorrect index mode " ) ) ; 
 + } 
 + 
 + try 
 + { 
 + / / invalid SPARSE on the literal index 
 + SASIIndex . validateOptions ( new HashMap < String , String > ( ) 
 + { { put ( " target " , " address " ) ; put ( " mode " , " SPARSE " ) ; } } , 
 + store . metadata ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + Assert . assertTrue ( e . getMessage ( ) . contains ( " non - literal " ) ) ; 
 + } 
 + 
 + try 
 + { 
 + / / invalid SPARSE on the explicitly literal index 
 + SASIIndex . validateOptions ( new HashMap < String , String > ( ) 
 + { { put ( " target " , " height " ) ; put ( " mode " , " SPARSE " ) ; put ( " is _ literal " , " true " ) ; } } , 
 + store . metadata ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + Assert . assertTrue ( e . getMessage ( ) . contains ( " non - literal " ) ) ; 
 + } 
 + 
 + try 
 + { 
 + / / SPARSE with analyzer 
 + SASIIndex . validateOptions ( new HashMap < String , String > ( ) 
 + { { put ( " target " , " height " ) ; put ( " mode " , " SPARSE " ) ; put ( " analyzed " , " true " ) ; } } , 
 + store . metadata ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + Assert . assertTrue ( e . getMessage ( ) . contains ( " doesn ' t support analyzers " ) ) ; 
 + } 
 + 
 + try 
 + { 
 + / / new index for column which already has a SASI index 
 + SASIIndex . validateOptions ( new HashMap < String , String > ( ) 
 + { { put ( " target " , " first _ name " ) ; put ( " mode " , " PREFIX " ) ; } } , 
 + store . metadata ) ; 
 + Assert . fail ( ) ; 
 + } 
 + catch ( ConfigurationException e ) 
 + { 
 + Assert . assertTrue ( e . getMessage ( ) . contains ( " already exists " ) ) ; 
 + } 
 + } 
 + 
 private static ColumnFamilyStore loadData ( Map < String , Pair < String , Integer > > data , boolean forceFlush ) 
 { 
 return loadData ( data , System . currentTimeMillis ( ) , forceFlush ) ; 
 diff - - git a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 index feb2778 . . 0340fd3 100644 
 - - - a / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 + + + b / test / unit / org / apache / cassandra / schema / LegacySchemaMigratorTest . java 
 @ @ - 34 , 7 + 34 , 7 @ @ import org . apache . cassandra . cql3 . ColumnIdentifier ; 
 import org . apache . cassandra . cql3 . functions . * ; 
 import org . apache . cassandra . db . * ; 
 import org . apache . cassandra . db . marshal . * ; 
 - import org . apache . cassandra . index . internal . CassandraIndex ; 
 + import org . apache . cassandra . index . TargetParser ; 
 import org . apache . cassandra . thrift . ThriftConversion ; 
 
 import static java . lang . String . format ; 
 @ @ - 681 , 7 + 681 , 7 @ @ public class LegacySchemaMigratorTest 
 / / index targets can be parsed by CassandraIndex . parseTarget 
 / / which should be true for any pre - 3 . 0 index 
 for ( IndexMetadata index : indexes ) 
 - if ( CassandraIndex . parseTarget ( table , index ) . left . equals ( column ) ) 
 + if ( TargetParser . parse ( table , index ) . left . equals ( column ) ) 
 return Optional . of ( index ) ; 
 
 return Optional . empty ( ) ;

NEAREST DIFF:
ELIMINATEDSENTENCE
