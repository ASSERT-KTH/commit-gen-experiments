BLEU SCORE: 0.002509562118626863

TEST MSG: Fix assertion error in ALTER TYPE RENAME
GENERATED MSG: now that getRangeSlice doesn ' t have to deal with wrapped ranges , we can inline CFS . getRangeRows into getRangeSlice . patch by jbellis

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b1fedd2 . . be2925a 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 3 , 6 + 3 , 7 @ @ <nl> * Fix ABTC NPE ( CASSANDRA - 6692 ) <nl> * Allow nodetool to use a file or prompt for password ( CASSANDRA - 6660 ) <nl> * Fix AIOOBE when concurrently accessing ABSC ( CASSANDRA - 6742 ) <nl> + * Fix assertion error in ALTER TYPE RENAME ( CASSANDRA - 6705 ) <nl> <nl> <nl> 2 . 1 . 0 - beta1 <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> index 9c097a3 . . 51b2865 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java <nl> @ @ - 109 , 7 + 109 , 7 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> if ( cfm . isSuper ( ) ) <nl> throw new InvalidRequestException ( " Cannot use collection types with Super column family " ) ; <nl> <nl> - cfm . comparator = cfm . comparator . addCollection ( columnName , ( CollectionType ) type ) ; <nl> + cfm . comparator = cfm . comparator . addOrUpdateCollection ( columnName , ( CollectionType ) type ) ; <nl> } <nl> <nl> Integer componentIndex = cfm . comparator . isCompound ( ) ? cfm . comparator . clusteringPrefixSize ( ) : null ; <nl> @ @ - 186 , 6 + 186 , 13 @ @ public class AlterTableStatement extends SchemaAlteringStatement <nl> def . type . asCQL3Type ( ) , <nl> validator ) ) ; <nl> <nl> + / / For collections , if we alter the type , we need to update the comparator too since it includes <nl> + / / the type too ( note that isValueCompatibleWith above has validated that the need type don ' t really <nl> + / / change the underlying sorting order , but we still don ' t want to have a discrepancy between the type <nl> + / / in the comparator and the one in the ColumnDefinition as that would be dodgy ) . <nl> + if ( validator . getType ( ) instanceof CollectionType ) <nl> + cfm . comparator = cfm . comparator . addOrUpdateCollection ( def . name , ( CollectionType ) validator . getType ( ) ) ; <nl> + <nl> break ; <nl> } <nl> / / In any case , we update the column definition <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> index 61a4e35 . . 4ce9283 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java <nl> @ @ - 167 , 6 + 167 , 10 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement <nl> case CLUSTERING _ COLUMN : <nl> cfm . comparator = CellNames . fromAbstractType ( updateWith ( cfm . comparator . asAbstractType ( ) , keyspace , toReplace , updated ) , cfm . comparator . isDense ( ) ) ; <nl> break ; <nl> + default : <nl> + / / If it ' s a collection , we still want to modify the comparator because the collection is aliased in it <nl> + if ( def . type instanceof CollectionType ) <nl> + cfm . comparator = CellNames . fromAbstractType ( updateWith ( cfm . comparator . asAbstractType ( ) , keyspace , toReplace , updated ) , cfm . comparator . isDense ( ) ) ; <nl> } <nl> return true ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java b / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java <nl> index 6d4ee12 . . 22aba09 100644 <nl> - - - a / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java <nl> + + + b / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java <nl> @ @ - 198 , 7 + 198 , 7 @ @ public abstract class AbstractCellNameType extends AbstractCType implements Cell <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> <nl> - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> { <nl> throw new UnsupportedOperationException ( ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / db / composites / CellNameType . java b / src / java / org / apache / cassandra / db / composites / CellNameType . java <nl> index 7128c91 . . 6e8744a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / composites / CellNameType . java <nl> + + + b / src / java / org / apache / cassandra / db / composites / CellNameType . java <nl> @ @ - 99 , 10 + 99 , 10 @ @ public interface CellNameType extends CType <nl> public ColumnToCollectionType collectionType ( ) ; <nl> <nl> / * * <nl> - * Return the new type obtained by adding the new collection type for the provided column name <nl> + * Return the new type obtained by adding / updating to the new collection type for the provided column name <nl> * to this type . <nl> * / <nl> - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) ; <nl> + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) ; <nl> <nl> / * * <nl> * Returns a new CellNameType that is equivalent to this one but with one <nl> diff - - git a / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java b / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java <nl> index e0cbc0f . . 44acf21 100644 <nl> - - - a / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java <nl> + + + b / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java <nl> @ @ - 122 , 7 + 122 , 7 @ @ public class CompoundSparseCellNameType extends AbstractCompoundCellNameType <nl> } <nl> <nl> @ Override <nl> - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> { <nl> return new WithCollection ( clusteringType , ColumnToCollectionType . getInstance ( Collections . singletonMap ( columnName . bytes , newCollection ) ) , internedIds ) ; <nl> } <nl> @ @ - 244 , 7 + 244 , 7 @ @ public class CompoundSparseCellNameType extends AbstractCompoundCellNameType <nl> } <nl> <nl> @ Override <nl> - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) <nl> { <nl> Map < ByteBuffer , CollectionType > newMap = new HashMap < > ( collectionType . defined ) ; <nl> newMap . put ( columnName . bytes , newCollection ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / CollectionType . java b / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> index b9816a6 . . fe672e4 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / CollectionType . java <nl> @ @ - 94 , 6 + 94 , 22 @ @ public abstract class CollectionType < T > extends AbstractType < T > <nl> valueComparator ( ) . validate ( bytes ) ; <nl> } <nl> <nl> + @ Override <nl> + public boolean isCompatibleWith ( AbstractType < ? > previous ) <nl> + { <nl> + if ( this = = previous ) <nl> + return true ; <nl> + <nl> + if ( ! getClass ( ) . equals ( previous . getClass ( ) ) ) <nl> + return false ; <nl> + <nl> + CollectionType tprev = ( CollectionType ) previous ; <nl> + / / The name is part of the Cell name , so we need sorting compatibility , i . e . isCompatibleWith ( ) . <nl> + / / But value is the Cell value , so isValueCompatibleWith ( ) is enough <nl> + return this . nameComparator ( ) . isCompatibleWith ( tprev . nameComparator ( ) ) <nl> + & & this . valueComparator ( ) . isValueCompatibleWith ( tprev . valueComparator ( ) ) ; <nl> + } <nl> + <nl> public boolean isCollection ( ) <nl> { <nl> return true ; <nl> diff - - git a / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java b / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java <nl> index a4f7857 . . a28b874 100644 <nl> - - - a / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java <nl> + + + b / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java <nl> @ @ - 121 , 7 + 121 , 8 @ @ public class ColumnToCollectionType extends AbstractType < ByteBuffer > <nl> / / We are compatible if we have all the definitions previous have ( but we can have more ) . <nl> for ( Map . Entry < ByteBuffer , CollectionType > entry : prev . defined . entrySet ( ) ) <nl> { <nl> - if ( ! entry . getValue ( ) . isCompatibleWith ( defined . get ( entry . getKey ( ) ) ) ) <nl> + CollectionType newType = defined . get ( entry . getKey ( ) ) ; <nl> + if ( newType = = null | | ! newType . isCompatibleWith ( entry . getValue ( ) ) ) <nl> return false ; <nl> } <nl> return true ;
NEAREST DIFF (one line): diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 964ca78 . . d331172 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 974 , 16 + 974 , 20 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> / * * <nl> * Fetch a range of rows and columns from memtables / sstables . <nl> * <nl> - * @ param rows The resulting rows fetched during this operation <nl> - * @ param superColumn Super column to filter by <nl> + * @ param superColumn optional SuperColumn to slice subcolumns of ; null to slice top - level columns <nl> * @ param range Either a Bounds , which includes start key , or a Range , which does not . <nl> * @ param maxResults Maximum rows to return <nl> * @ param columnFilter description of the columns we ' re interested in for each row <nl> * @ return true if we found all keys we were looking for , otherwise false <nl> * / <nl> - private void getRangeRows ( List < Row > rows , byte [ ] superColumn , final AbstractBounds range , int maxResults , IFilter columnFilter ) <nl> + public List < Row > getRangeSlice ( byte [ ] superColumn , final AbstractBounds range , int maxResults , IFilter columnFilter ) <nl> throws ExecutionException , InterruptedException <nl> { <nl> + assert range instanceof Bounds <nl> + | | ( ! ( ( Range ) range ) . isWrapAround ( ) | | range . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ) <nl> + : range ; <nl> + <nl> + List < Row > rows = new ArrayList < Row > ( ) ; <nl> final DecoratedKey startWith = new DecoratedKey ( range . left , ( byte [ ] ) null ) ; <nl> final DecoratedKey stopAt = new DecoratedKey ( range . right , ( byte [ ] ) null ) ; <nl> <nl> @ @ - 1011 , 7 + 1015 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> DecoratedKey key = current . key ; <nl> <nl> if ( ! stopAt . isEmpty ( ) & & stopAt . compareTo ( key ) < 0 ) <nl> - return ; <nl> + return rows ; <nl> <nl> / / skip first one <nl> if ( range instanceof Bounds | | ! first | | ! key . equals ( startWith ) ) <nl> @ @ - 1023 , 7 + 1027 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> first = false ; <nl> <nl> if ( rows . size ( ) > = maxResults ) <nl> - return ; <nl> + return rows ; <nl> } <nl> } <nl> finally <nl> @ @ - 1037 , 25 + 1041 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> throw new IOError ( e ) ; <nl> } <nl> } <nl> - } <nl> <nl> - / * * <nl> - * <nl> - * @ param super _ column <nl> - * @ param range : either a Bounds , which includes start key , or a Range , which does not . <nl> - * @ param keyMax maximum number of keys to process , regardless of startKey / finishKey <nl> - * @ param columnFilter description of the columns we ' re interested in for each row <nl> - * @ throws ExecutionException <nl> - * @ throws InterruptedException <nl> - * / <nl> - public List < Row > getRangeSlice ( byte [ ] super _ column , final AbstractBounds range , int keyMax , IFilter columnFilter ) <nl> - throws ExecutionException , InterruptedException <nl> - { <nl> - List < Row > rows = new ArrayList < Row > ( ) ; <nl> - assert range instanceof Bounds <nl> - | | ( ! ( ( Range ) range ) . isWrapAround ( ) | | range . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ) <nl> - : range ; <nl> - getRangeRows ( rows , super _ column , range , keyMax , columnFilter ) ; <nl> return rows ; <nl> } <nl>

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b1fedd2 . . be2925a 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 3 , 6 + 3 , 7 @ @ 
 * Fix ABTC NPE ( CASSANDRA - 6692 ) 
 * Allow nodetool to use a file or prompt for password ( CASSANDRA - 6660 ) 
 * Fix AIOOBE when concurrently accessing ABSC ( CASSANDRA - 6742 ) 
 + * Fix assertion error in ALTER TYPE RENAME ( CASSANDRA - 6705 ) 
 
 
 2 . 1 . 0 - beta1 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 index 9c097a3 . . 51b2865 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTableStatement . java 
 @ @ - 109 , 7 + 109 , 7 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 if ( cfm . isSuper ( ) ) 
 throw new InvalidRequestException ( " Cannot use collection types with Super column family " ) ; 
 
 - cfm . comparator = cfm . comparator . addCollection ( columnName , ( CollectionType ) type ) ; 
 + cfm . comparator = cfm . comparator . addOrUpdateCollection ( columnName , ( CollectionType ) type ) ; 
 } 
 
 Integer componentIndex = cfm . comparator . isCompound ( ) ? cfm . comparator . clusteringPrefixSize ( ) : null ; 
 @ @ - 186 , 6 + 186 , 13 @ @ public class AlterTableStatement extends SchemaAlteringStatement 
 def . type . asCQL3Type ( ) , 
 validator ) ) ; 
 
 + / / For collections , if we alter the type , we need to update the comparator too since it includes 
 + / / the type too ( note that isValueCompatibleWith above has validated that the need type don ' t really 
 + / / change the underlying sorting order , but we still don ' t want to have a discrepancy between the type 
 + / / in the comparator and the one in the ColumnDefinition as that would be dodgy ) . 
 + if ( validator . getType ( ) instanceof CollectionType ) 
 + cfm . comparator = cfm . comparator . addOrUpdateCollection ( def . name , ( CollectionType ) validator . getType ( ) ) ; 
 + 
 break ; 
 } 
 / / In any case , we update the column definition 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 index 61a4e35 . . 4ce9283 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / AlterTypeStatement . java 
 @ @ - 167 , 6 + 167 , 10 @ @ public abstract class AlterTypeStatement extends SchemaAlteringStatement 
 case CLUSTERING _ COLUMN : 
 cfm . comparator = CellNames . fromAbstractType ( updateWith ( cfm . comparator . asAbstractType ( ) , keyspace , toReplace , updated ) , cfm . comparator . isDense ( ) ) ; 
 break ; 
 + default : 
 + / / If it ' s a collection , we still want to modify the comparator because the collection is aliased in it 
 + if ( def . type instanceof CollectionType ) 
 + cfm . comparator = CellNames . fromAbstractType ( updateWith ( cfm . comparator . asAbstractType ( ) , keyspace , toReplace , updated ) , cfm . comparator . isDense ( ) ) ; 
 } 
 return true ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java b / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java 
 index 6d4ee12 . . 22aba09 100644 
 - - - a / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java 
 + + + b / src / java / org / apache / cassandra / db / composites / AbstractCellNameType . java 
 @ @ - 198 , 7 + 198 , 7 @ @ public abstract class AbstractCellNameType extends AbstractCType implements Cell 
 throw new UnsupportedOperationException ( ) ; 
 } 
 
 - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 { 
 throw new UnsupportedOperationException ( ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / db / composites / CellNameType . java b / src / java / org / apache / cassandra / db / composites / CellNameType . java 
 index 7128c91 . . 6e8744a 100644 
 - - - a / src / java / org / apache / cassandra / db / composites / CellNameType . java 
 + + + b / src / java / org / apache / cassandra / db / composites / CellNameType . java 
 @ @ - 99 , 10 + 99 , 10 @ @ public interface CellNameType extends CType 
 public ColumnToCollectionType collectionType ( ) ; 
 
 / * * 
 - * Return the new type obtained by adding the new collection type for the provided column name 
 + * Return the new type obtained by adding / updating to the new collection type for the provided column name 
 * to this type . 
 * / 
 - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) ; 
 + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) ; 
 
 / * * 
 * Returns a new CellNameType that is equivalent to this one but with one 
 diff - - git a / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java b / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java 
 index e0cbc0f . . 44acf21 100644 
 - - - a / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java 
 + + + b / src / java / org / apache / cassandra / db / composites / CompoundSparseCellNameType . java 
 @ @ - 122 , 7 + 122 , 7 @ @ public class CompoundSparseCellNameType extends AbstractCompoundCellNameType 
 } 
 
 @ Override 
 - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 { 
 return new WithCollection ( clusteringType , ColumnToCollectionType . getInstance ( Collections . singletonMap ( columnName . bytes , newCollection ) ) , internedIds ) ; 
 } 
 @ @ - 244 , 7 + 244 , 7 @ @ public class CompoundSparseCellNameType extends AbstractCompoundCellNameType 
 } 
 
 @ Override 
 - public CellNameType addCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 + public CellNameType addOrUpdateCollection ( ColumnIdentifier columnName , CollectionType newCollection ) 
 { 
 Map < ByteBuffer , CollectionType > newMap = new HashMap < > ( collectionType . defined ) ; 
 newMap . put ( columnName . bytes , newCollection ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / CollectionType . java b / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 index b9816a6 . . fe672e4 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / CollectionType . java 
 @ @ - 94 , 6 + 94 , 22 @ @ public abstract class CollectionType < T > extends AbstractType < T > 
 valueComparator ( ) . validate ( bytes ) ; 
 } 
 
 + @ Override 
 + public boolean isCompatibleWith ( AbstractType < ? > previous ) 
 + { 
 + if ( this = = previous ) 
 + return true ; 
 + 
 + if ( ! getClass ( ) . equals ( previous . getClass ( ) ) ) 
 + return false ; 
 + 
 + CollectionType tprev = ( CollectionType ) previous ; 
 + / / The name is part of the Cell name , so we need sorting compatibility , i . e . isCompatibleWith ( ) . 
 + / / But value is the Cell value , so isValueCompatibleWith ( ) is enough 
 + return this . nameComparator ( ) . isCompatibleWith ( tprev . nameComparator ( ) ) 
 + & & this . valueComparator ( ) . isValueCompatibleWith ( tprev . valueComparator ( ) ) ; 
 + } 
 + 
 public boolean isCollection ( ) 
 { 
 return true ; 
 diff - - git a / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java b / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java 
 index a4f7857 . . a28b874 100644 
 - - - a / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java 
 + + + b / src / java / org / apache / cassandra / db / marshal / ColumnToCollectionType . java 
 @ @ - 121 , 7 + 121 , 8 @ @ public class ColumnToCollectionType extends AbstractType < ByteBuffer > 
 / / We are compatible if we have all the definitions previous have ( but we can have more ) . 
 for ( Map . Entry < ByteBuffer , CollectionType > entry : prev . defined . entrySet ( ) ) 
 { 
 - if ( ! entry . getValue ( ) . isCompatibleWith ( defined . get ( entry . getKey ( ) ) ) ) 
 + CollectionType newType = defined . get ( entry . getKey ( ) ) ; 
 + if ( newType = = null | | ! newType . isCompatibleWith ( entry . getValue ( ) ) ) 
 return false ; 
 } 
 return true ;

NEAREST DIFF:
diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 964ca78 . . d331172 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 974 , 16 + 974 , 20 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 / * * 
 * Fetch a range of rows and columns from memtables / sstables . 
 * 
 - * @ param rows The resulting rows fetched during this operation 
 - * @ param superColumn Super column to filter by 
 + * @ param superColumn optional SuperColumn to slice subcolumns of ; null to slice top - level columns 
 * @ param range Either a Bounds , which includes start key , or a Range , which does not . 
 * @ param maxResults Maximum rows to return 
 * @ param columnFilter description of the columns we ' re interested in for each row 
 * @ return true if we found all keys we were looking for , otherwise false 
 * / 
 - private void getRangeRows ( List < Row > rows , byte [ ] superColumn , final AbstractBounds range , int maxResults , IFilter columnFilter ) 
 + public List < Row > getRangeSlice ( byte [ ] superColumn , final AbstractBounds range , int maxResults , IFilter columnFilter ) 
 throws ExecutionException , InterruptedException 
 { 
 + assert range instanceof Bounds 
 + | | ( ! ( ( Range ) range ) . isWrapAround ( ) | | range . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ) 
 + : range ; 
 + 
 + List < Row > rows = new ArrayList < Row > ( ) ; 
 final DecoratedKey startWith = new DecoratedKey ( range . left , ( byte [ ] ) null ) ; 
 final DecoratedKey stopAt = new DecoratedKey ( range . right , ( byte [ ] ) null ) ; 
 
 @ @ - 1011 , 7 + 1015 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 DecoratedKey key = current . key ; 
 
 if ( ! stopAt . isEmpty ( ) & & stopAt . compareTo ( key ) < 0 ) 
 - return ; 
 + return rows ; 
 
 / / skip first one 
 if ( range instanceof Bounds | | ! first | | ! key . equals ( startWith ) ) 
 @ @ - 1023 , 7 + 1027 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 first = false ; 
 
 if ( rows . size ( ) > = maxResults ) 
 - return ; 
 + return rows ; 
 } 
 } 
 finally 
 @ @ - 1037 , 25 + 1041 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 throw new IOError ( e ) ; 
 } 
 } 
 - } 
 
 - / * * 
 - * 
 - * @ param super _ column 
 - * @ param range : either a Bounds , which includes start key , or a Range , which does not . 
 - * @ param keyMax maximum number of keys to process , regardless of startKey / finishKey 
 - * @ param columnFilter description of the columns we ' re interested in for each row 
 - * @ throws ExecutionException 
 - * @ throws InterruptedException 
 - * / 
 - public List < Row > getRangeSlice ( byte [ ] super _ column , final AbstractBounds range , int keyMax , IFilter columnFilter ) 
 - throws ExecutionException , InterruptedException 
 - { 
 - List < Row > rows = new ArrayList < Row > ( ) ; 
 - assert range instanceof Bounds 
 - | | ( ! ( ( Range ) range ) . isWrapAround ( ) | | range . right . equals ( StorageService . getPartitioner ( ) . getMinimumToken ( ) ) ) 
 - : range ; 
 - getRangeRows ( rows , super _ column , range , keyMax , columnFilter ) ; 
 return rows ; 
 } 

