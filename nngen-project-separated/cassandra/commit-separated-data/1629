BLEU SCORE: 0.028465126651392333

TEST MSG: Make Functions . declared thread - safe
GENERATED MSG: Allow accessing column timestamp and ttl in CQL3

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 325a5f3 . . 0efba98 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 <nl> + * Make Functions . declared thread - safe <nl> * Add client warnings to native protocol v4 ( CASSANDRA - 8930 ) <nl> * Allow roles cache to be invalidated ( CASSANDRA - 8967 ) <nl> * Upgrade Snappy ( CASSANDRA - 9063 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / functions / Functions . java b / src / java / org / apache / cassandra / cql3 / functions / Functions . java <nl> index bc0b9d9 . . 7ac8039 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / functions / Functions . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / functions / Functions . java <nl> @ @ - 19 , 9 + 19 , 11 @ @ package org . apache . cassandra . cql3 . functions ; <nl> <nl> import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> + import java . util . Collections ; <nl> import java . util . List ; <nl> - <nl> - import com . google . common . collect . ArrayListMultimap ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . ConcurrentMap ; <nl> + import java . util . concurrent . CopyOnWriteArrayList ; <nl> <nl> import org . apache . cassandra . config . Schema ; <nl> import org . apache . cassandra . cql3 . * ; <nl> @ @ - 39 , 7 + 41 , 7 @ @ public abstract class Functions <nl> <nl> private Functions ( ) { } <nl> <nl> - private static final ArrayListMultimap < FunctionName , Function > declared = ArrayListMultimap . create ( ) ; <nl> + private static final ConcurrentMap < FunctionName , List < Function > > declared = new ConcurrentHashMap < > ( ) ; <nl> <nl> static <nl> { <nl> @ @ - 85 , 20 + 87 , 31 @ @ public abstract class Functions <nl> <nl> private static void declare ( Function fun ) <nl> { <nl> - declared . put ( fun . name ( ) , fun ) ; <nl> + synchronized ( declared ) <nl> + { <nl> + List < Function > functions = declared . get ( fun . name ( ) ) ; <nl> + if ( functions = = null ) <nl> + { <nl> + functions = new CopyOnWriteArrayList < > ( ) ; <nl> + List < Function > existing = declared . putIfAbsent ( fun . name ( ) , functions ) ; <nl> + if ( existing ! = null ) <nl> + functions = existing ; <nl> + } <nl> + functions . add ( fun ) ; <nl> + } <nl> } <nl> <nl> public static ColumnSpecification makeArgSpec ( String receiverKs , String receiverCf , Function fun , int i ) <nl> { <nl> return new ColumnSpecification ( receiverKs , <nl> receiverCf , <nl> - new ColumnIdentifier ( " arg " + i + " ( " + fun . name ( ) . toString ( ) . toLowerCase ( ) + " ) " , true ) , <nl> + new ColumnIdentifier ( " arg " + i + ' ( ' + fun . name ( ) . toString ( ) . toLowerCase ( ) + ' ) ' , true ) , <nl> fun . argTypes ( ) . get ( i ) ) ; <nl> } <nl> <nl> public static int getOverloadCount ( FunctionName name ) <nl> { <nl> - return declared . get ( name ) . size ( ) ; <nl> + return find ( name ) . size ( ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 142 , 13 + 155 , 13 @ @ public abstract class Functions <nl> / / function name not fully qualified <nl> candidates = new ArrayList < > ( ) ; <nl> / / add ' SYSTEM ' ( native ) candidates <nl> - candidates . addAll ( declared . get ( name . asNativeFunction ( ) ) ) ; <nl> + candidates . addAll ( find ( name . asNativeFunction ( ) ) ) ; <nl> / / add ' current keyspace ' candidates <nl> - candidates . addAll ( declared . get ( new FunctionName ( keyspace , name . name ) ) ) ; <nl> + candidates . addAll ( find ( new FunctionName ( keyspace , name . name ) ) ) ; <nl> } <nl> else <nl> / / function name is fully qualified ( keyspace + name ) <nl> - candidates = declared . get ( name ) ; <nl> + candidates = find ( name ) ; <nl> <nl> if ( candidates . isEmpty ( ) ) <nl> return null ; <nl> @ @ - 191 , 13 + 204 , 14 @ @ public abstract class Functions <nl> <nl> public static List < Function > find ( FunctionName name ) <nl> { <nl> - return declared . get ( name ) ; <nl> + List < Function > functions = declared . get ( name ) ; <nl> + return functions ! = null ? functions : Collections . < Function > emptyList ( ) ; <nl> } <nl> <nl> public static Function find ( FunctionName name , List < AbstractType < ? > > argTypes ) <nl> { <nl> assert name . hasKeyspace ( ) : " function name not fully qualified " ; <nl> - for ( Function f : declared . get ( name ) ) <nl> + for ( Function f : find ( name ) ) <nl> { <nl> if ( typeEquals ( f . argTypes ( ) , argTypes ) ) <nl> return f ; <nl> @ @ - 282 , 11 + 296 , 25 @ @ public abstract class Functions <nl> } <nl> <nl> / / Same remarks than for addFunction <nl> - public static void removeFunction ( FunctionName name , List < AbstractType < ? > > argsTypes ) <nl> + public static void removeFunction ( FunctionName name , List < AbstractType < ? > > argTypes ) <nl> { <nl> - Function old = find ( name , argsTypes ) ; <nl> - assert old ! = null & & ! old . isNative ( ) ; <nl> - declared . remove ( old . name ( ) , old ) ; <nl> + assert name . hasKeyspace ( ) : " function name " + name + " not fully qualified " ; <nl> + synchronized ( declared ) <nl> + { <nl> + List < Function > functions = find ( name ) ; <nl> + for ( int i = 0 ; i < functions . size ( ) ; i + + ) <nl> + { <nl> + Function f = functions . get ( i ) ; <nl> + if ( ! typeEquals ( f . argTypes ( ) , argTypes ) ) <nl> + continue ; <nl> + assert ! f . isNative ( ) ; <nl> + functions . remove ( i ) ; <nl> + if ( functions . isEmpty ( ) ) <nl> + declared . remove ( name ) ; <nl> + return ; <nl> + } <nl> + assert false : " Function " + name + " not declared " ; <nl> + } <nl> } <nl> <nl> / / Same remarks than for addFunction <nl> @ @ - 299 , 15 + 327 , 19 @ @ public abstract class Functions <nl> public static List < Function > getReferencesTo ( Function old ) <nl> { <nl> List < Function > references = new ArrayList < > ( ) ; <nl> - for ( Function function : declared . values ( ) ) <nl> - if ( function . hasReferenceTo ( old ) ) <nl> - references . add ( function ) ; <nl> + for ( List < Function > functions : declared . values ( ) ) <nl> + for ( Function function : functions ) <nl> + if ( function . hasReferenceTo ( old ) ) <nl> + references . add ( function ) ; <nl> return references ; <nl> } <nl> <nl> public static Collection < Function > all ( ) <nl> { <nl> - return declared . values ( ) ; <nl> + List < Function > all = new ArrayList < > ( ) ; <nl> + for ( List < Function > functions : declared . values ( ) ) <nl> + all . addAll ( functions ) ; <nl> + return all ; <nl> } <nl> <nl> public static boolean typeEquals ( AbstractType < ? > t1 , AbstractType < ? > t2 )
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 487f388 . . 8c58af7 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 62 , 6 + 62 , 7 @ @ <nl> * Fix exception on colum metadata with non - string comparator ( CASSANDRA - 4269 ) <nl> * Check for unknown / invalid compression options ( CASSANDRA - 4266 ) <nl> * ( cql3 ) Adds simple access to column timestamp and ttl ( CASSANDRA - 4217 ) <nl> + * ( cql3 ) Fix range queries with secondary indexes ( CASSANDRA - 4257 ) <nl> Merged from 1 . 0 : <nl> * Fix super columns bug where cache is not updated ( CASSANDRA - 4190 ) <nl> * fix maxTimestamp to include row tombstones ( CASSANDRA - 4116 ) <nl> diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> index d7089f9 . . 26f082b 100644 <nl> - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java <nl> @ @ - 546 , 8 + 546 , 11 @ @ public class SelectStatement implements CQLStatement <nl> { <nl> for ( Bound b : Bound . values ( ) ) <nl> { <nl> - ByteBuffer value = restriction . bound ( b ) . getByteBuffer ( name . type , variables ) ; <nl> - expressions . add ( new IndexExpression ( name . name . key , restriction . getIndexOperator ( b ) , value ) ) ; <nl> + if ( restriction . bound ( b ) ! = null ) <nl> + { <nl> + ByteBuffer value = restriction . bound ( b ) . getByteBuffer ( name . type , variables ) ; <nl> + expressions . add ( new IndexExpression ( name . name . key , restriction . getIndexOperator ( b ) , value ) ) ; <nl> + } <nl> } <nl> } <nl> }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 325a5f3 . . 0efba98 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 
 + * Make Functions . declared thread - safe 
 * Add client warnings to native protocol v4 ( CASSANDRA - 8930 ) 
 * Allow roles cache to be invalidated ( CASSANDRA - 8967 ) 
 * Upgrade Snappy ( CASSANDRA - 9063 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / functions / Functions . java b / src / java / org / apache / cassandra / cql3 / functions / Functions . java 
 index bc0b9d9 . . 7ac8039 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / functions / Functions . java 
 + + + b / src / java / org / apache / cassandra / cql3 / functions / Functions . java 
 @ @ - 19 , 9 + 19 , 11 @ @ package org . apache . cassandra . cql3 . functions ; 
 
 import java . util . ArrayList ; 
 import java . util . Collection ; 
 + import java . util . Collections ; 
 import java . util . List ; 
 - 
 - import com . google . common . collect . ArrayListMultimap ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . ConcurrentMap ; 
 + import java . util . concurrent . CopyOnWriteArrayList ; 
 
 import org . apache . cassandra . config . Schema ; 
 import org . apache . cassandra . cql3 . * ; 
 @ @ - 39 , 7 + 41 , 7 @ @ public abstract class Functions 
 
 private Functions ( ) { } 
 
 - private static final ArrayListMultimap < FunctionName , Function > declared = ArrayListMultimap . create ( ) ; 
 + private static final ConcurrentMap < FunctionName , List < Function > > declared = new ConcurrentHashMap < > ( ) ; 
 
 static 
 { 
 @ @ - 85 , 20 + 87 , 31 @ @ public abstract class Functions 
 
 private static void declare ( Function fun ) 
 { 
 - declared . put ( fun . name ( ) , fun ) ; 
 + synchronized ( declared ) 
 + { 
 + List < Function > functions = declared . get ( fun . name ( ) ) ; 
 + if ( functions = = null ) 
 + { 
 + functions = new CopyOnWriteArrayList < > ( ) ; 
 + List < Function > existing = declared . putIfAbsent ( fun . name ( ) , functions ) ; 
 + if ( existing ! = null ) 
 + functions = existing ; 
 + } 
 + functions . add ( fun ) ; 
 + } 
 } 
 
 public static ColumnSpecification makeArgSpec ( String receiverKs , String receiverCf , Function fun , int i ) 
 { 
 return new ColumnSpecification ( receiverKs , 
 receiverCf , 
 - new ColumnIdentifier ( " arg " + i + " ( " + fun . name ( ) . toString ( ) . toLowerCase ( ) + " ) " , true ) , 
 + new ColumnIdentifier ( " arg " + i + ' ( ' + fun . name ( ) . toString ( ) . toLowerCase ( ) + ' ) ' , true ) , 
 fun . argTypes ( ) . get ( i ) ) ; 
 } 
 
 public static int getOverloadCount ( FunctionName name ) 
 { 
 - return declared . get ( name ) . size ( ) ; 
 + return find ( name ) . size ( ) ; 
 } 
 
 / * * 
 @ @ - 142 , 13 + 155 , 13 @ @ public abstract class Functions 
 / / function name not fully qualified 
 candidates = new ArrayList < > ( ) ; 
 / / add ' SYSTEM ' ( native ) candidates 
 - candidates . addAll ( declared . get ( name . asNativeFunction ( ) ) ) ; 
 + candidates . addAll ( find ( name . asNativeFunction ( ) ) ) ; 
 / / add ' current keyspace ' candidates 
 - candidates . addAll ( declared . get ( new FunctionName ( keyspace , name . name ) ) ) ; 
 + candidates . addAll ( find ( new FunctionName ( keyspace , name . name ) ) ) ; 
 } 
 else 
 / / function name is fully qualified ( keyspace + name ) 
 - candidates = declared . get ( name ) ; 
 + candidates = find ( name ) ; 
 
 if ( candidates . isEmpty ( ) ) 
 return null ; 
 @ @ - 191 , 13 + 204 , 14 @ @ public abstract class Functions 
 
 public static List < Function > find ( FunctionName name ) 
 { 
 - return declared . get ( name ) ; 
 + List < Function > functions = declared . get ( name ) ; 
 + return functions ! = null ? functions : Collections . < Function > emptyList ( ) ; 
 } 
 
 public static Function find ( FunctionName name , List < AbstractType < ? > > argTypes ) 
 { 
 assert name . hasKeyspace ( ) : " function name not fully qualified " ; 
 - for ( Function f : declared . get ( name ) ) 
 + for ( Function f : find ( name ) ) 
 { 
 if ( typeEquals ( f . argTypes ( ) , argTypes ) ) 
 return f ; 
 @ @ - 282 , 11 + 296 , 25 @ @ public abstract class Functions 
 } 
 
 / / Same remarks than for addFunction 
 - public static void removeFunction ( FunctionName name , List < AbstractType < ? > > argsTypes ) 
 + public static void removeFunction ( FunctionName name , List < AbstractType < ? > > argTypes ) 
 { 
 - Function old = find ( name , argsTypes ) ; 
 - assert old ! = null & & ! old . isNative ( ) ; 
 - declared . remove ( old . name ( ) , old ) ; 
 + assert name . hasKeyspace ( ) : " function name " + name + " not fully qualified " ; 
 + synchronized ( declared ) 
 + { 
 + List < Function > functions = find ( name ) ; 
 + for ( int i = 0 ; i < functions . size ( ) ; i + + ) 
 + { 
 + Function f = functions . get ( i ) ; 
 + if ( ! typeEquals ( f . argTypes ( ) , argTypes ) ) 
 + continue ; 
 + assert ! f . isNative ( ) ; 
 + functions . remove ( i ) ; 
 + if ( functions . isEmpty ( ) ) 
 + declared . remove ( name ) ; 
 + return ; 
 + } 
 + assert false : " Function " + name + " not declared " ; 
 + } 
 } 
 
 / / Same remarks than for addFunction 
 @ @ - 299 , 15 + 327 , 19 @ @ public abstract class Functions 
 public static List < Function > getReferencesTo ( Function old ) 
 { 
 List < Function > references = new ArrayList < > ( ) ; 
 - for ( Function function : declared . values ( ) ) 
 - if ( function . hasReferenceTo ( old ) ) 
 - references . add ( function ) ; 
 + for ( List < Function > functions : declared . values ( ) ) 
 + for ( Function function : functions ) 
 + if ( function . hasReferenceTo ( old ) ) 
 + references . add ( function ) ; 
 return references ; 
 } 
 
 public static Collection < Function > all ( ) 
 { 
 - return declared . values ( ) ; 
 + List < Function > all = new ArrayList < > ( ) ; 
 + for ( List < Function > functions : declared . values ( ) ) 
 + all . addAll ( functions ) ; 
 + return all ; 
 } 
 
 public static boolean typeEquals ( AbstractType < ? > t1 , AbstractType < ? > t2 )

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 487f388 . . 8c58af7 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 62 , 6 + 62 , 7 @ @ 
 * Fix exception on colum metadata with non - string comparator ( CASSANDRA - 4269 ) 
 * Check for unknown / invalid compression options ( CASSANDRA - 4266 ) 
 * ( cql3 ) Adds simple access to column timestamp and ttl ( CASSANDRA - 4217 ) 
 + * ( cql3 ) Fix range queries with secondary indexes ( CASSANDRA - 4257 ) 
 Merged from 1 . 0 : 
 * Fix super columns bug where cache is not updated ( CASSANDRA - 4190 ) 
 * fix maxTimestamp to include row tombstones ( CASSANDRA - 4116 ) 
 diff - - git a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 index d7089f9 . . 26f082b 100644 
 - - - a / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 + + + b / src / java / org / apache / cassandra / cql3 / statements / SelectStatement . java 
 @ @ - 546 , 8 + 546 , 11 @ @ public class SelectStatement implements CQLStatement 
 { 
 for ( Bound b : Bound . values ( ) ) 
 { 
 - ByteBuffer value = restriction . bound ( b ) . getByteBuffer ( name . type , variables ) ; 
 - expressions . add ( new IndexExpression ( name . name . key , restriction . getIndexOperator ( b ) , value ) ) ; 
 + if ( restriction . bound ( b ) ! = null ) 
 + { 
 + ByteBuffer value = restriction . bound ( b ) . getByteBuffer ( name . type , variables ) ; 
 + expressions . add ( new IndexExpression ( name . name . key , restriction . getIndexOperator ( b ) , value ) ) ; 
 + } 
 } 
 } 
 }
