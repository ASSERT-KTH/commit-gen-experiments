BLEU SCORE: 0.03377156414337854

TEST MSG: Forward writes to replacement node when replace _ address ! = broadcast _ address
GENERATED MSG: Rework node replacement .

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0f7cf0e . . d7e9394 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 2 . 2 . 8 <nl> + * Forward writes to replacement node when replace _ address ! = broadcast _ address ( CASSANDRA - 8523 ) <nl> * Enable repair - pr and - local together ( fix regression of CASSANDRA - 7450 ) ( CASSANDRA - 12522 ) <nl> * Fail repair on non - existing table ( CASSANDRA - 12279 ) <nl> * cqlsh copy : fix missing counter values ( CASSANDRA - 12476 ) <nl> diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> index 00e3da8 . . a8f9524 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / Gossiper . java <nl> + + + b / src / java / org / apache / cassandra / gms / Gossiper . java <nl> @ @ - 76 , 6 + 76 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> static { <nl> SILENT _ SHUTDOWN _ STATES . addAll ( DEAD _ STATES ) ; <nl> SILENT _ SHUTDOWN _ STATES . add ( VersionedValue . STATUS _ BOOTSTRAPPING ) ; <nl> + SILENT _ SHUTDOWN _ STATES . add ( VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE ) ; <nl> } <nl> <nl> private volatile ScheduledFuture < ? > scheduledGossipTask ; <nl> @ @ - 333 , 10 + 334 , 12 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean <nl> if ( epState = = null ) <nl> return ; <nl> <nl> - logger . debug ( " Convicting { } with status { } - alive { } " , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; <nl> if ( ! epState . isAlive ( ) ) <nl> return ; <nl> <nl> + logger . debug ( " Convicting { } with status { } - alive { } " , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; <nl> + <nl> + <nl> if ( isShutdown ( endpoint ) ) <nl> { <nl> markAsShutdown ( endpoint ) ; <nl> diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> index 3ea7bb4 . . 661d3ba 100644 <nl> - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java <nl> @ @ - 65 , 6 + 65 , 7 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> <nl> / / values for ApplicationState . STATUS <nl> public final static String STATUS _ BOOTSTRAPPING = " BOOT " ; <nl> + public final static String STATUS _ BOOTSTRAPPING _ REPLACE = " BOOT _ REPLACE " ; <nl> public final static String STATUS _ NORMAL = " NORMAL " ; <nl> public final static String STATUS _ LEAVING = " LEAVING " ; <nl> public final static String STATUS _ LEFT = " LEFT " ; <nl> @ @ - 133 , 6 + 134 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > <nl> return new VersionedValue ( value . value ) ; <nl> } <nl> <nl> + public VersionedValue bootReplacing ( InetAddress oldNode ) <nl> + { <nl> + return new VersionedValue ( versionString ( VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE , oldNode . getHostAddress ( ) ) ) ; <nl> + } <nl> + <nl> public VersionedValue bootstrapping ( Collection < Token > tokens ) <nl> { <nl> return new VersionedValue ( versionString ( VersionedValue . STATUS _ BOOTSTRAPPING , <nl> diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> index de16fda . . b06c9c8 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java <nl> @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . atomic . AtomicReference ; <nl> import java . util . concurrent . locks . ReadWriteLock ; <nl> import java . util . concurrent . locks . ReentrantReadWriteLock ; <nl> <nl> + import com . google . common . base . Optional ; <nl> import com . google . common . collect . * ; <nl> import org . apache . commons . lang3 . StringUtils ; <nl> import org . slf4j . Logger ; <nl> @ @ - 79 , 6 + 80 , 9 @ @ public class TokenMetadata <nl> / / means we can detect and reject the addition of multiple nodes at the same token <nl> / / before one becomes part of the ring . <nl> private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < > ( ) ; <nl> + <nl> + private final BiMap < InetAddress , InetAddress > replacementToOriginal = HashBiMap . create ( ) ; <nl> + <nl> / / ( don ' t need to record Token here since it ' s still part of tokenToEndpointMap until it ' s done leaving ) <nl> private final Set < InetAddress > leavingEndpoints = new HashSet < > ( ) ; <nl> / / this is a cache of the calculation from { tokenToEndpointMap , bootstrapTokens , leavingEndpoints } <nl> @ @ - 185 , 6 + 189 , 7 @ @ public class TokenMetadata <nl> tokenToEndpointMap . removeValue ( endpoint ) ; <nl> topology . addEndpoint ( endpoint ) ; <nl> leavingEndpoints . remove ( endpoint ) ; <nl> + replacementToOriginal . remove ( endpoint ) ; <nl> removeFromMoving ( endpoint ) ; / / also removing this endpoint from moving <nl> <nl> for ( Token token : tokens ) <nl> @ @ - 297 , 13 + 302 , 17 @ @ public class TokenMetadata <nl> <nl> public void addBootstrapTokens ( Collection < Token > tokens , InetAddress endpoint ) <nl> { <nl> + addBootstrapTokens ( tokens , endpoint , null ) ; <nl> + } <nl> + <nl> + private void addBootstrapTokens ( Collection < Token > tokens , InetAddress endpoint , InetAddress original ) <nl> + { <nl> assert tokens ! = null & & ! tokens . isEmpty ( ) ; <nl> assert endpoint ! = null ; <nl> <nl> lock . writeLock ( ) . lock ( ) ; <nl> try <nl> { <nl> - <nl> InetAddress oldEndpoint ; <nl> <nl> for ( Token token : tokens ) <nl> @ @ - 313 , 7 + 322 , 7 @ @ public class TokenMetadata <nl> throw new RuntimeException ( " Bootstrap Token collision between " + oldEndpoint + " and " + endpoint + " ( token " + token ) ; <nl> <nl> oldEndpoint = tokenToEndpointMap . get ( token ) ; <nl> - if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) ) <nl> + if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) & & ! oldEndpoint . equals ( original ) ) <nl> throw new RuntimeException ( " Bootstrap Token collision between " + oldEndpoint + " and " + endpoint + " ( token " + token ) ; <nl> } <nl> <nl> @ @ - 328 , 6 + 337 , 43 @ @ public class TokenMetadata <nl> } <nl> } <nl> <nl> + public void addReplaceTokens ( Collection < Token > replacingTokens , InetAddress newNode , InetAddress oldNode ) <nl> + { <nl> + assert replacingTokens ! = null & & ! replacingTokens . isEmpty ( ) ; <nl> + assert newNode ! = null & & oldNode ! = null ; <nl> + <nl> + lock . writeLock ( ) . lock ( ) ; <nl> + try <nl> + { <nl> + Collection < Token > oldNodeTokens = tokenToEndpointMap . inverse ( ) . get ( oldNode ) ; <nl> + if ( ! replacingTokens . containsAll ( oldNodeTokens ) | | ! oldNodeTokens . containsAll ( replacingTokens ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Node % s is trying to replace node % s with tokens % s with a " + <nl> + " different set of tokens % s . " , newNode , oldNode , oldNodeTokens , <nl> + replacingTokens ) ) ; <nl> + } <nl> + <nl> + logger . debug ( " Replacing { } with { } " , newNode , oldNode ) ; <nl> + replacementToOriginal . put ( newNode , oldNode ) ; <nl> + <nl> + addBootstrapTokens ( replacingTokens , newNode , oldNode ) ; <nl> + } <nl> + finally <nl> + { <nl> + lock . writeLock ( ) . unlock ( ) ; <nl> + } <nl> + } <nl> + <nl> + public Optional < InetAddress > getReplacementNode ( InetAddress endpoint ) <nl> + { <nl> + return Optional . fromNullable ( replacementToOriginal . inverse ( ) . get ( endpoint ) ) ; <nl> + } <nl> + <nl> + public Optional < InetAddress > getReplacingNode ( InetAddress endpoint ) <nl> + { <nl> + return Optional . fromNullable ( ( replacementToOriginal . get ( endpoint ) ) ) ; <nl> + } <nl> + <nl> public void removeBootstrapTokens ( Collection < Token > tokens ) <nl> { <nl> assert tokens ! = null & & ! tokens . isEmpty ( ) ; <nl> @ @ - 391 , 6 + 437 , 10 @ @ public class TokenMetadata <nl> tokenToEndpointMap . removeValue ( endpoint ) ; <nl> topology . removeEndpoint ( endpoint ) ; <nl> leavingEndpoints . remove ( endpoint ) ; <nl> + if ( replacementToOriginal . remove ( endpoint ) ! = null ) <nl> + { <nl> + logger . debug ( " Node { } failed during replace . " , endpoint ) ; <nl> + } <nl> endpointToHostIdMap . remove ( endpoint ) ; <nl> sortedTokens = sortTokens ( ) ; <nl> invalidateCachedRings ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / service / LoadBroadcaster . java b / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> index 69fa93d . . 945dd2f 100644 <nl> - - - a / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> + + + b / src / java / org / apache / cassandra / service / LoadBroadcaster . java <nl> @ @ - 32 , 7 + 32 , 7 @ @ import org . apache . cassandra . gms . * ; <nl> <nl> public class LoadBroadcaster implements IEndpointStateChangeSubscriber <nl> { <nl> - static final int BROADCAST _ INTERVAL = 60 * 1000 ; <nl> + static final int BROADCAST _ INTERVAL = Integer . getInteger ( " cassandra . broadcast _ interval _ ms " , 60 * 1000 ) ; <nl> <nl> public static final LoadBroadcaster instance = new LoadBroadcaster ( ) ; <nl> <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java <nl> index 48a291b . . 9197ab1 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageService . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageService . java <nl> @ @ - 32 , 6 + 32 , 7 @ @ import javax . management . openmbean . TabularData ; <nl> import javax . management . openmbean . TabularDataSupport ; <nl> <nl> import com . google . common . annotations . VisibleForTesting ; <nl> + import com . google . common . base . Optional ; <nl> import com . google . common . base . Predicate ; <nl> import com . google . common . collect . * ; <nl> import com . google . common . util . concurrent . * ; <nl> @ @ - 185 , 6 + 186 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> private boolean useStrictConsistency = Boolean . parseBoolean ( System . getProperty ( " cassandra . consistent . rangemovement " , " true " ) ) ; <nl> private static final boolean allowSimultaneousMoves = Boolean . valueOf ( System . getProperty ( " cassandra . consistent . simultaneousmoves . allow " , " false " ) ) ; <nl> private boolean replacing ; <nl> + private UUID replacingId ; <nl> <nl> private final StreamStateStore streamStateStore = new StreamStateStore ( ) ; <nl> <nl> @ @ - 194 , 9 + 196 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Setting tokens to { } " , tokens ) ; <nl> SystemKeyspace . updateTokens ( tokens ) ; <nl> - tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; <nl> Collection < Token > localTokens = getLocalTokens ( ) ; <nl> setGossipTokens ( localTokens ) ; <nl> + tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; <nl> setMode ( Mode . NORMAL , false ) ; <nl> } <nl> <nl> @ @ - 431 , 11 + 433 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> / / make magic happen <nl> Gossiper . instance . doShadowRound ( ) ; <nl> <nl> - UUID hostId = null ; <nl> / / now that we ' ve gossiped at least once , we should be able to find the node we ' re replacing <nl> if ( Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) = = null ) <nl> throw new RuntimeException ( " Cannot replace _ address " + DatabaseDescriptor . getReplaceAddress ( ) + " because it doesn ' t exist in gossip " ) ; <nl> - hostId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; <nl> + replacingId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; <nl> try <nl> { <nl> VersionedValue tokensVersionedValue = Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) ; <nl> @ @ - 443 , 7 + 444 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> throw new RuntimeException ( " Could not find tokens for " + DatabaseDescriptor . getReplaceAddress ( ) + " to replace " ) ; <nl> Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( tokensVersionedValue . toBytes ( ) ) ) ) ; <nl> <nl> - SystemKeyspace . setLocalHostId ( hostId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc <nl> + if ( isReplacingSameAddress ( ) ) <nl> + { <nl> + SystemKeyspace . setLocalHostId ( replacingId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc <nl> + } <nl> Gossiper . instance . resetEndpointStateMap ( ) ; / / clean up since we have what we need <nl> return tokens ; <nl> } <nl> @ @ - 472 , 7 + 476 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> / / ignore local node or empty status <nl> if ( entry . getKey ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) | | entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) = = null ) <nl> continue ; <nl> - String [ ] pieces = entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; <nl> + String [ ] pieces = splitValue ( entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) ) ; <nl> assert ( pieces . length > 0 ) ; <nl> String state = pieces [ 0 ] ; <nl> if ( state . equals ( VersionedValue . STATUS _ BOOTSTRAPPING ) | | state . equals ( VersionedValue . STATUS _ LEAVING ) | | state . equals ( VersionedValue . STATUS _ MOVING ) ) <nl> @ @ - 681 , 8 + 685 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) <nl> throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; <nl> bootstrapTokens = prepareReplacementInfo ( ) ; <nl> - appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; <nl> - appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; <nl> + if ( isReplacingSameAddress ( ) ) <nl> + { <nl> + logger . warn ( " Writes will not be forwarded to this node during replacement because it has the same address as " + <nl> + " the node to be replaced ( { } ) . If the previous node has been down for longer than max _ hint _ window _ in _ ms , " + <nl> + " repair must be run after the replacement process in order to make this node consistent . " , <nl> + DatabaseDescriptor . getReplaceAddress ( ) ) ; <nl> + appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; <nl> + appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; <nl> + } <nl> } <nl> else if ( shouldBootstrap ( ) ) <nl> { <nl> @ @ - 799 , 7 + 810 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> else <nl> { <nl> - if ( ! DatabaseDescriptor . getReplaceAddress ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ) <nl> + if ( ! isReplacingSameAddress ( ) ) <nl> { <nl> try <nl> { <nl> @ @ - 885 , 17 + 896 , 14 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> if ( dataAvailable ) <nl> { <nl> - / / start participating in the ring . <nl> - SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; <nl> - setTokens ( bootstrapTokens ) ; <nl> + finishJoiningRing ( ) ; <nl> + <nl> / / remove the existing info about the replaced node . <nl> if ( ! current . isEmpty ( ) ) <nl> { <nl> for ( InetAddress existing : current ) <nl> Gossiper . instance . replacedEndpoint ( existing ) ; <nl> } <nl> - assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; <nl> - doAuthSetup ( ) ; <nl> } <nl> else <nl> { <nl> @ @ - 908 , 6 + 916 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> } <nl> <nl> + public static boolean isReplacingSameAddress ( ) <nl> + { <nl> + return DatabaseDescriptor . getReplaceAddress ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + } <nl> + <nl> public void gossipSnitchInfo ( ) <nl> { <nl> IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; <nl> @ @ - 933 , 16 + 946 , 22 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> else if ( isSurveyMode ) <nl> { <nl> - setTokens ( SystemKeyspace . getSavedTokens ( ) ) ; <nl> - SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; <nl> isSurveyMode = false ; <nl> logger . info ( " Leaving write survey mode and joining ring at operator request " ) ; <nl> - assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; <nl> - <nl> - doAuthSetup ( ) ; <nl> + finishJoiningRing ( ) ; <nl> } <nl> } <nl> <nl> + private void finishJoiningRing ( ) <nl> + { <nl> + / / start participating in the ring . <nl> + SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; <nl> + setTokens ( bootstrapTokens ) ; <nl> + <nl> + assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; <nl> + doAuthSetup ( ) ; <nl> + } <nl> + <nl> private void doAuthSetup ( ) <nl> { <nl> maybeAddOrUpdateKeyspace ( AuthKeyspace . definition ( ) ) ; <nl> @ @ - 1000 , 7 + 1019 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> <nl> public boolean isJoined ( ) <nl> { <nl> - return tokenMetadata . isMember ( FBUtilities . getBroadcastAddress ( ) ) ; <nl> + return tokenMetadata . isMember ( FBUtilities . getBroadcastAddress ( ) ) & & ! isSurveyMode ; <nl> } <nl> <nl> public void rebuild ( String sourceDc ) <nl> @ @ - 1122 , 12 + 1141 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> isBootstrapMode = true ; <nl> SystemKeyspace . updateTokens ( tokens ) ; / / DON ' T use setToken , that makes us part of the ring locally which is incorrect until we are done bootstrapping <nl> - if ( ! replacing ) <nl> + <nl> + if ( ! replacing | | ! isReplacingSameAddress ( ) ) <nl> { <nl> / / if not an existing token then bootstrap <nl> List < Pair < ApplicationState , VersionedValue > > states = new ArrayList < > ( ) ; <nl> states . add ( Pair . create ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ) ; <nl> - states . add ( Pair . create ( ApplicationState . STATUS , valueFactory . bootstrapping ( tokens ) ) ) ; <nl> + states . add ( Pair . create ( ApplicationState . STATUS , replacing ? <nl> + valueFactory . bootReplacing ( DatabaseDescriptor . getReplaceAddress ( ) ) : <nl> + valueFactory . bootstrapping ( tokens ) ) ) ; <nl> Gossiper . instance . addLocalApplicationStates ( states ) ; <nl> setMode ( Mode . JOINING , " sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; <nl> Uninterruptibles . sleepUninterruptibly ( RING _ DELAY , TimeUnit . MILLISECONDS ) ; <nl> @ @ - 1138 , 6 + 1160 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; <nl> SystemKeyspace . removeEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ; <nl> } <nl> + <nl> if ( ! Gossiper . instance . seenAnySeed ( ) ) <nl> throw new IllegalStateException ( " Unable to contact any seeds ! " ) ; <nl> <nl> @ @ - 1575 , 14 + 1598 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> { <nl> if ( state = = ApplicationState . STATUS ) <nl> { <nl> - String apStateValue = value . value ; <nl> - String [ ] pieces = apStateValue . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; <nl> + String [ ] pieces = splitValue ( value ) ; <nl> assert ( pieces . length > 0 ) ; <nl> <nl> String moveName = pieces [ 0 ] ; <nl> <nl> switch ( moveName ) <nl> { <nl> + case VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE : <nl> + handleStateBootreplacing ( endpoint , pieces ) ; <nl> + break ; <nl> case VersionedValue . STATUS _ BOOTSTRAPPING : <nl> handleStateBootstrap ( endpoint ) ; <nl> break ; <nl> @ @ - 1656 , 6 + 1681 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> } <nl> } <nl> <nl> + private static String [ ] splitValue ( VersionedValue value ) <nl> + { <nl> + return value . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; <nl> + } <nl> + <nl> public void updateTopology ( InetAddress endpoint ) <nl> { <nl> if ( getTokenMetadata ( ) . isMember ( endpoint ) ) <nl> @ @ - 1820 , 6 + 1850 , 43 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> tokenMetadata . updateHostId ( Gossiper . instance . getHostId ( endpoint ) , endpoint ) ; <nl> } <nl> <nl> + <nl> + private void handleStateBootreplacing ( InetAddress newNode , String [ ] pieces ) <nl> + { <nl> + InetAddress oldNode ; <nl> + try <nl> + { <nl> + oldNode = InetAddress . getByName ( pieces [ 1 ] ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + logger . error ( " Node { } tried to replace malformed endpoint { } . " , newNode , pieces [ 1 ] , e ) ; <nl> + return ; <nl> + } <nl> + <nl> + if ( FailureDetector . instance . isAlive ( oldNode ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Node % s is trying to replace alive node % s . " , newNode , oldNode ) ) ; <nl> + } <nl> + <nl> + Optional < InetAddress > replacingNode = tokenMetadata . getReplacingNode ( newNode ) ; <nl> + if ( replacingNode . isPresent ( ) & & ! replacingNode . get ( ) . equals ( oldNode ) ) <nl> + { <nl> + throw new RuntimeException ( String . format ( " Node % s is already replacing % s but is trying to replace % s . " , <nl> + newNode , replacingNode . get ( ) , oldNode ) ) ; <nl> + } <nl> + <nl> + Collection < Token > tokens = getTokensFor ( newNode ) ; <nl> + <nl> + if ( logger . isDebugEnabled ( ) ) <nl> + logger . debug ( " Node { } is replacing { } , tokens { } " , newNode , oldNode , tokens ) ; <nl> + <nl> + tokenMetadata . addReplaceTokens ( tokens , newNode , oldNode ) ; <nl> + PendingRangeCalculatorService . instance . update ( ) ; <nl> + <nl> + tokenMetadata . updateHostId ( Gossiper . instance . getHostId ( newNode ) , newNode ) ; <nl> + } <nl> + <nl> / * * <nl> * Handle node move to normal state . That is , node is entering token ring and participating <nl> * in reads . <nl> @ @ - 1844 , 11 + 1911 , 31 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> endpoint , <nl> Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ) ; <nl> <nl> + Optional < InetAddress > replacingNode = tokenMetadata . getReplacingNode ( endpoint ) ; <nl> + if ( replacingNode . isPresent ( ) ) <nl> + { <nl> + assert ! endpoint . equals ( replacingNode . get ( ) ) : " Pending replacement endpoint with same address is not supported " ; <nl> + logger . info ( " Node { } will complete replacement of { } for tokens { } " , endpoint , replacingNode . get ( ) , tokens ) ; <nl> + if ( FailureDetector . instance . isAlive ( replacingNode . get ( ) ) ) <nl> + { <nl> + logger . error ( " Node { } cannot complete replacement of alive node { } . " , endpoint , replacingNode . get ( ) ) ; <nl> + return ; <nl> + } <nl> + endpointsToRemove . add ( replacingNode . get ( ) ) ; <nl> + } <nl> + <nl> + Optional < InetAddress > replacementNode = tokenMetadata . getReplacementNode ( endpoint ) ; <nl> + if ( replacementNode . isPresent ( ) ) <nl> + { <nl> + logger . warn ( " Node { } is currently being replaced by node { } . " , endpoint , replacementNode . get ( ) ) ; <nl> + } <nl> + <nl> updatePeerInfo ( endpoint ) ; <nl> / / Order Matters , TM . updateHostID ( ) should be called before TM . updateNormalToken ( ) , ( see CASSANDRA - 4300 ) . <nl> UUID hostId = Gossiper . instance . getHostId ( endpoint ) ; <nl> InetAddress existing = tokenMetadata . getEndpointForHostId ( hostId ) ; <nl> - if ( replacing & & Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ! = null & & ( hostId . equals ( Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ) ) ) <nl> + if ( replacing & & isReplacingSameAddress ( ) & & Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ! = null <nl> + & & ( hostId . equals ( Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ) ) ) <nl> logger . warn ( " Not updating token metadata for { } because I am replacing it " , endpoint ) ; <nl> else <nl> { <nl> @ @ - 1933 , 7 + 2020 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> Gossiper . instance . replacementQuarantine ( ep ) ; / / quarantine locally longer than normally ; see CASSANDRA - 8260 <nl> } <nl> if ( ! tokensToUpdateInSystemKeyspace . isEmpty ( ) ) <nl> - SystemKeyspace . updateTokens ( endpoint , tokensToUpdateInSystemKeyspace ) ; ; <nl> + SystemKeyspace . updateTokens ( endpoint , tokensToUpdateInSystemKeyspace ) ; <nl> <nl> if ( isMoving | | operationMode = = Mode . MOVING ) <nl> { <nl> @ @ - 2058 , 7 + 2145 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE <nl> PendingRangeCalculatorService . instance . update ( ) ; <nl> <nl> / / find the endpoint coordinating this removal that we need to notify when we ' re done <nl> - String [ ] coordinator = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . REMOVAL _ COORDINATOR ) . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; <nl> + String [ ] coordinator = splitValue ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . REMOVAL _ COORDINATOR ) ) ; <nl> UUID hostId = UUID . fromString ( coordinator [ 1 ] ) ; <nl> / / grab any data we are now responsible for and notify responsible node <nl> restoreReplicaCount ( endpoint , tokenMetadata . getEndpointForHostId ( hostId ) ) ;
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 0a8db61 . . 87be6fa 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 30 , 6 + 30 , 7 @ @ <nl> * Fix compaction race during columnfamily drop ( CASSANDRA - 5957 ) <nl> * Fix validation of empty column names for compact tables ( CASSANDRA - 6152 ) <nl> * Skip replaying mutations that pass CRC but fail to deserialize ( CASSANDRA - 6183 ) <nl> + * Rework token replacement to use replace _ address ( CASSANDRA - 5916 ) <nl> <nl> <nl> 1 . 2 . 10

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0f7cf0e . . d7e9394 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 2 . 2 . 8 
 + * Forward writes to replacement node when replace _ address ! = broadcast _ address ( CASSANDRA - 8523 ) 
 * Enable repair - pr and - local together ( fix regression of CASSANDRA - 7450 ) ( CASSANDRA - 12522 ) 
 * Fail repair on non - existing table ( CASSANDRA - 12279 ) 
 * cqlsh copy : fix missing counter values ( CASSANDRA - 12476 ) 
 diff - - git a / src / java / org / apache / cassandra / gms / Gossiper . java b / src / java / org / apache / cassandra / gms / Gossiper . java 
 index 00e3da8 . . a8f9524 100644 
 - - - a / src / java / org / apache / cassandra / gms / Gossiper . java 
 + + + b / src / java / org / apache / cassandra / gms / Gossiper . java 
 @ @ - 76 , 6 + 76 , 7 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 static { 
 SILENT _ SHUTDOWN _ STATES . addAll ( DEAD _ STATES ) ; 
 SILENT _ SHUTDOWN _ STATES . add ( VersionedValue . STATUS _ BOOTSTRAPPING ) ; 
 + SILENT _ SHUTDOWN _ STATES . add ( VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE ) ; 
 } 
 
 private volatile ScheduledFuture < ? > scheduledGossipTask ; 
 @ @ - 333 , 10 + 334 , 12 @ @ public class Gossiper implements IFailureDetectionEventListener , GossiperMBean 
 if ( epState = = null ) 
 return ; 
 
 - logger . debug ( " Convicting { } with status { } - alive { } " , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; 
 if ( ! epState . isAlive ( ) ) 
 return ; 
 
 + logger . debug ( " Convicting { } with status { } - alive { } " , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; 
 + 
 + 
 if ( isShutdown ( endpoint ) ) 
 { 
 markAsShutdown ( endpoint ) ; 
 diff - - git a / src / java / org / apache / cassandra / gms / VersionedValue . java b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 index 3ea7bb4 . . 661d3ba 100644 
 - - - a / src / java / org / apache / cassandra / gms / VersionedValue . java 
 + + + b / src / java / org / apache / cassandra / gms / VersionedValue . java 
 @ @ - 65 , 6 + 65 , 7 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 
 / / values for ApplicationState . STATUS 
 public final static String STATUS _ BOOTSTRAPPING = " BOOT " ; 
 + public final static String STATUS _ BOOTSTRAPPING _ REPLACE = " BOOT _ REPLACE " ; 
 public final static String STATUS _ NORMAL = " NORMAL " ; 
 public final static String STATUS _ LEAVING = " LEAVING " ; 
 public final static String STATUS _ LEFT = " LEFT " ; 
 @ @ - 133 , 6 + 134 , 11 @ @ public class VersionedValue implements Comparable < VersionedValue > 
 return new VersionedValue ( value . value ) ; 
 } 
 
 + public VersionedValue bootReplacing ( InetAddress oldNode ) 
 + { 
 + return new VersionedValue ( versionString ( VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE , oldNode . getHostAddress ( ) ) ) ; 
 + } 
 + 
 public VersionedValue bootstrapping ( Collection < Token > tokens ) 
 { 
 return new VersionedValue ( versionString ( VersionedValue . STATUS _ BOOTSTRAPPING , 
 diff - - git a / src / java / org / apache / cassandra / locator / TokenMetadata . java b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 index de16fda . . b06c9c8 100644 
 - - - a / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 + + + b / src / java / org / apache / cassandra / locator / TokenMetadata . java 
 @ @ - 26 , 6 + 26 , 7 @ @ import java . util . concurrent . atomic . AtomicReference ; 
 import java . util . concurrent . locks . ReadWriteLock ; 
 import java . util . concurrent . locks . ReentrantReadWriteLock ; 
 
 + import com . google . common . base . Optional ; 
 import com . google . common . collect . * ; 
 import org . apache . commons . lang3 . StringUtils ; 
 import org . slf4j . Logger ; 
 @ @ - 79 , 6 + 80 , 9 @ @ public class TokenMetadata 
 / / means we can detect and reject the addition of multiple nodes at the same token 
 / / before one becomes part of the ring . 
 private final BiMultiValMap < Token , InetAddress > bootstrapTokens = new BiMultiValMap < > ( ) ; 
 + 
 + private final BiMap < InetAddress , InetAddress > replacementToOriginal = HashBiMap . create ( ) ; 
 + 
 / / ( don ' t need to record Token here since it ' s still part of tokenToEndpointMap until it ' s done leaving ) 
 private final Set < InetAddress > leavingEndpoints = new HashSet < > ( ) ; 
 / / this is a cache of the calculation from { tokenToEndpointMap , bootstrapTokens , leavingEndpoints } 
 @ @ - 185 , 6 + 189 , 7 @ @ public class TokenMetadata 
 tokenToEndpointMap . removeValue ( endpoint ) ; 
 topology . addEndpoint ( endpoint ) ; 
 leavingEndpoints . remove ( endpoint ) ; 
 + replacementToOriginal . remove ( endpoint ) ; 
 removeFromMoving ( endpoint ) ; / / also removing this endpoint from moving 
 
 for ( Token token : tokens ) 
 @ @ - 297 , 13 + 302 , 17 @ @ public class TokenMetadata 
 
 public void addBootstrapTokens ( Collection < Token > tokens , InetAddress endpoint ) 
 { 
 + addBootstrapTokens ( tokens , endpoint , null ) ; 
 + } 
 + 
 + private void addBootstrapTokens ( Collection < Token > tokens , InetAddress endpoint , InetAddress original ) 
 + { 
 assert tokens ! = null & & ! tokens . isEmpty ( ) ; 
 assert endpoint ! = null ; 
 
 lock . writeLock ( ) . lock ( ) ; 
 try 
 { 
 - 
 InetAddress oldEndpoint ; 
 
 for ( Token token : tokens ) 
 @ @ - 313 , 7 + 322 , 7 @ @ public class TokenMetadata 
 throw new RuntimeException ( " Bootstrap Token collision between " + oldEndpoint + " and " + endpoint + " ( token " + token ) ; 
 
 oldEndpoint = tokenToEndpointMap . get ( token ) ; 
 - if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) ) 
 + if ( oldEndpoint ! = null & & ! oldEndpoint . equals ( endpoint ) & & ! oldEndpoint . equals ( original ) ) 
 throw new RuntimeException ( " Bootstrap Token collision between " + oldEndpoint + " and " + endpoint + " ( token " + token ) ; 
 } 
 
 @ @ - 328 , 6 + 337 , 43 @ @ public class TokenMetadata 
 } 
 } 
 
 + public void addReplaceTokens ( Collection < Token > replacingTokens , InetAddress newNode , InetAddress oldNode ) 
 + { 
 + assert replacingTokens ! = null & & ! replacingTokens . isEmpty ( ) ; 
 + assert newNode ! = null & & oldNode ! = null ; 
 + 
 + lock . writeLock ( ) . lock ( ) ; 
 + try 
 + { 
 + Collection < Token > oldNodeTokens = tokenToEndpointMap . inverse ( ) . get ( oldNode ) ; 
 + if ( ! replacingTokens . containsAll ( oldNodeTokens ) | | ! oldNodeTokens . containsAll ( replacingTokens ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " Node % s is trying to replace node % s with tokens % s with a " + 
 + " different set of tokens % s . " , newNode , oldNode , oldNodeTokens , 
 + replacingTokens ) ) ; 
 + } 
 + 
 + logger . debug ( " Replacing { } with { } " , newNode , oldNode ) ; 
 + replacementToOriginal . put ( newNode , oldNode ) ; 
 + 
 + addBootstrapTokens ( replacingTokens , newNode , oldNode ) ; 
 + } 
 + finally 
 + { 
 + lock . writeLock ( ) . unlock ( ) ; 
 + } 
 + } 
 + 
 + public Optional < InetAddress > getReplacementNode ( InetAddress endpoint ) 
 + { 
 + return Optional . fromNullable ( replacementToOriginal . inverse ( ) . get ( endpoint ) ) ; 
 + } 
 + 
 + public Optional < InetAddress > getReplacingNode ( InetAddress endpoint ) 
 + { 
 + return Optional . fromNullable ( ( replacementToOriginal . get ( endpoint ) ) ) ; 
 + } 
 + 
 public void removeBootstrapTokens ( Collection < Token > tokens ) 
 { 
 assert tokens ! = null & & ! tokens . isEmpty ( ) ; 
 @ @ - 391 , 6 + 437 , 10 @ @ public class TokenMetadata 
 tokenToEndpointMap . removeValue ( endpoint ) ; 
 topology . removeEndpoint ( endpoint ) ; 
 leavingEndpoints . remove ( endpoint ) ; 
 + if ( replacementToOriginal . remove ( endpoint ) ! = null ) 
 + { 
 + logger . debug ( " Node { } failed during replace . " , endpoint ) ; 
 + } 
 endpointToHostIdMap . remove ( endpoint ) ; 
 sortedTokens = sortTokens ( ) ; 
 invalidateCachedRings ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / service / LoadBroadcaster . java b / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 index 69fa93d . . 945dd2f 100644 
 - - - a / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 + + + b / src / java / org / apache / cassandra / service / LoadBroadcaster . java 
 @ @ - 32 , 7 + 32 , 7 @ @ import org . apache . cassandra . gms . * ; 
 
 public class LoadBroadcaster implements IEndpointStateChangeSubscriber 
 { 
 - static final int BROADCAST _ INTERVAL = 60 * 1000 ; 
 + static final int BROADCAST _ INTERVAL = Integer . getInteger ( " cassandra . broadcast _ interval _ ms " , 60 * 1000 ) ; 
 
 public static final LoadBroadcaster instance = new LoadBroadcaster ( ) ; 
 
 diff - - git a / src / java / org / apache / cassandra / service / StorageService . java b / src / java / org / apache / cassandra / service / StorageService . java 
 index 48a291b . . 9197ab1 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageService . java 
 + + + b / src / java / org / apache / cassandra / service / StorageService . java 
 @ @ - 32 , 6 + 32 , 7 @ @ import javax . management . openmbean . TabularData ; 
 import javax . management . openmbean . TabularDataSupport ; 
 
 import com . google . common . annotations . VisibleForTesting ; 
 + import com . google . common . base . Optional ; 
 import com . google . common . base . Predicate ; 
 import com . google . common . collect . * ; 
 import com . google . common . util . concurrent . * ; 
 @ @ - 185 , 6 + 186 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 private boolean useStrictConsistency = Boolean . parseBoolean ( System . getProperty ( " cassandra . consistent . rangemovement " , " true " ) ) ; 
 private static final boolean allowSimultaneousMoves = Boolean . valueOf ( System . getProperty ( " cassandra . consistent . simultaneousmoves . allow " , " false " ) ) ; 
 private boolean replacing ; 
 + private UUID replacingId ; 
 
 private final StreamStateStore streamStateStore = new StreamStateStore ( ) ; 
 
 @ @ - 194 , 9 + 196 , 9 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( logger . isDebugEnabled ( ) ) 
 logger . debug ( " Setting tokens to { } " , tokens ) ; 
 SystemKeyspace . updateTokens ( tokens ) ; 
 - tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; 
 Collection < Token > localTokens = getLocalTokens ( ) ; 
 setGossipTokens ( localTokens ) ; 
 + tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; 
 setMode ( Mode . NORMAL , false ) ; 
 } 
 
 @ @ - 431 , 11 + 433 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 / / make magic happen 
 Gossiper . instance . doShadowRound ( ) ; 
 
 - UUID hostId = null ; 
 / / now that we ' ve gossiped at least once , we should be able to find the node we ' re replacing 
 if ( Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) = = null ) 
 throw new RuntimeException ( " Cannot replace _ address " + DatabaseDescriptor . getReplaceAddress ( ) + " because it doesn ' t exist in gossip " ) ; 
 - hostId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; 
 + replacingId = Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ; 
 try 
 { 
 VersionedValue tokensVersionedValue = Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) . getApplicationState ( ApplicationState . TOKENS ) ; 
 @ @ - 443 , 7 + 444 , 10 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 throw new RuntimeException ( " Could not find tokens for " + DatabaseDescriptor . getReplaceAddress ( ) + " to replace " ) ; 
 Collection < Token > tokens = TokenSerializer . deserialize ( getPartitioner ( ) , new DataInputStream ( new ByteArrayInputStream ( tokensVersionedValue . toBytes ( ) ) ) ) ; 
 
 - SystemKeyspace . setLocalHostId ( hostId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc 
 + if ( isReplacingSameAddress ( ) ) 
 + { 
 + SystemKeyspace . setLocalHostId ( replacingId ) ; / / use the replacee ' s host Id as our own so we receive hints , etc 
 + } 
 Gossiper . instance . resetEndpointStateMap ( ) ; / / clean up since we have what we need 
 return tokens ; 
 } 
 @ @ - 472 , 7 + 476 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 / / ignore local node or empty status 
 if ( entry . getKey ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) | | entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) = = null ) 
 continue ; 
 - String [ ] pieces = entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; 
 + String [ ] pieces = splitValue ( entry . getValue ( ) . getApplicationState ( ApplicationState . STATUS ) ) ; 
 assert ( pieces . length > 0 ) ; 
 String state = pieces [ 0 ] ; 
 if ( state . equals ( VersionedValue . STATUS _ BOOTSTRAPPING ) | | state . equals ( VersionedValue . STATUS _ LEAVING ) | | state . equals ( VersionedValue . STATUS _ MOVING ) ) 
 @ @ - 681 , 8 + 685 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 if ( ! DatabaseDescriptor . isAutoBootstrap ( ) ) 
 throw new RuntimeException ( " Trying to replace _ address with auto _ bootstrap disabled will not work , check your configuration " ) ; 
 bootstrapTokens = prepareReplacementInfo ( ) ; 
 - appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; 
 - appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; 
 + if ( isReplacingSameAddress ( ) ) 
 + { 
 + logger . warn ( " Writes will not be forwarded to this node during replacement because it has the same address as " + 
 + " the node to be replaced ( { } ) . If the previous node has been down for longer than max _ hint _ window _ in _ ms , " + 
 + " repair must be run after the replacement process in order to make this node consistent . " , 
 + DatabaseDescriptor . getReplaceAddress ( ) ) ; 
 + appStates . put ( ApplicationState . TOKENS , valueFactory . tokens ( bootstrapTokens ) ) ; 
 + appStates . put ( ApplicationState . STATUS , valueFactory . hibernate ( true ) ) ; 
 + } 
 } 
 else if ( shouldBootstrap ( ) ) 
 { 
 @ @ - 799 , 7 + 810 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 else 
 { 
 - if ( ! DatabaseDescriptor . getReplaceAddress ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ) 
 + if ( ! isReplacingSameAddress ( ) ) 
 { 
 try 
 { 
 @ @ - 885 , 17 + 896 , 14 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 if ( dataAvailable ) 
 { 
 - / / start participating in the ring . 
 - SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; 
 - setTokens ( bootstrapTokens ) ; 
 + finishJoiningRing ( ) ; 
 + 
 / / remove the existing info about the replaced node . 
 if ( ! current . isEmpty ( ) ) 
 { 
 for ( InetAddress existing : current ) 
 Gossiper . instance . replacedEndpoint ( existing ) ; 
 } 
 - assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; 
 - doAuthSetup ( ) ; 
 } 
 else 
 { 
 @ @ - 908 , 6 + 916 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 } 
 
 + public static boolean isReplacingSameAddress ( ) 
 + { 
 + return DatabaseDescriptor . getReplaceAddress ( ) . equals ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + } 
 + 
 public void gossipSnitchInfo ( ) 
 { 
 IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; 
 @ @ - 933 , 16 + 946 , 22 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 else if ( isSurveyMode ) 
 { 
 - setTokens ( SystemKeyspace . getSavedTokens ( ) ) ; 
 - SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; 
 isSurveyMode = false ; 
 logger . info ( " Leaving write survey mode and joining ring at operator request " ) ; 
 - assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; 
 - 
 - doAuthSetup ( ) ; 
 + finishJoiningRing ( ) ; 
 } 
 } 
 
 + private void finishJoiningRing ( ) 
 + { 
 + / / start participating in the ring . 
 + SystemKeyspace . setBootstrapState ( SystemKeyspace . BootstrapState . COMPLETED ) ; 
 + setTokens ( bootstrapTokens ) ; 
 + 
 + assert tokenMetadata . sortedTokens ( ) . size ( ) > 0 ; 
 + doAuthSetup ( ) ; 
 + } 
 + 
 private void doAuthSetup ( ) 
 { 
 maybeAddOrUpdateKeyspace ( AuthKeyspace . definition ( ) ) ; 
 @ @ - 1000 , 7 + 1019 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 
 public boolean isJoined ( ) 
 { 
 - return tokenMetadata . isMember ( FBUtilities . getBroadcastAddress ( ) ) ; 
 + return tokenMetadata . isMember ( FBUtilities . getBroadcastAddress ( ) ) & & ! isSurveyMode ; 
 } 
 
 public void rebuild ( String sourceDc ) 
 @ @ - 1122 , 12 + 1141 , 15 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 isBootstrapMode = true ; 
 SystemKeyspace . updateTokens ( tokens ) ; / / DON ' T use setToken , that makes us part of the ring locally which is incorrect until we are done bootstrapping 
 - if ( ! replacing ) 
 + 
 + if ( ! replacing | | ! isReplacingSameAddress ( ) ) 
 { 
 / / if not an existing token then bootstrap 
 List < Pair < ApplicationState , VersionedValue > > states = new ArrayList < > ( ) ; 
 states . add ( Pair . create ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ) ; 
 - states . add ( Pair . create ( ApplicationState . STATUS , valueFactory . bootstrapping ( tokens ) ) ) ; 
 + states . add ( Pair . create ( ApplicationState . STATUS , replacing ? 
 + valueFactory . bootReplacing ( DatabaseDescriptor . getReplaceAddress ( ) ) : 
 + valueFactory . bootstrapping ( tokens ) ) ) ; 
 Gossiper . instance . addLocalApplicationStates ( states ) ; 
 setMode ( Mode . JOINING , " sleeping " + RING _ DELAY + " ms for pending range setup " , true ) ; 
 Uninterruptibles . sleepUninterruptibly ( RING _ DELAY , TimeUnit . MILLISECONDS ) ; 
 @ @ - 1138 , 6 + 1160 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 tokenMetadata . updateNormalTokens ( tokens , FBUtilities . getBroadcastAddress ( ) ) ; 
 SystemKeyspace . removeEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ; 
 } 
 + 
 if ( ! Gossiper . instance . seenAnySeed ( ) ) 
 throw new IllegalStateException ( " Unable to contact any seeds ! " ) ; 
 
 @ @ - 1575 , 14 + 1598 , 16 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 { 
 if ( state = = ApplicationState . STATUS ) 
 { 
 - String apStateValue = value . value ; 
 - String [ ] pieces = apStateValue . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; 
 + String [ ] pieces = splitValue ( value ) ; 
 assert ( pieces . length > 0 ) ; 
 
 String moveName = pieces [ 0 ] ; 
 
 switch ( moveName ) 
 { 
 + case VersionedValue . STATUS _ BOOTSTRAPPING _ REPLACE : 
 + handleStateBootreplacing ( endpoint , pieces ) ; 
 + break ; 
 case VersionedValue . STATUS _ BOOTSTRAPPING : 
 handleStateBootstrap ( endpoint ) ; 
 break ; 
 @ @ - 1656 , 6 + 1681 , 11 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 } 
 } 
 
 + private static String [ ] splitValue ( VersionedValue value ) 
 + { 
 + return value . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; 
 + } 
 + 
 public void updateTopology ( InetAddress endpoint ) 
 { 
 if ( getTokenMetadata ( ) . isMember ( endpoint ) ) 
 @ @ - 1820 , 6 + 1850 , 43 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 tokenMetadata . updateHostId ( Gossiper . instance . getHostId ( endpoint ) , endpoint ) ; 
 } 
 
 + 
 + private void handleStateBootreplacing ( InetAddress newNode , String [ ] pieces ) 
 + { 
 + InetAddress oldNode ; 
 + try 
 + { 
 + oldNode = InetAddress . getByName ( pieces [ 1 ] ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + logger . error ( " Node { } tried to replace malformed endpoint { } . " , newNode , pieces [ 1 ] , e ) ; 
 + return ; 
 + } 
 + 
 + if ( FailureDetector . instance . isAlive ( oldNode ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " Node % s is trying to replace alive node % s . " , newNode , oldNode ) ) ; 
 + } 
 + 
 + Optional < InetAddress > replacingNode = tokenMetadata . getReplacingNode ( newNode ) ; 
 + if ( replacingNode . isPresent ( ) & & ! replacingNode . get ( ) . equals ( oldNode ) ) 
 + { 
 + throw new RuntimeException ( String . format ( " Node % s is already replacing % s but is trying to replace % s . " , 
 + newNode , replacingNode . get ( ) , oldNode ) ) ; 
 + } 
 + 
 + Collection < Token > tokens = getTokensFor ( newNode ) ; 
 + 
 + if ( logger . isDebugEnabled ( ) ) 
 + logger . debug ( " Node { } is replacing { } , tokens { } " , newNode , oldNode , tokens ) ; 
 + 
 + tokenMetadata . addReplaceTokens ( tokens , newNode , oldNode ) ; 
 + PendingRangeCalculatorService . instance . update ( ) ; 
 + 
 + tokenMetadata . updateHostId ( Gossiper . instance . getHostId ( newNode ) , newNode ) ; 
 + } 
 + 
 / * * 
 * Handle node move to normal state . That is , node is entering token ring and participating 
 * in reads . 
 @ @ - 1844 , 11 + 1911 , 31 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 endpoint , 
 Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ) ; 
 
 + Optional < InetAddress > replacingNode = tokenMetadata . getReplacingNode ( endpoint ) ; 
 + if ( replacingNode . isPresent ( ) ) 
 + { 
 + assert ! endpoint . equals ( replacingNode . get ( ) ) : " Pending replacement endpoint with same address is not supported " ; 
 + logger . info ( " Node { } will complete replacement of { } for tokens { } " , endpoint , replacingNode . get ( ) , tokens ) ; 
 + if ( FailureDetector . instance . isAlive ( replacingNode . get ( ) ) ) 
 + { 
 + logger . error ( " Node { } cannot complete replacement of alive node { } . " , endpoint , replacingNode . get ( ) ) ; 
 + return ; 
 + } 
 + endpointsToRemove . add ( replacingNode . get ( ) ) ; 
 + } 
 + 
 + Optional < InetAddress > replacementNode = tokenMetadata . getReplacementNode ( endpoint ) ; 
 + if ( replacementNode . isPresent ( ) ) 
 + { 
 + logger . warn ( " Node { } is currently being replaced by node { } . " , endpoint , replacementNode . get ( ) ) ; 
 + } 
 + 
 updatePeerInfo ( endpoint ) ; 
 / / Order Matters , TM . updateHostID ( ) should be called before TM . updateNormalToken ( ) , ( see CASSANDRA - 4300 ) . 
 UUID hostId = Gossiper . instance . getHostId ( endpoint ) ; 
 InetAddress existing = tokenMetadata . getEndpointForHostId ( hostId ) ; 
 - if ( replacing & & Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ! = null & & ( hostId . equals ( Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ) ) ) 
 + if ( replacing & & isReplacingSameAddress ( ) & & Gossiper . instance . getEndpointStateForEndpoint ( DatabaseDescriptor . getReplaceAddress ( ) ) ! = null 
 + & & ( hostId . equals ( Gossiper . instance . getHostId ( DatabaseDescriptor . getReplaceAddress ( ) ) ) ) ) 
 logger . warn ( " Not updating token metadata for { } because I am replacing it " , endpoint ) ; 
 else 
 { 
 @ @ - 1933 , 7 + 2020 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 Gossiper . instance . replacementQuarantine ( ep ) ; / / quarantine locally longer than normally ; see CASSANDRA - 8260 
 } 
 if ( ! tokensToUpdateInSystemKeyspace . isEmpty ( ) ) 
 - SystemKeyspace . updateTokens ( endpoint , tokensToUpdateInSystemKeyspace ) ; ; 
 + SystemKeyspace . updateTokens ( endpoint , tokensToUpdateInSystemKeyspace ) ; 
 
 if ( isMoving | | operationMode = = Mode . MOVING ) 
 { 
 @ @ - 2058 , 7 + 2145 , 7 @ @ public class StorageService extends NotificationBroadcasterSupport implements IE 
 PendingRangeCalculatorService . instance . update ( ) ; 
 
 / / find the endpoint coordinating this removal that we need to notify when we ' re done 
 - String [ ] coordinator = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . REMOVAL _ COORDINATOR ) . value . split ( VersionedValue . DELIMITER _ STR , - 1 ) ; 
 + String [ ] coordinator = splitValue ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . REMOVAL _ COORDINATOR ) ) ; 
 UUID hostId = UUID . fromString ( coordinator [ 1 ] ) ; 
 / / grab any data we are now responsible for and notify responsible node 
 restoreReplicaCount ( endpoint , tokenMetadata . getEndpointForHostId ( hostId ) ) ;

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 0a8db61 . . 87be6fa 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 30 , 6 + 30 , 7 @ @ 
 * Fix compaction race during columnfamily drop ( CASSANDRA - 5957 ) 
 * Fix validation of empty column names for compact tables ( CASSANDRA - 6152 ) 
 * Skip replaying mutations that pass CRC but fail to deserialize ( CASSANDRA - 6183 ) 
 + * Rework token replacement to use replace _ address ( CASSANDRA - 5916 ) 
 
 
 1 . 2 . 10
