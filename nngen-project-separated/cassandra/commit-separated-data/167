BLEU SCORE: 0.04767707020457096

TEST MSG: Handle repeat open bound from SRP in read repair
GENERATED MSG: merge from 1 . 0

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index b967580 . . d701a22 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 3 . 0 . 17 <nl> + * Handle repeat open bound from SRP in read repair ( CASSANDRA - 14330 ) <nl> * Use zero as default score in DynamicEndpointSnitch ( CASSANDRA - 14252 ) <nl> * Respect max hint window when hinting for LWT ( CASSANDRA - 14215 ) <nl> * Adding missing WriteType enum values to v3 , v4 , and v5 spec ( CASSANDRA - 13697 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> index c59d00a . . bc44a1b 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ReadResponse . java <nl> + + + b / src / java / org / apache / cassandra / db / ReadResponse . java <nl> @ @ - 107 , 13 + 107 , 33 @ @ public abstract class ReadResponse <nl> try ( UnfilteredRowIterator partition = iter . next ( ) ) <nl> { <nl> if ( partition . partitionKey ( ) . equals ( key ) ) <nl> - return ImmutableBTreePartition . create ( partition ) . toString ( ) ; <nl> + return toDebugString ( partition , command . metadata ( ) ) ; <nl> } <nl> } <nl> } <nl> return " < key " + key + " not found > " ; <nl> } <nl> <nl> + private String toDebugString ( UnfilteredRowIterator partition , CFMetaData metadata ) <nl> + { <nl> + StringBuilder sb = new StringBuilder ( ) ; <nl> + <nl> + sb . append ( String . format ( " [ % s . % s ] key = % s partition _ deletion = % s columns = % s " , <nl> + metadata . ksName , <nl> + metadata . cfName , <nl> + metadata . getKeyValidator ( ) . getString ( partition . partitionKey ( ) . getKey ( ) ) , <nl> + partition . partitionLevelDeletion ( ) , <nl> + partition . columns ( ) ) ) ; <nl> + <nl> + if ( partition . staticRow ( ) ! = Rows . EMPTY _ STATIC _ ROW ) <nl> + sb . append ( " \ n " ) . append ( partition . staticRow ( ) . toString ( metadata , true ) ) ; <nl> + <nl> + while ( partition . hasNext ( ) ) <nl> + sb . append ( " \ n " ) . append ( partition . next ( ) . toString ( metadata , true ) ) ; <nl> + <nl> + return sb . toString ( ) ; <nl> + } <nl> + <nl> protected static ByteBuffer makeDigest ( UnfilteredPartitionIterator iterator , ReadCommand command ) <nl> { <nl> MessageDigest digest = FBUtilities . threadLocalMD5Digest ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> index 6f4afa5 . . 0079114 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java <nl> @ @ - 140 , 7 + 140 , 7 @ @ public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker <nl> <nl> public String toString ( CFMetaData metadata ) <nl> { <nl> - return " Marker " + bound . toString ( metadata ) + ' @ ' + deletion . markedForDeleteAt ( ) ; <nl> + return String . format ( " Marker % s @ % d / % d " , bound . toString ( metadata ) , deletion . markedForDeleteAt ( ) , deletion . localDeletionTime ( ) ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> index 0683d76 . . c4bc2f2 100644 <nl> - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java <nl> @ @ - 153 , 7 + 153 , 10 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker <nl> <nl> public String toString ( CFMetaData metadata ) <nl> { <nl> - return String . format ( " Marker % s @ % d - % d " , bound . toString ( metadata ) , endDeletion . markedForDeleteAt ( ) , startDeletion . markedForDeleteAt ( ) ) ; <nl> + return String . format ( " Marker % s @ % d / % d - % d / % d " , <nl> + bound . toString ( metadata ) , <nl> + endDeletion . markedForDeleteAt ( ) , endDeletion . localDeletionTime ( ) , <nl> + startDeletion . markedForDeleteAt ( ) , startDeletion . localDeletionTime ( ) ) ; <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / service / DataResolver . java b / src / java / org / apache / cassandra / service / DataResolver . java <nl> index f02b565 . . 2252913 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DataResolver . java <nl> + + + b / src / java / org / apache / cassandra / service / DataResolver . java <nl> @ @ - 331 , 8 + 331 , 10 @ @ public class DataResolver extends ResponseResolver <nl> / / The following can be pretty verbose , but it ' s really only triggered if a bug happen , so we ' d <nl> / / rather get more info to debug than not . <nl> CFMetaData table = command . metadata ( ) ; <nl> - String details = String . format ( " Error merging RTs on % s . % s : merged = % s , versions = % s , sources = { % s } , responses : % n % s " , <nl> + String details = String . format ( " Error merging RTs on % s . % s : command = % s , reversed = % b , merged = % s , versions = % s , sources = { % s } , responses : % n % s " , <nl> table . ksName , table . cfName , <nl> + command . toCQLString ( ) , <nl> + isReversed , <nl> merged = = null ? " null " : merged . toString ( table ) , <nl> ' [ ' + Joiner . on ( " , " ) . join ( Iterables . transform ( Arrays . asList ( versions ) , rt - > rt = = null ? " null " : rt . toString ( table ) ) ) + ' ] ' , <nl> Arrays . toString ( sources ) , <nl> @ @ - 395 , 11 + 397 , 24 @ @ public class DataResolver extends ResponseResolver <nl> DeletionTime partitionRepairDeletion = partitionLevelRepairDeletion ( i ) ; <nl> if ( markerToRepair [ i ] = = null & & currentDeletion . supersedes ( partitionRepairDeletion ) ) <nl> { <nl> - / / Since there is an ongoing merged deletion , the only way we don ' t have an open repair for <nl> - / / this source is that it had a range open with the same deletion as current and it ' s <nl> - / / closing it . <nl> - assert marker . isClose ( isReversed ) & & currentDeletion . equals ( marker . closeDeletionTime ( isReversed ) ) <nl> - : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; <nl> + / * <nl> + * Since there is an ongoing merged deletion , the only two ways we don ' t have an open repair for <nl> + * this source are that : <nl> + * <nl> + * 1 ) it had a range open with the same deletion as current marker , and the marker is coming from <nl> + * a short read protection response - repeating the open RT bound , or <nl> + * 2 ) it had a range open with the same deletion as current marker , and the marker is closing it . <nl> + * / <nl> + if ( ! marker . isBoundary ( ) & & marker . isOpen ( isReversed ) ) / / ( 1 ) <nl> + { <nl> + assert currentDeletion . equals ( marker . openDeletionTime ( isReversed ) ) <nl> + : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; <nl> + } <nl> + else / / ( 2 ) <nl> + { <nl> + assert marker . isClose ( isReversed ) & & currentDeletion . equals ( marker . closeDeletionTime ( isReversed ) ) <nl> + : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; <nl> + } <nl> <nl> / / and so unless it ' s a boundary whose opening deletion time is still equal to the current <nl> / / deletion ( see comment above for why this can actually happen ) , we have to repair the source
NEAREST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index d518830 . . 52cc2c1 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 29 , 7 + 29 , 7 @ @ <nl> * add scheduler JMX metrics ( CASSANDRA - 2962 ) <nl> * add block level checksum for compressed data ( CASSANDRA - 1717 ) <nl> * make column family backed column map pluggable and introduce unsynchronized <nl> - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) <nl> + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) <nl> * refactoring of the secondary index api ( CASSANDRA - 2982 ) <nl> * make CL > ONE reads wait for digest reconciliation before returning <nl> ( CASSANDRA - 2494 ) <nl> diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> index c316a85 . . 71c7213 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java <nl> @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor <nl> this . reversed = reversed ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public AbstractType < ? > getComparator ( ) <nl> { <nl> return comparator ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> index 1239d1c . . 38bc0d7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java <nl> @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer <nl> this . cfm = cfm ; <nl> } <nl> <nl> - public ColumnFamily cloneMeShallow ( ) <nl> + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) <nl> { <nl> - ColumnFamily cf = ColumnFamily . create ( cfm ) ; <nl> + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; <nl> / / since deletion info is immutable , aliasing it is fine <nl> cf . deletionInfo . set ( deletionInfo . get ( ) ) ; <nl> return cf ; <nl> } <nl> <nl> + public ColumnFamily cloneMeShallow ( ) <nl> + { <nl> + return cloneMeShallow ( columns . getFactory ( ) ) ; <nl> + } <nl> + <nl> public AbstractType getSubComparator ( ) <nl> { <nl> IColumnSerializer s = getColumnSerializer ( ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> index 0bfd1c5 . . 552d3e9 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java <nl> @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> } <nl> <nl> - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> - * tombstones that are no longer relevant . * / <nl> + / * * <nl> + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out <nl> + * tombstones that are no longer relevant . <nl> + * The returned column family won ' t be thread safe . <nl> + * / <nl> ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) <nl> { <nl> / / special case slicing the entire row : <nl> @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; <nl> if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) <nl> { <nl> - ColumnFamily cf = cached . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> if ( sc ! = null ) <nl> cf . addColumn ( sc , HeapAllocator . instance ) ; <nl> return removeDeleted ( cf , gcBefore ) ; <nl> @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean <nl> } <nl> <nl> IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; <nl> - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; <nl> + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; <nl> filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; <nl> / / TODO this is necessary because when we collate supercolumns together , we don ' t check <nl> / / their subcolumns for relevance , so we need to do a second prune post facto here . <nl> diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> index 37f5a60 . . 624dec7 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java <nl> @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns <nl> public ISortedColumns cloneMe ( ) ; <nl> <nl> / * * <nl> + * Returns the factory used for this ISortedColumns implementation . <nl> + * / <nl> + public Factory getFactory ( ) ; <nl> + <nl> + / * * <nl> * Adds a column to this column map . <nl> * If a column with the same name is already present in the map , it will <nl> * be replaced by the newly added column . <nl> diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> index cd2488a . . 13a111a 100644 <nl> - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new ThreadSafeSortedColumns ( this ) ; <nl> diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> index 34e83dc . . 6c3fc42 100644 <nl> - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java <nl> @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp <nl> super ( columns ) ; <nl> } <nl> <nl> + public ISortedColumns . Factory getFactory ( ) <nl> + { <nl> + return factory ( ) ; <nl> + } <nl> + <nl> public ISortedColumns cloneMe ( ) <nl> { <nl> return new TreeMapBackedSortedColumns ( this ) ;

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index b967580 . . d701a22 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 3 . 0 . 17 
 + * Handle repeat open bound from SRP in read repair ( CASSANDRA - 14330 ) 
 * Use zero as default score in DynamicEndpointSnitch ( CASSANDRA - 14252 ) 
 * Respect max hint window when hinting for LWT ( CASSANDRA - 14215 ) 
 * Adding missing WriteType enum values to v3 , v4 , and v5 spec ( CASSANDRA - 13697 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ReadResponse . java b / src / java / org / apache / cassandra / db / ReadResponse . java 
 index c59d00a . . bc44a1b 100644 
 - - - a / src / java / org / apache / cassandra / db / ReadResponse . java 
 + + + b / src / java / org / apache / cassandra / db / ReadResponse . java 
 @ @ - 107 , 13 + 107 , 33 @ @ public abstract class ReadResponse 
 try ( UnfilteredRowIterator partition = iter . next ( ) ) 
 { 
 if ( partition . partitionKey ( ) . equals ( key ) ) 
 - return ImmutableBTreePartition . create ( partition ) . toString ( ) ; 
 + return toDebugString ( partition , command . metadata ( ) ) ; 
 } 
 } 
 } 
 return " < key " + key + " not found > " ; 
 } 
 
 + private String toDebugString ( UnfilteredRowIterator partition , CFMetaData metadata ) 
 + { 
 + StringBuilder sb = new StringBuilder ( ) ; 
 + 
 + sb . append ( String . format ( " [ % s . % s ] key = % s partition _ deletion = % s columns = % s " , 
 + metadata . ksName , 
 + metadata . cfName , 
 + metadata . getKeyValidator ( ) . getString ( partition . partitionKey ( ) . getKey ( ) ) , 
 + partition . partitionLevelDeletion ( ) , 
 + partition . columns ( ) ) ) ; 
 + 
 + if ( partition . staticRow ( ) ! = Rows . EMPTY _ STATIC _ ROW ) 
 + sb . append ( " \ n " ) . append ( partition . staticRow ( ) . toString ( metadata , true ) ) ; 
 + 
 + while ( partition . hasNext ( ) ) 
 + sb . append ( " \ n " ) . append ( partition . next ( ) . toString ( metadata , true ) ) ; 
 + 
 + return sb . toString ( ) ; 
 + } 
 + 
 protected static ByteBuffer makeDigest ( UnfilteredPartitionIterator iterator , ReadCommand command ) 
 { 
 MessageDigest digest = FBUtilities . threadLocalMD5Digest ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 index 6f4afa5 . . 0079114 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundMarker . java 
 @ @ - 140 , 7 + 140 , 7 @ @ public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker 
 
 public String toString ( CFMetaData metadata ) 
 { 
 - return " Marker " + bound . toString ( metadata ) + ' @ ' + deletion . markedForDeleteAt ( ) ; 
 + return String . format ( " Marker % s @ % d / % d " , bound . toString ( metadata ) , deletion . markedForDeleteAt ( ) , deletion . localDeletionTime ( ) ) ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 index 0683d76 . . c4bc2f2 100644 
 - - - a / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 + + + b / src / java / org / apache / cassandra / db / rows / RangeTombstoneBoundaryMarker . java 
 @ @ - 153 , 7 + 153 , 10 @ @ public class RangeTombstoneBoundaryMarker extends AbstractRangeTombstoneMarker 
 
 public String toString ( CFMetaData metadata ) 
 { 
 - return String . format ( " Marker % s @ % d - % d " , bound . toString ( metadata ) , endDeletion . markedForDeleteAt ( ) , startDeletion . markedForDeleteAt ( ) ) ; 
 + return String . format ( " Marker % s @ % d / % d - % d / % d " , 
 + bound . toString ( metadata ) , 
 + endDeletion . markedForDeleteAt ( ) , endDeletion . localDeletionTime ( ) , 
 + startDeletion . markedForDeleteAt ( ) , startDeletion . localDeletionTime ( ) ) ; 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / service / DataResolver . java b / src / java / org / apache / cassandra / service / DataResolver . java 
 index f02b565 . . 2252913 100644 
 - - - a / src / java / org / apache / cassandra / service / DataResolver . java 
 + + + b / src / java / org / apache / cassandra / service / DataResolver . java 
 @ @ - 331 , 8 + 331 , 10 @ @ public class DataResolver extends ResponseResolver 
 / / The following can be pretty verbose , but it ' s really only triggered if a bug happen , so we ' d 
 / / rather get more info to debug than not . 
 CFMetaData table = command . metadata ( ) ; 
 - String details = String . format ( " Error merging RTs on % s . % s : merged = % s , versions = % s , sources = { % s } , responses : % n % s " , 
 + String details = String . format ( " Error merging RTs on % s . % s : command = % s , reversed = % b , merged = % s , versions = % s , sources = { % s } , responses : % n % s " , 
 table . ksName , table . cfName , 
 + command . toCQLString ( ) , 
 + isReversed , 
 merged = = null ? " null " : merged . toString ( table ) , 
 ' [ ' + Joiner . on ( " , " ) . join ( Iterables . transform ( Arrays . asList ( versions ) , rt - > rt = = null ? " null " : rt . toString ( table ) ) ) + ' ] ' , 
 Arrays . toString ( sources ) , 
 @ @ - 395 , 11 + 397 , 24 @ @ public class DataResolver extends ResponseResolver 
 DeletionTime partitionRepairDeletion = partitionLevelRepairDeletion ( i ) ; 
 if ( markerToRepair [ i ] = = null & & currentDeletion . supersedes ( partitionRepairDeletion ) ) 
 { 
 - / / Since there is an ongoing merged deletion , the only way we don ' t have an open repair for 
 - / / this source is that it had a range open with the same deletion as current and it ' s 
 - / / closing it . 
 - assert marker . isClose ( isReversed ) & & currentDeletion . equals ( marker . closeDeletionTime ( isReversed ) ) 
 - : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; 
 + / * 
 + * Since there is an ongoing merged deletion , the only two ways we don ' t have an open repair for 
 + * this source are that : 
 + * 
 + * 1 ) it had a range open with the same deletion as current marker , and the marker is coming from 
 + * a short read protection response - repeating the open RT bound , or 
 + * 2 ) it had a range open with the same deletion as current marker , and the marker is closing it . 
 + * / 
 + if ( ! marker . isBoundary ( ) & & marker . isOpen ( isReversed ) ) / / ( 1 ) 
 + { 
 + assert currentDeletion . equals ( marker . openDeletionTime ( isReversed ) ) 
 + : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; 
 + } 
 + else / / ( 2 ) 
 + { 
 + assert marker . isClose ( isReversed ) & & currentDeletion . equals ( marker . closeDeletionTime ( isReversed ) ) 
 + : String . format ( " currentDeletion = % s , marker = % s " , currentDeletion , marker . toString ( command . metadata ( ) ) ) ; 
 + } 
 
 / / and so unless it ' s a boundary whose opening deletion time is still equal to the current 
 / / deletion ( see comment above for why this can actually happen ) , we have to repair the source

NEAREST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index d518830 . . 52cc2c1 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 29 , 7 + 29 , 7 @ @ 
 * add scheduler JMX metrics ( CASSANDRA - 2962 ) 
 * add block level checksum for compressed data ( CASSANDRA - 1717 ) 
 * make column family backed column map pluggable and introduce unsynchronized 
 - ArrayList backed one to speedup reads ( CASSANDRA - 2843 ) 
 + ArrayList backed one to speedup reads ( CASSANDRA - 2843 , 3165 ) 
 * refactoring of the secondary index api ( CASSANDRA - 2982 ) 
 * make CL > ONE reads wait for digest reconciliation before returning 
 ( CASSANDRA - 2494 ) 
 diff - - git a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 index c316a85 . . 71c7213 100644 
 - - - a / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ArrayBackedSortedColumns . java 
 @ @ - 67 , 6 + 67 , 11 @ @ public class ArrayBackedSortedColumns extends ArrayList < IColumn > implements ISor 
 this . reversed = reversed ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public AbstractType < ? > getComparator ( ) 
 { 
 return comparator ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamily . java b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 index 1239d1c . . 38bc0d7 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamily . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamily . java 
 @ @ - 81 , 14 + 81 , 19 @ @ public class ColumnFamily extends AbstractColumnContainer 
 this . cfm = cfm ; 
 } 
 
 - public ColumnFamily cloneMeShallow ( ) 
 + public ColumnFamily cloneMeShallow ( ISortedColumns . Factory factory ) 
 { 
 - ColumnFamily cf = ColumnFamily . create ( cfm ) ; 
 + ColumnFamily cf = ColumnFamily . create ( cfm , factory ) ; 
 / / since deletion info is immutable , aliasing it is fine 
 cf . deletionInfo . set ( deletionInfo . get ( ) ) ; 
 return cf ; 
 } 
 
 + public ColumnFamily cloneMeShallow ( ) 
 + { 
 + return cloneMeShallow ( columns . getFactory ( ) ) ; 
 + } 
 + 
 public AbstractType getSubComparator ( ) 
 { 
 IColumnSerializer s = getColumnSerializer ( ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 index 0bfd1c5 . . 552d3e9 100644 
 - - - a / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 + + + b / src / java / org / apache / cassandra / db / ColumnFamilyStore . java 
 @ @ - 1162 , 8 + 1162 , 11 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 } 
 
 - / * * filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 - * tombstones that are no longer relevant . * / 
 + / * * 
 + * Filter a cached row , which will not be modified by the filter , but may be modified by throwing out 
 + * tombstones that are no longer relevant . 
 + * The returned column family won ' t be thread safe . 
 + * / 
 ColumnFamily filterColumnFamily ( ColumnFamily cached , QueryFilter filter , int gcBefore ) 
 { 
 / / special case slicing the entire row : 
 @ @ - 1184 , 7 + 1187 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 IColumn sc = cached . getColumn ( filter . path . superColumnName ) ; 
 if ( sc = = null | | sliceFilter . count > = sc . getSubColumns ( ) . size ( ) ) 
 { 
 - ColumnFamily cf = cached . cloneMeShallow ( ) ; 
 + ColumnFamily cf = cached . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 if ( sc ! = null ) 
 cf . addColumn ( sc , HeapAllocator . instance ) ; 
 return removeDeleted ( cf , gcBefore ) ; 
 @ @ - 1203 , 7 + 1206 , 7 @ @ public class ColumnFamilyStore implements ColumnFamilyStoreMBean 
 } 
 
 IColumnIterator ci = filter . getMemtableColumnIterator ( cached , null , getComparator ( ) ) ; 
 - ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ) ; 
 + ColumnFamily cf = ci . getColumnFamily ( ) . cloneMeShallow ( ArrayBackedSortedColumns . factory ( ) ) ; 
 filter . collateColumns ( cf , Collections . singletonList ( ci ) , getComparator ( ) , gcBefore ) ; 
 / / TODO this is necessary because when we collate supercolumns together , we don ' t check 
 / / their subcolumns for relevance , so we need to do a second prune post facto here . 
 diff - - git a / src / java / org / apache / cassandra / db / ISortedColumns . java b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 index 37f5a60 . . 624dec7 100644 
 - - - a / src / java / org / apache / cassandra / db / ISortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ISortedColumns . java 
 @ @ - 42 , 6 + 42 , 11 @ @ public interface ISortedColumns extends IIterableColumns 
 public ISortedColumns cloneMe ( ) ; 
 
 / * * 
 + * Returns the factory used for this ISortedColumns implementation . 
 + * / 
 + public Factory getFactory ( ) ; 
 + 
 + / * * 
 * Adds a column to this column map . 
 * If a column with the same name is already present in the map , it will 
 * be replaced by the newly added column . 
 diff - - git a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 index cd2488a . . 13a111a 100644 
 - - - a / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / ThreadSafeSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class ThreadSafeSortedColumns extends ConcurrentSkipListMap < ByteBuffer , I 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new ThreadSafeSortedColumns ( this ) ; 
 diff - - git a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 index 34e83dc . . 6c3fc42 100644 
 - - - a / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 + + + b / src / java / org / apache / cassandra / db / TreeMapBackedSortedColumns . java 
 @ @ - 62 , 6 + 62 , 11 @ @ public class TreeMapBackedSortedColumns extends TreeMap < ByteBuffer , IColumn > imp 
 super ( columns ) ; 
 } 
 
 + public ISortedColumns . Factory getFactory ( ) 
 + { 
 + return factory ( ) ; 
 + } 
 + 
 public ISortedColumns cloneMe ( ) 
 { 
 return new TreeMapBackedSortedColumns ( this ) ;
