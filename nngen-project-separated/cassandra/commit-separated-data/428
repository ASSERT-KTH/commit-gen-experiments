BLEU SCORE: 0.020483489079410902

TEST MSG: Make it possible to monitor an ideal consistency level separate from actual consistency level
GENERATED MSG: Dynamic snitch to adaptively avoid reading from slow nodes . Patch by brandonwilliams ; reviewed by jbellis for CASSANDRA - 981

TEST DIFF (one line): diff - - git a / CHANGES . txt b / CHANGES . txt <nl> index 6a164ee . . d4b53d0 100644 <nl> - - - a / CHANGES . txt <nl> + + + b / CHANGES . txt <nl> @ @ - 1 , 4 + 1 , 5 @ @ <nl> 4 . 0 <nl> + * Make it possible to monitor an ideal consistency level separate from actual consistency level ( CASSANDRA - 13289 ) <nl> * Outbound TCP connections ignore internode authenticator ( CASSANDRA - 13324 ) <nl> * Upgrade junit from 4 . 6 to 4 . 12 ( CASSANDRA - 13360 ) <nl> * Cleanup ParentRepairSession after repairs ( CASSANDRA - 13359 ) <nl> diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index d8392a0 . . f2c4c84 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 1120 , 3 + 1120 , 8 @ @ back _ pressure _ strategy : <nl> <nl> # Do not try to coalesce messages if we already got that many messages . This should be more than 2 and less than 128 . <nl> # otc _ coalescing _ enough _ coalesced _ messages : 8 <nl> + <nl> + # Track a metric per keyspace indicating whether replication achieved the ideal consistency <nl> + # level for writes without timing out . This is different from the consistency level requested by <nl> + # each write which may be lower in order to facilitate availability . <nl> + # ideal _ consistency _ level : EACH _ QUORUM <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 36ce576 . . 1461cd4 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 32 , 6 + 32 , 8 @ @ import com . google . common . collect . Sets ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + <nl> / * * <nl> * A class that contains configuration properties for the cassandra node it runs within . <nl> * <nl> @ @ - 271 , 6 + 273 , 12 @ @ public class Config <nl> public int tracetype _ query _ ttl = ( int ) TimeUnit . DAYS . toSeconds ( 1 ) ; <nl> public int tracetype _ repair _ ttl = ( int ) TimeUnit . DAYS . toSeconds ( 7 ) ; <nl> <nl> + / * * <nl> + * Maintain statistics on whether writes achieve the ideal consistency level <nl> + * before expiring and becoming hints <nl> + * / <nl> + public volatile ConsistencyLevel ideal _ consistency _ level = null ; <nl> + <nl> / * <nl> * Strategy to use for coalescing messages in OutboundTcpConnection . <nl> * Can be fixed , movingaverage , timehorizon , disabled . Setting is case and leading / trailing <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 465cd8a . . debf161 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 44 , 6 + 44 , 7 @ @ import org . apache . cassandra . auth . IAuthorizer ; <nl> import org . apache . cassandra . auth . IInternodeAuthenticator ; <nl> import org . apache . cassandra . auth . IRoleManager ; <nl> import org . apache . cassandra . config . Config . CommitLogSync ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> import org . apache . cassandra . dht . IPartitioner ; <nl> import org . apache . cassandra . exceptions . ConfigurationException ; <nl> import org . apache . cassandra . io . FSWriteError ; <nl> @ @ - 2269 , 4 + 2270 , 14 @ @ public class DatabaseDescriptor <nl> { <nl> return backPressureStrategy ; <nl> } <nl> + <nl> + public static ConsistencyLevel getIdealConsistencyLevel ( ) <nl> + { <nl> + return conf . ideal _ consistency _ level ; <nl> + } <nl> + <nl> + public static void setIdealConsistencyLevel ( ConsistencyLevel cl ) <nl> + { <nl> + conf . ideal _ consistency _ level = cl ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> index 9c43486 . . c3498d9 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java <nl> @ @ - 28 , 6 + 28 , 7 @ @ import com . google . common . collect . Multimap ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> import org . apache . cassandra . db . ConsistencyLevel ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> import org . apache . cassandra . db . WriteType ; <nl> @ @ - 40 , 6 + 41 , 7 @ @ import org . apache . cassandra . service . DatacenterSyncWriteResponseHandler ; <nl> import org . apache . cassandra . service . DatacenterWriteResponseHandler ; <nl> import org . apache . cassandra . service . WriteResponseHandler ; <nl> import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; <nl> <nl> / * * <nl> @ @ - 135 , 16 + 137 , 57 @ @ public abstract class AbstractReplicationStrategy <nl> WriteType writeType , <nl> long queryStartNanoTime ) <nl> { <nl> + return getWriteResponseHandler ( naturalEndpoints , pendingEndpoints , consistency _ level , callback , writeType , queryStartNanoTime , DatabaseDescriptor . getIdealConsistencyLevel ( ) ) ; <nl> + } <nl> + <nl> + public < T > AbstractWriteResponseHandler < T > getWriteResponseHandler ( Collection < InetAddress > naturalEndpoints , <nl> + Collection < InetAddress > pendingEndpoints , <nl> + ConsistencyLevel consistency _ level , <nl> + Runnable callback , <nl> + WriteType writeType , <nl> + long queryStartNanoTime , <nl> + ConsistencyLevel idealConsistencyLevel ) <nl> + { <nl> + AbstractWriteResponseHandler resultResponseHandler ; <nl> if ( consistency _ level . isDatacenterLocal ( ) ) <nl> { <nl> / / block for in this context will be localnodes block . <nl> - return new DatacenterWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> + resultResponseHandler = new DatacenterWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> } <nl> else if ( consistency _ level = = ConsistencyLevel . EACH _ QUORUM & & ( this instanceof NetworkTopologyStrategy ) ) <nl> { <nl> - return new DatacenterSyncWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> + resultResponseHandler = new DatacenterSyncWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> } <nl> - return new WriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> + else <nl> + { <nl> + resultResponseHandler = new WriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; <nl> + } <nl> + <nl> + / / Check if tracking the ideal consistency level is configured <nl> + if ( idealConsistencyLevel ! = null ) <nl> + { <nl> + / / If ideal and requested are the same just use this handler to track the ideal consistency level <nl> + / / This is also used so that the ideal consistency level handler when constructed knows it is the ideal <nl> + / / one for tracking purposes <nl> + if ( idealConsistencyLevel = = consistency _ level ) <nl> + { <nl> + resultResponseHandler . setIdealCLResponseHandler ( resultResponseHandler ) ; <nl> + } <nl> + else <nl> + { <nl> + / / Construct a delegate response handler to use to track the ideal consistency level <nl> + AbstractWriteResponseHandler idealHandler = getWriteResponseHandler ( naturalEndpoints , <nl> + pendingEndpoints , <nl> + idealConsistencyLevel , <nl> + callback , <nl> + writeType , <nl> + queryStartNanoTime , <nl> + idealConsistencyLevel ) ; <nl> + resultResponseHandler . setIdealCLResponseHandler ( idealHandler ) ; <nl> + } <nl> + } <nl> + <nl> + return resultResponseHandler ; <nl> } <nl> <nl> private Keyspace getKeyspace ( ) <nl> diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> index 2e1c384 . . 63f8dd0 100644 <nl> - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java <nl> @ @ - 19 , 8 + 19 , 10 @ @ package org . apache . cassandra . metrics ; <nl> <nl> import java . util . Set ; <nl> <nl> + import com . codahale . metrics . Counter ; <nl> import com . codahale . metrics . Gauge ; <nl> import com . codahale . metrics . Histogram ; <nl> + import com . codahale . metrics . Meter ; <nl> import com . codahale . metrics . Timer ; <nl> import org . apache . cassandra . db . ColumnFamilyStore ; <nl> import org . apache . cassandra . db . Keyspace ; <nl> @ @ - 91 , 6 + 93 , 10 @ @ public class KeyspaceMetrics <nl> public final LatencyMetrics casPropose ; <nl> / * * CAS Commit metrics * / <nl> public final LatencyMetrics casCommit ; <nl> + / * * Writes failed ideal consistency * * / <nl> + public final Counter writeFailedIdealCL ; <nl> + / * * Ideal CL write latency metrics * / <nl> + public final LatencyMetrics idealCLWriteLatency ; <nl> <nl> public final MetricNameFactory factory ; <nl> private Keyspace keyspace ; <nl> @ @ - 236 , 6 + 242 , 8 @ @ public class KeyspaceMetrics <nl> casPrepare = new LatencyMetrics ( factory , " CasPrepare " ) ; <nl> casPropose = new LatencyMetrics ( factory , " CasPropose " ) ; <nl> casCommit = new LatencyMetrics ( factory , " CasCommit " ) ; <nl> + writeFailedIdealCL = Metrics . counter ( factory . createMetricName ( " WriteFailedIdealCL " ) ) ; <nl> + idealCLWriteLatency = new LatencyMetrics ( factory , " IdealCLWrite " ) ; <nl> } <nl> <nl> / * * <nl> @ @ - 251 , 6 + 259 , 7 @ @ public class KeyspaceMetrics <nl> readLatency . release ( ) ; <nl> writeLatency . release ( ) ; <nl> rangeLatency . release ( ) ; <nl> + idealCLWriteLatency . release ( ) ; <nl> } <nl> <nl> / * * <nl> diff - - git a / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java b / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java <nl> index 8c30b89 . . b5eaadb 100644 <nl> - - - a / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java <nl> @ @ - 22 , 6 + 22 , 7 @ @ import java . util . Collection ; <nl> import java . util . Map ; <nl> import java . util . concurrent . ConcurrentHashMap ; <nl> import java . util . concurrent . TimeUnit ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; <nl> <nl> import com . google . common . collect . Iterables ; <nl> @ @ - 40 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . concurrent . SimpleCondition ; <nl> <nl> public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackWithFailure < T > <nl> { <nl> - protected static final Logger logger = LoggerFactory . getLogger ( AbstractWriteResponseHandler . class ) ; <nl> + protected static final Logger logger = LoggerFactory . getLogger ( AbstractWriteResponseHandler . class ) ; <nl> <nl> + / / Count down until all responses and expirations have occured before deciding whether the ideal CL was reached . <nl> + private AtomicInteger responsesAndExpirations ; <nl> private final SimpleCondition condition = new SimpleCondition ( ) ; <nl> protected final Keyspace keyspace ; <nl> protected final Collection < InetAddress > naturalEndpoints ; <nl> @ @ - 50 , 14 + 53 , 22 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW <nl> protected final Collection < InetAddress > pendingEndpoints ; <nl> protected final WriteType writeType ; <nl> private static final AtomicIntegerFieldUpdater < AbstractWriteResponseHandler > failuresUpdater <nl> - = AtomicIntegerFieldUpdater . newUpdater ( AbstractWriteResponseHandler . class , " failures " ) ; <nl> + = AtomicIntegerFieldUpdater . newUpdater ( AbstractWriteResponseHandler . class , " failures " ) ; <nl> private volatile int failures = 0 ; <nl> private final Map < InetAddress , RequestFailureReason > failureReasonByEndpoint ; <nl> private final long queryStartNanoTime ; <nl> private volatile boolean supportsBackPressure = true ; <nl> <nl> / * * <nl> - * @ param callback A callback to be called when the write is successful . <nl> + * Delegate to another WriteReponseHandler or possibly this one to track if the ideal consistency level was reached . <nl> + * Will be set to null if ideal CL was not configured <nl> + * Will be set to an AWRH delegate if ideal CL was configured <nl> + * Will be same as " this " if this AWRH is the ideal consistency level <nl> + * / <nl> + private AbstractWriteResponseHandler idealCLDelegate ; <nl> + <nl> + / * * <nl> + * @ param callback A callback to be called when the write is successful . <nl> * @ param queryStartNanoTime <nl> * / <nl> protected AbstractWriteResponseHandler ( Keyspace keyspace , <nl> @ @ - 119 , 6 + 130 , 64 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW <nl> } <nl> <nl> / * * <nl> + * Set a delegate ideal CL write response handler . Note that this could be the same as this <nl> + * if the ideal CL and requested CL are the same . <nl> + * / <nl> + public void setIdealCLResponseHandler ( AbstractWriteResponseHandler handler ) <nl> + { <nl> + this . idealCLDelegate = handler ; <nl> + idealCLDelegate . responsesAndExpirations = new AtomicInteger ( naturalEndpoints . size ( ) + pendingEndpoints . size ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * This logs the response but doesn ' t do any further processing related to this write response handler <nl> + * on whether the CL was achieved . Only call this after the subclass has completed all it ' s processing <nl> + * since the subclass instance may be queried to find out if the CL was achieved . <nl> + * / <nl> + protected final void logResponseToIdealCLDelegate ( MessageIn < T > m ) <nl> + { <nl> + / / Tracking ideal CL was not configured <nl> + if ( idealCLDelegate = = null ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> + if ( idealCLDelegate = = this ) <nl> + { <nl> + / / Processing of the message was already done since this is the handler for the <nl> + / / ideal consistency level . Just decrement the counter . <nl> + decrementResponseOrExpired ( ) ; <nl> + } <nl> + else <nl> + { <nl> + / / Let the delegate do full processing , this will loop back into the branch above <nl> + / / with idealCLDelegate = = this , because the ideal write handler idealCLDelegate will always <nl> + / / be set to this in the delegate . <nl> + idealCLDelegate . response ( m ) ; <nl> + } <nl> + } <nl> + <nl> + public final void expired ( ) <nl> + { <nl> + / / Tracking ideal CL was not configured <nl> + if ( idealCLDelegate = = null ) <nl> + { <nl> + return ; <nl> + } <nl> + <nl> + / / The requested CL matched ideal CL so reuse this object <nl> + if ( idealCLDelegate = = this ) <nl> + { <nl> + decrementResponseOrExpired ( ) ; <nl> + } <nl> + else <nl> + { <nl> + / / Have the delegate track the expired response <nl> + idealCLDelegate . decrementResponseOrExpired ( ) ; <nl> + } <nl> + } <nl> + <nl> + / * * <nl> * @ return the minimum number of endpoints that must reply . <nl> * / <nl> protected int totalBlockFor ( ) <nl> @ @ - 149 , 7 + 218 , 9 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW <nl> * / <nl> protected abstract int ackCount ( ) ; <nl> <nl> - / * * null message means " response from local write " * / <nl> + / * * <nl> + * null message means " response from local write " <nl> + * / <nl> public abstract void response ( MessageIn < T > msg ) ; <nl> <nl> public void assureSufficientLiveNodes ( ) throws UnavailableException <nl> @ @ - 170 , 8 + 241 , 8 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW <nl> logger . trace ( " Got failure from { } " , from ) ; <nl> <nl> int n = waitingFor ( from ) <nl> - ? failuresUpdater . incrementAndGet ( this ) <nl> - : failures ; <nl> + ? failuresUpdater . incrementAndGet ( this ) <nl> + : failures ; <nl> <nl> failureReasonByEndpoint . put ( from , failureReason ) ; <nl> <nl> @ @ - 189 , 4 + 260 , 26 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW <nl> { <nl> this . supportsBackPressure = supportsBackPressure ; <nl> } <nl> + <nl> + / * * <nl> + * Decrement the counter for all responses / expirations and if the counter <nl> + * hits 0 check to see if the ideal consistency level ( this write response handler ) <nl> + * was reached using the signal . <nl> + * / <nl> + private final void decrementResponseOrExpired ( ) <nl> + { <nl> + int decrementedValue = responsesAndExpirations . decrementAndGet ( ) ; <nl> + if ( decrementedValue = = 0 ) <nl> + { <nl> + / / The condition being signaled is a valid proxy for the CL being achieved <nl> + if ( ! condition . isSignaled ( ) ) <nl> + { <nl> + keyspace . metric . writeFailedIdealCL . inc ( ) ; <nl> + } <nl> + else <nl> + { <nl> + keyspace . metric . idealCLWriteLatency . addNano ( System . nanoTime ( ) - queryStartNanoTime ) ; <nl> + } <nl> + } <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java <nl> index 9584611 . . 4137e3a 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java <nl> @ @ - 71 , 21 + 71 , 29 @ @ public class DatacenterSyncWriteResponseHandler < T > extends AbstractWriteResponse <nl> <nl> public void response ( MessageIn < T > message ) <nl> { <nl> - String dataCenter = message = = null <nl> - ? DatabaseDescriptor . getLocalDataCenter ( ) <nl> - : snitch . getDatacenter ( message . from ) ; <nl> + try <nl> + { <nl> + String dataCenter = message = = null <nl> + ? DatabaseDescriptor . getLocalDataCenter ( ) <nl> + : snitch . getDatacenter ( message . from ) ; <nl> + <nl> + responses . get ( dataCenter ) . getAndDecrement ( ) ; <nl> + acks . incrementAndGet ( ) ; <nl> <nl> - responses . get ( dataCenter ) . getAndDecrement ( ) ; <nl> - acks . incrementAndGet ( ) ; <nl> + for ( AtomicInteger i : responses . values ( ) ) <nl> + { <nl> + if ( i . get ( ) > 0 ) <nl> + return ; <nl> + } <nl> <nl> - for ( AtomicInteger i : responses . values ( ) ) <nl> + / / all the quorum conditions are met <nl> + signal ( ) ; <nl> + } <nl> + finally <nl> { <nl> - if ( i . get ( ) > 0 ) <nl> - return ; <nl> + / / Must be last after all subclass processing <nl> + logResponseToIdealCLDelegate ( message ) ; <nl> } <nl> - <nl> - / / all the quorum conditions are met <nl> - signal ( ) ; <nl> } <nl> <nl> protected int ackCount ( ) <nl> diff - - git a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> index 2309e87 . . 83dddcf 100644 <nl> - - - a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java <nl> @ @ - 46 , 7 + 46 , 15 @ @ public class DatacenterWriteResponseHandler < T > extends WriteResponseHandler < T > <nl> public void response ( MessageIn < T > message ) <nl> { <nl> if ( message = = null | | waitingFor ( message . from ) ) <nl> + { <nl> super . response ( message ) ; <nl> + } <nl> + else <nl> + { <nl> + / / WriteResponseHandler . response will call logResonseToIdealCLDelegate so only do it if not calling WriteResponseHandler . response . <nl> + / / Must be last after all subclass processing <nl> + logResponseToIdealCLDelegate ( message ) ; <nl> + } <nl> } <nl> <nl> @ Override <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> index 0585717 . . 6be5286 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxy . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxy . java <nl> @ @ - 561 , 9 + 561 , 16 @ @ public class StorageProxy implements StorageProxyMBean <nl> MessagingService . instance ( ) . sendOneWay ( message , destination ) ; <nl> } <nl> } <nl> - else if ( shouldHint ) <nl> + else <nl> { <nl> - submitHint ( proposal . makeMutation ( ) , destination , null ) ; <nl> + if ( responseHandler ! = null ) <nl> + { <nl> + responseHandler . expired ( ) ; <nl> + } <nl> + if ( shouldHint ) <nl> + { <nl> + submitHint ( proposal . makeMutation ( ) , destination , null ) ; <nl> + } <nl> } <nl> } <nl> <nl> @ @ - 1257 , 6 + 1264 , 8 @ @ public class StorageProxy implements StorageProxyMBean <nl> } <nl> else <nl> { <nl> + / / Immediately mark the response as expired since the request will not be sent <nl> + responseHandler . expired ( ) ; <nl> if ( shouldHint ( destination ) ) <nl> { <nl> if ( endpointsToHint = = null ) <nl> @ @ - 2774 , 4 + 2783 , 17 @ @ public class StorageProxy implements StorageProxyMBean <nl> { <nl> return Schema . instance . getNumberOfTables ( ) ; <nl> } <nl> + <nl> + public String getIdealConsistencyLevel ( ) <nl> + { <nl> + return DatabaseDescriptor . getIdealConsistencyLevel ( ) . toString ( ) ; <nl> + } <nl> + <nl> + public String setIdealConsistencyLevel ( String cl ) <nl> + { <nl> + ConsistencyLevel original = DatabaseDescriptor . getIdealConsistencyLevel ( ) ; <nl> + ConsistencyLevel newCL = ConsistencyLevel . valueOf ( cl . trim ( ) . toUpperCase ( ) ) ; <nl> + DatabaseDescriptor . setIdealConsistencyLevel ( newCL ) ; <nl> + return String . format ( " Updating ideal consistency level new value : % s old value % s " , newCL , original . toString ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / StorageProxyMBean . java b / src / java / org / apache / cassandra / service / StorageProxyMBean . java <nl> index 0a4ba19 . . 97f7615 100644 <nl> - - - a / src / java / org / apache / cassandra / service / StorageProxyMBean . java <nl> + + + b / src / java / org / apache / cassandra / service / StorageProxyMBean . java <nl> @ @ - 21 , 6 + 21 , 8 @ @ import java . util . List ; <nl> import java . util . Map ; <nl> import java . util . Set ; <nl> <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + <nl> public interface StorageProxyMBean <nl> { <nl> public long getTotalHints ( ) ; <nl> @ @ - 63 , 4 + 65 , 7 @ @ public interface StorageProxyMBean <nl> public Map < String , List < String > > getSchemaVersions ( ) ; <nl> <nl> public int getNumberOfTables ( ) ; <nl> + <nl> + public String getIdealConsistencyLevel ( ) ; <nl> + public String setIdealConsistencyLevel ( String cl ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> index 46e4e93 . . 55ca5aa 100644 <nl> - - - a / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java <nl> @ @ - 68 , 6 + 68 , 10 @ @ public class WriteResponseHandler < T > extends AbstractWriteResponseHandler < T > <nl> { <nl> if ( responsesUpdater . decrementAndGet ( this ) = = 0 ) <nl> signal ( ) ; <nl> + / / Must be last after all subclass processing <nl> + / / The two current subclasses both assume logResponseToIdealCLDelegate is called <nl> + / / here . <nl> + logResponseToIdealCLDelegate ( m ) ; <nl> } <nl> <nl> protected int ackCount ( ) <nl> diff - - git a / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java b / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java <nl> index c8f8bc1 . . b915854 100644 <nl> - - - a / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java <nl> + + + b / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java <nl> @ @ - 81 , 6 + 81 , 7 @ @ public class DatabaseDescriptorRefTest <nl> " org . apache . cassandra . config . YamlConfigurationLoader $ PropertiesChecker $ 1 " , <nl> " org . apache . cassandra . config . YamlConfigurationLoader $ CustomConstructor " , <nl> " org . apache . cassandra . config . TransparentDataEncryptionOptions " , <nl> + " org . apache . cassandra . db . ConsistencyLevel " , <nl> " org . apache . cassandra . dht . IPartitioner " , <nl> " org . apache . cassandra . exceptions . ConfigurationException " , <nl> " org . apache . cassandra . exceptions . RequestValidationException " , <nl> diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java <nl> new file mode 100644 <nl> index 0000000 . . 815dbf6 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java <nl> @ @ - 0 , 0 + 1 , 234 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . service ; <nl> + <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Collection ; <nl> + import java . util . List ; <nl> + import java . util . UUID ; <nl> + import java . util . concurrent . TimeUnit ; <nl> + <nl> + import com . google . common . collect . ImmutableList ; <nl> + import org . junit . Before ; <nl> + import org . junit . BeforeClass ; <nl> + import org . junit . Test ; <nl> + <nl> + import org . apache . cassandra . SchemaLoader ; <nl> + import org . apache . cassandra . config . DatabaseDescriptor ; <nl> + import org . apache . cassandra . db . ColumnFamilyStore ; <nl> + import org . apache . cassandra . db . ConsistencyLevel ; <nl> + import org . apache . cassandra . db . Keyspace ; <nl> + import org . apache . cassandra . db . WriteType ; <nl> + import org . apache . cassandra . locator . IEndpointSnitch ; <nl> + import org . apache . cassandra . locator . TokenMetadata ; <nl> + import org . apache . cassandra . net . MessageIn ; <nl> + import org . apache . cassandra . schema . KeyspaceParams ; <nl> + <nl> + import static org . junit . Assert . assertEquals ; <nl> + import static org . junit . Assert . assertTrue ; <nl> + <nl> + public class WriteResponseHandlerTest <nl> + { <nl> + static Keyspace ks ; <nl> + static ColumnFamilyStore cfs ; <nl> + static List < InetAddress > targets ; <nl> + <nl> + @ BeforeClass <nl> + public static void setUpClass ( ) throws Throwable <nl> + { <nl> + SchemaLoader . loadSchema ( ) ; <nl> + / / Register peers with expected DC for NetworkTopologyStrategy . <nl> + TokenMetadata metadata = StorageService . instance . getTokenMetadata ( ) ; <nl> + metadata . clearUnsafe ( ) ; <nl> + metadata . updateHostId ( UUID . randomUUID ( ) , InetAddress . getByName ( " 127 . 1 . 0 . 255 " ) ) ; <nl> + metadata . updateHostId ( UUID . randomUUID ( ) , InetAddress . getByName ( " 127 . 2 . 0 . 255 " ) ) ; <nl> + <nl> + DatabaseDescriptor . setEndpointSnitch ( new IEndpointSnitch ( ) <nl> + { <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + byte [ ] address = endpoint . getAddress ( ) ; <nl> + if ( address [ 1 ] = = 1 ) <nl> + return " datacenter1 " ; <nl> + else <nl> + return " datacenter2 " ; <nl> + } <nl> + <nl> + public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) <nl> + { <nl> + return null ; <nl> + } <nl> + <nl> + public void sortByProximity ( InetAddress address , List < InetAddress > addresses ) <nl> + { <nl> + <nl> + } <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return 0 ; <nl> + } <nl> + <nl> + public void gossiperStarting ( ) <nl> + { <nl> + <nl> + } <nl> + <nl> + public boolean isWorthMergingForRangeQuery ( List < InetAddress > merged , List < InetAddress > l1 , List < InetAddress > l2 ) <nl> + { <nl> + return false ; <nl> + } <nl> + } ) ; <nl> + DatabaseDescriptor . setBroadcastAddress ( InetAddress . getByName ( " 127 . 1 . 0 . 1 " ) ) ; <nl> + SchemaLoader . createKeyspace ( " Foo " , KeyspaceParams . nts ( " datacenter1 " , 3 , " datacenter2 " , 3 ) , SchemaLoader . standardCFMD ( " Foo " , " Bar " ) ) ; <nl> + ks = Keyspace . open ( " Foo " ) ; <nl> + cfs = ks . getColumnFamilyStore ( " Bar " ) ; <nl> + targets = ImmutableList . of ( InetAddress . getByName ( " 127 . 1 . 0 . 255 " ) , InetAddress . getByName ( " 127 . 1 . 0 . 254 " ) , InetAddress . getByName ( " 127 . 1 . 0 . 253 " ) , <nl> + InetAddress . getByName ( " 127 . 2 . 0 . 255 " ) , InetAddress . getByName ( " 127 . 2 . 0 . 254 " ) , InetAddress . getByName ( " 127 . 2 . 0 . 253 " ) ) ; <nl> + } <nl> + <nl> + <nl> + @ Before <nl> + public void resetCounters ( ) <nl> + { <nl> + ks . metric . writeFailedIdealCL . dec ( ks . metric . writeFailedIdealCL . getCount ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validate that failing to achieve ideal CL increments the failure counter <nl> + * @ throws Throwable <nl> + * / <nl> + @ Test <nl> + public void failedIdealCLIncrementsStat ( ) throws Throwable <nl> + { <nl> + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM ) ; <nl> + <nl> + / / Succeed in local DC <nl> + awr . response ( createDummyMessage ( 0 ) ) ; <nl> + awr . response ( createDummyMessage ( 1 ) ) ; <nl> + awr . response ( createDummyMessage ( 2 ) ) ; <nl> + <nl> + / / Fail in remote DC <nl> + awr . expired ( ) ; <nl> + awr . expired ( ) ; <nl> + awr . expired ( ) ; <nl> + assertEquals ( 1 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; <nl> + assertEquals ( 0 , ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validate that a successful write at ideal CL logs latency information . Also validates <nl> + * DatacenterSyncWriteResponseHandler <nl> + * @ throws Throwable <nl> + * / <nl> + @ Test <nl> + public void idealCLLatencyTracked ( ) throws Throwable <nl> + { <nl> + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; <nl> + / / Specify query start time in past to ensure minimum latency measurement <nl> + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM , System . nanoTime ( ) - TimeUnit . DAYS . toNanos ( 1 ) ) ; <nl> + <nl> + / / dc1 <nl> + awr . response ( createDummyMessage ( 0 ) ) ; <nl> + awr . response ( createDummyMessage ( 1 ) ) ; <nl> + / / dc2 <nl> + awr . response ( createDummyMessage ( 4 ) ) ; <nl> + awr . response ( createDummyMessage ( 5 ) ) ; <nl> + <nl> + / / Don ' t need the others <nl> + awr . expired ( ) ; <nl> + awr . expired ( ) ; <nl> + <nl> + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; <nl> + assertTrue ( TimeUnit . DAYS . toMicros ( 1 ) < ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; <nl> + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validate that WriteResponseHandler does the right thing on success . <nl> + * @ throws Throwable <nl> + * / <nl> + @ Test <nl> + public void idealCLWriteResponeHandlerWorks ( ) throws Throwable <nl> + { <nl> + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; <nl> + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . ALL ) ; <nl> + <nl> + / / dc1 <nl> + awr . response ( createDummyMessage ( 0 ) ) ; <nl> + awr . response ( createDummyMessage ( 1 ) ) ; <nl> + awr . response ( createDummyMessage ( 2 ) ) ; <nl> + / / dc2 <nl> + awr . response ( createDummyMessage ( 3 ) ) ; <nl> + awr . response ( createDummyMessage ( 4 ) ) ; <nl> + awr . response ( createDummyMessage ( 5 ) ) ; <nl> + <nl> + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; <nl> + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; <nl> + } <nl> + <nl> + / * * <nl> + * Validate that DatacenterWriteResponseHandler does the right thing on success . <nl> + * @ throws Throwable <nl> + * / <nl> + @ Test <nl> + public void idealCLDatacenterWriteResponeHandlerWorks ( ) throws Throwable <nl> + { <nl> + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; <nl> + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . ONE , ConsistencyLevel . LOCAL _ QUORUM ) ; <nl> + <nl> + / / dc1 <nl> + awr . response ( createDummyMessage ( 0 ) ) ; <nl> + awr . response ( createDummyMessage ( 1 ) ) ; <nl> + awr . response ( createDummyMessage ( 2 ) ) ; <nl> + / / dc2 <nl> + awr . response ( createDummyMessage ( 3 ) ) ; <nl> + awr . response ( createDummyMessage ( 4 ) ) ; <nl> + awr . response ( createDummyMessage ( 5 ) ) ; <nl> + <nl> + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; <nl> + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; <nl> + } <nl> + <nl> + private static AbstractWriteResponseHandler createWriteResponseHandler ( ConsistencyLevel cl , ConsistencyLevel ideal ) <nl> + { <nl> + return createWriteResponseHandler ( cl , ideal , System . nanoTime ( ) ) ; <nl> + } <nl> + <nl> + private static AbstractWriteResponseHandler createWriteResponseHandler ( ConsistencyLevel cl , ConsistencyLevel ideal , long queryStartTime ) <nl> + { <nl> + return ks . getReplicationStrategy ( ) . getWriteResponseHandler ( targets , ImmutableList . of ( ) , cl , new Runnable ( ) { <nl> + public void run ( ) <nl> + { <nl> + <nl> + } <nl> + } , WriteType . SIMPLE , queryStartTime , ideal ) ; <nl> + } <nl> + <nl> + private static MessageIn createDummyMessage ( int target ) <nl> + { <nl> + return MessageIn . create ( targets . get ( target ) , null , null , null , 0 , 0L ) ; <nl> + } <nl> + }
NEAREST DIFF (one line): diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml <nl> index 30f85a4 . . 11499a6 100644 <nl> - - - a / conf / cassandra . yaml <nl> + + + b / conf / cassandra . yaml <nl> @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler <nl> # the request scheduling . The current supported option is " keyspace " <nl> request _ scheduler _ id : keyspace <nl> <nl> + # dynamic _ snitch - - This boolean controls whether the above snitch is <nl> + # wrapped with a dynamic snitch , which will monitor read latencies <nl> + # and avoid reading from hosts that have slowed ( due to compaction , <nl> + # for instance ) <nl> + dynamic _ snitch : false <nl> + <nl> # A ColumnFamily is the Cassandra concept closest to a relational table . <nl> # <nl> # Keyspaces are separate groups of ColumnFamilies . Except in very <nl> diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java <nl> index 2a5478e . . 315c9a4 100644 <nl> - - - a / src / java / org / apache / cassandra / config / Config . java <nl> + + + b / src / java / org / apache / cassandra / config / Config . java <nl> @ @ - 71 , 6 + 71 , 7 @ @ public class Config { <nl> public Integer commitlog _ sync _ period _ in _ ms ; <nl> <nl> public String endpoint _ snitch ; <nl> + public Boolean dynamic _ snitch = false ; <nl> <nl> public String request _ scheduler ; <nl> public RequestSchedulerId request _ scheduler _ id ; <nl> diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> index 0947af0 . . b5f9302 100644 <nl> - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java <nl> @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; <nl> import java . net . UnknownHostException ; <nl> import java . util . * ; <nl> <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> <nl> @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor <nl> throw ( ConfigurationException ) e . getCause ( ) ; <nl> throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; <nl> } <nl> - return snitch ; <nl> + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; <nl> } <nl> <nl> - public static void loadSchemas ( ) throws IOException <nl> + public static void loadSchemas ( ) throws IOException <nl> { <nl> / / we can load tables from local storage if a version is set in the system table and that acutally maps to <nl> / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> index 4892281 . . 2ef4980 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java <nl> @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; <nl> <nl> import java . net . InetAddress ; <nl> import java . util . Collection ; <nl> + import java . util . Comparator ; <nl> import java . util . List ; <nl> import java . util . concurrent . CopyOnWriteArrayList ; <nl> <nl> @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch <nl> <nl> public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; <nl> + } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> index acb1d16 . . c40f995 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java <nl> @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch <nl> { <nl> public int compare ( InetAddress a1 , InetAddress a2 ) <nl> { <nl> - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> - return - 1 ; <nl> - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> - return 1 ; <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } ; <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> <nl> - String addressRack = getRack ( address ) ; <nl> - String a1Rack = getRack ( a1 ) ; <nl> - String a2Rack = getRack ( a2 ) ; <nl> - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> - return - 1 ; <nl> - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> - return 1 ; <nl> + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) <nl> + return - 1 ; <nl> + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) <nl> + return 1 ; <nl> <nl> - String addressDatacenter = getDatacenter ( address ) ; <nl> - String a1Datacenter = getDatacenter ( a1 ) ; <nl> - String a2Datacenter = getDatacenter ( a2 ) ; <nl> - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> - return - 1 ; <nl> - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> - return 1 ; <nl> + String addressRack = getRack ( address ) ; <nl> + String a1Rack = getRack ( a1 ) ; <nl> + String a2Rack = getRack ( a2 ) ; <nl> + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) <nl> + return - 1 ; <nl> + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) <nl> + return 1 ; <nl> <nl> - return 0 ; <nl> - } <nl> - } ) ; <nl> - return addresses ; <nl> + String addressDatacenter = getDatacenter ( address ) ; <nl> + String a1Datacenter = getDatacenter ( a1 ) ; <nl> + String a2Datacenter = getDatacenter ( a2 ) ; <nl> + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) <nl> + return - 1 ; <nl> + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) <nl> + return 1 ; <nl> + <nl> + return 0 ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> new file mode 100644 <nl> index 0000000 . . cb2f03b <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java <nl> @ @ - 0 , 0 + 1 , 238 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . * ; <nl> + import java . util . concurrent . LinkedBlockingDeque ; <nl> + import java . util . concurrent . ConcurrentHashMap ; <nl> + import java . util . concurrent . atomic . AtomicInteger ; <nl> + <nl> + import java . lang . management . ManagementFactory ; <nl> + import javax . management . MBeanServer ; <nl> + import javax . management . ObjectName ; <nl> + <nl> + import org . apache . cassandra . net . IVerbHandler ; <nl> + import org . apache . cassandra . net . MessagingService ; <nl> + import org . apache . cassandra . net . ResponseVerbHandler ; <nl> + import org . apache . cassandra . service . StorageService ; <nl> + import org . apache . cassandra . utils . AbstractStatsDeque ; <nl> + import org . apache . cassandra . locator . IEndpointSnitch ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + import org . apache . cassandra . locator . AbstractEndpointSnitch ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + / * * <nl> + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector <nl> + * / <nl> + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean <nl> + { <nl> + private static int UPDATES _ PER _ INTERVAL = 100 ; <nl> + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; <nl> + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; <nl> + private static int WINDOW _ SIZE = 100 ; <nl> + private boolean registered = false ; <nl> + <nl> + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; <nl> + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; <nl> + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; <nl> + public IEndpointSnitch subsnitch ; <nl> + <nl> + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) <nl> + { <nl> + subsnitch = snitch ; <nl> + TimerTask update = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + updateScores ( ) ; <nl> + } <nl> + } ; <nl> + TimerTask reset = new TimerTask ( ) <nl> + { <nl> + public void run ( ) <nl> + { <nl> + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try <nl> + / / to read from it , which would cause its score to never change <nl> + reset ( ) ; <nl> + } <nl> + } ; <nl> + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; <nl> + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; <nl> + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; <nl> + <nl> + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; <nl> + try <nl> + { <nl> + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; <nl> + } <nl> + catch ( Exception e ) <nl> + { <nl> + throw new RuntimeException ( e ) ; <nl> + } <nl> + } <nl> + <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getRack ( endpoint ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + return subsnitch . getDatacenter ( endpoint ) ; <nl> + } <nl> + <nl> + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> + { <nl> + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; <nl> + sortByProximity ( address , list ) ; <nl> + return list ; <nl> + } <nl> + <nl> + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) <nl> + { <nl> + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself <nl> + Collections . sort ( addresses , new Comparator < InetAddress > ( ) <nl> + { <nl> + public int compare ( InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + return compareEndpoints ( address , a1 , a2 ) ; <nl> + } <nl> + } ) ; <nl> + return addresses ; <nl> + } <nl> + <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) <nl> + { <nl> + Double scored1 = scores . get ( a1 ) ; <nl> + Double scored2 = scores . get ( a2 ) ; <nl> + <nl> + if ( scored1 = = null | | scored2 = = null ) <nl> + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; <nl> + if ( scored1 . equals ( scored2 ) ) <nl> + return 0 ; <nl> + if ( scored1 < scored2 ) <nl> + return 1 ; <nl> + else <nl> + return - 1 ; <nl> + } <nl> + <nl> + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap <nl> + { <nl> + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) <nl> + return ; <nl> + AdaptiveLatencyTracker tracker = windows . get ( host ) ; <nl> + if ( tracker = = null ) <nl> + { <nl> + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; <nl> + tracker = windows . putIfAbsent ( host , alt ) ; <nl> + if ( tracker = = null ) <nl> + tracker = alt ; <nl> + } <nl> + tracker . add ( latency ) ; <nl> + intervalupdates . getAndIncrement ( ) ; <nl> + } <nl> + <nl> + private void updateScores ( ) / / this is expensive <nl> + { <nl> + if ( ! registered ) <nl> + { <nl> + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; <nl> + if ( handler ! = null ) <nl> + { <nl> + handler . register ( this ) ; <nl> + registered = true ; <nl> + } <nl> + <nl> + } <nl> + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) <nl> + { <nl> + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; <nl> + } <nl> + intervalupdates . set ( 0 ) ; <nl> + } <nl> + <nl> + private void reset ( ) <nl> + { <nl> + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) <nl> + { <nl> + tracker . clear ( ) ; <nl> + } <nl> + } <nl> + <nl> + public Map < InetAddress , Double > getScores ( ) <nl> + { <nl> + return scores ; <nl> + } <nl> + } <nl> + <nl> + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / <nl> + class AdaptiveLatencyTracker extends AbstractStatsDeque <nl> + { <nl> + private LinkedBlockingDeque latencies ; <nl> + private final int size ; <nl> + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter <nl> + <nl> + AdaptiveLatencyTracker ( int size ) <nl> + { <nl> + this . size = size ; <nl> + latencies = new LinkedBlockingDeque ( size ) ; <nl> + } <nl> + <nl> + public void add ( double i ) <nl> + { <nl> + latencies . offer ( i ) ; <nl> + } <nl> + <nl> + public void clear ( ) <nl> + { <nl> + latencies . clear ( ) ; <nl> + } <nl> + <nl> + public Iterator < Double > iterator ( ) <nl> + { <nl> + return latencies . iterator ( ) ; <nl> + } <nl> + <nl> + public int size ( ) <nl> + { <nl> + return latencies . size ( ) ; <nl> + } <nl> + <nl> + double p ( double t ) <nl> + { <nl> + double mean = mean ( ) ; <nl> + double exponent = ( - 1 ) * ( t ) / mean ; <nl> + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; <nl> + } <nl> + <nl> + double score ( ) <nl> + { <nl> + double log = 0d ; <nl> + if ( latencies . size ( ) > 0 ) <nl> + { <nl> + double probability = p ( SENTINEL _ COMPARE ) ; <nl> + log = ( - 1 ) * Math . log10 ( probability ) ; <nl> + } <nl> + return log ; <nl> + } <nl> + <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> new file mode 100644 <nl> index 0000000 . . 26c5799 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java <nl> @ @ - 0 , 0 + 1 , 27 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . util . Map ; <nl> + <nl> + public interface DynamicEndpointSnitchMBean { <nl> + public Map < InetAddress , Double > getScores ( ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> index ca451c0 . . 091c4c2 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java <nl> @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; <nl> public interface IEndpointSnitch <nl> { <nl> / * * <nl> + * returns a String repesenting the rack this endpoint belongs to <nl> + * / <nl> + public String getRack ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> + * returns a String representing the datacenter this endpoint belongs to <nl> + * / <nl> + public String getDatacenter ( InetAddress endpoint ) ; <nl> + <nl> + / * * <nl> * returns a new < tt > List < / tt > sorted by proximity to the given endpoint <nl> * / <nl> public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; <nl> @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch <nl> * @ param subscriber the subscriber to notify <nl> * / <nl> public void register ( AbstractReplicationStrategy subscriber ) ; <nl> + <nl> + / * * <nl> + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would <nl> + * / <nl> + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> new file mode 100644 <nl> index 0000000 . . 0d97e84 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> + <nl> + public interface ILatencyPublisher <nl> + { <nl> + public void register ( ILatencySubscriber subcriber ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> new file mode 100644 <nl> index 0000000 . . 6cfcf33 <nl> - - - / dev / null <nl> + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java <nl> @ @ - 0 , 0 + 1 , 26 @ @ <nl> + / * * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , software <nl> + * distributed under the License is distributed on an " AS IS " BASIS , <nl> + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . <nl> + * See the License for the specific language governing permissions and <nl> + * limitations under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + <nl> + public interface ILatencySubscriber <nl> + { <nl> + public void receiveTiming ( InetAddress address , Double latency ) ; <nl> + } <nl> diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> index c2fd8b5 . . dd8fb68 100644 <nl> - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java <nl> @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; <nl> import java . util . Collection ; <nl> import java . util . List ; <nl> <nl> + import org . apache . commons . lang . NotImplementedException ; <nl> + <nl> / * * <nl> * A simple endpoint snitch implementation does not sort addresses by <nl> * proximity . <nl> * / <nl> public class SimpleSnitch extends AbstractEndpointSnitch <nl> { <nl> + public String getRack ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> + public String getDatacenter ( InetAddress endpoint ) <nl> + { <nl> + throw new NotImplementedException ( ) ; <nl> + } <nl> + <nl> public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) <nl> { <nl> return new ArrayList < InetAddress > ( addresses ) ; <nl> diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java <nl> index 474d7c2 . . efd2545 100644 <nl> - - - a / src / java / org / apache / cassandra / net / MessagingService . java <nl> + + + b / src / java / org / apache / cassandra / net / MessagingService . java <nl> @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener <nl> return taskCompletionMap _ . remove ( key ) ; <nl> } <nl> <nl> + public static long getRegisteredCallbackAge ( String key ) <nl> + { <nl> + return callbackMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> + public static long getAsyncResultAge ( String key ) <nl> + { <nl> + return taskCompletionMap _ . getAge ( key ) ; <nl> + } <nl> + <nl> public static ExecutorService getDeserializationExecutor ( ) <nl> { <nl> return messageDeserializerExecutor _ ; <nl> diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> index 020d187 . . cde87b2 100644 <nl> - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java <nl> @ @ - 18 , 21 + 18 , 30 @ @ <nl> <nl> package org . apache . cassandra . net ; <nl> <nl> + <nl> + import java . util . * ; <nl> + import java . net . InetAddress ; <nl> import org . slf4j . Logger ; <nl> import org . slf4j . LoggerFactory ; <nl> + import org . apache . cassandra . locator . ILatencyPublisher ; <nl> + import org . apache . cassandra . locator . ILatencySubscriber ; <nl> <nl> - public class ResponseVerbHandler implements IVerbHandler <nl> + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher <nl> { <nl> private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; <nl> - <nl> + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; <nl> + <nl> + <nl> public void doVerb ( Message message ) <nl> { <nl> String messageId = message . getMessageId ( ) ; <nl> IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; <nl> + double age = 0 ; <nl> if ( cb ! = null ) <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; <nl> cb . response ( message ) ; <nl> } <nl> else <nl> @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler <nl> { <nl> if ( logger _ . isDebugEnabled ( ) ) <nl> logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; <nl> + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; <nl> ar . result ( message ) ; <nl> } <nl> } <nl> + notifySubscribers ( message . getFrom ( ) , age ) ; <nl> + } <nl> + <nl> + private void notifySubscribers ( InetAddress host , double latency ) <nl> + { <nl> + for ( ILatencySubscriber subscriber : subscribers ) <nl> + { <nl> + subscriber . receiveTiming ( host , latency ) ; <nl> + } <nl> + } <nl> + <nl> + public void register ( ILatencySubscriber subscriber ) <nl> + { <nl> + subscribers . add ( subscriber ) ; <nl> } <nl> } <nl> diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> index dfaadf7 . . aa2c7ec 100644 <nl> - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java <nl> @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > <nl> return result ; <nl> } <nl> <nl> + public long getAge ( K key ) <nl> + { <nl> + long age = 0 ; <nl> + CacheableObject < V > co = cache . get ( key ) ; <nl> + if ( co ! = null ) <nl> + { <nl> + age = co . age ; <nl> + } <nl> + return age ; <nl> + } <nl> + <nl> public int size ( ) <nl> { <nl> return cache . size ( ) ; <nl> diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> new file mode 100644 <nl> index 0000000 . . 62904b4 <nl> - - - / dev / null <nl> + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java <nl> @ @ - 0 , 0 + 1 , 109 @ @ <nl> + / * <nl> + * Licensed to the Apache Software Foundation ( ASF ) under one <nl> + * or more contributor license agreements . See the NOTICE file <nl> + * distributed with this work for additional information <nl> + * regarding copyright ownership . The ASF licenses this file <nl> + * to you under the Apache License , Version 2 . 0 ( the <nl> + * " License " ) ; you may not use this file except in compliance <nl> + * with the License . You may obtain a copy of the License at <nl> + * <nl> + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 <nl> + * <nl> + * Unless required by applicable law or agreed to in writing , <nl> + * software distributed under the License is distributed on an <nl> + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY <nl> + * KIND , either express or implied . See the License for the <nl> + * specific language governing permissions and limitations <nl> + * under the License . <nl> + * / <nl> + <nl> + package org . apache . cassandra . locator ; <nl> + <nl> + import java . net . InetAddress ; <nl> + import java . net . UnknownHostException ; <nl> + import java . util . ArrayList ; <nl> + <nl> + import org . junit . Test ; <nl> + <nl> + import static org . junit . Assert . * ; <nl> + import org . apache . cassandra . locator . DynamicEndpointSnitch ; <nl> + import org . apache . cassandra . locator . SimpleSnitch ; <nl> + import org . apache . cassandra . utils . FBUtilities ; <nl> + <nl> + public class DynamicEndpointSnitchTest <nl> + { <nl> + @ Test <nl> + public void testSnitch ( ) throws UnknownHostException , InterruptedException <nl> + { <nl> + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; <nl> + InetAddress self = FBUtilities . getLocalAddress ( ) ; <nl> + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; <nl> + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; <nl> + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; <nl> + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; <nl> + <nl> + / / first , make all hosts equal <nl> + for ( int i = 0 ; i < 5 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + <nl> + Thread . sleep ( 1500 ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host1 a little worse <nl> + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host2 a little worse <nl> + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host3 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + <nl> + / / make host3 the worst <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host2 ) ; <nl> + order . add ( host1 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + / / make host3 equal to the others <nl> + for ( int i = 0 ; i < 2 ; i + + ) <nl> + { <nl> + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; <nl> + } <nl> + Thread . sleep ( 1500 ) ; <nl> + order . clear ( ) ; <nl> + <nl> + order . add ( host1 ) ; <nl> + order . add ( host2 ) ; <nl> + order . add ( host3 ) ; <nl> + <nl> + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; <nl> + } <nl> + }

TEST DIFF:
diff - - git a / CHANGES . txt b / CHANGES . txt 
 index 6a164ee . . d4b53d0 100644 
 - - - a / CHANGES . txt 
 + + + b / CHANGES . txt 
 @ @ - 1 , 4 + 1 , 5 @ @ 
 4 . 0 
 + * Make it possible to monitor an ideal consistency level separate from actual consistency level ( CASSANDRA - 13289 ) 
 * Outbound TCP connections ignore internode authenticator ( CASSANDRA - 13324 ) 
 * Upgrade junit from 4 . 6 to 4 . 12 ( CASSANDRA - 13360 ) 
 * Cleanup ParentRepairSession after repairs ( CASSANDRA - 13359 ) 
 diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index d8392a0 . . f2c4c84 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 1120 , 3 + 1120 , 8 @ @ back _ pressure _ strategy : 
 
 # Do not try to coalesce messages if we already got that many messages . This should be more than 2 and less than 128 . 
 # otc _ coalescing _ enough _ coalesced _ messages : 8 
 + 
 + # Track a metric per keyspace indicating whether replication achieved the ideal consistency 
 + # level for writes without timing out . This is different from the consistency level requested by 
 + # each write which may be lower in order to facilitate availability . 
 + # ideal _ consistency _ level : EACH _ QUORUM 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 36ce576 . . 1461cd4 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 32 , 6 + 32 , 8 @ @ import com . google . common . collect . Sets ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + 
 / * * 
 * A class that contains configuration properties for the cassandra node it runs within . 
 * 
 @ @ - 271 , 6 + 273 , 12 @ @ public class Config 
 public int tracetype _ query _ ttl = ( int ) TimeUnit . DAYS . toSeconds ( 1 ) ; 
 public int tracetype _ repair _ ttl = ( int ) TimeUnit . DAYS . toSeconds ( 7 ) ; 
 
 + / * * 
 + * Maintain statistics on whether writes achieve the ideal consistency level 
 + * before expiring and becoming hints 
 + * / 
 + public volatile ConsistencyLevel ideal _ consistency _ level = null ; 
 + 
 / * 
 * Strategy to use for coalescing messages in OutboundTcpConnection . 
 * Can be fixed , movingaverage , timehorizon , disabled . Setting is case and leading / trailing 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 465cd8a . . debf161 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 44 , 6 + 44 , 7 @ @ import org . apache . cassandra . auth . IAuthorizer ; 
 import org . apache . cassandra . auth . IInternodeAuthenticator ; 
 import org . apache . cassandra . auth . IRoleManager ; 
 import org . apache . cassandra . config . Config . CommitLogSync ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 import org . apache . cassandra . dht . IPartitioner ; 
 import org . apache . cassandra . exceptions . ConfigurationException ; 
 import org . apache . cassandra . io . FSWriteError ; 
 @ @ - 2269 , 4 + 2270 , 14 @ @ public class DatabaseDescriptor 
 { 
 return backPressureStrategy ; 
 } 
 + 
 + public static ConsistencyLevel getIdealConsistencyLevel ( ) 
 + { 
 + return conf . ideal _ consistency _ level ; 
 + } 
 + 
 + public static void setIdealConsistencyLevel ( ConsistencyLevel cl ) 
 + { 
 + conf . ideal _ consistency _ level = cl ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 index 9c43486 . . c3498d9 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractReplicationStrategy . java 
 @ @ - 28 , 6 + 28 , 7 @ @ import com . google . common . collect . Multimap ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 import org . apache . cassandra . db . ConsistencyLevel ; 
 import org . apache . cassandra . db . Keyspace ; 
 import org . apache . cassandra . db . WriteType ; 
 @ @ - 40 , 6 + 41 , 7 @ @ import org . apache . cassandra . service . DatacenterSyncWriteResponseHandler ; 
 import org . apache . cassandra . service . DatacenterWriteResponseHandler ; 
 import org . apache . cassandra . service . WriteResponseHandler ; 
 import org . apache . cassandra . utils . FBUtilities ; 
 + 
 import org . cliffc . high _ scale _ lib . NonBlockingHashMap ; 
 
 / * * 
 @ @ - 135 , 16 + 137 , 57 @ @ public abstract class AbstractReplicationStrategy 
 WriteType writeType , 
 long queryStartNanoTime ) 
 { 
 + return getWriteResponseHandler ( naturalEndpoints , pendingEndpoints , consistency _ level , callback , writeType , queryStartNanoTime , DatabaseDescriptor . getIdealConsistencyLevel ( ) ) ; 
 + } 
 + 
 + public < T > AbstractWriteResponseHandler < T > getWriteResponseHandler ( Collection < InetAddress > naturalEndpoints , 
 + Collection < InetAddress > pendingEndpoints , 
 + ConsistencyLevel consistency _ level , 
 + Runnable callback , 
 + WriteType writeType , 
 + long queryStartNanoTime , 
 + ConsistencyLevel idealConsistencyLevel ) 
 + { 
 + AbstractWriteResponseHandler resultResponseHandler ; 
 if ( consistency _ level . isDatacenterLocal ( ) ) 
 { 
 / / block for in this context will be localnodes block . 
 - return new DatacenterWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 + resultResponseHandler = new DatacenterWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 } 
 else if ( consistency _ level = = ConsistencyLevel . EACH _ QUORUM & & ( this instanceof NetworkTopologyStrategy ) ) 
 { 
 - return new DatacenterSyncWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 + resultResponseHandler = new DatacenterSyncWriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 } 
 - return new WriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 + else 
 + { 
 + resultResponseHandler = new WriteResponseHandler < T > ( naturalEndpoints , pendingEndpoints , consistency _ level , getKeyspace ( ) , callback , writeType , queryStartNanoTime ) ; 
 + } 
 + 
 + / / Check if tracking the ideal consistency level is configured 
 + if ( idealConsistencyLevel ! = null ) 
 + { 
 + / / If ideal and requested are the same just use this handler to track the ideal consistency level 
 + / / This is also used so that the ideal consistency level handler when constructed knows it is the ideal 
 + / / one for tracking purposes 
 + if ( idealConsistencyLevel = = consistency _ level ) 
 + { 
 + resultResponseHandler . setIdealCLResponseHandler ( resultResponseHandler ) ; 
 + } 
 + else 
 + { 
 + / / Construct a delegate response handler to use to track the ideal consistency level 
 + AbstractWriteResponseHandler idealHandler = getWriteResponseHandler ( naturalEndpoints , 
 + pendingEndpoints , 
 + idealConsistencyLevel , 
 + callback , 
 + writeType , 
 + queryStartNanoTime , 
 + idealConsistencyLevel ) ; 
 + resultResponseHandler . setIdealCLResponseHandler ( idealHandler ) ; 
 + } 
 + } 
 + 
 + return resultResponseHandler ; 
 } 
 
 private Keyspace getKeyspace ( ) 
 diff - - git a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 index 2e1c384 . . 63f8dd0 100644 
 - - - a / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 + + + b / src / java / org / apache / cassandra / metrics / KeyspaceMetrics . java 
 @ @ - 19 , 8 + 19 , 10 @ @ package org . apache . cassandra . metrics ; 
 
 import java . util . Set ; 
 
 + import com . codahale . metrics . Counter ; 
 import com . codahale . metrics . Gauge ; 
 import com . codahale . metrics . Histogram ; 
 + import com . codahale . metrics . Meter ; 
 import com . codahale . metrics . Timer ; 
 import org . apache . cassandra . db . ColumnFamilyStore ; 
 import org . apache . cassandra . db . Keyspace ; 
 @ @ - 91 , 6 + 93 , 10 @ @ public class KeyspaceMetrics 
 public final LatencyMetrics casPropose ; 
 / * * CAS Commit metrics * / 
 public final LatencyMetrics casCommit ; 
 + / * * Writes failed ideal consistency * * / 
 + public final Counter writeFailedIdealCL ; 
 + / * * Ideal CL write latency metrics * / 
 + public final LatencyMetrics idealCLWriteLatency ; 
 
 public final MetricNameFactory factory ; 
 private Keyspace keyspace ; 
 @ @ - 236 , 6 + 242 , 8 @ @ public class KeyspaceMetrics 
 casPrepare = new LatencyMetrics ( factory , " CasPrepare " ) ; 
 casPropose = new LatencyMetrics ( factory , " CasPropose " ) ; 
 casCommit = new LatencyMetrics ( factory , " CasCommit " ) ; 
 + writeFailedIdealCL = Metrics . counter ( factory . createMetricName ( " WriteFailedIdealCL " ) ) ; 
 + idealCLWriteLatency = new LatencyMetrics ( factory , " IdealCLWrite " ) ; 
 } 
 
 / * * 
 @ @ - 251 , 6 + 259 , 7 @ @ public class KeyspaceMetrics 
 readLatency . release ( ) ; 
 writeLatency . release ( ) ; 
 rangeLatency . release ( ) ; 
 + idealCLWriteLatency . release ( ) ; 
 } 
 
 / * * 
 diff - - git a / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java b / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java 
 index 8c30b89 . . b5eaadb 100644 
 - - - a / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / AbstractWriteResponseHandler . java 
 @ @ - 22 , 6 + 22 , 7 @ @ import java . util . Collection ; 
 import java . util . Map ; 
 import java . util . concurrent . ConcurrentHashMap ; 
 import java . util . concurrent . TimeUnit ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; 
 
 import com . google . common . collect . Iterables ; 
 @ @ - 40 , 8 + 41 , 10 @ @ import org . apache . cassandra . utils . concurrent . SimpleCondition ; 
 
 public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackWithFailure < T > 
 { 
 - protected static final Logger logger = LoggerFactory . getLogger ( AbstractWriteResponseHandler . class ) ; 
 + protected static final Logger logger = LoggerFactory . getLogger ( AbstractWriteResponseHandler . class ) ; 
 
 + / / Count down until all responses and expirations have occured before deciding whether the ideal CL was reached . 
 + private AtomicInteger responsesAndExpirations ; 
 private final SimpleCondition condition = new SimpleCondition ( ) ; 
 protected final Keyspace keyspace ; 
 protected final Collection < InetAddress > naturalEndpoints ; 
 @ @ - 50 , 14 + 53 , 22 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW 
 protected final Collection < InetAddress > pendingEndpoints ; 
 protected final WriteType writeType ; 
 private static final AtomicIntegerFieldUpdater < AbstractWriteResponseHandler > failuresUpdater 
 - = AtomicIntegerFieldUpdater . newUpdater ( AbstractWriteResponseHandler . class , " failures " ) ; 
 + = AtomicIntegerFieldUpdater . newUpdater ( AbstractWriteResponseHandler . class , " failures " ) ; 
 private volatile int failures = 0 ; 
 private final Map < InetAddress , RequestFailureReason > failureReasonByEndpoint ; 
 private final long queryStartNanoTime ; 
 private volatile boolean supportsBackPressure = true ; 
 
 / * * 
 - * @ param callback A callback to be called when the write is successful . 
 + * Delegate to another WriteReponseHandler or possibly this one to track if the ideal consistency level was reached . 
 + * Will be set to null if ideal CL was not configured 
 + * Will be set to an AWRH delegate if ideal CL was configured 
 + * Will be same as " this " if this AWRH is the ideal consistency level 
 + * / 
 + private AbstractWriteResponseHandler idealCLDelegate ; 
 + 
 + / * * 
 + * @ param callback A callback to be called when the write is successful . 
 * @ param queryStartNanoTime 
 * / 
 protected AbstractWriteResponseHandler ( Keyspace keyspace , 
 @ @ - 119 , 6 + 130 , 64 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW 
 } 
 
 / * * 
 + * Set a delegate ideal CL write response handler . Note that this could be the same as this 
 + * if the ideal CL and requested CL are the same . 
 + * / 
 + public void setIdealCLResponseHandler ( AbstractWriteResponseHandler handler ) 
 + { 
 + this . idealCLDelegate = handler ; 
 + idealCLDelegate . responsesAndExpirations = new AtomicInteger ( naturalEndpoints . size ( ) + pendingEndpoints . size ( ) ) ; 
 + } 
 + 
 + / * * 
 + * This logs the response but doesn ' t do any further processing related to this write response handler 
 + * on whether the CL was achieved . Only call this after the subclass has completed all it ' s processing 
 + * since the subclass instance may be queried to find out if the CL was achieved . 
 + * / 
 + protected final void logResponseToIdealCLDelegate ( MessageIn < T > m ) 
 + { 
 + / / Tracking ideal CL was not configured 
 + if ( idealCLDelegate = = null ) 
 + { 
 + return ; 
 + } 
 + 
 + if ( idealCLDelegate = = this ) 
 + { 
 + / / Processing of the message was already done since this is the handler for the 
 + / / ideal consistency level . Just decrement the counter . 
 + decrementResponseOrExpired ( ) ; 
 + } 
 + else 
 + { 
 + / / Let the delegate do full processing , this will loop back into the branch above 
 + / / with idealCLDelegate = = this , because the ideal write handler idealCLDelegate will always 
 + / / be set to this in the delegate . 
 + idealCLDelegate . response ( m ) ; 
 + } 
 + } 
 + 
 + public final void expired ( ) 
 + { 
 + / / Tracking ideal CL was not configured 
 + if ( idealCLDelegate = = null ) 
 + { 
 + return ; 
 + } 
 + 
 + / / The requested CL matched ideal CL so reuse this object 
 + if ( idealCLDelegate = = this ) 
 + { 
 + decrementResponseOrExpired ( ) ; 
 + } 
 + else 
 + { 
 + / / Have the delegate track the expired response 
 + idealCLDelegate . decrementResponseOrExpired ( ) ; 
 + } 
 + } 
 + 
 + / * * 
 * @ return the minimum number of endpoints that must reply . 
 * / 
 protected int totalBlockFor ( ) 
 @ @ - 149 , 7 + 218 , 9 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW 
 * / 
 protected abstract int ackCount ( ) ; 
 
 - / * * null message means " response from local write " * / 
 + / * * 
 + * null message means " response from local write " 
 + * / 
 public abstract void response ( MessageIn < T > msg ) ; 
 
 public void assureSufficientLiveNodes ( ) throws UnavailableException 
 @ @ - 170 , 8 + 241 , 8 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW 
 logger . trace ( " Got failure from { } " , from ) ; 
 
 int n = waitingFor ( from ) 
 - ? failuresUpdater . incrementAndGet ( this ) 
 - : failures ; 
 + ? failuresUpdater . incrementAndGet ( this ) 
 + : failures ; 
 
 failureReasonByEndpoint . put ( from , failureReason ) ; 
 
 @ @ - 189 , 4 + 260 , 26 @ @ public abstract class AbstractWriteResponseHandler < T > implements IAsyncCallbackW 
 { 
 this . supportsBackPressure = supportsBackPressure ; 
 } 
 + 
 + / * * 
 + * Decrement the counter for all responses / expirations and if the counter 
 + * hits 0 check to see if the ideal consistency level ( this write response handler ) 
 + * was reached using the signal . 
 + * / 
 + private final void decrementResponseOrExpired ( ) 
 + { 
 + int decrementedValue = responsesAndExpirations . decrementAndGet ( ) ; 
 + if ( decrementedValue = = 0 ) 
 + { 
 + / / The condition being signaled is a valid proxy for the CL being achieved 
 + if ( ! condition . isSignaled ( ) ) 
 + { 
 + keyspace . metric . writeFailedIdealCL . inc ( ) ; 
 + } 
 + else 
 + { 
 + keyspace . metric . idealCLWriteLatency . addNano ( System . nanoTime ( ) - queryStartNanoTime ) ; 
 + } 
 + } 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java 
 index 9584611 . . 4137e3a 100644 
 - - - a / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / DatacenterSyncWriteResponseHandler . java 
 @ @ - 71 , 21 + 71 , 29 @ @ public class DatacenterSyncWriteResponseHandler < T > extends AbstractWriteResponse 
 
 public void response ( MessageIn < T > message ) 
 { 
 - String dataCenter = message = = null 
 - ? DatabaseDescriptor . getLocalDataCenter ( ) 
 - : snitch . getDatacenter ( message . from ) ; 
 + try 
 + { 
 + String dataCenter = message = = null 
 + ? DatabaseDescriptor . getLocalDataCenter ( ) 
 + : snitch . getDatacenter ( message . from ) ; 
 + 
 + responses . get ( dataCenter ) . getAndDecrement ( ) ; 
 + acks . incrementAndGet ( ) ; 
 
 - responses . get ( dataCenter ) . getAndDecrement ( ) ; 
 - acks . incrementAndGet ( ) ; 
 + for ( AtomicInteger i : responses . values ( ) ) 
 + { 
 + if ( i . get ( ) > 0 ) 
 + return ; 
 + } 
 
 - for ( AtomicInteger i : responses . values ( ) ) 
 + / / all the quorum conditions are met 
 + signal ( ) ; 
 + } 
 + finally 
 { 
 - if ( i . get ( ) > 0 ) 
 - return ; 
 + / / Must be last after all subclass processing 
 + logResponseToIdealCLDelegate ( message ) ; 
 } 
 - 
 - / / all the quorum conditions are met 
 - signal ( ) ; 
 } 
 
 protected int ackCount ( ) 
 diff - - git a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 index 2309e87 . . 83dddcf 100644 
 - - - a / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / DatacenterWriteResponseHandler . java 
 @ @ - 46 , 7 + 46 , 15 @ @ public class DatacenterWriteResponseHandler < T > extends WriteResponseHandler < T > 
 public void response ( MessageIn < T > message ) 
 { 
 if ( message = = null | | waitingFor ( message . from ) ) 
 + { 
 super . response ( message ) ; 
 + } 
 + else 
 + { 
 + / / WriteResponseHandler . response will call logResonseToIdealCLDelegate so only do it if not calling WriteResponseHandler . response . 
 + / / Must be last after all subclass processing 
 + logResponseToIdealCLDelegate ( message ) ; 
 + } 
 } 
 
 @ Override 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxy . java b / src / java / org / apache / cassandra / service / StorageProxy . java 
 index 0585717 . . 6be5286 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxy . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxy . java 
 @ @ - 561 , 9 + 561 , 16 @ @ public class StorageProxy implements StorageProxyMBean 
 MessagingService . instance ( ) . sendOneWay ( message , destination ) ; 
 } 
 } 
 - else if ( shouldHint ) 
 + else 
 { 
 - submitHint ( proposal . makeMutation ( ) , destination , null ) ; 
 + if ( responseHandler ! = null ) 
 + { 
 + responseHandler . expired ( ) ; 
 + } 
 + if ( shouldHint ) 
 + { 
 + submitHint ( proposal . makeMutation ( ) , destination , null ) ; 
 + } 
 } 
 } 
 
 @ @ - 1257 , 6 + 1264 , 8 @ @ public class StorageProxy implements StorageProxyMBean 
 } 
 else 
 { 
 + / / Immediately mark the response as expired since the request will not be sent 
 + responseHandler . expired ( ) ; 
 if ( shouldHint ( destination ) ) 
 { 
 if ( endpointsToHint = = null ) 
 @ @ - 2774 , 4 + 2783 , 17 @ @ public class StorageProxy implements StorageProxyMBean 
 { 
 return Schema . instance . getNumberOfTables ( ) ; 
 } 
 + 
 + public String getIdealConsistencyLevel ( ) 
 + { 
 + return DatabaseDescriptor . getIdealConsistencyLevel ( ) . toString ( ) ; 
 + } 
 + 
 + public String setIdealConsistencyLevel ( String cl ) 
 + { 
 + ConsistencyLevel original = DatabaseDescriptor . getIdealConsistencyLevel ( ) ; 
 + ConsistencyLevel newCL = ConsistencyLevel . valueOf ( cl . trim ( ) . toUpperCase ( ) ) ; 
 + DatabaseDescriptor . setIdealConsistencyLevel ( newCL ) ; 
 + return String . format ( " Updating ideal consistency level new value : % s old value % s " , newCL , original . toString ( ) ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / StorageProxyMBean . java b / src / java / org / apache / cassandra / service / StorageProxyMBean . java 
 index 0a4ba19 . . 97f7615 100644 
 - - - a / src / java / org / apache / cassandra / service / StorageProxyMBean . java 
 + + + b / src / java / org / apache / cassandra / service / StorageProxyMBean . java 
 @ @ - 21 , 6 + 21 , 8 @ @ import java . util . List ; 
 import java . util . Map ; 
 import java . util . Set ; 
 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + 
 public interface StorageProxyMBean 
 { 
 public long getTotalHints ( ) ; 
 @ @ - 63 , 4 + 65 , 7 @ @ public interface StorageProxyMBean 
 public Map < String , List < String > > getSchemaVersions ( ) ; 
 
 public int getNumberOfTables ( ) ; 
 + 
 + public String getIdealConsistencyLevel ( ) ; 
 + public String setIdealConsistencyLevel ( String cl ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / service / WriteResponseHandler . java b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 index 46e4e93 . . 55ca5aa 100644 
 - - - a / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 + + + b / src / java / org / apache / cassandra / service / WriteResponseHandler . java 
 @ @ - 68 , 6 + 68 , 10 @ @ public class WriteResponseHandler < T > extends AbstractWriteResponseHandler < T > 
 { 
 if ( responsesUpdater . decrementAndGet ( this ) = = 0 ) 
 signal ( ) ; 
 + / / Must be last after all subclass processing 
 + / / The two current subclasses both assume logResponseToIdealCLDelegate is called 
 + / / here . 
 + logResponseToIdealCLDelegate ( m ) ; 
 } 
 
 protected int ackCount ( ) 
 diff - - git a / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java b / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java 
 index c8f8bc1 . . b915854 100644 
 - - - a / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java 
 + + + b / test / unit / org / apache / cassandra / config / DatabaseDescriptorRefTest . java 
 @ @ - 81 , 6 + 81 , 7 @ @ public class DatabaseDescriptorRefTest 
 " org . apache . cassandra . config . YamlConfigurationLoader $ PropertiesChecker $ 1 " , 
 " org . apache . cassandra . config . YamlConfigurationLoader $ CustomConstructor " , 
 " org . apache . cassandra . config . TransparentDataEncryptionOptions " , 
 + " org . apache . cassandra . db . ConsistencyLevel " , 
 " org . apache . cassandra . dht . IPartitioner " , 
 " org . apache . cassandra . exceptions . ConfigurationException " , 
 " org . apache . cassandra . exceptions . RequestValidationException " , 
 diff - - git a / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java 
 new file mode 100644 
 index 0000000 . . 815dbf6 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / service / WriteResponseHandlerTest . java 
 @ @ - 0 , 0 + 1 , 234 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . service ; 
 + 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Collection ; 
 + import java . util . List ; 
 + import java . util . UUID ; 
 + import java . util . concurrent . TimeUnit ; 
 + 
 + import com . google . common . collect . ImmutableList ; 
 + import org . junit . Before ; 
 + import org . junit . BeforeClass ; 
 + import org . junit . Test ; 
 + 
 + import org . apache . cassandra . SchemaLoader ; 
 + import org . apache . cassandra . config . DatabaseDescriptor ; 
 + import org . apache . cassandra . db . ColumnFamilyStore ; 
 + import org . apache . cassandra . db . ConsistencyLevel ; 
 + import org . apache . cassandra . db . Keyspace ; 
 + import org . apache . cassandra . db . WriteType ; 
 + import org . apache . cassandra . locator . IEndpointSnitch ; 
 + import org . apache . cassandra . locator . TokenMetadata ; 
 + import org . apache . cassandra . net . MessageIn ; 
 + import org . apache . cassandra . schema . KeyspaceParams ; 
 + 
 + import static org . junit . Assert . assertEquals ; 
 + import static org . junit . Assert . assertTrue ; 
 + 
 + public class WriteResponseHandlerTest 
 + { 
 + static Keyspace ks ; 
 + static ColumnFamilyStore cfs ; 
 + static List < InetAddress > targets ; 
 + 
 + @ BeforeClass 
 + public static void setUpClass ( ) throws Throwable 
 + { 
 + SchemaLoader . loadSchema ( ) ; 
 + / / Register peers with expected DC for NetworkTopologyStrategy . 
 + TokenMetadata metadata = StorageService . instance . getTokenMetadata ( ) ; 
 + metadata . clearUnsafe ( ) ; 
 + metadata . updateHostId ( UUID . randomUUID ( ) , InetAddress . getByName ( " 127 . 1 . 0 . 255 " ) ) ; 
 + metadata . updateHostId ( UUID . randomUUID ( ) , InetAddress . getByName ( " 127 . 2 . 0 . 255 " ) ) ; 
 + 
 + DatabaseDescriptor . setEndpointSnitch ( new IEndpointSnitch ( ) 
 + { 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return null ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + byte [ ] address = endpoint . getAddress ( ) ; 
 + if ( address [ 1 ] = = 1 ) 
 + return " datacenter1 " ; 
 + else 
 + return " datacenter2 " ; 
 + } 
 + 
 + public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) 
 + { 
 + return null ; 
 + } 
 + 
 + public void sortByProximity ( InetAddress address , List < InetAddress > addresses ) 
 + { 
 + 
 + } 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return 0 ; 
 + } 
 + 
 + public void gossiperStarting ( ) 
 + { 
 + 
 + } 
 + 
 + public boolean isWorthMergingForRangeQuery ( List < InetAddress > merged , List < InetAddress > l1 , List < InetAddress > l2 ) 
 + { 
 + return false ; 
 + } 
 + } ) ; 
 + DatabaseDescriptor . setBroadcastAddress ( InetAddress . getByName ( " 127 . 1 . 0 . 1 " ) ) ; 
 + SchemaLoader . createKeyspace ( " Foo " , KeyspaceParams . nts ( " datacenter1 " , 3 , " datacenter2 " , 3 ) , SchemaLoader . standardCFMD ( " Foo " , " Bar " ) ) ; 
 + ks = Keyspace . open ( " Foo " ) ; 
 + cfs = ks . getColumnFamilyStore ( " Bar " ) ; 
 + targets = ImmutableList . of ( InetAddress . getByName ( " 127 . 1 . 0 . 255 " ) , InetAddress . getByName ( " 127 . 1 . 0 . 254 " ) , InetAddress . getByName ( " 127 . 1 . 0 . 253 " ) , 
 + InetAddress . getByName ( " 127 . 2 . 0 . 255 " ) , InetAddress . getByName ( " 127 . 2 . 0 . 254 " ) , InetAddress . getByName ( " 127 . 2 . 0 . 253 " ) ) ; 
 + } 
 + 
 + 
 + @ Before 
 + public void resetCounters ( ) 
 + { 
 + ks . metric . writeFailedIdealCL . dec ( ks . metric . writeFailedIdealCL . getCount ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Validate that failing to achieve ideal CL increments the failure counter 
 + * @ throws Throwable 
 + * / 
 + @ Test 
 + public void failedIdealCLIncrementsStat ( ) throws Throwable 
 + { 
 + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM ) ; 
 + 
 + / / Succeed in local DC 
 + awr . response ( createDummyMessage ( 0 ) ) ; 
 + awr . response ( createDummyMessage ( 1 ) ) ; 
 + awr . response ( createDummyMessage ( 2 ) ) ; 
 + 
 + / / Fail in remote DC 
 + awr . expired ( ) ; 
 + awr . expired ( ) ; 
 + awr . expired ( ) ; 
 + assertEquals ( 1 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; 
 + assertEquals ( 0 , ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Validate that a successful write at ideal CL logs latency information . Also validates 
 + * DatacenterSyncWriteResponseHandler 
 + * @ throws Throwable 
 + * / 
 + @ Test 
 + public void idealCLLatencyTracked ( ) throws Throwable 
 + { 
 + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; 
 + / / Specify query start time in past to ensure minimum latency measurement 
 + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . EACH _ QUORUM , System . nanoTime ( ) - TimeUnit . DAYS . toNanos ( 1 ) ) ; 
 + 
 + / / dc1 
 + awr . response ( createDummyMessage ( 0 ) ) ; 
 + awr . response ( createDummyMessage ( 1 ) ) ; 
 + / / dc2 
 + awr . response ( createDummyMessage ( 4 ) ) ; 
 + awr . response ( createDummyMessage ( 5 ) ) ; 
 + 
 + / / Don ' t need the others 
 + awr . expired ( ) ; 
 + awr . expired ( ) ; 
 + 
 + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; 
 + assertTrue ( TimeUnit . DAYS . toMicros ( 1 ) < ks . metric . idealCLWriteLatency . totalLatency . getCount ( ) ) ; 
 + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Validate that WriteResponseHandler does the right thing on success . 
 + * @ throws Throwable 
 + * / 
 + @ Test 
 + public void idealCLWriteResponeHandlerWorks ( ) throws Throwable 
 + { 
 + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; 
 + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . LOCAL _ QUORUM , ConsistencyLevel . ALL ) ; 
 + 
 + / / dc1 
 + awr . response ( createDummyMessage ( 0 ) ) ; 
 + awr . response ( createDummyMessage ( 1 ) ) ; 
 + awr . response ( createDummyMessage ( 2 ) ) ; 
 + / / dc2 
 + awr . response ( createDummyMessage ( 3 ) ) ; 
 + awr . response ( createDummyMessage ( 4 ) ) ; 
 + awr . response ( createDummyMessage ( 5 ) ) ; 
 + 
 + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; 
 + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; 
 + } 
 + 
 + / * * 
 + * Validate that DatacenterWriteResponseHandler does the right thing on success . 
 + * @ throws Throwable 
 + * / 
 + @ Test 
 + public void idealCLDatacenterWriteResponeHandlerWorks ( ) throws Throwable 
 + { 
 + long startingCount = ks . metric . idealCLWriteLatency . latency . getCount ( ) ; 
 + AbstractWriteResponseHandler awr = createWriteResponseHandler ( ConsistencyLevel . ONE , ConsistencyLevel . LOCAL _ QUORUM ) ; 
 + 
 + / / dc1 
 + awr . response ( createDummyMessage ( 0 ) ) ; 
 + awr . response ( createDummyMessage ( 1 ) ) ; 
 + awr . response ( createDummyMessage ( 2 ) ) ; 
 + / / dc2 
 + awr . response ( createDummyMessage ( 3 ) ) ; 
 + awr . response ( createDummyMessage ( 4 ) ) ; 
 + awr . response ( createDummyMessage ( 5 ) ) ; 
 + 
 + assertEquals ( 0 , ks . metric . writeFailedIdealCL . getCount ( ) ) ; 
 + assertEquals ( startingCount + 1 , ks . metric . idealCLWriteLatency . latency . getCount ( ) ) ; 
 + } 
 + 
 + private static AbstractWriteResponseHandler createWriteResponseHandler ( ConsistencyLevel cl , ConsistencyLevel ideal ) 
 + { 
 + return createWriteResponseHandler ( cl , ideal , System . nanoTime ( ) ) ; 
 + } 
 + 
 + private static AbstractWriteResponseHandler createWriteResponseHandler ( ConsistencyLevel cl , ConsistencyLevel ideal , long queryStartTime ) 
 + { 
 + return ks . getReplicationStrategy ( ) . getWriteResponseHandler ( targets , ImmutableList . of ( ) , cl , new Runnable ( ) { 
 + public void run ( ) 
 + { 
 + 
 + } 
 + } , WriteType . SIMPLE , queryStartTime , ideal ) ; 
 + } 
 + 
 + private static MessageIn createDummyMessage ( int target ) 
 + { 
 + return MessageIn . create ( targets . get ( target ) , null , null , null , 0 , 0L ) ; 
 + } 
 + }

NEAREST DIFF:
diff - - git a / conf / cassandra . yaml b / conf / cassandra . yaml 
 index 30f85a4 . . 11499a6 100644 
 - - - a / conf / cassandra . yaml 
 + + + b / conf / cassandra . yaml 
 @ @ - 170 , 6 + 170 , 12 @ @ request _ scheduler : org . apache . cassandra . scheduler . NoScheduler 
 # the request scheduling . The current supported option is " keyspace " 
 request _ scheduler _ id : keyspace 
 
 + # dynamic _ snitch - - This boolean controls whether the above snitch is 
 + # wrapped with a dynamic snitch , which will monitor read latencies 
 + # and avoid reading from hosts that have slowed ( due to compaction , 
 + # for instance ) 
 + dynamic _ snitch : false 
 + 
 # A ColumnFamily is the Cassandra concept closest to a relational table . 
 # 
 # Keyspaces are separate groups of ColumnFamilies . Except in very 
 diff - - git a / src / java / org / apache / cassandra / config / Config . java b / src / java / org / apache / cassandra / config / Config . java 
 index 2a5478e . . 315c9a4 100644 
 - - - a / src / java / org / apache / cassandra / config / Config . java 
 + + + b / src / java / org / apache / cassandra / config / Config . java 
 @ @ - 71 , 6 + 71 , 7 @ @ public class Config { 
 public Integer commitlog _ sync _ period _ in _ ms ; 
 
 public String endpoint _ snitch ; 
 + public Boolean dynamic _ snitch = false ; 
 
 public String request _ scheduler ; 
 public RequestSchedulerId request _ scheduler _ id ; 
 diff - - git a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 index 0947af0 . . b5f9302 100644 
 - - - a / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 + + + b / src / java / org / apache / cassandra / config / DatabaseDescriptor . java 
 @ @ - 27 , 6 + 27 , 7 @ @ import java . net . URL ; 
 import java . net . UnknownHostException ; 
 import java . util . * ; 
 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 
 @ @ - 415 , 10 + 416 , 10 @ @ public class DatabaseDescriptor 
 throw ( ConfigurationException ) e . getCause ( ) ; 
 throw new ConfigurationException ( " Error instantiating " + endpointSnitchClassName + " " + e . getMessage ( ) ) ; 
 } 
 - return snitch ; 
 + return conf . dynamic _ snitch ? new DynamicEndpointSnitch ( snitch ) : snitch ; 
 } 
 
 - public static void loadSchemas ( ) throws IOException 
 + public static void loadSchemas ( ) throws IOException 
 { 
 / / we can load tables from local storage if a version is set in the system table and that acutally maps to 
 / / real data in the definitions table . If we do end up loading from xml , store the defintions so that we 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 index 4892281 . . 2ef4980 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractEndpointSnitch . java 
 @ @ - 21 , 6 + 21 , 7 @ @ package org . apache . cassandra . locator ; 
 
 import java . net . InetAddress ; 
 import java . util . Collection ; 
 + import java . util . Comparator ; 
 import java . util . List ; 
 import java . util . concurrent . CopyOnWriteArrayList ; 
 
 @ @ - 42 , 4 + 43 , 9 @ @ public abstract class AbstractEndpointSnitch implements IEndpointSnitch 
 
 public abstract List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 public abstract List < InetAddress > sortByProximity ( InetAddress address , List < InetAddress > addresses ) ; 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + return a1 . getHostAddress ( ) . compareTo ( a2 . getHostAddress ( ) ) ; 
 + } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 index acb1d16 . . c40f995 100644 
 - - - a / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / AbstractRackAwareSnitch . java 
 @ @ - 72 , 30 + 72 , 35 @ @ public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch 
 { 
 public int compare ( InetAddress a1 , InetAddress a2 ) 
 { 
 - if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 - return - 1 ; 
 - if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 - return 1 ; 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } ; 
 + } ) ; 
 + return addresses ; 
 + } 
 
 - String addressRack = getRack ( address ) ; 
 - String a1Rack = getRack ( a1 ) ; 
 - String a2Rack = getRack ( a2 ) ; 
 - if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 - return - 1 ; 
 - if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 - return 1 ; 
 + public int compareEndpoints ( InetAddress address , InetAddress a1 , InetAddress a2 ) 
 + { 
 + if ( address . equals ( a1 ) & & ! address . equals ( a2 ) ) 
 + return - 1 ; 
 + if ( address . equals ( a2 ) & & ! address . equals ( a1 ) ) 
 + return 1 ; 
 
 - String addressDatacenter = getDatacenter ( address ) ; 
 - String a1Datacenter = getDatacenter ( a1 ) ; 
 - String a2Datacenter = getDatacenter ( a2 ) ; 
 - if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 - return - 1 ; 
 - if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 - return 1 ; 
 + String addressRack = getRack ( address ) ; 
 + String a1Rack = getRack ( a1 ) ; 
 + String a2Rack = getRack ( a2 ) ; 
 + if ( addressRack . equals ( a1Rack ) & & ! addressRack . equals ( a2Rack ) ) 
 + return - 1 ; 
 + if ( addressRack . equals ( a2Rack ) & & ! addressRack . equals ( a1Rack ) ) 
 + return 1 ; 
 
 - return 0 ; 
 - } 
 - } ) ; 
 - return addresses ; 
 + String addressDatacenter = getDatacenter ( address ) ; 
 + String a1Datacenter = getDatacenter ( a1 ) ; 
 + String a2Datacenter = getDatacenter ( a2 ) ; 
 + if ( addressDatacenter . equals ( a1Datacenter ) & & ! addressDatacenter . equals ( a2Datacenter ) ) 
 + return - 1 ; 
 + if ( addressDatacenter . equals ( a2Datacenter ) & & ! addressDatacenter . equals ( a1Datacenter ) ) 
 + return 1 ; 
 + 
 + return 0 ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 new file mode 100644 
 index 0000000 . . cb2f03b 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitch . java 
 @ @ - 0 , 0 + 1 , 238 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . * ; 
 + import java . util . concurrent . LinkedBlockingDeque ; 
 + import java . util . concurrent . ConcurrentHashMap ; 
 + import java . util . concurrent . atomic . AtomicInteger ; 
 + 
 + import java . lang . management . ManagementFactory ; 
 + import javax . management . MBeanServer ; 
 + import javax . management . ObjectName ; 
 + 
 + import org . apache . cassandra . net . IVerbHandler ; 
 + import org . apache . cassandra . net . MessagingService ; 
 + import org . apache . cassandra . net . ResponseVerbHandler ; 
 + import org . apache . cassandra . service . StorageService ; 
 + import org . apache . cassandra . utils . AbstractStatsDeque ; 
 + import org . apache . cassandra . locator . IEndpointSnitch ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + import org . apache . cassandra . locator . AbstractEndpointSnitch ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitchMBean ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + / * * 
 + * A dynamic snitch that sorts endpoints by latency with an adapted phi failure detector 
 + * / 
 + public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean 
 + { 
 + private static int UPDATES _ PER _ INTERVAL = 100 ; 
 + private static int UPDATE _ INTERVAL _ IN _ MS = 1000 ; 
 + private static int RESET _ INTERVAL _ IN _ MS = 60000 ; 
 + private static int WINDOW _ SIZE = 100 ; 
 + private boolean registered = false ; 
 + 
 + private ConcurrentHashMap < InetAddress , Double > scores = new ConcurrentHashMap ( ) ; 
 + private ConcurrentHashMap < InetAddress , AdaptiveLatencyTracker > windows = new ConcurrentHashMap ( ) ; 
 + private AtomicInteger intervalupdates = new AtomicInteger ( 0 ) ; 
 + public IEndpointSnitch subsnitch ; 
 + 
 + public DynamicEndpointSnitch ( IEndpointSnitch snitch ) 
 + { 
 + subsnitch = snitch ; 
 + TimerTask update = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + updateScores ( ) ; 
 + } 
 + } ; 
 + TimerTask reset = new TimerTask ( ) 
 + { 
 + public void run ( ) 
 + { 
 + / / we do this so that a host considered bad has a chance to recover , otherwise would we never try 
 + / / to read from it , which would cause its score to never change 
 + reset ( ) ; 
 + } 
 + } ; 
 + Timer timer = new Timer ( " DynamicEndpointSnitch " ) ; 
 + timer . schedule ( update , UPDATE _ INTERVAL _ IN _ MS , UPDATE _ INTERVAL _ IN _ MS ) ; 
 + timer . schedule ( reset , RESET _ INTERVAL _ IN _ MS , RESET _ INTERVAL _ IN _ MS ) ; 
 + 
 + MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; 
 + try 
 + { 
 + mbs . registerMBean ( this , new ObjectName ( " org . apache . cassandra . locator : type = DynamicEndpointSnitch " ) ) ; 
 + } 
 + catch ( Exception e ) 
 + { 
 + throw new RuntimeException ( e ) ; 
 + } 
 + } 
 + 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getRack ( endpoint ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + return subsnitch . getDatacenter ( endpoint ) ; 
 + } 
 + 
 + public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 + { 
 + List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; 
 + sortByProximity ( address , list ) ; 
 + return list ; 
 + } 
 + 
 + public List < InetAddress > sortByProximity ( final InetAddress address , List < InetAddress > addresses ) 
 + { 
 + assert address = = FBUtilities . getLocalAddress ( ) ; / / we only know about ourself 
 + Collections . sort ( addresses , new Comparator < InetAddress > ( ) 
 + { 
 + public int compare ( InetAddress a1 , InetAddress a2 ) 
 + { 
 + return compareEndpoints ( address , a1 , a2 ) ; 
 + } 
 + } ) ; 
 + return addresses ; 
 + } 
 + 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) 
 + { 
 + Double scored1 = scores . get ( a1 ) ; 
 + Double scored2 = scores . get ( a2 ) ; 
 + 
 + if ( scored1 = = null | | scored2 = = null ) 
 + return subsnitch . compareEndpoints ( target , a1 , a2 ) ; 
 + if ( scored1 . equals ( scored2 ) ) 
 + return 0 ; 
 + if ( scored1 < scored2 ) 
 + return 1 ; 
 + else 
 + return - 1 ; 
 + } 
 + 
 + public void receiveTiming ( InetAddress host , Double latency ) / / this is cheap 
 + { 
 + if ( intervalupdates . intValue ( ) > = UPDATES _ PER _ INTERVAL ) 
 + return ; 
 + AdaptiveLatencyTracker tracker = windows . get ( host ) ; 
 + if ( tracker = = null ) 
 + { 
 + AdaptiveLatencyTracker alt = new AdaptiveLatencyTracker ( WINDOW _ SIZE ) ; 
 + tracker = windows . putIfAbsent ( host , alt ) ; 
 + if ( tracker = = null ) 
 + tracker = alt ; 
 + } 
 + tracker . add ( latency ) ; 
 + intervalupdates . getAndIncrement ( ) ; 
 + } 
 + 
 + private void updateScores ( ) / / this is expensive 
 + { 
 + if ( ! registered ) 
 + { 
 + 	 ILatencyPublisher handler = ( ILatencyPublisher ) MessagingService . instance . getVerbHandler ( StorageService . Verb . READ _ RESPONSE ) ; 
 + if ( handler ! = null ) 
 + { 
 + handler . register ( this ) ; 
 + registered = true ; 
 + } 
 + 
 + } 
 + for ( Map . Entry < InetAddress , AdaptiveLatencyTracker > entry : windows . entrySet ( ) ) 
 + { 
 + scores . put ( entry . getKey ( ) , entry . getValue ( ) . score ( ) ) ; 
 + } 
 + intervalupdates . set ( 0 ) ; 
 + } 
 + 
 + private void reset ( ) 
 + { 
 + for ( AdaptiveLatencyTracker tracker : windows . values ( ) ) 
 + { 
 + tracker . clear ( ) ; 
 + } 
 + } 
 + 
 + public Map < InetAddress , Double > getScores ( ) 
 + { 
 + return scores ; 
 + } 
 + } 
 + 
 + / * * a threadsafe version of BoundedStatsDeque + ArrivalWindow with modification for arbitrary times * * / 
 + class AdaptiveLatencyTracker extends AbstractStatsDeque 
 + { 
 + private LinkedBlockingDeque latencies ; 
 + private final int size ; 
 + private static double SENTINEL _ COMPARE = 0 . 0001 ; / / arbitrary ; as long as it is the same across hosts it doesn ' t matter 
 + 
 + AdaptiveLatencyTracker ( int size ) 
 + { 
 + this . size = size ; 
 + latencies = new LinkedBlockingDeque ( size ) ; 
 + } 
 + 
 + public void add ( double i ) 
 + { 
 + latencies . offer ( i ) ; 
 + } 
 + 
 + public void clear ( ) 
 + { 
 + latencies . clear ( ) ; 
 + } 
 + 
 + public Iterator < Double > iterator ( ) 
 + { 
 + return latencies . iterator ( ) ; 
 + } 
 + 
 + public int size ( ) 
 + { 
 + return latencies . size ( ) ; 
 + } 
 + 
 + double p ( double t ) 
 + { 
 + double mean = mean ( ) ; 
 + double exponent = ( - 1 ) * ( t ) / mean ; 
 + return 1 - ( 1 - Math . pow ( Math . E , exponent ) ) ; 
 + } 
 + 
 + double score ( ) 
 + { 
 + double log = 0d ; 
 + if ( latencies . size ( ) > 0 ) 
 + { 
 + double probability = p ( SENTINEL _ COMPARE ) ; 
 + log = ( - 1 ) * Math . log10 ( probability ) ; 
 + } 
 + return log ; 
 + } 
 + 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 new file mode 100644 
 index 0000000 . . 26c5799 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / DynamicEndpointSnitchMBean . java 
 @ @ - 0 , 0 + 1 , 27 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . util . Map ; 
 + 
 + public interface DynamicEndpointSnitchMBean { 
 + public Map < InetAddress , Double > getScores ( ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 index ca451c0 . . 091c4c2 100644 
 - - - a / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / IEndpointSnitch . java 
 @ @ - 31 , 6 + 31 , 16 @ @ import java . util . List ; 
 public interface IEndpointSnitch 
 { 
 / * * 
 + * returns a String repesenting the rack this endpoint belongs to 
 + * / 
 + public String getRack ( InetAddress endpoint ) ; 
 + 
 + / * * 
 + * returns a String representing the datacenter this endpoint belongs to 
 + * / 
 + public String getDatacenter ( InetAddress endpoint ) ; 
 + 
 + / * * 
 * returns a new < tt > List < / tt > sorted by proximity to the given endpoint 
 * / 
 public List < InetAddress > getSortedListByProximity ( InetAddress address , Collection < InetAddress > unsortedAddress ) ; 
 @ @ - 45 , 4 + 55 , 9 @ @ public interface IEndpointSnitch 
 * @ param subscriber the subscriber to notify 
 * / 
 public void register ( AbstractReplicationStrategy subscriber ) ; 
 + 
 + / * * 
 + * compares two endpoints in relation to the target endpoint , returning as Comparator . compare would 
 + * / 
 + public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) ; 
 } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencyPublisher . java b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 new file mode 100644 
 index 0000000 . . 0d97e84 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencyPublisher . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 + 
 + public interface ILatencyPublisher 
 + { 
 + public void register ( ILatencySubscriber subcriber ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / ILatencySubscriber . java b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 new file mode 100644 
 index 0000000 . . 6cfcf33 
 - - - / dev / null 
 + + + b / src / java / org / apache / cassandra / locator / ILatencySubscriber . java 
 @ @ - 0 , 0 + 1 , 26 @ @ 
 + / * * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , software 
 + * distributed under the License is distributed on an " AS IS " BASIS , 
 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . 
 + * See the License for the specific language governing permissions and 
 + * limitations under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + 
 + public interface ILatencySubscriber 
 + { 
 + public void receiveTiming ( InetAddress address , Double latency ) ; 
 + } 
 diff - - git a / src / java / org / apache / cassandra / locator / SimpleSnitch . java b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 index c2fd8b5 . . dd8fb68 100644 
 - - - a / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 + + + b / src / java / org / apache / cassandra / locator / SimpleSnitch . java 
 @ @ - 23 , 12 + 23 , 24 @ @ import java . util . ArrayList ; 
 import java . util . Collection ; 
 import java . util . List ; 
 
 + import org . apache . commons . lang . NotImplementedException ; 
 + 
 / * * 
 * A simple endpoint snitch implementation does not sort addresses by 
 * proximity . 
 * / 
 public class SimpleSnitch extends AbstractEndpointSnitch 
 { 
 + public String getRack ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 + public String getDatacenter ( InetAddress endpoint ) 
 + { 
 + throw new NotImplementedException ( ) ; 
 + } 
 + 
 public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) 
 { 
 return new ArrayList < InetAddress > ( addresses ) ; 
 diff - - git a / src / java / org / apache / cassandra / net / MessagingService . java b / src / java / org / apache / cassandra / net / MessagingService . java 
 index 474d7c2 . . efd2545 100644 
 - - - a / src / java / org / apache / cassandra / net / MessagingService . java 
 + + + b / src / java / org / apache / cassandra / net / MessagingService . java 
 @ @ - 400 , 6 + 400 , 16 @ @ public class MessagingService implements IFailureDetectionEventListener 
 return taskCompletionMap _ . remove ( key ) ; 
 } 
 
 + public static long getRegisteredCallbackAge ( String key ) 
 + { 
 + return callbackMap _ . getAge ( key ) ; 
 + } 
 + 
 + public static long getAsyncResultAge ( String key ) 
 + { 
 + return taskCompletionMap _ . getAge ( key ) ; 
 + } 
 + 
 public static ExecutorService getDeserializationExecutor ( ) 
 { 
 return messageDeserializerExecutor _ ; 
 diff - - git a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 index 020d187 . . cde87b2 100644 
 - - - a / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 + + + b / src / java / org / apache / cassandra / net / ResponseVerbHandler . java 
 @ @ - 18 , 21 + 18 , 30 @ @ 
 
 package org . apache . cassandra . net ; 
 
 + 
 + import java . util . * ; 
 + import java . net . InetAddress ; 
 import org . slf4j . Logger ; 
 import org . slf4j . LoggerFactory ; 
 + import org . apache . cassandra . locator . ILatencyPublisher ; 
 + import org . apache . cassandra . locator . ILatencySubscriber ; 
 
 - public class ResponseVerbHandler implements IVerbHandler 
 + public class ResponseVerbHandler implements IVerbHandler , ILatencyPublisher 
 { 
 private static final Logger logger _ = LoggerFactory . getLogger ( ResponseVerbHandler . class ) ; 
 - 
 + private List < ILatencySubscriber > subscribers = new ArrayList < ILatencySubscriber > ( ) ; 
 + 
 + 
 public void doVerb ( Message message ) 
 { 
 String messageId = message . getMessageId ( ) ; 
 IAsyncCallback cb = MessagingService . getRegisteredCallback ( messageId ) ; 
 + double age = 0 ; 
 if ( cb ! = null ) 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on a callback from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getRegisteredCallbackAge ( messageId ) ; 
 cb . response ( message ) ; 
 } 
 else 
 @ @ - 42 , 8 + 51 , 23 @ @ public class ResponseVerbHandler implements IVerbHandler 
 { 
 if ( logger _ . isDebugEnabled ( ) ) 
 logger _ . debug ( " Processing response on an async result from " + message . getMessageId ( ) + " @ " + message . getFrom ( ) ) ; 
 + age = System . currentTimeMillis ( ) - MessagingService . getAsyncResultAge ( messageId ) ; 
 ar . result ( message ) ; 
 } 
 } 
 + notifySubscribers ( message . getFrom ( ) , age ) ; 
 + } 
 + 
 + private void notifySubscribers ( InetAddress host , double latency ) 
 + { 
 + for ( ILatencySubscriber subscriber : subscribers ) 
 + { 
 + subscriber . receiveTiming ( host , latency ) ; 
 + } 
 + } 
 + 
 + public void register ( ILatencySubscriber subscriber ) 
 + { 
 + subscribers . add ( subscriber ) ; 
 } 
 } 
 diff - - git a / src / java / org / apache / cassandra / utils / ExpiringMap . java b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 index dfaadf7 . . aa2c7ec 100644 
 - - - a / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 + + + b / src / java / org / apache / cassandra / utils / ExpiringMap . java 
 @ @ - 129 , 6 + 129 , 17 @ @ public class ExpiringMap < K , V > 
 return result ; 
 } 
 
 + public long getAge ( K key ) 
 + { 
 + long age = 0 ; 
 + CacheableObject < V > co = cache . get ( key ) ; 
 + if ( co ! = null ) 
 + { 
 + age = co . age ; 
 + } 
 + return age ; 
 + } 
 + 
 public int size ( ) 
 { 
 return cache . size ( ) ; 
 diff - - git a / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 new file mode 100644 
 index 0000000 . . 62904b4 
 - - - / dev / null 
 + + + b / test / unit / org / apache / cassandra / locator / DynamicEndpointSnitchTest . java 
 @ @ - 0 , 0 + 1 , 109 @ @ 
 + / * 
 + * Licensed to the Apache Software Foundation ( ASF ) under one 
 + * or more contributor license agreements . See the NOTICE file 
 + * distributed with this work for additional information 
 + * regarding copyright ownership . The ASF licenses this file 
 + * to you under the Apache License , Version 2 . 0 ( the 
 + * " License " ) ; you may not use this file except in compliance 
 + * with the License . You may obtain a copy of the License at 
 + * 
 + * http : / / www . apache . org / licenses / LICENSE - 2 . 0 
 + * 
 + * Unless required by applicable law or agreed to in writing , 
 + * software distributed under the License is distributed on an 
 + * " AS IS " BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 + * KIND , either express or implied . See the License for the 
 + * specific language governing permissions and limitations 
 + * under the License . 
 + * / 
 + 
 + package org . apache . cassandra . locator ; 
 + 
 + import java . net . InetAddress ; 
 + import java . net . UnknownHostException ; 
 + import java . util . ArrayList ; 
 + 
 + import org . junit . Test ; 
 + 
 + import static org . junit . Assert . * ; 
 + import org . apache . cassandra . locator . DynamicEndpointSnitch ; 
 + import org . apache . cassandra . locator . SimpleSnitch ; 
 + import org . apache . cassandra . utils . FBUtilities ; 
 + 
 + public class DynamicEndpointSnitchTest 
 + { 
 + @ Test 
 + public void testSnitch ( ) throws UnknownHostException , InterruptedException 
 + { 
 + DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch ( new SimpleSnitch ( ) ) ; 
 + InetAddress self = FBUtilities . getLocalAddress ( ) ; 
 + ArrayList < InetAddress > order = new ArrayList < InetAddress > ( ) ; 
 + InetAddress host1 = InetAddress . getByName ( " 127 . 0 . 0 . 1 " ) ; 
 + InetAddress host2 = InetAddress . getByName ( " 127 . 0 . 0 . 2 " ) ; 
 + InetAddress host3 = InetAddress . getByName ( " 127 . 0 . 0 . 3 " ) ; 
 + 
 + / / first , make all hosts equal 
 + for ( int i = 0 ; i < 5 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host1 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host2 , 1 . 0 ) ; 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + 
 + Thread . sleep ( 1500 ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host1 a little worse 
 + dsnitch . receiveTiming ( host1 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host2 a little worse 
 + dsnitch . receiveTiming ( host2 , 2 . 0 ) ; 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host3 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + 
 + / / make host3 the worst 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 2 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host2 ) ; 
 + order . add ( host1 ) ; 
 + order . add ( host3 ) ; 
 + 
 + / / make host3 equal to the others 
 + for ( int i = 0 ; i < 2 ; i + + ) 
 + { 
 + dsnitch . receiveTiming ( host3 , 1 . 0 ) ; 
 + } 
 + Thread . sleep ( 1500 ) ; 
 + order . clear ( ) ; 
 + 
 + order . add ( host1 ) ; 
 + order . add ( host2 ) ; 
 + order . add ( host3 ) ; 
 + 
 + assert dsnitch . getSortedListByProximity ( self , order ) . equals ( order ) ; 
 + } 
 + }
